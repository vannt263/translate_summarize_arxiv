{
  "article_text": [
    "translating linear temporal logic ( ltl ) formulas to their equivalent automata ( usually bchi automata ) has been studied for nearly thirty years .",
    "this translation plays a key role in the automata - based model checking  @xcite : here the automaton of the negation of the ltl property is first constructed , then the verification process is reduced to the emptiness problem of the product .",
    "gerth et al .",
    "@xcite proposed an on - the - fly construction approach to generating bchi automata from ltl formulas , which means that the counterexample can be detected even only a part of the property automaton is generated .",
    "they called it a tableau construction approach , which became widely used and many subsequent works  @xcite for optimizing the automata under construction are based on it .",
    "however , as we shall see , in the tableau framework the formulas are translated into the generalized bchi automata ( gba ) in an intuitive way so early that deeper relationships between ltl and bchi automata are ignored .",
    "the muller automata is a generalization of bchi automata , and it preserves all the properties of bchi automata theoretically . for instance , the muller automata can also be used in model checking  @xcite . moreover , in automata theory , the muller automata have nicer properties than bchi automata .",
    "for instance , the determinization of muller automata can be as expressive as the non - deterministic ones , whereas it does not hold for the bchi automata .",
    "the deterministic bchi automata can not be closed under complement , while the muller automata can be .",
    "however there is not much research works on directly translating the ltl formulas to the muller automata , and one often obtains the muller automata from the existed automata  @xcite . as a result , translating the ltl formulas to equivalent muller automata ( non - deterministic )",
    "is also significant for model checking .",
    "although the deterministic muller automata can not be obtained directly , it is essential for further research of the applications of muller automata .    in this paper",
    ", we propose a novel construction by making use of the notion of _ disjuctive - normal forms _ ( dnf ) .",
    "for an ltl formula @xmath3 , its dnf normal form is an equivalent formula of the form @xmath4 where @xmath5 is a finite conjunction of literals ( atomic propositions or their negations ) , and @xmath6 is a conjunctive ltl formula such that the root operator of it is not a disjunction .",
    "we show that any ltl formula can be transformed into an equivalent dnf normal form , and refer to @xmath7 as a clause of @xmath3 .",
    "it is easy to see that any given ltl formula induces a labelled transition system ( lts ) : states correspond to formulas , and we assign a transition from @xmath3 to @xmath6 labelled with @xmath5 , if @xmath7 appears as a part of the dnf form of @xmath3 .",
    "figure  [ ltl_ts_and_ba ] demonstrates our idea in which the transition labels are omitted .",
    "transition system as shown in the figure , we can first get the transition system ( ts ) from the formula @xmath8 , in which each node corresponds to a formula .",
    "then we can extend the ts by doing the instantiation for formulas in each node to acquire the final bchi automaton ( ba ) .",
    "the details will be talked about in section  [ construction ] .     +    . ]",
    "the lts is the starting point of our construction .",
    "surprisingly , for until - free ( or release - free ) formulas , the bchi automaton can be obtained directly by equipping the above lts with the set of accepting states , which is illustrated as follows .",
    "consider the formula @xmath9 , whose dnf form is @xmath10 .",
    "the corresponding bchi automaton for @xmath9 is shown in figure  [ fig : buchiforaub ] where nodes @xmath9 and @xmath11 represent formulas @xmath9 and @xmath12 respectively .",
    "the transitions are self - explained . by semantics , we know that if the run @xmath13 satisfies a release - free formula @xmath3 , then there must be a finite satisfying prefix @xmath14 of @xmath13 such that any paths starting with @xmath14 satisfy @xmath3 as well .",
    "thus , for this class of formulas , the state corresponding to the formula @xmath11 is considered as the single accepting state .",
    "the until - free formulas can be treated in a similar way by taking the set of all states as accepting .",
    "the main contribution of the paper is to extend the above construction to general formulas . as an example we consider the formula @xmath15 , which has the normal form @xmath16 .",
    "note here the formula @xmath11 will be even not reachable . the most challenging part of the construction will then be identification of the set of accepting states . for this purpose",
    ", we identify subformulas that will be reached infinitely often , which we call looping formulas .",
    "only some of the looping formulas contribute to the set of accepting states .",
    "these formulas will be the key to our construction : we characterize a set of atomic propositions for each formula , referred to as the _ obligation set_. the set contains properties that must occur infinitely often to make the given formula satisfiable . in our construction , we add an additional component to the states to keep track of the obligations , and then define accepting states based on it  an illustrating example can be found in section [ example ] .",
    "our construction for general formula has at most @xmath0 states with @xmath1 denoting the number of subformulas .",
    "the number of states for the release / until cases is bounded @xmath2 .",
    "recall the complexity of @xmath17 @xcite of the classical tableau construction . to the best of our knowledge",
    ", this is the first time that one can give a precise bound on the exponent for such construction .",
    "summarizing , the contributions of the paper are as follows :    1 .",
    "we propose a _ disjunctive - normal form _",
    "( dnf ) for the ltl formula , based on which we investigate the relationship between dnf normal forms and bchi automata . as a result we present a novel construction for translating ltl formulas to bchi automaton . especially for release",
    "/ until - free formulas , our construction is very simple in theory .",
    "we discuss some interesting properties of ltl formulas , which demonstrate another view on the satisfiability of ltl formulas . using these properties",
    ", we can find the translation from ltl to bchi automaton is far more intuitive .",
    "3 .   as far as we know , compared to the complexity of @xmath17 @xcite for the tableau construction , our approach gives the more precise one of @xmath0 , and even more a better one of @xmath2 when the formula is restricted into release - free ( until - free ) .",
    "etessami and holzmann  @xcite have pointed out the goal of keeping the size of generated automata from ltl formulas small may not result in reducing the cost of model checking .",
    "thus sebastiani et al .",
    "@xcite suggested to make the generated automata `` as deterministic as possible '' and it is well accepted as a heuristic strategy by the researchers since then .",
    "however , it should be noted that keeping the generated automata small is still significant and it is still one of the key goals for the generated automata together with their determinism .",
    "thus , the new construction proposed here also adopts this criteria that makes the number of the states and transitions of the generated automata as small as possible .",
    "the experiments in this paper also consider the `` determinism '' criteria and use the approach in @xcite to make the generated automata as deterministic as possible , which makes the experimental comparisons are more meaningful .      as we know , there are two main approaches to bchi automata construction from ltl formulas .",
    "the first approach generates the alternating automaton from the ltl formula and then translates it to the equivalent bchi automaton  @xcite .",
    "gastin et al .",
    "@xcite proposed a variant of this construction in 2001 , which first translates the very weak alternating co - bchi automaton to generalised automaton with accepting transitions which is then translated into bchi automaton . in particular , the experiments show that their algorithm outperforms the others if the formulas under construction are restricted on fairness conditions .",
    "recently babiak et al .",
    "@xcite proposed some optimization strategies based on the work  @xcite .",
    "they make the observation on the formula where each branch of its syntax tree containing at least one eventually and always operators . compared to ltl2ba",
    ", their implementation tool , ltl3ba , performs more fast and deterministic .",
    "the second approach was proposed in 1995 by gerth et al .",
    "@xcite , which is called the _ tableau _ construction .",
    "this approach can generate the automata from ltl on - the - fly , which is widely used in the verification tools for acceleration of the automata - based verification process .",
    "introducing the ( state - based ) _ generalized bchi automata _ ( gba ) is the important feature for the tableau construction .",
    "daniele et al .",
    "@xcite improved the tableau construction by some simple syntactic techniques .",
    "giannakopoulou and lerda  @xcite proposed another construction approach that uses the transition - based generalized bchi automaton ( tgba ) . and some optimization techniques  @xcite have been proposed to reduce the size of the generated automata .",
    "for instance , etessami and holzmann  @xcite described the optimization techniques including proof theoretic reductions ( formulas rewritten ) , core algorithm tightening and the automata theoretic reductions ( simulation based ) .",
    "the experiments in the literature also pointed out the smaller generated automaton does not always result in the better performance of the model checking . based on this observation , sebastiani et al .",
    "@xcite focused on the determinism of the generated automaton and pointed that the generated automaton from the ltl formula should be `` as deterministic as possible '' , and this insight was accepted by other researchers , i.e. the tool spot  @xcite integrated this heuristics into its recent implementation .",
    "for muller automata our paper proposes a unified framework , thus without first generating the corresponding bchi automata , as done in @xcite .",
    "although jong @xcite proposed a translation directly from the ltl formulas to muller automata based on the classic automata construction , the translation involves automaton complementation and intersection which makes the complexity of the approach higher .",
    "section [ example ] illustrates our approach by a running example .",
    "section [ sec : pre ] introduces preliminaries of bchi automata and ltl formulas and then introduces the _ disjunctive - normal form _ for ltl formulas ; section  [ construction ] specifies the proposed _ dnf - based _ construction ; section  [ discussion ] discusses how our approach is related to the tableau construction in  @xcite .",
    "section  [ conclusion ] concludes the paper .",
    "[ example ] we consider the formula @xmath18 as our running example .",
    "the dnf form of @xmath8 is given by : @xmath19 where @xmath20 , @xmath21 , @xmath22 .",
    "it is easy to check that the above dnf form is indeed equivalent to formula @xmath8 .",
    "interestingly , we note that @xmath23 all have the same dnf form above .     the bchi automaton for the formula @xmath8.,title=\"fig : \" ] +    the corresponding bchi automaton for @xmath8 is depicted in fig .",
    "[ fig : buechi ] .",
    "we can see that there are four states in the generated automata , corresponding to the four formulas @xmath24 .",
    "the state corresponding to the formula @xmath8 is also the initial state .",
    "the transition relation is obtained by observing the dnf forms : for instance we have a self - loop for state @xmath25 with label @xmath26 .",
    "if we observe the normal form of @xmath8 , we can see that there is a term ( @xmath27 ) , where there is a conjunction of two terms @xmath26 and @xmath28 , and @xmath8 in @xmath29 operator corresponds to the node @xmath25 and @xmath26 corresponds the loop edge for @xmath25 .",
    "if we look at the edge @xmath30 between @xmath25 and @xmath31 in the generated automaton , we still can find a corresponding relation between the normal form of @xmath8 and the automaton , e.g. , the second term in the normal form of @xmath8 gives the hint .",
    "thus , the _ disjunctive - normal form _ of the formula has a very close relation with the generated automaton .",
    "the most difficult part is to determine the set of accepting states of the automaton .",
    "we give thus here a brief description of several notions introduced for this purpose in our running example .",
    "the four of all the formulas @xmath32 have the same _ obligation set _ , i.e. @xmath33 , which may vary for different formulas . in our construction , every _",
    "obligation _ in the _ obligation set _ of each formula identities the properties needed to be satisfied infinitely if the formula is satisfiable . for example",
    ", the formulas @xmath34 are satisfied if and only if all properties in the obligation @xmath35 are met infinitely according to our framework",
    ". then , a state consists of a formula and the _ process set _ , which records all the properties that have been met so far . for simplicity , we initialize the _ process set _ @xmath36 of the initial state @xmath25 with the empty set . for the state @xmath31 ,",
    "the corresponding process set @xmath37 is obtained by taking the union of @xmath36 and the label @xmath38 from @xmath25 .",
    "the label @xmath39 will be omitted as it is not contained in the obligation",
    ". similarly one can conclude @xmath40 and @xmath41 : here the property @xmath42 implies no property has been met so far .",
    "when there is more than one property in the _ process set _ , the @xmath43 can be erased , such as that in state @xmath44 .",
    "moreover , the _ process set _ in a state will be reset to empty if it includes one _ obligation _ in the formula s _ obligation set_. for instance , the transition in the figure @xmath45{c\\wedge d}}s_1 $ ] is due to that @xmath46 , which is actually in @xmath47 .",
    "so @xmath48 is reset to the empty set .",
    "one can also see the same rule when the transitions @xmath45{c\\wedge e}}s_1 $ ] , @xmath49{c\\wedge e}}s_1 $ ] , @xmath50{b\\wedge    e}}s_1 $ ] occur .    through the paper",
    ", we will go back to this example again when we explain our construction approach .",
    ".the formulas expanded from @xmath51 and their normal forms [ cols= \" < \" , ]     the next five formulas in the table are selected for the reason that they are often used in property description . again , _ aalta _ is better than ltl2ba or ltl2buchi without optimizations .",
    "compared with the optimized versions of the two tools , our tool generates the automata of the same size for three formulas , and is worse for the other two formulas . for the formula @xmath52 , the size of the generated automaton from ltl2ba or ltl2buchi with optimizations",
    "can be reduced to be linear with the length of the formula . however , the size of automaton generated by _ aalta _ for this formula is exponential to the length of the formula , which is the same case with ltl2ba and ltl2buchi when they do not optimize the results .",
    "once the result automata from _ aalta _ are optimized by the same techniques as those in ltl2buchi ( + sbf ) , we can see almost the same results for the formulas in the table between the two tools , i.e. shown in the fifth and last column .",
    "moreover for the last formula shown in the table , we can also find the result ( 5s , 14 t ) from _ aalta _",
    "( + sbf ) can outperform the one ( 6s , 19 t ) from ltl2buchi ( + sbf ) .",
    "now in table  [ result2 ] and table  [ result3 ] we present the experimental results on the constructions for the benchmarks , compared with ltl2buchi . to make the comparison more reasonable , we transform the generated automata from two tools to more deterministic versions  as described in  @xcite by enumerating all the combination of transitions for the automata .",
    "this is mainly motivated by the fact that non - deterministic automata with the same transitions and states do not mean that they have the same performance for the model checking  @xcite  @xcite . in the two tables the field @xmath53 lists the percentage of the automata number from _ aalta _ in the total one whose both states and transitions are smaller than those from ltl2buchi .",
    "the other fields denote the similar percentages .",
    "note that the automata from _ aalta _ and ltl2buchi may not always meet the situations in column 2 , 3 and 4 in table  [ result2 ] and  [ result3 ] , so the total percentage of the three columns can not be 100@xmath54 .",
    "first we scratch all the 2221 formulas without @xmath55 subformulas in benchmarks with a total number of 4046 to confirm the conjecture of `` the _ dnf - based _ construction can generates the bchi automata as small as possible when the formulas do not contain any @xmath55-operators '' . as table  [ result2 ] shows , when considering the formulas without any @xmath55 operators and both _ aalta _ and ltl2buchi do not use optimizations ( column 2 , 3 , 4 ) , we have 27.0@xmath54 of the generated automata from _ aalta _ are smaller than those from ltl2buchi and 57.0@xmath54 of the ones from _ aalta _ are equal to those from ltl2buchi , i.e. totally about 84@xmath54 of the automata from _ aalta _ are as small as those from ltl2buchi .",
    "meanwhile , there is just about 4.0@xmath54 of the results from _ aalta _ are bigger than those from ltl2buchi , which would not affect the truth of the _ dnf - based _ construction can outperform the original tableau construction any more . when comparing to the optimizing results from ltl2buchi ( + sbf ) , we have 5.1@xmath54 of the generated automata from _ aalta _ are smaller than those from ltl2buchi",
    "( + sbf ) and 71.0@xmath54 of the ones are equal to those from ltl2buchi ( + sbf ) , i.e. totally 76.1@xmath54 of automata from _ aalta _ are as small as those from ltl2buchi ( + sbf ) , which is still a huge advantage .    finally we present the comparison results for all the 4046 formulas between _ aalta _ and ltl2buchi .",
    "the process time of 4046 formulas in the computer for the experiments is about 3 minutes . for the 2023 formulas in the first row in table  [ result3 ]",
    ", we have 37.4@xmath54 of the bchi automata generated by _ aalta _ are smaller than those generated by ltl2buchi ( the second column ) , while 46.2@xmath54 of the generated automata from the two tools have the same size ( the third column ) .",
    "compared to ltl2buchi ( + sbf ) , 73.7@xmath54 of the bchi automata generated by _ aalta _ ( + sbf ) have the same size .",
    "surprisedly , observe that 10.2@xmath54 of the generated automata by _",
    "aalta _ ( + sbf ) are better .",
    "the second formulas set is generated by negating the formulas in the first set ( second row ) and the statistics are similar . from this table",
    "we can see our approach also has a better performance than the tableau construction when both of them use the same optimizations .",
    "let @xmath3 be a formula @xmath56 such that the root operator of @xmath57 is not a disjunctive : then we define the disjunctive formula set as @xmath58 .",
    "when @xmath59 does not include a disjunctive as a root operator , @xmath60 only include @xmath59 itself .",
    "we first can directly use the rules in lemma  [ lemma : expansion ] to generate an intermediate normal form for @xmath3 , whose format is @xmath61 where @xmath5 is an propositional formula and @xmath57 is an ltl formula without any constraint in definition  [ def : dnf ] .",
    "we denote the set of this intermediate normal form of the formula @xmath3 as @xmath62 ;    second we prove any intermediate normal form can be changed to the + _ disjunctive - normal form_. intuitively , one can easily find for each @xmath5 and @xmath57 the corresponding @xmath63 and @xmath64 can be obtained trivially .",
    "then we can get the final _ disjunctive - normal form _ through the following two steps :              * basic step : if @xmath59 is the case of the literal @xmath72 , then since @xmath73 , so obviously @xmath74 . *",
    "inductive step : if the formulas @xmath57 ( @xmath75 ) satisfy @xmath76 , then : 1 .",
    "if @xmath77 , we know @xmath78 .",
    "according to lemma  [ lemma : expansion].5 we have @xmath79 , then by induction hypothesis we have @xmath80 , so @xmath81 ; 2 .   if @xmath82 , we know @xmath83 .",
    "according to lemma  [ lemma : expansion].2 we have @xmath84 , so @xmath85 ; 3 .   if @xmath86 , we know @xmath87 .",
    "according to lemma  [ lemma : expansion].6 we know @xmath88 . then by induction hypothesis",
    "we have @xmath89 and @xmath90 , so @xmath91 ; 4 .   if @xmath92 , we know @xmath93 . according to lemma  [ lemma : expansion].3 if @xmath94 then @xmath95 directly by induction hypothesis , else if @xmath96 then by induction hypothesis we have @xmath97 ; 5 .",
    "if @xmath98 one can also prove in the similar way that @xmath99 .",
    "* base step : if @xmath70 then according to lemma  [ lemma : dnf : finite ] we know @xmath71 . *",
    "induction step : if @xmath102 where @xmath103 and @xmath71 hold , then according to lemma  [ lemma : dnf : finite ] we know for all @xmath104 we have @xmath105 .",
    "then according to lemma  [ lemma : expansion].6 we know @xmath106 holds .",
    "that is , if @xmath101 can be reached from @xmath3 in @xmath107 steps and @xmath81 holds , then any @xmath108 can be reached from @xmath3 in @xmath109 steps also has @xmath110 .    now come to prove theorem  [ thm : expand : bounded ] . from lemma  [ lemma :",
    "expand : finite ] we know for all @xmath111 if @xmath112 then we have @xmath113 .",
    "so the elements number in @xmath114 can not exceed the number of @xmath68 , i.e. @xmath115 . thus @xmath116 .        *",
    "basic step : if @xmath117 , then @xmath118 , and @xmath119 obviously true .",
    "* inductive step : if for the formulas @xmath120 ( @xmath121 ) , @xmath122 holds .",
    "then we have : 1 .   if @xmath123 , then @xmath124 . since for each @xmath125 in @xmath126 , the predicate @xmath127 according to its definition , and since @xmath124 so @xmath128 . then by induction hypothesis",
    "we know @xmath129 holds thus @xmath130 holds .",
    "if @xmath131 , then @xmath132 , so we know @xmath133 . then since @xmath134 , and by induction hypothesis @xmath135 holds when @xmath128 while @xmath136 holds when @xmath137 . due to @xmath138",
    "so @xmath139 is true .",
    "3 .   if @xmath140 , then @xmath141 . then @xmath142 . by induction hypothesis that @xmath143 and @xmath144 are true , thus @xmath145 holds .",
    "if @xmath146 , then @xmath147 . since for each @xmath125 in @xmath126 @xmath148 , and by induction hypothesis @xmath136 holds , so @xmath130 also holds .",
    "similarly one can prove the situation when @xmath149 and we omit it here .",
    "* basic step : if @xmath117 , then @xmath118 , and @xmath150 .",
    "so obviously @xmath151 .",
    "* inductive step : if for the formulas @xmath120 ( @xmath121 ) , @xmath152 holds .",
    "then we have : 1 .   if @xmath123 , then we know @xmath124 and @xmath153 . since by induction hypothesis @xmath154 , and @xmath155 , so @xmath156 .",
    "thus @xmath157 holds .",
    "2 .   if @xmath131 , then we have @xmath132 and @xmath158 . by induction hypothesis @xmath154 and @xmath159 , so @xmath160 , in which @xmath161 is exactly @xmath126 .",
    "thus @xmath157 holds .",
    "3 .   if @xmath140 , then @xmath141 . since @xmath162 , and by induction hypothesis we have @xmath163 , where @xmath164 , so @xmath165 .",
    "obviously @xmath166 , so @xmath157 holds .",
    "if @xmath146 , then we know @xmath147 and @xmath167 . by induction hypothesis @xmath168 , and since @xmath169 so @xmath125 is also in @xmath126 . thus @xmath157 holds .",
    "similarly one can prove the case when @xmath149 and we omit it here .",
    "for each @xmath173 in @xmath174 let @xmath175 , then we know easily @xmath176 . if @xmath177 , then we know @xmath178 and @xmath179 .",
    "since @xmath180 is also in @xmath174 , then according to the assumption @xmath181 and @xmath182 .",
    "moreover according to lemma  [ lemma : subformula : equiv ] @xmath183 also holds .",
    "however for @xmath184 it is also in @xmath174 and has at least one subformula @xmath185 in @xmath174 and @xmath186 ... infinitely using this will cause @xmath174 be an infinite set - that is obviously impossible .",
    "so this lemma is true .      according to lemma [ lemma : formulacycle : exist ] we know @xmath188 .",
    "then we know for such @xmath173 it will meet and only meet @xmath189{\\eta}}\\mathsf{true}\\vee\\mu{\\xrightarrow[]{\\eta}}\\mu$ ] when each @xmath190{\\eta}}\\phi$ ] holds .",
    "[ lemma : cycle : partialorder ] if @xmath191 , then there exists @xmath192 such that @xmath193{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mathsf{true}\\vee\\mu{\\xrightarrow[]{\\eta}}\\mu$ ] , and for @xmath194 we have @xmath195{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mu'$ ] and @xmath196 .    from lemma  [ lemma : formulacycle : forall ] we know @xmath197 .",
    "then let @xmath198{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mu'\\wedge cf(\\mu')\\subseteq s_0\\cup\\{\\mu\\}\\}$ ] .",
    "@xmath199 holds for the same reason with @xmath200 that @xmath201 , and such @xmath173s can be added into @xmath202 .",
    "inductively we can find the set @xmath203{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta_i}}\\mu'\\wedge cf(\\mu')\\subseteq s_{n-1}\\cup\\{\\mu\\}\\}$ ] ( @xmath204 ) .",
    "since @xmath205 and @xmath206 is limited and @xmath207 , so we can finally find @xmath208 .",
    "a demonstration of this lemma is shown in figure  [ fig : loopingformula ] .",
    "in this case , @xmath209 and @xmath190{\\eta}}\\phi$ ] holds .",
    "then according to lemma  [ lemma : cycle : partialorder ] there exists @xmath210 so that @xmath211{\\eta}}\\true\\vee\\phi_0{\\xrightarrow[]{\\eta}}\\phi_0 $ ] holds .",
    "moreover , for @xmath212 we have @xmath190{\\eta}}\\phi'$ ] and @xmath213 .",
    "note that including @xmath214 there can be more than one formulas added into @xmath215 at the same time : see @xmath8 and @xmath216 in @xmath217 .",
    "this property for the looping formula plays a key role in the proofs in the following .        *",
    "basic step : if @xmath117 , then we know @xmath218 .",
    "so @xmath190{\\alpha}}\\psi\\rightarrow p\\in cf(\\alpha)\\wedge cf(\\alpha)\\models_f\\mathsf{true}$ ] .",
    "thus @xmath219 is true . *",
    "inductive step : assume @xmath220 meet @xmath221{\\alpha_i}}\\psi_i\\wedge s_i\\models_f\\psi_i\\rightarrow s_i\\cup cf(\\alpha_i)\\models_f \\phi_i$ ] , then we have : 1 .   if @xmath82 , then we know @xmath222 .",
    "if @xmath223 holds , then since @xmath224 , so @xmath225 holds .",
    "2 .   if @xmath226 , then we know @xmath227 , that is , @xmath228 . if @xmath229 holds then by induction hypothesis we have @xmath230{\\alpha}}\\psi\\wedge s\\models_f \\psi\\rightarrow s\\cup cf(\\alpha)\\models_f \\phi_1(\\phi_2)$ ] , which indeed implies @xmath231 according to the definition of @xmath232 ( definition  [ def : finitestepsat ] ) .",
    "so @xmath190{\\alpha}}\\psi\\wedge s\\models_f \\psi\\rightarrow s\\cup cf(\\alpha)\\models_f \\phi$ ] .",
    "if @xmath233 , then we know @xmath234 there exists @xmath5 and @xmath235 so that @xmath236 and @xmath237 as well as @xmath238 and @xmath239 . if @xmath229 holds , then @xmath240 hold . by induction hypothesis",
    "we have @xmath221{\\alpha_i}}\\psi_i\\wedge s\\models_f \\psi_i\\rightarrow s\\cup cf(\\alpha_i)\\models_f \\phi_i ( i=1,2)$ ] , so @xmath241 holds .",
    "thus @xmath231 holds .",
    "if @xmath242 , then we know for each @xmath243 , it is either in @xmath244 or @xmath245 and @xmath246 .",
    "if @xmath247 holds then @xmath225 obviously holds when @xmath248 .",
    "thus @xmath231 holds . and",
    "if @xmath249 by induction hypothesis we have @xmath250 directly .",
    "5 .   if @xmath251 , then we know for each @xmath243 , it is either in @xmath252 or @xmath253 and @xmath254 .",
    "if @xmath247 holds then we have proven @xmath225 holds when @xmath255 . and",
    "if @xmath256 then @xmath247 obviously makes @xmath231 hold .",
    "[ lemma : finitesat : expandsat2 ] let @xmath257{\\alpha_0}}\\phi_1{\\xrightarrow[]{\\alpha_1}}\\phi_2{\\xrightarrow[]{\\alpha_2}}\\ldots{\\xrightarrow[]{\\alpha_n}}\\phi_{n+1}=\\psi$ ] and @xmath258 . if @xmath247 then @xmath259 holds .",
    "according to lemma  [ lemma : finitesat : expandsat ] we know @xmath260{\\alpha_n}}\\phi_{n+1}=\\psi\\wedge s\\models_f\\psi\\rightarrow s\\cup cf(\\alpha_n)\\models_f \\phi_n$ ] holds .",
    "inductively using lemma  [ lemma : finitesat : expandsat ] we can finally prove this lemma is true .",
    "[ lemma : until : finitesat ] if @xmath190{\\eta}}\\phi$ ] , then @xmath261{\\eta}}\\mu'\\wedge\\mu\\not\\in cf(\\mu')\\leftrightarrow\\eta\\models_f\\phi$ ] : here @xmath262 and each @xmath173 in @xmath263 is the until formula .",
    "let @xmath190{\\eta}}\\phi= ( \\phi_0=\\phi{\\xrightarrow[]{\\omega_0}}\\phi_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k}}}\\phi_{k+1}=\\phi ( k\\geq 0))$ ] and the set @xmath264 , where @xmath265 holds .    ( @xmath266 ) . from lemma  [ lemma : cycle",
    ": partialorder ] we know there exists @xmath192such that @xmath193{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mathsf{true}\\vee\\mu{\\xrightarrow[]{\\eta}}\\mu$ ] , and for @xmath194 we have @xmath195{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mu'$ ] and @xmath196 . for each @xmath173 in @xmath200 ,",
    "if @xmath189{\\eta}}\\mathsf{true}$ ] then according to lemma  [ lemma : finitesat : expandsat2 ] we have @xmath267 holds ; and if @xmath189{\\eta}}\\mu$ ] since @xmath173 is not an until formula , so @xmath173 is a release formula . for the release formula @xmath268 we know every time @xmath189{\\eta}}\\mu$ ] implies @xmath269{\\eta}}\\mathsf{true}$ ] . thus according to lemma  [ lemma : finitesat : expandsat2 ] we have @xmath270 holds and then @xmath271 holds according to its definition .",
    "so we prove now @xmath272 .",
    "inductively , for @xmath273 , if @xmath274 and @xmath189{\\eta}}\\mu'$ ] where @xmath275 , and since we have proven @xmath276 then according to lemma  [ lemma : finitesat : expandsat2 ] we know @xmath267 holds .",
    "else if @xmath189{\\eta}}\\mu'\\wedge\\mu\\in cf(\\mu')$ ] , then according to the assumption we know @xmath173 must be the release formula , so for @xmath268 we have @xmath269{\\eta}}\\nu'$ ] where @xmath277 .",
    "since we have proven @xmath278 then according to lemma  [ lemma : finitesat : expandsat2 ] we have @xmath279 hold also . then according to the definition of @xmath232 we know @xmath271 holds .",
    "thus we can prove @xmath280 , that is , @xmath281 holds .",
    "moreover since @xmath190{\\eta}}\\phi$ ] is true thus according to the definition of @xmath232 ( definition  [ def : finitestepsat ] ) we know @xmath282 holds .",
    "let @xmath289 .",
    "since @xmath190{\\xi}}\\phi$ ] , so we have @xmath290{\\xi^n}}\\phi\\wedge\\phi{\\xrightarrow[]{\\xi_n}}\\phi$ ] .",
    "let @xmath291 and @xmath292 .",
    "thus we can easily know @xmath293{\\eta_i}}\\mathsf{true}$ ] , which makes @xmath294 .",
    "inductively for @xmath190{\\xi_n}}\\phi$ ] we can get the same conclusion .",
    "so @xmath295 we have @xmath296 , which makes @xmath297 according to the ltl semantics .      from lemma  [ lemma : cycle",
    ": partialorder ] we know there exists @xmath192such that @xmath193{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mathsf{true}\\vee\\mu{\\xrightarrow[]{\\eta}}\\mu$ ] , and for @xmath194 we have @xmath195{\\eta}}\\phi\\cdot\\mu{\\xrightarrow[]{\\eta}}\\mu'$ ] and @xmath196",
    ".    basically for each @xmath173 in @xmath200 , if @xmath298{\\eta_i}}\\mathsf{true}$ ] holds , then since @xmath299{\\eta_j}}\\mu$ ] so we have @xmath300 ; and if @xmath301{\\eta_i}}\\mu$ ] , since @xmath302 , and according to lemma  [ lemma : until : finitesat ] we know @xmath173 can not be an until formula .",
    "then according to corollary  [ coro : expand : cycle ] we can know @xmath173 is a release formula . also we have @xmath189{\\eta_i}}\\mu$ ] , and according to lemma  [ lemma : release : sat ] we know @xmath301{\\eta_i}}\\mu$ ] plus @xmath173 is a release formula implies @xmath303 .",
    "so first we can prove @xmath304 .",
    "inductively for the set @xmath305 , if @xmath306{\\eta_i}}\\mu'\\wedge cf(\\mu')\\subseteq s_{n}$ ] , then from the basic step we know @xmath307 so @xmath308",
    ". moreover , we also have @xmath309 .",
    "if @xmath301{\\eta_i}}\\mu'\\wedge\\mu\\in cf(\\mu')$ ] , similarly according to lemma  [ lemma : until : finitesat ] and corollary  [ coro : expand : cycle ] we know @xmath173 must be a release formula .",
    "let @xmath268 and we know @xmath310{\\eta_i}}\\nu'\\wedge cf(\\nu')\\subseteq s_n$ ] .",
    "we have proven @xmath311 , so we have @xmath312 . then according to the ltl semantics we have @xmath313 .",
    "so we can prove now @xmath314 .",
    "* basic step : if @xmath320 , then @xmath321 . so according to definition [ def : finitestepsat ] we know @xmath322 is true",
    "* inductive step : assume for the formulas @xmath6 ( @xmath323 ) we have @xmath324 hold .",
    "then 1 .   if @xmath325 , then @xmath326 . by induction hypothesis",
    "we know @xmath327 holds , so @xmath328 also holds .",
    "2 .   if @xmath329 , then @xmath330 .",
    "by induction hypothesis we know @xmath331 and @xmath332 hold , so we can conclude @xmath333 holds .",
    "3 .   if @xmath334 , then @xmath335 . by induction hypothesis we know @xmath331 or @xmath332 hold , so we can conclude @xmath336 holds .",
    "4 .   if @xmath337 , then @xmath338 . by induction hypothesis",
    "we have @xmath339 hold , so from definition [ def : finitestepsat ] we have @xmath340 hold .",
    "5 .   if @xmath341 , then @xmath342 . so @xmath343 holds . then by induction hypothesis we know @xmath344 and according to definition [ def : finitestepsat ] we know @xmath345 also holds .",
    "[ lemma : complete : recursive ] @xmath190{\\xi}}\\phi\\wedge\\xi\\vdash\\phi\\rightarrow\\exists n\\cdot\\phi{\\xrightarrow[]{\\xi^n}}\\phi\\wedge \\xi^n\\models_f\\phi\\wedge ( \\phi{\\xrightarrow[]{\\xi_n}}\\phi\\wedge\\xi_n\\vdash\\phi)$ ] .",
    "we first prove @xmath190{\\xi}}\\phi\\wedge\\xi\\vdash\\phi\\rightarrow\\exists n\\cdot\\phi{\\xrightarrow[]{\\xi^n}}\\phi\\wedge \\xi^n\\models_f\\phi$ ] .",
    "if @xmath346{\\xi^n}}\\phi\\wedge \\neg ( \\xi^n\\models_f\\phi)$ ] , we can conclude @xmath347 , thus causing the contradiction with lemma  [ lemma : complete : finiteexist ] . moreover , since @xmath190{\\xi}}\\phi\\wedge\\phi{\\xrightarrow[]{\\xi^n}}\\phi\\wedge\\xi\\vdash\\phi$ ] , so @xmath190{\\xi_n}}\\phi\\wedge\\xi_n\\vdash\\phi$ ] is also true .",
    "so this lemma is true .",
    "[ lemma : automata : runable ] let @xmath348 and @xmath349 the bchi automaton for @xmath67 generated by _ dnf - based _ construction",
    ". then @xmath350{\\omega_0}}\\psi_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{n-1}}}\\psi_n$ ] holds , where @xmath351 , if and only if there is a corresponding path @xmath352{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{n-1}}}s_n$ ] in @xmath349 where each @xmath353 is the @xmath120-state .      1 ) .",
    "when @xmath354 , if @xmath355 , then according to our construction directly we know for @xmath350{\\omega_0}}\\psi_1 $ ] , if and only if there is a @xmath352{\\omega_0}}s_1 $ ] where @xmath353 is the @xmath120-state and @xmath356{\\omega_0}}\\psi_1 $ ] .    2 ) .",
    "when @xmath357 we assume @xmath350{\\omega_0}}\\psi_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k-1}}}\\psi_k$ ] if and only if there is a corresponding path @xmath352{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k-1}}}s_k$ ] where for @xmath358 each @xmath353 is the @xmath120-state in @xmath349",
    ". then for @xmath350{\\omega_0}}\\psi_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k-1}}}\\psi_k{\\xrightarrow[]{\\omega_{k}}}\\psi_{k+1}$ ] holds , we know if and only if @xmath359 holds from definition  [ def : expand ] .",
    "according to the construction we know @xmath360 if and only if there is a @xmath361{\\omega_k}}s_{k+1}$ ] where @xmath362 is @xmath363-state .",
    "so it is true that @xmath350{\\omega_0}}\\psi_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k-1}}}\\psi_k{\\xrightarrow[]{\\omega_{k}}}\\psi_{k+1}$ ] if and only if there is a @xmath352{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{k-1}}}s_k{\\xrightarrow[]{\\omega_k}}s_{k+1}$ ] in @xmath349 .",
    "the proof is done .",
    "( @xmath283 ) let @xmath348 be an accepting run of @xmath364 , and we want to prove that @xmath365 .",
    "let @xmath366{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots$ ] be the corresponding path accepting @xmath13 .",
    "thus , @xmath367 contains at least one accepting state @xmath368 .",
    "assume @xmath369 .",
    "since there exists a finite path @xmath352{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}s_2\\ldots{\\xrightarrow[]{\\omega_n}}s_{n+1}=s$ ] , where each @xmath353 is the @xmath6-state . according to lemma  [ lemma : automata : runable ] we know @xmath370{\\omega_0}}\\phi_1{\\xrightarrow[]{\\omega_1}}\\phi_2\\ldots{\\xrightarrow[]{\\omega_n}}\\phi_{n+1}=\\phi$ ] holds",
    "then we know @xmath371 so that for each @xmath372 we have @xmath373{\\omega_{i_0}}}s_{i_1}{\\xrightarrow[]{\\omega_{i_1}}}\\ldots{\\xrightarrow[]{\\omega_{i_n}}}s_{i_{n+1}}=s$ ] , of which for simplicity we denote as @xmath374{\\eta_i}}s$ ] .",
    "according to lemma  [ lemma : automata : runable ] we know each time @xmath374{\\eta_i}}s$ ] holds @xmath190{\\eta_i}}\\phi$ ] also holds ( @xmath375 is the @xmath3-state ) . moreover , according to our construction and lemma  [ lemma : obligaionandsatonce ] we know @xmath376 holds . finally according to theorem  [ thm : central ]",
    "we can conclude @xmath377 .",
    "( @xmath266 ) let @xmath348 and @xmath377 , we now prove there is an accepting run @xmath378{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots$ ] in @xmath349 . from theorem  [ thm : central ] we know @xmath379{\\xi^n}}\\phi\\wedge(\\exists\\xi_n=\\eta_1\\eta_2\\ldots\\cdot\\forall i\\geq 1\\cdot\\phi{\\xrightarrow[]{\\eta_i}}\\phi\\wedge \\eta_i\\models_f\\phi)$ ] . according to lemma  [ lemma : automata : runable ] we can find an infinite path @xmath380{\\omega_0}}s_1{\\xrightarrow[]{\\omega_1}}\\ldots{\\xrightarrow[]{\\omega_{n-1}}}s{\\xrightarrow[]{\\omega_n}}\\ldots$ ] in @xmath349 on which @xmath13 can run . here",
    "@xmath381 is the @xmath67-state and @xmath375 is the @xmath3-state , and for each @xmath372 we have @xmath373{\\omega_{i_0}}}s_{i_1}{\\xrightarrow[]{\\omega_{i_1}}}s_{i_2}\\ldots{\\xrightarrow[]{\\omega_{i_n}}}s_{i_{n+1}}=s$ ] , of which for simplicity we denote as @xmath374{\\eta_i}}s$ ] .",
    "let @xmath382 be the @xmath383-state , and the set @xmath384 where each @xmath385 satisfies @xmath386 .",
    "since @xmath387 holds so according to lemma  [ lemma : obligaionandsatonce ] we know @xmath388 .",
    "moreover , our construction guarantees for each @xmath374{\\eta_i}}s$ ] there is @xmath389 so that @xmath390 .",
    "since such states with the format of @xmath391 is finite , so there must be such a state in @xmath367 . finally we prove the theorem is true ."
  ],
  "abstract_text": [
    "<S> in this paper , we consider the problem of translating ltl formulas to bchi automata . </S>",
    "<S> we first translate the given ltl formula into a special _ disjuctive - normal form _ ( dnf ) </S>",
    "<S> . the formula will be part of the state , and its dnf normal form specifies the atomic properties that should hold immediately ( labels of the transitions ) and the _ formula _ that should hold afterwards ( the corresponding successor state ) . </S>",
    "<S> surprisingly , if the given formula is until - free or release - free , the bchi automaton can be obtained directly in this manner . for a general formula , </S>",
    "<S> the construction is slightly involved : an additional component will be needed for each formula that helps us to identify the set of accepting states . </S>",
    "<S> notably , our construction is an on - the - fly construction , and the resulting bchi automaton has in worst case @xmath0 states where @xmath1 denotes the number of subformulas . </S>",
    "<S> moreover , it has a better bound @xmath2 when the formula is until- ( or release- ) free .    </S>",
    "<S> we explore the properties of the formula s dnf form , and then identify the corresponding accepting states . as a result </S>",
    "<S> , we present a dnf - based approach to generating bchi automata from ltl formulas . compared to the classic tableau construction </S>",
    "<S> , our approach 1 ) avoids generating the gba ( generalized bchi automata ) ; 2 ) discusses many interesting ltl formulas properties which are seldom concerned before ; 3 ) gives the more precise upper bound of @xmath0 for the general translation , and even more has a better one of @xmath2 when the formula is until - free ( release - free ) . </S>"
  ]
}