{
  "article_text": [
    "dot plots are a standard method for local comparison of two biological sequences introduced by gibbs / mcintyre  @xcite and maizel / lenk  @xcite . when creating a dot plot , a substring to substring distance",
    "is computed for all pairs of fixed - size windows in the input strings .",
    "the result can be visualized by a plot showing a dot for each pair of windows that achieves a distance below a fixed threshold .",
    "commonly , the hamming distance is used  @xcite , since it can be computed very efficiently . however , the hamming distance is a rather crude measure of string similarity . using a string edit distance or alignment score",
    "( see e.g.  @xcite ) for dot plot filtering can greatly improve the sensitivity of the method . in the context of biological sequence comparison , this idea has been implemented by ott et al .",
    "@xcite , where a sequential algorithm is given which creates an alignment plot for two strings of lengths @xmath0 and @xmath1 using a fixed window length  @xmath2 in time @xmath7 . in this paper , we give an improved data - parallel algorithm , running in time @xmath8 using vector operations that work on @xmath5 values in parallel , and show experimental speedups from an implementation using mmx  @xcite .",
    "furthermore , we demonstrate that the algorithm can be parallelized to run on multiple processors using mpi  @xcite .",
    "let @xmath9 and @xmath10 be two strings over an alphabet @xmath11 of size @xmath12 .",
    "we distinguish between contiguous _ substrings _ of a string @xmath13 , which can be obtained by removing zero or more characters from the beginning and/or the end of @xmath13 , and _ subsequences _ , which can be obtained by deleting zero or more characters in any position .",
    "the _ longest common subsequence _ ( lcs ) of two strings is the longest string that is a subsequence of both input strings ; its length ( the llcs ) is a measure for the similarity of the two strings .",
    "substrings of length @xmath2 are called _",
    "@xmath2-windows_. for a given @xmath2 , the length of the lcs of two @xmath2-windows @xmath14 and @xmath15 will be denoted as @xmath16 .",
    "an _ alignment plot _ for @xmath13 and @xmath17 consists of all values @xmath16 with @xmath18 , @xmath19 .",
    "although the lcs is more accurate than the hamming score , more general similarity measures are of interest in practice .",
    "a standard interpretation of lcs is _ string alignment _",
    "an alignment of strings @xmath13 and @xmath17 is obtained by putting a subsequence of @xmath13 into one - to - one correspondence with a ( not necessarily identical ) subsequence of @xmath17 , character by character and respecting the index order .",
    "the corresponding pairs of characters , one from @xmath13 and the other from @xmath17 , are said to be _",
    "aligned_. a character not aligned with a character of another string",
    "is said to be aligned with a _",
    "gap _ in that string .",
    "finding the lcs corresponds to computing a maximum alignment when assigning the scores @xmath20 to aligning a matching pair of characters , @xmath21 to inserting a gap , and @xmath22 to aligning two mismatching characters .",
    "more general alignments than the lcs can be obtained using the standard dynamic programming algorithm  @xcite , which allows for gap penalties as well as different scores for each individual pair of matching / mismatching characters , forming a _ pairwise score matrix_. any algorithm for lcs computation can be generalized to pairwise score matrices with small rational scores at the price of a constant factor blow - up of the input strings  @xcite . in this paper",
    ", we will consider alignments with match score @xmath20 , mismatch score @xmath22 and gap penalty @xmath23 . to compute these alignments ,",
    "we modify the input strings by adding a new character ` $ ` to the alphabet , which we insert before every character in both input strings such that e.g.  ` abab ` transforms into ` $ a$b$a$b ` . for input strings @xmath13 and @xmath17 of length @xmath0 and @xmath1 , the alignment score @xmath24 can be retrieved from llcs of the modified strings @xmath25 and @xmath26 as @xmath27 .",
    "we expect the running time of the seaweed algorithm to increase by a factor of four by this reduction , as both input strings double in size .",
    "our new algorithms are based on semi - local sequence alignment  @xcite , for which we now give the necessary definitions . throughout this paper",
    ", we will denote the set of integers @xmath28 by @xmath29 $ ] , and the set of odd half - integers @xmath30 by @xmath31 .",
    "we will further mark odd half - integer variables by a `` @xmath32 '' symbol .",
    "when indexing a matrix @xmath33 by odd - half integer values @xmath34 and @xmath35 , we define that @xmath36 with @xmath37 and @xmath38 . therefore , if a matrix has integer indices @xmath39\\times [ 1:n]$ ] , it has odd - half integer indices @xmath40 .",
    "we also define the _ distribution matrix _ @xmath41 of an @xmath42 matrix @xmath43 as @xmath44 with @xmath45    let the _ alignment dag ( directed acyclic graph ) _ @xmath46 for two strings @xmath13 and @xmath17 be defined by a set of vertices @xmath47 with @xmath48 $ ] and @xmath49 $ ] and edges as follows .",
    "we have horizontal and vertical edges @xmath50 and @xmath51 of score  0 .",
    "further , we introduce diagonal edges @xmath52 of score  1 , which are present only if @xmath53 .",
    "longest common subsequences of a substring @xmath54 and @xmath17 correspond to highest - scoring paths in this graph from @xmath55 to @xmath56 .",
    "when drawing the alignment dag in the plane , its horizontal and vertical edges partition the plane into rectangular _ cells _ each of which , depending on the input strings , may contain a diagonal edge or not .",
    "for every pair of characters @xmath57 and @xmath58 , we define a corresponding cell @xmath59 . cells corresponding to a matching pair of characters are called _ match cells _ , and cells corresponding to mismatching characters are called _",
    "mismatch cells_.    solutions to the _ semi - local lcs problem _ are given by a _",
    "highest - score matrix _ which we define as follows .",
    "in a highest - score matrix @xmath60 , each entry @xmath61 is defined as the length of the highest - scoring path in @xmath46 from @xmath55 to @xmath56 .",
    "each entry @xmath61 with @xmath62 gives the llcs of @xmath13 and substring @xmath63 . since the values of @xmath61 for different @xmath64 and @xmath65 are strongly correlated , it is possible to derive an implicit , space - efficient representation of matrix @xmath61 .",
    "this implicit representation of a semi - local highest - score matrix consists of a set of _",
    "critical points_. the critical points of a highest - score matrix @xmath66 are defined as the set of odd half - integer pairs @xmath67 such that @xmath68 .",
    "consider a highest - score matrix @xmath66 .",
    "the matrix @xmath69 with @xmath70 if @xmath71 is a critical point in @xmath66 , and @xmath72 otherwise , is called the _ implicit highest - score matrix_. tiskin  @xcite showed that in order to represent a highest - score matrix for two strings of lengths @xmath0 and @xmath1 , exactly @xmath73 such critical points are sufficient .",
    "[ thm : implicitrep ] a highest - score matrix @xmath66 can be represented implicitly using only @xmath74 space by its implicit highest - score matrix @xmath69 , which is a permutation matrix .",
    "we have : @xmath75 , where @xmath76 is the distribution matrix of the implicit highest - score matrix @xmath69 .",
    "the set of critical points can be obtained using the _ seaweed algorithm _",
    "( by alves et al .",
    "@xcite , based on schmidt  @xcite , adapted by tiskin  @xcite ) which computes critical points by dynamic programming on all prefixes of the input strings .",
    "this method is graphically illustrated by tracing _",
    "seaweeds _ that start at odd half - integer positions between two adjacent vertices @xmath77 and @xmath78 in the top row of the alignment dag , and end between two adjacent vertices @xmath79 and @xmath80 in the bottom row .",
    "each critical point is computed as the pair of horizontal start and end coordinates of such a seaweed ( see algorithm  [ alg : seaweed_algorithm ] ) .",
    "two seaweeds enter every cell in the alignment dag , one at the left and one at the top .",
    "the seaweeds proceed through the cell either downwards or rightwards . in the cell",
    ", the directions of these seaweeds are interchanged either if there is a match @xmath81 , or if the same pair of seaweeds have already crossed .",
    "otherwise , their directions remain unchanged and the seaweeds cross . by theorem  [ thm : implicitrep ] , the length of the highest - scoring path in @xmath46 from @xmath55 to @xmath56 can be computed by counting the number of seaweeds which both start and end within @xmath82 .",
    "the seaweed algorithm can be used to compute the lcs of all pairs of @xmath2-windows simultaneously in time @xmath83 for two strings of respective lengths @xmath2 and @xmath1 ( i.e.  one of the strings consists of only one @xmath2-window ) . by theorem  [ thm : implicitrep ] , the lcs of @xmath13 and any @xmath2-window @xmath84 is computed as the number of seaweeds starting and ending within the odd half - integer range @xmath85 . by keeping track of only these seaweeds in a sliding window , our algorithm can compute the llcs for all @xmath2-windows in a single pass over all columns of cells in the alignment dag .",
    "we obtain an improved algorithm for comparing all pairs of @xmath2-windows .",
    "[ thm : basic_wlcs ] given two strings @xmath13 and @xmath17 of lengths @xmath0 and @xmath1 , the llcs for all pairs of @xmath2-windows between @xmath13 and @xmath17 can be computed in time @xmath86 .",
    "we apply the seaweed algorithm for computing the implicit @xmath87-restricted highest - score matrices for @xmath17 and all substrings of @xmath13 that have length @xmath2 .",
    "each application of the seaweed algorithm therefore runs on a strip of height @xmath2 and width @xmath1 of the alignment dag corresponding to @xmath14 and @xmath17 .",
    "a column of cells in this strip can be processed in time @xmath88 . in each column @xmath65 ,",
    "exactly one new seaweed starts at the top of the alignment dag , and exactly one seaweed ends at the bottom .",
    "we track seaweeds ending within @xmath89 . to count the seaweeds that have reached the bottom of the alignment dag",
    ", we maintain a priority queue @xmath90 . in each step ,",
    "one seaweed reaches the bottom of the alignment dag .",
    "furthermore , in each step , we have to delete at most one seaweed from @xmath91 .",
    "we use a priority queue of @xmath92-bit integers to represent @xmath91 . for each seaweed that reaches the bottom ,",
    "we compute its starting point and add it to the queue .",
    "we delete the minimum value from the queue if it is smaller than the starting position of the current @xmath2-window in string @xmath17 . by using a min - heap  @xcite ,",
    "both operations can be implemented in @xmath93 .",
    "the number @xmath94 of seaweeds which start within @xmath89 is then given by the size of queue  @xmath91 .",
    "the llcs of @xmath95 and @xmath96 can then be calculated as @xmath97 . in total",
    ", we have to process @xmath1 columns using time @xmath88 in every strip .",
    "overall , @xmath98 strips exist , therefore we obtain running time @xmath99 .    while this direct application of the seaweed method gives an asymptotic improvement on the method of computing the lcs independently for every pair of windows by dynamic programming , it is not necessarily more practical .",
    "the dynamic programming method can exploit the fact that we are only interested in windows with an alignment score above a given threshold .",
    "more importantly , the dynamic programming method allows one to improve performance by introducing a step size @xmath100 , and only comparing @xmath2-windows starting at positions that are multiples of @xmath100 .",
    "we will now show how to improve the practical performance of the algorithm .",
    "algorithm  [ alg : seaweed_algorithm ] requires @xmath101 bits to represent the start and endpoints of a single seaweed .",
    "we first show that for computing alignment plots with a fixed window length @xmath2 , @xmath93 bits are sufficient for tracing seaweeds , independently of the size of the input strings .",
    "to show this , we define the _ span _ of a seaweed as the horizontal distance it covers in the alignment dag .",
    "a seaweed corresponding to a critical point @xmath67 has span @xmath102 .",
    "seaweeds that have a span greater than the window length @xmath2 are not relevant for computing the alignment plot , since they will not start and end within a single window .",
    "furthermore , we are only interested in values with index pairs @xmath103 having @xmath104 , where @xmath105 is the constant blowup induced by the alignment score ( for the scoring scheme described in the previous section , we have @xmath106 ) .",
    "this is equivalent to computing the semi - local lcs for substrings restricted to length  @xmath2 , starting and ending at positions @xmath107 .",
    "[ def : restricted_hsm ] let @xmath66 be a highest - score matrix .",
    "@xmath108-restricted highest - score matrix _",
    "@xmath109 is defined as @xmath110 and @xmath111 , and @xmath112 otherwise .",
    "this restriction on the highest - score matrices allows us to reduce the number of critical points we need to store , and also to reduce the number of bits required to represent seaweeds in our computation .    to represent a @xmath108-restricted highest - score matrix implicitly , we only need to store the critical points @xmath67 of the corresponding unrestricted highest score matrix for which @xmath113 .",
    "straightforward from theorem  [ thm : implicitrep ] and definition  [ def : restricted_hsm ] .",
    "[ prop : w_r_bits ] we can represent a single critical point in a @xmath108-restricted highest - score matrix for comparing strings @xmath13 and @xmath17 using @xmath114 bits .",
    "we store the seaweeds in a vector @xmath115 of size @xmath73 , where each vector element stores @xmath116 bits . for each critical point @xmath67",
    ", we have one vector element @xmath117 .",
    "each vector element stores the span of the seaweed starting at @xmath34 .",
    "it is straightforward to see that we only need @xmath93 bits for a vector element : seaweeds in a @xmath108-restricted highest - score matrix become irrelevant once their span is larger than @xmath2 , since these critical points will not affect any lcs for a substring of length @xmath2 ( see theorem  [ thm : implicitrep ] ) . in order to reduce the number of bits to @xmath118",
    ", we use the fact that we only need to answer lcs queries correctly if @xmath119 .",
    "we therefore do not need to distinguish the individual @xmath105 seaweeds starting within @xmath120 $ ] with @xmath121 : once they reach the bottom , we only need to know their starting position within a window of size @xmath105 .",
    "we can therefore divide the distance values by @xmath105 , which gives the claimed number of required bits .",
    "we now show how to use vector instructions for improving algorithm  [ alg : seaweed_algorithm ] to trace multiple seaweeds in parallel . a practical example for vector parallelism are intel s mmx instructions  @xcite for integer vector arithmetic and comparison ( it would also be possible to implement our algorithm using floating point vector processing , e.g.  using sse  @xcite ) . in our algorithm , we assume that all elements @xmath122 in a vector @xmath123 are @xmath124-bit values . if an element of a vector has all bits set , then this represents the value of @xmath125 , having @xmath126 .",
    "when carrying out the seaweed algorithm on columns of the alignment dag , the result of every comparison in a cell of the column depends on the comparison result from the cell above it . to be able to process multiple cells in parallel ,",
    "we need to process cells by antidiagonals . we can then use vector operations to implement each step in the the seaweed algorithm , as each cell can be processed only using data computed in the previous step .",
    "we need to track seaweeds only if they are within the window of interest . in order to keep the required value of bits per seaweed as small as possible ( and",
    "hence allow a high degree of vector parallelism ) , we identify seaweeds by the distance of their starting points to the current column .",
    "this distance can be represented using @xmath127 bits ( see proposition  [ prop : w_r_bits ] ) .",
    "when advancing to the next column , we use saturated addition to increment all distances in parallel ( i.e.  saturated addition of one to vector element @xmath128 gives @xmath129 if @xmath130 , and @xmath131 otherwise ) . in each step , we compare the characters corresponding to the cells in the current antidiagonal using vectorised mask generation . given two vectors @xmath132 and @xmath133 , we generate a mask vector which contains the value @xmath131 at all positions @xmath134 , where @xmath135 and zero otherwise . the seaweed behaviour in mismatch cells is implemented by a compare / exchange operation",
    "which , given two vectors @xmath132 and @xmath133 , exchanges @xmath128 and @xmath136 only if @xmath137 .",
    "to combine the results from the mismatch cells and the match cells , we require an operation to exchange vector elements conditionally using the mask vector @xmath33 generated earlier . given two vectors @xmath132 and @xmath138 , this operation returns vector elements @xmath128 if @xmath139 , and @xmath136 otherwise .",
    "all these operations can be vectorized efficiently using mmx .",
    "using these operations , we can implement the seaweed operations from algorithm  [ alg : seaweed_algorithm ] by storing all seaweeds on the current antidiagonal in a vector @xmath123 if they enter the respective cell from the left , and a vector @xmath140 if they enter the respective cell from the top .",
    "we use a @xmath124-bit shift operation on vector @xmath140 in each step to advance the seaweeds leaving cells at the bottom downwards .",
    "l@rrrr * data set * & & & & +   + & 5.1 ( @xmath141 1.0 ) & 41.1 ( @xmath141 1.0 ) & 2677 ( @xmath141 1.0 ) & 11708 ( @xmath141 1.0 ) + blcs & 3.6 ( @xmath141 1.4 ) & 37.3 ( @xmath141 1.1 ) & 3680 ( @xmath141 0.7 ) & 16191 ( @xmath141 0.7 ) + sea-16 & 1.4 ( @xmath141 3.6 ) & 10.8 ( @xmath141 3.8 ) & 1026 ( @xmath141 2.6 ) & 4514 ( @xmath141 2.6 ) + sea-8 & 0.5 ( @xmath141 10.2 ) & 3.8 ( @xmath141 10.8 ) & 368 ( @xmath141 7.3 ) & 1614 ( @xmath141 7.3 ) +   + 1 core & 0.4 ( @xmath141 1.0 ) & 2.9 ( @xmath141 1.0 ) & 271 ( @xmath141 1.0 ) & 1199 ( @xmath141 1.0 ) + 4 cores & 0.7 ( @xmath141 0.6 ) & 1.3 ( @xmath141 2.2 ) & 70 ( @xmath141 3.9 ) & 307 ( @xmath141 3.9 ) +   + 1 core & 0.67 ( @xmath141 1.0 ) & 3.1 ( @xmath141 1.0 ) & 225 ( @xmath141 1.0 ) & 991 ( @xmath141 1.0 ) + 4 cores & 0.57 ( @xmath141 1.2 ) & 1.4 ( @xmath141 2.2 ) & 58 ( @xmath141 3.9 ) & 251 ( @xmath141 3.9 ) + 16 cores & 1.26 ( @xmath141 0.5 ) & 1.6 ( @xmath141 1.9 ) & 20 ( @xmath141 11.5 ) & 66 ( @xmath141 14.9 ) + 64 cores &  &  & 11 ( @xmath141 20.5 ) & 23 ( @xmath141 42.4 ) +    we have implemented the algorithm from the previous sections for allowing its application to actual biological sequences .",
    "the implementation uses c++ with and intel mmx assembly code . as input data for our tests",
    ", we used different biological sequence data sets and a fixed window size of  100 ( the nature of the sequences does not affect the running time of our algorithm , but may affect the impact of the heuristic speedup employed by the heuristic method we compare the results to ) .",
    "in all experiments , we used a vertical step size of  5 , i.e.  we only compare every fifth window in the first input to all windows in the other string .",
    "using the scoring scheme as described in section  [ sec : lcs ] induces a window size of  200 due to the constant - size blowup of the alignment dag . for comparing the results to existing methods",
    ", we implemented an alternative fast method for bit - parallel lcs computation  @xcite to compute the pairwise alignment scores ( `` blcs '' ) ",
    "our 64-bit implementation of this algorithm achieves a speedup of 32 over the standard dynamic programming algorithm for inputs of length  200 .",
    "furthermore , we compared our results to the code used in  @xcite ( `` heur '' ) which uses the standard dynamic programming algorithm  @xcite and a heuristic to speed up computation when a minimum alignment score for a window pair is specified . in the sea-16 , vectors of 16-bit values were used . using the results from section  [ sec : seawinwin ]",
    ", we can improve this to use 8-bit values , by computing @xmath142-restricted highest - score matrices .",
    "the results of our experiments are shown in table  [ tbl : compresults ] .",
    "we see that the seaweed - based algorithm is fastest for all data sets .",
    "we also see that the heuristic employed by heur makes this algorithm more effective than the blcs method for long sequences . however , we note that it would be possible to adapt blcs to make use of the same heuristic speedup .",
    "overall , these results show that the seaweed algorithm is highly competitive against the repeated dynamic programming approach , and that particularly the byte vector version ( sea-8 ) is more than seven times faster than the best existing method .",
    "we further conducted experiments to study the scalability on larger numbers of processors using mpi by distributing the computation of the strips between multiple processors ( see table  [ tbl : compresults ] , bottom result sets ) .",
    "we obtained good speedup especially for the large datasets both on small and larger parallel systems .",
    "note that our sample datasets are still rather small .",
    "we plan to apply the algorithm to whole - genome comparison , which involves much larger input sequences , and hence better speedup on more processors .",
    "in this paper , we present a practical algorithm for local string comparison by edit distance filtered dot plots which uses vector - parallelism and recent algorithmic results to achieve both improved asymptotic cost and performance over applying optimized standard methods .",
    "we have further shown results from a coarse - grained parallel implementation of the algorithm , which achieved good speedup on different parallel systems .",
    "further performance could be gained by using sse  @xcite or newer vector architectures like larrabee  @xcite for implementing our code .",
    "a few algorithmic improvements are possible as well . in  @xcite ,",
    "a tree approach is proposed to avoid recomputing all seaweeds in each strip of height @xmath2 , which allows to perform the computation in time @xmath143 .",
    "we are currently investigating a practical variation of this theoretical method which further reduces the dependency on the window size , and may improve the algorithm shown here .",
    "moreover , we believe that it is possible to use a similar heuristic to the one applied in  @xcite to further improve performance ."
  ],
  "abstract_text": [
    "<S> dot plots are a standard method for local comparison of biological sequences . in a dot plot , </S>",
    "<S> a substring to substring distance is computed for all pairs of fixed - size windows in the input strings . </S>",
    "<S> commonly , the hamming distance is used since it can be computed in linear time . </S>",
    "<S> however , the hamming distance is a rather crude measure of string similarity , and using an alignment - based edit distance can greatly improve the sensitivity of the dot plot method . in this paper , we show how to compute alignment plots of the latter type efficiently . </S>",
    "<S> given two strings of length @xmath0 and @xmath1 and a window size @xmath2 , this problem consists in computing the edit distance between all pairs of substrings of length @xmath2 , one from each input string . </S>",
    "<S> the problem can be solved by repeated application of the standard dynamic programming algorithm in time @xmath3 . </S>",
    "<S> this paper gives an improved data - parallel algorithm , running in time @xmath4 using vector operations that work on @xmath5 values in parallel and @xmath6 processors .    </S>"
  ]
}