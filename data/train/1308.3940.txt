{
  "article_text": [
    "_ resource usage analysis _ infers the aggregation of some numerical properties , like memory usage , time spent in computation , or bytes sent over a wire , throughout the execution of a piece of code .",
    "such numerical properties are known as _ resources_. the expressions giving the usage of resources are usually given in terms of the sizes of some input arguments to procedures .",
    "our starting point is the methodology outlined by  @xcite and  @xcite , characterized by the setting up of recurrence equations . in that methodology",
    ", the size analysis is the first of several other analysis steps that include cardinality analysis ( that infers lower and upper bounds on the number of solutions computed by a predicate ) , and which ultimately obtain the resource usage bounds .",
    "one drawback of these proposals , as well as most of their subsequent derivatives , is that they are only able to cope with size information about subterms in a very limited way .",
    "this is an important limitation , which causes the analysis to infer trivial bounds for a large class of programs .",
    "for example , consider a predicate which computes the factorials of a list :    p6.3cmp6 cm    .... listfact ( [ ] ,    [ ] ) .",
    "listfact([e|r],[f|fr ] ) : -      fact(e , f ) ,      listfact(r , fr ) .       ....    &    .... fact(0,1 ) .",
    "fact(n , m ) : - n1 is n - 1 ,               fact(n1 , m1 ) ,               m is n * m1 .",
    "....    intuitively , the best bound for the running time of this program for a list @xmath0 is @xmath1 , where @xmath2 and @xmath3 are constants related to the unification and calling costs . but with no further information , the upper bound for the elements of @xmath0 must be @xmath4 to be on the safe side , and then the returned overall time bound must also be @xmath4 .    in a previous paper  @xcite we focused on a proposal to improve the size analysis based on _",
    "sized types_. these sized types are similar to the ones present in @xcite for functional programs , but our proposal includes some enhancements to deal with regular types in logic programs , developing solutions to deal with the additional features of logic programming such as non - determinism and backtracking . while in that paper we already hinted at the fact that the application of our sized types in resource analysis could result in considerable improvement , no description was provided of the actual resource analysis .",
    "this paper is complementary and fills this gap by describing a new resource usage analysis with two novel aspects .",
    "firstly , it can _ take advantage of the new information contained in sized types_. furthermore , this resource analysis is _ fully based on abstract interpretation _ , i.e. , not just the auxiliary analyses but also the resource analysis itself .",
    "this allows us to integrate resource analysis within the plai abstract interpretation framework  @xcite in the ciaopp system , which brings in features such as _ multivariance _ , fixpoints , and assertion - based verification and user interaction for free .",
    "we also perform a performance assessment of the resulting global system .",
    "in section [ sec : overview ] we give a high - level view of the approach . in the following section we review the abstract interpretation approach to size analysis using sized types .",
    "section  [ sec : resources ] gets deeper into the resource usage analysis , our main contribution .",
    "experimental results are shown in section  [ sec : results ] .",
    "finally we review some related work and discuss future directions of our resource analysis work .",
    "we give now an overview of our approach to resource usage analysis , and present the main ideas in our proposal using the classical ` append/3 ` predicate as a running example :    .... append ( [ ] ,     s , s ) .",
    "append([e|r ] , s , [ e|t ] ) : - append(r , s , t ) .",
    "....    the process starts by performing the regular type analysis present in the ciaopp system  @xcite . in our example",
    ", the system infers that for any call to the predicate ` append(x , y , z ) ` with ` x ` and ` y ` bound to lists of numbers and ` z ` a free variable , if the call succeeds , then ` z ` also gets bound to a list of numbers .",
    "the set of `` list of numbers '' is represented by the regular type `` listnum , '' defined as follows :    .... listnum - > [ ] | .(num , listnum ) ....    from this regular type definition , sized type schemas are derived . in our case , the sized type schema @xmath5 is derived from @xmath6 .",
    "this schema corresponds to a list that contains a number of elements between @xmath2 and @xmath3 , and each element is between the bounds @xmath7 and @xmath8 .",
    "it is defined as : @xmath9    from now on , in the examples we will use @xmath10 and @xmath11 instead of @xmath6 and @xmath12 for the sake of conciseness .",
    "the next phase involves relating the sized types of the different arguments to the ` append/3 ` predicate using recurrence ( in)equations .",
    "let @xmath13 denote the sized type schema corresponding to argument ` x ` in a call ` append(x , y , z ) ` ( created from the regular type inferred by a previous analysis ) .",
    "we have that @xmath13 denotes @xmath14 .",
    "similarly , the sized type schema for the output argument ` z ` is @xmath15 , denoted by @xmath16 .",
    "now , we are interested in expressing bounds on the length of the output list ` z ` and the value of its elements as a function of size bounds for the input lists ` x ` and ` y ` ( and their elements ) . for this purpose",
    ", we set up a system of inequations .",
    "for instance , the inequations that are set up to express a lower bound on the length of the output argument ` z ` , denoted @xmath17 , as a function on the size bounds of the input arguments ` x ` and ` y ` , and their subarguments ( @xmath18 , and @xmath19 ) are :    @xmath20    note that in the recurrence inequation set up for the second clause of ` append/3 ` , the expression @xmath21 ( respectively @xmath22 ) represents the size relationship that a lower ( respectively upper ) bound on the length of the list in the first argument of the recursive call to ` append/3 ` is one unit less than the length of the first argument in the clause head .",
    "as the number of size variables grows , the set of inequations becomes too large .",
    "thus , we propose a compact representation .",
    "the first change in our proposal is to write the parameters to size functions directly as sized types .",
    "now , the parameters to the @xmath17 function are the sized type schemas corresponding to the arguments ` x ` and ` y ` of the ` append/3 ` predicate :    @xmath23    in a second step , we group together all the inequalities of a single sized type .",
    "as we always alternate lower and upper bounds , it is always possible to distinguish the type of each inequality .",
    "we do not write equalities , so that we do not use the symbol @xmath24 .",
    "however , we always write inequalities of both signs ( @xmath25 and @xmath26 ) for each size function , since we compute both lower and upper size bounds .",
    "thus , we use a compact representation @xmath27 for the symbols @xmath25 and @xmath26 that are always paired .",
    "for example , the expression : @xmath28 represents the conjunction of the following size constraints : @xmath29    after setting up the corresponding system of inequations for the output argument ` z ` of ` append/3 ` , and solving it , we obtain the following expression :    @xmath30    that represents , among others , the relation @xmath31 ( resp .",
    "@xmath32 ) , expressing that a lower ( resp .",
    "upper ) bound on the length of the output list ` z ` , denoted @xmath33 ( resp .",
    "@xmath34 ) , is the addition of the lower ( resp .",
    "upper ) bounds on the lengths of ` x ` and ` y ` .",
    "it also represents the relation @xmath35 ( resp .",
    "@xmath36 ) , which expresses that a lower ( resp .",
    "upper ) bound on the size of the elements of the list ` z ` , denoted @xmath37 ( resp .",
    "@xmath38 ) , is the minimum ( resp .",
    "maximum ) of the lower ( resp .",
    "upper ) bounds on the sizes of the elements of the input lists ` x ` and ` y ` .",
    "resource analysis builds upon the sized type analysis and adds recurrence equations for each resource we want to analyze .",
    "apart from that , when considering logic programs , we have to take into account that they can fail or have multiple solutions when executed , so we need an auxiliary _ cardinality analysis _ to get correct results .",
    "let us focus now on cardinality analysis .",
    "let @xmath39 and @xmath40 denote lower and upper bounds on the number of solutions respectively that predicate ` append/3 ` can generate .",
    "following the program structure we can infer that :    @xmath41 @xmath42    the solution to these inequations is @xmath43 , so we have inferred that ` append/3 ` generates at least ( and at most ) one solution .",
    "thus , it behaves like a function .",
    "when setting up the equations , we have used our knowledge that ` append/3 ` can not fail when given lists as arguments . if not , the lower bound in the number of solutions would be 0 .",
    "now we move forward to analyzing the number of resolution steps performed by a call to ` append/3 ` ( we will only focus on upper bounds , @xmath44 , for brevity ) .",
    "for the first clause , we know that only one resolution step is needed , so :    @xmath45    the second clause performs one resolution step plus all the resolution steps performed by all possible backtrackings over the call in the body of the clause .",
    "this number of possible backtrackings is bounded by the number of solutions of the predicate .",
    "so the equation reads :    @xmath46    solving these equations we infer that an upper bound on the number of resolution steps is the ( upper bound on the length ) of the input list ` x ` plus one .",
    "this is expressed as :    @xmath47",
    "as shown in the ` append ` example , the ( bound ) variables that we relate in our inequations come from sized types , which are ultimately derived from the regular types previously inferred for the program . among several representations of regular types used in the literature",
    ", we use one based on _ regular term grammars _ , equivalent to  @xcite but with some adaptations . a _ type term _ is either a _ base type _",
    "@xmath48 ( taken from a finite set ) , a _ type symbol _ @xmath49 ( taken from an infinite set ) , or a term of the form @xmath50 , where @xmath51 is a @xmath11-ary function symbol ( taken from an infinite set ) and @xmath52 are _ type terms_. a _ type rule _ has the form @xmath53 , where @xmath54 is a _ type symbol _ and @xmath55 a _ type term_. a _ regular term grammar _",
    "@xmath56 is a set of _ type rules_.    to devise the abstract domain we focus specifically on the generic and - or trees procedure of @xcite , with the optimizations of @xcite .",
    "this procedure is _ generic _ and goal dependent : it takes as input a pair @xmath57 representing a predicate along with an abstraction of the call patterns ( in the chosen _ abstract domain _ ) and produces an abstraction @xmath58 which overapproximates the possible outputs .",
    "this procedure is the basis of the plai abstract analyzer present in ciaopp  @xcite , where we have integrated an implementation of the proposed size analysis .",
    "the formal concept of _ sized type _ is an abstraction of a set of herbrand terms which are a subset of some regular type @xmath54 and meet some lower- and upper - bound size constraints on the number of _ type rule applications_. a grammar for the new sized types follows :    ' '' ''    [ cols=\">,^ , < , > \" , ]",
    "we have constructed a prototype implementation in ciao by defining the abstract operations for sized type and resource analysis that we have described in this paper and plugging them into ciaopp s plai implementation .",
    "our objective is to assess the gains in precision in resource consumption analysis .",
    "table  [ expresults ] shows the results of the comparison between the new lower ( * _ lb _ * ) and upper bound ( * _ ub _ * ) resource analyses implemented in ciaopp , which also use the new size analysis ( columns _ new _ ) , and the previous resource analyses in ciaopp  @xcite ( columns _ previous _ ) .",
    "we also compare ( for upper bounds ) with _ raml _ s analysis  @xcite ( column _ raml _ ) .",
    "although the new resource analysis and the previous one infer concrete resource usage bound functions ( as the ones in  @xcite ) , for the sake of conciseness and to make the comparison with raml meaningful , table  [ expresults ] only shows the complexity orders of such functions , e.g. , if the analysis infers the resource usage bound function @xmath59 , and @xmath60 , table  [ expresults ] shows @xmath61 .",
    "the parameters of such functions are ( lower or upper ) bounds on input data sizes .",
    "the symbols used to name such parameters have been chosen assuming that lists of numbers @xmath62 have size @xmath63 , lists of lists of lists of numbers have size @xmath64 , and numbers have size @xmath65 .",
    "table  [ expresults ] also includes columns with symbols summarizing whether the new ciaoppresource analysis improves on the previous one and/or _ raml _ s : @xmath66 ( resp .",
    "@xmath67 ) indicates more ( resp .",
    "less ) precise bounds , and @xmath24 the same bounds .",
    "the new size analysis improves on ciaopp s previous resource analysis in most cases .",
    "moreover , raml can only infer polynomial costs , while our approach is able to infer other types of cost functions , as is shown for the divide - and - conquer benchmarks ` hanoi ` and ` fib ` , which represent a large and common class of programs . for predicates with polynomial cost ,",
    "we get equal or better results than raml .",
    "several other analyses for resources have been proposed in the literature . some of them",
    "just focus on one particular resource ( usually execution time or heap consumption ) , but it seems clear that those analyses could be generalized .",
    "we already mentioned raml  @xcite in section  [ sec : results ] .",
    "their approach differs from ours in the theoretical framework being used : raml uses a type and effect system , whereas our system uses abstract interpretation .",
    "another important difference is the use of polynomials in raml , which allows a complete method of resolution but limits the type of closed forms that can be analyzed .",
    "in contrast , we use recurrence equations , which have no complete decision procedure , but encompass a much larger class of functions .",
    "type systems are also used to guide inference in @xcite and  @xcite .    in  @xcite ,",
    "the authors use sparsity information to infer asymptotic complexities .",
    "in contrast , we only get closed forms . similarly to ciaopp s previous analysis",
    ", the approach of  @xcite applies the recurrence equation method directly ( i.e. , not within an abstract interpretation framework ) .",
    "@xcite shows a complexity analysis based on abstract interpretation over a step - counting version of functional programs .",
    "@xcite uses symbolic evaluation graphs to derive termination and complexity properties of logic programs .",
    "in this paper we have presented a new formulation of resource analysis as a domain within abstract interpretation and which uses as input information the sized types that we developed in  @xcite .",
    "we have seen how this approach offers benefits both in the quality of the bounds inferred by the analysis , and in the ease of implementation and integration within a framework such as plai / ciaopp .    in the future",
    ", we would like to study the generalization of this framework to different behaviors regarding aggregation .",
    "for example , when running tasks in parallel , the total time is basically the maximum of both tasks , but memory usage is bounded by the sum of them .",
    "another future direction is the use of more ancillary analyses to obtain more precise results .",
    "also , since we use sized types as a basis , any new research that improves such analysis will directly benefit the resource analysis . finally , another planned enhancement is the use of mutual exclusion analysis ( already present in ciaopp ) to aggregate recurrence equations in a better way .",
    "e.  albert , s.  genaim , and a.  n. masud .",
    "ore precise yet widely applicable cost analysis . in r.",
    "jhala and d.  schmidt , editors , _",
    "12th verification , model checking , and abstract interpretation ( vmcai11 ) _ , volume 6538 of _ lecture notes in computer science _ , pages 3853 .",
    "springer verlag , january 2011 .",
    "r.  bagnara , a.  pescetti , a.  zaccagnini , and e.  zaffanella . : towards computer algebra support for fully automatic worst - case complexity analysis . technical report , 2005 .",
    "available from http://arxiv.org/.      f.  bueno , p.  lpez - garca , and m.  hermenegildo .",
    "ultivariant non - failure analysis via standard abstract interpretation . in _",
    "7th international symposium on functional and logic programming ( flops 2004 ) _ , number 2998 in lncs , pages 100116 , heidelberg , germany , april 2004 .",
    "springer - verlag .",
    "s.  k. debray , n .- w .",
    "lin , and m.  hermenegildo .",
    "ask granularity analysis in logic programs . in _ proc . of the 1990 acm conf",
    ". on programming language design and implementation _ , pages 174188 .",
    "acm press , june 1990 .",
    "s.  k. debray , p.  lpez - garca , m.  hermenegildo , and n .- w .",
    "ower bound cost estimation for logic programs . in _ 1997 international logic programming symposium _ , pages 291305 .",
    "mit press , cambridge , ma , october 1997 .",
    "jrgen giesl , thomas strder , peter schneider - kamp , fabian emmes , and carsten fuhs . symbolic evaluation graphs and term rewriting : a general methodology for analyzing logic programs . in _ ppdp _ , pages 112 .",
    "acm , 2012 .",
    "p.  lpez - garca , l.  darmawan , and f.  bueno .",
    "ramework for verification and debugging of resource usage properties . in m.",
    "hermenegildo and t.  schaub , editors , _ technical communications of the 26th intl .",
    "conference on logic programming ( iclp10 ) _ , volume  7 of _ leibniz international proceedings in informatics ( lipics ) _ , pages 104113 , dagstuhl , germany , july 2010 .",
    " leibniz - zentrum fuer informatik .",
    "j.  navas , e.  mera , p.  lpez - garca , and m.  hermenegildo .",
    "ser - definable resource bounds analysis for logic programs . in _ 23rd international conference on logic programming ( iclp07 ) _ , volume 4670 of _ lecture notes in computer science_. springer , 2007 .      g.  puebla and m.  hermenegildo .",
    "ptimized algorithms for the incremental analysis of logic programs . in _ international static analysis symposium",
    "( sas 1996 ) _ , number 1145 in lncs , pages 270284 .",
    "springer - verlag , september 1996 .",
    "pedro  b. vasconcelos and kevin hammond . inferring cost equations for recursive , polymorphic and higher - order functional programs . in philip",
    "w. trinder , greg michaelson , and ricardo pena , editors , _ ifl _ , volume 3145 of _ lecture notes in computer science _ , pages 86101 .",
    "springer , 2003 .    c.  vaucheret and f.  bueno .",
    "ore precise yet efficient type inference for logic programs . in _ international static analysis symposium _ ,",
    "volume 2477 of _ lecture notes in computer science _ , pages 102116 .",
    "springer - verlag , september 2002 ."
  ],
  "abstract_text": [
    "<S> we present a novel general resource analysis for logic programs based on sized types.sized types are representations that incorporate structural ( shape ) information and allow expressing both lower and upper bounds on the size of a set of terms and their subterms at any position and depth . </S>",
    "<S> they also allow relating the sizes of terms and subterms occurring at different argument positions in logic predicates . using these sized types , </S>",
    "<S> the resource analysis can infer both lower and upper bounds on the resources used by all the procedures in a program as functions on input term ( and subterm ) sizes , overcoming limitations of existing analyses and enhancing their precision . </S>",
    "<S> our new resource analysis has been developed within the abstract interpretation framework , as an extension of the sized types abstract domain , and has been integrated into the ciao preprocessor , ciaopp . </S>",
    "<S> the abstract domain operations are integrated with the setting up and solving of recurrence equations for both , inferring size and resource usage functions . </S>",
    "<S> we show that the analysis is an improvement over the previous resource analysis present in ciaopp and compares well in power to state of the art systems .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}