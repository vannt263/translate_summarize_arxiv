{
  "article_text": [
    "directed hypergraphs consist in a generalization of directed graphs , in which the tail and the head of the arcs are sets of vertices .",
    "directed hypergraphs have a very large number of applications , since hyperarcs naturally provide a representation of implication dependencies . among others , they are used to solve several problems related to satisfiability in propositional logic , in particular on horn formulas , see for instance  @xcite .",
    "they also appear in problems relative to network routing  @xcite , functional dependencies in database theory  @xcite , model checking  @xcite , chemical reaction networks  @xcite , transportation networks  @xcite , and more recently , tropical convex geometry  @xcite .",
    "many algorithmic aspects of directed hypergraphs have been studied , in particular optimization related ones , such as determining shortest paths  @xcite , maximum flows , minimum cardinality cuts , or minimum weighted hyperpaths ( we refer to the surveys of ausiello  _ et al . _",
    "@xcite and of gallo  _ et al . _",
    "@xcite for a comprehensive list of contributions ) . naturally , some problems raised by the reachability relation in directed hypergraphs have also been studied .",
    "for instance , determining the set of the vertices reachable from a given vertex is known to be solvable in linear time in the size of the directed hypergraph ( see for instance  @xcite ) .    in",
    "directed graphs , many other problems can be solved in linear time , such as testing acyclicity or strong connectivity , computing the strongly connected components ( sccs ) , determining a topological sorting over them , _",
    "etc_. surprisingly , the analogues of these elementary problems in directed hypergraphs have not received any particular attention ( as far as we know ) .",
    "unfortunately , none of the direct graph algorithms can be straightforwardly extended to directed hypergraphs .",
    "the main reason is that the reachability relation of hypergraphs does not have the same structure : for instance , establishing that a given vertex @xmath3 reaches another vertex @xmath4 generally involves vertices which do not reach @xmath4 .",
    "moreover , as shown by ausiello  _ et al . _  in  @xcite , the vertices of a hypercycle do not necessarily belong to a same strongly connected component .",
    "naturally , the aforementioned problems can be solved by determining the whole graph of the reachability relation , calling a linear time reachability algorithm on every vertex of the directed hypergraph .",
    "this naive approach is obviously not optimal , in particular when the hypergraph coincides with a directed graph .",
    "[ [ contributions ] ] contributions + + + + + + + + + + + + +    we first present in section  [ sec : maxscc ] an algorithm able to determine the terminal strongly connected components of a directed hypergraph in time complexity @xmath5 , where @xmath6 is the size of the hypergraph , @xmath2 the number of vertices , and @xmath1 is the inverse of the ackermann function . an scc is said to be _ terminal _ when no other scc is reachable from it . the time complexity is said to be _ almost linear _ because @xmath7 for any practical value of @xmath2 . as a by - product , the following two properties :",
    "is a directed hypergraph strongly connected ?    does a hypergraph admit a sink ( _ i.e. _  a vertex reachable from all vertices ) ?    can be determined in almost linear time .",
    "problems involving terminal sccs have important applications in computational tropical geometry .",
    "in particular , the algorithm presented here is the cornerstone of an analog of the double description method in tropical algebra  @xcite .",
    "we refer to section  [ subsec : other_properties ] for further details , where other applications to horn formulas and nonlinear spectral theory are also discussed .",
    "the contributions presented in section  [ sec : combinatorics ] indicate that the problem of computing the complete set of sccs is very likely to be harder in directed hypergraphs than in directed graphs .    in section  [ subsec : transitive_reduction ]",
    ", we establish a lower bound result which shows that the size of the transitive reduction of the reachability relation may be superlinear in the size of the directed hypergraph ( whereas it is linearly upper bounded in the setting of directed graphs ) .",
    "an important consequence is that any algorithm computing the sccs in directed hypergraphs by exploring the entire reachability relation , or at least a transitive reduction , has a superlinear complexity .    in section  [ subsec : set_pb_reduction ] , we prove a linear time reduction from the minimal set problem to the problem of computing the strongly connected components . given a family @xmath8 of sets over a certain domain , the minimal set problem consists in determining all the sets of @xmath8 which are minimal for the inclusion . while it has received much attention ( see section  [ subsec : set_pb_reduction ] and the references therein ) , the best known algorithms are only subquadratic time .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    reachability in directed hypergraphs has been defined in different ways in the literature , depending on the context and the applications .",
    "the reachability relation which is discussed here is basically the same as in  @xcite , but is referred to as _ @xmath9-reachability _ in  @xcite .",
    "it precisely captures the logical implication dependencies in horn propositional logic , and also the functional dependencies in the context of relational databases .",
    "some variants of this reachability relation have been introduced , for instance with the additional requirement that every hyperpath has to be provided with a linear ordering over the alternating sequence of its vertices and hyperarcs  @xcite .",
    "these variants are beyond the scope of the paper .",
    "as mentioned above , determining the set of the reachable vertices from a given vertex has been thoroughly studied .",
    "gallo  _ et al .",
    "_   provide a linear time algorithm in  @xcite . in a series of works  @xcite , ausiello  _ et al .",
    "_   introduce online algorithms maintaining the set of reachable vertices , or hyperpaths between vertices , under hyperarc insertions / deletions",
    ".    computing the transitive closure and reduction of a directed hypergraph has also been studied by ausiello  _ et al . _   in  @xcite . in their work ,",
    "reachability relations between sets of vertices are also taken into account , in contrast with our present contribution in which we restrict to reachability relations between vertices .",
    "the notion of transitive reduction in  @xcite is also different from the one discussed here ( section  [ subsec : transitive_reduction ] ) .",
    "more precisely , the transitive reduction of  @xcite rather corresponds to minimal hypergraphs having the same transitive closure ( several minimality properties are studied , including minimal size , minimal number of hyperarcs , _ etc _ ) .",
    "in contrast , we discuss here the transitive reduction of the reachability relation ( as a binary relation over vertices ) and not of the hypergraph itself .",
    "a _ directed hypergraph _ is a pair @xmath10 , where @xmath11 is a set of vertices , and @xmath12 a set of hyperarcs .",
    "a _ hyperarc _",
    "@xmath13 is itself a pair @xmath14 , where @xmath15 and @xmath16 are both non - empty subsets of @xmath11 .",
    "they respectively represent the _ tail _ and the _ head _ of @xmath13 , and are also denoted by @xmath17 and @xmath18 .",
    "note that throughout this paper , the term _",
    "_ will always refer to directed hypergraph(s ) .",
    "the size of a directed hypergraph @xmath19 is defined as @xmath20 ( where @xmath21 denotes the cardinality of any set @xmath22 ) .",
    "given a directed hypergraph @xmath19 and @xmath23 , the vertex @xmath4 is said to be _",
    "reachable _ from the vertex @xmath3 in @xmath24 , which is denoted @xmath25 , if @xmath26 , or there exists a hyperarc @xmath14 such that @xmath27 and all the elements of @xmath15 are reachable from @xmath3 .",
    "this also leads to a notion of hyperpaths : a _ hyperpath _ from @xmath3 to @xmath4 in @xmath24 is a sequence of @xmath28 hyperarcs @xmath29 satisfying @xmath30 for all @xmath31 , with the conventions @xmath32 and @xmath33 .",
    "the hyperpath is said to be _ minimal _ if none of its subsequences is a hyperpath from @xmath3 to @xmath4 .",
    "the _ strongly connected components _ ( sccs for short ) of a directed",
    "hypergraph @xmath24 are the equivalence classes of the relation @xmath34 , defined by @xmath35 if @xmath36 and @xmath37 .",
    "a component @xmath38 is said to be _ terminal _ if for any @xmath39 and @xmath40 , @xmath36 implies @xmath41 .",
    "if @xmath42 is a function from @xmath11 to an arbitrary set , the image of the directed hypergraph @xmath24 by @xmath42 is the hypergraph , denoted @xmath43 , consisting of the vertices @xmath44 ( @xmath40 ) and the hyperarcs @xmath45 ( @xmath46 ) , where @xmath47 .",
    "\\(u ) at ( -2,-1 ) @xmath3 ; ( v ) at ( 0,0 ) @xmath4 ; ( w ) at ( 0,-2 ) @xmath48 ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180 ] ( v ) ; at ( -1,-0.5 ) @xmath52 ; ( v ) edge[simpleedge , out=-90,in=90 ] ( w ) ; at ( -0.5,-1.3 ) @xmath53 ; ( w ) edge[simpleedge , out=-120,in=-60 ] ( u ) ; at ( -1.5,-2.5 ) @xmath54 ; at ( 1.75,-0.5 ) @xmath55 ; at ( 2.5,-3.5 ) @xmath56 ; ; ;    consider the directed hypergraph depicted in figure  [ fig : hypergraph ] .",
    "its vertices are @xmath57 , and its hyperarcs @xmath58 , @xmath59 , @xmath60 , @xmath61 , and @xmath62 .",
    "a hyperarc is represented as a bundle of arcs , and is decorated with a solid disk portion when its tail contains several vertices .    applying the recursive definition of reachability from the vertex @xmath3 discovers the vertices @xmath4 , then @xmath48 , which leads to the two vertices @xmath49 and @xmath50 through the hyperarc @xmath55 , and finally @xmath51 through @xmath56 .",
    "the vertex @xmath51 is reachable from @xmath3 through the hyperpath @xmath63 ( which is minimal ) .",
    "as mentioned in section  [ sec : introduction ] , some vertices play the role of   auxiliary  vertices when determining reachability . in our example , establishing that @xmath51 is reachable from @xmath3 requires to establish that @xmath50 is reachable from @xmath3 , while @xmath50 does not reach @xmath51 . such a situation can not occur in directed graphs .",
    "observe that all the notions presented in this section are generalizations of their analogues on directed graphs . indeed",
    ", any digraph @xmath64 ( @xmath65 ) can be equivalently seen as a directed hypergraph @xmath66 .",
    "the reachability relations on @xmath67 and @xmath24 coincide , and @xmath67 and @xmath24 both have the same size .",
    "the notations introduced here will be consequently used for directed graphs as well .",
    "given a directed hypergraph @xmath68 , an hyperarc @xmath46 is said to be _ simple _ when @xmath69 .",
    "such hyperarcs generate a directed graph , denoted by @xmath70 , defined as the couple @xmath71 where @xmath72 .",
    "we first point out a remarkable special case in which the terminal sccs of the directed hypergraph @xmath24 and the digraph @xmath70 are equal .",
    "[ prop : terminal_scc ] let @xmath24 be a directed hypergraph .",
    "every terminal strongly connected component of @xmath70 reduced to a singleton is a terminal strongly connected component of @xmath24 .",
    "besides , if all terminal strongly connected components of @xmath70 are singletons , then @xmath24 and @xmath70 have the same terminal strongly connected components .",
    "assume @xmath19 .",
    "let @xmath73 be a terminal scc of @xmath70 .",
    "suppose that there exists @xmath74 such that @xmath36 .",
    "there is necessarily a hyperarc @xmath75 such that @xmath76 and @xmath77 .",
    "let @xmath78 .",
    "then @xmath79 is an arc of @xmath70 .",
    "since @xmath73 is a terminal scc of @xmath70 , this enforces @xmath80 , which is a contradiction .",
    "hence @xmath73 is a terminal scc of the hypergraph  @xmath24 .",
    "assume that every terminal scc of @xmath70 is a singleton .",
    "let @xmath38 be a terminal scc of @xmath24 , and @xmath39 .",
    "consider @xmath81 a terminal scc of @xmath70 such that @xmath82 .",
    "using the first part of the proof , @xmath81 is a terminal scc of @xmath24 . besides",
    ", @xmath81 is reachable from @xmath38 in @xmath24 .",
    "we conclude that @xmath83 .",
    "the following proposition ensures that , in a directed hypergraph , merging two vertices of a same scc does not alter the reachability relation .",
    "[ prop : collapse ] let @xmath19 be a directed hypergraph , and let @xmath84 such that @xmath85 . consider the function @xmath42 mapping any vertex distinct from @xmath49 and @xmath50 to itself , and both @xmath49 and @xmath50 to a same vertex @xmath86 ( with @xmath87 ) . then @xmath36 if , and only if , @xmath88 .",
    "let @xmath89 .",
    "first assume that @xmath36 , and let us show by induction that @xmath88 .",
    "the case @xmath26 is trivial . if there exists @xmath75 such that @xmath27 and for all @xmath90 , @xmath91 , then @xmath92 by induction , which proves that @xmath44 is reachable from @xmath93 in @xmath43 .",
    "conversely , suppose @xmath88 . if @xmath94 , then either @xmath26 , or the two vertices @xmath3 and @xmath4 belong to @xmath95 . in both cases , @xmath4 is reachable from @xmath3 in @xmath24 .",
    "now suppose that there exists a hyperarc @xmath96 in @xmath43 such that @xmath97 , and for all @xmath90 , @xmath92 .",
    "by induction hypothesis , we know that @xmath91 . if @xmath27 , we obtain the expected result .",
    "if not , @xmath4 necessarily belongs to @xmath98 .",
    "if , for instance , @xmath99 , then @xmath100 . thus @xmath50 is reachable from @xmath3 in @xmath24 , and we conclude by @xmath85 .",
    "it follows that the terminal sccs of @xmath24 and @xmath43 are in one - to - one correspondence .",
    "this property can be straightforwardly extended to the operation of merging several vertices of a same scc simultaneously .",
    "using propositions  [ prop : terminal_scc ] and  [ prop : collapse ] , we now sketch a method which computes the terminal sccs in a directed hypergraph @xmath19 .",
    "it performs several transformations on a hypergraph @xmath101 whose vertices are labelled by subsets of @xmath11 :    ;    each time the _ vertex merging step _",
    "( step  ) is executed , new arcs may appear in the directed graph @xmath102 .",
    "this case is illustrated in figure  [ fig : merging ] . in both sides ,",
    "the arcs of @xmath102 are depicted in solid , and the non - simple arcs of @xmath101 in dotted line .",
    "note that the vertices of @xmath101 contain subsets of @xmath11 , but enclosing braces are omitted for readability . applying",
    "step   from vertex @xmath3 ( left side ) discovers a terminal scc formed by @xmath3 , @xmath4 , and @xmath48 in the directed graph @xmath102 . at step   ( right side ) , the vertices are merged , and the hyperarc @xmath55 is transformed into two graph arcs leaving the new vertex @xmath103 .",
    "the termination of this method is ensured by the fact that the number of vertices in @xmath101 is strictly decreased each time step   is applied .",
    "when the method is terminated , terminal sccs of @xmath101 are all reduced to single vertices , each of them labelled by subsets of @xmath11 .",
    "propositions  [ prop : terminal_scc ] and  [ prop : collapse ] prove that these subsets are precisely the terminal sccs of @xmath24 .",
    "\\(u ) at ( -2,-1 ) @xmath3 node[node distance=3.5ex , left of = u ] @xmath104 ; ( v ) at ( 0,0 ) @xmath4 node[node distance=3.5ex , below left of = v ] @xmath105 ; ( w ) at ( 0,-2 ) @xmath48 node[node distance=3.5ex , below of = w ] @xmath106 ; ( x ) at ( 3.5,-0.25 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 2 \\end{aligned}$ ] ; at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ;    \\(u ) edge[simpleedge , out=90,in=-180 ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90 ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60 ] ( u ) ; ; ;    ( uvw ) at ( 0,-1.5 ) @xmath3 @xmath4 + @xmath48 node[node distance=6ex , left of = uvw ] @xmath104 ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=3.5ex ,",
    "right of = x ] @xmath109 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ; ( uvw ) edge[simpleedge , out=40,in=-180 ] ( x ) ; ( uvw ) edge[simpleedge , out=40,in=120 ] ( y ) ; ;      the sketch given in section  [ subsec : maxscc_principle ] is naturally not optimal ( each vertex can be visited @xmath110 times ) .",
    "we propose to incorporate the vertex merging step directly into an algorithm determining the terminal sccs in directed graphs , in order to gain efficiency .",
    "the resulting algorithm on directed hypergraphs is given in figure  [ fig : maxscc ] .",
    "we suppose that the directed hypergraph @xmath24 is provided with the lists @xmath111 of hyperarcs @xmath13 such that @xmath112 , for each @xmath113 ( these lists can be built in linear time in a preprocessing step ) .",
    "the algorithm consists of a main function which initializes data , and then iteratively calls the function on the vertices which have not been visited yet . following the sketch given in section  [ subsec : maxscc_principle ]",
    ", the function repeats the following three tasks :    it recursively searches a terminal scc in the underlying directed graph @xmath102 , starting from the vertex @xmath3 ,    once a terminal scc is found , it performs a vertex merging step on it ,    and finally , it discovers the new graph arcs ( if any ) arising from the merging step .    before discussing each of these three operations ,",
    "we explain how the directed hypergraph @xmath101 is manipulated by the algorithm .",
    "observe that the vertices of the hypergraph @xmath101 always form a partition of the initial set @xmath11 of vertices . instead of referring to them as subsets of @xmath11",
    ", we use a union - find structure , which consists in three functions , , and ( see  ( * ? ? ?",
    "* chapter  21 ) for instance ) . a call to @xmath114 returns , for each original vertex @xmath113 , the unique vertex of the hypergraph @xmath101 containing @xmath3 .",
    "two vertices @xmath115 and @xmath116 of @xmath101 can be merged by a call to @xmath117 , which returns the new vertex .",
    "finally , the `` singleton '' vertices @xmath73 of the initial instance of the hypergraph @xmath101 are created by the function @xmath118 . in practice , each vertex of @xmath101 is encoded as a representative element @xmath113 , in which case the vertex corresponds to the subset @xmath119 . in other words ,",
    "the hypergraph @xmath101 is precisely the image of @xmath24 by the function @xmath120 . to avoid confusion ,",
    "we denote the vertices of the hypergraph @xmath24 by lower case letters , and the vertices of @xmath101 ( and subsequently @xmath102 ) by capital ones . by convention ,",
    "if @xmath113 , @xmath121 will correspond to the associated capital letter  @xmath115 .",
    "[ [ discovering - terminal - sccs - in - the - directed - graph - mathsfgraphmathcalh_mathitcur ] ] discovering terminal sccs in the directed graph @xmath122 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this task is performed by the parts of the algorithm which are not shaded in gray . similarly",
    "to tarjan s algorithm  @xcite , it uses a stack @xmath22 and two arrays indexed by vertices , @xmath123 and @xmath124 .",
    "the stack @xmath22 stores the vertices @xmath115 of @xmath102 which are currently visited by @xmath125 .",
    "the array @xmath123 tracks the order in which the vertices are visited , _",
    "i.e. _  @xmath126 < { \\mathit{index}}[v]$ ] if , and only if , @xmath115 has been visited by before @xmath116 .",
    "the value @xmath127 $ ] is used to determine the minimal index of the visited vertices which are reachable from @xmath115 ( see line  [ scc : min ] ) .",
    "a ( non necessarily terminal ) strongly connected component @xmath38 of @xmath102 is discovered when a vertex @xmath115 satisfies @xmath127 = { \\mathit{index}}[u]$ ] ( line  [ scc : root ] ) .",
    "then @xmath38 consists of all the vertices stored in the stack @xmath22 above @xmath115 .",
    "the vertex @xmath115 is the element of the scc which has been visited first , and is called its _",
    "root_. once the visit of the scc is terminated , its vertices are collected in a set @xmath128 ( line  [ scc : finished ] ) .",
    "additionally , the algorithm uses an array @xmath129 of booleans , allowing to track whether a scc of @xmath102 is terminal .",
    "a scc is terminal if , and only if , its root @xmath115 satisfies @xmath130 = \\true$ ] . in particular , the boolean @xmath130 $ ]",
    "is set to @xmath131 as soon as @xmath115 is connected to a vertex @xmath132 located in a distinct scc ( line  [ scc : not_max1 ] ) or satisfying @xmath133 = \\false$ ] ( line  [ scc : not_max2 ] ) .",
    "@xmath134 , @xmath135}$ ] , @xmath136 @xmath137 , @xmath138 @xmath139 \\gets \\nil$ ] @xmath140 \\gets \\nil$ ] @xmath141}$ ] , [ scc : makeset ] [ scc : end_init ] [ scc : begin_main_loop ] [ scc : visit_call ] [ scc : end_main_loop ] local @xmath142[scc : find1 ] , local @xmath143}$][scc : begin ] @xmath126 \\gets n$ ] , @xmath127 \\gets",
    "n$][scc : troot_def ] @xmath144 @xmath130 \\gets \\true$ ] push @xmath115 on the stack @xmath22 [ scc : begin_node_loop ] push @xmath13 on @xmath145[scc : simple_edge ] @xmath146[scc : root_def ] local @xmath147[scc : find2 ] [ scc : root_reach ] @xmath148[scc : counter_increment ] [ scc : counter_reach ] push @xmath13 on stack @xmath149[scc : stack_edge ] [ scc : end_aux ] [ scc : end_node_loop ]    [ scc : begin_edge_loop ] pop @xmath13 from @xmath145 [ scc : begin_edge_loop2 ] local @xmath150[scc : find3 ] [ scc : membership ] @xmath130 \\gets \\false$ ] [ scc : not_max1 ] @xmath127 \\gets \\min({\\mathit{low}}[u],{\\mathit{low}}[w])$ ] [ scc : min ] @xmath130 \\gets { \\mathit{is\\_term}}[u ] \\and { \\mathit{is\\_term}}[w]$ ] [ scc : not_max2 ] [ scc : end_edge_loop2 ] [ scc : end_edge_loop ] [ scc : root ] [ scc : begin2 ] local @xmath151$][scc : begin_node_merging ] pop each @xmath13 from @xmath152 and push it on @xmath145[scc :",
    "push_on_fprime1 ] pop @xmath116 from @xmath22 [ scc : begin_node_merging_loop ] pop each @xmath13 from @xmath153 and push it on @xmath145 [ scc : push_on_fprime2 ] @xmath154[scc : merge ] pop @xmath116 from @xmath22 [ scc : end_node_merging_loop][scc : end_node_merging ] @xmath126 \\gets i$ ] , push @xmath115 on @xmath22[scc : index_redef ] go to line  [ scc : begin_edge_loop][scc : end_node_merging2][scc : goto ] [ scc : begin_non_max_scc_loop ] pop @xmath116 from @xmath22 , add @xmath116 to @xmath128 [ scc : finished ] [ scc : end_non_max_scc_loop ] [ scc : end2 ] [ scc : end ]    \\(t ) + + ( 0ex,2ex ) coordinate ( t ) ; ( b ) + + ( 0ex,-0.5ex ) coordinate ( b ) ; ( l ) + + ( -0.5ex,0ex ) coordinate ( l ) ; ( r ) + + ( 0.5ex,0ex ) coordinate ( r ) ; let 1 = ( l ) , 2 = ( t ) in coordinate ( lt ) at ( 1,2 ) ; let 1 = ( l ) , 2 = ( b ) in coordinate ( lb ) at ( 1,2 ) ; let 1 = ( r ) , 2 = ( t ) in coordinate ( rt ) at ( 1,2 ) ; let 1 = ( r ) , 2 = ( b ) in coordinate ( rb ) at ( 1,2 ) ; ( lt )  ( rt )  ( rb )  ( lb )  cycle ; ( rt ) + + ( -1ex,0ex )  ( rt )  ( rb ) ",
    "+ + ( -1ex,0ex ) ; at ( @xmath155 ) auxiliary data update step ; ( t2 ) + + ( 0ex,-0.5ex ) coordinate ( t2 ) ; ( b2 ) + + ( 0ex,-0.5ex ) coordinate ( b2 ) ; ( l2 ) + + ( -0.5ex,0ex ) coordinate ( l2 ) ; ( r2 ) + + ( 0.5ex,0ex ) coordinate ( r2 ) ; let 1 = ( l2 ) , 2 = ( t2 ) in coordinate ( lt2 ) at ( 1,2 ) ; let 1 = ( l2 ) , 2 = ( b2 ) in coordinate ( lb2 ) at ( 1,2 ) ; let 1 = ( r2 ) , 2 = ( t2 ) in coordinate ( rt2 ) at ( 1,2 ) ; let 1 = ( r2 ) , 2 = ( b2 ) in coordinate ( rb2 ) at ( 1,2 ) ; ( lt2 )  ( rt2 )  ( rb2 )  ( lb2 )  cycle ; ( rt2 ) + + ( -1ex,0ex ) ",
    "( rt2 )  ( rb2 )  + + ( -1ex,0ex ) ; at ( @xmath156 ) vertex merging step ; ( t3 ) + + ( 0ex,-0.5ex ) coordinate ( t3 ) ; ( b3 ) + + ( 0ex,-0.5ex ) coordinate ( b3 ) ; ( l3 ) + + ( -0.5ex,0ex ) coordinate ( l3 ) ; ( r3 ) + + ( 0.5ex,0ex ) coordinate ( r3 ) ; let 1 = ( l3 ) , 3 = ( t3 ) in coordinate ( lt3 ) at ( 1,3 ) ; let 1 = ( l3 ) , 3 = ( b3 ) in coordinate ( lb3 ) at ( 1,3 ) ; let 1 = ( r3 ) , 3 = ( t3 ) in coordinate ( rt3 ) at ( 1,3 ) ; let 1 = ( r3 ) , 3 = ( b3 ) in coordinate ( rb3 ) at ( 1,3 ) ; ( lt3 )  ( rt3 ) ",
    "( rb3 )  ( lb3 )  cycle ; ( t6 ) + + ( 0ex,-0.5ex ) coordinate ( t6 ) ; ( b6 ) + + ( 0ex,-0.5ex ) coordinate ( b6 ) ; ( l6 ) + + ( -0.5ex,0ex ) coordinate ( l6 ) ; ( r6 ) + + ( 0.5ex,0ex ) coordinate ( r6 ) ; let 1 = ( l6 ) , 3 = ( t6 ) in coordinate ( lt6 ) at ( 1,3 ) ; let 1 = ( l6 ) , 3 = ( b6 ) in coordinate ( lb6 ) at ( 1,3 ) ; let 1 = ( r6 ) , 3 = ( t6 ) in coordinate ( rt6 ) at ( 1,3 ) ; let 1 = ( r6 ) , 3 = ( b6 ) in coordinate ( rb6 ) at ( 1,3 ) ; ( lt6 )  ( rt6 )  ( rb6 )  ( lb6 )  cycle ;    [ [ vertex - merging - step ] ] vertex merging step + + + + + + + + + + + + + + + + + + +    this step is performed from lines  [ scc : begin_node_merging ] to  [ scc : end_node_merging2 ] , when it is discovered that the vertex @xmath157 is the root of a terminal scc in the digraph @xmath102 .",
    "all vertices @xmath116 which have been collected in that scc are merged to @xmath115 ( line  [ scc : merge ] ) .",
    "let @xmath158 be the resulting hypergraph .    at line  [ scc : end_node_merging2 ] ,",
    "the stack @xmath145 is expected to contain the new arcs of the directed graph @xmath159 leaving the newly `` big '' vertex @xmath115 ( this point will be explained in the next paragraph ) .",
    "if @xmath145 is empty , the singleton @xmath160 constitutes a terminal scc of @xmath159 , hence also of @xmath158 ( proposition  [ prop : terminal_scc ] ) .",
    "otherwise , we go back to line  [ scc : begin_edge_loop ] to discover terminal sccs from the new vertex @xmath115 in the digraph @xmath159 .    [ [ discovering - the - new - graph - arcs ] ] discovering the new graph arcs + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in this paragraph , we explain informally how the new graph arcs arising after a vertex merging step can be efficiently discovered without examining all the hyperarcs . the formal proof of this technique is provided in appendix  [ sec : correctness_proof ] .    during the execution of , the local stack @xmath145 is used to collect the hyperarcs which represent arcs leaving the vertex @xmath121 in @xmath102 .",
    "initially , when is called , the vertex is still equal to @xmath3",
    ". then , the loop from lines  [ scc : begin_node_loop ] to  [ scc : end_node_loop ] iterates over the set @xmath111 of the hyperarcs @xmath46 such that @xmath112 . at the end of the loop",
    ", it can be verified that @xmath145 is indeed filled with all the simple hyperarcs leaving @xmath161 in @xmath101 , as expected ( see line  [ scc : simple_edge ] ) .",
    "the main difficulty is to collect in @xmath145 the arcs which are added to the digraph @xmath102 after a vertex merging step . to this aim , each non - simple hyperarc @xmath46",
    "is provided with two auxiliary data :    * a vertex @xmath162 , called the _",
    "root _ of the hyperarc @xmath13 , which is defined as the first vertex of the tail @xmath17 to be visited by a call to , * a counter @xmath163 , which determines the number of vertices @xmath164 which have been visited and such that @xmath165 is reachable from @xmath166 in the current digraph @xmath102 .",
    "these auxiliary data are maintained in the _ auxiliary data update step _ , located from lines  [ scc : root_def ] to  [ scc : end_aux ] .",
    "initially , the root @xmath162 of any hyperarc @xmath13 is set to the special value @xmath167 . the first time a vertex @xmath3 such that @xmath168 is visited , @xmath162 is assigned to @xmath3 ( line  [ scc : root_def ] ) . besides , at the call to , the counter @xmath169 of each non - simple hyperarc @xmath168 is incremented , but only when @xmath170 belongs to the stack @xmath22 ( line  [ scc : counter_increment ] ) .",
    "this is indeed a necessary and sufficient condition to the fact that @xmath121 is reachable from @xmath171 in the digraph @xmath102 ( see invariant  [ inv : call_to_visit3 ] in appendix  [ sec : correctness_proof ] ) .",
    "it follows from these invariants that , when the counter @xmath169 reaches the threshold value @xmath172 , all the vertices @xmath173 , for @xmath164 , are reachable from @xmath174 in the digraph @xmath102 .",
    "now suppose that , later , it is discovered that @xmath174 belongs to a terminal strongly connected component @xmath38 of @xmath102 .",
    "then the aforementioned vertices @xmath175 must all stand in the component @xmath38 ( since it is terminal ) .",
    "therefore , when the vertex merging step is applied on this scc , the vertices @xmath175 are merged into a single vertex @xmath115 .",
    "hence , the hyperarc @xmath13 necessarily generates new simple arcs leaving @xmath115 in the new version of the digraph @xmath102 .",
    "let us verify that in this case , @xmath13 is correctly placed into @xmath145 by our algorithm .",
    "as soon as @xmath169 reaches the value @xmath172 , the hyperarc @xmath13 is placed into a temporary stack @xmath149 associated to the vertex @xmath174 ( line  [ scc : stack_edge ] ) .",
    "this stack is then emptied into @xmath145 during the vertex merging step , at lines  [ scc : push_on_fprime1 ] or  [ scc : push_on_fprime2 ] .    in the left side of figure  [ fig : merging ] , the execution of the loop from lines  [ scc : begin_node_loop ] to  [ scc : end_node_loop ] during the call to sets the root of the hyperarc @xmath55 to the vertex @xmath4 , and @xmath176 to @xmath105 .",
    "then , during , @xmath176 is incremented to @xmath177 .",
    "the hyperarc @xmath55 is therefore pushed on the stack @xmath178 ( because @xmath179 ) . once it is discovered that @xmath3 , @xmath4 , and @xmath48 form a terminal scc of @xmath102 , @xmath55 is collected into @xmath145 during the merging step .",
    "it then allows to visit the vertices @xmath49 and @xmath50 from the new vertex ( rightmost hypergraph ) .",
    "a fully detailed execution trace is provided in appendix  [ sec : execution_trace ] below .",
    "[ [ correctness - and - complexity ] ] correctness and complexity + + + + + + + + + + + + + + + + + + + + + + + + + +    for the sake of simplicity , we have not included in the step returning the terminal sccs .",
    "however , they can be easily built by examining each vertex ( hence in time @xmath110 ) , as shown below :    [ th : correctness ] let @xmath19 be a directed hypergraph .",
    "after the execution of , the terminal strongly connected components of @xmath24 are precisely the sets @xmath180 = \\true \\}$ ] .",
    "the proof of theorem  [ th : correctness ] , which is too long to be included here , is provided in appendix  [ sec : correctness_proof ] .",
    "it relies on successive transformations of intermediary algorithms to .",
    "when using disjoint - set forests with union by rank and path compression as union - find structure ( see  ( * ? ? ?",
    "* chapter 21 ) ) , the time complexity of any sequence of @xmath28 operations , , or is known to be @xmath181 , where @xmath1 is the very slowly growing inverse of the ackermann function . the following result states that the algorithm is also almost linear time :    [ th : complexity ] let @xmath19 be a directed hypergraph . then the algorithm terminates in time @xmath182 , and has linear space complexity .",
    "the analysis of the time complexity depends on the kind of the instructions .",
    "we distinguish :    the operations on the global stacks @xmath183 and on the local stacks @xmath145 ,    the call to the functions , , and ,    and the other operations , referred to as _",
    "usual operations _",
    "( by extension , their time complexity will be referred to as _ usual complexity _ ) .    the complexity of each kind of operations is respectively described in the following three paragraphs .",
    "each operation on a stack ( pop or push ) is performed in @xmath184 .",
    "a hyperarc @xmath13 is pushed on a stack of the form @xmath183 at most once during the whole execution of ( when counter @xmath169 reaches the value @xmath172 ) .",
    "once it is popped from it , it will never be pushed on a stack of the form @xmath185 again .",
    "similarly , a hyperarc is pushed on a local stack @xmath145 at most once , and after it is popped from it , it will never be pushed on any local stack @xmath186 in the following states . therefore , the total number of stack operations on the local and global stacks @xmath145 and @xmath183 is bounded by @xmath187 .",
    "it follows that the corresponding complexity is bounded by @xmath188 .",
    "the same argument proves that the total number of iterations of the loop from lines  [ scc : begin_edge_loop2 ] to  [ scc : end_edge_loop2 ] occurring in a complete execution of is bounded by @xmath189 .    during the execution of , the function",
    "is called exactly @xmath190 times at line  [ scc : find1 ] , at most @xmath191 times at line  [ scc : find2 ] , and at most @xmath189 times at line  [ scc : find3 ] ( see above ) .",
    "hence it is called at most @xmath192 times .",
    "the function is always called to merge two distinct vertices .",
    "let @xmath193 ( @xmath194 ) be the equivalence classes formed by the elements of @xmath11 at the end of the execution of .",
    "then is called at most @xmath195 . since @xmath196 , is executed at most @xmath197 times .",
    "finally , is called exactly @xmath190 times .",
    "it follows that the total time complexity of the operations , and is @xmath182 .",
    "the analysis of the usual operations is split into several parts :    * the usual complexity of without the calls to the function is clearly @xmath198 . * during the execution of , the usual complexity of the block from lines  [ scc : begin ] to  [ scc : end_node_loop ] is @xmath199 .",
    "indeed , we suppose that the test at line  [ scc : root_reach ] can be performed in @xmath184 by assuming that the stack @xmath22 is provided with an auxiliary array of booleans which determines , for each element of @xmath11 , whether it is stored in @xmath22 ( obviously , the push and pop operations are still in @xmath184 under this assumption ) .",
    "then the total usual complexity between lines  [ scc : begin ] and  [ scc : end_node_loop ] is @xmath188 for a complete execution of . * the usual complexity of the loop body from lines  [ scc : begin_edge_loop2 ] to  [ scc : end_edge_loop2 ] , without the recursive calls to , is clearly @xmath184 ( the membership test at line  [ scc : membership ] is supposed to be in @xmath184 , encoding the set @xmath128 as an array of @xmath190 booleans ) .",
    "this inner loop is iterated @xmath200 times during each iteration of the outer loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] . since a hyperarc",
    "is placed in a local stack @xmath145 at most once , the total usual complexity of the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] ( without the recursive calls to ) is bounded by @xmath188 . *",
    "the usual complexity of the loop between lines  [ scc : begin_node_merging_loop ] and  [ scc : end_node_merging_loop ] for a complete execution of is @xmath110 , since in total , it is iterated exactly the number of times the function is called . *",
    "the usual complexity of the loop between lines  [ scc : begin_non_max_scc_loop ] and  [ scc : end_non_max_scc_loop ] for a whole execution of is @xmath110 , because a given element is placed at most once into the set @xmath128 ( adding an element in @xmath128 is in @xmath184 ) . *",
    "if the previous two loops are not considered , less than @xmath201 usual operations are executed in the block from lines  [ scc : begin2 ] to  [ scc : end ] , all of complexity @xmath184 .",
    "the execution of this block either follows a call to or the execution of the goto statement ( at line  [ scc : goto ] ) .",
    "the latter is executed only if the stack @xmath145 is not empty . since each hyperarc",
    "can be pushed on a local stack @xmath145 and then popped from it only once , it happens at most @xmath202 times during the whole execution of .",
    "it follows that the usual complexity of the block from lines  [ scc : begin2 ] to  [ scc : end ] is @xmath198 in total ( excluding the loops previously discussed ) .",
    "summing all the complexities above proves that the time complexity of is @xmath182 .",
    "the space complexity is obviously linear in @xmath192 .",
    "an implementation is provided in the library  tplib  @xcite , in the module ` hypergraph ` .",
    "the algorithm is not able to determine all strongly connected components in directed hypergraphs .",
    "consider the following example :    \\(u ) at ( 0 , 0 ) @xmath3 ; ( t ) at ( 0 , -1.5 ) @xmath48 ;    \\(x ) at ( 2.3 , -0.75 ) @xmath4 ;    \\(u ) edge[simpleedge , out=-110,in=110 ] ( t ) ;    \\(x ) edge[simpleedge , out=120,in=0 ] ( u ) ;    ; at ( 1,-1 ) @xmath13 ;    our algorithm determines the unique terminal scc , which is reduced to the vertex @xmath48 .",
    "however , the non - terminal scc formed by @xmath3 and @xmath4 is not discovered .",
    "indeed , the non - simple hyperarc @xmath13 , which allows to reach @xmath4 from @xmath3 , can not be transformed into a simple arc , since @xmath3 and @xmath4 do not belong to a same scc of the underlying digraph .",
    "some properties can be directly determined from the terminal sccs .",
    "indeed , a directed hypergraph @xmath24 admits a sink ( _ i.e. _  a vertex reachable from all vertices ) if , and only if , it contains a unique terminal scc . besides , strong connectivity amounts to the existence of a terminal scc containing all the vertices .",
    "[ cor : strongly_connectivity_and_sink ] given a directed hypergraph @xmath24 , the following problems can be solved in almost linear time in @xmath192 :    [ item : i ] is there a sink in @xmath24 ?",
    "[ item : ii ] is @xmath24 strongly connected ?",
    "we now discuss some applications of these results .",
    "[ [ tropical - geometry ] ] tropical geometry + + + + + + + + + + + + + + + + +    tropical polyhedra are the analogues of convex polyhedra in _ tropical algebra _ , _",
    "i.e. _  the semiring @xmath203 endowed with the operations @xmath204 and @xmath205 as addition and multiplication .",
    "a _ tropical polyhedron _ is the set of the solutions @xmath206 of finitely many tropical affine inequalities , of the form : @xmath207 where @xmath208 .",
    "analogously to classical convex polyhedra , any tropical polyhedron can be equivalently expressed as the convex hull ( in the tropical sense ) of a set of vertices and extreme rays .",
    "this yields the problem of computing the vertices of a tropical polyhedron , which can be seen as the `` tropical counterpart '' of the well - studied vertex enumeration problem in computational geometry .",
    "this problem has various applications in computer science and control theory , among others , in the analysis of discrete event systems  @xcite , software verification  @xcite , and verification of real - time systems  @xcite",
    ".    directed hypergraphs and their terminal sccs arise in the characterization of the vertices of a tropical polyhedron . in a joint work of the author with gaubert and goubault  @xcite",
    ", it has been proved that a point @xmath206 of a tropical polyhedron @xmath209 is a vertex if , and only if , a certain directed hypergraph associated to @xmath49 and built from the inequalities defining @xmath209 , admits a sink .",
    "this combinatorial criterion plays a crucial role in the tropical vertex enumeration problem .",
    "it is indeed involved in an algorithm called _ tropical double description method _",
    "@xcite , in order to eliminate points which are not vertices , among a set of candidates .",
    "this set can be very large ( exponential in the dimension @xmath2 ) , so the efficiency of the elimination step is critical .",
    "the almost linear time algorithm consequently leads to a significant improvement over the state - of - the - art , both in theory and in practice ( see  ( * ? ? ?",
    "* section  6 ) ) .",
    "it also allows to show the surprising result that it is easier to determine whether a point is a vertex in a tropical polyhedron than in a classical one ( if @xmath28 is the number of inequalities defining the polyhedron , the latter problem can be solved in @xmath210 while the former in @xmath211 ) .",
    "[ [ nonlinear - spectral - theory ] ] nonlinear spectral theory + + + + + + + + + + + + + + + + + + + + + + + + +    problem   appears in a generalization of the perron - frobenius theorem to homogeneous and monotone functions studied by gaubert and gunawardena in  @xcite .",
    "recall that a function @xmath212 is said to be _ monotone _",
    "when @xmath213 for any @xmath214 such that @xmath215 ( the relation @xmath216 being understood entrywise ) , and that it is _ homogeneous _",
    "when @xmath217 for all @xmath218 and @xmath219 .",
    "a central problem is to give conditions under which @xmath42 admits an eigenvector in the cone @xmath220 , _",
    "i.e. _  a vector @xmath219 such that @xmath221 for some @xmath222 . gaubert and gunawardena establish a sufficient combinatorial condition  ( * ? ? ?",
    "* theorem  6 ) expressed as the strong connectivity of a directed graph obtained as the limit of a sequence of graphs .",
    "this sequence is identical to the one arising during the execution of the method sketched in section  [ subsec : maxscc_principle ] .",
    "it follows that the sufficient condition is equivalent to the strong connectivity of a directed hypergraph @xmath223 constructed from @xmath42 .",
    "the hypergraph @xmath223 consists of the vertices @xmath224 and the hyperarcs @xmath225 such that @xmath226 ( @xmath227 denotes the vector whose @xmath228-th entry is equal to @xmath105 when @xmath229 , and @xmath104 otherwise ) .",
    "[ [ horn - propositional - logic ] ] horn propositional logic + + + + + + + + + + + + + + + + + + + + + + + +    as mentioned in section  [ sec : introduction ] , directed hypergraphs can be used to encode horn formulas .",
    "recall that a _ horn formula _ @xmath145 over the propositional variables @xmath230 is a conjunction of _ horn clauses _ , _ i.e. _     either an implication @xmath231 ,    or a fact @xmath232 ,    or a goal @xmath233 .",
    "given a propositional formula @xmath145 , an assignment @xmath234 is a _ model _ of @xmath145 if replacing each @xmath232 by its associated truth value @xmath235 yields a true assertion .",
    "if @xmath236 are two propositional formulas , @xmath237 is said to _ entail _ @xmath238 , which is denoted by @xmath239 , if every model of @xmath237 is a model of @xmath238 .",
    "a directed hypergraph @xmath240 can be associated to any horn formula @xmath145 so as to decide entailment of implications over its variables .",
    "we use the construction developed by ausiello and italiano  @xcite .",
    "the hypergraph @xmath240 consists of the vertices @xmath241 and the following hyperarcs : @xmath242 for every implication @xmath231 in @xmath145 , @xmath243 for every fact @xmath232 , @xmath244 for every goal @xmath233 , @xmath245 , and @xmath246 for all @xmath247 .",
    "observe that the size of @xmath240 is linear in the size of the formula @xmath145 , _",
    "i.e. _  the number of atoms in its clauses ( without loss of generality , it is assumed that every variable occurs in @xmath145 ) .",
    "[ lemma : horn ] let @xmath145 be a horn formula over the variables @xmath230 .",
    "then @xmath248 if , and only if , @xmath249 is reachable from @xmath228 in the directed hypergraph @xmath240 .    the `` if '' part can be shown by induction .",
    "if @xmath250 , this is obvious .",
    "otherwise , there exists a hyperarc @xmath14 such that @xmath251 and every element of @xmath15 is reachable from @xmath228 .",
    "three cases can be distinguished :    * if @xmath15 is not equal to @xmath252 or @xmath253 , then by construction , @xmath145 contains the implication @xmath254 . for all @xmath255 , @xmath256 by induction , so that @xmath248 . * if @xmath257 , then @xmath258 is a fact , and @xmath248 trivially holds . *",
    "if @xmath15 is reduced to @xmath253 , there is a goal @xmath259 in @xmath145 such that each @xmath260 is reachable from @xmath228 , hence @xmath261 .",
    "as @xmath145 also entails the implication @xmath262 , we conclude that @xmath248 .    for the `` only if '' part , let @xmath263 be the set of reachable vertices from @xmath228 in @xmath240 , and assume that @xmath264 .",
    "let @xmath265 be the assignment defined by @xmath266 if @xmath267 , @xmath131 otherwise .",
    "we claim that @xmath265 models @xmath145 .",
    "consider an implication @xmath268 in @xmath145 .",
    "if @xmath269 for all @xmath270 , then @xmath271 is reachable from @xmath228 in @xmath240 , hence @xmath266 , and the implication is valid on @xmath265 .",
    "similarly , for each fact @xmath272 in @xmath145 , @xmath271 obviously belongs to @xmath263 , which ensures that @xmath266 . finally , if @xmath145 contains a goal @xmath259 such that @xmath269 for all @xmath270 , then every vertex of the hypergraph is reachable from @xmath228 ( through the vertex @xmath273 ) , which is impossible ( @xmath264 ) .",
    "this completes the proof .",
    "corollary  [ cor : strongly_connectivity_and_sink ] and lemma  [ lemma : horn ] consequently prove that the two following decision problems over horn formulas can be solved in almost linear time :    whether a variable of a horn formula is implied by all the others ,    whether all variables of a horn formula are equivalent .",
    "given a directed graph or a directed hypergraph , the reachability relation can be represented by the set of the couples @xmath274 such that @xmath49 reaches @xmath50 .",
    "this is however a particularly redundant representation because of transitivity . in order to get a better idea of the intrinsic complexity of the reachability relation",
    ", we should rather consider transitive reductions , which are defined as minimal binary relations having the same transitive closure .    in directed graphs , aho  _ et al .",
    "_   have shown in  @xcite that all transitive reductions of the reachability relation have the same size ( the size of a binary relation @xmath275 is the number of couples @xmath274 such that @xmath276 ) .",
    "this size is bounded by the size of the digraph .",
    "furthermore , a canonical transitive reduction can be defined by choosing a total ordering over the vertices .    in",
    "directed hypergraphs , the existence of a canonical transitive reduction of the reachability relation can be similarly established , because reachability is still reflexive and transitive . can be seen as the reachability relation of a directed graph @xmath67 , whose arcs are the couples @xmath274 such that @xmath276 , @xmath277",
    ". then the transitive reduction of @xmath275 is defined as in  @xcite .",
    "] however , we are going to show that its size is superlinear in @xmath192 for some directed hypergraphs @xmath24 .",
    "these hypergraphs arise from the subset partial order .",
    "more specifically , given a family @xmath8 of distinct sets over a finite domain @xmath278 , the partial order induced by the relation @xmath279 on @xmath8 is called _ the subset partial order _ over @xmath8 . without loss of generality ,",
    "we assume that every set @xmath22 of @xmath8 satisfies @xmath280 ( up to adding two fixed elements @xmath281 to all sets , which does not change the partial order over @xmath8 ) . from this family",
    ", we build a corresponding directed hypergraph @xmath282 .",
    "each of its vertices is either associated to a set @xmath283 or to a domain element @xmath284 , and is denoted by @xmath285 $ ] or @xmath286 $ ] respectively . besides , each set @xmath22 is associated to two hyperarcs @xmath287 $ ] and @xmath288 $ ] . the hyperarc @xmath287 $ ] leaves the singleton @xmath289\\}$ ] and enters the set of the vertices @xmath286 $ ] such that @xmath290 . the hyperarc @xmath288 $ ] is defined inversely , leaving the latter set and entering @xmath289\\}$ ] .",
    "an example is given in figure  [ fig : subset_hypergraph ] .",
    "( x1 ) at ( 0,1.5 ) @xmath291 $ ] ; ( x2 ) at ( 2,1.5 ) @xmath292 $ ] ; ( x3 ) at ( 2,0 ) @xmath293 $ ] ; ( x4 ) at ( 0,0 ) @xmath294 $ ] ;    ( s1 ) at ( -2,0.75 ) @xmath295 $ ] ; ( s2 ) at ( 4,0.75 ) @xmath296 $ ] ; ( s3 ) at ( 1,3.25 ) @xmath297 $ ] ;    ; ( -1.6,-0.5 ) node[below , lbl ] @xmath298 $ ] ; ; ( -1.2,0.8 ) node[above , lbl ] @xmath299 $ ] ; ; ( 3.6,-0.5 ) node[below , lbl ] @xmath300 $ ] ; ; ( 3.2,0.8 ) node[above , lbl ] @xmath301 $ ] ; ; ( 0,2.5 ) node[right , lbl ] @xmath302 $ ] ; ; ( 2,2.5 ) node[left , lbl ] @xmath303 $ ] ;    [ lemma : reachable ] given @xmath283 , @xmath4 is reachable from @xmath285 $ ] in @xmath282 if , and only if , @xmath304 $ ] for some @xmath305 such that @xmath306 , or @xmath307 $ ] for some @xmath290 .",
    "clearly , any vertex @xmath286 $ ] is reachable from @xmath285 $ ] through the hyperarc @xmath287 $ ] . besides",
    ", assuming @xmath308 , then @xmath285 $ ] reaches @xmath309 $ ] through the hyperpath formed by the hyperarcs @xmath287 $ ] and @xmath310 $ ] .",
    "now , let us prove by induction that these are the only vertices reachable from @xmath285 $ ] .",
    "let @xmath3 be reachable from @xmath285 $ ] .",
    "if @xmath311 $ ] , then this is obvious .",
    "otherwise , there exists a hyperarc @xmath312 such that @xmath313 and @xmath314 with each @xmath315 being reachable from @xmath285 $ ] .",
    "we can distinguish two cases :    a.   either @xmath13 is of the form @xmath316 $ ] for some @xmath305 , in which case the tail is reduced to the vertex @xmath309 $ ] , which is reachable from @xmath285 $ ] . by induction , we know that @xmath308 . since @xmath317 $ ] for some @xmath318 , it follows that @xmath290 .",
    "b.   or @xmath13 is of the form @xmath310 $ ] for some @xmath305 .",
    "then its tail is the set of the @xmath286 $ ] for @xmath318 , and its head consists of the single vertex @xmath309 $ ] .",
    "thus @xmath290 for all @xmath318 by induction , which ensures that @xmath319 $ ] with @xmath306 .",
    "[ prop : transitive_reduction_lower_bound ] the size of the transitive reduction of the reachability relation of @xmath282 is lower bounded by the size of the transitive reduction of the subset partial order over the family @xmath8 .",
    "we claim that for any couple @xmath320 in the transitive reduction of the subset partial order over the family @xmath8 , @xmath321,v[s])$ ] belongs to the transitive reduction of the relation @xmath322 .",
    "suppose that the pair @xmath321,v[s])$ ] is not in transitive reduction of @xmath322 , and that @xmath323 ( the case @xmath324 is obvious ) .",
    "by lemma  [ lemma : reachable ] , @xmath285 $ ] is reachable from @xmath309 $ ] .",
    "besides , there exists a vertex @xmath3 of @xmath282 distinct from @xmath285 $ ] and @xmath309 $ ] such that @xmath309 { { \\rightsquigarrow}}_{{\\mathcal{h}}({\\mathcal{f}},d ) } u { { \\rightsquigarrow}}_{{\\mathcal{h}}({\\mathcal{f}},d ) } v[s]$ ] .",
    "observe that any vertex reaching a vertex of the form @xmath325 $ ] ( @xmath326 ) is necessarily of the form @xmath327 $ ] for some @xmath328 ( because of the assumption @xmath329 which ensures that no vertex of the form @xmath286 $ ] for @xmath284 can reach @xmath325 $ ] ) .",
    "consequently , there exists a set @xmath330 ( distinct from @xmath22 and @xmath331 ) such that @xmath332 $ ] .",
    "following lemma  [ lemma : reachable ] , this shows that @xmath333 .",
    "thus @xmath320 can not belong to the transitive reduction of the subset partial order over @xmath8 .",
    "the subset partial order has been well studied in the literature  @xcite .",
    "it has been proved in  @xcite that the size of the transitive reduction of the subset partial order can be superlinear in the size of the input @xmath334 ( defined as @xmath335 ) . combining this with proposition  [ prop : transitive_reduction_lower_bound ] provides the following result :    [ th : transitive_reduction_lower_bound ] there is a directed hypergraph @xmath24 such that the size of the transitive reduction of the reachability relation is in @xmath336 .",
    "we use the construction given in  @xcite in which @xmath8 consists of two disjoint families @xmath337 and @xmath338 of sets over the domain @xmath339 ( where @xmath2 is supposed to be divisible by 4 ) .",
    "the first family consists of the subsets having @xmath340 elements among @xmath341 .",
    "the second family is formed by the subsets containing all the elements @xmath341 , and precisely @xmath340 elements among @xmath342 .",
    "the transitive reduction of the subset partial order over @xmath8 coincides with the cartesian product @xmath343 .",
    "each @xmath344 precisely contains @xmath345 sets , so that the size of the transitive reduction of the subset partial order is @xmath346 .",
    "proposition  [ prop : transitive_reduction_lower_bound ] shows that the size of the transitive reduction of  @xmath322 is in @xmath347 .",
    "now , the size of the directed hypergraph @xmath282 is equal to : @xmath348 so that @xmath349 .",
    "this provides the expected result .",
    "the size of the transitive relation of the reachability relation can be seen as a partial measure of the complexity of the scc computation problem .",
    "it is indeed natural to think at algorithms computing the sccs by following the reachability relation between them , for instance by a depth - first search , hence by exploring at least a transitive reduction of the reachability relation .",
    "in fact , most of the algorithms determining sccs of directed graphs , for instance the ones due to tarjan  @xcite , cheriyan and mehlhorn  @xcite , or gabow  @xcite , perform a depth - first search on the entire graph , and thus follow this approach .",
    "theorem  [ th : transitive_reduction_lower_bound ] shows that this class of algorithms can not have a linear complexity on directed hypergraphs :    [ cor : scc_lower_bound ] any algorithm computing the strongly connected components of directed hypergraphs by traversing an entire transitive reduction of the reachability relation has a worst case complexity at least equal to @xmath350 , where @xmath6 is the size of the input .",
    "consequently , the reachability relation must be sufficiently explored to identify the sccs , but it can not be totally explored unless sacrificing the time complexity .",
    "note that the algorithm relies on a certain trade - off to discover terminal sccs : it only traverses hyperarcs @xmath14 such that @xmath15 is contained in a scc , whereas hyperarcs in which the tail vertices belong to distinct sccs are ignored .",
    "given a family @xmath8 of distinct sets over a domain @xmath278 as above , the _ minimal set problem _ consists in finding all minimal sets @xmath283 for the subset partial order .",
    "this problem has received much attention  @xcite .",
    "it has important applications in propositional logic  @xcite or data mining  @xcite .",
    "it can also be seen as a boolean case of the problem of finding maximal vectors among a given family  @xcite .",
    "surprisingly , the most efficient algorithms addressing the minimal set problem compute the whole subset partial order  @xcite . the best known methods to compute the subset partial order in the general case are due to pritchard  @xcite .",
    "their complexity are in @xmath351 , where @xmath6 is the size of the input @xmath334 . in the dense case , _",
    "i.e. _  when the size of the family is in @xmath352 , elmasry defined a method with a complexity in @xmath353  @xcite .",
    "this matches the lower bound provided in corollary  [ cor : scc_lower_bound ] .    in this section ,",
    "we establish a linear time reduction from the minimal set problem to the problem of computing the sccs in directed hypergraph . to obtain it ,",
    "we build a directed hypergraph @xmath354 starting from the hypergraph @xmath282 . on top of the vertices of the latter",
    ", @xmath354 has the following vertices :    for each @xmath283 , an additional vertex @xmath355 $ ] ,    @xmath356 vertices labelled by @xmath357 ,    and a special vertex labelled by @xmath358 .    besides",
    ", we add the following hyperarcs :    for each @xmath283 , a hyperarc leaving @xmath289\\}$ ] and entering the singleton @xmath359 ,    for every @xmath360 , a hyperarc leaving @xmath361 and entering the set of the vertices @xmath355 $ ] such that @xmath362 ,    for each @xmath363 , a hyperarc from @xmath361 to @xmath364 ,    for each @xmath283 , a hyperarc leaving the set @xmath289,w[s]\\}$ ] and entering the singleton @xmath365 ,    for every @xmath283 , a hyperarc from @xmath365 to @xmath289\\}$ ] .",
    "this construction is illustrated in figure  [ fig : minimal_subset_hypergraph ] .",
    "( x1 ) at ( 0,1.5 ) @xmath291 $ ] ; ( x2 ) at ( 2,1.5 ) @xmath292 $ ] ; ( x3 ) at ( 2,0 ) @xmath293 $ ] ; ( x4 ) at ( 0,0 ) @xmath294 $ ] ;    ( s1 ) at ( -2,0.75 ) @xmath295 $ ] ; ( s2 ) at ( 4,0.75 ) @xmath296 $ ] ; ( s3 ) at ( 1,3.25 ) @xmath297 $ ] ;    ( superset ) at ( -2.75,3.5 ) @xmath358 ;    ; ; ; ; ; ; ;    ( w1 ) at ( -3.5,0.75 ) @xmath366 $ ] ; ( w2 ) at ( 5.5,0.75 ) @xmath367 $ ] ; ( w3 ) at ( 2.5,3.25 ) @xmath368 $ ] ;    ( c0 ) at ( -2,-2 ) @xmath369 ; ( c1 ) at ( -0.5,-2 ) @xmath370 ; ( c2 ) at ( 1,-2 ) @xmath371 ; ( c3 ) at ( 2.5,-2 ) @xmath372 ; ( c4 ) at ( 4,-2 ) @xmath373 ;    ( c4 )  ( c3 ) ; ( c3 ) ",
    "( c2 ) ; ( c2 )  ( c1 ) ; ( c1 )  ( c0 ) ; ( s1.240 ) to[out=-80,in=130 ] ( -1.25,-2 ) to[out=-50,in=-120 ] ( c2 ) ; ( s2.-60 ) to[out=-100,in=50 ] ( 3.25,-2 ) to[out=-130,in=-60 ] ( c2 ) ; ; ( s3 ) .. controls ( 1,-1 ) and ( 0,-1.5 ) .. ( c1 ) ; ( c2 ) .. controls ( 1,2.25 ) and ( 2,2.75 ) .. ( w3 ) ; ; ; ; ( superset.-70 ) to[out=-80,in=90 ] ( s1 ) ; ( superset ) to[out=0,in=180 ] ( s3.160 ) ; ( superset.30 ) .. controls ( -1.75,4 ) and ( 4,7 ) .. ( s2 ) ;    [ prop : equivalence ] for any @xmath283 , @xmath22 is not minimal in @xmath8 if , and only if , the vertex @xmath358 is reachable from @xmath285 $ ] in @xmath354 .",
    "assume that @xmath22 is not minimal in @xmath8 , and let @xmath305 satisfying @xmath374",
    ". by lemma  [ lemma : reachable ] , @xmath309 $ ] is reachable from @xmath285 $ ] in @xmath282 , and hence in @xmath354 . since @xmath375 , @xmath376 $ ] is reachable from @xmath285 $ ] through the hyperpath traversing the vertices @xmath377 .",
    "finally , the vertex @xmath358 is reachable through the hyperarc from @xmath378,w[s']\\}$ ] .",
    "conversely , suppose that @xmath285 $ ] reaches @xmath358 in @xmath354 . consider a minimal hyperpath @xmath379 from @xmath285 $ ] to @xmath358 .",
    "necessarily , @xmath380 is a hyperarc of the form @xmath381 , w[s']\\},\\{{\\mathit{superset}}\\})$ ] for some @xmath305 .",
    "consequently , both vertices @xmath309 $ ] and @xmath376 $ ] are reachable from @xmath285 $ ] . besides , to each of the two vertices",
    ", there exists a hyperpath from @xmath285 $ ] , which is a subsequence of @xmath382 , and which consequently does not contain the vertex @xmath358 ( meaning that the latter does not appear in any tail or head of the hyperarcs of the hyperpath ) .",
    "let @xmath383 be a minimal hyperpath from @xmath285 $ ] to @xmath309 $ ] not containing @xmath358 .",
    "the hyperpath can not contain any hyperarc of the form @xmath384 , w[t]\\},\\{{\\mathit{superset}}\\})$ ] ( where @xmath326 ) .",
    "as a result , no vertex of the form @xmath385 $ ] should occur in the hyperpath ( by minimality ) .",
    "similarly , no vertex of the form @xmath386 belongs to the hyperpath ( otherwise , it should also contain a vertex of the form @xmath385 $ ] ) .",
    "it follows that the hyperpath @xmath383 is also a hyperpath in the hypergraph @xmath282 . applying lemma",
    "[ lemma : reachable ] then shows that @xmath306 .",
    "it remains to show that the latter inclusion is strict .",
    "similarly , let @xmath387 be a minimal hyperpath from @xmath285 $ ] to @xmath376 $ ] not containing @xmath358 .",
    "then the tail of @xmath388 is necessarily reduced to the vertex @xmath386 , where @xmath389 , and its head is @xmath390\\}$ ] .",
    "it follows that @xmath391 is a hyperpath from @xmath285 $ ] to @xmath386 not containing @xmath358 .",
    "now suppose that @xmath392 .",
    "let @xmath393 the greatest integer such that @xmath394 appears in the hyperpath @xmath391 . necessarily ,",
    "one of the hyperarcs in the hyperpath is of the form @xmath384\\},\\{c_j\\})$ ] , so that @xmath325 $ ] is reachable from @xmath285 $ ] through a hyperpath not passing through the vertex @xmath358 .",
    "it follows from the previous discussion that @xmath395 . but",
    "@xmath396 , which is a contradiction .",
    "this shows that @xmath397 , hence @xmath374 .",
    "since every vertex of the form @xmath285 $ ] is reachable from @xmath358 , minimal sets of the family @xmath8 are precisely given by the vertices which do not belong to the scc of the vertex @xmath358 .",
    "this proves the following complexity reduction :    [ th : minimal_set_pb_reduction ] the minimal set problem can be reduced in linear time to the problem of determining the strongly connected components in a directed hypergraph .",
    "we assume the existence of an oracle providing the sccs of any directed hypergraph .",
    "consider an instance @xmath334 of the minimal set problem .",
    "the hypergraph @xmath354 can be built in linear time in the size of the input .",
    "calling the oracle on @xmath354 yields its sccs . then , by examining each scc and its content , we collect the sets @xmath283 such that @xmath285 $ ] does not belong to the same component as the vertex @xmath358 .",
    "we finally return these sets . by proposition  [ prop :",
    "equivalence ] , they are precisely the minimal sets in the family @xmath8 .    another interesting combinatorial problem is to decide whether a collection of sets is a sperner family , _",
    "i.e. _  the sets are not pairwise comparable . as a consequence of theorem  [ th : minimal_set_pb_reduction ]",
    ", it can be shown that the problem of deciding whether a collection of sets is a sperner family can be reduced in linear time to the problem of determining the sccs in a directed hypergraph .",
    "the sperner family problem can be indeed reduced in linear time to the minimal set problem , by examining whether the number of minimal sets of @xmath8 is equal to the cardinality of @xmath8 .    in a similar way",
    ", we can also exhibit a linear time reduction from the problem of determining a linear extension of the subset partial order over a family of sets , to the problem of topologically sorting the vertices of an acyclic directed hypergraph .",
    "the _ topological sort _ of an acyclic directed hypergraph @xmath24 refers to a total ordering @xmath398 of the vertices such that @xmath399 as soon as @xmath36 .",
    "the idea is to use the directed hypergraph @xmath282 ( which can be built in linear time in the size of @xmath334 ) .",
    "this hypergraph can be shown to be acyclic ( under the assumption @xmath280 for all @xmath283 ) . by lemma  [ lemma : reachable ] , it is straightforward that inverting and restricting a topological ordering over the vertices of the form @xmath285 $ ] provides a linear extension of the partial order over  @xmath8 .    to our knowledge , the problem of determining a linear extension of the subset partial order has not been particularly studied .",
    "it is probably not obvious to solve this problem without examining a significant part of the subset partial order ( or at least of a sparse representation such as its transitive reduction ) .",
    "in this paper , we have proved that all terminal sccs can be determined in only almost linear time ( theorems  [ th : correctness ] and  [ th : complexity ] ) . as a consequence ,",
    "two other problems , testing strong connectivity and the existence of a sink , can be solved in almost linear time .",
    "the problem of computing all sccs appears to be much harder .",
    "we conclude with the following questions :    [ op1 ] is it possible to compute the strongly connected components in directed hypergraphs with the same time and space complexity as in directed graphs ?    [ op2 ]",
    "is it possible to `` break '' the partial lower bound @xmath353 provided by corollary  [ cor : scc_lower_bound ] ?",
    "the results established in section  [ sec : combinatorics ] on the size of the transitive reduction of the reachability relation in hypergraphs ( theorem  [ th : transitive_reduction_lower_bound ] ) , and on the reduction from the minimal set problem ( theorem  [ th : minimal_set_pb_reduction ] ) , show that the answer to question  [ op1 ] is likely to be `` no '' ( at least considering `` reasonable '' models of computation , like the ram model ) .",
    "corollary  [ cor : scc_lower_bound ] indicates that solving question  [ op2 ] would require to design an algorithm capturing only a part of the reachability relation ( or a transitive reduction ) .",
    "this part should be however sufficiently large to correctly identify the sccs . in any case",
    ", the directed hypergraphs @xmath282 and @xmath354 constructed in section  [ sec : combinatorics ] provide useful examples to study the problem .",
    "lmm@xmath40012    giorgio ausiello , alessandro datri , and domenico sacc , _ graph algorithms for functional dependency manipulation _ , j. acm * 30 * ( 1983 ) , 752766 .",
    "g  ausiello , a  datri , and d  sacc , _ minimal representation of directed hypergraphs _",
    ", siam j. comput .",
    "* 15 * ( 1986 ) , 418431 .",
    "giorgio ausiello , paolo  giulio franciosa , and daniele frigioni , _ directed hypergraphs : problems , algorithmic results , and a novel decremental approach _ , theoretical computer science , 7th italian conference , ictcs 2001 , proceedings ( antonio restivo , simona ronchi  della rocca , and luca roversi , eds . ) , lecture notes in computer science , vol .",
    "2202 , springer , 2001 , pp .",
    "312327 .",
    "giorgio ausiello , paolo  giulio franciosa , daniele frigioni , and roberto giaccio , _ decremental maintenance of reachability in hypergraphs and minimum models of horn formulae _ ,",
    "algorithms and computation , 8th international symposium , isaac 97 , singapore , december 17 - 19 , 1997 , proceedings ( hon  wai leong , hiroshi imai , and sanjay jain , eds . ) , lecture notes in computer science , vol .",
    "1350 , springer , 1997 , pp .",
    "122131 .",
    "x.  allamigeon , s.  gaubert , and e.  goubault , _ inferring min and max invariants using max - plus polyhedra _ , proceedings of the 15th international static analysis symposium ( sas08 ) , lecture notes in comput .",
    "5079 , springer , valencia , spain , 2008 , pp .",
    "189204 .",
    "to3em , _ the tropical double description method _ , proceedings of the 27th international symposium on theoretical aspects of computer science ( stacs 2010 ) ( dagstuhl , germany ) ( j .- y .",
    "marion and th .",
    "schwentick , eds . ) , leibniz international proceedings in informatics ( lipics ) , vol .  5 , schloss dagstuhl  leibniz - zentrum fuer informatik , 2010 , pp .",
    "to3em , _ computing the vertices of tropical polyhedra using directed hypergraphs _ ,",
    "discrete & computational geometry * 49 * ( 2013 ) , no .  2 , 247279 .",
    "alfred  v. aho , m.  r. garey , and jeffrey  d. ullman , _ the transitive reduction of a directed graph _ , siam journal on computing * 1 * ( 1972 ) , no .  2 , 131137 .",
    "giorgio ausiello and giuseppe  f. italiano , _ on - line algorithms for polynomially solvable satisfiability problems _ ,",
    "j. log . program .",
    "* 10 * ( 1991 ) , no .  1/2/3&4 , 6990 .",
    "giorgio ausiello , giuseppe italiano , luigi laura , umberto nanni , and fabiano sarracco , _ structure theorems for optimum hyperpaths in directed hypergraphs _",
    ", combinatorial optimization ( a.  mahjoub , vangelis markakis , ioannis milis , and vangelis paschos , eds . ) , lecture notes in computer science , vol .",
    "7422 , springer berlin / heidelberg , 2012 , pp .",
    "xavier allamigeon , _ tplib : tropical polyhedra library _ , 2009 , distributed under lgpl , available at https://gforge.inria.fr/projects/tplib .",
    "giorgio ausiello , umberto nanni , and giuseppe  f. italiano , _ dynamic maintenance of directed hypergraphs _ , theoretical computer science * 72 * ( 1990 ) , no .  2 - 3 , 97  117 .",
    "roberto  j. bayardo and biswanath panda , _ fast algorithms for finding extremal sets _ , proceedings of the eleventh siam international conference on data mining , sdm 2011 , april 28 - 30 , 2011 , mesa , arizona , usa , siam / omnipress , 2011 , pp .  2534 .    j.  cheriyan and k.  mehlhorn , _",
    "algorithms for dense graphs and networks on the random access computer _ , algorithmica * 15 * ( 1996 ) , 521549 .",
    "thomas  h. cormen , clifford stein , ronald  l. rivest , and charles  e. leiserson , _ introduction to algorithms _ , mcgraw - hill higher education , 2001 .",
    "amr elmasry , _ computing the subset partial order for dense families of sets _ , information processing letters * 109 * ( 2009 ) , no .  18 , 1082  1086 .",
    "harold  n. gabow , _ path - based depth - first search for strong and biconnected components _ , inf .",
    "* 74 * ( 2000 ) , no .  3 - 4 , 107114 .    s.  gaubert and j.  gunawardena , _ the perron - frobenius theorem for homogeneous , monotone functions _ ,",
    "trans . of ams * 356 * ( 2004 ) , no .  12 , 49314950 .",
    "giorgio gallo , claudio gentile , daniele pretolani , and gabriella rago , _ max horn sat and the minimum cut problem in directed hypergraphs _ , math .",
    "* 80 * ( 1998 ) , 213237 .",
    "giorgio gallo , giustino longo , stefano pallottino , and sang nguyen , _ directed hypergraphs and applications _ , discrete appl .",
    "* 42 * ( 1993 ) , no .  2 - 3 , 177201 .",
    "giorgio gallo and daniele pretolani , _ a new algorithm for the propositional satisfiability problem _ , discrete applied mathematics * 60 * ( 1995 ) , no .  1 - 3 , 159179 .    parke godfrey , ryan shipley , and jarek gryz , _ maximal vector computation in large data sets _ , proceedings of the 31st international conference on very large data bases , vldb 05 , vldb endowment , 2005 , pp .",
    "229240 .",
    "r.  d. katz , _ max - plus @xmath401-invariant spaces and control of timed discrete event systems _ , ieee trans .",
    "control * 52 * ( 2007 ) , no .  2 , 229241 .",
    "h.  t. kung , f.  luccio , and f.  p. preparata , _ on finding the maxima of a set of vectors _ , j. acm * 22 * ( 1975 ) , 469476 .",
    "david  g. kirkpatrick and raimund seidel , _ output - size sensitive algorithms for finding maximal vectors _ , proceedings of the first annual symposium on computational geometry ( new york , ny , usa ) , scg 85 , acm , 1985 , pp .",
    "qi  lu , michael madsen , martin milata , sren ravn , uli fahrenberg , and kim  g. larsen , _ reachability analysis for timed automata using max - plus algebra _ , the journal of logic and algebraic programming * 81 * ( 2012 ) , no .  3 , 298313 .",
    "xinxin liu and scott  a. smolka , _ simple linear - time algorithms for minimal fixed points ( extended abstract ) _ , automata , languages and programming , 25th international colloquium , icalp98 , proceedings ( kim  guldstrand larsen , sven skyum , and glynn winskel , eds . ) , lecture notes in computer science , vol . 1443 , springer , 1998 , pp .",
    "s.  nguyen and s.  pallottino , _ hyperpaths and shortest hyperpaths _ , como 86 : lectures given at the third session of the centro internazionale matematico estivo ( c.i.m.e . ) on combinatorial optimization ( new york , ny , usa ) , lectures notes in mathematics , springer - verlag new york , inc . , 1989 ,",
    "258271 .",
    "lars  relund nielsen , daniele pretolani , and kim  allan andersen , _ finding the k shortest hyperpaths using reoptimization _ , operations research letters * 34 * ( 2006 ) , no .  2 , 155  164",
    ".    sang nguyen , stefano pallottino , and michel gendreau , _ implicit enumeration of hyperpaths in a logit model for transit networks _ , transportation science * 32 * ( 1998 ) , no .  1 , 5464 .",
    "can  c. zturan , _ on finding hypercycles in chemical reaction networks _",
    "* 21 * ( 2008 ) , no .  9 , 881884 .",
    "daniele pretolani , _ a directed hypergraph model for random time dependent shortest paths _ , european journal of operational research * 123 * ( 2000 ) , no .  2 , 315324 .",
    "daniele pretolani , _ hypergraph reductions and satisfiability problems _ , theory and applications of satisfiability testing , 6th international conference , sat 2003 ( enrico giunchiglia and armando tacchella , eds . ) , lecture notes in computer science , vol . 2919 , springer , 2003 , pp .",
    "383397 .",
    "paul pritchard , _",
    "opportunistic algorithms for eliminating supersets _ , acta informatica * 28 * ( 1991 ) , 733754 .",
    "paul pritchard , _ a simple sub - quadratic algorithm for computing the subset partial order _ , information processing letters * 56 * ( 1995 ) , no .  6 , 337  341 .",
    "paul pritchard , _ a fast bit - parallel algorithm for computing the subset partial order _ , algorithmica * 24 * ( 1999 ) , 7686 .",
    "paul pritchard , _ on computing the subset graph of a collection of sets _ , journal of algorithms * 33 * ( 1999 ) , no .  2 , 187  203 .",
    "robert tarjan , _ depth - first search and linear graph algorithms _ , siam journal on computing * 1 * ( 1972 ) , no .  2 , 146160 .    mayur thakur and rahul tripathi , _ linear connectivity problems in directed hypergraphs _ ,",
    "sci . * 410 * ( 2009 ) , 25922618 .",
    "daniel  m. yellin , _ algorithms for subset testing and finding maximal sets _ , proceedings of the third annual acm - siam symposium on discrete algorithms ( philadelphia , pa , usa ) , soda 92 , society for industrial and applied mathematics , 1992 , pp",
    ".  386392 .",
    "daniel  m. yellin and charanjit  s. jutla , _ finding extremal sets in less than quadratic time _ ,",
    "information processing letters * 48 * ( 1993 ) , no .  1 , 29  34 .",
    "we give the main steps of the execution of the algorithm   on the directed hypergraph depicted in figure  [ fig : hypergraph ] :    \\(u ) at ( -2,-1 ) @xmath3 ; ( v ) at ( 0,0 ) @xmath4 ; ( w ) at ( 0,-2 ) @xmath48 ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180 ] ( v ) ; at ( -1,-0.5 ) @xmath52 ; ( v ) edge[simpleedge , out=-90,in=90 ] ( w ) ; at ( -0.5,-1.3 ) @xmath53 ; ( w ) edge[simpleedge , out=-120,in=-60 ] ( u ) ; at ( -1.5,-2.5 ) @xmath54 ; at ( 1.75,-0.5 ) @xmath55 ; at ( 2.5,-3.5 ) @xmath56 ; ; ;    vertices are depicted by solid circles if their index is defined , and by dashed circles otherwise . once a vertex is placed into @xmath128 , it is depicted in gray .",
    "similarly , a hyperarc which has never been placed into a local stack @xmath145 is represented by dotted lines .",
    "once it is pushed into @xmath145 , it becomes solid , and when it is popped from @xmath145 , it is colored in gray ( note that for the sake of readability , gray hyperarcs mapped to trivial cycles after a vertex merging step will not be represented ) .",
    "the stack @xmath145 which is mentioned always corresponds to the stack local to the last non - terminated call of the function @xmath125 .",
    "initially , @xmath402 for all @xmath403 .",
    "we suppose that @xmath404 is called first . after the execution of the block from lines  [ scc : begin ] to  [ scc : end_node_loop ] , the current state is :    \\(u ) at ( -2,-1 ) @xmath3 node[node distance=11ex , left of = u ] @xmath405 & = 0 \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( v ) at ( 0,0 ) @xmath4 ; ( w ) at ( 0,-2 ) @xmath48 ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180 ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90,dotted ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60,dotted ] ( u ) ; ; ;    at ( 7 , -1.5 ) @xmath406 \\\\[-0.8ex ] n & = 1 \\\\[-0.8ex ] f & = [ a_1 ] \\end{aligned}$ ] ;    following the hyperarc @xmath52 , @xmath407 is called during the execution of the block from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] of @xmath404 . after line  [ scc : end_node_loop ] in @xmath407 , the root of the hyperarc @xmath55 is set to @xmath4 , and the counter @xmath176 is incremented to @xmath105 since @xmath408 .",
    "the state is :    \\(u ) at ( -2,-1 ) @xmath3 node[node distance=11ex , left of = u ] @xmath405 & = 0 \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( v ) at ( 0,0 ) @xmath4 node[node distance=7ex , above of = v ] @xmath409 & = 1 \\\\[-0.8ex ] { \\mathit{low}}[v ] & = 1 \\\\[-0.8ex ] { \\mathit{is\\_term}}[v ] & = \\true   \\end{aligned}$ ] ; ( w ) at ( 0,-2 ) @xmath48 ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180,lightgray ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90 ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60,dotted ] ( u ) ; ; ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 1 \\end{aligned}$ ] ;    at ( 7 , -1.5 ) @xmath410 \\\\[-0.8ex ] n & = 2 \\\\[-0.8ex ] f & = [ a_2 ] \\end{aligned}$ ] ;    similarly , the function @xmath411 is called during the execution of the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] in @xmath407 . after line  [ scc : end_node_loop ] in @xmath411 , the root of the hyperarc @xmath56 is set to @xmath48 , and the counter @xmath412 is incremented to @xmath105 since @xmath413 .",
    "besides , @xmath176 is incremented to @xmath177 since @xmath414 , so that @xmath55 is pushed on the stack @xmath185 .",
    "the state is :    \\(u ) at ( -2,-1 ) @xmath3 node[node distance=11ex , left of = u ] @xmath405 & = 0 \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( v ) at ( 0,0 ) @xmath4 node[node distance=7ex , above of = v ] @xmath409 & = 1 \\\\[-0.8ex ] { \\mathit{low}}[v ] & = 1 \\\\[-0.8ex ] { \\mathit{is\\_term}}[v ] & = \\true   \\end{aligned}$ ] ; ( w ) at ( 0,-2 ) @xmath48 node[node distance=11ex , below left of = w ] @xmath415 & = 2 \\\\[-0.8ex ] { \\mathit{low}}[w ] & = 2 \\\\[-0.8ex ] { \\mathit{is\\_term}}[w ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,-0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 2 \\end{aligned}$ ] ; at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ;    \\(u ) edge[simpleedge , out=90,in=-180,lightgray ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90,lightgray ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60 ] ( u ) ; ; ;    at ( 7 , -1.5 ) @xmath416 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ]   f & = [ a_3]\\\\[-0.8ex ] f_{v } & = [ a_4 ]   \\end{aligned}$ ] ;    the execution of the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] of @xmath411 discovers that @xmath139 $ ] is defined but @xmath417 , so that @xmath418 $ ] is set to @xmath419,{\\mathit{low}}[u ] ) = 0 $ ] and @xmath420 $ ] to @xmath420 \\and { \\mathit{is\\_term}}[u ] = \\true$ ] . at the end of the loop ,",
    "the state is therefore :    \\(u ) at ( -2,-1 ) @xmath3 node[node distance=11ex , left of = u ] @xmath405 & = 0 \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( v ) at ( 0,0 ) @xmath4 node[node distance=7ex , above of = v ] @xmath409 & = 1 \\\\[-0.8ex ] { \\mathit{low}}[v ] & = 1 \\\\[-0.8ex ] { \\mathit{is\\_term}}[v ] & = \\true   \\end{aligned}$ ] ; ( w ) at ( 0,-2 ) @xmath48 node[node distance=11ex , below left of = w ] @xmath415 & = 2 \\\\[-0.8ex ] { \\mathit{low}}[w ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[w ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180,lightgray ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90,lightgray ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60,lightgray ] ( u ) ; ; ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 2 \\end{aligned}$ ] ; at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ;    at ( 7 , -1.5 ) @xmath416 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] f_{v } & = [ a_4 ]   \\end{aligned}$ ] ;    since @xmath418 \\neq { \\mathit{index}}[w]$ ] , the block from lines  [ scc : begin2 ] to  [ scc : end2 ] is not executed , and @xmath411 terminates .",
    "back to the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] in @xmath407 , @xmath421 $ ] is assigned to the value @xmath422,{\\mathit{low}}[w ] ) = 0 $ ] , and @xmath423 $ ] to @xmath423 \\and { \\mathit{is\\_term}}[w ] = \\true$ ] :    \\(u ) at ( -2,-1 ) @xmath3 node[node distance=11ex , left of = u ] @xmath405 & = 0 \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( v ) at ( 0,-0 ) @xmath4 node[node distance=7ex , above of = v ] @xmath409 & = 1 \\\\[-0.8ex ] { \\mathit{low}}[v ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[v ] & = \\true   \\end{aligned}$ ] ; ( w ) at ( 0,-2 ) @xmath48 node[node distance=11ex , below left of = w ] @xmath415 & = 2 \\\\[-0.8ex ] { \\mathit{low}}[w ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[w ] & = \\true   \\end{aligned}$ ] ;    \\(x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=90,in=-180,lightgray ] ( v ) ; ( v ) edge[simpleedge , out=-90,in=90,lightgray ] ( w ) ; ( w ) edge[simpleedge , out=-120,in=-60,lightgray ] ( u ) ; ; ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 2 \\end{aligned}$ ] ; at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ;    at ( 7 , -1.5 ) @xmath416 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] f_{v } & = [ a_4 ]   \\end{aligned}$ ] ;    since @xmath421 \\neq { \\mathit{index}}[v]$ ] , the block from lines  [ scc : begin2 ] to  [ scc : end2 ] is not executed , and @xmath407 terminates .",
    "back to the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] in @xmath404 , @xmath140 $ ] is assigned to the value @xmath424,{\\mathit{low}}[v ] ) = 0 $ ] , and @xmath425 $ ] to @xmath425 \\and { \\mathit{is\\_term}}[v ] = \\true$ ] . therefore , at line  [ scc : begin2 ] , the conditions @xmath140 = { \\mathit{index}}[u]$ ] and @xmath425 = \\true$ ] hold , so that a vertex merging step is executed . at that point ,",
    "the stack @xmath145 is empty .",
    "after that , @xmath228 is set to @xmath139 = 0 $ ] ( line  [ scc : begin_node_merging ] ) , and @xmath426}$ ] is emptied to @xmath145 ( line  [ scc : push_on_fprime1 ] ) , so that @xmath145 is still empty . then @xmath48 is popped from @xmath22 , and since @xmath427 = 2 > i = 0 $ ] , the loop from lines  [ scc : begin_node_merging_loop ] to  [ scc : end_node_merging_loop ] is iterated .",
    "then the stack @xmath428}$ ] is emptied in @xmath145 . at line  [ scc : merge ] , is called .",
    "the result is denoted by @xmath115 ( in practice , either @xmath429 or @xmath430 ) .",
    "the state is :    \\(v ) at ( 0,0 ) @xmath4 node[node distance=7ex , above of = v ] @xmath409 & = 1 \\\\[-0.8ex ] { \\mathit{low}}[v ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[v ] & = \\true   \\end{aligned}$ ] ; ( w ) at ( 0,-2 ) @xmath115 node[node distance=10ex , below left of = w ] @xmath431 & = 0 \\text { or } 2   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(v ) edge[simpleedge , out=-90,in=90,lightgray ] ( w ) ; ( w ) edge[simpleedge , out=170,in=-170,lightgray ] ( v ) ; ; ;    at ( 1.75,-0.3 ) @xmath107 c_{a_4 } & = 2 \\end{aligned}$ ] ; at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ;    at ( 7 , -1.5 ) @xmath410 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ] f_{v } & = [ a_4 ] \\\\[-0.8ex ] i & = 0 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] u & = { \\call{find}}{u } = { \\call{find}}{w }   \\end{aligned}$ ] ;    then @xmath4 is popped from @xmath22 , and since @xmath432 = 1 >",
    "i = 0 $ ] , the loop lines  [ scc : begin_node_merging_loop ] to  [ scc : end_node_merging_loop ] is iterated again .",
    "then the stack @xmath433 $ ] is emptied in @xmath145 . at line  [ scc :",
    "merge ] , is called .",
    "the result is set to @xmath115 ( in practice , @xmath115 is one of the vertices @xmath3 , @xmath4 , @xmath48 ) .",
    "the state is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=16ex , left of = u ] @xmath431 & = 0 , 1 , \\text { or } 2   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ; ( u ) edge[simpleedge , out=40,in=-180 ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120 ] ( y ) ; ;    at ( 6 , -2.5 ) @xmath406 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ] f_{v } & = { [ \\,]}\\\\[-0.8ex ] i & = 0 \\\\[-0.8ex ] f & = [ a_4]\\\\[-0.8ex ] u & = { \\call{find}}{u } = { \\call{find}}{v } \\\\[-0.8ex ] & = { \\call{find}}{w }   \\end{aligned}$ ] ;    after that , @xmath3 is popped from @xmath22 , and as @xmath139 = 0 = i$ ] , the loop is terminated . at line  [ scc : index_redef ] , @xmath126 $ ]",
    "is set to @xmath228 , and @xmath115 is pushed on @xmath22 .",
    "since @xmath434 , we go back to line  [ scc : begin_edge_loop ] , in the state :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ; ( u ) edge[simpleedge , out=40,in=-180 ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120 ] ( y ) ; ;    at ( 7 , -1.5 ) @xmath435 \\\\[-0.8ex ] n & = 3 \\\\[-0.8ex ] f & = [ a_4]\\\\[-0.8ex ] u & = { \\call{find}}{u } = { \\call{find}}{v } \\\\[-0.8ex ] & = { \\call{find}}{w }   \\end{aligned}$ ] ;    then @xmath55 is popped from @xmath145 , and the loop from  [ scc : begin_edge_loop2 ] to  [ scc : end_edge_loop2 ] iterates over @xmath436 .",
    "suppose that @xmath49 is treated first",
    ". then @xmath437 is called . during its execution , at line  [ scc : end_node_loop ] ,",
    "the state is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ; ( u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120 ] ( y ) ; ;    at ( 7 , -1.5 ) @xmath439 \\\\[-0.8ex ] n & = 4 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] u & = { \\call{find}}{u } = { \\call{find}}{v } \\\\[-0.8ex ] & = { \\call{find}}{w }   \\end{aligned}$ ] ;    since @xmath145 is empty , the loop from lines  [ scc : begin_edge_loop ] to  [ scc : end_edge_loop ] is not executed . at line  [ scc : begin2 ] , @xmath440 = { \\mathit{index}}[x]$ ] and @xmath441 = \\true$ ] , so that a trivial vertex merging step is performed , only on @xmath49 , since it is the top element of @xmath22 .",
    "after line  [ scc : index_redef ] , it can be verified that @xmath442 $ ] , @xmath443 = 3 $ ] and @xmath444}$ ] .",
    "therefore , the goto statement at line  [ scc : goto ] is not executed .",
    "it follows that the loop from lines  [ scc : begin_non_max_scc_loop ] to  [ scc : end_non_max_scc_loop ] is executed , and after that , the state is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\true   \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 ; ( t ) at ( 2,-4.5 ) @xmath51 ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 1 \\end{aligned}$ ] ; ( u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120 ] ( y ) ; ;    at ( 6 , -1.5 ) @xmath435 \\\\[-0.8ex ] n & = 4 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] u & = { \\call{find}}{u } = { \\call{find}}{v } \\\\[-0.8ex ]   & = { \\call{find}}{w } \\\\[-0.8ex ] { \\mathit{finished } } & = \\ { x \\ } \\end{aligned}$ ] ;    after the termination of @xmath437 , since @xmath445 , @xmath130 $ ] is set to @xmath131 .",
    "after that , @xmath446 is called , and at line  [ scc : end_node_loop ] , it can be checked that @xmath412 has been incremented to @xmath447 because @xmath448 and @xmath449 .",
    "therefore , @xmath56 is pushed to @xmath152 , and the state is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\false \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 node[node distance=12ex , right of = y ] @xmath450 & = 4   \\\\[-0.8ex ] { \\mathit{low}}[y ] & = 4 \\\\[-0.8ex ] { \\mathit{is\\_term}}[y ] & = \\true   \\end{aligned}$ ] ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120,lightgray ] ( y ) ; ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 2 \\end{aligned}$ ] ;    at ( 8 , -1.5 ) @xmath451 \\\\[-0.8ex ] n & = 5 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] f_u & = [ a_5]\\\\[-0.8ex ] u & = { \\call{find}}{u } \\\\[-0.8ex ] & = { \\call{find}}{v } \\\\[-0.8ex ]   & = { \\call{find}}{w } \\\\[-0.8ex ] { \\mathit{finished } } & = \\ { x \\ } \\end{aligned}$ ] ;    as for the vertex @xmath49 , @xmath446 terminates by popping @xmath50 from @xmath22 and adding it to @xmath128 . back to the execution of @xmath452 , at line  [ scc : begin2 ] ,",
    "the state is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\false \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 node[node distance=12ex , right of = y ] @xmath450 & = 4   \\\\[-0.8ex ] { \\mathit{low}}[y ] & = 4 \\\\[-0.8ex ] { \\mathit{is\\_term}}[y ] & = \\true   \\end{aligned}$ ] ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120,lightgray ] ( y ) ; ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 2 \\end{aligned}$ ] ;    at ( 8 , -1.5 ) @xmath435 \\\\[-0.8ex ] n & = 5 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] f_u & = [ a_5]\\\\[-0.8ex ] u & = { \\call{find}}{u}\\\\[-0.8ex ] & = { \\call{find}}{v } \\\\[-0.8ex ]   & = { \\call{find}}{w } \\\\[-0.8ex ] { \\mathit{finished } } & = \\ { y , x \\ } \\end{aligned}$ ] ;    while @xmath127 = { \\mathit{index}}[u]$ ] , @xmath130 $ ] is equal to @xmath131 , so that no vertex merging loop is performed on @xmath115 .",
    "therefore , @xmath56 is not popped from @xmath152 .",
    "nevertheless , the loop from lines  [ scc : begin_non_max_scc_loop ] to  [ scc : end_non_max_scc_loop ] is executed , and after that , @xmath404 is terminated in the state :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\false \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 node[node distance=12ex , right of = y ] @xmath450 & = 4   \\\\[-0.8ex ] { \\mathit{low}}[y ] & = 4 \\\\[-0.8ex ] { \\mathit{is\\_term}}[y ] & = \\true   \\end{aligned}$ ] ; ( t ) at ( 2,-4.5 ) @xmath51 ;    \\(u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120,lightgray ] ( y ) ; ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 2 \\end{aligned}$ ] ;    at ( 8 , -1.5 ) @xmath453}\\\\[-0.8ex ] n & = 5 \\\\[-0.8ex ] f & = { [ \\,]}\\\\[-0.8ex ] f_u & = [ a_5]\\\\[-0.8ex ] u & = { \\call{find}}{u}\\\\[-0.8ex ] & = { \\call{find}}{v } \\\\[-0.8ex ]   & = { \\call{find}}{w } \\\\[-0.8ex ] { \\mathit{finished } } & = \\ { u , y , x \\ } \\end{aligned}$ ] ;    finally , @xmath454 is called from at line  [ scc : visit_call ] .",
    "it can be verified that a trivial vertex merging loop is performed on @xmath51 only .",
    "after that , @xmath51 is placed into @xmath128 .",
    "therefore , the final state of is :    \\(u ) at ( 0,-1.5 ) @xmath115 node[node distance=13ex , left of = u ] @xmath431 & = 0   \\\\[-0.8ex ] { \\mathit{low}}[u ] & = 0 \\\\[-0.8ex ] { \\mathit{is\\_term}}[u ] & = \\false \\end{aligned}$ ] ; ( x ) at ( 3.5,0 ) @xmath49 node[node distance=7ex , above of = x ] @xmath438 & = 3   \\\\[-0.8ex ] { \\mathit{low}}[x ] & = 3 \\\\[-0.8ex ] { \\mathit{is\\_term}}[x ] & = \\true   \\end{aligned}$ ] ; ( y ) at ( 3.5,-2 ) @xmath50 node[node distance=12ex , right of = y ] @xmath450 & = 4   \\\\[-0.8ex ] { \\mathit{low}}[y ] & = 4 \\\\[-0.8ex ] { \\mathit{is\\_term}}[y ] & = \\true   \\end{aligned}$ ] ; ( t ) at ( 2,-4.5 ) @xmath51 node[node distance=7ex , below of = t ] @xmath455 & = 5 \\\\[-0.8ex ] { \\mathit{low}}[t ] & = 5 \\\\[-0.8ex ] { \\mathit{is\\_term}}[t ] & = \\true   \\end{aligned}$ ] ; ;    \\(u ) edge[simpleedge , out=40,in=-180,lightgray ] ( x ) ; ( u ) edge[simpleedge , out=40,in=120,lightgray ] ( y ) ; ;    at ( 3.2,-3.4 ) @xmath108 c_{a_5 } & = 2 \\end{aligned}$ ] ;    at ( 7.8 , -1.5 ) @xmath453}\\\\[-0.8ex ] n & = 6 \\\\[-0.8ex ] f_u & = [ a_5]\\\\[-0.8ex ] u & = { \\call{find}}{u}\\\\[-0.8ex ] & = { \\call{find}}{v } \\\\[-0.8ex ] & = { \\call{find}}{w } \\\\[-0.8ex ] { \\mathit{finished } } & = \\ { t , u , y , x \\ } \\end{aligned}$ ] ;    as @xmath441 = { \\mathit{is\\_term}}[y ] = { \\mathit{is\\_term}}[t ] = \\true$ ] and @xmath456 = \\false$ ] for @xmath457 , there are three terminal sccs , given by the sets : @xmath458",
    "the correctness proof of the algorithm turns out to be harder than for algorithms on directed graphs such as tarjan s one  @xcite , due to the complexity of the invariants which arise in the former algorithm .",
    "that is why we propose to show the correctness of two intermediary algorithms , named ( figure  [ fig : maxscc2 ] ) and ( figure  [ fig : maxscc3 ] ) , and then to prove that they are equivalent to .",
    "@xmath134 , @xmath135}$ ] , @xmath136 @xmath459 @xmath139 \\gets \\nil$ ] @xmath140 \\gets \\nil$ ] local @xmath142[scc2:find1 ] , local @xmath460[scc2:begin_atom1 ] @xmath126 \\gets n$ ] , @xmath127 \\gets n$ ] @xmath144 @xmath130 \\gets \\true$ ] push @xmath115 on the stack @xmath22[scc2:push1 ] local @xmath461 @xmath462[scc2:f_assign ] @xmath463",
    "[ scc2:end_atom1 ]    [ scc2:begin_edge_loop ] pop @xmath13 from @xmath145 local @xmath150[scc2:find3 ] [ scc2:rec_call ] @xmath130 \\gets \\false$ ] @xmath127 \\gets \\min({\\mathit{low}}[u],{\\mathit{low}}[w])$ ] @xmath130 \\gets { \\mathit{is\\_term}}[u ] \\and { \\mathit{is\\_term}}[w]$ ] [ scc2:end_edge_loop ] [ scc2:is_root ] local @xmath151$][scc2:begin_node_merging][scc2:begin_atom2 ] pop @xmath116 from @xmath22[scc2:pop1 ] [ scc2:begin_node_merging_loop ] @xmath464 @xmath154[scc2:merge ] pop @xmath116 from @xmath22[scc2:pop2 ] [ scc2:end_node_merging_loop ] push @xmath115 on @xmath22[scc2:push2 ] @xmath465                    & \\forall x \\in t(a),\\call{find}{x } = u                   \\end{aligned } \\biggr\\}$ ] [ scc2:f_assign2 ] @xmath463[scc2:end_atom2][scc2:end_node_merging ]    [ scc2:begin_not_single ] @xmath466 , @xmath126 \\gets n$ ] , @xmath144 [ scc2:nredefined ] @xmath461 , go to line  [ scc2:begin_edge_loop][scc2:goto ] [ scc2:end_not_single ] [ scc2:begin_non_max_scc_loop][scc2:begin_atom3 ] pop @xmath116 from @xmath22 , add @xmath116 to @xmath128[scc2:pop3 ] [ scc2:end_non_max_scc_loop][scc2:end_atom3 ]    the main difference between the first intermediary form and is that it does not use auxiliary data associated to the hyperarcs to determine which ones are added to the digraph @xmath102 after a vertex merging step . instead",
    ", the stack @xmath145 is directly filled with the right hyperarcs ( lines  [ scc2:f_assign ] and  [ scc2:f_assign2 ] ) . besides , a boolean @xmath467 is used to determine whether a vertex merging step has been executed .",
    "the notion of _ vertex merging step _ is refined : it now refers to the execution of the instructions between lines  [ scc2:begin_node_merging ] and  [ scc2:end_node_merging ] in which the boolean @xmath467 is set to @xmath131 .    for the sake of simplicity",
    ", we will suppose that sequences of assignment or stack manipulations are executed atomically .",
    "for instance , the sequences of instructions located in the blocks from lines  [ scc2:begin_atom1 ] and  [ scc2:end_atom1 ] , or from lines  [ scc2:begin_atom2 ] and  [ scc2:end_atom2 ] , and at from lines  [ scc2:begin_atom3 ] to  [ scc2:end_atom3 ] , are considered as elementary instructions . under this assumption , intermediate complex invariants do not have to be considered .",
    "after a merging step yielding the vertex @xmath115 , we necessarily have @xmath126 \\neq \\nil$ ] . moreover , all the vertices @xmath116 which has been merged into @xmath115 satisfied @xmath469 \\neq \\nil$ ] because they were stored in the stack @xmath22 . applying",
    "the induction hypothesis terminates the proof .",
    "initially , @xmath470 , and once @xmath139 $ ] is defined , @xmath121 is pushed on @xmath22 ( line  [ scc2:push1 ] ) . naturally , @xmath417 , because otherwise , @xmath139 $ ] would have been defined before ( see the condition line  [ scc2:end_non_max_scc_loop ] ) .",
    "after that , @xmath157 can be popped from @xmath22 at three possible locations :    * at lines  [ scc2:pop1 ] or  [ scc2:pop2 ] , in which case @xmath115 is transformed into a vertex @xmath471 which is immediately pushed on the stack @xmath22 at line  [ scc2:push2 ] . since after that , @xmath472 , the property @xmath473 still holds .",
    "* at line  [ scc2:pop3 ] , in which case it is directly appended to the set @xmath128",
    ".            _ basis case .",
    "_ first , suppose that the hypergraph @xmath24 is such that no vertices are merged during the execution of , _",
    "i.e. _  the vertex merging loop ( from lines  [ scc2:begin_node_merging_loop ] to  [ scc2:end_node_merging_loop ] ) is never executed .",
    "then the boolean @xmath467 is always set to @xmath476 , so that @xmath2 is never redefined to @xmath477 ( line  [ scc2:nredefined ] ) , and there is no back edge to line  [ scc2:begin_edge_loop ] in the control - flow graph .",
    "it follows that removing all the lines between lines  [ scc2:begin_node_merging ] to  [ scc2:end_not_single ] does not change the behavior of the algorithm .",
    "besides , since the function is never called , @xmath114 always coincides with @xmath3 .",
    "finally , at line  [ scc2:f_assign ] , @xmath145 is precisely assigned to the set of simple hyperarcs leaving @xmath3 in @xmath24 , so that the loop from lines  [ scc2:begin_edge_loop ] to  [ scc2:end_edge_loop ] iterates on the successors of @xmath3 in @xmath70 . as a consequence",
    ", the algorithm behaves exactly like .",
    "moreover , under our assumption , the terminal sccs of @xmath70 are all reduced to singletons ( otherwise , the loop from lines  [ scc2:begin_node_merging_loop ] to  [ scc2:end_node_merging_loop ] would be executed , and some vertices would be merged ) . therefore , by proposition  [ prop : terminal_scc ] , the statement in proposition  [ prop : maxscc2 ] holds .",
    "_ inductive case . _",
    "suppose that the vertex merging loop is executed at least once , and that its first execution happens during the execution of , say , .",
    "consider the state of the algorithm at line  [ scc2:begin_node_merging ] just before the execution of the first occurrence of the vertex merging step . until that point , @xmath478 is still equal to @xmath4 for all vertices @xmath40 , so that the execution of coincides with the execution of",
    ". consequently , if @xmath38 is the set formed by the vertices @xmath50 located above @xmath49 in the stack @xmath22 ( including @xmath49 ) , @xmath38 forms a terminal scc of @xmath70 . in particular , the elements of @xmath38 are located in a same scc of the hypergraph @xmath24 .",
    "consider the hypergraph @xmath479 obtained by merging the elements of @xmath38 in the hypergraph @xmath480 , and let @xmath175 be the resulting vertex .",
    "for now , we may add a hypergraph as last argument of the functions , , _ etc _ , to distinguish their execution in the context of the call to or .",
    "we make the following observations :    * the vertex @xmath49 is the first element of the component @xmath38 to be visited during the execution of .",
    "it follows that the execution of until the call to coincides with the execution of until the call to . * besides , during the execution of , the execution of the loop from lines  [ scc2:begin_edge_loop ] to  [ scc2:end_edge_loop ] only has a local impact , _",
    "i.e. _  on the @xmath481 $ ] , @xmath482 $ ] , or @xmath483 $ ] for @xmath484 , and not on any information relative to other vertices .",
    "indeed , we claim that the set of the vertices @xmath50 on which is called during the execution of the loop is exactly @xmath485 .",
    "first , for all @xmath486 , has necessarily been executed _ after _ line  [ scc2:begin_edge_loop ] ( otherwise , by invariant  [ inv : comporstack ] , @xmath50 would be either below @xmath49 in the stack @xmath22 , or in @xmath128 ) .",
    "conversely , suppose that after line  [ scc2:begin_edge_loop ] , there is a call to with @xmath487 . by invariant  [ inv : comporstack ]",
    ", @xmath51 belongs to @xmath128 , so that for one of the vertices @xmath48 examined in the loop , either @xmath488 or @xmath420 = \\false$ ] after the call to . hence @xmath441 $ ] should be @xmath131 , which contradicts our assumptions . *",
    "finally , from the execution of line  [ scc2:goto ] during the call to , our algorithm behaves exactly as from the execution of line  [ scc2:begin_edge_loop ] in .",
    "indeed , @xmath489 $ ] is equal to @xmath228 , and the latter is equal to @xmath490 .",
    "similarly , for all @xmath484 , @xmath483 = i$ ] and @xmath481 = \\true$ ] .",
    "the vertex @xmath175",
    "being equal to one of the @xmath484 , we also have @xmath491 = i$ ] and @xmath492 = \\true$ ] .",
    "moreover , @xmath175 is the top element of @xmath22 .",
    "+ furthermore , it can be verified that at line  [ scc2:f_assign2 ] , the set @xmath145 contains exactly all the hyperarcs of @xmath12 which generate the simple hyperarcs leaving @xmath175 in @xmath479 : they are exactly characterized by @xmath493 since at that line  [ scc2:f_assign2 ] , a hyperarc @xmath13 satisfies @xmath494 if , and only if , @xmath17 is reduced to a singleton @xmath495 such that @xmath496 $ ] is defined .",
    "+ finally , for all vertices @xmath484 , @xmath497 can be equivalently replaced by @xmath498 .",
    "let @xmath42 be the function which maps all vertices @xmath484 to @xmath175 , and any other vertex to itself .",
    "we claim that @xmath479 and @xmath43 have the same reachability graph , _",
    "@xmath499 and @xmath500 are identical relations .",
    "indeed , the two hypergraphs only differ on the images of the hyperarcs @xmath46 such that @xmath501 for some @xmath484 .",
    "for such hyperarcs , we have @xmath502 , because otherwise , @xmath441 $ ] would have been set to @xmath131 ( _ i.e. _  the component @xmath38 would not be terminal ) .",
    "it follows that their are mapped to the cycle @xmath503 by @xmath42 , so that @xmath479 and @xmath43 clearly have the same reachability graph .",
    "in particular , they have the same terminal sccs .",
    "finally , since the elements of @xmath38 are in a same scc of @xmath24 , proposition  [ prop : collapse ] shows that the function @xmath42 induces a one - to - one correspondence between the sccs of @xmath24 and the sccs of @xmath43 : @xmath504 the action of the function @xmath42 exactly corresponds to the vertex merging step performed on @xmath38 .",
    "since by induction hypothesis , determines the terminal sccs in @xmath43 , it follows that proposition  [ prop : maxscc2 ] holds .",
    "@xmath134 , @xmath135}$ ] , @xmath136 @xmath137 , @xmath138 @xmath459[scc3:collected_init ] @xmath139 \\gets \\nil$ ] @xmath140 \\gets \\nil$ ] , @xmath141}$ ] [ scc3:init_call ] local @xmath142[scc3:find1 ] , local @xmath143}$][scc3:begin_atom1 ] @xmath126 \\gets n$ ] , @xmath127 \\gets n$ ] @xmath144[scc3:troot_def ] @xmath130 \\gets \\true$ ] push @xmath115 on the stack @xmath22 [ scc3:begin_node_loop ] push @xmath13 on @xmath145[scc3:f_push ] @xmath146 local @xmath147[scc3:find2 ] [ scc3:root_reach ] @xmath148[scc3:counter_increment ] [ scc3:counter_reach ] push @xmath13 on the stack @xmath149[scc3:stack_edge][scc3:root_def ] [ scc3:collected1_begin ] @xmath463 [ scc3:collected1_end][scc3:end_atom1 ]    [ scc3:begin_edge_loop ] pop @xmath13 from @xmath145 local @xmath150[scc3:find3 ] [ scc3:rec_call ] @xmath130 \\gets \\false$ ] @xmath127 \\gets \\min({\\mathit{low}}[u],{\\mathit{low}}[w])$ ] @xmath130 \\!\\ ! \\gets \\!\\",
    "! { \\mathit{is\\_term}}[u ] \\ ! \\and \\",
    "! { \\mathit{is\\_term}}[w]$ ] [ scc3:end_edge_loop ] local @xmath151$][scc3:begin_node_merging ] pop each @xmath505 and push it on @xmath145[scc3:push_on_fprime1][scc3:begin_atom2 ] pop @xmath116 from @xmath22 [ scc3:begin_node_merging_loop ] pop each @xmath506 and push it on @xmath145[scc3:push_on_fprime2 ] @xmath154[scc3:merge ] pop @xmath116 from @xmath22 [ scc3:end_node_merging_loop][scc3:end_node_merging ] @xmath126 \\gets i$ ] , push @xmath115 on @xmath22 @xmath507            & \\forall x \\in t(a),\\call{find}{x } = u          \\end{aligned } \\!\\biggr\\}$ ] [ scc3:f_assign2 ] @xmath463[scc3:end_atom2][scc3:collected2 ] go to line  [ scc3:begin_edge_loop][scc3:goto][scc3:begin_not_single ] [ scc3:begin_non_max_scc_loop][scc3:begin_atom3 ] pop @xmath116 from @xmath22 , add @xmath116 to @xmath128 [ scc3:end_non_max_scc_loop ] [ scc3:end_atom3 ]    \\(t ) + + ( 0ex,2ex ) coordinate ( t ) ; ( b ) + + ( 0ex,-0.5ex ) coordinate",
    "( b ) ; ( l ) + + ( -0.5ex,0ex ) coordinate ( l ) ; ( r ) + + ( 0.5ex,0ex ) coordinate ( r ) ; let 1 = ( l ) , 2 = ( t ) in coordinate ( lt ) at ( 1,2 ) ; let 1 = ( l ) , 2 = ( b ) in coordinate ( lb ) at ( 1,2 ) ; let 1 = ( r ) , 2 = ( t ) in coordinate ( rt ) at ( 1,2 ) ; let 1 = ( r ) , 2 = ( b ) in coordinate ( rb ) at ( 1,2 ) ; ( lt )  ( rt )  ( rb )  ( lb )  cycle ;    ( t2 ) + + ( 0ex,-0.5ex ) coordinate ( t2 ) ; ( b2 ) + + ( 0ex,-0.5ex ) coordinate ( b2 ) ; ( l2 ) + + ( -0.5ex,0ex ) coordinate ( l2 ) ; ( r2 ) + + ( 0.5ex,0ex ) coordinate ( r2 ) ; let 1 = ( l2 ) , 2 = ( t2 ) in coordinate ( lt2 ) at ( 1,2 ) ; let 1 = ( l2 ) , 2 = ( b2 ) in coordinate ( lb2 ) at ( 1,2 ) ; let 1 = ( r2 ) , 2 = ( t2 ) in coordinate ( rt2 ) at ( 1,2 ) ; let 1 = ( r2 ) , 2 = ( b2 ) in coordinate ( rb2 ) at ( 1,2 ) ; ( lt2 )  ( rt2 )  ( rb2 ) ",
    "( lb2 )  cycle ;    ( t3 ) + + ( 0ex,-0.5ex ) coordinate ( t3 ) ; ( b3 ) + + ( 0ex,-0.5ex ) coordinate ( b3 ) ; ( l3 ) + + ( -0.5ex,0ex ) coordinate ( l3 ) ; ( r3 ) + + ( 0.5ex,0ex ) coordinate ( r3 ) ; let 1 = ( l3 ) , 3 = ( t3 ) in coordinate ( lt3 ) at ( 1,3 ) ; let 1 = ( l3 ) , 3 = ( b3 ) in coordinate ( lb3 ) at ( 1,3 ) ; let 1 = ( r3 ) , 3 = ( t3 ) in coordinate ( rt3 ) at ( 1,3 ) ; let 1 = ( r3 ) , 3 = ( b3 ) in coordinate ( rb3 ) at ( 1,3 ) ; ( lt3 ) ",
    "( rt3 )  ( rb3 )  ( lb3 )  cycle ;    ( t4 ) + + ( 0ex,-0.5ex ) coordinate ( t4 ) ; ( b4 ) + + ( 0ex,-0.5ex ) coordinate ( b4 ) ; ( l4 ) + + ( -0.5ex,0ex ) coordinate ( l4 ) ; ( r4 ) + + ( 0.5ex,0ex ) coordinate ( r4 ) ; let 1 = ( l4 ) , 3 = ( t4 ) in coordinate ( lt4 ) at ( 1,3 ) ; let 1 = ( l4 ) , 3 = ( b4 ) in coordinate ( lb4 ) at ( 1,3 ) ; let 1 = ( r4 ) , 3 = ( t4 ) in coordinate ( rt4 ) at ( 1,3 ) ; let 1 = ( r4 ) , 3 = ( b4 ) in coordinate ( rb4 ) at ( 1,3 ) ; ( lt4 ) ",
    "( rt4 )  ( rb4 )  ( lb4 )  cycle ;    the second intermediary version of our algorithm , , is based on the first one , but it performs the same computations on the auxiliary data @xmath162 and @xmath169 as in .",
    "however , the latter are never used , because at line  [ scc3:f_assign2 ] , @xmath145 is re - assigned to the value provided in .",
    "it follows that for now , the parts in gray can be ignored .",
    "the following lemma states that and are equivalent :      when is executed , the local stack @xmath145 is not directly assigned to the set @xmath509 ( see line  [ scc2:f_assign ] in figure  [ fig : maxscc2 ] ) , but built by several iterations on the set @xmath111 ( line  [ scc3:f_push ] ) . since @xmath112 and @xmath69 holds if , and only if , @xmath17 is reduced to @xmath73 , initially fills @xmath145 with the same hyperarcs as .",
    "besides , the condition @xmath510 in ( line  [ scc2:begin_not_single ] ) is replaced by @xmath434 ( line  [ scc3:begin_not_single ] ) .",
    "we claim that the condition @xmath434 can be safely used in as well .",
    "indeed , in , @xmath434 implies @xmath510 .",
    "conversely , suppose that in , @xmath510 and @xmath511 , so that the algorithm goes back to line  [ scc2:goto ] after having @xmath467 to @xmath476 .",
    "the loop from lines  [ scc2:begin_edge_loop ] to  [ scc2:end_edge_loop ] is not executed since @xmath511 , and it directly leads to a new execution of lines  [ scc2:is_root ] to  [ scc2:begin_not_single ] with @xmath512 .",
    "therefore , going back to line  [ scc2:goto ] was useless .",
    "finally , during the vertex merging step in , @xmath2 keeps its value , which is greater than or equal to @xmath477 , but is not necessarily equal to @xmath477 like in ( just after line  [ scc2:nredefined ] ) .",
    "this is safe because the whole algorithm only need that @xmath2 take increasing values , and not necessarily consecutive ones .          for all @xmath164",
    ", @xmath514 has been called . the root @xmath162 has necessarily been defined at the first of these calls ( remember that the block from lines  [ scc3:begin_atom1 ] to  [ scc3:end_atom1 ] is supposed to be executed atomically ) .",
    "the invariant clearly holds when @xmath115 is placed in @xmath128 . using the atomicity assumptions ,",
    "the call to @xmath517 is necessarily terminated .",
    "let @xmath518 be the state of the algorithm at that point , and @xmath519 and @xmath520 the corresponding hypergraph and set of terminated vertices at that state respectively . since @xmath517 has performed a depth - first search from the vertex @xmath115 in @xmath521 , all the vertices reachable from @xmath115 in @xmath519 stand in @xmath520 .",
    "we claim that the invariant is then preserved by the following vertex merging steps .",
    "the graph arcs which may be added by the latter leave vertices in @xmath22 , and consequently not from elements in @xmath128 ( by invariant  [ inv : comporstack ] ) .",
    "it follows that the set of reachable vertices from elements of @xmath520 is not changed by future vertex merging steps . as a result ,",
    "_ all the vertices reachable from @xmath115 in @xmath102 are elements of @xmath520_. since by invariant  [ inv : incomp2 ] , @xmath522 , this proves the whole invariant in the state @xmath515 .",
    "[ inv : call_to_visit3 ] in the digraph @xmath102 , at the call to @xmath517 , @xmath3 is reachable from a vertex @xmath132 such that @xmath523 $ ] is defined if , and only if , @xmath132 belongs to the stack @xmath22 .",
    "the `` if '' part can be shown by induction .",
    "when the function @xmath517 is called from line  [ scc3:init_call ] , the stack @xmath22 is empty , so that this is obvious .",
    "otherwise , it is called from line  [ scc3:rec_call ] during the execution of @xmath514 . then @xmath524 is reachable from any vertex in the stack , since @xmath49 was itself reachable from any vertex in the stack at the call to @xmath525 ( inductive hypothesis ) and that this reachability property is preserved by potential vertex merging steps ( proposition  [ prop : collapse ] ) . as @xmath3 is obviously reachable from @xmath175 , this shows the statement .",
    "conversely , suppose that @xmath523 $ ] is defined , and @xmath132 is not in the stack . according to invariant  [ inv : comporstack ]",
    ", @xmath132 is necessarily an element of @xmath128 .",
    "hence @xmath3 also belongs to @xmath128 by invariant  [ inv : incomp2 ] , which is a contradiction since this can not hold at the call to @xmath404 .",
    "since at line  [ scc3:counter_increment ] , @xmath169 is incremented only if @xmath170 belongs to @xmath22 , we already know using invariant  [ inv : call_to_visit3 ] that @xmath169 is equal to the number of elements @xmath164 such that , at the call to @xmath514 , @xmath49 was reachable from @xmath171 .",
    "now , let @xmath527 , and consider a state @xmath515 of the algorithm in which @xmath162 and @xmath443 $ ] are both defined , and @xmath171 appears in the stack @xmath22 . since @xmath443 $ ] is defined , has been called on @xmath49 , and let @xmath518 be the state of the algorithm at that point .",
    "let us denote by @xmath519 and @xmath101 the current hypergraphs at the states @xmath518 and @xmath515 respectively .",
    "like previously , we may add a hypergraph as last argument of the function @xmath120 to distinguish its execution in the states @xmath518 and @xmath515 .",
    "we claim that @xmath528 if , and only if , @xmath529 .",
    "the `` if '' part is due to the fact that reachability in @xmath521 is not altered by the vertex merging steps ( proposition  [ prop : collapse ] ) .",
    "conversely , if @xmath49 is not reachable from @xmath530 in @xmath519 , then @xmath530 is not in the call stack @xmath531 ( invariant  [ inv : call_to_visit3 ] ) , so that it is an element of @xmath520 . but",
    "@xmath532 , which contradicts our assumption since by invariant  [ inv : comporstack ] , an element can not be stored in @xmath533 and @xmath534 at the same time .",
    "it follows that if @xmath162 is defined and @xmath171 appears in the stack @xmath22 , @xmath169 is equal to the number of elements @xmath164 such that @xmath443 $ ] is defined and @xmath535 .",
    "let @xmath515 be the state of the algorithm when @xmath171 is moved from @xmath22 to @xmath128 .",
    "the invariant still holds . besides , in the future states @xmath536",
    ", @xmath169 is not incremented because @xmath537 ( invariant  [ inv : incomp ] ) , so that @xmath538 , and the latter can not appear in the stack @xmath539 ( invariant  [ inv : comporstack ] ) .",
    "furthermore , any vertex reachable from @xmath540 in @xmath159 belongs to @xmath541 ( invariant  [ inv : incomp2 ] ) .",
    "it even belongs to @xmath533 , as shown in the second part of the proof of invariant  [ inv : incomp2 ] ( emphasized sentence ) .",
    "it follows that the number of reachable vertices from @xmath171 has not changed between states @xmath515 and @xmath536 .",
    "therefore , the invariant on @xmath169 will be preserved , which completes the proof .",
    "it can be shown by strong induction on the number @xmath28 of times that this line has been executed .",
    "suppose that we are currently at line  [ scc3:begin_node_merging ] , and let @xmath542 be the elements of the stack located above the root @xmath543 of the terminal scc of @xmath102 .",
    "any arc @xmath13 which will transferred to @xmath145 from line  [ scc3:begin_node_merging ] to line  [ scc3:end_node_merging ] satisfies @xmath544 and @xmath545 for some @xmath546 ( since at  [ scc3:begin_node_merging ] , @xmath145 is initially empty ) .",
    "invariant  [ inv : ce ] implies that for all elements @xmath164 , @xmath526 is reachable from @xmath232 in @xmath102 , so that by terminality of the scc @xmath547 , @xmath526 belongs to @xmath38 , _",
    "i.e. _  there exists @xmath249 such that @xmath548 .",
    "it follows that at line  [ scc3:end_node_merging ] , @xmath549 for all @xmath164 .",
    "then , we claim that @xmath550 at line  [ scc3:end_node_merging ] .",
    "indeed , @xmath551 satisfies @xmath552 if , and only if :    * either it has been copied to @xmath145 at line  [ scc3:f_push ] , in which case @xmath553 , * or it has been copied to @xmath145 at the @xmath554-th execution of line  [ scc3:f_assign2 ] , with @xmath555 . by induction hypothesis",
    ", this means that @xmath556 has been pushed on a stack @xmath557 and then popped from it strictly before the @xmath554-th execution of line  [ scc3:f_assign2 ] .",
    "observe that a given hyperarc can be popped from a stack @xmath558 at most once during the whole execution of .",
    "here , @xmath13 has been popped from @xmath559 after the @xmath28-th execution of line  [ scc3:f_assign2 ] , and @xmath513 .",
    "it follows that @xmath550 .",
    "conversely , suppose for that , at line  [ scc3:f_assign2 ] , @xmath550 , and all the @xmath164 satisfies @xmath549 .",
    "clearly , @xmath513 ( otherwise , @xmath13 would have been placed into @xmath145 at line  [ scc3:f_push ] and @xmath560 would be equal to @xmath476 ) .",
    "few steps before , at line  [ scc3:begin_node_merging ] , @xmath526 is equal to one of @xmath258 , @xmath561 .",
    "since @xmath562 $ ] is defined ( @xmath258 is an element of the stack @xmath22 ) , by invariant  [ inv : tindex ] , @xmath443 $ ] is also defined for all @xmath164 , hence , the root @xmath162 is defined by invariant  [ inv : re ] . besides , @xmath171 is equal to one of the @xmath258 , say @xmath272 ( since @xmath563 ) .",
    "as all the @xmath526 are reachable from @xmath171 in @xmath102 , then @xmath564 using invariant  [ inv : ce ] .",
    "it follows that @xmath13 has been pushed on the stack @xmath149 , where @xmath565 in an previous state @xmath518 of the algorithm . as @xmath550",
    ", @xmath13 has not been popped from @xmath149 , and consequently , the vertex @xmath174 of @xmath519 has not involved in a vertx merging step .",
    "therefore , @xmath174 is still equal to @xmath566 .",
    "it follows that at line  [ scc3:begin_node_merging ] , @xmath13 is stored in @xmath567 , and thus it is copied to @xmath145 between lines  [ scc3:begin_node_merging ] and  [ scc3:end_node_merging ] .",
    "this completes the proof .      by proposition  [ prop : visit3 ]",
    ", line  [ scc3:f_assign2 ] can be safely removed in .",
    "it follows that the booleans @xmath560 are now useless , so that line  [ scc3:collected_init ] , the loop from lines  [ scc3:collected1_begin ] to  [ scc3:collected1_end ] , and line  [ scc3:collected2 ] can be also removed .",
    "after that , we precisely obtain the algorithm .",
    "proposition  [ prop : maxscc3 ] completes the proof ."
  ],
  "abstract_text": [
    "<S> we study the complexity of some algorithmic problems on directed hypergraphs and their strongly connected components ( sccs ) . </S>",
    "<S> the main contribution is an almost linear time algorithm computing the terminal strongly connected components ( _ i.e. _  sccs which do not reach any components but themselves ) . _ </S>",
    "<S> almost linear _ here means that the complexity of the algorithm is linear in the size of the hypergraph up to a factor @xmath0 , where @xmath1 is the inverse of ackermann function , and @xmath2 is the number of vertices . our motivation to study </S>",
    "<S> this problem arises from a recent application of directed hypergraphs to computational tropical geometry .    </S>",
    "<S> we also discuss the problem of computing all sccs . </S>",
    "<S> we establish a superlinear lower bound on the size of the transitive reduction of the reachability relation in directed hypergraphs , showing that it is combinatorially more complex than in directed graphs . besides , we prove a linear time reduction from the well - studied problem of finding all minimal sets among a given family to the problem of computing the sccs . only subquadratic time algorithms are known for the former problem . </S>",
    "<S> these results strongly suggest that the problem of computing the sccs is harder in directed hypergraphs than in directed graphs . </S>"
  ]
}