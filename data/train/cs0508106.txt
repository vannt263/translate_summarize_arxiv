{
  "article_text": [
    "on one hand , termination analysis of logic programs is a fairly established research topic within the logic programming community , see the surveys @xcite . for prolog , various tools are now available via web interfaces and we note that the mercury compiler , designed with industrial goals in mind by its implementors , has included two termination analyzers ( see @xcite and @xcite ) for a few years .",
    "on the other hand , non - termination analysis seems to remain a much less attractive subject .",
    "we can divide this line of research into two kinds of approaches : dynamic versus static analysis . in the former one ,",
    "@xcite sets up some solid foundations for loop checking , while some recent work is presented in @xcite .",
    "the main idea is to prune at runtime at least all infinite derivations , and possibly some finite ones . in the latter approach , which includes the work we present in this article , @xcite present an algorithm for detecting non - terminating atomic queries with respect to a binary clause of the type @xmath0 .",
    "the condition is described in terms of rational trees , while we aim at generalizing non - termination analysis for the generic clp(x ) framework .",
    "our analysis shares with some work on termination analysis @xcite a key component : the binary unfoldings of a logic program @xcite , which transforms a finite set of definite clauses into a possibly infinite set of facts and binary definite clauses . while some termination analyses begin with the analysis of the recursive binary clauses of an upper approximation of the binary unfoldings of an abstract clp(n ) version of the original program , we start from a finite subset of the binary unfoldings of the concrete program @xmath1 ( a larger subset may increase the precision of the analysis , see @xcite for some experimental evidence ) .",
    "first we detect patterns of non - terminating atomic queries for binary recursive clauses and then propagate this non - termination information to compute classes of atomic queries for which we have a finite proof that there exists at least one infinite derivation with respect to the subset of the binary unfoldings of @xmath1 .",
    "the equivalence of termination for a program or its binary unfoldings given in @xcite is a corner stone of both analyses .",
    "it allows us to conclude that any atomic query belonging to the identified above classes of queries admits an infinite left derivation with respect to @xmath1 .",
    "so in this paper , we deliberately choose to restrict the analysis to binary clp clauses and atomic clp queries as the result we obtain can be directly lifted to full clp .",
    "our initial motivation , see @xcite , is to complement termination analysis with non - termination inside the logic programming paradigm in order to detect optimal termination conditions expressed in a language describing classes of queries .",
    "we started from a generalization of the lifting lemma where we may ignore some arguments .",
    "for instance , from the clause @xmath2 , we can conclude that the atomic query @xmath3 loops for any term @xmath4 , thus ignoring the second argument .",
    "then we have extended the approach , see @xcite which gives the full picture of the non - termination analysis , an extensive experimental evaluation , and a detailed comparison with related works .",
    "for instance , from the clause @xmath5 , and with the help of the criterion designed in @xcite we can now conclude that @xmath3 loops for any term @xmath4 which is an instance of @xmath6 .",
    "although we obtained interesting experimental results from such a criterion , the overall approach remains quite syntactic , with an _ ad hoc _ flavor and tight links to some basic logic programming machinery such as the unification algorithm .",
    "so we moved to the constraint logic programming scheme : in @xcite , we started from a generic definition of the generalization of the lifting lemma we were looking for . such a definition was practically useless but we were able to give a sufficient condition expressed as a logical formula related to the constraint binary clause @xmath7 under consideration .",
    "for some constraint domains , we showed that the condition is also necessary .",
    "depending on the constraint theory , the validity of such a condition can be automatically decided .",
    "moreover , we showed that the syntactic criterion we used in @xcite was actually equivalent to the logical criterion and could be considered as a correct and complete implementation specialized for the algebra of finite trees @xmath8 .",
    "the main contribution of this article consists in a strict generalization of the logical criterion defined in @xcite which allows us to reconstruct the syntactic approaches described in @xcite and @xcite .",
    "we emphasize the improvement with respect to @xcite in sect .",
    "[ section - special - kind - filter ] ( see example  [ ex - stric - generalization ] ) .",
    "the paper is organized as follows .",
    "first , in sect .  [ sect - preliminaries ] , we introduce some preliminary definitions .",
    "then , in sect",
    ".  [ section - loop - inference - with - constraints ] , we recall , using clp terms , the subsumption test to detect looping queries . in sect .",
    "[ section - loop - filters ] , we present our generalized criterion for detecting looping queries , whilst in sect .  [ section - special - kind - filter ] we consider the connections with the results of  @xcite .",
    "for any non - negative integer @xmath9 , @xmath10 $ ] denotes the set @xmath11 . if @xmath12 , then @xmath10=\\emptyset$ ] .      throughout this paper ,",
    "we consider a fixed , infinite and denumerable set of variables @xmath13 .",
    "a _ signature _ defines a set of function and predicate symbols and associates an _ arity _ with each symbol .",
    "if @xmath14 is a first order formula on a signature @xmath15 and @xmath16 is a set of variables , then @xmath17 ( resp .",
    "@xmath18 ) denotes the formula @xmath19 ( resp .",
    "@xmath20 ) .",
    "we let @xmath21 ( resp .",
    "@xmath22 ) denote the existential ( resp .",
    "universal ) closure of @xmath14 .",
    "a _ @xmath15-structure _",
    "@xmath23 is an interpretation of the symbols in the signature @xmath15 .",
    "it is a pair @xmath24)$ ] where @xmath25 is a set called the _",
    "domain _ of @xmath23 and @xmath26 $ ] maps :    * each function symbol @xmath27 of arity @xmath9 in @xmath15 to a function @xmath28 : d^n \\rightarrow d$ ] , * each predicate symbol @xmath29 of arity @xmath9 in @xmath15 to a boolean function @xmath30 : d^n \\rightarrow \\{0,1\\}$ ] .",
    "a _ @xmath23-valuation _ ( or simply a _ valuation _ if the @xmath15-structure @xmath23 is understood ) is a mapping @xmath31 .",
    "every @xmath23-valuation @xmath32 extends ( by morphism ) to terms :    * @xmath33(v(t_1),\\dots , v(t_n))$ ] if @xmath34 is a term .",
    "a @xmath23-valuation @xmath32 induces a valuation @xmath26_v$ ] of formulas to @xmath35 :    * @xmath36_v : = [ p](v(t_1),\\dots , v(t_n))$ ] if @xmath37 is an atomic proposition , * if @xmath38 and @xmath39 are formulas and @xmath40 , @xmath41_v$ ] and @xmath42_v$ ] are deduced from @xmath43_v$ ] , @xmath44_v$ ] and the truth table of @xmath45 and @xmath46 , * if @xmath47 is a variable and @xmath14 is a formula , @xmath48_v=1 $ ] if and only if there exists a valuation @xmath49 such that @xmath50_{v'}=1 $ ] and for each variable @xmath51 distinct from @xmath47 , @xmath52 , * if @xmath47 is a variable and @xmath14 is a formula , @xmath53_v=1 $ ] if and only if @xmath50_{v'}=1 $ ] for every valuation @xmath49 such that for each variable @xmath51 distinct from @xmath47 , @xmath52 .    given a formula @xmath14 , we write @xmath54 if @xmath50_v=1 $ ] and @xmath55 if @xmath50_v=0 $ ] .",
    "we write @xmath56 if and only if for every @xmath23-valuation @xmath32 , we have @xmath54 . notice that @xmath57 if and only if @xmath56 , that @xmath58 if and only if there exists a @xmath23-valuation @xmath32 such that @xmath54 , and that @xmath59 if and only if @xmath60 .    given a @xmath15-structure @xmath23 , we say that a @xmath15-formula @xmath14 is _ satisfiable _ ( resp .",
    "_ unsatisfiable _ ) in @xmath23 if @xmath58 ( resp .",
    "@xmath60 ) .",
    "we say that @xmath23 is a _ model _ of a set @xmath61 of @xmath15-formulas if for each element @xmath14 of @xmath61 we have @xmath56 . given two sets @xmath61 and @xmath62 of @xmath15-formulas",
    ", we say that @xmath61 _ semantically implies _",
    "@xmath62 , written @xmath63 , if every model of @xmath61 is also a model of @xmath62 .",
    "sequences of distinct variables are denoted by @xmath64 , @xmath65 , @xmath66 , @xmath67 ,  and sequences of ( not necessarily distinct ) terms are denoted by @xmath68 , @xmath69 ,  given two sequences of @xmath9 terms @xmath70 and @xmath71 , we write @xmath72 either to denote the formula @xmath73 or as a shorthand for  @xmath74 and  and @xmath75 \" . moreover , given a valuation @xmath32 ,",
    "we write @xmath76 to denote the sequence @xmath77 . finally , given a sequence @xmath78 of distinct variables and",
    "given a formula @xmath14 , we write @xmath79 ( resp .",
    "@xmath80 ) to denote the formula @xmath81 ( resp @xmath82 ) .",
    "we recall some basic definitions about clp , see  @xcite for more details . in this paper",
    ", we consider a constraint logic programming language clp(@xmath83 ) based on the constraint domain @xmath84 .",
    "the constraint domain signature @xmath85 is a pair @xmath86 where @xmath87 is a set of function symbols and @xmath88 is a set of predicate symbols .",
    "the domain of computation @xmath89 is a @xmath85-structure @xmath90_{\\mathcal{c}})$ ] that is the intended interpretation of the constraints .",
    "we assume the following :    * @xmath83 is ideal , * the predicate symbol @xmath91 is in @xmath85 and is interpreted as identity in @xmath92 , * @xmath89 and @xmath93 correspond on @xmath94 , * @xmath93 is satisfaction complete with respect to @xmath94 , * the theory and the solver agree in the sense that for every @xmath95 , @xmath96 if and only if @xmath97 . consequently , as @xmath89 and @xmath93 correspond on @xmath94 , we have , for every @xmath95 , @xmath96 if and only if @xmath98 .",
    "[ example - reals ] the constraint domain @xmath99 has @xmath100 , @xmath101 , @xmath91 , @xmath102 and @xmath103 as predicate symbols , @xmath104 , @xmath105 , @xmath106 , @xmath107 as function symbols and sequences of digits ( possibly with a decimal point ) as constant symbols .",
    "only linear constraints are admitted .",
    "the domain of computation is the structure with reals as domain and where the predicate symbols and the function symbols are interpreted as the usual relations and functions over reals .",
    "the theory @xmath108 is the theory of real closed fields  @xcite .",
    "a constraint solver for @xmath99 always returning either true or false is described in  @xcite .",
    "[ example - lp ] the constraint domain @xmath8 has @xmath91 as predicate symbol and strings of alphanumeric characters as function symbols . the domain of computation of @xmath8 is the set of _ finite trees _",
    "( or , equivalently , of finite terms ) , @xmath109 , while the theory @xmath110 is clark s equality theory  @xcite .",
    "the interpretation of a constant is a tree with a single node labeled with the constant .",
    "the interpretation of an @xmath9-ary function symbol @xmath27 is the function @xmath111 mapping the trees @xmath112 ,  , @xmath113 to a new tree with root labeled with @xmath27 and with @xmath112 , ",
    ", @xmath113 as child nodes .",
    "a constraint solver always returning either true or false is provided by the _ unification _ algorithm .",
    "clp(@xmath114 coincides then with logic programming .",
    "the signature in which all programs and queries under consideration are included is @xmath115 with @xmath116 and @xmath117 where @xmath118 , the set of predicate symbols that can be defined in programs , is disjoint from @xmath88 .",
    "we assume that each predicate symbol @xmath29 in @xmath119 has a unique arity denoted by @xmath120 .",
    "an _ atom _ has the form @xmath121 where @xmath122 and @xmath69 is a sequence of @xmath120 @xmath123-terms . throughout this paper , when we write @xmath121 , we implicitly assume that @xmath69 contains @xmath120 terms . a clp(@xmath83 ) _ program _ is a finite set of rules",
    "rule _ has the form @xmath124 where @xmath125 and @xmath126 are atoms and @xmath127 is a finite conjunction of primitive constraints such that @xmath128 .",
    "a _ query _ has the form @xmath129 where @xmath130 is an atom and @xmath131 is a finite conjunction of primitive constraints .",
    "given an atom @xmath132 , we write @xmath133 to denote the predicate symbol @xmath29 . given a query @xmath134 , we write @xmath135 to denote the predicate symbol @xmath133 .",
    "the set of variables occurring in some syntactic objects @xmath136 is denoted @xmath137 .",
    "the examples of this paper make use of the language clp(@xmath99 ) and the language clp(@xmath8 ) . in program and query examples ,",
    "variables begin with an upper - case letter , @xmath138 $ ] denotes a list with head @xmath139 and tail @xmath140 , and @xmath141 $ ] denotes an empty list .",
    "we consider the following operational semantics given in terms of _ derivations _ from queries to queries .",
    "let @xmath142 be a query and @xmath143 be a rule .",
    "let @xmath144 be a variant of @xmath145 variable disjoint with @xmath142 such that @xmath146 .",
    "then , @xmath147 is a _ derivation step _ of @xmath142 with respect to @xmath145 with @xmath148 as its _",
    "input rule_. we write @xmath149 to summarize a finite number ( @xmath150 ) of derivation steps from @xmath61 to @xmath151 where each input rule is a variant of a rule from program @xmath1 .",
    "let @xmath152 be a query . a sequence of derivation steps @xmath153 of maximal length",
    "is called a _ derivation _ of @xmath154 if @xmath155 , @xmath156 ,  are rules from @xmath1 and if the _ standardization apart _ condition holds , _",
    "i.e. _ each input rule used is variable disjoint from the initial query @xmath152 and from the input rules used at earlier steps .",
    "we say @xmath152 _ loops _ with respect to @xmath1 if there exists an infinite derivation of @xmath154 .",
    "in the logic programming framework , the subsumption test provides a simple way to infer looping queries : if , in a logic program @xmath1 , there is a rule @xmath157 such that @xmath121 is more general than @xmath158 , then the query @xmath158 loops with respect to @xmath1 . in this section",
    ", we extend this result to the constraint logic programming framework .",
    "a query can be viewed as a finite description of a possibly infinite set of atoms , the arguments of which are values from @xmath92 .",
    "suppose that @xmath159 .",
    "* the query @xmath160 describes those atoms @xmath161 where @xmath162 is a real and the term @xmath163 can be made equal to @xmath162 while the constraint @xmath164 is satisfied . * the query @xmath165 describes those atoms @xmath166 where @xmath162 and @xmath167 are reals and @xmath47 and @xmath51 can be made equal to @xmath162 and @xmath167 respectively while the constraint @xmath168 is satisfied .    in order to capture this intuition ,",
    "we introduce the following definition .",
    "the set of atoms that is described by a query @xmath169 is denoted by @xmath170 and is defined as : @xmath171 .",
    "clearly , @xmath172 if and only if @xmath131 is unsatisfiable in @xmath89",
    ". moreover , two variants describe the same set .",
    "notice that the operational semantics we introduced above can be expressed using sets described by queries :    [ lemma - operational - sem ] let @xmath61 be a query and @xmath173 be a rule .",
    "there exists a derivation step of @xmath61 with respect to @xmath145 if and only if @xmath174 .",
    "the  more general than \" relation we consider is defined as follows :    we say that a query @xmath151 is _ more general than _ a query @xmath61 if @xmath175 .    * in any constraint domain , @xmath176 is more general than any query @xmath61 verifying @xmath177 ; * in the constraint domain @xmath8 , the query @xmath178 is more general than the query @xmath179 ; * in the constraint domain @xmath99 , the query @xmath165 is more general than the query @xmath180 .",
    "suppose we have a derivation step @xmath181 where @xmath173 .",
    "then , by lemma  [ lemma - operational - sem ] , @xmath174 .",
    "hence , if @xmath151 is a query that is more general than @xmath61 , as @xmath182 , we have @xmath183 .",
    "so , by lemma  [ lemma - operational - sem ] , there exists a query @xmath184 such that @xmath185 .",
    "the following lifting result says that , moreover , @xmath184 is more general than @xmath62 :    [ theorem - lifting ] consider a derivation step @xmath186 and a query @xmath151 that is more general than @xmath61 .",
    "then , there exists a derivation step @xmath187 where @xmath184 is more general than @xmath62 .    from this theorem , we derive two corollaries that can be used to infer looping queries just from the text of a clp(@xmath83 ) program :    [ coro - p - if - p ] let @xmath173 be a rule",
    ". if @xmath188 is more general than @xmath189 then @xmath189 loops with respect to @xmath190 .",
    "[ coro - p - if - q ] let @xmath173 be a rule from a program @xmath1 .",
    "if @xmath188 loops with respect to @xmath1 then @xmath189 loops with respect to @xmath1 .",
    "[ ex - loop - inference - append ] consider the clp(@xmath8 ) rule @xmath145 : @xmath191,\\mathit{ys } ,    [ x|\\mathit{zs } ] ) \\leftarrow \\mathit{true } \\diamond    \\mathit{append}(\\mathit{xs},\\mathit{ys},\\mathit{zs})\\ ] ] we note that the query @xmath192 is more general than the query @xmath193,\\mathit{ys } ,    [ x|\\mathit{zs}])}\\,|\\,{\\mathit{true}}\\rangle}$ ] .",
    "so , by corollary  [ coro - p - if - p ] , @xmath61 loops with respect to @xmath190 . therefore , there exists an infinite derivation @xmath194 of @xmath195 .",
    "then , if @xmath151 is a query that is more general than @xmath61 , by successively applying the lifting theorem  [ theorem - lifting ] to each step of @xmath194 , one can construct an infinite derivation of @xmath196 .",
    "so , @xmath151 also loops with respect to @xmath190 .",
    "the condition provided by corollary  [ coro - p - if - p ] is rather weak because it fails at inferring looping queries in some simple cases .",
    "this is illustrated by the following example .",
    "[ example - neutral - rlin ] assume @xmath197 .",
    "let @xmath198 we have the infinite derivation : @xmath199 where : @xmath200 but as in @xmath145 , @xmath201 is not more general than @xmath202 , corollary  [ coro - p - if - p ] does not allow to infer that @xmath202 loops with respect to @xmath190 .    in this section , we extend the relation `` is more general '' . instead of comparing atoms in all positions using the `` more general '' relation , we distinguish some predicate argument positions for which we just require that a certain property must hold , while for the other positions we use the `` more general '' relation as before",
    ". doing so , we aim at inferring more looping queries .",
    "[ example - neutral - rlin - continued ] let us consider argument position 1 of predicate symbol @xmath29 . in the rule @xmath145 , the argument of @xmath203 in position 1 is @xmath47 and the argument of @xmath204 in position 1 is @xmath205 .",
    "notice that the condition on @xmath47 in @xmath127 is @xmath206 and that if @xmath206 then @xmath207 .",
    "hence , let us define the condition @xmath208 as : a query satisfies @xmath208 if it has the form @xmath209 where @xmath210 and @xmath211 are some terms and @xmath212 is included in the set of positive real numbers .",
    "then , both @xmath213 and @xmath214 satisfy @xmath208 .",
    "so , if we consider a",
    " more general than \" relation where we",
    " filter \" queries using @xmath208 , as @xmath61 and @xmath62 both satisfy @xmath208 and as the  piece \" @xmath215 of @xmath62 is more general than the  piece \" @xmath216 of @xmath61 , by an extended version of corollary  [ coro - p - if - p ] we could infer that @xmath61 loops with respect to @xmath190 .      a basic idea in example",
    "[ example - neutral - rlin - continued ] lies in identifying argument positions of predicate symbols .",
    "below , we introduce a formalism to do so .",
    "a _ set of positions _ , denoted by @xmath217 , is a function that maps each predicate symbol @xmath218 to a subset of @xmath219 $ ] .",
    "[ example - set - of - pos ] if we want to distinguish the first argument position of the predicate symbol @xmath29 defined in example  [ example - neutral - rlin ] , we set @xmath220 .",
    "let @xmath217 be a set of positions .",
    "then , @xmath221 is the set of positions defined as : for each predicate symbol @xmath218 , @xmath222\\setminus\\tau(p)$ ] .",
    "we have @xmath223 .",
    "using a set of positions @xmath217 , one can _ project _",
    "syntactic objects :    [ def - projection ] let @xmath217 be a set of positions .",
    "* let @xmath224 be a predicate symbol .",
    "the _ projection of @xmath29 on @xmath217 _ is the predicate symbol denoted by @xmath225 .",
    "its arity equals the number of elements of @xmath226 . *",
    "let @xmath224 be a predicate symbol of arity @xmath9 and @xmath71 be a sequence of @xmath9 terms .",
    "the _ projection of @xmath69 on @xmath217 _ , denoted by @xmath227 is the sequence @xmath228 where @xmath229 and @xmath230 .",
    "* let @xmath132 be an atom .",
    "the _ projection of @xmath130 on @xmath217 _ , denoted by @xmath231 , is the atom @xmath232 . *",
    "the _ projection of a query @xmath129 on @xmath217 _ , denoted by @xmath233 , is the query @xmath234 .",
    "[ example - restriction ] the projection of the query @xmath202 on @xmath217 is the query @xmath235 .      according to the intuitions described in example",
    "[ example - neutral - rlin - continued ] above , we define a filter as follows .    [ def - filter ] a _ filter _ , denoted by @xmath236 , is a pair @xmath237 where @xmath217 is a set of positions and @xmath208 is a function that maps each predicate symbol @xmath218 to a query of the form @xmath238 where @xmath239 and @xmath240 is a sequence of @xmath241 terms .",
    "[ ex - filter - rlin ] let @xmath208 be the function defined as @xmath242 .",
    "then , @xmath243 is a filter .",
    "[ ex - filter - term ] suppose that @xmath244 .",
    "let @xmath245 be a predicate symbol whose arity is 1 .",
    "let @xmath246 and @xmath247 . then , @xmath243 is a filter .",
    "the function @xmath208 is used to  filter \" queries as indicated by the next definition .",
    "[ def - satisfies ] let @xmath243 be a filter and @xmath61 be a query .",
    "let @xmath248 .",
    "we say that @xmath61 _ satisfies _",
    "@xmath236 if @xmath249",
    ".    now we come to the extension of the relation  more general than \" . intuitively , @xmath250 is @xmath236-more general than @xmath251 if the ",
    "more general than \" relation holds for the elements of @xmath69 and @xmath252 whose position is not in @xmath217 while the elements of @xmath252 whose position is in @xmath217 satisfy @xmath208 .",
    "more formally :    [ def - delta - more - gen - state ] let @xmath243 be a filter and @xmath61 and @xmath151 be two queries .",
    "we say that @xmath151 is _",
    "@xmath236-more general than _",
    "@xmath61 if @xmath253 is more general than @xmath254 and @xmath151 satisfies @xmath236 .    * in the context of example  [ ex - filter - rlin ] , @xmath255 is @xmath236-more general than @xmath256 . * in the context of example  [ ex - filter - term ] , @xmath257 is @xmath236-more general than @xmath258 .",
    "notice that for any filter @xmath243 and any query @xmath61 , we have that @xmath254 is more general than itself ( because the  more general than \" relation is reflexive ) , but @xmath61 may not satisfy @xmath236 .",
    "hence , the  @xmath236-more general than \" relation is not always reflexive .",
    "@xmath259 is not @xmath236-more general than itself because , as @xmath260 and @xmath261 , we have @xmath262 .",
    "hence , @xmath61 does not satisfy @xmath236 .",
    "the fact that reflexivity does not always hold is an expected property . indeed , suppose that a filter @xmath243 induces a  @xmath236-more general than \" relation that is reflexive .",
    "then for any queries @xmath61 and @xmath151 , we have that @xmath151 is @xmath236-more general than @xmath61 if and only if @xmath253 is more general than @xmath254 ( because , as @xmath151 is @xmath236-more general than itself , @xmath151 necessarily satisfies @xmath236 ) .",
    "hence , @xmath208 is useless in the sense that it  does not filter anything \" .",
    "filters equipped with such a @xmath208 are studied in sect .  [ section - special - kind - filter ] and",
    "were introduced in  @xcite where for any predicate symbol @xmath29 , @xmath263 is @xmath264 . in this paper",
    ", we aim at generalizing the approach of  @xcite .",
    "hence , we also consider functions @xmath208 that really filter queries .      in the sequel of this paper ,",
    "we focus on  derivation neutral \" filters .",
    "the name  derivation neutral \" stems from the fact that if , in a derivation of a query @xmath61 , we replace @xmath61 by @xmath151 that satisfies the filter , then we get a  similar \" derivation .",
    "[ def - dn - filter ] let @xmath145 be a rule and @xmath236 be a filter .",
    "we say that @xmath236 is _ dn _ for @xmath145 if for each derivation step @xmath186 and each query @xmath151 that is @xmath236-more general than @xmath61 , there exists a derivation step @xmath185 where @xmath184 is @xmath236-more general than @xmath62 .",
    "this definition is extended to programs : @xmath236 is _ dn _ for @xmath1 if it is dn for each rule of @xmath1 .",
    "derivation neutral filters lead to the following extended version of corollary  [ coro - p - if - p ] ( to get corollary  [ coro - p - if - p ] , take @xmath243 such that @xmath265 for any @xmath29 ) .",
    "[ propo - p - if - p - delta ] let @xmath266 be a rule .",
    "let @xmath236 be a filter that is dn for @xmath145 .",
    "if @xmath188 is @xmath236-more general than @xmath189 then @xmath189 loops with respect to @xmath190 .",
    "suppose that @xmath236 is dn for @xmath145 .",
    "now we can deduce that the query @xmath256 loops with respect to @xmath145 because the query @xmath255 is @xmath236-more general than the query @xmath256 .",
    "computing a neutral filter from the text of a program is not that easy if we use the definition above .",
    "the next subsections present a logical and a syntactic characterization that can be used to compute a filter that is dn for a given program .      from now on ,",
    "we suppose that , without loss of generality , a rule has the form @xmath267 where @xmath64 and @xmath65 are disjoint sequences of distinct variables . hence , @xmath127 is the conjunction of all the constraints , including unifications .",
    "we distinguish the following set of variables that appear inside such a rule .",
    "let @xmath268 be a rule .",
    "the set of _ local variables _ of @xmath145 is denoted by @xmath269 and is defined as : @xmath270 .    in this section",
    ", we aim at characterizing dn filters in a logical way . to this end , we define :    let @xmath271 be a query and @xmath68 be a sequence of @xmath120 terms .",
    "then , @xmath272 denotes a formula of the form @xmath273 where @xmath274 is any variant of @xmath61 variable disjoint with @xmath68 .",
    "clearly , the satisfiability of @xmath272 does not depend on the choice of the variant of @xmath61 .",
    "now we give a logical definition of derivation neutrality .",
    "as we will see below , under certain circumstances , this definition is equivalent to the operational one we gave above .",
    "[ def - log - dn ] we say that a filter @xmath243 is _ dnlog _ for a rule @xmath268 if @xmath275    \\big]\\ ] ] where @xmath276 .    intuitively , the formula in definition  [ def - log - dn ] has the following meaning .",
    "if one holds a solution @xmath32 for constraint @xmath127 , then , changing the value given to the variables of @xmath64 distinguished by @xmath217 to some value satisfying @xmath263 , there exists a value for the local variables and the variables of @xmath65 distinguished by @xmath217 such that @xmath127 is still satisfied .",
    "suppose that @xmath197 .",
    "consider the rule @xmath277 where @xmath127 is the constraint @xmath278 .",
    "then , the local variables of @xmath145 are @xmath130 and @xmath126 .",
    "any filter @xmath243 where @xmath279 and @xmath280 is dnlog for @xmath145 .",
    "indeed , @xmath281 , @xmath282 and @xmath283 is true if and only if @xmath284 .",
    "so the formula of definition  [ def - log - dn ] turns into @xmath285\\big]$ ] , which is true .",
    "[ example - dnlog - term ] suppose that @xmath244 .",
    "consider the rule @xmath286 where @xmath127 is the constraint @xmath287 .",
    "then , the only local variable of @xmath145 is @xmath130 .",
    "any filter @xmath243 where @xmath279 and @xmath288 is dnlog for @xmath145 .",
    "indeed , @xmath289 , @xmath290 and @xmath283 is true if and only if @xmath4 has the form @xmath291 .",
    "so the formula of definition  [ def - log - dn ] turns into @xmath292\\,\\big ] ,      \\end{array}\\ ] ] which is true .",
    "the logical definition of derivation neutrality implies the operational one :    [ prop - dnlog - implies - dn ] let @xmath145 be a rule and @xmath236 be a filter .",
    "if @xmath236 is dnlog for @xmath145 then @xmath236 is dn for @xmath145",
    ".    the reverse implication does not always hold .",
    "but when considering a special case of the ( @xmath293 ) condition of _ solution compactness _ given in @xcite , we get :    [ prop - dn - implies - dnlog2 ] let @xmath145 be a rule and @xmath236 be a filter .",
    "assume @xmath83 enjoys the following property : for each @xmath294 , there exists a ground @xmath85-term @xmath295 such that @xmath296=\\alpha$ ] .",
    "then , @xmath236 is dn for @xmath145 if and only if @xmath236 is dnlog for @xmath145 .",
    "we show how the ( @xmath293 ) condition is used to get this result .    by proposition  [ prop - dnlog - implies - dn ]",
    ", we just have to establish that dn @xmath297 dnlog .",
    "let @xmath298 and @xmath299 .",
    "suppose that @xmath236 is dn for @xmath145 .",
    "we have to prove that then , the formula of definition  [ def - log - dn ] holds .",
    "assume that @xmath32 is a valuation such that @xmath300 by property of @xmath83 , we can consider the query @xmath301 where @xmath302 is a sequence of ground terms such that @xmath303=v(\\tilde{x})$ ] .",
    "as @xmath145 and @xmath61 are variable disjoint , we have @xmath181 where @xmath62 is the query @xmath304 .    as we assumed  ( [ eq1-theo - dn - iff - dnlog ] ) , we have to establish that @xmath305    \\big]$ ] holds .",
    "assume @xmath306 is a valuation such that @xmath307 and for each variable @xmath308 , @xmath309 . by property of @xmath83",
    ", we can consider the query @xmath310 where @xmath311 and @xmath312 is a sequence of ground terms such that @xmath313 = v_1({\\tilde{x}_{\\tau}})$ ] .",
    "it can be noticed that @xmath151 is @xmath236-more general than @xmath61 .",
    "as @xmath236 is dn for @xmath145 , there exists a query @xmath184 that is @xmath236-more general than @xmath62 and such that @xmath185 .",
    "necessarily , @xmath314 where @xmath315 is a variant of @xmath145 variable disjoint with @xmath151 .",
    "as we assumed  ( [ eq2-theo - dn - iff - dnlog ] ) , we now have to establish that @xmath316 $ ] holds .",
    "this is done using the fact that @xmath184 is @xmath236-more general than @xmath62 and that @xmath317 .    in the constraint domain @xmath8 , dn is equivalent to dnlog .",
    "in  @xcite , we gave , in the scope of logic programming , a syntactic definition of neutral arguments .",
    "now we extend this syntactic criterion to the more general framework of constraint logic programming .",
    "first , we need rules in flat form :    a rule @xmath318 is said to be _ flat _ if @xmath127 has the form @xmath319 where @xmath68 is a sequence of @xmath120 terms and @xmath69 is a sequence of @xmath320 terms such that @xmath321 .",
    "notice that there are some rules @xmath268 for which there exists no `` equivalent '' rule in flat form .",
    "more precisely , there exists no rule @xmath322 verifying @xmath323 ( take for instance @xmath324 in @xmath99 . )    syntactic derivation neutrality is defined that way :    [ def - syn - dn ] let @xmath243 be a filter and @xmath325 be a flat rule .",
    "we say that @xmath236 is _ dnsyn _ for @xmath145 if    * @xmath326 is more general than @xmath263 , * @xmath327 is more general than @xmath328 , * @xmath329 , * @xmath330 .    in example",
    "[ example - dnlog - term ] , the rule @xmath145 is flat .",
    "moreover , the filter @xmath236 is dnsyn for @xmath145 .    a connection between dn , dnsyn and dnlog is as follows :    [ prop - dnsyn - implies - dn ] [ prop - dnsyn - dn ]",
    "let @xmath145 be a flat rule and @xmath236 be a filter .",
    "if @xmath236 is dnsyn for @xmath145 then @xmath236 is dnlog for @xmath145 hence ( by proposition  [ prop - dnlog - implies - dn ] ) @xmath236 is dn for @xmath145 .",
    "if @xmath236 is dnlog for @xmath145 then * ( dnsyn1 ) * holds .",
    "notice that a dnlog filter is not necessarily dnsyn because one of * ( dnsyn24 ) * may not hold :    in @xmath99 , consider the flat rule @xmath145 : @xmath331 let @xmath243 where @xmath279 and @xmath280 .",
    "then , @xmath236 is dnlog for @xmath145 , but none of * ( dnsyn24 ) * hold .",
    "however , in the special case of logic programming , we have :    [ theo - dn - dnsyn - log - prog ] suppose that @xmath244 .",
    "let @xmath145 be a flat rule and @xmath236 be filter . if @xmath236 is dnlog for @xmath145 then * ( dnsyn3 ) * and * ( dnsyn4 ) * hold .",
    "the results of  @xcite can be easily obtained within the framework presented above .",
    "it suffices to consider the following special kind of filter :    [ def - does - not - filter ] we say that @xmath243 is an _",
    "open filter _ if for all @xmath122 , @xmath263 has the form @xmath332 where @xmath66 is a sequence of distinct variables .    in an open filter ,",
    "the function @xmath208  does not filter anything \" :    [ lemma - open - filters1 ] let @xmath243 be an open filter .",
    "then , a query @xmath151 is @xmath236-more general than a query @xmath61 if and only if @xmath253 is more general than @xmath254 .",
    "consequently , an open filter is uniquely determined by its set of positions .",
    "when reconsidering the definitions and results of the preceding section within such a context , we exactly get what we presented in  @xcite .",
    "in particular , definition  [ def - log - dn ] can be rephrased as :    [ def - dnlog - open - filter ] a set of positions @xmath217 is _ dnlog _ for a rule @xmath333 if @xmath334 where @xmath276 .    as stated in sect  [ section - intro ] , the framework presented in this paper is a strict generalization of that of @xcite .",
    "this is illustrated by the following example .",
    "[ ex - stric - generalization ] first , notice that , as @xmath216 is not more general than @xmath335 , corollary  [ coro - p - if - p ] does not allow to infer that @xmath335 loops with respect to @xmath190 .",
    "let us try to use definition  [ def - dnlog - open - filter ] to prove that the argument of @xmath29 is `` irrelevant '' .",
    "we let @xmath279 . hence ,",
    "@xmath289 , @xmath336 and @xmath337 .",
    "let us consider a valuation @xmath32 such that @xmath338 , @xmath339 and @xmath340 .",
    "so , we have @xmath341 .",
    "but we do not have @xmath342 .",
    "for instance , if we consider @xmath306 such that @xmath343 and @xmath344 for each variable @xmath345 distinct from @xmath47 , we do not have @xmath346 as the subformula @xmath347 of @xmath127 can not hold , whatever value is assign to @xmath130 .",
    "consequently , we do not have @xmath348 , so @xmath217 is not dnlog for @xmath145 . as @xmath244 , by theorem  [ prop - dn - implies - dnlog2 ]",
    "@xmath217 is not dn for @xmath145 . therefore , using open filters with proposition  [ propo - p - if - p - delta ] we are not able to prove that @xmath335 loops with respect to @xmath190",
    ".    however , in example  [ example - dnlog - term ] , we noticed that any filter @xmath243 where @xmath279 and @xmath288 is dnlog , hence dn , for @xmath145 .",
    "moreover , for such a filter , @xmath216 is @xmath236-more general than @xmath335 .",
    "consequently , by proposition  [ propo - p - if - p - delta ] , @xmath335 loops with respect to @xmath190 .",
    "we have presented a criterion to detect non - terminating atomic queries with respect to a binary clp clause .",
    "this criterion generalizes our previous papers in the clp settings and allows us to reconstruct the work we did in the lp framework .",
    "however , when switching from lp to clp , we lose the ability to compute , given a binary clause , a useful filter .",
    "we plan to work on this and try to define some conditions on the constraint domain which enable the computation of such filters .",
    "moreover , as pointed out by an anonymous referee , dnsyn and dnlog seem to be independent notions which we proved to coincide only for open filters with the specific constraint domain @xmath8 . in theorem  [ prop - dn - implies - dnlog2 ]",
    "we investigate the relationship between dnlog and dn while proposition  [ prop - dnsyn - implies - dn ] and proposition  [ theo - dn - dnsyn - log - prog ] essentially establish some connections between dnsyn and dnlog .",
    "the study of relationship between dnsyn and dn is still missing and we intend to work on this shortly .                d.  de  schreye , k.  verschaetse , and m.  bruynooghe .",
    "a practical technique for detecting non - terminating queries for a restricted class of horn clauses , using directed , weighted graphs . in _ proc .",
    "of iclp90 _ , pages 649663 . the mit press , 1990 .",
    "f.  mesnard , e.  payet , and u.  neumerkel . detecting optimal termination conditions of logic programs . in m.",
    "hermenegildo and g.  puebla , editors , _ proc . of the 9th international symposium on static analysis _ ,",
    "volume 2477 of _ lecture notes in computer science _ , pages 509525 .",
    "springer - verlag , berlin , 2002 .",
    "e.  payet and f.  mesnard .",
    "non - termination inference for constraint logic programs . in roberto giacobazzi , editor , _ proc . of the 11th international symposium on static analysis _ ,",
    "volume 3148 of _ lecture notes in computer science _ , pages 377392 .",
    "springer - verlag , berlin , 2004 .          c.  speirs , z.  somogyi , and h.  sndergaard .",
    "termination analysis for mercury . in p.",
    "van hentenrick , editor , _ proc . of the 1997 intl .",
    "symp . on static analysis _ ,",
    "volume 1302 of _",
    "lncs_. springer - verlag , 1997 ."
  ],
  "abstract_text": [
    "<S> on one hand , termination analysis of logic programs is now a fairly established research topic within the logic programming community . on the other hand , </S>",
    "<S> non - termination analysis seems to remain a much less attractive subject . </S>",
    "<S> if we divide this line of research into two kinds of approaches : dynamic versus static analysis , this paper belongs to the latter . </S>",
    "<S> it proposes a criterion for detecting non - terminating atomic queries with respect to binary clp clauses , which strictly generalizes our previous works on this subject . </S>",
    "<S> we give a generic operational definition and a logical form of this criterion . </S>",
    "<S> then we show that the logical form is correct and complete with respect to the operational definition . </S>"
  ]
}