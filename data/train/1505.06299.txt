{
  "article_text": [
    "several languages have been proposed to program applications based on web service orchestrations ( bpel @xcite is probably one of the best known ) .",
    "the present work is based on orc @xcite , an orchestration language whose definition is based on a mathematical semantics , which is needed to define precisely the notion of causality .",
    "orc is designed over the notion of _ sites _ , a generalization of functions that can encapsulate any kind of externally defined web sites or services as well as orc expressions . as usual for languages , the operational semantics of orc",
    "was defined as a labeled transition system .",
    "such semantics produces naturally sets of sequential traces , which explicitly represent the observable behaviors of an orc program  @xcite .",
    "finding the causal dependencies in a program is very useful for error detection . in a non - deterministic concurrent context",
    ", this analysis can not be based solely on the static structure of the program and requires execution .",
    "dependencies are also very difficult to extract from a sequential record without additional information to unravel the interleaving of events .",
    "this is especially true for the analysis of qos or of non functional properties , like timing constraints derived from the critical path of dependencies  @xcite .",
    "we consider any orc program , which has been already parsed and expanded into its orc calculus intermediate form . in this program , we distinguish the actions , which are the site calls , and the publications ( return values of expressions ) .",
    "an event is the occurrence of an action during the execution of the orc program .",
    "the events are linked by causal dependencies , that force the events to be executed in a certain order .",
    "we can distinguish three kinds of dependencies :    * the dependencies that are imposed by the control flow of the program defined by the semantics of the orc combinators and imposed by the binding mechanism of orc variables ; * the dependencies that are provided by the server executing the site calls .",
    "these external dependencies are not part of the orc description , but could be returned by the site .",
    "we will consider at least that the possible return of a site call is directly caused by this call ; * the dependencies induced by preemption ( the pruning operator of orc ) .",
    "the method used in this article is to extend the standard structural operational semantics ( sos  @xcite ) to rewrite extended expressions , in which additional information has been added to compute causal and weakly - causal dependencies .",
    "this information is also made visible by extending the labeling of transitions .",
    "concurrency is just the complement of the weak - causal relation , and conflicts are defined by cycles in this relation .",
    "capturing causality and concurrency by instrumenting the semantics rules is a difficult job .",
    "this is mainly due to the fact that these relationships are global and therefore difficult to locate on the syntactic forms .",
    "the solution is to keep information about the causal past in a context associated with each rule .",
    "we build the necessary links between different contexts during the execution of rules .",
    "the aim is that such instrumented semantics reproduces the standard behavior of the program while calculating the additional information needed to track concurrency , causality and conflicts between the events produced by the execution .",
    "after this introduction , the article presents the contribution compared to the existing works .",
    "section [ section : orc ] presents the orc language from the perspective of its core calculus and its operational semantics , illustrated using an example of orchestration of web services .",
    "section [ section : instrumentation ] presents our proposed instrumented semantics based on the construction of event structures , giving the concurrent semantics of orc .",
    "this section sets out the formal correctness of the approach stating that this new semantics produces the same executions as the standard semantics . before concluding the paper , section [ section : application ] reuses the example of section [ section : orc ] to show the causal structure obtained from its execution in the instrumented semantics and how this can be used to find errors .",
    "the need to dynamically trace the causal dependencies during the execution of the a program in order to monitor , detect errors or analyze performances is well recognized for concurrent applications .",
    "causality , seen as a partial order  @xcite , can be tracked in different ways .",
    "some works are based on an instrumentation of either the underlying operating system or the source code .",
    "for example , vector clocks have been widely used by the distributed algorithms community in the context of message - passing systems @xcite .",
    "the context of web service orchestrations is more complex as a language like orc can generate unbounded concurrency patterns . to our knowledge ,",
    "the only instrumentation made on programs is @xcite , based on java byte - code .",
    "however , in the considered model , the only source of causality comes from variable accesses .",
    "the second approach is to change the semantics so that it produces causal information which leads to a _",
    "concurrent semantics_. the challenge is then to maintain a good form of equivalence with the original semantics .",
    "several debugging techniques rely on this principle , especially for performing replay ( @xcite is a good example for a fragment of the oz language )",
    ". the most successful works in concurrent semantics were conducted on process algebra ( e.g. pi - calculus @xcite ) .",
    "our contribution is in the same vein , but for the orc language , in the complex context of wide - area computing .",
    "other attempts of concurrent semantics for orc based on event structures have already been published @xcite .",
    "they use an ad hoc connection of petri net diagrams or join calculus .",
    "it is not clear how this semantics can be implemented in practice at compile - time that transforms the source code into a concurrent model .",
    "an instrumented semantics solves this problem and allows to catch causal dependencies at runtime .",
    "orc is a full programming language , that looks like a functional language with many non - functional aspects to handle concurrency . the interested reader can refer to @xcite concerning the ability of orc to design large - scale distributed applications . the orc programming language is designed over a process calculus : the orc core calculus .",
    "all the conveniences offered in the full orc language are derived from very few central concepts present in the calculus : sites and operators .",
    "values such as booleans , numbers and strings , arithmetic and logic operators , as well as complex data types such as shared registers , are just external sites .",
    "even choices are implemented through the use of sites ` ift ` and ` iff ` , that publish a signal if their argument is true or false respectively .",
    "besides sites , four operators are provided by the calculus to orchestrate the execution .",
    "these operators describe the sequencing of actions ( `` @xmath0 '' ) , the launching of parallel threads ( `` @xmath1 '' ) and an alternative in case of no response ( `` otherwise : @xmath2 '' ) .",
    "the full syntax of the calculus is specified by the grammar given in figure [ figure : syntaxe ] . from now on , we denote by @xmath3 the set of the expressions allowed by this syntax .",
    "the expressions of the calculus that correspond to real orc programs , denoted by the set @xmath4 , are those that do not contain @xmath5 and @xmath6 expressions .",
    "@xmath7    there are two kinds of sites in orc : the external ones , denoted @xmath8 in the syntax , and the internal ones defined as an orc expression with the syntax @xmath9 where @xmath10 is the body of the site and @xmath11 is the remaining of the program in which @xmath12 can be used as any site . for the sake of clarity , we consider in this work that the sites are curryfied , so they have exactly one argument .",
    "site definitions are recursive , which allows the same expressivity as any functional language .",
    "calls to external sites are strict , i.e. their arguments have to be bound before the site can be called , while an internal site can be called immediately , and its arguments are evaluated lazily .",
    "when an external site is called , it sends its responses to a placeholder @xmath5",
    ". a response can be either a non - terminating value @xmath13 if further responses are expected , or a terminating value @xmath14 if this is the last publication of the site , or @xmath15 if the site terminates without publishing any value . in @xmath16 , the parallel composition expresses pure concurrency ; @xmath10 and @xmath11 are run in parallel , their events are interleaved and the expression stops when both @xmath10 and @xmath11 have terminated .",
    "sequentiality can be expressed by the sequential operator , like in @xmath0 , where the variable @xmath17 can be used in @xmath11 .",
    "here , @xmath10 is started first , and then a new instance of @xmath18 $ ] , where @xmath17 is bound to @xmath19 , is launched as a consequence of each publication of @xmath19 . in @xmath20 ,",
    "the pruning operator is used to express preemption .",
    "the variable @xmath17 can be used in @xmath10 .",
    "both @xmath10 and @xmath11 are started , but @xmath10 is paused when it needs to evaluate @xmath17 . when @xmath11 publishes a value , it is bound to @xmath17 in @xmath10 , and @xmath11 is stopped .",
    "other events that could have been produced by @xmath11 are preempted by the publication .",
    "for example , if @xmath11 is supposed to publish two values @xmath21 and @xmath22 , only one will be selected and published in each execution .",
    "we say that these two events are in conflict .",
    "the pruning operator is left - associative : in @xmath23 , @xmath10 , @xmath11 and @xmath24 are started in parallel , the first publication of @xmath11 is bound to @xmath17 and the first publication of @xmath24 is bound to @xmath12 . the otherwise operator is used in @xmath2 . in this expression , @xmath10 is first started alone and @xmath11 is started if and only if @xmath10 stops without publishing any value .",
    "finally , the @xmath25 symbol can be used by the programmer exactly like a site or a variable to denote a terminated program .",
    "@xmath25 still produces an event @xmath26 to notify its parent expression that it has terminated .",
    "it then evolves into @xmath6 , the inert final expression . @xmath5 and @xmath6 can not be used directly .",
    "lr [ @xmath19 closed ] + & + & [ @xmath27 fresh ] +   +   + [ @xmath28 & + [ @xmath28 & + & + & + & + & + & [ @xmath28 + & +      @xmath29 find_best(agencies , destination ) = +  @xmath29 find_offers ( ) = +  each(agencies ) @xmath30 agency @xmath30 agency(destination ) @xmath30 offer @xmath30 +  ( offers.add((offer , agency ) ) @xmath31 +  ( best_offer.read ( ) @xmath32 compare(o , offer",
    ") @xmath33 +  ift(b ) @xmath34 ( best_agency.write(agency ) @xmath31 best_offer.write(offer ) ) ) ) # +  @xmath29 extend_best ( ) = +  best_agency.read ( ) @xmath30 ba @xmath30 best_offer.read ( ) @xmath30 bo @xmath30 ba.exists(bo ) @xmath30 b @xmath30 +  ( ift(b ) @xmath34 ba.get_info(bo ) @xmath31 iff(b ) @xmath34 alarm(``inconsistent '' ) ) # +  @xmath29 sort_offers(offers , best_offer ) = +  offers.sort ( ) ; best_offer.read ( ) = offers.first ( ) @xmath30b@xmath30 +  ( ift(b ) @xmath34 offers @xmath31 iff(b ) @xmath34 alarm(``not best '' ) ) # +  ( ( t @xmath35t@xmath35 ( find_offers ( ) @xmath31 timer(2000 ) ) ) @xmath36 +  ( ( e_b , s_o ) @xmath35e_b@xmath35 extend_best ( ) @xmath35s_o@xmath35 sort_offers ( ) ) ) +  @xmath35offers@xmath35 stack ( ) +  @xmath35best_offer@xmath35 ( register ( ) @xmath30r@xmath30 r.write(null ) ; r ) +  @xmath35best_agency@xmath35 register ( ) #    we now illustrate the use of orc in figure [ figure : illustration_orc ] .",
    "this program defines the internal site ` find_best(agencies , destination ) ` that computes the best offers proposed by the agencies listed in ` agencies ` for the destination given as a parameter .",
    "it publishes a unique value that is a pair composed of the best offer augmented with additional information and the list of other offers sorted by price .",
    "the program is composed of three internal sites .",
    "it uses three shared objects , that are created in lines 15 to 17 : the stack ` offers ` and the registers ` best_offer ` and ` best_agency ` . at line  16",
    ", a new register is created through a call to the site ` register ( ) ` and is bound to the variable ` r ` .",
    "it is then initialized to a default value : ` r.write(null ) ` that can be seen as a shortcut for ` r(\"write\")>w >",
    "w(null ) ` , so the shared register is a site that can publish its accessors when it is called . as writing in a register does not publish any value , the otherwise operator is finally used to bound the value to ` best_offer ` . at line 11 ,",
    "the site ` find_offers ` can be started before the variables are created ( left hand side of pruning operators ) . `",
    "each ` publishes in parallel all the sites contained into the stack ` agencies ` , so all known agencies have to publish their offers .",
    "each time a new offer is found , it is added into ` offer ` and its price is compared to the current best known offer .",
    "the test is first evaluated and passed as an argument to ` ift ` . if true , the program publishes a signal and the registers can be updated .",
    "` find_offers ` does not publish any value . in parallel with its call",
    ", we start a timer that publishes after 2 seconds a signal .",
    "the signal will halt this part of the program thanks to the pruning operator , and starts the line 14 , thanks to the sequential operator .",
    "line  14 calls both ` extend_best ` and ` sort_offers ` and publishes the result when both sites have published .",
    "the two sites call an external site either to sort the offers or to get extra information about the best offer , and they perform a test that raises an alarm if something wrong is detected",
    ".    3    1 .",
    "each([a1 , a2 ] ) 2 .",
    "timer(2000 ) 3 .",
    "new_register ( ) 4 .",
    "new_register ( ) 5 .",
    "a1(d ) 6 .",
    "r.write(null ) 7 .",
    "best_offer.read ( ) 8 .",
    "new_stack ( ) 9 .",
    "offers.add(o1 ) 10 .",
    "a2(d ) 11 .",
    "offers.add(o2 ) 12 .",
    "compare(null , 01 ) 13 .",
    "best_offer.read ( ) 14 .",
    "compare(null , 02 ) 15 .",
    "ift(true ) 16 .",
    "ift(true ) 17 .",
    "best_offer.write(o2 ) 18 .",
    "best_offer.write(o1 ) 19 .",
    "best_agency.write(a1 ) 20 .",
    "best_agency.write(a2 ) 21 .",
    "best_agency.read ( ) 22 .",
    "best_offer.read ( ) 23 .",
    "a2.exists(o1 ) 24 .",
    "iff(false ) 25 .",
    "ift(false ) 26 .",
    "alarm(``inconsistent '' ) 27 .",
    "offers.sort ( ) 28 .",
    "best_offer.read ( ) 29 .",
    "offers.first ( ) 30 .",
    "= ( o1 , o2 ) 31 .",
    "iff(false ) 32 .",
    "ift(false ) 33 .",
    "alarm(``not best '' )    figure [ figure : sequential_execution ] shows a possible trace of the program of figure [ figure : illustration_orc ] . in this example , both alarms are due to inconsistencies in the shared registers . to avoid the alarm `` inconsistent '' ,",
    "it is necessary to write into ` best_offer ` and ` best_agency ` atomically , and to avoid the other alarm , the comparison with the current value of ` best_offer ` and its edition should be atomic . the event ` best_offer.write(01 ) ` is a cause for both alarms , but it is impossible to detect it in the sequential trace without any information about causality .",
    "sos specifications take the form of a set of inference rules that define the valid transitions of a composite piece of syntax in terms of the transitions of its components . rewriting transforms terms by executing a rule",
    "( it may be a non - deterministic transition in case of multiple alternatives ) .",
    "the successive transitions represent the program behavior .",
    "this may produce a sequence of values , that can be brought by the labeling of rules .",
    "our approach is based on an instrumentation of the rules , that appends additional information to the labels in order to track the partial order of events .",
    "actually , a label in the instrumented semantics is a tuple @xmath37 , where @xmath38 is an identifier taken in a countable set @xmath39 , that is unique for the execution , @xmath40 is a label similar to those of the standard semantics and @xmath41 and @xmath42 contain the finite sets of the identifiers of the causes and the weak causes of the event , respectively . informally , an event @xmath43 is a cause of @xmath44 if @xmath43 always happens before @xmath44 , regardless of the scheduling chosen by the system .",
    "similarly , @xmath43 is a weak cause of @xmath44 if @xmath44 can never happen after @xmath43 , either because @xmath43 is one of its causes or because @xmath44 preempts @xmath43 .    in order to record the information concerning the past of an expression",
    ", we enrich the language with a new syntactic construction : @xmath45 means that @xmath46 and @xmath21 are the causes of the orc instrumented expression @xmath10 .",
    "thus , if @xmath10 has @xmath46 and @xmath21 as causes and if it can evolve into @xmath47 , this transition should also have @xmath46 and @xmath21 as causes .",
    "the index @xmath48 expresses the kind of events that can activate the rule : @xmath49 matches any publication , @xmath50 stands for any label and @xmath26 means that @xmath46 and @xmath21 are only the causes of the termination of the program .",
    "we also consider that the external sites track causality themselves , as an internally - defined function would do .",
    "it makes sense as some sites ( e.g. @xmath51 ) handle their calls independently , while others ( e.g. shared registers , management library ) induce more complex causality patterns between the calls . hence , the responses we get include this additional information .",
    "the verification of these responses is not the subject here , and we suppose them to be correct by hypothesis .",
    "apart from the introduction of the instrumentation construction and the new information in the responses , the syntax of the instrumented expressions ( figure [ fig : instr_syntax ] ) is very similar to the regular one .",
    "the set of all the expressions allowed by this extended syntax is @xmath52 .",
    "we can notice that every valid orc program is also a valid instrumented expression , which means that the instrumented semantics can be applied without program transformation .",
    "@xmath53      labeled asymmetric event structures ( laes ) @xcite are natural objects to represent concurrent executions in a compact way .    a _ labelled asymmetric event structure _ ( laes ) is a tuple @xmath54 .",
    "* @xmath55 is a set of _ events _ , * @xmath48 is a set of _ labels _ , * @xmath56 , _ causality _ is a partial order on @xmath55 , * @xmath57 , _ weak causality _ is a binary relation on @xmath55 , * @xmath58 is the _ labelling function _ , * each @xmath59 has a finite _ causal history",
    "_ @xmath60 = \\{e'\\in e | e'\\le e\\}$ ] , * for all events @xmath61 , where @xmath35 is the irreflexive restriction of @xmath56 , * for all @xmath59 , @xmath62 \\times [ e]$ ] , the restriction of weak causality to the causal history of @xmath43 , is acyclic .",
    "we also define an induced _ conflict _ relation @xmath63 as the smallest set of finite parts of @xmath55 such that : for @xmath64 and @xmath65 ,    * if @xmath66 then @xmath67 , * if @xmath68 and @xmath69 then @xmath70 .",
    "informally , two events are in conflict if they can not occur together in the same execution .",
    "a laes can be seen as a structure that encodes concisely several sequential executions ; each of them being a linearization of the laes .",
    "let @xmath71 be a laes .",
    "a _ finite linearization _ of @xmath72 is a word @xmath73 where the different @xmath74 are distinct and such that :    * it is left - closed for causality : @xmath75 * the weak causality is respected : @xmath76    we denote @xmath77 as the set of all finite linearizations of @xmath72 .",
    "let @xmath54 be an asymmetric event structure and @xmath78 two events .",
    "we say that :    * @xmath43 is a _ cause _ of @xmath44 , if @xmath43 happens before @xmath44 in all executions ; * @xmath43 is a _ weak cause _ of @xmath44 , if there is no execution in which @xmath43 happens after @xmath44 ; * @xmath43 and @xmath44 are _ concurrent _ , denoted @xmath79 , if they can occur in either order . formally , @xmath80 if neither @xmath81 nor @xmath82 . * @xmath43 is _ preempted _ by @xmath44 , denoted @xmath83 , if @xmath44 can occur independently from @xmath43 , but after that , @xmath43 can not occur anymore .",
    "formally , @xmath83",
    "if @xmath81 and @xmath84 .      @xmath85 [ @xmath86 @xmath87 [ @xmath88 @xmath85    lr + [ @xmath27 fresh ] & +   +   +   +   +   + [ @xmath28 & [ @xmath89 fresh ] + [ @xmath28 & [ @xmath89 fresh ] +   +   + & + & +   +   +   +   +   +    essentially , the instrumented semantics presented in figure [ figure : instrumented_semantics ] decorates the rules of standard semantics , except that two rules are added ( see figure [ figure : rules_instr_cause ] ) .",
    "the transition system defined by this instrumented semantics is denoted @xmath90 and the sequential executions starting from a program @xmath10 are contained in the set @xmath91 .",
    "informally , the expression @xmath92 evolves exactly like @xmath10 , but some causes and weak causes may be added to the event .",
    "for example , if @xmath93 and @xmath10 produces an internal event , that is not a publication , only the rule causeno can be applied , so the instrumentation will have no effect . on the other hand , if @xmath10 publishes a value , the rule causeyes applies and @xmath46 and @xmath21 are added to the causes and weak causes of the publication . note",
    "that @xmath46 is also added to the weak causes .",
    "this is to ensure that causality is always a special case of weak causality .",
    "let us now comment the most relevant instrumentations of the other rules . let us consider rule seqv .",
    "when a value is published , a new instance of the right hand side expression is created .",
    "all the events produced by this new expression need the former publication to _ have occurred before _ them , i.e. they are consequences of this publication .",
    "this is why the new expression is instrumented . even if prunev and seqv are syntaxically very similar in their standard forms , the fact that both hand sides of the pruning operator are run in parallel makes them very different in terms of causality . in the expression @xmath94 , the second publication of @xmath95 is a consequence of the first one , but not the publication of @xmath96 .",
    "this is why the instrumentation covers the occurrences of the newly bound variable .",
    "however , this is not sufficient .",
    "consider the program @xmath97 .",
    "the publication of @xmath98 must wait the end of the left hand side ( i.e the publication of @xmath95 ) .",
    "however , this publication is useless , in the sense that no variable @xmath17 can be bound to its value . to handle this case",
    ", we add an instrumentation to the whole expression that is only triggered when the expression stops .",
    "finally , the rule prunen is also interesting as it generates weak causality . indeed , in the program @xmath99 , the left hand side can call site @xmath51 and then publish @xmath98 , or publish @xmath98 directly , but can never publish @xmath98 and then call site @xmath51 , because a publication preempts any other event .",
    "of course , it could also wait for the answer of the site and then publish @xmath95 , which would preempt the publication of @xmath98 .",
    "this preemption relation is operated by an instrumentation that contains @xmath27 as weak causes and that is triggered only in case of publication .",
    "the equivalent of traces in the instrumented semantics are the _ concurrent executions _ , represented by laes .",
    "let @xmath100 , where for all @xmath101 , @xmath102 .",
    "we define the _ concurrent execution _ of @xmath103 as the laes : @xmath104 where for all @xmath105 :    * @xmath106 if @xmath107 or @xmath108 , * @xmath109 if @xmath110 , * @xmath111 .    as the fields @xmath112 and @xmath113 only contain events that happened before @xmath114 in the sequential execution , both @xmath56 and @xmath115 are order relations and every event has a finite causal history . for the same reason ,",
    "@xmath115 is acyclic .",
    "moreover , it is easy to check that weak causality is more general than causality , so this definition actually corresponds to a real laes .",
    "we now state the main result : the behavior of a program is preserved by the instrumented semantics .",
    "it is established through two properties .",
    "the first one justifies the name of the instrumented semantics and the second one proves that the instrumentation is correct , i.e. that it does not define incorrect behaviors .",
    "note that we do not give a complete proof of the two propositions for lack of space , but it can be found in @xcite .    [",
    "prop : instrumentation ] the projections of the executions produced by the instrumented semantics on their labels correspond exactly to the executions of the standard semantics : @xmath116 in other words , it is always possible to instrument a standard execution to get a concurrent execution , and conversely we can get a standard execution from an instrumented execution by a simple projection .",
    "the proof of this property is straightforward since both semantics contain similar rules .",
    "the only difficulty comes from the applications of causeyes and causeno , that slightly modifie the structure of the derivation trees .",
    "all in all , both executions are similar .",
    "[ prop : instrument_correct ] the linearizations that can be inferred from an execution in the instrumented semantics are correct with respect to the standard semantics : @xmath117    this proof is much more complicated .",
    "let us consider a linearization @xmath118 . to prove that @xmath119 , we show that it is possible to progressively transform @xmath120 into @xmath48 by applying a series of small steps that correspond either to the inversion of two consecutive concurrent events , to the preemption of an event by its successor or to a prefixation of the sequence .",
    "as @xmath121 and each step preserves this property , we get that @xmath122 .",
    "the main difficulty concerns the proof of the correctness of the two first steps , as it requires a proof for all pairs of possible consecutive rules .    by introducing concurrency and preemption between events that were arbitrarily ordered by the standard semantics ,",
    "the instrumented semantics gathers many sequential executions into one concurrent execution , which hugely reduces the number of different executions .",
    "however , all the events contained in a concurrent execution are also contained into a single sequential execution .",
    "therefore , no instrumentation is able to capture conflict , as two conflictual events would never occur together .",
    "this is why completeness can not be achieved with this approach .",
    "2 ( 1 , @xmath123 , @xmath124 , @xmath124 ) + ( 2 , @xmath125 , @xmath124 , @xmath124 ) + ( 3 , @xmath126 , @xmath124 , @xmath124 ) + ( 4 , @xmath127 , @xmath124 , @xmath124 ) + ( 5 , @xmath128 , \\{1 } , \\{1 } ) + ( 6 , @xmath129 , \\{4 } , \\{4 } ) + ( 7 , @xmath130 , \\{1,4 - 6 } , \\{1,4 - 6 } ) + ( 8 , @xmath131 , @xmath124 , @xmath124 ) + ( 9 , @xmath132 , \\{1,5,8 } , \\{1,5,8 } ) + ( 10 , @xmath133 , \\{1 } , \\{1 } ) + ( 11 , @xmath134 , \\{1,8,10 } , \\{1,8,10 } ) + ( 12 , @xmath135 , \\{1,4 - 7 } , \\{1,4 - 7 } ) + ( 13 , @xmath136 , \\{1,4,6,10 } , \\{1,4,6,10 } ) + ( 14 , @xmath137 , \\{1,4,6,10,13 } , \\{1,4,6,10,13 } ) + ( 15 , @xmath138 , \\{1,4 - 7,12 } , \\{1,4 - 7,12 } ) + ( 16 , @xmath139 , \\{1,4,6,10,13,14 } , \\{1,4,6,10,13,14 } ) + ( 17 , @xmath140 , \\{1,4,6,10,13,14,16 } ,   + \\{1,4,6,10,13,14,16 } ) + ( 18 , @xmath141 , \\{1,4 - 7,12,15 } , \\{1,4 - 7,12,15 } ) + ( 19 , @xmath142 , \\{1,3 - 7,12,15 } , \\{1,3 - 7,12,15 } ) + ( 20 , @xmath143 , \\{1,3,4,6,10,13,14,16 } ,   + \\{1,3,4,6,10,13,14,16 } )    ( 21 , @xmath144 , \\{2 } , \\{2 , 1 } ) + ( 22 , @xmath145 , \\{1 - 7,10,12 - 16,19 - 21 } ,   + \\{1 - 7,10,12 - 16,19 - 21 } ) + ( 23 , @xmath146 , \\{1 - 7,10,12 - 19,22 } ,   + \\{1 - 7,10,12 - 19,22 } ) + ( 24 , @xmath147 , \\{1 - 7,10,12 - 19,22,23 } ,   + \\{1 - 7,10,12 - 19,22,23 } ) + ( 25 , @xmath148 , \\{1 - 7,10,12 - 19,22,23 } ,   + \\{1 - 7,10,12 - 19,22,23 } ) + ( 26 , @xmath149 , \\{1 - 7,10,12 - 19,22 - 24 } ,   + \\{1 - 7,10,12 - 19,22 - 24 } ) + ( 27 , @xmath150 , \\{2 } , \\{2 , 1 } ) + ( 28 , @xmath151 , \\{1,2,5,9 - 11,27 } , \\{1,2,5,9 - 11,27 } ) + ( 29 , @xmath152 , \\{1,2,5,9 - 11,27 } , \\{1,2,5,9 - 11,27 } ) + ( 30 , @xmath153 , \\{1,2,4 - 7,9 - 18,27 - 29 } ,   + \\{1,2,4 - 7,9 - 18,27 - 29 } ) + ( 31 , @xmath154 , \\{1,2,4 - 7,9 - 18,27 - 30 } ,   + \\{1,2,4 - 7,9 - 18,27 - 30 } ) + ( 32 , @xmath155 , \\{1,2,4 - 7,9 - 18,27 - 30 } ,   + \\{1,2,4 - 7,9 - 18,27 - 30 } ) + ( 33 , @xmath156 , \\{1,2,4 - 7,9 - 18,27 - 31 } ,   + \\{1,2,4 - 7,9 - 18,27 - 31 } ) +    let us reuse the example presented in section [ section : orc ] and the execution of figure [ figure : sequential_execution ] .",
    "figure [ figure : instrumented_execution ] shows the trace augmented with the causal information gained by the instrumented semantics .",
    "figure [ figure : graphical_instrumented_execution ] shows the laes in its graphical form .",
    "events taht correspond to site calls are represented in circles and connected by three kinds of arrows .",
    "direct causality is figured by solid and dashed arrows .",
    "solid arrows represent program causality , that is specified by the instrumented semantics , while dashed arrows represent data causes , that are managed by the sites themselves .",
    "a _ call _ to a write on a site is a cause of the _ publications _ of the next read on this site , so the write is a cause of all the consequences of the read .",
    "moreover , preemption is figured by dotted arrows . the call to ` each ( ) `",
    " and all its consequences  is preempted by the publication made by ` timer(2000 ) `  and all its consequences .",
    "[ [ root - causes - analysis . ] ] root causes analysis .",
    "+ + + + + + + + + + + + + + + + + + + + +    this execution concurrently raises two alarms .",
    "let us consider their last common causes , i.e. the events that are causes of both alarms , and that are not causes of another such event .",
    "the alarms have two last common causes : ` timer(2000 ) ` and ` best_offer.write(o1 ) ` .",
    "the timer is not to blame here , as it has no causes and is just used as a starter for the program . indeed , ` best_offer.write(o1 ) ` is the root cause for these two alarms .",
    "if this event did not exist , the value published by ` best_offer.read ( ) ` would be ` o2 ` for both calls , ` a2.exists(o2 ) ` and ` = ( 02 , o2 ) ` would be true and no alarm would be raised .",
    "[ [ detection - of - race - conditions . ] ] detection of race conditions .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we can see that the events ` best_offer.write(o1 ) ` and ` best_offer.write(o2 ) ` are concurrent , as well as ` best_agency.write(o1 ) ` and ` best_agency.write(o2 ) ` . in this context",
    ", these events can interleave so that ` best_offer ` and ` best_agency ` get inconsistent values .",
    "we based our work on the orc core calculus , as it is expressive enough to easily generate many situations found in distributed systems , such as causality , concurrency and preemption , and remains simple enough to be tractable in a formal work .",
    "our contribution consists of an instrumentation of the standard structural operational semantics of orc that tracks causality and weak causality at runtime to build laes , well suited to represent concurrent executions .",
    "we think laes are an interesting tool to access important properties of orchestrations .",
    "we illustrate this point on two questions : root cause analysis and detection of race conditions . beyond the orc language",
    ", we think that the article presents a general approach that can be used for other non - deterministic languages with concurrency operators .",
    "based on this work , we think it is possible to produce the same information using a source to source transformation",
    ". such a technique would be easier to implement , as it does not require to modify the execution engine of the language .",
    "tony andrews , francisco curbera , hitesh dholakia , yarob goland , johannes klein , franck leymann , kevin liu , dieter roller , doug smith , satish thatte , ivana trickovic , sanjiva weerawarana .",
    "_ business process execution language for web services_. version 1.1 , may 5 , 2003 .",
    "david kitchin , adrian quark , william cook , and jayadev misra . _",
    "the orc programming language .",
    "_ in david lee , antonia lopes , and arnd poetzsch - heffter , editors , formal techniques for distributed systems , volume 5522 of lecture notes in computer science , pages 1 - 25 .",
    "springer , 2009 .",
    "david kitchin , william cook , and jayadev misra .",
    "_ a language for task orchestration and its semantic properties_. in christel baier and holger hermanns , editors , concur 2006 , concurrency theory , volume 4137 of lecture notes in computer science , pages 477 - 491 .",
    "springer , 2006 .",
    "sidney rosario , albert benveniste , stefan haar , and claude jard .",
    "_ foundations for web services orchestrations : functional and qos aspects_. isola 2006 , 2nd international symposium on leveraging applications of formal methods , verification and validation , 15 - 19 november 2006 , cyprus .",
    "grigore rou and koushik sen .",
    "_ an instrumentation technique for online analysis of multithreaded programs .",
    "_ in volume 19 of concurrency and computation : practice and experience , pages 311 - 325 .",
    "wiley online library , 2007 .",
    "elena giachino , ivan lanese , claudio antares mezzina .",
    "_ causal - consistent reversible debugging _ fundamental approaches to software engineering , lecture notes in computer science volume 8411 , 2014 ,",
    "pages 370 - 384 .",
    "sidney rosario , david kitchin , albert benveniste , william cook , stefan haar and claude jard .",
    "_ event structure semantics of orc . _",
    "4th international workshop on web services and formal methods ( ws - fm 2007 ) , pages 154 - 168 .",
    "roberto bruni , hernn melgratti and emilio tuosto .",
    "_ translating orc features into petri nets and the join calculus .",
    "_ 3rd international workshop on web services and formal methods ( ws - fm 2006 ) , pages 123 - 137 .",
    "matthieu perrin , claude jard , achour mostfaoui .",
    "_ building a concurrent operational semantics for the orc language_. technical report , lina , universit de nantes ( 2014 ) https://hal.archives-ouvertes.fr/hal-01101340v2"
  ],
  "abstract_text": [
    "<S> this article shows how the operational semantics of a language like orc can be instrumented so that the execution of a program produces information on the causal dependencies between events . </S>",
    "<S> the concurrent semantics we obtain is based on asymmetric labeled event structures . </S>",
    "<S> the approach is illustrated using a web service orchestration instance and the detection of race conditions . </S>"
  ]
}