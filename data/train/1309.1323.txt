{
  "article_text": [
    "network coding allows senders or intermediate nodes of a network to mix different data packets / flows and can enhance the throughput of many network setups @xcite . but",
    "this is often at the price of large decoding delay , because mixed data needs to be network decoded before delivery to higher layers @xcite . understanding",
    "the tradeoff between throughput and decoding delay in network coded systems has been the subject of research in recent years @xcite , where a packet - level network coding model is particularly suitable for such studies . in this paper , we are primarily concerned with the achievable throughput - delay tradeoff of packet - level network coding in wireless broadcast scenarios , where a sender wishes to broadcast a block of data packets to some receivers through wireless channels with packet erasures .",
    "we first review two classic packet - level network coding techniques under this scenario : random linear network coding ( rlnc ) @xcite and instantly decodable network coding ( idnc ) @xcite .",
    "the primary advantage of rlnc is its optimality in terms of block completion time @xcite , which is the time it takes to successfully broadcast all data packets in a block to all receivers and is a fundamental measure of throughput .",
    "rlnc achieves its optimality by sending random linear combinations of all data packets as coded packets , with coefficients randomly chosen from a finite field @xmath0 where usually @xmath1 .",
    "another advantage of rlnc is that it only requires one ack feedback from each receiver upon successful decoding of all data packets in a block .",
    "however , rlnc can suffer from large decoding delays , since a receiver needs to collect enough linear combinations to perform block - wise decoding .",
    "this also incurs heavy decoding computational load , since gaussian eliminations on a coefficient matrix under large field size @xmath2 are involved @xcite .    on the contrary , idnc aims at minimizing decoding delay . by carefully choosing data packets",
    "to be coded together , it guarantees a subset of ( or if possible , all ) receivers to instantly decode one of their wanted data packets upon successful reception of a coded packet @xcite .",
    "this means that data packets can be potentially delivered to higher layers much faster than rlnc .",
    "another advantage of idnc is its simple xor - based encoding and decoding , i.e. , coding coefficients are chosen from the binary field @xmath3 .",
    "however , idnc is generally not optimal in terms of block completion time , as there might exist a subset of receivers who can not instantly decode any of their wanted data packets from the received coded packet .",
    "moreover , idnc requires feedback from all receivers at a proper frequency for making coding decisions .",
    "rlnc and idnc have many contrasting features .",
    "they generally trade off decoding delay or throughput for one another , respectively .",
    "they also differ in practical issues such as feedback frequency and decoding complexity",
    ". moreover , since rlnc uses a larger finite field than idnc , any adaptive choice and switching between idnc and rlnc is impossible during the broadcast of one block .    in this paper , we are interested in investigating the performance spectrum between idnc and rlnc .",
    "this study will help us develop coding schemes that offer moderate throughput - delay tradeoffs , or equivalently , more balanced throughput and decoding delay performance compared with rlnc and idnc .",
    "we are also interested in the connection between the coding mechanisms of idnc and rlnc .",
    "this study will help us manage feedback frequency , decoding complexity , and even in - block performance adaption .",
    "the first question we ask is :    * _ is there a coding scheme which provides more balanced throughput and decoding delay performance than idnc and rlnc ? _    at the beginning of section[sec : partition_motivation ] , we will show the existence of such a scheme through an example , in which the decoding delay can be reduced without trading off the throughput .",
    "the key idea is to appropriately partition a partially - received block of data packets into _ sub - generations _ based on their reception states at the receivers after sending them uncoded once first .",
    "a similar partitioning has been studied in the literature @xcite , where sub - generations with equal number of data packets are generated and transmitted separately to reduce decoding delay in peer - to - peer scenarios . however , as we will prove in section[sec : partition_motivation ] , such partitioning may generally yield a prohibitively large block completion time compared with rlnc and idnc in our broadcast scenario . hence , the following question arises :    * _ is there a better way of packet partitioning to achieve more balanced throughput and decoding delay performance during block transmission ? _",
    "our answer to this question is through using the concept of _ non - conflicting data packets _ @xcite , which is defined as data packets not jointly wanted by any receiver . by properly grouping non - conflicting data packets together into coding sets ,",
    "we obtain an idnc solution @xcite . then by appropriately partitioning coding sets in an idnc solution into sub - generations , we obtain a desirable balance between throughput and decoding delay performance , which lies between that of rlnc and idnc . consequently , we redefine the concepts of sub - generation and its size , which is the core of this work .",
    "based on these new concepts , we achieve the following contributions :    1 .",
    "we fill the throughput and decoding delay performance gap between idnc and rlnc by proposing new adaptive coding schemes .",
    "they offer more balanced throughout and decoding delay performance than idnc and rlnc ; 2 .",
    "the new coding schemes , together with idnc and rlnc , constitute a general coding framework .",
    "this coding framework unifies idnc and rlnc , because they become its two specific cases ; 3 .",
    "we study the throughput and decoding delay properties of this coding framework .",
    "the results provide a good insight from the perspective of the proposed sub - generation size ; 4 .",
    "we develop various implementations of this coding framework , which can further improve throughput and decoding delay performance without sacrificing on one another .",
    "they also enable in - block performance adaption by allowing switching between idnc and rlnc .",
    "plenty of hands - on examples are designed to demonstrate the proposed concepts and algorithms .",
    "extensive simulations are also provided to evaluate the performance of the proposed coding schemes .",
    "we consider wireless broadcast of @xmath4 data packets , denoted by @xmath5 , from a sender to @xmath6 receivers , denoted by @xmath7 .",
    "time is slotted . in each time slot , a packet ( either original data or coded ) is sent .",
    "wireless channels between the sender and the receivers are subject to packet erasures . for the ease of simulations ,",
    "we assume i.i.d .",
    "memoryless erasure channels to all receivers with equal probability @xmath8 .",
    "however , this is not strictly needed and can be easily extended to more general cases .    in this scenario ,",
    "@xmath4 data packets are first sent uncoded once using @xmath4 time slots .",
    "this phase is known as a _ systematic transmission phase _ @xcite .",
    "we justify the application of this phase on idnc and rlnc in the following remark .",
    "we will review this again under the proposed coding framework .",
    "[ remark : systematic ] for idnc , a systematic transmission phase is compulsory @xcite , since coding opportunities are unavailable at the beginning .",
    "rlnc with a systematic transmission phase is known as systematic rlnc @xcite .",
    "it reserves the throughput optimality of the traditional rlnc .",
    "it also introduces extra benefits such as 1 ) smaller packet decoding delay , and 2 ) smaller field size @xmath2 and thus lower coding / decoding complexity . in the rest of this paper",
    ", the term rlnc always refers to systematic rlnc unless otherwise specified .    during the systematic transmission phase a receiver might miss any data packet due to packet erasures .",
    "the receivers then send lossless feedback to the sender about their packet reception states .",
    "feedback information can be expressed by an @xmath9 binary state feedback matrix ( sfm ) @xcite , denoted by @xmath10 $ ] , where @xmath11 means receiver @xmath12 still wants data packet @xmath13 and @xmath14 otherwise . here",
    "@xmath15 is the number of receivers who have not received all @xmath4 data packets and @xmath16 is the number of data packets that have not been received by all @xmath6 receivers .",
    "the set of these @xmath16 partially - received data packets is denoted by @xmath17 .",
    "an example of a @xmath18 sfm is given in fig .",
    "[ fig : sfm ] .",
    "the subset of @xmath17 wanted by receiver @xmath12 is called the",
    "_ wants _ set of this receiver , denoted by @xmath19 .",
    "its size is denoted by @xmath20 and the largest @xmath20 across all receivers is denoted by @xmath21 .",
    "the subset of receivers that want @xmath13 is called the _",
    "target _ set of @xmath13 , denoted by @xmath22 .",
    "its size is denoted by @xmath23 .",
    "based on the sfm , the sender initiates a _ coded transmission phase _ which is also subject to erasures . in this phase , the sender sends network coded packets to efficiently complete the broadcast of the data block .",
    "this two - phase broadcast is illustrated in fig .",
    "[ fig : phases ] .",
    "the throughput and decoding delay performance of the network coding schemes can be measured by the minimum block completion time and minimum average packet decoding delay , respectively .",
    "we first define the minimum block completion time :    given an sfm and a certain coding scheme , the minimum block completion time , or equivalently the minimum number of coded transmissions , is the smallest possible number of coded transmissions by the sender that is needed to satisfy the demands of all receivers in the absence of any packet erasures in the coded transmission phase .",
    "this number is denoted by @xmath24 .",
    "the minimum block completion time @xmath24 reflects the best throughput performance of a certain coding scheme , calculated as @xmath25 .",
    "such measure of throughput is important in the sense that it disentangles the effect of channel - induced packet erasures and algorithm - induced network coded packet design on the throughput . in reality ,",
    "due to packet erasures or suboptimal choices of coded packet transmissions , we may need more than @xmath24 transmissions to complete a data block . in this case",
    ", @xmath25 serves as an upper bound on throughput and will still serve as a useful measure of performance .",
    "we now define the minimum average packet decoding delay :    given an sfm and a certain coding scheme , assume that a sequence of coded packets that can achieve the corresponding minimum block completion time are transmitted without erasures .",
    "also assume that coded packets are transmitted in the decreasing order of their targeted receivers to minimize decoding delay .",
    "denote by @xmath26 the first time slot when original data packet @xmath13 can be decoded by receiver @xmath12 , and let @xmath27 if @xmath14 .",
    "we have @xmath28 $ ] .",
    "then the minimum average packet decoding delay , @xmath29 , is defined as : @xmath30    it is noted that @xmath29 refers to the minimum possible delay under a certain coding scheme achieving its minimum block completion time , but not refer to _ universal minimum delay _ under all coding schemes , which is still an opten question to the best of our knowledge .",
    "we now review idnc and rlnc schemes in the coded transmission phase and discuss their throughput and decoding delay performance .",
    "an idnc coded packet takes the form of @xmath31 where @xmath32 is the time index , @xmath33 and the summation is bit - wise xor @xmath34 .",
    "we denote by @xmath35 the set of original data packets that have non - zero coefficients in @xmath36 , namely , @xmath37 .",
    "@xmath35 fully represents @xmath36 and is called a coding set .",
    "it is instantly decodable if it satisfies the following _ idnc constraint _",
    "@xcite :    [ def : coding_set ] an idnc coding set @xmath35 contains at most one data packet from the wants set , @xmath19 , of any receiver @xmath12 .",
    "according to this constraint , we have two important concepts called conflicting and non - conflicting data packets @xcite :    [ def : conf_packet ] we say that two data packets @xmath38 and @xmath39 conflict with each other if there exists at least one receiver who wants both packets .",
    "that is , @xmath38 and @xmath39 conflict if both belong to the wants set , @xmath19 , of at least one receiver such as @xmath12 .",
    "we say that two data packets @xmath38 and @xmath39 do not conflict with each other if there is no receiver who wants both packets .",
    "it is clear that to avoid non - instantly decodable coded packets , two conflicting data packets @xmath38 and @xmath39 can not be coded together .",
    "conflict states among all @xmath16 data packets can be represented by an undirected idnc graph @xmath40 , where vertex @xmath41 represents packet @xmath13 , and edge @xmath42 exists if @xmath38 does not conflict with @xmath39 @xcite .",
    "below is an example :    consider the sfm in fig .",
    "[ fig : sfm ] .",
    "@xmath43 and @xmath44 conflict with each other because @xmath45 wants both packets .",
    "hence , in the idnc graph @xmath46 in fig .",
    "[ fig : graph ] , @xmath43 and @xmath44 are not connected .",
    "if @xmath47 were sent , @xmath45 would not be able to instantly decode @xmath43 or @xmath44 .",
    "on the other hand , @xmath43 and @xmath48 do not conflict with each other because there is no single receiver who wants both packets .",
    "thus @xmath43 and @xmath48 are connected in @xmath46 . by receiving @xmath49",
    ", @xmath45 can instantly decode @xmath43 as @xmath50 , since @xmath45 already has @xmath48 .",
    "similarly , the other three receivers can also instantly decode one data packet .",
    "since data packets in the same coding set @xmath51 do not conflict with each other , the vertices representing these packets are connected to each other in @xmath46 .",
    "these vertices form a clique @xcite of @xmath46 . furthermore",
    ", a coding set @xmath51 is said to be _ maximal _ if its corresponding clique is maximal , i.e. , is not a subset of a larger clique .",
    "we then have the following lemma @xcite , which identifies the minimum block completion time of idnc :    the minimum block completion time of idnc , denoted by @xmath52 , is equal to the chromatic number of the complementary idnc graph @xmath53 .    here",
    ", @xmath53 denotes the complementary of @xmath46 , which has the same vertices as @xmath46 , but with opposite vertex connectivities .",
    "we then have the concepts of an idnc solution and optimal idnc solution :    [ def : idnc_solution ] an idnc solution is a collection of idnc coding sets which satisfy the following two conditions : 1 ) they jointly cover all @xmath16 data packets ; and 2 ) the union of any of them is not an idnc coding set .",
    "[ def : optimal_idnc_solution ] while the first condition ensures completeness of the solution , the second condition prevents redundant idnc coding sets which can be absorbed into other coding sets to reduce the cardinality of the solution .",
    "an idnc solution is optimal if : 1 ) its cardinality is @xmath52 ; and 2 ) all its coding sets are maximal .",
    "an optimal idnc solution is denoted by @xmath54 .    the minimum average packet coding delay of the optimal idnc solution can be computed using and is denoted by @xmath55 .",
    "below is an example .",
    "[ exmp : sfm_idnc ] the optimal idnc solution for the sfm in fig .",
    "[ fig : sfm ] is @xmath56 , @xmath57,@xmath58 , @xmath59 , @xmath60 .",
    "thus @xmath61 .",
    "one can easily verify that every coding set in @xmath62 is maximal . by sending @xmath63 , @xmath64 , @xmath65 , and @xmath66 using four time slots ,",
    "the minimum average packet decoding delay is computed using to be @xmath67 .",
    "coded packets in rlnc are random linear combinations of _ all _ @xmath16 data packets : @xmath68 where coding coefficients @xmath69 are randomly chosen from a finite field @xmath0 and usually @xmath1 . in order to decode @xmath20 data packets",
    ", a receiver @xmath12 needs to receive @xmath20 linearly independent coded packets .",
    "hence , to satisfy the demands of all @xmath15 receivers , at least @xmath21 linearly independent coded packets need to be broadcast . the minimum block completion time using rlnc is thus equal to @xmath21 and is denoted by @xmath70 .",
    "the minimum average packet decoding delay of rlnc , denoted by @xmath71 , can be calculated as : @xmath72 where we ignore early decoding chances of rlnc and assume that decoding of @xmath20 wanted packets by receiver @xmath12 is only possible after @xmath20 coded packets are received .    for the sfm given in fig .",
    "[ fig : sfm ] , if rlnc is applied , @xmath73 because @xmath74 .",
    "the minimum average packet decoding delay is @xmath75 , which is almost @xmath76 larger than idnc with @xmath67 .",
    "[ remark : rlnc_vs_idnc ] rlnc has a better throughput performance than idnc , i.e. , @xmath77 .",
    "this relationship is always valid .",
    "actually , @xmath70 is the benchmark for any network coding technique under the scenario considered here . on the other hand",
    ", idnc is expected to have better decoding delay performance than rlnc , i.e. , @xmath78 . however , this relationship is not always valid , as we may find some instances of sfm where @xmath79 .",
    "below is one such example .",
    "detailed comparisons can be found in @xcite .     for which @xmath80 results in @xmath79 . ]",
    "consider the sfm in fig .",
    "[ fig : sfm_2 ] .",
    "assume rlnc is applied , then @xmath81 and @xmath82 .",
    "if idnc is applied , because all four data packet conflict with each other , they must be sent separately .",
    "thus , @xmath61 and @xmath83 .",
    "the question that motivates our following work is whether there exist coding scheme(s ) that can provide a block completion time between @xmath70 and @xmath52 and an average packet decoding delay between @xmath55 and @xmath71 .",
    "if one can find such schemes then moderate throughput - delay tradeoffs compared with idnc and rlnc can be achieved .",
    "we will show that this is possible by packet partitioning .",
    "the initial motivation of this work is to investigate whether the decoding delay of rlnc can be reduced without sacrificing on throughput .",
    "rlnc suffers from large decoding delay mainly because it encodes all @xmath16 partially - received data packets in a block @xmath17 together .",
    "hence , one may infer that decoding delay could be reduced by partitioning these @xmath16 data packets into several _",
    "smaller generations _ and applying rlnc to these small generations separately . by doing so",
    ", data packets in early small generations can be decoded sooner .",
    "the idea of applying small generations has been studied in the literature for traditional rlnc , e.g. , @xcite for reducing decoding complexity and @xcite for reducing decoding delay , where throughput loss has been reported as inevitable .",
    "we now show that such partitioning does not generally work well for systematic rlnc either .",
    "in this paper we use the term _ sub - generations _ to denote smaller generations after partitioning of a partially - received data block @xmath17 of original size @xmath16 .",
    "a sub - generation , by classic definition of generation @xcite , is a set of @xmath84 consecutive data packets , where @xmath84 is called the sub - generation size and ranges from 1 to @xmath16 here . according to this definition ,",
    "sub - generations are generated by consecutively and evenly partitioning @xmath16 data packets in @xmath17 into @xmath85 partitions .",
    "denote by @xmath86 the @xmath87-th sub - generation , we have @xmath88 .",
    "its coded packet is : @xmath89 where coefficients @xmath90 are randomly chosen from an appropriate finite field @xmath0 .",
    "let @xmath91 be the largest number of data packets in @xmath86 wanted by any one receiver across all receivers .",
    "@xmath86 thus requires a minimum of @xmath91 coded transmissions .",
    "then the minimum block completion time under partitioning with sub - generation size @xmath84 , denoted by @xmath92 , is calculated as : @xmath93    we further denote by @xmath94 the minimum average packet decoding delay under sub - generation size @xmath84 . its calculation follows .",
    "we now demonstrate via an example that this classic partitioning can result in large @xmath92 and @xmath94 and hence is undesirable in terms of both throughput and delay .",
    "[ exmp : bad_partition ] consider the sfm given in fig .",
    "[ fig : sfm ] .",
    "@xmath95 data packets can be partitioned into @xmath96 sub - generations under @xmath97 : the first sub - generation is @xmath98 and the second sub - generations is @xmath99 . because @xmath100 and @xmath101 , the minimum block completion time is @xmath102 , which is much greater than both @xmath52 and @xmath70 .",
    "the minimum average packet decoding delay is @xmath103 , which is also much greater than both @xmath55 and @xmath71 studied in example [ exmp : sfm_idnc ] and below .",
    "however , by changing the content of each sub - generation , we can obtain better performance :    [ exmp : good_partition ] consider the sfm given in fig .",
    "[ fig : sfm ] . we still partition the data packets into two sub - generations , but the first sub - generation is @xmath104 and the second sub - generation is @xmath105 .",
    "the two sub - generations have @xmath106 and thus @xmath107 , which is the same as @xmath70 .",
    "however , since data packets in @xmath108 can be decoded after only 2 coded transmissions , @xmath94 is only 2.7 , which is smaller than @xmath75 calculated earlier .",
    "example [ exmp : bad_partition ] demonstrates that the classic partitioning does not provide convincing throughput and decoding delay performance .",
    "whereas example [ exmp : good_partition ] shows that there may be better ways of partitioning .",
    "explicitly , under classic partitioning , the minimum block completion time @xmath92 has the following property :    if data packets are partitioned into classic sub - generations , @xmath92 is lower bounded as : @xmath109    it is obvious that @xmath110 . furthermore , because @xmath111 for @xmath112 $ ] , @xmath113 according to ( [ eq : u_calculation ] ) .",
    "this lemma indicates that , when a small sub - generation size @xmath84 is applied in an attempt to reduce decoding delay , the resulted @xmath114 and @xmath92 can be much larger than @xmath70 and even @xmath52 .",
    "a large @xmath92 implies large decoding delays for data packets sent in the last few sub - generations .",
    "this will in turn increase @xmath94 , making such partitioning pointless in terms of both throughput and decoding delay .",
    "in example [ exmp : bad_partition ] , due to the fact that @xmath102 , the decoding delay of data packets @xmath115 is as large as 7 .",
    "in conclusion , following the classic partitioning we are unable to fill the performance gap between idnc and rlnc . a better way of partitioning is needed and will be developed next , based on which the concept of sub - generations will be redefined and a new coding framework will be proposed .      the partitioning in example [ exmp : bad_partition ] failed to reduce either @xmath92 or @xmath94 because all data packets in the same sub - generation , e.g. , @xmath99 , are jointly wanted by at least one receiver , yielding a minimum of @xmath101 coded transmissions to complete this sub - generation .",
    "in contrast , as shown in example [ exmp : good_partition ] , sub - generations of @xmath116 and @xmath105 only requires @xmath106 coded transmissions because all receivers want at most 2 data packets from them .",
    "these two examples motivate the key to a better partitioning , that is , _ to avoid as much as possible partitioning data packets that are jointly wanted by any receiver into the same sub - generation .",
    "_ by doing so , @xmath117 of the sub - generations are reduced .",
    "imagine an extreme sub - generation in which any two data packets are not jointly wanted by any receiver .",
    "then the broadcast of this sub - generation only requires one coded transmission .",
    "such a sub - generation , recalling definition [ def : coding_set ] in section [ sec : system_idnc ] , is exactly an idnc coding set .",
    "the key step of partitioning then becomes clear :    instead of partitioning packets in the packet set @xmath17 based on their consecutive index , we partition a set of idnc coding sets which together cover all @xmath16 data packets . in other words , we partition an idnc solution . has the smallest cardinality ( @xmath52 ) , it is the desired object for partitioning .",
    "although we will develop the new coding framework based on the optimal idnc solution , the proposed definitions , properties , and implementations are not restricted to the optimal idnc solution .",
    "they can be applied to any idnc solution satisfying definition [ def : idnc_solution ] , such as those heuristically found in @xcite . ]    accordingly , the concept of sub - generations is redefined :    a sub - generation @xmath118 is a collection of idnc coding sets in an idnc solution .",
    "the definition of sub - generation size is also changed :    sub - generation size @xmath84 is the number of coding sets in a sub - generation .",
    "the above definitions enable a new coding framework . given the optimal idnc solution @xmath54 , the @xmath52 maximal coding sets are partitioned into @xmath119 sub - generations , where @xmath120 $ ] .",
    "the simplest partitioning method is a consecutive one : @xmath121 , @xmath122 , @xmath123 .",
    "a schematic of this partitioning is plotted in fig.[fig : partition ] .",
    "more efficient partitioning algorithms will be developed in section [ sec : implementations ] .",
    "for each sub - generation @xmath86 , its coded packets are generated using as in classic partitioning .",
    "linear independency among the coded packets are promoted by randomly choosing coding coefficients from a sufficiently large finite field @xmath0 .",
    "the field size @xmath2 can be reduced with decreasing sub - generation size @xmath84 . in fact , @xmath124 when @xmath125 , since all receivers want at most one data packet from a sub - generation of size @xmath125 .",
    "the definition of @xmath91 of a sub - generation @xmath86 , where @xmath112 $ ] , is still the largest number of data packets in @xmath86 wanted by any one receiver across all receivers .",
    "since @xmath86 needs a minimum of @xmath91 coded transmissions , the relationship between @xmath92 and @xmath91 is still as in .",
    "below is an example of the proposed coding framework .",
    "consider the sfm in fig .",
    "[ fig : sfm ] , whose optimal idnc solution is : @xmath126 if @xmath127 , there will be @xmath128 sub - generations , where @xmath104 and @xmath105 .",
    "this result is exactly the same as that in example [ exmp : good_partition ] and explains the success of the partitioning in example [ exmp : good_partition ] compared to the classic partitioning in example [ exmp : bad_partition ] .",
    "interestingly , there are two extreme cases of this coding framework , taking place when @xmath125 and @xmath129 .",
    "when @xmath125 , since @xmath124 , coding within a sub - generation is through xor and there are @xmath52 such sub - generations .",
    "hence , the coding scheme becomes idnc with @xmath130 .",
    "when @xmath129 , there will be only one sub - generation , which contains all coding sets and thus all @xmath16 data packets .",
    "hence , the coding scheme becomes rlnc with @xmath131 .",
    "therefore , the proposed coding framework successfully unifies the coding mechanisms of idnc and rlnc .",
    "it also enables the coding schemes in the spectrum between idnc and rlnc with @xmath132 $ ] . in the next section",
    ", we will study throughput and decoding delay properties of the proposed coding framework under all values of sub - generation size @xmath84 .",
    "the minimum block completion time @xmath92 is determined by @xmath117 according to ( [ eq : u_calculation ] ) .",
    "@xmath117 has the following property :    when sub - generation size satisfies @xmath133 , @xmath134 $ ] for all sub - generations @xmath112 $ ] .    1 .",
    "@xmath86 is the superset of all @xmath84 idnc coding sets in it .",
    "if all receivers want at most one data packet in @xmath86 , i.e. , if @xmath135 , then @xmath86 itself is an idnc coding set .",
    "this contradicts with the fact that the union of any coding sets in an idnc solution is not a coding set according to definition [ def : idnc_solution ] .",
    "thus @xmath136 ; 2 .   if there is a receiver who wants @xmath137 data packets in @xmath86 , these @xmath91 data packets conflict with each other and at least two of them must belong to the same coding set .",
    "this contradicts the idnc constraint stated in definition [ def : coding_set ] .",
    "thus , @xmath138 .    then , by considering the relationship between @xmath91 and @xmath92 in ( [ eq : u_calculation ] ) and noting that @xmath119 , the above lemma yields an important corollary :    [ theo : u_bounds ] for all values of sub - generation size @xmath84 , the minimum block completion time is bounded between @xmath70 and @xmath52 : @xmath139\\ ] ] where @xmath140 holds when @xmath129 and @xmath141 holds when @xmath142 ( because @xmath143 when @xmath127 ) .",
    "explicitly , @xmath92 approaches @xmath70 when the sub - generation size @xmath84 increases gradually from @xmath144 to @xmath52 and approaches @xmath52 the other way around .",
    "the above lower and upper bounds on the minimum block completion time generally hold under the proposed coding framework .",
    "they are also useful benchmarks for the throughput performance of packet - level network coded wireless broadcast schemes in general .",
    "while @xmath70 is the lower bound for any such scheme , the upper bound @xmath52 is an indicator of throughput efficiency , because any scheme requiring a minimum block completion time of greater than @xmath52 can be treated as inefficient .",
    "one such inefficient scheme is the rlnc with classic partitioning in example [ exmp : bad_partition ] .    for the minimum average packet decoding delay , @xmath94 ,",
    "the situation is more complicated .",
    "it is clear that @xmath94 lies between @xmath55 and @xmath71 .",
    "however , as we have discussed in remark [ remark : rlnc_vs_idnc ] , there is no guarantee that @xmath145 .",
    "hence , instead of @xmath55 or @xmath71 , we propose an alternative upper bound on @xmath94 in terms of sub - generation size @xmath84 :    the minimum average decoding delay under sub - generation size @xmath84 satisfies @xmath146    denote the largest decoding delay of data packets in @xmath86 by @xmath147 .",
    "it is equal to @xmath148 .",
    "when @xmath149 is maximized , i.e. , when @xmath150 for all @xmath151 $ ] , @xmath147 is maximized with a value of @xmath152 . since we can always send @xmath86 with more targeted receivers first",
    ", the largest @xmath94 happens when all @xmath86 have the same number of target receivers , denoted by @xmath153 .",
    "then , as a variation of ( [ eq : d_definition ] ) , the largest @xmath94 is calculated as : @xmath154    this bound also justifies the application of the systematic transmission phase : at the beginning of the broadcast of @xmath4 data packets , we have an all - one sfm @xmath155 of size @xmath156 .",
    "thus , while @xmath157 , ( [ eq : d_bound ] ) indicates that using @xmath125 offers the smallest packet decoding delay , which requires all @xmath4 data packets to be sent separately uncoded .",
    "in summary , in this section we showed that throughput and decoding delay performance of all coding schemes in the proposed coding framework is well bounded between that of idnc and rlnc .",
    "therefore , our coding framework is a general one with idnc and rlnc identified as two extreme cases with @xmath125 and @xmath158 , respectively .",
    "it successfully fills the performance gap between idnc and rlnc and enables a series of coding schemes with a range of more balanced throughput and decoding delay performance . in the next section",
    ", we will turn to implementations of the proposed coding framework to further improve its throughput and decoding delay performance .",
    "in the last section , we showed that throughput and decoding delay performance of the proposed coding framework is well bounded between idnc and rlnc for all sub - generation sizes @xmath120 $ ] .",
    "although we can not further improve the performance of idnc and rlnc , we can do so for the coding schemes with @xmath132 $ ] .",
    "after the systematic transmission phase , there are two steps in the coded transmission phase : 1 ) partitioning idnc coding sets into sub - generations ; and 2 ) broadcasting these sub - generations following a transmission strategy .",
    "we will first optimize these two steps and then further explore the potentials of this coding framework .",
    "we denote by @xmath159 the number of targeted receivers of a coding set @xmath35 in the optimal idnc solution @xmath160 @xmath161 @xmath162 @xmath163 @xmath164 , where : @xmath165    without loss of generality we also assume that @xmath166 , i.e. , @xmath167 is wanted by the most receivers , followed by @xmath168 , and so on .",
    "the simplest algorithm is to consecutively partition the @xmath52 coding sets .",
    "that is , @xmath121 , @xmath169 , @xmath123 .",
    "this algorithm is referred to as _ direct partitioning _ ( dp ) .",
    "dp offers good decoding delay performance , because coding sets with more targeted receivers are partitioned into earlier sub - generations and are broadcast earlier .",
    "however , @xmath91 may not be uniform across coding sets in @xmath86 .",
    "dp overlooks this fact and thus does not necessarily minimize @xmath117 and @xmath92 . below is an example .     when @xmath170 .",
    "]    _ in the matrix in fig .",
    "[ fig : algorithmc_partition ] , an entry of one at row @xmath171 and column @xmath172 means receiver @xmath12 wants one data packet in coding set @xmath173 .",
    "suppose the sub - generation size is @xmath170 .",
    "then , according to dp , we have @xmath174 , and thus @xmath100 .",
    "however , if we use @xmath175 , we have @xmath176 .",
    "_    hence , to strike a balance between throughput and decoding delay , we design a heuristic algorithm which aims at 1 ) reducing @xmath92 by exploiting the opportunities of reducing @xmath91 for all @xmath87 , and 2 ) preserving low decoding delay by partitioning the most wanted coding sets into earlier sub - generations .",
    "this algorithm , which we refer to as _ smart partitioning _",
    "( sp ) , fills sub - generations sequentially , i.e. , the @xmath84 coding sets for @xmath108 are first determined , followed by the @xmath84 coding sets for @xmath177 , etc .",
    "details of this algorithm are presented in algorithm [ alg : partition ] .",
    "initialize : an idnc solution @xmath62 , and @xmath114 empty sub - generations , @xmath178 ; sort the coding sets in @xmath62 in a descending order in terms of their number of targeted receivers ; find the coding sets in @xmath62 that do not increase @xmath91 by one . denote the collection of such coding sets by @xmath179 ; add the coding set in @xmath179 with the smallest index ( _ and thus wanted by most receivers _ ) to @xmath86 ; add the coding set in @xmath62 with the smallest index to @xmath86 ; remove the chosen coding set from @xmath62 ; terminate the algorithm ;    compared with dp , sp costs light extra computations .",
    "however , as will be numerically compared later , the performance of sp is better than dp in a wide range of system settings .",
    "the reason why sp outperforms dp in terms of decoding delay is that , by reducing @xmath92 in sp we also reduce the worst packet decoding delay , which will in turn reduce the average packet decoding delay .",
    "with sub - generations generated , we are ready to broadcast them through erasure - prone channels .",
    "in this subsection , we present two coded transmission strategies , called sequential and semi - online , respectively . they are superior to each other in different aspects",
    ".         given all @xmath114 sub - generations , the simplest strategy for the coded transmission phase is to segment this phase into @xmath114 rounds . in each round ,",
    "coded packets of a sub - generation are broadcast until all its targeted receivers have decoded it and informed the sender .",
    "we name this strategy _",
    "sequential_.    in sequential strategy , the decoding of different sub - generations are independent of each other .",
    "this property leads to the primary advantage of this strategy , namely , tunable throughput and decoding delay even within the broadcast of a data block , because we can apply different sub - generation sizes in different rounds without affecting the decoding of sub - generations in other rounds .",
    "for example , when decoding delay becomes the primary concern , the system can easily switch to idnc by setting @xmath125 in all remaining rounds .",
    "such switching was impossible because rlnc generally applies a larger field size than idnc .",
    "another example is schematically shown in fig.[fig : change_g ] . in this example",
    ", there are three rounds , with sub - generation sizes of 2 , 1 , and @xmath180 , respectively .",
    "sequential strategy requires at most @xmath114 ack feedback from every receiver .",
    "the sub - generation size can also be adjusted to fit the system s specific feedback frequency if there is any .",
    "the main disadvantage of this strategy is its large decoding delay , because the broadcast of a sub - generation @xmath86 can not be started until the broadcast of @xmath181 is completed .",
    "even if only one targeted receiver of @xmath181 experiences a bad channel , the round for @xmath181 must continue and thus all targeted receivers of @xmath86 have to wait . to overcome this drawback",
    ", we propose another coded transmission strategy called _ semi - online _ strategy .     during the broadcast using sequential strategy . ]         in semi - online strategy , the coded transmission phase is also segmented into rounds , which is , though , different from the rounds in sequential strategy . here in each round , all @xmath114 sub - generations are broadcast , where for @xmath86 , @xmath91 coded packets are broadcast . thus in each round , there are @xmath182 coded transmissions .",
    "after each round , the sender collects feedback from the receivers about how many more coded packets of each sub - generation they still want .",
    "@xmath117 is thus updated accordingly before the next round starts .",
    "below is a simple example .",
    "assume there are three receivers , @xmath45 to @xmath183 .",
    "they want two , three , and four data packets from sub - generation @xmath108 , respectively .",
    "therefore , @xmath184 coded packets of @xmath108 are broadcast in the first round , along with coded packets of other sub - generations .",
    "assume that after the first round , @xmath45 to @xmath183 have received two , one , and three coded packets of @xmath108 , respectively",
    ". then they still want zero , two , and one coded packets to decode @xmath108 , respectively .",
    "@xmath185 is thus updated to two . in the second round ,",
    "two coded packets of @xmath108 will be broadcast , along with coded packets of other sub - generations .",
    "semi - online strategy overcomes the main drawback of sequential strategy , and thus significantly improves the decoding delay performance . on the other hand , from a statistical point of view",
    ", semi - online strategy has the same throughput performance as sequential strategy , since we only `` swap '' the coded transmissions for each sub - generation .",
    "the main drawback of semi - online strategy is that throughput and decoding delay performance is no longer tunable .",
    "moreover , since the number of rounds in semi - online strategy increases with decreasing channel quality , the amount of feedback in this strategy can not be predetermined .",
    "however , as will be presented in section [ sec : merge ] , semi - online strategy offers the opportunity to algorithmically merge sub - generations together , which can further improve both throughput and decoding delay performance .    therefore , there is no clear winner between sequential and semi - online strategies .",
    "which one to adopt depends on the application . in the next subsection",
    ", we will discuss the concept and impacts of _ packet diversity _ on these two strategies .",
    "the diversity of a data packet in the proposed coding framework is defined as follows :    the diversity of a data packet is the number of sub - generations in which it appears .    in the proposed coding framework ,",
    "data packets might have diversities of greater than one because the sub - generations are generated from maximal idnc coding sets , whose intersections are usually not empty .",
    "our motivation of studying packet diversity is the fact that , we could possibly reduce @xmath91 of a sub - generation @xmath86 by removing a data packet from it . below is an example .",
    "assume that there are two sub - generations .",
    "the first sub - generation @xmath108 contains @xmath186,@xmath44,@xmath187 and some other data packets .",
    "the second sub - generation @xmath177 contains @xmath188 and some other data packets .",
    "here data packet @xmath188 has a diversity of 2 .",
    "also assume that receiver @xmath45 wants @xmath186,@xmath44,@xmath187 , which means @xmath185 is at least 3 .",
    "now let us remove @xmath188 from @xmath108 , which reduces the diversity of @xmath188 to 1 .",
    "the targeted receivers of @xmath188 can still decode it from @xmath177 , while @xmath185 can be possibly reduced to 2 , which reduces the minimum block completion time @xmath92 by 1 .",
    "inspired by this fact , we investigate the benefits and problems that a packet diversity of greater than one brings to sequential and semi - online coded transmission strategies , and then decide whether it should be reduced to one or not .         a packet diversity of greater than one is redundant in sequential strategy regardless of the sub - generation size .",
    "suppose data packet @xmath43 is included in @xmath108 and @xmath177 . by the end of the round for @xmath108 , all receivers who want",
    "@xmath43 will have received it , indicating that @xmath43 does not need to be included in @xmath177 .         unlike sequential strategy",
    ", the impacts of packet diversity in semi - online strategy is much more complex .",
    "since all data packets are broadcast in every round , a higher packet diversity can be translated into a higher probability of being received and decoded , and thus reduces the number of coded transmissions in the next round . however , a high packet diversity incurs complicated coding and decoding decision makings .",
    "this drawback can be illustrated by the following example .",
    "assume that receiver @xmath45 wants @xmath189 from @xmath108 , and wants @xmath190 from @xmath177 .",
    "here @xmath44 has a diversity of 2 .",
    "imagine a case that , after the first coded transmission round , @xmath45 has received one coded packet of @xmath108 and one coded packet of @xmath177 .",
    "in the next round , @xmath45 only needs one coded packet of either @xmath108 or @xmath177 to decode all three data packets .",
    "thus the sender needs to decide to send a coded packet of @xmath108 or @xmath177 or both .",
    "this case is referred to as case-1 .",
    "imagine another case that , after the first coded transmission round , @xmath45 has received one coded packet of @xmath108 and two coded packets of @xmath177 .",
    "@xmath45 can thus directly decode @xmath190 from @xmath177 .",
    "after that , @xmath45 can substitute @xmath44 into the received coded packet of @xmath108 to decode @xmath43 .",
    "this case is referred to as case-2 .    when case-1 in the above example is extended to all receivers ,",
    "decision making by the sender will become very complicated .",
    "when case-2 in the above example is extended to all sub - generations , decoding by the receiver will become complicated , because once it has decoded some data packets from a sub - generation , it has to look up all other sub - generations for more decoding opportunities .",
    "the only exception happens when @xmath125 , i.e. , idnc . in this case , since there is no linear equations to solve , such search is unnecessary .    in conclusion ,",
    "we suggest to reduce the diversities of all data packets to one for both sequential and semi - online strategies unless @xmath125 .",
    "this reduction is applied to the optimal idnc solution by removing data packets from a maximal coding set if they have already been covered by the previous coding sets .",
    "the resulted solution is denoted by @xmath191 and also has a length of @xmath52 .",
    "any of the partitioning algorithms discussed before can then be applied to @xmath191 before the coded transmission phase .",
    "it is noted that our theoretical analysis and partitioning algorithms are not affected by the diversity reduction .",
    "throughput properties are not affected because both @xmath52 and @xmath70 remain the same and the relationship between @xmath92 and @xmath117 always holds .",
    "decoding delay properties are not affected because , by its definition in , we only consider the first time slot that a data packet can be decoded .",
    "its reception in later time slots due to diversity is not considered .",
    "partitioning algorithms are not affected because they work for any valid idnc solution .    in this subsection , we reduce packet diversities primarily for reducing @xmath117 at the beginning of the coded transmission phase . in the next subsection , we will introduce an operation called _ sub - generation merging _ , which could reduce @xmath117 in the second and further coded transmission rounds in the semi - online strategy .",
    "sub - generation merging is an operation that can only be applied under semi - online strategy .",
    "we use a simple example to introduce it .",
    "imagine that after a semi - online coded transmission round , there are two uncompleted sub - generations and two receivers . as shown in fig .",
    "[ fig : dof_merge ] , @xmath45 still wants two coded packets of @xmath108 and @xmath192 still wants three coded packets of @xmath177 . in this case ,",
    "@xmath176 and @xmath193 , thus @xmath194 .",
    "@xmath45 can decode after two coded transmissions , and @xmath192 can decode after five coded transmissions . alternatively , let us merge @xmath108 and @xmath177 together , that is , combine data packets in @xmath108 and @xmath177 together to form a new sub - generation @xmath195 .",
    "@xmath45 wants two and @xmath192 wants three coded packets of @xmath195 , respectively .",
    "thus @xmath196 and @xmath92 is reduced from 5 to 3 , i.e. , throughput is improved . moreover , while @xmath45 can still decode after two coded transmissions , @xmath192 can decode after only three coded transmissions rather than five , thus decoding delay is also reduced .    in this example ,",
    "the two sub - generations @xmath108 and @xmath177 are not jointly wanted by any receiver .",
    "compared with the definition of non - conflicting data packets in section [ sec : system ] , we define such sub - generations as _ non - conflicting sub - generations_. it is straightforward that non - conflicting sub - generations can be merged together so that both the throughput and decoding delay performance can be improved . the way of deciding which sub - generations to merge together is the same as finding an idnc solution from its graph representation . since the number of sub - generations is small",
    ", such decision making is not computationally expensive and can be heuristically found using the methods introduced in @xcite .",
    "a flow chart is presented in fig.[fig : implementations ] to summarize proposed implementations of our coding framework .     with their advantages and drawbacks .",
    "]    the proposed coding framework and its implementations can be easily adapted to existing linear network coding systems , because at its core , the proposed coding framework generates linear combinations of the data packets as coded packets .",
    "the only modification is that the sender requires the receivers to provide feedback by the last coded transmission of each round .",
    "four sets of simulations are carried out in this section . in the first simulation",
    ", we numerically demonstrate the well - bounded throughput and decoding delay performance of the proposed coding schemes compared with idnc and rlnc . in the second to fourth simulations ,",
    "we verify the effectiveness of the proposed implementations , including partitioning algorithms , coded transmission strategies , and sub - generation merging , respectively .",
    "we simulate broadcast of @xmath197 data packets to @xmath198 $ ] receivers .",
    "wireless channels between the sender and the receivers are subject to i.i.d . memoryless packet erasures with a probability of @xmath199 .",
    "since the first two simulations are concerned with the minimum block completion time and the minimum average packet decoding delay , packet erasures in the coded transmission phase are not considered in these two simulations , but will be incorporated in the third and fourth simulations .      in this simulation , we evaluate the block completion time ( @xmath92 ) and decoding delay ( @xmath94 ) performance of the proposed coding schemes with various values of sub - generation size @xmath84 , including @xmath125 ( idnc scheme ) , @xmath200 , and @xmath158 ( rlnc scheme ) .",
    "direct partitioning is applied .",
    "the results are plotted in fig.[fig : tradeoff ] .",
    "as we can see , throughput and decoding delay performance of the coding schemes with @xmath120 $ ] is well bounded between the performance of idnc and rlnc .",
    "they fill the performance gap between idnc and rlnc , and thus offer moderate throughput - delay tradeoffs compared with idnc and rlnc .",
    "another observation is that the throughput performance under @xmath127 is always the same as under @xmath125 , i.e. , @xmath201 .",
    "this result matches our upper bound on @xmath92 in corollary [ theo : u_bounds ] . on the other hand ,",
    "their decoding delay performance is generally different due to their different sub - generation sizes .",
    "fig.[fig : tradeoff ] also provides an example where rlnc outperforms idnc in terms of both throughput and decoding delay performance .",
    "it takes place when @xmath52 becomes much larger than @xmath70 ( 11.3 and 8 , respectively , at @xmath202 ) , which means the worst packet decoding delay of idnc is much larger than rlnc .",
    "data packets . ]      in this simulation , we evaluate the direct and smart partitioning algorithms .",
    "we apply two sub - generation sizes , @xmath203 and @xmath204 .",
    "simulation results are shown in fig .",
    "[ sim : partition ] . from this figure , we observe that the performance of smart partitioning is equal to or better than direct partitioning for all values of @xmath6 and for both values of sub - generation size @xmath84 .",
    "in this simulation , we evaluate sequential and semi - online coded transmission strategies .",
    "we use smart partitioning and apply three sub - generation sizes , @xmath205 , @xmath204 and @xmath129 .",
    "simulation results are shown in fig .",
    "[ sim : straight_vs_semi ] .",
    "our first observation is that the two strategies always share the same throughput performance .",
    "this result matches our statistical claim in section [ sec : trans_schemes ] .",
    "the second observation is that the decoding delay performance of the semi - online strategy successfully outperforms the sequential strategy when @xmath206 .",
    "when @xmath129 , since there is only one sub - generation , both strategies become equivalent to rlnc and thus have the same decoding delay performance .      in this simulation , we compare the performance of semi - online strategy with and without sub - generation merging .",
    "the results are shown in fig .",
    "[ sim : merge ] , from which it is clear that sub - generation merging improves both throughput and decoding delay under all parameter settings .    at a high level , our simulations show that throughput and decoding delay performance do not have to be improved by trading each other off , but they can have coordination in our coding framework . by applying proposed implementations and choosing a proper sub - generation size , a large range of throughput - delay tradeoffs can be achieved .",
    "the best configuration in terms of performance is smart partitioning combined with semi - online coded transmission strategy with sub - generation merging .",
    "for wireless network coded broadcast , we showed that it is possible to build upon an idnc solution to obtain a series of more general linear network coded solutions with varying throughput and decoding delay performance , as well as varying implementation complexity and feedback frequency .",
    "the core of our work was introducing a novel way of partitioning a partially - received data block into sub - generations based on the coding sets in a given idnc solution .",
    "consequently , when an idnc solution is used unaltered for coded transmissions , we are at one end of the spectrum , namely idnc with sub - generation size @xmath207 . when all idnc coding sets are combined , we reach the other end of the spectrum , namely rlnc with sub - generation size @xmath208 .",
    "the primary advantage of our coding framework is that the throughput and decoding delay of all intermediate coding schemes with different sub - generation sizes are guaranteed to lie between those of idnc and rlnc . with this crucial advantage",
    ", we showed that we are able to focus on further improvement of throughput and delay for intermediate coding schemes by more advanced partitioning and transmission strategies such as smart partitioning combined with semi - online transmission strategy and sub - generation merging , or even smart partitioning with sequential transmission strategy that enables in - block switching between idnc and rlnc for performance adaptation .",
    "b.  swapna , a.  eryilmaz , and n.  shroff , `` throughput - delay analysis of random linear network coding for wireless broadcasting , '' in _ proc .",
    "symposium on network coding ( netcod ) _",
    ", jun . 2010 , pp . 16 .",
    "p.  sadeghi , r.  shams , and d.  traskov , `` an optimal adaptive network coding scheme for minimizing decoding delay in broadcast erasure channels , '' _ eurasip j. on wireless commun . and netw .",
    "_ , pp . 114 , jan . 2010 .",
    "m.  yu , p.  sadeghi , and n.  aboutorab , `` on the throughput and decoding delay performance of instantly decodable network coding : , '' _ ieee / acm trans .",
    "_ , ( submitted to ) , 2013 .",
    "[ online ] .",
    "available : \\url{http://arxiv.org / abs/1309.0607}[\\url\\{http://arxiv.org / abs/1309.0607 } ]            j.  k. sundararajan , p.  sadeghi , and m.  mdard , `` a feedback - based adaptive broadcast coding scheme for reducing in - order delivery delay , '' in _ proc .",
    "workshop on network coding , theory , and applications _",
    ", 2009 , pp .",
    "n.  aboutorab , s.  sorour , and p.  sadeghi , `` o2-gidnc : beyond instantly decodable network coding , '' in _ network coding ( netcod ) , 2013 international symposium on_.1em plus 0.5em minus 0.4emieee , 2013 , pp ."
  ],
  "abstract_text": [
    "<S> our primary goal in this paper is to traverse the performance gap between two linear network coding schemes : random linear network coding ( rlnc ) and instantly decodable network coding ( idnc ) in terms of throughput and decoding delay . </S>",
    "<S> we first redefine the concept of packet generation and use it to partition a block of partially - received data packets in a novel way , based on the coding sets in an idnc solution . by varying the generation size </S>",
    "<S> , we obtain a general coding framework which consists of a series of coding schemes , with rlnc and idnc identified as two extreme cases . </S>",
    "<S> we then prove that the throughput and decoding delay performance of all coding schemes in this coding framework are bounded between the performance of rlnc and idnc and hence throughput - delay tradeoff becomes possible . </S>",
    "<S> we also propose implementations of this coding framework to further improve its throughput and decoding delay performance , to manage feedback frequency and coding complexity , or to achieve in - block performance adaption . </S>",
    "<S> extensive simulations are then provided to verify the performance of the proposed coding schemes and their implementations . </S>"
  ]
}