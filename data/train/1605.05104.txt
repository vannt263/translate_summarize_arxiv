{
  "article_text": [
    "it is well - known that , as the size of programs increases , it becomes impractical to maintain them as monolithic structures .",
    "indeed , splitting programs into smaller pieces allows to construct , understand and maintain large programs much more easily .",
    "_ program slicing _",
    "@xcite is a program - manipulation technique that extracts , from programs , those statements which are _ relevant _ to a particular computation . in the most traditional definition , a _ program slice _",
    "is an executable program whose behavior must be identical to a specific subset of the original program s behavior .",
    "the specification of this subset is called the _ slicing criterion _ , and can be expressed as the value of some set of variables at some set of statements and/or program points @xcite .",
    "slicing can be and is used in several areas like debugging @xcite , software maintenance @xcite , comprehension @xcite , or re - engineering @xcite .",
    "since the seminal paper introducing slicing @xcite , there have been many works proposing several notions of slicing , and different algorithms to compute slices ( see @xcite for good surveys about existing slicing techniques ) .",
    "program slicing is a transformation technique that reduces the size of programs to analyze .",
    "nevertheless , the reduction obtained by means of standard slicing techniques may be not sufficient for simplifying program analyses since it may keep more statements than those strictly necessary for the desired analysis .",
    "suppose we are analyzing a program , and suppose we want a variable @xmath0 to have a particular property @xmath1 at a given program point @xmath2 .",
    "if we realize that @xmath0 does not have that property at @xmath2 , then we may want to understand which statements affect that property of @xmath0 , in order to find out more easily where the computation went wrong .",
    "in this case , we are not interested in the exact value of @xmath0 , so that we may not need _ all _ the statements that a standard slicing algorithm would return . instead , we would need a technique that returns the minimal amount of statements that actually affect that specific property of @xmath0 .",
    "[ [ abstract - program - slicing ] ] abstract program slicing + + + + + + + + + + + + + + + + + + + + + + + +    this paper introduces and discusses a `` semantic '' general notion of slicing , called _ abstract program slicing _ , looking for those statements affecting a property ( modeled in the context of abstract interpretation @xcite ) of a set of variables of interest , the so called _ abstract criterion_. the idea behind this new notion of slicing is investigating more _ semantically _ precise notions of dependency between variables . in other words ,",
    "when a syntactic dependency is detected , such as the dependency , in an assignment , of _ defined _ variables from _ used _ variables , we look further for semantic dependencies , i.e. , dependencies between _ values _ of variables .    consider the program @xmath3 in fig .",
    "[ fig : progp33 ] , and suppose that we are interested in the variable @xmath4 at the end of the execution .",
    "standard slicing algorithms extract slices by computing syntactic dependencies ; in this sense , @xmath4 depends on all @xmath5 , @xmath6 and @xmath7 , so that a sound slice would have to take all the statements involving all these variables . in the figure",
    ", @xmath8 is a _ slice _ of @xmath3 with respect to that criterion .",
    "however , if we are interested in a more precise , semantic notion of slicing , then we could observe that the value of @xmath4 only depends on the values of variables @xmath5 and @xmath6 , so that a more precise slice would be represented by @xmath9 . finally ,",
    "if we are interested in the parity of @xmath4 at that point , then we observe that parity of @xmath4 does not depend on the value of @xmath5 , and @xmath10 is an",
    "_ abstract slice _ of @xmath3 with respect to the specified criterion . even in this simple case , the _ abstract slice _ gives more precise information about the statements affecting the property of interest .",
    "cccc    ....",
    "a:=1 ;     b:=b+1 ;     c:=c+2 ;     e:=e+1 ;     d:=2*c+b+a - a ;         ....    &    ....",
    "a:=1 ;     b:=b+1 ;     c:=c+2 ;         d:=2*c+b+a - a ;         ....    &    ....        b:=b+1 ;     c:=c+2 ;         d:=2*c+b+a - a ;         ....    &    ....         b:=b+1 ;         d:=2*c+b+a - a ;         ....     + program & program & program & program    [ [ contributions ] ] contributions + + + + + + + + + + + + +    in this paper , we aim at introducing a generalized notion of slicing , allowing us to weaken the notion of `` dependency '' ( from syntax , to semantics , to abstract semantics ) with respect to what is considered _ relevant _ for computing the slice . since our generalization is a semantic one , we start from the unifying framework proposed in @xcite , where different forms of slicing are defined and compared w.r.t .  their characteristics ( static / dynamic , iteration - count / non - iteration - count , etc .",
    ") , into a comprehensive formal framework .",
    "the structure of this framework is based on the formal definition of the criterion , inducing a semantic equivalence relation @xmath11 which uniquely characterizes the set of possible slices of a program @xmath3 as the set of all the sub - programs equivalent to @xmath3 w.r.t .",
    "this structure makes the framework suitable for the introduction and the formal definition of an abstract form of slicing , since abstraction corresponds simply to consider a weaker criterion , which implies weakening the equivalence relation @xmath11 defining slicing .",
    "once we have the equivalence relation defining a desired notion of slicing w.r.t . a given criterion ,",
    "we show how this corresponds to fixing the notion of dependency we are interested in ( namely , the notion of dependency determining what has to be considered relevant in the construction of slicing ) , and we show how the extension to semantic dependencies may be used to extend the program dependency graph - based approach to computing slices @xcite . finally , we define a notion of abstract dependencies implying abstract criteria .",
    "we show that this new notion of dependency is not suitable for computing slices by using program dependency graphs , and propose algorithms for computing ( abstract ) dependencies and a systematic approach to compute backward slices .",
    "such an approach relies on two systems of logical rules in order to prove ( 1 ) hoare - style tuples capturing the effect of executing a statement @xmath12 on a pair of states for which some similarity ( _ agreement _ ) is required by the slicing criterion ( indeed , this similarity corresponds to the semantic equivalent relation ) ; and ( 2 ) when some properties of the state do not change ( are _ preserved _ ) after @xmath12 is executed .",
    "the combination of the results provided by these rule systems allows to decide whether it is safe to remove a statement from a program without changing the observation corresponding to the criterion .",
    "importantly , the rule systems and algorithms provided in section [ sec : thequestforabstractslices ] rely on the knowledge and manipulation of a `` library '' of abstract properties . for example , in order to infer that @xmath13 is always even , the abstract domain representing the parity of number must be known .",
    "if no abstract property is known except the identity ( which is the most precise property , and is not really abstract ) , then the approach boils down to standard slicing .",
    "importantly , it becomes clear in this case that slices on the same variables ( properties of them in the abstract case ; exact values in the concrete case ) are generally bigger in the concrete setting ( when identity is the only available property ) with respect to the corresponding abstract slicing .",
    "needless to say , this does not mean that every algorithm for abstract slicing will perform better than any algorithm for non - abstract slicing ; rather , it provides a practical insight of how optimal ( purely semantic - based ) abstract slices may not include statements which are included in concrete slices .",
    "part of this work has been previously published in conference proceedings @xcite .",
    "the present paper joins these works into a coherent framework , and contains a number of novel contributions    * we formally prove that abstract slicing in the formal framework of @xcite generalizes concrete forms of slicing .",
    "* we formally define the notion of dependency induced by a particular criterion , i.e. , by the equivalence relation among programs induced , in the formal framework , by the chosen criterion . *",
    "we define and prove how we can approximate this ( concrete semantic ) dependency in order to use it for pruning pdgs and computing slicing with the well known pdg - based algorithm for slicing @xcite .",
    "* we discuss why the idea of pruning pdgs is not applicable to the abstract notion of dependency motivating the need of providing different approaches for computing abstract slices . * the treatment of non - numerical values when computing slices was already considered in @xcite .",
    "however , the language under study in the present paper is different in that it is closer to standard object - oriented languages .",
    "more concretely , that work used complex identifiers @xmath14 as if they were normal variables , thus obtaining that sharing between variables was easier to deal with . however , this came at the cost of increasing the number of `` variables '' to be tracked by the analysis .",
    "moreover , examples have been provided to illustrate how properties of the heap can be taken into account . *",
    "the introduced here is a quite refined version of the @xmath15-system @xcite ; rules for variable assignment and field update have been changed according to the new language ( which implies a number of technical issues ) ; there is a new rule @xmath16 ; the overall discussion has been improved .",
    "* the rule system for proving the preservation of properties ( the ) is explicitly introduced here . *",
    "the description of how statements can be erased has been improved ; an algorithm has been explicitly introduced , which labels each program point with agreements according to the .",
    "a thorough discussion and proofs are provided , so that it is guaranteed that the conditions for erasing a statement ( relying on the , the , and the @xmath17 procedure for labeling program points with agreements ) are sound .",
    "* recent work on field - sensitive sharing analysis @xcite is included in the computation of abstract slices , which results in improving the precision when data structure in the heap overlap .",
    "the language is a simple imperative language with basic object - oriented features , whose syntax will be easy to understand for anyone who is familiar with imperative programming and object orientation .",
    "the language syntax includes the usual arithmetic expressions @xmath18 and access to object fields via `` dot '' selectors .",
    "a statement can be @xmath19 , a variable assignment @xmath20 , a field update @xmath21 , a conditional or a @xmath22 loop .",
    "in addition , there exist special statements ( 1 ) @xmath23 which reads the value of some variable from the input , simulating the use of parameters ; this kind of statement can only appear at the beginning of the program ; and ( 2 ) @xmath24 , which can only appear at the end of the program and outputs the current value of some variables . for simplicity ,",
    "guards in conditionals and loops are supposed not to have _",
    "side effects_. we denote by @xmath25 the set of all programs .",
    "@xmath26 is the set of program variables and @xmath27 denotes the set of values , which can be either integer or reference values , or the @xmath28 constant ( @xmath29 ) ; every variable is supposed to be well - typed ( as integer or reference ) at every program point .",
    "@xmath30 denotes the set of _ line numbers _",
    "( program points ) .",
    "let @xmath31 , and @xmath32 be the statement at program line @xmath33 .",
    "for a given program @xmath3 , we denote by @xmath34 the set of all and only the line numbers corresponding to statements of the program @xmath3 , i.e. , @xmath35 .",
    "this definition is necessary since when we look for slicing we erase statements without changing the numeration of line numbers ; for instance , in figure  [ fig : progp33 ] , we have that @xmath36 , so that @xmath37 .    a _ program state _",
    "@xmath38 is a pair @xmath39 where @xmath2 is the executed program point , @xmath40 is the number of times the statement at @xmath2 has been reached so far , @xmath41 is the memory .",
    "a _ memory _ is a pair @xmath42 where the _ store _ @xmath43 maps variables to values , and the _ heap _ @xmath44 is a sequence of locations where objects can be stored ; a reference value corresponds to one of such locations .",
    "an _ object _",
    "@xmath45 maps field identifiers to values , in the usual way ; @xmath46 is the value corresponding to the field @xmath47 of the object @xmath45 , and can be either a number , the location in which another object is stored , or @xmath28 . for the sake of simplicity , _ classes _ are supposed to be declared somewhere , and field accesses are supposed to be consistent with class declarations .    unless ambiguity may arise , a memory ( or even an entire program state )",
    "can be represented directly as a store , so that @xmath48 ( resp . , @xmath49 ) will be the value of @xmath0 in the store contained in @xmath41 ( resp .",
    ", in @xmath50 )",
    ". moreover , a store @xmath51 can be represented as @xmath52 , meaning that @xmath53 for every @xmath54 , and , again , @xmath55 ( resp . ,",
    "@xmath56 ) can be used instead of @xmath57 whenever the store is the only relevant part of the memory ( resp . ,",
    "the state ) .    a _ state trajectory _",
    "@xmath58 is a sequence of program states through which a program goes during the execution .",
    "state trajectories are actually traces equipped with the @xmath59 component .",
    "the state trajectory obtained by executing program @xmath3 from the input memory @xmath41 is denoted @xmath60 .",
    "moreover , @xmath61 $ ] will be the set of states in @xmath62 where the program point is @xmath2 .",
    "any initial state has @xmath63 , i.e. , the set of initial states is @xmath64 .    in the following",
    ", @xmath65 denotes the program semantics where @xmath66 returns the set of state trajectories obtained by executing the program @xmath3 starting from any initial state in @xmath67 , i.e. , @xmath68 .",
    "we abuse notation by denoting in the same way also the semantics of expressions , namely , @xmath69 , which is such that @xmath70 ( @xmath71 ) returns the evaluation of @xmath72 in @xmath50 .",
    "finally , if @xmath73 , in sake of simplicity , we still abuse notation by denoting in the same way also the additive lift of semantics , i.e. , @xmath74 .      this section introduces the lattice of _ abstract interpretations _  @xcite .",
    "let @xmath75 denote a complete lattice @xmath76 , with ordering @xmath77 , lub @xmath78 , glb @xmath79 , top and bottom element @xmath80 and @xmath81 , respectively .",
    "galois connection _",
    "( g.c . ) is a pair of monotone functions @xmath82 and @xmath83 such that @xmath84 . in standard terminology ,",
    "@xmath76 and @xmath85 are , respectively , the concrete and the abstract domain .",
    "abstract domains can be formulated as upper closure operators ( @xmath1 ) @xcite .",
    "given an ordered set @xmath76 with ordering @xmath86 , a uco on @xmath76 , @xmath87 , is a monotone , idempotent ( @xmath88 ) and extensive ( @xmath89 ) map .",
    "each uco @xmath1 is uniquely determined by the set of its fixpoints , which is its image ; i.e. , @xmath90 . when @xmath91 for some set @xmath92 , and @xmath93 then we usually write @xmath94 instead of @xmath95 ( and in general for any function , @xmath96 instead of @xmath97 ) .",
    "if @xmath76 is a complete lattice , then @xmath98 is a complete lattice , where @xmath99 is the domain of all the upper closure operators on the lattice @xmath76 ; for every two ucos @xmath100 , @xmath101 if and only if @xmath102 iff @xmath103 ; and , for every @xmath104 , @xmath105 and @xmath106 . in the following we will denote by @xmath107 the most concrete uco on a domain , i.e. , @xmath108 , and by @xmath109 the most abstract one @xmath110 .",
    "@xmath111 is more precise than @xmath112 ( i.e. , @xmath112 is an abstraction of @xmath111 ) iff @xmath113 in @xmath99 .",
    "the _ reduced product _ of a family @xmath114 is @xmath115 and is one of the best - known operations for composing abstract domains .",
    "let the concrete domain @xmath76 be @xmath116 : the _ parity _ abstract domain @xmath117 in figure  [ dom1 ] ( on the left ) represents the parity of numbers , and is determined by fix - points @xmath118 where @xmath119 and @xmath120 denote even and odd numbers , respectively ; @xmath121 is the empty set , and @xmath122 . for example , @xmath123 ( all numbers are even ) , @xmath124 ( both numbers are odd ) , and @xmath125 ( there are both even and odd numbers ) .",
    "the _ sign _ abstract domain @xmath126 in figure  [ dom1 ] ( on the right ) is characterized by fix - points @xmath127 and tracks the sign of integers ( zero , positive , negative , etc . ) .",
    "for example , @xmath128 , @xmath129 , @xmath130 , @xmath131 . finally , the _ parity - sign _",
    "domain @xmath132 , which is the reduced product @xmath133 of @xmath117 and @xmath126 , captures both properties ( the parity and the sign ) , and has fix - points @xmath121 , @xmath134 , @xmath135 , @xmath136 , @xmath137 , @xmath138 , @xmath119 , @xmath120 , @xmath139 , @xmath140 , and @xmath141 .",
    "( partop ) at ( 0.2,0 ) @xmath141 ; ( pareven ) at ( -0.6,-1.5 ) @xmath119 ; ( parodd ) at ( 1,-1.5 ) @xmath120 ; ( parbot ) at ( 0.2,-3 ) @xmath121 ; ( partop )  ( pareven ) ; ( partop )  ( parodd ) ; ( pareven ) ",
    "( parbot ) ; ( parodd )  ( parbot ) ;    ( signtop ) at ( 3,0 ) @xmath141 ; ( signpos ) at ( 2,-1.5 ) @xmath139 ; ( signneg ) at ( 4,-1.5 ) @xmath140 ; ( signzero ) at ( 3,-1.5 ) @xmath134 ; ( signbot ) at ( 3,-3 ) @xmath121 ; ( signtop )  ( signpos ) ; ( signtop )  ( signneg ) ; ( signtop )  ( signzero ) ; ( signpos )  ( signbot ) ; ( signneg )  ( signbot ) ; ( signzero )  ( signbot ) ;    ( parsigntop ) at ( 7.7,0 ) @xmath141 ; ( parsignpos ) at ( 6.2,-1 ) @xmath139 ; ( parsigneven ) at ( 7.2,-1 ) @xmath119 ; ( parsignodd ) at ( 8.2,-1 ) @xmath120 ; ( parsignneg ) at ( 9.2,-1 ) @xmath140 ; ( parsignposeven ) at ( 5.4,-2 ) @xmath135 ; ( parsignposodd ) at ( 6.7,-2.5 ) @xmath136 ; ( parsignnegeven ) at ( 8.7,-2.5 ) @xmath137 ; ( parsignnegodd ) at ( 10,-2 ) @xmath138 ; ( parsignzero ) at ( 7.7,-3 ) @xmath134 ; ( parsignbot ) at ( 7.7,-4 ) @xmath121 ; ( parsigntop )  ( parsignpos ) ; ( parsigntop )  ( parsignneg ) ; ( parsigntop )  ( parsigneven ) ; ( parsigntop ) ",
    "( parsignodd ) ; ( parsignpos )  ( parsignposeven ) ; ( parsignpos )  ( parsignposodd ) ; ( parsignneg )",
    " ( parsignnegeven ) ; ( parsignneg )  ( parsignnegodd ) ; ( parsigneven )  ( parsignposeven ) ; ( parsigneven ) ",
    "( parsignnegeven ) ; ( parsigneven )  ( parsignzero ) ; ( parsignodd )  ( parsignposodd ) ; ( parsignodd )  ( parsignnegodd ) ; ( parsignposeven )  ( 6,-3.2 )  ( parsignbot ) ; ( parsignnegeven )  ( parsignbot ) ; ( parsignposodd )  ( parsignbot ) ; ( parsignnegodd )  ( 9.4,-3.2 )  ( parsignbot ) ; ( parsignzero )  ( parsignbot ) ;    formally speaking , the value of a reference variable is either a location @xmath142 or @xmath28 . however , the domains introduced in the next example classify variables not only with respect to @xmath142 itself , but also on the data structure in the heap which is reachable from @xmath142 .",
    "this point of view is similar to previous work on static analysis of properties of the heap like _ sharing _ @xcite or _",
    "cyclicity _ @xcite .",
    "[ ex : referenceabstractdomains ] let @xmath76 be @xmath143 , i.e. , the possible values of reference variables .",
    "the _ nullity _",
    "domain @xmath144 classifies values on nullity , and has fix - points @xmath145 where the concretizations of @xmath146 and @xmath147 are , respectively , @xmath148 and @xmath149 .    on the other hand ,",
    "it is possible to define a _",
    "domain @xmath150 which classifies variables on whether they point to _ cyclic _ or _ acyclic _ data structures @xcite .",
    "cycle _ in the heap is a path in which the same location is reached more than once ; a double - linked list ( one which can be traversed in both directions ) is a good example of a cyclic data structure .",
    "the fix - points of this domain are @xmath151 , where all acyclic values ( including @xmath28 ) are abstracted to @xmath152 , and all cyclic values ( i.e. , locations from which a cycle is reachable ) are abstracted to @xmath153 .",
    "both domains and their reduced product are depicted in figure [ dom2 ] ; note that there are values which are both null and cyclic , so that their intersection collapses to @xmath121 .",
    "finally , the identity domain @xmath107 , abstracts two concrete values to the same abstract value only if they are equal .",
    "two references are _ equal _ if ( 1 ) their are both null ; or ( 2 ) they are both non - null and the objects stored in the corresponding locations are equal , where equality on objects means that all their numeric fields must be the same number and all reference fields must be equal ( w.r.t .",
    "this same notion of equality on references ) .",
    "( nulltop ) at ( 0.2,0 ) @xmath141 ; ( nullnull ) at ( -0.6,-1.5 ) @xmath146 ; ( nullnonnull ) at ( 1,-1.5 ) @xmath147 ; ( nullbot ) at ( 0.2,-3 ) @xmath121 ; ( nulltop ) ",
    "( nullnull ) ; ( nulltop )  ( nullnonnull ) ; ( nullnull )  ( nullbot ) ; ( nullnonnull )  ( nullbot ) ;    ( cycletop ) at ( 4,0 ) @xmath141 ; ( cyclecyclic ) at ( 3,-1.5 ) @xmath153 ; ( cycleacyclic ) at ( 5,-1.5 ) @xmath152 ; ( cyclebot ) at ( 4,-3 ) @xmath121 ; ( cycletop )  ( cyclecyclic ) ; ( cycletop )  ( cycleacyclic ) ; ( cyclecyclic )  ( cyclebot ) ; ( cycleacyclic )  ( cyclebot ) ;    ( top ) at ( 9.7,0 ) @xmath141 ; ( cyclic ) at ( 7.7,-1.2 ) @xmath154 ; ( null ) at ( 9.7,-1.7 ) @xmath155 ; ( acyclic ) at ( 11.7,-1.2 ) @xmath156 ; ( bot ) at ( 9.7,-3 ) @xmath121 ; ( top )  ( null ) ; ( top )  ( cyclic ) ; ( top )  ( acyclic ) ; ( null )  ( bot ) ; ( cyclic ) ",
    "( bot ) ; ( acyclic )  ( bot ) ;    let us consider now @xmath157 ( @xmath76 lattice and @xmath158 ) , namely @xmath159 is a @xmath2-tuple of elements of @xmath76 , and consider @xmath160 . in this case",
    ", we can distinguish between two kinds of abstractions:[rel - nonrel ] _ non - relational _ and _ relational _ abstractions @xcite .",
    "the non - relational or _ attribute - independent _ one ( * ? ? ?",
    "* example 6.2.0.2 ) consists in ignoring the possible relationships between the values of the abstracted inputs .",
    "for instance , if @xmath1 is applied to the values of variables @xmath0 and @xmath161 , then @xmath1 can be approximated through projection by a pair of abstractions on the single variables , analyzing the single variables in isolation . in sake of simplicity , without losing generality , consider @xmath162 , i.e. , @xmath163 .",
    "formally , @xmath164 is non - relational if there exist @xmath165 such that @xmath166 , i.e , @xmath167 .",
    "for instance , let @xmath117 be the abstract domain depicted in figure  [ dom1 ] expressing the parity of integer values ; the @xmath117 non - relational property of @xmath168 provides the parity of @xmath0 and @xmath161 independently one from each other , meaning that all the possible combinations of parity of @xmath0 and @xmath161 are possible as results ( @xmath169 and all combinations where at least one variable is @xmath141 or @xmath121 ) .",
    "relational abstractions may preserve some of the relationship between the analyzed values @xcite .",
    "for instance , we could define an abstraction preserving the fact that @xmath0 is even ( @xmath119 ) if and only if @xmath161 is odd ( @xmath120 ) .",
    "it is clear that , in this case , we are more precise since the only possible analysis results are @xmath170 , @xmath171 , @xmath172 and @xmath173 .    if @xmath174 , @xmath175 , and @xmath176 , then @xmath177 is a _",
    "sound _ approximation of @xmath47 if @xmath178 .",
    "@xmath179 is known as the _ best correct approximation _ ( bca ) of @xmath47 in @xmath1 , which is always sound by construction .",
    "soundness naturally implies fix - point soundness , that is , @xmath180 . if @xmath181 then we say that @xmath182 is a",
    "_ complete _ approximation of @xmath47 @xcite . in this case ,",
    "@xmath183 .",
    "closure operators and equivalence relations are related concepts @xcite .",
    "recently , this connection has been further studied in the field of abstract model checking and language based - security @xcite . in particular",
    ", there exists an isomorphism between equivalence relations and a subclass of upper closure operators .",
    "consider a set @xmath184 : for each equivalence relation @xmath185 we can define an upper closure operator , @xmath186 such that @xmath187_\\tr$ ] and @xmath188_\\tr$ ] .",
    "conversely , for each upper closure operator @xmath189 , we are able to define an equivalence relation @xmath190 such that @xmath191 .",
    "it is immediate to prove that @xmath192 is an equivalence relation , and this comes from @xmath193 being merely a function , not necessarily a closure operator .",
    "@xmath194 is identified as the most concrete closure @xmath193 such that @xmath195 @xcite .",
    "it is possible to associate with each upper closure operator the most concrete closure inducing the same partition on the concrete domain @xmath184 : @xmath196    note that , for all @xmath197 , @xmath198 is the ( unique ) most concrete closure that induces the same equivalence relation as @xmath193 ( @xmath199 ) .",
    "the fix - points of @xmath200 are called the _ partitioning _ closures .",
    "being @xmath201 a complete boolean lattice , an upper closure operator @xmath189 is partitioning , i.e. , @xmath202 , iff it is complemented , namely if @xmath203 @xcite .        consider the set @xmath204 and one of its possible partitions @xmath205 .",
    "the closure @xmath193 with fix - points @xmath206 induces exactly @xmath207 as a state partition , but the most _ concrete _ closure that induces @xmath207 is @xmath208 , which is the closure on the right of figure [ partizioni ] .",
    "given a partitioning upper closure operator @xmath1 , an _ atom _ is an element @xmath209 of @xmath1 such that there does not exists another element @xmath210 with @xmath211 .",
    "for example , the atoms of @xmath132 are @xmath135 , @xmath136 , @xmath134 , @xmath137 , and @xmath138 . in partitioning closures ,",
    "atoms are all the possible abstractions of singletons : in fact , @xmath212 will never give @xmath139 or @xmath120 since there is always a more precise abstract value describing @xmath2 .",
    "in the following , @xmath213 holds iff @xmath209 is an atom of @xmath1 .",
    "an abstract program semantics is the abstract counterpart of the concrete semantics w.r.t .",
    "an abstract program observation : it is meant to compute , for each program point , an abstract state which soundly represents _ invariant properties _ of variables at that point . in general , it is computed by an abstract interpreter @xcite collecting the set of all the possible values that each variable may have in each program point and abstracting this set in the chosen abstract domain .    given a concrete program state @xmath50 and an abstract domain @xmath214 , an _ abstract state _",
    "@xmath215 is obtained by applying the abstraction @xmath1 to the values of variables stored in it .",
    "namely , @xmath216 , where @xmath217 and @xmath218 is such that @xmath219 . for simplicity",
    ", we can write @xmath220 , treating the whole state as a store when applied to variables . in the case of a reference variable @xmath0",
    ", the abstraction @xmath221 gives information about the data structure pointed to by @xmath0 ( e.g. , if @xmath222 , the cyclicity of the data structure can be represented ) .",
    "this explains why the heap is not represented explicitly in the abstract state : instead , relevant information about the heap is contained in the abstraction of variables ( see the previous discussion before example [ ex : referenceabstractdomains ] ) .    in the following , ordering @xmath77 on abstract states",
    "is variable - wise comparison between abstract values : @xmath223 the greater an abstract state is , the wider is the set of concrete states it represents .",
    "moreover , a _ covering _ of @xmath224 is a set of abstract states @xmath225 such that @xmath226 .",
    "the set of abstract state trajectories is @xmath227 , namely an abstract trajectory is the computation of a program on the set of abstract states .",
    "the trace in @xmath228 of a program @xmath3 , starting from the abstract memory @xmath229 is denoted by @xmath230 .    formally , the _ abstract program semantics _",
    "@xmath231 is such that @xmath232 is the set of the sequences of abstract states computed starting from the abstract initial states in @xmath233 .",
    "we also abuse notation by denoting @xmath234 also the abstract evaluation of expressions .",
    "namely , @xmath235 is such that @xmath236 .",
    "this definition is correct , since by construction , we have that any abstract state @xmath224 corresponds to a set of concrete states , i.e. , @xmath237 , namely , it is the set of all the concrete states having as abstraction in @xmath1 precisely @xmath224 , and we abuse notation by denoting with @xmath234 also its additive lift . in other words , @xmath238 is the best correct approximation of @xmath239 by means of an abstract value in @xmath1 . in general , in order to compute the abstract semantics of a program on an abstract domain @xmath1 , we have to equip the domain @xmath1 with the abstract versions of all the operators used for defining expressions . in our language , we should define , for example , the meaning of @xmath240 , @xmath241 , @xmath242 and @xmath243 on abstract values , i.e. , on sets of concrete values .",
    "this is standard in abstract interpretation , and these operations are defined for all the known numerical abstract domains .",
    "for instance , the sound approximation of the sum operation on @xmath117 is the following : @xmath244 we can reason similarly for all the other operators .",
    "the use of @xmath234 in section [ section : algorithmicideasforcheckingndep ] and later in the paper is twofold : ( 1 ) to infer invariant properties , as in example [ ex : invariantproperties ] ; and ( 2 ) to evaluate expressions at the abstract level .",
    "[ ex : invariantproperties ] consider the following code fragment :    ....     i : = 10 ;     j : = 0 ;     while ( i$\\geq$0 ) {       i : = i-1 ;       j : = j+1 ;     }     ....    and an abstraction @xmath245 , i.e. , the property of interest is the sign of both and . by computing the abstract semantics of this simple program",
    ", we can observe that inside the loop we lose the sign of since starts being positive , but then the @xmath246 operation makes impossible to know statically the sign of ( the result may be positive , zero or negative starting from positive or zero ) ,",
    "while we have that always remains positive .",
    "moreover , if the loop terminates we can surely say that , at the end , @xmath247 , namely it is negative ( due to the negation of the while guard ) . hence , we are able to infer that is negative and is positive after line 6 .",
    "this means that the final abstract state @xmath224 is such that @xmath248 and @xmath249 ( in the following , the extensional notation for @xmath224 will be @xmath250 , similar to the notation for concrete states ) .",
    "program slicing @xcite is a program - manipulation technique which extracts from programs those statements which are relevant to a particular portion of a computation . in order to answer the question about which are the relevant statements",
    ", an observer needs a _ window _ through which only a part of the computation can be seen @xcite .",
    "usually , what identifies the portion of interest in the computation is the value of some set of variables at a certain program point , so that a _ program slice _ comes to be the subset ( syntactically , in terms of statements ) of the original program which contributes directly or indirectly to the values assumed by some set of variables at the program point of interest .",
    "the _ slicing criterion _ is what specifies the part of the computation which is relevant to the analysis ; in this case , a criterion is a pair consisting of a set @xmath251 of variables and a program point ( or line number ) @xmath2 .",
    "the following definition @xcite is a possible formalization the original idea of program slicing @xcite , in the case of a single variable :    @xcite [ defslice ] for a statement @xmath12 ( at program point @xmath2 ) and a variable @xmath0 , the slice @xmath252 of the program @xmath253 with respect to the slicing criterion @xmath254 is any executable program with the following properties :    1 .",
    "@xmath252 can be obtained by deleting zero or more statements from @xmath253 ; 2 .",
    "if @xmath253 halts on the input @xmath255 , then , each time @xmath12 is reached in @xmath253 , it is also reached in @xmath252 , and the value of @xmath0 at @xmath12 is the same in @xmath253 and in @xmath252 . if @xmath253 fails to terminate , then @xmath12 may be reached more times in @xmath252 than in @xmath253 , but @xmath253 and @xmath252 have the same value for @xmath0 each time @xmath12 is executed by @xmath253 .",
    "it is worth noting that reps and yang @xcite , in their _ slicing theorem _ , provide implicitly a similar definition of program slicing , but it only considers terminating computations .",
    "the following example provides the intuition of how slicing works .    ....",
    "int c , nl : = 0 , nw : = 0 , nc : = 0 ;     int in : = false ;     while ( ( c = getchar())!=eof ) {       nc : = nc+1 ;       if ( c= ' ' || c='\\n ' || c='\\t ' ) {         in : = false ; }       elseif ( in = false ) {          in : = true ;         nw : = nw+1 ; }       if ( c = ' \\n ' ) {         nl : = nl+1 ; }     }     ....    c|c    ....     int c , nl : = 0 ;         while ( ( c = getchar())!=eof ) {             if ( c = ' \\n ' ) {         nl : = nl+1 ; }     }         ....    &    ....     int c , nw : = 0 ;     int in : = false ;     while ( ( c = getchar())!=eof ) {             if ( c= ' ' || c='\\n ' || c='\\t ' ) {         in : = false ; }       elseif ( in = false ) {         in : = true ;         nw : = nw+1 ; }           }         ....    consider the word - count program @xcite given in figure [ programs ] .",
    "it takes in a block of text and outputs the number of lines ( @xmath256 ) , words ( @xmath257 ) and characters ( @xmath258 ) .",
    "suppose the slicing criterion only cares for the value of @xmath256 at the end of the program ; then a possible slice is on the left in figure  [ example ] . on the other hand ,",
    "if the criterion is only interested in @xmath257 , then a correct slice is on the right .",
    "starting from the original definition @xcite , the notion of slicing has gone through several generalizations and versions , but one feature is constantly present : the fact that slicing is based on a notion of _ semantic equivalence _ that has to hold between a program and its slices or on a corresponding notion of _ dependency _ , determining what we keep in the slice while preserving the equivalence relation .",
    "what we can observe about definitions of slicing such as the one given in definition  [ defslice ] is that they are enough precise for finding algorithms for soundly computing slicing , such as @xcite , but not enough formal to become suitable to generalizations allowing us to compare different forms of slicing and/or to define new weaker forms of slicing .    in the following ,",
    "we use the formal framework proposed in @xcite where several notions and forms of slicing are modeled and compared .",
    "this is not the only attempt to provide a formal framework for slicing ( see section  [ sec : relatedwork ] ) , but we believe that , due to its semantic - based approach , it is suitable to include an abstraction level to slicing , which can be easily compared with all the other forms of slicing included in the original framework . hence , in the following section we do nt rewrite a formal framework , but we re - formalize the slicing criterion in order to allow us to easily include abstraction simply as a new parameter .",
    "a brief introduction of the formal framework together with some examples showing the differences between the different forms of slicing introduced in the following is given in the appendix .",
    "in this section , our aim is to define the form of slicing that we can lift to an abstract level .",
    "namely , we consider the framework in @xcite , which allows us to define abstract slicing simply by defining an abstract criterion which , independently from the kind of slicing ( static , dynamic , conditional , standard , etc . )",
    "allows us to observe properties instead of concrete values .",
    "since our aim is to define abstract program slicing as a form of slicing , perfectly integrated in the proposed hierarchy and where the criterion simply has one more parameter describing the abstraction , we need to slightly revise the construction in order to provide a completely unified notation for the slicing criterion .",
    "note that , the present paper will only deal with _",
    "backward _ slicing , where the interest is on the part of the program which _ affects _ the observation associated with the slicing criterion and not on the part of the program which _ is affected _ by such an observation ( called instead _ forward _ slicing @xcite ) .      the slicing criterion characterizes what we have to observe of the program in order to decide whether a program is a slice or not of another program .",
    "in particular , we have to fix which computations have to be compared , i.e. , the inputs and the observations on which the slice and the program have to agree .    in the seminal weiser approach ,",
    "given a set of variables of interest @xmath251 and program statement @xmath12 , here referred by the program point @xmath2 where @xmath12 is placed , a slicing criterion was modeled as @xmath259 . in the following , we will gradually enrich and generalize this model in order to include several different notions and forms of slicing .",
    "weiser s approach is known as _",
    "static slicing _ since the equivalence between the original program and the slice has , implicitly , to hold for every possible input .",
    "on the other hand , korel and laski proposed a new technique called _ dynamic slicing _",
    "@xcite which only considers one particular computation , and therefore one particular input , so that the dynamic slice only preserves the ( subset of the ) meaning of the original program for that input .",
    "hence , in order to characterize a slicing criterion including also dynamic slicing we have to add a parameter describing the set of initial memories @xmath260 : the criterion is now @xmath261 , where @xmath262 for static slicing , while @xmath263 , with @xmath264 , for dynamic slicing .",
    "finally , canfora proposed _ conditioned slicing _",
    "@xcite , which requires that a conditioned slice preserves the meaning of the original program for a set of inputs satisfying one particular condition @xmath265 .",
    "let @xmath266 be the set of input memories satisfying @xmath265 @xcite .",
    "hence , the slicing criterion still can be modeled as @xmath267 .",
    "each type of slicing comes in four forms which differ on what the program and the slices must agree on , namely on the observable semantics that has to agree . in the following ,",
    "we provide an informal definition of these forms in order to provide the intuition of what will be formally defined afterwards :    standard : :    it considers one point in a program with respect to a set of    variables . in other words , the standard form of slicing only tracks    one program point .",
    "semantically , this form of slicing consists in    comparing the program and the slices in terms of the ( _ denotational _ )",
    "i / o semantics from the program inputs selected by the criterion .",
    "namely , for each selected input , the results of the criterion    variables in the point of observation must be the same , independently    from the executed statements .",
    "korel and laski ( @xmath268 ) : :    it is a stronger form where the program and the slice must follow    identical paths @xcite .",
    "semantically , we could say that the program    and the slice must have the same ( _ operational _ ) trace semantics    w.r.t .",
    "the statements kept in the slice , starting from the program    inputs selected by the criterion . in other words , as before , the final    value must be the same , but in this case these values must be obtained    by executing precisely the same statements , i.e. , following the same    execution path",
    ". iteration count ( @xmath269 ) : :    when considering the trace semantics , the same program point inside a    loop may be visited more than once , in the following we call    _ @xmath40-th iteration _ of a program point @xmath2 the    @xmath40-th time the program point @xmath2 is visited .",
    "the iteration count form of slicing requires that a program and its    slice agree only at a particular @xmath40-th iteration of a    program point of interest . in this way ,",
    "when a point of interest is    inside a loop , we have the possibility to require that the variables    must agree only at some iterations of the loop and not always .",
    "korel and laski iteration count ( @xmath270 ) : :    it is the combination of the last two forms .    in order to deal with these different forms of slicing ,",
    "the slicing criterion must be enriched with additional information .",
    "in particular , the @xmath268 form of slicing does not change where to observe variables , but it does change the observed semantics up to that point . hence , we simply have to add a boolean parameter @xmath271 :  means that we are considering a @xmath268 form and we require that the slice must agree with the program on the execution of statements that are in the slice ( and obviously also in the original program ) ; on the other hand ,  indicates a standard , non-@xmath268 form of slicing .",
    "hence , a criterion @xmath272 comes to be @xmath273 .",
    "the @xmath269 form , instead , affects the observation : in order to embed this features in the criterion , the third parameter has to be changed .",
    "let @xmath274 be the iterations of the program point @xmath275 we are interested in ; then , instead of @xmath2 , in the third parameter of the criterion we should have @xmath276 .",
    "therefore , @xmath272 takes the form @xmath277 , where @xmath278 .",
    "note that @xmath279 represents the fact that we are interested in all occurrences of @xmath2 , as it happens in the standard form .",
    "there are also some _ simultaneous _",
    "( @xmath280 ) forms of slicing that consider more than one program point of interest .",
    "in order to deal with @xmath280 forms of slicing , we simply extend the definition of a slicing criterion by considering @xmath281 as a set instead of a singleton , namely , @xmath282 .    in the appendix",
    "there are some simple examples showing the main differences between the several forms of slicing introduced so far .",
    "in this section we define a weaker notion of slicing based on abstract interpretation . in particular , we generalize the formal framework in @xcite in order to include also the abstract versions of slicing .",
    "program slicing is used for reducing the size of programs to analyze . nevertheless , sometimes this reduction is not sufficient for really improving an analysis .",
    "suppose that some variables at some point of execution do not have a desired property ( for example , that they are different from @xmath283 , or from @xmath28 ) ; in order to understand where the error occurred , it would be useful to find those statements which affect such a property of these variables .",
    "standard slicing may return too many statements , making it hard for the programmer to realize which one caused the error .",
    "[ ex : abstractslicing ] consider the following program @xmath3 , that inserts a new element @xmath284 at position @xmath285 in a single - linked list .",
    "for simplicity , let @xmath285 never exceed the length of @xmath286 .    _",
    "_    ....     y : = null ;     x : = list ;     while ( pos>0 ) {       y : = x ;       x : = x.next ; // by hypothesis",
    ", this always succeeds       pos : = pos-1 ;     }     z : = new node(elem ) ;     z.next : = x ;     if ( y = null ) {       list : = z ;     } else {       y.next = z ;     }       ....    suppose that @xmath286 is cyclic after line 47 , i.e. , a traversal of the list visits the same node twice .",
    "a close inspection of the code reveals that no cycle is created between lines 34 and 47 : @xmath286 is cyclic after line 47 if and only if it was cyclic before line 34 .    in the standard approach ,",
    "it is possible to set the value of @xmath286 after line 47 as the slicing criterion . in this case , since @xmath286 can be modified at lines 4147 , at least this piece of code must be included in the slice .",
    "on the other hand , let the cyclicity of @xmath286 after line 47 be the property of interest , represented by @xmath150 ( example [ ex : referenceabstractdomains ] ) .",
    "since this property of @xmath286 does not change , the entire code can be removed from the slice .",
    "we introduce _ abstract program slicing _ , which compares a program and its abstract slices by considering",
    "_ properties _ instead of exact values of program variables .",
    "such properties are represented as abstract domains , based on the theory of _ abstract interpretation _",
    "( section [ sec : basicabstractinterpretation ] ) .",
    "we first introduce the notion of _ abstract slicing criterion _ , where the property of interest is also specified .",
    "for the sake of simplicity , the definition only refers to non-@xmath280 forms ( i.e. , @xmath281 is a singleton instead of a set of occurrences : @xmath287 ) . in order to make abstract the criterion we have to formalize in it the _ properties _ that we aim at observing on program variables . in particular we could think of observing different properties for different variables .",
    "hence , we define a criterion abstraction @xmath288 defined as a tuple of abstract domains , each one relative to a specific subset of program variables : let @xmath251 be a set of variables of interest in @xmath3 and @xmath289}\\subseteq\\wp(\\cx)$ ] a partition of @xmath251 , the notation @xmath290 means that each uco @xmath291 is applied to the set of variable @xmath292 ( left implicit when it is clear from the context ) , meaning that @xmath291 is precisely the property to observe on @xmath292 . in the following ,",
    "we denote by @xmath293 the property observed on @xmath292 , formally @xmath294 .",
    "this is the most general representation , accounting also for relational domains .",
    "when ucos will be applied to singletons , the notation will be simplified ( @xmath295 instead of @xmath296 ) .",
    "let @xmath0 , @xmath161 , @xmath297 and @xmath298 be the variables in @xmath251 .",
    "let @xmath288 be @xmath299 , meaning that the interest is on the parity of @xmath0 , the sign of @xmath298 , and the ( relational ) property of _ intervals _ @xcite of the value @xmath300 . when abstracting a criterion w.r.t .",
    "@xmath288 , the required observation at a program state @xmath50 is @xmath301    in order to be as general as possible , we consider _ relational _ properties of variables ( see section  [ sec : preliminaries ] ) , so that properties are associated with tuples instead of single variables . in this case , a property is said to _ involve _ some set ( tuple ) of variables .",
    "given a memory @xmath41 , @xmath302 is the result of applying @xmath1 to the values in @xmath41 of the variables involved by the abstract domain , and @xmath303 is the corresponding notion for tuples of ucos .",
    "[ def : abstractcriteria ] let @xmath260 be a set of input memories , @xmath304 be a set of variables of interest ; @xmath278 be a set of occurrences of interest ; @xmath271 be a truth value indicating if the slicing is in @xmath268 form .",
    "moreover , let @xmath251 be the set of variables of interest and @xmath305 , with @xmath289}$ ] a partition of @xmath251 . then ,",
    "the _ abstract slicing criterion _",
    "is @xmath306 ,    note that , when dealing with non - abstract notions of slicing , we have that each domains is the identity on each single variable , namely @xmath307 , where @xmath308 .",
    "it is also worth pointing out that , exactly as it happens for non - abstract forms , @xmath262 corresponds to static slicing , and @xmath309 corresponds to dynamic slicing ; in the intermediate cases , we have conditioned slicing .      in this section ,",
    "we extend a formal framework in which all forms of abstract slicing can be formally represented .",
    "it is an extension of the mathematical structure introduced by binkley .",
    "following their framework , we represent a form of abstract slicing by a pair @xmath310 , where @xmath311 is the traditional syntactic ordering , and @xmath312 is a function mapping abstract slicing criteria to semantic equivalence relations on programs . given two programs @xmath3 and @xmath8 , and an abstract slicing criterion @xmath313",
    ", we say that @xmath8 is a @xmath310-_(abstract)-slice _ of @xmath3 with respect to @xmath313 iff @xmath314 and @xmath315 ( i.e. , @xmath3 and @xmath8 are equivalent w.r.t .",
    "@xmath312 ) .",
    "some preliminary notions are needed to define @xmath312 in the context of abstract slicing .",
    "an _ abstract memory _ w.r.t .  a set of variables of interests @xmath251 ( partitioned in @xmath289}$ ] )",
    "is obtained from a memory by restricting its domain to the variables of interest , and assigning to each set @xmath292 of variables an abstract value determined by the corresponding abstract property of interest @xmath291 .",
    "[ def : abstractstaterestriction ] let @xmath316 be a memory , @xmath251 be the set of a tuple of sets of variables of interest , and @xmath317 be the corresponding tuple of properties of interest such that @xmath289}$ ] is a partition of @xmath251 .",
    "the _ abstract restriction _ of a memory @xmath41 w.r.t .",
    "the state abstraction @xmath288 is defined as @xmath318 .",
    "[ ex : var ] let @xmath319 be a set of variables , and suppose that the properties of interest are the ( relational ) sign of the product @xmath320 and the parity of @xmath321 ( both defined in section  [ sec : preliminaries ] ) .",
    "we slightly abuse notation by denoting as @xmath126 also its extension to pairs @xmath322 where the sign of their product matters : e.g. , @xmath323 . in our formal framework ,",
    "@xmath288 is defined as @xmath324 .",
    "let @xmath325 , @xmath326 , @xmath327 , and @xmath328 ; then , @xmath329 comes to be @xmath330 .",
    "the _ abstract projection _ operator modifies a state trajectory by removing all those states which do not contain occurrences or points of interest .",
    "if there is a state that contains an occurrence of interest , then its memory state is restricted via @xmath331 to the variables of interest , and only a property is considered for each tuple . in the following ,",
    "the _ abstract projection _",
    "@xmath332 is formally defined .",
    "[ def : proja ] let @xmath333 , and @xmath334 such that @xmath335 if @xmath336 , @xmath337 otherwise .",
    "for any @xmath275 , @xmath338 , @xmath339 , we define a function @xmath340 as : @xmath341 the abstract projection @xmath342 is the extension of @xmath340 to sequences : @xmath343    @xmath340 takes a state from a state trajectory , and returns either one pair or an empty sequence @xmath344 .",
    "abstract projection allows us to define all the semantic equivalence relations we need for representing the abstract forms of slicing .",
    "[ abssli ] consider the program @xmath3 in figure  [ fig : exsl ] .",
    "c|c    ....",
    "read(n ) ;    i : = 1 ;     s : = 0 ;     p : = 1 ;    while ( i < = n ) {      s : = s+i ;      p : = p*i ;      i : = i+1 ; }    write(i , n , s , p ) ;             ....    &    ....",
    "read(n ) ;    i : = 1 ;     s : = 0 ;        while ( i < = n ) {      s : = s+i ;           i : = i+1 ; }    write(i , n , s ) ;             ....     + & + program @xmath3 & program @xmath8    consider @xmath345 ( meaning that we are considering static slicing ) , @xmath346 , @xmath347 ( meaning that we check the value of variables of interest at each iteration of program point @xmath348 ) . moreover , we consider @xmath349",
    ". then in figure  [ absfig ] we have the corresponding abstract projection ( the concrete trace is given in the appendix , example  [ extrace ] ) . in this figure , we depict states as set of boxes , the first one contains the number of the executed program point ( with the iteration counter as apex ) , while the other boxes are the different variables associations .",
    "the cross on a box means that the projection does not consider that variable or state .",
    "so for instance , in this example we care only of states @xmath350 and @xmath351 , and in particular , in states @xmath350 we are not interested in the values of variables , while in states @xmath351 we are interested in the sign of @xmath54 and in the parity of @xmath12 ( if we would be interested in the value of these variables we would have the value instead of their property , as it happens in the examples in the appendix ) .     in example",
    "[ abssli ] ]      the only missing step for completing the formal definition of abstract slicing in the formal framework is to characterize the functions mapping abstract slicing criteria to abstract semantic equivalence relations .",
    "[ def : abstractunifiedequivalence ] let @xmath3 and @xmath8 be executable programs , and @xmath333 be an abstract criterion",
    ". then @xmath3 is _ abstract - equivalent _ to @xmath8 if and only if , for every @xmath352 , it holds that @xmath353 , where @xmath354 if @xmath336 .",
    "the function @xmath355 maps each criterion @xmath356 to a corresponding abstract semantic equivalence relation .",
    "therefore , a generic form of slicing can be represented as @xmath357 .",
    "this can be used to formally define both traditional and abstract forms of slicing in the presented abstract formal framework , so that the latter comes to be a generalization of the original formal framework .",
    "the following examples show how it is possible to use these definitions in order to check whether a program is an abstract slice of another one .    c@|@c    ....",
    "read(n ) ;     read(s ) ;     i : = 1 ;     while ( i<=n ) {       s : = s+2*i ;       i : = i+1 ;   }     write(i ,",
    "n , s ) ;         ....    &    ....     read(n ) ;     read(s ) ;         write(n , s ) ;         ....    consider the programs @xmath3 and @xmath8 in figure  [ fig : pandq ] .",
    "let @xmath358 , meaning that we are interested in the parity of  ( @xmath359 ) at the end of execution ( @xmath360 ) for all possible inputs ( @xmath262 ) , in non-@xmath268 form .",
    "since @xmath361 , in order to show that @xmath8 is an abstract static slice of @xmath3 with respect to @xmath356 , we have to show that @xmath362 holds .",
    "let @xmath363 for some @xmath364 be an initial memory .",
    "the trajectory of @xmath3 from @xmath41 contains the following steps of computation :        applying @xmath332 ( with @xmath337 since @xmath365 ) to @xmath60 returns only the abstract value of the variable at point @xmath366 ( due to @xmath313 ) : @xmath367 since we have @xmath368 , @xmath369 returns @xmath370 .",
    "the abstract memory restricts the domain of @xmath41 to variables of interest , so we consider only the part of @xmath41 regarding @xmath12 , i.e. , @xmath371 .",
    "hence , we have @xmath372 . since the parity of @xmath373 only depends on the parity of @xmath210 , being either @xmath209 or @xmath374 even , the final result is @xmath375 .",
    "consider now the execution of @xmath8 from @xmath41 , which corresponds to the following state trajectory :        applying @xmath332 to @xmath376 gives : @xmath377 therefore , @xmath378 is equal to @xmath379 . as @xmath41 is an arbitrary input , this equation holds for each @xmath264 , so that @xmath380 , and this implies that @xmath8 is an abstract static slice of @xmath3 w.r.t .",
    "@xmath356 .    c@|@c    ....",
    "read(n ) ;     s : = 0 ;     i : = 1 ;     while ( i<=n ) {       s : = s+i ;       i : = i+1 ; }     write(i , n , s ) ;         ....    &    ....",
    "read(n ) ;     s : = 0 ;         write(n , s ) ;         ....    consider the programs @xmath9 and @xmath10 in figure  [ fig : rands ] , and let @xmath356 be @xmath381 , where @xmath382 ; i.e. , we are interested in the parity of at the end of the execution for all inputs where is a multiple of @xmath383 . since @xmath384",
    ", in order to show that @xmath10 is an abstract conditioned slice of @xmath9 w.r.t .",
    "@xmath356 , we have to show that @xmath385 holds , namely that they have the same abstract projection .",
    "let @xmath386 be an initial memory , and suppose @xmath387 .",
    "the trajectory @xmath388 of @xmath9 from @xmath41 contains the following computations :        while executing @xmath10 from @xmath41 gives the state trajectory @xmath389        applying @xmath332 to both state trajectories we have : @xmath390 therefore , we have @xmath391 . as @xmath41 is an arbitrary input from @xmath392 , this equation holds for each @xmath386 , so that @xmath393 , and this implies that @xmath10 is an abstract conditioned slice of @xmath9 w.r.t .",
    "it is worth noting , that @xmath10 is not a _ static _ abstract slice of @xmath9 since for all the input values",
    "@xmath394 for @xmath2 the parity of the final value of is not necessarily even .",
    "this section provides a formal theory allowing us to compare abstract forms of slicing between themselves , and with non - abstract ones .",
    "first of all , we show under which conditions an abstract semantic equivalence relation _ subsumes _ another one ; analogously , we show when the form of ( _ abstract _ ) slicing , corresponding to the former equivalence relation , subsumes the form of ( _ abstract _ ) slicing corresponding to the latter one .",
    "such results are necessary in order to obtain a precise characterization of the extension of the _ weaker than _ relation ( whose original definition is recalled in the appendix ) to the abstract forms of slicing .",
    "the following lemma shows under which conditions on the slicing criteria there is a relation of subsumption between two semantic equivalence relations . in the following ,",
    "we denote @xmath395 the relation `` more concrete than '' in the lattice of abstract interpretations between tuples of abstractions .",
    "formally , let us consider @xmath396 defined on the variables @xmath397 and @xmath398 defined on the variables @xmath399 , such that @xmath400 , @xmath401 and @xmath402 we have @xmath403 , namely the variables in common are partitioned in the same way . then @xmath404 iff @xmath405 .",
    "note that , for all the variables in @xmath406 , the abstraction @xmath407 does not require any particular observation , hence on these variables surely @xmath408 is more precise .",
    "the following relation is such that , when both @xmath409 and @xmath410 are the identity on all the variables of interest , then the resulting criterion relation is the same proposed in @xcite ( see the appendix for details ) for characterizing the original formal framework .    [",
    "the : abstractunifiedequivalencelemma ] let two abstract slicing criteria @xmath411 and @xmath412 be given .",
    "if ( 1 ) @xmath413 ; ( 2 ) @xmath414 ; ( 3 ) @xmath415 ; ( 4 ) @xmath416 ; and ( 5 ) @xmath404 ( denoted @xmath417 ) , then @xmath418 _ subsumes _ @xmath419 , i.e. , for every @xmath3 and @xmath8 such that @xmath420 , @xmath421 implies @xmath422 .",
    "first of all , note that , if @xmath423 , namely if we are considering concrete criteria , then @xmath424 collapses to the concrete relation defined in @xcite ( which is the @xmath425 defined in equation  [ eq : defrelcrit ] in the appendix ) .",
    "hence , in this case , the results holds by @xcite .",
    "+ suppose @xmath426 with @xmath427 , namely @xmath8 slice of @xmath3 w.r.t .",
    "this means that , for each @xmath429 @xmath430 , where @xmath431 is defined as in definition  [ def : abstractunifiedequivalence ] .",
    "this means that , for each state @xmath432 in the trajectory @xmath433 , whose projection @xmath434 means that we are projecting a state of the computation of @xmath3 . ]",
    "is not empty , there exists a state @xmath435 in @xmath436 with the same projection .",
    "let us consider now , @xmath437 .",
    "we prove that on these states @xmath438 ( and in this case there is a corresponding state in the trajectory of @xmath8 ) , or it is empty ( and in this case also the state in @xmath8 has empty projection ) .",
    "recall that @xmath439 where also @xmath440 is defined as in definition  [ def : abstractunifiedequivalence ] .",
    "note that , since we are considering both the criteria on the same pair of programs , we have also that @xmath416 corresponds to saying that @xmath441 . at this point    * if @xmath442 then @xmath443 , but @xmath444 , hence @xmath445 .",
    "this mean that @xmath446 , which by hypothesis is equal to @xmath447 , for a memory @xmath448 . by definition and hypothesis , @xmath449 .",
    "namely , @xmath450 . therefore ,",
    "in particular , @xmath451\\subseteq[1,k^2]$ ] we have @xmath452 , but by hypothesis @xmath453 , hence we also have @xmath454 ( by properties of ucos ) .",
    "but then @xmath455 , namely @xmath456 .",
    "hence @xmath457 * if @xmath458 then @xmath459 . if @xmath460 then @xmath461 , then also @xmath462 but then by hypothesis we have that there exists a memory @xmath448 such that @xmath463 .",
    "but then we also have @xmath464 .",
    "+ if @xmath465 , then @xmath466 , but then there exists @xmath448 such that also in @xmath8 we have @xmath467 .",
    "but then , the same memory , in @xmath468 keep the program point but loses the state observation because @xmath469 , hence @xmath470 . * finally , if @xmath471 , then @xmath472 .",
    "but this means that , even if there exists @xmath448 such that we have the state @xmath473 in the trajectory of @xmath8 , also in this case we have @xmath474 .",
    "this lemma tells us how it is possible to find the relationship ( in the sense of subsumption ) between two semantic equivalence relations determined by two abstract slicing criteria . in the following , abstract notions of slicing",
    "will be denoted by adding an @xmath288 ; e.g. , @xmath475 denotes static abstract slicing , whereas @xmath476 denotes dynamic abstract slicing . by using this lemma",
    "we can show that , given a slicing criterion @xmath356 , all the abstract equivalence relations introduced in sec .",
    "[ subsection : abstractunifiedequivalence ] subsume the corresponding non - abstract equivalence relations @xmath477 , @xmath478 and @xmath479 .",
    "furthermore , by using this lemma we can show that @xmath480 subsumes @xmath481 , which in turns subsumes @xmath482 .",
    "@xcite let @xmath483 and @xmath484 be semantic equivalence relations such that @xmath484 subsumes @xmath483 .",
    "then , for every @xmath3 and @xmath8 , we have @xmath485 .",
    "[ fig : ret2 ] shows the non - hierarchy obtained by enriching the hierarchy in fig .",
    "[ fig : ret1 ] with standard forms of _ abstract static slicing _ , _ abstract dynamic slicing _ , and _",
    "abstract conditioned slicing_. in general , we can enrich this hierarchy with any abstract form of slicing simply by using the comparison notions defined above .",
    "non - abstract forms are particular cases of abstract forms of slicing , as they can be instantiated by choosing the identity property , @xmath107 , for each variable of interest .",
    "hence , non - abstract forms are the `` strongest '' forms , since , for each property @xmath1 , we have @xmath486 . moreover , if parameters @xmath487 are fixed , and @xmath288 is made less precise or more abstract ( i.e. , the information represented by the property is reduced ) , then the abstract slicing form becomes weaker , as suggested by dotted lines in figure [ fig : ret2 ] .",
    "in the previous sections we introduced a formal framework of different notions of program slicing . in particular , we observed that a kind of slicing is a pair : a syntactic preorder and a semantic equivalence relation @xcite .",
    "after discussing how the notion of `` to be a slice of '' can be formally _ defined _ , the focus will shift to how to _ compute _ a slice given a program and a slicing criterion .",
    "again , among all the possible definitions of slicing , we are interested in slices obtained by erasing statements from the original program , i.e. , the slice is related to the original program by the syntactic ordering relation @xmath311 . given a slicing criterion ,",
    "the idea is keeping all the statements affecting the _ semantic equivalence relation _ defined by the criterion .",
    "in other words , we should have to _ translate _ the formal definition into a characterization of which statements has to be kept in a slice , or vice versa which statements can be erased , in order to preserve the semantic equivalence defining the chosen notion of slicing .",
    "intuitively , we have to keep all the statements _ affecting _ the semantics defined by the chosen slicing criterion .    the standard approach for characterizing slices and the corresponding relation",
    "_ being slice of _ is based on the notion of program dependency graph @xcite , as described by binkley and gallagher @xcite .",
    "_ program dependency graphs _ ( pdgs ) can be built out of programs , and describe how data propagate at runtime . in program slicing , we could be interested in computing dependencies on statements : @xmath488 depends on @xmath489 if some variables which are used inside @xmath488 are defined inside @xmath489 , and definitions in @xmath489 reach @xmath488 through at least one possible execution path .",
    "also , @xmath12 depends _ implicitly _ on an if - statement or a loop if its execution depends on the boolean guard .",
    "[ example : statementdependency ] consider the program in figure  [ pdgfig ] and the derived pdg ( edges which can be obtained by transitivity are omitted ) .",
    "@xmath490 depends on both @xmath491 and @xmath492 ( and , by transitivity , @xmath493 ) since @xmath494 is not known statically when entering @xmath490 . on the other hand ,",
    "there is _ no _ dependency of @xmath490 on either ( i ) @xmath495 , since @xmath297 is not used in @xmath490 ; or ( ii ) @xmath496 , since @xmath298 is always redefined before @xmath490 .",
    "the dependency of @xmath492 on @xmath493 is implicit since @xmath383 does not depend on @xmath0 nor @xmath161 , but @xmath492 is executed conditionally on @xmath493 .    formally , a _ program dependence graph _",
    "@xcite @xmath497 for a program @xmath3 is a directed graph with nodes denoting program components and edges denoting _ dependencies _ between components .",
    "the nodes of @xmath497 represent the assignment statements and control predicates in @xmath3 .",
    "in addition , nodes include a distinguished node called _ entry _ , denoting where the execution starts .",
    "an edge represents either a _ control dependency _ or a _ flow _",
    "( _ data _ ) _ dependency_. control dependency edges @xmath498 are such that ( 1 ) @xmath499 is the entry node and @xmath494 represents a component of @xmath3 that is not nested within any control predicate ; or ( 2 ) @xmath499 represents a control predicate and @xmath494 represents a component of @xmath3 immediately nested within the control predicate represented by @xmath499 .",
    "flow dependency edges @xmath500 are such that ( 1 ) @xmath499 is a node that defines the variable @xmath0 ( usually an assignment ) , ( 2 ) @xmath494 is a node that _ uses _ @xmath0 , and ( 3 ) control can reach @xmath494 from @xmath499 via an execution path along which there is no intervening re - definition of @xmath0 .",
    "unfortunately , there is a clear _ gap _ between the definition of slicing given in definition  [ defslice ] and the standard implementation based on program dependency graphs ( pdg ) @xcite .",
    "this happens because slicing and dependencies are usually defined at _ different levels _ of approximation .",
    "in particular , we can note that the slicing definition in the formal framework defines slicing by requiring the same _ behavior _ , with respect to a criterion , between the program and the slice , i.e. , we are specifying what is _ relevant _ as a _ semantic _ requirement . on the other hand ,",
    "dependency - based approaches consider a notion of dependency between statements which corresponds to the _ syntactic _ presence of a variable in the definition of another variable .",
    "in other words , slices are usually defined at the _ semantic _ level , while dependencies are defined at the _ syntactic _ level .",
    "the idea presented in this paper consists , first of all , in identifying a notion of _ semantic _ dependency corresponding to the slicing definition given above , in order to characterize the implicit parametricity of the notion of slicing on a corresponding notion of dependency .",
    "this way , we can precisely identify the semantic definition of slicing corresponding to a given dependency - based algorithm , characterizing so far the loss of precision of a given algorithm w.r.t .  the semantic definition .        in figure",
    "[ fig : schema ] we show these relations . in particular , starting from the criterion , we can define an equivalent notion of dependency which allows us to identify which variables should be kept in a slice , affecting the whole program semantics ( program dependency notion ) .",
    "let @xmath501 be a slicing criterion , and @xmath3 be a program .",
    "the program depends on @xmath0 , denoted @xmath502 iff @xmath503    this means that the variable @xmath0 affects the observable semantics of @xmath3 .",
    "unfortunately , this characterization is not effective due to undecidability of the program semantics . in particular",
    ", the amount of traces to compare could be infinite , and also the traces themselves could be infinite .",
    "hence , we consider a stronger notion of dependency that looks for _ local _ semantic dependencies , identifying all the variables affecting at least one expression used in the program ( expression dependency notion ) , and this is precisely the _ semantic _ generalization of the syntactic dependency notion used , for instance , in pdg - based algorithm for slicing . in other words",
    "we characterize when a variable affects the semantics of an expression in @xmath3 .",
    "our idea is to make semantic the standard notion of syntactic dependency , by substituting the notion of _ uses _ with the notion of _ depends on _ @xcite . in order to obtain this characterization",
    ", we have to find which variables might affect the evaluation of the expression @xmath72 in the assignment @xmath504 or in a control statement guarded by @xmath72 , i.e. , which variables belong to the set @xmath505 of the variables _ relevant _ to the evaluation of @xmath72 . as already pointed out , standard syntactic dependency calculi compute @xmath505 as @xmath506 .",
    "[ def : concretedependencies ] let @xmath501 be a slicing criterion .",
    "let @xmath507 , @xmath508 .",
    "@xmath509 the formulation of @xmath510 can be rewritten as @xmath511}}{}}{}{\\left({\\state\\left[x \\leftarrow v_1\\right]}\\right ) } } } } \\neq    { \\ok{{{\\left\\llbracket \\exp \\right\\rrbracket}\\ifthenelse{\\equal{{\\state\\left[x \\leftarrow v_2\\right]}}{}}{}{\\left({\\state\\left[x \\leftarrow v_2\\right]}\\right)}}}}\\ ] ]    [ prop : approxdep ] let @xmath272 be a slicing criterion . if @xmath502 then there exists @xmath72 in @xmath3 such that @xmath510 .",
    "let us reason by contradiction .",
    "if for each @xmath72 in @xmath3 we have @xmath512 , then all the expressions in @xmath3 do not depend on @xmath0 and therefore , independently from @xmath0 , @xmath3 provides precisely the same results .    by using this notion of dependency",
    ", we can characterize the subset @xmath513 containing exactly those variables which are _ semantically _ relevant for the evaluation of @xmath72 .",
    "this way , we obtain a notion of dependency which allows us to derive more precise slices , i.e. , to remove statements that a merely syntactic analysis would leave .",
    "[ ese1 ] consider the program @xmath3 :    ....     x:=$e_x$ ;     y:=$e_y$ ;      w:=$e_w$ ;     z:=w+y+2(x$^2$)-w ;     ....    where @xmath514 , @xmath515 and @xmath516 are expressions .",
    "we want to compute the static slice @xmath8 of @xmath3 affecting the final value of ( i.e. , the _ slicing criterion _",
    "@xmath517 is interested in the final value of ) .",
    "if we consider the traditional notion of slicing , then it is clear that we can erase line 3 without changing the final result for .",
    "however , in the usual syntactic approach , we would have a dependency between and , since is used where is defined .",
    "consequently , the slice obtained by applying this form of dependency would leave the program unchanged .",
    "on the other hand , if the semantic dependency is considered , then the evaluation of @xmath518 does not depend on the possible variations of , which implies that we are able to erase line 3 from the slice .",
    "next we show how the pdg - based approach to slicing can be modified in order to cope with semantic slicing .",
    "the pdg approach is based on the computation of the set of variables _ used _ in a expression @xmath72 . in the following ,",
    "we wonder if this set can be rewritten by considering a semantic form of dependency .",
    "hence , let us define the new notion of _ semantic _ pdg , where all the flow dependencies are _ semantic _ , i.e. , we substitute the flow edges defined above with semantic flow dependency edges @xmath519 which are such that ( 1 ) @xmath499 is a node that defines the variable @xmath0 ( usually an assignment ) , ( 2 ) @xmath494 is a node containing an expression @xmath72 such that @xmath510 ( where @xmath272 is the criterion with respect with we are computing the slice ) , and ( 3 ) control can reach @xmath494 from @xmath499 via an execution path along which there is no intervening re - definition of @xmath0 .",
    "a ( semantic ) flow path is a sequence of ( semantic ) flow edges .",
    "[ prop : flowdep ] let @xmath3 be a program and @xmath272 be a slicing criterion .",
    "let @xmath497 the pdg with flow dependency edges @xmath520 , and @xmath521 be the semantic pdg where the flow dependency edge are semantic @xmath522 . if @xmath523 then @xmath524 .",
    "trivially , since if @xmath510 , then @xmath72 must use the variable @xmath0 .    in principle , a ( backward ) slice is composed by all the statements ( i.e. , nodes ) such that there exists a path from the corresponding node to the relevant ( according to the slicing criterion ) use of a variable of interest ( in the criterion ) @xcite .",
    "in other words , we follow backward the ( semantic ) flow edges from the nodes identified by the criterion , and we keep all the nodes / statements we reach .",
    "hence , the criterion , and therefore the dependency notion , defines the edges that we can follow for computing the slice .    by using the semantic flow dependency edges",
    ", we can draw a new _ semantic _ pdg containing less flow edges , i.e. , only those corresponding to semantic dependencies . at this point , the type of slicing ( either static , dynamic or conditional ) characterized by the criterion decides which nodes can be kept in the pdg .",
    "[ th : slispdg ] let @xmath525 be a slicing criterion .",
    "let @xmath3 be a program and @xmath526 its _ semantic pdg _ , i.e. , a pdg whose flow edges are @xmath522 .",
    "let @xmath8 the subprogram of @xmath3 containing all the statements corresponding to nodes such that there exists a semantic flow path in @xmath526 from them to a node in @xmath527 .",
    "then @xmath8 is a slice w.r.t .",
    "the criterion @xmath528 .",
    "note that , the pdg construction is syntactic , and therefore independent from the input set @xmath392 , hence any slice computed by using the pdg holds for any possible input memory in @xmath529 .",
    "moreover , since we simply collects the statements potentially affecting the program observation , we can not decide which iteration to observe , for this reason each program point is taken in the slice independently from the iteration to observe , for this reason the obtained slice will provide the same result for any possible iteration , i.e. , the set of interesting points to observe are @xmath530 .",
    "finally , by construction we can not have statements executed in the slice which are not executed in the original programs .",
    "hence , the criterion enforced by the pdg slice construction is @xmath531 ( direct consequence of the _ slicing theorem _ in @xcite ) , which for each @xmath532 and @xmath533 is a slice also w.r.t .  the criterion @xmath534 , by @xcite ( equation  [ eq : defrelcrit ] in the appendix ) .",
    "hence , we have that the results is a slice w.r.t .  @xmath272 @xcite .",
    "we have pointed out so far the difference between syntactic and semantic dependencies : it can be the case that a variable syntactically appears in an expression without affecting its value .",
    "actually , one could argue that the case is not very likely to happen : the possibility to find an assignment like @xmath535 in code written by a professional software engineer is remote to the very least .",
    "however , when it comes to abstract dependencies , the picture is quite different , and we could even say that , in the present work , ( concrete ) semantic dependencies have been mainly introduced to prepare the discussion about their abstract counterpart . indeed , it is much more likely that some variables are not semantically relevant to an expression if the value of interest is an abstract one , e.g. , the parity or the sign of a numeric expression , or the nullity of a pointer .",
    "this justifies the definition of a semantic notion of dependency at the abstract level .",
    "this section discusses the problem of defining and computing abstract dependencies allowing us to capture the dependency relation between variables w.r.t .  a given abstract criterion . in the previous section",
    ", we formalized this relation in the concrete semantic case ; the following example takes it to the abstract level .",
    "consider the expression @xmath536",
    "@xmath537 : although both variables are semantically relevant to the result , only can affect its parity , since @xmath538 will always be even . on the other hand , note that both variables are relevant to the sign of @xmath72 , in spite of the positivity of @xmath539 . in fact , given a negative value for , a change in the value of can alter the sign of the entire expression .",
    "first of all , it is worth noting that the notion of _ semantic program dependency _ can be easily extended to abstract criteria , simply by changing the projection considered . in this case",
    "we will write that @xmath540 , meaning that @xmath0 has effect on the abstract projection of @xmath3 determined by @xmath313 .",
    "also in the abstract case we inherit the undecidability of the concrete semantics of @xmath3 ; hence , again , we have to approximate the semantic program dependency with a local notion of _ abstract semantic expression dependency_. unfortunately , when dealing with abstract criteria @xmath313 , some aspects become more complicated .      in the previous section",
    ", we defined the concrete semantic dependency by identifying those variables that do not _ interfere _ with the final observation of each expression .",
    "analogously , in order to define a general notion of abstract semantic dependency , we need to consider the _ abstract _ interference between a property of a variable and a property of an expression .",
    "the definition below follows the same philosophy as _ narrow abstract non - interference _",
    "@xcite , where abstractions for observing input and output are considered , but these abstractions are observations of the _ concrete _ executions .",
    "[ def : abstractdependencies][def : narrowdependencies ] consider the abstractions @xmath214 and @xmath541 , where @xmath2 is the number of variables , i.e. , @xmath542 is a tuple of properties such that @xmath543 is the property on the variable @xmath161 .",
    "@xmath544    this notion is a generalization of definition  [ def : concretedependencies ] where we abstract the observation of the result ( @xmath1 ) and the information that we fix about all the variables different from ( @xmath542 ) . still , this notion characterizes whether the variation of the value of affects the abstract evaluation in @xmath1 of @xmath72 .    as an important result , we have @xmath545 whenever @xmath546 and @xmath547 induce the same partitions ( either on values , or tuples of values ) .",
    "this happens because , in definition  [ def : abstractdependencies ] , both abstractions are only applied to singletons . in the following ,",
    "only partitioning domains will be considered since it is straightforward to note that @xmath548 is affected only by @xmath549 , rather than by @xmath1 itself .    when dealing with abstractions , and therefore with abstract computations , some more considerations have to be taken into account .",
    "consider the program in example  [ ese1 ] , and consider the @xmath117 property ( section [ sec : basicabstractinterpretation ] ) for all variables on both input and output .",
    "if we compute the set of variables on which the parity of @xmath550 @xmath551 depends on , then we can observe that @xmath72 is still independent from , but is also independent from any possible variation of . at a first sight ,",
    "the parity of @xmath551 is independent from just because @xmath552 is constantly even .",
    "however , it is not only a matter of constancy : a deeper analysis would note that we can look simply at the abstract value of only because the operation involved ( the sum ) in the evaluation is _ complete _ ( section [ sec : basicabstractinterpretation ] ) , i.e. , precise , w.r.t .  the abstract domain considered ( @xmath117 ) . in particular ,",
    "when we deal with abstract domains which are complete for the considered operations , then it is enough to look at the abstract value of variables in order to compute dependencies . indeed , consider the @xmath126 domain ( section [ sec : basicabstractinterpretation ] ) . in this case , even if the sign of @xmath553 is constantly positive , the final sign of might be affected by a concrete variation of ( e.g. , consider @xmath554 and two executions in which is , respectively , 1 and 5 ) .",
    "therefore , has to be considered relevant , although the sign of @xmath553 ( the only sub - expression containing ) is constant .",
    "this can be also derived by considering the logic of independencies from @xcite since , by varying the value of , we can change the sign of @xmath72 .",
    "unfortunately , the notion of abstract dependencies given in definition  [ def : abstractdependencies ] is not suitable for weakening the pdg approach , as we have done in the concrete semantic case .",
    "let us explain the problem in the following example .",
    "[ ex : probabs ] consider the program @xmath555@xmath556 , where @xmath557 is come code fragment and the expression @xmath558 evaluates to @xmath559 if @xmath6 is true , and to @xmath560 otherwise .",
    "suppose the criterion requires the observation of the parity of @xmath0 at this program point , i.e. , @xmath561 .",
    "then it is straightforward to observe that the expression depends on @xmath161 , but we would like to be more specific ( being in the context of abstract slicing ) , and we can observe that it is the sign of @xmath161 that affects the parity of the expression , and therefore of @xmath0 . at this point , in the code @xmath557 we should look for the variables affecting not simply @xmath161 ( as expected in standard slicing approaches ) , but more specifically the _ sign _ of @xmath161 , a requirement not considered in the abstract criterion .",
    "this example shows that , if we aim at computing abstract dependencies without losing too much information , we would need an algorithm able to keep trace backwards , not only of the different variables that become of interest ( affecting the desired criterion ) , but also of the different properties to observe on variables affecting the desired property of the criterion .",
    "this means that , while for the concrete semantic program dependency we can provide a definition depending only on the criterion , this is not possible in a more abstract context , where each flow edge should be defined depending on abstract properties potentially different from those in the abstract criterion , and which should be characterized dynamically backward starting from the criterion .",
    "unfortunately , this is not possible in definition  [ def : abstractdependencies ] , where we always look for the variation of the value and not of an abstract property of , hence if we would use this notion for substituting the semantic dependency in pdgs we would not have so much advantage .",
    "these observations make clear that , if we aim at constructively characterize abstract slicing by means of the abstract dependency notion provided in definition  [ def : abstractdependencies ] , we need to build from scratch a systematic approach for characterizing abstract slicing . towards this direction ,",
    "the first step we propose is a computable approximation of the abstract dependencies of definition  [ def : abstractdependencies ] .      by means of the ( uco - dependent ) definition of operations on abstract values , it is possible to automatically obtain ( an over - approximation of ) the set of relevant variables .",
    "the starting point is the _ brute - force _ approach which uses the abstract version of concrete operations , and explicitly _ goes into _ the quantifiers involved in definition [ def : narrowdependencies ] .",
    "consider the program in example  [ ese1 ] and let @xmath562 . in order to decide whether @xmath563 holds",
    ", the brute - force approach considers the abstract evaluation of @xmath72 in all contexts where all variables different from does not change , up to @xmath542 , while may change . in this example , this boils down to consider pairs of memories where has the same parity ( with no information about sign ) , and we take memories where changes value , and see whether the final values of @xmath72 agree on the expression observation @xmath1 .",
    "suppose @xmath564 ( meaning that it is even but the sign is unknown ) and suppose @xmath245 , then we should have to compute the abstract value of @xmath72 for each possible value for .",
    "it is clear that we can easily find @xmath565 and @xmath566 such that @xmath567 even if @xmath568 ( for instance @xmath569 while @xmath570 and @xmath571 ) .",
    "it is clear that the sign of @xmath72 may depend on the value of since to `` fix '' the abstract property of the other variables is not enough to `` fix '' the final value of @xmath72 w.r.t .",
    "@xmath1 . on the other hand , the parity of @xmath72 does not depend on , in particular if we fix the property @xmath117 of , for instance to @xmath119 ( but it holds also for the other abstract values ) then @xmath572 namely ,",
    "if we fix all the ( abstract values of the ) variables but , then the parity of the result does not change , hence the variation of does not affect the parity of the expression @xmath72 .    in the following",
    ", we introduce an algorithm able to improve the computational complexity of the brute - force approach , especially on bigger ucos , and when ( 1 ) several variables are involved in expressions , and ( 2 ) a significant part of them is irrelevant .      in the following ,",
    "we discuss how we can constructively compute narrow dependencies .",
    "unfortunately , in static analysis , the concrete semantics can not be used directly as it appears in definition  [ def : narrowdependencies ] , hence we need to approximate this abstract notion .",
    "the following definition introduces a stronger notion of dependency based on a sound abstract semantics @xmath234 ( section [ sec : abstractsemantics ] ) , which approximates narrow dependencies .",
    "[ def : atomicabstractdependencies ] an expression @xmath72 _ atom - depends _ on @xmath0 ( written @xmath573 ) with respect to @xmath214 and @xmath574 ( @xmath2 number of variables ) if and only if there exist @xmath575 such that @xmath576    being domains partitioning , the _ non - atomicity _ requirement @xmath577 amounts to say that all @xmath1-abstract evaluations of @xmath72 , starting from different values for @xmath0 , may not be abstracted in the same abstract value ( this is the crucial issue in _ ndep _ ) , i.e. , @xmath578 and @xmath579 may lead to different abstract values for @xmath580 .",
    "next results shows that _ atom - dep _ is an approximation of _ ndep _ , since _ ndep",
    "_ implies _ atom - dep _ , meaning that _ atom - dep _ may only add false dependencies , but can not lose abstract dependencies characterized by _",
    "ndep_.    [ theorem : equivalenza ] consider the abstractions @xmath214 and @xmath541 , where @xmath2 is the number of variables , i.e. , @xmath542 is a tuples of properties . for every @xmath72 and @xmath0",
    ", @xmath548 implies @xmath573 .",
    "suppose @xmath548 , i.e. , @xmath581 , then we have to prove @xmath573 , i.e. , there exist @xmath582 such that @xmath583 and @xmath584 . since conditions @xmath585 and @xmath586 are the same , we have to prove that @xmath587 .    consider @xmath588 satisfying @xmath585 and such that @xmath589 , then @xmath590 . at this point , since @xmath591 contains two different values of @xmath1 , then , by definition , it can not be an atom of @xmath1 .",
    "starting from this new approximate notion , our idea is to provide an algorithm over - approximating the set of variables relevant for a given expression @xmath72 when @xmath592 , namely the abstraction observed in output is the same that we fix on the input variables .",
    "the idea is to start from an empty set of not relevant variables @xmath593 for an expression @xmath72 , and incrementally increase this set adding all those variables that _ surely _ are not relevant for the expression ( obtaining an under - approximation of abstract dependencies ) . finally , the complement of such set is returned , which is an over - approximation of relevant variables .    in order to check the dependency relation",
    ", we aim at checking whether a change of the values of a variables makes a difference in the evaluation of the expression .",
    "dependencies are computed according to _ atom - dep _ , in order to approximate _",
    "ndep_. in a brute - force approach , _ atom - dep _ would be verified by checking for each @xmath224 associating atomic values to variables we have that @xmath594 is always the same atom .",
    "[ example : dependenciesonsign ] let @xmath580 be an expression involving variables @xmath0 , @xmath161 and @xmath297 , and @xmath595 . in principle , in order to compute the set of @xmath1-dependencies on @xmath72 , we must compute @xmath238 on every possible atomic value are @xmath134 , @xmath135 , @xmath136 , @xmath137 , and @xmath138 ; since this is a partition of concrete values , we describe all concrete inputs by computing @xmath238 on atoms .",
    "] of , and , i.e. , @xmath238 must be computed @xmath596 times .",
    "is _ not _ relevant to @xmath72 if , for any abstract values @xmath597 , there exists an atomic abstract value @xmath598 such that @xmath599 .",
    "this amounts to say that changing the value of does not affect @xmath72 , since we require the same output atomic evaluation for each possible abstract value for .",
    "indeed , if the result is not atomic , it means that we have at least two different abstract results for different values of .",
    "analogously , for different ( abstract ) values for we have different atomic results , then again it means that there exists a variation of affecting the abstract evaluation of @xmath72 .    however , it is possible to be smarter :    * _ excluding states : _ consider dependencies of @xmath72 in example [ example : dependenciesonsign ] , computed at program point @xmath2 .",
    "suppose @xmath234 ( used as a tool to infer invariant properties , as discussed in section [ sec : abstractsemantics ] ) is able to infer , at point @xmath2 , that the abstract state @xmath600 is such that @xmath601}$ ] correctly approximates the value of variables at @xmath2 .",
    "then , we only need to consider states of the form @xmath602}},{z\\!\\leftarrow\\!\\avalue_z}\\}$ ] as inputs for @xmath238 ( now considered as the abstract computation of expressions , according to definition [ def : atomicabstractdependencies ] ) at @xmath2 . *",
    "_ computing on non - atomic states : _ let @xmath603 and @xmath604 . in this case",
    ", @xmath605 is implied by the more general result @xmath606 since @xmath607 and @xmath608 are partitions , respectively , of @xmath119 and @xmath120 , and @xmath238 is monotone : @xmath609 implies @xmath610 .",
    "this means that results obtained on @xmath224 can be used on @xmath611 .    in the following ,",
    "we compute dependencies w.r.t .",
    "the abstract state @xmath600 , which is the abstract state computed at @xmath2 as an invariant at that program point . in the worse case",
    ", we do nt have any information about the different variables , and therefore @xmath600 associates @xmath141 ( of the considered abstraction @xmath1 ) to all the unknown variables . at this point",
    ", we aim at proving that @xmath72 is independent from a set of variable @xmath593 , and in order to prove this fact we need to prove that the evaluation of @xmath72 is always the same atom in @xmath1 , independently from the value of the variables in @xmath593 , without proving for all these values .",
    "hence , our idea is to prove this atomicity , if it holds , by iteratively refining the starting abstract state @xmath600 .",
    "let us explain the intuition in the following example .",
    "[ example : funesharppmeaning ] let @xmath612 @xmath613 and @xmath614 .",
    "let also @xmath238 follow the usual rules on @xmath242 and @xmath240 : @xmath615 , @xmath616 , @xmath617 , @xmath618 , @xmath619 , etc .",
    "suppose to start from a memory such that @xmath620 , then we observe that @xmath621 can not be proved by using these rules , since @xmath622 , which is not atomic , and therefore there may be a dependency",
    ". then , consider the possible refinements w.r.t . in @xmath126 , namely @xmath623 .",
    "this is enough to compute @xmath624 meaning that any variation of provides the same atomic result in @xmath1 .    given an initial abstract state @xmath224 , we define the set of all the abstract states that refine its abstract value on the variables in @xmath593 , while leaving unchanged atomic values of other variables .",
    "@xmath625}={\\left\\{~{{\\sigma^\\rho_{i}}\\xspace } ~ \\left",
    "|                                 \\begin{array}{l}\\forall y\\notin x.\\:\\astate(y)=\\uco(\\state(y))={{\\sigma^\\rho_{i}}\\xspace}(y)\\in{{\\textsc{atoms}\\ifthenelse{\\equal{\\uco}{}}{}{\\left(\\uco\\right)}}},\\:\\forall x\\in x.\\ : { { \\sigma^\\rho_{i}}\\xspace}(x)\\leq\\astate(x)\\end{array }                            \\right .",
    "\\right\\}}\\ ] ] this is the set of all the possible abstract states that can be obtained by restricting abstract values of variables in @xmath593 ( the least values are the atoms of @xmath1 ) starting from an initial memory @xmath224 , while all the other variables are atomic . ] and fixed by @xmath224 .",
    "hence , the idea is that , once that all the variables different from are specified by atoms , we first compute the expression with @xmath626 , if the result is atomic , it means that all the values for provide the same results , and we can conclude that surely @xmath72 does not depend on . if the result is not atomic , it may be because there is a dependency or because the abstraction is incomplete for the semantics of the expressions , hence , in order not to be too coarse , we consider the covering of the @xmath141 in @xmath1 , namely we take the elements under the top and we repeat for all these values .",
    "if all the computations provide the same atomic results then we surely have @xmath72 independent form , otherwise we continue to refine the abstract values . if , we reach atomic values for then we terminate the recursion and we conclude that there may be dependency .",
    "hence we have to define a recursive predicate computing this iteration : given an expression @xmath72 and an atom @xmath627 , the _ atomicity condition _",
    "@xmath628 holds iff @xmath629 gives @xmath627 .",
    "@xmath630}\\in x\\mbox{\\em -covering}(\\astate).\\:\\forall i\\in[1,k].\\:{{\\mathbb{a}'_e\\ifthenelse{\\not\\equal{{{\\sigma^\\rho_{i}}\\xspace}}{}}{\\left({{\\sigma^\\rho_{i}}\\xspace}\\ifthenelse{\\equal{x}{}}{}{,x}\\right)}{}}}=\\avaluee\\\\ \\bot & \\mbox{if}\\ \\forall x\\in x.\\:\\astate(x)\\in{{\\textsc{atoms}\\ifthenelse{\\equal{\\rho}{}}{}{\\left(\\rho\\right)}}}\\ \\wedge\\ \\nexists\\avaluee\\in{{\\textsc{atoms}\\ifthenelse{\\equal{\\rho}{}}{}{\\left(\\rho\\right)}}}.\\:{{\\mathbb{a}^{\\avaluee}_e\\ifthenelse{\\equal{\\astate}{}}{}{\\left(\\astate\\right)}}}\\\\ \\end{array } \\right .\\ ] ] with @xmath631.\\:{{\\sigma^\\rho_{i}}\\xspace}\\in { \\left[\\astate|x\\right]}\\ \\wedge\\ \\forall x\\in x.\\:{{\\sigma^\\rho_{i}}\\xspace}(x)\\leq_\\iota\\astate(x),\\\\ \\mbox{and}\\ \\bigvee_i { { \\sigma^\\rho_{i}}\\xspace}(x)=\\astate(x)\\end{array }                            \\right .",
    "\\right\\}}\\ ] ] where @xmath632 iff @xmath633 or @xmath634 is a direct sub - value of @xmath635 in @xmath1 .",
    "intuitively , @xmath636 terminates the iterations either when the evaluation of the expression is always the same atom independently from the abstract value of the variables in @xmath593 ( meaning that there is no dependency from @xmath593 ) or when , for all the possible atomic values for variables in @xmath593 , the evaluation of the expression is not atomic or may have different atomic values ( meaning that there may be dependency from variables in @xmath593 ) .",
    "hence , a judgment @xmath637 means that an atomic value for @xmath72 was obtained without the need of further restricting the variables in @xmath593 , when all the other variables are atomic ; therefore , @xmath593 only contains non - relevant variables .",
    "the @xmath638 algorithm ( figure [ fig : ndepalgorithm ] ) starts by trying to prove that @xmath639 is atomic .",
    "if it find a restriction of the abstract values of all the variables making the @xmath72 evaluation atomic , then @xmath72 depends on no variables . otherwise ,",
    "the set @xmath593 is decreased non - deterministically ( one element at a time , randomly ) until some judgment @xmath637 is proved .",
    "[ proposition : correctness ] let @xmath214 be partitioning and @xmath224 , if there is no information then it works mapping all the variables in @xmath593 to @xmath80 ] an abstract state",
    ". let @xmath641 denote the tuple of @xmath1 , on each variable . for all @xmath642}$ ]",
    "we have that if @xmath643 ( namely not @xmath81 ) , then there is no @xmath644 such that @xmath645 .",
    "suppose to know that the variables in @xmath593 may soundly have only the values determined by @xmath224 , namely for each @xmath646 the concrete value of @xmath0 in the computation is contained in @xmath221 .",
    "this means that , for each @xmath646 , we can check dependency only for the values ranging over @xmath221 .",
    "consider @xmath647}$ ] , by definition of @xmath648}$ ] we have that @xmath649 we have @xmath650 , moreover again by definition these values are atomic hence @xmath651 . at this point , in order to prove that there is no dependency , we have to show that @xmath652 holds .",
    "but , at this point , by hypothesis since @xmath653 , meaning that there exists a covering of @xmath224 @xmath654}\\subseteq{\\left[\\astate|x\\right]}$ ] and @xmath655 such that @xmath656 $ ] we have @xmath657 , but this implies that @xmath658 and @xmath659 , which trivially implies the thesis .",
    "importantly , the assertions @xmath637 and @xmath660 guarantee @xmath661 not to hold , even if @xmath662 can not be directly proved",
    ". the final result of @xmath638 is @xmath663 , where @xmath664 is the union of all sets @xmath665 such that @xmath666 can be proved . by proposition [ proposition :",
    "correctness ] , this set is an over - approximation of relevant variables .",
    "function @xmath638 @xmath667 : = @xmath668 ; // @xmath669",
    "@xmath670(@xmath600,@xmath671 ) ; return @xmath672 ; // @xmath673 procedure @xmath670(@xmath224,@xmath593 ) if(@xmath674 ) then @xmath667 : = @xmath675 ; else foreach ( @xmath644 ) @xmath670(@xmath224,@xmath676 ) ;    the @xmath638 algorithm may deal , in principle , with _ infinite _ abstract domains , and in particular with abstract domains with infinite descending chains , since non - dependency results can be possibly proved without exploring the entire state - space ; in fact , if @xmath628 can be proved , then it is not needed to descend into the ( possibly infinite ) set of sub - states of @xmath224 . this is not possible in the brute - force approach .",
    "it is also straightforward to add _ computational bounds _ in order to stop `` refining '' states if some amount of computational effort has been reached .",
    "the problem of computing abstract dependencies can be observed from another point of view : given @xmath580 and a set @xmath593 of variables , we may be interested in soundly approximating the _ most concrete _",
    "@xmath1 such that @xmath677 does not hold .",
    "namely , the most concrete observation guaranteeing the non - interference of the variables in @xmath593 on the evaluation of @xmath72 @xcite .",
    "this can be accomplished by repeatedly simplifying an initial domain @xmath678 in order to eliminate abstract values which are _ responsible _ for dependencies .",
    "in order to avoid dependencies on @xmath593 , we should have @xmath637 , i.e. , @xmath679 should hold for any @xmath680}$ ] . if this does not hold for some @xmath224 , then @xmath1 is modified to obtain the atomicity of @xmath681 .",
    "we design a simple algorithm @xmath682 ( figure [ edep ] ) which repeatedly checks if there exists @xmath683 such that @xmath684 .",
    "initially , the current state @xmath224 is @xmath600 ( remember that @xmath600 is the abstract state correctly describing invariant properties of variables at the current program point @xmath2 ) ; then , it is progressively specialized to states belonging to one of its @xmath593-coverings , until one of the following holds :    * @xmath684 ; in this case , @xmath1 is precise enough to exclude dependencies on @xmath593 in @xmath224 , and is not further modified ; * @xmath224 can not be refined anymore ( it is atomic on @xmath685 ) but @xmath683 is non - atomic ; in this case , @xmath1 needs to be simplified in order to obtain @xmath686",
    ".    states are processed by means of a queue ; the algorithm stops when all states have been consumed without any modification to @xmath1 , i.e. , when no non - atomic @xmath683 has been found . as in @xmath638",
    ", states are progressively restricted , and computations on @xmath629 are avoided if the desired property already holds for @xmath687 .",
    "@xmath1 : = @xmath678 ; // @xmath688 repeat @xmath689 : = [ @xmath690 ; // @xmath691 while ( @xmath692(@xmath689 ) ) @xmath224 : = @xmath693(@xmath689 ) ; if ( @xmath694 ) then if ( @xmath695 ) then // @xmath696 //",
    "@xmath697 @xmath698 : = @xmath699 ; @xmath1 : = @xmath700 ; // @xmath701 @xmath689 : = [ @xmath690 ; else //",
    "@xmath702 foreach(@xmath54 ) @xmath703(@xmath689,@xmath704 ) until ( @xmath705 ) ; return @xmath1 ; // @xmath706",
    "the simplifying operator @xmath707 is a _ domain transformer _ , and works by removing abstract values in order to obtain @xmath686 .",
    "formally , @xmath708    the final @xmath1 is an approximation of the most precise @xmath709 s.t .",
    "@xmath710 is false :    [ theorem : nondependency ] @xmath711 makes @xmath580 not narrow - dependent on @xmath593 . in other words : the final @xmath1 satisfies non - narrow - dependency of @xmath72 on @xmath593 , that is , for every @xmath224 which is atomic on @xmath685 , @xmath629 is atomic .",
    "the algorithm halts if , in processing @xmath600 , @xmath1 is not changed .",
    "processing @xmath600 involves computing @xmath238 on sub - states when required , in order to prove the atomicity property on every concrete state represented by @xmath600 ( to this end , we exploit monotonicity of @xmath238 on states ) .",
    "this is precisely obtained if every state is removed from the queue before any modification to @xmath1 occurs .    on the practical side ,",
    "the loss of precision in abstract computations may lead to remove more abstract values than strictly necessary from the semantic point of view .",
    "it is important to note that @xmath712 works as long as @xmath713 can be computed on the initial domain ( in this case , no problems arise in subsequent computations , since the `` complexity '' of @xmath1 can only decrease ) .",
    "this can possibly happen even if @xmath678 is infinite ( see the end of section [ section : algorithmicideasforcheckingndep ] ) .",
    "moreover , unlike @xmath638 , there is no reasonable trivial counterpart , since any brute - force approach would be definitely impractical .",
    "this section introduces an algorithm for computing conditioned abstract slices , based on abstract dependencies and the notion of _ agreement _ between states .    as explained in section [ sec : practicalissuesandoptimizations ] , this way to compute slices relies on _ a priori _ knowledge of the properties which will be of interest for the analysis . in most cases , the majority of the abstract domains to be taken into account are quite simple ( e.g. , nullity ) . on the other hand , section [ sec : constructiveapproachestoabstractprogramslicing ] presents a general way to compute abstract dependencies on more complex domains .",
    "indeed , those algorithms can be used here , and their complexity is acceptable if small domains are dealt with .",
    "the slices obtained by following this methodology will have the standard form of backward slicing ; _ predicates _ or _ conditions _ on states can be specified , in the style of conditioned slicing @xcite . in this case , for a predicate @xmath714 , the judgment @xmath715 means that the state @xmath50 satisfies @xmath714",
    ". a predicate @xmath714 at a certain program point may include either user - provided or statically inferred information : for example , after a @xmath716 statement , judgments like `` @xmath717 is not null '' , `` @xmath717 is not cyclic '' , `` @xmath717 is not sharing with @xmath718 '' could be provided depending of the kind of static analyses available ( nullity , sharing , cyclicity , etc . ) . a way to decide which statements have to be included in an abstract slice",
    "consists of two main steps :    * for each statement @xmath12 , a specific static - analysis algorithm provides information about the relevant data _",
    "after _ that statement ( below , the _ agreement _ ) , according to the slicing criterion and the program code ; * if the execution of @xmath12 _ does not affect _ its corresponding agreement ( i.e. , some condition on states which must hold after @xmath12 ) , then @xmath12 can be removed from the slice .",
    "[ ex : conditionstoslice ] consider the following code fragment , and suppose that the slicing criterion is the nullity of at the end :    ....     ...     y.f : = $ \\mathit{exp}$ ;     x : = y ;     ....    the field update on ( line 22 ) can be removed from the slice because    * the question about the nullity of after line @xmath719 is equivalent to the question about the nullity of after line @xmath720 ; and * the field update at line @xmath720 does not affect the nullity of .    the rest of this section formalizes how these two main steps are carried out .",
    "this section describes how agreements are defined and propagated via a system of logical rules : the .- system .",
    "however , there are many differences between both systems , mainly due to the changes in the language under study ( for example , variables are taken into account here instead of a more involved notion of _ pointer expression _ ) . ]",
    "hoare - style _ triples _",
    "@xcite are used for this purpose , in the spirit of the _ weakest precondition calculus _ @xcite .",
    "[ def : agreement ] an _ agreement _",
    "@xmath721 is a set of conditions @xmath722}$ ] where each uco @xmath723 involves a sequence of variables @xmath724 ( most usually , just one variable ) , and all conditions involve mutually disjoint sets of variables .",
    "two states @xmath578 and @xmath579 are said to _ agree _ on @xmath721 , written @xmath725 , iff , for every @xmath722}$ ] in @xmath721 , @xmath726 , where notation is abused by taking @xmath727 as the sequence of values of variables @xmath724 in @xmath728 , and @xmath729 as the application of @xmath1 ( which could be a relational domain ) to the elements of such a sequence .",
    "agreements are easily found to form a lattice , and a partial order @xmath311 can be defined : @xmath730 iff , for every @xmath578 , @xmath579 such that @xmath731 , then @xmath732 . moreover ,",
    "an intersection operator is induced by the partial order : @xmath733 is the greatest agreement which is less than or equal to both .    in the following",
    ", @xmath734 will be the uco corresponding to the condition @xmath735}$ ] in @xmath721 , or @xmath109 if no condition on @xmath0 belongs to @xmath721 .",
    "for the sake of simplicity , the discussion will be limited to domains each involving one single variable . in this case , ordering amounts to the following : @xmath736 if @xmath737 , where @xmath738 is the comparison on the _ precision _ of abstract domains , meaning that @xmath739 is _ more precise _ than @xmath740 .",
    "[ ex : agreement ] let @xmath741 and @xmath742 be two states .",
    "then , they agree on @xmath743 } , { [ \\langle \\mbox{\\xx}\\rangle{::}\\nulldom ] } \\}$ ] since    * has the same parity in both states ; * is @xmath744 ( therefore , it has `` the same nullity '' ) in both states ; and * there is no condition on .    on the other hand , these states do not agree on @xmath745 } , { [ \\langle      \\mbox{\\xx}\\rangle{::}\\nulldom ] } \\}$ ] because is odd in @xmath578 whereas it is even in @xmath579 .    in a triple @xmath746 ,",
    "the pre - condition @xmath721 is the weakest agreement on two states before a statement @xmath12 such that the agreement specified by the post - condition @xmath747 holds after the statement .",
    "predicates on states can be used , so that triples are , actually , 4-tuples which only take into account a subset of the states .",
    "formally , the 4-tuple ( or _ augmented triple _ ) @xmath748 ( where the @xmath749 predicate is often omitted ) holds if , for every @xmath578 and @xmath579 , @xmath750 the rules of the are shown in figure [ fig : grules ] .",
    "the _ transformed predicate _",
    "@xmath751 is one which is guaranteed to hold after a statement @xmath12 , given that @xmath714 holds before , in the style of _ strongest post - condition calculus _ @xcite .",
    "for example , if @xmath752 , then the condition @xmath753 certainly holds after @xmath754 .",
    "the way predicates are transformed is outside the scope of this paper ; however , the cited works introduced calculi for computing such strongest post - conditions . in the absence of such tools , @xmath749 is always a consistent choice ( precision , but not soundness , may be affected since the set of states to be considered grows larger , and to prove useful results could become harder ) .",
    "the is tightly related to narrow non - interference @xcite .",
    "these works define a similar system of rules , the @xmath755-rules , for assertions @xmath756s\\left(\\eta'\\right)}$ ] , where @xmath193 and @xmath757 are basically the ( tuples of ) abstract domains corresponding to , resp . ,",
    "@xmath721 and @xmath747 .",
    "the systems differ in that :    * the use of pointers requires the rules for assignment to account for sharing , while @xmath755-rules only work on integers ; * in the present approach , domains are supposed to be partitioning , so that there is no need to include explicitly the @xmath200 operator ( section [ sect : partit ] ) ; * the  does not distinguish between _ public _ and _ private _ since this notion is not relevant in slicing ; * the rule for conditional is not included in the @xmath755-system ; indeed , this is quite a tricky rule , and , in general , expressing a conditional with loops and using the rule @xmath758 for loops results in inferring less precise assertions ; * in the @xmath755-system , predicates @xmath714 on program states are not supported .    in the following ,",
    "each rule of the is discussed .",
    "importantly , this rule system relies on the computation of _ property preservation_. we rely on a rule system which soundly computes whether executing a statement affects properties of some variables : the judgment    @xmath759    can only obtained by using those rules if it is possible to prove that executing @xmath12 in a state @xmath50 satisfying the condition @xmath714 results in a final state @xmath760 that is equal to the initial @xmath50 with respect to the agreement @xmath721 , i.e. , @xmath761 .",
    "in other word , the statement is equivalent to @xmath19 with respect to the properties of interest . note that , here , the agreement is not used to compare two states at the same program point ; rather , it takes as input the states before and after executing a statement .",
    "the rule system for proving property preservation is explained after introducing the ( section [ sec : thepsystem ] ) .",
    "@xmath762 @xmath763 @xmath764 @xmath765 @xmath766,\\state_2[y.f \\leftarrow              { \\left\\llbracket e \\right\\rrbracket}(\\state_2 ) ] ) \\\\            ( { * } { * } ) & \\forall y \\in { \\textsc{sh}\\left(x\\right)}. &            \\forall \\bar{g } , \\forall            \\state_1 \\models \\pred,\\state_2 \\models            \\pred .",
    "\\\\            & & ~~\\agreem(\\state_1,\\state_2 )            \\rightarrow \\\\            & & ~~\\agreem'(\\state_1[y.\\bar{g } \\leftarrow              { \\left\\llbracket e \\right\\rrbracket}(\\state_1)],\\state_2[y.\\bar{g } \\leftarrow              { \\left\\llbracket e \\right\\rrbracket}(\\state_2 ) ] ) \\\\            ( { * } { * } { * } ) & \\forall y \\notin { \\textsc{dal}\\left(x\\right)}. & \\agreem(y )            \\sqsubseteq \\agreem'(y )          \\end{array }        } {          { \\left\\{\\agreem\\right\\}^{\\pred}\\ x.f\\mbox{{\\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}}e\\ \\left\\{\\agreem'\\right\\ } }        } \\ { \\textsc{g - fassign}}}\\ ] ] @xmath767 @xmath768",
    "@xmath769      this rule makes the relation between property preservation and the more clear .",
    "the triple @xmath771 amounts to say that two executions agree _ after _",
    "@xmath12 , provided they agree _ before _ on the same @xmath721 . on the other hand , the preservation of @xmath721 on @xmath12 means that any state _ before _",
    "@xmath12 agrees on @xmath721 with the corresponding state _ after _",
    "property preservation is a stronger requirement than the mere propagation @xmath771 of agreements , so that this rule is sound .",
    "in fact , if @xmath725 and both @xmath772 and @xmath773 hold , then @xmath774 follows , which is , equivalent , by definition , to @xmath771 .    let the parity of @xmath0 be the property of interest . in this case , x  @xmath775  x+1 does not preserve the parity of @xmath0 , but two initial states agreeing on @xmath776}$ ] lead to final states which still agree on it .",
    "therefore , @xmath777}\\right\\}\\ \\mbox{{x\\ { \\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}\\ x+1}}\\ \\left\\{{[x{::}\\pardom]}\\right\\}}$ ] holds . on the other hand",
    ", x  @xmath775  x+2 also satisfies a stronger requirement : that @xmath778 does not change .",
    "therefore , besides having @xmath777}\\right\\}\\ \\mbox{{x\\ { \\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}\\ x+2}}\\ \\left\\{{[x{::}\\pardom]}\\right\\}}$ ] , the judgment @xmath779},\\mbox{{x\\ { \\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}\\ x+2}}\\right)}$ ] is also true .",
    "the @xmath780 rule describes _ no - op_. the assertion holds for every @xmath721 and @xmath714 since @xmath783 .",
    "@xmath781 is also easy : soundness holds by transitivity ( note also the use of @xmath751 to propagate conditions of states ) .",
    "rule @xmath16 can be used when nothing else can be proved : it always holds because execution is deterministic , so that two execution starting from two states which are equal .",
    "] on all variables will end in a pair of states agreeing on any abstraction .",
    "note that , as pointed out in section [ sec : theprogramminglanguage ] , @xmath23 statements are supposed only to appear at the beginning of a program ; therefore ,    finally , in @xmath782 , remember that @xmath311 is the partial order on agreements .",
    "this rule means that , given a statement @xmath785 , any agreement @xmath721 which satisfies the two conditions of the above part of the rule is a sound pre - condition for the post - condition @xmath747 .",
    "the conditions are ( 1 ) that , given two states which agree on @xmath721 , the computed results for the expression @xmath580 in both states are abstracted by @xmath786 to the same abstract value ; and ( 2 ) that @xmath721 is as precise as @xmath747 on all variables but @xmath0 . the first condition is represented in terms of definition [ def : atomicabstractdependencies ] , and the superscript @xmath714 indicates that only states satisfying @xmath714 have to be considered . such a condition can be easily shown to imply the formula @xmath787 note that , by proposition  [ theorem : equivalenza ] , the absence of abstract dependencies w.r.t",
    ".  definition [ def : atomicabstractdependencies ] ( _ atom - dep _ ) implies the absence of abstract dependencies w.r.t .",
    "definition [ def : abstractdependencies ] ( _ ndep _ ) which , in turn , implies @xmath788 .",
    "this clarifies the relation between abstract dependencies and the computation of a slice .",
    "obviously , the second condition guarantees that , for all variables which are not updated by the assignment , the agreement required by @xmath721 still holds when @xmath747 is considered .",
    "this rule accounts for the modification of the data structure pointed to by a variable by means of a field update . in the following ,",
    "that a variable is _ affected _ means that the data structure pointed to by it is updated . given a field update on a variable @xmath0 ,",
    "some other variables ( i.e. , the data structures pointed to by them ) could be affected .",
    "there exists a well - known static analysis which tries to detect which variables point to a data structure which is updated by a field update on @xmath0 : this analysis is known as _ sharing analysis _",
    "@xcite , and usually comes as _ possible - sharing _",
    "analysis , where the set of variables which _ could _ be affected by a field update is over - approximated . moreover , _ aliasing analysis _",
    "@xcite can be used in order to compute the set of variables pointing exactly ( and directly ) to the same location as @xmath0 ; in this case , _ definite - aliasing _ analysis makes sense , which under - approximates the set of variables which _ certainly _ alias with @xmath0 . according to the result of these analyses ,",
    "reference variables can be partitioned in three categories : ( 1 ) variables which certainly alias with @xmath0 , so that they can be guaranteed to be updated in their field @xmath47 ; ( 2 ) variables which could share with @xmath0 , so that they could be affected by the update in many ways ; and ( 3 ) variables which certainly do not share with @xmath0 , so that they are unaffected by the update .",
    "let @xmath790 be the set of variables possibly sharing with @xmath0 before the update , and @xmath791 be the set of variables definitely aliasing with @xmath0 . in the absence of a definite - aliasing analysis ,",
    "then @xmath791 can be safely taken as @xmath792 .",
    "[ ex : sharingflavours ] consider the following code fragment :    _ _    ....     if ( ... ) then { y.f : = x ; } else { y.f : = z ; }     w : = x ;     x.g : = $ e$ ;     ....    suppose that , initially , no variable is sharing with any other variable ( i.e. , there is no overlapping between data structures referred by different variables ) , and that the truth value of the boolean guard can not be determined statically , so that both branches of the conditional statement have to be considered as possible executions . in this case , the sharing and aliasing information before line 12 is as follows : @xmath793 note that every variable is aliasing with itself ( none of them is @xmath744 ) , is certainly aliasing with because of line 11 , and is possibly sharing with ( the actual sharing depends on the value of the guard ) .",
    "the @xmath789 rule comes with three pre - conditions .",
    "pre - condition @xmath794 only applies to variables in category ( 1 ) : those definitely aliasing with @xmath0 .",
    "pre - condition @xmath795 applies to category ( 2 ) , while pre - condition @xmath796 applies to categories ( 2 ) and ( 3 ) .",
    "* @xmath794 requires that updating the field @xmath47 of the location pointed to by @xmath0 ( and all variables definitely aliasing with it ) leads to an agreement on @xmath747 , provided that the initial states agree on @xmath721 .",
    "* @xmath795 is similar , but states that the agreements must hold for _ every _ sequence of field selectors @xmath797 ( starting with a dot is intentional ) will be used to represents sequences of field selectors .",
    "] , possibly the empty sequence .",
    "this is needed since , given that some @xmath161 may share with @xmath0 , it can not be known which fields of @xmath161 will be updated , and how . in practice , only the sequences of field selectors which are compatible with the class hierarchy of the program under study have to be considered , as shown in example [ ex : unfeasiblefieldsequences ] . *",
    "@xmath796 applies to variables that could be unaffected by the update , i.e. , variables in categories ( 2 ) and ( 3 ) ( note that the conditions @xmath798 in @xmath795 and @xmath799 in @xmath796 are not mutually exclusive , so that variables in category ( 2 ) satisfy both ) . the relation between @xmath721 and @xmath747 is clear in this case , as agreement on @xmath721 must entail agreement on @xmath747 .",
    "[ ex : unfeasiblefieldsequences ] in a java - like language , a sequence like @xmath800 is not compatible with the following class hierarchy since the class of @xmath801 is @xmath802 whereas @xmath803 is declared in @xmath557 :    ....     class c { d f ; d g ; }         class d { d h ; }       ....    [ ex : fassignnullity ] consider the statement @xmath804 .",
    "let @xmath805 and the agreement @xmath747 after @xmath12 be @xmath806 } , { [ \\mbox{\\zz}{::}\\nulldom ] } \\}$ ] .",
    "let also @xmath807 before @xmath12 be @xmath808 . in this case ,",
    "an agreement @xmath721 which satisfies the judgment @xmath809 can be the same @xmath810 } , { [ \\mbox{\\zz}{::}\\nulldom ] } \\}$ ] because    * is unaffected by the update ( it belongs to category ( 3 ) ) , so that @xmath811 must be at least as precise as @xmath812 ; * category ( 2 ) contains no variables ; and * category ( 1 ) only includes itself , and the nullity of is clearly unaffected by the update .",
    "one may think that the universal quantification on field sequences in pre - condition @xmath795 results in an unacceptable loss of precision . indeed ,",
    "to require that all possible updates to possibly - sharing variables preserve the desired agreements seems to be too strict .",
    "however , there are a number of things to be considered :    * a closer look to the rule shows that there is no easier way to account for sharing if traditional sharing analysis is used .",
    "* example [ ex : fassignnullity ] shows that it is still possible to get meaningful results on domains working on pointer variables . *",
    "the state of the art in static analysis of object - oriented languages indicates that abstract domains on pointers are likely to be quite simple ( @xmath144 being one of them ) .",
    "* there is recent work @xcite introducing a more precise , _ field - sensitive _ sharing analysis which computes _ how _ variables share : this analysis is able to detect which _ fields _ are or are not involved in paths in the heap converging from two variables to a shared location . in order to keep the discussion as simple as possible , the definition of @xmath789 given in figure [ fig : grules ] uses traditional sharing analysis .",
    "however , the impact of field - sensitive sharing analysis is discussed in section [ sec : practicalissuesandoptimizations ] , where a refined version of @xmath789 is given .",
    "the domain of cyclicity introduced in section [ ex : referenceabstractdomains ] represents information about _ data structures _ in the heap , not only program variables . in this sense ,",
    "field updates have to be regarded as potentially affecting the propagation of agreements .",
    "[ ex : cyclicitydomain ] let @xmath12 be , again , the statement @xmath813 , and @xmath747 be @xmath814 }    \\}$ ] ; i.e. , the interest is on the cyclicity of the data structure pointed to by @xmath0 after executing @xmath12 .",
    "suppose also that @xmath0 and @xmath161 are certainly not sharing before @xmath12 , and that an object whose type is compatible with @xmath0 has two reference fields @xmath47 and @xmath815 .",
    "then , the agreement @xmath816},{[y{::}\\cycledom ] } \\}$ ] is _ not _ a correct precondition for the hoare tuple to hold , since there can be two states @xmath578 and @xmath579 ( figure [ fig : cyclicity ] ) such that    * the data structure corresponding to @xmath161 is acyclic , and equal in both states ( therefore , there is an agreement on the cyclicity of @xmath161 ) ; * the data structure corresponding to @xmath0 is cyclic in both @xmath578 and @xmath579 , but ( a ) in @xmath578 there is only a cycle originating from the location bound to @xmath817 ; and ( b ) in @xmath579 there is a cycle originating from @xmath817 and another one originating from @xmath818 .    in this case",
    ", @xmath725 holds but the resulting final states @xmath819 and @xmath820 do _ not _ agree on @xmath747 since @xmath0 is acyclic in @xmath819 ( the only cycle has been broken ) while it is still cyclic in @xmath820 .",
    "this behavior is captured by @xmath789 because condition @xmath794 applied to @xmath0 itself ( which , by hypothesis , is the only variable in @xmath791 ) does not hold , so that the augmented triple can not be proven . on the other hand , @xmath821},{[y{::}\\cycledom ] } \\}$ ] would be a correct precondition .",
    "( yv1 ) at ( -2,-0.2 ) @xmath161 ; ( y1 ) at ( -2,-1 ) ; ( yv1 )  ( y1 ) ; ( xv1 ) at ( 0,-0.2 ) @xmath0 ; ( x1 ) at ( 0,-1 ) ; ( xf1 ) at ( -0.5,-2 ) ; ( xg1 ) at ( 0.5,-2 ) ; ( xv1 )  ( x1 ) ; ( x1 )  node[left ] @xmath47 ( xf1 ) ; ( x1 ) ",
    "node[right ] @xmath815 ( xg1 ) ; ( xf1 ) .. controls ( -1.5,-3.5 ) and ( 0.5,-3.5 ) .. ( xf1 ) ; at ( -1.35,-2.7 ) _ _ ; ( -2.5,0 ) rectangle ( 1,-3.3 ) ; at ( 1.3,-3.1 ) @xmath578 ;    ( 1.3,-1.65 ) ",
    "node[above ] @xmath813 ( 4.3,-1.65 ) ;    ( pyv1 ) at ( 5,-0.2 ) @xmath161 ; ( py1 ) at ( 5,-1 ) ; ( pyv1 )  ( py1 ) ; ( pxv1 ) at ( 7,-0.2 ) @xmath0 ; ( px1 ) at ( 7,-1 ) ; ( pxg1 ) at ( 7.5,-2 ) ; ( pxv1 )  ( px1 ) ; ( px1 ) ",
    "node[above ] @xmath47 ( py1 ) ; ( px1 ) ",
    "node[right ] @xmath815 ( pxg1 ) ; ( 4.5,0 ) rectangle ( 8,-3.3 ) ; at ( 8.3,-3.1 ) @xmath819 ;    ( yv1 ) at ( -2,-0.2 ) @xmath161 ; ( y1 ) at ( -2,-1 ) ; ( yv1 )  ( y1 ) ; ( xv1 ) at ( 0,-0.2 ) @xmath0 ; ( x1 ) at ( 0,-1 ) ; ( xf1 ) at ( -0.5,-2 ) ; ( xg1 ) at ( 0.5,-2 ) ; ( xv1 )  ( x1 ) ; ( x1 )  node[left ] @xmath47 ( xf1 ) ; ( x1 ) ",
    "node[right ] @xmath815 ( xg1 ) ; ( xf1 ) .. controls ( -1.5,-3.5 ) and ( 0.5,-3.5 ) .. ( xf1 ) ; ( xg1 ) .. controls ( -0.5,-3.5 ) and ( 1.5,-3.5 ) .. ( xg1 ) ; at ( -1.4,-2.7 ) _ _ ; ( -2.5,0 ) rectangle ( 1,-3.3 ) ; at ( 1.3,-3.1 ) @xmath579 ;    ( 1.3,-1.65 ) ",
    "node[above ] @xmath813 ( 4.3,-1.65 ) ;    ( pyv1 ) at ( 5,-0.2 ) @xmath161 ; ( py1 ) at ( 5,-1 ) ; ( pyv1 )  ( py1 ) ; ( pxv1 ) at ( 7,-0.2 ) @xmath0 ; ( px1 ) at ( 7,-1 ) ; ( pxg1 ) at ( 7.5,-2 ) ; ( pxv1 )  ( px1 ) ; ( px1 ) ",
    "node[above ] @xmath47 ( py1 ) ; ( px1 ) ",
    "node[right ] @xmath815 ( pxg1 ) ; ( pxg1 ) .. controls ( 6.5,-3.5 ) and ( 8.5,-3.5 ) .. ( pxg1 ) ; ( 4.5,0 ) rectangle ( 8,-3.3 ) ; at ( 8.3,-3.1 ) @xmath820 ;      in a conditional @xmath824 @xmath825 @xmath826 @xmath827 there are two possibilities .",
    "rule @xmath822 states that an input agreement which induces the output one whichever path is taken is a sound precondition . here",
    ", the assertion @xmath828 means that @xmath829 where the judgment @xmath830 means that all four states agree on @xmath747 .",
    "this rule requires @xmath747 to hold on the output state independently from the value of @xmath210 .",
    "soundness is easy ( note that the above assertion implies @xmath831 and @xmath832 ) .",
    "note that such a @xmath721 can always be found ( in the worst case , it assigns the identity upper closure operator @xmath107 to each variable , so that two states agree only if they are exactly equal ) .",
    "however , sometimes it can be more convenient to exploit information about @xmath210 . in such cases ,",
    "@xmath823 can be applied , which means that the initial agreement @xmath833 is strong enough to verify the final one , provided the same branch is taken in both executions , as @xmath834 requires .",
    "in fact , @xmath834 is built from @xmath210 , and separates states according to its value : @xmath835 the rule means that , whenever two states agree on the branch to be executed , and the triples on both branches hold , the whole triple holds as well .",
    "[ lemma : aifppsoundness ] if @xmath578 and @xmath579 both satisfy @xmath714 and agree on @xmath836 , then the corresponding output states @xmath819 and @xmath820 agree on @xmath747 under the hypotheses of the rule .    by hypothesis ,",
    "the same branch is taken in both cases .",
    "conditions @xmath837 and @xmath838 are consistent since @xmath825 ( respectively , @xmath827 ) can only be executed when @xmath210 is true ( respectively , false ) .",
    "the agreement on @xmath721 holds in both paths , so that the entire assertion is correct .",
    "note that the rule to be chosen for the conditional depends on the precision of the outcome : @xmath823 can be a good choice if ( 1 ) it can be applied ; and ( 2 ) the result is `` better '' than the one obtained by @xmath822 . the second condition amounts to say that , given the same final agreement @xmath747 , the initial agreement obtained by using @xmath823 is weaker ( i.e. , it is more likely that two states agree on it ) than the one obtained by using @xmath822 .",
    "[ ex : ifrules ] consider the code fragment    ....     if ( x>0 ) { x:=x+1 ; } else { x:=x-1 ; }     ....    and let @xmath839 } \\}$ ] be the agreement after the statement , i.e. , the relevant property is the sign of .",
    "the rule @xmath823 is able to compute the same @xmath721 as the input agreement because    * the triple @xmath840 holds since the condition @xmath837 guarantees that is positive , and two states which agree on the sign before the increment will still agree after it ( if is positive in both states , then it will remain positive in both ) ; * similarly , the triple @xmath841 also holds ( if is 0 in both states , then it will be negative in both ; and if it is negative in both , it will remain negative in both ) ; * @xmath834 is less precise than @xmath721 ( i.e. , @xmath842 since the latter only separates numbers into positive and non - positive ) , so that the input agreement @xmath843 is equal to @xmath721 .    on the other hand , @xmath822 is not able to compute the same input agreement because the precondition @xmath844 of the rule does not hold .",
    "in fact , consider two states @xmath845 and @xmath846 : they agree on the sign of , but @xmath847 and @xmath848 have different sign ( the first is zero while the second is positive ) .",
    "the meaning of the rule for loops can be understood by discussing its soundness : if @xmath714 is preserved after any iteration of the body , and the agreement which is preserved by the body guarantees the same number of iterations in both executions ( i.e. , it is more precise than @xmath834 ) , then such an agreement is preserved through the entire loop .",
    "[ lemma : awhilesoundness ] let @xmath850 and @xmath851 satisfy @xmath714 , and agree on @xmath852 .",
    "then , given @xmath853 , the result @xmath854 holds .",
    "let @xmath855 .",
    "there are two cases :    * @xmath856 : in this case , the body is not executed , and the result holds trivially ; * @xmath857 : in this case , @xmath858 . by the hypothesis of the rule",
    ", @xmath859 and @xmath860 agree on @xmath852 , and @xmath714 still holds since @xmath861 .    at every iteration ,",
    "the hypotheses hold",
    ". moreover @xmath834 guarantees the same number of iterations in both executions .",
    "consequently , for a terminating loop ( non - termination is not considered ) , @xmath862 and @xmath863 will fall in the first case ( false guard ) after the same number @xmath40 of iterations .",
    "these states are exactly @xmath819 and @xmath820 , and agree on @xmath852 after the loop .",
    "[ theorem : asoundness ] let @xmath12 be a statement , @xmath747 be required after @xmath12 , @xmath714 be a predicate and @xmath864 be the program point before @xmath12 .",
    "let also @xmath721 be an agreement computed before @xmath12 by means of the .",
    "let @xmath865 and @xmath866 be two trajectories , and the states @xmath867 $ ] and @xmath868 $ ] satisfy @xmath725 and @xmath714 .",
    "then , the condition @xmath869 holds , where @xmath870 .",
    "easy from lemmas [ lemma : aifppsoundness ] and [ lemma : awhilesoundness ] , and the discussion explaining each rule ( especially , @xmath789 ) .",
    "@xmath871 @xmath872 @xmath873 ) \\\\",
    "( { * } { * } ) & \\forall y \\in { \\textsc{sh}\\left(x\\right)}. &             \\forall \\bar{g } , \\forall             \\state \\models \\pred.~\\agreem(\\state,\\state[y.\\bar{g }               \\leftarrow { \\left\\llbracket e \\right\\rrbracket}(\\state ) ] )         \\end{array}}{{\\textsc{pp}^{\\pred}\\left(\\agreem , x.f\\mbox{{\\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}}e\\right)}}\\ { \\textsc{pp - fassign}}}\\ ] ] @xmath874 @xmath875    property preservation can be proved by means of a rule system , the ( figure [ fig : thepsystem ] ) .",
    "most rules are straightforward or very similar to rules , and characterize when executing a certain statement preserves the properties represented by an agreement @xmath721 ( i.e. , for every variable @xmath0 , the property / uco @xmath734 is preserved ) .",
    "for example , rule @xmath876 allows proving that a certain agreement is preserved when the initial value of @xmath0 can not be distinguished from the value of the expression ( i.e. , the new value of @xmath0 ) , when it comes to the property @xmath734 . in rule @xmath877 , a mechanism similar to @xmath789 is used : definite aliasing and possible sharing can be used to identify which variables are affected by the field update . as for @xmath789 , an optimization based on field - sensitive sharing analysis ( section [ sec : useoffieldsensitivesharing ] ) can be introduced , which makes it easier to prove property preservation on field updates .",
    "indeed , a number of optimizations can be applied to the ( for example , one could think that property preservation on @xmath878 does not require the preservation of the same properties on both statements separately ) . however , this rule system is not the central part of this paper , and figure [ fig : thepsystem ] is just a sensible way to infer property preservation .",
    "this approach to compute abstract slices follows the standard conditioned , non - iteration - count form of backward slicing .",
    "therefore , a slicing criterion @xmath272 takes the form @xmath879 where @xmath2 is the last program point , and @xmath288 is a sequence of ucos assigning a property to each variable in @xmath251 .",
    "the initial agreement can be easily computed from the criterion and is such that @xmath880}~|~x\\in \\cx \\}$ ] , where @xmath881 is the element of @xmath288 corresponding to @xmath0 .",
    "this shows that there is a close relation between this specific kind of slicing criteria and agreements , and in the following , these concepts will be used somehow interchangeably in informal parts .",
    "it will be shown that this makes sense , i.e. , criteria and agreements define tightly related notions .",
    "next definition defines the correctness of an abstract slice of this kind , where the slicing criterion is intentionally confused with an agreement .",
    "[ def : abstractslicingcondition ] let @xmath882 be the slice of @xmath3 with respect to an agreement ( criterion ) @xmath721 .",
    "in order for @xmath882 to be correct , @xmath883 and @xmath884 must agree on @xmath721 for every initial @xmath50 : @xmath885 .",
    "the main purpose of the is to propagate a final agreement backwards through the program code , in order to have a specific agreement attached to each statement .",
    "this is done as follows : a program can be seen as a sequence @xmath886 of @xmath887 statements , where each @xmath888 can be either a simple statement ( skip , assignment , field update ) or a compound one ( conditional or loop ) , containing one ( the loop body ) or two ( the branches of the conditional ) sequences of statements ( either simple or compound , recursively ) . the way to derive an agreement for every statement in the program",
    "is depicted in the pseudocode of figure [ fig : agreementpropagation ] .",
    "the procedure @xmath17 takes as input    1 .   a sequence of statements ( in the first call , it is the whole program code statements ( remember that @xmath23 statements are basically meant to provide the input ) . ] ; 2 .",
    "a pair of agreements : ( 2.a ) the first one , @xmath889 , refers to the beginning of the sequence , and , in the first call , is such that the abstraction on each variable is @xmath107 ; and ( 2.b ) the second one , @xmath890 , is the desired final agreement , which corresponds to the slicing criterion as discussed in section [ section : agreementsandslicingcriteria ] ; and 3 .   a predicate on states which is supposed to hold at the beginning of the sequence .",
    "@xmath17 goes backward through the program code inferring , for each @xmath888 , an agreement @xmath891 which corresponds to the program point _ after _ @xmath888 .",
    "@xmath892 will be the same @xmath890 , whereas , for each @xmath54 , @xmath893 will be inferred by using the : more specifically , it is a ( ideally , the best ) precondition such that the tuple @xmath894 holds .",
    "note that , since the initial @xmath895 is the identity on all variables , @xmath896 trivially holds for every @xmath54 ( execution is deterministic ) ; however , the @xmath889 argument plays an important role when dealing with loop statements .",
    "importantly , statements inside compound statements ( e.g. , assignments contained in the branch of a conditional ) are also labeled with agreements .",
    "this is done by calling @xmath17 recursively .",
    "note that , in this case , if @xmath897 and @xmath898 are . respectively , the sequences corresponding to the `` then '' and `` else '' branch of a conditional statement @xmath899 , then @xmath17 is called with second argument @xmath900 ; this is so because the state does not change when control goes from the end of a branch to the statement immediately after @xmath899 .",
    "the treatment of loops follows closely the definition of @xmath849 . in the augmented triple",
    ", @xmath893 appears before and after the statement ; this is consistent with the rule .",
    "the condition @xmath901 guarantees that the @xmath894 can be proven by applying @xmath902 . moreover , the recursive call on the body @xmath903 has @xmath904 as its second argument .",
    "procedure labelsequence(`@xmath905 ' , @xmath906 , @xmath714 ) @xmath895 = @xmath889 ; @xmath892 = @xmath890 ; every @xmath907 is @xmath908 where @xmath909 ; // ( remember the transformed predicate @xmath751 ) for @xmath54 = @xmath40 downto @xmath910",
    "if ( @xmath888 is a conditional ) let @xmath210 be the guard ; let @xmath897 and @xmath898 be its branches ; call labelsequence(@xmath897 , @xmath911 , @xmath912 ) ; call labelsequence(@xmath898 , @xmath911 , @xmath913 ) ; @xmath893 is such that @xmath894 ; else if ( @xmath888 is a loop ) @xmath893 is an agreement such that - @xmath901 // ( see rule @xmath849 ) - @xmath914 let @xmath210 be the guard ; let @xmath903 be the loop body ; call labelsequence(@xmath903 , @xmath904 , @xmath912 ) ; else //",
    "non - compound statement @xmath893 is such that @xmath894 ;    now , suppose that the judgment @xmath915 can be proved , where @xmath916 and @xmath917 are computed by @xmath17 , and @xmath714 refers to the program point before @xmath12 . in this case ,",
    "let @xmath918 be the program @xmath3 where @xmath12 has been replaced by @xmath919 , and @xmath50 be an initial state .",
    "then , the following holds : @xmath883 agrees with @xmath920 with respect to @xmath890 , provided that executions terminate ( non - termination is not considered ) .",
    "[ prop : soundnesspreservation ] given a statement @xmath12 in @xmath3 such that @xmath915 , the output states obtained by executing both @xmath3 and @xmath918 on some @xmath50 agree on the agreement @xmath890 corresponding to the desired slicing criterion if the execution terminates .",
    "let @xmath62 and @xmath921 be two trajectories coming from executing , respectively , @xmath3 and @xmath918 from the initial state @xmath50 .",
    "let @xmath922 $ ] and @xmath923 $ ] be the states of @xmath62 and @xmath921 , respectively , when control reaches the program point before @xmath12 ( or @xmath19 , in the case of @xmath918 ) for the @xmath924-th time , and @xmath925 $ ] and @xmath926 $ ] be their corresponding states after @xmath12 ( or @xmath19 ) .",
    "if @xmath12 is not contained in any loop , then @xmath924 can only be @xmath910 , and the proof is trivial .",
    "otherwise , it can be any number up to some @xmath927 ( a non - negative number ) .    if @xmath928 , then the loop is never executed on the input @xmath50 , and the proof follows trivially .    otherwise , @xmath929 $ ] and @xmath930 $ ] are identical because both executions went exactly through the same statements ; as a consequence , they certainly agree on @xmath916 . on the other hand , @xmath931 $ ] and @xmath932 $ ] are in general not identical , but they still agree on @xmath916 :",
    "in fact , the following holds : @xmath933,\\state'_{in}[1 ] ) & \\mbox{(they are        identical ) } \\\\      ( 2 ) & \\agreem_s(\\state'_{in}[1],\\state'_{out}[1 ] ) &      \\mbox{(semantics of { \\ensuremath{\\mbox{\\lstinline!skip!}\\xspace}\\xspace } ) }      \\\\ ( 3 ) & \\agreem_s(\\state_{in}[1],\\state_{out}[1 ] ) & \\mbox{(property        preservation ) } \\\\ ( 4 ) &      \\agreem_s(\\state_{out}[1],\\state'_{out}[1 ] ) &      \\mbox{(transitivity applied to ( 1 ) , ( 2 ) and ( 3 ) ) }    \\end{array}\\ ] ] due to how the program is labeled with agreements , @xmath934,\\state'_{out}[1])$ ] implies an agreement of both executions at the end of the loop body with respect to the agreement @xmath935 labeling that program point .",
    "this also means that both executions will still agree on @xmath935 at the beginning of the next iteration , and ( again , by construction ) they will also agree on @xmath916 when @xmath12 is reached for the second time .",
    "this mechanism can be repeated until @xmath927 is reached , and it is easy to realize that the agreement on @xmath916 at the last iteration implies the final agreement on @xmath890 ( see figure [ fig : soundnesspreservation ] ) .",
    "the crux of this reasoning is that , by construction , the agreements labeling each program point imply that , when a statement can be removed from the loop body , this means that the original program and the slice will execute the loop body the same number of times . in general , this does not mean that every loop will be executed the same number of times ( some property - preserving loops could be even sliced out completely ) .",
    "( pi ) at ( 0,0 ) @xmath62 ; ( pip ) at ( 4,0 ) @xmath921 ; ( lb ) at ( -5.5,-3 ) body of loop @xmath888 ; ( -3.5,-1 )  ( -3.7,-1 )  ( -3.7,-5 )  ( -3.5,-5 ) ; ( begin ) at ( 0,-1 ) @xmath936 ; ( beginp ) at ( 4,-1 ) @xmath936 ;    ( pi )  ( begin ) ; ( pip )  ( beginp ) ;    ( begin ) ",
    "node[above ] @xmath107 ( first time ) , @xmath893 ( beginp ) ;    ( end ) at ( 0,-5 ) @xmath936 ; ( endp ) at ( 4,-5 ) @xmath936 ;    ( s0 ) at ( 0,-2.7 ) ; ( s ) at ( 0,-3 ) s ; ( s1 ) at ( 0,-3.3 ) ; ( begin )  ( s0 ) ; ( s1 )  ( end ) ;    ( skip0 ) at ( 4,-2.7 ) ; ( skip ) at ( 4,-3 ) @xmath19 ; ( skip1 ) at ( 4,-3.3 ) ; ( beginp )  ( skip0 ) ; ( skip1 )  ( endp ) ;    ( s0 ) ",
    "node[above ] @xmath916 ( skip0 ) ; ( s1 ) ",
    "node[below ] @xmath916 ( skip1 ) ; ( end ) ",
    "node[above ] @xmath893 ( endp ) ;    ( s0 ) .. controls ( -0.7,-2.5 ) and ( -0.7,-3.5 ) .. node[left ] @xmath916 ( s1 ) ; ( skip0 ) .. controls ( 4.7,-2.5 ) and ( 4.7,-3.5 ) .. node[right ] @xmath107 , @xmath916 ( skip1 ) ;    ( end ) .. controls ( -2.8,-4.5 ) and ( -2.8,-1.5 ) .. ( begin ) ; ( endp ) .. controls ( 6.8,-4.5 ) and ( 6.8,-1.5 ) .. ( beginp ) ;    this proposition can be used in order to remove all statements for which such a property - preservation judgment can be proved . in general , the slice is computed by replacing all statements @xmath12 such that @xmath937 holds by @xmath919 , or , equivalently removing all of them from the original code . it is easy to observe that this corresponds exactly to the notion of backward abstract slicing given in section [ section : abstractprogramslicing ] .",
    "[ ex : conditionstoslice ] consider the following code , and let the final nullity of be the property of interest ( corresponding to the agreement @xmath938 } \\}$ ] after line 15 ) :    _ _    ....     ...     n : = n*2 ;        // $ \\ { \\agrs{\\zerodom}{n } \\}$     c x : = new c ( ) ; //",
    "$ \\ { \\agrs{\\zerodom}{n } \\}$     if ( n=0 ) {       //",
    "$ \\{\\}$ ( final result on this branch always null )       x : = null ;     //",
    "$ \\ { \\agrs{\\nulldom}{x } \\}$     } else {         //",
    "$ \\{\\}$ ( final result on this branch never null )       x : = new c ( ) ; //",
    "{ \\agrs{\\nulldom}{x } \\}$     }                //",
    "$ \\ { \\agrs{\\nulldom}{x } \\}$         ....",
    "each agreement on the right - hand side is the label after the statement at the same line .",
    "both lines @xmath939 and @xmath940 can be removed from the slice because :    * the final nullity of only depends on the equality of to @xmath283 before line 11 , which is captured by the @xmath941 domain ; * line 10 does not affect ; and * multiplying a number by 2 preserves the property of being equal to @xmath283 .    note",
    "that , although agreements after lines 11 and 13 are both empty ( no matters how the state is @xmath0 will be null after line 12 and non - null after line 14 ) , the one after line 10 is not because of rule @xmath823 .",
    "consider again the code of example [ ex : abstractslicing ] .",
    "starting from the final agreement @xmath942 }    \\}$ ] , the code is annotated as follows :    _ _    ....                          //",
    "$ \\{\\agrs{\\cycledom}{list}\\}$     y : = null ;            //",
    "$ \\{\\agrs{\\cycledom}{list}\\}$     x : = list ;            // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$     while ( pos>0 ) {       // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$",
    "y : = x ;             //",
    "$ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$       x : = x.next ;        // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$       pos : = pos-1 ;     }                     // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$     z : = new node(elem ) ; // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{x}\\}$     z.next : = x ;          // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{z},\\agrs{\\cycledom}{x}\\}$     if ( y = null ) {       // $ \\{\\agrs{\\cycledom}{z},\\agrs{\\cycledom}{x}\\}$       list : = z ;          // $ \\{\\agrs{\\cycledom}{list}\\}$     } else {              // $ \\{\\agrs{\\cycledom}{list},\\agrs{\\cycledom}{z},\\agrs{\\cycledom}{x}\\}$       y.next = z ;         // $ \\{\\agrs{\\cycledom}{list}\\}$     }                     // $ \\{\\agrs{\\cycledom}{list}\\}$       ....    to prove the necessary tuples , it is important to note that @xmath943 is the only reference field selector in the class @xmath944 , so that any cycle has to traverse it .",
    "moreover , to prove that the cyclicity of @xmath286 after line 46 is equivalent to the cyclicity of @xmath286 and @xmath945 needs non trivial reasoning about data structures ; concretely , it is necessary to have some _ reachability analysis _ @xcite and @xmath945 are sharing before line 46 . ] capable to detect that there is no path from @xmath718 to @xmath718 ( otherwise , a cycle could be created by @xmath946 ) .",
    "this information should be available as @xmath714 , and allows to say that @xmath718 and @xmath286 ( note that @xmath286 is affected because it is sharing with @xmath718 ) are cyclic after line 46 if and only if @xmath945 or @xmath717 or @xmath286 were before that line .",
    "the same happens at line 42 .",
    "moreover , the agreement does not change in the loop body at lines 3640 because ( 1 ) data structures are not modified ; ( 2 ) @xmath286 is not affected in any way ; and ( 3 ) the value of @xmath717 changes , but its cyclicity does not ( by executing @xmath947 , there is no way to make unreachable a cycle which was reachable before , or the other way around ) .",
    "importantly , this also means that the cyclicity of @xmath286 and @xmath717 is _ preserved _ by the loop , so that it can be safely removed from the slice ( the preserved property is the same as the agreement after line 40 ) .    on the other hand , the conditional statement at lines 4347 can not be removed directly because it is not possible to prove that the cyclicity of @xmath286 is preserved through it ( actually , it is not ) . in order to prove that the whole code between lines 34 and 47 preserves the cyclicity of @xmath286 , a kind of _",
    "case - based _ reasoning could be used : ( 1 ) the initially acyclicity of @xmath286 implies its final acyclicity ; and ( 2 ) the initially cyclicity of @xmath286 implies its final cyclicity .",
    "both these results can be proved by standard static - analysis techniques @xcite .",
    "needless to say , slices could be sub - optimal ( for example , the requirement about executing loops the same number of times needs not be satisfied by any correct slice ) .",
    "it is not difficult to see that , if a `` concrete '' slicing criterion would be considered instead of an abstract one , then agreements would only be allowed to contain conditions @xmath948}$ ] for a certain set of variables .",
    "the @xmath17 would work exactly the same way , with an important difference : when trying to compute the precondition of a tuple @xmath949 , the possible outcome could , again , contain only conditions @xmath948}$ ] .",
    "[ ex : conditionstoslice1 ] in example [ ex : conditionstoslice ] , suppose the final agreement be @xmath950 } \\}$ ] , corresponding to a concrete slicing criterion interested in ( the exact value of ) @xmath0 . in this case , the agreement after line 10 could only be @xmath951 } \\}$ ] , since ( 1 ) @xmath952 would not be correct , and ( 2 ) no other abstract domain can appear in agreements .",
    "this way , line 9 could not be sliced out since it does not preserve the @xmath107 property of @xmath2 .",
    "semantically , abstract slices are in general smaller than concrete slices .",
    "this is also the case of example [ ex : conditionstoslice1 ] .",
    "clearly , this does _ not _ imply that _ every _ abstract slicing algorithm would remove more statements than _ every _ concrete slicing algorithm .",
    "this section discusses how the analysis can realistically deal with the computation of abstract dependencies and the propagation of agreements , and an optimization based on recent work on sharing .",
    "one of the major challenges of the whole approach is how agreements are propagated backwards through the code as precisely as possible , i.e. , being able to detect that agreement on some ucos before @xmath12 implies agreement on ( possibly ) other ucos after @xmath12 .",
    "ideally , given @xmath12 , @xmath714 and @xmath747 , the should find the _",
    "@xmath721 such that @xmath748 .",
    "however , it is clearly unrealistic to imagine that the static analyzer will always be able to find the best ucos without going into severe scalability ( even decidability ) issues : in general , there exist infinite possible choices for an input agreement satisfying the augmented triple . in practice",
    ", an implementation of this slicing algorithm will be equipped with a library of ucos among which the satisfaction of augmented triples can be checked . the wider the library , the more precise the results .",
    "rule of the and the can be specialized with respect to the ucos at hand .",
    "[ ex : conditionstoslice2 ] consider this code already presented in example [ ex : conditionstoslice ] , where the slicing criterion is the final nullity of :    _ _    ....     ...     n : = n*2 ;     c x : = new c ( ) ;     if ( n=0 ) {       x : = null ;     } else {       x : = new c ( ) ;     }     ....    in order to be able to remove lines 9 and 10 from the slice , an analyzer has to `` know '' that , after merging the result of both branches , the uco @xmath941 precisely describes the agreement before line 11 . in other words ,",
    "the analyzer must know both @xmath941 and @xmath144 in order to be able to manipulate information about them .",
    "moreover , given a library of ucos , rules can be optimized for some recurrent programming patterns like guards ( @xmath953 ) or ( @xmath954 ) , or statements @xmath955 .",
    "it is clear that to design of an analyzer which is able to deal with all possible ucos is infeasible .",
    "however , the combination of some simple numeric or reference domains like the one described in this paper would already lead to meaningful results .      as already mentioned , _ field - sensitive sharing analysis _",
    "@xcite is able to keep track of fields which are involved in _ converging paths _ from two variables to a common location in the heap ( the _ shared _ location ) .",
    "propositional formula _ is attached to each pair of variables and each program point , and specifies the fields involved in _ every _ pair of converging paths reaching a common location .",
    "for example , if the formula @xmath956 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!f!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } \\wedge { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!g!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] is attached to a pair of variables @xmath957 at a certain program point @xmath2 ( written @xmath958 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!f!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } \\wedge { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!g!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] ) , this means that the analysis was able to detect that , for _ every _ two paths @xmath959 and @xmath960 in the heap starting from @xmath0 and @xmath161 , respectively , and both ending in the same ( shared ) location ,    * @xmath959 certainly does not traverse field @xmath803 , as dictated by @xmath956 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!f!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } $ ] ( arrows from top - left to bottom - right refer to paths from @xmath0 , i.e. , the first variable in the pair under study ) ; and * @xmath960 certainly traverses @xmath801 , as prescribed by @xmath961 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!g!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] ( arrows from top - right to bottom - left refer to paths from @xmath161 ) .    in presence of such an analysis , two kinds of improvements can be potentially obtained when analyzing a field update :    * the number of variables which can be actually affected by an update is , in general , reduced since it is possible to guarantee that some ( traditionally ) sharing variables will not be affected ; * even for variables which are ( still ) possibly sharing with @xmath0 , the set of field sequences @xmath797 to be considered can be substantially smaller .    [",
    "ex : fieldsensitivesharing ] suppose that field - sensitive sharing analysis is able to guarantee the following at a program point before the field update @xmath21 :    * the formula @xmath956 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!f!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } \\wedge      { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!g!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] correctly describes the sharing between and ; and * the formula @xmath961 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{\\mbox{{\\ensuremath{\\mbox{\\lstinline!h!}\\xspace}\\xspace } } } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] correctly describes the sharing between and .",
    "according to the traditional notion of sharing , both and may share with .",
    "however ,    * the assignment @xmath21 provably does _ not _ affect because no path from traversing @xmath803 will reach a location that is also reachable from ; and * when considering all the possible field sequences starting from , only those containing @xmath962 have to be considered .",
    "the rule g - fassign can be refined by using field - sensitive sharing , as follows .",
    "let @xmath2 be the program point before the field update .",
    "* in pre - condition @xmath795 , the only sharing variables that have to be dealt with are those for which it can not be proved that they are unaffected by the update ; this can be done by defining a new set @xmath963 of variables which are possibly sharing with @xmath0 in such a way that some path from @xmath0 to a shared location could traverse @xmath47 : @xmath964 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } \\right\\}\\ ] ] this means that @xmath161 is considered as potentially affected by the update when the propositional formula describing how it shares with @xmath0 does not entail that paths from @xmath0 to shared locations do not traverse @xmath47 . * in the same pre - condition @xmath795 , the universal quantification on field sequences can be restricted to those compatible with field - sensitive information .",
    "more formally , a field sequence @xmath965 has to be considered only if it is possible that a path from @xmath161 traversing exactly those fields ends in a shared location , or , equivalently , if the set @xmath966 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } , { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f_1 } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } , { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f_2 } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } , .. ,    { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f_n } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } \\}$ ] is a _ model _ of @xmath967 . that such a set is a model of @xmath967 is equivalent to say that the field - sensitive information is compatible with the existence of a pair of paths @xmath959 and @xmath960 such that ( 1 ) @xmath959 starts from @xmath0 ; ( 2 ) @xmath960 starts from @xmath161 ; ( 3 ) @xmath959 only traverses @xmath47 ; ( 4 ) @xmath960 traverses all and only the fields @xmath968 ; and ( 5 ) both paths end in the same shared location .",
    "let @xmath969 be the set of fields contained in the field sequence @xmath797 .",
    "then , the above condition can be written as @xmath970 where @xmath971 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{f } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } \\ }",
    "\\cup \\ {    { \\mbox { {     \\tikz[baseline=(tocancel.base ) ] {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{g } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } ~|~ g \\in { \\mathit{fields}(\\bar{g } ) } \\}$ ] , and @xmath972 means that @xmath973 is any proposition @xmath961 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{h } } ;          \\draw[- > ] ( $ ( tocancel)+(-5pt,5pt)$ ) -- ( $ ( tocancel)+(5pt,-5pt)$ ) ;      } } } } $ ] or @xmath961 {          \\node[inner sep=0pt , outer sep=0pt ] ( tocancel ) { \\ensuremath{h } } ;          \\draw[- > ] ( $ ( tocancel)+(5pt,5pt)$ ) -- ( $ ( tocancel)+(-5pt,-5pt)$ ) ;      } } } } $ ] ( for some field @xmath974 ) not included in @xmath593 .",
    "the refined g - fassign rule , called g - fassign2 , comes to be    @xmath975,\\state_2[y.f \\leftarrow        { \\left\\llbracket e \\right\\rrbracket}(\\state_2 ) ] ) \\\\      ( { * } { * } ) & \\forall y \\in { \\textsc{sh}_{f}\\left(x\\right)}. &      \\forall \\bar{g}.~{\\textsc{sh}_{seq}^{x , y}\\left(f,\\bar{g}\\right ) } \\rightarrow      ( \\forall      \\state_1 \\models \\pred,\\state_2 \\models      \\pred . \\\\      & & ~~\\agreem(\\state_1,\\state_2 )      \\rightarrow \\\\      & & ~~\\agreem'(\\state_1[y.\\bar{g } \\leftarrow        { \\left\\llbracket e \\right\\rrbracket}(\\state_1)],\\state_2[y.\\bar{g } \\leftarrow        { \\left\\llbracket e \\right\\rrbracket}(\\state_2 ) ] ) ) \\\\      ( { * } { * } { * } ) & \\forall y \\notin { \\textsc{dal}\\left(x\\right)}. & \\agreem(y )      \\sqsubseteq \\agreem'(y )    \\end{array } } {    { \\left\\{\\agreem\\right\\}^{\\pred}\\ x.f\\mbox{{\\ensuremath{\\mbox{\\lstinline!:=!}\\xspace}\\xspace}}e\\ \\left\\{\\agreem'\\right\\ } } } \\ { \\textsc{g - fassign2}}}\\ ] ]      the tukra abstract program slicing tool @xcite implements the computation of a dependence condition graph @xcite for performing abstract slicing .",
    "to use a program dependence graph is somehow alternative to the computation of agreements .",
    "as far as the author make it possible to understand , tukra only deals with numerical values , and it is not clear which properties are supported ( i.e. , which is the `` library '' of ucos mentioned in section [ sec : agreementsanducos ] ) .    moreover , the authors of that tool point out that their approach is able to exclude some dependencies that were not ruled out in previous work introducing abstract dependencies @xcite .",
    "however , they do not consider that a rule system for computing agreements ( essentially , the described in the present paper ) was introduced @xcite before tukra was developed , and does not suffer from the limitations they describe .",
    "the formal framework referred to in this paper @xcite is not the only attempt to provide a unified mathematical framework from program slicing . in @xcite , the authors have precisely this aim . in this work ,",
    "the authors unify different approaches to program slicing by defining a particular semantic relation , based on the weakest precondition semantics , called _ semirefinement _ such that , given a program @xmath3 , the possible slices are all the programs that are semirefinements of @xmath3 . in this framework ,",
    "different forms of slicing are modeled as program transformations .",
    "hence , a program @xmath8 is a slice of @xmath3 if the transformation of @xmath8 ( corresponding to the particular form of slicing to compute ) is a semirefinement of the same transformation of @xmath3 .",
    "this approach is extremely interesting , but does not really allow to compare the different forms of slicing , feature that we consider fundamental for introducing the new abstract forms of slicing as generalizations of the existing ones .",
    "it may surely deserve further research to study whether also abstract slicing could be modeled in this framework .    as far as the relation between slicing and dependencies is concerned , there are at least two works that are related with our ideas in different ways .",
    "one of the first works aiming at formalizing a semantic approach to dependency , leading to a semantic computation of slicing , is the _ information - flow logic _ by amtoft and banerjee @xcite .",
    "this logic allows us to formally derive , by structural induction , the set of all the _ independencies _ among variables . in figure",
    "[ ab04-fig ] , the original notation proposed by the authors is used , where @xmath976 $ ] is to be read as `` the current value of @xmath0 is independent of the initial value of @xmath161 '' , and holds if , for each pair of _ initial _ states which agree on all the variables but @xmath161 , the corresponding _ current _ states agree on @xmath0 .",
    "hence , @xmath977 stands for sets of independencies , and @xmath978 is a set of variables representing the _ context _ , i.e. , ( a superset of ) the variables on which at least one test surrounding the statements depends on .    in our aim of defining slicing in terms of dependencies , the first thing we have to observe in this logic is that it always computes ( in)dependencies from the _ initial _ values of variables .",
    "this makes its use for slicing not so straightforward , since it loses the _ local _ dependency between statements .",
    "consider for example the program fragment @xmath979 . at the end of this program ,",
    "we know that only depends on the initial value of , but , by using the logic in fig .",
    "[ ab04-fig ] , we lose the trace of ( in)dependencies which , in this case , would involve all the three assignments . as a matter of fact ,",
    "this logic is more suitable for forward slicing , which is the one considered by the authors @xcite , since it fixes the criterion _ on the input_. in the trivial example given above , if we consider as criterion the input of , then we obtain that all the statements depend on .",
    "therefore , any slice of the original program contains all statements @xcite . in the logic , more explicitly , this notion of dependency is used for characterizing the set of independencies holding during the execution of a program .",
    "another , more recent , approach to slicing by means of dependencies is @xcite . in this work ,",
    "the authors propose new definitions of control dependencies : non - termination sensitive and insensitive .",
    "these new semantic notions of dependencies are then used for computing more precise standard slices .",
    "it could be surely interesting to study the semantic relation between their notion of dependencies and the ones we propose in this paper .",
    "finally , a related algorithm for computing abstract slices has been already discussed in section [ sec : comparisonwithrelatedalgorithms ] .",
    "it is necessary to point out that the agreement - based approach to abstract slicing @xcite was introduced before the tukra tool .",
    "the present paper formally defines the notion of abstract program slicing , a general form of slicing where properties of data are observed instead of their exact value .",
    "a formal framework is introduced where the different forms of abstract slicing can be compared ; moreover , traditional , non - abstract forms of slicing are also included in the framework , allowing to prove that non - abstract slicing is a special case of abstract slicing where no abstraction on data is performed .",
    "algorithms for computing abstract dependencies and program slices are given .",
    "future work includes an implementation of this analysis for an object - oriented programming language where properties may refer either to numerical or reference values ( to the best of our knowledge , existing tools only deal with integer variables ) . on the other hand",
    ", we observed that the provided notion of abstract dependency is not suitable for slicing computation by using pdgs .",
    "we believe that it is possible to further generalize the notion of abstract dependencies allowing to characterize a recursive algorithm able to track backwards both the variables that affect the criterion , and the abstract properties of these variables affecting the abstract criterion .",
    "another interesting line of research is to understand how other approaches to slicing can be extended in order to include abstract slicing . as noted before , it would be interesting to study whether it is possible to model abstract slicing as a program transformation , allowing us to define also abstract slicing in term of semirefinement @xcite .",
    "another , more algorithmic , interesting approach is the one proposed in @xcite , where weakest precondition and strongest postcondition semantics are combined in a new more precise algorithm for standard slicing .",
    "it could be very interesting to understand whether this approach could be extended in order to cope also with the computation of abstract forms of slicing .",
    "\\2007 . a logic for information flow analysis with an application to forward slicing of simple imperative programs .",
    "_ 64 , _  1 , 328 .",
    ", da  cruz , d. , henriques , p.  r. , and pinto , j.  s. 2010 . assertion - based slicing and slice graphs . in _ proceedings of the 2010 8th ieee international conference on software engineering and formal methods_. sefm 10 .",
    "ieee computer society , washington , dc , usa , 93102 .    \\1998 .",
    "dijkstra - scholten predicate calculus : concepts and misconceptions .",
    "_ 35 , _  12 , 10071036 .    ,",
    "danicic , s. , gyimthy , t. , harman , m. , kiss , a. , and korel , b. 2006a .",
    "a formalisation of the relationship between forms of program slicing .",
    "_ 62 , _  3 , 228252 .    ,",
    "danicic , s. , gyimthy , t. , harman , m. , kiss , a. , and korel , b. 2006b .",
    "theoretical foundations of dynamic program slicing .",
    "_ 360 , _  1 , 2341 .",
    "program slicing .  _",
    "43_.    , cinitile , a. , and , a. 1998 .",
    "conditioned program slicing .",
    "_ 40 _ , 1112 .",
    ", de  lucia , a. , and munro , m. 1996 . a specification driven slicing process for identifying reusable functions .",
    "_ 8 , _  3 , 145178 .",
    "abstract interpretation based formal methods and future challenges . in _ informatics - 10 years back .",
    "10 years ahead_. 138156 .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _ proceedings of acm symposium on principles of programming languages ( popl)_. acm press , new york , 238252 .",
    ". systematic design of program analysis frameworks . in _ proceedings of acm symposium on principles of programming languages ( popl)_. acm press , new york , 269282 .    , barraclough , r.  w. , harman , m. , howroyd , j.  d. , kiss , a. , and laurence , m.  r. 2011 . a unifying theory of control dependence and its application to arbitrary program structures .",
    "_ 412 , _  49 , 68096842 .",
    "program slicing : methods and applications . in _ proceedings of international workshop on source code analysis and manipulation ( scam)_.    \\1975 .",
    "guarded commands , nondeterminacy and formal derivation of programs .",
    "_ 18 , _  8 , 453457 .",
    "springer - verlag .    , ramalingam , g. , and tip , f. 1995 .",
    "parametric program slicing . in _ proceedings of acm symposium on principles of programming languages ( popl)_. acm press , 379392 .",
    "\\1991 . using program slicing in software maintenance .",
    "_ 17 , _  8 , 751761 .    \\2013 .",
    "reachability - based acyclicity analysis by abstract interpretation .",
    "_ 474 , _  0 , 6079 .    ,",
    "jones , n.  d. , and mastroeni , i. 2012 .",
    "obfuscation by partial evaluation of distorted interpreters . in _ proceedings of the acm sigplan 2012 workshop on partial evaluation and program manipulation , pepm 2012 , philadelphia , pennsylvania , usa , january 23 - 24 , 2012_. 6372 .",
    "abstract non - interference : parameterizing non - interference by abstract interpretation . in _ proceedings of acm symposium on principles of programming languages ( popl)_. acm press , 186197",
    ".    2004b . proving abstract non - interference .",
    "in _ annual conf .  of the european association for computer science logic ( csl  04 ) _ , a.  t. j.  marcinkowski , ed .",
    "springer - verlag , berlin , 280294 .    ,",
    "ranzato , f. , and scozzari , f. 2000 . making abstract interpretations complete .",
    "_ 47 , _  2 , 361416 .",
    "tukra : an abstract program slicing tool . in _ proceedings of international conference on software paradigm trends",
    "( icsoft)_. 178183 .",
    "abstract program slicing on dependence condition graphs .",
    "_ 78 , _  9 , 12401263 .",
    "pointer analysis : havent we solved this problem yet ? in _ proceedings of the workshop on program analysis for software tools and engineering ( paste)_. acm press , new york , 5461 .",
    "\\1969 . an axiomatic basis for computer programming .",
    "_ 12 , _  10 , 576580 .    , prins , j. , and reps , t. 1989 .",
    "integrating non - interfering versions of programs .",
    "_ 11 , _  3 .",
    "the per model of abstract non - interference . in",
    "_ proceedings of static analysis symposium ( sas)_. lecture notes in computer science series , vol . 3672 .",
    "springer - verlag , 171185 .",
    "dynamic program slicing .",
    "_ 29 , _  3 , 155183 .    ,",
    "drape , s.  j. , and thomborson , c.  d. 2007 .",
    "slicing obfuscations : design , correctness , and evaluation . in _ proceedings of acm workshop on digital rights management ( drm)_. acm , new york , ny , usa , 7081 .",
    "abstract interpretation - based approaches to security - a survey on abstract non - interference and its challenging applications . in _",
    "semantics , abstract interpretation , and reasoning about programs : essays dedicated to david a. schmidt on the occasion of his sixtieth birthday , manhattan , kansas , usa , 19 - 20th september 2013 .",
    "_ 4165 .",
    "abstract program slicing : from theory towards an implementation . in _ proceedings of international conference on formal engineering methods ( icfem)_. lecture notes in computer science series , vol .",
    "springer - verlag , 452467 .",
    "data dependencies and program slicing : from syntax to abstract semantics . in _ proceedings of symposium on partial evaluation and semantics - based program manipulation ( pepm)_. 125134 .",
    "making abstract model checking strongly preserving . in _ proceedings of static analysis symposium ( sas)_. lecture notes in computer science series , vol .",
    "springer - verlag , 411427 .",
    "algebraic properties of program integration .  _ 17",
    "_ , 139215 .",
    "the semantics of program slicing and program integration . in _ proc .  of the colloq .  on current issues in programming languages _ ,",
    "j.  diaz and f.  orejas , eds .",
    "lecture notes in computer science series , vol .",
    "springer - verlag , berlin , 360374 .    \\2006 . detecting non - cyclicity by abstract compilation into boolean functions . in _ proceedings of the international conference on verification , model checking , and abstract interpretation ( vmcai)_. lecture notes in computer science series , vol .",
    "springer - verlag , 95110 .",
    "pair - sharing analysis of object - oriented programs . in _ proceedings of the interanational symposium on static analysis ( sas)_. springer - verlag , 320335 .",
    "\\1995 . a survey of program slicing techniques .",
    "_ 3 _ , 121181 .",
    "\\2007 . slicing as a program transformation .",
    "_ 29 , _  2 .",
    "program slicing .",
    "_ 10 , _  4 , 352357 .",
    "the semantics of abstract program slicing . in _ proceeding of working conference on source code analysis and manipualtion ( scam)_.    \\2015 .",
    "ield - sensitive sharing .  _",
    "in this section , we first provide a better intuition of the differences between the forms of slicing introduced in section  [ section : background ] by means of examples and then we recall the main notions introduced in @xcite that has been generalized in this paper in the abstract form .      [ ex : crit ] consider the program on the left in figure  [ exfig : crit ] .",
    "suppose that the execution start with an initial value @xmath980 for @xmath981 ( written @xmath982 ) .",
    "states are denoted as @xmath983 , where @xmath984 is the program point of the executed statement , @xmath40 is its current iteration ( i.e. , the statement at @xmath984 is being executed for the @xmath40-th time in the loop unrolling ) , and @xmath41 is the actual memory , represented by a list of pairings @xmath985 ) . in the picture , @xmath986 is depicted in the first ( fully colored ) box , while the memory is depicted in the remaining boxes , one for each variable .",
    "a program state that is not executed in a trace is depicted by overwriting a grey cross on each box ( program point and variables ) .",
    "the execution trajectory of the program is the following :              we can observe that the semantics of the second program follows precisely the same path on the statements which are in both programs ( the only difference is the execution , in the original program of the statement at point @xmath987 , erased in the `` candidate '' slice ) , hence it is a slice according both to the standard and the @xmath268 form , namely w.r.t .",
    "@xmath988 for both the possible values of @xmath271 .",
    "+ suppose now we are interested in an @xmath269 form of slice , variable at the second iteration of the program point @xmath989 . in this case",
    ", the program on the right is not a dynamic slice , since the value of in the original program is @xmath990 , while in the candidate slice it is undefined . in other words ,",
    "this program is not slice of the program on the left w.r.t .  the criterion @xmath991 ( @xmath271 may be both true or false ) .",
    "+ finally , let us consider the execution of the program on the right in fugure  [ exfig : crit ] :        this last program is a standard dynamic slice since the final value of the variable of interest is the same , but it is not a slice in the @xmath268 form , since in this last program the statement at program point @xmath940 is executed , while in the original program it is not executed .",
    "namely , it is a slice w.r.t .",
    "the criterion @xmath988 only for @xmath365 .",
    "[ ex : stkl ] consider the program @xmath3 on the left of figure  [ fig : stkl ] .",
    "suppose static slicing is considered , i.e. , all the possible initial memories are taken into account .",
    "given an input @xmath494 , the state trajectory is :                      consider the standard form of static slicing interested in at program point @xmath992 , i.e. , @xmath993 .",
    "then the program on the right is a slice of @xmath3 w.r.t .",
    "@xmath272 , since in @xmath992 the value of is @xmath994 in both cases . on the other hand , if we consider the @xmath268 form , @xmath995 , then the program is no more a slice of @xmath3 since there is a program point , @xmath996 , which is not reached in @xmath3 .      the first step for defining",
    "the formal framework is to define an equivalence relation between programs , determining when a program is a slice of another .",
    "first , a _ restricted memory _ is obtained from a memory by restricting its domain to a set of variables .",
    "more formally , the restriction of @xmath41 with respect to a set of variables @xmath251 is defined as @xmath997 such that @xmath998 is equal to @xmath48 if @xmath999 , and undefined otherwise .",
    "this restriction is used to project the trace semantics only on those points of interest where we have to check the correspondence between the original program and the candidate slice .",
    "[ def : proj ] let @xmath501 , and @xmath334 such that @xmath335 if @xmath336 , @xmath337 otherwise .",
    "for any @xmath275 , @xmath338 , @xmath264 , we define the function @xmath1000 as : @xmath1001 where @xmath344 is the empty sequence .",
    "the trace projection @xmath1002 is the extension of @xmath1003 to sequences ( @xmath1004 is sequence concatenation ) : @xmath1005    @xmath1003 takes a state from a state trajectory , and returns either one pair or an empty sequence @xmath344 .",
    "if @xmath1006 is an occurrence of interest , then it returns @xmath1007 .",
    "this means that , at @xmath2 , we consider exact values of variables in @xmath251",
    ". if @xmath1006 is not an occurrence of interest , but , due to a @xmath268 form , the projection has to keep trace of a set @xmath1008 of executed statements ( even if the variables in that point are not of interest ) , then @xmath1003 returns @xmath1009 , meaning that we require the execution of @xmath2 , but we are not interested in the values of variables in @xmath251 .",
    "trajectory projection allows us to define all the semantic equivalence relations characterizing on what a program and its slices have to agree due to the chosen criterion .. given two programs @xmath3 and @xmath8 , we can say that @xmath8 is a slice of @xmath3 if it contains a subset of the original statements and @xmath8 is _ equivalent _ to @xmath3 with respect to the semantic equivalence relation induced by chosen the slicing criterion .",
    "[ def : unifiedequivalence ] let @xmath3 and @xmath8 be executable programs , and @xmath501 be a slicing criterion .",
    "let @xmath34 be the set of program points of @xmath3 , and @xmath1010 if @xmath336 , as we suppose in this paper , then @xmath1011 .",
    "we provide the general definition since the original definition of dynamic slicing @xcite does not require that all the line of @xmath8 are included in @xmath1008 ; however , our choice follows the paths taken in the original framework @xcite . ]",
    "( @xmath1012 if @xmath365 ) .",
    "then @xmath3 is _ equivalent _ to @xmath8 w.r.t .",
    "@xmath272 if and only if @xmath1013 the function @xmath11 maps any criterion @xmath272 to the r to the corresponding semantic equivalence relation , hence , in this case , we write @xmath1014 .",
    "[ ex : formsl ] consider the program @xmath3 in the left of figure  [ fig : exsl ] ; let the input for be @xmath980 .",
    "suppose we want to compute a non iteration - count @xmath268 form of dynamic slicing , i.e. , @xmath1015 .",
    "namely , the variables of interest are and  , which are observed at the program point @xmath348 each time it is reached , and the slice has not to execute statements not executed in the original program .",
    "the program on the right of figure  [ ex : formsl ] is a slice w.r.t .  @xmath272 . in figure  [ extrace ]",
    "we have the execution trajectory of the original program ( on the top ) , the execution trajectory of the candidate slice ( in the middle ) and the ( same ) projection of the two trajectories due to the chosen criterion ( on the bottom ) .",
    "the formal framework proposed in @xcite represents different forms of slicing by means of a @xmath1016 pair : a _ syntactic preorder _ , and a _ function from slicing criteria to semantic equivalences_. the _ preorder _ fixes a syntactic relation between the program and its slices . in traditional",
    "slicing , slices are obtained from the original program by removing zero or more statements .",
    "this preorder is called _ traditional syntactic ordering _ , simply denoted by @xmath311 , and it is defined as follows : @xmath1017 the second component @xmath11 fixes the semantic constraints that a subprogram has to respect in order to be a slice of the original program . as we have seen before , the equivalence relation is uniquely determined by the chosen slicing criterion determining also a specific form of slicing . this way , binkley are able to characterize eight forms of non-@xmath280 slicing , and twelve forms of @xmath280 slicing .",
    "finally , this framework is used to formally compare the different notions of slicing .",
    "first of all , it is defined a binary relation on slicing criteria @xmath1018 @xcite : let @xmath1019 and @xmath1020 @xmath1021 at this point , we say that a form of slicing @xmath1022 is _ weaker than _",
    "@xmath1023 w.r.t .",
    "@xmath1018 iff @xmath1024 , slicing criteria such that @xmath1025 , and @xmath1026 , if @xmath8 is a slice of @xmath3 w.r.t .",
    "@xmath1027 , then @xmath8 is a slice of @xmath3 w.r.t .",
    "@xmath1028 as well . in this case",
    "we say that @xmath1029 subsumes @xmath1030 .    following this definition , binkley et al .",
    "show that all forms of slicing introduced in  @xcite are comparable in the way shown in figure  [ fig : ret1 ] , where the symbols @xmath1031 , @xmath528 , @xmath1032 , @xmath1033 , @xmath1034 and @xmath1035 represent static , conditioned , dynamic , static @xmath280 , conditioned @xmath280 and dynamic @xmath280 types of slicing , respectively .",
    "subscripts @xmath54 , @xmath268 and @xmath270 represent @xmath269 , @xmath268 and @xmath270 forms of slicing , respectively ; the absence of subscripts denotes the standard forms of slicing . in figure",
    "[ fig : ret1 ] we explicitly provide both the hierarchy concerning @xmath280 and non-@xmath280 forms of conditioned slicing constructed in  @xcite ."
  ],
  "abstract_text": [
    "<S> in the present paper we formally define the notion of _ abstract program slicing _ , a general form of program slicing where properties of data are considered instead of their exact value . </S>",
    "<S> this approach is applied to a language with numeric and reference values , and relies on the notion of _ abstract dependencies _ between program components ( statements ) .    </S>",
    "<S> the different forms of ( backward ) abstract slicing are added to an existing formal framework where traditional , non - abstract forms of slicing could be compared . </S>",
    "<S> the extended framework allows us to appreciate that abstract slicing is a generalization of traditional slicing , since traditional slicing ( dealing with syntactic dependencies ) is generalized by ( semantic ) non - abstract forms of slicing , which are actually equivalent to an abstract form where the _ identity _ abstraction is performed on data .    </S>",
    "<S> sound algorithms for computing abstract dependencies and a systematic characterization of program slices are provided , which rely on the notion of _ agreement _ between program states .    </S>",
    "<S> authors addresses : isabella mastroeni , dipartimento di informatica , facolt di scienze , universit di verona , strada le grazie 15 , 37134 verona , italy ; damiano zanardini , departamento de inteligencia artificial , escuela tcnica superior de ingenieros informticos , campus de montegancedo , boadilla del monte , 28660 madrid , spain . </S>"
  ]
}