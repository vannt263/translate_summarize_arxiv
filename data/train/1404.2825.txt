{
  "article_text": [
    "protect copyrighted content against unauthorized redistribution , distributors commonly embed watermarks or fingerprints in the content , uniquely linking copies to individual users .",
    "if the distributor finds an illegal copy of the content online , he can then extract the watermark from this copy and compare it to the database of watermarks , to determine which user was responsible .    to combat this solution",
    ", a group of @xmath0 pirates may try to form a coalition and perform a collusion attack . by comparing their unique versions of the content",
    ", they will detect differences in their copies which must be part of the watermark .",
    "they can then try to create a mixed pirate copy , where the resulting watermark matches the watermark of different pirates in different segments of the content , making it hard for the distributor to find the responsible users .",
    "the goal of the distributor of the content is to assign the watermarks to the users in such a way that , even if many pirates collude , the pirate copy can still be traced back to the responsible users .      a different area of research that has received considerable attention in the last few decades is group testing , introduced by dorfman  @xcite in the 1940s .",
    "suppose a large population contains a small number @xmath0 of infected ( or defective ) items .",
    "to identify these items , it is possible to perform group tests : testing a subset of the population will lead to a positive test result if this subset contains at least one defective item , and a negative result otherwise . since the time to run a single test may be very long ,",
    "the subsets to test need to be chosen in advance , after which all group tests are performed simultaneously .",
    "then , when the test results come back , the subset of defective items needs to be identified .",
    "the goal of the game is to identify these defectives using as few group tests as possible , and with a probability of error as small as possible .",
    "the above problems of fingerprinting and group testing can be jointly modeled by the following two - person game between ( in terms of fingerprinting ) the distributor @xmath1 and the adversary @xmath2 ( the set of colluders , or the set of defectives ) . throughout the paper",
    "we will mostly use terminology from fingerprinting ( i.e. users instead of items , colluders instead of defective items ) , unless we are specifically dealing with group testing results .",
    "first , there is a universe @xmath3 of @xmath4 users , and the adversary is assigned a random subset of users @xmath5 of size @xmath6 .",
    "this subset @xmath2 is unknown to the distributor ( but we assume that the distributor does know the size @xmath0 of @xmath2 ) , and the aim of the game for the distributor is ultimately to discover @xmath2 .",
    "the two - person game consists of three phases : ( 1 ) the distributor uses an _ encoder _ to generate a fingerprinting code , used for assigning versions to users ; ( 2 ) the colluders employ a _ collusion channel _ to generate the pirate output from their given code words ; and ( 3 ) the distributor uses a _ decoder _ to map the pirate output to a set @xmath7 .",
    "the distributor generates a fingerprinting code @xmath8 of @xmath4 binary code words of length @xmath9 . , but in this paper we restrict our attention to the binary case @xmath10 .",
    "] the parameter @xmath9 is referred to as the code length , and the distributor would like @xmath9 to be as small as possible . for the eventual embedded watermark , we assume that for each segment of the content there are two differently watermarked versions , so the watermark of user @xmath11 is determined by the @xmath9 entries in the @xmath11th code word of @xmath8 .    a common restriction on the encoding process is to assume that @xmath8 is created by first generating a bias vector @xmath12 ( by choosing each entry @xmath13 independently from a certain distribution @xmath14 ) , and then generating code words @xmath15 according to @xmath16 .",
    "this guarantees that watermarks of different users @xmath11 are independent , and that watermarks in different positions @xmath17 are independent .",
    "fingerprinting schemes that satisfy this assumption are sometimes called bias - based schemes , and the encoders in this paper ( both for group testing and fingerprinting ) are also assumed to belong to this category .      after generating @xmath8 ,",
    "the code words are used to select and embed watermarks in the content , and the content is sent out to all users .",
    "the colluders then get together , compare their copies , and use a certain collusion channel or pirate attack @xmath18 to determine the pirate output @xmath19 .",
    "if the pirate attack behaves symmetrically both in the colluders and in the positions @xmath17 , then the collusion channel can be modeled by a vector @xmath20^{c+1}$ ] , consisting of entries @xmath21 ( for @xmath22 ) indicating the probability of outputting a @xmath23 when the pirates received @xmath24 ones and @xmath25 zeroes . a further restriction on @xmath26 in fingerprinting is the marking assumption , introduced by boneh and shaw  @xcite , which says that @xmath27 and @xmath28 , i.e. , if the pirates receive only zeros or ones they have to output this symbol .      finally , after the pirate output has been generated and distributed , we assume the distributor intercepts it and applies a decoding algorithm to @xmath29 , @xmath8 and @xmath30 to compute a set @xmath7 of accused users .",
    "the distributor wins the game if @xmath31 and loses if this is not the case .",
    "while the above model is described in fingerprinting terminology , it also covers many common group testing models .",
    "the users then correspond to items , the colluders translate to defectives , the code @xmath8 corresponds to the group testing matrix @xmath32 ( where @xmath33 if item @xmath11 is included in the @xmath17th test ) , and the pirate output corresponds to positive / negative test results .",
    "the collusion channel is exactly what separates group testing from fingerprinting : while in fingerprinting it is commonly assumed that this channel is not known or only weakly known to the distributor , in group testing this channel is usually assumed known in advance .",
    "this means that there is no malicious adversary in group testing , but only a randomization procedure that determines @xmath29 .",
    "note also that in ( noisy ) group testing , the boneh - shaw marking assumption may not always hold .",
    "work on the fingerprinting game described above started in the late 90s , and lower bounds on the code length were established of the order @xmath34",
    "@xcite , until in 2003 tardos  @xcite proved a lower bound of the order @xmath35 and described a scheme with @xmath36 , showing this bound is tight . since the leading constants of the upper and lower bounds did not match , later work on fingerprinting focused on finding the optimal leading constant .    based on channel capacities , amiri and tardos  @xcite and huang and",
    "moulin  @xcite independently derived the optimal leading constant to be @xmath37 ( i.e.  an asymptotic code length of @xmath38 ) and many improvements to tardos s original scheme were made  @xcite to reduce the leading constant from @xmath39 to @xmath40 .",
    "recently it was shown that with tardos original ` score function ' one can not achieve capacity  @xcite , which lead to the study of different score functions . based on a result of abbe and zheng  @xcite , meerwald and furon",
    "@xcite noted that a score function designed against the worst - case attack achieves capacity against arbitrary attacks .",
    "this also lead to a proposal for a capacity - achieving score function in  @xcite , which achieves the lower bound on the leading constant of @xmath37 .",
    "most of the work on fingerprinting focused on the setting of arbitrary , unknown attacks , but some work was also done on the informed setting , where the decoder knows or tries to estimate the pirate strategy  @xcite .",
    "it is well known that for suboptimal pirate attacks the required code length may be significantly smaller than @xmath38 , but explicit schemes provably achieving an optimal scaling in @xmath9 are not known .",
    "research on the group testing problem started much longer ago , and already in 1985 exact asymptotics on the code length for probabilistic schemes were derived as @xmath41  @xcite , whereas deterministic schemes require a code length of @xmath35  @xcite .",
    "later work focused on slight variations of the classical model such as noisy group testing , where a positive result may not always correspond to the presence of a defective item due to ` noise ' in the test output  @xcite . for noisy group testing exact asymptotics on the capacities ( with leading constants )",
    "are yet unknown , and so it is not known whether existing constructions are optimal .      in this paper",
    "we show how to build schemes using log - likelihood decoders that provably satisfy given bounds on the error probabilities , and have a code length with the optimal asymptotic scaling .",
    "we do this both for the informed setting ( where @xmath26 is known to the decoder ) and the universal setting , where @xmath26 is only known to satisfy the marking assumption .",
    "the results for the informed setting for fingerprinting are summarized in table  [ tab : tab1 ] .",
    "simple informed and universal decoders are discussed in sections  [ sec : dec - simple ] and [ sec : dec - simple - universal ] , and joint informed and universal decoders are discussed in sections  [ sec : dec - joint ] and [ sec : dec - joint - universal ] respectively .",
    "in - between , section  [ sec : dec - simple - universal - emi ] discusses a completely different approach to obtain a universal simple decoder ( based on the empirical mutual information decoder of moulin  @xcite ) and shows how in the end the result is again quite similar .",
    ".an overview of the provable asymptotic code lengths of the informed fingerprinting decoders discussed in this paper .",
    "[ tab : tab1 ] [ cols=\"<,<,<\",options=\"header \" , ]",
    "in this section we will discuss simple decoders with explicit scheme parameters ( code lengths , accusation thresholds ) that provably satisfy given bounds on the error probabilities .",
    "the asymptotics of the resulting code lengths further show that these schemes are capacity - achieving ; asymptotically , the code lengths achieve the lower bounds that follow from the simple capacities , as derived in  @xcite",
    ".    we will follow the bias - based and score - based framework introduced by tardos  @xcite , which was later generalized to joint decoders by moulin  @xcite . for simple decoding",
    ", this means that a user @xmath11 receives a score @xmath42 of the form @xmath43 and he is accused iff @xmath44 for some fixed threshold @xmath45 .",
    "the function @xmath46 is sometimes called the score function .",
    "note that since @xmath46 only depends on @xmath8 through @xmath47 , any decoder that follows this framework is a simple decoder .",
    "several different score functions @xmath46 have been considered before  @xcite , but in this work we will restrict our attention to log - likelihood scores , which are known to perform well and which turn out to be quite easy to analyze .    first , when building a decoder we naturally want to be able to distinguish between two cases : user @xmath11 is guilty or user @xmath11 is not guilty . to do this",
    ", we assign scores to users based on the available data , and we try to obtain an optimal trade - off between the false positive error ( accusing an innocent user ) and the false negative error ( not accusing a guilty user ) .",
    "this problem is well known in statistics as a hypothesis testing problem , where in this case we want to distinguish between the following two hypotheses @xmath48 and @xmath49 : @xmath50 the neyman - pearson lemma  @xcite tells us that the most powerful test to distinguish between @xmath48 and @xmath49 is to test whether the following likelihood ratio exceeds an appropriately chosen threshold @xmath45 : @xmath51 taking logarithms , and noting that different positions @xmath17 are i.i.d .",
    ", it is clear that testing whether a user s likelihood ratio exceeds @xmath52 is equivalent to testing whether his score @xmath42 exceeds @xmath53 for @xmath46 defined by @xmath54 thus , the score function @xmath46 from   corresponds to using a neyman - pearson score over the entire code word @xmath47 , and therefore @xmath46 is in a sense optimal for minimizing the false positive error for a fixed false negative error .",
    "score functions of this form were previously considered in the context of fingerprinting in e.g.  @xcite , but these papers did not show how to choose @xmath45 and @xmath9 to provably satisfy certain bounds on the error probabilities .",
    "let us first see how we can choose @xmath9 and @xmath45 such that we can prove that the false positive and false negative error probabilities are bounded from above by certain values @xmath55 and @xmath56 . for the analysis below , we will make use of the following function @xmath57 , which is closely related to the moment - generating function of scores in one position @xmath17 for both innocent and guilty users . for fixed @xmath58",
    ", this function @xmath57 is defined on @xmath59 $ ] by @xmath60 and it satisfies @xmath61 .",
    "[ thm : dec - simple - informed ] let @xmath58 and @xmath26 be fixed and known to the decoder .",
    "let @xmath62 , and let the code length @xmath9 and threshold @xmath45 be chosen as @xmath63 then with probability at least @xmath64 no innocent users are accused , and with probability at least @xmath65 at least one colluder is caught .",
    "for innocent users @xmath11 , we would like to prove that @xmath66 , where @xmath42 is the user s total score over all segments .",
    "if this can be proved , then since innocent users have independent scores , it follows that with probability at least @xmath67 no innocent users are accused . to get somewhat tight bounds , we start by applying the markov inequality to @xmath68 for some @xmath69 : @xmath70 let us now first switch to guilty users",
    ". we will prove that for some guilty user @xmath11 , @xmath71 .",
    "again using markov s inequality with some fixed constant @xmath72 , we get @xmath73 for both guilty and innocent users , we can now obtain bounds by choosing appropriate values for @xmath74 and @xmath75 . investigating the resulting expressions , it seems that good choices for @xmath76 leading to sharp bounds are @xmath77 and @xmath78 . substituting these choices for @xmath74 and @xmath75 , and setting the bounds equal to the desired upper bounds @xmath79 and",
    "@xmath56 , we get @xmath80 combining these equations we obtain the given expression for @xmath45 , and solving for @xmath9 leads to the expression for @xmath9 in  .",
    "compared to previous papers analyzing provable bounds on the error probabilities  @xcite , the proof of theorem  [ thm : dec - simple - informed ] is remarkably short and simple .",
    "note however that the proof that a colluder is caught assumes that the attack used by the colluders is the same as the one the decoder is built against , and that the actual value of @xmath9 is still somewhat mysterious due to the term @xmath81 . in section  [ sec : dec - simple - codelength ] we will show how to get some insight into this expression for @xmath9 .",
    "before going into details how the code lengths of theorem  [ thm : dec - simple - informed ] scale , note that theorem  [ thm : dec - simple - informed ] only shows that with high probability we provably catch _ at least one _ colluder with this decoder .",
    "although this is commonly the best you can hope for when dealing with arbitrary attacks in fingerprinting , if the attack is colluder - symmetric it is actually possible to catch _ all _ colluders with high probability .",
    "so instead we would like to be able to claim that with high probability , the set of accused users @xmath82 _ equals _ the set of colluders @xmath2 .",
    "similar to the proof for innocent users , we could simply replace @xmath56 by @xmath83 , and argue that the probability of finding all pirates is the product of their individual probabilities of getting caught , leading to a lower bound on the success probability of @xmath84 .",
    "this leads to the following heuristic estimate for the code length required to catch _ all _ pirates .",
    "let @xmath85 in theorem  [ thm : dec - simple - informed ] be replaced by @xmath86 .",
    "then with probability at least @xmath64 no innocent users are accused , and with probability at least @xmath65 _ all colluders are caught_.    the problem with this claim is that the pirate scores are related through @xmath29 , so they are not independent . as a result",
    ", we can not simply take the product of the individual probabilities @xmath87 to get a lower bound on the success probability of @xmath65 . on the other hand , especially when the code length @xmath9 is large and",
    "@xmath56 is small , we do not expect the event @xmath88 to tell us much about the probability of e.g.  @xmath89 occurring .",
    "one might thus expect that @xmath89 does not become much less likely when @xmath88 occurs .",
    "but since it is not so simple to prove a rigorous upper bound on the _ catch - all _ error probability without assuming independence , we leave this problem for future work .",
    "let us now see how the code lengths @xmath9 from   scale in terms of @xmath0 and @xmath4 . in general",
    "this expression is not so pretty , but if we focus on the regime of large @xmath4 ( and fixed @xmath55 and @xmath56 ) , it turns out that the code length always has the optimal asymptotic scaling , regardless of @xmath58 and @xmath26 .",
    "[ thm : dec - simple - asymptotics ] for large @xmath4 and fixed @xmath55 and @xmath56 , the code length @xmath9 of theorem  [ thm : dec - simple - informed ] scales as @xmath90 , \\label{eq : dec - simple - asymptotics}\\end{aligned}\\ ] ] where @xmath91 is the mutual information between a pirate symbol @xmath92 and the pirate output @xmath93 . as a result",
    ", @xmath9 has the optimal asymptotic scaling .",
    "first , note that if @xmath94 and @xmath95 are fixed , then @xmath96 .",
    "let us first study the behavior of @xmath81 for small @xmath85 , by computing the first order taylor expansion of @xmath81 around @xmath97 . for convenience , below we will abbreviate @xmath98 by @xmath99 .",
    "@xmath100 here the second equality follows from the fact that if @xmath101 , then the factor @xmath102 in front of the exponentiation would already cause this term to be @xmath103 , while if @xmath104 , then also @xmath105 and thus their ratio is bounded and does not depend on @xmath85 .",
    "now , recognizing the remaining summation as the mutual information ( in natural units ) between a colluder symbol @xmath92 and the pirate output @xmath93 , we finally obtain : @xmath106 substituting this result in the original equation for @xmath9 , and noting that the factor @xmath55 inside the logarithm is negligible for large @xmath4 , we finally obtain the result of .    note that in the discussion above , we did not make any assumptions on @xmath58 .",
    "in fact , both theorems  [ thm : dec - simple - informed ] and [ thm : dec - simple - asymptotics ] hold for _ arbitrary _ values of @xmath58 ; the decoder always achieves the capacity associated to that value of @xmath58 . as a result , if we optimize and fix @xmath58 based on @xmath26 ( using results from  ( * ? ? ?",
    "* section  ii ) ) , we automatically end up with a decoder that provably achieves capacity for this attack .",
    "let us now consider specific pirate attacks which are often considered in the fingerprinting literature , and investigate the resulting code lengths .",
    "we will again consider the following five attacks of @xcite , which were also considered in e.g. @xcite . recall that @xmath107 is the probability of the pirates outputting a @xmath23 when they received @xmath24 ones .    *",
    "* interleaving attack * : the coalition randomly selects a pirate and outputs his symbol .",
    "this corresponds to @xmath108 * * all-@xmath23 attack * : the pirates output a @xmath23 whenever they can , i.e. whenever they have at least one @xmath23 .",
    "this translates to @xmath109 * * majority voting * : the colluders output the most common received symbol .",
    "this corresponds to @xmath110 * * minority voting * : the colluders output the least common received symbol .",
    "this corresponds to @xmath111 * * coin - flip attack * : if the pirates receive both symbols , they flip a fair coin to decide which symbol to output : @xmath112    using theorem  [ thm : dec - simple - informed ] we can now obtain exact , provable expressions for the code length @xmath9 in terms of @xmath113 . in general these expressions",
    "are quite ugly , but performing a taylor series expansion around @xmath114 for the optimal values of @xmath58 from ( * ? ? ?",
    "* section ii.a ) we obtain the following expressions for @xmath9 .",
    "note that @xmath115 .",
    "@xmath116 , \\label{eq : dec - simple - int } \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{all1 } } } ) & = \\frac{c \\ln\\left(\\frac{n}{{\\varepsilon}_1}\\right)}{\\ln(2)^2 }   \\left[\\frac{\\sqrt{\\gamma}\\left(1 + \\sqrt{\\gamma } - \\gamma\\right)\\ln 2}{1 - 2^{-\\sqrt{\\gamma } } } + o\\left(\\frac{1}{c}\\right)\\right ] , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{maj } } } ) & = \\pi c \\ln\\left(\\frac{n}{{\\varepsilon}_1}\\right ) \\left[\\frac{1 + \\sqrt{\\gamma } - \\gamma}{1 - \\sqrt{\\gamma } } + o\\left(\\frac{1}{c}\\right)\\right ] , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{coin } } } ) & = \\frac{4c}{\\ln(2)^2 } \\ln\\left(\\frac{n}{{\\varepsilon}_1}\\right ) \\\\   & \\times \\left[\\frac{\\sqrt{\\gamma } \\left(1 + \\sqrt{\\gamma } - \\gamma\\right ) \\ln 2 } { 2 - \\left(1+\\frac{1}{\\sqrt{2}}\\right)^{\\sqrt{\\gamma } } - \\left(1-\\frac{1}{\\sqrt{2}}\\right)^{\\sqrt{\\gamma } } } + o\\left(\\frac{1}{c}\\right)\\right].\\end{aligned}\\ ] ] if we assume that both @xmath117 and @xmath96 , then we can further simplify the above expressions for the code lengths .",
    "the first terms between brackets all scale as @xmath118 , so the code lengths scale as the terms before the square brackets .",
    "these code lengths match the capacities of @xcite .",
    "as for the score functions @xmath46 , let us highlight one attack in particular , the interleaving attack .",
    "the all-@xmath23 decoder will be discussed in section  [ sec : dec - simple - gt ] , while the score functions for other attacks can be computed in a similar fashion .",
    "for the interleaving attack , working out the probabilities in , we obtain the following score function : @xmath119      for group testing , we will consider three models : the classical ( noiseless ) model and the models with additive noise and dilution noise",
    ". other models where the probability of a positive test result only depends on the tally @xmath120 ( such as the threshold group testing models considered in  @xcite ) may be analyzed in a similar fashion .",
    "note that the classical model is equivalent to the all-@xmath23 attack in fingerprinting , as was previously noted in e.g.  @xcite .    *",
    "* classical model * : the test output is positive iff the tested pool contains at least one defective : @xmath109 * * additive noise model * : just like the classical model , but if no defectives are tested the result may still be positive : @xmath121 * * dilution noise model * : similar to the classical model , but the probability of a positive result increases with @xmath24 : @xmath122    we can again expand the expressions of theorem  [ thm : dec - simple - informed ] around @xmath114 for the optimal values of @xmath58 from ( * ? ? ?",
    "* section ii.b ) , but with the added parameter @xmath123 the resulting formulas are quite a mess .",
    "if we also let @xmath96 then we can use theorem  [ thm : dec - simple - asymptotics ] to obtain the following simpler expressions : @xmath124 , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{add } } } ) & = \\frac{c \\ln n}{\\ln(2)^2 - r \\ln 2 + o(r^2 ) } \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right ] , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{dil } } } ) & = \\frac{c \\ln n}{\\ln(2)^2 - o(r \\ln r ) } \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right].\\end{aligned}\\ ] ] for more detailed expressions for @xmath9 , one may combine theorems  [ thm : dec - simple - informed ] and [ thm : dec - simple - asymptotics ] with  ( * ? ? ?",
    "* section ii.b ) .",
    "for the classical model , working out the details we obtain the following result .",
    "[ thm : dec - simple - cla ] for the classical group testing model , the simple decoder for the optimal value @xmath125 is given by by a factor @xmath126 , and so also @xmath45 should be scaled by a factor @xmath126 . ]",
    "@xmath127 using this decoder in combination with the parameters @xmath45 and @xmath9 of theorem  [ thm : dec - simple - informed ] , we obtain a simple group testing algorithm with an optimal asymptotic number of group tests of @xmath128    this asymptotically improves upon results of e.g.  chan et al .",
    "@xcite who proposed an algorithm with an asymptotic code length of @xmath129 .",
    "their algorithm does have a guarantee of never falsely identifying a non - defective item as defective ( whereas our proposed decoder does not have this guarantee ) , but the price they pay is a higher asymptotic number of tests to find the defectives .",
    "while in the previous section we discussed simple decoders for the setting where @xmath26 is completely known to the decoder , let us now consider the setting which is more common in fingerprinting , where the attack strategy is not assumed known to the decoder .",
    "this setting may partially apply to group testing as well ( where there may be some unpredictable noise on the test outputs ) but the main focus of this section is the uninformed fingerprinting game .",
    "let us now try to investigate how to build a decoder that works against arbitrary attacks in fingerprinting .",
    "to build such a decoder , meerwald and furon  @xcite previously noted that abbe and zheng  @xcite proved in a more general context that under certain conditions on the set of allowed pirate strategies @xmath18 , a decoder that works against the worst - case attack @xmath130 also works against arbitrary other attacks @xmath131 . in this case",
    "the set of allowed pirate strategies we consider is the set of all attacks satisfying the marking assumption @xmath132 : @xmath133^{c + 1 } \\mid \\theta_0 = 0 , \\theta_c = 1\\}.\\end{aligned}\\ ] ]    for finite @xmath0 the worst - case attack in fingerprinting ( from an information - theoretic perspective ) has been studied in e.g.  @xcite , but in general this attack is quite messy and unstructured . since this attack is not so easy to analyze , let us therefore focus on the asymptotics of large @xmath0 and @xmath4 .",
    "huang and moulin  @xcite previously proved that for large coalitions , the optimal pirate attack is the interleaving attack . so combining this knowledge with the result of abbe and zheng ,",
    "perhaps a good choice for a universal decoder is the interleaving decoder , which we recall is given by : @xmath134 let us take a closer look at this decoder . for fixed @xmath135 , if we look at values @xmath136 $ ] and focus on the regime of large @xmath0",
    ", we can perform a taylor series expansion around @xmath114 to get @xmath137 .",
    "the resulting expressions then turn out to be closely related to oosterwijk et al.s  @xcite decoder @xmath138 : @xmath139 this implies that @xmath46 and @xmath138 are asymptotically equivalent for @xmath58 sufficiently far away from @xmath103 and @xmath23 . since for oosterwijk et al.s score function one generally uses _ cut - offs _ on @xmath14 ( i.e.  only using values @xmath136 $ ] for fixed @xmath135 ) to guarantee that @xmath140 ( cf .",
    "@xcite ) , and since the decoder of oosterwijk et al .",
    "is known to achieve capacity using these cut - offs , we immediately get the following result .    [ prop : dec - simple - uninformed ] the score function @xmath46 of together with the bias density function ( encoder ) @xmath141 on @xmath142 $ ] of the form @xmath143 asymptotically achieve the simple capacity for the uninformed fingerprinting game when the same cut - offs @xmath144 as those of  @xcite are used .    so combining the log - likelihood decoder tuned against the asymptotic worst - case attack ( the interleaving attack ) with the arcsine distribution with cut - offs , we obtain a universal decoder that works against arbitrary attacks .",
    "although proposition  [ prop : dec - simple - uninformed ] is already a nice result , the cut - offs @xmath144 have been a nagging inconvenience ever since tardos introduced them in 2003  @xcite . in previous settings it was well - known that this cut - off @xmath144 had to be large enough to guarantee that innocent users are not falsely accused , and small enough to guarantee that large coalitions can still be caught .",
    "for instance , when using tardos original score function , it was impossible to do without cut - offs , and the same seems to hold for oosterwijk et al.s decoder @xmath138 , since the scores blow up for @xmath145 .",
    "looking at the universal log - likelihood decoder , one thing to notice is that the logarithm has a kind of mitigating effect on the tails of the score distributions .",
    "for @xmath146 the resulting scores are roughly a factor @xmath0 smaller than those obtained with @xmath138 , but where the blow - up effect of @xmath138 for small @xmath58 is proportional to @xmath147 , the function @xmath46 only scales as @xmath148 in the region of small @xmath58 .",
    "this motivates the following claim , showing that with this decoder @xmath46 we finally do not need any cut - offs anymore !    [ thm : dec - simple - universal ] the decoder @xmath46 of and the encoder @xmath149 , defined on @xmath59 $ ] by @xmath150 together asymptotically achieve the simple capacity for the uninformed fingerprinting game .",
    "we will argue that using this new universal decoder @xmath46 , the difference in performance between using and not using cut - offs on @xmath14 is negligible for large @xmath0 .",
    "since the encoder with cut - offs asymptotically achieves capacity , it then follows that without cut - offs this scheme also achieves capacity .",
    "let us first prove that all moments of user scores are finite , even if no cut - offs are used .",
    "we will show that @xmath151 < \\infty$ ] for any @xmath152 and @xmath153 , so that after taking weighted combinations we also get @xmath154 .",
    "let us consider the case where @xmath155 ; other cases can be analyzed in the same way . using the density function @xmath156 of",
    ", we have @xmath157 \\\\   & = \\int_{0}^1 \\frac{dp}{\\pi \\sqrt{p(1-p ) } } \\log^k\\left(1 + \\frac{1 - p}{c p}\\right).\\end{aligned}\\ ] ] splitting the interval @xmath59 $ ] into two parts @xmath158 $ ] and @xmath159 $ ] ( where @xmath144 depends on @xmath160 but not on @xmath0 ) we obtain @xmath161 let us denote the two terms by @xmath162 and @xmath163 .",
    "for the first term , we can perform a taylor series expansion to obtain : @xmath164 here @xmath165 follows from considering sufficiently large @xmath0 while @xmath144 remains fixed .",
    "( note that for large @xmath0 we even have @xmath166 . ) for the other term we do not expand the logarithm : @xmath167 the last step @xmath168 follows from the fact that the integration is done over an interval of width @xmath144 , while the integrand scales as @xmath169 times some less important logarithmic terms . for arbitrary @xmath160 ,",
    "we can thus let @xmath170 as a function of @xmath160 to see that this is always bounded .",
    "similar arguments can be used to show that for other values of @xmath171 we also have @xmath172 < 0 $ ] .    as a result",
    ", all innocent and guilty user score moments are finite , and so for large @xmath0 from the central limit theorem it follows that the distributions of user scores will converge to gaussians .",
    "if the scores of innocent and guilty users are indeed gaussian for large @xmath0 , then as discussed in e.g.  @xcite all that matters for assessing the performance of the scheme are the mean and variance of both curves .",
    "similar to , the effects of small cut - offs on the distribution function @xmath14 are negligible as both means and variances stay the same up to small order terms .",
    "so indeed , in both cases the ` performance indicator '  @xcite asymptotically stays the same , leading to equivalent code lengths .",
    "note that the same result does _ not _ apply to the score function @xmath138 of oosterwijk et al .",
    "@xcite , for which the effects of values @xmath145 are not negligible .",
    "the main difference is that for small @xmath58 , the score function @xmath138 scales as @xmath147 ( which explodes when @xmath58 is really small ) , while the log - likelihood decoder @xmath46 only scales as @xmath173 .",
    "figure  [ fig : pdf ] illustrates the difference in the convergence of normalized innocent user scores to the standard normal distribution , when using the score functions @xmath46 and @xmath138 .",
    "these are experimental results for @xmath174 and @xmath175 based on @xmath176 simulated scores for each curve , and for both score functions we did not use any cut - offs .",
    "as we can see , using @xmath46 the normalized scores @xmath177 are close to gaussian , while using @xmath138 the curves especially do not look very gaussian for @xmath178 ; in most cases the distribution tails are much too large . for",
    "the minority voting attack the resulting curve does not even seem close to a standard normal gaussian distribution .      with the above result in mind ,",
    "let us now briefly discuss how to actually build a universal scheme with the interleaving decoder @xmath46 . from theorem  [ thm :",
    "dec - simple - universal ] it is clear that for generating biases we should use the arcsine distribution @xmath156 , and our decoder will be the interleaving decoder @xmath46 of  .",
    "what remains is figuring out how to choose @xmath9 and @xmath45 for arbitrary attacks .",
    "first , it is important to note that the expected innocent and guilty scores per segment ( @xmath179 and @xmath180 ) and the variance of the innocent and guilty scores ( @xmath181 and @xmath182 ) heavily depend on the collusion channel @xmath26 .",
    "this was not the case for tardos original decoder  @xcite and the symmetrized decoder  @xcite , for which @xmath45 could be fixed in advance regardless of the collusion strategy .",
    "this means that we will either have to delay fixing @xmath45 until the decoding stage , or scale / translate scores per segment accordingly at each position @xmath17 .    for choosing the code length @xmath9 and threshold @xmath45",
    "let us focus on the regime of reasonably large @xmath0 . in that case ,",
    "as argued above the total innocent and guilty scores will behave like gaussians , with parameters @xmath183 and @xmath184 .",
    "to distinguish between these two distributions , using e.g.  sanov s theorem the code rate @xmath185 should be proportional to the kullbeck - leibler divergence between the two distributions : @xmath186 a similar expression appears in @xcite , where it was noted that @xmath187 , so that the first term is the most important term .",
    "in @xcite the ratio @xmath188 was coined the ` performance indicator ' , and it was argued that this ratio should be maximized . in @xcite",
    "it was further shown that when using their decoder @xmath138 , this ratio is minimized by the pirates when they choose the interleaving attack @xmath189 . in other words : assuming scores are gaussian for large @xmath0 , the best attack the pirates can use is the interleaving attack when using @xmath138 as the decoder .",
    "since our new decoder @xmath46 is very similar to oosterwijk et al.s decoder @xmath138 ( by @xmath190 ) , a natural conjecture would be that also for this new score function , asymptotically the best pirate attack maximizing the decoder s error probabilities is the interleaving attack .",
    "experiments with @xmath46 and previous experiments of @xcite with @xmath138 indeed show that other pirate attacks ( such as those considered in section  [ sec : dec - simple - fp ] ) generally perform worse than the interleaving attack . as a result , a natural choice for selecting @xmath9 would be to base @xmath9 on the code length needed to deal with the ( asymptotic ) worst - case attack for this decoder , which we conjecture is the interleaving attack . and for the interleaving attack we know how to choose @xmath9 by theorem  [ thm : dec - simple - informed ] , equation  [ eq : dec - simple - int ] and theorem  [ thm : dec - simple - asymptotics ] : @xmath191 \\label{eq : ell - int - uni2 } \\\\",
    "& = 2 c^2 \\ln n \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c^2}\\right)\\right ] .",
    "\\label{eq : ell - int - uni3}\\end{aligned}\\ ] ] these choices for @xmath9 thus seem reasonable estimates for the code lengths required to deal with arbitrary attacks .    finally , for choosing @xmath45 , as argued before this parameter depends on the pirate strategy @xmath26 , which may lead to different scalings and translations of the curves of innocent and guilty user scores .",
    "what we could do is compute the parameters @xmath192 based on the pirate output @xmath193 and normalize the scores accordingly .",
    "this means that after computing user scores @xmath42 , we apply the following transformation : @xmath194 this guarantees that the scores of innocent users will roughly be distributed as @xmath195 , and for guilty users this results in a distribution of the form @xmath196 . to guarantee that the probability that an innocent user has a score below @xmath45 is at least @xmath197 , it then suffices to let @xmath198 where @xmath199 denotes the distribution function of the standard normal distribution @xmath195",
    "this means that after transforming the scores , the threshold can be fixed independent of the pirate strategy .",
    "besides oosterwijk et al.s lagrangian approach and our neyman - pearson - based approach to obtaining efficient decoders , let us now mention a third way to obtain a similar capacity - achieving universal decoder .    to construct this decoder ,",
    "we start with the empirical mutual information decoder proposed by moulin  @xcite , and for now let us assume @xmath200 is fixed is not fixed and is drawn from a continuous distribution function @xmath14 , the empirical probabilities considered below do not make much sense , as each value of @xmath201 only occurs once . in that case one could e.g.  build a histogram for the values of @xmath58 , and compute empirical probabilities for each bin , or discretize the distribution function for @xmath58  @xcite . ] . with this decoder , a user",
    "is assigned a score of the form @xmath202 and again the decision to accuse depends on whether this score exceeds some fixed threshold @xmath45 . here",
    "@xmath203 is the empirical estimate of the actual probability @xmath204 , i.e. , @xmath205 .",
    "writing out the empirical probability outside the logarithm , and replacing the summation over @xmath171 by a summation over the positions @xmath17 , this is equivalent to @xmath206 now , this almost fits the score - based simple decoder framework , except for that the terms inside the logarithm are not independent for different positions @xmath17 . to overcome this problem",
    ", we could try to replace the empirical probabilities @xmath203 by the actual probabilities @xmath204 , but to compute @xmath207 we need to know whether user @xmath11 is guilty or not . solving this final problem using bayesian inference ,",
    "we get the following result .    approximating the empirical probabilities in the empirical mutual information decoder with actual probabilities using bayesian inference ( with an a priori probability of guilt of @xmath208 )",
    ", this decoder corresponds to using the following score function @xmath209 : @xmath210\\right ) .",
    "\\label{eq : dec - simple - moulin1}\\end{aligned}\\ ] ]    the value of @xmath211 can be computed without any problems , so let us focus on the term @xmath212 . using bayesian inference , we have : @xmath213 assuming an a priori probability of guilt of @xmath208 and dividing by @xmath214 we get @xmath215 taking logarithms , this leads to the expression of .",
    "although this score function looks very similar to the log - likelihood decoder , there are some essential differences . for instance , for the all-@xmath23 attack we have @xmath216 while @xmath217 . for the interleaving attack , for which we may again hope to obtain a universal decoder using this approach",
    ", we do get a familiar result .",
    "[ thm : dec - simple - moulin ] for the interleaving attack , the bayesian approximation of the empirical mutual information decoder of satisfies @xmath218    for values of @xmath136 $ ] with @xmath135 and large @xmath0 , this decoder is again equivalent to both the log - likelihood score function @xmath46 and oosterwijk et al.s score function @xmath138 : @xmath219 for @xmath145 the logarithm again guarantees that scores do not blow up so much , but due to the factor @xmath4 in the denominator ( rather than a factor @xmath0 , as in @xmath46 ) the scores relatively increase more when @xmath58 approaches @xmath103 than for the score function @xmath46 .",
    "in this section we will discuss informed joint decoders which we conjecture are able to find pirates with shorter code lengths than simple decoders .",
    "the asymptotics of the resulting code lengths further motivate that these schemes may be optimal , but some open problems remain for proving that they are indeed optimal .    following the score - based framework for joint decoders of moulin  @xcite",
    ", we assign tuples @xmath220 of size @xmath0 a score of the form @xmath221 note that if @xmath26 is colluder - symmetric , then this is equivalent to @xmath222 where @xmath223 is the tally of the number of ones received by the tuple @xmath220 in position @xmath17 . for the accusation phase ,",
    "we now accuse all users in @xmath220 iff @xmath224 for some fixed threshold @xmath45 . note that this accusation algorithm is not exactly well - defined , since it is possible that a user appears both in a tuple that is accused and in a tuple that is not accused . for the analysis we will assume that the scheme is only successful",
    "if the single tuple consisting of all colluders has a score exceeding @xmath45 and no other tuples have a score exceeding @xmath45 , in which case all users in that guilty tuple are accused .",
    "this may be too pessimistic for evaluating the performance of the scheme .      for building a joint decoder we would like to be able to distinguish between the all - guilty tuple and other tuples , so a natural generalization of the hypotheses @xmath48 and @xmath49 for simple decoding would be to let @xmath225 and @xmath226 .",
    "however , with this choice of @xmath49 , computing probabilities @xmath227 is complicated : the event @xmath49 does not completely determine @xmath228 , since that depends on exactly how many colluders are present in @xmath220 . to be able to compute the likelihood ratios",
    ", we therefore use the following two hypotheses , which were also used in e.g.  @xcite : @xmath229 we again use the corresponding log - likelihood ratio per position as our score function @xmath46 , which is again the logarithm of the likelihood ratio over all positions @xmath17 : @xmath230 using this joint score function @xmath46 corresponds to a most powerful test according to the neyman - pearson lemma  @xcite , so @xmath46 is in a sense optimal for distinguishing between @xmath48 and @xmath49 .",
    "joint decoders of this form were previously considered in e.g.  @xcite .",
    "let us again study how to choose @xmath9 and @xmath45 such that we can prove that the false positive and false negative error probabilities are bounded from above by certain values @xmath55 and @xmath56 .",
    "below we will again make use of the function @xmath57 of where the simple hypotheses have been replaced by our new joint hypotheses @xmath48 and @xmath49 .",
    "[ thm : dec - joint - informed ] let @xmath58 and @xmath26 be fixed and known to the decoder .",
    "let @xmath231 , and let the code length @xmath9 and the threshold @xmath45 be defined as @xmath232 then with probability at least @xmath64 all all - innocent tuples are not accused , and with probability at least @xmath65 the single all - guilty tuple is accused .",
    "the proof is very similar to the proof of theorem  [ thm : dec - simple - informed ] .",
    "instead of @xmath4 innocent and @xmath0 guilty users we now have @xmath233 all - innocent tuples and just @xmath23 all - guilty tuple , which changes some of the numbers in @xmath85 , @xmath45 and @xmath9 above .",
    "we then again apply the markov inequality with @xmath77 and @xmath78 to obtain the given expressions for @xmath45 and @xmath9 .    for deterministic strategies @xmath234 ,",
    "choosing the scheme parameters is much simpler .",
    "similar to ( * ? ? ? * lemma 1 ) , where it was shown that for deterministic attacks the capacity is exactly @xmath235 , in this case we get a code length of roughly @xmath236 .    [ thm : dec - joint - deterministic ] let @xmath26 be a deterministic attack , and let @xmath58 be chosen such that @xmath237 .",
    "let @xmath9 and @xmath45 be chosen as : @xmath238 then with probability @xmath64 all all - innocent tuples will not be accused , and the single all - guilty tuple will _ always _ be accused .    for deterministic attacks , we have @xmath239 as a result , the score function @xmath46 satisfies @xmath240 with the capacity - achieving choice of @xmath58 of ( * ? ? ?",
    "* lemma 1 ) , we have @xmath241 for @xmath242 leading to a score of @xmath243 for a match , and @xmath244 for cases where @xmath245 does not match the output that follows from @xmath26 and the assumption that @xmath220 is the all - guilty tuple . for @xmath246 , clearly we will always have a match , so this tuple s score will always be @xmath247 , showing that this tuple is always accused .    for innocent tuples ,",
    "since @xmath248 it follows that in each position @xmath17 , with probability @xmath249 this tuple s score will not be @xmath244 .",
    "so with probability @xmath250 , the tuple s score after @xmath9 segments will not be @xmath244 , in which case it equals @xmath247 . to make sure that this probability is at most @xmath251 so that the total error probability is at most @xmath55 , we set @xmath252 , leading to the resulting expression for @xmath9",
    ".    note that for deterministic attacks , any choice of @xmath253 works just as well as choosing @xmath45 ; after @xmath9 segments all tuples will either have a score of @xmath244 or @xmath45 .",
    "theorem  [ thm : dec - joint - informed ] does not prove that we can actually find the set of colluders with high probability , since mixed tuples ( consisting of some innocent and some guilty users ) also exist and these may or may not have a score exceeding @xmath45 .",
    "theorem  [ thm : dec - joint - informed ] only proves that with high probability we can find a set @xmath82 of @xmath0 users which contains at least one colluder .",
    "basic experiments show that in many cases the only tuple with a score exceeding @xmath45 ( and thus the tuple with the highest score ) is the all - guilty tuple , and so all mixed tuples have a score below @xmath45 .",
    "proving that mixed tuples indeed get a score below @xmath45 is left as an open problem .      to further motivate why using this joint decoder may be the right choice , the following proposition shows that at least the resulting code lengths are optimal .",
    "the proof is analogous to the proof of theorem  [ thm : dec - simple - asymptotics ] .",
    "[ thm : dec - joint - asymptotics ] if @xmath254 then the code length @xmath9 of theorem  [ thm : dec - joint - informed ] scales as @xmath255,\\end{aligned}\\ ] ] thus asymptotically achieving an optimal scaling of the code length for arbitrary values of @xmath58 .",
    "since the asymptotic code length is optimal regardless of @xmath58 , these asymptotics are also optimal when @xmath58 is optimized to maximize the mutual information in the fully informed setting .    finally , although it is hard to estimate the scores of mixed tuples with this decoder , just like in  @xcite we expect that the joint decoder score for a tuple is roughly equal to the sum of the @xmath0 individual simple decoder scores .",
    "so a tuple of @xmath0 users consisting of @xmath160 colluders and @xmath256 innocent users is expected to have a score roughly a factor @xmath257 smaller than the expected score for the all - guilty tuple .",
    "so after computing the scores for all tuples of size @xmath0 , we can get rough estimates of how many guilty users are contained in each tuple , and for instance try to find the set @xmath82 of @xmath0 users that best matches these estimates .",
    "there are several options for post - processing that may improve the accuracy of using this joint decoder , which are left for future work .",
    "using theorem  [ thm : dec - joint - informed ] we can obtain exact expressions for @xmath9 in terms of @xmath113 .",
    "for the optimal values of @xmath58 of  ( * ? ? ?",
    "* section iii.a ) we can use theorem  [ thm : dec - joint - asymptotics ] to obtain the following expressions . note again that @xmath115 .",
    "@xmath258 , \\label{eq : dec - joint - int } \\\\ \\ell({{\\bm}{\\theta}_{\\text{all1 } } } ) & = c \\log_2 n \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right ] , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{maj } } } ) & = c \\log_2 n \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right ] , \\\\ \\ell({{\\bm}{\\theta}_{\\text{coin } } } ) & = c \\log_{5/4 } n \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right].\\end{aligned}\\ ] ] let us again highlight one resulting decoder in particular ; the one for the interleaving attack . in general we can rewrite the ratio inside the logarithm as follows : @xmath259 for the interleaving attack we further have @xmath260 and @xmath261 .",
    "this leads to the following joint decoder @xmath46 .",
    "this means that the joint scores are purely based on the similarities between the tuple tally @xmath24 and the expected tuple tally @xmath263 for each position @xmath17 . if a tuple s tally @xmath24 is larger than the expected tally @xmath263 , then the score is positive if @xmath264 and negative otherwise , while if @xmath24 is smaller than @xmath263 , then the score is positive if @xmath265 and negative otherwise . for innocent tuples",
    "this leads to an expected score of roughly @xmath103 , while for the guilty tuple this leads to a high ( positive ) expected score .",
    "similar to the above , for group testing models we can also use theorem  [ thm : dec - joint - informed ] to obtain exact expressions for @xmath9 in terms of @xmath113 with provable error bounds . for the optimal values of @xmath58 of  (",
    "* section iii.b ) we can use theorem  [ thm : dec - joint - asymptotics ] to obtain the following refined expressions .",
    "@xmath266 , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{add } } } ) & = \\frac{c \\log_2 n}{1 - \\frac{1}{2 } h(r ) + o(r^2 ) } \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right ] , \\\\",
    "\\ell({{\\bm}{\\theta}_{\\text{dil } } } ) & = \\frac{c \\log_2 n}{1 - \\frac{\\ln 2}{2 } h(r ) + o(r^2 ) } \\left[1 + o\\left(\\sqrt{\\gamma } + \\frac{1}{c}\\right)\\right].\\end{aligned}\\ ] ] note that as discussed in theorem  [ thm : dec - joint - deterministic ] the score function for the classical model is equivalent to simply checking whether some subset of @xmath0 items matches the test results , i.e.  whether these would indeed have been the test results , had this subset been the set of defectives . with high probability ,",
    "only the correct set of defectives passes this test .",
    "let us now again consider the more common setting in fingerprinting where the attack strategy @xmath26 is assumed unknown to the distributor . with the results for simple decoding in mind , and knowing that the interleaving attack is also the asymptotically optimal pirate attack in the joint fingerprinting game , we again turn our attention to the decoder designed against the interleaving attack .",
    "similar to the setting of simple decoding , explicitly proving that this decoder achieves the uninformed capacity is not so easy .",
    "however , through a series of reductions we can prove that this decoder is asymptotically capacity - achieving , for certain parameters @xmath9 and @xmath45 .",
    "[ thm : dec - joint - universal ] the joint log - likelihood decoder designed against the interleaving attack , using the score function @xmath46 defined by @xmath267 and the arcsine distribution encoder @xmath156 of   together asymptotically achieve the joint capacity for the uninformed fingerprinting game .",
    "first , the simple uninformed capacity is asymptotically equivalent to the joint uninformed capacity , which follows from results of huang and moulin  @xcite and oosterwijk et al .",
    "@xcite ( and section  [ sec : dec - simple ] ) .",
    "this means that the simple universal decoder of theorem  [ thm : dec - simple - universal ] already asymptotically achieves the joint capacity .",
    "we will prove that asymptotically , the proposed universal joint decoder is equivalent to the universal simple decoder of section  [ sec : dec - simple - universal ] , thus also achieving the joint uninformed capacity .",
    "suppose we have a tuple @xmath220 of size @xmath0 , and suppose in some segment @xmath17 there are @xmath24 users who received a @xmath23 and @xmath25 users who received a @xmath103 .",
    "for now also assume that @xmath136 $ ] for some @xmath135 that does not depend on @xmath0 . in case @xmath265",
    ", the combined simple decoder score of this tuple @xmath220 ( using the simple universal decoder @xmath46 of section  [ sec : dec - simple - universal ] ) would be : @xmath268 on the other hand , if we look at this tuple s joint score with the joint universal decoder @xmath46 of  , we have @xmath269 note that the last step follows from the fact that for large @xmath0 , with overwhelming probability we have @xmath270 ( since @xmath120 is binomially distributed with mean @xmath263 and variance @xmath271 ) , in which case @xmath272 . combining the above",
    ", we have that @xmath273 .",
    "so the joint universal decoder score for a tuple @xmath220 is asymptotically equivalent to the sum of the simple universal decoder scores for the members in this tuple , if @xmath136 $ ] .    since as argued before the distribution tails @xmath274 $ ] and @xmath275 $ ] are negligible for the performance of the scheme for sufficiently small @xmath144 , and since the same result holds for @xmath264 , the simple and joint decoders are asymptotically equivalent",
    ".    note that for the uninformed setting , the simple and joint capacities are asymptotically equivalent , which allowed us to prove the result . for finite @xmath0",
    "the joint capacity may be slightly higher than the simple capacity , but the fact that they are asymptotically the same does show that there is not as much to gain with joint decoders as there is with e.g.  joint group testing decoders , where the joint capacity is asymptotically a factor @xmath276 higher than the simple capacity . and since assigning joint scores to all tuples of size @xmath0 for each position @xmath17 is computationally very involved ( and since the resulting joint scores are very similar to the sum of simple universal scores anyway ) a more practical choice seems to be to use the simple universal decoder of section  [ sec : dec - simple - universal ] instead .",
    "let us now briefly discuss the main results in this paper and their consequences .      for the setting of simple decoders with known collusion channels @xmath26 , we have shown how to choose the score functions @xmath46 in the score - based framework , as well as how to choose the threshold @xmath45 and code length @xmath9 to guarantee that certain bounds on the error probabilities are met . with log - likelihood decoders",
    ", we showed that these decoders achieve capacity _ regardless of @xmath58 and regardless of @xmath26_. this means that no matter which pirate strategy @xmath26 and bias @xmath58 you plug in , this construction will always achieve the capacity corresponding to those choices for @xmath26 and @xmath58 .",
    "a trivial consequence is that for the optimal values of @xmath58 derived in  @xcite , one also achieves the optimal code length for arbitrary @xmath58 .",
    "since in fingerprinting it is usually more common to assume that @xmath26 is unknown , we then turned our attention to the uninformed setting .",
    "we showed that the decoder designed against the interleaving attack , with the score function @xmath46 given by @xmath277 is actually a universal decoder , and achieves the uninformed fingerprinting capacity .",
    "we also showed how the proposed universal decoder is very similar to both oosterwijk et al.s decoder @xmath138 and an approximation of moulin s empirical mutual information decoder @xmath209 for @xmath146 by @xmath278 and we highlighted the differences between these decoders for @xmath145 .",
    "we argued that the proposed decoder @xmath46 is the most natural choice for a universal decoder ( motivated from the neyman - pearson lemma ) , and that it has some practical advantages compared to oosterwijk et al.s decoder @xmath138 , such as finally being able to get rid of the cut - offs @xmath144 on the density function @xmath14 .      in sections  [ sec : dec - joint ] and",
    "[ sec : dec - joint - universal ] we then turned our attention to joint decoders , which have the potential to significantly decrease the required code length @xmath9 at the cost of a higher decoding complexity .",
    "we considered a natural generalization of the simple decoders to joint decoders , and argued that our choice for the joint score functions @xmath46 seems to be optimal .",
    "there are still some gaps to fill here , since we were not able to prove how scores of mixed tuples ( tuples containing some innocent and some guilty users ) behave , and whether their scores also stay below @xmath45 with high probability . on the other hand , for deterministic attacks",
    "it is quite easy to analyze the behavior of these decoders , and for arbitrary attacks we did show that the code lengths have the optimal asymptotic scaling .",
    "finally , for the uninformed setting with joint decoders , we proved that the joint interleaving decoder achieves the joint uninformed capacity .",
    "since the joint uninformed capacity is asymptotically the same as the simple uninformed capacity , and since joint decoding generally has a much higher computational complexity than simple decoding , this decoder may not be as practical as the proposed simple universal decoder .",
    "finally , let us finish by mentioning some open problems which are left for future work .",
    "while in section  [ sec : dec - simple - universal ] we showed that the new simple universal decoder achieves capacity and how one should roughly choose the code length @xmath9 and threshold @xmath45 , we did not provide any provable bounds on the error probabilities for the uninformed setting . for earlier versions of tardos scheme various papers analyzed such provable bounds  @xcite and a similar analysis",
    "could be done for the log - likelihood decoder designed against the interleaving attack .",
    "perhaps such an analysis may once and for all establish the best way to choose the scheme parameters in universal fingerprinting .",
    "although this paper focused on applications to the ` static ' fingerprinting game , in some settings the feedback @xmath93 may be obtained in real - time .",
    "for instance , in pay - tv pirates may try to duplicate a fingerprinted broadcast in real time , while in group testing it may sometimes be possible to do several rounds of group testing sequentially .",
    "the construction of  @xcite can trivially be applied to the decoders in this paper as well to build efficient dynamic fingerprinting schemes with the same asymptotics for the code lengths , but where ( i ) the order terms in @xmath9 are significantly smaller ; ( ii ) one can provably catch _ all _ pirates regardless of the ( asymmetric ) pirate strategy ; and ( iii ) one does not necessarily need to know ( a good estimate of ) @xmath0 in advance  ( * ? ? ?",
    "* section  v ) .",
    "an important open problem remains to determine the dynamic uninformed fingerprinting capacity , which may prove or disprove that the construction of  @xcite combined with the universal decoder @xmath46 of section  [ sec : dec - simple - universal ] is asymptotically optimal .      in this work we focused on the binary case of @xmath10 different symbols for generating the code @xmath8 , but in ( universal ) fingerprinting it may be advantageous to work with larger alphabet sizes @xmath279 , since the code length decreases linearly with @xmath280  @xcite .",
    "this generalization to @xmath280-ary alphabets was considered in e.g.  @xcite . for the results in this paper we did not really use that we were working with a binary alphabet",
    ", so it seems a straightforward exercise to prove that the @xmath280-ary versions of the log - likelihood decoders also achieve the @xmath280-ary capacities .",
    "a harder problem seems to be to actually compute these capacities in the various informed settings , since the maximization problem involved in computing these capacities then transforms from a one - dimensional optimization problem to a @xmath281-dimensional optimization problem .",
    "the author is grateful to pierre moulin for his comments during the author s visit to urbana - champaign that lead to the study of the empirical mutual information decoder of theorem  [ thm : dec - simple - moulin ] and that eventually inspired work on this paper .",
    "the author further thanks jeroen doumen , teddy furon , jan - jaap oosterwijk , boris kori , and benne de weger for valuable discussions and comments regarding earlier versions of this manuscript .",
    "chan , p.  h.  che , s.  jaggi , and v.  saligrama ,  non - adaptive probabilistic group testing with noisy measurements : near - optimal bounds with efficient algorithms , \" _",
    "49th allerton conference on communication , control , and computing _ , pp .  18321839 , 2011 .",
    "chan , s.  jaggi , v.  saligrama , and s.  agnihotri ,  non - adaptive group testing : explicit bounds and novel algorithms , \" _ ieee international symposium on information theory ( isit ) _ , pp .  18371841 , 2012 .",
    "m.  cheraghchi , a.  hormati , a.  karbasi , and m.  vetterli ,  group testing with probabilistic tests : theory , design and application , \" _ ieee transactions on information theory _ , vol .",
    "57 , no .",
    "10 , pp .  70577067 , 2011 .",
    "y .- w .  huang and p.  moulin ,  on the saddle - point solution and the large - coalition asymptotics of fingerprinting games , \" _ ieee transactions on information forensics and security _ , vol .  7 , no .  1 , pp .  160175 , 2012 .",
    "t.  laarhoven ,  capacities and capacity - achieving decoders for various fingerprinting games , \" _ acm workshop on information hiding and multimedia security ( ih&mmsec ) _ , 2014 .",
    "this is a preliminary version of the present paper .",
    "j.  neyman and e.  s.  pearson ,  on the problem of the most efficient tests of statistical hypotheses , \" _ philosophical transactions of the royal society a : mathematical , physical and engineering sciences _ , vol .",
    "231 , pp .  289337 , 1933 .",
    "k.  nuida , s.  fujitsu , m.  hagiwara , t.  kitagawa , h.  watanabe , k.  ogawa , and h.  imai ,  an improvement of discrete tardos fingerprinting codes , \" _ designs , codes and cryptography _ , vol .  52 , no .  3 , pp .",
    "339362 , 2009 .",
    "d.  sejdinovic and o.  johnson ,  note on noisy group testing : asymptotic bounds and belief propagation reconstruction , \" _",
    "48th allerton conference on communication , control , and computing ( allerton ) _ , pp .  9981003 , 2010 .",
    "d.  r.  stinson , t.  van  trung , and r.  wei ,  secure frameproof codes , key distribution patterns , group testing algorithms and related structures , \" _ journal of statistical planning and inference _ , vol .",
    "86 , no .  2 , pp .",
    "595617 , 2000 ."
  ],
  "abstract_text": [
    "<S> we study the large - coalition asymptotics of fingerprinting and group testing , and derive explicit decoders that provably achieve capacity for many of the considered models . </S>",
    "<S> we do this both for simple decoders ( fast but suboptimal ) and for joint decoders ( slow but optimal ) , and both for informed and uninformed settings .    for fingerprinting , we show that if the pirate strategy is known , the neyman - pearson - based log - likelihood decoders provably achieve capacity , regardless of the strategy . the decoder built against the interleaving attack </S>",
    "<S> is further shown to be a universal decoder , able to deal with arbitrary attacks and achieving the uninformed capacity . </S>",
    "<S> this universal decoder is shown to be closely related to the lagrange - optimized decoder of oosterwijk et al .  and the empirical mutual information decoder of moulin . </S>",
    "<S> joint decoders are also proposed , and we conjecture that these also achieve the corresponding joint capacities .    for group testing , the simple decoder for the classical model is shown to be more efficient than the one of chan et al .  and </S>",
    "<S> it provably achieves the simple group testing capacity . for generalizations of this model such as noisy group testing </S>",
    "<S> , the resulting simple decoders also achieve the corresponding simple capacities .    </S>",
    "<S> fingerprinting , traitor tracing , group testing , log - likelihood ratios , hypothesis testing . </S>"
  ]
}