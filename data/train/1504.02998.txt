{
  "article_text": [
    "let @xmath0 be a finitely generated subsemigroup of @xmath1 , that is , an _ affine semigroup_. we are interested in studying the factorization structure of elements @xmath2 , that is , the distinct expressions of @xmath3 as a sum of the generators @xmath4 .",
    "most of the theory on nonunique factorization stems from the study of factorizations in integral domains ; in this context , one can view factorizations of affine semigroup elements as factorizations of monomials in the corresponding monoid algebra @xmath5 $ ] for @xmath6 a field .",
    "often , factorization structure is examined using factorization invariants , which assign quantities to each element of @xmath7 ( or to @xmath7 as a whole ) that measure the failure of its factorizations to be unique @xcite .",
    "every affine semigroup @xmath7 is an _",
    "ff - monoid _ , meaning that each element @xmath2 has only finitely many factorizations .",
    "as such , many factorization invariants can be computed explicitly using computer software @xcite , an attribute that has greatly aided their study @xcite . on the other hand ,",
    "the class of affine semigroups is sufficiently broad to exhibit varied factorization structure , and remains an interesting source of examples and an active area of study .    in this paper",
    ", we present new algorithms for computing several well - studied factorization invariants . after some preliminary definitions in section  [ sec : background ] , we present in section  [ sec : deltaset ] the first known algorithm for computing the delta set of an affine semigroup .",
    "two distinct approaches are given ( algorithms  [ a : affinedeltahilbert ] and  [ a : affinedeltagb ] ) , the latter of which introduces a novel connection between the delta set and grbner bases of homogeneous toric ideals ( see remark  [ r : affinedeltagb ] ) .",
    "next , we give algorithm  [ a : dynamiccatenary ] for dynamically computing catenary degrees of affine semigroup elements , in the style of several known algorithms for other factorization invariants @xcite .",
    "we conclude with an improved algorithm for computing the tame degree of an affine semigroup in section  [ sec : tamedegree ] .    following the statement and proof of correctness of each algorithm",
    ", we discuss implementation in the ` gap ` @xcite package ` numericalsgps ` @xcite , including sample code and benchmark comparisons with existing algorithms . whenever a grbner basis ( definition  [ d : grobnerbasis ] ) or a hilbert basis ( definition  [ d : hilbertbasis ] ) must be computed , our implementations rely on trusted software packages like ` 4ti2 `  @xcite , ` normaliz `  @xcite , and ` singular `  @xcite .",
    "in what follows , let @xmath8 denote the set of non - negative integers . fix a field @xmath6 , and let @xmath9 $ ] denote the polynomial ring in commuting variables @xmath10 with coefficients in @xmath6 .",
    "lastly , for @xmath11 we use the shorthand @xmath12 $ ] .",
    "[ d : affine ] a semigroup @xmath13 is _ affine _ if it is finitely generated . if @xmath14 and @xmath15 , we say @xmath7 is a _ numerical semigroup_.    [ r : minimalgenerators ] any affine semigroup @xmath7 is reduced , and thus has a unique generating set that is minimal with respect to containment . throughout this paper , whenever we write @xmath16 , we assume @xmath4 are precisely the minimal generators of @xmath7 .",
    "[ d : hilbertbasis ] fix a matrix @xmath17 .",
    "the set @xmath18 of nonnegative integer homogeneous solutions of @xmath19 forms an affine semigroup .",
    "the minimal generating set of @xmath7 ( w.r.t .",
    "containment ) is called the _ hilbert basis _ of @xmath19 , denoted @xmath20 .",
    "[ d : factset ] fix an affine semigroup @xmath0 .",
    "the elements @xmath4 comprising the unique minimal generating set of @xmath7 are called _ irreducible _ elements ( or _ atoms _ ) .",
    "a _ factorization _ of @xmath2 is an expression @xmath21 of @xmath3 as a finite sum of atoms , which we denote by the @xmath22-tuple @xmath23 .",
    "write @xmath24 for the _ set of factorizations _ of @xmath2 , viewed as a subset of @xmath25 .    since @xmath26 generate @xmath7 , the monoid homomorphism @xmath27 given by @xmath28 is surjective , and @xmath29 , where @xmath30 denotes the _ kernel _ of @xmath31 .",
    "notice that @xmath32 is a _ congruence _ on @xmath33 ( i.e.  an equivalence relation that is closed under translation ) , and thus it is finitely generated ( see @xcite ) . in particular , there exists a finite set @xmath34 such that the smallest congruence containing @xmath35 is @xmath32 ( equivalently , @xmath32 equals the intersection of all congruences containing @xmath35 ) .",
    "[ d : minimalpresentation ] a _ minimal presentation _ of @xmath7 is a generating set @xmath35 of the congruence @xmath32 that is minimal with respect to containment .",
    "betti elements _ of @xmath7 are elements of the form @xmath36 for @xmath37 ( this is independent of the minimal presentation chosen ) .",
    "[ d : graverbasis ] fix @xmath0 , and let @xmath38 denote the matrix with columns @xmath4 .",
    "the _ graver basis _ of @xmath19 ( or the _ graver basis _ of @xmath7 ) is the hilbert basis of the matrix @xmath39 .",
    "[ r : graverminpres ] the graver basis of a semigroup @xmath7 contains every minimal presentation of @xmath7 , but is typically orders of magnitude larger . even for numerical semigroups with 3 minimal generators , whose minimal presentations have at most 3 relations , the graver basis can be arbitrarily large .",
    "as such , algorithms relying on a proper subset of the graver basis ( such as a minimal presentation or a grbner basis ) are preferred whenever possible .",
    "[ e : minimalpresentation ] let @xmath40 .",
    "the minimal presentation of @xmath7 is @xmath41 as computed in ( * ? ? ?",
    "* example 8.23 ) . in this case",
    ", @xmath35 is the only minimal presentation of @xmath7 , though minimal presentations need not be unique in general .",
    "for comparison , the graver basis of @xmath7 consists of ( upon omitting symmetry ) the pairs @xmath42    we associate to @xmath7 an ideal @xmath43 $ ] defined as follows .",
    "consider the polynomial ring @xmath44 $ ] , and more specifically the subring @xmath5 = \\bigoplus_{\\gamma \\in \\gamma } \\mathbb{k } t^\\gamma$ ] . in this",
    "setting , @xmath31 has a polynomial ring counterpart , namely the ring homomorphism @xmath45\\to \\mathbb k[\\gamma]\\ ] ] determined by @xmath46 .",
    "the _ defining ideal _ of @xmath7 is the kernel @xmath47.\\ ] ] it is well known that a set @xmath48 generates @xmath32 as a congruence if and only if @xmath49 generates @xmath50 , and that @xmath35 is a minimal presentation for @xmath7 precisely when the above set irredundantly generates @xmath50 ( see @xcite ) .",
    "we conclude this section with a brief discussion of grbner bases , which are standard in computational commutative algebra ; the unfamiliar reader is encouraged to consult  @xcite for a more thorough overview .",
    "[ d : grobnerbasis ] fix a monomial order @xmath51 on @xmath9 $ ] ( that is , a total ordering of the monomials containing the usual partial ordering by divisibility ) . given @xmath52 $ ] , denote by @xmath53 the _ initial term _ of @xmath54 with respect to @xmath51 .",
    "a _ grbner basis _ of an ideal @xmath55 $ ] with respect to @xmath51 is a set @xmath56 generating @xmath57 such that @xmath58 .    [",
    "r : elimination ] minimal presentations can be computed using grbner bases . set @xmath59,\\ ] ] and observe that @xmath60 $ ] . to compute a generating set for @xmath50",
    ", one can compute a grbner basis @xmath61 for @xmath62 with respect to any monomial ordering @xmath51 satisfying @xmath63 for all possible @xmath64 and @xmath65 , and then calculate @xmath66 $ ] .",
    "in this section , we introduce algorithms  [ a : affinedeltahilbert ] and  [ a : affinedeltagb ] , the first known algorithms for computing the delta set of any affine semigroup , as well as proofs of correctness ( theorems  [ t : affinedeltahilbert ] and  [ t : affinedeltagb ] , respectively ) . both algorithms have theorem  [ t : deltahilbert ] at their core , but each uses a different method for computing the necessary ideal generating sets .    [",
    "d : deltaset ] fix an affine semigroup @xmath0 and @xmath2 . given @xmath67 ,",
    "the _ length _ of @xmath68 is the number @xmath69 of irreducibles in @xmath68 .",
    "the _ length set _ of @xmath3 is @xmath70 the set of factorization lengths",
    ". writing @xmath71 , the _ delta set _ of @xmath3 is the set @xmath72 of successive differences of factorization lengths .",
    "delta set of @xmath7 _ is @xmath73 .",
    "theorem  [ t : minmaxdeltaset ] follows from ( * ? ? ?",
    "* corollary 2.4 , thoerem 2.5 ) , and describes which delta set elements can be easily recovered from a minimal presentation .",
    "[ t : minmaxdeltaset ] if @xmath0 and @xmath74 is a minimal presentation of @xmath7 , then @xmath75 @xmath76 and @xmath77\\cap \\min\\delta(\\gamma)\\mathbb z.\\ ] ] in particular , @xmath78 , and both @xmath79 and @xmath80 can be quickly recovered from @xmath35 .",
    "[ e : deltaset ] let us return to @xmath81 from example  [ e : minimalpresentation ] . according to theorem  [ t : minmaxdeltaset ] , the minimum and maximum of @xmath82",
    "are determined by @xmath83 , @xmath84 and @xmath85 .",
    "the only factorizations of @xmath86 are @xmath87 and @xmath88 , so @xmath89 .",
    "we can obtain @xmath90 similarly .",
    "as such , @xmath91 , since in this case @xmath92 .",
    "in general , however , theorem  [ t : minmaxdeltaset ] only yields an interval containing @xmath82 .",
    "[ r : deltadifficulty ] the primary difficulty in computing @xmath82 for a general affine semigroup @xmath7 is ensuring that a given value does _ not _ occur in @xmath82 .",
    "indeed , some elements of @xmath82 may only occur in the delta sets of a small ( finite ) number of semigroup elements .",
    "for example , if @xmath93 , then @xmath94 only occurs in @xmath95 , @xmath96 , and @xmath97 .    as such , although it is computationally feasible to compute the delta set of any single element of @xmath7 ( since each has only finitely many factorizations ) , this can not be accomplished for all of the ( infinitely many ) elements of @xmath7 . to date , all existing delta set algorithms are limited to numerical semigroups , and act by bounding the semigroup elements for which `` new '' elements of @xmath82 can occur , thus restricting computation to a finite list of semigroup elements ; see @xcite for more detail .",
    "one of the primary benefits of algorithm  [ a : affinedeltahilbert ] is that it does not rely on computing delta sets of individual semigroup elements . as such , both of our algorithms are generally much faster than existing algorithms for numerical semigroups ; see examples  [ e : affinedeltahilbert ] and  [ e : affinedeltagb ] .",
    "we now state theorem  [ t : deltahilbert ] , the main theoretical result used in algorithm  [ a : affinedeltahilbert ] .",
    "[ t : deltahilbert ] suppose @xmath0 .",
    "the ideals @xmath98\\ ] ] for @xmath99 form an ascending chain @xmath100 in which @xmath101 if and only if @xmath102 .    algorithm  [ a : affinedeltahilbert ] obtains the delta set of a given affine semigroup @xmath0 by computing each ideal defined in theorem  [ t : deltahilbert ]",
    ". the generating set of @xmath103 appearing in theorem  [ t : deltahilbert ] is determined by ( integer solutions to ) a system of linear inequalities , and thus can be computed using a hilbert basis .",
    "for example , by inserting a slack variable to transform the single inequality to an equality , it suffices to compute a hilbert basis for the matrix @xmath19 below .",
    "each element @xmath104 of the hilbert basis with @xmath105 yields a binomial generator @xmath106 for @xmath103 by lemma  [ l : affinedeltahilbert ] .",
    "@xmath107    once each generating set has been computed , successive ideals @xmath108 can be checked for strict containment by computing a reduced grbner basis for each ideal ( with respect to the same term order ) and then comparing .",
    "the final step in the algorithm is locating the maximal value of @xmath65 , which by theorem  [ t : minmaxdeltaset ] can be obtained by computing a minimal presentation for @xmath7 .",
    "note that each element of @xmath82 is a multiple of @xmath79 , which by theorem  [ t : minmaxdeltaset ] can also be obtained from a minimal presentation for @xmath7 .",
    "we are now ready to state algorithm  [ a : affinedeltahilbert ] .",
    "[ a : affinedeltahilbert ] computes the delta set of an affine semigroup @xmath0 .",
    "@xmath109 minimal presentation for @xmath7 @xmath110 @xmath111 @xmath112 hilbert basis for @xmath113 @xmath114 grbner basis for @xmath115 $ ] @xmath116 @xmath114 grbner basis for @xmath117 @xmath118    we now give a proof that algorithm  [ a : affinedeltahilbert ] gives the correct output .",
    "[ l : affinedeltahilbert ] resume notation from theorem  [ t : deltahilbert ] and algorithm  [ a : affinedeltahilbert ] . the ideal @xmath119\\ ] ] computed in algorithm  [ a : affinedeltahilbert ] coincides with the ideal @xmath103 from theorem  [ t : deltahilbert ] for all @xmath99 .    for each @xmath105 and @xmath120",
    ", it is clear that @xmath121 , so @xmath122 .",
    "conversely , if @xmath123 with @xmath124 , then @xmath125 which is the binomial corresponding to @xmath126 .",
    "this means the generating set for @xmath103 given in theorem  [ t : deltahilbert ] can be restricted to the binomials corresponding to elements of the hilbert basis @xmath127 , so @xmath128 as well .",
    "[ t : affinedeltahilbert ] for any affine semigroup @xmath13 , algorithm  [ a : affinedeltahilbert ] returns @xmath82 .",
    "resume notation from theorem  [ t : deltahilbert ] and algorithm  [ a : affinedeltahilbert ] .",
    "theorem  [ t : minmaxdeltaset ] implies that @xmath129 , and that only multiples of @xmath130 can appear in @xmath82 .",
    "lemma  [ l : affinedeltahilbert ] ensures each loop iteration computes the ideal @xmath103 for some multiple @xmath65 of @xmath130 , and appends @xmath65 to @xmath118 if @xmath131 .",
    "applying theorem  [ t : deltahilbert ] completes the proof .",
    "algorithm  [ a : affinedeltagb ] uses an alternative approach to compute generators for the ideals @xmath103 in theorem  [ t : deltahilbert ] .",
    "given @xmath132 , denote by @xmath133 the element in @xmath134 whose first coordinate is  1 and whose remaining coordinates are those in @xmath135 .",
    "for @xmath0 , set @xmath136 there is a tight relation between factorizations in @xmath137 and those in @xmath7 @xcite .",
    "observe that @xmath138.\\ ] ] algorithm  [ a : affinedeltagb ] exploits this idea to compute the generators @xmath103 in theorem [ t : deltahilbert ] .",
    "as there is no need to compute a graver basis ( see remark  [ r : graverminpres ] ) , algorithm  [ a : affinedeltagb ] is better equipped than algorithm  [ a : affinedeltahilbert ] to handle input with large generators ( see example  [ e : affinedeltahilbert ] ) .",
    "[ a : affinedeltagb ] computes the delta set of an affine semigroup @xmath0 .",
    "@xmath109 minimal presentation for @xmath139 @xmath114 reduced lex grbner basis for @xmath140 $ ] @xmath141    [ t : affinedeltagb ] fix @xmath0 an affine semigroup .",
    "let @xmath61 denote a reduced grbner basis for @xmath142 with respect to any lexicographic term order satisfying @xmath143 for each @xmath144 , and for @xmath99 let @xmath145 we have @xmath146 for each @xmath99 .",
    "each generator of @xmath147 certainly lies in @xmath103 , so @xmath122 .",
    "conversely , fix @xmath121 with @xmath148 , and let @xmath149 . by definition ,",
    "@xmath150 , so performing polynomial long division by @xmath61 yields a remainder of 0 . since @xmath61 was computed using a lex term order , the only elements of @xmath61 used in the division algorithm have leading term dividing @xmath151 , and thus correspond to generators of @xmath147 .",
    "as such , @xmath128 .",
    "the final claim follows from @xmath61 being reduced , since the initial term @xmath152 of each @xmath153 can not be divisible by the leading term of any other elements of @xmath61 , including those corresponding to generators of @xmath154 .",
    "[ c : affinedeltagb ] fix @xmath0 an affine semigroup .",
    "if @xmath61 is a reduced grbner basis for @xmath142 with respect to any lexicographic term order satisfying @xmath143 for @xmath144 , then @xmath155    [ r : affinedeltagb ] in addition to ensuring the correctness of algorithm  [ a : affinedeltagb ] , corollary  [ c : affinedeltagb ] is also interesting from a theoretical perspective , as it expresses the delta set in terms of grbner bases of homogeneous toric ideals .",
    "the authors are optimistic that this novel connection will spur interest in the delta set from members of the computational algebra community .",
    "we implemented both algorithms above in ` gap ` to compare their performance to existing methods . in our implementation of algorithm",
    "[ a : affinedeltahilbert ] , we used ` normaliz ` @xcite through ` normalizinterface ` @xcite for the calculation of the hilbert basis @xmath127 , and ` singular ` @xcite via the ` gap ` package ` singular ` @xcite for the computation of successive grbner bases .",
    "although we did some experiments with ` 4ti2 ` @xcite via @xcite for the calculation of @xmath127 , the resulting implementation was slower than with ` normaliz ` ; additionally , one can not use ` 4ti2 ` for grbner basis computations here since the ideals are not toric .",
    "[ e : affinedeltahilbert ] for numerical semigroups , the algorithm used in the ` numericalsgps ` @xcite package is the one presented in @xcite , which was the fastest known prior to those given above .",
    "though it only works with numerical semigroups , we can still compare how it behaves against algorithm [ a : affinedeltahilbert ] .",
    "a log - time algorithm has also been given for numerical semigroups with 3  minimal generators  @xcite , but the techniques used therein do not easily generalize .    in examples with `` small '' generators ,",
    "algorithm  [ a : affinedeltahilbert ] outperforms ` deltasetofnumericalsemigroup ` ( the current implementation in ` numericalsgps ` ) . for instance , the calculation of @xmath156 takes 550  ms with the current implementation , compared to 50  ms with algorithm [ a : affinedeltahilbert ] .",
    "additionally , the current implementation takes 415263  ms to compute @xmath157 , while algorithm [ a : affinedeltahilbert ] accomplishes this task in under 4 seconds .    for semigroups with large generators , the situation can differ .",
    "choosing , for instance , @xmath158 , ` deltasetofnumericalsemigroup ` computes @xmath82 in less than  two  minutes , whereas the processes running ` normaliz ` completed algorithm  [ a : affinedeltahilbert ] in around three minutes , even when run with ` scip `  @xcite ( ` 4ti2 ` was killed after half an hour ) .",
    "one of the advantages of algorithm  [ a : affinedeltagb ] is that one can use either ` singular ` ( ` eliminate ( ) ` ) or ` 4ti2 ` ( ` groebner ( ) ` ) to compute a grbner basis for @xmath142 , with comparable performance .",
    "[ e : affinedeltagb ] all delta sets appearing in example [ e : affinedeltahilbert ] were computed with algorithm  [ a : affinedeltagb ] in less than 20  ms . even for significantly larger examples such as @xmath159 @xmath160 computes in less than a minute .",
    "the catenary degree is a factorization invariant that measures how spread out the factorizations of an element are .",
    "recent results prove the catenary degree is eventually periodic for numerical semigroups @xcite , and a natural generalization is given for affine semigroups @xcite , but neither result gives a concrete bound for the start of periodic behavior ( in contrast to similar results for several other invariants ; see  ( * ? ? ?",
    "* remark  5.11 ) ) . in this section ,",
    "we give algorithm  [ a : dynamiccatenary ] for computing the catenary degree of affine semigroup elements using dynamic programming , answering ( * ? ? ?",
    "* problem  5.12 ) .",
    "the primary motivation for such an algorithm is to aid the investigation of concrete bounds for the aforementioned eventual behavior results , and our approach mirrors several existing algorithms for other factorization invariants @xcite .",
    "[ d : catenarydegree ] fix @xmath0 and @xmath2 .",
    "the _ greatest common divisor _ of @xmath161 is given by @xmath162 and the _ distance _ between @xmath68 and @xmath163 ( or the _ weight _ of @xmath164 ) is defined as @xmath165 given @xmath161 and @xmath166 , an _ @xmath167-chain _ from @xmath68 to @xmath163 is a sequence @xmath168 of factorizations of @xmath3 such that ( i )  @xmath169 , ( ii )  @xmath170 , and ( iii )  @xmath171 for all @xmath172 .",
    "the  _ weight _ of @xmath173 is the smallest @xmath167 such that @xmath173 is an @xmath167-chain ( or , equivalently , the largest distance between successive factorizations ) .",
    "the _ catenary degree _ of @xmath3 , denoted @xmath174 , is the smallest @xmath167 such that there exists an @xmath167-chain between any two factorizations of @xmath3 .",
    "[ e : catenarydegree ] consider the numerical semigroup @xmath175 .",
    "the left - hand picture in figure  [ fig : catenarydegree ] depicts @xmath176 and all pairwise distances .",
    "any two factorizations of 450 are connected by a 16-chain ; one such chain between @xmath177 and @xmath178 is depicted with bold red edges .",
    "every 16-chain between @xmath68 and @xmath163 contains the bottom edge , so @xmath179 .",
    "the catenary degree can also be computed by examining edges with weight at most 16 , as depicted in the right - hand picture of figure  [ fig : catenarydegree ] .",
    "removing edges labeled 8 and 12 yields a ( minimal total weight ) spanning tree , at which point lemma  [ l : spanningtreecatenary ] implies @xmath179 .     in @xmath175 from example  [ e :",
    "catenarydegree ] .",
    "both graphics were created using the computer algebra system ` sage ` @xcite.,title=\"fig:\",width=240 ]   in @xmath175 from example  [ e : catenarydegree ] .",
    "both graphics were created using the computer algebra system ` sage ` @xcite.,title=\"fig:\",width=240 ]    the graph theoretic description of the catenary degree evident in example  [ e : catenarydegree ] is one of the core structures used in algorithm  [ a : dynamiccatenary ] .",
    "we now make this definition explicit .",
    "[ d : catenarygraph ] given @xmath2 , the _ catenary graph _ of @xmath3 is the complete graph @xmath180 with @xmath181 whose edges are labeled by the distance function @xmath182 .    to compute the catenary degree of an element @xmath2 , one typically first computes @xmath183 , and compiles a list of edges in @xmath180 sorted by distance . from this list of edges ,",
    "a minimal connected graph is constructed one edge at a time , starting with the lowest weight ( one can use kruskal s algorithm @xcite for this ) .",
    "the final edge weight equals the catenary degree .",
    "one of the primary bottlenecks in this procedure is listing and sorting the edges of @xmath180 , since for large @xmath3 most edges have weight higher than the catenary degree and thus are never used .",
    "the main goal of algorithm  [ a : dynamiccatenary ] is to reduce the number of edges by remembering which edges were redundant for smaller elements .",
    "this is achieved by storing , for each @xmath2 , a spanning tree of the graph @xmath180 with minimum weight ( definition  [ d : minimalweight ] ) , from which the catenary degree can be easily recovered ( lemma  [ l : spanningtreecatenary ] ) .",
    "indeed , the number of edges of @xmath180 is quadratic in @xmath184 , whereas the number of edges of a spanning tree is linear in @xmath184 .",
    "[ d : minimalweight ] let @xmath61 be an undirected graph with integer edge labels .",
    "we say a chain @xmath185 has _ minimum weight _ if @xmath186 has minimum weight among all chains in @xmath61 connecting @xmath187 and @xmath188 .",
    "a spanning tree @xmath189 of @xmath61 has _ minimum weight _ if the unique path between any two vertices @xmath187 and @xmath188 in @xmath189 is a minimum weight path in @xmath61 .",
    "[ l : spanningtreecatenary ] if @xmath189 is a minimum weight spanning tree of the catenary graph of @xmath2 , then @xmath174 equals the highest edge weight in @xmath189 .",
    "immediate upon unraveling definitions .",
    "the term `` minimum weight spanning tree '' usually refers to a spanning tree that minimizes edge weight sums .",
    "proposition  [ p : minspanningtree ] verifies that our definition is equivalent to the usual one .",
    "[ p : minspanningtree ] fix a graph @xmath61 , a spanning tree @xmath190 with @xmath191 , and a weight function @xmath163 on the edges of @xmath61 .",
    "if  @xmath192 is minimal among all spanning trees of @xmath61 , then @xmath189 is a minimum weight spanning tree of @xmath61 .",
    "let @xmath193 denote a minimum weight chain @xmath194 , and let @xmath186 denote the unique path in @xmath189 from @xmath187 to @xmath188 .",
    "for @xmath172 , let @xmath195 denote the unique path in @xmath189 connecting @xmath196 and @xmath197 .",
    "concatenating the chains @xmath198 produces a chain @xmath199 in @xmath189 connecting @xmath187 and @xmath188 . since @xmath186 is the unique path in @xmath189 connecting @xmath187 and @xmath188 , every edge in @xmath186 must also be in @xmath199 .",
    "in particular , the edge @xmath200 of highest weight in @xmath186 must lie in one of the chains @xmath201 .",
    "as such , if @xmath202 , then @xmath203 , so deleting @xmath200 from @xmath189 and adding @xmath204 produces a spanning tree of lesser weight .",
    "this completes the proof .",
    "now that we have identified minimum weight spanning trees as sufficient for computing the catenary degree , it remains to see how a minimum weight spanning tree for @xmath180 can be constructed from minimum weight spanning trees of its divisors .",
    "we accomplish this task using cover morphisms ( definition  [ d : covermorphism ] ) , which played a crucial role in the dynamic algorithms presented in @xcite .",
    "the key observation is that cover morphisms also preserve edge weights when applied to adjacent factorizations in @xmath205 ( remark  [ r : covermorphism ] ) .",
    "[ d : covermorphism ] a _ cover morphism _ is a map @xmath206 that acts on the vertex set @xmath207 by incrementing the @xmath64-th coordinate of each factorization .",
    "[ r : covermorphism ] when applied to a pair @xmath164 of factorizations in @xmath205 , the cover morphism @xmath208 applies the same translation to both @xmath68 and @xmath163 , so the resulting factorizations @xmath209",
    "satisfy @xmath210 in particular , @xmath211 , so @xmath208 preserves edge weights ( stated another way , @xmath208 defines an isometric embedding of @xmath205 into @xmath180 ) .",
    "additionally , an edge @xmath212 lies in the image of @xmath208 precisely when @xmath213 . here",
    ", @xmath214 denotes the _ support _ of @xmath68 , that is , the set of indices of the nonzero coordinates of @xmath68 .    as a final step",
    ", theorem  [ t : spanningtree ] implies that in addition to edges arising from the minimum weight spanning trees of @xmath215 , some supplementary edges from the graver basis of @xmath7 are needed to obtain a minimum weight spanning tree for @xmath180 .",
    "the edges from the graver basis of @xmath7 can be thought of as a base case for the dynamic process , in the sense that every edge used in a minimum weight spanning tree is a translation of a graver basis element .",
    "although the graver basis of @xmath7 is computationally expensive ( albeit necessary ; see  example  [ e : catenarygraver ] ) , it only needs to be calculated once for the monoid .",
    "[ e : catenarygraver ] although a minimal presentation for @xmath7 produces enough edges via translation to connect @xmath180 for every @xmath2 , these edges are not sufficient for computing catenary degrees .",
    "for example , in the numerical semigroup @xmath216 from example  [ e : catenarydegree ] , the only edge @xmath217 in @xmath218 with weight @xmath219 does not appear in any minimal presentation .",
    "in fact , the weight 16 edge in figure  [ fig : catenarydegree ] is a translation of @xmath200 .",
    "it is this phenomenon that forces algorithm  [ a : dynamiccatenary ] to rely on a graver basis for @xmath7 .",
    "[ t : spanningtree ] for each @xmath144 , let @xmath220 denote the image in @xmath180 of a minimum weight spanning tree of @xmath205 under the cover morphism @xmath206",
    ". additionally , let @xmath221 be the elements of the graver basis of @xmath7 that lie in @xmath222 .",
    "the graph @xmath223 is connected , and any minimum weight spanning tree of @xmath224 is minimum weight in @xmath180 .",
    "fix @xmath161 .",
    "if @xmath225 , then a path in @xmath226 connects @xmath68 and @xmath163 .",
    "alternatively , if @xmath68 and @xmath163 have disjoint support and @xmath227 , then @xmath164 can be expressed as a sum @xmath228 of graver basis elements , so the chain @xmath186 given by @xmath229 connects @xmath68 and @xmath163 in @xmath180 . since each edge in @xmath186 connects factorizations with common support , @xmath68 and @xmath163",
    "are connected in @xmath224 .",
    "next , let @xmath230 be any minimum weight spanning tree of @xmath224 .",
    "it suffices to prove that the  unique  path @xmath199 in @xmath230 connecting @xmath231 has weight at most @xmath232 .",
    "if @xmath225 , then the unique path from @xmath68 to @xmath163 in @xmath226 has weight at most @xmath232 , and thus so does @xmath199 . on the other hand ,",
    "if @xmath68 and @xmath163 have disjoint support , then the @xmath64-th edge in the chain @xmath186 constructed in the above paragraph has weight @xmath233 meaning @xmath199 has weight at most @xmath234 .",
    "this completes the proof .",
    "we are now ready to state algorithm  [ a : dynamiccatenary ] .",
    "[ a : dynamiccatenary ] finds @xmath174 for any affine semigroup element @xmath235 .",
    "@xmath236 @xmath237 .",
    "@xmath238 @xmath239 @xmath240 @xmath241 @xmath242 @xmath243    [ t : dynamiccatenary ] for any affine semigroup element @xmath2 , algorithm  [ a : dynamiccatenary ] returns @xmath174 .",
    "proposition  [ p : minspanningtree ] and theorem  [ t : spanningtree ] ensure that ` minimumweightspanningtree ` returns a minimum weight spanning tree @xmath244 , and by lemma  [ l : spanningtreecatenary ] , the maximum weight among the edges of @xmath189 equals @xmath174 .",
    "algorithm  [ a : dynamiccatenary ] has now been implemented as ` catenarydegreeelementlistwrtnumericalsemigroup ` in the ` numericalsgps ` @xcite ` gap ` @xcite package .",
    "the function definition mirrors that of the dynamic length sets and @xmath245-primality functions @xcite , which motivated the results in this section .",
    "a version for affine semigroups is forthcoming , pending discussion of the function definition .",
    "the code is accessible in @xcite or from the official ` gap ` web page http://www.gap-system.org .",
    "the development version of ` numericalsgps ` can be found in https://bitbucket.org/gap-system/numericalsgps .",
    "we give a few implementation notes before concluding the section with an example .    1",
    ".   if @xmath246 is a numerical semigroup , then it is natural to begin with @xmath247 and compute @xmath174 in order .",
    "this allows the spanning trees to be stored in a ring buffer of size @xmath248 ( the largest generator ) , since @xmath249 is the smallest element that needs to be recalled to compute @xmath174 .",
    "2 .   by storing the list of edges in @xmath250 ordered by weight and computing the union @xmath251 via a merge of sorted lists , the first ( and most computationally - intensive ) step in kruskal s algorithm runs in linear time . 3 .   at no point must @xmath183 be explicitly computed .",
    "the base case @xmath252 consists of precisely those elements for which @xmath253 ,  , @xmath254 and @xmath255 are all empty , and in all other cases , @xmath183 is simply the set of edge endpoints by theorem  [ t : spanningtree ] .",
    "this is essentially  ( * ? ?",
    "* algorithm  3.3 ) for dynamically computing sets of factorizations .",
    "[ e : catenarynum ] given here are runtimes for three separate methods of computing @xmath174 in @xmath256 for @xmath257 .    ....",
    "s:=numericalsemigroup(11,23,27,31,43 ) ; ; gap >",
    "c:=catenarydegreeofnumericalsemigroup(s ) ; ; gap > l:=intersection([1 .. 500 ] , s ) ; ; gap >",
    "lc:=list(l , x->catenarydegreeofelementinnumericalsemigroup(x , s ) ) ; ; time ; 270390 gap >",
    "ln:=list(l , x->catenarydegreeofelement(x , s , c ) ) ; ; time ; 29380 gap > ld:=catenarydegreeelementlistwrtnumericalsemigroup(l , s ) ; ; time ; 6630 ....    the function ` catenarydegreeofelementinnumericalsemigroup ` ( original implementation in the package ) computes @xmath174 by computing the complete graph @xmath180 and then removing edges by weight , whereas the function ` catenarydegreeofelement ` constructs a spanning tree for @xmath180 using kruskal s algorithm ( as discussed immediately following definition  [ d : catenarygraph ] ) .",
    "the latter will replace the implementation of the former in the next release of the ` numericalsgps ` package .",
    "although ` catenarydegreeofelement ` is an improvement over the original implementation , the dynamic algorithm is still considerably faster for large @xmath3 .",
    "a variant of the catenary degree , the tame degree also uses distance ( as in definition  [ d : catenarydegree ] ) to measure how wild the factorizations of monoid elements are   @xcite . in this section ,",
    "we present algorithm  [ a : affinetame ] , an improved method for computing the tame degree of a full affine semigroup ( definition  [ d : full ] ) .",
    "we begin by presenting theorem  [ t : tameprincipal ] , the main new theoretical result used in algorithm  [ a : affinetame ] , followed by a discussion of the algorithm .",
    "one of the primary motivations for having a dedicated algorithm for this family of affine semigroups is to examine the tame degree of block monoids ; in examples  [ e : tameb2x2x2]-[e : tameb2x2x2x2 ] , we apply our algorithm in this setting .",
    "[ d : tamedegree ] fix @xmath0 . given @xmath2 and @xmath144 such that @xmath258 , the _ tame degree _ of @xmath3 with respect to @xmath259 , denoted @xmath260 , is defined as the least @xmath261 such that for every @xmath262 , there exists @xmath263 with @xmath264 and @xmath265 .",
    "the _ tame degree _ of @xmath7 with respect to @xmath259 is then defined as @xmath266",
    "lastly , the _ tame degree _ of @xmath7 is defined as @xmath267 .    in",
    "what follows , we denote by ` @xmath268 ' the usual partial ordering in @xmath25 , that is , @xmath269 if @xmath270 , or , equivalently , if @xmath271 for all @xmath144 .",
    "notice that @xmath272 is also equivalent to @xmath273 .",
    "[ t : tameprincipal ] let @xmath0 , and fix @xmath144 .",
    "we have @xmath274 where @xmath275 .    since @xmath276 , clearly @xmath277 .",
    "conversely , fix @xmath278 and @xmath262 . if @xmath279 , then choose @xmath280 in the definition of tame degree .",
    "otherwise , @xmath281 since @xmath278 , and consequently , there exists @xmath282 such that @xmath283 .",
    "set @xmath284 . by the definition of @xmath285 ,",
    "there exists @xmath286 with @xmath287 .",
    "let @xmath288 . upon verifying that @xmath289 @xmath290 , and @xmath291 , it follows that @xmath292 .",
    "this implies @xmath293 , and consequently @xmath294 .",
    "[ r : tameprincipal ] theorem  [ t : tameprincipal ] holds in more generality with a nearly identical proof ; the only requirement is that @xmath7 be atomic .",
    "we specialize to the affine setting here to simplify notation since algorithm  [ a : affinetame ] requires this assumption ; see  @xcite for the general definitions .",
    "[ r : tameomega ] comparing theorem  [ t : tameprincipal ] to ( * ? ? ?",
    "* proposition  3.3 ) , it is not a coincidence that the elements needed to compute the tame degree of @xmath7 are the same as those needed to compute the @xmath245-primality invariant ( see  ( * ? ? ?",
    "* definition  3.1 ) ) .",
    "some evidence of this connection was already observed for numerical semigroups ; see , for instance , ( * ? ? ?",
    "* corollary  3 ) and ( * ? ? ? * remark  5.9 ) .    arranging the atoms @xmath4 of @xmath7 as the columns of a matrix @xmath19 , the set @xmath183 of factorizations of @xmath2 coincides with the nonnegative integer solutions to the linear system @xmath295 prior to theorem  [ t : tameprincipal ] , the tame degree of @xmath7",
    "was typically computed by first computing the graver basis of @xmath19 @xcite .",
    "we propose here an alternative method , instead computing the sets @xmath296 for each @xmath297 . by dickson",
    "s lemma , both @xmath298 and @xmath299 have finitely many elements .    for the calculation of @xmath298 one can use ( * ? ?",
    "* algorithm 16 ) ( this is precisely how @xmath245-primality is computed in @xcite ) .",
    "however , it turns out that ` normaliz `  @xcite performs this task faster . to obtain @xmath298",
    ", we first compute the minimal nonnegative integer solutions of @xmath300 and then project on the first @xmath22 coordinates ( here , @xmath301 is the matrix having as columns the columns of @xmath19 followed by those of @xmath302 ) . from the resulting ( finite ) set ,",
    "we simply take those elements that are minimal with respect to @xmath268 .    since the graver basis of @xmath19 coincides with the minimal nonnegative integer solutions of @xmath303 it would seem that our approach has no significant computational advantage over the procedure given in @xcite .",
    "however , combining with ( * ? ? ?",
    "* corollary  3.5 ) ( stated here as proposition  [ p : principalsaturated ] ) yields significant performance improvements for full affine semigroups .",
    "[ d : full ] an affine semigroup @xmath13 is _ full _ if @xmath304 , where @xmath305 denotes the subgroup of @xmath306 generated by @xmath7 .",
    "[ r : full ] up to isomorphism , every full affine semigroup is a ( reduced finitely generated ) krull monoid ( * ? ? ?",
    "* proposition 2 ) .",
    "also , the class of reduced krull monoids coincides with the class of saturated submonoids of free monoids ( * ? ? ?",
    "* theorem 2.4.8 ) .",
    "[ p : principalsaturated ] if @xmath0 is full , then for every @xmath2 , @xmath307    the `` full '' hypothesis in proposition  [ p : principalsaturated ] can not be omitted .",
    "for example , the numerical semigroup @xmath308 is not full since @xmath309 ( in  fact , the only full numerical semigroup is @xmath310 ) . in this example",
    ", we see that @xmath311 even though @xmath312 .",
    "recalling @xmath38 from above , proposition  [ p : principalsaturated ] states that @xmath313 meaning that @xmath298 can be computed as a hilbert basis . at this point , in order to compute @xmath314 using theorem  [ t : tameprincipal ] , it remains to compute @xmath260 for each @xmath315 . to this end , proposition  [ p : fulldist ] implies that for fixed @xmath316 with @xmath317 , we can find the closest factorization @xmath318 to  @xmath68 in the fiber of @xmath36 with @xmath319 by minimizing @xmath320 subject to the constraints @xmath321 and @xmath322 .",
    "in particular , this expresses @xmath260 as the result of an integer linear programming  problem .",
    "[ p : fulldist ] let @xmath0 , fix @xmath144 , and fix @xmath316 . if  @xmath317 and @xmath318 fulfills @xmath323 and @xmath321 , then @xmath324 and @xmath325 .    assume to the contrary that @xmath326 . as @xmath327 , we deduce that @xmath328 .",
    "this implies that the @xmath64-th coordinate of @xmath329 is nonzero , and consequently @xmath330 .",
    "hence @xmath331 and @xmath332 , contradicting the minimality of @xmath68 .",
    "the last necessary observation is that @xmath333 , where @xmath334 is the @xmath64th column vector of the @xmath335 identity matrix , so it suffices to consider those @xmath316 satisfying @xmath317 when computing @xmath314 .",
    "we now summarize our procedure in algorithm  [ a : affinetame ] .",
    "[ a : affinetame ] computes @xmath314 for a full affine semigroup @xmath0 .",
    "@xmath336 minimal solutions @xmath68 of @xmath337 with respect to @xmath268 satisfying @xmath317 0 ( and thus stop ) @xmath338 minimize @xmath339 subject to @xmath340 and @xmath341 @xmath342 @xmath343 .",
    "[ t : affinetame ] for any full affine semigroup @xmath7 , algorithm  [ a : affinetame ] returns @xmath314 .",
    "theorem  [ t : tameprincipal ] , propositions  [ p : principalsaturated ] and  [ p : fulldist ] , and the discussion in between .",
    "notice that if all solutions @xmath344 obtained in algorithm  [ a : affinetame ] satisfy @xmath345 , then @xmath314 will coincide with the @xmath245-primality of @xmath259 , @xmath346 ( see ( * ? ? ?",
    "* proposition 3.3 ) ) .",
    "indeed , this provides an alternative proof that @xmath347 .",
    "we have implemented algorithm  [ a : affinetame ] in the ` numericalsgps ` @xcite ` gap ` @xcite package .",
    "the function ` tamedegreeofaffinesemigroup ` therein has two main methods : one for affine semigroups in general , and another for full affine semigroups ( affine semigroups with the attribute ` hasequations ` ) .",
    "the code is accessible in @xcite or from the official ` gap ` web page http://www.gap-system.org .",
    "the development version of ` numericalsgps ` can be found in https://bitbucket.org/gap-system/numericalsgps .",
    "we conclude this section by applying our implementation of algorithm  [ a : affinetame ] in several examples of block monoids ( definition  [ d : blockmonoid ] ) .",
    "[ d : blockmonoid ] fix an abelian group @xmath348 and a finite subset @xmath349 .",
    "the _ block monoid _ associated to @xmath127 is the affine semigroup @xmath350 denote by @xmath351 the block monoid of the set of nonzero elements of @xmath61 .",
    "[ r : blockmonoid ] it is easy to show that @xmath352 is a full affine semigroup .",
    "many factorization properties of a monoid can be derived from the factorization properties of the block monoid associated to its class group ( see @xcite for a thorough treatment ) .",
    "[ e : tameb2x2x2 ] we begin by computing the tame degree of @xmath353 . if @xmath354 denotes the matrix with columns the nonzero elements of @xmath355 , then @xmath7 is the submonoid of @xmath356 of nonnegative integer solutions of the system @xmath357    the tame degree of @xmath7 can be computed in ` gap ` as follows .",
    ".... gap > m:= [ [ 0 , 0 , 1 ] , [ 0 , 1 , 0 ] , [ 0 , 1 , 1 ] , [ 1 , 0 , 0 ] ,             [ 1 , 0 , 1 ] , [ 1 , 1 , 0 ] , [ 1 , 1 , 1 ] ] ; gap > a:=affinesemigroup(\"equations\",[transposedmat(m),[2,2,2 ] ] ) ; < affine semigroup > gap >",
    "at:=generatorsofaffinesemigroup(a ) ; [ [ 0 , 0 , 0 , 0 , 0 , 2 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 2 ] , [ 0 , 0 , 0 , 0 , 2 , 0 , 0 ] ,     [ 0 , 0 , 0 , 2 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , 0 , 0 , 0 , 0 ] , [ 0 , 2 , 0 , 0 , 0 , 0 , 0 ] ,     [ 2 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 1 , 1 , 0 ] , [ 0 , 0 , 1 , 1 , 0 , 0 , 1 ] ,     [ 0 , 1 , 0 , 0 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 1 , 0 , 1 , 0 ] , [ 1 , 0 , 0 , 0 , 0 , 1 , 1 ] ,     [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ,     [ 0 , 1 , 1 , 0 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 0 , 1 , 0 , 1 ] ,     [ 1 , 0 , 1 , 1 , 0 , 1 , 0 ] , [ 1 , 1 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 1 , 0 , 1 , 0 , 0 , 1 ] ] gap > tamedegreeofaffinesemigroup(a ) ; 4 ....    we use the package ` normalizinterface ` @xcite that utilizes the ` normaliz ` library to compute the hilbert bases .",
    "although ` 4ti2 ` @xcite can also be used to compute graver and hilbert bases via the ` 4ti2gap ` @xcite package , in this example ` 4ti2 ` was slower than ` normaliz ` .",
    "the computation of @xmath358 took 4955 ms on an i7 laptop with 16 gb of memory ( ` normaliz ` was compiled without ` openmp ` , and thus was running in a single thread ) . for comparison , an implementation of the procedure described in @xcite took 1,048,757 ms .",
    "the runtime can actually be improved further . according to  @xcite , in order to compute @xmath358 it suffices to compute @xmath314 with @xmath359 .",
    "this is accomplished as follows , where ` minimalelementsprincipalidealoffullaffinesemigroup ` implements proposition  [ p : principalsaturated ] .",
    ".... gap > u:=first(at , x->sum(x)=4 ) ; [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] gap > mu:=minimalelementsprincipalidealoffullaffinesemigroup(u ,",
    "a ) ; ; gap > facts:=list(mu , x->factorizationsvectorwrtlist(x , at ) ) ; ; gap > set(facts , tamedegreeofsetoffactorizations ) ;   [ 0 , 2 , 3 , 4 ] ....    it took 2 ms to compute ` at ` ( the set of atoms of @xmath7 ) , and 12 ms to compute ` mu ` .",
    "it took another 420 ms to complete the third line above , and the final line finished in 425 ms . in total , it takes less than a second to compute the tame degree of @xmath7 .",
    "[ e : tameb2x3 ] running algorithm  [ a : affinetame ] for @xmath360 yields @xmath361 after 19214 ms ; execution of the procedure presented in @xcite was killed after several hours .",
    "[ e : tameb2x2x2x2 ] as the size of @xmath61 increases , the number of atoms ( i.e.  the ambient dimension of @xmath351 ) quickly makes use of algorithm  [ a : affinetame ] infeasible .",
    "indeed , the block monoid @xmath362 has 323 atoms , and @xmath363 has 20367 atoms . although algorithm  [ a : affinetame ] is considerably faster than the general - purpose algorithm introduced in @xcite , it is still not sufficient to compute @xmath364 . given below is the analysis for @xmath364 by using the supercomputer alhambra.ugr.es .",
    "1 .   first attempt : 16 cores with 30 gb of internal memory .",
    "+ [ cols=\"^,^,^ \" , ]    + after 72 hours of execution , @xmath365 is still not computed .",
    "we contacted w.  bruns , b.  ichim and c.  sger ( developers of ` normaliz ` ) and were told ( i ) the input has too many variables and few equations to finish in a reasonable time , and ( ii ) the cone has tens of millions of extremal rays and thus requires extensive memory ( @xmath366 gb ) just to store .",
    "the point of this example is that even though we may consider @xmath367 a `` small '' group , the monoid @xmath368 has 20367 atoms , and this translates to working in an ambient space of dimension 323 !",
    "thus , algorithm  [ a : affinetame ] will fail to compute the tame degree for this monoid with the computational tools at hand .",
    "supported by fqm-343 , fqm-5849 and feder funds .",
    "the authors would like to thank winfried bruns , alfred geroldinger , alfredo snchez - r .- navarro , richard sieg and christof sger for their comments and discussions on section  [ sec : tamedegree ] .",
    "additionally , we thank winfried bruns for pointing out that we only need a single hilbert basis computation in algorithm  [ a : affinedeltahilbert ] , as well as for his assistance with several computations in ` normaliz ` . the first author",
    "also thanks the centro de servicios de informtica y redes de comunicaciones ( csirc ) , universidad de granada , for providing the computing time , especially rafael arco arredondo for his personal time advising which queues should be used in the experiments , and for installing everything needed on the supercomputer alhambra.ugr.es .            v. blanco , p.a .",
    "garca - snchez and a. geroldinger , _ semigroup theoretical characterizations of arithmetical invariants with applications to numerical monoids and krull monoids _ ,",
    "illinois journal of mathematics , * 55 * ( 2011 ) , 13851414 .            s.t .",
    "chapman , p.a .",
    "garca - snchez , d.  llena , v.  ponomarenko , and j.c .",
    "rosales , _ the catenary and tame degree in finitely generated commutative cancellative monoids _ , manuscr . math .",
    "* 120 * ( 2006 ) , 253264 .",
    "d.  cox , j.  little , and d.  oshea , _ ideals , varieties , and algorithms : an introduction to computational algebraic geometry and commutative algebra _ , 4th edition , undergraduate texts in mathematics , springer , cham , 2015 .",
    "delgado , m. , p. a. garca - snchez and j. morais , _ numericalsgps , a package for numerical semigroups _",
    ", version 1.0.1 ( 2015 ) , ( refereed gap package ) , http://www.gap-system.org . g. gamrath , t. fischer , t. gally , a. m. gleixner , g.hendel , t. koch , s. j. maher , m. miltenberger , b. mller , m. e. pfetsch , c. puchert , d. rehfeldt , s. schenker , r. schwarz , f. serrano , y. shinano , s. vigerske , d. weninger , m. winkler , j. t. witt , j. witzig , the scip optimization suite 3.2 , zib - report ( 1560 ) ( 2016 ) .          j. i. garca - garca , m. a. moreno - fras , and a. vigneron - tenorio , _ computation of the @xmath245-primality and asymptotic @xmath245-primality , applications to numerical semigroups _ , israel j.  math .  206 ( 2015 ) , no .  1 , 395411 . available from",
    "` arxiv:1307.5807 ` ."
  ],
  "abstract_text": [
    "<S> we present several new algorithms for computing factorization invariant values over affine semigroups . </S>",
    "<S> in particular , we give ( i ) the first known algorithm to compute the delta set of any affine semigroup , ( ii ) an improved method of computing the tame degree of an affine semigroup , and ( iii ) a dynamic algorithm to compute catenary degrees of affine semigroup elements . </S>",
    "<S> our algorithms rely on theoretical results from combinatorial commutative algebra involving grbner bases , hilbert bases , and other standard techniques . </S>",
    "<S> implementation in the computer algebra system gap is discussed . </S>"
  ]
}