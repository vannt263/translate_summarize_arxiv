{
  "article_text": [
    "in what follows , we provide the relevant parts of the intermediate class - based representation in ` dining-philosophers-example.maude ` , together with parts of the maude output corresponding to the strategy - based execution of the example :          ( class ' application       create           { ' make }      (          attribute { ' any } ' meal : [ ! , t,'meal ] ;                   procedure { ' any } ' make ( nil )               require true               local ( nil )              do                  (                  create ( ' meal . '",
    "make(nil ) ) ;                  command('current . ' execute_wrong('meal ;) ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' execute_wrong ( ' m : [ ! , t,'meal ] ;   )               require true               local ( nil )              do                  (                  command('m . '",
    "do_wrong(nil ) ) ;                  )              ensure true              rescue   nil          end ;      )           invariant true   end ) ;    ( class ' meal       create           { ' make }      (          attribute { ' any } ' p1 : [ !",
    ", t,'philosopher ] ;          attribute { ' any } ' p2 : [ ! , t,'philosopher ] ;          attribute { ' any } ' f1 : [ ! , t,'fork ] ;          attribute { ' any } ' f2 : [ ! , t,'fork ] ;                   procedure { ' any } ' make ( nil )               require true               local ( nil )              do                  (                  create ( ' f1 . '",
    "make(nil ) ) ;   create ( ' f2 . '",
    "make(nil ) ) ;                  create ( ' p1 . ' make('f1 ; ' f2 ;) ) ;   create ( ' p2 . ' make('f2 ; ' f1 ;) ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' do_wrong ( nil )               require true               local ( nil )              do                  (                  command ( ' current . ' go_wrong('p1 ; ' p2 ;) ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' go_wrong ( ' pa : [ ! , t,'philosopher ] ; ' pb : [ ! , t,'philosopher ] ;)",
    "require true               local ( nil )              do                  (                  command ( ' pa . '",
    "eat_wrong(nil ) ) ;                  command ( ' pb . '",
    "eat_wrong(nil ) ) ;                  )              ensure true              rescue   nil          end ;      )           invariant true   end ) ;    ( class ' philosopher       create           { ' make }      (          attribute { ' any } ' left : [ !",
    ", t,'fork ] ;          attribute { ' any } ' right : [ ! , t,'fork ] ;                   procedure { ' any } ' make ( ' fl : [ ! , t,'fork ] ; ' fr : [ ! , t,'fork ] ; )               require true               local ( nil )              do                  (                   assign ( ' left , ' fl ) ;                  assign ( ' right , ' fr ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' pick_two ( ' fa : [ ! ,",
    "t,'fork ] ; ' fb : [ ! , t,'fork ] ; )               require true               local ( nil )              do                  (                  command ( ' fa . '",
    "use(nil ) ) ;                  command ( ' fb . ' use(nil ) ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' eat_wrong ( nil )               require true               local ( nil )              do                  (                  command ( ' current . '",
    "pick_in_turn('left ;) ) ;                  )              ensure true              rescue   nil          end ;                   procedure { ' any } ' pick_in_turn ( ' f : [ ! , t,'fork ] ; )               require true               local ( nil )              do                  (                  command ( ' current . '",
    "pick_two('f ; ' right ;) ) ;                  )              ensure true              rescue   nil          end ;      )           invariant true   end ) ;    ( class ' fork       create           { ' make }      (          procedure { ' any } ' make ( nil )               require true               local ( nil )              do ( nil )              ensure true              rescue   nil          end ;                   procedure { ' any } ' use ( nil )               require true               local ( nil )              do ( nil )              ensure true              rescue   nil          end ;      )           invariant true   end ) ;      the entry point of the program implementing the dining philosophers example is the function ` ' make ` in the class ` application ` .",
    "the flag enabling the deadlock analysis is set to `` on '' .",
    "this information is specified using the instruction ` settings('application , ' make , false , deadlock - on ) ` .    a possible scenario that leads to a deadlock",
    "when running the above code is as follows .",
    "first , we initialize the left and right forks of the philosophers : ` p1 ` is assigned ` f1 ` and ` f2 ` , respectively , whereas ` p2 ` is assigned ` f2 ` and ` f1 ` , respectively .",
    "then , asynchronously , ` p1 ` and ` p2 ` ( of _ separate _ type ` philosopher ` ) execute ` eat_wrong ` , which calls ` pick_in_turn(left ) ` . in the context of ` p1 ` , the actual value of ` left ` is ` f1 ` , whereas for ` p2 ` it is ` f2 ` .",
    "consequently , both resources ` f1 ` and ` f2 ` , respectively , might be locked `` at the same time '' by ` p1 ` and ` p2 ` , respectively .",
    "note that ` pick_in_turn ` subsequently calls ` pick_two ` that , intuitively , should enable the philosophers to use both forks .",
    "thus , if ` f1 ` and ` f2 ` , respectively , are locked by ` p1 ` and ` p2 ` , respectively , the calls ` pick_two(f2 , f1 ) ` and ` pick_two(f1 , f2 ) ` corresponding to ` p1 ` and ` p2 ` will ( circularly ) wait for each other to finish .",
    "according to the scoop semantics , ` pick_two(f1 , f2 ) ` is waiting for ` p2 ` to release ` f2 ` , whereas ` pick_two(f2 , f1 ) ` is waiting for ` p1 ` to release ` f1 ` , as the forks are passed to ` pick_two ( ... ) ` as _ separate _ types . in the context of scoop",
    ", this corresponds to a coffman deadlock  @xcite .",
    "we force the execution of the scenario above by applying the command / strategy + ` srew [ ... ] using init ; parallelism{lock } ; [ ... ] ; deadlock - on ` .",
    "this determines maude to first trigger the rule ` [ init ] ` in the scoop formalization .",
    "this makes all the required initializations of the _ bootstrap _ processor .",
    "then , one of the processors that managed to _",
    "the necessary resources is ( `` randomly '' ) enabled to proceed to the asynchronous execution of its instruction stack , according to the strategy ` parallelism{lock } ` .",
    "the last step of the strategy calls the rule ` [ deadlock - on ] ` implementing the coffman deadlock detection as in  ( [ eq : maude - deadlock ] ) .",
    "( for a detailed description of scoop and its maude formalization we refer the interested reader to the work in  @xcite . )",
    "we run the example by executing the command : + ` > maude scoop.maude .. \\examples\\dining - philosophers - example.maude `   + the rewriting guided according to the aforementioned strategy leads to one solution identifying a coffman deadlock .",
    "the relevant parts of the corresponding maude output are as follows :      ....                       \\||||||||||||||||||/                     --- welcome to maude ---                       /||||||||||||||||||\\              maude 2.6 built : mar 31 2011 23:36:02              copyright 1997 - 2010 sri international                     we d sep 17 14:47:47 2014 [ ... ] = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = srewrite in system : ( import default _ _ create__invariant_end ( ... ) ;      _ _ create__invariant_end ( ... ) ; _ _ create__invariant_end ( ... ) ;      _ _ create__invariant_end ( ... ) ;) settings('application , ' make , false ,      deadlock - on ) using init ; parallelism{lock } ; [ ... ] ; deadlock - on ."
  ],
  "abstract_text": [
    "<S> in this paper we address the deadlock detection problem in the context of scoop  an oo - programming model for concurrency , recently formalized in maude . </S>",
    "<S> we present the integration of a deadlock detection mechanism on top of the aforementioned formalization and analyze how an abstract semantics of scoop based on a notion of `` may alias expressions '' can contribute to improving the deadlock detection procedure .    </S>",
    "<S> [ [ introduction . ] ] introduction . </S>",
    "<S> + + + + + + + + + + + + +    in this paper we are targeting scoop  @xcite  a concurrency model recently provided with a formalization based on rewriting logic ( rl )  @xcite , which is `` executable '' and straightforwardly implementable in the programming language maude . _ </S>",
    "<S> our aim _ is to develop a ( coffman ) deadlock  @xcite detection mechanism for scoop applications . </S>",
    "<S> intuitively , such deadlocks occur whenever two or more executing threads are each waiting for the other to finish .    _ </S>",
    "<S> our contribution . </S>",
    "<S> _ we present the integration of a deadlock detection mechanism on top of the formalization in  @xcite </S>",
    "<S> . we also briefly analyze how a simplified , abstract semantics of scoop based on a notion of `` may alias '' expressions  @xcite can be exploited in order to improve the deadlock detection procedure .    </S>",
    "<S> the literature on using static analysis  @xcite and abstracting techniques for ( related ) concurrency models is considerable . </S>",
    "<S> we refer , for instance , to the recent work in  @xcite that introduces a framework for detecting deadlocks by identifying circular dependencies in the ( finite state ) model of so - called contracts that abstract methods in an oo - language . </S>",
    "<S> the integration of a deadlock analyzer in scoop on top of maude is an orthogonal approach that belongs to a more ambitious goal , namely the construction of a rl - based toolbox for scoop programs including a _ may alias _ analyzer , as thoroughly presented in  @xcite and a type checker .    </S>",
    "<S> [ [ deadlock - detection - in - scoop . ] ] deadlock detection in scoop . </S>",
    "<S> + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the key idea of scoop is to associate to each object a processor , or _ handler _ ( that can be a cpu , or it can also be implemented in software , as a process or thread ) . in scoop terminology , objects that can run on different processors are _ separate _ from each other . assume a processor @xmath0 that performs a call @xmath1 on an object @xmath2 . if @xmath2 is declared as `` separate '' , then @xmath0 sends a request for executing @xmath3 to @xmath4  the handler of @xmath2 ( note that @xmath0 and @xmath4 can coincide ) . </S>",
    "<S> meanwhile , @xmath0 can continue . </S>",
    "<S> moreover , assume that @xmath5 are of `` separate '' types . in the scoop semantics , </S>",
    "<S> the application of the call @xmath6 will _ wait _ until it has been able to _ lock _ all the separate objects associated to @xmath5 . </S>",
    "<S> this mechanism guarantees exclusive access to these objects . </S>",
    "<S> processors communicate via _ </S>",
    "<S> channels_.    in the context of scoop , </S>",
    "<S> the _ deadlocking problem _ reduces to identifying whether a set of processors reserve each other circularly . </S>",
    "<S> this situation might occur , for instance , in a dining philosophers scenario , where both philosophers and forks are objects residing on their own processors . </S>",
    "<S> given a processor @xmath0 , by @xmath7 we denote the set of processors @xmath0 _ waits _ to release the resources @xmath0 needs for its asynchronous execution . </S>",
    "<S> orthogonally , by @xmath8 we represent the set of resources ( more precisely , resource handlers that ) @xmath0 already acquired . </S>",
    "<S> we say that a deadlock exists if for some set @xmath9 of processors : @xmath10 the semantics of scoop in  @xcite is defined over tuples of shape @xmath11 where , @xmath12 denotes a processor ( for @xmath13 ) , @xmath14 is the call stack of @xmath12 and @xmath15 is the _ state _ of the system . </S>",
    "<S> states hold information about the _ heap _ ( which is a mapping of references to objects ) and the _ store _ ( which includes formal arguments , local variables , _ </S>",
    "<S> etc_. ) . </S>",
    "<S> integrating the deadlock definition in  @xmath16 on top of the maude formalization in  @xcite is almost straightforward . given a processor @xmath17 as in  @xmath16 , the set @xmath18 corresponds , based on  @xcite , to @xmath19 . </S>",
    "<S> whenever the top of the instruction stack of a processor @xmath0 is of shape @xmath20 , we say that the wait set @xmath7 is the set of processors @xmath21 . hence , assuming a predefined system configuration @xmath22 , the scoop transition rule in maude corresponding to  @xmath16 can be written as : @xmath23 it is intuitive to guess that @xmath24 in  ( [ eq : maude - deadlock ] ) returns the set of processors in the system , whereas @xmath25 stands for the list of these processors and their instruction stacks ( separated by the associative & commutative operator `` @xmath26 ''  ) . </S>",
    "<S> we use `` @xmath27 '' to represent an arbitrary sequence of processors and processor stacks .    </S>",
    "<S> [ [ discussion . ] ] discussion . </S>",
    "<S> + + + + + + + + + + +    we implemented  ( [ eq : maude - deadlock ] ) and tested the deadlock detection mechanism on top of the formalization in  @xcite for the dining philosophers problem . a case study considering two philosophers </S>",
    "<S> can be run by downloading the scoop formalization at : + ` https://dl.dropboxusercontent.com/u/1356725/scoop-nwpt-14.zip ` , and executing the command + ` > maude scoop.maude .. \\examples\\dining - philosophers - example.maude ` . in our example , the philosophers ` p1 ` and ` p2 ` can reach a ( coffman ) deadlock ( ` go_wrong(p1 , p2 ) ` ) if they adopt a wrong eating strategy ( ` pi.eat_wrong ` , with ` i ` @xmath28 ) . </S>",
    "<S> this might happen whenever a philosopher proceeds by picking up the forks ` f1 ` and ` f2 ` on the table in turn ( ` pick_in_turn(fi ) ` , with ` i ` @xmath28 ) instead of picking them at the same time </S>",
    "<S> . it might be the case that , for instance , ` p1 ` picks up ` f1 ` , whereas ` p2 ` immediately picks up ` f2 ` . </S>",
    "<S> thus , each of the two philosophers is holding a fork the other philosopher is waiting for .    </S>",
    "<S> as can be seen from the code in ` dining-philosophers-example.maude ` , in order to implement our applications in maude , we use intermediate representations . for a brief example , consider the class implementing the _ philosopher _ concept , given below :    [ [ section ] ]     it declares two forks  ` ' left ` and ` ' right ` of type ` [ ! , t , ' </S>",
    "<S> fork ] ` , that can be handled by any processor ( ` t ` ) and that can not be ` void ` ( ` ! ` ) . </S>",
    "<S> the corresponding constructor ` ' make('fl , ' fr ) ` initializes the philosopher s forks accordingly .    </S>",
    "<S> it is worth pointing out that in the aforementioned example we use a predefined strategy  @xcite that guides the rewriting of the maude rules formalizing scoop towards a @xmath22 system configuration </S>",
    "<S> . nevertheless , such an approach requires lots of ingeniousness and , moreover , is not automated . </S>",
    "<S> given the size of the current scoop formalization , running the maude model checker is , unfortunately , not an option . </S>",
    "<S> we anticipate a `` way out '' of the state explosion issue by exploiting the expression - based alias calculus in  @xcite in order to provide a simplified , abstract semantics of scoop . in short , the calculus in  @xcite identifies whether two expressions in a program _ may _ reference to the same object . </S>",
    "<S> consider , for intuition , the code ` x : = y ; loop x : = x.next end ` that assignes a linked list . </S>",
    "<S> the corresponding execution causes ` x ` to become aliased to ` y.next.next . ... ` , with a possibly infinite number of occurrences of the field ` next ` . </S>",
    "<S> the set of associated `` may alias '' expressions identified by the calculus in  @xcite can be equivalently written as @xmath29 ` x ` , ` y.next ` @xmath30\\mid k \\geq 0 \\}$ ] .    </S>",
    "<S> the idea behind using an alias - based abstract semantics of scoop stems from the fact that scoop processors are known from object references , which may be aliased . </S>",
    "<S> therefore , the scoop semantics could be simplified by retaining within the corresponding transition rules only the information relevant for aliasing . </S>",
    "<S> consider , for instance , the assignment instruction formally specified as : @xmath31 intuitively , `` eval@xmath32 '' evaluates @xmath33 and puts the result on channel @xmath34 , `` wait@xmath35 '' enables processor @xmath0 to use the evaluation result and `` write@xmath36 '' sets the value of @xmath37 to @xmath38 . </S>",
    "<S> the abstract transition rule omits the evaluation of the right - hand side of the assignment @xmath39 and the associated message passing between channels , and updates the aliasing information in the newly added component _ alias _ _ ( consisting of a set of alias expressions ) according to the calculus in  @xcite : @xmath40 then , the rule  ( [ eq : maude - deadlock ] ) identifying deadlocks can be naturally redefined to range over the expressions aliased with the processors @xmath41 and @xmath42 , respectively . nevertheless , observe that this approach is prone to introducing `` false positives '' w.r.t . </S>",
    "<S> the expressions that would actually become aliased at runtime ; this is due to the over - approximating nature of the alias calculus in  @xcite that ignores conditions in conditionals and loops . </S>",
    "<S> furthermore , the abstract setting enables the simplification of the scoop semantics by completely eliminating the rules formalizing the exception handling mechanism , for instance . </S>",
    "<S> we plan to closely investigate and implement this abstraction mechanism in maude . for a survey on similar `` abstracting '' procedures we refer to the work in  @xcite </S>",
    "<S> .    10    g.  caltais . </S>",
    "<S> expression - based aliasing for oo - languages . </S>",
    "<S> accepted in _ </S>",
    "<S> 3rd international workshop on formal techniques for safety - critical systems 2014 _ ; to appear . , abs/1409.7509 , 2014 .    </S>",
    "<S> e.  g. coffman , m.  elphick , and a.  shoshani . </S>",
    "<S> system deadlocks . </S>",
    "<S> , 3(2):6778 , 1971 .    </S>",
    "<S> e.  giachino , c.  a. grazia , c.  laneve , m.  lienhardt , and p.  y.  h. wong . </S>",
    "<S> deadlock analysis of concurrent objects : theory and practice . in _ </S>",
    "<S> integrated formal methods _ , 394411 , 2013 .    </S>",
    "<S> a.  kogtenkov , b.  meyer , and s.  velder . alias and change calculi , applied to frame inference . </S>",
    "<S> , abs/1307.3189 , 2013 .    </S>",
    "<S> w.  landi . </S>",
    "<S> undecidability of static analysis . </S>",
    "<S> , 1(4):323337 , 1992 .    </S>",
    "<S> n.  mart - oliet , j.  meseguer , and a.  verdejo . . </S>",
    "<S> in _ electr . </S>",
    "<S> notes in theor . comp . </S>",
    "<S> sci . </S>",
    "<S> _ , 117:417441 , 2005 .    </S>",
    "<S> j.  meseguer and g.  rosu . </S>",
    "<S> the rewriting logic semantics project : a progress report . in _ fundamentals of computation theory _ </S>",
    "<S> , 137 , 2011 .    </S>",
    "<S> b.  morandi , m.  schill , s.  nanz , and b.  meyer . </S>",
    "<S> prototyping a concurrency model . in _ </S>",
    "<S> 13th international conference on application of concurrency to system design _ </S>",
    "<S> , 170179 , 2013 . </S>"
  ]
}