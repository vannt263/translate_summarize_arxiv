{
  "article_text": [
    "satisfiability of quantified boolean formulas ( qbf ) is a generalization of the boolean satisfiability problem ( sat ) where universal quantifiers are added to the existential ones .",
    "qbf are useful in modeling practical problems harder than np e.g. planning , verification or combinatorial game playing .",
    "algorithmic complexity of qbf ranges in the polynomial hierarchy up to pspace .",
    "message passing algorithms are used in a wide range of algorithmically hard problems , from constraint satisfaction problems such as the satisfiability problem @xcite to gene regulation network reconstruction @xcite , error correcting codes @xcite , or compressed sensing @xcite .",
    "message passing algorithms can be very efficient for large random systems where complete algorithms can not be applied . however , on small systems sizes or for structured sat problems the use of message passing has been so far very limited .",
    "for instance there have been attempts to solve small satisfiability problems by using message passing in a complete algorithm @xcite .",
    "however , according to these result it seems that message passing is helpful only for satisfiable random formulas , where complete algorithms are less efficient than stochastic local search algorithms .    in this paper",
    "we introduce two types of message passing algorithms for quantified boolean formulas , one as a heuristic scheme and another as a subroutine for a complete solver .",
    "we mainly consider qbf with two alternations @xmath0 with @xmath1 corresponding to the set of universal variables , @xmath2 corresponding to the set of existential variables , and @xmath3 being a cnf formula . such qbf",
    "are said to be satisfiable if for all configurations of the universal variables , there exists an assignment of the existential variables that satisfies the formula .",
    "examples for the case with more alternations are presented in sec .",
    "[ sec : extention ] .    solving a qbf",
    "is in general more difficult than solving a sat formula .",
    "in case of random sat formulas , the state - of - art sat solvers e.g. kcnfs @xcite or march @xcite can solve hard satisfiable @xmath4-sat instances with @xmath5 variables , while the state - of - art qbf solvers e.g. qube7.2 @xcite can solve hard random qbf with number of variables only up to @xmath6 .",
    "the intuitive reason for this difference is that a much larger search space needs to be explored in qbf .",
    "another reason is that , whereas for sat formulas there are several good decision heuristics based on e.g. look - ahead  @xcite or backbone - search  @xcite , for qbf efficient decision heuristics are missing .",
    "here we introduce belief propagation based decision heuristics that provides considerable speed up to the state of the art qbf solvers .",
    "a similar attempt has been done in @xcite where , however , the use of survey propagation instead of belief propagation was unfortunate as we discuss briefly later",
    ".    for the sat problem , besides complete algorithms based on dpll @xcite or resolution , there are also many efficient heuristic algorithms @xcite .",
    "however up to our best knowledge , all algorithms proposed for qbf were complete except one @xcite .",
    "here we introduce a new message passing based heuristics for proving unsatisfiability that improves over the algorithm of @xcite .",
    "in this section we remind the definition of random qbf formulas that we use as benchmarks for our algorithms @xcite .",
    "we also remind the standard formulas for belief propagation and survey propagation update rules @xcite .",
    "to express qbf with @xmath7 alternations , we use @xmath8 where @xmath9 denotes quantifier @xmath10 or @xmath11 at @xmath12th alternation , @xmath13 denotes the set of variables at @xmath12th alternation and @xmath3 denotes the set of clauses .",
    "we evaluate satisfiability of qbf in the following way . if one is able to find an assignment of the universal variables for which no solution exists , the qbf is said unsatisfiable , otherwise it is satisfiable .",
    "for instance , @xmath14 denotes qbf with two alternations , and the set of universal @xmath1 and existential @xmath2 variables .",
    "this formula is satisfiable if for every assignments of @xmath1 , one can find an assignment for @xmath2 such that @xmath3 is satisfied .",
    "we will use the notation @xmath15 , @xmath16 , @xmath17 for the number of clauses in @xmath3 , @xmath18 and @xmath19 .",
    "several models for random qbf were proposed . in this paper",
    ", we consider the @xmath20 model @xcite , and the model - b @xcite . in model - b , each clause in @xmath3 has @xmath21 universal variables and @xmath22 existential variables that are selected randomly from the whole set of universal ( resp .",
    "existential ) variables .",
    "the @xmath20 model is a special case of model - b formula with 2 alternations , which specifies a formula @xmath23 where each clause in @xmath3 contains @xmath24 variables , @xmath25 from @xmath1 and @xmath26 from @xmath2 .    in message passing algorithms , belief propagation @xcite and survey propagation @xcite ,",
    "we define @xmath27 to be the marginal probability that variable @xmath28 takes assignment @xmath29 among all the solutions ( bp ) or among all the solution clusters ( sp ) . in bp @xmath29",
    "has two possible values @xmath30 or @xmath31 , with @xmath32 , in sp @xmath29 has three possible values @xmath30,@xmath33 , and @xmath31 with @xmath34 .",
    "we say that a variable is biased if @xmath35 , the larger the difference the larger bias the variable has . if @xmath36 we define the bias of @xmath28 to be @xmath37 , and if @xmath38 we define the bias of @xmath28 to be @xmath39 .",
    "let us define @xmath40 as the set of clauses to which @xmath28 belongs non - negated , and @xmath41 as the set of clauses to which @xmath28 belongs negated .",
    "then the set of clauses to which variable @xmath28 belongs can be written as @xmath42 where ( a ) if @xmath28 is not negated in @xmath43 then @xmath44 , @xmath45 , and ( b ) if @xmath28 is negated in @xmath43 then @xmath46 , @xmath47 .",
    "the bp marginals are computed as @xmath48 where messages @xmath49 are a fixed point of the following iterative equations @xmath50 iteration equations of sp are written as : @xmath51 \\prod _ { b\\in { \\cal s}_{ia }    } u_{b\\to i } \\ , , \\nonumber \\\\",
    "\\psi^s_{i\\to a}&=&\\frac{1}{c_{i\\to a } }   \\left[1-\\prod _ { b\\in { \\cal s}_{ia}}u_{b\\to i}\\right ]   \\prod _ { b\\in   { \\cal u}_{ia } } u_{b\\to i}\\ , , \\nonumber\\\\    \\psi^*_{i\\to a}&= & \\frac{1}{c_{i\\to a}}\\prod _ { b\\in \\partial     i\\setminus a } u_{b\\to i}\\ , , \\nonumber\\\\   u_{a \\to i}&=&1-\\prod_{j \\in \\partial a\\backslash i}\\psi_{j\\to a}^{u } , \\label{eq : speta1}\\end{aligned}\\ ] ] where @xmath52 is a normalization constant ensuring @xmath53 . sp marginals are computed by @xmath54 \\prod _ { b\\in \\partial_{- } i    } u_{b\\to i}\\ , , \\nonumber \\\\",
    "\\psi^-_{i}&=&\\frac{1}{c_{i } }   \\left[1-\\prod _ { b\\in \\partial_{- } i}u_{b\\to i}\\right ]   \\prod _ { b\\in \\partial_{+ } i   } u_{b\\to i}\\ , , \\nonumber\\\\   \\psi^*_{i}&= & \\frac{1}{c_{i}}\\prod _ { b\\in \\partial i}u_{b\\to i}\\ , , \\nonumber\\\\ \\label{eq : spmar}\\end{aligned}\\ ] ] where @xmath55 is again a normalization constant .",
    "proving unsatisfiability for the two - level qbf can be done by finding an assignment of the universal variables that leaves the existential part of the formula unsatisfiable .",
    "one strategy is to find a configuration of the universal variables that leaves the largest possible number of clauses unsatisfied ; see e.g. walkminqbf @xcite .",
    "this , however , leads to heuristic algorithms that do not use in any way the existential part of the qbf . here",
    "we suggest and test a belief propagation decimation heuristics for proving unsatisfiability that takes into account the whole formula and outperforms significantly the previously known heuristics .",
    "our belief propagation decimation heuristics ( bpdu ) for proving unsatisfiability of qbf works as follows : input is the qbf formula @xmath23 .",
    "we disregard for a moment the quantifiers in the qbf formula and run randomly initialized bp on the whole formula ( i.e. with both universal and existential variables ) till convergence or till the maximum number of allowed iterations @xmath56 is achieved ( typically we use @xmath57 in our algorithms ) .",
    "we select the most biased universal variable and fix it against the direction of the bias .",
    "we repeat the above steps until all the universal variables are assigned .",
    "then we run a complete sat solver ( in our case kcnfs @xcite ) on the formula consisting of the existential variables and clauses that were not satisfied by any of the universal variables .",
    "if this remaining formula is unsatisfiable then we proved unsatisfiability of the qbf . if the remaining formula is satisfiable then the algorithm outputs `` unknown '' , since there might be another configuration of the universal variables that would leave the remaining formula unsatisfiable .    a variation on the above heuristic algorithm is to run survey propagation instead of belief propagation whenever survey propagation converges to a nontrivial fixed point",
    "in what follows we call this variation bpspdu .    to evaluate the performance of the bpdu and bpspdu heuristics we first apply them on random @xmath58 and @xmath59 qbf instances with @xmath60 variables and with varying number of clauses ( more clauses make the formulas less likely to be satisfiable ) , see fig .",
    "[ fig:2_13_200 ] . for",
    "the @xmath58 case , a complete solver ( e.g. qube7 ) can solve every formula hence we can compare the fraction of unsatisfiable formulas found by bpdu to the true fraction . for the @xmath59 case",
    "the size is prohibitive for the use of a complete qbf solver . in both cases",
    "we also show the fraction of unsatisfiable formulas found by the `` greedy '' strategy , which fixes the universal variables in order to let the largest possible number of unsatisfied clauses . in case of @xmath61 qbf",
    "this is easy as every universal variable just needs to be set positive if it appears negated in more clauses than non - negated , and vice versa . in fig .",
    "[ fig:2_13_200 ] we see that the bpdu and bpspdu heuristics perform much better than the greedy strategy . and",
    "in case of @xmath58 qbf the performance is not too far from the optimal .",
    "ratio of unsatisfiable formulas found by the various algorithms discussed in the text for random @xmath58 qbf instances ( left ) and @xmath59 qbf instances ( right ) with @xmath62 as a function of @xmath63 . , title=\"fig:\",scaledwidth=50.0% ]   ratio of unsatisfiable formulas found by the various algorithms discussed in the text for random @xmath58 qbf instances ( left ) and @xmath59 qbf instances ( right ) with @xmath62 as a function of @xmath63 . ,",
    "title=\"fig:\",scaledwidth=50.0% ]     running time of the bpspdu heuristics compared to walkminqbf on @xmath64 random @xmath65 qbf benchmarks with the same number of variables @xmath66 but different @xmath67 values ( left ) , and the same @xmath68 but different number of variable @xmath69 ( right),title=\"fig:\",scaledwidth=50.0% ]   running time of the bpspdu heuristics compared to walkminqbf on @xmath64 random @xmath65 qbf benchmarks with the same number of variables @xmath66 but different @xmath67 values ( left ) , and the same @xmath68 but different number of variable @xmath69 ( right),title=\"fig:\",scaledwidth=50.0% ]    .    in fig .",
    "[ fig:2_23 ] we compare the performance of the bpspdu and walkminqbf heuristics for random @xmath65 instances .",
    "the walkminqbf aims at setting the universal variables in order to maximize the number of unsatisfied clauses , and then evaluates the remaining sat formula with a complete sat solver .",
    "note that the complete sat solver used by walkminqbf and bpspdu is the same , kcnfs @xcite , so the difference in performance comes only from the quality of the universal configuration given by the two heuristics .",
    "as the figure shows , formulas with larger number of clauses are easier for walkminqbf , and the running time of the algorithm has larger fluctuations compared to that of bpspdu .",
    "the difference between the two algorithms is clearer for larger problem instances ; with @xmath70 , bpspdu solves @xmath71 out of the @xmath64 instances , and walkminqbf solves only @xmath72 of them within @xmath73 seconds .",
    "the above results indicate that the universal configuration suggested by bpspdu is much better than the one suggested by walkminqbf .",
    "when the bpdu or the bpspdu algorithms introduced in the last section output `` unknown '' , there might be another configuration of the universal variables that makes the formula unsatisfiable . given that we were fixing the universal variables starting with the most biased one , it might be a good strategy to backtrack on the variables fixed in the later stages . in this section",
    "we extend this idea into a complete dpll - style solver , which is using message passing to decide on which variables to branch next .",
    "dpll - style algorithms are the most efficient complete solvers for sat and qbf , they search the whole configurational space by backtracking .",
    "the difference between dpll for sat and for qbf is that in qbf dpll does backtracking on existential variable when it encounters a contradiction , and does backtracking on universal variable when it encounters a solution , see e.g. @xcite for details . besides the basic dpll backtracking procedure",
    ", there are several components in modern sat and qbf solvers that lead to exponential speed up , among the important ones are decision heuristics , unit - clause propagation , non - chronological back - jumping , conflict and solution driven clause learning @xcite .",
    "our contribution concerns the _ decision heuristics _ which is used in order to decide which variable will be used in the next branch and which sign of the variable should be checked first .",
    "decision heuristics guides dpll to the more relevant branches and keeps it away from irrelevant branches .",
    "here we propose a decision heuristics that uses information coming from the result of belief propagation ( that was iterated till convergence or for @xmath56 steps on the whole formula ignoring the quantifiers ) .",
    "we propose to start branching with the more biased universal variables and assign them first the less probable values .",
    "for the existential variables we start branching also on the more biased ones , but assign them the more probable values .",
    "the motivation is that this will speed up the search of a universal configuration that will leave the existential part of the qbf unsatisfiable , and the search for a solution on the existential part .",
    "in particular we propose two decision heuristics .    in the bph decision heuristics",
    "we simply order the variables according to their bias , starting with the most biased one , and assign them first the value opposite to the bias for the universal variables and according to the bias for the existential ones .",
    "in the bpdh decision heuristics we run bp and choose the most biased unassigned variables which belong to the highest quantifier order .",
    "if this variable is universal we assign it the value opposite to its bias , if this variable is existential we assign it according to its bias .",
    "we repeat bp on the simplified formula .",
    "finally the bpdh heuristics will branch variables in the same order as they were encountered in this procedure .",
    "most of the good decision heuristics for sat and qbf solvers are dynamic , which means that the branching sequence is being updated during the run .",
    "our bph and bpdh decision heuristics are computationally heavier than the other efficient decision heuristics e.g. vsids , moms or failed - literal - detection @xcite , so we use it only once at the very beginning of the dpll run .",
    "we report performance of dpll with our bph and bpdh decision heuristics on two levels .",
    "first level is using bph and bpdh in the pure dpll ( no features such as conflict and solution driving back - jumping and clause learning included ) .",
    "the second level is using bph in a state - of - art qbf solver qube7.2 , which is one of the fastest known solvers today .",
    "number of solutions , number of conflicts , running time , and ratio of satisfiable formulas @xmath74 , as resulting from pure dpll for solving random @xmath59 formulas , data are averaged over @xmath75 instances . @xmath76 and @xmath77 .",
    ", title=\"fig:\",scaledwidth=50.0% ]   number of solutions , number of conflicts , running time , and ratio of satisfiable formulas @xmath74 , as resulting from pure dpll for solving random @xmath59 formulas , data are averaged over @xmath75 instances . @xmath76 and @xmath77 . , title=\"fig:\",scaledwidth=50.0% ]   number of solutions , number of conflicts , running time , and ratio of satisfiable formulas @xmath74 , as resulting from pure dpll for solving random @xmath59 formulas , data are averaged over @xmath75 instances . @xmath76 and @xmath77 . ,",
    "title=\"fig:\",scaledwidth=50.0% ]   number of solutions , number of conflicts , running time , and ratio of satisfiable formulas @xmath74 , as resulting from pure dpll for solving random @xmath59 formulas , data are averaged over @xmath75 instances .",
    "@xmath76 and @xmath77 . , title=\"fig:\",scaledwidth=50.0% ]    in fig .  [ fig:15con ]",
    "we plot the number of solutions and the number of conflicts encountered in dpll using a pure dpll algorithm and those encountered in dpll with bpdh and bph decision heuristics on random @xmath59 qbf formulas . by pure dpll",
    "we mean with no back - jumping nor clause learning , and the default decision heuristics is vsids ( variable state independent decaying sum ) @xcite , which is based on dynamic statistics of literal count as a score to order literals ( in case of pure dpll , no learned clause contributes to the literal count ) .",
    "since pure dpll is very cpu - time demanding , we use formulas with only @xmath78 variables .",
    "we also plot the ratio of satisfiable formulas @xmath74 , and we can see that when almost all formulas are satisfiable , the average number of solutions encountered in dpll is always @xmath79 , because to prove the satisfiability of a formula , pure dpll has to scan all the @xmath80 universal configurations .",
    "when @xmath74 becomes smaller than one , dpll with bpdh and bph encounters much smaller number of solutions than the pure dpll .",
    "[ fig:15con ] shows that in the whole range of parameters the number of conflicts encountered by dpll with bpdh and bph is always much smaller than dpll with vsids decision heuristics .",
    "the fewer solutions and conflicts encountered , the smaller search tree is explored by the algorithm .    a better way to extract the full power of bph and bpdh in dpll - based search is to use solution and conflict driven back - jumping and clause learning . in clause learning ,",
    "reasons of solutions and conflicts are analyzed and stored as learned clauses in order to implement non - chronological back - jumping to more relevant branches of the search tree and to avoid the encounter of the same solutions or conflicts in the future search . with clause learning",
    ", dpll does not have to explore @xmath80 satisfiable leaves of the search tree , and",
    "good decision heuristics could lead to a smaller number of solutions .",
    "we applied clause learning to the pure dpll with and without bph .",
    "results show that with bph and bpdh , both search tree size and running time are exponentially smaller than without bph for both unsatisfiable and satisfiable formulas .    as a next step we implemented message passing decision heuristics in a state - of - art solver , we chose qube7.2 , which uses solution and conflict driven clause learning , as the fastest known solver today , and replaced the decision heuristics in qube7.2 by bph .",
    "we have also tried using bph in other state - of - art solvers , and found quantitatively similar results .",
    "number of conflicts , solutions and time used by dpll of qube7.2 and qube7.2+bph in solving random @xmath59 formulas , data are averaged over @xmath81 instances . @xmath82 and @xmath83 . ,",
    "title=\"fig:\",scaledwidth=50.0% ]   number of conflicts , solutions and time used by dpll of qube7.2 and qube7.2+bph in solving random @xmath59 formulas , data are averaged over @xmath81 instances . @xmath82 and @xmath83 .",
    ", title=\"fig:\",scaledwidth=50.0% ]   number of conflicts , solutions and time used by dpll of qube7.2 and qube7.2+bph in solving random @xmath59 formulas , data are averaged over @xmath81 instances . @xmath82 and @xmath83 . , title=\"fig:\",scaledwidth=50.0% ]   number of conflicts , solutions and time used by dpll of qube7.2 and qube7.2+bph in solving random @xmath59 formulas , data are averaged over @xmath81 instances . @xmath82 and @xmath83 . , title=\"fig:\",scaledwidth=50.0% ]    our results are presented in fig .  [ fig:50con ] .",
    "the power of qube enables to reach larger formulas than we used in fig .",
    "[ fig:15con ] , so our experiments are carried out on random @xmath59 formulas with @xmath84 . from the figures we can see that bph considerably",
    "reduces the size of the search tree as well as the computation time exponentially for whole range of @xmath67 .",
    "the improvement in performance is relatively small only close to the transition region because information given by bp is probably less reliable there .",
    "figure  [ fig : quben ] shows the computational time reduction with the system size .",
    "we see that with the same time limit , bph enables qube to solve larger formulas .",
    "time used by dpll of qube7.2 and qube7.2+bph in solving random @xmath59 formulas with fixed @xmath67 values and different number of variables @xmath12 ( @xmath85 ) .",
    "data are averaged over @xmath86 instances . as shown in fig .",
    "[ fig:50con ] , with @xmath87 , most formulas are satisfiable and with @xmath88 , most formulas are unsatisfiable.,scaledwidth=80.0% ]    ideas similar to ours were already explored in @xcite , where the authors studied an algorithm named hspqbf that uses survey propagation ( sp ) as decision heuristics in a qbf solver quaffle @xcite .",
    "we see that using bp as decision heuristics is more stable than sp because sp has a narrow region of working parameter .",
    "recall that in random sat formulas with number of variables going to infinity , bp reports correct marginals with constraint density ranging from zero to the condensation transition point  @xcite .",
    "however , sp always has trivial solution ( zero messages ) when the constrain density is smaller than a value that lies relatively close to the sat - unsat transition point  @xcite .",
    "moreover , hard qbf instances are often located in the region where sat formula created by ignoring the quantifiers is easy and sp often has trivial solution , but bp works well .",
    "we cross - checked these intuitions using bph to guide quaffle , and compared running time of dpll in solving random @xmath59 instances by bph guided quaffle and hspqbf in fig .",
    "[ fig:30time ] .",
    "the figure indicates that in the whole range of @xmath67 , quaffle with bph gives better results than hspqbf .",
    "we also checked other types of random formulas , similar results are obtained .",
    "time used by quaffle+bph and by hspqbf  @xcite in solving random @xmath59 formulas , data are averaged over @xmath86 instances . @xmath89 and @xmath90 .",
    ", scaledwidth=80.0% ]",
    "our bph decision heuristics for dpll works naturally in qbf with multiple alternations . to test performance of bph in general qbf , we tested model - b formulas with @xmath91 alternations , results are plotted in fig .  [",
    "fig : mb20con ] . as the figure shows , for small @xmath67 bph improves the performance considerably .",
    "however , it gives only small performance improvement for large @xmath67 when all formulas are unsatisfiable .",
    "number of conflicts , solutions and time used by dpll of qube7.2 in solving model - b formulas , data are averaged over @xmath81 instances .",
    "formulas have @xmath91 alternations and @xmath92 variables in each alternation .",
    "each clause in the formula contains @xmath91 existential variables that are selected randomly from all the existential variables ( i.e. from the 2nd and 4th level variables ) and @xmath93 universal variable that is selected randomly from all the universal variables ( i.e. from the 1st and 3rd level variables ) .",
    "@xmath67 in figure corresponds to number of clauses divided by @xmath12 . in generating formula , we use formula generator downloaded from qbflib @xcite . , title=\"fig:\",scaledwidth=50.0% ]   number of conflicts , solutions and time used by dpll of qube7.2 in solving model - b formulas , data are averaged over @xmath81 instances .",
    "formulas have @xmath91 alternations and @xmath92 variables in each alternation .",
    "each clause in the formula contains @xmath91 existential variables that are selected randomly from all the existential variables ( i.e. from the 2nd and 4th level variables ) and @xmath93 universal variable that is selected randomly from all the universal variables ( i.e. from the 1st and 3rd level variables ) .",
    "@xmath67 in figure corresponds to number of clauses divided by @xmath12 . in generating formula",
    ", we use formula generator downloaded from qbflib @xcite . , title=\"fig:\",scaledwidth=50.0% ]",
    "number of conflicts , solutions and time used by dpll of qube7.2 in solving model - b formulas , data are averaged over @xmath81 instances .",
    "formulas have @xmath91 alternations and @xmath92 variables in each alternation .",
    "each clause in the formula contains @xmath91 existential variables that are selected randomly from all the existential variables ( i.e. from the 2nd and 4th level variables ) and @xmath93 universal variable that is selected randomly from all the universal variables ( i.e. from the 1st and 3rd level variables ) .",
    "@xmath67 in figure corresponds to number of clauses divided by @xmath12 . in generating formula",
    ", we use formula generator downloaded from qbflib @xcite . , title=\"fig:\",scaledwidth=50.0% ]   number of conflicts , solutions and time used by dpll of qube7.2 in solving model - b formulas ,",
    "data are averaged over @xmath81 instances .",
    "formulas have @xmath91 alternations and @xmath92 variables in each alternation .",
    "each clause in the formula contains @xmath91 existential variables that are selected randomly from all the existential variables ( i.e. from the 2nd and 4th level variables ) and @xmath93 universal variable that is selected randomly from all the universal variables ( i.e. from the 1st and 3rd level variables ) .",
    "@xmath67 in figure corresponds to number of clauses divided by @xmath12 . in generating formula",
    ", we use formula generator downloaded from qbflib @xcite . , title=\"fig:\",scaledwidth=50.0% ]    a multi - alteration qbf can be transformed to a @xmath94-alternation qbf by changing the order of universal and existential variables .",
    "for example , given a 4-alternation qbf @xmath95 , we can arrive at @xmath96 by switching the order of @xmath97 and @xmath98 .",
    "one can prove that if @xmath99 is unsatisfiable , then @xmath100 is unsatisfiable .",
    "the heuristic algorithm can be used to prove the unsatisfiability of @xmath99 , and so that of @xmath100 .",
    "in contrast with random formulas , bp usually does not give accurate information about the solution space on structured formulas because of existence of many short loops .",
    "hence we do not expect bp to improve complete solvers in solving every structured formulas .",
    "we tested some structured benchmarks from qbflib  @xcite , part of the results are listed in table 1 .",
    "we can see from the table that on some formulas , bph increases the performance of qube7.2 while in other formulas , bph decreases the performance .",
    "remarkably , some instances e.g. _ ncf_16_64_8_edau.8 _ problem and _ ii8c1 - 50 _ problem , which have not been solved by other solvers ( in previous qbf evaluations ) , can be solved by qube7.2+bph in few seconds .",
    "[ table : benchmarks ]    .running time ( in seconds ) of qube7.2 and qube7.2+bph in solving structured benchmarks . [ cols=\"^,^,^,^,^,^,^\",options=\"header \" , ]",
    "in this paper we developed heuristic and complete algorithms for qbf based on message passing .",
    "our heuristic algorithm bpdu and bpspdu use message passing to find a universal assignment that evaluates to an unsatisfiable remaining formula , thus to prove the unsatisfiability of @xmath94-alternation qbf .",
    "our complete algorithm is based on dpll process , which searches the whole configurational space by backtracking more efficiently using message passing branching heuristics bpdh and bph .",
    "our algorithms described above can be downloaded from @xcite .",
    "both our algorithms work very well on random qbf and in some cases they provide large improvement also on structured qbf and solve some previously unsolved benchmarks in qbflib .",
    "these results should encourage further investigation of the use of message passing as heuristic solvers or as guides for heuristics included in dpll - like complete solvers .",
    "r.z . and p.z .",
    "would like to thank massimo narizzano for discussing and sharing the source code of qube7.2 .",
    "p.z . would like to thank minghao yin and junping zhou for discussing and sharing the source code of hspqbf .",
    "biere , a. , biere , a. , heule , m. , van maaren , h. , walsh , t. : handbook of satisfiability : volume 185 frontiers in artificial intelligence and applications .",
    "ios press , amsterdam , the netherlands , the netherlands ( 2009 )    interian , y. , corvera , g. , selman , b. , williams , r. : finding small unsatisfiable cores to prove unsatisfiability of qbfs .",
    "ninth international symposium on ai and mathematics .",
    "fort lauderdale , florida ( 2006 ) , http://www.cs.cornell.edu/~gec27/report/wmq.asp                zhang , l. , madigan , c.f . ,",
    "moskewicz , m.h . ,",
    "malik , s. : efficient conflict driven learning in a boolean satisfiability solver . in : proceedings of the 2001 ieee / acm international conference on computer - aided design 279 ( 2001 )      krzakala , f. , montanari , a. , ricci - tersenghi , f. , semerjian , g. , zdeborov , l. : gibbs states and the set of solutions of random constraint satisfaction problems .",
    "104 , 10318 ( 2007 )"
  ],
  "abstract_text": [
    "<S> we introduce two types of message passing algorithms for quantified boolean formulas ( qbf ) . </S>",
    "<S> the first type is a message passing based heuristics that can prove unsatisfiability of the qbf by assigning the universal variables in such a way that the remaining formula is unsatisfiable . in the second type , we use message passing to guide branching heuristics of a davis - putnam logemann - loveland ( dpll ) complete solver . </S>",
    "<S> numerical experiments show that on random qbfs our branching heuristics gives robust exponential efficiency gain with respect to the state - of - art solvers . </S>",
    "<S> we also manage to solve some previously unsolved benchmarks from the qbflib library . </S>",
    "<S> apart from this our study sheds light on using message passing in small systems and as subroutines in complete solvers . </S>"
  ]
}