{
  "article_text": [
    "emerging 3g/4 g wireless networks can be categorized as high - speed , ip - based , packet access networks .",
    "they utilize the channel variability , using data rate adaptation , and user diversity to increase their channel capacity .",
    "these systems usually employ a mixture of time and code division multiple access ( tdma / cdma ) schemes .",
    "time is divided into equal size slots , each of which can be allocated to one or more users . to optimize the use of the enhanced data rate , these systems allow several users to share the wireless channel simultaneously using cdma .",
    "this will minimize the wasted capacity resulting from the allocation of the whole channel capacity to one user at a time even when that user is unable to utilize all of that capacity .",
    "another reason for sharing system capacity between several users , at the same time slot , is that some of the user equipments at the receiving side might have design limitations on the amount of data they can receive and process at a given time .",
    "the connectivity of users to the base station in any wireless system is varying with time and can be best modeled as a random process .",
    "the application of stochastic modeling and queuing theory to model wireless systems is well vetted in the literature .",
    "modeling wireless systems using parallel queues with random queue / server connectivity was used by tassiulas and ephremides @xcite , ganti , modiano and tsitsiklis @xcite and many others to study scheduler optimization in wireless systems . in the following subsection",
    ", we provide a more formal model description and motivation for the problem at hand .      in this work",
    ", we assume that time is slotted into equal length deterministic intervals .",
    "we model the wireless system under investigation as a set of @xmath0 parallel queues with infinite capacity ( see figure [ fig_1 ] ) ; the queues correspond to the different users in the system .",
    "we define @xmath2 to represent the number of packets in the @xmath3 queue at the beginning of time slot @xmath4 .",
    "the queues share a set of @xmath1 identical servers , each server representing a network resource , e.g. , transmission channel .",
    "we make no assumption regarding the number of servers relative to the number of queues , i.e. , @xmath1 can be less , equal or greater than @xmath0 .",
    "the packets in this system are assumed to have constant length , and require one time slot to complete service",
    ". a server can serve one packet only at any given time slot .",
    "a server can only serve connected , non - empty queues . therefore , the system can serve up to @xmath1 packets during each time slot .",
    "those packets may belong to one or several queues .",
    "the channel connectivity between a queue and any server is random .",
    "the state of the channel connecting the @xmath3 queue to the @xmath5 server during the @xmath6 time slot is denoted by @xmath7 and can be either connected ( @xmath8 ) or not connected ( @xmath9 ) . therefore ,",
    "in a real system @xmath7 will determine if transmission channel @xmath10 can be used by user @xmath11 or not .",
    "we assume that @xmath7 , for all @xmath12 , @xmath13 and @xmath4 , are independent , bernoulli random variables with parameter @xmath14 .",
    "the number of arrivals to the @xmath3 queue during time slot @xmath4 is denoted by @xmath15 .",
    "the random variables @xmath16 is assumed to have bernoulli distribution .",
    "we require that arrival processes to different queues be independent of each other ; we further require that the random processes @xmath17 be independent of the processes @xmath18 for @xmath12 , @xmath13 .",
    "the symmetry and independence assumptions are necessary for the coupling arguments we use in our optimality proofs .",
    "the rest are simplifying assumptions that can be relaxed at the price of a more complex and maybe less intuitive proof .",
    "a scheduling policy ( or server allocation policy or scheduler ) decides , at the beginning of each time slot , what servers will be assigned to which queue during that time slot .",
    "the objective of this work is to identify and analyze the optimal scheduling policy that minimizes , in a stochastic ordering sense , a range of cost functions of the system queue sizes , including the total number of queued packets , in the aforementioned system .",
    "the choice of the class of cost functions and the minimization process are discussed in detail in section [ yv : main - result ] .          in the literature , there is substantial research effort focusing on the subject of optimal scheduling in wireless networks with random connectivity .",
    "tassiulas and ephremides @xcite studied the problem of allocating a single , randomly connected server to a set of parallel queues .",
    "they proved , using stochastic coupling arguments , that a lcq ( longest connected queue ) policy is optimal . in our work",
    "we investigate a more general model that studies the optimal allocation of @xmath19 randomly connected servers to parallel queues .",
    "we show that lcq is not always optimal in a multi - server system where multiple servers can be allocated to each queue at any given time slot .",
    "bambos and michailidis @xcite worked on a similar model ( a continuous time version of @xcite with finite buffer capacity ) and proved that under stationary ergodic input job flow and modulation processes , both ` maximum connected workload ' and lcq dynamic allocation policies maximize the stability region for this system .",
    "furthermore , they proved that a policy that allocates the server to the connected queue with the fewest empty spaces , stochastically minimizes the loss flow and maximizes the throughput @xcite .",
    "another relevant result is that reported by ganti , modiano and tsitsiklis @xcite .",
    "they presented a model for a satellite node that has @xmath1 transmitters .",
    "the system was modeled by a set of parallel queues with symmetrical statistics competing for @xmath1 identical , randomly connected servers . at each time slot ,",
    "no more than one server is allocated to each scheduled queue .",
    "they proved , using stochastic coupling arguments , that a policy that allocates the @xmath1 servers to the @xmath1 longest connected queues at each time slot , is optimal .",
    "this model is similar to the one we consider in this work , except that in our model one or more servers can be allocated to each queue in the system .",
    "a further , stronger difference between the two models is that we consider the case where each queue has _ independent connectivities _ to different servers .",
    "we make these assumptions for a more suitable representation of the 3g/4 g wireless systems described earlier .",
    "these differences make it substantially harder to identify ( and even describe ) the optimal policy ( see section [ sec : mbpolicies ] ) .",
    "a more recent result that has relevance to our work is the one reported by kittipiyakul and javidi in @xcite .",
    "they proved , using dynamic programming , that a ` maximum - throughput and load - balancing ' policy minimizes the expected average cost for a two - queue , multi - server system with random connectivity . in our research work ,",
    "we prove optimality of the most balancing policies in the more general problem of a multi - queue ( more than two queues ) and multi - server system with random channel connectivity . a stronger distinction of our work is that we proved the optimality in a stochastic ordering sense which is a stronger notion of optimality compared to the expected average cost criterion that was used in @xcite .",
    "lott and teneketzis @xcite investigated a multi - class system of @xmath20 weighted cost parallel queues and @xmath21 servers with random connectivity .",
    "they also used the same restriction of one server per queue used in @xcite .",
    "they showed that an index rule is optimal and provided conditions sufficient , but not necessary , to guarantee its optimality .",
    "koole et al @xcite studied a model similar to that of @xcite and @xcite .",
    "they found that the ` best user ' policy maximizes the expected discounted number of successful transmissions .",
    "liu et al @xcite , @xcite studied the optimality of opportunistic schedulers ( e.g. , proportional fair ( pf ) scheduler ) .",
    "they presented the characteristics and optimality conditions for such schedulers .",
    "however , andrews @xcite showed that there are six different implementation algorithms of a pf scheduler , none of which is stable . for more information on resource allocation and optimization in wireless networks",
    "the reader may consult @xcite , @xcite , @xcite , @xcite , @xcite , and @xcite .",
    "the model we present in this work can be applied to many of the previous work described above . in section [ sec : final - remarks ] we discuss this applicability for three key publications , namely @xcite , @xcite and @xcite , that are strongly related to our own .",
    "we also show how our model can be reduced to their models and used to describe the problems they investigated . in summary ,",
    "the main contributions of our work are the following :    1 .   we introduce and show the existence of the class of most balancing ( mb ) scheduling policies in the model of figure [ fig_1 ] ( see equations ( [ eq : kappa ] ) and ( [ eq : mbpolicy ] ) ) . intuitively , an mb policy attempts to balance all queue sizes at every time slot , so that the total sum of queue size differences will be minimized .",
    "we prove the optimality of mb policies for minimizing , in stochastic ordering sense , a set of functionals of the queue lengths ( see theorem [ thm:3 ] ) .",
    "3 .   we provide low - overhead , heuristic approximations for an mb policy . at any time slot ,",
    "such policies allocate the `` least connected servers first '' to their `` longest connected queues '' ( lcsf / lcq ) .",
    "these policies have @xmath22 complexity and thus can be easily implemented .",
    "we evaluate the performance of these approximations via simulations .",
    "the rest of the article is organized as follows . in section",
    "ii , we introduce notation and define the scheduling policies . in section iii ,",
    "we introduce and provide a detailed description of the mb policies . in section iv , we introduce and characterize _ balancing interchanges _ , that we will use in the proof of mb optimality . in section v , we present the main result , i.e. , the optimality of mb policies . in section",
    "vi , we present the least balancing ( lb ) policies , and show that these policies perform the worst among all work conserving policies .",
    "mb and lb policies provide upper and lower performance bounds .",
    "in section vii , we introduce practical , low - overhead approximations for such policies , namely the lcsf / lcq policy and the mcsf / scq policy , with their implementation algorithms . in section viii , we present simulation results for different scheduling policies . in section ix , we give some final remarks that show the applicability of our model to problems studied in previous work .",
    "we present proofs for some of our results in the appendix .",
    "recall that @xmath0 and @xmath1 denote the number of queues and servers respectively in the model introduced in figure [ fig_1 ] .",
    "we will use * bold face * , upper case and lower case letters to represent vector / matrix quantities , random variables and sample values respectively . in order to represent the policy action that corresponds to `` idling '' a server",
    ", we introduce a special , `` dummy '' queue which is denoted as queue 0 .",
    "allocating a server to this queue is equivalent to idling that server . by default ,",
    "queue 0 is permanently connected to all servers and contains only `` dummy '' packets .",
    "let @xmath23 denote the indicator function for condition @xmath24 . throughout this article , we will use the following notation :    * @xmath25 is an @xmath26 matrix , where @xmath7 for @xmath27 is the channel connectivity random variable as defined in section [ yv : intro_section ] . by assumption ,",
    "@xmath28 for all @xmath29 .",
    "* @xmath30 is the vector of queue lengths at the beginning of time slot @xmath4 , measured in number of packets .",
    "we assume @xmath31 .",
    "* @xmath32 is the _",
    "withdrawal control_. for any @xmath11 , @xmath33 denotes the number of packets withdrawn from queue @xmath11 ( and assigned to servers ) during time slot @xmath4 .",
    "* @xmath34 is the vector of the number of exogenous arrivals during time slot @xmath4 .",
    "arrivals to queue @xmath35 are as defined in section [ yv : intro_section ] . * for ease of reference , we call the tuple @xmath36 the `` state '' of the system at the beginning of time slot @xmath4 .    for any ( feasible ) control ( @xmath37 ) , the system described previously evolves according to @xmath38    we assume that arrivals during time slot @xmath4 are added after removing served packets .",
    "therefore , packets that arrive during time slot @xmath4 have no effect on the controller decision at that time slot and may only be withdrawn during @xmath39 or later . for convenience and in order to ensure that @xmath40 for all @xmath4 , we define @xmath41 .",
    "we define controller policies more formally next",
    ".      the withdrawal control defined earlier does not provide any information regarding server allocation .",
    "such information is necessary for our optimality proof . to capture such information",
    ", we define the vector @xmath42 , where @xmath43 denotes the index of the queue that is selected ( according to some rule ) to be served by server @xmath10 during time slot @xmath4 .",
    "note that serving the  dummy \" queue , i.e. , setting @xmath44 indicates that server @xmath10 is idling during time slot @xmath4 . for future reference",
    ", we will call @xmath42 the _ scheduling ( or server allocation ) control_.    using the previous notation and given a scheduling control vector @xmath42 we can compute the withdrawal control vector as : @xmath45    we say that a given vector @xmath46 is a _ feasible _ scheduling control ( during time slot @xmath4 ) if : ( a ) a server is allocated to a connected queue , and , ( b ) the number of servers allocated to a queue ( dummy queue excluded ) can not exceed the size of the queue at time @xmath4 . similarly , we say that a vector @xmath47 is a _",
    "feasible _ withdrawal control ( during time slot @xmath4 ) if there exists a feasible scheduling control @xmath42 that satisfies equation ( [ yi_qi ] ) .",
    "conditions ( a ) and ( b ) above are also necessary for feasibility of a scheduling control vector @xmath42 . from equation ( [ yi_qi ] ) , a feasible withdrawal control @xmath37 satisfies the following necessary conditions : @xmath48 for the rest of this article , we will refer to @xmath42 as an _ implementation _ of the given feasible control @xmath37 .",
    "we denote the set of all feasible withdrawal controls while in state @xmath49 by @xmath50 .    note from equation ( [ yi_qi ] )",
    "that , given a feasible scheduling control @xmath42 , a feasible withdrawal control @xmath37 can be readily constructed .",
    "note , however , that , for any feasible @xmath37 , the feasible scheduling control @xmath42 may not be unique .",
    "furthermore , given a feasible @xmath51 , the construction of the scheduling control @xmath42 may not be straightforward and a feasible withdrawal vector @xmath37 , one can determine the feasible scheduling control by performing a brute - force search over all feasible vectors @xmath42 . ] and will not be examined in this article .",
    "a _ scheduling policy _ @xmath52 ( or policy @xmath52 for simplicity ) is a rule that determines feasible withdrawal vectors @xmath37 for all @xmath4 , as a function of the past history and current state of the system @xmath53 .",
    "the state history is given by the sequence of random variables @xmath54    let @xmath55 be the set of all state histories up to time slot @xmath4 . then a policy @xmath52 can be formally defined as the sequence of measurable functions @xmath56 where @xmath57 is the set of non - negative integers and @xmath58 , where the cartesian product is taken @xmath59 times .    at each time slot , the following sequence of events happens : first , the connectivities @xmath25 and the queue lengths @xmath60 are observed .",
    "second , the packet withdrawal vector @xmath37 is determined according to a given policy .",
    "finally , the new arrivals @xmath61 are added to determine the next queue length vector @xmath62 .",
    "we denote the set of all scheduling policies described by equation ( [ eq : policy ] ) by @xmath63 .",
    "we introduce next a subset of @xmath63 , namely the class of _ most balancing _ ( mb ) policies .",
    "the goal of this work is to prove that mb policies are optimal ( in a stochastic ordering sense ) .",
    "in this section , we provide a description and mathematical characterization of the class of mb policies . intuitively , the mb policies  attempt to minimize the queue length differences in the system at every time slot @xmath4 \" . for a more formal characterization of mb policies ,",
    "we first define the following :    given a state @xmath64 and a policy @xmath52 that chooses the feasible control @xmath65 at time slot @xmath4 , define the `` updated queue size '' @xmath66 as the size of queue @xmath67 , after applying the control @xmath68 and just before adding the arrivals during time slot @xmath4 .",
    "note that because we let @xmath69 , we have @xmath70 where @xmath71 is the set of all integers ,",
    "i.e. , we allow @xmath72 to be negative .",
    "we define @xmath73 , the _",
    "`` imbalance index '' _ of policy @xmath52 at time slot @xmath4 , as the following sum of differences :    @xmath74}(n ) -\\hat x_{[j]}(n ) ) , \\ ] ]    where @xmath75 $ ] denotes the index of the @xmath76 longest queue after applying the control @xmath77 and before adding the arrivals at time slot @xmath4 . by convention ,",
    "queue ` @xmath78 ' ( the  dummy queue \" ) will always have order @xmath59 ( i.e. , the queue with the minimum length ) .",
    "this definition ensures that the differences are nonnegative and a pair of queues is accounted for in the summation only once ; moreover , as we shall see in lemma [ lem : alg1c ] , this definition allows for a straightforward calculation and comparison of various policies ) that use lexicographic ordering of queues and `` min - max '' definitions ( e.g. , minimize the length of the largest queue ) .",
    "however , we were not able to derive results equivalent to lemma [ lem : alg1c ] . ] .",
    "it follows from equation ( [ eq : kappa ] ) that the minimum possible value of the imbalance index is equal to @xmath79}$ ] ( i.e. , all @xmath0 queues have the same length which is equal to the shortest queue length ) which is indicative of a fully balanced system .",
    "it also follows that the maximum such value is equal to @xmath80 } - ( l-2)\\hat x_{[l]}$ ] .",
    "this value is attained when the @xmath81 longest queues have the same size .",
    "let @xmath82 denote the set of all mb policies , then we define the elements of this set as follows :    * definition : * a _ most balancing _ ( mb )",
    "policy is a policy @xmath83 that , at every @xmath84 , chooses feasible withdrawal vector @xmath85 such that the imbalance index at that time slot is minimized , i.e. , @xmath86    the set @xmath87 in equation ( [ eq : mbpolicy ] ) is well - defined and non - empty , since the minimization is over a finite set .",
    "note that the set of mb policies may have more than one element .",
    "this could happen , for example , when at a given time slot @xmath4 , a server @xmath88 is connected to two or more queues of equal size , which happen to be the longest queues connected to this server after allocating all the other servers . to illustrate this case ,",
    "consider a two - queue system with a single , fully - connected server at time slot @xmath4 .",
    "let @xmath89 .",
    "assume that policy @xmath90 ( respectively @xmath91 ) chooses a withdrawal vector @xmath92 ( respectively @xmath93 ) .",
    "then both policies minimize the imbalance index , and @xmath94 .",
    "given @xmath95 and @xmath96 , one can construct an mb policy using a direct search over all possible server allocations . for large @xmath0 and @xmath1",
    ", this can be a challenging computational task and is not the focus of this work . in section [ heurestic_implem ]",
    ", we provide a low - complexity heuristic algorithm ( lcsf / lcq ) to approximate mb policies .",
    "note that the lcq policy in @xcite is a most balancing ( mb ) policy for @xmath97 ( i.e. , the one server system presented in @xcite ) .",
    "extension of lcq to @xmath19 ( i.e. , allocating all the servers to the longest queue in the multiserver model ) may not result in a mb policy , as the following example demonstrates .",
    "consider a system of three queues with three fully - connected servers during time slot @xmath4 .",
    "let @xmath98 . an lcq policy in the spirit of @xcite that allocates all servers to the longest connected queue results in queue size vector @xmath99",
    "moreover , an lcq policy in the spirit of @xcite that allocates the three servers to the three longest connected queues results in queue size vector @xmath100 . both policies have @xmath101 .",
    "an mb policy results in queue size vector @xmath102 and @xmath101 .      when comparing various policies to an mb policy , the definition in equation ( [ eq : mbpolicy ] ) is cumbersome since it involves all time instants @xmath4 .",
    "the subsets @xmath103 we introduce next define policies that are related to mb policies and allow us to perform comparisons _",
    "one single instant at a time_.    consider any fixed @xmath104 ; we say that a policy @xmath105 `` has the mb property '' at time @xmath4 , if @xmath52 achieves the minimum value of the index @xmath73 .",
    "* definition : * for any given time @xmath106 , @xmath103 denotes the set of policies that have the mb property at all time slots @xmath107 ( and are arbitrary for @xmath108 ) .",
    "we have that @xmath109 .",
    "note that the set @xmath103 is not empty , since mb policies are elements of it .",
    "we can easily see that these sets form a monotone sequence , with    @xmath110    then the set @xmath87 in equation ( [ eq : mbpolicy ] ) can be defined as    @xmath111    the vector @xmath112 defined in equation ( [ eq : i1 ] ) is a measure of how much an arbitrary policy @xmath52 differs from a given mb policy during a given time slot @xmath4 .",
    "* definition : * consider a given state @xmath113 and a policy @xmath114 that chooses the feasible withdrawal vector @xmath77 during time slot @xmath4 .",
    "let @xmath115 be a withdrawal vector chosen by an mb policy during the same time slot @xmath4 .",
    "we define the ( @xmath116-dimensional vector @xmath117 as @xmath118    note that , for notational simplicity , we omit the dependence of @xmath112 on the policies and the time index @xmath4 .",
    "intuitively , a negative element @xmath119 of vector @xmath112 indicates that more packets than necessary ( compared to a policy that has the mb property ) have been removed from queue @xmath11 under policy @xmath52 .",
    "the following lemma quantifies the difference between an arbitrary policy and an mb policy ( at time @xmath4 ) . its proof is given in appendix [ appendixb1iii ] .",
    "[ lem : i1 ] consider a given state @xmath113 and a policy @xmath120 .",
    "then , ( a ) if @xmath121 , the policy @xmath52 has the mb property at time @xmath4 , and , ( b ) if @xmath52 has the mb property at time @xmath4 , the vector @xmath112 has components that are @xmath122 or @xmath123 only .    consider a policy @xmath120 ; let @xmath124 . as we show in the appendix ( see lemma [ lem : i2 ] ) , @xmath125 is integer - valued and @xmath126 .",
    "in view of lemma [ lem : i1 ] , @xmath125 can be seen as a measure of `` how close '' the policy @xmath52 is to having the mb property at time @xmath4 .",
    "* definition : * for any given time @xmath4 and integer @xmath127 , where @xmath128 , define the set @xmath129 as the set that contains all policies @xmath130 , such that @xmath131 .",
    "from lemma [ lem : i1 ] , we can see that @xmath132 .",
    "we can easily check that @xmath133 , so @xmath134 by default .",
    "@xmath135 forms a monotone sequence , with    @xmath136    we exploit the monotonicity property of the @xmath137 sets in the next section , when we show how balancing interchanges reduce the imbalance index of a given policy .",
    "note that the set @xmath63 of all policies can be denoted as    @xmath138    it follows from the last two equations that an arbitrary policy @xmath105 will also belong to a set @xmath139 , for some @xmath140 .",
    "the proof of optimality in section [ yv : main - result ] is based on comparisons of @xmath52 to a series of policies that belong to the subsets @xmath137 ( see lemma [ lem:6 ] ) .",
    "in this section , we introduce the notion of `` balancing interchanges '' .",
    "intuitively , an _ interchange _ @xmath141 between two queues , @xmath142 and @xmath143 , describes the action of withdrawing a packet from queue @xmath142 instead of queue @xmath143 ( see equations ( [ eq:30002 ] ) and ( [ eq:30003 ] ) ) .",
    "such interchanges are used to relate the imbalance indices of various policies ( see equation ( [ eq : i001 ] ) ) ; _ balancing _ interchanges are special in two ways : ( a ) they do not increase the imbalance index ( see lemma [ lem : yv1 ] ) and thus provide a means to describe how a policy can be modified to obtain the mb property at time @xmath4 , and , ( b ) they preserve the queue size ordering we define in the next section ( see relations r1-r3 in section [ preferredorder - section ] ) .",
    "this ordering is crucial in proving optimality .",
    "interchanges can be implemented via server reallocation .",
    "since there are @xmath1 servers , it is intuitive that at most @xmath1 interchanges suffice to convert any arbitrary policy to a policy that has the mb property at time @xmath4 .",
    "the crux of lemma [ lem : i6 ] , the main result of this section , is that such interchanges are _",
    "balancing_.      let @xmath144 represent the indices of two queues that we refer to as the ` from ' and ` to ' queues .",
    "define the @xmath145-dimensional vector @xmath141 , whose @xmath10-th element is given by : @xmath146    fix an initial state @xmath147 at time slot @xmath4 ; consider a policy @xmath52 with a ( feasible ) withdrawal vector @xmath148 .",
    "let @xmath149 be another withdrawal vector .",
    "the two vectors @xmath150 differ only in the two components @xmath151 ; under the withdrawal vector @xmath152 , an additional packet is removed from queue @xmath142 , while one packet less is removed from queue @xmath143 .",
    "note that either @xmath143 or @xmath142 can be the dummy queue .",
    "in other words , @xmath153    in the sequel , we will call @xmath141 an _ interchange _ between queues @xmath142 and @xmath143 . we will call @xmath141 a _ feasible interchange _ if it results in a feasible withdrawal vector @xmath152 .",
    "it follows immediately from equations ( [ sys_evol ] ) and ( [ eq : i30000 ] ) that the @xmath141 interchange will result in a new vector , @xmath154 , of updated queue sizes , such that : @xmath155    we are interested next in describing sufficient conditions for ensuring feasible interchanges .",
    "given the state @xmath147 , let @xmath77 be any feasible withdrawal vector at time slot @xmath4 that is implemented via @xmath156 .",
    "we define a `` feasible , single - server reallocation '' ( from queue @xmath143 to queue @xmath142 ) as the reallocation of a single server @xmath88 from queue @xmath143 to queue @xmath142 , such that the new scheduling control @xmath157 is also _ feasible_. the conditions @xmath158 and @xmath159 are sufficient for the reallocation of server @xmath88 ( from queue @xmath143 to queue @xmath142 ) to be feasible .    a feasible , single - server reallocation from queue @xmath143 to queue @xmath142 results into a feasible interchange @xmath141 .",
    "however , the reverse may not be true , as we detail in the following section .",
    "consider again the state @xmath64 and feasible scheduling control @xmath156 .",
    "the feasible interchange @xmath141 in equation ( [ eq : i30000 ] ) may result from a _ sequence _ of @xmath160 feasible , single - server reallocations among several queues , as demonstrated in figure [ example ] , where @xmath161 .",
    "single - server reallocations results in a feasible @xmath141 .",
    "the dotted line denotes original server allocation .",
    "the solid line denotes server reallocation that implements @xmath141.,width=259 ]    let @xmath162 denote a sequence of queue indices , where @xmath163 and @xmath164 .",
    "let @xmath165 denote the server reallocated from queue @xmath166 to queue @xmath167 .",
    "then the following are sufficient conditions for the feasibility of the interchange operation of equation ( [ eq : i30000 ] ) :    @xmath168    for some integer @xmath169 and @xmath170 .    constraint",
    "( [ eq : i101 ] ) ensures that connectivity conditions allow for the feasibility of all @xmath160 intermediate single - server reallocations .",
    "the sequence of server reallocations starts by reallocating server @xmath171 to queue @xmath172 . in this case ,",
    "queue @xmath173 is reduced by one packet ( i.e. , an extra packet is withdrawn from queue @xmath142 ) and queue @xmath174 is increased by one packet . constraint ( [ eq : i102.1 ] ) ensures that a packet can be withdrawn from queue @xmath142 .",
    "the reallocation of server @xmath171 insures that queue @xmath174 contains at least one packet for the second intermediate single - server reallocation to be feasible even when @xmath175 .",
    "same is true for any queue @xmath176 .",
    "therefore , constraints ( [ eq : i101 ] ) and ( [ eq : i102.1 ] ) are also sufficient for the feasibility of the interchange @xmath141 .      *",
    "definition : * a feasible interchange @xmath141 is `` _ _ balancing _ _ '' if @xmath177    @xmath141 is `` _ _ unbalancing _ _ '' if @xmath178    balancing interchanges result in policies that may reduce the imbalance index , as the following lemma states .",
    "[ lem : yv1 ] consider two policies @xmath179 and @xmath52 , related via the balancing interchange @xmath180 at time slot @xmath4 .",
    "then the imbalance indices for the two policies are related via @xmath181}(n ) \\geq",
    "\\hat x_{[s]}(n ) + 2 \\ } } \\ ] ] where @xmath182 ( respectively @xmath183 ) is the order of queue @xmath142 ( respectively @xmath143 ) in @xmath184 when ordered in descending order , such that , @xmath185 and @xmath186 .",
    "( respectively @xmath187 ) only the last ( respectively the first ) of the components in order is considered .",
    "intuitively , we use @xmath183 ( respectively @xmath182 ) to refer to the order of the `` shorter '' ( respectively the `` longer '' ) queue of the two queues used in the interchange . ] .",
    "the proof is a direct consequence of lemma [ lem : alg1c ] in appendix [ appendixb1 ] and the fact that , by definition of the balancing interchange , we have @xmath188 .    in words ,",
    "equation ( [ eq : i001 ] ) states that an interchange @xmath141 , when balancing , results in : either a cost reduction of @xmath189 ( when @xmath190}(n ) \\geq \\hat",
    "x_{[s]}(n ) + 2 = \\hat x_{t}(n)+2 $ ] ) or an unchanged cost ( when @xmath191 ) .",
    "the latter case agrees with intuition , since the balancing interchange in this case will result in simply permuting the lengths of queues @xmath142 and @xmath143 ; this permutation does not change the total sum of differences ( and hence the imbalance index ) in the resulting queue length vector .",
    "we determine next conditions that characterize what interchanges are balancing .",
    "we also describe how balancing interchanges transform an arbitrary policy to an mb policy .",
    "lemma [ lem : i4 ] provides a selection criterion to systematically select balancing ( and hence improving ) interchanges .",
    "lemma [ lem : i6 ] provides a bound on the number of interchanges needed to convert any policy into one that has the mb property at time @xmath4 .",
    "the proofs of the two lemmas are given in appendix [ appendixb1i ] and [ appendixc1i ] respectively .",
    "[ lem : i4 ] consider a given state @xmath113 and a feasible withdrawal vector @xmath77 .",
    "any feasible interchange @xmath141 with indices @xmath142 and @xmath143 such that @xmath192 , @xmath193 is a balancing interchange .",
    "recall that @xmath194 .",
    "consider a sequence of balancing interchanges , @xmath195 .",
    "let    @xmath196 we denote by @xmath197 the policy that chooses the withdrawal vector @xmath198 .",
    "in other words , @xmath197 denotes the policy that results from applying this sequence of interchanges .",
    "[ lem : i6 ] for any policy @xmath130 , @xmath199 balancing interchanges suffice to determine a policy @xmath197 such that @xmath200 .",
    "lemma [ lem : i4 ] can be used to identify queues @xmath201 and @xmath202 during time slot @xmath4 such that the interchange @xmath203 is balancing .",
    "lemma [ lem : i6 ] shows that performing a sequence of such interchanges , determines a policy that has the mb property for one more time slot .",
    "both lemmas are crucial for the proof of our main result , since they indicate how a given policy can be improved using one balancing interchange at a time .",
    "in this section , we present the main result of this article , that is , the optimality of the most balancing ( mb ) policies",
    ". we will establish optimality for a range of performance criteria , including the minimization of the total number of packets in the system .",
    "we introduce the following definition .",
    "let s define the relation @xmath204 on @xmath205 first ; we say @xmath206 if :    1 .",
    "@xmath207 for all @xmath11 ( i.e. , point wise comparison ) , 2 .",
    "@xmath208 is obtained from @xmath209 by permuting two of its components ; the two vectors differ only in two components @xmath11 and @xmath10 , such that @xmath210 and @xmath211 , or 3 .",
    "@xmath208 is obtained from @xmath209 by performing a _  balancing interchange \" _ , in the sense of equation ( [ eq : i001yv ] ) , i.e. , the two vectors differ in two components @xmath27 and @xmath212 only , where @xmath213 , such that : @xmath214 and @xmath215 .    to prove the optimality of mb policies , we will need a methodology that enables comparison of the queue lengths under different policies . towards this end , we define a `` preferred order '' as follows : * definition : ( preferred order)*. the transitive closure of the relation @xmath204 defines a partial order ( which we call _ preferred order _ and use the symbol @xmath216 to represent ) on the set @xmath205 .",
    "the transitive closure @xcite , @xcite of @xmath204 on the set @xmath205 is the smallest transitive relation on @xmath205 that contains the relation @xmath204 . from the engineering point of view , @xmath217 if @xmath218 is obtained from @xmath209 by performing a sequence of _ reductions _ , _ permutations of two components _ and/or _ balancing interchanges_.    for example , if @xmath219 and @xmath220 then @xmath217 since @xmath218 can be obtained from @xmath221 by performing the following two consecutive two - component permutations : first swap the second and third components of @xmath221 , yielding @xmath222 then swap the first and second components of @xmath223 , yielding @xmath224 .",
    "suppose that @xmath225 represent queue size vectors for our model .",
    "statement r3 in this case describes moving a packet from one real , large queue @xmath11 to another smaller one @xmath10 ( note that the queue with index @xmath226 is not excluded since a balancing interchange may represent the allocation of an idled server ) .",
    "we say that @xmath208 is _ more balanced _ than @xmath209 when r3 is satisfied .",
    "for example , if @xmath227 and @xmath228 then a balancing interchange ( where @xmath229 and @xmath230 ) will result in @xmath231 .",
    "let @xmath233 be two vectors representing queue lengths .",
    "then we denote by @xmath232 the class of real - valued functions on @xmath205 that are monotone , non - decreasing with respect to the partial order @xmath216 ; that is , @xmath234 if and only if @xmath235    from ( [ func_class ] ) and the definition of preferred order , it can be easily seen that the function @xmath236 belongs to @xmath232 .",
    "this function corresponds to the total number of queued packets in the system which also belongs to the class @xmath232 . ] .    for two real - valued random variables @xmath24 and @xmath237",
    ", @xmath238 defines the usual stochastic ordering @xcite . in the remainder of this paper",
    ", we say that a policy @xmath239 _ dominates _ another policy @xmath52 if    @xmath240    for all cost functions @xmath234 .",
    "we will need the following lemma to complete the proof of our main result presented in theorem [ thm:3 ] .",
    "[ lem:6 ] consider an arbitrary policy @xmath241 , where @xmath242 .",
    "then , there exists a policy @xmath243 , such that @xmath244 dominates @xmath52 .",
    "the full details of the proof for lemma [ lem:6 ] are given in appendix [ appendixb ] .",
    "the proof involves two parts .",
    "first , we construct a policy @xmath244 by applying a balancing interchange to @xmath52 ; using lemmas [ lem : i4 ] and [ lem : i6 ] , we show that @xmath243 .",
    "second , we prove that @xmath244 dominates policy @xmath52 ( see equation ( [ policy_dominance ] ) ) ; this part employs coupling arguments .      in the following ,",
    "@xmath245 and @xmath246 represent the queue sizes under a mb and an arbitrary policy @xmath52 .",
    "[ thm:3 ] consider a system of @xmath0 queues served by @xmath1 identical servers , as shown in figure [ fig_1 ] with the assumptions of section [ yv : intro_section ] .",
    "a most balancing ( mb ) policy dominates any arbitrary policy when applied to this system , i.e. , @xmath247 for all @xmath120 and all cost functions @xmath234 .    from ( [ func_class ] ) and the definition of stochastic dominance",
    ", it is sufficient to show that @xmath248 for all @xmath143 and all sample paths in a suitable sample space .",
    "the sample space is the standard one used in stochastic coupling methods @xcite ; see appendix [ appendixb ] for more details .    to prove the optimality of an mb policy , @xmath249 , we start with an arbitrary policy @xmath52 and apply a series of modifications that result in a sequence of policies ( @xmath250 ) . the modified policies have the following properties :    1 .",
    "@xmath251 dominates the given policy @xmath52 , 2 .",
    "@xmath252 , i.e. , policy @xmath253 has the mb property at time slots @xmath254 , and , 3 .",
    "@xmath255 dominates @xmath253 for @xmath256 ( i.e. , @xmath257 has the mb property for a longer period of time than @xmath258 ) .",
    "let @xmath52 be any arbitrary policy ; then @xmath259 .",
    "using lemma [ lem:6 ] we can construct a policy @xmath260 that dominates the original policy @xmath52 . repeating this operation",
    "we can construct policies that belong to @xmath261 such that all dominate the original policy @xmath52 .",
    "this sequence of construction steps will result in a policy @xmath90 that has the mb property at @xmath262 , i.e. , @xmath263 , and dominates @xmath52 .",
    "therefore , by construction @xmath264 .",
    "we repeat the construction steps above for time slot @xmath265 , by improving on @xmath90 , to obtain a policy @xmath266 that dominates @xmath90 , and recursively for @xmath267 to obtain policies @xmath268 . from the construction of @xmath269",
    ", we can see that it satisfies properties ( a ) , ( b ) and ( c ) above .",
    "denote the limiting policy as @xmath270 by @xmath179 .",
    "one can see that @xmath179 is an mb policy .",
    "furthermore , @xmath179 dominates @xmath258 , for all @xmath271 , as well as the original policy @xmath52 .",
    "the optimal policy may not be unique .",
    "our main objective is to prove the optimality of the mb policy not its uniqueness .",
    "the optimality of mb policies makes intuitive sense ; any such policy will tend to reduce the chance that any server idles .",
    "this is because an mb policy distributes the servers among the connected queues in the system such that it keeps packets spread among all the queues in a `` uniform '' manner .",
    "the _ least balancing _ ( lb )",
    "policies are the scheduling policies , among all work - conserving ( non - idling ) policies , that at every time slot ( @xmath272 ) , choose a packet withdrawal vector @xmath273 that `` maximizes the differences '' between queue lengths in the system ( i.e. , maximizes @xmath73 in equation ( [ eq : kappa ] ) ) . in other words ,",
    "if @xmath274 is the set of all lb policies and @xmath275 is the set of all work conserving policies then , @xmath276    maximizing the imbalance among the queues in the system will result in maximizing the number of empty queues at any time slot , thus maximizing the chance that servers are forced to idle in future time slots .",
    "this intuitively suggests that lb policies will be outperformed by any work conserving policy .",
    "the next theorem states this fact .",
    "its proof is analogous to that of theorem [ thm:3 ] and will not be given here .",
    "a non - work conserving policy can by constructed such that it will perform worse than lb policies , e.g. , a policy that idles all servers .",
    "[ thm:4 ] consider a system of @xmath0 queues served by @xmath1 identical servers , under the assumptions described in sections [ yv : intro_section ] .",
    "a least balancing ( lb ) policy is dominated by any arbitrary work conserving policy when applied to this system , i.e. , @xmath277 for all @xmath278 and all cost functions @xmath234 .",
    "an lb policy has no practical significance , since it maximizes the cost functions presented earlier .",
    "intuitively , it should also worsen the system stability region and hence the system throughput . however , it is interesting to study the worst possible policy behavior and to measure its performance .",
    "the lb and mb policies provide lower and upper limits to the performance of any work conserving policy .",
    "the performance of any policy can be measured by the deviation of its behavior from that of the mb and lb policies .",
    "in this section , we present two heuristic policies that approximate the behavior of the mb and lb policies respectively .",
    "we present an implementation algorithm for each one of them .",
    "we introduce the _ least connected server first / longest connected queue _ ( lcsf / lcq ) policy , a low - overhead approximation of mb policy , with @xmath279 computational complexity .",
    "the policy is stationary and depends only on the current state @xmath36 during time slot @xmath4 .",
    "the lcsf / lcq implementation during a given time slot is described as follows : the least connected server is identified and is allocated to its longest connected queue .",
    "the queue length is updated ( i.e. , decremented ) .",
    "we proceed accordingly to the next least connected server until all servers are assigned . in algorithmic terms",
    ", the lcsf / lcq policy can be described / implemented as follows :    let @xmath280 denote the set of queues that are connected to server @xmath10 during time slot @xmath143 ; we omit the dependence on @xmath143 to simplify notation .",
    "let @xmath281}$ ] be the @xmath3 element in the sequence @xmath282 , when ordered in ascending manner according to their size ( set cardinality ) , i.e. , @xmath283}| \\geq |\\mathds{q}_{[m]}|$ ] if @xmath284 .",
    "ties are broken arbitrarily . then under the lcsf / lcq policy ,",
    "the @xmath1 servers are allocated according to the following algorithm :    [ eq3 ]    1 .",
    "& for t = 1,2,  do \\ { + 2 . &",
    "( t),(t ) . _",
    "[ l ] , l = 1,  ,k .",
    "( t ) , , + 4 .",
    "& for j = 1 to k \\ { + 5 . &",
    "l : l_k : k_[j ] ( x_k|x_k>0 ) ) + 6 .",
    "& for i = 1 to l \\ { + 7 . &",
    "y_i = y_i+ _ i= q_[j ]   + 8 . &",
    "x_i = x_i(t)-y_i } } + 9 . &",
    "( t ) , ( t ) + 10 .",
    "& }    note that in line 5 of algorithm [ eq3 ] , if the set @xmath285}$ ] is empty , then the @xmath286 returns the empty set . in this case , the @xmath5 order server will not be allocated ( i.e. , will be idle during time slot @xmath143 ) .",
    "algorithm [ eq3 ] produces two outputs , when it is run at @xmath287 : @xmath288 and @xmath289 as shown in line 9 of the algorithm . in accordance to the definition of a policy in equation ( [ eq : policy ] )",
    ", the lcsf / lcq policy can be formally defined as the sequence of time - independent mappings @xmath290 that produce the withdrawal vector @xmath148 described in line 9 above .",
    "[ lem : lcsf_not_mb ] lcsf / lcq is not an mb policy .    to prove lemma [ lem : lcsf_not_mb ] we present the following counter example .",
    "consider a system with @xmath291 and @xmath292 . at time",
    "slot @xmath4 the system has the following configuration :    the queue state at time slot @xmath4 is @xmath293 .",
    "servers 1 to 6 are connected to queues 1 , 2 and 3 and server 7 is connected to queues 1 and 4 only .    under this configuration , we can show that the lcsf / lcq algorithm will result in @xmath294 ( where the first element represents the dummy queue that by assumption holds no real packets ) and @xmath295 .",
    "a policy @xmath52 can be constructed that selects the feasible server allocation @xmath296 which yields the state @xmath297 and @xmath298 .",
    "therefore , lcsf / lcq is not an mb policy .",
    "the lcsf / lcq policy is of particular interest for the following reasons : ( a ) it follows a particular server allocation ordering ( lcsf ) to their longest connected queues ( lcq ) and thus it can be implemented using simple sequential server allocation with low computation complexity , ( b ) the selected server ordering ( lcsf ) and allocation ( lcq ) intuitively attempt to reduce the size of the longest connected queue thus reducing the imbalance among queues , and , ( c ) as we will see in section [ sec : simres ] , the lcsf / lcq performance is statistically indistinguishable from that of an mb policy ( implying that the counterexamples similar to the one in lemma [ lem : lcsf_not_mb ] proof have low probability of occurrence under lcsf / lcq system operation ) . therefore , lcsf / lcq can be proposed as an approximate heuristic for the implementation of mb policies .      in this section",
    ", we present the mcsf / scq policy as a low complexity approximation of lb policies .",
    "we also provide an implementation algorithm for mcsf / scq using the same sequential server allocation principle that we used in algorithm [ eq3 ] above .",
    "the _ most connected server first / shortest connected queue _",
    "( mcsf / scq ) policy is the server allocation policy that allocates each one of the @xmath1 servers to its shortest connected queue ( not counting the packets already scheduled for service ) starting with the most connected server first .",
    "the mcsf / scq implementation algorithm is analogous to algorithm [ eq3 ] except for lines 4 and 5 which are described next :    [ eq : alg2 ]    1 . & for t = 1,2,  do +   + 4 . & for j = k to 1 + 5 . &",
    "q_[j ] = ( l : l_k : k_[j ] ( x_k|x_k>0 ) ) +   + 10 . &",
    "comments analogous to the ones valid for algorithm [ eq3 ] are also valid for algorithm [ eq : alg2 ] .",
    "we used simulation to study the performance of the system under the mb / lb policies and to compare against the system performance under several other policies .",
    "the metric we used in this study is @xmath299 , the average of the total number of packets in the system .",
    "we focused on two groups of simulations . in the first",
    ", we evaluate the system performance with respect to number of queues ( @xmath0 ) and servers ( @xmath1 ) as well as channel connectivity ( figures [ fig : sr ] to [ figsr3 ] ) .",
    "arrivals are assumed to be i.i.d .",
    "bernoulli . in the second group ( figures [ figsr41 ] to [ figsr43 ] )",
    "we consider batch arrivals with random ( uniformly distributed ) burst size .",
    "the policies used in this simulation are : lcsf / lcq , as an approximation of an mb policy ; mcsf / scq , as an approximation of an lb policy .",
    "an mb policy was implemented using full search , for the cases specified in this section , and its performance was indistinguishable from that of the lcsf / lcq .",
    "therefore , in the simulation graphs the mb and lcsf / lcq are represented by the same curves .",
    "this statement is also true for lb and mcsf / scq policies performances .",
    "other policies that were simulated include the randomized , most connected server first / longest connected queue ( mcsf / lcq ) , and least connected server first / shortest connected queue ( lcsf / scq ) policies .",
    "the randomized policy is the one that , at each time slot , allocates each server randomly and with equal probability to one of its connected queues .",
    "the mcsf / lcq policy differs from the lcsf / lcq policies in the order that it allocates the servers .",
    "it uses the exact reverse order , starting the allocation with the most connected server and ending it with the least connected one .",
    "however , it resembles the lcsf / lcq policies in that it allocates each server to its longest connected queue .",
    "the lcsf / scq policy allocates each server , starting from the one with the least number of connected queues , to its shortest connected queue .",
    "the difference from an lcsf / lcq policy is obviously the allocation to the shortest connected queue .",
    "this policy will result in greatly unbalanced queues and hence a performance that is closer to the lb policies .",
    "figure [ fig : sr ] shows the average total queue occupancy versus arrival rate under the five different policies .",
    "the system in this simulation is a symmetrical system with 16 parallel queues ( @xmath300 ) , 16 identical servers ( @xmath301 ) and i.i.d .",
    "bernoulli queue - to - server ( channel ) connectivity with parameter @xmath302=0.2 $ ] .",
    ", versus load under different policies , @xmath303 and @xmath304.,width=268 ]    the curves in figure [ fig : sr ] follow a shape that is initially almost flat and ends with a rapid increase",
    ". this abrupt increase happens at a point where the system becomes unstable . in this case , the queue lengths in the system will grow fast and the system becomes unstable .",
    "the graph shows that lcsf / lcq , the mb policy approximation outperforms all other policies .",
    "it minimizes @xmath305 and hence the queuing delay .",
    "we also noticed that it maximizes the system stability region and hence the system throughput as well .",
    "the mcsf / scq performed the worst . as expected , the performance of the other three policies lies within the performance of the mb and lb policies .",
    "the mcsf / lcq and lcsf / scq policies are variations of the mb and lb policies respectively .",
    "the performance of mcsf / lcq policy is close to that of the mb policy .",
    "the difference in performance is due to the order of server allocation . on the other hand",
    ", the lcsf / scq policy shows a large performance improvement on that of the lb policy .",
    "this improvement is a result of the reordering of server allocations .",
    "figure [ fig : sr ] also shows that the randomized policy performs reasonably well .",
    "moreover , its performance improves as the number of servers in the system decreases , as the next set of experiments shows .      in this section",
    ", we study the effect of the number of servers on policy performance .",
    "figure [ fig : sr11 ] ( @xmath306 ) and figure [ fig : sr12 ] ( @xmath307 ) show @xmath305 versus arrival rate per queue under the five policies , in a symmetrical system with @xmath300 and @xmath304 .",
    "comparing these two graphs to the one in figure [ fig : sr ] , we notice the following :    first , the performance advantage of the lcsf / lcq ( and hence of an mb policy ) over the other policies increases as the number of servers in the system increases . the presence of more servers implies that the server allocation action space is larger . selecting the optimal ( i.e. , mb ) allocation , over any arbitrary policy , out of a large number of options will result in a better performance as compared to the case when the number of server allocation options is less .",
    "second , the stability region of the system becomes narrower when less servers are used .",
    "this is true because fewer resources ( servers ) are available to be allocated by the working policy in this case .",
    "finally , we notice that the mcsf / lcq performs very close to the lcsf / lcq policy in the case of @xmath307 . apparently ,",
    "when @xmath1 is small , the order of server allocation does not have a big impact on the policy performance .",
    ", versus load , @xmath308 and @xmath304.,width=268 ]    , versus load , @xmath309 and @xmath304.,width=268 ]      in this section we investigate the effect of channel connectivity on the performance of the previously considered policies . figures [ figsr2 ] and [ figsr3 ] show this effect for two choices of @xmath0 and @xmath1 .",
    "we observe the following :    first , we notice that for larger channel connection probabilities ( @xmath310 ) , the effect of the policy behavior on the system performance becomes less significant .",
    "therefore , the performance difference among the various policies is getting smaller .",
    "the lcsf / lcq policy still has a small advantage over the rest of the policies , even though it is statistically difficult to distinguish .",
    "mcsf / scq continues to have the worst performance .",
    "as @xmath14 increases , the probability that a server will end up connected to a group of empty queues will be very small regardless of the policy in effect .",
    "in fact , when the servers have full connectivity to all queues ( i.e. , @xmath311 ) we expect that any work conserving policy will minimize the total number of packets in a symmetrical homogeneous system of queues since , any ( work - conserving ) policy will be optimal in a system with full connectivity .",
    "second , from all graphs we observe that there is a maximum input load that results in a stable system operation ( maximum stable throughput ) .",
    "an upper bound ( for stable system operation ) for the arrival rate per queue @xmath312 is given by @xmath313 i.e. , the average number of packets entering the system ( @xmath314 ) must be less than the rate they are being served . when @xmath311 , the stability condition in inequality ( [ eq : stability ] ) will be reduced to @xmath315 , which makes intuitive sense in such a system .",
    "finally , we observe that the mcsf / lcq policy performance is very close to that of lcsf / lcq .",
    "however , its performance deteriorates in systems with higher number of servers and lower probabilities for queue - server connectivity .",
    "it is intuitive that with more servers available , the effect of the order of server allocations on the policy performance will increase . since mcsf / lcq differs from lcsf / lcq only by the order of server allocation , therefore , more servers implies larger performance difference .",
    "also , the lower the connectivity probability , the higher the probability that a server will end up with no connectivity to any non - empty queue , and hence be forced to idle .",
    "+     +      we studied the performance of the presented policies in the case of batch arrivals with uniformly distributed batch size , in the range @xmath316 .",
    "figure [ figsr4 ] shows @xmath305 versus load for three cases with @xmath317 , and hence average batch sizes 1.5 , 3 , and 5.5 .",
    "the lcsf / lcq policy clearly dominates all the other policies .",
    "however , the performance of the other policies , including mcsf / scq ( lb approximation ) approaches that of the lcsf / lcq policy as the average batch size increases .",
    "the performance of all the policies deteriorates when the arrivals become burstier , i.e. , the batch size increases .",
    "the model and the results presented in this article can be regarded as a generalization ( with the obvious added complexity as well as utility of our model ) of the models and results reported by @xcite , @xcite , and @xcite .    in @xcite , the authors investigated the optimal scheduling policy for a model of @xmath0 parallel queues and one randomly connected server .",
    "this model is a special case of the model we presented in this article , i.e. , when @xmath97 .",
    "using stochastic dominance techniques , they proved that lcq is optimal in that it minimizes the total number of packets in the system . in our work",
    ", we also use stochastic dominance techniques to prove the optimality of mb policies for a wide range of cost functions ( cost functions that are monotone , non - decreasing with respect to the partial order @xmath216 ) including the total number of packets in the system .",
    "it can be easily shown that for the case of a single server ( i.e. , @xmath97 ) the lcq policy minimizes the imbalance index and therefore , lcq belongs to the set of mb policies .    in @xcite ,",
    "the authors investigated the optimal policy for a model of @xmath0 parallel queues with a stack of @xmath1 servers .",
    "each queue is randomly connected to the entire server stack .",
    "only one server can be allocated to a queue at any time slot .",
    "in contrast , our model assumes independent queue - server connectivity , i.e. , a queue can be connected to a subset of the @xmath1 servers and not connected to the rest at any given time slot .",
    "we also allow for multiple servers to be allocated ( when connected ) to any queue .",
    "therefore , the model in @xcite can also be considered as a special case of our model , i.e. , by letting @xmath318 and by adding the feasibility constraint @xmath319 .",
    "they proved that a policy that allocates the @xmath1 servers to the @xmath1 longest connected queues ( lcq ) is optimal . under the constraints above ,",
    "this policy would also minimize the imbalance index among all feasible policies , i.e. , this policy belongs to the set of mb policies .",
    "in @xcite the authors proved that , in a model of two parallel queues ( @xmath227 ) and multiple randomly connected servers , a mtlb ( maximum throughput / load balancing ) policy minimizes the expected total cost .",
    "they defined the cost as a class of functions of the queue lengths for the two queues in the system . in our work , we generalize the model in @xcite as follows : ( a ) we extend the model to @xmath320 , ( b ) we optimize the cost function in the stochastic order sense which implies the expected total cost used in @xcite , and ( c ) we relax the supermodularity and convexity constraints that they enforced on the cost function , i.e. , we prove our results for a larger set of cost functions that includes theirs .",
    "the authors of @xcite defined the mtlb policy as the one that minimizes the lexicographic order of the queue length vector while maximizing the instantaneous throughput .",
    "we can show that mtlb policy belongs to the set of mb policies . to do that",
    ", we have to show that a policy which minimizes the lexicographic order : ( a ) also minimizes the imbalance index , i.e. , it belong to the set of mb policies , and ( b ) is a work - conserving policy .",
    "a work - conserving policy minimizes the number of idling servers and hence , it maximizes instantaneous throughput ( by the definition of instantaneous throughput ) .",
    "lemma [ lem : lexismb ] states these results formally .",
    "[ lem : lexismb ] given the state @xmath321 during time slot @xmath4 .",
    "let @xmath322 be a vector resulted from the feasible withdrawal vector @xmath323 .",
    "suppose that @xmath324 for all feasible @xmath325 .",
    "then : a ) the vector @xmath326 achieves the minimum imbalance index among all feasible vectors , and b ) a policy that selects @xmath327 is a work - conserving policy .",
    "\\a ) assume to the contrary that @xmath326 does not minimize the imbalance index . then there must exist a @xmath328 such that the imbalance index of the vector @xmath329 is strictly less than that of @xmath326 .",
    "this implies that a policy @xmath179 that results in the withdrawal vector @xmath330 , and therefore the vector @xmath326 , belongs to the set @xmath331 for some @xmath242 , i.e. , it does not have the mb property during time slot @xmath4 . for",
    "any given state , a policy that minimizes the imbalance index must exist , ` minimization on a finite set ' . according to lemma 4 , @xmath332",
    "balancing interchanges ( bis are feasible interchanges ) are required to make any policy in @xmath333 belongs to @xmath334 .",
    "lemma d-1 shows that such balancing interchanges are feasible .",
    "therefore , the following _ balancing interchange _ is both feasible and enhancing ( it reduces the imbalance index ) : @xmath335 for any @xmath336 and @xmath337 .    in other words , we perform a feasible server reallocation from the @xmath338 longest queue to the @xmath339 longest queue in the system during time slot @xmath4 .",
    "the resulted leftover vector @xmath329 is related to the vector @xmath326 as follows : @xmath340    since @xmath341 by definition , then it is clear that @xmath342 .",
    "this contradicts the initial assumption .",
    "therefore , @xmath326 must have the minimum imbalance index .",
    "\\b ) a feasible interchange @xmath343 is a balancing one , since by definition of queue 0 and the interchange feasibility conditions , we have @xmath344 .",
    "queue 0 is permanently connected to all servers by assumption . according to lemma b-1",
    "this interchange will definitely reduce the imbalance index .",
    "therefore , any policy that intentionally idles servers can always be improved ( i.e. , reduce its imbalance index ) by using the balancing interchange @xmath345 for some queue @xmath346 .",
    "from part a ) of this lemma , we showed that a policy that minimizes the lexicographic order will also minimize the imbalance index .",
    "we also showed that a policy that idles servers intentionally can not achieve the minimum imbalance index .",
    "therefore , only a work - conserving policy can minimize the lexicographic order .    from the above ,",
    "we conclude that the mtlb belongs to the class of mb policies .",
    "in this work , we presented a model for dynamic packet scheduling in a multi - server systems with random connectivity .",
    "this model can be used to study packet scheduling in emerging wireless systems .",
    "we modeled such systems via symmetric queues with random server connectivities and and bernoulli arrivals .",
    "we introduced the class of most balancing policies .",
    "these policies distribute the service capacity between the connected queues in the system in an effort to `` equalize '' the queue occupancies .",
    "a theoretical proof of the optimality of mb policies using stochastic coupling arguments was presented .",
    "optimality was defined as minimization , in stochastic ordering sense , of a range of cost functions of the queue lengths .",
    "the lcsf / lcq policy was proposed as good , low - complexity approximation for mb policies .",
    "a simulation study was conducted to study the performance of five different policies .",
    "the results verified that the mb approximation outperformed all other policies ( even when the arrivals became bursty ) .",
    "however , the performance of all policies deteriorate as the mean burst size increases . furthermore , we observed ( through simulation ) that the performance gain of the optimal policy over the other policies is reduced greatly in this case .",
    "finally , we observed that a randomized policy can perform very close to the optimal one in several cases .      to prove part ( a ) , assume that @xmath121 ; then , using equation ( [ eq : i1 ] ) , we have : @xmath347 from equations ( [ eq : i11 ] ) and ( [ eq : kappa ] ) , we have that @xmath348 and thus @xmath52 has the mb property during time slot @xmath4 .    to prove part ( b ) , assume that @xmath52 has the mb property at time slot @xmath4 . therefore , @xmath348 . from lemma",
    "[ lem : alg1c ] this is only possible if either : ( i ) @xmath349 , or ( ii ) @xmath350 is obtained by performing a balancing interchange between the pair of the @xmath339 and the @xmath338 longest queues ( @xmath341 ) in @xmath351 such that @xmath352}(n ) = \\hat x_{[s]}(n ) + 1 $ ] , is satisfied ; note that there may be multiple such queue pairs .",
    "the balancing interchange in case ( ii ) will affect the length of two queues only ( call them @xmath11 and @xmath10 ) such that @xmath353 and @xmath354 , where @xmath355 $ ] and @xmath356 $ ] ( for each given pair ) .",
    "therefore , @xmath357 and , @xmath358 while withdrawals from the remaining queues will be the same , i.e. , @xmath359    from equations ( [ eq : i12 ] ) through ( [ eq : i13.1 ] ) , we conclude that the vector @xmath112 has components that are @xmath122 or @xmath123 only .      in this section",
    ", we present a lemma that quantifies the effect of performing a balancing interchange on the imbalance index @xmath73 .",
    "[ lem : alg1c ] let @xmath360 and @xmath361 be two @xmath59-dimensional ordered vectors ( in descending order ) ; suppose that @xmath361 is obtained from @xmath360 by performing a balancing interchange @xmath362 between two components , @xmath182 and @xmath183 , of @xmath360 , where @xmath363 , such that , @xmath185 and @xmath186 . then @xmath364    we generate the vector @xmath361 by performing a _ balancing interchange _ of two components , @xmath182 and @xmath183 ( i.e. , the @xmath339 and the @xmath338 largest components ) , in the vector @xmath360 and reorder the resulted vector in descending manner .",
    "the resulted vector @xmath361 is characterized by the following : @xmath365 where @xmath366 ( respectively @xmath367 ) is the new index ( i.e. , the order in the new vector @xmath361 ) of component @xmath182 ( respectively @xmath183 ) in the original vector @xmath360 .",
    "from equation ( [ eq : lemb1_2 ] ) we can identify @xmath368 elements that have the same magnitude in the two vectors @xmath360 and @xmath361 .",
    "therefore , the sum of differences between these @xmath368 elements in both vectors will also be the same , i.e. ,    @xmath369    we calculate the sums for the remaining terms ( i.e. , when at least one of the indices @xmath370 belongs to @xmath371 and/or @xmath372 belongs to @xmath373 ) next .",
    "we first assume that @xmath374 ; in this case , we can easily show that @xmath375 .",
    "then , we have the following five , mutually exclusive , cases to consider :    1 .",
    "when @xmath376 and @xmath377 .",
    "this case occurs only once , i.e. , when decomposing the double sum in equation ( [ eq : lemb1_1 ] ) we can find only one term that satisfies this case . from equation ( [ eq : lemb1_2 ] ) we have @xmath378 2 .",
    "when @xmath379 and @xmath380 .",
    "there are @xmath381 terms that satisfy this case .",
    "analogous to case 1 ) we determined that @xmath382 3 .",
    "when @xmath383 and @xmath384 .",
    "there are @xmath385 terms that satisfy this case . in this case",
    "we can show that @xmath386 4 .",
    "when @xmath387 and @xmath388 .",
    "there are @xmath389 terms that satisfy this case . in this case",
    "we can show that @xmath390 5 .",
    "when @xmath391 and @xmath392 .",
    "there are @xmath393 terms that satisfy this case .",
    "in this case we have @xmath394    the above cases ( i.e. , equations ( [ eq : lemb1_3])-([eq : lemb1_8 ] ) ) cover all the terms in equation ( [ eq : lemb1_1 ] ) when @xmath374 . combining all these terms yields : @xmath395    furthermore ,",
    "if @xmath396 , then from equation ( [ eq : lemb1_2 ] ) it is clear that @xmath397 and @xmath398 , i.e. , the resulted vector is a permutation of the original one .",
    "therefore , the sum of differences will be the same in both vectors and equation ( [ eq : lemb1_1 ] ) will be reduced to    @xmath399    equation ( [ eq : lemb1_1 ] ) follows from equations ( [ eq : lemb1_9 ] ) and ( [ eq : lemb1_91 ] ) .",
    "we first introduce a few intermediate lemmas that describe properties of @xmath141 and @xmath112 .",
    "[ lem : i003 ] the feasible interchange @xmath400 is a balancing interchange .    by definition , @xmath401 . since @xmath402 , therefore @xmath403 . according to the feasibility constraint ( [ eq : i102.1 ] ) ,",
    "the interchange @xmath345 is feasible only when @xmath159 .",
    "therefore , @xmath404 , and it follows that @xmath345 is a balancing interchange .    [ lem : i2 ] for a given policy @xmath130 and a time slot @xmath4 , @xmath405 i.e. , the sum of all positive elements of @xmath112 equals the sum of all negative elements of @xmath112 .",
    "moreover , @xmath406 is an integer between 0 and @xmath1 .    for any feasible withdrawal vector @xmath77 , we have from equation ( [ yveq : cons2 ] ) that @xmath407 where @xmath1 is the number of servers . from equation ( [ eq : i1 ] ) , we have then : @xmath408    and equation ( [ eq : i2 ] ) follows .",
    "the last assertion of the lemma follows from    @xmath409    and @xmath410    [ lem : i41 ] consider a given state @xmath113 during time slot @xmath4 .",
    "let @xmath411 be any two queues such that @xmath141 is feasible .",
    "a policy @xmath412 that results in @xmath413 does not have the mb property at time @xmath4 .",
    "the interchange @xmath141 is a balancing interchange by definition .",
    "since @xmath413 , then the balancing interchange @xmath141 reduces the imbalance index by a factor of two according to equation ( [ eq : i001 ] ) .",
    "therefore , @xmath52 does not achieve the minimum imbalance index during time slot @xmath4 , q.e.d .",
    "[ lem:001 ] given the state @xmath414 and a feasible withdrawal vector @xmath77 then a withdrawal vector @xmath415 that results from performing any sequence of feasible , single - server reallocations on @xmath77 is feasible .",
    "the proof of lemma [ lem:001 ] is straightforward and therefore it is not included here .",
    "[ lem:002 ] consider the state @xmath414 and any two feasible withdrawal vectors @xmath77 and @xmath415 .",
    "then , starting from @xmath77 , the vector @xmath415 can be obtained by performing a sequence of feasible , single - server reallocations .    to prove this lemma we construct one such sequence next .",
    "let @xmath416 denote two server allocations for the implementation of @xmath417 respectively .",
    "then we can relate @xmath77 and @xmath418 as follows :    @xmath419    since we assume both @xmath77 and @xmath418 to be feasible , server @xmath88 must be connected to both queues @xmath420 and @xmath421 . therefore , each interchange @xmath422 is equivalent to a feasible , single - server reallocation .",
    "note that @xmath423 is possible , for some @xmath88 , in which case @xmath424 . by construction , all the interchanges in the right hand side of equation ( [ eq:0021 ] )",
    "are feasible .",
    "we are now ready to prove lemma [ lem : i4 ] of section [ section - lem : i4 ] .",
    "we consider the following three cases assuming @xmath425 :    case 1 : @xmath426 .",
    "this case is not possible by contradiction . by assumption , @xmath427 , which means that @xmath428 .",
    "this case states that an mb policy idled at least one more server than @xmath52 .",
    "therefore , @xmath429 .",
    "this makes queue @xmath78 the shortest queue .",
    "allocating the idled server to queue @xmath143 , i.e. , the interchange @xmath430 , is both feasible ( since @xmath77 is feasible by assumption ) and balancing ( by lemma [ lem : i003 ] ) .",
    "the interchange @xmath430 will result in a withdrawal vector @xmath431 .",
    "let @xmath183 be the order of queue @xmath426 when ordering the vector @xmath432 in a descending manner .",
    "therefore , @xmath433 .",
    "furthermore , in order for @xmath430 to be feasible queue @xmath143 must not be empty ( according to feasibility constraint ( [ eq : i102.1 ] ) ) which implies that @xmath434 and the order of queue @xmath143 is @xmath341 .",
    "therefore , @xmath435 and the interchange @xmath430 will reduce the imbalance index by @xmath436 according to equation ( [ eq : i001 ] ) .",
    "this implies that the new policy has a smaller imbalance index than an mb policy .",
    "this contradicts the fact that any mb policy minimizes the imbalance index .",
    "case 2 : @xmath437 .",
    "when @xmath437 then the interchange @xmath141 is the process of allocating an idled server to queue @xmath438 .",
    "this , according to lemma [ lem : i003 ] , is a balancing interchange .",
    "case 3 : @xmath439 .",
    "we will show that this case will also result in a balancing interchange .",
    "let @xmath77 be the original withdrawal vector .",
    "let @xmath327 be the withdrawal vector resulted from the feasible interchange @xmath141 , i.e. , @xmath440    using the assumption @xmath193 and equation ( [ eq:30003 ] ) , we arrive at the following : @xmath441 hence , @xmath442    similarly , using the assumption @xmath192 and equation ( [ eq:30002 ] ) , we have @xmath443 hence , @xmath444    to show that @xmath445 in this case is a balancing interchange , we have to show that @xmath446 .",
    "suppose to the contrary that @xmath447 ; then , from equations ( [ eq : i42 ] ) and ( [ eq : i44 ] ) , we have @xmath448    from ( [ eq : i42 ] ) and ( [ eq : i44 ] ) we have , @xmath449    the differences satisfy the inequalities @xmath192 and @xmath193 by assumption , i.e. , there is at least one more ( respectively one less ) server allocated to queue @xmath142 ( respectively queue @xmath143 ) under the mb policy .",
    "therefore , @xmath450 is feasible and inequality ( [ eq : i46 ] ) is a contradiction according to lemma [ lem : i41 ] .",
    "we must have that @xmath446 and by definition the interchange @xmath445 is a balancing interchange .",
    "we present the proof of lemma [ lem : i6 ] of section [ section - lem : i4 ] in this appendix .",
    "lemma [ lem : i11 ] , stated below , guarantees the existence of a feasible interchange .",
    "[ lem : i11 ] consider a given state @xmath113 and a policy @xmath130 that selects a withdrawal vector @xmath77 during time slot @xmath4 .",
    "let @xmath451 denote the ( non - empty ) sets of queues for which @xmath452 and @xmath453 , respectively .",
    "then , there exist at least two queues @xmath454 and @xmath455 such that the interchange @xmath141 is feasible .",
    "let @xmath456 be an mb policy that selects the withdrawal vector @xmath327 during time slot @xmath4 .",
    "let @xmath457 .",
    "furthermore , let @xmath157 and @xmath156 be two implementations of @xmath327 and @xmath77 respectively .",
    "from lemma [ lem:002 ] we have : @xmath458    the summation on the right - hand side of equation ( [ eq : i1101 ] ) is composed of @xmath1 terms , each of which represents a reallocation of a server @xmath88 from queue @xmath420 to queue @xmath459 .",
    "such server reallocation can be formulated as an interchange @xmath460 .    in the following",
    ", we will selectively use @xmath11 out of the @xmath1 terms of the summation in equation ( [ eq : i1101 ] ) to construct a feasible interchange @xmath461 for some @xmath462 , with @xmath463 and @xmath464 .",
    "we will show that such a queue @xmath465 that belongs to @xmath466 does exist and the interchange @xmath467 is feasible .",
    "let @xmath468 then using equation ( [ eq : i1101 ] ) we can write @xmath469 since @xmath470 by our assumption , then we have @xmath471 and @xmath472    from equations ( [ eq : i1102 ] ) and ( [ eq : i1103 ] ) we conclude @xmath473    in words , there is at least one more server allocated to queue @xmath474 under @xmath179 than the servers allocated to queue @xmath474 under @xmath52 .",
    "let @xmath171 be one such server .",
    "from ( [ eq : i1104 ] ) we conclude that one of the @xmath1 terms in equation ( [ eq : i1101 ] ) must be @xmath475 such that @xmath476 .",
    "in other words , a server @xmath171 and two queues @xmath477 and @xmath478 must exist such that the interchange @xmath479 is feasible .",
    "the feasibility of @xmath479 stems from the fact that server @xmath171 is allocated to queues @xmath480 and @xmath174 under two different policies , namely @xmath179 and @xmath52 .",
    "this is possible only if @xmath481 furthermore , using equation ( [ eq : i1103 ] ) we can write @xmath482    from equation ( [ eq : i1106 ] ) we conclude @xmath483    equations ( [ eq : i1105 ] ) and ( [ eq : i1107 ] ) are sufficient for the feasibility of the interchange @xmath484 .",
    "consider queue @xmath174 above .",
    "one of the following two cases may apply :    case ( 1 ) @xmath485 : the proof of the lemma in this case is completed by letting @xmath486 and @xmath487 .",
    "the resulted interchange @xmath488 is feasible by construction and the lemma follows .",
    "case ( 2 ) @xmath489 : define @xmath490 as follows : @xmath491    using lemma [ lem:001 ] we conclude that @xmath490 is a feasible withdrawal vector . from equations ( [ eq : i1108 ] ) and ( [ eq : newi4 ] ) we can write @xmath492 from equation ( [ eq : i1109 ] ) and since @xmath489 we conclude @xmath493    therefore , one of the terms of the summation in equation ( [ eq : i1101 ] ) must be a server reallocation of some server @xmath494 from queue @xmath495 to queue @xmath496 , i.e. , the interchange @xmath497 is a feasible , single - server reallocation .",
    "it follows that @xmath498 is feasible , where @xmath499    if @xmath500 then we complete the proof using the argument in case ( 1 ) above . otherwise , we repeat the argument in case ( 2 ) again .    repeating the previous argument @xmath11 times , @xmath501 ,",
    "we arrive at the following relationship : @xmath502 where by construction , each one of the @xmath11 terms in equation ( [ eq : i11012 ] ) above corresponds uniquely to one of the terms of the summation in equation ( [ eq : i1101 ] ) . for every @xmath11 we check to see whether @xmath464 ( in which case the lemma is proved ) or not .",
    "if not then we have @xmath503    repeating the argument @xmath1 times ( one for each term of the summation in equation ( [ eq : i1101 ] ) ) we will show that a queue @xmath464 , where @xmath504 is one of the terms in equation ( [ eq : i1101 ] ) , must exist .    in order to do that , we assume to the contrary that @xmath505 . the @xmath506 ( last )",
    "server reallocation @xmath507 will result in the withdrawal vector @xmath508 , such that , @xmath509 since there is one - to - one correspondence between the summation terms in equation ( [ eq : i11013 ] ) and those in equation ( [ eq : i1101 ] ) by construction , then we can write @xmath510 hence @xmath511 . however , since @xmath512 then @xmath513 have a contradiction . we conclude that there must exist a queue @xmath464 such that server @xmath514 reallocation @xmath515 is feasible .",
    "let @xmath516 and @xmath517 .",
    "it follows that the interchange @xmath518 is feasible and the lemma follows .    from its definition and lemma [ lem : i2 ]",
    ", @xmath194 is an integer between 0 and @xmath1 . if @xmath519 , then @xmath52 has the mb property during time slot @xmath4 according to lemma [ lem : i1 ] .",
    "so , suppose that @xmath520 . from equation [ eq : i2 ] ,",
    "we can pair queues @xmath201 and @xmath521 , such that for every @xmath11 , @xmath522 and @xmath523 . from lemmas [ lem : i11 ] and [ lem : i4 ] , the interchange @xmath203 is feasible and balancing .",
    "since we have @xmath125 such pairs of queues , then applying the @xmath125 balancing interchanges @xmath203 described by lemma [ lem : i4 ] to policy @xmath52 will result in a policy @xmath179 for which @xmath524 , i.e. , @xmath525 .",
    "hence the resulting policy @xmath200 .",
    "if we want to compare probability measures on a measurable space , it is often possible to construct random elements @xcite , with these measures as their distributions , on a common probability space , such that the comparison can be carried out in terms of these random elements rather than the probability measures .",
    "the term _ stochastic coupling _ ( or coupling ) is often used to refer to any such construction . in the notation of @xcite , a formal definition of coupling of two probability measures on the measurable space @xmath526 ( the state space , e.g. , @xmath527 ) is given below ; further details regarding coupling method and its application can be found in @xcite .    a random element in @xmath526 is a quadruple @xmath528 , where @xmath529 is the sample space and @xmath530 is the class of measurable mappings from @xmath531 to @xmath532 ( @xmath530 is an @xmath532-valued random variable , s.t .",
    "@xmath533 for all @xmath534 ) .",
    "* definition : * _ a coupling of the two random elements @xmath535 and @xmath536 in @xmath526 is a random element @xmath537 in ( @xmath538 ) such that _",
    "@xmath539    _ where @xmath540 denotes equal in distribution_.    the above definition makes no assumption about the distribution of the collection of random variables @xmath541 ; for example , @xmath541 may be a sequence of non - i.i.d .",
    "random variables .    in the area of optimal control of queues ,",
    "coupling arguments have been used extensively to prove characteristics of the optimal policies for many queuing systems , c.f .",
    "@xcite , @xcite , @xcite , @xcite and many others .",
    "we apply the coupling method to our proof as follows : let @xmath542 and @xmath52 be a given sample path of the system state process and scheduling policy .",
    "the values of the sequences @xmath543 and @xmath544 can be completely determined by @xmath542 and @xmath52 .",
    "we denote the ensemble of all random variables as system @xmath545 .",
    "a new sample path , @xmath546 and a new policy @xmath547 are constructed as we specify in the proof .",
    "we denote the ensemble of all random variables ( in the new construction ) as system @xmath548 .",
    "then , in the coupling definition , @xmath549 and the `` coupled '' processes of interest in equation ( [ def2:coupling ] ) will be the queue sizes @xmath550 and @xmath551 .",
    "we define @xmath542 as the sequence of sample values of the random variables @xmath552 , i.e. , @xmath553 .",
    "the sample path @xmath554 is constructed such that ( a ) @xmath555 , ( b ) @xmath556 is the same as @xmath557 , except for two elements that are exchanged , ( c ) @xmath558 is the same as @xmath559 , except for two elements that are exchanged .",
    "the selection of the appropriate elements that are exchanged is detailed in the proof that follows has the same distribution as @xmath560 , since the distributions of @xmath561 as well as @xmath562 are i.i.d . and will not change when their elements are reordered .",
    "the mappings from @xmath561 to @xmath563 and from @xmath562 to @xmath564 are one - to - one . ] .",
    "the new policy @xmath547 is constructed ( by showing how @xmath547 chooses the withdrawal vector @xmath565 ) as detailed in the proof . then using equation ( [ sys_evol ] ) , the new states @xmath566 are determined under @xmath52 and @xmath567 .",
    "the goal is to prove that the relation @xmath568 is satisfied at all times @xmath143 . towards this end , the preferred order ( introduced in section [ preferredorder - section ] )",
    "can be described by the following property :    * property 1 : * @xmath208 is preferred over @xmath569 ( @xmath570 ) if and only if one of the statements r1 , r2 or r3 ( that we introduced in section [ preferredorder - section ] ) holds .",
    "we restate these statements here for the sake of presentation :    1 .",
    "@xmath571 : the two vectors are component - wise ordered ; 2 .",
    "@xmath208 is a two - component permutation of @xmath209 as described in section [ preferredorder - section ] .",
    "@xmath208 is obtained from @xmath209 by performing a _  balancing interchange \" _ as described in section [ preferredorder - section ] .",
    "[ yv : pi - tilde ]    fix an arbitrary policy @xmath241 and a sample path @xmath572 , where @xmath573 and @xmath574 are sample values of the random variables @xmath575 and @xmath576 .",
    "let , @xmath456 be an mb policy that works on the same system .",
    "the policy @xmath179 chooses a withdrawal vector @xmath577 .",
    "the proof has two parts ; part 1 provides constructions for @xmath546 and @xmath547 ( as defined by lemma [ lem:6 ] statement ) for times up to @xmath578 .",
    "part 2 does the same for @xmath579 .    _ * part 1 : * _ for the construction of @xmath546 , we let the arrivals and channel states be the same in both systems at all time slots before @xmath580 , i.e. , @xmath581 and @xmath582 for all @xmath583 .",
    "we construct @xmath547 such that it chooses the same withdrawal vector as @xmath52 , i.e. , we set @xmath584 for all @xmath583 . in this case , at @xmath585 , the resulting queue sizes are equal , i.e. , @xmath586 . in the remainder of part 1 , we will construct the policy @xmath547 at time slot @xmath580 such that : ( a ) @xmath243 , i.e. , @xmath547 is closer to @xmath456 than @xmath52 , and ( b ) the resulting queue length under @xmath547 is preferred over that under the original policy @xmath587 , i.e. , @xmath588 .",
    "condition ( b ) is necessary for proving the second part of the lemma , i.e. , the domination of policy @xmath547 over @xmath587 , a result that will be shown in part 2 of this proof .    at time",
    "slot @xmath580 , let @xmath589 have the same channel connectivities and arrivals as @xmath590 , i.e. , let @xmath591 and @xmath592 . furthermore , let @xmath593 .",
    "recall that @xmath594 .",
    "then one of the following two cases may apply :    1- during time slot @xmath578 , the original policy @xmath52 differs from @xmath179 , the mb policy , by _",
    "strictly _ less than @xmath595 balancing interchanges .",
    "then @xmath596 as well , so we set @xmath597 . in this case , the resulting queue sizes @xmath598 will be equal , property ( r1 ) holds true and ( [ prefered1 ] ) is satisfied at @xmath599 .",
    "2- during time slot @xmath578 , @xmath52 differs from the mb policy @xmath179 by _ exactly _ @xmath595 balancing interchanges .",
    "since @xmath241 and @xmath242 and following lemma [ lem : i6 ] , we can identify two queues @xmath182 and @xmath183 such that : ( a ) @xmath600 , ( b ) @xmath601 , and ( c )",
    "@xmath602 is feasible .",
    "the construction of @xmath547 is completed in this case by performing the interchange @xmath602 , i.e. , @xmath603 or equivalently , @xmath604    according to lemma [ lem : i4 ] , this interchange is balancing . to complete the construction of @xmath546",
    ", we examine the arrivals under @xmath542 during time slot @xmath580 .",
    "we set @xmath605 . for queues @xmath182 and @xmath183",
    ", we do the following : ( i ) if @xmath606 and @xmath607 then we swap the arrivals for queues @xmath182 and @xmath183 , i.e. , we let @xmath608 and @xmath609 , ( ii ) otherwise , let @xmath610 and @xmath611 .",
    "the queue lengths at the beginning of time slot ( @xmath612 ) under the two policies satisfy property ( r1 ) in case ( i ) and ( r3 ) otherwise . in either case , ( [ prefered1 ] )",
    "is satisfied at @xmath599 .",
    "starting from a preferred state at @xmath599 , we will show next , in part 2 of the proof , that a feasible control at time slot @xmath613 , such that the constructed policy @xmath547 dominates the original one @xmath52 , will always exist .",
    "we do that by showing one such construction .    _ * part 2 : * _ in this part of the proof , we construct @xmath614 for times @xmath579 , such that the preferred order @xmath615 is valid for all @xmath579 .",
    "this will insure @xmath547 domination over @xmath52 . we will use induction to complete our proof .",
    "we assume that @xmath547 and @xmath616 are defined up to time @xmath617 and that @xmath618 .",
    "we will prove that at time slot @xmath4 , @xmath547 can be constructed so that @xmath619 .",
    "thus , we have to show that either r1 , r2 or r3 holds at time slot @xmath620 .",
    "the following three cases , corresponding to properties ( r1 ) , ( r2 ) and ( r3 ) are considered next .",
    "case ( 1 ) @xmath621 .",
    "the construction of @xmath546 is straightforward in this case .",
    "we set @xmath622 and @xmath623 .",
    "we construct @xmath547 such that @xmath624 . in this case , its obvious that @xmath625 and ( [ prefered1 ] ) holds at @xmath39 .",
    "case ( 2 ) @xmath626 is a permutation of @xmath627 , such that @xmath626 can be obtained from @xmath627 by permuting components @xmath11 and @xmath10 ( as described in property r2 of the preferred order ) . for the construction of @xmath546 ,",
    "we set @xmath628 and @xmath629 , for all @xmath630 ; @xmath631 and @xmath632 ( refer to footnote 7 or @xcite ) ; the connectivities and arrivals for each one of the remaining queues are the same as in @xmath542 .",
    "we construct @xmath547 such that @xmath633 , @xmath634 and @xmath635 for all @xmath636 . as a result , @xmath637 and @xmath638",
    "satisfy property ( r2 ) and ( [ prefered1 ] ) is satisfied at @xmath39 .",
    "case ( 3 ) @xmath626 is obtained from @xmath627 by performing a balancing interchange for queues @xmath11 and @xmath10 as defined in property ( r3 ) . in this case",
    "@xmath639 , by the definition in ( r3 ) , @xmath640 and @xmath641 . ] .",
    "there are three cases to consider :    ( 3.a ) @xmath642 .",
    "therefore , @xmath643 and @xmath644 , i.e. , the vectors @xmath627 and @xmath626 have components @xmath11 and @xmath10 permuted and all other components are the same .",
    "this case corresponds to case ( 2 ) above .",
    "( 3.b ) @xmath645 and @xmath646 .",
    "we construct @xmath546 as in case ( 1 ) above , and we let @xmath647 . note that it is not feasible for policy @xmath52 to empty queue @xmath11 in this case . depending on whether @xmath52 empties queue @xmath10 or not at @xmath287 , the construction of @xmath547 will follow one of the following two cases :    \\(i ) @xmath648 , i.e. , , then let @xmath649 ( i.e. , @xmath567 is identical to @xmath52 at @xmath287 ) . in this case , property ( r3 )",
    "will be preserved regardless of the arrivals pattern then property ( r2 ) is a special case of ( r3 ) .",
    "] , hence ( [ prefered1 ] ) is satisfied at @xmath39 .",
    "( ii ) @xmath650 , i.e. , .",
    "then if under policy @xmath52 all the servers connected to queue @xmath10 are allocated , then let @xmath649 . as in case ( i ) above , property ( r3 ) holds and ( [ prefered1 ] ) satisfied at @xmath39 .    in the event that @xmath52 empties queue @xmath10 without exhausting all the servers connected to queue @xmath10 , then",
    "@xmath567 will be constructed such that one of these idling servers is allocated to queue @xmath10 , i.e. , @xmath651 , so that @xmath567 preserves the work conservation property at @xmath287 .",
    "since @xmath652 by property ( r3 ) and @xmath653 by construction , then we have @xmath654 since @xmath655 by property ( r3 ) , @xmath656 and @xmath657 by construction , we have @xmath658 the rest of the queues will have the same lengths in both systems at @xmath39 .",
    "therefore , ( r1 ) holds with strict inequality and ( [ prefered1 ] ) is satisfied at @xmath39 .",
    "this case shows that a `` more '' balancing policy results in a strict enhancement of the original policy .    cases ( i ) and ( ii ) are the only possible ones , since @xmath52 can not allocate more servers to queue @xmath10 than its length .",
    "( 3.c ) @xmath645 and @xmath659 .",
    "we consider the following two cases :    \\(i ) @xmath660 , i.e. , .",
    "to construct @xmath546 for this case , we set @xmath622 , @xmath661 for all @xmath662 , and for all @xmath663 . for queues @xmath11 and @xmath10",
    "we do the following :    let server @xmath664 be a server that is connected to queue @xmath11 at time slot @xmath4 such that @xmath665 ( i.e. , server @xmath664 is allocated to queue @xmath11 by policy @xmath52 at @xmath287 ) .",
    "now , we switch the connectivity of server @xmath664 to queue @xmath11 and that of server @xmath664 to queue @xmath10 , i.e. , we set @xmath666 and @xmath667 ( refer to footnote 7 or @xcite )",
    ". the rest of the servers will have the same connectivities to queues @xmath11 and @xmath10 under both policies , i.e. , we set @xmath668 and @xmath669 for all @xmath670 .",
    "we construct @xmath547 such that @xmath671 and @xmath672 .",
    "this means that @xmath547 differs from @xmath52 , at @xmath287 , by one server allocation ( server @xmath664 ) that is allocated to queue @xmath10 ( under @xmath547 ) rather than queue @xmath11 ( under @xmath52 ) . from equation ( [ yi_qi ] ) , we can easily calculate that the resulting queue lengths at @xmath39 ( for any arrivals pattern ) will be : @xmath673    it follows that property ( r1 ) is satisfied and therefore ( [ prefered1 ] ) is satisfied at @xmath39 .",
    "\\(ii ) @xmath674 , i.e. , .",
    "then consider the following :    if @xmath52 does not empty queue @xmath10 at @xmath287 or if @xmath52 empties queue @xmath10 and in the process it exhausts all servers connected to queue @xmath10 , i.e. , @xmath52 does not idle any server connected to queue @xmath10 , then we construct @xmath546 and @xmath567 similar to case ( 3.c(i ) ) above and the same conclusion holds .",
    "if on the other hand , @xmath52 empties queue @xmath10 without exhausting all its connected servers and therefore @xmath52 is forced to idle some of the servers connected to queue @xmath10 , then let @xmath675 be one such server .",
    "we set @xmath622 , @xmath676 .",
    "we construct @xmath567 such that @xmath677 , by allocating server @xmath675 to queue @xmath10 under @xmath567 , i.e. , we set @xmath678 .",
    "this is feasible since @xmath679 by property ( r3 ) .",
    "we also have @xmath680 ( by property ( r3 ) ) . since @xmath681 by construction , then similar to case ( 3.b(ii ) ) , property ( r1 ) holds with strict inequality at @xmath39 for any arrivals pattern , and ( [ prefered1 ] ) follows .",
    "since @xmath52 can not allocate more servers to queue @xmath10 than its length , therefore , ( i ) and ( ii ) are the only possible cases .",
    "note that policy @xmath547 belongs to @xmath682 by construction in part 1 ; its dominance over @xmath52 follows from relation ( [ func_class ] ) .",
    "the authors wish to thank professor l. tassiulas from university of thessaly , volos , greece for his insightful comments throughout the course of this work .",
    "n. bambos and g. michailidis ,  on the stationary dynamics of parallel queues with random server connectivities , \" _ proceedings of 34th conference on decision and control _ , ( cdc ) , new orleans , la ( 1995 ) .",
    "a. ganti , e. modiano and j. n. tsitsiklis ,  optimal transmission scheduling in symmetric communication models with intermittent connectivity , \" _ ieee transactions on information theory _ , 53(3 ) : 998 - 1008 , march 2007 .",
    "s. kittipiyakul , t. javidi , `` delay - optimal server allocation in multiqueue multi - server systems with time - varying connectivities , '' _ ieee transactions on information theory _ , 55(5 ) : 2319 - 2333 , may 2009 .    c. lott and d. teneketzis ,  on the optimality of an index rule in multichannel allocation for single - hop mobile networks with multiple service classes , \" _ probability in the engineering and information services _ , 14(3 ) : 259 - 297 , july 2000 .",
    "r. agrawal and v. subramanian ,  optimality of certain channel aware scheduling policies \" , _ the 40th annual allerton conference on communication , control , and computing _ , monticello , illinois , oct ."
  ],
  "abstract_text": [
    "<S> we investigate an optimal scheduling problem in a discrete - time system of @xmath0 parallel queues that are served by @xmath1 identical , randomly connected servers . </S>",
    "<S> each queue may be connected to a subset of the @xmath1 servers during any given time slot . </S>",
    "<S> this model has been widely used in studies of emerging 3g/4 g wireless systems . </S>",
    "<S> we introduce the class of most balancing ( mb ) policies and provide their mathematical characterization . </S>",
    "<S> we prove that mb policies are optimal ; we define optimality as minimization , in stochastic ordering sense , of a range of cost functions of the queue lengths , including the process of total number of packets in the system . </S>",
    "<S> we use stochastic coupling arguments for our proof . </S>",
    "<S> we introduce the least connected server first / longest connected queue ( lcsf / lcq ) policy as an easy - to - implement approximation of mb policies . </S>",
    "<S> we conduct a simulation study to compare the performance of several policies . </S>",
    "<S> the simulation results show that : ( a ) in all cases , lcsf / lcq approximations to the mb policies outperform the other policies , ( b ) randomized policies perform fairly close to the optimal one , and , ( c ) the performance advantage of the optimal policy over the other simulated policies increases as the channel connectivity probability decreases and as the number of servers in the system increases . </S>"
  ]
}