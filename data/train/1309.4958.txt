{
  "article_text": [
    "_ grammar - based compression _ has emerged to an active field in string compression during the last couple of years .",
    "the principle idea is to represent a given string @xmath5 by a small context - free grammar that generates only @xmath5 ; such a grammar is also called a _ straight - line program _ , briefly slp .",
    "for instance , the word @xmath6 can be represented by the slp with the productions @xmath7 and @xmath8 for @xmath9 ( @xmath10 is the start symbol ) .",
    "the size of this grammar is much smaller than the size ( length ) of the string @xmath6 . in general ,",
    "an slp of size @xmath2 ( the size of an slp is usually defined as the total length of all right - hand sides of productions ) can produce a  string of length @xmath11 .",
    "hence , an slp can be seen indeed as the succinct representation of the generated word .",
    "the principle task of grammar - based string compression is to construct from a  given input string @xmath5 a small slp that produces @xmath5 .",
    "unfortunately , finding a minimal ( with respect to size ) slp for a given input string is not achievable in polynomial time unless * p * = * np * @xcite .",
    "therefore , one can concentrate either on heuristic grammar - based compressors  @xcite , or compressors whose output slp is guaranteed to be not much larger than a size - minimal slp for the input string . in this paper we are interested mostly in the latter approach . formally , in @xcite the approximation ratio for a grammar - based compressor @xmath12 is defined as the function @xmath13 with @xmath14 where the maximum is taken over all strings of length @xmath2 ( over an arbitrary alphabet ) .",
    "the above statement means that unless * p * = * np * there is no polynomial time grammar - based compressor with the approximation ratio @xmath15 . using approximation lower bounds for computing vertex covers , it is shown in @xcite that unless * p * = * np * there is no polynomial time grammar - based compressor , whose approximation ratio is less than the constant 8569/8568 .",
    "apart from this complexity theoretic bound , the authors of @xcite prove lower and upper bounds on the approximation ratios of well - known grammar - based string compressors ( lz78 , bisection , sequential , repair , etc . ) .",
    "the currently best known approximation ratio of a polynomial time grammar - based string compressor is of the form @xmath16 , where @xmath17 is the size of a smallest slp for the input string .",
    "actually , there are several compressors achieving this approximation ratio  @xcite and each of them works in linear time ( a property that a reasonable compressor should have ) .    at this point ,",
    "the reader might ask , what makes grammar - based compression so attractive .",
    "there are actually several arguments in favor of grammar - based compression :    * the output of a grammar - based compressor ( an slp ) is a clean and simple object , which may simplify the analysis of a compressor or the analysis of algorithms that work on compressed data ; see @xcite for a survey .",
    "* there are grammar - based compressors which achieve very good compression ratios .",
    "for example repair @xcite performs very well in practice and was for instance used for the compression of web graphs @xcite .",
    "* the idea of grammar - based string compression can be generalized to other data types as long as suitable grammar formalisms are known for them .    the last point is the most important one for this work . in @xcite , grammar - based compression was generalized from strings to trees .",
    "for this , context - free tree grammars were used .",
    "context free tree grammars that produce only a single tree are also known as straight - line context - free tree grammars ( slcf tree grammars ) .",
    "several papers deal with algorithmic problems on trees that are succinctly represented by slcf tree grammars @xcite . in @xcite",
    ", repair was generalized from strings to trees , and the resulting algorithm treerepair achieved excellent results on real xml data trees .",
    "other grammar - based tree compressors were developed in @xcite . but none of these compressors has a good approximation ratio .",
    "for instance , in @xcite a series of trees is constructed , where the @xmath2-th tree @xmath18 has size @xmath19 , there exists an slcf tree grammar for @xmath18 of size @xmath20 , but the grammar produced by treerepair for @xmath18 has size @xmath21 ( and similar examples can be constructed for the compressors in @xcite ) .    in this paper , we give the first example of a grammar - based tree compressor ( for `` tree to grammar '' ) with an approximation ratio of @xmath22 assuming the maximal rank @xmath4 of symbols is bounded and where @xmath3 denotes the size of the smallest grammar generating the given tree ; otherwise the approximation ratio becomes @xmath23 .",
    "our algorithm is based on the work @xcite of the first author , where another grammar - based string compressor with an approximation ratio of @xmath22 is presented ( here @xmath3 denotes the size of the smallest grammar for the input text ) .",
    "the remarkable fact about this latter compressor is that in contrast to @xcite it does not use the lz77 factorization of a string ( which makes the compressors from @xcite not suitable for a generalization to trees , since lz77 ignores the tree structure and no good analogue of lz77 for trees is known ) , but is based on the _",
    "recompression technique_. this technique was introduced in @xcite and successfully applied for a variety of algorithmic problems for slp - compressed strings @xcite and word equations @xcite .",
    "the basic idea is to compress a string using two operations :    * block compressions , which replaces every maximal substring of the form @xmath24 for a letter @xmath25 by a new symbol @xmath26 . *",
    "pair compression , which for a given partition @xmath27 replaces every substring @xmath28 by a new symbol @xmath29 .",
    "it can be shown that the composition of block compression followed by pair compression ( for a suitably chosen partition of the input letters ) reduces the length of the string by a constant factor .",
    "hence , the iteration of block compression followed by pair compression yields a string of length one after a logarithmic number of phases . by reversing a single compression step ,",
    "one obtains a grammar rule for the introduced letter and thus reversing all such steps yields an slp for the initial string .",
    "the term `` recompression '' refers to the fact , that for a given slp @xmath30 , block compression and pair compression can be simulated on @xmath30 .",
    "more precisely , one can compute from @xmath30 a new slp @xmath31 , which is not much larger than @xmath30 such that @xmath31 produces the result of block compression ( respectively , pair compression ) applied to the string produced by @xmath30 . in @xcite ,",
    "the recompression technique is used to bound the approximation ratio of the above compression algorithm based on block and pair compression .    in this work",
    "we generalize the recompression technique from strings to trees .",
    "the operations of block compression and pair compression can be directly applied to chains of unary nodes ( nodes having only a single child ) in a tree . but clearly , these two operations alone can not reduce the size of the initial tree by a constant factor . hence we need a third compression operation that we call _ leaf compression_. it merges all children of a node that are leaves into the node ; the new label of the node determines the old label , the sequence of labels of the children that are leaves , and their positions in the sequence of all children of the node .",
    "then , one can show that a  single phase , consisting of block compression ( that we call chain compression ) , followed by pair compression ( that we call unary pair compression ) , followed by leaf compression reduces the size of the initial tree by a constant factor . as for strings ,",
    "we obtain an slcf tree grammar for the input tree by basically reversing the sequence of compression operations .",
    "the recompression approach again yields an approximation ratio of @xmath22 ( assuming that the maximal rank of symbols is a constant ) for our compression algorithm , but the analysis is technically more subtle .",
    "[ thm : main ] the algorithm runs in linear time , and for a tree @xmath1 of size @xmath2 , it returns an slcf tree grammar of size @xmath32 , where @xmath3 is the size of a smallest slcf grammar for @xmath1 and @xmath4 is the maximal rank of a symbol in @xmath1 .",
    "note that in some specific cases it could happen that @xmath33 and so the term @xmath34 is in fact negative , we follow the usual practice of bounding the logarithm from below by @xmath35 , i.e.  in such a case we assign @xmath35 as the value of the logarithm .",
    "[ [ related - work - on - grammar - based - tree - compression . ] ] * related work on grammar - based tree compression .",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we already mentioned that grammar - based tree compressors were developed in @xcite , but none of these compressors has a good approximation ratio .",
    "another grammar - based tree compressors was presented in @xcite .",
    "it is based on the bisection algorithm for strings and has an approximation ratio of @xmath36 . but this algorithm used a different form of grammars ( elementary ordered tree grammars ) and it is not clear , whether the results from @xcite can be extended to slcf tree grammars , or whether the good algorithmic results for slcf - compressed trees @xcite can be extended to elementary ordered tree grammars .",
    "let us finally mention the work from @xcite where trees are compressed by so called top dags .",
    "these are another hierarchical representation of trees .",
    "upper bounds on the size of the minimal top dag are derived in @xcite and compared with the size of the minimal dag ( directed acyclic graph ) .",
    "more precisely , it is shown in @xcite that the size of the minimal top dag is at most by a factor of @xmath20 larger than the size of the minimal dag .",
    "since dags can be seen as a special case of slcf tree grammars , our main result is stronger .",
    "[ [ other - applications - of - the - technique - context - unification . ] ] * other applications of the technique : context unification . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the recompression method can be applied to word equations and it is natural to hope that its generalization to trees also applies to appropriate generalizations of word equations .",
    "indeed , the tree recompression approach is used in  @xcite to show that the context unification problem can be solved in * pspace*. it was a long standing open problem whether context unification is decidable  @xcite .",
    "[ [ parallel - tree - contraction . ] ] * parallel tree contraction . *",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    our compression algorithm is similar to algorithms for parallel tree evaluation @xcite . here",
    ", the problem is to evaluate an algebraic expression of size @xmath2 in time @xmath20 on a pram . using parallel tree contraction ,",
    "this can be achieved on a pram with @xmath37 many processors .",
    "the rake operation in parallel tree contraction is the same as our leaf compression operation , whereas the _ compress operations _ contracts chains of unary nodes and hence corresponds to block compression and pair compression . on the other hand ,",
    "the specific features of block compression and pair compression that yield the approximation ratio of @xmath16 have no counterpart in parallel tree contraction .    [",
    "[ computational - model . ] ] * computational model . * + + + + + + + + + + + + + + + + + + + + + +    to achieve the linear running time we need some assumption on the computational model and form of the input .",
    "we assume that numbers of @xmath20 bits ( where @xmath2 is the size of the input tree ) can be manipulated in time @xmath38 and that the labels of the input tree come from an interval @xmath39 $ ] , where @xmath29 is some constant .",
    "those assumption are needed so that we can employ , which sorts @xmath40 many @xmath41-ary numbers of length @xmath42 in time @xmath43 , see e.g. ( * ? ? ?",
    "* section  8.3 ) .",
    "in fact , we need a slightly more powerful version of that sorts lexicographically @xmath40 sequences of digits from @xmath44 $ ] of lengths @xmath45 in time @xmath46 .",
    "this is a standard generalisation of , see the appendix .",
    "if for any reason the labels do not belong to an interval @xmath39 $ ] , we can sort them in time @xmath47 and replace them with numbers from @xmath48 .",
    "let us fix for every @xmath49 a countably infinite set @xmath50 of _ letters _ ( or _ symbols _ ) of rank @xmath51 , where @xmath52 for @xmath53 , and let @xmath54 .",
    "symbols in @xmath55 are called _ constants _ , while symbols in @xmath56 are called _",
    "unary letters_. we also write @xmath57 if @xmath58 . a _ ranked alphabet _ is a finite subset of @xmath59 .",
    "let @xmath60 be a ranked alphabet .",
    "we also write @xmath61 for @xmath62 and @xmath63 for @xmath64 .",
    "an _ @xmath60-labelled tree _ is a rooted , ordered tree whose nodes are labelled with elements from @xmath60 , satisfying the condition that if a node @xmath65 is labelled with @xmath25 then it has exactly @xmath66 children , which are linearly ordered ( by the usual left - to - right order ) .",
    "we denote by @xmath67 the set of @xmath60-labelled trees . in the following we will simply speak about trees when the ranked alphabet is clear from the context or unimportant .",
    "when useful , we identify an @xmath60-labelled tree with a term over @xmath60 in the usual way .",
    "the size of the tree @xmath68 is its number of nodes and is denoted by @xmath69 .",
    "we assume that a tree is given using a pointer representation , i.e. , each node has a list of its children ( ordered from left to right ) and each node ( except for the root ) has a pointer to its parent node .",
    "fix a countable set @xmath70 with @xmath71 of _ ( formal ) parameters _ , which are usually denoted by @xmath72 . for the purposes of building trees with parameters",
    ", we treat all parameters as constants , and so @xmath60-labelled trees with parameters from @xmath73 ( where @xmath74 is finite ) are simply @xmath75-labelled trees , where the rank of every @xmath76 is @xmath35",
    ". however , to stress the special role of parameters we write @xmath77 for the set of @xmath60-labelled trees with parameters from @xmath74 .",
    "we identify @xmath67 with @xmath78 . in the following we talk about _ trees with parameters _ ( or even trees ) when the ranked alphabet and parameter set is clear from the context or unimportant .",
    "the idea of parameters is best understood when we represent trees as terms : for instance @xmath79 with parameters @xmath80 and @xmath81 can be seen as a term with variables @xmath80 , @xmath81 and we can instantiate those variables later on . a _ pattern _ ( or _ linear tree _ ) is a tree @xmath82 , that contains for every @xmath76 at most one @xmath83-labelled node . clearly , a tree without parameters is a pattern .",
    "all trees in this paper will be patterns , and we will not mention this assumption explicitly in the following .    ,",
    "its subpattern @xmath84 , subpatterns @xmath85 , and subpattern @xmath86 in which @xmath25 is the first child of @xmath87 . ]    when we talk of a _ subtree _ @xmath88 of a tree @xmath68 , we always mean a full subtree in the sense that for every node of @xmath88 all children of that node in @xmath68 belong to @xmath88 as well .",
    "in contrast , a _ subpattern _",
    "@xmath65 of @xmath68 is obtained from a subtree @xmath88 of @xmath68 by removing some of the subtrees of @xmath88 .",
    "if we replace these subtrees by pairwise different parameters , then we obtain a pattern @xmath89 and we say that ( i ) the subpattern @xmath65 is an _ occurrence _ of the pattern @xmath90 in @xmath68 and ( ii ) @xmath90 is the pattern corresponding to the subpattern @xmath65 ( this pattern is unique up to renaming of parameters ) .",
    "this later terminology applies also to subtrees , since a subtree is a subpattern as well .",
    "a _ context _",
    "@xmath91 is a pattern with exactly one parameter , and occurrences of a context @xmath91 in a tree are called _ subcontexts_. to make this notions clear , consider for instance the tree @xmath92 with @xmath93 , @xmath94 and @xmath95 .",
    "it contains one occurrence of the pattern ( in fact , tree ) @xmath84 , two occurrences of the pattern ( in fact , context ) @xmath85 and one of the pattern ( in fact , context ) @xmath86 , see figure  [ fig : tree_pattern ] .    a _ chain pattern _",
    "is a context of the form @xmath96 with @xmath97 .",
    "a _ chain _ in a tree @xmath68 is an occurrence of a chain pattern in @xmath68 .",
    "a chain @xmath5 in @xmath68 is _ maximal _ if there is no chain @xmath98 in @xmath68 with @xmath99 .",
    "a @xmath100-chain is a chain consisting of only two nodes ( which , most of the time , will be labelled with different letters ) .",
    "for @xmath101 , an @xmath25-maximal chain is a chain such that ( i ) all nodes are labelled with @xmath25 and ( ii ) there is no chain @xmath98 in @xmath68 such that @xmath99 and all nodes of @xmath98 are labelled with @xmath25 too .",
    "note that an @xmath25-maximal chain is not necessarily a maximal chain .",
    "consider for instance the tree @xmath102 .",
    "the unique occurrence of the chain pattern @xmath103 is an @xmath25-maximal chain , but is not maximal .",
    "the only maximal chain is the unique occurrence of the chain pattern @xmath104 , see figure  [ fig : tree_chain ] .",
    ", its unique @xmath25-maximal chain ( an occurrence of @xmath103 ) and its unique maximal chain ( an occurrence of @xmath104 ) . ]    we write @xmath105 for the chain pattern @xmath96 and treat it as a string ( even though this ` string ' still needs an argument on its right to form a proper term ) .",
    "in particular , we write @xmath24 for the chain pattern consisting of @xmath42 many @xmath25-labelled nodes and we write @xmath106 ( for chain patterns @xmath65 and",
    "@xmath107 ) for what should be @xmath108 .      for the further considerations ,",
    "fix a countable infinite set @xmath109 of symbols of rank @xmath51 with @xmath110 for @xmath53 .",
    "let @xmath111 .",
    "furthermore , assume that @xmath112 .",
    "hence , every finite subset @xmath113 is a ranked alphabet . a _ linear context - free tree grammar _ ,",
    "_ linear cf tree grammar _ for short , is a tuple @xmath114 such that the following conditions hold :    1 .",
    "@xmath113 is a finite set of _",
    "nonterminals_. 2 .",
    "@xmath115 is a finite set of _",
    "terminals_. 3 .",
    "@xmath116 ( the set of _ productions _ ) is a finite set of pairs @xmath117 ( for which we write @xmath118 ) , where @xmath119 and @xmath120 is a pattern , which contains exactly one @xmath121-labelled node for each @xmath122 .",
    "@xmath123 is the",
    "_ start nonterminal _ , which is of rank @xmath35 .    to stress the dependency of @xmath124 on its parameters we sometimes write @xmath125 instead of @xmath118 . without loss of generality",
    "we assume that every nonterminal @xmath126 occurs in the right - hand side @xmath68 of some production @xmath127 ( a much stronger fact is shown in  ( * ? ? ?",
    "* theorem 5 ) ) .     and the result of applying the rule @xmath128 . ]    a linear cf tree grammar @xmath129 is _ @xmath41-bounded _ ( for a natural number @xmath41 ) if @xmath130 for every @xmath131 .",
    "moreover , @xmath129 is _ monadic _ if it is @xmath15-bounded .",
    "the derivation relation @xmath132 on @xmath133 is defined as follows : @xmath134 if and only if there is a production @xmath135 such that @xmath98 is obtained from @xmath5 by replacing some subtree @xmath136 of @xmath5 by @xmath68 with each @xmath121 replaced by @xmath137 . intuitively , we replace an @xmath124-labelled node by the pattern @xmath138 and thereby identify the @xmath139-th child of @xmath124 with the unique @xmath140-labelled node of the pattern , see figure  [ fig : rewriting ] . then @xmath141 is the set of all trees from @xmath142 ( so @xmath60-labelled without parameters ) that can be derived from @xmath143 ( in arbitrarily many steps ) .",
    "a _ straight - line context - free tree grammar _ ( or _ slcf grammar _ for short ) is a linear cf tree grammar @xmath144 , where    * for every @xmath119 there is _ exactly one _",
    "production @xmath145 with left - hand side @xmath124 , * if @xmath146 and @xmath147 occurs in @xmath68 then @xmath148 , where @xmath149 is a linear order on @xmath150 , and * @xmath143 is the maximal nonterminal with respect to @xmath149 .    by the first two conditions , every @xmath119 derives exactly one tree from @xmath151 .",
    "we denote this tree by @xmath152 ( like _ valuation _ ) .",
    "moreover , we define @xmath153 , which is a tree from @xmath67 .",
    "in fact , every tree from @xmath154 derives a unique tree from @xmath155 , where @xmath74 is an arbitrary finite set of parameters .    for an slcf grammar @xmath144",
    "we can assume without loss of generality that for every production @xmath146 the parameters @xmath156 occur in @xmath68 in the order @xmath157 from left to right .",
    "this can be ensured by a simple bottom - up rearranging procedure , see ( * ? ? ?",
    "* proof of theorem 5 ) .",
    "in the rest of the paper , when we speak of grammars , we aways mean slcf grammars .",
    "there is a subtle point , when defining the _ size _",
    "@xmath158 of the slcf grammar @xmath30 : one possible definition could be @xmath159 , i.e. , the sum of all sizes of all right - hand sides . however ,",
    "consider for instance the rule @xmath160 .",
    "it is in fact enough to describe the right - hand side as @xmath161 , as we have @xmath25 as the @xmath51-th child of @xmath87 . on the remaining positions we just list the parameters , whose order is known to us ( see the remark in the previous paragraph ) . in general ,",
    "each right - hand side of @xmath129 can be specified by listing for each node its children that are _ not _ parameters together with their positions in the list of all children .",
    "these positions are numbers between @xmath15 and @xmath4 ( it is easy to show that our algorithm creates only nonterminals of rank at most @xmath4 , see lemma  [ lem : small rank ] , and hence every node in a right - hand side has at most @xmath4 children ) and therefore fit into @xmath38 machine words . for this reason",
    "we define the size @xmath158 as the total number of non - parameter nodes in all right - hand sides .",
    "should the reader prefer to define the size of a grammar as the total number of all nodes ( including parameters ) in all right - hand sides , then the approximation ratio of our algorithm has to be multiplied with the additional factor @xmath4 .",
    "our compression algorithm takes the input tree and applies to it local compression operations , each such operation decreases the size of the kept tree . with @xmath1",
    "we will always denote the current tree stored by , whereas @xmath2 denotes the size of the initial input tree .",
    "the algorithm relabels the nodes of the tree with fresh letters .",
    "with @xmath60 we will always denote the set of letters occurring in the current tree @xmath1 . by @xmath4",
    "we denote the maximal rank of the letters occurring in the initial input tree .",
    "the ranks of the fresh letters will not exceed @xmath4 .",
    "-chain compression , @xmath162-compression , and ( parallel ) leaf compression . ]",
    "our compression algorithm is based on three local replacement rules applied to trees :    a.   [ a compression]@xmath25-maximal chain compression ( for a unary symbol @xmath25 ) , b.   [ b compression]unary pair compression , c.   [ c compression]and leaf compression .    operations and apply only to unary letters and are direct translations of the operations used in the recompression - based algorithm for constructing a grammar for a given string  @xcite . to be more precise , and affect only chains , return chains as well , and when a chain is treated as a string the results of and , respectively , correspond to the results of the corresponding operations on strings . on the other hand ,",
    "the last operations is new and designed specifically to deal with trees .",
    "let us inspect these operations :    [ [ a - maximal - chain - compression ] ] @xmath25-maximal chain compression : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for a unary letter @xmath25 replace every @xmath25-maximal chain consisting of @xmath163 nodes with a fresh unary letter @xmath26 ( for all @xmath163 ) .",
    "[ [ ab - pair - compression ] ] @xmath164-pair compression : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for two unary letters @xmath165 replace every occurrence of @xmath162 by a single node labelled with a fresh unary letter @xmath29 ( which identifies the pair @xmath164 ) .    [",
    "[ f - i_1a_1ldotsi_ella_ell - leaf - compression ] ] @xmath166-leaf compression : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for @xmath167 , @xmath168 , @xmath169 and @xmath170 replace every occurrence of @xmath171 , where @xmath172 for @xmath173 and @xmath137 is a non - constant for @xmath174 , with @xmath175 , where @xmath176 is a fresh letter of rank @xmath177 ( which identifies @xmath166 ) .",
    "note that each of these operations decreases the size of the current tree .",
    "also note that for each of these compression operations one has to specify some arguments : for chain compression the unary letter @xmath25 , for unary pair compression the unary letters @xmath25 and @xmath178 , and for leaf compression the letter @xmath87 ( of rank at least 1 ) as well as the list of positions @xmath179 and the constants @xmath180 ,  , @xmath181 .    despite its rather cumbersome definition ,",
    "the idea behind leaf compression is easy : for a fixed occurrence of @xmath87 in a tree we ` absorb ' all leaf - children of @xmath87 that are constants ( and do the same for all other occurrences of @xmath87 that have the same set of leaf - children on the same positions ) .",
    "every application of one of our compression operations can be seen as the ` backtracking ' of a production of the grammar that we construct : when we replace @xmath24 by @xmath26 , we in fact introduce the new nonterminal @xmath182 with the production @xmath183 when we replace all occurrences of the chain @xmath162 by @xmath29 , the new production is @xmath184 finally , for a @xmath166-leaf compression the production is @xmath185 where @xmath172 for @xmath173 and every @xmath137 with @xmath174 is a parameter ( and the left - to - right order of the parameters in the right - hand side is @xmath186 ) .",
    "observe that all productions introduced in   are for nonterminals of rank at most @xmath4 .",
    "[ lem : small rank ] the rank of nonterminals defined by is at most @xmath4 .    during the analysis of the approximation ratio of we also consider the nonterminals of a smallest grammar generating the given input tree . to avoid confusion between these nonterminals and the nonterminals of the grammar produced by ,",
    "we insist on calling the fresh symbols introduced by ( @xmath26 , @xmath29 , and @xmath176 in  ) _ letters _ and add them to the set @xmath60 of current letters , so that @xmath60 always denotes the set of letters in the current tree . in particular , whenever we talk about nonterminals , productions , etc .",
    "we mean the ones of the smallest grammar we consider .    still , the above rules , , and form the grammar returned by our algorithm and we need to estimate their size .",
    "in order to not mix the notation , we will call the size of the rule for a new letter @xmath25 the _ representation cost _ for @xmath25 and say that @xmath25 _ represents _ the subpattern it replaces in @xmath1 .",
    "for instance , the representation cost of @xmath26 in is @xmath42 , the representation cost of @xmath29 in is @xmath100 , and the representation cost of @xmath176 in is @xmath187 .",
    "a crucial part of the analysis of is the reduction of the representation cost for @xmath26 .",
    "note that instead of representing @xmath188 directly via the rule , we can introduce new unary letters representing some shorter chains in @xmath24 and build a longer chains using the smaller ones as building blocks .",
    "for instance , the rule @xmath189 can be replaced by the rules @xmath190 , @xmath191 and @xmath192 .",
    "this yields a total representation cost of @xmath193 instead of @xmath194 .",
    "our algorithm employs a particular strategy for representing @xmath25-maximal chains . slightly abusing the notation",
    "we will say that the sum of the sizes of the right - hand sides of the generated subgrammar is the representation cost for @xmath26 ( for our strategy ) .",
    "the important property of the compression operations is that we can perform many of them in parallel : since different @xmath25-maximal chains and @xmath178-maximal chains do not overlap ( regardless of whether @xmath195 or not ) we can perform @xmath25-maximal chain compression for all @xmath196 in parallel ( assuming that the new letters do not belong to @xmath197 ) .",
    "this justifies the following compression procedure for compression of all @xmath25-maximal chains ( for all @xmath196 ) in a tree @xmath68 :    replace every @xmath25-maximal chain of size @xmath42 by a fresh letter @xmath26    we will refer to the procedure simply as _",
    "chain compression_. the running time of an appropriate implementation is considered in the next section and the corresponding representation cost is addressed in section  [ sec : size ] .",
    "a similar observation applies to leaf compressions : we can perform several different leaf compressions as long as we do not try to compress the letters introduced by these leaf compressions .",
    "replace each subtree @xmath171 s.t .",
    "@xmath172 for @xmath173 and @xmath198 for    @xmath199 by @xmath175    we refer to the procedure as _ leaf compression_. an efficient implementation is given in the next section , while the analysis of the number of introduced letters is done in section  [ sec : size ] .",
    "the situation is more subtle for unary pair compression : observe that in a chain @xmath200 we can compress @xmath162 or @xmath201 but we can not do both in parallel ( and the outcome depends on the order of the operations ) . however , as in the case of string compression  @xcite , parallel @xmath164-pair compressions are possible when we take @xmath25 and @xmath178 from disjoint subalphabets @xmath202 and @xmath203 , respectively . in this case",
    "we can tell for each unary letter whether it should be the parent node or the child node in the compression step and the result does not depend on the order of the considered @xmath100-chains , as long as the new letters do not belong to @xmath204 .",
    "replace each occurrence of @xmath162 with a fresh unary letter @xmath29    the procedure is called @xmath205-compression in the following .",
    "again , its efficient implementation is given in the next section and the analysis of the number of introduced letters is done in section  [ sec : size ] .",
    "in a single phase of the algorithm , chain compression , @xmath205-compression and leaf compression are executed in this order ( for an appropriate choice of the partition @xmath206 ) .",
    "the intuition behind this approach is as follows : if the tree @xmath68 in question does not have any unary letters , then leaf compression on its own reduces the size of @xmath68 by at least half , as it effectively reduces all constant nodes , i.e. , leaves of the tree , and more than half of the nodes are leaves . on the other end of the spectrum",
    "is the situation in which all nodes ( except for the unique leaf ) are labelled with unary letters . in this case",
    "our instance is in fact a string .",
    "chain compression and unary pair compression correspond to the operations of block compression and pair compression , respectively , from the earlier work of the first author on string compression  @xcite , where it is shown that block compression followed by pair compression reduces the size of the string by a constant factor ( for an appropriate choice of the partition @xmath206 of the letters occurring in the string ) .",
    "the in - between cases are a mix of those two extreme scenarios and it can be shown that for them the size of the instance drops by a constant factor in one phase as well .    recall from section   [ sec : conventions ] that @xmath207 always denotes the current tree kept by and that @xmath60 is the set of letters occurring in @xmath207 .",
    "moreover , @xmath2 denotes the size of the input tree .",
    "[ alg : mainloop ] @xmath208 list of unary letters in @xmath1 [ listing letters ] @xmath209 @xmath208 list of unary letters in @xmath1 [ listing pairs ] compute partition @xmath210 using the algorithm from lemma  [ lem : finding partition][partition letters ] @xmath211 @xmath212 list of constants in @xmath1 , @xmath213 list of other letters in @xmath1 @xmath214 constructed grammar    a single iteration of the main loop of is called a _",
    "phase_. in the rest of this section we show how to implement in linear time ( a polynomial implementation is straightforward ) , while in section  [ sec : size ] we analyze the approximation ratio of .",
    "since the compression operations use for grouping it is important that right before such a compression the letters in @xmath1 form an interval of numbers .",
    "as no letters are replaced in the listing of letters preceeding such a compression , it is enough to guarantee that after each compression , as a post - processing , letters are replaced so that they form an interval of numbers .",
    "such a post - processing takes linear time .",
    "[ lem : letters are consecutive ] after each compression operation performed by we can rename in time @xmath215 the letters used in @xmath1 so that they form an interval of numbers , where @xmath216 denotes the tree before the compression step . furthermore , in the preprocessing step we can in linear time ensure the same property for the input tree .",
    "recall that we assume that the input alphabet consists of letters that can be identified with elements from an interval @xmath217 for a constant @xmath29 , see the discussion in the introduction . treating them as @xmath2-ary numbers of length @xmath29 , we",
    "we can sort them using in @xmath218 time , i.e. , in linear time .",
    "then we can renumber the letters to @xmath219 for some @xmath220 .",
    "this preprocessing is done once at the beginning .",
    "fix the compression step and suppose that before the listing preceding this compression the letters formed an interval @xmath221 $ ] .",
    "each new letter , introduced in place of a compressed subpattern ( i.e. , a chain @xmath24 , a chain @xmath162 or a node @xmath87 together with some leaf - children ) is assigned a consecutive value , and so after the compression the letters occurring in @xmath1 are within an interval @xmath222 $ ] for some @xmath223 , note also that @xmath224 , as each new letter labels a node in @xmath1 .",
    "it is now left to re - number the letters from @xmath222 $ ] , so that the ones occurring in @xmath1 indeed form an interval . for each symbol in the interval @xmath222 $ ] we set a flag to @xmath35 . moreover , we set a variable @xmath225 to @xmath226",
    ". then we traverse @xmath1 ( in an arbitrary way ) .",
    "whenever we spot a letter @xmath227 $ ] with @xmath228 = 0 $ ] , we set @xmath228 : = 1 $ ] ; @xmath229 : = { \\textnormal{\\textsl{next}}}$ ] , and @xmath230 .",
    "moreover , we replace the label of the current node ( which is @xmath25 ) by @xmath229 $ ] .",
    "when we spot a symbol @xmath227 $ ] with @xmath228 = 1 $ ] , then we replace the label of the current node ( which is @xmath25 ) by @xmath229 $ ] .",
    "clearly the running time is @xmath231 and after the algorithm the symbols form a subinterval of @xmath232 $ ] .",
    "the reader might ask , why we do not assume in lemma  [ lem : letters are consecutive ] that the letters used in @xmath1 form an initial interval of numbers ( starting with @xmath15 ) .",
    "the above proof can be easily modified so that it ensures this property .",
    "but then , we would assign new names to letters , which makes it difficult to produce the final output grammar at the end .",
    "the efficient implementation of @xmath233 is very simple : we traverse @xmath207 . for an @xmath25-maximal chain of size",
    "@xmath234 we create a record @xmath235 , where @xmath236 is the pointer to the top - most node in this chain .",
    "we then sort these records lexicographically using ( ignoring the last component and viewing @xmath237 as a number of length @xmath100 )",
    ". there are at most @xmath238 records and we assume that @xmath60 can be identified with an interval , see lemma  [ lem : letters are consecutive ] . hence , needs time @xmath239 to sort the records .",
    "now , for a fixed unary letter @xmath25 , the consecutive tuples with the first component @xmath25 correspond to all @xmath25-maximal chains , ordered by size .",
    "it is easy to replace them in time @xmath240 with new letters .",
    "[ lem : chain comp time ] @xmath233 can be implemented in @xmath240 time .",
    "note that so far we did not care about the representation cost for the new letters that replace @xmath25-maximal chains .",
    "we use a particular scheme to represent @xmath241 , which will have a representation cost of @xmath242 , where we take @xmath243 for convenience .",
    "this is an easy , but important improvement over @xmath244 obtained using the binary expansion of the numbers @xmath245 .",
    "[ lem : cost of powers ] given a list @xmath246 we can represent the letters @xmath241 that replace the chain patterns @xmath247 with a total cost of @xmath242 , where @xmath248 .    the proof is identical , up to change of names , to the proof of lemma  2 in @xcite , still we supply it for completeness .",
    "firstly observe that without loss of generality we may assume that the list @xmath249 is given in a sorted way , as it can be easily obtained form the sorted list of occurrences of @xmath25-maximal chains .",
    "for simplicity define @xmath248 and let @xmath250 .    in the following ,",
    "we will define rules for certain new unary letters @xmath251 , each of them derives @xmath252 ( in other words , @xmath251 represents @xmath252 ) . for each @xmath253 introduce a new letter @xmath254 with the rule @xmath255 , where @xmath180 simply denotes @xmath25 .",
    "clearly @xmath254 represents @xmath256 and the representation cost summed over all @xmath253 is @xmath257 .",
    "now introduce new unary letters @xmath258 for each @xmath259 , which will represent @xmath260 .",
    "these letters are represented using the binary expansions of the numbers @xmath261 , i.e. , by concatenation of @xmath262 many letters from @xmath263 .",
    "this introduces an additional representation cost of @xmath264 .",
    "finally , each @xmath265 is represented as @xmath266 , which adds @xmath267 to the representation cost . summing all contributions yields the promised value @xmath242 .    in the following",
    "we will also use a simple property of chain compression : since no two @xmath25-maximal chains can be next to each other , there are no @xmath178-maximal chains ( for any unary letter @xmath178 ) of length greater than @xmath15 in @xmath1 after chain compression .",
    "[ lem : consecutive letters are different ] in line  [ listing pairs ] of algorithm there is no node in @xmath1 such that this node and its child are labelled with the same unary letter .",
    "suppose for the sake of contradiction that there is a node @xmath88 that is labelled with the unary letter @xmath25 and @xmath88 s unique child @xmath65 is labelled with @xmath25 too .",
    "there are two cases :    _ case 1 . _",
    "the letter @xmath25 was present in @xmath1 in line  [ listing letters ] : but then @xmath25 was listed in @xmath197 in line  [ listing letters ] and @xmath88 and @xmath65 are part of an @xmath25-maximal chain that was replaced by a single node during @xmath233 .",
    "_ case 2 . _",
    "the letter @xmath25 was introduced during @xmath233 : assume that @xmath25 represents @xmath268 .",
    "hence @xmath88 and @xmath65 both replaced @xmath178-maximal chains .",
    "but this is not possible since the definition of a @xmath178-maximal chain implies that two @xmath178-maximal chains are not adjacent .",
    "the operation of unary pair compression is implemented similarly as chain compression . as already noticed , since 2-chains can overlap ,",
    "compressing all 2-chains at the same time is not possible .",
    "still , we can find a subset of non - overlapping chain patterns of length 2 in @xmath1 such that an almost constant fraction of unary letters in @xmath1 is covered by occurrences of these chain patterns .",
    "this subset is defined by a _",
    "partition _ of the letters from @xmath197 occurring in @xmath1 into subsets @xmath202 and @xmath203 .",
    "then we replace all @xmath100-chains , whose first ( respectively , second ) node is labelled with a letter from @xmath202 ( respectively , @xmath203 ) .",
    "our first task is to show that indeed such a partition exists and that it can be found in time @xmath240 .",
    "[ lem : finding partition ] assume that ( i ) @xmath1 does not contain an occurrence of a chain pattern @xmath269 for some @xmath270 and ( ii ) that the symbols in @xmath207 form an interval of numbers .",
    "then , in time @xmath240 one can find a partition @xmath210 such that the number of occurrences of chain patterns from @xmath271 in @xmath1 is at least @xmath272 , where @xmath273 is the number of nodes in @xmath1 with a unary label and @xmath29 is the number of maximal chains in @xmath1 . in the same running time we can provide for each @xmath274 occurring in @xmath1 a lists of pointers to all occurrences of @xmath162 in @xmath1 .",
    "for a choice of @xmath202 and @xmath275 we say that occurrences of @xmath274 are _ covered _ by the partition @xmath210 .",
    "we extend this notion also to words : a partition covers also occurrences of a chain pattern @xmath162 in a word ( or set of words ) .",
    "the following claim is a slighter stronger version of ( * ? ? ?",
    "* lemma  4 ) , the proof is essentially the same , still , for completeness , we provide it below :    [ clm : finding partition ] _ for words @xmath276 , @xmath277 ,  , @xmath278 that do not contain a factor @xmath269 for any symbol @xmath25 and whose alphabet can be identified with an interval of numbers of size @xmath40 , one can in time @xmath279 partition the letters occurring in @xmath276 , @xmath277 ,  , @xmath278 into sets @xmath202 and @xmath203 such that the number of occurrences of chain patterns from @xmath271 in @xmath276 , @xmath277 , ",
    ", @xmath278 is at least @xmath280 . in the same running time we can provide for each @xmath274 occurring in @xmath276 , @xmath277 , ",
    ", @xmath278 a lists of pointers to all occurrences of @xmath162 in @xmath276 , @xmath277 ,  , @xmath278 .",
    "_    it is easy to derive the statement of the lemma from this claim : consider all maximal chains in @xmath1 , and let us treat the corresponding chain patterns as strings @xmath281 .",
    "the sum of their lengths is @xmath282 . by the assumption from the lemma no two consecutive letters in strings @xmath276 , @xmath277 ,  , @xmath278 are identical .",
    "moreover , the alphabet of @xmath276 , @xmath277 ,  , @xmath278 is within an interval of size @xmath283 . by claim  [ clm : finding partition ]",
    "one can compute in time @xmath284 a partition @xmath285 of @xmath197 such that @xmath286 many 2-chains from @xmath276 , @xmath277 ,  , @xmath278 are covered by this partition , and hence the same applies to @xmath1 .",
    "moreover , by claim  [ clm : finding partition ] one can also compute in time @xmath287 for every @xmath288 occurring in @xmath276 , @xmath277 , ",
    ", @xmath278 a lists of pointers to all occurrences of @xmath162 in @xmath276 , @xmath277 ,  , @xmath278 .",
    "it is straightforward to compute from this list a lists of pointers to all occurrences of @xmath162 in @xmath1 .",
    "let us now provide a proof of claim  [ clm : finding partition ] :    _ proof of claim  [ clm : finding partition ] .",
    "_ observe that finding a partition reduces to the ( well - studied and well - known ) problem of finding a cut in a directed and weighted graph : for the reduction , for each letter @xmath25 we create a node @xmath25 in a graph and make the weight of the edge @xmath289 the number of occurrences of @xmath162 in @xmath276 , @xmath277 , ",
    ", @xmath278 .",
    "a _ directed cut _ in this graph is a partition @xmath290 of the vertices , and the weight of this cut is the sum of all weights of edges in @xmath291 .",
    "it is easy to see that a directed cut of weight @xmath41 corresponds to a partition of the letters covering exactly @xmath41 occurrences of chain patterns ( and vice - versa ) .",
    "the rest of the the proof gives the standard construction  ( * ? ? ?",
    "* section  6.3 ) in the terminology used in the paper ( the running time analysis is not covered in standard sources ) .",
    "the existence of a partition covering at least one fourth of the occurrences can be shown by a  simple probabilistic argument : divide @xmath197 into @xmath202 and @xmath203 randomly , where each letter goes to each of the parts with probability @xmath292 .",
    "fix an occurrence of @xmath162 , then @xmath293 and @xmath294 with probability @xmath295 .",
    "there are @xmath296 such 2-chains in @xmath276 , @xmath277 ,  , @xmath278 , so the expected number of occurrences of patterns from @xmath271 in @xmath276 , @xmath277 , ",
    ", @xmath278 is @xmath280 .",
    "hence , there exists a partition that covers at least @xmath280 many occurrences of 2-chains .",
    "observe , that the expected number of occurrences of patterns from @xmath297 is @xmath298 .",
    "the deterministic construction of a partition covering at least @xmath280 occurrences follows by a simple derandomisation , using an expected value approach .",
    "it is easier to first find a  partition @xmath285 such that at least @xmath298 many occurrences of 2-chains in @xmath276 , @xmath277 ,  , @xmath278 are covered by @xmath297 .",
    "we then choose @xmath271 or @xmath299 , depending on which of them covers more occurrences .",
    "suppose that we have already assigned some letters to @xmath202 and @xmath203 and we have to decide where the next letter @xmath25 is assigned to .",
    "if it is assigned to @xmath202 , then all occurrences of patterns from @xmath300 are not going to be covered , while occurrences of patterns from @xmath301 are .",
    "a similar observation holds if @xmath25 is assigned to @xmath203 .",
    "the algorithm 2chains makes a greedy choice , maximising the number of covered 2-chains in each step .",
    "as there are only two options , the choice will cover at least half of all occurrences of 2-chains that contain the letter @xmath25 and a letter from @xmath285 .",
    "finally , as each occurrence of a pattern @xmath162 from @xmath276 , @xmath277 ,  , @xmath278 is considered exactly once ( namely when the second letter of @xmath25 and @xmath178 is considered in the main loop ) , this procedure guarantees that at least half of all 2-chains in @xmath276 , @xmath277 , ",
    ", @xmath278 are covered .    in order to make the selection efficient , the algorithm 2chains below keeps for every letter @xmath25 counters @xmath302 $ ] and @xmath303 $ ] , storing the number of occurrences of patterns from @xmath300 and @xmath304 , respectively , in @xmath276 , @xmath277 ,  , @xmath278 .",
    "these counters are updated as soon as a letter is assigned to @xmath202 or @xmath203 .",
    "@xmath208 set of letters used in @xmath276 , @xmath277 , ",
    ", @xmath278 @xmath305 @xmath302 \\gets { \\ensuremath{\\textnormal{\\textsl{count}}^{\\textnormal{down}}}}[a ] \\gets 0 $ ] @xmath306 @xmath307 @xmath308 \\gets { \\ensuremath{\\textnormal{\\textsl{count}}^{\\textnormal{choice}}}}[b ] + 1 $ ] [ counter update ] @xmath309 switch @xmath203 and @xmath202 [ actual partition ] @xmath310    by the argument given above , when @xmath197 is partitioned into @xmath202 and @xmath203 by 2chains , at least half of all @xmath100-chains in @xmath276 , @xmath277 ,  , @xmath278 are occurrences of patterns from @xmath297 .",
    "then one of the choices @xmath205 or @xmath311 covers at least one fourth of all @xmath100-chains in @xmath276 , @xmath277 ,  , @xmath278 .",
    "it is left to give an efficient variant of 2chains .",
    "the non - obvious operations are the updating of @xmath308 $ ] in line  [ counter update ] and the choice of the actual partition in line  [ actual partition ] .",
    "all other operation clearly take at most time @xmath312 .",
    "the latter is simple : since we organize @xmath202 and @xmath203 as bit vectors , we can read each @xmath276 , @xmath277 , ",
    ", @xmath278 from left to right ( in any order ) and calculate the number of occurrences of patterns from @xmath271 as well as those from @xmath299 in time @xmath312 ( when we read a  pattern @xmath162 we check in @xmath38 time whether @xmath274 or @xmath313 ) .",
    "afterwards we choose the partition that covers more @xmath100-chains in @xmath276 , @xmath277 ,  , @xmath278 .    to implement @xmath314 and @xmath315 , for each letter @xmath25 in @xmath276 , @xmath277 , ",
    ", @xmath278 we store a _",
    "right list _",
    "@xmath316 , represented as a list .",
    "furthermore , the element @xmath178 on the right list points to a list of all occurrences of the pattern @xmath162 in @xmath276 , @xmath277 ,  , @xmath278 .",
    "there is a similar _ left list _ @xmath317 .",
    "we comment on how to create the left lists and right lists in linear time later .",
    "given @xmath318 and @xmath319 , performing the update in line  [ counter update ] is easy : we go through @xmath320 ( respectively , @xmath321 ) and increment @xmath322 $ ] for every occurrence of @xmath162 ( respectively , @xmath323 ) .",
    "note that in this way each of the lists @xmath320 ( @xmath321 ) is read once during 2chains , the same applies also to pointers from those lists .",
    "therefore , all updates of @xmath314 and @xmath315 only need time @xmath312 , as the total number of pointers on those lists is @xmath240 .",
    "it remains to show how to initially create @xmath324 ( @xmath325 is created similarly ) .",
    "we read @xmath276 , @xmath277 ,  , @xmath278 .",
    "when reading a pattern @xmath162 we create a record @xmath326 , where @xmath236 is a pointer to this occurrence .",
    "we then sort these records lexicographically using , ignoring the last component .",
    "there are @xmath327 records and the alphabet is an interval of size @xmath40 , so needs time @xmath279 .",
    "now , for a fixed letter @xmath25 , the consecutive tuples with the first component @xmath25 can be turned into @xmath324 : for @xmath328 we want to store a list @xmath329 of pointers to occurrences of @xmath162 . on a sorted list of records the entries @xmath326 for @xmath330 form an interval of consecutive records .",
    "this shows the first statement from claim  [ clm : finding partition ] .    in order to show the second statement from claim  [ clm : finding partition ] , i.e. , in order to get for each @xmath274 the lists of pointers to occurrences of @xmath162 in @xmath276 , @xmath277 ,",
    ", @xmath278 , it is enough to read @xmath318 and filter the patterns @xmath162 such that @xmath331 and @xmath294 ; the filtering can be done in @xmath38 per occurrence as @xmath202 and @xmath203 are represented as bitvectors .",
    "the total needed time is @xmath312 .",
    "this concludes the proof of claim  [ clm : finding partition ] and thus also the proof of lemma  [ lem : finding partition ] .",
    "when for each pattern @xmath274 the list of its occurrences in @xmath1 is provided , the replacement of these occurrences is done by going through the list and replacing each of the occurrences , which is done in linear time .",
    "note that since @xmath202 and @xmath203 are disjoint , the considered occurrences can not overlap and the order of the replacements is unimportant .",
    "[ lem : pair comp time ] @xmath332 can be implemented in @xmath240 time .",
    "leaf compression is done in a similar way as chain compression and @xmath205-compression : we traverse @xmath1 .",
    "whenever we reach a node @xmath65 labelled with a symbol @xmath167 , we scan the list of its children .",
    "assume that this list is @xmath333 .",
    "when no @xmath334 is a leaf , we do nothing . otherwise , let @xmath335 be a list of those positions such that @xmath336 is a leaf , say labelled with a constant @xmath337 , for all @xmath338 .",
    "we create a record @xmath339 , where @xmath236 is a pointer to node @xmath65 , and continue with the traversing of @xmath1 .",
    "observe that the total number of elements in the created tuples is at most @xmath340 .",
    "furthermore each position index is at most @xmath341 and by lemma  [ lem : letters are consecutive ] also each letter is a number from an interval of size at most @xmath238 . hence sorts those tuples ( ignoring the pointer coordinate ) in time @xmath240 ( we use the version for lists of varying length ) . after the sorting the tuples corresponding to nodes with the same label and the same constant - labelled children ( at the same positions ) are consecutive on the returned list",
    ", so we can easily perform the replacement .",
    "given a tuple @xmath339 we use the last component ( i.e.  pointer ) in the created records to localize the node , replace the label @xmath87 with the fresh label @xmath176 and remove the children at positions @xmath342 ( note that in the meantime some other children might become leaves , we do not remove them , though ) .",
    "clearly all of this takes time @xmath240 .",
    "[ lem : leaf comp time ] @xmath343 can be implemented in @xmath240 time .",
    "it remains to estimate the total running time of our algorithm , summed over all phases . as each subprocedure in a phase has running time @xmath240 and there are constant number of them in a phase , it is enough to show that @xmath344 is reduced by a constant factor per phase ( then the sum of the running times over all phases is a geometric sum ) .",
    "[ lem : number of phases ] in each phase @xmath238 is reduced by a constant factor .    for @xmath49 let @xmath345 , @xmath346 , @xmath347 and @xmath348 be the number of nodes labelled with a letter of rank @xmath51 in @xmath207 at the beginning of the phase , after chain compression , unary pair compression , and leaf compression , respectively .",
    "let @xmath349 and define @xmath350 , @xmath351 , and @xmath352 similarly .",
    "we have @xmath353 to see this , note that there are @xmath354 nodes that are children ( ` @xmath355 ' is for the root ) . on the other hand ,",
    "a node of arity @xmath51 is a parent node for @xmath51 children .",
    "so the number of children is at least @xmath356 .",
    "comparing those two values yields  .",
    "we next show that @xmath357 which shows the claim of the lemma .",
    "let @xmath29 denote the number of maximal chains in @xmath1 at the beginning of the phase , this number does not change during chain compression and unary pair compression .",
    "observe that @xmath358 indeed , consider a maximal chain .",
    "then the node above has a label from @xmath359 ( unless the maximal chain includes the root ) while the node below it has a label from @xmath360 . summing this up over all chains , we get @xmath361 ( the ` @xmath362 ' is for the possibility that the root has a unary label ) , which yields  .    clearly after chain compression",
    "we have @xmath363 , @xmath364 and @xmath365 .",
    "furthermore , the number of maximal chains does not change . during unary pair compression , by lemma  [ lem : finding partition ] , we choose a partition such that at least @xmath366 many @xmath100-chains are compressed ( note that the assumption of lemma  [ lem : finding partition ] that no parent node and its child are labelled with the same unary letter is satisfied by lemma  [ lem : consecutive letters are different ] ) , so the size of the tree is reduced by at least @xmath366 .",
    "hence , the size of the tree after unary pair compression is at most @xmath367",
    "lastly , during leaf compression the size is reduced by @xmath368 .",
    "hence the size of @xmath1 after all three compression steps is @xmath369 as claimed .",
    "[ thm : time ] runs in linear time .    by lemma  [ lem",
    ": letters are consecutive ] there is a linear preprocessing . by lemmata  [ lem",
    ": letters are consecutive ] ,  [ lem : chain comp time ] ,  [ lem : pair comp time ] , and  [ lem : leaf comp time ] , each phase takes @xmath240 time and by lemma  [ lem : number of phases ] @xmath238 drops by a constant factor in each phase .",
    "as the initial size of @xmath207 is @xmath2 , the total running time is @xmath370 .",
    "to bound the cost of representing the letters introduced during the construction of the slcf grammar , we start with a smallest slcf grammar @xmath371 generating the input tree @xmath1 ( note that @xmath371 is not necessarily unique ) and show that we can transform it into an slcf grammar @xmath30 ( also generating @xmath1 ) of a special form and of size @xmath372 , where @xmath4 is the maximal rank of symbols in @xmath60 ( the set of letters occurring in @xmath371 ) .",
    "the transformation is based on known results on normal forms for slcf grammars  @xcite , see section  [ subsec : normal form ] .    during the run of we",
    "modify @xmath30 , preserving its special form , so that it generates @xmath1 ( i.e. , the current tree kept by ) after each of the compression steps of .",
    "then the cost of representing the letters introduced by is paid by various credits assigned to @xmath30 .",
    "therefore , instead of computing the total representation cost of the new letters , it suffices to calculate the total amount of issued credit , which is much easier than calculating the actual representation cost .",
    "note that this is entirely a mental experiment for the purpose of the analysis , as @xmath30 is not stored or even known by .",
    "we just perform some changes on it depending on the actions of .    in this section",
    "we show a slightly weaker bound , the full proof of the bound from theorem  [ thm : main ] is presented in section  [ sec : improved ] .",
    "it is known that every slcf grammar @xmath30 can be transformed into a monadic slcf grammar @xmath31 ( thus , every nonterminal of @xmath31 has rank @xmath35 or @xmath15 ) generating the same tree .",
    "moreover , @xmath31 is only @xmath373 times larger than @xmath129 , where @xmath4 is the maximal rank of letters from @xmath59 used in @xmath30  ( * ? ? ?",
    "* theorem  10 ) .",
    "however , we need a slightly stronger statement , which follows from the original proof of  ( * ? ? ? * theorem  10 ) .",
    "it is repeated in the appendix for completeness .",
    "we formalise this result in terms of _ handles _ :",
    "has rank @xmath35 , @xmath29 is a constant and @xmath25 is a unary letter . ]",
    "we say that a pattern @xmath374 is a _ handle _ if it is of the form @xmath375 where @xmath376 , every @xmath377 is either a constant symbol or a nonterminal of rank @xmath35 , every @xmath378 is a chain pattern , and @xmath83 is a parameter , see figure  [ fig : handle ] .",
    "note that @xmath379 for a unary letter @xmath25 is a handle . since handles",
    "have one parameter only , for handles @xmath380 we write @xmath381 for the tree @xmath382 and treat it as a string , similarly to chains patterns .     and",
    "rank @xmath35 nonterminal .",
    "the dots symbolize the chains of unary letters ended by a nonterminal of rank @xmath35 or a constant . ]",
    "we say that an slcf grammar @xmath144 is a _",
    "handle grammar _ ( or simply `` @xmath30 is handle '' ) if the following conditions hold :    1 .",
    "[ lg 1 ] @xmath383 2 .",
    "[ lg 2 ] for @xmath384 the unique rule for @xmath124 is of the form @xmath385 where @xmath88 , @xmath65 , and @xmath107 are ( perhaps empty ) sequences of handles and @xmath386 .",
    "we call @xmath147 the _ first _ and @xmath387 the _ second _ nonterminal in the rule for @xmath124 , see figure  [ fig : rules ] .",
    "3 .   [ lg 3 ] for @xmath388 the rule for @xmath124 is of the ( similar ) form @xmath389 where @xmath88 and @xmath65 are ( perhaps empty ) sequences of handles , @xmath29 is a constant , @xmath390 , and @xmath391 , see figure  [ fig : rules ] .",
    "again we speak of the _ first _ and _ second _ nonterminal in the rule for @xmath124 .",
    "note that the representation of the rules for nonterminals from @xmath392 is not unique .",
    "take for instance the rule @xmath393 , which can be written as @xmath394 for the handle @xmath395 or as @xmath396 for the handle @xmath397 .",
    "on the other hand , for nonterminals from @xmath398 the representation of the rules is unique , since there is a unique occurrence of the parameter @xmath83 in the right - hand side .    for each slcf grammar we can find an equivalent handle grammar that is at most @xmath4 times larger :    [ lem : monadic grammar ] from a given slcf grammar @xmath129 of size @xmath399 one can construct an equivalent handle grammar of size @xmath400 with only @xmath401 many occurrences of nonterminals of arity 1 in the rules ( and @xmath400 occurrences of nonterminals of arity 0 ) .",
    "the construction and proof of ( * ? ? ? * theorem  10 ) yield the claim , though the actual statement in @xcite is a bit weaker . for completeness",
    ", the proof of this stronger statement is given in the appendix .    ; each handle and nonterminal represents a context . ]",
    "when considering handle grammars it is useful to have some intuition about the trees they derive .",
    "be a pattern @xmath402 with a unique occurrence of the only parameter @xmath83 .",
    "observe that each nonterminal @xmath403 derives a unique context @xmath152 , the same applies to a handle @xmath87 and so we write @xmath404 as well .",
    "furthermore , we can ` concatenate ' contexts , so we write them in the string notation . also ,",
    "when we attach a tree from @xmath405 to a context , we obtain another tree from @xmath405 .",
    "thus , when we consider a rule @xmath406 in a handle grammar ( where @xmath407 are handles and @xmath124 , @xmath147 , and @xmath387 are nonterminals of rank 1 ) then @xmath408 , i.e. , we concatenate the contexts derived by the handles and nonterminals , see figure  [ fig : concatenating ] .",
    "similar considerations apply to other rules of handle grammars as well , also the ones for nonterminals of rank @xmath35 .      for a given input tree @xmath1",
    "we start ( as a mental experiment ) with a smallest slcf grammar generating @xmath1 .",
    "let @xmath3 be the size of this grammar .",
    "we first transform it to a handle grammar @xmath30 of size @xmath409 using lemma  [ lem : monadic grammar ] . the number of nonterminals of rank @xmath35 ( resp . , @xmath15 ) in @xmath30 is bounded by @xmath409 ( resp . , @xmath401 ) .",
    "in the following , by @xmath1 we will denote the current tree stored by . for analyzing the size of the grammar produced by applied to @xmath1",
    ", we use the accounting method , see e.g. ( * ? ? ?",
    "* section 17.2 ) . with each occurrence of a letter from @xmath59 in @xmath30 s rules we associate",
    "two units of _ credit _ ( no credit is assigned to occurrences of nonterminals in rules ) . during the run of we",
    "appropriately modify @xmath30 , so that @xmath410 ( recall that @xmath207 always denotes the current tree stored by ) . in other words",
    ", we perform the compression steps of also on @xmath30",
    ". we thereby always maintain the invariant that every occurrence of a letter from @xmath59 in @xmath30 s rules has two units of credit . in order to do this",
    ", we have to _ issue _ ( or pay ) some new credits during the modifications , and we have to do a precise bookkeeping on the amount of issued credit . on the other hand , if we do a compression step in @xmath30 , then we remove some occurrences of letters .",
    "the credit associated with these occurrences is then _ released _ and can be used to pay for the representation cost of the new letters introduced by the compression step . for unary pair compression and leaf compression , the released credit indeed suffices to pay the representation cost for the fresh letters , but for chain compression the released credit will not suffice . here",
    "we need some extra amount that will be estimated separately later on in section  [ subsec : chain cost ] . at the end ,",
    "we can bound the size of the grammar produced by by the sum of the initial credit assigned to @xmath30 , which is at most @xmath400 by lemma  [ lem : monadic grammar ] , plus the total amount of issued credit plus the extra cost estimated in section  [ subsec : chain cost ] .",
    "an important difference between our algorithm and the string compression algorithm from the earlier paper of the first author  @xcite is that we add new nonterminals to @xmath30 during its modification . to simplify notation ,",
    "we denote with @xmath40 always the number of nonterminals of the current grammar @xmath30 , and we denote its nonterminals with @xmath411 .",
    "we assume that @xmath412 if @xmath413 occurs in the right - hand side of @xmath414 , and that @xmath415 is the start nonterminal .",
    "with @xmath416 we always denote the current right - hand side of @xmath413 . in other words ,",
    "the productions of @xmath30 are @xmath417 for @xmath418 .",
    "again note that the modification of @xmath30 is not really carried out by , but is only done for the purpose of analyzing .",
    "suppose a compression step , for simplicity say an @xmath164-pair compression , is applied to @xmath1 .",
    "we should also reflect it in @xmath30 .",
    "the simplest solution would be to perform the same compression on each of the rules of @xmath30 , hoping that in this way all occurrences of @xmath162 in @xmath419 will be replaced by @xmath29 . however , this is not always the case .",
    "for instance , the 2-chain @xmath162 may occur ` between ' a nonterminal and a unary letter .",
    "this intuition is made precise in section  [ subsec : pair compression ] . to deal with this problem , we modify the grammar , so that the problem disappears .",
    "similar problems occur also when we want to replace an @xmath25-maximal chain or perform leaf compression .",
    "the solutions to those problems are similar and are given in section  [ subsec : block compression ] and section  [ subsec : child compression ] , respectively .    to ensure that @xmath30 stays handle and to estimate the amount",
    "of issued credit , we show that the grammar preserves the following invariants , where @xmath420 ( respectively , @xmath421 ) is the initial number of occurrences of nonterminals from @xmath392 ( respectively , @xmath398 ) in @xmath30 while @xmath422 and @xmath423 are those values at some particular moment .",
    "similarly , @xmath424 is the number of occurrences of nonterminals from @xmath425 .    1 .",
    "[ gr 1 ] @xmath30 is handle .",
    "[ gr 2 ] @xmath30 has nonterminals @xmath426 , where @xmath427 , @xmath428 and @xmath429 , @xmath430 .",
    "[ gr 3 ] the number @xmath431 of occurrences nonterminals from @xmath432 in @xmath30 never increases ( and is initially @xmath433 ) , and the number @xmath434 of occurrences of nonterminals from @xmath435 also never increases ( and is initially @xmath273 ) .",
    "4 .   [ gr 4 ]",
    "the number @xmath424 of occurrences of nonterminals from @xmath425 in @xmath30 is at most @xmath436 .",
    "[ gr 5 ] the rules for @xmath437 are of the form @xmath438 or @xmath439 , where @xmath107 is a string of unary symbols , @xmath440 , and @xmath29 is a constant",
    ".    intuitively , @xmath432 and @xmath435 are subsets of the initial nonterminals of rank @xmath35 and @xmath15 , respectively , while @xmath425 are the nonterminals introduced by , which are all of rank @xmath35 .",
    "clearly , ( )  ( ) hold for the initial handle grammar @xmath30 obtained by lemma  [ lem : monadic grammar ] .",
    "we begin with some necessary definitions that help to classify @xmath100-chains .    for a non - empty tree or context @xmath68 its _ first _",
    "letter is the letter that labels the root of @xmath68 . for a context @xmath374 which is not a parameter its _ last _",
    "letter is the label of the node above the one labelled with @xmath83 .",
    "for instance , the last letter of the context @xmath85 is @xmath178 and the last letter of the context @xmath442 is @xmath87 , which is also the first letter .",
    "a chain pattern @xmath162 has a _ crossing occurrence _ in a nonterminal @xmath413 if one of the following holds :    1 .",
    "[ cr 1 ] @xmath443 is a subpattern of @xmath416 and the first letter of @xmath444 is @xmath178 2 .",
    "[ cr 2 ] @xmath445 is a subpattern of @xmath416 and the last letter of @xmath444 is @xmath25 3 .",
    "[ cr 3 ] @xmath446 is a subpattern of @xmath416 , the last letter of @xmath444 is @xmath25 and the first letter of @xmath447 is @xmath178 .",
    "a chain pattern @xmath162 is _ crossing _ if it has a crossing occurrence in any nonterminal and _ non - crossing _ otherwise . unless explicitly written",
    ", we use this notion only in case @xmath165 .",
    "when every chain pattern @xmath274 is noncrossing , simulating @xmath205-compression on @xmath30 is easy : it is enough to apply @xmath448 ( algorithm  [ alg : treepaircomp ] ) to each right - hand side of @xmath30 .",
    "we denote the resulting grammar with @xmath449 .    in order to distinguish between the nonterminals , grammar , etc.before and",
    "after the application of ( or , in general , any procedure ) we use ` primed ' symbols , i.e. , @xmath450 , @xmath31 , @xmath451 for the nonterminals , grammar and tree , respectively , after the compression step and ` unprimed ' symbols ( i.e. , @xmath413 , @xmath30 , @xmath1 ) for the ones before .    [ lem : noncrossing compression ] let @xmath129 satisfy  ( )  ( ) and @xmath452 .",
    "then the following hold :    * the grammar @xmath31 satisfies  ( )  ( ) as well .",
    "* if there is no crossing chain pattern from @xmath271 in @xmath30 , then @xmath453 * the credit for new letters in @xmath31 and the cost of representing these new letters is paid by the released credit .",
    "clearly , @xmath454 can be obtained from @xmath419 by compressing some occurrences of patterns from @xmath271 .",
    "hence , to show that @xmath455 , it suffices to show that @xmath454 does not contain occurrences of patterns from @xmath271 .",
    "by induction on @xmath51 we show that for every @xmath418 , @xmath456 does not contain occurrences of patterns from @xmath271 .",
    "to get a contradiction , consider an occurrence of @xmath274 in @xmath457 .",
    "if it is generated by an explicit occurrence of @xmath162 in the right - hand side of @xmath450 then it was present already in the rule for @xmath413 , since we do not introduce new occurrences of the letters from @xmath129 .",
    "so , the occurrence of @xmath162 is replaced by a new letter in @xmath31 . if the occurrence is contained within the subtree generated by some @xmath458 ( @xmath459 ) , then the occurrence is compressed by the inductive assumption .",
    "the remaining case is that there exists a crossing occurrence of @xmath162 in the rule for @xmath460 .",
    "however note that if @xmath25 is the first ( or @xmath178 is the last ) letter of @xmath461 , then it was also the first ( respectively , last ) letter of @xmath444 in the input instance , as we do not introduce new occurrences of the old letters .",
    "hence , the occurrence of @xmath162 was crossing already in the input grammar @xmath30 , which is not possible by the assumption of the lemma .",
    "each occurrence of @xmath274 has 4 units of credit ( two for each symbol ) , which are released in the compression step .",
    "two of the released units are used to pay for the credit of the new occurrence of the symbol @xmath29 ( which replaces the occurrence of @xmath162 ) , while the other two units are used to pay for the representation cost of @xmath29 ( if we replace more than one occurrence of @xmath162 in @xmath129 , some credit is wasted ) .",
    "let us finally argue that the invariants ( )  ( ) are preserved : replacing an occurrence of @xmath162 with a single unary letter @xmath29 can not make a handle grammar a non - handle one , so  ( ) is preserved .",
    "similarly , ( ) is preserved .",
    "the set of nonterminals and the number of occurrences of the nonterminals is unaffected , so also ( )  ( ) are preserved .    by lemma  [ lem : noncrossing compression ]",
    "it is left to assure that indeed all occurrences of chain patterns from @xmath271 are noncrossing .",
    "what can go wrong ?",
    "consider for instance the grammar with the rules @xmath462 and @xmath463 .",
    "the pattern @xmath162 has a crossing occurrence . to deal with crossing occurrences we change the grammar . in our example , we replace @xmath464 with @xmath25 , leaving only @xmath465 , which does not contain a crossing occurrence of @xmath162 .",
    "suppose that some @xmath274 is crossing because of  ( ) .",
    "let @xmath466 be a subpattern of some right - hand side and let @xmath467 .",
    "then it is enough to modify the rule for @xmath413 so that @xmath468 and replace each occurrence of @xmath413 in a right - hand side by @xmath469 .",
    "we call this action _ popping - up @xmath178 from @xmath413_. the similar operation of _ popping down _ a letter @xmath25 from @xmath470 is symmetrically defined ( note that both pop operations apply only to unary letters ) .",
    "see figure  [ fig : uncrpair ] for an example .",
    "it is shown in the lemma below that popping up and popping down removes all crossing occurrences of @xmath162 .",
    "note that the operations of popping up and popping down can be performed for several letters in parallel : the procedure @xmath471 below ` uncrosses ' all occurrences of patterns from the set @xmath271 , assuming that @xmath202 and @xmath203 are disjoint subsets of @xmath472 ( and we apply it only in the cases in which they are disjoint ) .",
    "recall that for a handle grammar , right - hand sides can be viewed as sequences of nonterminals and handles .",
    "hence , we can speak of the first ( respectively , last ) symbol of a right - hand side .    [ still to the right ] replace @xmath413 in all right - hand sides of @xmath129 by @xmath178 [ remove - b ] remove this leading @xmath178 from @xmath416 replace @xmath413 in all right - hand sides of @xmath129 by @xmath469 [ still to the left ] replace @xmath413 in all right - hand sides of @xmath129 by @xmath25 [ remove - a ] remove this final @xmath25 from @xmath416 replace @xmath413 in all right - hand sides of @xmath129 by @xmath473    .",
    "the affected nodes are highlighted by squares . ]",
    "[ lem : uncrossing pairs ] assume that @xmath474 and let @xmath475 .",
    "then , the following hold :    * @xmath476 and hence @xmath477 .",
    "* all chain patterns from @xmath271 are non - crossing in @xmath31 . *",
    "if @xmath30 satisfies  ( )  ( ) , then so does @xmath31 .",
    "* at most @xmath478 units of credit are issued in the computation of @xmath31 .",
    "observe first that whenever we pop up @xmath178 from some @xmath413 , then we replace each of @xmath413 s occurrences in @xmath30 with @xmath469 ( or with @xmath178 , when @xmath479 ) , and similarly for the popping down operation , thus the value of @xmath444 is not changed for @xmath480 .",
    "hence , in the end we have @xmath481 ( note that @xmath415 does not pop letters ) .",
    "secondly , we show that if the first letter of @xmath456 ( where @xmath482 ) is @xmath483 then we popped - up a letter from @xmath413 ( which by the code is some @xmath294 ) ; a similar claim holds by symmetry for the last letter of @xmath484 .",
    "so , suppose that the claim is not true and consider the nonterminal @xmath413 with the smallest @xmath51 such that the first letter of @xmath456 is @xmath483 but we did not pop up a letter from @xmath413 .",
    "consider the first symbol of @xmath416 when considered @xmath413 in line  [ still to the right ] .",
    "note , that as did not pop up a letter from @xmath413 , the first letter of @xmath484 and @xmath456 is the same and hence it is @xmath483 .",
    "so @xmath416 can not begin with a letter as then it is @xmath483 which should have been popped - up .",
    "hence , the first symbol of @xmath416 is some nonterminal @xmath414 for @xmath459 .",
    "but then the first letter of @xmath485 is @xmath483 and so by the inductive assumption popped - up a letter from @xmath414 .",
    "hence , @xmath416 begins with a letter when @xmath413 is considered in line  [ still to the right ] .",
    "we obtained a contradiction .",
    "suppose now that after there is a crossing pattern @xmath274 .",
    "this is due to one of the bad situations ( )  ( ) .",
    "we consider only ( ) ; the other cases are dealt in a similar fashion .",
    "hence , assume that @xmath486 is a subpattern in a right - hand side of @xmath31 and the first letter of @xmath457 is @xmath178 .",
    "note that as @xmath487 is labelling the parent node of an occurrence of @xmath460 in @xmath31 , @xmath413 did not pop up a letter .",
    "but the first letter of @xmath456 is @xmath294 .",
    "so , @xmath413 should have popped up a letter by our earlier claim , which is a contradiction .",
    "note that introduces at most two new letters for each occurrence of a  nonterminal from @xmath435 ( one popped up and one popped down ) and at most @xmath15 new letter for each occurrence of a nonterminal from @xmath488 ( as nonterminals of rank @xmath35 can not pop down a letter ) . as",
    "each letter has two units of credit ; the estimation on the number of issued credit is correct .    concerning the preservation of the invariants , note that @xmath489 does not introduce new nonterminals or new occurrences of existing nonterminals",
    "( occurrences of nonterminals can be eliminated in line  [ remove - b ] and  [ remove - a ] ) . therefore , ( )  ( ) are preserved . moreover , also the form of the productions guaranteed by ( ) and ( ) can not be spoiled , so ( ) and ( ) are preserved as well .",
    "hence , to simulate @xmath310-compression on @xmath30 it is enough to first uncross all 2-chains from @xmath271 and then compress them all using @xmath449 .",
    "[ lem : pc crossing ] let @xmath30 satisfy ( )  ( ) and @xmath490 then the following hold :    * @xmath491 * the grammar @xmath31 satisfies  ( )  ( ) as well .",
    "* at most @xmath492 units of credit are issued in the computation of @xmath31 . *",
    "the issued credit and the credit released by @xmath493 cover the representation cost of fresh letters as well as their credit in @xmath31 .    by lemma  [ lem : uncrossing pairs ] ,",
    "every chain pattern from @xmath271 is non - crossing in @xmath471 .",
    "we get @xmath494 moreover , at most @xmath492 units of credit are issued . by lemma  [ lem : noncrossing compression ] the cost of representing new letters introduced by is covered by the released credit . finally , both and preserve the invariants ( )  ( ) .",
    "since by lemma  [ lem : number of phases ] we apply at most @xmath20 many @xmath205-compressions ( for different sets @xmath202 and @xmath203 ) and by ( )  ( ) we have @xmath495 , @xmath496 and @xmath497 , we obtain .",
    "[ cor : credit pair compression ] @xmath205-compression issues in total @xmath498 units of credit during all modifications of @xmath30 .",
    "our notations and analysis for chain compression is similar to those for @xmath205-compression . in order to simulate chain compression on @xmath30",
    "we want to apply ( algorithm  [ alg : treechaincomp ] ) to the right - hand sides of @xmath30 .",
    "this works as long as there are no crossing chains : a unary letter @xmath25 _ has a crossing chain _ in a rule @xmath417 if @xmath269 has a crossing occurrence in @xmath416 , otherwise @xmath25 has no crossing chain . as for @xmath205-compression ,",
    "when there are no crossing chains , we apply to the right - hand sides of @xmath30 .",
    "we denote with @xmath499 the grammar obtained by applying @xmath500 to all right - hand sides of @xmath30 .",
    "let @xmath30 satisfies ( )  ( ) and @xmath501 . then the following hold :    * if no unary letter from @xmath197 has a crossing chain in a rule of @xmath30 , then @xmath502 * the grammar @xmath31 satisfies  ( )  ( ) as well .",
    "-prefix and @xmath25-suffix depicted . ]",
    "the proof is similar to the proof of lemma  [ lem : noncrossing compression ] and so it is omitted .",
    "note that so far we have neither given a bound on the amount of issued credit nor on the representation cost for the new letters @xmath26 introduced by @xmath500 .",
    "let us postpone these points and first show how to ensure that no letter has a crossing chain .",
    "the solution is similar to : suppose for instance that @xmath25 has a crossing chain due to ( ) , i.e. , some @xmath466 is a subpattern in a right - hand side and @xmath484 begins with @xmath25 . popping up @xmath25 does not solve the problem , since after popping , @xmath484 might still begin with @xmath25 .",
    "thus , we keep on popping up until the first letter of @xmath484 is not @xmath25 , see figure  [ fig : uncrchain ] . in order to do this in one step",
    "we need some notation : we say that @xmath24 is an _",
    "@xmath25-prefix _ of a tree ( or context ) @xmath68 if @xmath503 and the first letter of @xmath504 is not @xmath25 ( here @xmath504 might be the trivial context @xmath83 ) , see figure  [ fig : prefixsuffix ] . in this terminology",
    ", we remove the @xmath25-prefix of @xmath484 .",
    "similarly , we say that @xmath24 is an _",
    "@xmath25-suffix _ of a context @xmath374 if @xmath505 for a context @xmath506 and the last letter of @xmath504 is not @xmath25 ( again , @xmath504 might be the trivial context @xmath83 and then @xmath24 is also the @xmath25-prefix of @xmath68 ) .",
    "the following algorithm eliminates crossing chains from @xmath30 .",
    "let @xmath236 be the length of the @xmath25-prefix of @xmath416 [ length - l ] replace @xmath413 in all right - hand sides by @xmath507 remove @xmath507 from the beginning of @xmath416 replace @xmath413 by @xmath508 in all right - hand sides [ popping prefix ] let @xmath5 be the length of the @xmath178-suffix of @xmath416 [ length - r ] replace @xmath413 in all right - hand sides by @xmath509 remove @xmath509 from the end of @xmath416 replace @xmath413 by @xmath510 in all right - hand sides[popping suffix ]    [ lem : uncrossing chains ] let @xmath31 = ( @xmath30 ) . then the following hold :    * @xmath511 and hence @xmath477 . *",
    "no unary letter has a crossing chain in @xmath31 . * if @xmath30 satisfies ( )  ( ) , then so does @xmath31 .",
    "first observe that whenever we remove the @xmath25-prefix @xmath512 from the rule for @xmath413 we replace each occurrence of @xmath413 by @xmath513 and similarly for @xmath178-suffixes .",
    "hence , as long as @xmath414 is not yet considered , it defines the same tree as in the input tree .",
    "in particular , after we have @xmath476 , as we do not pop prefixes and suffixes from @xmath415 .",
    "next , we show that when @xmath514 considers @xmath413 , then @xmath236 from line  [",
    "length - l ] is the length of the @xmath25-prefix of @xmath484 ( similarly , @xmath5 from line  [ length - r ] is the length of the @xmath25-suffix of @xmath484 ) .",
    "suppose that this is not the case and consider @xmath413 with smallest @xmath51 which violates the statement .",
    "clearly @xmath515 since there are no nonterminals in the right - hand side for @xmath464 .",
    "let @xmath516 be the @xmath25-prefix of @xmath484 .",
    "we have @xmath517 . the symbol below @xmath507 in @xmath416 ( which must exist because otherwise @xmath518 ) can not be a letter ( as the @xmath25-prefix of @xmath484 is not @xmath507 ) , so it is a nonterminal @xmath414 with @xmath459 .",
    "the first letter of @xmath444 must be @xmath25 .",
    "let @xmath519 be the @xmath25-prefix of @xmath444 .",
    "by induction , @xmath414 popped up @xmath519 , and at the time when @xmath413 is considered , the first letter of @xmath444 is different from @xmath25 .",
    "hence , the @xmath25-prefix of @xmath484 is exactly @xmath507 , a contradiction .    as a consequence of the above statement ,",
    "if @xmath486 occurs in a right - hand side of the output grammar @xmath31 , then @xmath25 is not the first letter of @xmath457 .",
    "this shows that ( ) can not hold for a chain pattern @xmath269 .",
    "the conditions ( ) and ( ) are handled similarly .",
    "so there are no crossing chains after .    concerning the preservation of ( )  ( )",
    ", the argument is the same as in the proof of lemma  [ lem : uncrossing pairs ] and therefore omitted .",
    "so chain compression is done by first running and then on the right - hand sides of @xmath30 . concerning the amount of issued credit , note that the arbitrarily long chains popped by are compressed into single letters by .",
    "hence , as for @xmath205-compression , only four units of credit per occurrence of a nonterminal from @xmath435 and two units of credit per occurrence of a nonterminal from @xmath488 have to be issued .",
    "we get :    [ lem : blocksc ] let @xmath30 satisfy ( )  ( ) and @xmath520 .",
    "then , the following hold :    * @xmath521 * the grammar @xmath31 satisfies  ( )  ( ) as well . * at most @xmath492 units of credit are issued in the computation of @xmath31 and this credit is used to pay the credit for the fresh letters @xmath26 in the grammar introduced by ( but not their representation cost ) .",
    "since by lemma  [ lem : number of phases ] we apply at most @xmath20 many chain compressions to @xmath30 and by ( )  ( ) we have @xmath495 , @xmath496 and @xmath497 , we get :    [ cor : credit chain compression ] chain compression issues in total @xmath498 units of credit during all modifications of @xmath30 .",
    "the total representation cost for the new letters @xmath26 introduced by chain compression will be estimated separately in section  [ subsec : chain cost ] .      in order to simulate leaf compression on @xmath30",
    "we perform similar operations as in the case of @xmath205-compression : ideally we would like to apply to each rule of @xmath30 .",
    "however , in some cases this does not return the appropriate result .",
    "we say that the pair @xmath522 is a _ crossing parent - leaf pair _ in @xmath30 , if @xmath167 , @xmath523 , and one of the following cases holds :    1 .",
    "[ fc 1 ] @xmath524 is a subtree of some right - hand side of @xmath30 , where for some @xmath139 we have @xmath525 and @xmath526 .",
    "2 .   [ fc 2 ] for some @xmath527",
    ", @xmath528 is a subtree of some right - hand side of @xmath30 and the last letter of @xmath484 is @xmath87 .",
    "3 .   [ fc 3 ] for some @xmath527 and @xmath529 , @xmath446 is a subtree of some right - hand side of @xmath30 , the last letter of @xmath484 is @xmath87 , and @xmath526 .    when there is no crossing parent - leaf pair , we proceed as in the case of any of the two previous compressions : we apply to each right - hand side of a rule .",
    "we denote the resulting grammar with @xmath530 .",
    "[ lem : no crossing parent node child compression ] let @xmath30 satisfy ( )  ( ) and @xmath531 .",
    "then , the following hold :    * if there is no crossing parent - leaf pair in @xmath30 , then @xmath532 . * the cost of representing new letters and the credits for those letters are covered by the released credit . *",
    "the grammar @xmath31 satisfies  ( )  ( ) as well .",
    "most of the proof follows similar lines as the proof of lemma  [ lem : noncrossing compression ] , but there are some small differences .",
    "let us first prove that @xmath532 under the assumption that there is no crossing parent - leaf pair in @xmath30 .",
    "as in the proof of lemma  [ lem : noncrossing compression ] it suffices to show that @xmath454 does not contain a subtree of the form @xmath533 with @xmath167 such that there exist positions @xmath534 ( @xmath168 ) and constants @xmath535 with @xmath536 for @xmath173 and @xmath537 for @xmath174 ( note that the new letters introduced by @xmath538 do not belong to the alphabet @xmath60 ) .",
    "assume that such a subtree exists in @xmath457 .",
    "using induction , we will deduce a contradiction .",
    "if the root @xmath87 together with its children at positions @xmath539 are generated by some other nonterminal @xmath458 occurring in the right - hand side of @xmath460 , then these nodes are compressed by the induction assumption .",
    "if they all occur explicitly in the right - hand side , then they are compressed by @xmath530 .",
    "the only remaining case is that @xmath31 contains a crossing parent - leaf pair .",
    "but then , since @xmath540 are old letters , this crossing parent - leaf pair must be already present in @xmath30 , which contradicts the assumption from the lemma .",
    "concerning the representation cost for the new letters , observe that when @xmath87 and @xmath42 of its children are compressed , the representation cost for the new letter is @xmath187 .",
    "there is at least one occurrence of @xmath87 with those children in a right - hand side of @xmath30 . before the compression these nodes held @xmath541 units of credit .",
    "after the compression , only two units are needed for the new node .",
    "the other @xmath542 units are enough to pay for the representation cost .    concerning the preservation of the invariants , observe that no new nonterminals were introduced , so ( )  ( )",
    "are preserved .",
    "also the form of the rules for @xmath543 can not be altered ( the only possible change affecting those rules is a replacement of @xmath544 , where @xmath270 and @xmath545 , by a new letter @xmath546 ) .",
    "so it is left to show that the resulting grammar is handle .",
    "it is easy to show that after a leaf compression a handle is still a handle , with only one exception : assume we have a handle @xmath547 followed by a constant @xmath29 in the right - hand side @xmath416 of @xmath413 .",
    "such a situation can only occur , if @xmath548 and @xmath416 is of the form @xmath549 or @xmath550 for sequences of handles @xmath88 and @xmath65 , where @xmath551 for a possibly empty sequence of handles @xmath552 ( see ( hg[lg 3 ] ) ) .",
    "then leaf compression merges the constant @xmath29 into the @xmath87 from the handle @xmath553 .",
    "there are two cases : if all @xmath554 ( which are chains ) are empty and all @xmath555 are constants from @xmath556 , then the resulting tree after leaf compression is a constant and no problem arises .",
    "otherwise , we obtain a tree of the form @xmath557 , where every @xmath558 is a chain , and every @xmath559 is either a constant or a nonterminal of rank @xmath35 .",
    "we must have @xmath560 ( otherwise , this is in fact the first case ) .",
    "therefore , @xmath557 can be written ( in several ways ) as a handle , followed by ( a possibly empty ) chain , followed by a constant or a nonterminal of rank @xmath35 .",
    "for instance , we can write the rule for @xmath413 as @xmath561 or @xmath562 ( depending on the form of the original rule for @xmath413 ) . this rule has one of the forms from ( hg[lg 3 ] ) , which concludes the proof .",
    "note that we possibly add a second nonterminal to the right - hand side of @xmath563 in the second case ( as @xmath564 can be a non - terminal ) , which is allowed in ( hg[lg 3 ] ) .",
    "if there are crossing parent - leaf pairs , then we uncross them all by a generalisation of the procedure .",
    "observe that in some sense we already have a partition : we want to pop up letters from @xmath556 and pop down letters from @xmath565 .",
    "the latter requires some generalisation , as when we pop down a letter , it may have rank greater than @xmath15 and so we need to in fact pop a whole handle .",
    "this adds new nonterminals to @xmath30 as well as a large number of new letters and hence a large amount of credit , so we need to be careful .",
    "there are two crucial details :    * when we pop down a whole handle @xmath566 , we add to the set @xmath567 fresh nonterminals for all trees @xmath137 that are non - constants , replace these @xmath137 in @xmath553 by their corresponding nonterminals and then pop down the resulting handle . in this way on one hand we keep the issued credit small and on the other no new occurrence of nonterminals from @xmath568 are created .",
    "* we do not pop down a handle from every nonterminal , but do it only when it is needed , i.e. , if for @xmath527 one of the cases ( ) or ( ) holds .",
    "this allows preserving ( ) .",
    "note that when the last symbol in the rule for @xmath413 is not a handle but another nonterminal , this might cause a need for recursive popping .",
    "so we perform the whole popping down in a depth - first - search style .",
    "our generalized popping procedure is called ( algorithm  [ code - algremchild ] ) and is shown in figure  [ fig : uncrleaf ] .",
    "[ no more constants ] replace each @xmath413 in the right - hand sides by @xmath25 [ replaced by a constant ] mark @xmath413 mark @xmath414    let @xmath416 end with handle @xmath569 [ popping from marked ] remove this handle from @xmath416 [ removing handle ] create a rule @xmath570 for a fresh nonterminal @xmath571 [ new rule ] add @xmath571 to @xmath567 [ add - to - n_0-tilde ] @xmath572 @xmath573 replace each @xmath574 in a right - hand side by @xmath575 [ new nonterminals ]    [ lem : uncrossing children ] let @xmath30 satisfy ( )  ( ) and @xmath576 . then , the following hold :    * @xmath577 and hence @xmath477 . * the grammar @xmath31 satisfies ( )  ( ) as well .",
    "* the grammar @xmath31 has no crossing parent - leaf pair .",
    "* at most @xmath578 units of credit are issued during the run of .",
    "the identity @xmath577 follows as for @xmath489 .",
    "next , we show that ( )  ( ) are preserved : so , assume that @xmath30 satisfies ( )  ( ) . replacing nonterminals by constants and popping down handles can not turn a handle grammar into one that is not a handle grammar , so ( ) is preserved .",
    "the number of nonterminals in @xmath432 and @xmath435 does not increase , so ( ) also holds . concerning ( ) ,",
    "observe that no new occurrences of nonterminals from @xmath435 are produced and that new occurrences of nonterminals from @xmath432 can be created only in line  [ new rule ] , when a rule @xmath570 is added to @xmath30 ( @xmath579 may end with a nonterminal from @xmath432 ) .",
    "however , immediately before , in line  [ removing handle ] , we removed one occurrence of @xmath579 from @xmath30 , so the total count is the same . hence ( ) holds .    the rules for the new nonterminals @xmath580 that are added in line [ add - to - n_0-tilde ] are of the form @xmath570 , where @xmath569 was a handle .",
    "so , by the definition of a handle , every @xmath579 is either of the form @xmath581 or @xmath582 , where @xmath107 is a string of unary letters , @xmath29 a constant , and @xmath583 .",
    "hence , the rule for @xmath571 is of the form required in ( ) and thus ( ) is preserved .",
    "it remains to show ( ) , i.e. , the bound on the number of occurrences of nonterminals from @xmath567 , which is the only non - trivial task .",
    "when we remove the handle @xmath569 from the rule for @xmath413 and introduce new nonterminals @xmath584 , ",
    ", @xmath585 then we say that @xmath413 _ owns _ those new nonterminals ( note that @xmath527 ) . might be constants and are not replaced by new nonterminals @xmath571 . for notational simplicity",
    "we assume here that no @xmath579 is a constant , which in some sense is the worst case . ] furthermore , when we replace an occurrence of @xmath574 in a right - hand side by @xmath586 in line  [ new nonterminals ] , those new occurrences of @xmath584 , ",
    ", @xmath585 are _ owned _ by this particular occurrence of @xmath413 . if the owning nonterminal ( or its occurrence ) is later removed from the grammar , the owned ( occurrences of ) nonterminals get _ disowned _ and they remain so till they get removed .",
    "the crucial technical claim is that one occurrence of a nonterminal owns at most @xmath587 occurrences of nonterminals , here stated in a slightly stronger form :    [ clm : at most r-1 ] when an occurrence of @xmath527 creates new occurrences of nonterminals ( in line  [ new nonterminals ] ) from @xmath425 , then right before it does not own any occurrences of other nonterminals from @xmath425 .",
    "this is shown in a series of simpler claims .",
    "[ clm : the same owned appearances ] for a fixed nonterminal @xmath527 , every occurrence of @xmath413 owns occurrences of the same nonterminals @xmath588 .",
    "this is obvious : we assign occurrences of the same nonterminals @xmath588 to each occurrence of @xmath413 in line  [ new nonterminals ] and the only way that such an occurrence ceases to exist is when @xmath571 is replaced with a constant . but",
    "this happens for all occurrences of @xmath571 at the same time",
    ".     dominates the tree @xmath504 . ]    in order to formulate the next claim , we need some notation : we say that an occurrence of a subcontext @xmath374 of @xmath1 _ dominates _ an occurrence of the subtree @xmath504 of @xmath1 , if @xmath1 can be written as @xmath589 , where @xmath68 and @xmath504 refer here to the specific occurrences of @xmath68 and @xmath504 , respectively , see figure  [ fig : domination ] for an illustration .",
    "[ clm : domination prevails ] when @xmath413 owns @xmath571 then each subcontext generated by @xmath413 in @xmath1 dominates a subtree generated by @xmath571 .",
    "this is true right after the introduction of an owned nonterminal @xmath571 : each occurrence of @xmath413 is replaced by @xmath586 and this occurrence of @xmath413 owns the occurrence of @xmath571 in this particular @xmath590 . what can change ?",
    "compression of letters does not affect dominance , as we always compress subtrees that are either completely within @xmath484 or completely outside @xmath484 and the same applies to each @xmath571 . when popping up from @xmath571 then",
    "the new tree generated by this occurrence of @xmath571 is a subtree of the previous one , so the dominance is not affected . when popping up or popping down from @xmath413 , then the new context is a subcontext of the previous one , so dominance is also not affected ( assuming that @xmath413 exists afterwards ) . hence the claim holds .",
    "[ clm : dominates constant ] when @xmath413 is marked by , then @xmath1 contains a subtree of the form @xmath591 for a constant symbol @xmath25 , where the subcontext @xmath68 is generated by an occurrence of @xmath413 .",
    "if @xmath413 was marked because @xmath528 occurs in some rule then this is obvious , otherwise it was marked because it is the last nonterminal in the right - hand side of some @xmath414 which is also marked ( and @xmath592 ) . by induction",
    "we conclude that @xmath1 contains a subtree of the form @xmath591 for a constant symbol @xmath25 , where the subcontext @xmath68 is generated by an occurrence of @xmath414 . but",
    "as @xmath413 is the last symbol in the right - hand side for @xmath414 , the same is true for @xmath413 .",
    "getting back to the proof of claim  [ clm : at most r-1 ] , suppose that we create new occurrences of the nonterminals @xmath588 in line  [ new nonterminals ] and right before line  [ new nonterminals ] , @xmath413 already owns a nonterminal @xmath593",
    ". then @xmath413 must be marked and so by claim  [ clm : dominates constant ] we know that @xmath1 contains a subtree of the form @xmath591 for a constant @xmath25 , where the subcontext @xmath68 is generated by an occurrence of @xmath413 . by claim  [ clm : the same owned appearances ] this occurrence of @xmath413 owns an occurrence of @xmath593 .",
    "then by claim  [ clm : domination prevails ] @xmath593 must produce the constant @xmath25 .",
    "but this is not possible , since in line  [ no more constants ] we eliminate all nonterminals that generate constants , and there is no way to introduce a nonterminal that produces a constant .",
    "so , we derived a contradiction and thus claim  [ clm : at most r-1 ] holds .",
    "using claim  [ clm : at most r-1 ] we can show the bound from ( ) on the number of occurrences of nonterminals from @xmath425 .",
    "the bound clearly holds as long as there are no disowned nonterminals : each occurrence of a nonterminal from @xmath425 is owned by an occurrence of a nonterminal from @xmath435 . by claim  [ clm : at most r-1 ] at most @xmath587 of them are owned by an occurrence of a nonterminal from @xmath435 , so there are at most @xmath594 such occurrence , where @xmath497 by ( ) . as the second subclaim we show that there are at most @xmath595 disowned occurrences of nonterminals from @xmath425 , which finally shows ( ) .",
    "this is shown by induction and clearly holds when there are no disowned nonterminals . by ( )",
    "the number @xmath423 of occurrences of nonterminals from @xmath435 never increases .",
    "so it is left to consider what happens , when a nonterminal gets disowned .",
    "assume that it was owned by @xmath527 and now this @xmath413 is removed from @xmath30 .",
    "thus @xmath423 decreases by @xmath15 and we know , from claim  [ clm : at most r-1 ] that @xmath413 owns at most @xmath587 nonterminals , which yields the claim .    concerning the credit",
    ": we issue at most two units of credit per occurrence of a nonterminal from @xmath432 and @xmath425 during popping up and @xmath596 units per occurrence of a nonterminal from @xmath435 during popping down .",
    "so at most @xmath597 units of credit have to be issued .",
    "finally , we show that @xmath576 does not contain crossing parent - leaf pairs .",
    "observe that after the loop in line  [ no more constants ] there are no nonterminals @xmath413 such that @xmath598 .",
    "afterwards , we can not create a nonterminal that evaluates to a constant in @xmath599 .",
    "hence there can be no crossing parent - leaf pair that satisfies ( ) or ( ) .    in order to rule out ( ) , we proceed with a series of claims . we first claim that if @xmath413 is marked then in line  [ popping from marked ] indeed the last symbol in the rule @xmath417 is a handle ( so it can be removed in line [ removing handle ] ) .",
    "suppose this is wrong and let @xmath413 be the nonterminal with the smallest @xmath51 for which this does not hold .",
    "as a first technical step observe that if some @xmath414 is marked then @xmath600 : indeed , if @xmath601 occurs in a rule of @xmath30 then clearly @xmath600 and if @xmath602 is the last nonterminal in the rule for @xmath600 then @xmath603 as well .",
    "hence @xmath527 .",
    "so the last symbol in the rule for @xmath413 is either a nonterminal @xmath600 with @xmath459 or a handle . in the latter case",
    "we are done as there is no way to remove this handle from the rule for @xmath413 before @xmath413 is considered in line  [ popping from marked ] . in the former case observe that @xmath414 is also marked . by the minimality of @xmath51 , when @xmath414 is considered in line  [ popping from marked ]",
    ", it ends with a handle @xmath569 .",
    "hence the terminating @xmath604 in the right - hand side for @xmath413 is replaced by @xmath605 and there is no way to remove the handle @xmath606 from the end until @xmath413 is considered in line [ removing handle ] .",
    "finally , suppose that there is a crossing parent - leaf pair because of the situation ( ) after @xmath607 , i.e. , @xmath528 occurs in some right - hand side and the last letter of @xmath484 is @xmath87 .",
    "then in particular we did not pop down a letter from @xmath413 , so by the earlier claim @xmath413 was not marked .",
    "but @xmath528 occurs in the right - hand already after the loop in line  [ no more constants ] , because @xmath25 can not be introduced after the loop .",
    "so we should have marked @xmath413 , which is a contradiction .",
    "so in case of leaf compression we can proceed as in the case of @xmath205-compression and chain compression : we first uncross all parent - leaf pairs and then compress each right - hand side independently .",
    "[ lem : representation cost child ] let @xmath608 .",
    "then , the following hold :    * @xmath609 * if @xmath30 satisfy ( )  ( ) , then so does @xmath31 . * at most @xmath578 units of credit are issued in the computation of @xmath31 . *",
    "the issued credit and the credit released by @xmath538 cover the representation cost of fresh letters as well as their credit in @xmath31 .",
    "this is a combination of lemma  [ lem : no crossing parent node child compression ] and lemma  [ lem : uncrossing children ] : @xmath607 makes sure that there are no crossing parent - leaf pairs and issues at most @xmath578 units of credit by lemma  [ lem : uncrossing children ] . then by lemma  [ lem : no crossing parent node child compression ] , @xmath538 ensures that @xmath610 .",
    "furthermore the credit of the new letters and the representation cost is covered by the credit released by @xmath538 .",
    "finally , both subprocedures preserve ( )  ( ) .    by lemma  [ lem :",
    "number of phases ] we apply at most @xmath20 many leaf compressions to @xmath129 . by ( )",
    " ( ) we have @xmath495 , @xmath496 and @xmath497 . hence , we get :    [ cor : credit child compression ] leaf compression issues in total at most @xmath498 units of credit during all modifications of @xmath30 .    from corollaries  [ cor : credit pair compression ] , [ cor : credit chain compression ] , and [ cor : credit child compression ] and the observation that the initial credit is @xmath611",
    "we get :    [ cor : credit all compressions ] the whole credit issued during all modifications of @xmath30 is in @xmath612 .      the issued credit is enough to pay the two units of credit for every letter introduced during popping , whereas the released credit covers the cost of representing the new letters introduced by @xmath205-compression and leaf compression .",
    "however , the released credit _ does not _ cover the cost of representation for letters created during chain compression .",
    "the appropriate analysis is presented in this section .",
    "the overall plan is as follows : firstly , we define a scheme of representing letters introduced by chain compression based on the grammar @xmath30 and the way @xmath30 is changed by ( the _ @xmath30-based representation _ ) .",
    "then , we show that for this scheme the representation cost is bounded by @xmath498 .",
    "lastly , it is proved that the actual representation cost for the letters introduced by chain compression during the run of ( the _ -based representation _ , which was defined in section  [ sec chain comp ] ) is smaller than the @xmath30-based one .",
    "hence , it is bounded by @xmath498 as well .",
    "the intuition is as follows : while @xmath30 can produce patterns of the form @xmath24 , which have exponential length in @xmath158 , most patterns of this form are obtained by concatenating explicit @xmath25-chains to a shorter pattern .",
    "in such a case the credit that is released from the explicit occurrences of @xmath25 can be used to pay for the representation cost .",
    "this does not apply when the new pattern is obtained by concatenating two patterns ( popped from nonterminals ) inside a rule .",
    "however , this can not happen too often : when patterns of length @xmath613 are compressed ( at the cost of @xmath614 , as @xmath615 for each @xmath616 ) , the size of the derived context in the input tree is at least @xmath617 , which is at most @xmath2 . thus @xmath618 ; this is formally shown later on .",
    "we create a new letter for each chain pattern from @xmath619 ( where @xmath25 is a unary symbol ) that is either popped from a right - hand side or is in a rule at the end of ( i.e. , after popping but before the actual replacement in ) .",
    "such a chain pattern is a _ power _ if it is obtained by concatenation of a popped suffix and a popped prefix inside a right - hand side ( and perhaps some other letters that were in the right - hand side before ) . for this to happen , in the rule @xmath620 ( or @xmath621 ) the popped suffix of @xmath414 and popped prefix of @xmath602 belong to @xmath619 for some unary letter @xmath25 , and furthermore @xmath622 .",
    "note that it might be that one ( or both ) of @xmath414 and @xmath602 are removed in the process and in such a case this power may be popped ( up or down ) from @xmath413 . for each chain pattern",
    "@xmath623 that is not a power we can identify another represented pattern @xmath516 ( where we allow @xmath624 here ) such that @xmath24 is obtained by concatenating explicit occurrences of @xmath25 from some right - hand side to @xmath516 .",
    "note that a chain pattern @xmath24 may be created in several different ways .",
    "for instance , a power @xmath24 may be also created in a right - hand side by concatenating explicit occurrences of @xmath25 to a shorter represented pattern @xmath516 .",
    "it is an arbitrary choice to declare @xmath24 a power in this case .",
    "similarly , a non - power @xmath24 may be created in several right - hand sides by concatenating occurrences of @xmath25 to shorter patterns . in this case , we arbitrarily fix one choice .",
    "we represent chain patterns as follows :    a.   for a chain pattern @xmath24 that is a power we represent @xmath26 using the binary expansion , which costs @xmath625 .",
    "b.   a chain pattern @xmath24 that is not a power is obtained by concatenating @xmath626 explicit occurrences of @xmath25 from a right - hand side to @xmath516 ( recall that we fixed some choice in this case ) . in this case",
    "we represent @xmath26 as @xmath627 .",
    "the representation cost is @xmath628 , which is covered by the @xmath629 units of credit released from the @xmath630 many explicit occurrences of @xmath25 .",
    "recall that the credit for occurrences of a fresh letter @xmath26 is covered by the issued credit , see lemma  [ lem : blocksc ] , hence the released credit is still available .",
    "we refer to the cost in ( a ) as the _ cost of representing a power_. as remarked above , the cost in ( b ) is covered by the released credit .",
    "the cost in ( a ) is redirected towards the rule in which this power was created .",
    "note that this needs to be a rule for a nonterminal from @xmath568 , as the right - hand side of the rule needs to have two nonterminals to generate a power and by ( ) the right - hand sides for nonterminals from @xmath425 have at most one nonterminal . in section  [ subsubsec : grammar based ]",
    "we show that the total cost redirected towards a rule during all modifications of @xmath30 is at most @xmath20 .",
    "hence , the total cost in ( b ) is @xmath631 .",
    "we now estimate the cost of representing the letters introduced during chain compression described in the previous section .",
    "the idea is that if a nonterminal @xmath413 produces powers of length @xmath632 , @xmath633 , ",
    ", @xmath634 ( which have total representation cost @xmath635 ) during all chain compression steps , then in the initial grammar , @xmath413 generates a subpattern of the input tree of size at least @xmath636 and so the total cost of representing powers is at most @xmath637 per nonterminal from @xmath568 .",
    "this is formalised in the lemma below .",
    "[ clm : cost from power to rule ] the total cost of representing powers charged towards a single rule for a nonterminal from @xmath568 is @xmath20 .",
    "we first bound the cost redirected towards a rule for @xmath527 .",
    "there are two cases : first , after the creation of a power in the rule @xmath620 one of the nonterminals @xmath414 or @xmath602 is removed from the grammar . but this happens at most once for the rule ( there is no way to reintroduce a nonterminal from @xmath435 to a rule ) and the cost of @xmath20 of representing the power can be charged to the rule .",
    "note that here the assumption that we consider @xmath527 is important : otherwise it could be that the second nonterminal in a right - hand side is removed and added several times , see the last sentence in the proof of lemma  [ lem : no crossing parent node child compression ] .",
    "the second and crucial case is when after the creation of a power both nonterminals remain in the rule .",
    "fix such a rule @xmath620 , where @xmath88 , @xmath65 , and @xmath107 are sequences of handles . since we create a power",
    ", there is a unary letter @xmath25 such that @xmath622 and @xmath444 ( respectively , @xmath447 ) has a suffix ( respectively , prefix ) from @xmath619 , see figure  [ fig : powers ] .",
    "the first nonterminal has an @xmath25-suffix , while the second one has an @xmath25-prefix , and the letters between them are all @xmath25 s . ]",
    "fix this rule and consider all such creations of powers performed in this rule during all modifications of @xmath30 .",
    "let the consecutive letters , whose chain patterns are compressed , be @xmath638 , @xmath639 ,  ,",
    "@xmath640 and their lengths @xmath632 , @xmath633 ,  , @xmath634 .",
    "let also @xmath641 be the letter that replaces the chain @xmath642 .",
    "note that @xmath643 does not need to be the letter that replaced @xmath644 , as there might have been some other compressions performed on the letter @xmath645 .",
    "then the cost of the representation charged towards this rule is bounded by @xmath646 as @xmath647 for each @xmath648 .",
    "define the _ weight _ @xmath649 of a letter @xmath25 as follows : in the input tree each letter has weight @xmath15 . when we replace @xmath162 by @xmath29 , set @xmath650 .",
    "similarly , when @xmath26 represents @xmath24 then set @xmath651 , and when @xmath176 represents @xmath87 with constant - labelled children @xmath652 , then set @xmath653 .",
    "the weight of a tree is defined as the sum of the weights of all node labels .",
    "it is easy to see that in this way @xmath654 is preserved during all modifications of the grammar @xmath30 .    for a rule @xmath620",
    "we say that the letters in handles from @xmath65 are _ between _ @xmath414 and @xmath602 .",
    "observe that as long as both @xmath414 and @xmath602 are in the rule , the maximal weight of letters between @xmath414 and @xmath602 can not decrease : popping letters and handles from @xmath414 and @xmath602 can not decrease this maximal weight , and the same is true for a compression step .",
    "moreover , there is no way to remove a letter that is between @xmath414 and @xmath602 or to change it into a nonterminal .    now , directly after the @xmath5-th chain compression the only letter between @xmath414 and @xmath602 is @xmath655 which has weight @xmath656 since it replaces @xmath644 . on the other hand ,",
    "right before the @xmath657-th chain compression the sequence between @xmath414 and @xmath602 is @xmath658 .",
    "since the maximal weight of a symbol between @xmath414 and @xmath602 can not decrease , we must have @xmath659 since @xmath660 it follows that @xmath661 .",
    "as @xmath662 we have @xmath663 therefore , the total cost @xmath664 , as estimated in  , is @xmath20 .",
    "it is left to describe the differences , when considering nonterminals from @xmath432 .",
    "there are two of them :    * when a power is created in a rule for a nonterminal @xmath563 , then the rule must contain two nonterminals , i.e. , it must be of the form @xmath665 for a unary symbol @xmath25 , and afterwards it is of the same form .",
    "in particular we do not have to consider the case when the second nonterminal @xmath602 is removed from the rule ( as @xmath602 is of rank @xmath35 , it can not be replaced with a chain ) .",
    "* instead of considering the letters between @xmath414 and @xmath602 , we consider letters that are _ below _ @xmath414 : in a rule @xmath621  or @xmath666 , these are the letters that are in handles in @xmath65 as well as the ending @xmath29 .    as before , as long as @xmath414 is in the rule , the maximal weight of letters that are below @xmath414 can only increase ( note that the rule for @xmath413 can switch between the forms @xmath621 and @xmath666 many times , but this does not affect the claim ) .",
    "considering the cost of creating powers : the representation of the power that is created in the phase when @xmath414 is removed costs at most @xmath20 and there is no way to bring a nonterminal from @xmath435 back to this rule .",
    "hence , this cost is paid once .",
    "so , it is enough to consider the cost of powers that were created when @xmath414 was still present in the rule .",
    "let as in the previous case the consecutive letters , whose chain patterns are compressed , be @xmath667 and let their lengths be @xmath613 .",
    "let also @xmath641 be the letter that replaces the chain @xmath642 .",
    "it is enough to show that @xmath668 as then the rest of the proof follows as in the case of a nonterminal from @xmath435 .",
    "after the @xmath5-th compression , the right - hand side of @xmath413 has the form @xmath669 . before the @xmath657-th compression , the right - hand side of @xmath413 has the form @xmath670 . by the earlier observation ,",
    "the maximal weight of letters below @xmath414 can only increase , hence @xmath668 as claimed .",
    "now , the whole cost of the @xmath30-based representation can be calculated :    [ coro : grammar - based cost ] the cost of the @xmath30-based representation is @xmath612 .",
    "concerning powers , we redirect to each nonterminal from @xmath568 a cost of @xmath20 by lemma  [ clm : cost from power to rule ] .",
    "there are at most @xmath671 such nonterminals , as we do not introduce new ones .",
    "so , the total representation cost for powers is @xmath672 . for non - powers",
    ", the representation cost is paid from the released credit .",
    "but the released credit is bounded by the credit assigned to the initial grammar @xmath30 , which is at most @xmath400 by lemma  [ lem : monadic grammar ] , plus the total issued credit during all modifications of @xmath30 , which is @xmath498 by corollary  [ cor : credit all compressions ] .",
    "we get the statement by summing all contributions .",
    "recall the -based representation from section  [ sec chain comp ] .",
    "we now show that the -based representation cost is bounded by the @xmath30-based representation cost ( note that both costs include the credit released by explicit letters ) .",
    "we first represent both representations by edge - weighted graphs such that the total cost of a representation is bounded ( up to a constant factor ) by the sum of all edge weights of the corresponding graph .",
    "then we show that we can transform the @xmath30-based graph into the @xmath673-based graph without increasing the sum of the edge weights . for an edge - weighted graph @xmath674",
    "let @xmath675 be the sum of all edge weights .",
    "let us start with the @xmath30-based representation .",
    "we define the graph @xmath676 as follows : each chain pattern that is represented in the @xmath30-based representation is a node of @xmath676 , and edges are defined as follows :    * a power @xmath24 has an edge with weight @xmath677 to @xmath678 .",
    "recall that the cost of representing this power is @xmath625 .",
    "* when @xmath26 is represented as @xmath679 ( @xmath680 ) , then node @xmath24 has an edge to @xmath516 of weight @xmath681 .",
    "the cost of representing @xmath26 is @xmath682 .    from the definition of this graph",
    "the following statement is obvious :    [ lem : representation cost ] the @xmath30-based representation cost is in @xmath683 .",
    "next let us define the graph @xmath684 of the @xmath673-based representation : the nodes of this graph are all chain patterns that are represented in the -based representation , and there is an edge of weight @xmath685 from @xmath24 to @xmath516 if and only if @xmath680 and there is no node @xmath686 with @xmath687 ( note that we may have @xmath688 ) .",
    "[ lem : algmain representation cost ] the -based cost of representing the letters introduced during chain compression is in @xmath689 .",
    "observe that this is a straightforward consequence of the way chain patterns are represented in section  [ sec chain comp ] : lemma  [ lem : cost of powers ] guarantees that if @xmath247 ( @xmath690 ) are all chain patterns of the form @xmath619 ( for a fixed unary letter @xmath25 ) that are represented by , then the -based representation cost for these patterns is @xmath691 , where @xmath692 .",
    "we now show that @xmath676 can be transformed into @xmath684 without increasing the sum of edge weights :    [ lem : transforming representations ] we have @xmath693 .",
    "we transform the graph @xmath676 into the graph @xmath684 without increasing the sum of edge weights .",
    "thereby we can fix a letter @xmath25 and consider only nodes of the form @xmath516 in @xmath676 and @xmath684 .",
    "we start with @xmath676 .",
    "firstly , let us sort the nodes from @xmath694 according to the increasing length .",
    "for each node @xmath24 with @xmath695 , we redirect its unique outgoing edge to its unique predecessor @xmath516 ( i.e. , @xmath696 and there is no node @xmath686 with @xmath687 ) , and assign the weight @xmath697 to this new edge .",
    "this can not increase the sum of edge weights :    * if @xmath24 has an edge of weight @xmath677 to @xmath698 in @xmath676 , then @xmath699 .",
    "* otherwise it has an edge to some @xmath519 ( @xmath700 ) with weight @xmath701 .",
    "then @xmath702 , as claimed ( note that @xmath703 for @xmath704 ) .",
    "let @xmath705 be the graph obtained from @xmath676 by this redirecting .",
    "note that @xmath705 is not necessarily @xmath684 , because @xmath676 may contain nodes that are not present in @xmath684 .",
    "in other words : there might exist a chain @xmath24 which occurs in the @xmath129-based representation but which does not occur in the -based representation .",
    "on the other hand , every node @xmath24 that occurs in @xmath684 also occurs in @xmath676 : if @xmath24 is represented by the -based representation , then it occurs as an @xmath25-maximal chain in @xmath1 .",
    "but right before chain compression , there are no crossing chains in @xmath30 , see lemma  [ lem : uncrossing chains ] .",
    "hence , @xmath24 occurs in some right - hand side of @xmath30 and is therefore represented by the @xmath30-based representation as well .",
    "so , assume that @xmath706 is an edge in @xmath684 but in @xmath705 we have edges @xmath707 , @xmath708 , where @xmath709 .",
    "but the sum of the weights of these edges in @xmath705 ( which is @xmath710 ) ) is larger or equal than the weight of @xmath706 in @xmath684 ( which is @xmath711 ) .",
    "this follows from @xmath712 when @xmath713 .    using ( in this order )",
    "lemmata  [ lem : algmain representation cost ] , [ lem : transforming representations ] , and [ lem : representation cost ] , followed by corollary  [ coro : grammar - based cost ] , we get :    [ cor : algmain representation ] the total cost of the -representation is @xmath612 .",
    "the total representation cost of the letters introduced by ( and hence the size of the grammar produced by ) is @xmath714 .    by corollary  [ cor : algmain representation ]",
    "the representation cost of letters introduced by chain compression is @xmath715 , while by lemmata  [ lem : pc crossing ] and  [ lem : representation cost child ] the representation cost of letters introduced by unary pair compression and leaf compression is covered by the initial credit ( which is @xmath409 by lemma  [ lem : monadic grammar ] ) plus the total amount of issued credit . by corollary  [ cor :",
    "credit all compressions ] the latter is @xmath612 . recalling that @xmath420 and @xmath421 by lemma  [ lem : monadic grammar ] ends the proof .",
    "the naive algorithm , which simply represents the input tree @xmath207 as @xmath716 results in a grammar of size @xmath2 . in some extreme cases",
    "this might be better than @xmath717 as guaranteed by .",
    "in fact , even a stronger fact holds : _ any _ ` reasonable ' grammar for a tree @xmath68 has size at most @xmath718 , where a grammar ( for @xmath68 ) is reasonable if    * it has no production of the form @xmath719 , where @xmath720 and * all its nonterminals are used in the derivation of @xmath68    ( recall that the size of @xmath721 does not include the parameters in it ) .",
    "[ lem : trivial estimation ] let @xmath30 contain no production @xmath719 with @xmath722 and assume that every production is used in the derivation of the tree @xmath68 defined by @xmath30 . then @xmath723 .",
    "in particular , if at any point already paid @xmath41 units of credit for the representation of the letters and the remaining tree is @xmath207 then for sure the final grammar for the input tree has size at most @xmath724    assume that @xmath30 has the properties from the lemma .",
    "an application of a rule @xmath417 to the current tree increases its size by @xmath725 for each occurrence of @xmath413 in the tree derived so far . as we assume that each production is used in the derivation ,",
    "each of @xmath725 is added at least once and so we get @xmath726 .",
    "thus @xmath727 and so it is left to estimate @xmath40 .",
    "as there are @xmath40 productions and each application increases the size by at least @xmath15 , and we start the derivation with a tree of size one , we get @xmath728 .",
    "thus @xmath729 .",
    "we show that when @xmath730 at a certain point , then up to this point @xmath731 units of credit are issued so far , where @xmath3 is the size of an optimal slcf grammar for the input tree .",
    "it follows that the size of the slcf grammar returned by is @xmath32 , as claimed in theorem  [ thm : main ] .",
    "let @xmath732 be the tree at the beginning of phase @xmath51 and choose phase @xmath51 such that @xmath733 ( for an input tree with at least @xmath734 symbols such an @xmath51 exists , as @xmath735 and for the ` last ' @xmath51 we have @xmath736 ; the easy special case in which @xmath737 follows directly from lemma  [ lem : trivial estimation ] ) .",
    "we estimate the representation cost ( i.e. , the issued credit and the cost of the @xmath673-based representation ) up to phase @xmath51 ( inclusively ) . we show that this cost is bounded by @xmath32 , which shows the full claim of theorem  [ thm : main ] .",
    "[ lem : cost of compression ] if @xmath738 at the beginning of a phase , then till the end of this phase , the representation cost of the fresh letters introduced by as well as the credit of the letters in the current slcf grammar @xmath30 is @xmath739 .",
    "we estimate separately the amount of issued credit and the representation cost for letters replacing chains .",
    "this covers the whole representation cost for fresh letters ( see lemmata  [ lem : pc crossing ] ,  [ lem : blocksc ] and  [ lem : representation cost child ] ) as well as the credit on the letters in the current slcf grammar .",
    "observe first that the initial grammar @xmath30 has at most @xmath740 credit , see lemma  [ lem : monadic grammar ] .",
    "the input tree has size @xmath2 and the one at the beginning of the phase is of size @xmath741 .",
    "hence , there were @xmath742 phases before , as in each phase the size of @xmath207 drops by a constant factor , see lemma  [ lem : number of phases ] .",
    "adding one phase for the current phase still yields @xmath742 phases . as @xmath743 , we obtain the upper bound @xmath744 on the number of phases . due to lemmata  [ lem : pc crossing ] ,  [ lem : blocksc ] and  [ lem : representation cost child ] , during unary pair compression , chain compression and leaf compression at most @xmath745 units of credit per phase",
    "are issued , and by lemma  [ lem : monadic grammar ] this is at most @xmath746 .",
    "so in total @xmath747 units of credit are issued . from lemmata  [",
    "lem : pc crossing ] ,  [ lem : blocksc ] and  [ lem : representation cost child ] we conclude that this credit is enough to cover the credit of all letters in @xmath30 s right - hand sides as well as the representation cost of letters introduced during unary pair compression and leaf compression .",
    "so it is left to calculate the cost of representing chains .",
    "observe that the analysis in section  [ subsec : chain cost ] did not assume anywhere that was carried out completely , i.e. , the final grammar was returned .",
    "so we can consider the cost of the @xmath30-based representation , the -based representation , and the corresponding graphs .",
    "lemma  [ lem : representation cost ] still applies and the cost of the @xmath129-based representation is @xmath683 . by lemma  [ lem : algmain representation cost ] the cost of the -based representation is @xmath748 .",
    "lemma  [ lem : transforming representations ] shows that we can transform @xmath676 to @xmath749 without increasing the sum of weights .",
    "hence it is enough to show that the @xmath30-based representation cost is at most @xmath747 .",
    "the @xmath30-based representation cost consists of some released credit and the cost of representing powers , see its definition .",
    "the former was already addressed ( the whole issued credit is @xmath747 ) and so it is enough to estimate the latter , i.e. , the cost of representing powers .    the outline of the analysis is as follows :",
    "when a new power @xmath24 is represented , we mark some letters of the input tree ( and perhaps modify some other markings ) .",
    "those markings are associated with nonterminals .",
    "formally , for a nonterminal @xmath750 we introduce the notions of an @xmath413-pre - power marking and @xmath413-in marking .",
    "such a marking is a subset of the node set of the initial tree ( note that we do not define such markings for a nonterminal @xmath437 ) .",
    "these marking satisfy the following conditions :    1 .   [ m1 ] each marking contains at least two nodes and two different markings are disjoint .",
    "[ m2 ] for every nonterminal @xmath413 and every @xmath751 there is at most on @xmath413-x marking .",
    "[ m3 ] if @xmath752 are the sizes of the markings ( i.e. , the cardinalities of the node sets ) , then the cost of representing powers ( created up to the current phase ) by the @xmath30-based representation is @xmath753 ( for some fixed constant c ) .",
    "note that in ( m[m3 ] ) we must have @xmath754 for some constant @xmath755 , because @xmath756 by lemma  [ lem : monadic grammar ] .    using ( )  ( ) the total cost of representing powers ( in the @xmath30-based representation ) can be upper - bounded by ( a constant times )    [ eq : estimations ] @xmath757 where @xmath755 is some constant .",
    "let us bound the sum @xmath758 under the above constraints : clearly , the second sum is maximized for @xmath759 .",
    "for a fixed @xmath41 and @xmath759 we have @xmath760 . by the inequality of arithmetic and geometric means",
    "we conclude that @xmath761 , where the maximum @xmath762 is achieved if each @xmath763 is equal to @xmath764 .",
    "now , the term @xmath762 is maximized for @xmath765 ( independently of the base of the logarithm ) . moreover , in the range @xmath766 the function @xmath767 is monotonically increasing . hence , if @xmath768 , then , indeed , the maximal value of @xmath758 under the constraints in   is in @xmath769    on the other hand , if @xmath770 , then @xmath771 and the bound in the statement of the lemma trivially holds .",
    "the idea of preserving  ( )  ( ) is as follows : if a new power of length @xmath42 is represented , this yields a cost of @xmath625 . since @xmath772",
    ", we can treat this cost as @xmath773 and choose @xmath29 in ( ) so that this is at most @xmath774 .",
    "then either we add a new marking of size @xmath42 or we remove some marking of size @xmath775 and add a new marking of size @xmath776 .",
    "it is easy to see that in this way  ( )  ( ) are preserved ( still , those details are repeated later in the proof ) .",
    "whenever we have to represent powers @xmath777 , for each power @xmath24 , where @xmath163 , we find the last ( according to preorder ) maximal chain pattern @xmath24 in the current tree @xmath1 .",
    "it is possible that this particular @xmath24 was obtained as a concatenation of @xmath681 explicit letters to @xmath516 ( so , not as a power ) .",
    "in such a case we are lucky , as the representation of this @xmath26 is paid by the credit and we do not need to separately consider the cost of representing the power @xmath24 . otherwise @xmath24 is a  power and we add a new marking which is contained in the subcontext of the input tree that is derived from the last occurrence of @xmath24 in the current tree . let @xmath413 be the smallest nonterminal that derives ( before ) this last occurrence of the maximal chain pattern @xmath24 ( clearly there is such non - terminal , as @xmath415 derives it ) .",
    "note that @xmath750 as otherwise this @xmath24 is not a  power , since powers can not be created inside nonterminals from @xmath425 .",
    "the new marking will be either an @xmath413-pre - power marking or an @xmath413-in marking : if one of the nonterminals in @xmath413 s right - hand side was removed during , then we add an @xmath413-pre - power marking ( note that such a removed nonterminal is necessarily from @xmath435 , as no nonterminal from @xmath778 is removed during ) . otherwise , we add an @xmath413-in marking .",
    "[ clm : markings ] at any time , there is at most one @xmath413-pre - power marking in the input tree .",
    "when an @xmath413-in marking is added because of a power @xmath24 , then after chain compression @xmath413 has a rule of the form    * @xmath779 , where @xmath107 and @xmath65 are ( perhaps empty ) sequences of handles and @xmath780 , if @xmath527 , or * @xmath781 where @xmath107 is a ( perhaps empty ) sequence of handles , @xmath600 , and @xmath782 , if @xmath563 .",
    "concerning @xmath413-pre - power markings , let @xmath24 be the first power that causes the creation of an @xmath413-pre - power marking .",
    "so one nonterminal from @xmath435 was removed from the right - hand side for @xmath413 and there is no way to reintroduce such a nonterminal .",
    "hence , @xmath413 s rule has at most one nonterminal from @xmath435 ( when @xmath527 ) or none at all ( when @xmath563 ) .",
    "thus , no more powers can be created in @xmath413 s right - hand side . in particular",
    ", neither @xmath413-pre - power markings nor @xmath413-in markings will be added in the future .",
    "next , suppose that an @xmath413-in marking is added to the input tree because a new power @xmath24 is created .",
    "thus , the last occurrence of the maximal chain pattern @xmath24 is generated by @xmath413 but not by the nonterminals in the rule for @xmath413 ( as then , a different marking would be introduced ) .",
    "since @xmath24 is a  power it is obtained in the rule as the concatenation of an @xmath25-prefix and an @xmath25-suffix popped from nonterminals in the rule for @xmath413 .",
    "the suffix needs to come from a nonterminal of rank @xmath15 . in particular",
    "this means that those two nonterminals in the rule for @xmath413 generate parts of this last occurrence of @xmath24 and in between them only the letter @xmath25 occurs .",
    "if any of those nonterminals would be removed during the chain compression for @xmath24 , then an @xmath413-pre - power marking would be introduced , which is not the case .",
    "so both nonterminals remain in the rule for @xmath413 . hence after popping prefixes and suffixes , between those two nonterminals there is exactly a chain pattern @xmath24 , which is then replaced by @xmath26 .",
    "this yields the desired form of the rule , both in case @xmath563 or @xmath527 .",
    "consider the occurrence of @xmath24 and the ` derived ' subcontext @xmath783 of the _ input tree_. we show that if there exists a marking inside @xmath783 , then this marking is contained in the last occurrence of @xmath107 inside the occurrence of @xmath783 .",
    "[ clm : existing marking ] let @xmath24 be an occurrence of a maximal chain pattern , which is replaced by @xmath26 .",
    "assume that @xmath26 derives the subcontext @xmath783 of the input tree , where @xmath107 is a context .",
    "if this occurrence of @xmath783 contains a marking , then this marking is contained in the last occurrence of @xmath107 inside the occurrence of @xmath783 .",
    "consider a marking @xmath784 within @xmath783 .",
    "assume it was created , when some @xmath785 was replaced by @xmath786 .",
    "as @xmath786 is a single letter and @xmath24 derives it , each @xmath25 derives at least one @xmath786 .",
    "then , the marking @xmath784 must be contained in the subcontext derived from the last @xmath786 ( as we always create markings within the last occurrence of the chain pattern to be replaced ) .",
    "clearly the last @xmath786 can be only derived from the last @xmath25 within @xmath24 .",
    "so in particular , the marking @xmath784 is contained in the last @xmath107 inside @xmath783 .",
    "so all markings within @xmath783 are in fact within the last @xmath107 .",
    "we now demonstrate how to add markings to the input tree .",
    "suppose that we replace a power @xmath24 .",
    "note that we must have @xmath772 .",
    "let us consider the last occurrence of this @xmath24 in the current tree @xmath207 and the smallest @xmath413 that generates this occurrence .",
    "this @xmath24 generates some occurrence of @xmath783 ( for some context @xmath107 ) in the input tree .",
    "if this occurrence of @xmath783 contains no marking , then we simply add a marking ( either an @xmath413-pre - power or an @xmath413-in marking according to the above rule ) consisting of @xmath772 arbitrarily chosen nodes within @xmath783 . in the other case , by claim  [ clm : existing marking ] , we know that all markings within the occurrence of @xmath783 are contained in the last @xmath107 .",
    "if one of them is the ( unique , by ( ) ) @xmath413-in marking , let us choose it .",
    "otherwise choose any other marking in the last @xmath107 .",
    "let @xmath784 be the chosen marking and let @xmath787 .",
    "we proceed , depending on whether @xmath784 is the only marking in the last @xmath107 :    * @xmath784 is the unique marking in the last @xmath107 : then we remove it and mark arbitrarily chosen @xmath776 nodes in @xmath783 .",
    "this is possible , as @xmath788 and so @xmath789 . since @xmath790 , ( )",
    "is preserved , as it is enough to account for the @xmath791 representation cost for @xmath24 as well as the @xmath792 cost associated with the previous marking of size @xmath775 .",
    "* @xmath784 is not the unique marking in the last @xmath107 : then @xmath793 ( the ` @xmath794 ' comes from the other markings , which are of size at least @xmath100 , see  ( ) ) .",
    "we first remove the chosen marking of size @xmath775 .",
    "let us calculate how many unmarked nodes are in @xmath783 afterwards : in @xmath795 there are at least @xmath796 nodes and by claim  [ clm : existing marking ] none of them belongs to a marking .",
    "in the last @xmath107 there are at least @xmath775 unmarked nodes ( from the marking that we removed ) .",
    "hence , in total we have @xmath797 many unmarked nodes ( recall that @xmath772 ) .",
    "we arbitrarily choose @xmath776 many unmarked nodes and add them as a new marking . by the same argument as in the previous case , ( ) is preserved .    by the above construction , ( )",
    "is preserved .",
    "there is one remaining issue concerning  ( ): it might be that we create an @xmath413-in marking while there already was one , violating  ( ) .",
    "however , we show that if there already exists an @xmath413-in marking , then it is within @xmath783 ( and so within the last @xmath107 , by claim  [ clm : existing marking ] ) .",
    "hence , we could choose this @xmath413-in marking as the one that is removed when the new one is created .",
    "consider the previous @xmath413-in marking .",
    "it was introduced when some power @xmath785 was replaced by @xmath798 , which , by claim  [ clm : markings ] , became the unique letter between the first and second nonterminal in the right - hand side for @xmath413 .",
    "consider the last ( as usual , with respect to preorder ) subpattern of the input tree that is either generated by the explicit letters between nonterminals of rank @xmath15 in the rule for @xmath413 ( when @xmath527 ) or is generated by the explicit letters below the nonterminals of rank @xmath15 ( when @xmath563 ) ( recall from the proof of lemma  [ clm : cost from power to rule ] that in a rule @xmath799 for a nonterminal of rank @xmath35 , where @xmath107 and @xmath65 are sequences of handles , all letters occurring in handles in @xmath65 are classified as being _ below _",
    "@xmath414 ) .",
    "the operations performed on @xmath30 can not make this subpattern smaller , in fact popping letters expands it .",
    "when @xmath786 is created , then this subpattern is generated by @xmath786 , as by claim  [ clm : markings ] this is the unique letter between the nonterminals ( resp .",
    ", below the nonterminal ) .",
    "when @xmath26 is created , it is generated by @xmath26 , again by claim  [ clm : markings ] , i.e. , it is exactly @xmath783 .",
    "so in particular @xmath783 includes the @xmath413-in marking that was added when the power @xmath785 was replaced by @xmath798 .",
    "this shows that ( )  ( ) hold and so also the calculations in   hold , in particular , the representation cost of powers is @xmath800 .",
    "now the estimations from lemma  [ lem : cost of compression ] allow to prove theorem  [ thm : main ] .",
    "suppose first that the input tree @xmath1 has size smaller than @xmath734",
    ". then by lemma  [ lem : trivial estimation ] , returns a tree of size at most @xmath801 .",
    "otherwise , consider the phase , such that before it @xmath1 has size @xmath802 and right after it has size is @xmath803 , where @xmath804 .",
    "there is such a phase as in the end @xmath1 has size @xmath15 and initially it has size at least @xmath734 .",
    "then by lemma  [ lem : cost of compression ] the cost of representing letters introduced till the end of this phase is @xmath805 . by lemma  [ lem : trivial estimation ]",
    "the cost of representing the remaining tree is at most @xmath801 .",
    "hence , the size of the grammar that is returned by is at most @xmath805 .",
    "the first author would like to thank pawe gawrychowski for introducing him to the topic of compressed data , for pointing out the relevant literature  @xcite and discussions , as well as sebatian maneth and stefan bttcher for the question of applicability of the recompression - based approach to the tree case .",
    "10    tatsuya akutsu .",
    "a bisection algorithm for grammar - based compression of ordered trees .",
    ", 110(18 - 19):815820 , 2010 .",
    "philip bille , inge  li grtz , gad  m. landau , and oren weimann .",
    "tree compression with top trees . in fedor",
    "v. fomin , rusins freivalds , marta  z. kwiatkowska , and david peleg , editors , _ icalp ( 1 ) _ , volume 7965 of _ lecture notes in computer science _ , pages 160171 .",
    "springer , 2013 .",
    "giorgio busatto , markus lohrey , and sebastian maneth .",
    "efficient memory representation of xml document trees .",
    ", 33(45):456474 , 2008 .",
    "moses charikar , eric lehman , ding liu , rina panigrahy , manoj prabhakaran , amit sahai , and abhi shelat .",
    "the smallest grammar problem .",
    "51(7):25542576 , 2005 .    francisco claude and gonzalo navarro .",
    "fast and compact web graph representations . , 4(4 ) , 2010 .",
    "thomas  h. cormen , charles  e. leiserson , ronald  l. rivest , and clifford stein .",
    ". mit press , 2009 .",
    "volker diekert , artur jez , and wojciech plandowski .",
    "finding all solutions of equations in free groups and monoids with involution . in edward",
    "a. hirsch , sergei  o. kuznetsov , jean - ric pin , and nikolay  k. vereshchagin , editors , _ csr _ , lncs , pages 115 .",
    "springer , 2014 .",
    "adria gascn , guillem godoy , and manfred schmidt - schau .",
    "unification and matching on compressed terms .",
    ", 12(4):26 , 2011 .",
    "artur je .",
    "compressed membership for nfa ( dfa ) with compressed labels is in np ( p ) . in christoph drr and thomas wilke , editors ,",
    "_ stacs _ , volume  14 of _ lipics _ , pages 136147 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik , 2012 .",
    "artur je .",
    "approximation of grammar - based compression via recompression . in johannes fischer and peter sanders , editors , _",
    "cpm _ , volume 7922 of _ lncs _ , pages 165176 .",
    "springer , 2013 .",
    "full version at http://arxiv.org/abs/1301.5842 .",
    "artur je . .",
    "in natacha portier and thomas wilke , editors , _ stacs _ , volume  20 of _ lipics _ , pages 233244 , dagstuhl , germany , 2013 .",
    " leibniz - zentrum fuer informatik .",
    "artur je .",
    "context unification is in pspace . in javier esparza , pierre fraigniaud , thore husfeldt , and elias koutsoupias , editors , _ icalp ( 2 ) _ ,",
    "volume 8573 of _ lncs _ , pages 244255 .",
    "springer , 2014 .",
    "full version at http://arxiv.org/abs/1310.4367 .",
    "artur je .",
    "a _ really _ simple approximation of smallest grammar . in _",
    "cpm _ , volume 8486 of _ lncs _ , pages 182191 .",
    "springer , 2014 .",
    "full version at http://arxiv.org/abs/1310.4367 .",
    "artur je .",
    "faster fully compressed pattern matching by recompression . , 2014 .",
    "accepted .",
    "artur je .",
    "one - variable word equations in linear time . , 2014 .",
    "accepted and available online .",
    "john  c. kieffer and en - hui yang .",
    "sequential codes , lossless compression of individual sequences , and kolmogorov complexity . , 42(1):2939 , 1996 .    n.  jesper larsson and alistair moffat .",
    "offline dictionary - based compression . in james  a. storer and martin cohn , editors ,",
    "_ data compression conference _ , pages 296305 .",
    "ieee computer society , 1999 .",
    "markus lohrey .",
    "algorithmics on slp - compressed strings : a survey . , 4(2):241299 , 2012 .",
    "markus lohrey and sebastian maneth .",
    "the complexity of tree automata and xpath on grammar - compressed trees .",
    ", 363(2):196210 , 2006 .",
    "markus lohrey , sebastian maneth , and roy mennicke .",
    "tree structure compression using repair .",
    ", 38(8):11501167 , 2013 .",
    "markus lohrey , sebastian maneth , and eric noeth .",
    "xml compression via dags . in wang - chiew tan , giovanna guerrini , barbara catania , and anastasios gounaris , editors , _ icdt _ , pages 6980 .",
    "acm , 2013 .",
    "markus lohrey , sebastian maneth , and manfred schmidt - schau .",
    "parameter reduction and automata evaluation for grammar - compressed trees .",
    ", 78(5):16511669 , 2012 .",
    "kurt mehlhorn , r.  sundar , and christian uhrig .",
    "maintaining dynamic sequences under equality tests in polylogarithmic time .",
    ", 17(2):183198 , 1997 .",
    "gary  l. miller and john  h. reif .",
    "parallel tree contraction part 1 : fundamentals . in silvio micali , editor , _ randomness and computation _ , volume  5 , pages 4772 .",
    "jai press , greenwich , connecticut , 1989 .",
    "gary  l. miller and john  h. reif .",
    "parallel tree contraction , part 2 : further applications .",
    ", 20(6):11281147 , 1991 .",
    "michael mitzenmacher and eli upfal . .",
    "cambridge university press , 2005 .",
    "craig  g. nevill - manning and ian  h. witten .",
    "identifying hierarchical strcture in sequences : a linear - time algorithm .",
    ", 7:6782 , 1997 .    .",
    "problem  90 .",
    "http://rtaloop.mancoosi.univ-paris-diderot.fr/problems/90.html .",
    "wojciech rytter .",
    "application of lempel - ziv factorization to the approximation of grammar - based compression .",
    ", 302(1 - 3):211222 , 2003 .",
    "hiroshi sakamoto .",
    "a fully linear - time approximation algorithm for grammar - based compression .",
    ", 3(2 - 4):416430 , 2005 .    manfred schmidt - schau .",
    "matching of compressed patterns with character - variables . in ashish tiwari , editor ,",
    "_ rta _ , volume  15 of _ lipics _ , pages 272287 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik , 2012 .    manfred schmidt - schau , david sabel , and altug anis .",
    "congruence closure of compressed terms in polynomial time . in cesare tinelli and viorica sofronie - stokkermans , editors ,",
    "_ frocos _ , volume 6989 of _ lecture notes in computer science _ , pages 227242 .",
    "springer , 2011 .",
    "james  a. storer and thomas  g. szymanski . the macro model for data compression . in richard",
    "j. lipton , walter  a. burkhard , walter  j. savitch , emily  p. friedman , and alfred  v. aho , editors , _ stoc _ , pages 3039 .",
    "acm , 1978 .",
    "imagine we want to sort sequences @xmath806 of lengths @xmath45 from an alphabet @xmath44 $ ] lexicographically , see figure  [ fig : sorting ] .",
    "let @xmath807 , @xmath808 , and @xmath809 .",
    "standard uses time @xmath810 , see e.g. ( * ? ? ?",
    "* section  8.3 ) .",
    "we want to reduce the running time to @xmath811 .",
    "the problem with is that on each position @xmath812 it checks buckets for each possible value in @xmath44 $ ] . to avoid this , we first create for each position @xmath813",
    "$ ] a list @xmath814 $ ] which is a sorted list of all digits @xmath815 $ ] that occur on position @xmath139 in any of the sequences @xmath806 .",
    "this is easily done by creating a pair @xmath816 for each @xmath418 and @xmath817 in time @xmath818 .",
    "then we sort these @xmath819 many pairs using simple in time @xmath820 .",
    "additionally , we create for each position @xmath173 a list @xmath821 $ ] of last elements of strings that have length exactly @xmath139 together with the index @xmath51 , i.e. , ( as a set ) @xmath821 = \\{(a_{i , j},i )   \\mid 1 \\leq i \\leq m , \\ell_i = j \\}$ ] , see figure  [ fig : sorting ] .",
    "note that no sorting is needed , it is enough to go trough @xmath806 in time @xmath818 .",
    "now in round @xmath822 we keep a list of letters on position @xmath139 , i.e. , @xmath823 sorted according to the lexicographic order on suffixes of @xmath806 starting at position @xmath139 . to update the list when going from @xmath824 to @xmath139 we need to change each pair @xmath825 to @xmath826 and append the list @xmath821 $ ] at the beginning and then stably sort them using , which sorts a list of @xmath40 number from the interval @xmath44 $ ] in time @xmath827 ) , see  ( * ? ? ?",
    "* section  8.2 ) .",
    "however , using the list @xmath814 $ ] we only need to inspect the digits that actually occur in our list , so the running time of in the @xmath139-th phase can be reduced to @xmath828|+|\\ { i \\mid 1 \\leq i \\leq m , j",
    "\\leq \\ell_i \\}|)$ ] .",
    "summing over all @xmath139 yields a running time of @xmath818 and hence in total @xmath811 .",
    "[ [ proof - of - lemmalem - monadic - grammar - transforming - slcf - grammars - into - handle - grammar . ] ] proof of lemma  [ lem : monadic grammar ] ( transforming slcf grammars into handle grammar ) .",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      the idea is as follows , see figure  [ fig : preskeleton ] . consider a nonterminal @xmath829 of @xmath30 and the tree @xmath152 that it generates . within @xmath152",
    "take the nodes representing the parameters @xmath830 and the spanning tree ( within @xmath152 ) for those nodes .",
    "consider the nodes of degree at least @xmath100 within this spanning tree , delete those nodes and delete the parameters .",
    "what is left is a collection of subtrees and subcontexts .",
    "we want to construct a grammar that has for each such subtree and subcontext a nonterminal generating it .",
    "this is done inductively on the structure of @xmath30 . as the starting nonterminal of @xmath30 has rank @xmath35 ,",
    "such a decomposition for @xmath419 is in fact trivial .",
    "so , in particular the constructed grammar generates @xmath419 .",
    "lastly , the construction will guarantee that the introduced nonterminals , which are of rank @xmath35 and @xmath15 , are expressed through each other ( plus some rules introduced on the way ) .",
    "so the new grammar generates the same tree and it is monadic .",
    "moreover , the rules for those nonterminals will be in the form required for a handle grammar , see ( ) and ( ) .      1 .",
    "[ sk 1 ] the child of a node of degree @xmath15 can be labelled only with a letter of arity at least @xmath100 .",
    "[ sk 2 ] if @xmath87 of arity at least @xmath100 labels a node with children @xmath832 , then there are @xmath53 such that the subtrees rooted in @xmath334 and @xmath833 both contain parameters .",
    "intuitively , the skeleton tree is what one obtains after replacing each context and tree in the tree constructed above with a nonterminal : ( ) says that whole context is replaced with a nonterminal , while ( ) says that only branching nodes of the spanning tree of parameters are be labelled with letters .",
    "our first goal is to construct for each nonterminal @xmath124 of the input grammar @xmath30 a skeleton tree @xmath834 together with rules for the nonterminals appearing in @xmath834 .",
    "these rules will allow to rewrite @xmath834 into @xmath152 .",
    "we show that in the introduced rules the nonterminals of arity @xmath15 occur at most @xmath401 times , while nonterminals of arity @xmath35 and letters occur at most @xmath400 times .    as a first step",
    ", we transform the grammar into _ chomsky normal form _ ( cnf ) , which is obtained by a straightforward decomposition of rules .",
    "the rules in a cnf grammar are of two possible forms , where @xmath835 and @xmath836 :      note that the number of parameters can be @xmath35 .",
    "it is routine to check that any slcf grammar @xmath30 of size @xmath17 can be transformed into an equivalent cnf grammar of size @xmath401 and with @xmath401 nonterminals  ( * ? ? ? * theorem 5 ) .    given an slcf grammar in cnf , we build bottom - up skeleton trees for its nonterminals , during this we introduce @xmath38 nonterminals per considered nonterminal , their rules have @xmath38 occurrences of nonterminals of arity @xmath15 and at most @xmath373 occurrences of nonterminals of arity @xmath35 and constants .",
    "moreover , the rules for those nonterminals are in the form required by the definition of a handle grammar , see ( ) and  ( ) . all nonterminals occurring in the constructed skeletons use only those introduced nonterminals .    .",
    "on the left - most figure we see the two skeletons . after substituting ,",
    "there are two neighbouring rank-@xmath15 nonterminals : @xmath839 and @xmath840 .",
    "they are replaced with the nonterminal @xmath841 . ]",
    "consider some nonterminal @xmath124 of the cnf grammar .",
    "if its rule has the form @xmath837 , then @xmath842 and if the arity of @xmath124 is at most @xmath15 then we add @xmath124 and its rule to the set of constructed rules as well ( if the rank of @xmath124 is at least @xmath100 , then we do not add @xmath124 and its rule ) .",
    "this rule has the desired form  ( ) or ( ) , there is no nonterminal on the right - hand side and at most @xmath15 letter on the right - hand side .",
    "if the rule for @xmath124 has the form @xmath838 , then we take @xmath843 and @xmath844 and replace in @xmath843 the parameter @xmath845 by @xmath844 , see figures  [ fig : rank1 ] and  [ fig : rank0 ] for two different cases .",
    "let us denote the resulting tree with @xmath846 ; it will be transformed into a proper skeleton tree @xmath834 in the following .",
    "let @xmath847 .",
    "let us inspect what changes are needed , so that @xmath846 satisfies ( )  ( ) .",
    "suppose first that @xmath387 is of arity at least @xmath15 , see figure  [ fig : rank1 ] .",
    "it might be that the root node of @xmath844 and the node above the leaf @xmath83 in @xmath843 are both of arity @xmath15 , without loss of generality assume that their labels are nonterminals @xmath848 and @xmath849 ( the case of letters follows in the same way ) .",
    "we then introduce a new nonterminal @xmath850 of rank @xmath15 and replace the subpattern @xmath851 in @xmath846 with @xmath850 and add a rule @xmath852 .",
    "note that it is in a form required by  ( ) .",
    "we claim that the resulting tree satisfies ( ) and ( ) and hence can be taken for @xmath834 .",
    "since the node above @xmath849 and the node below @xmath848 are not of degree @xmath15 ( by induction assumption on ( ) ) , ( ) is satisfied . concerning  ( ) , take any node of arity at most @xmath100 in @xmath846 .",
    "any node labelled with a letter in @xmath844 has the same subtrees in @xmath844 and in @xmath846 , so ( ) holds for them .",
    "for the nodes in @xmath843 the only problem can arise for nodes that had the replaced @xmath83 in some of their subtrees .",
    "however , as @xmath83 is replaced with @xmath844 , which has a parameter , the condition is preserved for them .    , going from the left - top to bottom - right . in the first picture",
    "there are two skeletons , in the second they are substituted into each other . in the third we replace @xmath853 by @xmath854 with the rule @xmath855 . in the fourth we replace @xmath856 by @xmath841 with the rule @xmath857 and",
    "finally we replace @xmath858 by @xmath859 with the rule @xmath860 , which can be split into two rules . ]",
    "suppose now that @xmath387 is of arity @xmath35 , see figure  [ fig : rank0 ] .",
    "then the skeleton @xmath844 has no parameters , which implies that it is either a constant or a nonterminal of arity @xmath35 ( @xmath844 can not use letters of arity larger than @xmath15 by  ( ) , and can not use nonterminals and letters of arity @xmath15 , as their children need to be labelled with letters of arity at least @xmath100 ) .",
    "we only consider the former case ( the same argument hold for the latter case ) .",
    "let @xmath844 be the constant @xmath29 .",
    "firstly , the node above @xmath83 ( the parameter which is replaced by @xmath861 ) in @xmath843 can be a node of arity @xmath15 . without loss of generality suppose that it is a nonterminal @xmath849 ( the case of unary letter follows in the same way ) . we introduce a fresh nonterminal @xmath850 of arity @xmath35 ,",
    "replace the subtree @xmath862 by @xmath850 and introduce the rule @xmath863 .",
    "the rule is of the form required by  ( ) . for uniformity ,",
    "if the node above @xmath83 is not of arity @xmath15 , introduce @xmath850 with the rule @xmath864 and replace @xmath29 by @xmath850 . condition ( )",
    "now holds .    concerning  ( ) ,",
    "consider the parent node @xmath65 of @xmath850 .",
    "either it does not exist , in which case we are done ( as @xmath865 ) or it is labelled with a letter @xmath87 of arity at least @xmath100 .",
    "all other nodes in @xmath846 labelled with letters of arity at least @xmath100 satisfy  ( ) , as the subtree rooted at @xmath65 still contains at least one parameter . focusing on the @xmath87-labelled node @xmath65 , if it still has at least two children with parameters in their subtrees , then we are done , as ( ) is satisfied for @xmath65 .",
    "if not , then exactly one of @xmath65 s children is a subtree with a parameter . without loss of generality let it be @xmath65 s first child , all other children are constants or nonterminals of arity @xmath35 .",
    "so let the children of @xmath65 ( except for the first one ) be labelled with @xmath866 , where each @xmath867 is either a constant or a nonterminal of rank @xmath35 .",
    "introduce a new nonterminal @xmath850 of rank @xmath15 with the rule @xmath868 and replace the subpattern @xmath869 with @xmath870 ( where , @xmath871 is the subtree rooted at the first child of @xmath65 ) .",
    "observe that the rule for @xmath850 is of size @xmath872 and is of the form  ( ) .",
    "lastly , now again  ( ) can be violated , because the parent node or the child ( or both ) of the @xmath850-labelled node can be of degree @xmath15 .",
    "this can be fixed by replacing those @xmath100 or @xmath873 nodes of degree @xmath15 by one nonterminal of rank @xmath15 .",
    "this requires adding at most @xmath100 rules for nonterminals of arity @xmath15 of the required form  ( ) .",
    "we constructed @xmath38 rules of the form  ( ) or  ( ) per nonterminal of the cnf grammar ( there are @xmath874 of them ) , each of them has at most @xmath4 occurrences of letters and nonterminals of arity @xmath35 and at most @xmath100 of nonterminals of arity @xmath15 . by a routine calculation",
    "it can be shown that @xmath875 .",
    "if @xmath143 is the start nonterminal of the cnf grammar , then @xmath876 has no parameters and hence is either a constant ( this case is of course trivial ) or a nonterminal of rank @xmath35 , which is the start nonterminal of our output grammar .",
    "concerning the efficiency of the construction , the proof follows in the same way as in ( * ? ? ?",
    "* theorem  10 ) : it is enough to observe that @xmath834 , where @xmath124 has rank @xmath41 , has at most @xmath877 nodes : by ( ) nodes of arity @xmath15 constitute at most half of all nodes .",
    "secondly , as it has @xmath41 parameters , it has at most @xmath878 nodes of arity larger than @xmath15 , so at most @xmath879 leaves .",
    "summing up yields the claim ."
  ],
  "abstract_text": [
    "<S> a simple linear - time algorithm for constructing a linear context - free tree grammar of size @xmath0 for a given input tree @xmath1 of size @xmath2 is presented , where @xmath3 is the size of a minimal linear context - free tree grammar for @xmath1 , and @xmath4 is the maximal rank of symbols in @xmath1 ( which is a constant in many applications ) . </S>",
    "<S> this is the first example of a grammar - based tree compression algorithm with a good approximation ratio . </S>",
    "<S> the analysis of the algorithm uses an extension of the recompression technique ( used in the context of grammar - based string compression ) from strings to trees . </S>"
  ]
}