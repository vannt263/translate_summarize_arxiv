{
  "article_text": [
    "the asc / flash center at the university of chicago has developed a public domain astrophysics application code , flash  @xcite .",
    "flash is component - based , parallel , and portable , and has a proven ability to scale to tens of thousands of processors .",
    "the flash code was developed under contract with the department of energy asc / alliance program .",
    "it is available to external users through a cost - free licensing agreement .",
    "approved users may download the source code and make local modifications , but may not redistribute the code .",
    "flash is the flagship computer science product of the flash center , resulting from over 10 years of research and development .",
    "one of the mandates of the flash center was the delivery of a parallel , scalable , and highly - capable community code for astrophysics .",
    "motivation for the code effort lay in the increasing complexity of astrophysical simulations .",
    "the traditional academic approach of developing numerical software in piecemeal was deemed inadequate to meet the science needs .",
    "another aim of the flash center was to shift the paradigm of theoretical research towards working in multidisciplinary teams with scientific codes that are developed with modern software practices prevalent in the commercial world .",
    "the flash code has now reached a level of maturity where it has a large number of users , more than 80% external to the university of chicago . moreover",
    ", it also has a substantial number of external code contributors .",
    "the number of requests for download , and the number of publications using the flash code , have grown superlinearly in recent years ( see section  [ sec : usersurvey ] ) .",
    "this success was achieved by carefully balancing the often conflicting requirements of physics , software engineering , portability , and performance .    from its inception",
    ", flash has simultaneously been in development and in production mode .",
    "its evolution into a modern component - based code has taken a path very different from that of most scientific computing frameworks such as chombo , samrai , cactus , and pooma @xcite .",
    "those efforts developed the framework first , followed by the addition of solvers and other capabilities .",
    "an alternative path taken by scientific application codes such as enzo , swmf , and athena @xcite is to grow into a large application from smaller solvers and applications .",
    "both models of development have their advantages and disadvantages : codes initialized with frameworks have superior modularity and maintainability , while codes begun with solvers generally deliver better performance for their target applications .",
    "flash straddles both approaches .    in the first released version ,",
    "the development followed the solvers - first model , but later versions place more emphasis on modularity , maintainability , and extensibility .",
    "the outcome of this duality in development is that flash has more capabilities and customizability , and it reaches a much wider community than most scientific application codes .",
    "flash has gained wide usage because the capabilities of the code have been driven by physics , while its architecture is driven by extensibility and maintainability .",
    "the addition of new solvers to flash is almost always dictated by the needs of users applications .",
    "the solvers for multiphysics applications tend to put severe strain on any modern object - oriented software design .",
    "lateral data movement is normally required between different solvers and functional units , which makes resolving data ownership and maintaining encapsulation especially challenging .",
    "also , many of the core physics solvers are legacy third - party software written in fortran , which are rarely modular . while modularity , flexibility , and extensibility are some of the primary guiding principles in the code architecture design , these goals often conflict with the equally important considerations of efficiency and performance .",
    "additionally , since high performance platforms usually have a relatively short lifespan , the need for performance portability places even more constraints on the design process . achieving a balance between these conflicting goals while retaining the very complex multiphysics capabilities has been the biggest contributor to the widespread acceptance of the flash code .",
    "the flash model of development and architecture is informed by the literature from the common component architecture effort @xcite . since the project s inception",
    ", flash has undergone two major revisions , both of which included significant architectural and capabilities improvements .",
    "flash has always striven for a component - based architecture , but this goal was not realized in the first version because of a strong emphasis on producing early scientific results using legacy codes .",
    "however , foundations for a component - based architecture were firmly laid in the first version flash1.6 @xcite by providing wrappers on all the solvers and minimizing lateral communication between different solvers .",
    "the second generation versions , flash2.0 ",
    "flash2.5 , built upon this foundation by addressing data ownership and access , resulting in a centralized data management approach .",
    "finally , the current version , flash3 , has realized a true component - based architecture with decentralized data management , clean interfaces , and encapsulation of functional units .",
    "flash3also has well - defined rules for inheritance within a unit and for interactions such as data communication between units .",
    "further discussion of architecture changes over revisions is provided in @xcite .",
    "this latest release contains over 380,000 lines of code , with over 138,000 additional lines of comments .",
    "the core of the flash code is written in fortran90 , with input / output interfaces provided in c. initially fortran was chosen because the legacy computational kernels were written in fortran , whose interoperability with object - oriented languages can be memory inefficient and unportable .",
    "in addition , experience with system software limitations on various supercomputers demonstrated the wisdom of avoiding complex features such as dynamic linking in the build process .",
    "the choice of fortran does affect the architecture : instead of depending upon the programming language to enforce modular implementation , flash must rely upon a combination of the unix directory structure and several scripts to maintain modularity ( see figure  [ fig : units ] ) .",
    "however , lack of strong checking by the language can also be advantageous because it discourages complexity in the design .",
    "in addition , the `` primitive '' features of fortran allow developers to sometimes accelerate debugging by temporarily bypassing the architecture to give direct access to data structures .",
    "more than 35 developers and researchers have contributed to all versions of the flash code . during the past 10 years , over 80 person - years of effort",
    "have built the code and its scientific algorithms .",
    "as the complexity of the code and the number of developers have grown , code verification and management of the software development process have become increasingly important to the success of the project .",
    "the flash3distribution now includes a unit test framework and its own test - suite , called flashtest , which can be used for professional regression testing .    in this paper",
    "we describe the flash3architecture , with emphasis on solutions to the more challenging conflicts arising from solver complexity , portable performance requirements , and legacy codes .",
    "we also include results from user surveys conducted in 2005 and 2007 , indicating how the architecture choices have led to the widespread acceptance of the flash code .",
    "flash is not a monolithic application code ; instead , it should be viewed as a collection of components that are selectively grouped to form various applications .",
    "users specify which components should be included in a simulation , define a rough discretization / parallelization layout , and assign their own initial conditions , boundary conditions , and problem setup to create a unique application executable . in flash terminology , a component that implements an exclusive portion of the code s functionality",
    "is called a _",
    "unit_. a typical flash simulation requires a proper subset of the units available in the code .",
    "thus , it is important to distinguish between the entire flash source code and a given flash application .",
    "the flash architecture is defined by four cornerstones : unit , configuration layer , data management , and interaction between units . here",
    "we describe the four cornerstones briefly .",
    "a flash unit provides well - defined functionality and conforms to a structure that facilitates its interactions with other units .",
    "a unit can have interchangeable implementations of varying complexity , as well as subunits that provide subsets of the unit s functionality .",
    "each unit defines its application programming interface ( api ) , a collection of routines through which other units can interact with it .",
    "units must provide a null implementation for every routine in their api .",
    "this feature permits an application to easily exclude a unit without the need to modify code elsewhere .",
    "for example , the input / output unit can be easily turned on and off for testing purposes , by linking with the null implementations .",
    "flash units can be broadly classified into five functionally distinct categories : infrastructure , physics , driver , monitoring , and simulation .",
    "this categorization is meant to clarify the role of different classes of units in a simulation , rather than any architectural differences among them . in terms of organization , and their treatment by the configuration tool , all units follow the same rules , except the io and the simulation units , described in sections  [ sec : infrastructureunit ] and [ sec : simulationunit ] .",
    "the infrastructure category includes the units responsible for housekeeping tasks such as the management of runtime parameters , the handling of input and output to and from the code , and the administration of the solution mesh .",
    "units of this type are discussed further in section  [ sec : infrastructureunit ] .",
    "units in the physics category implement algorithms to solve the equations describing specific physical phenomena , and include units such as hydrodynamics , equations of state , and gravity .",
    "these units constitute the core of the flash solution capabilities .",
    "the driver unit implements the time advancement methods , initializes and finalizes the application , and controls most of the interaction between units included in a simulation .",
    "because control of the simulation is implemented by the driver unit , it interacts the most with other individual units ( see section  [ sec : interactions ] for more detail ) .",
    "the monitoring units track the progress and performance of a simulation .",
    "in general these units are not essential to producing scientific results , but provide information to the user about hardware usage and software efficiency .",
    "the simulation unit is of particular significance ; it defines how a flash application will be built and executed .",
    "it also provides initial conditions and the simulation - specific runtime parameters for the application .",
    "the simulation unit has been designed to enable customization of the flash code for specific applications without modifying other units , as explained in section  [ sec : simulationunit ] .",
    "additional details on the unit architecture in general is provided in section  [ sec : unitarchitecture ] .",
    "flash implements its inheritance , extensibility , and object - oriented approach through its configuration layer .",
    "this layer consists of a collection of text _ config _ files that reside at various levels of the code organization , and the _ setup _ tool which interprets the config files .",
    "the two primary functions of this layer are to configure a single application from the flash source tree , and to implement inheritance and customizability in the code .",
    "the config files for a unit contain directives that apply to everything at , or below , that hierarchical level , and describe its dependencies as well as variables and runtime parameters requirements .",
    "the setup tool parses the relevant config files , starting with the one for the simulation unit described in section  [ sec : simulationunit ] .",
    "dependencies are recursively resolved to configure individual units needed for the application .",
    "remember that each application requires different sections of code and produces a distinct executable .",
    "this method of configuration avoids an unnecessarily large binary and memory footprint , as only the needed sections of code are included .",
    "it also enables extensibility , since the inclusion of a new unit , or a new implementation of a unit , need become known only to the config file of the specific problem setup in the simulation unit .",
    "figure [ fig : config ] shows sections of two sample config files , one from the simulation unit ( left panel ) , and another one from a physics unit ( right panel ) . in figure",
    "[ fig : config_sim ] , lines 1 and 3 - 5 specify units that must be included . line 2 specifies a monitoring unit that is requested but may be excluded .",
    "no substitutions are permitted for these units , or their implementations . in the same file ,",
    "lines 6 - 8 specify desirable implementations of subunits . these subunit implementations will be included if there are no overriding directives given on the setup command line , but such a directive can cause them to be either excluded or replaced by another implementation .",
    "the remaining lines in the file pertain to the runtime parameters and variables .",
    "similarly , in the config file shown in the right panel of figure  [ fig : config_part ] , the first 5 lines specify the required and desirable units and subunits .",
    "line 6 indicates which implementation of the current unit is to be included by default , in this case , an implementation that is found in the particlesmain / passive subdirectory .",
    "again , a directive to the setup tool can replace this implementation .",
    "note that both the config files define the parameter `` pt_maxperproc '' , along with its default value .",
    "because of flash s inheritance rules , the parameter value in the simulation config will be used in the simulation , which in turn can be overwritten at runtime .",
    "flash s approach of using the unix directory structure with text annotations in the config files to implement inheritance and other object oriented features has the triple advantage of being simple , extensible , and completely portable .",
    "figure [ fig : units ] shows an example unit and its corresponding unix directory organization .",
    "the unit has two subunits : one with a single implementation , and another one with two alternative implementations .",
    "the top section of figure  [ fig : units_logical ] shows the logical architecture of the unit , while the bottom section of figure  [ fig : units_unix ] shows its organization using the unix directory structure .",
    "+      in a large multiphysics code with many solvers , management and movement of data is one of the biggest challenges .",
    "legacy solver codes rarely address resolving the ownership of data by different sections of code , a necessity for encapsulation and modularity . during the first round of modernization in the second version of flash",
    ", the data management was centralized into a separate unit to unravel the legacy code .",
    "this technique is also the data management model followed by samrai @xcite .",
    "the centralized data management extracted all the data from the individual units , and ensured data coherency by eliminating any possibility of replication .",
    "the main drawback of this approach was that it gave equal access to all units for data fetching and modification .",
    "thus a unit could get mutator access to data that it should never have modified .",
    "the onus was on the developer to find out the scope of each data item being fetched and to make sure that the scope was not violated .",
    "this responsibility limited the ability to add more functionality to the code to those who knew the code very well , a serious handicap to extensibility .",
    "flash version 3 takes the next and final step in modularizing data management by decentralizing the data ownership .",
    "every data item in the code belongs to exactly one unit .",
    "the owner unit has complete control over the scope and modifiability of the data item while the non - owner units can access or mutate the data only through the owner unit s api functions .",
    "additionally , the scope of data within a unit can vary .",
    "thus for example a data item specific to a subunit is visible only to that subunit , while unit scope data is visible to all functions in the unit .",
    "the interactions between units are governed by both the _ driver _ unit and the published apis of the individual units .",
    "the driver unit is responsible for initializing all the included units and the meta - data for the application as a whole .",
    "the driver unit implements the time - stepping scheme of the application , and hence dictates the order in which the units are initialized and invoked , and how they interact with each other .",
    "recall that units have default null implementations , a feature that allows a comprehensive implementation of the driver unit .",
    "once a unit is invoked by the driver , it can also interact with other units through their api .",
    "the driver unit also cleanly closes the units and the application when the run is complete .",
    "of the four cornerstones of the flash architecture , the unit structure is the most complex .",
    "unit architecture separates the computational kernel from the public interfaces , and controls the scope of various data items owned by the unit .",
    "a detailed description of the unit architecture is therefore critical to understanding the overall structure and software methodology of the flash code .",
    "subunits are an important and novel feature of the unit architecture detailed below .",
    "in addition to the unit architecture , we also describe some of the infrastructure units and the simulation unit , since these play an important role in the code architecture .",
    "the unit itself has three layers .",
    "the outer layer , the api , defines the full functionality of the unit . a unit s api",
    "can be viewed as having two sections : one for making its private data available to the other units , and another which defines its capabilities for modifying the state of the simulation .",
    "the inner layer of the unit is known as the kernel , and implements the full functionality .",
    "the middle layer implements the architecture , and acts as conduit between the outer and inner layers .",
    "it hides the knowledge of the flash framework and unit architecture from the kernel , and vice - versa , by providing wrappers for the kernel .",
    "the wrapper layer thus facilitates the import of third party solvers and software into flash . to include a new third party algorithm ,",
    "additional wrappers would be implemented in the middle layer to interface between the already published api and the new functionality .",
    "units can have one or more subunits which are groupings of self - contained functionality .",
    "the concept of subunits is new in flash version 3 .",
    "it was developed to constrain the complexity of the code architecture , and to minimize the fragmentation of code units , which would result in proliferation of data access functions .",
    "in particular the concept of subunits formalizes the selective use of a subset of a unit s functionality , and the possibility of multiple alternative implementations of the same subset .",
    "the wrapper layer in the unit architecture starts with the definition of subunits .",
    "subunits implement disjoint subsets of a unit s api , where none of the subsets can be a null set .",
    "the union of all subsets constituting various subunits must be exactly equal to the unit api .",
    "every unit has at least a _",
    "main _ subunit that implements the bulk of the unit s functionality , including its initialization .",
    "the main subunit is also the custodian of all the unit - scope data .",
    "the wrapper layer arbitrates on locating functions common to many alternative implementations of subunits , such that code duplication is minimized and flexibility is maximized .",
    "the use of the subunit concept is best illustrated with an example of interdependencies between the _ grid _ unit , which manages the eulerian mesh , and the _ particles _ unit .",
    "the discretized mesh in flash is composed of a collection of blocks , where individual blocks span a section of the domain , and all the blocks taken together cover the entire domain . in parallel environments , domain decomposition maps one or more blocks to each processor participating in the simulation .",
    "particles may be massless and passive , used to track the lagrangian features of the simulation , or active particles with mass which can affect gravitational fields . while individual elements ( zones and grid points ) of the eulerian mesh stay at the same physical location in the domain throughout the evolution , the lagrangian elements ( particles ) move with the motion of the fluid .",
    "the motion of lagrangian particles relative to the underlying eulerian mesh is best illustrated with snapshots of a set of particles at different times during evolution .",
    "figure [ fig : particles ] shows the positions of a small subset of particles at different stages of evolution in a weakly compressible turbulence simulation using a uniform grid @xcite . here , because the mesh does not change with time , the eulerian elements are stationary in the physical domain at all times , while the narrow line of lagrangian elements has spread all over the domain in the same timeframe .",
    "images of lagrangian tracer particles movement with advance in time evolution .",
    "the snapshots are taken at times ( a ) t=0 , ( b ) t=0.75 , ( c ) t=1.75 and finally ( d ) t=4.25 seconds .",
    "the simulation was done on 32,768 nodes of the ibm bg / l machine at lawrence livermore national laboratory , with @xmath0 grid points and more than 16 million particles.,width=518 ]    flash has four distinct subsets of functionality related to particles , each of which can have multiple alternative implementations .",
    "the current flash release provides three implementation methods for initial distribution of particles , four methods of mesh / particle mapping , two types of gravitational field interaction , and seven methods of time integration .",
    "this level of complexity is not limited to the particles unit .",
    "the time integration of particles can result in their migration between physical regions served by different processors .",
    "similarly , regridding of the active mesh may require migration of particles .",
    "these particle - related movements are best handled by the grid unit since it knows the topology of the eulerian mesh , thereby retaining encapsulation of alternative unit implementations .",
    "if flash were to solely follow the unit model of architecture described in section  [ sec : unit ] , then separate units for particles distribution , mapping , integration and migration would be needed .",
    "each of these units would need access to large amounts of data in the other units , thereby requiring many accessor - mutator functions .",
    "therefore , the addition of subunits is a major feature of the flash3architectural improvements .",
    "the concept of subunits very elegantly solves both the problems of data access and unit fragmentation through the introduction of a level of hierarchy in the unit s architecture .",
    "thus in the particles unit the particlesinitialization and particlesmapping subunits respectively deal with the initial spatial distribution and with mappings to and from the eulerian grid , while the particlesmain unit keeps the unit scope data and implements time integration methods .",
    "each subunit can have several alternative implementations .",
    "hence , subunits not only organize a unit into distinct functional subsets that can be selectively turned off , but also expand the flexibility of the code since implementations of different subunits can permute with each other and therefore can be combined in many different ways .",
    "in addition to the subunits level functionality , the other major challenge posed by the interaction between solvers for multiphysics simulations is the need for lateral data movement , which makes resolution of data ownership and encapsulation extremely difficult .",
    "for instance , the calculation of the hydrodynamics equations is dependent upon the equation of state , and if gravity is included in the simulation , upon gravitational acceleration .",
    "similarly , within the hydrodynamics calculation , there is a need to reconcile the fluxes at a global level when adaptive meshing is being used .",
    "all of these operations require access to data which is owned by different units .",
    "though version 2.5 of flash with its centralized database did not have some of these difficulties , it did not resolve data ownership , and did not achieve encapsulation .",
    "flash3 s solution to this challenge is to provide interfaces that allow for transfer back and forth between units , so that data can be accessed through argument passing by reference .",
    "the challenge is then reduced to arbitration between units as to which one is best suited to implement the needed functionality .",
    "figure  [ fig : lateral ] shows examples of lateral data movement between the particles unit and the grid unit .",
    "the left panel of figure  [ fig : lateral_particles ] shows the flow of execution , starting in the particles unit , as particles change their physical position due to time integration .",
    "some of the new positions in the eulerian mesh may be on different processors .",
    "the movement of particles to the appropriate processor is best carried out by handing control , along with the particles data , to the grid unit because of its knowledge of the mesh layout . once it has moved the particles appropriately , the grid unit returns the data and control back to the particles unit .",
    "the right panel of figure  [ fig : lateral_grid ] shows movement between the same two units where the example operation starts in the grid unit .",
    "when using amr , the mesh regridding operation changes the mapping of blocks to processors . in reorienting themselves to the new mesh , the particles have to move among processors .",
    "because the particles data structures are not accessible to the grid unit , the control is temporarily transferred to the particles unit , which passes the particles data by reference to the grid unit for redistribution .",
    "both examples preserve data encapsulation and ownership without compromising the performance .",
    "the infrastructure units in flash are responsible for discretization of the physical domain ; reading , writing , and maintaining the data structures related to the simulation data ; and other housekeeping tasks such as handling physical constants and runtime parameters . of these ,",
    "the most extensive responsibilities lie with the grid unit , which manages the discretized mesh , and the input / output io unit , which reads and writes the data .",
    "these two units are also unique in that they share their data with each other ; this exception to unit encapsulation is allowed for performance reasons .",
    "here we describes these two units briefly ( further discussion is found in @xcite and @xcite ) .",
    "the grid unit is the custodian of all the data structures related to the physical variables necessary for advancing the simulations .",
    "every discrete point in the mesh is associated with a number of physical variables , logical and physical coordinates , and an indexing number . on each processor ,",
    "meta - data exists , such as the location in the physical domain and the number of discretization points per parallel grouping .",
    "flash3has two different grid implementations : a simple grid uniform in space and a block - structured adaptive oct - tree mesh .",
    "if adaptive mesh refinement is being used , blocks are created , destroyed , and distributed dynamically , and different blocks exist at varying levels of resolution , all of which must be tracked by the unit .",
    "the grid unit is also responsible for keeping the physical variables consistent throughout the simulation .",
    "for example , when two adjacent blocks are at different resolutions , interpolation and prolongation ensure that conservation laws are not violated .",
    "hence , the grid unit is the most complex and extensive unit in the code , and most of the scaling performance of the code is determined by the efficiency of its parallel algorithms .    in flash , more than 90% of the reading or writing of data to the disk",
    "is controlled by the io unit .",
    "flash outputs data for checkpointing and analysis .",
    "the checkpoints save the complete state of the simulation in full precision so that simulations can transparently restart from a checkpoint file .",
    "the analysis data is written in many formats .",
    "the largest of these are the plotfiles , which record the state of the physical variables .",
    "quantities integrated over the entire domain are written from the master processor into a simple text file .",
    "the only input controlled by the io unit is the reading of checkpoint files .",
    "other forms of input , such as reading in a table of initial conditions needed by a specific simulation , are managed by the unit in question .",
    "flash is one of the relatively few applications codes that have support for multiple io libraries , such as hdf5 @xcite and parallel netcdf @xcite , where all processors can write data to a single shared file .",
    "the _ simulation _ unit effectively defines the scientific application .",
    "each subdirectory in the simulation unit contains a different application , which can be viewed as a different implementation of the simulation unit .",
    "this unit also provides a mechanism by which users can customize any part of their application without having to modify the source code in any other unit .",
    "an application can assume very specific knowledge of units it wants to include and can selectively replace functions from other units with its own customized ones by simply placing a different implementation of the function in its simulation subdirectory . at configuration time , the arbitration rules of the setup tool cause an implementation placed in the simulation unit to override any other implementation of that function elsewhere in the code .",
    "similarly , the simulation unit can also be aware of the runtime parameters defined in other units and can reset their default values .",
    "additionally , flash does not limit applications to the functionality distributed with the code ; an application can add functionality by placing its implementation in the simulation subdirectory .",
    "the setup tool has the capability to include any new functionality thus added at configuration time , without any prior knowledge of the functionality .",
    "accordingly , by allowing great flexibility to the simulation unit , flash makes it possible for users to quickly and painlessly customize the code for their applications .",
    "a typical use of this flexibility is in user - defined boundary conditions that may not have standard support in flash .",
    "another frequently customized functionality is control of refinement when using the amr adaptive grid mode .",
    "while a clear architecture design is the first step in producing a useful code , the flash code is not static and continues to develop based on internal pressures and external requests and collaborations . as the code gains maturity , regular testing and maintenance become crucial .",
    "maintenance of the flash code is assisted by guidelines for all stages in the code lifecycle , some of which are enforced and others are strongly encouraged .      in keeping with good software practice , flash3incorporates a unit test framework that allows for rigorous testing and easy isolation of errors . the implementation of a new code unit or subunit is usually accompanied by the creation of one or more corresponding unit tests . where possible , the unit tests compare numerical results against known analytical or semi - analytical solutions which isolate the new code module .",
    "the components of the unit test reside in two different places in the flash source tree .",
    "one is a dedicated path in the simulation unit , where the specific unit test acts as an ordinary simulation .",
    "the other is a subdirectory called unittest , located within the hierarchy of the corresponding unit , which implements the actual test and any helper functions it may need .",
    "these functions have extensive access to the internal data of the unit being tested . by splitting the unit test into two locations in the source tree",
    ", unit encapsulation is maintained .",
    "figure  [ fig : unittest ] illustrates the split implementation of the unit test with an example .",
    "the figure shows relevant sections of the particles and simulation units in the flash code . the example does not represent the full implementation of either unit",
    "; it includes only those few sections that best highlight the features of the unit test framework . in the simulation unit",
    ", there is an organizational directory which houses all the unit tests . within this directory ,",
    "there are two unit tests for the particles unit .",
    "one of the tests verifies the correct movement of the particles after their positions have changed because of either time integration or regridding .",
    "the routine implementing this test resides at the top level of the particlesmain subunit .",
    "the other unit test verifies the time integration methods that advance passive particles in time .",
    "for this test , the corresponding routine resides in the subdirectory `` passive '' of particlesmain subunit , where time integration of passive particles is computed .",
    "figure  [ fig : unittest ] also shows the particlesinitialization subunit to facilitate clearer understanding of the unit structure and the overlying unit test framework .",
    "the dotted arrows from the simulation unit test to the particles unit show the coupling between the two units .",
    "the figure also highlights the flexibility of having alternative implementations of the same function co - exist at several levels in the source tree .",
    "the unit test framework underlying the flash source tree .",
    "unit tests are split into drivers located in a subdirectory of the simulation unit and implementation routines within the relevant unit being tested .",
    "_ files _ are shown in italics .",
    "dotted lines indicate the coupling between the two units.,width=480 ]      flash s clean architecture is well documented , which enables easy extention by external contributors @xcite . for all routines defining the interface of a unit ,",
    "a well documented header is a code requirement .",
    "the developers are also strongly encouraged to include extensive in - line documentation in addition to a header describing each routine they implement .",
    "flash uses robodoc @xcite for automatic generation of documentation from internal headers .",
    "compliance with code regulations such as documentation and good coding practice is checked through scripts that run nightly .",
    "in addition , rapidly executing example problems are provided in the public release of flash .",
    "availability of a collection of example problems that a first - time user can set up and run in an hour or less has been cited as one of the more attractive features of flash in a code survey ( see section  [ sec : usersurvey ] ) .",
    "flash comes with a user s guide , on - line howtos , on - line quick reference tips , and hyperlinks to full descriptions with examples of all the api routines that form the public interfaces of various units @xcite .",
    "all of these user - assistance components are available on - line , as is the current release .",
    "in addition , there is an active email user s group where support questions are addressed by both developers and knowledgeable active users .",
    "the flash code has attracted a wide range of users and has become a premier community code preeminent in , but not limited to , the astrophysics community .",
    "many users cite flash s capabilities , ease of use , scalability , modularity , and extensive documentation as the key reasons for their use of flash .",
    "a code survey performed in 2005 , followed by another in 2007 , found that the close to three hundred responding users utilize the code in three major ways .",
    "the first group ( approximately 41% ) uses flash as a primary research tool for a broad range of application areas , including high - energy astrophysics , cosmology , stars and stellar evolution , computational fluid dynamics ( cfd ) , and algorithm development .",
    "the second group of users ( @xmath1 ) employ the flash code for verification and validation ( v&v ) .",
    "these users primarily attempt to compare flash to other codes or use flash as a benchmark .",
    "still others in this v&v group port flash to new machines to test compilers , libraries , and performance",
    ". finally , the third group ( @xmath2 ) uses flash as a sample code or for educational purposes .",
    "the results of the survey clearly indicate that flash enjoys wide acceptance among researchers from many fields . by 2007",
    ", flash had been downloaded more than 1700 times and used in more than 320 publications , by both center members and external users .",
    "figure [ fig : flashdownloadspapers ] shows that both the number of code downloads and the number of publications has steadily grown as the code has matured .",
    "figure [ fig : whyusingflash ] shows that while the presence of adaptive mesh refinement is the top reason cited for using flash , it is the only one in the top six reasons that relates to the capabilities of the code .",
    "the remaining five top reasons pertain to the code architecture and its software process .",
    "these reasons include flexibility , ease of use , and performance , thus vindicating the architectural choices of flash .",
    "we wish to thank all the past contributors to the flash code .",
    "the software described in this work was in part developed by the doe - supported asc / alliance center for astrophysical thermonuclear flashes at the university of chicago under grant b523820 .",
    "antypas , k.b . ,",
    "calder , a.c .",
    ", dubey , a. , gallagher , j.b . ,",
    "joshi , j. , lamb , d.q . , linde , t. , lusk , e.l . ,",
    "messer , o.e.b . ,",
    "mignone , a. , pan , h. , papka , m. , peng , f. , plewa , t. , riley , k.m . , ricker , p.m. , sheeler , d. , siegel , a. , taylor , n. , truran , j.w . ,",
    "vladimirova , n. , weirs , g. , yu d. , and zhang , j. ( 2006 ) .",
    "flash : applications and future .",
    "_ parallel computational fluid dynamics 2005 : theory and applications _ 235 + .",
    "armstrong , r. , kumfert , g. , mcinnes , l. , parker , s. , allan , b. , sottile , m. , epperly , t. , and dahlgren , t. ( 2006 ) .",
    "the cca component model for high - performance scientific computing . _ concurrency and computation : practice and experience _",
    "18(2 ) , 215229 .        , a.  c. , fryxell , b. , plewa , t. , rosner , r. , dursi , l.  j. , weirs , v.  g. , dupont , t. , robey , h.  f. , kane , j.  o. , remington , b.  a. , drake , r.  p. , dimonte , g. , zingale , m. , timmes , f.  x. , olson , k. , ricker , p. , macneice , p. , and tufo , h.  m. ( 2002 ) . on validating an astrophysical simulation code .",
    "_ astrophysical journal , supplement _ 143 , 201229 .",
    "chilan , c. , yang , m. , cheng , a. , and arber , l. ( 2006 ) .",
    "parallel i / o performance study with hdf5 , a scientific data package .",
    "http://www.hdfgroup.uiuc.edu/papers/papers/parallelio/parallelperformance.pdf .",
    "colella , p. , graves , d.   t. , keen , n.  d. , ligocki , t.  j. , martin , d.  f. , mccorquodale , p.  w. , modiano , d. , schwartz , p.  o. , sternberg , t.  d. , and van straalen , b. ( 2009 ) .",
    "software package for amr applications , design document , https://seesar.lbl.gov/anag/chombo .",
    "fisher , r. , abarzhi , s. , antypas , k. , asida , s.m . ,",
    "calder , a.c .",
    ", cattaneo , f. , constantin , p. , dubey , a. , foster , i . ,",
    "gallagher , j.b . ,",
    "ganapathy , m.k . ,",
    "glendenin , c.c .",
    ", kadanoff , l. , lamb , d.q . , needham , s. , papka , m. , plewa , t . ,",
    "reid , l.b . , rich , p. , riley , k. , sheeler , d.(2008 ) .",
    "terascale turbulence computation on bg / l using the flash3 code . _",
    "ibm journal of research and development _",
    "52(1/2 ) , 127137 .    , b. , olson , k. , ricker , p. , timmes , f.  x. , zingale , m. , lamb , d.  q. , macneice , p. , rosner , r. , truran , j.  w. , and tufo , h. ( 2000 ) . : an adaptive mesh hydrodynamics code for modeling astrophysical thermonuclear flashes .",
    "_ astrophysical journal , supplement _ 131 , 273334 .",
    "hovland , p. , keahey , k. , mcinnes , l.  c. , norris , b. , diachin , l.  f. , and raghavan , p. ( 2003 ) . a quality of service approach for high - performance numerical components . in _ proceedings of workshop on qos in component - based software engineering ,",
    "software technologies conference_. toulouse , france .",
    "ko , s. , cho , k.  w. , song , y.  d. , kim , y.  g. , na , j. , and kim , c. ( 2005 ) .",
    "development of cactus driver for cfd analyses in the grid computing environment . in _ advances in grid computing - egc 2005",
    "_ vol . 3470 , pp .",
    "771777 .",
    "li , j. , liao , w. , choudhary , a. , ross , r. , thakur , r. , gropp , w. , latham , r. , siegel , a. , gallagher , b. , and zingale , m. ( 2003 ) .",
    "parallel netcdf : a high - performance scientific i / o interface .",
    "_ supercomputing , 2003 acm / ieee conference _",
    "39 + .        , b.  w. , bryan , g. , bordner , j. , norman , m.  l. , abel , t. , harkness , r. , and kritsuk , a. ( 2005 ) . introducing enzo , an amr cosmology application . in plewa , t. , timur , l. , and weirs , v. ( eds . ) adaptive mesh refinement ",
    "theory and applications .",
    "springer , vol .",
    "41 of _ lecture notes in computational science and engineering_.    reynders , j. , hinker , p. , cummings , j. , atlas , s. , banerjee , s. , humphrey , w. , karmesin , s. , keahey , k. , srikant , m. , and tholburn , m. ( 1996 ) .",
    "framework for scientific simulations on parallel architectures .",
    "_ parallel programming using c++_.      toth , g. , sokolov , i. , gombosi , t. , chesney , d. , clauer , c. , de  zeeuw , d. , hansen , k. , kane , k. , manchester , w. , oehmke , r. , et  al .",
    "new tool for the space science community . _ j. geophysical research _ 110 , 12226",
    ".      worth , d. and greenough , c. ( 2005 ) .",
    "a survey of available tools for developing quality software using fortran 95 .",
    "technical report ral - tr-2005 , _ sftc rutherford appleton laboratory , sesp software engineering support programme_. available at http://www.sesp.cse.clrc.ac.uk/html/publications.html .",
    "* figure 1 caption : * + sections of sample config files . + * figure 2 caption : * + architecture of units , subunits , and local api . + * figure 3 caption : * + images of lagrangian tracer particles movement with advance in time evolution .",
    "the snapshots are taken at times ( a ) t=0 , ( b ) t=0.75 , ( c ) t=1.75 and finally ( d ) t=4.25 seconds .",
    "the simulation was done on 32,768 nodes of the ibm bg / l machine at lawrence livermore national laboratory , with @xmath0 grid points and more than 16 million particles .",
    "+ * figure 4 caption : * + lateral data movement during two different algorithmic steps .",
    "+ * figure 5 caption : * + the unit test framework underlying the flash source tree .",
    "unit tests are split into drivers located in a subdirectory of the simulation unit and implementation routines within the relevant unit being tested . _",
    "files _ are shown in italics .",
    "dotted lines indicate the coupling between the two units .. + * figure 6 caption : * + yearly number of publications in which the flash code was used ( left dark bars ) and flash downloads ( right striped bars ) .",
    "the jump in downloads in 2006 followed the release of the alpha version of flash3 , the new version of the code . +",
    "* figure 7 caption : * + results from a flash users survey in 2007 : reasons cited for flash usage ."
  ],
  "abstract_text": [
    "<S> flash is a publicly available high performance application code which has evolved into a modular , extensible software system from a collection of unconnected legacy codes . </S>",
    "<S> flash has been successful because its capabilities have been driven by the needs of scientific applications , without compromising maintainability , performance , and usability . in its newest incarnation , flash3consists of inter - operable modules that can be combined to generate different applications . </S>",
    "<S> the flash architecture allows arbitrarily many alternative implementations of its components to co - exist and interchange with each other , resulting in greater flexibility . </S>",
    "<S> further , a simple and elegant mechanism exists for customization of code functionality without the need to modify the core implementation of the source . </S>",
    "<S> a built - in unit test framework providing verifiability , combined with a rigorous software maintenance process , allow the code to operate simultaneously in the dual mode of production and development . in this paper </S>",
    "<S> we describe the flash3architecture , with emphasis on solutions to the more challenging conflicts arising from solver complexity , portable performance requirements , and legacy codes . </S>",
    "<S> we also include results from user surveys conducted in 2005 and 2007 , which highlight the success of the code .    </S>",
    "<S> software architecture , portability , extensibility , massively parallel , flash + </S>"
  ]
}