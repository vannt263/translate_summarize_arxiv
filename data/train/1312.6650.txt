{
  "article_text": [
    "the domains of scientific visualization , medical visualization , cad , and virtual reality often require large amounts of time for gpu rendering . at the high end , these computations require many computers in a cluster for highly gpu - intensive graphics rendering  @xcite . at the medium- and low - end",
    "this rendering may still require large amounts of gpu - intensive graphics rendering , but on a single computer .",
    "for such long - running jobs , checkpointing the state of graphics is an important consideration .",
    "transparent checkpointing is strongly preferred , since writing application - specific code to save graphics state is highly labor - intensive and error - prone .",
    "this work presents an approach to transparent checkpoint - restart for gpu - accelerated graphics based on record - prune - replay .",
    "the gpu support is vendor - independent .",
    "it is presented in the context of opengl for linux , but the same approach would work for other operating systems and other graphics apis , such as direct3d .    previously , lagar - cavilla presented vmgl  @xcite for vendor - independent checkpoint - restart . that pioneering work employs the approach of a shadow device driver for opengl , which shadows most opengl calls in order to model the opengl state , and restores it when restarting from a checkpoint . while that tour de force demonstrated feasibility for most of opengl  1.5 , the vmgl code to maintain the opengl state grew to 78,000 lines of code",
    "this document proposes a simpler , more maintainable alternative approach whose implementation consists of only 4,500 lines of code , to support opengl  1.5 .",
    "the approach is based on replaying a log of library calls to opengl and their parameters .",
    "the opengl - specific code is written as a plugin on top of a standard checkpoint - restart package , dmtcp .",
    "the role of dmtcp in this work corresponds to the role of virtual machine snapshots in vmgl .    the key observation behind the _ record - prune - replay _ approach is that in order to restore the graphics state after restart , it suffices to replay the original opengl calls .",
    "more precisely , it suffices to replay just those opengl calls that are relevant to restoring the pre - checkpoint graphics state .",
    "for example , opengl provides two functions , glenableclientstate and gldisableclientstate .",
    "both functions take a `` capability '' parameter .",
    "each capability is initially disabled , and can be enabled or disabled . at the end of a sequence of opengl calls , a capability is enabled or disabled based only on which of the two functions was called last for that capability .",
    "so , all previous calls for the same capability parameter can be pruned .",
    "_ pruning _ consists of purging all opengl calls not needed to reproduce the state of opengl that existed at the time of the checkpoint .",
    "the current work is implemented as a plugin on top of dmtcp  @xcite .",
    "checkpoint - restart is the process of saving to traditional disk or ssd the state of the processes in a running computation , and later re - starting from stable storage .",
    "_ checkpoint _ refers to saving the state , _ resume _ refers to the original process resuming computation , and _",
    "_ refers to launching a new process that will restart from stable storage .",
    "the checkpoint - restart is _ transparent _ if no modification of the application is required .",
    "this is sometimes called _ system - initiated _ checkpointing .    finally , this work is demonstrated both for opengl  1.5 and for opengl  3.0 .",
    "this is in contrast to vmgl , which was demonstrated only for opengl  1.5 .",
    "the complexity of supporting opengl  3.0 is considerably larger than that for opengl  1.5 .",
    "this is because opengl  3.0 introduces programmable pipelines , and shaders .",
    "shaders are programs compiled from a glsl c - like programming language .",
    "shaders are then passed to the server side of opengl ( to the gpu ) .",
    "when including the opengl  3.0 functions , the size of our implementation grows from 4,500 lines of code to 6,500 lines of code ( in c and python ) .",
    "[ [ organization - of - paper . ] ] organization of paper .",
    "+ + + + + + + + + + + + + + + + + + + + + +    in the rest of this work , section  [ sec : background ] provides background on the software libraries being used .",
    "section  [ sec : design ] describes the software design , and section  [ sec : algorithm ] describes the algorithm for pruning the log .",
    "section  [ sec : comparison ] compares the two approaches of shadow drivers and record - prune - replay .",
    "section  [ sec : limitations ] describes the limitations of this approach , while section  [ sec : relatedwork ] presents related work .",
    "section  [ sec : experiments ] describes an experimental evaluation .",
    "finally , section  [ sec : futurework ] presents future work , and section  [ sec : conclusion ] presents the conclusion .",
    "the software stack being checkpointed is described in figure  [ fig : software ] .",
    "software stack of a graphics application to be checkpointed . ]    [ [ windowing - toolkits . ] ] windowing toolkits .",
    "+ + + + + + + + + + + + + + + + + + +    opengl applications typically use a windowing toolkit in order to handle external issues such as providing a graphics context based on a window from x - windows , and handling of input ( mouse , keyboard , joystick ) , and handling of sound .",
    "two of the more popular windowing toolkits are glut and sdl .",
    "glut is noted for its simplicity , while sdl is noted for its completeness and is often used with games . in particular ,",
    "sdl is used by ioquake3  @xcite , and glut is used by pymol  @xcite .",
    "both are built on top of lower - level glx functions .",
    "this work supports calls both to sdl and to glut , as well as to glx .",
    "[ [ sec : dmtcp ] ] dmtcp .",
    "+ + + + + +    dmtcp  @xcite ( distributed multithreaded checkpointing ) provides transparent user - space checkpointing of processes .",
    "the implementation was built using dmtcp plugins  @xcite .",
    "in particular , two features of plugins were used :    1 .",
    "wrapper functions around calls to the opengl library ; and 2 .",
    "event notifications for checkpoint , restart , and thread resume during restart ( pre_resume ) .",
    "wrapper functions around the opengl calls were used to maintain a log of the calls to the opengl library , along with the parameters passed to that library . at the time of restart ,",
    "the log was pruned and replayed , before returning control back to the graphics application .",
    "as described in the introduction , the fundamental technique to be used is record - prune - replay .",
    "the key to pruning is to identify the dependencies among opengl calls in the log .",
    "note that it is acceptable to over - approximate the dependencies ( to include additional dependencies that are not required ) , as long as the size of the pruned log continues to remain approximately constant over time .",
    "this is sometimes used to produce a simpler model of the dependencies among opengl calls .    in maintaining dependencies",
    ", the key observation is that if the function  @xmath0 can only set the single parameter  @xmath1 on which @xmath2 depends , then only the last call to  @xmath0 prior to calling  @xmath2 needs to be preserved .",
    "however , the situation can become more complicated when a single function  @xmath0 is capable of setting multiple parameters .",
    "for example , imagine a function : +    @xmath3 .",
    "imagine further that @xmath4 and @xmath5 exist .",
    "then it is important the last call be retained for each category @xmath6 , where @xmath7 is one of the three functions @xmath8 , @xmath9 , and @xmath10 , and @xmath11 is a value of the parameter @xmath12 .",
    "several additional considerations are important for a correct implementation .    [",
    "[ reinitializing - the - graphics - library - during - restart . ] ] reinitializing the graphics library during restart .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    sdl provides a function sdl_quit ( ) , that resets all state to its initial state .",
    "that function is required for the current work , since at the time of restart , the pruned log of calls to opengl is replayed .",
    "glut does not appear to provide such a re - initialization function .",
    "hence , for glut , we make a copy of the glut library in memory ( both text and data segments ) prior to initialization , and at the time of restart , we overwrite this memory with a copy of the glut library memory as it existed prior to the first call to that glut library .",
    "potentially , one must also worry about re - initializing a low - level graphics library such as dri .",
    "we posit that this is usually not necessary , because a well - structured graphics library like opengl or a generic dri library will determine which vendor s gpu is present , and then directly load and initialize that vendor - specific library as part of its own initialization .",
    "note that a subtle issue arises in overwriting a graphics library during restart .",
    "this overwriting occurs only after the checkpoint - restart system has restarted all pre - checkpoint threads , open files , etc . yet",
    ", some graphics libraries directly create a new thread .",
    "this issue arose , for example , in the case of the dri library for the ati r300 .",
    "when it initializes itself , it creates an auxiliary thread to maintain its internal data structures .",
    "the auxiliary thread still exists at the time of restart , even though the re - initialization creates an additional thread .",
    "hence , one must kill the older thread on restart .",
    "this is accomplished through the pre_resume event notification from the dmtcp checkpoint - restart subsystem . otherwise , the older thread would write to its data structures at the same time as the newer thread , causing memory to be corrupted .",
    "[ [ sdl - glut - and - glx . ] ] sdl , glut and glx .",
    "+ + + + + + + + + + + + + + + + + +    in this work , we intercept and log calls to sdl and glut as a proof of principle .",
    "these windowing toolkits provide high - level abstractions for calls to glx . in the future ,",
    "we intend to directly intercept calls to glx in the opengl library .",
    "this will provide support for all windowing toolkits .",
    "[ [ virtualization - of - graphics - ids . ] ] virtualization of graphics ids .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    most of the wrappers around opengl functions are used only to maintain the log . in a few cases",
    ", we also required virtualization of certain ids for graphics objects .",
    "this is because the graphics i d could change between checkpoint and a restart in a new session .",
    "hence , a translation table between virtual ids and real ids was maintained for these cases .",
    "these cases included texture ids , sdl surface ids , and joystick ids .",
    "[ [ sec : pointers ] ] saving pointers to memory for later replay .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in most opengl functions , the entire argument is passed to the opengl library .",
    "but in a few cases , a pointer to application memory is passed to the opengl library . in these cases , the data in memory at the time of the call",
    "may be altered at the time of checkpointing .",
    "the implementation must then copy the data into separately allocated memory .",
    "examples occur for calls to glteximage , gltexcoordpointer , glcolorpointer , glvertexpointer , glbufferdata , gltexparameterfv , and others .",
    "virtualization of opengl  ids follows a standard paradigm for dmtcp plugins . for each opengl function that refers to",
    "the type of i d of interest , the dmtcp plugin defines a wrapper function with the same type signature as the original opengl function .",
    "when the graphics application is run under dmtcp , the wrapper function is interposed between any calls from the graphics application to the opengl library .",
    "thus , each wrapper function is called by the application , possibly modifies parameters of the i d type of interest , and then calls the real opengl function in the opengl library .",
    "if the opengl function normally returns an i d ( possibly as an `` out '' parameter ) , then the wrapper function creates a new virtual i d , enters the ( virtual ,  real ) pair into a translation table , and then returns the virtual i d to the application .    if the opengl function has an argument corresponding to that i d ( an `` in '' parameter ) , then the wrapper function assumes that the application has passed in a virtual i d .",
    "the application uses the translation table to replace it by the corresponding real i d , before calling the real opengl function in the opengl library .",
    "finally , at the time of restart , the dmtcp plugin must recreate all graphics objects by replaying the log . at that time",
    ", the opengl library may pass back a new real i d .",
    "since the log retained the original virtual i d , the plugin then updates the translation table by setting the translation of the virtual i d to be the new real i d generated by opengl .",
    "the current implementation of the log of opengl calls maintains that log as human - readable strings .",
    "further , the code for pruning the log is currently a python program .",
    "even worse , the log of calls is maintained solely as a file on disk , even though this is much slower than maintaining the log in ram .",
    "all of this is done for simplicity of implementation .    while pruning the log in this way undoubtedly adds at least one order of magnitude to the time for pruning , the effect on performance is minor .",
    "this is because the plugin periodically creates a child process , which prunes the log in parallel , and then notifies the parent of success .",
    "the child process uses an otherwise idle core of the cpu . as figure",
    "[ fig : cdf - plot ] shows , the overhead of doing this is too small to be measured , when an idle core is available .",
    "nevertheless , while a human - readable log on disk is advantageous for software development and debugging , a future version of this software will employ c  code for pruning . furthermore , the current implementation represents each opengl function and parameter as an ascii string ( and even integers are written out as decimal numbers in ascii ) .",
    "the future implementation will use binary integers to represent opengl function names and most parameters .",
    "opengl 3.0 simplified future revisions of the api by deprecating some older features , including glpush , glpop and display lists .",
    "programmable vertex and fragment processing , which was introduced in opengl  2.0 , became a core feature of opengl  3.0 , and all fixed - function vertex and fragment processing were deprecated .",
    "the programmable pipelines have become the standard for modern opengl programming .",
    "shaders and vertex buffer objects ( vbos ) are two important concepts in modern opengl .",
    "these two types of objects are both stored in the graphics memory ( on the server - side ) .",
    "vertex buffer objects were introduced in opengl  1.5 , but they had not been widely used until opengl  3.0 .",
    "display lists were an earlier attempt to store program objects on the server - side , but using a fixed program model in opengl .",
    "these were deprecated in modern opengl .",
    "shaders are a large part of the motivation for opengl  3.0 .",
    "a shader is a program written in the glsl language , which runs on the gpu instead of the cpu . a shader program in the glsl language is separately compiled into binary before being used by an opengl program .",
    "the plugin described here places a wrapper function around all opengl functions related to shaders .",
    "example functions are glcreateshader , glshadersource , glcompileshader , gllinkprogram , and so on . in particular",
    ", we virtualize the shader i d parameter for these functions .",
    "since the user application runs on the cpu and shaders run on the gpu , a method of copying data from the cpu to the gpu is needed .",
    "vertex buffer objects ( originally introduced in opengl  1.5 ) fulfill this role .",
    "this allows various types of data ( including shader programs ) to be cached in the graphics memory of the gpu .",
    "the approach described here preserves all memory buffers associated with a vertex buffer object by copying them into a temporary buffer in memory . that memory will be restored on restart , thus allowing the plugin to copy the same buffer from memory into graphics memory .",
    "we have found the log - based approach to be especially helpful from the point of view of software engineering . in the first stage of implementation , we wrote wrapper functions to virtualize each of the opengl ids , so as to guarantee that record - replay will work .",
    "( in certain cases , such as testing on ioquake3 , even this stage could largely be skipped , since the application chooses its own texture and certain other ids . )",
    "since the wrapper functions often follow a common pattern ( e.g. , translate the i d parameter from virtual to real , and then call the real opengl function in the opengl library ) , we also wrote a preprocessing language .",
    "this language concisely takes the declaration of an opengl function as input , along with a declaration of which parameter is to be virtualized , and then generates the desired wrapper function in  c. thus , full c  code is available for compiling and debugging at all times .",
    "however , ensuring that all pointers to memory are saved for later replay ( see section  [ sec : pointers ] ) continued to consume significant amounts of time for debugging .",
    "finally , the code for pruning the log can be developed iteratively .",
    "code is written for pruning a set of related opengl functions , and the record - prune - replay cycle is tested for correctness by running it inside a sophisticated opengl application .",
    "then another set of related opengl functions is targeted , and similarly tested .",
    "this breaks down the code - writing into small , independent modules .",
    "the strategy for pruning the log of opengl calls is based on dependencies among opengl functions .",
    "opengl functions for drawing a graphics frame are identified and form the root of a dependency tree for all opengl functions ( along with any glx extensions ) .",
    "a node is a child of a parent node if executing an opengl call of the type given by the child can potentially affect a later opengl call of the type given by the parent .",
    "hence , in this tree , almost every opengl function  @xmath13 is a descendant of gldraw , since there is almost always a sequence of calls beginning with  @xmath13 and ending with gldraw , such that changing the parameters of a call to  @xmath13 , or removing call  @xmath13 entirely , will affect what is displayed through gldraw .",
    "an example of such a dependency tree is given in figure  [ fig : textures ] . the opengl functions that draw the next graphics frame ( gldraw ) , or flush the current graphics to the framebuffer ( glfinish ) , form the root of the dependency tree .",
    "note also that a call to glgentextures can not affect how a call to glclearcolor ( setting the `` background '' color when clearing the buffer ) , and similarly , vice versa .",
    "hence , if there are two calls to glclearcolor , with an intervening call to glteximage and no intervening calls to gldraw or glfinish , then it is safe to prune the first call to glclearcolor . only the second call to glcolor can affect a later call to gldraw / glfinish , and the first call to glcolor can not affect the call to glteximage .",
    "dependency tree for some opengl functions . ]    in general , the algorithm begins by finding the last call to gldraw or glfinish .",
    "no earlier call to gldraw or glfinish can have an affect on a final call to gldraw .",
    "hence , we search within the log for the last opengl call that drew or flushed a graphics frame .",
    "we only prune calls until this last drawing call .",
    "this has the benefit of re - drawing the last graphics frame properly upon replay , and additionally avoiding any bad corner cases that might occur by replaying only until the middle of the commands for a graphics frame .",
    "after this , branches of this dependency tree are identified , such that calls to a function within a branch may affect the calls for drawing a graphics frame , but do not affect the behavior of any other branch .",
    "this is illustrated in figure  [ fig : textures ] , where one branch is concerned with clearing a buffer , and the other is concerned with creating , deleting or modifying the effect of textures .    [ [ textures - a - running - example . ] ] textures : a running example .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    next , we discuss a running example , concerning textures in opengl  1.5 .",
    "this illustrates the general approach taken toward pruning the log by maintaining a tree of dependencies among opengl calls .",
    "a texture can be assigned to a target , such as the targets gl_texture_1d , gl_texture_2d , gl_texture_3d .",
    "the glbindtexture binds a texture  i d to a target .",
    "other opengl functions operate solely on a specific target , where the target acts as an alias for the texture  i d that was most recently bound to that target . thus",
    ", a call to draw a graphics frame depends only on the texture  i d that was most recently bound to a target , for each of the targets .",
    "thus , for a given target , one need only retain the most recent call to glbindtexture for that same target .",
    "hence , it may _ seem _ that an older call to glbindtexture may be dropped from this dependency tree , if a more recent call to the same target exists .",
    "unfortunately , this is not the case , due to the issue of texture parameters .",
    "we continue the example of textures in the following .",
    "each texture denoted by a texture  i d has many associated parameters .",
    "these parameters are affected both by the gltexparameter and the glteximage family of opengl functions .",
    "( one can think of glteximage as specifying a single texture parameter , the image associated with a texture .",
    "note that these functions specify only a target , and not a texture  i d . )    in order to incorporate the dependencies on texture parameters , we conceptually view the `` live objects '' prior to drawing a graphics frame as consisting of _ texture triples_:(texture  i d , texture target , texture parameter)a function within the gltexparameter or glteximage family directly specifies a texture target and a texture parameter .",
    "it also implicitly specifies a texture  i d .",
    "more precisely , it specifies the texture  i d corresponding to the most recent of the earlier calls to glbindtexture that was applied to the same texture target .",
    "hence , a call within the gltexparameter family may be dropped if it refers to the same triple as a later call within the log of opengl calls .",
    "if a call within the glteximage family is viewed as affecting an extra `` image '' parameter , then the same rules apply .",
    "finally , one can now state the rule for when a call to glbindtexture may be dropped . a call within the gltexparameter or",
    "glteximage family refers to a given texture triple .",
    "this call to gltexparameter or glteximage refers implicitly to a texture  i d through an earlier call to glbindtexture , as described earlier .",
    "all such earlier calls to glbindtexture must be retained , while all other such calls may be dropped .    in the running example of textures",
    ", one can see that the size of the log is limited to those calls relevant to a given texture triple .",
    "since the number of texture  ids of a graphics program will be limited , this will determine the size of the log , in practice .",
    "in this section , following a review of vmgl , section  [ sec : designchoices ] compares the different design choices of vmgl and the current approach",
    ". then section  [ sec : features ] compares the features and expected performance that result from these design choices .",
    "[ [ review - of - the - design - of - vmgl . ] ] review of the design of vmgl .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as mentioned earlier , vmgl  @xcite uses a shadow driver strategy , similar in spirit to the earlier shadow device driver work of swift  @xcite .",
    "in contrast , the approach described here uses a record - prune - replay strategy . in this section",
    ", we will always refer to the three phases of checkpoint - restart as : checkpoint ( writing to disk a checkpoint image ) ; resume ( resuming the original process after writing the checkpoint image ) ; and restart ( restarting a new process , based on a checkpoint image on disk ) . in the vmgl work , they typically refer to checkpoint as `` suspend '' and restart as `` resume '' .",
    "they do not use the term `` restart '' at all .",
    "further , the vmgl work uses wiregl in its implementation .",
    "wiregl has now been absorbed into the current chromium project  @xcite ) .",
    "we continue to refer to wiregl here , for clarity of exposition , although any new implementation would use chromium rather than wiregl .",
    "finally , in the vmgl approach , the saved graphics state for opengl contexts falls into three categories .    * global context state : including the current matrix stack , clip planes , light sources , fog setting , visual properties , etc . *",
    "texture state * display lists    this enabled vmgl to support most of opengl  1.5 .",
    "the vmgl work is based on a shadow driver design employing a snapshot of a virtual machine , while the the current work is based on the use of record - prune - replay operating directly within the end user s current desktop .",
    "these two design choices have a variety of consequences . here",
    ", we attempt to codify some of the larger consequences of those design choices .    1",
    ".   virtual machine versus direct execution : 1 .",
    "vmgl is designed to operate with a virtual machine such as xen . at checkpoint time",
    ", vmgl uses vnc to detach a graphics viewer at checkpoint time , and to re - attach at restart time .",
    "it uses wiregl  @xcite to pass opengl commands between the guest operating system ( containing the application ) and the host ( where the graphics are displayed ) .",
    "the current approach is based on dmtcp , a package for transparent checkpoint - restart .",
    "a dmtcp plugin records the opengl calls , and periodically prunes the log .",
    "the graphics application executes within the user s standard desktop , with no vnc .",
    "checkpoint : ( actions at checkpoint time ) 1 .",
    "vmgl calls on the virtual machine snapshot facility to create a checkpoint image ( a virtual machine snapshot ) .",
    "the dmtcp plugin deletes the graphics window ( along with the application s opengl contexts ) , and then calls on dmtcp to write a checkpoint image .",
    "3 .   resume : ( resuming the original process after writing a checkpoint image ) 1 .",
    "vmgl has very little to do on resume , and is fully efficient .",
    "2 .   the dmtcp plugin must recreate the graphics window with the application s opengl context , and then replay the log .",
    "restart : ( restarting from a checkpoint image on disk ) 1 .",
    "vmgl restores the virtual machine snapshot along with its vmgl library and x  server .",
    "wiregl connection allows it to re - synchronize with a stub function within a vnc viewer .",
    "the dmtcp plugin restores the the graphics application memory from the dmtcp checkpoint image .",
    "the plugin then connects to the x  server and creates a new graphics window and replays the pruned log , which creates a new opengl context , and restores the opengl state .",
    "5 .   _ restoring opengl ids : _ ( in the opengl standard , many opengl functions return ids for numerous graphics objects , including textures , buffers , opengl programs , queries , shaders , etc .",
    "since the graphics application will usually cache the ids , it is important for a checkpointing package to use the same graphics ids on restart that were passed to the application prior to checkpoint . ) 1 .",
    "vmgl takes advantage of the fact that a new opengl context will provide ids for graphics object in a deterministic manner .",
    "so at restart time , vmgl makes opengl calls to recreate the graphics objects in the same order in which they were created .",
    "2 .   unlike vmgl ,",
    "the dmtcp plugin guarantees that the application always sees the same graphics i d because the plugin only passes virtual ids to the application .",
    "the plugin provides a wrapper function around any opengl function that refers to a graphics i d .",
    "the wrapper function translates between a virtual i d ( known to the application ) and a real i d ( known to the current x  server ) . at restart time , the translation table between virtual and real ids is updated to reflect the real ids of the new x  server .",
    "next , we discuss some of the differences in features and performance for vmgl and dmtcp plugin .",
    "we _ do not _ argue that one approach is always better than the other .",
    "our goal is simply to highlight what are the different features and performance to be expected , so that an end user may make an informed choice of which approach is best for a particular application .    1 .",
    "_ time for checkpoint - resume : _ the vmgl time for checkpointing and resuming the original process is dominated by the time to write out a snapshot of the entire operating system .",
    "the dmtcp time for checkpointing and resuming the original process is dominated by two times : the time to write out the graphics application memory , and the time to prune the log before checkpoint , and then replay the pruned log .",
    "note that the plugin periodically prunes the log , so that pruning at checkpoint time does not require excessive time .",
    "( currently , the time to replay the pruned log is a little larger .",
    "this is expected to change in future work , when the the pruning code will be switched from python to  c. ) 2 .",
    "_ size of checkpointed data : _ while both approaches must save the server - side data , vmgl also writes out a snapshot of both the graphics application memory and its entire operating system at checkpoint time .",
    "in contrast , the dmtcp plugin must write out just the graphics application . however , the plugin has an extra burden in also needing to write out the pruned log .",
    "_ rendering over a network : _ since vmgl employs vnc and wiregl , it is trivial for vmgl to operate over a network in which the vnc server and the vnc viewer execute on different machines .",
    "( the vmgl project also makes a minor modification to vnc and places a vmgl - specific x  extension inside the guest operating system . )",
    "this mode is also possible for the dmtcp plugin , since dmtcp can checkpoint and restart a vnc server after the vnc viewer has disconnected .",
    "however , most vnc servers do not support gpu - accelerated opengl implementations .",
    "thus , the dmtcp plugin approach would have to be extended to include a compatible vnc that uses an analog of wiregl ( chromium ) .",
    "this has _ not _ been implemented in the current work .",
    "support for heterogeneous gpu architectures : _ while both vmgl and the dmtcp plugin are vendor - independent , vmgl has the further advantage of being able to checkpoint on a computer with one type of gpu and to restart on another computer with a different type of gpu .",
    "this is because the application always `` talks '' to the same graphics driver ( the one saved as part of the guest virtual machine snapshot ) , and wiregl insulates this graphics driver within the guest from the graphics driver on the host .",
    "one can restart on a different host with a different graphics driver . in the case of the dmtcp plugin , see section  [ sec : limitations ] for a discussion of future work in which the plugin could also capture heterogeneous operation .",
    "_ support for distinct operating systems : _ the plugin approach operates within x  windows , and requires dmtcp , which has been implemented only for linux .",
    "the vmgl approach runs well over multiple operating systems , including linux .",
    "vmgl can also make use of wined3d to translate from the windows - oriented direct3d graphics to opengl .",
    "_ gpu - accelerated opengl graphics within a virtual machine : _ the vmgl project was created specifically to provide gpu - accelerated graphics for a virtual machine .",
    "although dmtcp has been used to checkpoint a kvm machine  @xcite , it is not clear how to extend that work to support gpu - accelerated opengl for virtual machines .",
    "_ window manager : _ since the dmtcp plugin operates within an existing desktop , it is possible to restart a graphics application on a different desktop _ with a different window manager_. this is not possible in vmgl , since the window manager is part of the virtual machine snapshot , and can not be changed on restart .",
    "_ virtualization of opengl ids : _ vmgl must maintain every i d ever created since the startup of the graphics application .",
    "it then recreates them in the original order at the time of restart .",
    "it is usually not a burden to maintain all ids , since typical applications create their graphics objects only near the beginning of the program .",
    "but an atypical application might choose to frequently create and destroy graphics ids , and this would force vmgl to carefully model the choice of new ids made by an opengl implementation during creation and deletion",
    ". this model might be vendor - specific , thereby losing its desirable vendor - independent quality .",
    "in contrast , the dmtcp plugin virtualizes the opengl ids ( see section  [ sec : virtualization ] ) .",
    "this allows the plugin to insulate itself from the particular pattern of opengl ids passed back by the x  server .",
    "several limitations are discussed .",
    "certain graphics operations take pointers to large data objects .",
    "a user program may modify these data objects , or even delete them from memory entirely .",
    "if the data object is not available in memory at the time of restart , then replaying the graphics operation will not faithfully reproduce the pre - checkpoint operation .",
    "this can be compensated for by saving a copy of the data object at the time that the operation is executed . but",
    "this is problematic if the graphics operation is called repeatedly on the same data object .",
    "a hash on the memory of the data object can be used to determine if the data object has been modified since the last call , but this creates significant overhead .",
    "a good example of this occurs for the opengl function glbufferdataarb , which enables a graphics client to store the data associated with a server - side buffer object .",
    "the approach presented here works well in homogeneous architectures ( same gpu and drivers on the pre - checkpoint machine and the restart machine ) .",
    "it does not support heterogeneous architectures .",
    "this is because the graphics driver library in system memory ( in ram ) is saved with the rest of the checkpoint image .",
    "if the checkpoint image is transferred to another computer with a different gpu architecture , then the original graphics driver library will fail to operate correctly .",
    "the current approach could be generalized to heterogeneous architectures in the future by loading and unloading appropriate graphics driver libraries , but only at the expense of additional complication .",
    "opengl  4.0 adds support for arb_get_program_binary , which retrieves the contents of vendor - specific program objects for later reuse .",
    "this illustrates a situation in which any checkpointing package for gpus is likely to lose the ability to do heterogeneous checkpointing .",
    "the current work stresses checkpointing of hardware - accelerated opengl state for a standalone application .",
    "vmgl  @xcite presented a pioneering approach that demonstrated checkpointing of hardware - accelerated opengl state for the first time .",
    "that work was motivated by an approach of swift et al .",
    "@xcite within the linux kernel . in that work , a separate shadow device driver within the kernel records inputs to the real driver , and models the state of the real driver .",
    "if the device driver temporarily fails due to unexpected input , the shadow driver intercepts calls between the real device driver and the rest of the kernel , and passes its own calls to the real device driver , in order to place the driver back into a `` sane '' state .",
    "this is comparable to the approach of vmgl , except that swift discuss a shadow device driver inside the kernel , and vmgl maintains a library within the graphics application itself to model the entire opengl state ( drivers and gpu hardware ) , and to restore that state during restart .",
    "the current work is distinguished from the previous two examples  @xcite in that we do not maintain shadow driver state , but instead we log the calls to the opengl api , along with any parameters .",
    "both vmgl and the current work potentially suffer from having to save the state of large data buffer objects .",
    "both approaches are potentially limited when a user - space vendor - dependent library ( such as dri ) is saved as part of the application , and the application is then restarted under another vendor s graphics hardware . both approaches could unload the old library and load a new library at the time of restart . this issue does not arise in virtual machines for which the user - space vendor - dependent library may be eliminated through paravirtualization .    there is also a rich literature concerned with extending virtual machine support to include run - time access from within the virtual machine to hardware - accelerated graphics .",
    "vmgl  @xcite also appears to have been the first example in this area . to date , aside from vmgl , none of these approaches provide the ability to checkpoint and restore the state of the hardware - accelerated graphics .",
    "several open source or free packages , including wiregl  @xcite ( since incorporated into chromium  @xcite ) , virtualgl  @xcite , apitrace  @xcite provide support for extending opengl and other 3d graphics apis , so that calls to the graphics api for a client within the guest o / s of the virtual machine are passed on to a graphics server outside of the virtual machine .",
    "this external graphics server is often part of a host virtual machine , but other schemes are available , including passing graphics commands across a network .",
    "schmitt present virtgl  @xcite for virtualizing opengl while preserving hardware acceleration .    among the solutions for providing virtual access to hardware - accelerated gpus",
    "are those of dowtyetal  @xcite ( vmware workstation and vmware fusion ) , with a virtualized gpu for access to the gpu of a host virtual machine .",
    "similarly , duato et al .",
    "@xcite have presented a gpu virtualization middleware to make remote gpus available to all cluster nodes .",
    "gupta  @xcite present gvim , which demonstrates access to nvidia - based gpu hardware acceleration from within the xen virtual machine .",
    "along similar lines , wegger  @xcite present virtgl .",
    "lin  @xcite present live migration of virtual machines across physical machines , while supporting opengl .",
    "finally , the approach of record - prune - replay has also been applied in the context of deterministic record - replay for a virtual machine . in that context ,",
    "one applies time slices and abstraction slices in order to limit the record log to those calls that do not reveal sensitive information to an unprivileged user .",
    "there are two larger questions that we wish to answer in this experimental evaluation .",
    "first , we measure the overhead of logging the opengl calls ( section  [ sec : logging ] ) , and also of periodically pruning the log ( section  [ sec : pruning ] ) to prevent the log from growing too large",
    ". these two forms of overhead are measured .",
    "second , in section  [ sec : pruning ] we measure the growth of the size of the log over a long - running graphics program , in order to verify that the size of the log approaches a plateau and does not grow excessively .",
    "finally , section  [ sec : ckptrestarttimes ] shows that checkpointing requires up to two seconds , even at the larger resolutions , while restarting requires up to 17  seconds .",
    "while the above results are concerned with a detailed analysis of opengl  1.5 , section  [ sec : opengl3experiments ] demonstrates that the same approach extends to opengl  3.0 .",
    "that section relies on pymol ( molecular visualization ) for real - world testing .",
    "-10pt    the detailed testing for opengl  1.5 relies on ioquake3  @xcite , the well - known open source game quake3 ( see figure  [ fig : ioquake - screen ] ) .",
    "ioquake3 is chosen due to its existing use as an open source benchmark  @xcite , and particularly for comparability with the use of vmgl  @xcite .",
    "the implementation of ioquake3 is described by stefyn  @xcite . for each of the experiments , we ran the freely available 60  second quake3 demo .",
    "[ [ configuration . ] ] configuration .",
    "+ + + + + + + + + + + + + +    the experiments were run on an 8-core intel core - i7 laptop computer with 8  gb of ram .",
    "the host operating system was a 64-bit version of ubuntu-13.10 with linux kernel  3.11 .",
    "for these experiments , we used an nvidia gt  650 m graphics card and the open - source nouveau driver based on mesa version  9.2.1 .",
    "dmtcp-2.0 was used for the plugin implementation .",
    "table  [ tab : performance ] shows the impact on the performance of ioquake3 at different resolutions when running under dmtcp . at higher resolutions , the time spent is dominated by the time in the gpu . in this case",
    "the overhead of recording calls to the log is negligible .    .",
    "[ tab : performance ] frames per second when running natively and under dmtcp for ioquake3 [ cols=\"^,^,^ \" , ]      to test the proposed approach with opengl  3.0 we used a widely - used open - source molecular visualization software , pymol  @xcite .",
    "figure  [ fig : pymol ] shows the application running a demonstration with different representations of a protein .",
    "we observe that the application runs with a 9% overhead on the frames - per - second because of the dmtcp plugin . the time to checkpoint , and the time to restart ( that includes replaying of the logs ) are 1.4  seconds , and 10  seconds , respectively .",
    "the performance overhead , and the restart times are better because of the opengl  3.0 features calls to shader processing units , which do more work for the same log entry by the plugin .     pymol screenshot ]",
    "a production - quality version of this software will be contributed to the dmtcp open source project for checkpoint - restart . in that version",
    ", the log of opengl calls will be stored in a binary format , instead of using ascii strings .",
    "two other enhancements will make it still faster .",
    "first , the program for pruning the log will be re - written in c , and made into a software module in the main executable .",
    "second , the log will be maintained in ram , instead of being stored as a file on disk .",
    "next , support for heterogeneous gpu architectures will be considered , in which the gpu on the restart machine is different from the gpu on the pre - checkpoint machine . see section  [ sec : limitations ] for a further discussion of this issue .    since software such as wiregl can be used as part of a larger rendering farm , and",
    "since dmtcp directly supports checkpointing of networks  @xcite , this work can be extended to support checkpointing over a cluster of gpu - enabled workstations for visualization .",
    "the work of vmgl  @xcite has already demonstrated the possibility of using wiregl  @xcite and a vnc implementation to render the 3d  graphics inside a virtual machine through transport to a gpu - enabled host .",
    "the same scheme could be applied in this approach .",
    "while vnc had used wiregl and tightvnc , it is currently possible to use either wiregl with a choice of vnc implementations , or else to use virtualgl  @xcite and its recommended pairing with turbovnc .",
    "support for direct3d under windows will be considered by running windows inside a virtual machine , and making use of the wined3d  @xcite library for translation of direct3d to opengl .",
    "the approach of this work will be extended to work with xlib .",
    "this will eliminate the need for supporting glut and sdl .",
    "furthermore , this will directly support all 2d  applications based on xlib .",
    "this improves on the current practice of using vnc to support checkpointing of 2d  graphics .",
    "this work shows feasibility for a record - prune - replay approach to checkpointing 3d  graphics for both opengl  1.5 and opengl  3.0 .",
    "checkpointing requires up to two seconds . while the current run - time overhead is high ( for example , 40% overhead for periodically pruning the log ) , this is attributed to the current inefficient representation of opengl calls in the log as ascii strings in a file on disk .",
    "a binary data representation is planned for the future .",
    "this will eliminate the need to do pruning in a second cpu core .",
    "previously , the only approach to transparently saving the state of gpu - accelerated opengl as part of checkpoint - restart was to use vmgl s shadow device driver along with a virtual machine snapshot .",
    "that approach was demonstrated for opengl through 78,000 lines of code . as an indication of the relative levels of effort , the current approach required only 4,500 lines of code for opengl  1.5 and and 6,500 lines in total .",
    "the current approach is implemented as a plugin that extends the functionality of the dmtcp checkpoint - restart package .",
    "this allows the graphics programs to be checkpointed directly , without the intervention of a virtual machine and its snapshot capability .",
    "we would especially like to thank james shargo for demonstrating that apitrace supports a record - replay approach , and then suggesting that although he did not personally have the time , we should pursue a record - prune - replay approach for checkpoint - restart .",
    "we would also like to thank andrs lagar - cavilla for his earlier discussions on the design and implementation of vmgl .",
    "finally , we would also like to thank daniel kunkle for his insights during an earlier investigation into the complexities of checkpointing opengl in  2008 , at a time when much of the software landscape was less mature .                    an efficient implementation of gpu virtualization in high performance clusters . in _ proc .",
    "of 2009 international conference on parallel processing _",
    "( berlin , heidelberg , 2010 ) , euro - par09 , springer - verlag , pp .  385394 .",
    "adaptive display algorithm for interactive frame rates during visualization of complex virtual environments . in _ proceedings of the 20th annual conference on computer graphics and interactive techniques _",
    "( new york , ny , usa , 1993 ) , siggraph 93 , acm , pp .",
    "247254 .",
    "pengl application live migration with gpu acceleration in personal cloud . in _ proceedings of the 19th acm international symposium on high performance",
    "distributed computing _",
    "( new york , ny , usa , 2010 ) , hpdc 10 , acm , pp ."
  ],
  "abstract_text": [
    "<S> providing fault - tolerance for long - running gpu - intensive jobs requires application - specific solutions , and often involves saving the state of complex data structures spread among many graphics libraries . </S>",
    "<S> this work describes a mechanism for transparent gpu - independent checkpoint - restart of 3d  graphics . </S>",
    "<S> the approach is based on a record - prune - replay paradigm : all opengl calls relevant to the graphics driver state are recorded ; calls not relevant to the internal driver state as of the last graphics frame prior to checkpoint are discarded ; and the remaining calls are replayed on restart . </S>",
    "<S> a previous approach for opengl  1.5 , based on a shadow device driver , required more than 78,000 lines of opengl - specific code . </S>",
    "<S> in contrast , the new approach , based on record - prune - replay , is used to implement the same case in just 4,500 lines of code . </S>",
    "<S> the speed of this approach varies between 80 per cent and nearly 100  per cent of the speed of the native hardware acceleration for opengl  1.5 , as measured when running the ioquake3 game under linux . </S>",
    "<S> this approach has also been extended to demonstrate checkpointing of opengl  3.0 for the first time , with a demonstration for pymol , for molecular visualization . </S>"
  ]
}