{
  "article_text": [
    "cographs have been defined independently by several authors since the 1970 s and are usually defined as @xmath4-free graphs , as proved in @xcite .",
    "the original definition of cograph is based on a recursive construction described as follows : any single vertex graph is a cograph ; if @xmath5 is a cograph , so is its complement graph @xmath6 ; if @xmath5 and @xmath7 are cographs , so is their disjoint union . the _ disjoint union _ @xmath8 of graphs @xmath9 and @xmath10 is a graph operation such that @xmath11 and @xmath12 .",
    "cographs can be defined alternatively in the following way .",
    "the _ join _",
    "@xmath13 of @xmath9 and @xmath10 is an operation such that @xmath11 and @xmath14 .",
    "note that @xmath15 .",
    "one can obtain a structural decomposition of a cograph by means of the operations _ join _ and _ disjoint union _ , as follows .",
    "in @xcite a special tree , called _ cotree _ , is used to represent a cograph @xmath5 , in which leaf nodes are associated with the vertices of @xmath5 , and each internal node is labeled 0 ( _ type-0 node _ ) or 1 ( _ type-1 node _ ) indicating operations of join or disjoint union on their children , respectively .",
    "furthermore , every cotree must be such that the nodes in a root - leaf path have alternate labels , which ensures that each cograph is associated with only one cotree ( up to permutation of siblings ) . on the other hand , each cotree refers to a single cograph .",
    "as cographs can be identified by cotrees , given a rooted tree @xmath16 we use the following notation .",
    "the root of @xmath16 is denoted by @xmath17 . given a node @xmath18 ( other than the root ) , we denote by @xmath19 the only path from @xmath18 to the root .",
    "the nodes of @xmath19 ( except @xmath18 ) are named _",
    "ancestors _ of @xmath18 in @xmath16 . the immediate ancestor of @xmath18 in @xmath19",
    "is called the _",
    "parent _ of @xmath18 and denoted by @xmath20 .",
    "we set @xmath21 .",
    "if @xmath18 is an internal node , its _ children _ are the elements of the set @xmath22 . if @xmath23 , its _ siblinghood _ is the set @xmath24 .",
    "define also @xmath25 .",
    "we denote by @xmath26 the subtree of @xmath16 rooted at @xmath18 containing all the nodes @xmath27 for which @xmath18 is an ancestor of @xmath27 . when there is no ambiguity we omit the index @xmath16 from the above definitions . if two graphs @xmath9 and @xmath10 are isomorphic we write @xmath28 .",
    "in @xcite the authors prove that given two leaves @xmath18 and @xmath27 of a cotree , the closest ancestor to both ( that is common to @xmath19 and @xmath29 ) is type-1 if and only if @xmath18 and @xmath27 are adjacent in the associated cograph .",
    "hence a cograph is connected if and only if the root of the cotree is type-1 .    in the context of enumerative combinatorics , the work @xcite gives an asymptotic approximation for the number of cographs with a given number of vertices .",
    "another approach consists of the generation of _ all _ graphs with a given property ( e.g. , `` cographs with @xmath0 vertices '' ) .",
    "observe that this kind of approach provides , as a by - product , the exact number of graphs satisfying the given property .",
    "formally , a _ generation _ ( or _ enumeration _ ) algorithm @xmath30 generates the sequence @xmath31 of all graphs satisfying a required property @xmath32 , where @xmath33 for @xmath34 .",
    "there are some alternative definitions of efficiency for generation algorithms  @xcite , the weakest one being _ polynomial total time _ , i.e. , the total running time is polynomial in the combined size of @xmath35 .",
    "the strongest definition is _ polynomial delay _ , which means that the time between the generation of two consecutive elements is polynomial only in the size of the next output element",
    ". some important examples of enumeration algorithms with polynomial delay are the generation of all minimum spanning trees  @xcite , all maximal independent sets  @xcite , and all cycles of a graph  @xcite . in  @xcite ,",
    "the author describe sufficient conditions that guarantee linear delay generation of certain structures of a graph @xmath5 .",
    "more precisely , the author proves the following theorem : if @xmath36 is a family of graphs of bounded tree - width then for every monadic second - order formula @xmath37 , where @xmath38 are the free set variables in @xmath39 , there is an algorithm that takes as input an @xmath0-vertex graph @xmath5 in @xmath36 and generates with linear delay all the @xmath40-tuples of sets that satisfy @xmath39 in @xmath5 , after an @xmath41 preprocessing step .",
    "the formula @xmath39 can be interpreted as a query on @xmath5 with parameters @xmath38 .",
    "for instance , the result of the query @xmath42 , where @xmath43 , @xmath44 , and @xmath45 , is the collection of all pairs @xmath46 such that @xmath47 and @xmath48 are disjoint independent sets of @xmath5 .",
    "( in other words , the result of the query can be viewed as the collection of all induced bipartite subgraphs of @xmath5 . )",
    "motivated by the above discussion , in this work we develop an algorithm that generates all ( mutually nonisomorphic ) unlabeled cographs with @xmath0 vertices .",
    "say that two cotrees are _ isomorphic _ if they are associated with the same cograph . since a cotree is a compact representation of the associated cograph size representation of a cograph , because adjacency relations are implicit from the structure of cotrees .",
    "] , our algorithm in fact generates all mutually non - isomorphic cotrees with @xmath0 leaves , for a given positive integer @xmath0 .",
    "the delay of our algorithm ( time spent between two consecutive outputs ) is @xmath1 .",
    "the time needed to generate the first output is also @xmath1 , which gives an overall @xmath2 time complexity , where @xmath3 is the number of unlabeled cographs with @xmath0 vertices .",
    "the algorithm avoids the generation of duplicates ( isomorphic outputs ) and produces , as a by - product , a linear ordering of unlabeled cographs with @xmath0 vertices . to the best of the authors knowledge ,",
    "this is the first explicit description of a linear - delay cograph generation algorithm .",
    "since each output element is associated with a cograph with exactly @xmath0 vertices , the @xmath1 delay attained by our algorithm is best possible in practice .",
    "the remainder of this work is organized as follows . in sections 2 and 3 ,",
    "we define and study special orderings of nodes and trees using concepts of integer partitions . in section 4",
    ", we describe our cograph generation algorithm and discuss its complexity and correctness .",
    "section 5 contains our conclusions .",
    "as discussed above , any path in a cotree alternates the types of its nodes ; thus they are only determined by the type of the root .",
    "let @xmath49 be the set of rooted trees where each internal node has at least two children .",
    "then each element of @xmath50 refers to exactly two distinct cographs : one with a type-1 root and another with a type-0 root , unless the tree consists only of the root ( and , in this case , represents the trivial graph ) . on the other hand , each cograph",
    "is associated with a single tree of @xmath50 , up to permutation of nodes in the same siblinghood . in the next paragraphs",
    "we introduce a standard way to configure such a tree .    for @xmath51 and each node @xmath18 of @xmath16",
    "we define @xmath52 as the number of leaves of @xmath26 . if @xmath18 is a leaf , @xmath53 .",
    "a tree is said _ labeled _ if each node @xmath18 in @xmath16 is labeled @xmath52 .",
    "figure  [ fig : ordered - tree ] shows an example of labeled tree .",
    "[ fact : sum - of - children ] if @xmath18 is an internal node then @xmath54 .",
    "let @xmath55 , and consider the partition @xmath56 .",
    "notice that each cograph with @xmath0 vertices can be represented by a tree in @xmath57 .",
    "the fact below is straightforward and will be useful to calculate the complexities of the algorithms .",
    "[ fact : number - of - internal - nodes ] for each @xmath0 the number of nodes of a tree in @xmath57 is at most @xmath58 .",
    "facts  [ fact : sum - of - children ] and  [ fact : number - of - internal - nodes ] guarantee that labeling a tree can be done in @xmath1 .    the notion of _ integer partition _ was introduced by euler . in this work",
    "we assume that a partition must have at least two components , as described below .",
    "[ def : particao ] let @xmath59 be a positive integer . the _ integer partition _ of @xmath0 is a non - decreasing sequence of positive integers @xmath60 such that @xmath61 and @xmath62 .",
    "the set of all partitions of @xmath0 is denoted by @xmath63 .",
    "we will use a _ lexicographic ordering _ of partitions .",
    "[ def : ordenacaoparticao ] given distinct elements @xmath64 , where @xmath65 and @xmath66 , let @xmath67 , where @xmath68 . if @xmath69 then @xmath70 , otherwise @xmath71 .    as definition [ def : ordenacaoparticao ]",
    "is based on comparison of integers , the law of trichotomy applies to partitions :    [ fact : trichotomy - partitions ] if @xmath72 then exactly one of the following holds : @xmath70 , @xmath73 , or @xmath71 .",
    "the elements of @xmath74 listed in increasing order are : @xmath75    [ fact : min - and - max - partitions ] the minimum element of @xmath63 is @xmath76 , and the maximum is @xmath77 .",
    "it is useful for our purposes to relate partitions of integers with distribution of siblinghoods in a tree .",
    "let @xmath51 , and assume that for every internal node @xmath18 of @xmath16 its children @xmath78 are such that @xmath79 .",
    "we say that @xmath80 is the _ partition induced by _",
    "@xmath18 _ in _ @xmath16 .",
    "[ def : nodes - inequality ] let @xmath81 , and let @xmath82 two nodes of @xmath16 .",
    "define an order relation on the nodes of @xmath16 recursively as follows :    * case 1 : if @xmath83 then @xmath84 ; * case 2 : if @xmath85 then @xmath86 ; * case 3 : if @xmath87 , @xmath88 * * let @xmath89 , and let @xmath90 be the partition induced by @xmath18 in @xmath16 .",
    "analogously , let @xmath91 , and let @xmath92 be the partition induced by @xmath27 in @xmath16 . consider the following subcases : * * case 3.1 : if @xmath93 then @xmath84 ; * * case 3.2 : if @xmath94 @xmath95and , consequently , @xmath96 @xmath97 * * * case 3.2.a : if @xmath98 for all @xmath99 then @xmath86 ; * * * case 3.2.b : otherwise , let @xmath100 . if @xmath101 + then @xmath84 else @xmath102 .",
    "if @xmath86 we will say that @xmath18 and @xmath27 are _ equivalent _ , which allows us to write the equivalence class @xmath103=\\{u \\in v(t)\\mid u\\equi v\\}$ ] . also , we use the following notation : ( a ) @xmath104 if and only if @xmath86 or @xmath84 ; ( b ) @xmath105 if and only if @xmath106 .    it is worth noting that definition  [ def : nodes - inequality ] can be easily extended to nodes @xmath18 and @xmath27 in different trees @xmath107 and @xmath108 ( simply consider an auxiliary tree with a new root @xmath109 with subtrees @xmath110 and @xmath111 ) .",
    "from fact  [ fact : trichotomy - partitions ] , we have :    _ ( node trichotomy ) [ fact : trichotomy - nodes ] if @xmath82 are nodes of a tree @xmath51 then exactly one of the following holds : @xmath84 , @xmath86 , or @xmath105 . _    throughout the text , if we use the symbol of equality between nodes we are referring to the same node .    for two trees",
    "@xmath112 , write @xmath113 if they can be converted into identical trees by sibling permutations . definition [ def : nodes - inequality ] gives the intuitive idea that two nodes @xmath18 and @xmath27 are equivalent when @xmath114 .",
    "this is guaranteed by the following lemma :    [ lem : equality - isomorphism ] if @xmath82 are nodes of @xmath115 then @xmath114 if and only if @xmath86 .",
    "the proof is trivial when @xmath18 is a leaf .",
    "suppose @xmath18 is an internal node of @xmath16 and let @xmath90 be the partition induced by @xmath18 in @xmath16 , where @xmath89 and @xmath116 for @xmath117 .",
    "analogously , let @xmath92 be the partition induced by @xmath27 in @xmath16 , where @xmath91 .",
    "suppose @xmath114 .",
    "then @xmath118 and @xmath119 , for some integer @xmath120 .",
    "we use induction to prove that @xmath86 holds for every @xmath120 .",
    "the base case @xmath121 easily follows , since @xmath122 .",
    "now assume that @xmath86 holds for every @xmath123 .",
    "since @xmath114 , we can arrange siblings so that @xmath124 and @xmath125 for @xmath126 .",
    "thus , by the induction hypothesis , @xmath98 holds , which implies @xmath86 by case 3.2.a in definition  [ def : nodes - inequality ] .",
    "conversely , suppose that @xmath86 .",
    "then @xmath127 for some @xmath40 .",
    "we use induction on @xmath40 again to prove that @xmath114 .",
    "the result is valid for the base case @xmath128 .",
    "suppose now that it is valid for every @xmath123 .",
    "using node trichotomy , we have that @xmath98 for @xmath129 , with @xmath125 .",
    "thus , by the induction hypothesis , @xmath124 , i.e. , @xmath114 .",
    "[ def : ordered - tree ] let @xmath51 , and let @xmath18 be a node of @xmath16 .",
    "the siblinghood @xmath130 is said to be _ ordered _ if @xmath131 .",
    "if all the siblinghoods of a tree are ordered , we say that the tree is ordered .    the tree in figure  [ fig : ordered - tree ]",
    "is ordered .",
    "ordered trees establish a standard way to represent cotrees , as shown in the following proposition :    [ propo : cographs - and - trees ] each cograph is associated with a single ordered tree in @xmath50 .",
    "let @xmath5 be a cograph and let @xmath16 be its associated cotree .",
    "in  @xcite the authors prove that @xmath16 is unique up to isomorphism .",
    "let @xmath132 and @xmath133 be ordered trees , both isomorphic to @xmath16 . as the nodes of @xmath132 and @xmath133 have an order of arrangement , they are the same tree , up to permutation of _ equivalent _ nodes of the same siblinghood . but lemma  [ lem : equality - isomorphism ] ensures that this permutation generates identical subtrees with exactly the same arrangement of nodes",
    ". therefore @xmath132 and @xmath133 are identical .",
    "now we introduce a total ordering on trees of @xmath57 .",
    "[ def : ordering - trees ] let @xmath134 .",
    "define @xmath135 if @xmath136 , and @xmath137 if @xmath138 .",
    "[ fact : minimum - tree ] the minimum element of @xmath57 is the tree @xmath139 whose root induces the partition @xmath140 ( see fact  [ fact : min - and - max - partitions ] ) .",
    "this tree is associated with the graphs @xmath141 and @xmath142 .",
    "proposition [ propo : cographs - and - trees ] ensures that one can generate the unlabeled cographs with @xmath0 vertices by generating the elements of @xmath57 , whose first element is the minimum tree @xmath139 described in fact  [ fact : minimum - tree ] .",
    "based on the total order established in definition  [ def : ordering - trees ] , a way to generate all the elements of @xmath57 is to generate the tree @xmath108 which is _ immediately next _ to @xmath139 , and then the tree @xmath143 which is immediately next to @xmath108 , and so on , until the generation of the maximum tree in @xmath57 . the notion of immediately next element in a set equipped with a total order is formalized in the definition below .",
    "let @xmath144 be a non - empty , finite , and totally ordered set .",
    "given @xmath145 , we say that @xmath146 is the element _ immediately next _ to @xmath147 in @xmath144 if @xmath148 , @xmath149 , and for any @xmath150 such that @xmath151 it holds that @xmath152 .",
    "if there no element immediately next to @xmath147 in @xmath144 then @xmath147 is the maximum element of @xmath144 .",
    "we now apply the above definition to the set @xmath63 . given a partition @xmath153 ,",
    "algorithm  [ alg : immediately - next - partition ] determines the partition immediately next to @xmath90 , if it exists , or decides that @xmath90 is the maximum partition in @xmath63 ( see fact  [ fact : min - and - max - partitions ] ) .",
    "@xmath154 @xmath92 immediately next to @xmath90 in @xmath63 , if it exists , or @xmath155 @xmath156 ; @xmath157 @xmath158 ; @xmath159 ; @xmath160 ;  @xmath161 ; * if * @xmath162 * then * @xmath163 ; * else * @xmath164 ; @xmath165 special case * if * @xmath166 * then * ; * else * @xmath167 ;    [ thm : next - partition - correctness ] if @xmath168 , algorithm  [ alg : immediately - next - partition ] returns the partition immediately next to @xmath147 . in case",
    "the algorithm returns , @xmath147 is the maximum element of @xmath63 .",
    "let @xmath169 .",
    "cases @xmath170 and @xmath165 are trivial .    by definition of partition , necessarily @xmath171 .",
    "suppose @xmath172 and @xmath173 .",
    "consider the following cases :    _ case 1 _ : @xmath174 .    in this case , the algorithm returns the partition @xmath175 , where @xmath176 for @xmath177 and @xmath178 .",
    "clearly , @xmath149 and @xmath179 .",
    "we prove that @xmath146 is the partition immediately next to @xmath147 .",
    "let @xmath180 such that @xmath151 .",
    "our aim is to prove that @xmath152 . by definition",
    "there is a minimum index @xmath181 such that @xmath182 .    if @xmath183 then @xmath184 , and it follows that @xmath185 .",
    "if @xmath186 then @xmath187 for @xmath188 and @xmath189",
    ". thus , @xmath190 .",
    "also , note that @xmath191 has @xmath192 terms , otherwise we would have @xmath193 .",
    "this implies @xmath194 , which is a contradiction .",
    "therefore , @xmath195 and this implies @xmath196 , that is , @xmath197 .    finally , if @xmath198 then @xmath194 , which is a contradiction .",
    "hence , @xmath152 .",
    "_ case 2 _ : @xmath199 .",
    "in this case , lines 6 and 7 generate the partition @xmath200 , where @xmath176 for @xmath188 , @xmath201 , and @xmath202 .",
    "notice that @xmath203 , and then @xmath204 . let @xmath205 and @xmath109 be the quotient and the rest , respectively , of the integer division of @xmath206 by @xmath207 ( line 8) .",
    "we have two sub - cases to consider :    _ case 2a _ : @xmath162 .    in this case",
    ", the algorithm returns the partition @xmath208    note that @xmath209 has @xmath210 terms .",
    "note also that :    * \\(a ) @xmath211 , if @xmath177 ; * \\(b ) @xmath212 , if @xmath213 ; * \\(c ) @xmath214 .",
    "thus :    @xmath215    therefore @xmath216 and @xmath217 .",
    "we prove that @xmath209 is immediately next to @xmath147 in @xmath63 .",
    "let @xmath218 such that @xmath151 , and let @xmath181 be the minimum index such that @xmath182 .",
    "if @xmath183 then @xmath219 , i.e. , @xmath220 .    if @xmath186 then @xmath189 , i.e. , @xmath221 .",
    "thus , @xmath222 .    finally , if @xmath198 then @xmath194 , which is a contradiction . thus @xmath222 .",
    "_ case 2b _ : @xmath223 .",
    "in this case the algorithm returns the partition @xmath224 . since @xmath225 , we have @xmath149 .    again , we prove that @xmath146 is immediately next to @xmath147 in @xmath63 .",
    "let @xmath218 such that @xmath151 , and let @xmath181 be the minimum index such that @xmath182 .",
    "if @xmath183 then @xmath226 , i.e. , @xmath185 .    if @xmath186 then @xmath189 , i.e. , @xmath227 .",
    "thus , @xmath152 .    finally , if @xmath198 then @xmath228 , a contradiction . thus @xmath152 .    to conclude the proof , if @xmath172 and @xmath229 then the algorithm returns .",
    "[ coro : next - partition - complexity ] let @xmath168 .",
    "then @xmath230 runs in @xmath1 time .",
    "the only case that does not have a constant - time complexity appears in line 9 , whose worst case occurs when the input is @xmath231 . in such a situation , @xmath232 and the number of operations performed is @xmath233 .    in order to develop a procedure for determining the tree immediately next to the current tree being generated , we introduce the concept of _ pivot node _ , which indicates the place of the current tree where changes will be made .",
    "let @xmath81 be an ordered tree .",
    "a node @xmath18 of @xmath16 is said to be _ exhausted _ if it is a leaf or the partition induced by @xmath18 in @xmath16 is the maximum element of @xmath234 .",
    "[ fact : exhausted - node ] given an ordered and labeled tree @xmath235 , verifying whether a node @xmath18 of @xmath16 is exhausted can be done in constant time ( see fact  [ fact : min - and - max - partitions ] ) .    for an ordered tree @xmath236",
    "we define the _ inverted post - order traversal _ of @xmath16 by the following recursive procedure : if @xmath237 , traverse ( in the given sequence ) the subtrees @xmath238 in inverted post - order , and then visit @xmath17 .",
    "the inverted post - order traversal can be done in @xmath1 time , by fact  [ fact : number - of - internal - nodes ] .",
    "[ def : tree - pivot ] let @xmath51 be an ordered tree such that the inverted post - order traversal of @xmath16 visits its nodes in the sequence @xmath239 , where @xmath240 .",
    "the _ pivot _ of @xmath16 , if it exists , is the node @xmath241 with minimum index such that @xmath241 is not exhausted .",
    "the square node in figure  [ fig : ordered - tree ] is the pivot of the tree .",
    "given an ordered and labeled tree @xmath235 , the procedure for determining the pivot of @xmath16 can be simply done using the definition . in other words , simply perform an inverted post - order traversal and check whether the current visited node is exhausted or not .",
    "we call this procedure @xmath242 . if there is no pivot in the tree , the procedure returns .",
    "[ fact : pivot - complexity ] the search for the pivot node in a tree @xmath115 can be done in @xmath1 time .",
    "another step towards our cograph generation algorithm is to describe a procedure that replaces a subtree @xmath26 of a given ordered @xmath115 by another subtree @xmath132 rooted at @xmath18 with the same number of leaves as @xmath26 .",
    "the procedure receives as input a node @xmath18 of @xmath16 and a partition @xmath243 , and replaces @xmath26 by a subtree @xmath132 such that @xmath244 , @xmath245 , and , for @xmath246 , @xmath116 and @xmath247 consists of @xmath248 leaves ( if @xmath249 ) .",
    "the procedure returns the new tree @xmath250 obtained from @xmath16 in this way .",
    "node @xmath18 of an ordered tree @xmath115 ; partition @xmath243 new tree @xmath250 obtained from @xmath16 where @xmath26 is replaced by a subtree @xmath132 such that @xmath90 is the partition induced by @xmath18 in @xmath132 replace the children of @xmath18 by @xmath78 such that @xmath90 becomes the partition induced by @xmath18 * if * @xmath249 * then * insert @xmath248 leaves as children of @xmath241 @xmath16    by fact  [ fact : sum - of - children ] , we have :    [ fact : rebuild - complexity ] let @xmath243 .",
    "then procedure @xmath251 runs in @xmath252 time .",
    "[ lem : maximum - tree - no - pivot ] a tree @xmath115 is the maximum element of @xmath57 if and only if @xmath16 contains no pivot node .",
    "suppose @xmath16 contains a pivot node @xmath18 such that the partition induced by @xmath18 in @xmath16 is @xmath253 .",
    "thus there is @xmath254 such that @xmath149 .",
    "let @xmath250 be the tree returned by @xmath255 .",
    "clearly , @xmath256 and therefore @xmath16 is not the maximum element of @xmath57 .",
    "the other direction is trivial .",
    "now we are able to describe the procedure that generates the tree immediately next to a given tree @xmath16 , which is crucial to our cograph generation algorithm .",
    "we use the following notation : let @xmath257 be the ordered siblinghood of a node @xmath18 .",
    "assume @xmath258 for some @xmath259 and define the sets @xmath260 and @xmath261 .",
    "note that @xmath262 is a partition of @xmath263 .    ordered and labeled tree @xmath235 @xmath264 such that @xmath132 is the tree immediately next to @xmath16 @xmath265 @xmath266 , where @xmath90 is the partition induced by @xmath18 @xmath267 @xmath268 * if * @xmath269 * then * copy subtree @xmath270 in @xmath271 * else * @xmath272 , where @xmath273 @xmath274 @xmath16 there is no immediately next tree    algorithm  [ alg : immediately - next - tree ] finds the tree pivot @xmath18 and the partition that is immediately next to the one induced by @xmath18 .",
    "next , it `` restarts '' each node @xmath27 visited during @xmath242 to the lowest possible configuration for @xmath27 .",
    "this idea is based on the fact that comparison between trees is done from left to right in each siblinghood , while the searching for the pivot occurs from right to left .",
    "figure  [ fig : next - tree ] depicts the tree immediately next to the tree depicted in figure  [ fig : ordered - tree ] .        before checking the correctness of algorithm  [ alg :",
    "immediately - next - tree ] , we prove the following lemma .",
    "[ lem : next - tree - keeps - ordering ] let @xmath115 be an ordered tree that is not the maximum element of @xmath57 .",
    "then the tree returned by @xmath275 is ordered .",
    "let @xmath132 be the tree returned by @xmath275 .",
    "note that @xmath264 because its number of leaves is the same as in @xmath16 .",
    "let @xmath18 denote the pivot of @xmath16 ( whose existence is guaranteed by lemma  [ lem : maximum - tree - no - pivot ] ) .",
    "denote its corresponding node in @xmath132 by @xmath276 ( line 5 ) . in general",
    ", for each @xmath277 in @xmath16 , denote by @xmath278 its corresponding node in @xmath132 , if it exists ( lines 9 and 10 ) .    for each @xmath278 ancestor of @xmath276 , we prove that the siblinghoods @xmath279 and @xmath280 are ordered .",
    "since other siblinghoods did not change , their orderings follow directly from the ordering of @xmath16 .",
    "moreover , by the same reason , the set @xmath281 is already ordered for each @xmath278 .",
    "then it remains to analyze the orderings of @xmath282 and @xmath283 .",
    "in fact , for every @xmath284 the following cases are valid :    1 .   if @xmath285 and @xmath286 then the operation in line 9 and lemma [ lem : equality - isomorphism ] guarantee @xmath287 .",
    "2 .   if @xmath288 and @xmath289 then the partition induced by @xmath290 is minimum in @xmath291 ( line 10 ) ; therefore , @xmath292 .",
    "thus in both cases the ordering of the nodes is maintained , i.e. @xmath293 is ordered .",
    "it remains to analyze the ordering of @xmath280 .",
    "write @xmath294 , where @xmath295 .",
    "similarly , write @xmath296 , where @xmath297 .    as the algorithm changes only the nodes of @xmath298 , the ordering of @xmath16 guarantees that @xmath299 is ordered .",
    "* claim : * @xmath276 is correctly positioned in @xmath280 .",
    "to prove the claim we need to show that @xmath300 . by theorem",
    "[ thm : next - partition - correctness ] and case @xmath301 of definition  [ def : nodes - inequality ] we have @xmath302 .",
    "but by the ordering of @xmath16 , @xmath303 is valid , and thus @xmath304 . on the other hand , if @xmath305 then by line 9 we have @xmath306 , otherwise @xmath307 and from line 10 and definition  [ def : nodes - inequality ] we have @xmath308 .",
    "hence , the claim follows .",
    "following the same analysis used for @xmath309 , we conclude that @xmath310 is also ordered , because both are handled by the operation in lines 9 and 10 .",
    "this fact and the above claim guarantee that @xmath280 is ordered .",
    "hence , the lemma follows .",
    "[ thm : next - tree - correctness ] let @xmath115 .",
    "if @xmath311 then @xmath16 is the maximum element in @xmath57 ; otherwise , @xmath275 returns the tree immediately next to @xmath16 in @xmath57 .",
    "if the procedure returns , the result is guaranteed by lemma  [ lem : maximum - tree - no - pivot ] .",
    "otherwise , let @xmath132 be the output of the algorithm .    since @xmath132 is ordered , we use lemma  [ lem : next - tree - keeps - ordering ] to compare @xmath16 and @xmath132 .",
    "let @xmath18 be the pivot of @xmath16 , and @xmath276 the node corresponding to @xmath18 in @xmath132 .",
    "as in the previous lemma , for each @xmath277 in @xmath16 we denote by @xmath278 its corresponding node in @xmath132 .",
    "* claim * : @xmath312 .    to prove the claim , first note that theorem  [ thm : next - partition - correctness ] and definition  [ def : nodes - inequality ] guarantee @xmath313 .",
    "if @xmath314 then it is clear that @xmath312 . otherwise we write @xmath315 and @xmath316 , where @xmath317 and @xmath318 . since the algorithm only makes changes to @xmath319 , we have @xmath320 for @xmath321 .",
    "hence , by case 3.2.b in definition  [ def : nodes - inequality ] , @xmath322 .",
    "let @xmath323 .",
    "write @xmath324 and @xmath325 , where @xmath326 and @xmath327 .",
    "similarly , we have @xmath328 for @xmath329 .",
    "then , since @xmath330 , by case 3.2.b in definition  [ def : nodes - inequality ] it follows that @xmath331 . in general ,",
    "the same argument can be successively applied to each ancestor @xmath277 of @xmath18 to conclude that @xmath330 .",
    "if @xmath332 then @xmath312 , and the claim follows .    now prove that @xmath132 is immediately next to @xmath16 in @xmath57 .",
    "initially , the algorithm takes the pivot @xmath18 of @xmath16 and builds @xmath276 , whose induced partition by line 5 is immediately next to the partition induced by @xmath18 .",
    "let @xmath277 be such that @xmath333 or @xmath277 is an ancestor of @xmath18 .",
    "then , for each @xmath334 , the algorithm builds @xmath335 as follows : if @xmath336 then @xmath290 is equivalent to @xmath278 ; if @xmath337 then @xmath338 is exhausted from the definition of pivot .",
    "therefore , @xmath338 is built so that it is the minimum node , as detailed below and similarly to the proof of the previous lemma :    1 .   if @xmath339 and @xmath286 then @xmath287 ( line 9 ) .",
    "2 .   if @xmath288 and @xmath289 then @xmath290 is built from the minimum partition @xmath291 ; therefore , @xmath292 ( line 10 ) .    since @xmath340 and @xmath341",
    ", it follows that @xmath331 . by the cases above , for each @xmath342 we have that @xmath343",
    "is exhausted in @xmath16 .",
    "moreover , @xmath344 is built so that it is the minimum node with @xmath345 leaves .",
    "hence , @xmath346 is immediately next to @xmath347 .",
    "as this argument applies to every ancestor @xmath277 of @xmath18 and to @xmath18 itself , it follows that @xmath132 is immediately next to @xmath16 in @xmath57 .",
    "[ coro : next - tree - complexity ] let @xmath115 .",
    "then algorithm @xmath275 runs in @xmath1 time .",
    "the worst case occurs when @xmath16 has a pivot other than @xmath17 .",
    "corollary  [ coro : next - partition - complexity ] together with facts  [ fact : pivot - complexity ] and  [ fact : rebuild - complexity ] ensure that all the operations outside the loop in lines 713 are done in @xmath1 time .    the * for * loop in lines 811 performs the operations in lines 1011 , for each @xmath348 . assume that @xmath349 .",
    "the worst case complexity of lines 811 occurs when @xmath350 and @xmath351 , and thus is given by @xmath352 ( recall fact  [ fact : sum - of - children ] ) .",
    "let @xmath353 be the path from the pivot to the root of the tree , where @xmath354 and @xmath355 .",
    "the * repeat * command in lines 713 executes the internal * for * loop in lines 811 for each @xmath277 of @xmath19 .",
    "then , using the idea developed in the previous paragraph , we conclude that : ( a ) for @xmath356 , the internal * for * loop in lines 811 is executed for every @xmath357 in @xmath358 total time , since @xmath359 ; ( b ) the runtime for @xmath360 , @xmath361 , is :    @xmath362    where @xmath363 is the complexity of the @xmath364 previous iterations .",
    "the process terminates when the last ancestor ( @xmath365 ) is reached .",
    "therefore , the overall time complexity of @xmath275 is @xmath366 .",
    "as discussed in the beginning of the previous section , the generation of the elements in @xmath57 can be done as follows : starting from the minimum tree @xmath139 in @xmath57 ( fact [ fact : minimum - tree ] ) , apply algorithm [ alg : immediately - next - tree ] to generate the tree immediately next to @xmath139 in @xmath57 , and successively repeat the application of the algorithm until reaching the maximum element of @xmath57 ( characterized by the absence of pivot ) . since the entire generation procedure starts with an ordered tree ( recall that @xmath139 is trivially ordered ) , lemma  [ lem : next - tree - keeps - ordering ] ensures that subsequent trees are all ordered as well , i.e.",
    ", there is no need of extra work to order trees along the generation .",
    "in addition , by corollary  [ coro : next - tree - complexity ] , each new generated tree is determined in @xmath1 time .",
    "based on such arguments , we present below a formal description of our cograph generation algorithm .",
    "let @xmath367 denote the family of all cographs , and consider the partition @xmath368 , where @xmath369 .",
    "below we establish a total order on the members of @xmath370 .",
    "first , note that any cotree @xmath16 with @xmath0 leaves can be viewed as a member ( ordered tree ) of @xmath57 , and therefore we can apply the total ordering in definition  [ def : ordering - trees ] to cotrees .",
    "[ def : cograph - ordering ] let @xmath371 , and let @xmath372 be their respective ordered cotrees .",
    "say that @xmath373 if @xmath374 @xmath375 , or @xmath376 @xmath137 , @xmath377 is type-1 , and @xmath378 is type-0 . in addition , say that @xmath379 if @xmath137 and @xmath377 and @xmath378 are of the same type .    from the above definition ,",
    "it is easy to see that @xmath373 implies @xmath380 . in adition , @xmath379 if and only if @xmath28 .    for @xmath115 , let @xmath381 ( resp . , @xmath382 ) be the cotree associated with @xmath16 by setting @xmath17 as a type-0 ( resp",
    ". , type-1 ) node .",
    "also , let @xmath383 and @xmath384 be the cographs associated with cotrees @xmath385 and @xmath386 , respectively .",
    "integer @xmath387 all cographs with @xmath0 vertices @xmath388 @xmath389 output @xmath390",
    "@xmath391 @xmath392    [ propo : corretude_geradorcografos ] let @xmath393 be an integer",
    ". then :    @xmath394 the sequence @xmath395 generated by algorithm  [ alg : cograph - generation ] contains all the cotrees with @xmath0 leaves ;    @xmath396 the associate sequence @xmath397 contains all the cographs with @xmath0 vertices , where no two graphs in @xmath398 are isomorphic ;    @xmath399 the delay of algorithm  [ alg : cograph - generation ] is @xmath1 ;    @xmath400 the time spent by algorithm  [ alg : cograph - generation ] to output the first element is @xmath1 .",
    "\\(a ) by theorem  [ thm : next - tree - correctness ] , the tree @xmath401 is immediately next to @xmath402 in @xmath57 . since the algorithm starts with the minimum tree and stops with the maximum tree in @xmath57 , the sequence @xmath403 determined by the algorithm contains all the elements of @xmath57 .",
    "therefore , the sequence @xmath395 generated by the algorithm contains all the cotrees with @xmath0 leaves .",
    "\\(b ) by item ( a ) , the associated sequence @xmath404 of cographs contains all the members of @xmath370 .",
    "now , note that the @xmath402 s are in increasing order according to definition  [ def : ordering - trees ] , and by lemma  [ lem : equality - isomorphism ] are pairwise nonisomorphic .",
    "hence , @xmath398 is in _ strictly _ increasing order according to definition  [ def : cograph - ordering ] .",
    "this implies that no two cographs in @xmath398 are isomorphic .",
    "\\(c ) by fact  [ fact : number - of - internal - nodes ] , each @xmath402 contains @xmath1 nodes ; hence , obtaining @xmath385 and @xmath386 from @xmath402 can be done in @xmath1 time .",
    "in addition , by corollary  [ coro : next - tree - complexity ] , @xmath405 runs in @xmath1 time .",
    "therefore , algorithm  [ alg : cograph - generation ] has delay @xmath1 .",
    "\\(d ) it is easy to see that @xmath139 can be determined in @xmath1 time .",
    "this implies that the time spent to output @xmath406 is @xmath1 .",
    "[ coro ] algorithm  [ alg : cograph - generation ] determines a linear order on @xmath370 .",
    "figure  [ fig : four - vertex - cographs ] depicts in increasing order all cographs with @xmath407 vertices generated by @xmath408 .",
    "based on the fact that a cotree is a compact , @xmath1 size representation of an @xmath0-vertex cograph , in this work we described an algorithm for generating all unlabeled cographs with @xmath0 vertices , via the generation of cotrees .",
    "the delay of our algorithm is @xmath1 and the time needed to generate the first output is also @xmath1 , yielding an overall @xmath2 time complexity , where @xmath409 . the algorithm avoids the generation of duplicates ( isomorphic outputs ) and produces , as a by - product , a total ordering of @xmath370 . to the best of the authors knowledge ,",
    "this is the first practical description of a linear - delay cograph generation algorithm .",
    "the algorithm was implemented in language @xmath410 and executed on an amd fx-6100 six - core processor at 3.30ghz with 8 gb of ram , running _",
    "windows 7 _ operating system .",
    "table  [ tab : number - of - cographs ] shows the values @xmath411 calculated by the algorithm , for @xmath412 .",
    "we remark that the results in table  [ tab : number - of - cographs ] agree with the results presented in  @xcite , for @xmath413 . in a future work",
    ", we will describe an application of our generation algorithm in the search of counter - examples for spectral graph theory conjectures on cographs .",
    "d. eppstein . representing all minimum spanning trees with applications to counting and generation .",
    "tech . rep .",
    "95 - 50 ( 1995 ) , univ . of california ,",
    "irvine , ca 92717 , dept . of information and computer science .",
    "available at http://www.ics.uci.edu/@xmath414eppstein/pubs/epp-tr-95-50.pdf .",
    "b. kimelfeld and y. sagiv .",
    "efficiently enumerating results of keyword search . proc . of the 10th international symposium dblp 2005 , trondheim , norway .",
    "_ lecture notes in computer science _ 3774 ( 2005 ) 5873 ."
  ],
  "abstract_text": [
    "<S> cographs have always been a research target in areas such as coloring , graph decomposition , and spectral theory . in this work </S>",
    "<S> , we present an algorithm to generate all unlabeled cographs with @xmath0 vertices , based on the generation of cotrees . </S>",
    "<S> the delay of our algorithm ( time spent between two consecutive outputs ) is @xmath1 . </S>",
    "<S> the time needed to generate the first output is also @xmath1 , which gives an overall @xmath2 time complexity , where @xmath3 is the number of unlabeled cographs with @xmath0 vertices . </S>",
    "<S> the algorithm avoids the generation of duplicates ( isomorphic outputs ) and produces , as a by - product , a linear ordering of unlabeled cographs wih @xmath0 vertices .    </S>",
    "<S> cographs , enumarative combinatorics , enumerative algorithms </S>"
  ]
}