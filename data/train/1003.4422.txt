{
  "article_text": [
    "there are many ways to shuffle a deck of cards .",
    "one of the most common is to split the deck into equal halves and then riffle or dovetail shuffle the cards back together , wherein the cards from the two halves interlace .",
    "a perfect shuffle of this type is one where the cards alternate perfectly between the two halves .",
    "there are two types of perfect shuffles , depending on which card ends up on top .",
    "these are called `` in '' and `` out '' shuffles and have been frequently described in the literature ( see , e.g.  @xcite or @xcite ) .    another way to think about this shuffling",
    "is we split the deck in two equal stacks and go through the stack from top to bottom using a rule about how to put the two cards into the newly shuffled stack . in and out",
    "shuffles correspond to the two rules where either we always put the card from the second half of the stack on top or we always put the card from the first half of the stack on top .    in this paper",
    "we start the examination of a new kind of shuffling where our rule is to set an order on the labeling of the cards ( we allow for labels to be used multiple times in the deck ) and we again go through from top to bottom but now we let the order of the labeling on the cards determine which one goes on top .",
    "that is , starting with @xmath5 cards with labels from the ordered list @xmath6 , divide the stack of cards into @xmath2 stacks of @xmath7 , then take the top card off of each stack , sort the @xmath2 cards ( according to the order of the labels , where if the labels agree then the order they are sorted is unimportant ) and add them to the new stack .",
    "an example of this is shown in figure  [ fig : sorting ] where the labels are @xmath8 and we let the heaviest weights `` sink down '' ( i.e. , go to the lower card height where we start counting from the top card down ) .     to the deck @xmath9 . ]",
    "equivalently , this is the same as starting out with a list of @xmath10 labeled objects , @xmath11 and putting this into a @xmath12 matrix where we proceed by filling up the rows left to right and top to bottom , @xmath13 now take this matrix and sort the elements in each _ column _ according to the ordering of the labels , @xmath14 and finally concatenate the columns to form the new list . @xmath15    as an example if we have @xmath16 and start with @xmath17 cards labeled @xmath18 ( where we again let the 3 labels be ordered @xmath19 ) then we have @xmath20 this process can be repeated and so we have @xmath21 and now we see we have a stack which will repeat itself every two shuffling steps , or in other words a _ periodic _ stack . a stack which returns to itself after one shuffling step will similarly be called a _ fixed _ stack .    in general",
    ", we can relate the shuffling to a directed graph where each of the possible @xmath22 stacks are the vertices and we put a directed edge between two vertices if shuffling one stack gives the other .",
    "since the outcome of our shuffling is uniquely determined by the order of the cards , each edge will only have one edge going out ( though it is possible many edges can go in ) .",
    "this immediately gives us the following .    given any stack of cards after applying the shuffling procedure finitely many times we will settle into a stack which is periodic under the shuffling .",
    "there now arise several natural questions .",
    "for example , how do we find fixed / periodic stacks ? what periods are possible ?",
    "how many periodic / fixed stacks are there ?",
    "how long does it take for a stack to settle into a periodic stack ?    in this paper we will answer some of these questions . in section  [ sec : cycles ]",
    "we will introduce a weight function on the subscripts and show how to use this to represent the shuffling by a poset structure . in section  [ sec : gcd ]",
    "we will show in the case when @xmath3 ( where @xmath0 ) the possible periods are all divisors of @xmath4 .",
    "in section  [ sec : posets ] we will show how to adopt the poset structures to find posets that generate all fixed and periodic stacks .",
    "finally , in section  [ sec : conclusion ] we will give some concluding remarks .",
    "we will throughout assume the number of cards is @xmath23 , where @xmath1 is the highest power of @xmath2 that divides @xmath24 , and @xmath25 is the size of the stacks we split @xmath24 into when shuffling . for simplicity we will focus on subscripts ,",
    "i.e. , @xmath26 means @xmath27 .",
    "the key to understanding this shuffling is looking at a column which will ( for some @xmath28 ) consist of the terms @xmath29 and after sorting will be sent to @xmath30 for example , returning to the case @xmath17 and @xmath16 then we get the following .        this shows , for example , @xmath31 in some order ( depending on the labels of the cards ) . to help us understand what is happening it is useful to weight the subscripts .",
    "a shuffling weight function on the subscripts is a map @xmath32 which satisfies the following two conditions for @xmath33 :    * @xmath34 . * @xmath35 .",
    "the first condition says the weight of the entries in the column and the weight of the entries in a block it maps to are equal .",
    "the second condition says the weights are distinct and increasing in a block ( and combined with the first condition says the weights of the column are also distinct ) .    as an example for @xmath17 and @xmath16 one possible weight function",
    "is given below .",
    "@xmath36 if we now take this weight function and replace all the entries in the above diagram with the corresponding weights then our diagram now becomes the following ( for which it is easy to check the two conditions are satisfied ) .",
    "we can use this weight function to map the subscripts to the subscripts in a bijective manner so the weight is preserved .",
    "for instance in the third column we have @xmath37 .",
    "since @xmath38 , @xmath39 and @xmath40 then we would have @xmath41 , @xmath42 and @xmath43 .",
    "repeating this for each column / block combination we can now break up the elements of @xmath44 into cycles , and we can place these cycles into a poset structure where the height of a cycle is the weight of a subscript in the cycle ( by construction they are all equal ) .",
    "so for our particular weight function we would end up with three levels with the following cycles .",
    "this diagram essentially represents half of the shuffling ( i.e. , how we move from columns to blocks in the concatenation ) .",
    "we also need to represent the other half of the shuffling , which is sorting among the columns . to do this",
    "we add edges between levels in the diagram connecting any two subscripts which appear in the same column .",
    "doing this gives us the following diagram ( which we will refer to as the _ shuffling poset _ ) .",
    "the important part about the shuffling poset is that the higher ordered cards ( or by analogy heaviest cards ) will always try to `` sink down '' , i.e. , the highest label in a column will want to map to the smallest possible @xmath45 value which corresponds to the lowest level it can reach , the second highest label will similarly go to the second lowest level it can reach and so on . in particular , we have the following .",
    "shuffling can be carried out completely in the shuffling poset by placing the corresponding cards in their position and carrying out the following two steps :    * using only the edges _ between _ levels in the poset swap cards so no edge connects a higher ordered card at height ( or weight ) @xmath46 in the poset with a lower ordered card at height ( or weight ) @xmath47 where @xmath48 . * using only the edges _ in _ the levels advance the card to the next entry .",
    "we now see that once we have a shuffling weight function we can generate the shuffling poset which completely describes the shuffling .",
    "we now show a shuffling weight function always exists by giving an algorithm which will generate one .",
    "* set @xmath49 and construct a @xmath50 array where the element in the @xmath51th entry of the array ( @xmath52 and @xmath53 is @xmath54 , where @xmath55 is the remainder when @xmath56 is divided by @xmath57 .",
    "* while there are still cells in the array which have not been crossed off do the following : * * construct a directed graph on the vertices @xmath58 by letting @xmath59 where @xmath60 is the column and @xmath61 is the @xmath62 entry in the _ lowest _ cell of column @xmath60 which has not been crossed out .",
    "( if all the cells in column @xmath60 have been crossed out then @xmath60 will be an isolated node . ) * * find all directed cycles in the graph that was constructed . for each edge in the directed cycle let @xmath63 , where @xmath64 comes from the cell that generated the edge . *",
    "* cross out all cells which were used to assign a weight .",
    "* * increase @xmath65 by @xmath66 .",
    "an example of the algorithm being carried out when @xmath67 and @xmath68 is shown in the appendix .",
    "( the reader is encouraged to try this algorithm out to generate the weight function for @xmath17 and @xmath16 given above and for @xmath69 and @xmath70 given in section  [ sec : conclusion ] . )",
    "the above algorithm generates a shuffling weight function .",
    "first let us observe that the algorithm will terminate so @xmath45 is a well defined function .",
    "this follows since each column is referred to exactly @xmath2 times and so if all of the entries in a column have been crossed out no edge will be directed towards it . in particular ,",
    "if we ignore isolated vertices then the directed graph generated in step 2i will have all vertices with outdegree @xmath71 and so it must contain at least one directed cycle ( in fact one directed cycle for each connected component )",
    ". therefore at every stage we will continue to cross out cells unless all cells have been crossed out so the algorithm will terminate .",
    "the first condition of a shuffling weight function ( that weights in the blocks match weights in the columns ) is satisfied because we are pulling out cycles .",
    "namely , if we look at a cell @xmath72 in the @xmath60th column , this can be understood as the subscript @xmath64 will be placed into the @xmath62th column ( when shuffling ) .",
    "what we need is to make sure there is some subscript which will go into the @xmath60th column that also will be assigned the same weight .",
    "but this happens because we assign the entire directed cycle the same weight and by step 2ii the vertex preceding @xmath60 will give a subscript that maps into the @xmath62th column .",
    "the second condition of a shuffling weight function ( that weights in each block are increasing ) is easily satisfied since the blocks form the columns of the array generated in step 1 , and in columns the weights assigned to the cells are increasing ( since in each round at most one cell in each column will be assigned the current weight . )",
    "the algorithm used the lowest cell which had not been crossed out .",
    "we could also have used the highest cell which was not crossed out and then decreased the weight by @xmath71 .",
    "this will essentially generate the same picture ( where we rotated the arrays by @xmath73 and let @xmath74 in the entries and in the directed graphs generated in step 2i of the algorithm .",
    "another important thing to note is the directed cycles we are pulling out are the same directed cycles ( but with the @xmath62 terms replaced by the @xmath64 terms from the corresponding cells ) found in the shuffling poset .",
    "if we combine this with the previous idea of going from bottom to top we get the following observation .    in the shuffling poset @xmath26 if and only if @xmath75 .",
    "something else worth noting is that if we look at the shuffling weight function produced in the appendix we see there is some symmetry , i.e. , @xmath76 is independent of @xmath46 .",
    "so for example we have @xmath77 .",
    "when this happens we will call this a _ symmetrical _ weight function .    the shuffling weight function produced by",
    "the algorithm is symmetric .",
    "it is easy to show a symmetric weight function always exists for every @xmath24 and @xmath2 . for instance let @xmath78 be the weight function generated by the given algorithm ( where we use the lowest cells and work our way up ) and",
    "let @xmath79 be the weight function generated by the modified algorithm ( where we use the highest cells and work our way down ) .",
    "then the weight function @xmath80 is still a shuffling weight function and by the symmetry of the two algorithms will be symmetric .",
    "in the preceding section we saw that a weight function could be used to give us the shuffling poset , which in turn gives us another representation of how to shuffle .",
    "one natural question to ask is what can we say about the lengths of the directed cycles in the shuffling poset . in this section",
    "we will show in the special case when @xmath0 and @xmath3 this question has an easy answer . note",
    "this will cover all the cases when @xmath2 is a prime ( in particular @xmath81 ) .",
    "first , for @xmath3 we observe one shuffling weight function can be found using the base @xmath2 expansion of subscripts .",
    "[ lem : qk ] let @xmath82 with @xmath3 and let @xmath83 be the base @xmath2 expansion of @xmath84 .",
    "then @xmath85 is a shuffling weight function .",
    "let @xmath33 and @xmath86 be the base @xmath2 expansion of @xmath87 , and let the base @xmath2 expansion of @xmath7 be @xmath88 where @xmath89 is in the @xmath90th slot and @xmath91 ( this follows from @xmath25 ) .    in particular , for @xmath92 the base @xmath2 expansion of @xmath93 will be @xmath94 which has @xmath95 .",
    "on the other hand the base @xmath2 expansion of @xmath96 will be @xmath97 which has @xmath98 ( where @xmath99 is the remainder of @xmath100 when divided by @xmath101 ) . because @xmath102 then @xmath103 will cycle through all @xmath2 possibilities as @xmath46 goes from @xmath104 to @xmath105 .",
    "it follows the first condition of a shuffling weight function is satisfied .",
    "the second condition of a shuffling weight function is satisfied since the base @xmath2 expansion of @xmath93 for @xmath92 is @xmath106 and so @xmath107 from this it follows @xmath35 .",
    "one nice feature about this case is the the rule for mapping subscripts is easy to describe .",
    "namely , if the base @xmath2 expansion of @xmath84 is @xmath108 then the map is @xmath109 ( there are two things to check , one is that both these terms have the same weight and the other is that the column that contains @xmath84 will map to the block that contains @xmath110 , both conditions are easily checked . )    we will now use this map to determine the cycle lengths in the shuffling poset .",
    "[ thm : period ] let @xmath0 with @xmath111 , and let @xmath112 denote the multiplicative order of @xmath2 modulo @xmath100 . then the length of a cycle in the shuffling poset when we divide @xmath24 into @xmath2 equal stacks for shuffling is a divisor of @xmath4 .",
    "further , there is a cycle of length @xmath4 in the shuffling poset .",
    "before we begin we note by our assumption that @xmath113 and so the multiplicative order is well defined .",
    "as a check we note @xmath114 since @xmath115 , this agrees with the diagram given above for @xmath17 and @xmath16 .    consider a cycle starting at @xmath116 , and suppose that the base @xmath2 expansion of @xmath116 is @xmath117 .",
    "using we have after @xmath101 steps we will be at @xmath118 in particular , after we have taken @xmath101 steps , the last @xmath101 terms in the base @xmath2 expansion will agree with the last @xmath101 terms in the base @xmath2 expansion of @xmath116 .",
    "now suppose we repeat this @xmath119 times ( so a total of @xmath120 steps ) .",
    "then we have @xmath121 for some @xmath119 we will be back where we started if @xmath122 multiplying both sides by @xmath123 and simplifying this is equivalent to @xmath124 looking at the base @xmath2 expansion of @xmath116 we have @xmath125 for some @xmath126 , if we now substitute this in and simplify we get @xmath127 or @xmath128 since @xmath129 , if @xmath130 then @xmath131 and this condition is satisfied .",
    "in particular , after taking @xmath4 steps then @xmath132 for each value of @xmath116 , and so each cycle must be some divisor of @xmath4 .",
    "we are implicitly using @xmath133 . to see why this is true ,",
    "let @xmath134 then @xmath135 , and so @xmath136 but we also have in general @xmath137 combining these two statements we have @xmath138 showing @xmath101 is a divisor of @xmath134 .",
    "finally , to show there is a cycle of length @xmath4 we note also holds for @xmath139 , which corresponds to @xmath140 and @xmath141 .",
    "so reduces to finding the smallest value of @xmath120 so @xmath142 which is clearly @xmath130 .      the preceding weight function relied on having @xmath3 ( this",
    "was used in the lemma to make sure we hit all of the residue classes modulo @xmath2 , and then in the theorem  [ thm : period ] by giving a simple rule for mapping ) .",
    "we now present a weight function that works in more cases ( but from the definition it will agree with the previous weight function when @xmath3 ) . for example , the following weight function will work for the case when @xmath2 is any prime power .",
    "let @xmath82 with @xmath143 and let @xmath144 be the base @xmath2 expansion of @xmath84 .",
    "then @xmath145 is a shuffling weight function .    for @xmath28 let @xmath146 be the base @xmath2 expansion of @xmath87 .",
    "then for @xmath92 , the base @xmath2 expansion of @xmath93 is @xmath147 and so @xmath148 using this , we note the second condition for a shuffling weight function is easily satisfied .    since @xmath25 ,",
    "the base @xmath2 expansion of @xmath7 is @xmath149 .",
    "also we have @xmath150 , and so @xmath151 .",
    "so for @xmath92 the base @xmath2 expansion of @xmath152 is @xmath153 , i.e. , it agrees in the first @xmath154 slots with the expansion of @xmath87 , so we need to understand @xmath155 .    for a given value of @xmath46 we have @xmath156 .",
    "since @xmath157 is relatively prime to @xmath2 , this takes on @xmath158 different values that differ by a multiple of @xmath159 from @xmath160 ( modulo @xmath2 ) , and we will attain each one of these values @xmath159 times as @xmath161 ranges over its possible values . in particular we have , @xmath162 fix a possible value for @xmath163 and let @xmath164 be the first value of @xmath46 that gives us @xmath163 , and let @xmath165 be the value of @xmath166 for this corresponding @xmath46 . in particular , the only values of @xmath46 where we will be at the fixed value of @xmath163 are @xmath167 for @xmath168",
    ". for these values of @xmath161 we have @xmath169 ( the last step follows from noting @xmath170 and that when we divide this by @xmath159 all but the first two terms will have at least one factor of @xmath2 . )",
    "so we have @xmath171 since @xmath143 then this covers all of the residue classes modulo @xmath159 .",
    "combined with what we know about @xmath163 then we have @xmath172 so we have @xmath173 where @xmath47 which ranges over @xmath174 as @xmath46 ranges over @xmath174 .    the problem is even though we have a simple weight function , the rule for mapping is not simple , and so we have no similar result as theorem  [ thm : period ] .",
    "we note one of the results coming out of the proof of theorem  [ thm : period ] is when @xmath3 the cycle in the shuffle poset which contains @xmath71 has maximal length .",
    "this no longer needs to hold when @xmath175 .",
    "if we look at the example shown in the appendix , we can see the cycle which will contain @xmath71 has length @xmath176 but the maximal length of a cycle is @xmath177 .",
    "in section  [ sec : cycles ] we saw a way to represent our shuffling in terms of a poset of cycles .",
    "we will now exploit this poset to find stacks of cards which are fixed or periodic under shuffling .    to find the fixed stacks , we observe when looking at the cycles of the shuffling poset in a stack which is fixed under shuffling there are two necessary conditions :    * if there is an edge between levels in the shuffling poset then the label on the lower level must be at least as great as the label on the higher level .",
    "( otherwise we would swap labels and we would not be fixed . ) * all the labels in a cycle on a level in the shuffling poset must agree .",
    "( otherwise when we shift by one in the cycle the stack is not fixed . )",
    "it is easy to see that these conditions are also sufficient .",
    "we now form a poset , which we call the _ fixed poset _ , based off the shuffling poset .",
    "namely , each cycle goes to one element in the poset ( at the same height as before ) and we connect an edge between two corresponding cycles if one cycle contains @xmath178 while the other contains @xmath179 from the same column and there is no @xmath180 in the column with @xmath181 .",
    "( technically , by condition ( i ) above we would want to connect all cycles which are connected by an edge in the shuffle poset , but by transitivity we only need to consider edges which can not be broken down further . ) some examples of fixed posets are given in figure  [ fig : fixpo ] .",
    "using the two conditions , the fixed stacks are now found by assigning labeled cards to each element in the fixed poset so the labels are weakly increasing with respect to the fixed poset .",
    "this allows us to quickly and easily find fixed stacks for a given @xmath24 and @xmath2 .",
    "it also helps us to answer whether or not fixed stacks with some given property can exist .",
    "for example if @xmath182 and @xmath81 it is easy to see from the fixed poset there is no fixed stack with four labels each label with 13 cards ( i.e. , such as in a standard deck of cards with the labels being the suits in some order ) .    note the fixed posets in figure  [ fig : fixpo ]",
    "are symmetric in that if we flipped it upside down we would have the same poset",
    ". this will always happen when our weight function is symmetric ( and as already noted we can always find such a weight function ) .",
    "one question to consider is the number of fixed stacks .",
    "this is dependent on both the fixed poset and the number of labels . as an example , for a fixed @xmath2 and a fixed order of the labeling we can have dramatically different behavior for various values of @xmath24 .",
    "for example , suppose we have two labels @xmath183 and @xmath81 .",
    "if @xmath184 , then by theorem  [ thm : period ] all the cycles have length at most @xmath101 and there are @xmath185 levels in the fixed poset using the weight function given in lemma  [ lem : qk ] .",
    "we can then assign all of the cycles with height @xmath186 in the poset to have label @xmath71 and then take any collection of posets from the layer at height @xmath187 to have label @xmath71 .",
    "there are at least @xmath188 cycles on the @xmath187 level for some constant @xmath189 , and since we can take any subset of them and form a fixed stack then there are at least @xmath190 fixed stacks for @xmath184 ( in particular this is super - polynomial ) . by comparison if we consider @xmath191 , then it is easy to show it has a fixed poset of the following form .",
    "so in particular there are exactly @xmath192 fixed stacks for @xmath191 .    to make the comparison more concrete we have for @xmath193 there are @xmath194 fixed stacks , while for @xmath195 there are 128 fixed stacks .      when looking for periodic stacks we will again set up a poset , but instead of having cycles as elements in the poset we will have individual subscripts be the elements",
    "the basic idea is to consider what can keep a card at a given subscript from dropping down as we go through repeated shufflings ( because we are periodic the only operation that will happen as we shuffle is shifting the cycles ) . in particular",
    ", an element @xmath84 can only drop down if for some @xmath196 and some @xmath197 we have the following edges in our shuffling poset : @xmath198    in this case we need to make sure the card in @xmath196 will not cause the card in @xmath84 to sink . to do this",
    "we draw the poset where the elements are the subscripts ( as before we can place @xmath84 at level @xmath199 ) , and we connect an edge between @xmath84 and @xmath196 if we have the edges in our shuffling poset as indicated above _ and _ there is no @xmath180 in the same column as @xmath200 and @xmath201 so @xmath202 . we will call this the _ periodic poset_. an example of the situation is shown in figure  [ fig:1624 ] .    as before",
    ", the periodic stacks are now found by assigning labeled cards to each subscript in the periodic poset so the labels are weakly increasing with respect to the periodic poset .",
    "this allows us to quickly and easily find periodic stacks for given @xmath24 and @xmath2 .",
    "the possible periods of the periodic stacks are determined by the size of the cycles in the shuffling poset .",
    "namely , the possible periods are the divisors of the least common multiple of the cycle lengths in the shuffling poset . in the case when @xmath3 then theorem  [ thm : period ] shows the possible periods of stacks are divisors of @xmath4 , on the other hand it is easy to construct a periodic stack for any period dividing @xmath4 .",
    "we have seen how to find a weight function which can in turn allow us to represent our shuffling in a shuffling poset .",
    "this poset can then be modified to help us find fixed stacks , periodic stacks , and also tell us which periods are possible .",
    "one of the problems we have not addressed is how quickly a stack will settle into a periodic stack . as with the number of fixed stacks this depends highly on @xmath24 .",
    "for example , it is not hard to see ( i.e. , using the periodic poset ) that it takes no more than @xmath203 shuffles to settle into a periodic orbit ( where @xmath126 is the least common multiple of the cycle lengths and @xmath185 the number of levels in the shuffling poset ) .",
    "so for example when @xmath184 and @xmath81 then we need at most @xmath204 steps . on the other hand for @xmath205",
    "it is easy to construct a stack that takes exactly @xmath206 steps to get into a periodic stack .",
    "there are still many questions that remain .",
    "one of the biggest problems is trying to understand how the weight function works for arbitrary @xmath24 and @xmath2 .",
    "for instance the weight functions given in section  [ sec : gcd ] do not apply for the case @xmath69 and @xmath70 . in this case",
    "the algorithm for finding a weight function generates the following : @xmath207 \\begin{array}{||c||c|c|c|c|c|c|c|c|c|c|c|c|| } \\hline\\hline n&12&13&14&15&16&17&18&19&20&21&22&23\\\\ \\hline \\varphi(n)&1&2&3&4&7&8&2&3&4&5&8&9 \\\\",
    "\\hline\\hline \\end{array } \\end{array}\\ ] ]    one notable difference between this weight function and the weight function when @xmath3 or @xmath143 is that in the blocks the weight function does not consist of consecutive numbers , i.e. , it has gaps .",
    "determining why these gaps are there and where they will appear given @xmath24 and @xmath2 will go a long way to understanding the shuffling weight function .",
    "another important question in regards to the shuffling posets is understanding the possible cycle lengths .",
    "we understand what is going on for the case when @xmath3 , but all other cases remain open . for example , is it true the least common multiple of the cycle lengths is the length of the longest cycle ?    we can also consider what happens when instead of only considering a single type of shuffling we consider combining the @xmath208 different shuffling rules that come from all the possible rearrangements of the ordering of the labels . and of course , perhaps the most important thing missing right now is a good magic trick that can be performed using this shuffling rule , which was the original motivation of larry carter and j .- c .",
    "reyes who first suggested this problem !    99 persi diaconis , ron graham and william kantor , _ the mathematics of perfect shuffles _ , adv . in appl",
    "* 4 * ( 1983 ) , 175196 .",
    "s. brent morris , _ magic tricks , card shuffling and dynamic computer memories _ , maa spectrum , mathematical association of america , washington , d.c . , ( 1998 ) xviii + 148 pp .",
    "we implement the algorithm given in section  [ algo ] to find the weight function in the case @xmath67 and @xmath68 .",
    "the steps are shown below .",
    "the generated weight function is given in the following table .",
    "@xmath209 \\begin{array}{||c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|| } \\hline\\hline n&17&18&19&20&21&22&23&24&25&26&27&28&29&30&31\\\\ \\hline \\varphi(n)&2&3&4&2&3&4&5&3&4&5&6&4&5&6&7 \\\\ \\hline\\hline \\end{array } \\end{array}\\ ] ]"
  ],
  "abstract_text": [
    "<S> we consider a problem of shuffling a deck of cards with ordered labels . </S>",
    "<S> namely we split the deck of @xmath0 cards ( where @xmath1 is maximal ) into @xmath2 equally sized stacks and then take the top card off of each stack and sort them by the order of their labels and add them to the shuffled stack . </S>",
    "<S> we show how to find stacks of cards invariant and periodic under the shuffling . </S>",
    "<S> we also show when @xmath3 the possible periods of this shuffling are all divisors of @xmath4 . </S>"
  ]
}