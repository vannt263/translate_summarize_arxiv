{
  "article_text": [
    "argumentation has evolved as an important field in ai , with abstract argumentation frameworks ( afs , for short ) as introduced by dung  @xcite being its most popular formalization .",
    "several semantics for afs have been proposed ( see e.g.  @xcite for an overview ) , but here we shall focus on the so - called preferred semantics .",
    "reasoning under this semantics is known to be intractable @xcite .",
    "an interesting approach to dealing with intractable problems comes from parameterized complexity theory which suggests to focus on parameters that allow for fast evaluations as long as these parameters are kept small .",
    "one important parameter for graphs ( and thus for argumentation frameworks ) is tree - width , which measures the `` tree - likeness '' of a graph . to be more specific , tree - width",
    "is defined via a certain decomposition of graphs , the so - called tree decomposition .",
    "recent work @xcite describes novel algorithms for reasoning in the preferred semantics , such that the performance mainly depends on the tree - width of the given af , but the running times remain linear in the size of the af . to put this approach to practice",
    ", we shall use the _ sharp _ framework , a c++ environment which includes heuristic methods to obtain tree decompositions @xcite , provides an interface to run algorithms on these decompositions , and offers further useful features , for instance for parsing the input . for",
    "a description of the _ sharp _ framework , see @xcite .",
    "the main purpose of our work here is to support the theoretical results from @xcite with experimental ones .",
    "therefore we use different classes of afs and analyze the performance of our approach compared to an implementation based on answer - set programming ( see  @xcite ) .",
    "our prototype system together with the used benchmark instances is available as a ready - to - use tool from http://www.dbai.tuwien.ac.at / research / project / argumentation / dynpartix/.",
    "[ [ argumentation - frameworks . ] ] argumentation frameworks .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    an _ argumentation framework ( af ) _ is a pair @xmath0 where @xmath1 is a set of arguments and @xmath2 is the attack relation . if @xmath3 we say @xmath4 attacks @xmath5 .",
    "an @xmath6 is _ defended _ by a set @xmath7 iff for each @xmath8 , there exists a @xmath9 such that @xmath10 .",
    "an af can naturally be represented as a digraph .",
    "[ example : argumentation_framework ] consider the af @xmath0 , with @xmath11 and @xmath12 , @xmath13 , @xmath14 , @xmath15 , @xmath16 , @xmath17 , @xmath18,@xmath19 .",
    "the graph representation of @xmath20 is given as follows :    node[arg](a)@xmath4 + + ( 1,0 ) node[arg](b)@xmath5 + + ( 1,0 ) node[arg](c)@xmath21 + + ( 1,0 ) node[arg](d)@xmath22 + + ( 1,0 ) node[arg](e)@xmath23 + + ( 1,0 ) node[arg](f)@xmath24 + + ( 1,0 ) node[arg](g)@xmath25 ; ( a ) edge ( b ) ( c ) edge ( b ) ( d ) edge ( e ) ( f ) edge ( e ) ( g ) edge ( f ) ; ( c ) edge ( d ) ( d ) edge ( c ) ( e ) edge ( g ) ;    we require the following semantical concepts : let @xmath0 be an af .",
    "a set @xmath26 is ( i ) _ conflict - free _ in @xmath20 , if there are no @xmath27 , such that @xmath28 ; ( ii ) _ admissible _ in @xmath20 , if @xmath29 is conflict - free in @xmath20 and each @xmath30 is defended by @xmath29 ; ( iii ) a _ preferred extension _ of @xmath20 , if @xmath29 is a @xmath31-maximal admissible set in @xmath20 . for the af in example [ example : argumentation_framework ] , we get the admissible sets @xmath32 , and @xmath33 . consequently , the preferred extensions of this framework are @xmath34 .",
    "+ the typical reasoning problems associated with afs are the following : ( 1 ) credulous acceptance asks whether a given argument is contained in at least one preferred extension of a given af ; ( 2 ) skeptical acceptance asks whether a given argument is contained in all preferred extensions of a given af .",
    "credulous acceptance is @xmath35-complete , while skeptical acceptance is even harder , namely @xmath36-complete  @xcite .",
    "[ [ tree - decompositions - and - tree - width . ] ] tree decompositions and tree - width .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as already outlined , tree decompositions will underlie our implemented algorithms .",
    "we briefly recall this concept ( which is easily adapted to afs ) .",
    "a _ tree decomposition _ of an undirected graph @xmath37 is a pair @xmath38 where @xmath39 is a tree and @xmath40 is a set of so - called bags , which has to satisfy the following conditions : ( a ) @xmath41 , i.e.  @xmath42 is a cover of @xmath43 ; ( b ) for each @xmath44 , @xmath45 is connected ; ( c ) for each @xmath46 , @xmath47 for some @xmath48 .",
    "the width of a tree decomposition is given by @xmath49 .",
    "the _ tree - width _ of @xmath50 is the minimum width over all tree decompositions of @xmath50 .",
    "it can be shown that our example af has tree - width @xmath51 and next we illustrate a tree decomposition of width @xmath51 :    = [ rectangle , draw , rounded corners=2pt ] ( r)@xmath52 child node [ trd ] ( l1)@xmath53 child node [ trd ] ( l2)@xmath54 child node [ trd](r1)@xmath55 child node [ trd](r2)@xmath56 ;    dynamic programming algorithms traverse such tree decompositions ( for our purposes we shall use so - called normalized decompositions , however ) and compute local solutions for each node in the decomposition .",
    "thus the combinatorial explosion is now limited to the size of the bags , that is , to the width of the given tree decomposition .",
    "for the formal definition of the algorithms , we refer to @xcite .",
    "_ dynpartix _ implements these algorithms using the _ sharp _ framework @xcite , which is a purpose - built framework for implementing algorithms that are based on tree decompositions .",
    "figure [ fig : architectureofsharp ] shows the typical architecture , that systems working with the _ sharp _ framework follow . in fact , _ sharp _ provides interfaces and helper methods for the preprocessing and dynamic algorithm steps as well as ready - to - use implementations of various tree decomposition heuristics , i.e. minimum - fill , maximum - cardinality - search and minimum - degree heuristics ( cf .",
    "@xcite ) .",
    "= [ very thick , draw = black,>=latex ] ( a ) [ box ] parsing ; ( in ) at ( a ) [ above=9 mm ] ; at ( a ) [ above=9mm , right=4.5mm , anchor = south east ] input ; ( b ) [ right of = a , box ] preprocessing ; ( c ) [ right of = b , box]tree decomposition ; ( d ) [ right of = c , box]normalization ; ( e ) [ right of = d , box]dynamic algorithm ; ( out ) at ( e ) [ above=9 mm ] solutions ; ( in )  ( a ) node ; ( a )  ( b ) ; ( b )  ( c ) ; ( c )  ( d ) ; ( d ) ",
    "( e ) ; ( e )  ( out ) ;    _ dynpartix _ builds on normalized tree decompositions provided by _ sharp _ , which contain four types of nodes : leaf- , branch- , introduction- and removal - nodes . to implement our algorithms we just have to provide the methods and data structures for each of these node types ( see @xcite for the formal details ) . in short ,",
    "the tree decomposition is traversed in a bottom - up manner , where at each node a table of all possible partial solutions is computed .",
    "depending on the node type , it is then modified accordingly and passed on to the respective parent node .",
    "finally one can obtain the complete solutions from the root node s table .",
    "_ sharp _ handles data - flow management and provides data structures where the calculated ( partial ) solutions to the problem under consideration can be stored .",
    "the amount of dedicated code for _ dynpartix _  comes to around 2700 lines in c++ .",
    "together with the _ sharp _ framework ( and the used libraries for the tree - decomposition heuristics ) , our system roughly comprises of 13 000 lines of c++ code .",
    "currently the implementation is able to calculate the admissible and preferred extensions of the given argumentation framework and to check if credulous or skeptical acceptance holds for a specified argument .",
    "the basic usage of _ dynpartix _ is as follows :    .... > ./dynpartix [ -f < file > ] [ -s < semantics > ]           [ --enum | --count | --cred < arg > |",
    "--skept < arg > ] ....    the argument ` -f < file > ` specifies the input file , the argument ` -s < semantics > ` selects the semantics to reason with , i.e. either admissible or preferred , and the remaining arguments choose one of the reasoning modes .",
    "[ [ input - file - conventions ] ] input file conventions : + + + + + + + + + + + + + + + + + + + + + + +    we borrow the input format from the _ aspartix _ system  @xcite .",
    "dynpartix _ thus handles text files where an argument @xmath4 is encoded as arg(a ) and an attack @xmath57 is encoded as att(a , b ) .",
    "for instance , consider the following encoding of our running example and let us assume that it is stored in a file inputaf .    ....",
    "att(a , b ) .",
    "att(c , b ) .",
    "att(c , d ) .",
    "att(d , c ) .",
    "att(d , e ) .",
    "att(e , g ) .",
    "att(f , e ) .",
    "att(g , f ) .   ....",
    "[ [ enumerating - extensions ] ] enumerating extensions : + + + + + + + + + + + + + + + + + + + + + + +    first of all , _ dynpartix _ can be used to compute extensions , i.e. admissible sets and preferred extensions .",
    "for instance to compute the admissible sets of our running example one can use the following command :    ....   > ./dynpartix -f inputaf -s admissible ....    [ [ credulous - reasoning ] ] credulous reasoning : + + + + + + + + + + + + + + + + + + + +    _ dynpartix _ decides credulous acceptance using proof procedures for admissible sets ( even if one reasons with preferred semantics ) to avoid unnecessary computational costs .",
    "the following statement decides if the argument @xmath22 is credulously accepted in our running example .    ....",
    "> ./dynpartix -f inputaf -s",
    "preferred --cred d ....    indeed the answer would be _ yes _ as @xmath33 is a preferred extension .",
    "[ [ skeptical - reasoning ] ] skeptical reasoning : + + + + + + + + + + + + + + + + + + + +    to decide skeptical acceptance , _ dynpartix _ uses proof procedures for preferred extensions which usually results in higher computational costs ( but is unavoidable due to complexity results ) . to decide if the argument @xmath22 is skeptically accepted , the following command is used :    ....   > ./dynpartix -f inputaf -s preferred --skept d ....    here the answer would be _ no _ as @xmath58 is a preferred extension not containing @xmath22 .    [ [ counting - extensions ] ] counting extensions : + + + + + + + + + + + + + + + + + + + +    recently the problem of counting extensions has gained some interest  @xcite .",
    "we note that our algorithms allow counting without an explicit enumeration of all extensions ( thanks to the particular nature of dynamic programming ; see also @xcite ) . counting preferred extensions with _",
    "dynpartix _ is done by    ....",
    "> ./dynpartix -f inputaf -s preferred --count ....",
    "in this section we compare _ dynpartix _ with _ aspartix _",
    "@xcite , one of the most efficient reasoning tools for abstract argumentation ( for an overview of existing argumentation systems see @xcite ) . for our benchmarks we used",
    "randomly generated afs of low tree - width . to ensure that afs are of a certain tree - width we considered random grid - structured afs .",
    "in such a grid - structured af each argument is arranged in an @xmath59 grid and attacks are only allowed between neighbours in the grid ( we used a 8-neighborhood here to allow odd - length cycles ) . when generating the instances we varied the following parameters : the number of arguments ; the tree - width ; and the probability that an possible attack is actually in the af .",
    "the benchmark tests were executed on an intelcore2 cpu 6300@1.86ghz machine running suse linux version 2.6.27.48 .",
    "we generated a total of 4800 argumentation frameworks with varying parameters as mentioned above .",
    "the corresponding runtimes are illustrated in figure [ figure : benchmarks ] .",
    "the two graphs on the left - hand side compare the running times of _ dynpartix _ and _ aspartix _ ( using dlv ) on instances of small treewidth ( viz .  3 and 5 ) .",
    "for the graphs on the right - hand side , we have used instances of higher width .",
    "results for credulous acceptance are given in the upper graphs and those for skeptical acceptance in the lower graphs .",
    "the y - axis gives the runtimes in logarithmic scale ; the x - axis shows the number of arguments .",
    "note that the upper - left picture has different ranges on the axes compared to the three other graphs .",
    "we remark that the test script stopped a calculation if it was not finished after 300 seconds . for these cases",
    "we stored the value of 300 seconds in the database .",
    "[ [ interpretation - of - the - benchmark - results ] ] interpretation of the benchmark results : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we observe that , independent of the reasoning mode , the runtime of _ aspartix _ is only minorly affected by the tree - width while _ dynpartix _ strongly benefits from a low tree - width , as expected by theoretical results  @xcite .    for the _ credulous acceptance _",
    "problem we have that our current implementation is competitive only up to tree - width @xmath60 .",
    "this is basically because _ aspartix _ is quite good at this task .",
    "considering figures [ figure : benchmarks_a ] and [ figure : benchmarks_b ] , there is to note that for credulous acceptance _ aspartix _ decided every instance in less than 300 seconds , while _ dynpartix _ exceeded this value in 4% of the cases .",
    "now let us consider the _",
    "skeptical acceptance _ problem . as mentioned before , skeptical acceptance is much harder computationally than credulous acceptance , which is reflected by the bad runtime behaviour of _",
    "indeed we have that for tree - width @xmath61 , _ dynpartix _ has a significantly better runtime behaviour , and that it is competitive on the whole set of test instances . as an additional comment to figures [ figure : benchmarks_c ] and [ figure : benchmarks_d ] , we note that for skeptical acceptance , _ dynpartix _ was able to decide about 71% of the test cases within the time limit , while _ aspartix _ only finished 41% .",
    "finally let us briefly mention the problem of _ counting preferred extensions_. on the one side we have that _ aspartix _ has no option for explicit counting extensions , so the best thing one can do is enumerating extensions and then counting them .",
    "it can easily be seen that this can be quite inefficient , which is reflected by the fact that _ aspartix _ only finished 21% of the test instances in time . on the other hand",
    "we have that the dynamic algorithms for counting preferred extensions and deciding skeptical acceptance are essentially the same and thus have the same runtime behaviour .",
    "we identify several directions for future work .",
    "first , a more comprehensive empirical evaluation would be of high value .",
    "for instance , it would be interesting to explore how our algorithms perform on real world instances .",
    "to this end , we need more knowledge about the tree - width typical argumentation instances comprise , i.e.  whether it is the case that such instances have low tree - width . due to the unavailability of benchmark libraries for argumentation , so far we had to omit such considerations .",
    "second , we see the following directions for further development of _ dynpartix _ : enriching the framework with additional argumentation semantics mentioned in @xcite ; implementing further reasoning modes , which can be efficiently computed on tree decompositions , e.g. ideal reasoning ; and optimizing the algorithms to benefit from recent developments in the sharp framework ."
  ],
  "abstract_text": [
    "<S> the aim of this paper is to announce the release of a novel system for abstract argumentation which is based on decomposition and dynamic programming . </S>",
    "<S> we provide first experimental evaluations to show the feasibility of this approach . </S>"
  ]
}