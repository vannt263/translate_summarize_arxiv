{
  "article_text": [
    "the complexity theory allows us to rule out polynomial time algorithms for many fundamental optimization problems under the assumption @xmath13 . on the other hand , however , this does not give us ( non - polynomial ) lower bounds on the running time for such algorithms .",
    "for example , under the assumption @xmath14 , there could still be an algorithm with running time @xmath15 for 3-sat or bin packing . a stronger assumption , the exponential time hypothesis ( eth ) , was introduced by impagliazzo , paturi , and zane @xcite :    * exponential time hypothesis ( eth ) * : there is a positive real @xmath16 such that 3-sat with @xmath9 variables and @xmath0 clauses can not be solved in time @xmath17 .",
    "using the sparsification lemma by impagliazzo et al .",
    "@xcite , the eth assumption implies that there is no algorithm for 3-sat with @xmath9 variables and @xmath0 clauses that runs in time @xmath18 for a real @xmath19 as well . under the eth assumption ,",
    "lower bounds on the running time for several graph theoretical problems have been obtained via reductions between decision problems .",
    "for example , there is no @xmath20 time algorithm for 3-coloring , independent set , vertex cover , and hamiltonian path unless the eth assumption fails .",
    "an essential property of the underlying strong reductions to show these lower bounds is that the main parameter , the number of vertices , is increased only linearly .",
    "these lower bounds together with matching optimal algorithms of running time @xmath8 gives us some evidence that the eth is true , i.e. that a subexponential time algorithm for 3-sat is unlikely to exist .",
    "for a nice survey about lower bounds via the eth we refer to  @xcite .",
    "interestingly , using the eth assumption one can also prove lower bounds on the running time of approximation schemes . for example , marx @xcite proved that there is no ptas of running time @xmath21 for maximum independent set on planar graphs .",
    "there are only few lower bounds known for scheduling and packing problems .",
    "chen et al .",
    "@xcite showed that precedence constrained scheduling on @xmath0 machines can not be solved in time @xmath22 ( where @xmath23 is the length of the instance ) , unless the parameterized complexity class @xmath24 = fpt$ ] .",
    "kulik and shachnai @xcite proved that there is no ptas for the 2d knapsack problem with running time @xmath25 for sized subset sum with @xmath9 items and cardinality value @xmath26 .",
    "recently , jansen et al .",
    "@xcite showed a lower bound of @xmath27 and @xmath28 , respectively .",
    "in this paper , we consider the classical scheduling problem of jobs on identical machines with the objective of minimizing the makespan , i.e. , the largest completion time .",
    "formally , an instance @xmath29 is given by a set @xmath30 of @xmath0 identical machines and a set @xmath31 of @xmath9 jobs with processing times @xmath32 .",
    "the objective is to compute a non - preemptive schedule or an assignment @xmath33 such that each job is executed by exactly one machine and the maximum load @xmath34 among all machines is minimized . in scheduling theory , this problem is denoted by @xmath1 if @xmath0 is a constant or @xmath4 if @xmath0 is an arbitrary input .",
    "this problem is np - hard even if @xmath35 , and is strongly np - hard if @xmath0 is an input . on the other hand , for any @xmath36",
    "there is a @xmath37-approximation algorithm for @xmath1 @xcite and @xmath4 @xcite .",
    "furthermore , there is a long history of improvements on the running time of such algorithms , the reader may refer to the full version for the literature , and we mention that currently the best known fptas for @xmath1 has a running time of @xmath38 @xcite for sufficiently small @xmath39 ( e.g. , @xmath40 ) , and the best known ptas for @xmath4 has a running time of @xmath41 @xcite .",
    "exact algorithms for the scheduling problem are also under extensive research .",
    "recently lente et al .",
    "@xcite provided algorithms of running time @xmath42 and @xmath43 for @xmath44 and @xmath45 , respectively .",
    "oneil @xcite gave a sub - exponential time algorithm of running time @xmath46 for the bin packing problem with @xmath0 bins where @xmath23 is the length of the input , and it works also for @xmath1 .    the main contribution of this paper is to characterize lower bounds on the running times of exact and approximation algorithms for the classical scheduling problem .",
    "we prove the following .",
    "[ th : id - sche - linear ] for any @xmath19 , there is no @xmath47 time ptas for @xmath4 , unless eth fails .",
    "[ th : id - sche - number ] for any @xmath7 , there is no @xmath11 time exact algorithm for @xmath4 with @xmath9 jobs even if we restrict that the processing time of each job is bounded by @xmath10 , unless eth fails .",
    "[ th : sche - machine parameter ] for any @xmath19 , there is no @xmath3 time fptas for @xmath1 , unless eth fails .",
    "[ th : length of the input1 ] for any @xmath48 , there is no @xmath49 time exact algorithm for @xmath1 , unless eth fails . here",
    "@xmath23 is the length of the input .",
    "we also prove the traditional dynamic programming algorithm for the scheduling problem runs in latexmath:[$2^{o(\\sqrt{m|i|\\log m}+ m\\log    of running time .",
    "an overview about the known and new results for @xmath4 is in the table 1 .",
    ".lower and upper bounds on the running time [ cols=\"^,^,^\",options=\"header \" , ]     notice that in table [ fig : number huge ] we do not list variable - clause , variable - dummy and variable - assignment gaps , however , they contribute to the number of singular @xmath51 terms by @xmath52 for any @xmath53 .",
    "now we come to the proof of lemma [ le : regular well - cancel ] .",
    "we prove the lemma through induction .",
    "we first consider @xmath54-terms .",
    "a regular @xmath54-term of a gap could always be expressed as @xmath55 for @xmath56 .",
    "we start with @xmath57 .",
    "notice that a regular @xmath54-term comes from a variable - agent , layer - decreasing or agent - agent gap . according to table 5 ,",
    "the @xmath54-term of the other two jobs ( variable or agent jobs ) used to fill up such a gap are nonzero and at least @xmath58 , thus the regular term @xmath59 is well canceled .",
    "suppose for any @xmath60 , each regular term @xmath51 is well - canceled .",
    "we consider the case that @xmath61 . for any @xmath62 such that @xmath63 , there are in all @xmath64 variable or agent jobs whose @xmath54-term is @xmath51 ( see table  [ fig : number variable ] ) .",
    "we determine the scheduling of these jobs .    among them",
    "@xmath52 jobs are on used to cancel singular terms according to lemma [ le : singular well - cancel ] .",
    "meanwhile since there are @xmath65 gaps with regular terms @xmath66 ( see table  [ fig : number huge ] ) , the induction hypothesis implies that @xmath67 of these variable and agent jobs are used to cancel these regular terms .",
    "thus , we can conclude that for a regular @xmath54-term being @xmath68 , both of the @xmath54 term of the two jobs ( variable or agent jobs ) used to cancel it are at least @xmath69 .",
    "this implies , again , that the regular term @xmath68 is well - canceled .",
    "the proof for regular @xmath70-terms are the same .",
    "next we prove that in @xmath71 , every machine is satisfied . see figure [ fig : index - scheduling ] as an illustration of such a solution .",
    "obviously a variable - dummy machine ( gap ) is satisfied .",
    "[ le : theta_0 ^ 3 ] agent - agent machines ( gaps ) are satisfied .",
    "consider each agent - agent machine , say , @xmath72 .",
    "we can assume that the other two jobs on it are @xmath73 and @xmath74 .",
    "then according to lemma [ le : regular well - cancel ] , we have @xmath75    since @xmath76 , while @xmath77 , thus @xmath78 , @xmath79 .",
    "according to the construction of functions @xmath80 and @xmath81 ( see observation 3 ) , we know that @xmath82 and @xmath83 .",
    "we consider variable - clause machines .",
    "notice that for each @xmath84 and @xmath85 , either @xmath86 or @xmath87 exists .",
    "[ le : clause job with variable ] machine @xmath88 or @xmath89 ( @xmath90 ) is satisfied .",
    "the machine @xmath86 or @xmath87 for @xmath91 and @xmath85 is satisfied if :    * for @xmath92 , each machine @xmath93 or @xmath94 is satisfied . *",
    "all variable jobs @xmath95 with @xmath96 and @xmath97 are not scheduled on this machine .",
    "we consider clause @xmath98 . as @xmath99 contains three variables @xmath100 , @xmath101 and @xmath102 , there are three huge jobs @xmath103 , @xmath104 and @xmath105 where @xmath106 .",
    "meanwhile there are three clause jobs of @xmath107 .    for @xmath108 and",
    "any @xmath109 , suppose @xmath110 exists , and the two jobs together with it are a clause job @xmath111 and a variable job @xmath112 with @xmath113 . since @xmath114 , according to lemma [ le : r and delta equal ] , we have @xmath115 . if @xmath116 , then the left side is at least @xmath117 , while the right side is at most @xmath118 , which is a contradiction .",
    "thus @xmath119 and it follows directly that @xmath83 , @xmath120 .",
    "otherwise @xmath121 exists , and the proof is just similar .",
    "thus , machine @xmath110 or @xmath121 ( @xmath122 ) is satisfied .    when @xmath91 and @xmath123 , again we suppose that @xmath86 exists .",
    "notice that for any @xmath124 , @xmath125 contains three variables . according to the hypothesis , the three clause jobs @xmath111 are scheduled on three machines , they are @xmath126 or @xmath127 , @xmath128 or @xmath129 and @xmath130 or @xmath131 .",
    "thus when we consider machine @xmath86 , all clause jobs @xmath111 with @xmath132 could not be scheduled on this machine .",
    "again suppose that the two jobs scheduled together with @xmath86 are @xmath133 and @xmath95 , then @xmath134 .",
    "since @xmath135 and @xmath136 , if @xmath137 , then we have @xmath138 , which is a contradiction .",
    "thus @xmath139 , @xmath140 and @xmath120 , which means machine @xmath86 is satisfied .    similarly if @xmath87 exists , this machine is also satisfied .    [",
    "le : truth assignment with variable ] machines @xmath141 , @xmath142 , @xmath143 and @xmath144 are satisfied .",
    "moreover , machines @xmath145 ,",
    "@xmath146 , @xmath147 and @xmath148 for @xmath91 are satisfied if :    * machines @xmath149 , @xmath150 , @xmath151 and @xmath152 are satisfied for @xmath132 . *",
    "all variable jobs @xmath153 with @xmath154 and @xmath113 are not scheduled on these machines .",
    "consider machine @xmath141 . except the huge job ,",
    "let the other three jobs be @xmath155 ( @xmath113 ) , @xmath156 and @xmath157 .",
    "then we have @xmath158 it can be easily seen that @xmath159 and @xmath120 .",
    "thus , machine @xmath141 is satisfied . using similar arguments",
    "we can show that machines @xmath144 , @xmath143 and @xmath142 are satisfied .    the proof that machines @xmath145 , @xmath146 , @xmath147 and @xmath148 are satisfied for @xmath160 if two conditions of the lemma hold is the same .    for simplicity , we call variable jobs @xmath161 with @xmath162 and agent jobs @xmath163 with @xmath164 as jobs of index - level @xmath165 .",
    "in contrast , let @xmath166 , we call machine @xmath167 , @xmath168 , machine @xmath169 , machine @xmath170 , machines @xmath149 , @xmath151 , @xmath152 , @xmath150 as machines of index - level @xmath165 .    specifically , machine @xmath171 is of index - level @xmath165 and also of index - level @xmath26 , i.e. , this machine would appear in the set of machines with index - level of @xmath165 as well as the set of machines with index - level of @xmath26 .",
    "notice that according to lemma [ le : theta_0 ^ 3 ] these machines are already satisfied .",
    "[ le : each satisfy ] in @xmath71 , every machine ( gap ) is satisfied .",
    "we prove it through induction on the index - level of machines .",
    "we start with @xmath119 .    consider machine @xmath172 .",
    "we assume jobs @xmath173 and @xmath174 are on it .",
    "then simple calculations show that @xmath175    according to lemma [ le : regular well - cancel ] , @xmath176 .    since @xmath177",
    ", according to observation 3 we have @xmath178 .",
    "meanwhile @xmath179 , thus @xmath180 and @xmath119 .",
    "again , due to observation 3 we have @xmath181 .",
    "thus @xmath182 and @xmath183 are on machine @xmath172 , i.e. , this machine is satisfied .",
    "similarly we can prove that @xmath184 and @xmath185 are on machine @xmath186 .",
    "consider machine @xmath187 for @xmath188 .",
    "we assume jobs @xmath189 and @xmath190 are on it .",
    "then simple calculations show that @xmath191    according to lemma [ le : regular well - cancel ] , we have @xmath192 @xmath193 thus @xmath194    according to observation 3 , we have @xmath195 and @xmath196 .",
    "thus @xmath197 , @xmath198 .",
    "again due to observation 3 we have @xmath181 , i.e. , machine @xmath187 is satisfied .    similarly we can prove that machine @xmath199 for @xmath200 is also satisfied . for @xmath201 ,",
    "recall that there is a slight difference between @xmath202 and @xmath203 , we prove that machine @xmath202 is satisfied separately .",
    "consider @xmath202 and assume jobs @xmath204 and @xmath205 are on it . then @xmath206    according to lemma [ le : regular well - cancel ]",
    ", we have @xmath207 @xmath208 thus @xmath209 . similarly due to observation 3 we have @xmath210 , and @xmath211 .",
    "thus again we can prove @xmath181 , which implies that machine @xmath202 is also satisfied .",
    "combining lemma [ le : clause job with variable ] , lemma [ le : truth assignment with variable ] and lemma [ le : theta_0 ^ 3 ] , we have proved so far that each machine of index - level @xmath212 is satisfied .",
    "we further show that indeed , all the variable and agent jobs of index - level @xmath212 are on machines of index - level @xmath212 . to see why , see figure [ fig : sche - index1 ] for an overview of the scheduling of jobs of index - level 1 ( here case 1 means @xmath213 , while case 2 means @xmath214 ) .",
    "suppose that for any @xmath215 , each machine of index - level @xmath165 is satisfied and all the variable or agent jobs of index - level @xmath165 are on machines of index - level @xmath165 .",
    "we consider @xmath82 .",
    "according to lemma [ le : clause job with variable ] and lemma [ le : truth assignment with variable ] , we know that machines @xmath216 ( or @xmath217 ) for @xmath218 and machines @xmath145 , @xmath146 , @xmath147 , @xmath148 are satisfied .",
    "consider machine @xmath219 which is of index - level @xmath84 .",
    "again we may assume jobs @xmath173 and @xmath174 are on it , and the induction hypothesis implies that @xmath220 , @xmath221 .",
    "simple calculations show that @xmath222    according to lemma [ le : regular well - cancel ] , @xmath223 .",
    "since @xmath224 , according to observation 3 we have @xmath225 .",
    "meanwhile @xmath220 , thus @xmath226 and @xmath82 .",
    "we can conclude that @xmath227 .",
    "so , @xmath228 and @xmath229 are on machine @xmath219 , i.e. , this machine is satisfied .",
    "similarly we can prove that @xmath230 and @xmath231 are on machine @xmath232 .",
    "consider machine @xmath233 for @xmath188 .",
    "we assume jobs @xmath189 and @xmath190 are on it .",
    "then simple calculations show that @xmath234    according to lemma [ le : regular well - cancel ] , we have @xmath235 @xmath236 thus @xmath237    according to the hypothesis we know @xmath238 . due to observation 3 , we have @xmath239 and @xmath240 .",
    "thus @xmath241 , @xmath242 , which implies again that @xmath227 , i.e. , machine @xmath233 is satisfied .",
    "similarly we can prove that machine @xmath243 for @xmath244 is also satisfied ( again we need to prove machine @xmath245 is satisfied separately , and the proof is actually the same as the case when @xmath108 ) .",
    "the above analysis shows that each machine of index - level @xmath84 is satisfied .",
    "similar to the case when @xmath108 , we can further show that all the variable and agent jobs of index - level @xmath84 are on machines of index - level @xmath84 .",
    "a machine is called truth benevolent if one of the following three conditions holds .    * for a variable - agent , layer - decreasing or agent - agent machine , the two jobs ( variable or agent ) on it are one true and one false . * for a variable - clause machine , the variable and clause job on it are of the form @xmath246 , @xmath247 or @xmath248 . * for a variable - assignment machine , the variable and truth - assignment jobs on it are of the form @xmath249 or @xmath250 .",
    "we have the following lemma .    [",
    "le : truth benevolent ] in @xmath71 , every machine of is truth benevolent .",
    "consider a variable - agent , layer - decreasing or agent - agent machine",
    ". on each of these machines , the @xmath251-terms of the two ( variable or agent ) jobs should add up to @xmath252 according to lemma [ le : r and delta equal ] , thus the two jobs are one true and one false .",
    "consider a variable - clause machine .",
    "we check the @xmath251-terms of the clause , variable and dummy job . according to lemma [ le : r and delta equal ] , there are three possibilities that the three @xmath251-terms add up to @xmath253 , which are @xmath254 , @xmath255 and @xmath256 , thus the variable and clause jobs are always of the form @xmath246 , @xmath247 or @xmath248 .",
    "consider variable - assignment machines .",
    "we check the @xmath251-terms . except for the huge job , the @xmath251-terms of the variable job , @xmath257 or @xmath258 , @xmath259 or",
    "@xmath260 should add up to @xmath261 and thus there are only two possibilities , @xmath262 and @xmath263 , which implies that they are of the form @xmath249 or @xmath250 .",
    "now we come to the proof of lemma [ le : sche->3sat ] .",
    "we assign values to variables according to the variable - assignment machines . for each @xmath165 , consider the four machines , @xmath149 , @xmath150 , @xmath151 and @xmath152 .",
    "since the three jobs are @xmath250 or @xmath249 , thus @xmath264 is on the same machine with either @xmath265 or @xmath266 .",
    "if @xmath264 is scheduled with @xmath265 , then the jobs on the two machines with @xmath149 and @xmath150 are @xmath267 , @xmath268 .",
    "we let variable @xmath269 be false .",
    "otherwise @xmath264 is scheduled with @xmath266 , and the jobs on the two machines with @xmath151 and @xmath152 are @xmath270 and @xmath271 .",
    "we let variable @xmath269 be true .",
    "we show that every clause is satisfied .    for each @xmath272",
    ", there is one job @xmath273 , and it should be scheduled with a true variable job . if it is @xmath274 where @xmath275 or @xmath276 , then it turns out that @xmath269 is true because otherwise @xmath274 is already scheduled with @xmath264 and @xmath265 .",
    "notice that either machine @xmath277 or machine @xmath278 exists .",
    "since @xmath279 is scheduled with @xmath280 , machine @xmath278 does not exist because otherwise @xmath281 , instead of @xmath279 , is scheduled together with @xmath280 on this machine .",
    "thus the huge job @xmath277 exists , which means the positive literal @xmath269 appears in @xmath282 , thus @xmath282 is satisfied .",
    "otherwise it is @xmath283 , then it turns out that @xmath269 is false . as @xmath281 is scheduled with @xmath280 , they are together with @xmath278 , which means the negative literal @xmath284 appears in @xmath282 , and thus @xmath282 is satisfied .",
    "consider each @xmath285 .",
    "there is a huge job @xmath171 . as machine",
    "@xmath171 is satisfied and truth benevolent , @xmath73 and @xmath74 on this machine should be one true and one false according to lemma [ le : truth benevolent ] .",
    "suppose on machine @xmath171 , @xmath73 is false and @xmath74 is true .",
    "notice that there are two jobs , @xmath286 and @xmath287 .",
    "since @xmath287 is on machine @xmath171 , @xmath286 should be on machine @xmath288 , and thus on this machine the other job is @xmath289 .",
    "this further implies that @xmath290 and @xmath291 are on machine @xmath292 .",
    "carry on the above analysis until we reach machine @xmath293 , and we know that @xmath294 is on this machine . thus on machine @xmath295 the two jobs are @xmath296 and @xmath297",
    ". see figure [ fig : truthassign ] for an illustration .",
    "similarly , we can show that on machine @xmath298 the two jobs are @xmath299 and @xmath300 .",
    "thus , we can conclude that the variable @xmath301 is false , because otherwise @xmath300 should be scheduled with @xmath302 and @xmath303 , which is a contradiction .",
    "so the clause @xmath304 is satisfied .    otherwise on machine @xmath171 ,",
    "the two jobs are @xmath286 and @xmath305 . using the same argument as before we can show that on machine @xmath295 , the job @xmath306 is false and the job @xmath173 is true , while on machine @xmath298 , the job @xmath307 is true and the job @xmath308 is false .",
    "thus , the variable @xmath269 is true because otherwise @xmath309 should be scheduled with @xmath310 and @xmath266 , which is a contradiction .",
    "this implies that the clause @xmath304 is satisfied . in both cases ,",
    "every clause is satisfied , which means that @xmath311 is satisfiable .",
    "recall that given any instance of the 3sat problem with @xmath9 variables , for any @xmath7 we construct a scheduling instance with @xmath312 jobs such that it admits a feasible schedule of makespan @xmath313 if and only if the given 3sat instance is satisfiable .",
    "thus theorem  [ th : sche - makespan ] ( and also theorem  [ th : id - sche - linear ] ) follows directly .",
    "we prove theorem  [ th : id - sche - number ] .",
    "suppose the theorem fails , then there exists an exact algorithm for the restricted scheduling problem that runs in @xmath314 time for some @xmath315 , then we may simply choose @xmath316 in our reduction .",
    "since @xmath317 is some fixed constant , the scheduling problem we construct contains @xmath10 jobs with the processing time of each job bounded by @xmath318 .",
    "then we apply the scheduling algorithm to get an optimum solution , and it runs in @xmath319 , i.e. , @xmath320 time . through the makespan of this optimum solution , we can determine whether the given 3sat instance is satisfiable in @xmath320 time for some fixed @xmath315 , resulting a contradiction .",
    "suppose we are given an arbitrary @xmath323 instance @xmath311 with @xmath9 variables .",
    "we further apply tovey s method  @xcite to transform @xmath311 into @xmath322 , i.e. , we replace each occurrence of a variable in @xmath322 with a new variable , and then add new clauses to enforce that new variables corresponding to the same original variable are taking the same truth value .    recall that each variable appears exactly three times in @xmath311 , thus there are in all @xmath324 variables in @xmath322 .",
    "all the clauses of @xmath322 could be divided into two sets , namely @xmath325 and @xmath326 .",
    "every variable appears exactly once in clauses of @xmath325 , and appears twice in clauses of @xmath326 .",
    "furthermore , by re - indexing , we may assume that all the clauses of @xmath326 are @xmath327 , @xmath328 , @xmath329 for @xmath330 .",
    "we may further assume that @xmath9 could be divided by @xmath0 by adding dummy variables . to see why , suppose @xmath331 with @xmath332 .",
    "since @xmath333 , @xmath334 . we could then add additionally @xmath335 dummy variables , say , @xmath336 , @xmath337 and @xmath338 for @xmath339 . for these dummy variables , we further introduce @xmath340 dummy clauses in @xmath325 as @xmath341 , and @xmath335 clauses in @xmath326 as @xmath342 , @xmath343 , @xmath344 for each @xmath165 .    it is not difficult to verify that @xmath311 is satisfiable if and only if @xmath322 is satisfiable .",
    "we construct an instance of the generalized 3 dm problem based on @xmath322 ( with @xmath324 variables ) .",
    "we first construct elements .",
    "we construct two variable elements for each variable @xmath269 , i.e. , we construct @xmath345 corresponding to @xmath269 and @xmath346 corresponding to @xmath347 .",
    "let @xmath348 be the set of them .",
    "it can be easily seen that @xmath349 .",
    "we construct a clause element @xmath350 for each @xmath272 .",
    "recall that all the clauses of @xmath326 could be listed as @xmath351 , @xmath352 , @xmath353 for @xmath354 . for every @xmath165",
    ", we construct @xmath355 and @xmath356 .",
    "this completes the construction of elements and it can be easily seen that @xmath357 , and @xmath358 .",
    "we construct matchings . for each variable @xmath269",
    ", we construct two matchings of @xmath359 , namely @xmath360 and @xmath361 .    for each clause @xmath272 , if the positive literal @xmath362 , then we construct @xmath363 .",
    "else if the negative literal @xmath364 , then we construct @xmath365 .",
    "notice that @xmath282 might contain two or three literals , thus two or three matchings of @xmath366 are constructed corresponding to it .    for each @xmath367 ,",
    "6 matchings of @xmath368 are constructed for the three clauses @xmath351 , @xmath369 and @xmath353 , namely @xmath370 , @xmath371 , @xmath372 and @xmath373 , @xmath374 , @xmath375 .",
    "it can be easily seen that @xmath376 , @xmath377 , @xmath378 .",
    "an exact cover is a subset of matches in which every element appears once .",
    "we prove the following lemma .",
    "[ le:3sat to 3 dm ] @xmath322 is satisfied if and only if @xmath321 admits an exact cover .",
    "suppose @xmath322 is satisfiable , we choose matchings out of @xmath379 to form an exact cover .    we know that for each @xmath367 , @xmath380 , @xmath381 and @xmath382 are either all true or all false .",
    "if they are all true , then we choose @xmath373 , @xmath374 , @xmath375 .",
    "otherwise they are all false , and @xmath370 , @xmath371 , @xmath372 are chosen instead .",
    "now every element of @xmath383 appears exactly once in the matches we choose currently .",
    "since each clause @xmath272 is satisfied , it is satisfied by at least one variable .",
    "we choose the variable that leads to the satisfaction of @xmath282 ( if there are multiple such variables , we choose arbitrarily one ) .",
    "suppose this variable is @xmath269 .",
    "if @xmath269 is true , then we know the positive literal @xmath384 . according to our construction @xmath363 and",
    "we choose it .",
    "otherwise @xmath269 is false , and the negative literal @xmath385 .",
    "again it follows that @xmath386 and we choose it .",
    "consider the matches we have chosen so far .",
    "every element of @xmath387 and @xmath383 appears exactly once in these matchings .",
    "moreover , each element of @xmath348 appears at most once in these matchings . to see why , notice that if we choose @xmath363 , for example , then @xmath269 is true and we do not choose matchings of @xmath368 that contain @xmath345 . finally , we choose matchings of @xmath359 to enforce that every element of @xmath348 appears exactly once .    on the contrary , suppose there exists an exact cover of @xmath321",
    ", we prove that @xmath322 is satisfiable .",
    "consider elements of @xmath387 and @xmath383 .",
    "for each @xmath367 , to ensure that @xmath388 , @xmath389 , @xmath390 , @xmath391 and @xmath392 , @xmath393 appear once respectively , in the exact cover @xmath394 we have to choose either @xmath373 , @xmath374 , @xmath375 , or choose @xmath370 , @xmath371 , @xmath372 .",
    "if @xmath373 , @xmath374 , @xmath375 are in @xmath394 , we set @xmath380 , @xmath381 and @xmath382 to be true .",
    "otherwise we set @xmath380 , @xmath381 and @xmath382 to be false .",
    "it can be easily seen that every clause of @xmath326 is satisfied .",
    "we consider @xmath272 .",
    "notice that @xmath350 appears once in @xmath394 .",
    "suppose the match containing @xmath395 is @xmath396 for some @xmath165 , then it follows that the positive literal @xmath362 .",
    "the fact that @xmath345 also appears once implies that @xmath346 appears in @xmath397 , and thus variable @xmath269 is true and @xmath282 is satisfied .",
    "otherwise the matching containing @xmath395 is @xmath398 for some @xmath165 , then similar arguments show that the negative literal @xmath364 and variable @xmath269 is false .",
    "again @xmath282 is satisfied .",
    "we show in this section that the traditional dynamic programming algorithm for the scheduling problem runs in @xmath399 time .",
    "consider the dynamic programming algorithm for the scheduling problem .",
    "suppose jobs are sorted beforehand as @xmath400 .",
    "we use a vector @xmath401 to represent a schedule for the first @xmath26 jobs where the load of machine @xmath165 ( i.e. , total processing times of jobs on machine @xmath165 ) is @xmath402 .",
    "let @xmath403 be the set of all these vectors that correspond to some schedules .",
    "we could determine @xmath403 iteratively in the following way .",
    "let @xmath404 . for @xmath405 , @xmath406",
    "if there exists some @xmath407 such that for some @xmath408 , @xmath409 , and @xmath410 for @xmath411 .",
    "since each vector of @xmath412 can give rise to at most @xmath413 different vectors of @xmath403 , the computation of the set @xmath403 thus takes @xmath414 time .",
    "meanwhile , once @xmath415 is determined , we check each vector of it and select the one whose makespan is minimized , which also takes @xmath416 time . after the desired vector is chosen , we may need to backtrack to determine how jobs are scheduled on each machine , and this would take @xmath10 time .",
    "notice that each vector of @xmath403 corresponds to some schedule .",
    "let @xmath420 be the first @xmath26 jobs with processing times @xmath421 and @xmath422 .",
    "notice that such an indexing of jobs is only used in the proof , while in the dynamic programming jobs are in arbitrary order .",
    "there are three possibilities .",
    "* case 1 : * @xmath423 .",
    "since each vector in @xmath403 corresponds to a schedule , we consider all possible assignments of the @xmath26 jobs . each job could be assigned to @xmath413 machines ,",
    "thus there are at most @xmath424 different assignments for @xmath26 different jobs .",
    "notice that each vector of @xmath403 corresponds to some schedule . given @xmath436",
    ", we may let @xmath437 be the set of jobs on machine @xmath165 .",
    "group @xmath437 can be split into two subgroups , i.e. , jobs belonging to the set @xmath438 and the set @xmath439 .",
    "let @xmath440 be the total processing time of jobs in the former subgroup and @xmath441 be the total processing time of jobs in the latter subgroup .",
    "then the vector @xmath442 can be expressed as the sum of two vectors @xmath443    let @xmath444 and @xmath445 be the sets of all possible vectors @xmath446 and @xmath447 respectively , then we know @xmath448 .",
    "consider each vector of @xmath444 , it corresponds to some feasible schedule of jobs @xmath212 to @xmath449 over machines .",
    "since @xmath450 and @xmath434 , we have @xmath451    consider each vector of @xmath445 , it corresponds to some feasible schedule of jobs @xmath452 to @xmath26 over machines . to assign @xmath453 different jobs to @xmath0 machines ,",
    "there are at most @xmath454 different assignments . since @xmath455",
    ", we have @xmath456 thus @xmath457 , which implies that @xmath458 thus , @xmath459"
  ],
  "abstract_text": [
    "<S> we consider the classical scheduling problem on parallel identical machines to minimize the makespan . </S>",
    "<S> there is a long history of studies on this problem , focusing on exact and approximation algorithms , and it is thus natural to consider whether these algorithms are optimal in terms of the running time . under the exponential time hypothesis ( eth ) , we achieve the following results in this paper :    * the scheduling problem on a constant number @xmath0 of identical machines , denoted by @xmath1 , is known to admit a fully polynomial time approximation scheme ( fptas ) of running time @xmath2 ( indeed , the algorithm works for an even more general problem where machines are unrelated ) . </S>",
    "<S> we prove this algorithm is essentially the best possible in the sense that a @xmath3 time ptas implies that eth fails . </S>",
    "<S> * the scheduling problem on an arbitrary number of identical machines , denoted by @xmath4 , is known to admit a polynomial time approximation scheme ( ptas ) of running time @xmath5 . </S>",
    "<S> we prove this algorithm is nearly optimal in the sense that a @xmath6 time ptas for any @xmath7 implies that eth fails , leaving a small room for improvement . </S>",
    "<S> * the traditional dynamic programming algorithm for @xmath4 is known to run in @xmath8 time . </S>",
    "<S> we prove this is essentially the best possible in the sense that even if we restrict that there are @xmath9 jobs and the processing time of each job is bounded by @xmath10 , an exact algorithm of running time @xmath11 for any @xmath7 implies that eth fails .    to obtain our results we will provide two new reductions from 3sat , one for @xmath1 and one for @xmath4 . indeed , the new reductions explore the structure of scheduling problems and can also lead to other interesting results . </S>",
    "<S> for example , the recent paper of bhaskara et al .  </S>",
    "<S> @xcite consider the minimum makespan scheduling problem where the matrix of job processing times @xmath12 is of a low rank . </S>",
    "<S> they prove that rank 4 scheduling is apx - hard while the rank 2 scheduling is not , leaving the classification of rank 3 scheduling as an open problem . using the framework of our reduction for @xmath4 , </S>",
    "<S> rank 3 scheduling is proved to be apx - hard  @xcite .    </S>",
    "<S> * keywords : * approximation schemes ; scheduling ; lower bounds ; exponential time hypothesis </S>"
  ]
}