{
  "article_text": [
    "[ [ program - maintenance - and - trace - analysis . ] ] * program maintenance and trace analysis .",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    several experimental studies ( e.g. , @xcite ) show that maintenance is the most expensive phase of software development : the initial development represents only 20  % of the cost , whereas error fixing and addition of new features after the first release represent , each , 40  % of the cost .",
    "thus , 80  % of the cost is due to the maintenance phase .",
    "a key issue of maintenance is program understanding . in order to fix logical errors",
    ", programmers have to analyze their program symptoms and understand how these symptoms have been produced . in order to fix performance errors ,",
    "programmers have to understand where the time is spent in the programs . in order to add new functionality , programmers have to understand how the new parts will interact with the existing ones .",
    "program analysis tools help programmers understand programs . for example",
    ", type checkers @xcite help understand data inconsistencies . slicing tools @xcite help understand dependencies among parts of a program .",
    "tracers give insights into program executions @xcite .",
    "some program analysis tools automatically analyze program execution traces .",
    "they can give very precise insights of program ( mis)behavior . we have shown how such trace analyzers can help users debug their programs . in our automated debuggers , a trace query mechanism helps users check properties of parts of traced executions in order to understand misbehavior @xcite .    in this article",
    ", we show that trace analysis can be pushed toward monitoring to further help understand program behavior . whereas debuggers are tools that retrieve run - time information at specific program points , monitors collect information relative to the whole program executions .",
    "for example , some monitors gather statistics which help detect heavily used parts that need to be optimized ; other monitors build graphs ( e.g. , control flow graphs , dynamic call graphs , proof trees ) that give a global understanding of the execution .",
    "[ [ execution - monitoring . ] ] * execution monitoring . * + + + + + + + + + + + + + + + + + + + + + + +    monitors are trace analyzers which differ from debuggers .",
    "monitoring is mostly a `` batch '' activity whereas debugging is mostly an interactive activity . in monitoring ,",
    "a _ set _ of properties is specified beforehand ; the whole execution is checked ; and the global collected information is displayed . in debugging ,",
    "the end - user is central to the process ; he specifies on the fly the very next property to be checked ; each query is induced by the user s current understanding of the situation at the very moment it is typed in .",
    "monitoring is therefore less versatile than debugging .",
    "the properties specified for monitoring have a much longer lifetime , they are meant to be used over several executions .",
    "it is , nevertheless , impossible to foresee all the properties that programmers may want to check on executions .",
    "one intrinsic reason is that these properties are often driven by the application domain .",
    "therefore monitoring systems must provide some genericity .",
    "[ [ existing - approaches - to - implement - monitors . ] ] * existing approaches to implement monitors .",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    unfortunately , monitors are generally implemented by ad hoc instrumentation .",
    "this instrumentation requires a significant programming effort . when done at a low level , for example by modifying the compiler and the runtime system , it requires deep knowledge that mostly only the language compiler implementors have",
    "however , the monitored information is often application - dependent , and application programmers or end - users know better what has to be monitored .",
    "but instrumenting compilers is almost impossible for them .",
    "an alternative to low - level instrumentation is source - level instrumentation ; run - time behavior information can be extracted by source - to - source transformation , as done for ml @xcite and prolog @xcite for instance . such instrumentation ,",
    "although simpler than low - level compiler instrumentation , can still be too complex for most programmers .",
    "furthermore , for certain new declarative programming languages like mercury  @xcite , instrumentation may even be impossible .",
    "indeed , in mercury , the declarative semantics is simple and well defined , but the operational semantics is complex .",
    "for example , the compiler reorders goals according to its needs .",
    "furthermore , input and output can be made only in deterministic predicates .",
    "this complicates code instrumentation .",
    "thus , ad hoc instrumentation is tedious at a low level and it may be impossible at a high level .",
    "on the other hand , the difficult task of instrumenting the code to extract run - time information has , in general , already been achieved to provide a debugger .",
    "debuggers , which help users locate faults in programs are based on tracers .",
    "these tracers generate execution traces which provide a precise and faithful image of the operational semantics of the traced language .",
    "these traces often contain sufficient information to base monitors upon them .",
    "[ [ our - proposal . ] ] * our proposal . * + + + + + + + + + + + + + + +    in this article",
    ", we propose a high - level primitive built on top of an event oriented execution tracer .",
    "the proposed monitoring primitive , called foldt , is a fold  which operates on a list of events .",
    "an event oriented _ trace _ is a sequence of events .",
    "an _ event _ is a tuple of event attributes .",
    "event attribute _ is an elementary piece of information that can be extracted from the current state of the program execution .",
    "thus , a trace can be seen as a sequence of tuples of a database ordered by time .",
    "many tracers are event - oriented : for example , prolog tracers based on byrd box model  @xcite , tracers for c such as dalek  @xcite and coca  @xcite , the egadt tracer for pascal  @xcite , the esa tracer for ada  @xcite , and the ebba tracer for distributed systems  @xcite .",
    "one of the key advantages of our approach is that it allows a clean separation of concerns ; the definition of the monitors is totally distinct from both the user source code and the language compiler .",
    "we have implemented foldt  on top of the mercury trace .",
    "we give a number of applications of the foldt  operator to compute various monitors : execution profiles , graphical abstract views , and test coverage measurements .",
    "each example is implemented by a few lines of mercury which can be written by any mercury programmer .",
    "these applications show that the mercury trace , indeed , contains enough information to build a wide variety of interesting monitors .",
    "detailed measurements show that , under some requirements , foldt  can have acceptable performance for executions of several millions of execution events .",
    "therefore our operator lays the foundation for a generic and powerful monitoring environment .",
    "the proposed scheme has been integrated into the mercury environment .",
    "it is fully operational and part of the mercury distribution .",
    "note that we have implemented the foldt  operator on top of mercury mostly for historical reasons .",
    "we acknowledge that some of the monitors were particularly easy to write thanks to the neatness of mercury libraries , in particular the set library ( e.g. , figure  [ cfg - source ] ) .",
    "nevertheless , foldt  could be implemented for any system with an event - oriented tracer .",
    "[ [ plan . ] ] * plan . * + + + + + + +    in section  [ collect - section ] , we introduce the foldt  operator and describe its current implementation on top of the mercury tracer . in section  [ collect - app ] , we illustrate the genericity of foldtwith various kinds of monitors . all the examples are presented at a level of detail that does not presuppose any knowledge of mercury .",
    "section  [ performance - section ] discusses performance issues of foldt .",
    "section  [ collect - related ] compares our contribution with related work .",
    "a thorough description of the mercury trace can be found in appendix  [ trace - appendix ] .",
    "appendix  [ queens - prog - appendix ] lists a mercury program solving the n  queens problem , which is used at various places in the article as an input for our monitors .",
    "in this section , we first define the foldt  operator over a general trace in a language - independent manner .",
    "we describe an implementation of this operator for mercury program executions , and then present its current user interface .",
    "a trace is a list of events ; analyzing a trace therefore requires to process such a list .",
    "the standard functional programming operator fold  encapsulates a simple pattern of recursion for processing lists .",
    "it takes as input arguments a function , a list , and an initial value of an accumulator ; it outputs the final value of the accumulator ; this final value is obtained by successively applying the function to the current value of the accumulator and each element of the list . as demonstrated by hutton @xcite",
    ", fold has a great expressive power for processing lists .",
    "therefore , we propose a fold - like operator to process execution traces ; we call this operator foldt .    before defining foldt",
    ", we define the notions of event and trace for sequential executions .",
    "( execution event , event attributes , execution trace ) + _ an execution event _ is an element of the cartesian product @xmath0 , where @xmath1 for @xmath2 are arbitrary sets called _",
    "event attributes_. _ an execution trace _ is a ( finite or infinite ) sequence of execution events ; the set of all execution traces is denoted by  @xmath3 .",
    "we note @xmath4 the size ( its number of events ) of a finite trace @xmath5 and @xmath6 the size of infinite traces .",
    "the following definition of foldt  is a predicative definition of a fold  operating on a finite number of events of a ( possibly infinite ) trace .",
    "the set of predicates over @xmath7 is denoted by @xmath8 .",
    "( foldt ) + [ foldt - def ] a _ foldt  monitor of type @xmath9 _ is a 3-tuple : @xmath10 such that : @xmath11 , either + ( 1 ) @xmath12 + @xmath13 + ( 2 ) @xmath14 + @xmath15 + @xmath16    @xmath17 is called _ the result of the monitor @xmath18 on trace @xmath19_. we use the notation @xmath20 to mean that there exists a unique @xmath21 , and @xmath22 for the sequence ( in the mathematical sense ) @xmath23 .",
    "operationally , an accumulator of type @xmath24 is used to gather the collected information .",
    "it is first initialized ( @xmath25 ) .",
    "the predicate collect  is then applied to each event of the trace in turn , updating the accumulator along the way ( @xmath26 ) .",
    "there are two ways to stop this process : ( 1 ) the folding process stops when the end of the execution is reached if the trace is finite ( @xmath27 ) ; ( 2 ) if collect fails before the end of the execution is reached ( @xmath28 ) . in both cases ,",
    "the last value of the accumulator ( @xmath29 ) is processed by post_process , which returns a value ( @xmath17 ) of type @xmath30 ( @xmath31 ) .",
    "note that this definition holds for finite and infinite traces ( thanks to the second case of definition  [ foldt - def ] ) .",
    "this is convenient to analyze programs that run permanently .",
    "the ability to end the foldt  process before the end of the execution is also convenient to analyze executions part by part as explained in section  [ part - by - part - analysis - section ] .",
    "a further interesting property , which is useful to execute several monitors in a single program execution , is the possibility to simultaneously apply several fold  on the same list using a tuple of fold  @xcite ; in other words : + @xmath32    where :    @xmath33 ,    @xmath34 ,    @xmath35 .",
    "we prototyped an implementation of foldt  for the mercury programming language . after a brief presentation of mercury and its trace system ,",
    "we describe our foldt  implementation .",
    "mercury  @xcite is a logic and functional programming language .",
    "the principal differences with prolog are as follows .",
    "mercury supports functions and higher - order terms .",
    "mercury programs are free from side - effects ; even input and output are managed in a declarative way .",
    "mercury strong type , mode and determinism system allows a lot of errors to be caught at compile time , and a lot of optimizations to be done .",
    "the trace generated by the mercury tracer  @xcite is adapted from byrd box model  @xcite .",
    "its attributes are the event number , the call number , the execution depth , the event type ( or port ) , the determinism , the procedure ( defined by a module name , a name , an arity and a mode number ) , the live arguments , the live non - argument variables , and the goal path . a detailed description of these attributes together with an example of event is given in appendix  [ trace - appendix ] .",
    "an obvious and simple way to implement foldt  would be to store the whole trace into a single list , and then to apply a fold  to it .",
    "this naive implementation is highly inefficient , both in time and in space .",
    "it requires creating and processing a list of possibly millions of events .",
    "most of the time , creating such a list is simply not feasible because of memory limitations . with the current mercury trace system",
    ", several millions of events are generated each second , each event requiring several bytes .",
    "to implement realistic monitors , run - time information needs to be collected and analyzed simultaneously ( on the fly ) , * without explicitly creating the trace . *    in order to achieve analysis on the fly , we have implemented foldtby modifying the mercury trace system , which works as follows : when a program is compiled with tracing switched on , the generated c code is instrumented with calls to the tracer ( via the c function trace ) . before the first event ( resp . after the last one ) , a call to an initialization c function trace_init ( resp . to a finalization c function",
    "trace_final ) is inserted .",
    "when the trace system is entered through either one of the functions trace , trace_init , or trace_final , the very first thing it does is to look at an environment variable that tells whether the mercury program has been invoked from a shell , from the standard mercury debugger ( mdb ) , or from another debugger ( e.g. , morphine  @xcite ) .",
    "we have added a new possible value for that environment variable which indicates whether the program has been invoked by foldt . in that case , the trace_init function dynamically links the mercury program under execution with the object file that contains the object code of collect , initialize , and post_process .",
    "dynamically linking the program to its monitor is very convenient because neither the program nor the monitor need to be recompiled .",
    "once the monitor object file has been linked with the program , the c function trace_init can call the procedure initialize  to set the value of a global variable accumulator_variable ( of type @xmath24 ) . at each event",
    ", the c function trace calls the procedure collect  which updates accumulator_variable . if collect  fails or if the last event is reached , the c function trace_final calls the procedure post_process   with accumulator_variable and returns the new value of this accumulator ( now of type @xmath30 ) .      in this section",
    ", we first describe what the user needs to do in order to define a monitor with foldt .",
    "then , we show how this monitor can be invoked .      ' '' ''    1 : - type accumulator_type = = < a mercury type > .",
    "initialize(accumulator ) : - < mercury goals which initialize the accumulator > .",
    "collect(event , accumulatorin , accumulatorout ) : - < mercury goals which update the accumulator > .",
    ": - type collected_type = = < a mercury type > .",
    "post_process(accumulator , foldtresult ) : - < mercury goals which post - process the accumulator > .    ' '' ''    we chose mercury to be the language in which users define the foldt   monitors to monitor mercury programs .",
    "as a matter of fact , it could have been any other language that has an interface with c , since the trace system of mercury is written in  c. the choice of mercury , however , is quite natural ; people who want to monitor mercury programs are likely to be mercury programmers .",
    "the items users need to implement in order to define a foldt   monitor are given in figure  [ use - collect ] .",
    "lines preceded by ` % ' are comments .",
    "first of all , since mercury is a typed language , one first needs to define the type of the accumulator variable accumulator_type ( line  2 ) .",
    "then , one needs to define initialize  which gives the initial value of the accumulator , and collect  which updates the accumulator at each event(line  9 ) .",
    "optionally , one can also define the post_process  predicate which processes the last value of the accumulator .",
    "post_process   takes as input a variable of type accumulator_type ( @xmath24 ) and outputs a variable of type collected_type ( @xmath30 ) .",
    "if collected_type is not the same type as accumulator_type , then one needs to provide its definition too ( line  13 ) .",
    "types and modes of predicates initialize , collect and post_process   should be consistent with the following mercury declarations :    `  : -  pred  `` initialize``(accumulator_type::out )  is  det .  `",
    "+ `  : -  pred  `` collect``(event::in ,  accumulator_type::in , ` + `  accumulator_type::out )  is  semidet . `",
    "+ `  : -  pred  `` post_process``(accumulator_type::in ,  collected_type::out )  ` + `  is  det . `",
    "these declarations state that initialize  is a deterministic predicate ( is det ) , namely it succeeds exactly once , and it outputs a variable of type accumulator_type ; collect  is a semi - deterministic predicate , namely it succeeds at most once , and it takes as input an event and an accumulator .",
    "if collect  fails , the monitoring process stops at the current event",
    ". this can be very useful , for example to stop the monitoring process before the end of the execution if the collecting data is too large , or to collect data part by part ( e.g. , collecting the information by slices of 10000 events ) .",
    "this also allows foldt  to operate over non - terminating executions .",
    "the type event is a structure made of all the event attributes .",
    "to access these attributes , we provide specific functions which types and modes are : + `` ` : - func < attribute_name>(event::in ) = < attribute_type>::out . ` '' , + which takes an event and returns the event attribute corresponding to its name .",
    "for example , the function call depth(event ) returns the depth of event .",
    "the complete list of attribute names is given in appendix  [ trace - appendix ] .",
    "figure  [ count - call - collect ] shows an example of monitor that counts the number of predicate invocations ( calls ) that occur during a program execution .",
    "we first import library module int ( line  1 ) to be able to manipulate integers .",
    "predicate initialize  initializes the accumulator to ` 0 ' ( line  3 ) .",
    "then , for every execution event , collect  increments the counter if the event port is call , and leaves it unchanged otherwise ( line  5 ) . since collect",
    "can never fail here , the calls to collect  proceed until the last event of the execution is reached .    note that those five lines of code constitute _ all the necessary lines _ for this monitor to be run . for the sake of conciseness , in the following figures containing monitors",
    ", we sometimes omit the module importation directives as well as the type of the accumulator when the context makes them clear .    ' '' ''    1 : - import_module int .",
    ": - type accumulator_type = = int .",
    "initialize(0 ) .",
    "collect(event , c0 , c ) : - if port(event ) = call then c = c0 + 1 else c = c0 .    ' '' ''      [ invoke - fold ]    currently , foldt  can be invoked from a prolog query loop interpreter .",
    "we could not use mercury for that purpose because there is no mercury interpreter yet .",
    "we have implemented a prolog predicate named run_mercury , which takes a mercury program call as argument , and which forks a process in which this mercury program runs in coroutining with the prolog process .",
    "the two processes communicate via sockets .",
    "when the first event of the mercury program is reached , the hand is given to the prolog process which waits for a foldt  query .",
    "the command foldt  has two arguments ; the first one should contain the name of the file defining the monitor to be run ; the second one is a variable that will be unified with the result of the monitor .",
    "when foldt  is invoked , ( 1 ) the file containing the monitor is used to automatically produce a mercury module named foldt.m ( by adding the declarations of initialize , collect , and post_process , as well as the definitions of the event type and the attribute accessing functions ) ; ( 2 ) foldt.m is compiled , producing the object file foldt.o ; ( 3 ) foldt.o is dynamically linked with the mercury program under coroutining .",
    "of course , steps ( 1 ) and ( 2 ) are only performed if the file containing the monitor is newer than the object file foldt.o .",
    "a monitor stops either because the end of the execution is reached , or because the collect predicate failed ; in the latter case , the current event ( i.e. , the event the next query will start at ) is the one occurring immediately after the event where collect failed .    ' '' ''    `  [ morphine ] :  run_mercury(queens ) ,  foldt(count_call ,  result ) . `",
    "+ `  ` _ `  a  5  queens  solution  is  [ 1 ,  3 ,  5 ,  2 ,  4 ] ` _ + `  last  event  of  queens  is  reached ` + `  result  =  146  more ?  ( ;)  ` + `  [ morphine ] :  `    ' '' ''    a possible session for invoking the monitor of figure  [ count - call - collect ] is given in figure  [ morphine - session ] . at the right - hand side of the ` : ' prompt , there are the characters typed in by a user .",
    "the line in italic is output by the mercury program ; all the other lines are output by the prolog process .",
    "we can therefore see that the program queens ( which solves the @xmath36 queens problem , cf appendix  [ queens - prog - appendix ] ) produces 146 procedure calls .",
    "being able to call foldt  from a prolog interpreter loop enables users to write scripts that control several foldt  invocations .",
    "figures  [ depth - monitor ] and  [ depth - session ] illustrate this .",
    "the monitor of figure  [ depth - monitor ] computes the maximal depth for the next 500 events . in the session of figure  [ depth - session ] , a user ( via the .",
    "directive ) defines the predicate print_max_depth that calls the monitor of figure  [ depth - monitor ] and prints its result in loop until the end of the execution is reached .",
    "this is useful for example for a program that runs out of stack space to check whether this is due to a very deep execution and to know at which events this occurs .",
    "note that the fact that the monitor is dynamically linked with the monitored program has an interesting side - effect here : one can change the monitor during the foldt  query resolution ( by modifying the file where this monitor is defined ) .",
    "indeed , in our example , one could change the interval within which the maximal depth is searched from 500 to 100 .",
    "the monitor would be ( automatically ) recompiled , but the foldt  query would not need to be killed and rerun .",
    "this can be very helpful to monitor a program that runs permanently ; the monitored program is simply suspended while the monitor is recompiled .    ' '' ''    1 initialize(acc(0 , 0 ) ) .",
    "collect(event , acc(n0 , d0 ) , acc(n0 + 1 , max(d0 , depth(event ) ) ) ) : - n0 < 500 .    ' '' ''    ' '' ''    `  [ morphine ] :  [ user ] .",
    "` + `  print_max_depth  : - ` + `  foldt(max_depth ,  acc ( _ ,  maxdepth ) ) ,  ` + `  print(````the  maximal  depth  is  ` ' ' ` ) ,  print(maxdepth ) ,  nl ,  ` + `  print_max_depth .  `",
    "+ `  ^d ` + `  [ morphine ] :  run_mercury(qsort ) ,  print_max_depth . `",
    "+   + `  ` _ `  the  maximal  depth  is  54 ` _ + `  ` _ `",
    "the  maximal  depth  is  28 ` _",
    "+ `  ` _ `  the  maximal  depth  is  50 ` _",
    "+ `  ` _ `  [ 0 ,  2 ,  4 ,  6 ,  7 ,  8 ,  ... ,  94 ,  95 ,  99 ,  99 ] ` _ + `  last  event  of  qsort  is  reached ` + `  ` _ `  the  maximal  depth  is  53 ` _ + `  [ morphine ] :  `    ' '' ''    as a matter of fact ( as the prompt suggests ) , the prolog query loop that we use is morphine  @xcite , an extensible debugger for mercury ``  la opium ''  @xcite . the basic idea of morphine is to build on top of a prolog query loop a few coroutining primitives connected to the trace system ( like foldt ) .",
    "those primitives let one implement all classical debugger commands as efficiently as their hand - written counter - parts ; the advantage is , of course , that they let users implement more commands than the usual hard - coded ones , fitting their own needs .",
    "invoking foldt  from a debugger has a further advantage ; it makes it very easy to call a monitor during a debugging session , and vice versa .",
    "indeed , some monitors are very useful for understanding program runtime behavior , and therefore can be seen as debugging tools .",
    "in this section , we describe various execution monitors that can be implemented with foldt .",
    "we first give monitors which compute three different execution profiles : number of events at each port , number of goal invocations at each depth , and sets of solutions .",
    "then , we describe monitors that produce two types of execution graphs : dynamic control flow graph and dynamic call graph . finally , we introduce two test coverage criteria for logic programs , and we give the monitors that measure them .",
    "[ collect - monitoring ]      ' '' ''    1 : - import_module int , array .",
    ": - type accumulator_type = = array(int ) .",
    ": - mode acc_in : : array_di .",
    ": - mode acc_out : : array_uo .",
    "initialize(array ) : - init(5 , 0 , array ) .",
    "collect(event , array0 , array ) : - port = port(event ) , port_to_int(port , intport ) , lookup(array0 , intport , n ) , set(array0 , intport , n+1 , array ) .",
    ": - pred port_to_int(port::in , int::out ) is det .",
    "port_to_int(port , number ) : - ( if port = call then number = 0 else if port = exit then number = 1 else if port = redo then number = 2 else if port = fail then number = 3 else number = 4 ) .    ' '' ''    in figure  [ count - call - collect ] , we have given a monitor that counts the number of goal invocations .",
    "figure  [ statistic - collect ] shows how to extend this monitor to count the number of events at each port .",
    "we need 5 counters that we store in an array . in the current implementation of foldt",
    ", the default mode of the second and third argument of collect , respectively equal to in and out , can be overridden ; here , we override them with array_di and array_uo ( lines  4 and  5 ) . modes",
    "array_di and array_uo are special modes that allow arrays to be destructively updated .",
    "predicate initializecreates an array array of size 5 with each element initialized to 0 ( line  8) .",
    "predicate collect  extracts the port from the current event ( line  11 ) and converts it to an integer ( line  12 ) ( cf appendix  [ trace - appendix ] ) ; we ignore them here for the sake of conciseness . ] .",
    "this integer is used as an index to get ( lookup/3 ) and set ( set/4 ) array values . the goal lookup(array0 , intport , n ) returns in n the intport@xmath37 element of array0 .",
    "the goal set(array0 , intport , n+1 , array ) sets the value n+1 in the intport@xmath37 element of array0 and returns the resulting array in array .",
    "[ histogramme - collect - section ]    ' '' ''    1 initialize(acc ) : - init(32 , 0 , acc ) .",
    "collect(event , acc0 , acc ) : - ( if port(event ) = call then depth = depth(event ) , ( if semidet_lookup(acc0 , depth , n ) then set(acc0 , depth , n+1 , acc ) else size(acc0 , size ) , resize(acc0 , size*2 , 0 , acc1 ) , set(acc1 , depth , 1 , acc ) ) else acc = acc0 ) .    ' '' ''    figure [ histogram - collect ] implements a monitor that counts the number of calls at each depth .",
    "predicate initialize  creates an array of size 32 with each element initialized to 0 ( line  4 ) . at call events ( line  7 )",
    ", predicate collect  extracts the depth from the current event ( line  8) and increments the corresponding counter ( lines  10 and  14 ) .",
    "whenever the upper bound of the array is reached , i.e. , whenever semidet_lookup/4 fails ( line  9 ) , the size of the array is doubled ( lines  13 ) .      ' '' ''    1 : - type solution  >",
    "proc_name / arguments .",
    ": - type accumulator_type = = list(solution ) .",
    "initialize ( [ ] ) .",
    "collect(event , accin , accout ) : - ( if port(event ) = exit , solution = proc_name(event)/arguments(event ) , not(member(solution , accin ) ) then accout = [ solution | accin ] else accout = accin ) .    ' '' ''    the monitor of figure  [ solutions - collect ] collects the solutions produced during the execution .",
    "we define the type solution as a pair containing a procedure and a list of arguments ( line  1 ) .",
    "the collected variable is a list of solutions ( line  2 ) , which is initialized to the empty list ( line  4 ) . if the current port is exit ( line  8) and if the current solution has not been already produced ( lines  9,10 ) , then the current solution is added to the list of already collected solutions ( line  12 ) .    note that for large programs , it would be better to use a table from predicate names to set of solutions instead of lists .",
    "other execution abstract views that are widely used and very useful in terms of program understanding are given in terms of graphs . in the following ,",
    "we show how to implement monitors that generate graphical abstractions of program executions such as control flow graphs and dynamic call graphs .",
    "we illustrate the use of these monitors by applying them to the @xmath36 queens program given in appendix  [ queens - prog - appendix ] .",
    "this @xmath38 line program generates @xmath39 events for a board of @xmath40 . in this article",
    ", we use the graph drawing tool dot  @xcite .",
    "more elaborated visualization tools such as in  @xcite would be desirable , especially for large executions .",
    "this is , however , beyond the scope of this article .      ' '' ''        ' '' ''",
    "we define the _ dynamic control flow graph _ of a logic program execution as the directed graph where nodes are predicates of the program , and arcs indicate that the program control flow went from the origin to the destination node .",
    "the dynamic control flow graph of the 5  queens program is given in figure  [ cfg - eps ] .",
    "we can see , for example , that , during the program execution , the control moves from predicate main/2 to predicate data/1 , from predicate data/1 to predicate data/1 and predicate queen/2 .",
    "note that such a graph ( or variants of it ) is primarily useful for tools and only secondarily for humans .    ' '' ''    1 : - type predicate",
    " > proc_name / arity .",
    ": - type arc ",
    "> arc(predicate , predicate ) .",
    ": - type graph = = set(arc ) .",
    ": - type accumulator_type  > collected_type(predicate , graph ) .",
    "initialize(collected_type(``user''/0 , set__init ) ) .",
    "collect(event , acc0 , acc ) : - port = port(event ) , ( if ( port = call ; port = exit ; port = fail ; port = redo ) then acc0 = collected_type(previouspred , graph0 ) , currentpred = proc_name(event ) / proc_arity(event ) , arc = arc(previouspred , currentpred ) , set__insert(graph0 , arc , graph ) , acc = collected_type(currentpred , graph ) else acc = acc0 ) .    ' '' ''    an implementation of a monitor that produces such a graph is given in figure  [ cfg - source ] .",
    "graphs are encoded by a set of arcs , and arcs are terms composed of two predicates ( lines 1 to 3 ) .",
    "the collecting variable is composed of a predicate and a graph ( line  4 ) ; the predicate is used to remember the previous node .",
    "the collecting variable is initialized with the fake predicate user/0 , and the empty graph ( line  6 ) . at call ,",
    "exit , redo , and fail events ( line  10 ) , we insert in the graph an arc from the previous predicate to the current one ( lines  11 to 14 ) .    ' '' ''        ' '' ''    note that in our definition of dynamic control flow graph , the number of times each arc is traversed is not given .",
    "even if the control goes between two nodes several times , only one arc is represented .",
    "one can imagine a variant where , for example , arcs are labeled by a counter ; one just needs to use multi - sets instead of sets .",
    "the result of such a variant applied to the 5 queens program is displayed figure  [ cfg - cpt ] .",
    "note that here , the queens program was linked with a version of the library that has been compiled without trace information .",
    "this is the reason why one should not be surprised not to see any call to , e.g , io__write_string/3 in this figure .      ' '' ''        ' '' ''",
    "a _ static call graph _ of a program is a graph where the nodes are labeled by the predicates of the program , and where arcs between nodes indicate potential predicate calls .",
    "we define the _ dynamic call graph _ of a logic program execution as the sub - graph of the ( static ) call graph composed of the arcs and nodes that have actually been traversed during the execution . for example , in figure  [ dcg - eps ] , we can see that predicate main/2 calls predicates data/1 , queen/2 , and print_list/2 . in this particular example , the static and dynamic call graphs are identical .    ' '' ''    1 : - type accumulator_type ",
    "> ct(stack(predicate ) , graph ) .",
    "initialize(ct(stack , set__init ) ) : - stack__push(stack__init , `` user''/0 , stack ) .",
    "collect(event , ct(stack0 , graph0 ) , acc ) : - port = port(event ) , currentpred = proc_name(event ) / proc_arity(event ) , update_call_stack(port , currentpred , stack0 , stack ) , ( if port = call then previouspred = stack__top_det(stack0 ) , set__insert(graph0 , arc(previouspred , currentpred ) , graph ) , acc = ct(stack , graph ) else acc = ct(stack , graph0 ) ) .",
    ": - pred update_call_stack(trace_port_type::in , predicate::in , stack(predicate)::in , stack(predicate)::out ) is det .",
    "update_call_stack(port , currentpred , stack0 , stack ) : - ( if ( port = call ; port = redo ) then stack__push(stack0 , currentpred , stack ) else if ( port = fail ; port = exit ; port = exception ) then stack__pop_det(stack0 , _ , stack ) else stack = stack0 ) .    ' '' ''    an implementation of a monitor that builds the dynamic call graphs is given in figure  [ dcg - source ] . in order to define this monitor",
    ", we use the same data structures as for the previous one , except that we replace the last traversed predicate by the whole call stack in the collected variable type ( line  2 ) .",
    "this stack is necessary in order to be able to get the direct ancestor of the current predicate .",
    "the set of arcs is initialized to the empty set ( lines  4 ) and the stack is initialized to a stack that contains a fake node user/0 ( line  5 ) . in order to construct the set of arcs ,",
    "we insert at call events an arc from the previous predicate to the current one ( line  12 ) . the call stack is maintained on the fly by the update_call_stack/4 predicate ; the current predicate is pushed onto the stack at call and redo events ( line  22 ) , and popped at exit , fail , and exception events ( line  24 ) .",
    "the result of the execution of this monitor applied to the 5 queens program is displayed in figure  [ dcg - eps ] .",
    "note that the call stack is actually available in the mercury trace .",
    "we have intentionally not use it here for didactical purpose in order to demonstrate how this information can easily ( but not cheaply ! )",
    "be reconstructed on the fly .",
    "[ tests ]    in this section , we define two notions of test coverage for logic programs , and we show how to measure the corresponding coverage rate of mercury program executions using the foldt  primitive . the aim here is not to provide the ultimate definition of test coverage for logic programs , but rather to propose two possible definitions , and to show how the corresponding coverage rate measurements can be quickly prototyped . as a consequence ,",
    "the proposed monitors can not pretend to be optimal either in functionality , or in implementation .",
    "the aim of test coverage is to assess the quality of a test suite . in particular",
    ", it helps to decide whether it is necessary to generate more test cases or not . for a given coverage criterion , one can decide to stop testing when a certain percentage of coverage is reached .",
    "the usual criterion used for imperative languages are _ instruction _ and _ branch _ criteria @xcite .",
    "the _ instruction coverage rate _ achieved by a test suite is the percentage of instructions that have been executed .",
    "the _ branch coverage rate _ achieved by a test suite is the percentage of branches that have been traversed during its execution .",
    "one of the weaknesses of instruction and branch coverages is due to boolean expressions .",
    "the problem occurs when a boolean expression is composed by more than one atomic instruction : it may be that a test suite covers each value of the whole condition without covering all values of each atomic part of the condition .",
    "for example , consider the condition ` a or b ' and a test suite where the two cases ` @xmath41 , @xmath42 ' and ` @xmath43 , @xmath42 ' are covered . in that case , every branch and every instruction is exercised , and nevertheless , b never succeeded",
    ". if b is erroneous , even @xmath38% instruction and branch coverage will miss it .",
    "whereas in imperative programs , you get conditional branches only in the conditions of if - then - else and loops , in logic programs you get them at every unification and call ( whose determinism allows failure ) ; therefore this issue is crucial for logic programs .      in order to address the above problem , we need a coverage criterion that checks that each single predicate defined in the tested program succeeds and fails a given number of times .",
    "but we do not want to expect every predicate to fail because some , like printing predicates , are intrinsically deterministic .",
    "therefore , we want a criterion that allows the test designer to specify how many times a predicate should succeed and fail . therefore we define a _ predicate criterion _ as a pair composed of a predicate and a list of exit and fail . in the case of mercury",
    ", we can take advantage of the determinism declaration to automatically determine if a predicate should succeed and fail .",
    "here is an example of predicate criterion that can be automatically defined according to the determinism declaration of each predicate : +    [ cols= \" < , < \" , ]    + the event structure is illustrated by figure  [ event_structure ] .",
    "the displayed structure is related to an event of the execution of a qsort program which sorts the list of integers using a _ quick sort _",
    "the information contained in that structure indicates that qsort : partition/4 - 0 is currently invoked , it is the tenth trace event being generated , the sixth goal being invoked , and it has four ancestors ( depth is 5 ) . at this point",
    ", only the first two arguments of partition/4 are instantiated : the first one is bound to the list of integers and the second one to the integer 3 ; the third and fourth arguments are not live , which is indicated by the atom ` - ' .",
    "there are two live local variables : h , which is bound to the integer 1 , and t , which is bound to the list of integers .",
    "the goal path tells that this event occurred in the then branch ( t ) of the second conjunction ( c2 ) of the first switch ( s1 ) of partition/4 .",
    ".... : - module queens .                                      nodiag ( _ , _ , [ ] ) .",
    "nodiag(b , d , [ n|l ] ) : -      nmb is",
    "n - b ,      bmn is b - n ,      ( d = nmb - >          fail      ; d = bmn - >          fail      ;          true      ) ,      d1 is d + 1 ,      nodiag(b , d1 , l ) ."
  ],
  "abstract_text": [
    "<S> program execution monitoring consists of checking whole executions for given properties , and collecting global run - time information . </S>",
    "<S> monitoring helps programmers maintain their programs . however , application developers face the following dilemma : either they use existing monitoring tools which never exactly fit their needs , or they invest a lot of effort to implement relevant monitoring code . in this article </S>",
    "<S> we argue that , when an event - oriented tracer exists , the compiler developers can enable the application developers to easily code their own monitors . we propose a high - level primitive , called foldt , which operates on execution traces . </S>",
    "<S> one of the key advantages of our approach is that it allows a clean separation of concerns ; the definition of monitors is totally distinct from both the user source code and the language compiler . </S>",
    "<S> we give a number of applications of the use of foldt  to define monitors for mercury program executions : execution profiles , graphical abstract views , and test coverage measurements . </S>",
    "<S> each example is implemented by a few lines of mercury .    </S>",
    "<S> * keywords : * monitoring , automated debugging , trace analysis , test coverage , mercury . </S>"
  ]
}