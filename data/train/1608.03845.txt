{
  "article_text": [
    "modern motion planning methods have proven effective at navigating geometric constraint manifolds within high dimensional configurations spaces .",
    "this capability is critical for robots to exhibit autonomy in complex real - world environments , because geometric constraints are frequently used to determine the _ feasibility _ of a physical action and hence are often used as `` feasibility constraints '' which must be satisfied or else the action is considered infeasible .",
    "geometric constraints include requirements such as avoiding obstacles and placing end effectors in appropriate locations .",
    "two common types of motion planners are probabilistic roadmaps ( prm ) @xcite and rapidly - exploring random tree ( rrt ) @xcite .",
    "standard prm is well - suited for exploring a single _ expansive _ manifold , as defined in @xcite .",
    "constrained bi - directional rrt ( cbirrt ) @xcite can effectively handle constraint manifolds whose dimensionality is lower than the configuration space in which it exists .",
    "standard motion planning methods tend to struggle when a solution needs to traverse numerous topologically distinct constraint manifolds .",
    "this occurs most often in hybrid dynamic systems where the `` mode '' of the system alters its constraint manifold .",
    "for example , standing on the left foot is a different mode from standing on the right foot for a bipedal robot .",
    "the constraint manifolds of these two modes are different , and their intersection is narrow , resulting in a low ( sometimes zero ) probability of randomly moving from one manifold to the other .",
    "hauser et al . introduced the multi - modal prm @xcite to address this problem .",
    "the primary bottleneck of this method is the combinatorial complexity of sampling and selecting modes , since each footstep taken by the robot represents a mode that must be explored .",
    "additionally , existing implementations of the multi - modal prm are limited to quasi - static actions , which broadly eliminates its ability to utilize the dynamic capabilities of a robot system .",
    "the robot is tasked with traversing from the right side of a hallway to the left side .",
    "it must navigate underneath bars which are positioned at various angles , and then must jump across a gap .",
    "( a ) the graph explored the space of the hallway until a solution was found .",
    "green edges are walking actions , light blue edges are crawling actions , and fuchsia arcs are jumping actions .",
    "( b ) snapshots show the plan in action.,scaledwidth=98.0% ]    ( a )    the robot is tasked with traversing from the right side of a hallway to the left side .",
    "it must navigate underneath bars which are positioned at various angles , and then must jump across a gap .",
    "( a ) the graph explored the space of the hallway until a solution was found .",
    "green edges are walking actions , light blue edges are crawling actions , and fuchsia arcs are jumping actions .",
    "( b ) snapshots show the plan in action.,title=\"fig:\",scaledwidth=98.0% ] ( b )    in contrast to motion planning methods , standard footstep planners are able to rapidly generate footsteps and walking trajectories without spending time exploring the constraint manifolds of combinatorial modes the way a multi - modal prm does .",
    "they typically do this by approximating the problem of walking . in @xcite this is done using a 2d representation of obstacles and in @xcite only a finite set of footstep parameters or action primitives are available to the planner .",
    "the two - stage method presented in @xcite uses a bounding cylinder to represent the collision geometry of the lower body .",
    "all of these estimations inherently limit the completeness of the methods . moreover , these methods are all limited to a single category of action : bipedal walking .",
    "the use of optimization methods in the motion planning domain has been growing @xcite , especially for walking motions .",
    "nonlinear constrained optimization can elegantly handle the mixed modes and hybrid dynamics @xcite required for walking and crawling .",
    "however , they tend to be tailored for generating single behaviors ( e.g. a walking behavior that consists of a single- and double - support phase ) .",
    "this is insufficient for traversing a complex environment where a sequence of different types of behaviors is needed .",
    "optimizations methods also tend to be local , making them inappropriate for tackling problems that require a global search .",
    "the goal of this paper is to introduce a new high - level motion planning method , named the _ possibility graph _",
    ", that can leverage the speed and efficiency of standard footstep planners with the completeness of randomized motion planning methods and the dynamics capabilities of optimization - based methods .",
    "the possibility graph is general enough to handle arbitrary categories of actions instead of being limited to only walking or stepping primitives .",
    "the role of the possibility graph is to quickly explore what actions might be possible throughout an environment .",
    "different action types are compactly interlaced with each other within the graph , allowing a solution to utilize any action types in any order .",
    "once a potential route is discovered , lower - level planning methods are used to confirm whether the route is truly feasible .",
    "this allows the lower - level ( and computationally intensive ) planners to focus their efforts on queries which are likely to achieve a solution .",
    "these queries can be performed in parallel , ensuring that the overall planning effort does not get bottlenecked by any single challenging step .",
    "the three categories of actions used in this paper are walking , crawling , and a standing long jump .",
    "figure [ fig : hallway ] shows these three actions being utilized in a hallway example .",
    "we test the possibility graph on various scenarios . in some scenarios ,",
    "multiple action categories may be required to reach the goal .",
    "we show that the possibility graph works reliably on the order of seconds .",
    "complete solutions tend to generate at faster than 100x real time .",
    "this makes possibility graphs suitable for online planning .",
    "they could also be incorporated into higher level task planners @xcite which require numerous high - speed queries .",
    "the governing logical principles behind the possibility graph have a theoretical grounding in possibility theory @xcite , but the concepts are intuitive enough that a knowledge of possibility theory is not necessary to proceed .",
    "it is enough to understand that the _ possibility _ of any given action instance can be labelled with `` impossible '' , `` possible '' , or `` indeterminate '' depending on whether the instance satisfies the necessary or sufficient conditions that are assigned to it .",
    "the motivation for using a possibility graph is two - fold :    1 .   we can design necessary and/or sufficient conditions that can be checked quickly , making expansion of the graph very efficient .",
    "2 .   even though different actions may have constraint manifolds with different dimensionalities , we can design their necessary and/or sufficient conditions to share a common set of parameters , allowing for a single unified graph which combines all actions .",
    "motion planning methods ordinarily operate by constructing graphs or trees which fully exist within the feasibility constraint manifold of the action they are performing . remaining within this manifold is a reasonable requirement to place on the graph , because any vertices or edges which step outside of the manifold are , by definition , invalid  which may mean it is physically impossible , or simply harmful to the robot or its surroundings . unfortunately , for a humanoid robot to remain on the constraint manifold , expensive calls to whole body inverse kinematics solvers ( for more on whole body ik , see @xcite ) must be performed .",
    "this results in a critical bottleneck if a broad area needs to be explored before finding a solution . by exploring the _ possibility _ of actions first",
    ", we can broadly avoid expensive whole body inverse kinematics queries and easily slide through transition spaces which would otherwise be narrow .      to construct the possibility graph , we must first design sufficient and/or necessary conditions for the feasibility constraint manifold of each action .",
    "the two motivations which were mentioned earlier imply that the conditions we create should satisfy two criteria : ( 1 ) they should be quick to test , and ( 2 ) they should be low dimensional , using as few parameters as is reasonable .",
    "suppose we have a 2d constraint manifold , @xmath0 , which exists in 3d space , as shown in fig .",
    "[ fig : abstract_manifold](a )",
    ". supposing we can directly compute the @xmath1-value of the manifold given valid @xmath2 and @xmath3 values , it makes sense to project this manifold down onto the @xmath4-plane .",
    "we can call the projection @xmath5 .",
    "this accomplishes our goal of lower dimensionality .",
    "even with a flattened - out projection , identifying which points are inside or outside of the manifold may still be costly or difficult , because the boundaries of the projection may be functions that are expensive to compute or hard to fully define .",
    "however , suppose a box , circle , or some other simple shape can be fit within the projection such that it is _ guaranteed _ that every point within the simplified shape also lies within the manifold projection .",
    "such a shape would be a suitable representation of the sufficient condition manifold , @xmath6 , for the constraint manifold @xmath0 .",
    "mathematically , this means @xmath7 .",
    "similarly , if a simple shape , @xmath8 , could be fit _ around _",
    "the projection @xmath5 such that @xmath9 , then @xmath8 would qualify as the necessary condition manifold .",
    "the specific designs of necessary and sufficient manifolds for this paper are discussed in sec . [",
    "sec : action_implementations ] .",
    "visual depiction of an abstract constraint manifold , @xmath0 and its projection .",
    "the manifold is projected , @xmath5 , from 3d space onto a plane .",
    "`` sufficient '' @xmath6 and `` necessary '' @xmath8 boundaries are fitted within and around the projection of the manifold.,scaledwidth=48.0% ]    cartoon showing a simple 2d stick - figure example where the stick figure can walk or crawl forward .",
    "the graph s vertices represent the @xmath10 values of a point fixed to the stick figure s chest .",
    "the upper region , marked by @xmath11 in the top photo , is where walking is valid .",
    "the lower region , @xmath12 , is where crawling is valid .",
    "( a ) we extend from the start vertex towards a randomly sampled point in the center .",
    "[ alg : holonomic_growth ] , line [ alg : holonomic_growth : first_connect ] ] ( b ) we extend from the goal vertex towards the last vertex that was created in the previous step .",
    "[ alg : holonomic_growth ] , line [ alg : holonomic_growth : second_connect ] ] ( c ) for each new walking vertex , we create a crawling vertex and connect it to the walking vertex using a transition edge [ alg .",
    "[ alg : explore ] , line [ alg : explore : transition ] ] . for some of the walking vertices ,",
    "a transition into crawling is not viable due to obstacles .",
    "( d ) we now extend the crawling subgraphs towards a point that was sampled near the center of the room , and the subgraphs manage to connect [ alg . [ alg : explore ] , line [ alg : explore : growtowards]].,scaledwidth=97.0% ]    cartoon showing a simple 2d stick - figure example where the stick figure can walk or crawl forward .",
    "the graph s vertices represent the @xmath10 values of a point fixed to the stick figure s chest .",
    "the upper region , marked by @xmath11 in the top photo , is where walking is valid .",
    "the lower region , @xmath12 , is where crawling is valid .",
    "( a ) we extend from the start vertex towards a randomly sampled point in the center .",
    "[ alg : holonomic_growth ] , line [ alg : holonomic_growth : first_connect ] ] ( b ) we extend from the goal vertex towards the last vertex that was created in the previous step .",
    "[ alg : holonomic_growth ] , line [ alg : holonomic_growth : second_connect ] ] ( c ) for each new walking vertex , we create a crawling vertex and connect it to the walking vertex using a transition edge [ alg .",
    "[ alg : explore ] , line [ alg : explore : transition ] ] . for some of the walking vertices ,",
    "a transition into crawling is not viable due to obstacles .",
    "( d ) we now extend the crawling subgraphs towards a point that was sampled near the center of the room , and the subgraphs manage to connect [ alg . [ alg : explore ] , line [ alg : explore : growtowards]].,scaledwidth=97.0% ]      the purpose of the possibility graph is to find a feasible action sequence to get from a start point to at least one goal point .",
    "we define the contents of the possibility graph in def .",
    "[ def : posgraph ] . the procedure for finding solutions with the graph",
    "is described by alg .",
    "[ alg : explore ] .",
    "the graph is initialized with a set of subgraphs , each subgraph consisting solely of either the start point or a goal point .",
    "all the graph s vertices are elements of the `` possibility exploration space '' , @xmath13 .",
    "the possibility graph finds paths through the exploration space by querying each available action to expand the graph in randomized directions within @xmath13 ( see line [ alg : explore : growtowards ] of alg .",
    "[ alg : explore ] ) .",
    "if a query meets at least the necessary conditions of the action , then it will be appended to the graph .",
    "[ def : posgraph]a possibility graph is a tuple + @xmath14 , where    * ` actions ` is a set of actions ( defined in table [ tab : action ] ) , * @xmath13 is a space consisting of the union of all the parameters used by the necessary and sufficient conditions of each ` action ` , * @xmath15 is a directed graph whose vertices are elements of @xmath13 , * @xmath16 is a queue which manages confirmation jobs ( see table [ tab : action ] ) .    an important feature of our algorithm is the exploration of transitions between various action categories . each time vertices are added for one action",
    ", the other actions will be queried to see if they can transition from it ( alg .",
    "[ alg : explore ] , line [ alg : explore : transition ] ) .",
    "this allows different actions to be interlaced with each other within the graph .",
    "each action keeps track of its own exploration by storing a set of subgraphs , @xmath17 , consisting of its own vertices and edges . at the same time",
    ", the possibility graph maintains the `` master '' graph , @xmath15 , which combines all the subgraphs of all the different action types .",
    "the algorithm is illustrated by a toy example in fig .",
    "[ fig : cartoon ] .    over time , the possibility graph will consist of vertices and edges from various actions interlaced with each other . some elements of the graph will satisfy the sufficient conditions of their respective actions , but some will only satisfy the necessary conditions .",
    "once the graph contains a path from the start vertex to a goal vertex , we need to inspect the vertices and edges of that path to confirm whether all the path elements are truly feasible .",
    "this process is shown in the ` confirmpath ` function of alg .",
    "[ alg : confirmation ] .",
    "actions are responsible for spawning `` confirmation jobs '' which are low - level planning routines whose job is to verify whether or not an edge in the possibility graph is truly feasible .",
    "these routines are loaded into the confirmation queue , @xmath16 .",
    "the confirmation queue will rotate between running each job to ensure that easy ones are finished promptly while difficult ones do not halt the overall confirmation progress .",
    "these jobs are executed on threads which run parallel to the graph expansion and each other .",
    "this allows the planner to search for alternative potential solutions when certain edges are difficult to confirm .",
    "lll + ` extendtowards`(@xmath18 , @xmath19 ) : & create a vertex by moving towards @xmath19 from @xmath18 + & via this action .",
    "+ @xmath20 : & return * true * if @xmath2 meets the action s necessary conditions , + & otherwise return * false*. @xmath2 may be a vertex or an edge .",
    "+ @xmath21 : & return * true * if @xmath2 meets the action s sufficient conditions , + & otherwise return * false*. @xmath2 may be a vertex or an edge .",
    "+ ` transitionfrom`(@xmath22 ) : & attempt to return a path that goes from @xmath22 into the + & necessary condition manifold of this action .",
    "+ ` spawnconfirmationjob`(@xmath23 ) : & return a routine ( called a confirmation job ) which can + & examine edge @xmath23 to ascertain whether it is truly feasible .",
    "+   + ` project`(@xmath22 ) : & attempt to return a point on the necessary + & condition manifold which is close to @xmath22 .",
    "+   + ` reverseextend`(@xmath18 , @xmath19 ) : & create a vertex which can arrive at @xmath18 from the + & direction of @xmath19 via this action .",
    "+ ` findlaunchpoint`(@xmath22 , @xmath19 ) : & return a point , @xmath18 , close to @xmath22 which can be used + & in a call to ` extendtowards`(@xmath18 , @xmath19 ) + ` findlandingpoint`(@xmath22 , @xmath19 ) : & return a point , @xmath18 , close to @xmath22 which can be used + & in a call to ` reverseextend`(@xmath18 , @xmath19 ) +    for the possibility graph to explore actions , we need to fully define each action type .",
    "table [ tab : action ] lays out the implementation - dependent functions which must be engineered for each action type .",
    "the functions in that table enable the ` growtowards ` and ` performtransitions ` functions to work . `",
    "performtransitions ` is described in alg .",
    "[ alg : transitions ] .",
    "it simply pulls vertices from other actions out of a queue and attempts to create transitions from those actions to itself . `",
    "growtowards ` serves two primary roles : ( 1 ) expand the graph in new directions , and ( 2 ) connect together disjoint subgraphs .",
    "the nature of how an action grows will depend on what kind of action it is .",
    "for this paper , we have two methods of expanding an action , one for holonomic actions and the other for nonholonomic .",
    "* holonomic actions * are expanded using alg . [ alg : holonomic_growth ] . when we describe an action as `` holonomic '' in this context , we mean that its sufficient / necessary condition manifold is holonomic .",
    "even if the full feasibility constraint manifold of the action is nonholonomic , it can be treated as holonomic by the possibility graph if its necessary / sufficient condition manifold is simplified to be holonomic within the exploration space , @xmath13 .",
    "[ alg : holonomic_growth ] shows how the possibilities of holonomic actions are expanded .",
    "importantly , holonomic actions always try to connect disjoint subgraphs together .",
    "this procedure is very similar to the growth of a cbirrt @xcite , except that it accommodates numerous directional subgraphs .",
    "to avoid having subgraphs needlessly cross over each other , we only extend two at a time : the subgraph who has the vertex closest to the random target is extended towards the target up to some point @xmath18 [ alg .",
    "[ alg : holonomic_growth ] , line [ alg : holonomic_growth : first_connect ] ] ( at which point it can not extend any further ) ; then the second closest subgraph attempts to connect to @xmath18 [ alg . [ alg : holonomic_growth ] , line [ alg : holonomic_growth : second_connect ] ] .",
    "however , if the first subgraph was goal - connected , then the second subgraph must not be ( i.e. we skip over the next closest subgraph until we reach one which is not goal - connected ) , because connecting together two goal - connected subgraphs can not help in finding a solution .",
    "* nonholonomic actions * are expanded in a more complex way than holonomic actions , as shown in alg .",
    "[ alg : nonholonomic_growth ] .",
    "nonholonomic actions generally can not move directly towards a goal , so they need to `` line themselves up '' first .",
    "we do this by identifying a launch point which is reachable from an existing point on the graph [ alg .",
    "[ alg : nonholonomic_growth ] , line [ alg : launch ] ] .",
    "the launch point should be chosen such that it allows the action to land as close to the randomly generated target as possible , so long as the launch point is still reachable from the existing graph .",
    "since nonholonomic actions are also generally direction - dependent , we do the reverse for goal - connected subgraphs [ alg .",
    "[ alg : nonholonomic_growth ] , line [ alg : land ] ] : pick a landing point which can connect to an existing goal - connected vertex such that it has a viable launch point coming from the direction of the target .",
    "section [ sec : standing_long_jump ] describes this for the jump action .",
    "in this paper , we implement three action types to serve as a proof of concept .",
    "two are holonomic and one is nonholonomic .",
    "they include walking , crawling , and a standing long jump .",
    "we use a model of the drc - hubo1 robot , because its kinematic structure is designed to accommodate crawling .",
    "the scenarios in which we apply these actions will be discussed in sec .",
    "[ sec : experimental ] . for the exploration space of the possibility graph , @xmath13",
    ", we use the se(3 ) coordinates of a reference frame attached to the robot s pelvis .      the walking and crawling actions",
    "are formulated very similarly to each other .",
    "sufficient conditions for walking and crawling are holonomic , and include these simplifications :    1 .",
    "we use a swept collision geometry , similar to @xcite .",
    "the geometries can be seen in fig .",
    "[ fig : sweeps ] .",
    "these geometries must not be in collision with the environment when given a point in @xmath13 .",
    "each point that defines the robot s support polygon must be touching flat ground when the robot is in a `` nominal '' walk / crawl configuration .",
    "the nominal configurations can be seen in fig .",
    "[ fig : sweeps ] .",
    "3 .   the root must be in the `` nominal '' orientation of the action ( upright for walking and pitched backwards @xmath24 for crawling ) .",
    "the necessary conditions are significantly easier to satisfy :    1 .",
    "we use only the collision geometry of the pelvis , because all other bodies depend on joint parameters which are not included in @xmath13 .",
    "2 .   at least one foot must be able to reach some ground surface .",
    "the ` extendtowards`(@xmath25 ) function simply applies an se(3 ) transform which translates and rotates @xmath18 to bring it closer to @xmath19 .",
    "changes in rotation should be weighted less than changes in translation in order to have sensible differences between steps .",
    "the ` project ` function for these action templates adjusts the height and orientation of the se(3 ) input so that it matches the nominal configuration of the action .",
    "translation in @xmath2/@xmath3 and rotation along @xmath1 are unaffected .",
    "the ` transitionfrom ` function moves between these actions by generating a simple motion that goes from one nominal configuration to the other .",
    "if an edge only meets the necessary conditions of the action , then another planning method ( such as multi - modal prm ) must be generated by the ` spawnconfirmationjob ` function .",
    "on the other hand , when the sufficient conditions are satisfied , the final motion for these actions is easily determined by placing footsteps along the specified route through se(3 ) and then generating a whole body motion to follow those footsteps .",
    "our sufficient conditions guarantee that it will be possible to generate and follow those footsteps .",
    "the nominal configurations used for ( a ) walking and ( b ) crawling , with their swept geometries surrounding them.,title=\"fig:\",scaledwidth=30.0% ] the nominal configurations used for ( a ) walking and ( b ) crawling , with their swept geometries surrounding them.,title=\"fig:\",scaledwidth=40.0% ]    \\(a ) ( b )    an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ] an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ] an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ] an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ] an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ] an example standing long jump trajectory .",
    "the robot begins from a standing configuration , swings its arms , and jumps forward .",
    "it plans out its angular momentum so that it is able to land in a crawling configuration . after hitting the ground",
    ", it absorbs some of the impact by letting its joints behave elastically.,title=\"fig:\",scaledwidth=16.0% ]      a standing long jump is a forward jump which begins from standing in place and launches forward without taking any steps .",
    "figure [ fig : jump ] shows an example of a jumping trajectory .",
    "we use a standing long jump in this paper for simplicity ; future work will include long jumps that take running starts , which can achieve considerably greater range .",
    "we provide necessary conditions for the standing long jump but not sufficient conditions .",
    "the necessary condition manifold is nonholonomic , and contains the following :    1 .",
    "the vertex that begins the jump must be a valid walk vertex .",
    "the vertex that finishes the jump must be a valid crawl vertex .",
    "3 .   there must be at least one collision - free parabola through @xmath13 from the beginning vertex to the finishing vertex .",
    "the parabola must follow a feasible jump arc according to the physical limitations of the robot .    the ` transitionfrom ` function for the jump action is trivial , because it always begins from valid walking configurations and ends in valid crawling configurations , therefore the transition function does nothing .",
    "the ` extendtowards`(@xmath25 ) function performs a forward jump from @xmath18 to @xmath19 .",
    "if @xmath19 is too far to reach from @xmath18 , then it performs the furthest allowable jump .",
    "the ` reverseextend`(@xmath25 ) function instead performs a jump which lands at @xmath18 and begins as close to @xmath19 as the robot s physical limitations allow .",
    "the ` findlaunchingpoint`(@xmath26 ) function returns a point , @xmath18 , whose translation is the same as @xmath22 but whose orientation has the robot facing @xmath19 ; this allows the ` extendtowards`(@xmath25 ) function to bring the robot closer to @xmath19 .",
    "conversely , the ` findlandingpoint`(@xmath26 ) function returns a point , @xmath18 , whose translation is the same as @xmath22 but which is facing _ away _ from @xmath19 ; this allows the robot to jump towards @xmath22 from the direction of @xmath19 using ` reverseextend`(@xmath25 ) .",
    "the ` spawnconfirmationjob ` function of the jump action is a basic collocation optimization on a boundary value problem .",
    "the boundary value constraints are ( 1 ) zero initial velocity , ( 2 ) a take - off configuration and velocity which will allow the robot to reach its jump target .",
    "the objective function of the optimization problem attempts to minimize the accelerations during take - off . while generating the trajectory , we also check that the joint and contact forces required to achieve the trajectory are physically feasible .",
    "trajectories which fail this test are discarded .",
    "once the jump is generated , we can check for collisions along its trajectory .",
    "if the jump was successfully generated ( i.e. the jumping motion is physically feasible ) and is collision - free , then its `` possibility '' status is changed from `` indeterminate '' to `` possible '' , and it can be used in a final solution .",
    "we run performance tests on three scenarios ( one of which has three versions ) .",
    "each performance test is the result of 50 trials .",
    "the possibility graph is a randomized planner , so the time required for the same trial can vary between runs .",
    "we put a 60 second time limit on the planner ; if a solution is not found within 60 seconds , we consider it a failed run .",
    "* * three routes * scenario is shown in fig .",
    "[ fig : threeroutes ] .",
    "there are three potential routes that the robot might take to get from the start to the goal .",
    "we have three different versions of this scenario , and each version has progressively stronger requirements for what actions are needed by the solution , allowing us to compare the performance impact caused by specific action sequences being required . *",
    "* hallway * scenario was shown in fig .",
    "[ fig : hallway ] .",
    "the robot must crawl underneath some bars and then jump across a gap to get from the start on the right side to the goal on the left . * * double jump * scenario is shown in fig .",
    "[ fig : doublejump ] . the robot must jump twice to get from the right side to the left .    in table",
    "[ tab : results ] we see that the time required to solve a problem scales up with the number of actions being used ( comparing the values in the * graph * column of rows 13 and 45 ) . for every action that is utilized by the planner , more exploration needs to be performed , which tends to increase the runtime .",
    "not only does the action s space get explored , but also the transitions between the actions need to be explored",
    ". however , this cost is additive , not multiplicative , so the overall costliness will be related to the sum ( not product ) of the costliness of the individual actions .",
    "jumping exploration is considerably more expensive than walking or crawling exploration . to curb this",
    ", we can modify alg .",
    "[ alg : explore ] , line [ alg : explore : growtowards ] so that there is some probability of skipping the jumping expansion each cycle . in the results of table [",
    "tab : results ] , we use a 90% chance of skipping .",
    "we can also see that the time required to solve a problem scales up with the number of actions _ required _ by the environment to get a solution ( comparing the * graph * values of row 2 to 4 and of row 3 to 5 ) .",
    "this is not surprising since requiring certain actions can be viewed as tightening the constraints on the solution , and tighter constraints tend to take longer to solve with randomized search .",
    ".[tab : results]time performance results , tested on an intel^^ xeon^^ processor e3 - 1290 v2 ( 8 m cache , 3.70 ghz ) with 16 gb of ram .",
    "@xmath27 is the number of action types that were provided to the planner .",
    "`` graph '' is the time it took to generate a solved graph .",
    "`` motion '' is the time it took to generate the physical motions for the solution .",
    "@xmath28 is the `` real - time ratio '' , i.e. the time it would take to execute the plan divided by how long the whole plan ( graph+motion ) took to generate .",
    "`` success rate '' is how many times the planner succeeded ( instead of timing out ) .",
    "all times are given in seconds .",
    "each result is the average of 50 runs ; the standard deviation is given in parentheses .",
    "[ cols=\"<,^,<,<,<,>\",options=\"header \" , ]      the three versions of the `` three routes '' scenario .",
    "the robot must get from the back left corner to the back right corner .",
    "( a ) a route exists that allows the robot to walk all the way to the goal .",
    "( b ) some bars were added to the walking route , so the robot must crawl at least once to reach the goal .",
    "( c ) a gap was added at the end of the crawling routes , so the robot must jump at least once to reach the goal .",
    "( d ) a grid that shows the map being explored.,title=\"fig:\",scaledwidth=48.0% ]   the three versions of the `` three routes '' scenario .",
    "the robot must get from the back left corner to the back right corner .",
    "( a ) a route exists that allows the robot to walk all the way to the goal .",
    "( b ) some bars were added to the walking route , so the robot must crawl at least once to reach the goal .",
    "( c ) a gap was added at the end of the crawling routes , so the robot must jump at least once to reach the goal .",
    "( d ) a grid that shows the map being explored.,title=\"fig:\",scaledwidth=48.0% ]    \\(a ) ( b )     the three versions of the `` three routes '' scenario .",
    "the robot must get from the back left corner to the back right corner .",
    "( a ) a route exists that allows the robot to walk all the way to the goal .",
    "( b ) some bars were added to the walking route , so the robot must crawl at least once to reach the goal .",
    "( c ) a gap was added at the end of the crawling routes , so the robot must jump at least once to reach the goal .",
    "( d ) a grid that shows the map being explored.,title=\"fig:\",scaledwidth=48.0% ]   the three versions of the `` three routes '' scenario .",
    "the robot must get from the back left corner to the back right corner . ( a )",
    "a route exists that allows the robot to walk all the way to the goal .",
    "( b ) some bars were added to the walking route , so the robot must crawl at least once to reach the goal .",
    "( c ) a gap was added at the end of the crawling routes , so the robot must jump at least once to reach the goal .",
    "( d ) a grid that shows the map being explored.,title=\"fig:\",scaledwidth=48.0% ]    \\(c ) ( d )     the `` double jump '' scenario .",
    "the robot must jump across two gaps and navigate around a wall in the middle to get from the right side to the left side.,title=\"fig:\",scaledwidth=48.0% ]   the `` double jump '' scenario .",
    "the robot must jump across two gaps and navigate around a wall in the middle to get from the right side to the left side.,title=\"fig:\",scaledwidth=48.0% ]      our experiments only used sufficient conditions for walking and crawling ; any actions which violate the sufficient conditions for walking and crawling are ignored . unfortunately , this eliminates the probabilistic completeness of the implementation .",
    "a more complete approach would consider the necessary conditions of walking and crawling , and then employ multi - modal prm @xcite to examine walking / crawling segments where only the necessary conditions are met .",
    "this would allow the robot to step over small obstructions and squeeze through narrow passages between obstacles .",
    "these considerations will be the topic of future work .",
    "we presented performance results of multi - action traversal plans being generated for the drc - hubo1 platform in complex environments .",
    "the complexity of the environments is derived from the fact that they require a variety of different action types to be interlaced in the correct sequence in order to navigate from the start to the goal .",
    "three action types were used to traverse these environments : walking , crawling , and the standing long jump .",
    "the time required to fully generate the motion plans was less than 1/100th of the time that the motions require for physical execution .",
    "this makes the possibility graph a promising option for online use .",
    "moreover , the time required to guarantee that a solution exists is even smaller , which suggests that the possibility graph would be an effective tool for higher - level task planners such as the hybrid backward - forward planner @xcite which only needs to know whether a query is solvable .    the theoretical framework of the possibility graph can extend beyond the applications seen here .",
    "future work will incorporate multi - modal prm to achieve probabilistic completeness in the quasi - static domain .",
    "we will also incorporate highly dynamic actions , e.g. running jumps , using nonlinear constrained optimization .",
    "this will open the door to fast , global , dynamic planning for high dimensional systems .",
    "zucker , m. , ratliff , n. , dragan , a.d .",
    ", pivtoraiko , m. , klingensmith , m. , dellin , c.m . , bagnell , j.a . ,",
    "srinivasa , s.s . :",
    "chomp : covariant hamiltonian optimization for motion planning .",
    "j. of rob .",
    ", 32(9 - 10 ) , 11641193 ( 2013 )    kuindersma , s. , deits , r. , fallon , m. , valenzuela , a. , dai , h. , permenter , f. , koolen , t. , marion , r. , tedrake , r. : optimization - based locomotion planning , estimation , and control design for the atlas humanoid robot . autonomous robots , 40(3 ) , 429455 ( 2016 )    hereid , a. , cousineau , e.a . , hubicki , c.m . , ames , a.d .",
    ": 3d dynamic walking with underactuated humanoid robots : a direct collocation framework for optimizing hybrid zero dynamics .",
    "ieee trans . on rob . and aut ."
  ],
  "abstract_text": [
    "<S> locomotion for legged robots poses considerable challenges when confronted by obstacles and adverse environments . </S>",
    "<S> footstep planners are typically only designed for one mode of locomotion , but traversing unfavorable environments may require several forms of locomotion to be sequenced together , such as walking , crawling , and jumping . </S>",
    "<S> multi - modal motion planners can be used to address some of these problems , but existing implementations tend to be time - consuming and are limited to quasi - static actions . </S>",
    "<S> this paper presents a motion planning method to traverse complex environments using multiple categories of actions . </S>",
    "<S> we introduce the concept of the `` possibility graph '' , which uses high - level approximations of constraint manifolds to rapidly explore the `` possibility '' of actions , thereby allowing lower - level single - action motion planners to be utilized more efficiently . </S>",
    "<S> we show that the possibility graph can quickly find paths through several different challenging environments which require various combinations of actions in order to traverse . </S>"
  ]
}