{
  "article_text": [
    "in many applications one has to deal with computational problems where some parts of the input data are imprecise or uncertain .",
    "for example , in a geometric problem involving sets of points , the locations of the points might be known only approximately ; effectively this means that instead of the location of a point , only a region or area containing that point is known . in other applications ,",
    "only estimates of certain input parameters may be known , for example in form of a probability distribution .",
    "there are many different approaches to dealing with problems of this type , including e.g.  stochastic optimization and robust optimization .    pursuing a different approach ,",
    "we consider a setting in which the algorithm can obtain exact information about an input data item using an _ update _ operation , and we are interested in the _ update complexity _ of an algorithm , i.e. , our goal is to compute a correct solution using a minimum number of updates .",
    "the updates are adaptive , i.e. , one selects the next item to update based on the result of the updates performed so far , so we refer to the algorithm as an _ on - line algorithm_. there are a number of application areas where this setting is meaningful . for example , in a mobile ad - hoc network an algorithm may have knowledge about the approximate locations of all nodes , and it is possible ( but expensive ) to find out the exact current location of a node by communicating to that node and requesting that information . to assess the performance of an algorithm , we compare the number of updates that the algorithm makes to the optimal number of updates . here",
    ", optimality is defined in terms of an adversary , who , knowing the values of all input parameters , makes the fewest updates needed to present a solution to the problem that is provably correct , in that no additional areas need to be updated to verify the correctness of the solution claimed by the adversary .",
    "we say that an algorithm is _ @xmath4-update competitive _ if , for each input instance , the algorithm makes at most @xmath4 times as many updates as the optimum number of updates for that input instance .",
    "the notions of update complexity and @xmath4-update competitive algorithms were implicit in kahan s model for data in motion  @xcite and studied further for two - dimensional geometric problems by bruce et al .",
    "@xcite .    in this paper",
    ", we consider the classical minimum spanning tree ( mst ) problem in two settings with uncertain information . in the first",
    "setting , the edge weights are initially given as uncertainty areas , and the algorithm can obtain the exact weight of an edge by updating the edge . if the uncertainty areas are trivial ( i.e. , contain a single number ) or ( topologically ) open , we give a @xmath5-update competitive algorithm and show that this is best possible for deterministic algorithms . without this restriction on the areas , it is easy to construct degenerate inputs for which there is no constant update competitive algorithm .",
    "although degeneracy could also be excluded by other means ( similar to the `` general position '' assumption in computational geometry ) , our condition is much cleaner .    in the second setting that we consider , the vertices of the graph correspond to points in euclidean space , and the locations of the points",
    "are initially given as uncertainty areas .",
    "the weight of an edge equals the distance between the points corresponding to its vertices .",
    "the algorithm can update a vertex to reveal its exact location .",
    "we give a general relation between the edge uncertainty version and the vertex uncertainty version of a problem .",
    "for trivial or open uncertainty areas we obtain a @xmath6-update competitive algorithm for the mst problem with vertex uncertainty and show again that this is optimal for deterministic algorithms .    * related work .",
    "* we do not attempt to survey the vast literature dealing with problems on uncertain data , but focus on work most closely related to ours .",
    "kahan @xcite studied the problem of finding the maximum , the median and the minimum gap of a set of @xmath7 real values constrained to fall in a given set of @xmath7 real intervals . in the spirit of competitive analysis",
    ", he defined the _",
    "lucky ratio _ of an update strategy as the worst - case ratio between the number of updates made by the strategy and the optimal number of updates of a non - deterministic strategy . in our terminology ,",
    "a strategy with lucky ratio @xmath4 is @xmath4-update competitive .",
    "kahan gave strategies with optimal lucky ratios for the problems considered @xcite .",
    "bruce et al .  studied the problems of computing maximal points or the points on the convex hull of a set of uncertain points @xcite and presented @xmath8-update competitive algorithms .",
    "they introduced a general method , called the _ witness algorithm _ , for dealing with problems involving uncertain data , and derived their @xmath8-update competitive algorithms using that method .",
    "the algorithms we present in this paper are based on the method of the witness algorithm of @xcite , but the application to the mst problem is non - trivial .",
    "feder et al .",
    "@xcite , consider two problems in a similar framework to ours .",
    "firstly , they consider the problem of computing the median of @xmath7 numbers to within a given tolerance .",
    "each input number lies in an interval , and an update reveals the exact value , but different intervals have different update costs .",
    "they consider off - line algorithms , which must decide the sequence of updates prior to seeing the answers , as well as on - line ones , aiming to minimize the total update cost . in @xcite , off - line algorithms for computing the length of a shortest path from a source @xmath9 to a given vertex @xmath10",
    "are considered .",
    "again , the edge lengths lie in intervals with different update costs , and they study the computational complexity of minimizing the total update cost .",
    "one difference between the framework of feder et al .",
    "and ours is that they require the computation of a specific numeric value ( the value of the median , the length of a shortest path ) .",
    "we , on the other hand , aim to obtain a subset of edges that form an mst . in general",
    ", our version of the problem may require far fewer updates .",
    "indeed , for the mst with vertex uncertainties , it is obvious that one must update all non - trivial areas to compute the cost of the mst exactly .",
    "however , the cost of the mst may not be needed in many cases : if the mst is to be used as a routing structure in a wireless ad - hoc network , then it suffices to determine the edge set . also , our algorithms aim towards on - line optimality against an adversary , whereas their off - line algorithms aim for static optimality .    further work in this vein attempts to compute other aggregate functions to a given degree of tolerance , and establishes tradeoffs between update costs and error tolerance or presents complexity results for computing optimal strategies , see e.g.  @xcite .",
    "another line of work considers the robust spanning tree problem with interval data . for a given graph with weight intervals specified for its edges ,",
    "the goal is to compute a spanning tree that minimizes the worst - case deviation from the minimum spanning tree ( also called the _ regret _ ) , over all realizations of the edge weights .",
    "this is an off - line problem , and no update operations are involved .",
    "the problem is proved @xmath11-hard in  @xcite .",
    "a @xmath5-approximation algorithm is given in  @xcite .",
    "further work has considered heuristics or exact algorithms for the problem , see e.g.  @xcite .    in the setting of geometric problems with imprecise points , lffler and van kreveld",
    "have studied the problem of computing the largest or smallest convex hull over all possible locations of the points inside their uncertainty areas  @xcite . here ,",
    "the option of updating a point does not exist , and the goal is to design fast algorithms computing an extremal solution over all possible choices of exact values of the input data .    the remainder of the paper is organized as follows . in section  [ sec : prelim ] , we define our problems and introduce the witness algorithm of @xcite in general form .",
    "sections  [ sec : edgeu ] and  [ sec : vertexu ] give our results for msts with edge and vertex uncertainty , respectively .",
    "the mst - edge - uncertainty problem is defined as follows : let @xmath12 be a connected , undirected , weighted graph .",
    "initially the edge weights @xmath2 are unknown ; instead , for each edge @xmath0 an area @xmath1 is given with @xmath3 . when updating an edge @xmath0 , the value of @xmath2 is revealed .",
    "the aim is to find ( the edge set of ) an mst for @xmath13 with the least number of updates .    in applications such as mobile ad - hoc networks",
    "it is natural to assume the vertices of our graph are embedded in two or three dimensional space .",
    "this leads to the mst - vertex - uncertainty problem defined as follows : let @xmath12 be a connected , undirected , weighted graph .",
    "the vertices correspond to points in euclidean space .",
    "we refer to the point @xmath14 corresponding to a vertex @xmath15 as its _",
    "location_. the weight of an edge is the euclidean distance between the locations of its vertices . initially the locations of the vertices are not known",
    "; instead , for each vertex @xmath15 an area @xmath16 is given with @xmath17 , where @xmath14 is the actual location of vertex  @xmath15 .",
    "when a vertex @xmath15 is updated , the location @xmath14 is revealed .",
    "the aim is to find an mst for @xmath13 with the least number of updates .",
    "formally we are interested in on - line update problems of the following type : each problem instance @xmath18 consists of an ordered set of data @xmath19 , also called a configuration , and a function @xmath20 such that @xmath21 is the set of solutions for @xmath22 .",
    "( the function @xmath20 is the same for all instances of a problem and can thus be taken to represent the problem . ) at the beginning the set @xmath23 is not known to the algorithm ; instead , an ordered set of areas @xmath24 is given , such that @xmath25 is an element of @xmath26 .",
    "the sets @xmath26 are called _ areas of uncertainty _ or _ uncertainty areas _ for @xmath23 . we say that an uncertainty area @xmath26 that consists of a single element is _",
    "trivial_. for example , in the mst - edge - uncertainty problem , @xmath23 consists of the given graph @xmath12 and its @xmath27 actual edge weights .",
    "the ordered set of areas @xmath28 specifies the graph @xmath13 exactly ( so we assume complete knowledge of @xmath13 ) and , for each edge  @xmath29 , contains an area @xmath1 giving the possible values the weight of @xmath0 may take .",
    "then @xmath21 is the set of msts of the graph with edge weights given by @xmath23 , each tree represented as a set of edges .    for a given set of uncertainty areas @xmath24 , an area @xmath26 can be _ updated _ , which reveals the exact value of @xmath30 . after updating @xmath26 ,",
    "the new ordered set of areas of uncertainty for @xmath23 is @xmath31 .",
    "updating all non - trivial areas would reveal the configuration @xmath23 and would obviously allow us to calculate an element of @xmath21 ( under the natural assumption that @xmath20 is computable ) .",
    "the aim of the on - line algorithm is to minimize the number of updates needed in order to compute an element of @xmath21 .",
    "an algorithm is @xmath4-update competitive for a given problem @xmath20 if for every problem instance @xmath18 the algorithm needs at most @xmath32 updates , where @xmath33 is a constant and @xmath34 is the minimum number of updates needed to verify an element of @xmath21 .",
    "( for our algorithms we can take @xmath35 , but our lower bounds apply also to the case where @xmath33 can be an arbitrary constant . ) note that the primary aim is to minimize the number of updates needed to calculate a solution .",
    "we do not consider running time or space requirements in detail , but note that our algorithms are clearly polynomial , provided that one can obtain the infimum and supremum of an area in @xmath36 time , an assumption which holds e.g.  if areas are open intervals .",
    "as an example , consider the instance of mst - edge - uncertainty shown in figure  [ fig : example](a ) , where each edge is labeled with its actual weight ( in bold ) and its uncertainty area ( an open interval ) .",
    "updating the edge @xmath37 leads to the situation shown in figure  [ fig : example](b ) and suffices to verify that the edges @xmath38 , @xmath39 and @xmath37 form an mst regardless of the exact weights of the edges that have not yet been updated .",
    "if no edge is updated , one can not exclude that an mst includes the edge @xmath40 instead of @xmath37 , as the former could have weight @xmath41 and the latter weight @xmath42 , for example .",
    "therefore , for the instance of mst - edge - uncertainty in figure  [ fig : example](a ) the minimum number of updates is  @xmath43 .",
    "the witness algorithm for problems with uncertain input was first introduced in @xcite .",
    "this section describes the witness algorithm in a more general setting and notes some of its properties .",
    "we call @xmath44 a _ witness set _ of @xmath45 if for every possible configuration @xmath23 ( where @xmath46 ) no element of @xmath21 can be verified without updating an element of @xmath47 . in other words ,",
    "any set of updates that suffices to verify a solution must update at least one area of  @xmath47 .",
    "the witness algorithm for a problem instance @xmath18 is shown in figure  [ fig : witnessalgo ] .    wwwwwwww= * if * an element of @xmath21 can not be calculated from @xmath28 * then * + find a witness set @xmath47 + update all areas in @xmath47 + let @xmath48 be the areas of uncertainty after updating @xmath47 + restart the algorithm with @xmath49 + * end if * + * return * an element of @xmath21 that can be calculated from @xmath28    for two ordered sets of areas @xmath50 and @xmath51 we say that @xmath52 is at least as narrow as @xmath28 if @xmath53 for all @xmath54 .",
    "the following lemma is easy to prove .",
    "[ lem : narrow ] let @xmath18 be a problem instance and @xmath52 be a narrower set of areas than @xmath28 .",
    "further let @xmath47 be a witness set of @xmath55 .",
    "then @xmath47 is also a witness set of @xmath45 .",
    "[ th : global_bound ] if there is a global bound @xmath4 on the size of any witness set used by the witness algorithm , then the witness algorithm is @xmath4-update competitive .",
    "theorem  [ th : global_bound ] was proved in a slightly different setting in  @xcite , but the proof carries over to the present setting in a straightforward way by using lemma  [ lem : narrow ] .",
    "in this section we present an algorithm u - red for the problem mst - edge - uncertainty . in the case",
    "that all areas of uncertainty are either open or trivial , algorithm u - red is @xmath5-update competitive , which we show is optimal .",
    "furthermore , we show that for arbitrary areas of uncertainty there is no constant update competitive algorithm .",
    "first , let us recall a well known property , usually referred to as the _ red rule _",
    "@xcite , of msts :    [ out ] let @xmath13 be a weighted graph and let @xmath23 be a cycle in  @xmath13 . if there exists an edge @xmath56 with @xmath57 for all @xmath58 , then @xmath0 is not in any mst of  @xmath13 .",
    "we will use the following notations and definitions : a graph @xmath59 with an area @xmath1 for each edge @xmath29 is called an _ edge - uncertainty graph_. we say a weighted graph @xmath12 with edge weights @xmath2 is a _ realization _ of @xmath60 if @xmath61 for every @xmath62 . note that @xmath2 is associated with @xmath13 and @xmath1 with @xmath60 .",
    "we also say that an edge @xmath0 is _ trivial _ if the area @xmath1 is trivial .    for an edge @xmath0 in an edge - uncertainty graph",
    "we denote the upper limit of @xmath1 by @xmath63 and the lower limit of @xmath1 by @xmath64 .",
    "we extend the notion of an mst to edge - uncertainty graphs in the following way : let @xmath60 be an edge - uncertainty graph .",
    "we say @xmath65 is an _ mst of @xmath60 _ if @xmath65 is an mst of every realization of  @xmath60 .",
    "clearly not every edge - uncertainty graph has an mst .",
    "let @xmath23 be a cycle in @xmath60 .",
    "we say the edge @xmath56 is an _ always maximal _ edge in @xmath23 if @xmath66 for all @xmath67 .",
    "therefore in every realization @xmath13 of @xmath60 we have @xmath68 for all @xmath69 .",
    "note that a cycle can have more than one always maximal edge and not every cycle has an always maximal edge . the following lemma deals with cycles of the latter kind :    [ fg ] let @xmath60 be an edge - uncertainty graph .",
    "let @xmath23 be a cycle in @xmath60 .",
    "let @xmath23 not have an always maximal edge .",
    "then for any @xmath70 with @xmath71 we have that @xmath72 is non - trivial and there exists an edge @xmath73 with @xmath74 .",
    "let @xmath70 be an edge with @xmath75 .",
    "if @xmath76 the edge @xmath72 would be always maximal . hence @xmath77 must be strictly smaller than @xmath78 and @xmath72 is non - trivial .",
    "since there is no always maximal edge in @xmath23 , we have that @xmath79 . therefore there",
    "exists at least one edge @xmath80 in @xmath81 with @xmath82 .",
    "[ path1 ] let @xmath60 be an edge - uncertainty graph with an mst @xmath65 .",
    "let @xmath83 be an edge of @xmath84 such that @xmath85 .",
    "let @xmath22 be the path in @xmath65 connecting @xmath86 and @xmath15 , then @xmath87 for all @xmath88 .",
    "assume there exists a @xmath88 with @xmath89 .",
    "then there exists a realization @xmath13 of @xmath60 with @xmath90 .",
    "hence by removing the edge @xmath91 and adding the edge @xmath72 to @xmath65 we obtain a spanning tree that is cheaper than @xmath65 .",
    "so @xmath65 is not an mst for @xmath13 .",
    "this is a contradiction since @xmath65 is an mst of @xmath60 and therefore of any realization of  @xmath60 .",
    "our algorithm u - red applies the red rule to the given uncertainty graph , but we have to be careful about the order in which edges are considered .",
    "the order we use is as follows : let @xmath60 be an edge - uncertainty graph and let @xmath92 be two edges in @xmath60 .",
    "we say    * @xmath93 if @xmath94 or ( @xmath95 and @xmath96 ) , * @xmath97 if @xmath93 or ( @xmath98 and @xmath99 )",
    ".    edges with the same upper and lower weight limit are ordered arbitrarily .",
    "01 index all edges such that @xmath100 .",
    "+ 02 let @xmath101 be @xmath60 without any edge + 03 * for * @xmath102 from @xmath43 to @xmath103 * do * + 04 add @xmath104 to @xmath101 + 05 * if * @xmath101 has a cycle @xmath23 * then * + 06 * if * @xmath23 contains an always maximal edge @xmath0 * then * + 07 delete @xmath0 from @xmath101 + 08 * else *",
    "+ 09 let @xmath70 such that @xmath105 + 10 let @xmath73 such that @xmath74 + 11 update @xmath72 and @xmath80 + 12 restart the algorithm + 13 * end if * + 14 * end if * + 15 * end for * + 16 * return * @xmath101    algorithm u - red is shown in figure  [ fig : algo ] . observe that :    * in case no update",
    "is made the algorithm u - red will perform essentially kruskal s algorithm @xcite .",
    "when a cycle is created there will be an always maximal edge in that cycle . due to the order in which the algorithm adds the edges to @xmath101 the edge @xmath104 that closes a cycle @xmath23 must be an always maximal edge in @xmath23 .",
    "so where kruskal s algorithm does not add an edge to @xmath101 when it would close a cycle , the u - red algorithm adds this edge to @xmath101 but then deletes it or an equally weighted edge in the cycle from @xmath101 .",
    "* by lemma [ fg ] the edges @xmath106 in line @xmath107 and @xmath108 exist and @xmath72 is non - trivial . * the algorithm will terminate . the algorithm",
    "either updates at least one non - trivial edge @xmath72 and restarts , or does not perform any updates .",
    "hence the algorithm u - red will eventually return an mst of @xmath13 .",
    "* during the run of the algorithm the graph @xmath101 is either a forest or contains one cycle . in case",
    "the most recently added edge closes a cycle either one edge of the cycle will be deleted or after some updates the algorithm restarts and @xmath101 has no edges . hence at any given time there is at most one cycle in @xmath101 .",
    "as the algorithm may restart itself , we say a _ run _ is completed if the algorithm restarts or returns the mst . in case of a restart , another run of",
    "the algorithm starts .    before showing that the algorithm u - red is @xmath5-update competitive under the restriction to open or trivial areas , we discuss some technical preliminaries . in each run",
    "the algorithm considers all edges in a certain order @xmath109 . during the run of the algorithm",
    "we refer to the currently considered edge as @xmath104 .",
    "let @xmath86 and @xmath15 be two distinct vertices . in case @xmath86 and @xmath15 are in the same connected component of the subgraph with edges @xmath110 ,",
    "then they are also connected in the current @xmath101 .",
    "furthermore , we need some properties of a path connecting @xmath86 and @xmath15 in @xmath101 under certain conditions .",
    "the next two lemmas establish these properties .",
    "they are technical and are solely needed in the proof of lemma [ witness_mst_edge ] .",
    "[ lem : singleedge ] let @xmath111 and @xmath0 be two edges in @xmath60 .",
    "let @xmath112 and @xmath113 .",
    "let the algorithm be in a state such that @xmath114 has been considered .",
    "then @xmath86 and @xmath15 are connected in the current @xmath115 .",
    "if the edge @xmath114 is in the current @xmath101 then clearly @xmath86 and @xmath15 are connected in @xmath116 , so assume that @xmath114 is no longer in @xmath101 .",
    "therefore it must have been an always maximal edge in a cycle @xmath23 . in order for @xmath114 to be an always maximal edge in @xmath23",
    "we must have that @xmath117 for all @xmath118 .",
    "so since @xmath119 we have that @xmath120 . also the edge @xmath114 can not be an always maximal edge in @xmath23 if @xmath23 contains @xmath0 .",
    "clearly @xmath121 is a path in @xmath122 connecting @xmath86 and @xmath15 and does not contain @xmath0 .",
    "since the edges in @xmath123 might have been deleted from the current @xmath101 themselves we have to use this argument repeatedly , but eventually we get a path in the current @xmath116 connecting @xmath86 and @xmath15 .",
    "the next lemma follows directly from lemma  [ lem : singleedge ] .",
    "[ path ] let @xmath124 be vertices and @xmath0 be an edge in @xmath60 .",
    "let @xmath22 be a path in @xmath125 connecting @xmath86 and @xmath15 with @xmath126 for all @xmath88 .",
    "let the algorithm be in a state such that all edges of @xmath22 have been considered , then there exists a path @xmath127 in the current @xmath101 connecting @xmath86 and @xmath15 with @xmath128 .",
    "[ witness_mst_edge ] assume that all uncertainty areas are open or trivial .",
    "the edges @xmath72 and @xmath80 as described in the algorithm u - red at line @xmath107 and @xmath108 form a witness set .",
    "we have the following situation : there exist a cycle @xmath23 in @xmath101 with no always maximal edge .",
    "let @xmath129 .",
    "the edges @xmath72 and @xmath80 are in @xmath23 with @xmath130 and @xmath131 . by lemma [ fg ]",
    "the area @xmath132 is non - trivial .",
    "we now assume that the set @xmath133 is not a witness set .",
    "so we can update some edges , but not @xmath72 or @xmath80 such that the resulting edge - uncertainty graph @xmath134 has an mst @xmath65 .",
    "let @xmath135 and @xmath136 denote the upper and lower limit of an area for an edge @xmath0 with regard to @xmath134 .",
    "since both edges @xmath72 and @xmath80 are not updated we note that @xmath137    since all areas in @xmath134 and @xmath60 are either trivial or open , and @xmath23 has no always maximal edge , the weight of every edge in @xmath23 must be less than @xmath103 .",
    "in particular we have that for all @xmath138 @xmath139 since @xmath140 there exists a realization @xmath141 of @xmath134 and @xmath60 , where the weight of @xmath72 is greater than the weight of any other edge in @xmath23 . by proposition",
    "[ out ] the edge @xmath72 is not in any mst of @xmath141 and therefore also not in @xmath65 .",
    "let @xmath86 and @xmath15 be the vertices of @xmath72 . by proposition [ path1 ] there",
    "exists a path @xmath22 in @xmath134 connecting @xmath86 and @xmath15 with @xmath142 for all @xmath143 . since @xmath74 and neither @xmath72 nor @xmath80",
    "are updated the edge @xmath80 is not in the path @xmath22 .",
    "we now argue that all edges of @xmath22 must have been already considered by the algorithm . for this",
    "we look at the following two cases :    case 1 ) let @xmath88 and @xmath144 . since @xmath145 we have that @xmath146 .",
    "case 2 ) let @xmath88 and @xmath147 . since @xmath148 we have that @xmath149 .",
    "either the area @xmath150 is also trivial ( @xmath151 ) or @xmath150 is open and contains the point @xmath152 , in this case @xmath153 .",
    "so for all @xmath143 we have @xmath154 .",
    "therefore all edges of @xmath22 will be considered before @xmath72 .",
    "we also note that @xmath155 for all @xmath88 . by lemma [ path ] there",
    "exists a path @xmath156 in @xmath101 connecting @xmath86 and @xmath15 and @xmath157 .",
    "hence @xmath101 has two cycles , which is a contradiction .",
    "using theorem  [ th : global_bound ] , this leads directly to the following result .",
    "[ 2competitive ] under the restriction to open and trivial areas the algorithm u - red is @xmath5-update competitive .",
    "we remark that the analysis of algorithm u - red actually works also in the more general setting where it is only required that every area is trivial or satisfies the following condition : the area contains neither its infimum nor its supremum .",
    "it remains to show that under the restriction to open and trivial areas there is no algorithm for the mst - edge - uncertainty problem that is @xmath158-update competitive .",
    "the graph @xmath13 displayed in figure [ lowerbound ] consists of a path and , for each vertex of the path , a gadget connected to that vertex .",
    "each gadget is a triangle with sides @xmath159 and @xmath33 and areas @xmath160 , @xmath161 and @xmath162 . in each gadget",
    "@xmath163 and either @xmath164 or @xmath33 are part of the minimum spanning tree .",
    "if the algorithm updates @xmath164 we let the weight of @xmath164 be @xmath165 .",
    "so @xmath33 needs to be updated , which reveals a weight for @xmath33 of @xmath166 .",
    "however , by updating only @xmath33 the edge @xmath164 would be part of the minimum spanning tree regardless of its exact weight .",
    "if the algorithm updates @xmath33 first , we let the weight of @xmath33 be @xmath165 .",
    "the necessary update of @xmath164 reveals a weight of @xmath6 , and updating only @xmath164 would have been enough .",
    "so in each gadget every algorithm makes two updates where only one is needed by @xmath34 .",
    "hence no deterministic algorithm is @xmath158-update competitive .",
    "the following example shows that without restrictions on the areas there is no algorithm for the mst - edge - uncertainty problem that is constant update competitive .",
    "[ ex : ne ] figure [ badmst - both](a ) shows an example of an edge - uncertainty graph for which no algorithm can be constant update competitive .",
    "the minimum spanning tree consists of all edges incident with @xmath86 and all edges incident with @xmath15 plus one more edge .",
    "let us assume the weight of one of the remaining @xmath167 edges is @xmath5 and the weight of the others is @xmath8 .",
    "any algorithm would need to update these edges until it finds the edge with weight @xmath5 .",
    "this in the worst case could be the last edge and @xmath4 updates were made .",
    "however @xmath34 will only update the edge with weight @xmath5 and therefore @xmath168 .",
    "+ ( a)(b )    note that this example actually shows that there is no algorithm that is better then @xmath169-update competitive , where @xmath7 is the number of vertices of the given graph . by adding edges with uncertainty area @xmath170 $ ] such that the neighbors of @xmath86 and the neighbors of @xmath15 form a complete bipartite graph",
    ", we even get a lower bound of @xmath171 .",
    "the construction in example  [ ex : ne ] works also if the intervals @xmath170 $ ] are replaced by half - open intervals @xmath172 .",
    "thus , the example demonstrates that with closed lower limits on the areas there is no constant update competitive algorithm for the mst - edge - uncertainty problem .",
    "the following example does the same for closed upper limits .",
    "the graph shown in figure  [ badmst - both](b ) is one big cycle with @xmath4 edges and the uncertainty area of each edge is @xmath173 $ ] .",
    "let us assume exactly one edge @xmath0 has weight @xmath6 and the others are of weight @xmath8 . in the worst case any algorithm has to update all @xmath4 edges before finding @xmath0 .",
    "however @xmath34 is @xmath43 by just updating @xmath0 .    -0.5",
    "in this section we consider the model of vertex - uncertainty graphs .",
    "the models of vertex - uncertainty and edge - uncertainty are closely related .",
    "clearly a vertex uncertainty graph @xmath60 has an associated edge - uncertainty graph @xmath174 where the area for each edge @xmath175 is determined by the combinations of possible locations of @xmath86 and @xmath15 in @xmath60 , i.e. , the areas @xmath176 in @xmath174 are defined as @xmath177 .",
    "an update of an edge @xmath175 in @xmath174 can be performed ( simulated ) by updating @xmath86 and @xmath15 in @xmath60 ; these two vertex updates might also reveal additional information about the weights of other edges incident with @xmath86 or @xmath15 . furthermore , note that if neither of the two vertices @xmath86 and @xmath15 in @xmath60 is updated , no information about the weight of @xmath0 can be obtained .",
    "thus , we get :    let @xmath20 be a graph problem such that the set of solutions for a given edge - weighted graph @xmath12 depends only on the graph and the edge weights ( but not the locations of the vertices ) .",
    "let @xmath60 be a vertex - uncertainty graph that is an instance of  @xmath20 .",
    "if @xmath178 is a witness set for @xmath174 , then @xmath179 is a witness set for @xmath60 .",
    "[ open2k ] let @xmath20 be a graph problem such that the set of solutions for a given edge - weighted graph depends only on the graph and the edge weights ( but not the locations of the vertices ) .",
    "let @xmath28 be a @xmath4-update competitive algorithm for the problem @xmath20 with respect to edge - uncertainty graphs .",
    "if @xmath28 is a witness algorithm , then by simulating an edge update by updating both its endpoints the algorithm @xmath28 is @xmath180-update competitive for vertex - uncertainty graphs .",
    "combining theorems [ 2competitive ] and [ open2k ] together with lemma [ open2open ] , we get that u - red is @xmath6-update competitive for the mst - vertex - uncertainty problem when restricted to trivial or open areas .",
    "it remains to show that this is optimal .",
    "-0.1 cm we show that no algorithm can be better than @xmath6-update competitive . in figure",
    "[ fig : vertexbound](a ) we give a construction in the euclidean plane for which any algorithm can be forced to make 4 updates , while @xmath34 is 1 .",
    "the black dots on the left and right represent trivial areas .",
    "the distance between two neighboring trivial areas is  @xmath43 .",
    "there are four non - trivial areas @xmath181 and @xmath182 .",
    "each of these areas is a long , thin open area of length @xmath5 and small positive width .",
    "the distance between each non - trivial area and its closest trivial area is  @xmath43 as well .",
    "let @xmath13 be the complete graph with one vertex for each of the trivial and non - trivial areas .",
    "independent of the exact locations of the vertices in the non - trivial areas @xmath181 and @xmath182 , the edges indicated in figure  [ fig : vertexbound](b ) must be part of any mst .",
    "note that the distance between the vertex of a non - trivial area and its trivial neighbor is in @xmath183 and thus less than  @xmath8 .",
    "we now consider the distances between the non - trivial areas .",
    "we let @xmath184 be the area of all possible distances between two vertex areas @xmath185 and @xmath186 .",
    "so @xmath187 , @xmath188 .",
    "note that the distance between the vertices in @xmath28 and @xmath182 and the distance between the vertices in @xmath52 and @xmath23 are greater than  @xmath166 , so either the edge @xmath189 or the edge @xmath190 is part of the minimum spanning tree .",
    "every algorithm will update the areas @xmath181 and @xmath182 in a certain order until it is clear that either the distance between the vertices of @xmath28 and @xmath52 is smaller or equal to the distance between the vertices of @xmath23 and @xmath182 , or vice versa . in order to force the algorithm to update all four areas , we let the locations of the vertices revealed in any of the first 3 updates made by the algorithm be as follows :        we show that it is impossible for the algorithm to output a correct minimum spanning tree after only three updates .",
    "consider the situation after the algorithm has updated three of the four non - trivial areas .",
    "since the choice of the locations of the vertices in the areas is independent of the sequence of updates , we have to consider four cases depending on which of the four areas has not yet been updated .",
    "we use @xmath193 and @xmath194 to refer to the areas @xmath195 and @xmath182 after they have been updated .",
    "if the area @xmath28 is the only area that has not yet been updated , we have that @xmath196 and @xmath197 . clearly the area @xmath28 needs to be updated . by having the vertex of area @xmath28 on the",
    "far left , updating only area @xmath28 instead of the areas @xmath198 results in @xmath199 and @xmath200 .",
    "hence @xmath34 would only update the area @xmath28 and know that the edge @xmath189 is not part of the minimum spanning tree .",
    "the other three cases are similar .",
    "so for the construction in figure  [ fig : vertexbound](a ) , no algorithm can guarantee to make less than @xmath6 updates even though a single update is enough for the optimum .",
    "furthermore , we can create @xmath4 disjoint copies of the construction and connect them using lines of trivial areas spaced @xmath43 apart .",
    "as long as the copies are sufficiently far apart , they will not interfere with each other .",
    "hence , for a graph with @xmath4 copies there is no algorithm that can guarantee less than @xmath201 updates when at the same time @xmath202 .                          c.  olston and j.  widom . offering a precision - performance tradeoff for aggregation queries over replicated data . in _ proc .",
    "26th intern .",
    "conference on very large data bases ( vldb00 ) _ , pp .",
    "144155 , 2000 ."
  ],
  "abstract_text": [
    "<S> we consider the minimum spanning tree problem in a setting where information about the edge weights of the given graph is uncertain . </S>",
    "<S> initially , for each edge @xmath0 of the graph only a set @xmath1 , called an _ uncertainty area _ , that contains the actual edge weight @xmath2 is known . the algorithm can ` update ' @xmath0 to obtain the edge weight @xmath3 . </S>",
    "<S> the task is to output the edge set of a minimum spanning tree after a minimum number of updates . </S>",
    "<S> an algorithm is @xmath4-update competitive if it makes at most @xmath4 times as many updates as the optimum . </S>",
    "<S> we present a @xmath5-update competitive algorithm if all areas @xmath1 are open or trivial , which is the best possible among deterministic algorithms . </S>",
    "<S> the condition on the areas @xmath1 is to exclude degenerate inputs for which no constant update competitive algorithm can exist .    </S>",
    "<S> next , we consider a setting where the vertices of the graph correspond to points in euclidean space and the weight of an edge is equal to the distance of its endpoints . </S>",
    "<S> the location of each point is initially given as an uncertainty area , and an update reveals the exact location of the point . </S>",
    "<S> we give a general relation between the edge uncertainty and the vertex uncertainty versions of a problem and use it to derive a @xmath6-update competitive algorithm for the minimum spanning tree problem in the vertex uncertainty model . </S>",
    "<S> again , </S>",
    "<S> we show that this is best possible among deterministic algorithms .    thomas erlebach    michael hoffmann    danny krizanc    mat mihalk    rajeev raman </S>"
  ]
}