{
  "article_text": [
    "low - density parity - check ( ldpc ) codes as opposed to turbo codes have been studied extensively on the binary erasure channel ( bec ) . in @xcite , an iterative decoding algorithm for ldpc codes over the bec",
    "was proposed , and it was shown that this scheme approaches channel capacity arbitrarily close . although carefully optimized irregular ldpc codes with iterative decoding can achieve channel capacity on the bec as the code length tends to infinity , there is still some performance loss compared to maximum - likelihood ( ml ) decoding of a given fixed code of finite length .",
    "recently , some progress has been made towards efficient ml or near ml decoding of ldpc codes over the bec @xcite .",
    "the tanner graph representation of an ldpc code is a bipartite graph with left and right nodes .",
    "the left nodes correspond to codeword bits .",
    "the right nodes correspond to parity - check constraints .",
    "it is known that iterative belief - propagation ( bp ) decoding fails if and only if the set of erased bit - positions contains a _ stopping set _ @xcite .",
    "a stopping set is a subset of the bit - positions such that the corresponding left nodes in the tanner graph have the property that all neighboring nodes are connected to the set at least twice .    in this work",
    "we consider turbo decoding over the bec .",
    "turbo codes have gained considerable attention since their introduction by berrou _",
    "@xcite in 1993 due to their near - capacity performance and low decoding complexity .",
    "here we consider the conventional turbo code which is the parallel concatenation of two identical recursive systematic convolutional encoders separated by a pseudo - random interleaver . to accurately describe turbo decoding on the bec",
    "we introduce the concept of a _ turbo stopping set _ , and we identify an exact condition for decoding failure .",
    "assume that we transmit codewords of a turbo code over the bec .",
    "apply turbo decoding until either the codeword has been recovered , or the decoder fails to progress further .",
    "then the set of erased positions that will remain when the decoder stops is equal to the unique maximum - size turbo stopping set which is also a subset of the set of erased positions .",
    "we also consider improved turbo decoding on the bec .",
    "the algorithm applies turbo decoding until the transmitted codeword is recovered , or the decoder fails to progress further .",
    "then , an unknown ( systematic ) bit - position is identified and its value is guessed , after which turbo decoding is applied again .",
    "thus , the algorithm is based on guessing bit - values in erased bit - positions when turbo decoding does not progress further and has the same _ structure _ as the algorithms in @xcite .",
    "recently , several algorithms have been introduced to compute the first few terms of the weight distribution of both parallel and serial turbo codes . both exact algorithms ( e.g. , @xcite ) and approximate algorithms ( e.g. , @xcite )",
    "have been presented . in this work",
    "we also show that basically all _ trellis - based _ algorithms can be adapted to find the first few terms of the turbo stopping set size enumerating function .",
    "in particular , we have considered in detail how to adapt the algorithm by garello _",
    "introduced in @xcite and the improved algorithm in @xcite . also , an expression for the ( average ) turbo stopping set size enumerating function under the uniform interleaver assumption is presented .",
    "using linear programming ( lp ) to decode binary linear codes has recently been considered by feldman _",
    "see also the seminal papers @xcite where lp decoding of turbo - like codes is considered . in particular , repeat - accumulate ( ra ) codes are considered .",
    "a description of lp decoding of arbitrary concatenated codes is given in ( * ? ? ?",
    "* ch .  6 ) .",
    "the obvious polytope for lp decoding is the convex hull of all codewords , in which case lp decoding is equivalent to ml decoding .",
    "however , the convex hull has a description complexity that is exponential in the codeword length for a general binary linear code .",
    "thus , feldman _",
    "@xcite proposed a relaxed polytope which contains all valid codewords as vertices , but also additional non - codeword vertices .",
    "the vertices of the relaxed polytope are basically what the authors called _ pseudo - codewords _ in @xcite .",
    "one desirable property of the lp decoder is the ml certificate property , i.e. , when the lp decoder outputs a codeword , it is guaranteed to be the ml codeword .",
    "experimental results with ldpc codes show that the performance of the relaxed lp decoder is better than with the iterative min - sum algorithm , but slightly worse than with iterative bp decoding .",
    "recently , some understanding of the performance of iterative bp decoding of finite - length ldpc codes over general memoryless channels have been developed .",
    "finite graph covers of the tanner graph and the codes defined by these covers play an essential role in the analysis @xcite .",
    "the low complexity of iterative bp decoding is due to the fact that the algorithm operates _ locally _ on the tanner graph of the code .",
    "this property is also the main weakness of iterative bp decoding , since the decoder can not distinguish if it operates on the original tanner graph or on any of the finite covers .",
    "hence , codewords in the code defined by a finite cover of the tanner graph will influence on iterative decoding .",
    "these codewords are basically what vontobel and koetter referred to as pseudo - codewords in @xcite .",
    "it turns out that the set of pseudo - codewords of all finite covers of the tanner graph is equal to the set of points where all entries are rational numbers from the relaxed polytope of lp decoding of ldpc codes as introduced by feldman _",
    "et al . _ in @xcite . a similar connection between the relaxed polytope of lp decoding of turbo codes , as described in ( * ?",
    "6 ) , and the pseudo - codewords of all finite covers of the turbo code factor graph @xcite was established in @xcite .",
    "furthermore , rosnes also showed in @xcite that there is a many - to - one correspondence between these pseudo - codewords and turbo stopping sets in the following sense .",
    "the support set of any pseudo - codeword , i.e. , the set of non - zero coordinates , is a turbo stopping set , and for any turbo stopping set there is a pseudo - codeword with support set equal to the turbo stopping set .",
    "a similar connection also holds for pseudo - codewords of finite graph covers of tanner graphs and stopping sets @xcite .    for ldpc codes",
    "it has been observed that stopping sets , to some degree , also reflect the performance of iterative decoding for other channels than the bec @xcite .",
    "it is therefore our hope that the notion of turbo stopping sets also can provide some useful insight into turbo decoding on the additive white gaussian noise ( awgn ) channel or on other memoryless channels . in @xcite , rosnes presented some simulation results to indicate that this may be the case .",
    "this paper is organized as follows . in section  [ sec : decoding ]",
    "we define some basic notation and describe simplified turbo decoding on the bec .",
    "section  [ sec : stopping ] introduces the concept of a turbo stopping set .",
    "we further give some of the basic properties and show that turbo stopping sets characterize exactly the performance of turbo decoding on the bec . an improved turbo decoding algorithm on the bec",
    "is introduced in section  [ sec : improved ] , and its superiority compared to conventional turbo decoding is illustrated by simulation examples .",
    "finally , in section  [ sec : alg ] , we consider enumeration of small - size turbo stopping sets for a particular interleaver and under the uniform interleaver assumption . conclusions and a discussion of future work are given in section  [ sec : conclu ] .",
    "in this section we introduce the channel , define some basic notation , and describe simplified turbo decoding on the bec .",
    "the bec model was introduced by elias @xcite in @xmath0 .",
    "the channel has recently been used for modeling information transmission over the internet .",
    "the bec is a two - input , three - output discrete memoryless channel .",
    "each input bit is erased with probability @xmath1 , or received correctly with probability @xmath2 .",
    "let @xmath3 denote a parallel concatenated convolutional code ( pccc ) , or turbo code , with information length @xmath4 , constituent encoders @xmath5 and @xmath6 of rate @xmath7 , and interleaver @xmath8 . in this work we consider dual termination @xcite , which implies that the length of the interleaver @xmath9 where @xmath10 is the constraint length .",
    "we assume here that @xmath11 is a multiple of @xmath12 .",
    "let @xmath13 and @xmath14 denote the lengths of the constituent codes .",
    "the length of the turbo code is denoted by @xmath15 . for an unpunctured turbo code , @xmath16 and @xmath17 . in general , the values of @xmath13 , @xmath14 , and @xmath15 depend on the puncturing pattern @xmath18 and the termination scheme .",
    "we will now define some useful mappings , but we advise the reader that the formal definitions below will be easier to understand after taking a look at fig .  [ figur_mapping ] .",
    "define two mappings @xmath19 and @xmath20 where @xmath21 for a positive integer @xmath15 .",
    "the mapping @xmath22 gives the index in the first constituent codeword of the turbo codeword index if such a relation exists , or @xmath23 if not .",
    "similarly , the mapping @xmath24 gives the index in the second constituent codeword of the turbo codeword index if such a relation exists , or @xmath23 if not .",
    "note that for turbo codeword indices that correspond to systematic bits , the interleaver is used to get the correct constituent codeword index for the second encoder .",
    "define two mappings @xmath25 and @xmath26 .",
    "the mapping @xmath27 gives the systematic sequence index of the first constituent codeword index if such a relation exists , or @xmath23 if not .",
    "similarly , the mapping @xmath28 gives the interleaved systematic sequence index of the second constituent codeword index if such a relation exists , or @xmath23 if not .",
    "[ example1 ] consider a turbo code composed of two identical nominal rate-@xmath29 constituent convolutional codes .",
    "the interleaver length @xmath30 and parity bits from the two constituent encoders are punctured alternatively to create a nominal rate-@xmath29 turbo code .",
    "the lengths of the first and second constituent codes are @xmath31 .",
    "the interleaver @xmath8 is defined by @xmath32 ( i.e. , @xmath33 , @xmath34 , and so on ) .",
    "the ordering of bits in the turbo codeword is @xmath35 where @xmath36 and @xmath37 denote the @xmath38th systematic and parity bit from the first constituent code , respectively , and where @xmath39 denotes the @xmath38th parity bit from the second constituent code .",
    "the mappings @xmath22 , @xmath24 , @xmath27 , and @xmath28 are depicted graphically in fig .",
    "[ figur_mapping ] .",
    "graphical representation of the mappings @xmath22 , @xmath24 , @xmath27 , and @xmath28 for the turbo code from example  [ example1].,width=336,height=192 ]      the aim of turbo decoding on the bec is to find a set of paths through each constituent code trellis that is consistent with the received sequence .",
    "the decoding starts with a set of all paths and iteratively eliminates those that are inconsistent .",
    "this iterative process continues until either there is only one possible path left in each constituent trellis ( successful decoding ) , or there is no change from one iteration step to the next .",
    "we will describe the basic algorithm , but remark that the bec version of turbo decoding allows more efficient implementations . for simplicity , we omit the details .",
    "let @xmath40 denote an _ information bit - oriented trellis _",
    "@xcite for constituent code @xmath41 , @xmath42 .",
    "the trellis @xmath40 is time - variant , but periodic , and has two edges out of each vertex . for details ,",
    "see section  [ sec : conv ] .",
    "the number of trellis depths in @xmath40 is @xmath43 , i.e. , there is one trellis section for each information bit .",
    "below , @xmath44 denotes the complement of @xmath45 , @xmath42 .    like turbo decoding for an awgn channel , the constituent decoders work with a forward and a backward pass through the constituent code trellis @xmath40 , and during these passes the state metric @xmath46 ( resp .",
    "@xmath47 ) for vertex @xmath48 at trellis depth @xmath49 , at the @xmath38th iteration , is updated .",
    "for the bec , however , the state metrics are boolean and define forward ( resp.backward ) paths that are consistent with the current estimate of the transmitted sequence @xmath50 .",
    "the decoding for constituent code @xmath41 is performed as follows .",
    "initially , we set @xmath51 ; @xmath52 for all vertices @xmath48 at trellis depth @xmath49 in @xmath40 , @xmath53 ; and @xmath54 for every non - zero vertex @xmath48 at trellis depths @xmath55 and @xmath11 , respectively , in @xmath56",
    ". finally , set the estimate of the transmitted sequence @xmath57 equal to the received sequence .",
    "then the forward pass calculates , for @xmath58 and for each vertex @xmath59 at trellis depth @xmath49 in @xmath40 , @xmath60 and subsequently @xmath61 . here",
    "@xmath60 is a boolean variable which is true if there exists , in the @xmath62th trellis section of @xmath40 , an edge consistent with @xmath57 , with right vertex @xmath59 , and left vertex @xmath48 such that @xmath63",
    ". initially , prior to the forward pass , we set @xmath64 for all vertices @xmath48 at trellis depth @xmath55 in @xmath40 .    in a similar way",
    "the backward pass calculates @xmath47 for all vertices @xmath48 at trellis depth @xmath49 in @xmath40 , @xmath65 .",
    "finally , the estimate @xmath57 of the transmitted sequence is updated so that only information values consistent with legal edges remain , and control is passed to the other constituent decoder .    the codeword is said to be _ recovered _ if @xmath66 , where @xmath67 denotes an erasure , for all @xmath49 such that @xmath68 and @xmath69 , @xmath70 .",
    "the decoder is said to _ fail to progress further _ if , for @xmath42 , the state metrics @xmath71 and @xmath72 , for some positive integer @xmath73 , are equal to the state metrics @xmath74 and @xmath75 , respectively , for all vertices @xmath48 at trellis depth @xmath49 in @xmath40 , @xmath53 .",
    "in this section we will introduce the concept of a turbo stopping set .",
    "a turbo stopping set is the equivalent of an ldpc stopping set when turbo decoding and _ not _ iterative bp decoding is performed .",
    "[ def_1 ] let @xmath76 denote a given pccc with interleaver @xmath8 .",
    "a set @xmath77 is a turbo stopping set if and only if there exist two linear subcodes @xmath78 and @xmath79 of dimension @xmath80 with support sets @xmath81 and @xmath82 , respectively , such that @xmath83 the _ size _ of a turbo stopping set @xmath84 is its cardinality .    the lemmas below state some of the properties of a turbo stopping set .",
    "[ lemma1 ] let @xmath76 denote a given pccc with interleaver @xmath8 .",
    "the support set of any non - zero codeword from @xmath76 is a turbo stopping set of size equal to the hamming weight of the given codeword .",
    "thus , the minimum turbo stopping set size is upper - bounded by the minimum hamming weight .",
    "denote the turbo codeword by @xmath85 and the corresponding first and second constituent codewords by @xmath86 and @xmath87 , respectively .",
    "furthermore , let @xmath88 and @xmath89 where @xmath90 denotes an all - zero sequence of length @xmath91 , @xmath42 .",
    "the result follows immediately from definition  [ def_1 ] , since @xmath92 , @xmath93 , and @xmath94 .",
    "[ lemma2 ] let @xmath76 denote a given pccc with interleaver @xmath8 , and let @xmath95 denote a turbo stopping set .",
    "if @xmath96 and @xmath97 can both be decomposed into _ direct sums _ of linear subcodes of dimension @xmath98 with disjoint support sets , then @xmath84 is the support set of a turbo codeword of hamming weight @xmath99 .",
    "the converse is also true .",
    "assume that @xmath96 and @xmath97 can both be decomposed into direct sums of linear subcodes of dimension @xmath98 with disjoint support sets .",
    "in more detail , @xmath100 where @xmath101 and @xmath102 are non - negative integers . the codewords @xmath103 and @xmath104 have support sets @xmath105 and @xmath106 , respectively , since the support sets of the direct sum subcodes are disjoint .",
    "since the two sets @xmath107 and @xmath108 are equal ( from definition  [ def_1 ] ) , there exists a turbo codeword @xmath85 with first and second constituent codewords @xmath86 and @xmath87 , respectively .",
    "thus , the turbo stopping set is the support set of a turbo codeword of hamming weight @xmath99 , since @xmath109 .",
    "we prove the converse using the following argument .",
    "the turbo stopping set @xmath84 is the support set of a turbo codeword @xmath85 .",
    "the corresponding first and second constituent codewords are denoted by @xmath86 and @xmath87 , respectively . then , there exist subcodes @xmath110 and @xmath111 both of dimension @xmath98 which satisfy the constraints in ( [ eq : stoppingset ] ) with @xmath112 , and the result follows .",
    "( the codewords @xmath86 and @xmath87 may or may not be further decomposed . )",
    "[ construct:1 ] let @xmath113 and @xmath114 denote two _ arbitrarily _ chosen tanner graphs for the first and second constituent codes , respectively .",
    "the node set @xmath115 can be partitioned into three disjoint subsets @xmath116 , @xmath117 , and @xmath118 , corresponding to systematic bits , parity bits , and parity - check equations , respectively , where @xmath42 .",
    "there is an edge @xmath119 connecting a node @xmath120 to a node @xmath121 if and only if the first ( @xmath122 ) or second ( @xmath123 ) constituent codeword bit represented by @xmath124 is checked by the parity - check equation represented by @xmath125 .",
    "next , define @xmath126 then , the graph @xmath127 is a tanner graph for the turbo code @xmath76 .",
    "we remark that for a given binary linear code there exist in general several full - rank parity - check matrices , and thus several ( distinct ) tanner graphs .",
    "the minimum stopping set size is in general a function of the tanner graph @xcite .",
    "note that construction  [ construct:1 ] gives a specific class of tanner graphs for a turbo code that is a proper subset of the class of all tanner graphs of the given turbo code .",
    "we will consider this specific class of tanner graphs below .",
    "let @xmath76 denote a given pccc with interleaver @xmath8 .",
    "for any turbo stopping set @xmath95 there is an ldpc stopping set of cardinality @xmath99 in any tanner graph @xmath128 for @xmath76 within the class of tanner graphs from construction  [ construct:1 ] .",
    "we use the notation introduced in construction  [ construct:1 ] .",
    "the set @xmath129 , where @xmath130 denotes the @xmath49th node in @xmath131 , is an ldpc stopping set in any tanner graph @xmath132 of @xmath41 , since @xmath133 is the support set @xmath134 ( from definition  [ def_1 ] ) of some subcode @xmath135 of @xmath41 of dimension @xmath80 .",
    "we have here used the fact that the variables nodes corresponding to the support set of a non - zero codeword constitute an ldpc stopping set .",
    "furthermore , the set @xmath136 is an ldpc stopping set in the tanner graph @xmath128 of the turbo code @xmath76 due to the last condition in definition  [ def_1 ] .",
    "the cardinality of the ldpc stopping set in ( [ eq : set ] ) is @xmath99 .",
    "note that the converse is not necessarily true ( i.e. , for an ldpc stopping set in any tanner graph @xmath128 for @xmath76 within the class of tanner graphs from construction  [ construct:1 ] , there is not necessarily a turbo stopping set ) .",
    "thus , iterative bp decoding using a tanner graph within the class of tanner graphs of a turbo code from construction  [ construct:1 ] is inferior to turbo decoding on the bec .",
    "the following theorem states an exact condition for decoding failure .",
    "let @xmath76 denote a given pccc with interleaver @xmath8 that we use to transmit information over the bec .",
    "the received vectors are decoded using turbo decoding until either the codeword has been recovered , or the decoder fails to progress further .",
    "then the set of erased positions that will remain when the decoder stops is equal to the unique maximum - size turbo stopping set which is also a subset of @xmath137 , where @xmath137 denotes the subset of erased positions .",
    "the proof given here is inspired by the proof given by di _",
    "et al . _ in ( * ? ? ?",
    "* lemma  1.1 ) in the context of an ldpc stopping set .",
    "let @xmath84 be a turbo stopping set contained in @xmath137 .",
    "the claim is that the basic turbo decoder can not determine the bits corresponding to the positions in the turbo stopping set @xmath84 .",
    "assume that all other bits are known .",
    "turbo decoding starts by activating the first constituent decoder .",
    "for the first constituent decoder , the forward - backward algorithm will determine @xmath138 possible paths through the trellis .",
    "the support set of these possible paths is equal to @xmath139 , and they are all equally likely . consequently , no additional codeword bits can be determined .",
    "thus , the extrinsic probability distributions for systematic bits in positions in @xmath140 are uniform . for the second constituent decoder ,",
    "the forward - backward algorithm will determine @xmath141 possible paths through the trellis .",
    "the support set of these possible paths is equal to @xmath142 and , since the _ a priori _ probability distributions for systematic bits in positions in @xmath143 are uniform , and the two sets @xmath143 and @xmath144 are equal ( see definition  [ def_1 ] ) , all paths are equally likely .",
    "consequently , no additional codeword bits can be determined .",
    "thus , the extrinsic probability distributions for systematic bits in positions in @xmath145 are uniform .",
    "one iteration of the basic turbo decoding algorithm has been performed and no additional codeword bits have been determined .",
    "since there is no new information available to the first constituent decoder , no additional bits will be determined in the next round of turbo decoding either .",
    "it follows that the decoder can not determine the bits corresponding to the positions in the unique maximum - size turbo stopping set which is also a subset of @xmath137 .",
    "note that there is a unique maximum - size turbo stopping set which is also a subset of @xmath137 , since the union of two turbo stopping sets is also a turbo stopping set .",
    "conversely , if the decoder terminates at a set @xmath84 , then there will exist subcodes @xmath146 and @xmath147 of dimension @xmath80 with support sets @xmath148 and @xmath142 , respectively .",
    "since the turbo decoder terminates , the two sets @xmath143 and @xmath144 are equal . from definition  [ def_1 ] , it follows that @xmath84 is a turbo stopping set and , since no erased bit - positions contained in a turbo stopping set can be determined by the turbo decoder , it must be the maximum - size turbo stopping set which is also a subset of @xmath137 .      in @xcite , a particularly nice @xmath150-regular ldpc code of length @xmath151 , dimension @xmath152 , and minimum hamming distance @xmath153",
    "was constructed .",
    "the underlying tanner graph has girth @xmath154 which makes the code an excellent candidate for iterative decoding .",
    "this is the reason behind the selected code parameters .",
    "the turbo code is obtained by puncturing of a nominal rate-@xmath155 turbo code with nominal rate-@xmath29 , constraint length @xmath156 constituent codes defined by the parity - check matrix @xmath157 .",
    "the last polynomial which is irreducible and primitive has been chosen as the parity polynomial making the constituent encoders recursive .",
    "the information block size is @xmath152 , the interleaver length is @xmath158 due to dual termination @xcite , and the interleaver is a dithered relative prime ( drp ) interleaver @xcite .",
    "the puncturing pattern is designed using the algorithm in @xcite .",
    "the minimum distance of @xmath159 of the code has been computed using the algorithm in @xcite . for this code",
    "there exists a turbo stopping set of size @xmath160 .",
    "the turbo stopping set is depicted in fig .",
    "[ figur1 ] . in fig .",
    "[ figur1 ] , the three upper rows of nodes correspond to the first constituent encoder , while the three remaining rows of nodes correspond to the second constituent encoder . the nodes in row number",
    "@xmath161 give the bit - position in the turbo codeword of the corresponding systematic ( @xmath162 ) and parity ( @xmath163 ) bits .",
    "the nodes in row number @xmath164 and @xmath165 correspond to parity and systematic bits , respectively , from constituent encoder @xmath38 , @xmath166 .",
    "the blue and dark green nodes correspond to systematic bits .",
    "the blue nodes are information bits ( can be assigned freely ) , while the dark green nodes are redundant systematic bits ( can _ not _ be assigned freely ) .",
    "the red and yellow nodes correspond to erased bits and punctured ( parity ) bits , respectively .",
    "the light green nodes correspond to parity bits .",
    "the arrows in between the upper three rows and the remaining three rows correspond to interleaving of erased information bits .",
    "the remaining part of the interleaver is of no concern for the following discussion .",
    "in fact , possible choices for @xmath96 and @xmath97 are the linear subcodes spanned by @xmath167 and @xmath168 respectively .",
    "the symbol @xmath169 indicates that the bit - position has been punctured . from fig .",
    "[ figur1 ] we get @xmath170 furthermore , it holds that @xmath171 , @xmath172 , and @xmath173 , which shows that @xmath84 is a turbo stopping set .        the turbo stopping",
    "set depicted in fig .",
    "[ figur1 ] is given as an example to illustrate the concept of a turbo stopping set . actually , it is possible to find an exhaustive list of all turbo stopping sets of size less than some threshold using a modification of the algorithm in @xcite .",
    "the details of the algorithm are outlined in section  [ sec : alg ] . for this code",
    "there are @xmath174 turbo stopping sets of size @xmath175 and @xmath176 of size @xmath160 .      from fig .",
    "[ figur1 ] it is apparent that some of the punctured bits can be reinserted without increasing the size of the depicted turbo stopping set . in fact , @xmath178 out of the @xmath179 punctured parity bits from the first constituent code can be reinserted . for the second constituent code ,",
    "@xmath180 out of the @xmath181 punctured parity bits can be reinserted .",
    "the minimum distance of @xmath182 of the resulting turbo code has been determined by the algorithm in @xcite .",
    "note that this is a _ constructed _ example , since it is possible to design a puncturing pattern of weight @xmath183 that will give a length @xmath184 and dimension @xmath152 turbo code of minimum distance @xmath185 using the same mother code and the algorithm in @xcite .",
    "the minimum distance of the unpunctured mother code is @xmath178 .",
    "the code considered in section  [ sec:155turbo ] is _ not _ a rare example in the sense of having turbo stopping sets of size smaller than the minimum distance .",
    "we have found several examples of excellent turbo codes with this property .",
    "for further examples see section  [ sec : numerical1 ] .",
    "in @xcite , pishro - nik and fekri consider improved iterative bp decoding of ldpc codes on the bec .",
    "when standard iterative bp decoding fails , the improved algorithm chooses one of the unknown variables nodes and guesses its value .",
    "the decoding continues until either the transmitted codeword is recovered , the decoder does not progress further , or the decoder reaches an _ inconsistency_. the decoder is said to reach an inconsistency if all the variables nodes connected to a check node are known , but the check node is not satisfied .",
    "if the decoder has reached an inconsistency , then the value of the guessed variable node is changed and the decoding is repeated .",
    "this time the decoder will not reach an inconsistency , but the decoding can stop again .",
    "more sophisticated algorithms for improved iterative bp decoding of ldpc codes on the bec were recently proposed by ravisankar and fekri in @xcite .",
    "these algorithms improve upon the algorithms in @xcite .",
    "furthermore , the algorithms in @xcite use the tanner graph representation of the ldpc code actively to identify _ equivalent _ bit - positions when iterative bp decoding has stopped in a stopping set . in this context ,",
    "two bit - positions are equivalent if and only if the knowledge of one of the bits implies the knowledge of the other bit after a series of message - passing in the subgraph of the tanner graph composed of all unknown variable nodes and the neighboring check nodes of degree @xmath174 .",
    "improved turbo decoding , the pseudo - code of which is given below , has the same _ structure _ as the algorithm in @xcite . in more detail",
    ", it is based on guessing unknown systematic bit - positions and then decode until either the transmitted codeword is recovered , the decoder does not progress further , or the decoder reaches some kind of inconsistency . in the context of turbo decoding , however , the unknown bit - position to guess can be chosen more efficiently than in the context of improved iterative bp decoding of ldpc codes , since the forward and backward passes on the constituent trellises give information on legal paths .",
    "bit - position selection is considered in more detail in section  [ sec : turbo_improved ] .    in the pseudo - code below @xmath186 , @xmath42 , denotes the number of vertices of @xmath40 at trellis depth @xmath49 that are legal after the @xmath187th iteration .",
    "* step 1 ( initialization ) * :    1 .",
    "choose the maximal number of iterations @xmath188 .",
    "2 .   initialize @xmath189 and @xmath128 with zero .    * step 2 ( original turbo decoding ; bit - position selection ) * :    1 .",
    "run turbo decoding as described in section  [ sec : turbodec ] , with a maximum of @xmath188 iterations , until either the codeword is recovered , or the decoder fails to progress further .",
    "let @xmath190 denote the number of iterations carried out and increment @xmath128 with @xmath191 .",
    "if @xmath192 , or the codeword is recovered , make a decision based on @xmath193 , and terminate the algorithm .",
    "3 .   compute @xmath194 for @xmath42 and select a bit - position @xmath195 to guess based on these values .",
    "see section  [ sec : turbo_improved ] below for details .",
    "initialize a list @xmath196 with the _ ordered _ sets @xmath197 and @xmath198 .",
    "initialize @xmath199 and @xmath200 with @xmath193 .",
    "* step 3 ( performing additional iterations ; bit - position selection ) * :    1 .   increment @xmath189 .",
    "@xmath201 is chosen and removed from @xmath196 .",
    "3 .   initialize @xmath193 with @xmath202 and set @xmath203 equal to @xmath204 where @xmath205 and @xmath206 .",
    "4 .   run turbo decoding as described in section  [ sec : turbodec ] with a maximum of @xmath207 iterations , but without assigning values to @xmath193 in the initialization step of the algorithm , until the decoder fails to progress further , or there is a trellis depth @xmath49 in which _ all _ vertices in @xmath40 have false forward or backward state metrics for some @xmath45 , @xmath42 . in this case",
    "the decoder is said to have reached an _",
    "inconsistency_. let @xmath208 denote the number of iterations carried out and increment @xmath128 with @xmath191 .",
    "if @xmath192 , or the decoder has not reached an inconsistency and @xmath66 for all @xmath49 such that @xmath209 and @xmath69 , @xmath70 , make a decision based on @xmath193 , and terminate the algorithm .",
    "delete @xmath202 .",
    "if the decoder has not reached an inconsistency , perform the following . 1 .",
    "compute @xmath194 for @xmath42 and select a bit - position @xmath195 to guess based on these values .",
    "see section  [ sec : turbo_improved ] below for details .",
    "2 .   add the two elements @xmath210 and @xmath211 to the list @xmath196 , and initialize @xmath212 and @xmath213 with @xmath193 .",
    "* step 4 ( repeating ) * : repeat step 3 .",
    "the list @xmath196 in improved turbo decoding can be implemented as a _",
    "last - in first - out _ queue or as a _ first - in first - out _ queue .",
    "the first - in first - out implementation requires more memory than the last - in first - out implementation .",
    "the efficiency of an improved decoding algorithm with the above structure is very dependent on the selection of bit - positions to guess .",
    "when turbo decoding fails to progress further , the unknown bit - positions constitute a turbo stopping set .",
    "thus , guessing a bit - position in @xmath134 will _ free _ at least one additional bit . some of the positions in @xmath134 can be determined from the numbers @xmath186 of legal vertices at trellis depth @xmath49 in @xmath40 ( @xmath187 is the iteration number ) .",
    "in particular , the @xmath49th systematic bit is unknown if @xmath214 and @xmath215 , or @xmath216 and @xmath217 . when selecting a bit - position to guess we would also like to free as many unknown positions as possible .",
    "we propose the following bit - position selection algorithm .    1 .   for @xmath42",
    "do the following . 1 .",
    "let @xmath218 be the number of indices @xmath49 with the property that @xmath219 and @xmath220 .",
    "2 .   let @xmath221 be the largest non - negative integer such that there exists an index @xmath222 with the property that @xmath223 and @xmath224 .",
    "3 .   let @xmath225 be the largest non - negative integer such that there exists an index @xmath226 with the property that @xmath227 and @xmath228 .",
    "4 .   let @xmath229 .",
    "if @xmath230 , or @xmath231 and @xmath232 , then set @xmath122 .",
    "otherwise , set @xmath123 .",
    "3 .   if @xmath233 , then @xmath195 is set equal to @xmath234 if @xmath122 and @xmath235 if @xmath123",
    "otherwise , @xmath195 is set equal to @xmath226 if @xmath122 and @xmath236 if @xmath123 .",
    "we remark that several variations of the above bit - position selection algorithm are possible .",
    "in particular , one could use both the number of legal edges in each trellis section , or equivalently the edge entropy , and the number of legal vertices for each trellis depth , or equivalently the vertex entropy , in combination with the interleaver to improve the algorithm as described below .",
    "let @xmath195 denote a chosen systematic bit - position within a vertex entropy transition from level @xmath49 at time @xmath237 to level @xmath238 at time @xmath239 ( a forward transition from level @xmath49 at time @xmath237 ) , or from level @xmath49 at time @xmath237 to level @xmath238 at time @xmath240 ( a backward transition from level @xmath49 at time @xmath237 ) for one of the constituent trellises .",
    "the _ effective length _ of @xmath195 is the number of undetermined systematic bit - positions that will be determined by the forward - backward algorithm on the considered constituent trellis before any interleaving , if @xmath195 is guessed . to simplify notation",
    "we assume that @xmath195 is chosen based on the first constituent trellis .",
    "the effective length of @xmath195 is a positive integer smaller than or equal to the number of undetermined systematic bit - positions within the range @xmath241 $ ] for a forward transition , or within the range @xmath242 $ ] for a backward transition .",
    "the positive integer @xmath243 is the smallest integer such that the vertex entropy at time @xmath244 , for a forward transition , or at time @xmath245 , for a backward transition , is different from @xmath238 .",
    "a general upper bound on the effective length of @xmath195 is @xmath243 .",
    "when @xmath246 , we can use the edge entropy to find the exact value of the effective length of @xmath195 .",
    "let @xmath247 denote the smallest positive integer such that the edge entropy for the @xmath248th trellis section , i.e. , for the transition from time @xmath249 to time @xmath250 , for a forward transition , or for the @xmath251th trellis section , for a backward transition , is @xmath174 .",
    "a general upper bound on the effective length of @xmath195 in this case is @xmath252 .",
    "the exact value is the number of undetermined systematic bit - positions within the range @xmath253 $ ] , for a forward transition , or within the range @xmath254 $ ] , for a backward transition .",
    "the selection of bit - positions can be improved even further by actively using the interleaver .",
    "if we choose a bit - position @xmath195 with the property that both @xmath195 and @xmath255 are within vertex entropy transitions , then the performance will be improved .",
    "finally , we remark that the simple version described in section  [ sec : turbo_improved ] provides good results as indicated in section  [ sec : numerical_sim ] below .",
    "in this subsection we establish some basic results of improved turbo decoding as described above .",
    "the following lemma is simple , but important , since the bit - position selection algorithm in section  [ sec : turbo_improved ] is based on this result .",
    "[ lemma:1 ] apply improved turbo decoding as described above using the bit - position selection algorithm in section  [ sec : turbo_improved ] .",
    "then , the channel value corresponding to the selected bit - position @xmath195 is an erasure .    the bit - position selection algorithm in section  [ sec : turbo_improved ] selects only ( systematic ) bit - positions @xmath256 with the property that @xmath257 for @xmath122 or @xmath258 , where @xmath259 for @xmath122 and @xmath260 for @xmath123 .",
    "if the channel value is _ not _ erased , then we know the @xmath195th information bit with probability @xmath98 . since the @xmath195th information bit is known with probability @xmath98 , and both constituent trellises are information bit - oriented , there is only a single legal edge out of each legal vertex at trellis depth @xmath261 for @xmath122 or @xmath258 .",
    "consequently , the number of legal trellis vertices at trellis depth @xmath262 is equal to the number of legal trellis vertices at trellis depth @xmath261 , and the result follows by contradiction .",
    "[ lemma10 ] let @xmath76 denote a given pccc with interleaver @xmath8 .",
    "let @xmath95 denote a turbo stopping set , and erase all bit - positions in @xmath84 . then , choose any bit - position @xmath263 , and do the following .    1 .",
    "fix the bit - value in bit - position @xmath49 to @xmath55 and perform turbo decoding until either the decoder fails to progress further , or the decoder reaches an inconsistency . if the decoder does not reach an inconsistency , denote the set of erased positions that remain when the decoder stops by @xmath264 .",
    "2 .   fix the bit - value in bit - position @xmath49 to @xmath98 and perform turbo decoding until either the decoder fails to progress further , or the decoder reaches an inconsistency . if the decoder does not reach an inconsistency , denote the set of erased positions that remain when the decoder stops by @xmath265 .",
    "if the decoder does _ not _ reach an inconsistency in either of the two cases above , then the two sets @xmath264 and @xmath265 are equal .",
    "fix the bit - value in bit - position @xmath49 to @xmath266 where @xmath267 or @xmath98 .",
    "then the number of possible paths in the first constituent code is immediately reduced by a factor of @xmath174 , since the subcode @xmath96 corresponding to @xmath84 is linear .",
    "let this reduced set of legal paths in the first constituent code be denoted by @xmath268 .",
    "furthermore , the forward - backward algorithm for the first constituent code will determine additional bit - positions ( which are previously unknown ) contained within a set @xmath269 .",
    "for a given bit - position @xmath270 , all paths in @xmath268 will have the same bit - value of @xmath271 ( depending on the value of @xmath266 ) in this bit - position . since the subcode @xmath96 is linear , all paths in @xmath272 , where @xmath273 denotes the complement of @xmath266 , will also have a fixed bit - value of @xmath274 in bit - position @xmath38 .",
    "thus , it holds that @xmath275 , from which it follows that @xmath276 , since @xmath266 and @xmath38 both are arbitrarily chosen . for the second constituent code",
    ", several bit - positions are fixed due to extrinsic information from the first constituent code .",
    "however , we can apply the same type of arguments as above to show that the sequence of additional bit - positions determined by the forward - backward algorithm in the second constituent code is independent of @xmath266 .",
    "the result follows by applying these arguments in an iterative fashion until there is no further progress .",
    "[ lemma11 ] apply improved turbo decoding as described above with the bit - position selection algorithm in section  [ sec : turbo_improved ] . for any two elements @xmath277 with the property that @xmath278 , it holds that @xmath279 for all @xmath38 , @xmath280 , i.e. , the actual bit - values in the guessed bit - positions do not influence on which bit - positions are selected next by the bit - position selection algorithm in section  [ sec : turbo_improved ] , as long as no inconsistency is reached .",
    "the result follows directly from lemma  [ lemma10 ] .",
    "we remark that due to lemma  [ lemma11 ] we can reduce the number of times we need to run the bit - position selection algorithm from section  [ sec : turbo_improved ] when performing improved turbo decoding .    improved turbo decoding is ml decoding on the bec when @xmath281 .",
    "the proof is two - fold .",
    "first we prove that if the algorithm terminates , then we have an ml decoder .",
    "secondly , we prove that the algorithm will always terminate .",
    "* it follows from the pseudo - code above ( step 2 , item 2 ) , and step 3 , item 5 ) ) that if the algorithm terminates , then the decoder has not reached an inconsistency and @xmath66 for all @xmath49 such that @xmath209 and @xmath69 , @xmath70 , since @xmath281 .",
    "the original turbo decoding algorithm will not introduce bit errors and neither will the improved turbo decoding algorithm due to items 5 ) and 7 ) in step 3 . in more detail",
    ", the algorithm will not terminate if the decoder has reached an inconsistency , and no further guessing is performed if this is the case .",
    "thus , if the improved turbo decoding algorithm terminates , then transmitted codeword is recovered , or there exists a different turbo codeword @xmath282 with support set @xmath283 where @xmath137 denotes the subset of remaining erased bit - positions . in the latter case",
    "the transmitted codeword is not recovered .",
    "an ml decoder will not be able to determine the transmitted codeword in the latter case either , since both codewords @xmath85 and @xmath284 where @xmath85 denotes the transmitted codeword are equally likely to have been transmitted .",
    "thus , improved turbo decoding is ml decoding .",
    "* as the algorithm proceeds , erased bit - positions are guessed .",
    "each time an element @xmath285 is removed from the list @xmath196 , turbo decoding is performed .",
    "if the decoder does not reach an inconsistency and @xmath286 for some @xmath49 such that @xmath209 and @xmath69 , @xmath70 , then a _ new _ erased bit - position is guessed ( see the bit - position selection algorithm in section  [ sec : turbo_improved ] and lemma  [ lemma:1 ] for details ) .",
    "the decoder will always terminate , since there is a finite number of bit - positions to guess .      here",
    "we present some simulation results of improved turbo decoding on the bec .",
    "the simulated frame error rate ( fer ) is presented in fig .",
    "[ figur2 ] for the @xmath149 turbo code introduced in section  [ sec:155turbo ] .",
    "we have used the bit - position selection algorithm described in section  [ sec : turbo_improved ] in the simulations .",
    "the truncated union bound ( tub ) in fig .",
    "[ figur2 ] is computed from the first @xmath287 non - zero terms of the code s weight distribution .",
    "the near ml decoding curve is obtained using improved turbo decoding with a large number for @xmath188 . in table",
    "[ tab : table3 ] we have tabulated , for different values of the channel erasure probability @xmath1 , the empirical value of @xmath288 such that improved turbo decoding is near ml decoding . in this context , improved turbo decoding is near ml decoding when the fraction of ml - decodable frame errors observed in the simulation is @xmath289 .",
    "the corresponding estimated values of the expected number of iterations @xmath290 $ ] are tabulated in the third row of the table .",
    "the gap between the tub and the near ml performance curve at moderate - to - high values of @xmath1 is due to the fact that only a limited number of codewords are taken into account in the summation of the union bound .",
    "the two remaining curves show the fer for two different values of @xmath188 .",
    "observe that when @xmath188 is increased , the performance improves . in table",
    "[ tab : table2 ] estimated values of @xmath290 $ ] of improved turbo decoding are tabulated for different values of @xmath1 and @xmath188 . from table  [",
    "tab : table2 ] we observe that the difference in the estimated values of @xmath290 $ ] for @xmath291 and @xmath292 decreases when @xmath1 decreases .",
    "in particular , for @xmath293 , there is almost no difference in the expected number of iterations .",
    "however , as can be seen from fig .",
    "[ figur2 ] , there is a large difference in performance .",
    "the numbers in tables  [ tab : table3 ] and [ tab : table2 ] are based on more than @xmath294 observed frame errors for @xmath295 , and more than @xmath296 frame errors for @xmath297 .",
    "similar performance improvements have been observed for the @xmath298 turbo code from @xcite .",
    "fer on the bec of the @xmath149 turbo code from section  [ sec:155turbo].,width=432,height=384 ]    .",
    "[ tab : table3 ] estimated expected number of iterations @xmath290 $ ] and empirical @xmath188 such that improved turbo decoding is near ml decoding for the @xmath149 turbo code from section  [ sec:155turbo ] [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     only two types of irtssef are possible .",
    "it is easy to verify that the average over all possible interleavers is equal to the expression in ( [ eq : hamming1 ] ) .",
    "note that the wef is dependent on the interleaver while the _ non - codeword _ tssef is the same for _ all _ interleavers .",
    "let @xmath299 , @xmath42 , enumerate all subcode classes of @xmath41 constructed from trellis paths in constituent trellis @xmath300 leaving the all - zero vertex at trellis depth zero , and remerging into the all - zero vertex at or before trellis depth @xmath11 , with possible remerging into the all - zero vertex at other depths in between , subject to the constraint that , after remerging , the paths leave the all - zero vertex at the same trellis depth . in general , @xmath301 where @xmath302 is the number of subcode classes of @xmath41 of input support set size @xmath303 and parity support set size @xmath304 constructed from trellis paths of length @xmath305 , and with @xmath306 remergings with the all - zero vertex .",
    "notice that each subcode class in @xmath299 of input support set size @xmath303 and parity support set size @xmath304 constructed from trellis paths of length @xmath305 , and with @xmath306 remergings with the all - zero vertex , gives rise to @xmath307 subcode classes with the same input and parity support set sizes .",
    "thus , the conditional sirsef @xmath308 can be written as @xmath309 z^z.\\ ] ] finding a closed - form expression for the conditional sirsef ( as we did in section  [ sec : hamming ] when the constituent codes were hamming codes ) for a given ( large ) value of the interleaver length @xmath11 is difficult .",
    "for this reason , we will use an algorithmic approach to compute the most significant terms of the conditional sirsef in ( [ eq : transfer ] ) .",
    "one approach is to use the algorithm to be described in section  [ gpb ] with only one constituent code .",
    "see section  [ gpb ] below for details .",
    "let @xmath310 and @xmath311 denote the information bit - oriented and the extended information bit - oriented trellis modules of constituent code @xmath41 , @xmath42 .",
    "we assume that @xmath310 and @xmath311 both have input and output labels assigned to the edges .",
    "the trellises constructed from the trellis modules @xmath310 and @xmath311 are denoted by @xmath312 and @xmath313 , respectively .",
    "let @xmath314 denote the subset of @xmath315 of label sequences of paths that begin and end at the all - zero vertex at trellis depths @xmath55 and @xmath11 of the trellis @xmath316 , @xmath42 .",
    "finally , let @xmath317 denote the pccc with information length @xmath4 , constituent encoders @xmath318 and @xmath319 , and interleaver @xmath8 .",
    "note that the support sets of words of @xmath320 are in one - to - one correspondence with _ all _ turbo stopping sets of @xmath76 .",
    "thus , the minimum hamming weight of @xmath321 is equal to the minimum turbo stopping set size of @xmath322 . in general ,",
    "the set of turbo stopping sets can be obtained by _",
    "turbo encoding _ using the constituent encoders @xmath318 and @xmath319 .",
    "note that there could exist several paths in @xmath313 with the same input label sequence from which it follows that the complexity of turbo encoding could be more than linear in @xmath4 .",
    "let @xmath323 be the problem of finding all words of @xmath324 of hamming weight @xmath325 .",
    "this problem is equivalent of finding an exhaustive list of all turbo stopping sets of size @xmath325 . to simplify notation we assume below that the @xmath326 redundant systematic bits appear at the end of the input block .",
    "a _ constraint set _",
    "@xmath327 is a set @xmath328 , where @xmath329 is a set of distinct positions . for any constraint set @xmath327 , let @xmath330 be the set of length-@xmath4 vectors @xmath331",
    "let the _ length _ @xmath332 be the number of constraints .",
    "we will start with a constraint set @xmath327 of length @xmath187 of the form @xmath333 , i.e. , it applies consecutively to the first @xmath187 positions . when the turbo interleaver @xmath8 acts on @xmath327 , we obtain a new constraint set @xmath334 , where in general the constrained positions are scattered over the input block .",
    "let @xmath335 be the subset of @xmath321 that is obtained by encoding the input vectors in @xmath330 , let @xmath336 be the minimum hamming weight of @xmath337 , and let @xmath338 be any lower bound for @xmath336 .",
    "the pseudo - code of the algorithm to solve @xmath339 is given below .",
    "note that the algorithm has the same _ structure _ as the algorithm proposed by garello _",
    "_ in @xcite to solve @xmath340",
    ". we will refer to this algorithm as the gpb algorithm . however , there are some differences that we will discuss below .",
    "let @xmath341 be the subset of words generated by the constituent encoder @xmath342 when the input vectors are contained in @xmath330 , and let @xmath343 be the minimum hamming weight of @xmath341 . select any vector from @xmath330 as an input sequence of @xmath342 .",
    "after @xmath344 time units the encoder has reached a subset @xmath345 of cardinality @xmath346 of the set of trellis vertices of @xmath347 at trellis depth @xmath344 .",
    "the trellis path of @xmath347 from the all - zero vertex at trellis depth @xmath55 to vertex @xmath348 at trellis depth @xmath344 of minimum hamming weight is denoted by @xmath349 .",
    "let @xmath350 be the hamming weight of @xmath349 , and let @xmath351 be the minimum hamming weight of any path from vertex @xmath348 at trellis depth @xmath344 to the all - zero vertex at trellis depth @xmath11 .",
    "in general , it holds that @xmath352 the weights @xmath351 can be computed in a preprocessing stage using the viterbi algorithm .",
    "actually , the weights @xmath351 depend only on the vertex @xmath348 if @xmath344 is not too close to @xmath4 and @xmath347 is _ non - catastrophic_. this reduces the memory requirements .",
    "however , the weights @xmath353 have to be computed during the course of the algorithm . in general , the weights @xmath350 can be computed by a _ constrained _ viterbi algorithm . note that in the original gpb algorithm there is no need to apply a constrained viterbi algorithm here , since @xmath354 , and there is a unique path in @xmath355 from the all - zero vertex at trellis depth @xmath55 to the vertex @xmath356 at trellis depth @xmath344 .",
    "similarly , let @xmath357 be the subset of words generated by the constituent encoder @xmath319 when the input vectors are contained in @xmath358 .",
    "also , let @xmath359 be the minimum hamming _ parity _ weight of @xmath357 .",
    "we have @xmath360 note that @xmath361 is a lower bound on @xmath336 , since the sequence of input bits giving the minimum - weight path in the second constituent encoder trellis @xmath362 is not necessarily an interleaved version of the sequence of input bits giving the minimum - weight path in the first constituent encoder trellis @xmath347 .",
    "the value of @xmath359 can be determined by the use of a constrained viterbi algorithm .",
    "since the positions of @xmath363 are in general not consecutive , the complexity of calculating the value of @xmath359 by a constrained viterbi algorithm is larger than the complexity of calculating the weights @xmath364 , @xmath365 , needed in ( [ wca_eq ] ) .    in @xcite",
    "we outlined several improvements to the basic gpb algorithm for solving @xmath366 .",
    "all of the improvements described in the context of solving @xmath366 can be applied when solving @xmath323 .    from table  [ table1 ]",
    "we observe that the edge complexity of @xmath367 is large compared to the edge complexity of @xmath368 even for @xmath156 . to reduce complexity we propose to remove some of the edges from @xmath311 .",
    "for instance , all edges in @xmath311 that correspond to edge subspaces of @xmath310 of dimension @xmath369 , for some integer @xmath370 , can be removed .",
    "we remark that in principle every _ trellis - based _ turbo code weight spectrum computation or estimation algorithm can be adapted in a straightforward manner to find small - size turbo stopping sets .",
    "the only requirement is that the basic trellis module is substituted with the extended trellis module introduced above .",
    "we have considered the impulse methods by berrou and vaton @xcite , vila - casado and garello @xcite , and crozier _ et al .",
    "_ @xcite with promising results .",
    "we have applied the algorithm from section  [ gpb ] with the improvements from @xcite on a few example codes .",
    "the example codes are constructed without considering turbo stopping sets .",
    "consider the @xmath371 turbo code constructed by crozier _",
    "_ in @xcite .",
    "the code has an optimized minimum distance , is based on a drp interleaver , and is constructed from nominal rate-@xmath29 , @xmath372 constituent codes defined by the parity - check matrix @xmath373 the last polynomial which is irreducible and primitive has been chosen as the parity polynomial making the constituent encoders recursive . for this code",
    "there are @xmath374 , @xmath375 , and @xmath376 stopping sets ( codewords ) of size ( weight ) @xmath377 , @xmath378 , and @xmath379 , respectively .",
    "the minimum turbo stopping set size is smaller than the code s minimum distance .",
    "this is typically what happens for both short and moderate - length distance - optimized drp interleavers . with the uniform interleaver ,",
    "however , there are @xmath380 stopping sets ( codewords ) of size ( weight ) @xmath381 , @xmath382 , @xmath383 , @xmath176 , @xmath384 , @xmath183 , @xmath175 , @xmath160 , @xmath159 , @xmath180 , @xmath153 , @xmath182 , @xmath385 , and @xmath386 , respectively .",
    "thus , small - size turbo stopping sets is not a problem with the uniform interleaver for these parameters . as another example consider an interleaver length of @xmath387 . in @xcite ,",
    "crozier _ et al .",
    "_ constructed an impressive drp interleaver of length @xmath387 with a dither length of @xmath154 .",
    "the corresponding turbo code has length @xmath388 , dimension @xmath389 , and minimum distance @xmath390 . for this code",
    "we have found turbo stopping sets of size @xmath391 .",
    "results for a range of interleaver lengths are given in fig .",
    "[ fig : dmin_data_matlab ] .",
    "the turbo codes are constructed from the same nominal rate-@xmath29 constituent codes as the @xmath371 code above . for each interleaver length between @xmath392 and @xmath393 ,",
    "in which the dither length is a divisor , we have found the best ( in terms of turbo code minimum distance ) drp interleaver with a dither length of @xmath394 .",
    "also , for the same interleavers we have found the minimum turbo stopping set sizes .",
    "these results are plotted in fig .",
    "[ fig : dmin_data_matlab ] .",
    "note that for several interleaver lengths the minimum turbo stopping set size is smaller than the minimum distance .",
    "minimum distance and minimum turbo stopping set size as a function of interleaver length for distance - optimized drp interleavers with a dither length of @xmath394.,width=432,height=384 ]",
    "in this work we have considered the finite - length analysis of turbo decoding on the bec . in the same way as",
    "iterative bp decoding of ldpc codes is simpler on the bec than on other channels , turbo decoding can also be simplified on this channel .",
    "based on this simplified turbo decoding algorithm we have introduced turbo stopping sets by adapting the concept of stopping sets from the theory of iterative bp decoding of ldpc codes .",
    "these turbo stopping sets characterize turbo decoding on the bec , and an exact condition for decoding failure has been established as follows .",
    "apply turbo decoding until the transmitted codeword has been recovered , or the decoder fails to progress further .",
    "then the set of erased positions that will remain when the decoder stops is equal to the unique maximum - size turbo stopping set which is also a subset of the set of erased positions .",
    "furthermore , we have presented some improvements of the basic turbo decoding algorithm on the bec .",
    "the proposed improved turbo decoding algorithm has substantially better error performance as illustrated by simulation examples . in the second part of the paper an expression for",
    "the turbo stopping set size enumerating function under the uniform interleaver assumption was derived .",
    "also , an efficient enumeration algorithm of small - size turbo stopping sets for a particular interleaver was given .",
    "the solution is based on the algorithm proposed by garello _",
    "_ in 2001 to compute an exhaustive list of _ all _ low - weight codewords in a turbo code .",
    "in fact , it turns out that every trellis - based weight spectrum computation or estimation algorithm for turbo codes can be adapted to the case of finding small - size turbo stopping sets .",
    "in particular , the impulse methods by berrou and vaton , vila - casado and garello , and crozier _ et al . _ can be adapted in a straightforward manner .",
    "one interesting topic for future work is the design of interleavers in which one considers both low - weight codewords and small - size turbo stopping sets .",
    "trellis - based interleaver design algorithms can in a similar manner be adapted to this problem using the extended trellis module .",
    "finally , we remark that the findings in this paper can be adapted in a fairly straightforward manner to other turbo - like codes , e.g. , ra codes , serial concatenated convolutional codes , and product codes .        b.  n.  v. ravisankar and f.  fekri , `` results on the improved decoding algorithm for low - density parity - check codes over the binary erasure channel , '' 2005 , _ ieee trans .",
    "theory _ , submitted for publication .",
    "c.  di , d.  proietti , i.  e. telatar , t.  j. richardson , and r.  l. urbanke , `` finite - length analysis of low - density parity - check codes on the binary erasure channel , '' _ ieee trans .",
    "inform . theory _",
    "48 , no .  6 , pp . 15701579 , june 2002 .    c.  berrou , a.  glavieux , and p.  thitimajshima , `` near shannon limit error - correcting coding and decoding : turbo - codes . 1 , '' in _ proc",
    "( icc ) _ , geneva , switzerland , may 1993 , pp . 10641070 .",
    "r.  garello , p.  pierleoni , and s.  benedetto , `` computing the free distance of turbo codes and serially concatenated codes with interleavers : algorithms and applications , '' _ ieee j. select .",
    "areas commun .",
    "_ , vol .  19 , no .  5 , pp . 800812 , may 2001 .",
    "s.  crozier , p.  guinand , and a.  hunt , `` computing the minimum distance of turbo - codes using iterative decoding techniques , '' in _ proc .",
    "22th biennial symp .",
    "_ , kingston , ontario , canada , may - june 2004 , pp .",
    "306308 .",
    "a.  vila - casado and r.  garello , `` the all - zero iterative decoding algorithm for turbo code minimum distance computation , '' in _ proc .",
    "( icc ) _ , vol .  1 , paris , france , june 2004 , pp . 361364 .",
    "j.  feldman and d.  r. karger , `` decoding turbo - like codes via linear programming , '' in _ proc .",
    "43rd annu .",
    "ieee symp .",
    "foundations of computer science ( focs ) _ , vancouver , bc , canada , nov .",
    "2002 , pp . 251260 .",
    "j.  feldman , m.  j. wainwright , and d.  r. karger , `` linear programming - based decoding of turbo - like codes and its relation to iterative approaches , '' in _ proc .",
    "allerton conf . on communications , control , and computing _ ,",
    "monticello , il , oct .",
    "j.  feldman , `` decoding error - correcting codes via linear programming , '' ph.d .",
    "dissertation , dept .  of electrical engineering and computer science ,",
    "massachusetts institute of technology ( mit ) , cambridge , ma , 2003 .",
    "o. vontobel and r.  koetter , `` graph - cover decoding and finite - length analysis of message - passing iterative decoding of ldpc codes , '' 2005 , _ ieee trans .  inform .",
    "theory _ , submitted for publication .",
    "[ online ] .",
    "available : http://arxiv.org/abs/cs.it/0512078/      e.  rosnes , `` on the connection between finite graph covers , pseudo - codewords , and linear programming decoding of turbo codes , '' in _ proc .",
    "symp . on turbo codes & related topics _ , munich , germany , apr . 2006 .",
    "t.  tian , c.  r. jones , j.  d. villasenor , and r.  d. wesel , `` construction of irregular ldpc codes with low error floors , '' in _ proc .",
    "( icc ) _ , vol .  5 ,",
    "anchorage , ak , may 2003 , pp . 31253129 .",
    "h.  d.  l. hollmann and l.  m. g.  m. tolhuizen , `` on parity check collections for iterative erasure decoding that correct all correctable erasure patterns of a given size , '' 2005 , _ ieee trans .",
    "inform . theory _ , submitted for publication .",
    "[ online ] .",
    "available : http://arxiv.org/abs/cs.it/0507068/      s.  crozier and p.  guinand , `` distance upper bounds and true minimum distance results for turbo - codes designed with drp interleavers , '' in _ proc .",
    "3rd int . symp . on turbo codes & related topics _ , brest , france , sept .",
    "2003 , pp . 169172 .",
    "e.  rosnes and  .",
    "ytrehus , `` on the construction of good families of rate - compatible punctured turbo codes , '' in _ proc .",
    "symp . on inform .",
    "theory ( isit ) _ , adelaide , sa , australia , sept .",
    "2005 , pp . 602606 .",
    "r.  j. mceliece , `` the algebraic theory of convolutional codes , '' in _ handbook of coding theory _ , v.  s. pless and w.  c. huffman , eds .",
    "1em plus 0.5em minus 0.4emnorth - holland , amsterdam : elsevier , 1998 , ch ."
  ],
  "abstract_text": [
    "<S> this paper is devoted to the finite - length analysis of turbo decoding over the binary erasure channel ( bec ) . </S>",
    "<S> the performance of iterative belief - propagation ( bp ) decoding of low - density parity - check ( ldpc ) codes over the bec can be characterized in terms of _ stopping sets_. we describe turbo decoding on the bec which is simpler than turbo decoding on other channels . </S>",
    "<S> we then adapt the concept of stopping sets to turbo decoding and state an exact condition for decoding failure . </S>",
    "<S> apply turbo decoding until the transmitted codeword has been recovered , or the decoder fails to progress further . </S>",
    "<S> then the set of erased positions that will remain when the decoder stops is equal to the unique maximum - size _ turbo stopping set _ which is also a subset of the set of erased positions . </S>",
    "<S> furthermore , we present some improvements of the basic turbo decoding algorithm on the bec . </S>",
    "<S> the proposed improved turbo decoding algorithm has substantially better error performance as illustrated by the given simulation results . </S>",
    "<S> finally , we give an expression for the turbo stopping set size enumerating function under the uniform interleaver assumption , and an efficient enumeration algorithm of small - size turbo stopping sets for a particular interleaver . </S>",
    "<S> the solution is based on the algorithm proposed by garello _ </S>",
    "<S> et al . _ in 2001 to compute an exhaustive list of _ all _ low - weight codewords in a turbo code .    binary erasure channel , improved decoding , stopping set , turbo decoding , uniform interleaver , weight spectrum . </S>"
  ]
}