{
  "article_text": [
    "data storage technologies in magnetic and flash memories are shifting towards a two - dimensional ( 2d ) paradigm since it offers better signal - to - noise ( snr ) ratio and format efficiency @xcite , inturn leading to higher storage densities .",
    "examples of such storage technologies include 2d magnetic recording @xcite , bit - patterned media @xcite , flash storage @xcite , optical holographic recording @xcite etc .",
    "the native format of data applicable to these technologies is inherently two - dimensional .",
    "this is useful for combating 2d intersymbol - interference , noise and other impairments .",
    "storage channels have noise bursts along with an intersperse of random errors @xcite . the data to be encoded and written onto the storage medium",
    "must be capable of overcoming a mixture of burst and random errors .",
    "thus , designing efficient 2d error correcting codes along with modulation codes is important for these storage channels along with sophisticated signal processing for timing recovery , equalization and detection @xcite as a precursor step before decoding . in this paper",
    ", we develop a theory for encoding 2d data resilient to burst errors .    while there are many well known approaches for correcting 1d burst errors ,",
    "the design of codes for correcting 2d errors is non trivial for the following reasons : ( a ) the shape of a 2d burst can be arbitrary , unlike a 1d burst string of errors .",
    "( b ) the errors can be correlated in 2d and non - separable , requiring a 2d frame work for efficient encoding and decoding . in the following sub - sections",
    ", we will survey 2d coding techniques relevant within the context of our work and highlight our contribution .",
    "the fundamental theory of 2d cyclic codes was first formulated by imai @xcite with the construction of generator and parity check tensors for 2d codewords .",
    "the construction was analogous to the construction of 1d linear block codes .",
    "this code could correct only a single burst error of an arbitrary error pattern and was not designed for correcting single burst of more than one error pattern . in a recent paper by yoon and moon @xcite , they provided the construction of a code with disjoint syndrome sets among specific error patterns , improving the construction in @xcite .",
    "this helped in correction of a single occurrence of an error pattern from a finite set of different error patterns .",
    "however , they did not address the correction of multiple burst errors.____others @xcite-@xcite have constructed codes for correcting a small cluster of errors by converting the 2d binary codewords into symbols of non - binary codewords by grouping the bits along rows and columns .",
    "although they can correct an error pattern of any shape , their method could not correct multiple disjoint cluster of errors .",
    "blahut @xcite introduced higher dimensional finite field transforms for realizing algebraic codes over curves .",
    "madhusudhana and siddiqui @xcite extended blahut s decoding algorithm for 2d bch codes .",
    "analogous to the 1d bch code , the 2d extension is required to have a block of contiguous positions set to zero in the frequency domain , where , the syndromes are calculated sequentially .",
    "they show correction of random and burst errors from a deconvolution viewpoint .",
    "however , their work does not incorporate the idea of disjoint syndrome sets which otherwise can lead to miscorrections .",
    "shiozaki @xcite presented a new class of 2d codes over @xmath0 using 2d fourier transform techniques of dimension @xmath1 . in that work ,",
    "an exact relationship between the parity check symbols and the minimum distance was also provided .",
    "however , the code construction does not accommodate disjoint syndrome sets .",
    "also , the details of the decoding procedure are not explicitly provided . in this paper , we present a construction of 2d codewords in the frequency domain for correcting multiple burst errors .",
    "our work is based on the 2d finite field transform inspired from the work in @xcite .",
    "we present a construction of 2d linear codes using the finite field fourier transform for correcting multiple non - overlapping occurrences of different error patterns from a finite set of predefined error patterns .",
    "our encoding scheme uses the conjugacy property of the 2d finite field fourier transform . unlike prior approaches @xcite ,",
    "the encoding process is simple as it does not need any parity check or generator tensors .",
    "further , our code construction is tailored for correcting a set of predefined error patterns as well as an arbitrary linear combination from the set of predefined error patterns .",
    "most 1d decoding approaches follow a two step process of identifying error locations followed by error correction . in the 2d case , we first need to identify which error pattern has occurred . with this information",
    ", we try to solve the erroneous locations . in case",
    "we do not identify the error pattern , we declare an occurrence of uncorrectable error . in our work",
    ", we also consider the correction of multiple disjoint bursts of the same pattern assuming the number of bits to be corrected falls within the minimum distance bound , a feature not considered in @xcite-@xcite .",
    "the set of common roots among all the codewords in the code forms the set of common zeros @xcite . to facilitate the decoding procedure",
    ", we formulate the common zero set accordingly .",
    "a subset of the common zero set is defined as the set of indicator zeros .",
    "this set of zeros are used to identify the error pattern that might have occurred .",
    "the remaining set of zeros are used to form the syndrome equations in the transformed domain for solving the erroneous locations in contrast to the approach in @xcite .",
    "the entire common zero set is also chosen in a way to obtain disjoint syndrome sets among a set of predefined error patterns / error events .",
    "yoon and moon @xcite gave a criterion to obtain disjoint syndrome sets among specific error patterns .",
    "we interpret the same criterion from a transform domain perspective .",
    "the construction in @xcite required a block of contiguous zeros in the transform domain .",
    "however , in our work , we relax this constraint and choose the zeros for _ a - priori _ identification of error patterns , and obtaining disjoint syndrome sets among predefined error patterns .",
    "the paper is organized as follows . in section",
    "ii , we highlight the code description and motivate the 2d finite field fourier transform ( ffft ) . in section iii , we develop an encoding scheme for mapping 2d binary arrays into 2d codewords using ffft . in section iv",
    ", we discuss the decoding of 2d codewords in the transform domain that can correct simultaneous occurrence of disjoint error patterns with illustrative examples .",
    "we conclude the paper in section v.",
    "a 2d binary code @xmath2 of dimension @xmath3 is a collection of arrays having @xmath4 rows and @xmath5 columns with elements from @xmath6 .",
    "a 2d array can be described using a bi - variate polynomial expression as ,    @xmath7    where , @xmath8 and @xmath9 .",
    "a 2d code is cyclic if @xmath10 .",
    "a 2d binary code is said to be linear if @xmath11 .",
    "let @xmath12 $ ] denote the set of all bi - variate polynomials . if @xmath13 $ ] , then @xmath14    where ,",
    "@xmath15 and @xmath16 are polynomials over @xmath6 .",
    "consider a bi - variate polynomial @xmath17 .",
    "a point @xmath18 is said to be a root of @xmath17 if @xmath19 for a code of dimension @xmath3 , let @xmath20 and @xmath21 be the primitive @xmath22 and @xmath23 roots of unity respectively i.e. , @xmath24 and @xmath25 all roots constitute the set @xmath26 given by @xmath27 the roots common to all the codewords in the code are referred to as the set of _ common zeros_. for any set of zeros @xmath28 , common to some arbitrary polynomials over @xmath6 , if @xmath29 then @xmath30 for @xmath31 and @xmath4 is the least positive integer for which @xmath32 .",
    "these points are known as conjugate points in @xmath33 . from the set @xmath26",
    ", we select a subset @xmath34 , which will be our set of common zeros .",
    "a 2d code is completely characterized by this set of common zeros .",
    "the 2d finite field fourier transform ( ffft ) for an array of dimension @xmath3 having elements from gf(2 ) is defined as @xmath35    @xmath36 , @xmath37 , where @xmath38 denotes the least common multiple",
    ". if we have @xmath39 and @xmath40 , the elements of @xmath41 are from @xmath42 .",
    "thus , a binary codeword gets converted to a non - binary codeword of the same dimension .",
    "this is a direct extension from the 1d ffft defined in @xcite      the 2d finite field inverse finite field fourier transform ( iffft ) is defined as @xmath43    where , @xmath44 is the characteristic of the field and @xmath45 is defined as the remainder obtained while @xmath46",
    "we highlight the encoding procedure in @xcite in this section for completeness .",
    "the encoding of the 2d codewords in @xcite begins by selecting the common zero set @xmath34 which is followed by the creation of the parity check tensor . the generator tensor is then created from the parity check tensor and used for encoding a message . later in the section ,",
    "we describe the encoding process of the code using 2d ffft , and highlight its various advantages over @xcite .",
    "the parity check tensor @xcite can have two forms .",
    "in the first form , each element of the parity check tensor is a binary vector of length equal to the cardinality of the common zero set .",
    "the other form has a bi - variate polynomial as its elements .",
    "the second form is required because we need to generate our 2d codewords in polynomial form .",
    "two zeros of @xmath34 are said to be equivalent if the first component of their coordinate are conjugates over @xmath6 .",
    "thus , to find the parity position , we have to partition @xmath34 into equivalence classes .",
    "two roots @xmath47 are said to be equivalent @xcite i.e. , @xmath48 for some positive integer @xmath49 , if @xmath50 .",
    "each component of the parity check tensor , which is a binary vector , is split in length depending on the size of each of the equivalence classes . for a particular @xmath51 coordinate of the tensor",
    ", we express @xmath52 in terms of @xmath53 for the @xmath54 segment .",
    "the binary vectors created at the parity positions are all linearly independent .",
    "the binary vectors at the message positions can be expressed as a linear combination of these vectors .",
    "let the set of all coordinates of the 2d code be defined as @xmath55 , and , the set of all parity positions be defined by the set @xmath56 .",
    "each vector at position @xmath51 is expressed as @xmath57    where , @xmath58 and @xmath59 . to get the algebraic form of the parity check tensor",
    ", we express the components in bi - variate polynomial form as @xmath60    the operators @xmath61 and @xmath62 @xcite operating on @xmath63 is defined as @xmath64 & = & h_{\\mathrm{mod(}(i+1),n),j}(x , y),\\label{eq : tx}\\\\ t_{y}[h_{i , j}(x , y ) ] & = & h_{i,\\mathrm{mod((j+1),}m)}(x , y).\\label{eq : ty}\\end{aligned}\\ ] ] from the construction of the parity check tensor in the algebraic form , we see that , @xmath65 component is always 1 .",
    "few properties of @xmath61 and @xmath62 @xcite are as follows :    1 .",
    "@xmath66 2 .",
    "@xmath67    a residue of a polynomial @xmath17 is defined as @xmath68 a bi - variate codeword @xmath17 is said to be valid if its residue is zero , i.e. , @xmath69      the relation between @xmath51 components of the generator tensor and the parity check tensor is given by , @xmath70 from equation ( [ eq : valid_in_time ] ) , it is easy to verify that each component of the generator tensor is a valid 2d codeword",
    ".    let the message polynomial be @xmath71 where @xmath72 for @xmath73 .",
    "the work done in @xcite does not provide an explicit mathematical expression for encoding .",
    "we prove a result on the encoding of a message vector @xmath74 into a valid codeword @xmath75 in the following lemma .",
    "the encoding equation of the message vector @xmath74 into a codeword @xmath75 follows as , @xmath76    we know that a codeword @xmath75 is valid if @xmath77 .",
    "so , we can write the codeword @xmath75 as @xmath78    simplifying further by using properties of @xmath61 and @xmath62 , and using ( [ eq : generator ] ) in ( [ eq : msgres ] ) , we have @xmath79    thereby , proving the result .",
    "the original form and the transformed representation of codewords are defined in the time and frequency domains respectively .",
    "we use the ffft technique to transform the codewords in the frequency domain .",
    "the data is encoded directly into the transformed domain .",
    "this procedure is easier because it helps us to save space for not storing the parity check and generator tensors , which are of considerable size .",
    "this reduces the space complexity at the transmitter side extensively .",
    "the binary codewords are obtained from the transformed domain using 2d iffft . in the transformed domain ,",
    "the conjugacy constraints are used to express the coordinates of the transformed codeword .      for a 2d code over @xmath0 , @xmath80    for an element @xmath81 , we have @xmath82 .",
    "also , we know in case of finite fields , for elements @xmath83 , the following relation holds : @xmath84    thus , from ( [ eq : ffft ] ) ,    @xmath85    the last step follows since @xmath86    thereby , proving the result .",
    "let @xmath87 be a zero of the codespace . in the frequency domain , @xmath88 .",
    "we have ,    @xmath89    plugging in @xmath87 for @xmath90 , we have    @xmath91    from ( [ eq : ffft ] ) , @xmath88 , which proves our result .",
    "thus , the condition for checking the validity of a codeword in the frequency domain is    @xmath92    @xmath93 .",
    "let the common zero set in the frequency domain be    @xmath94    from lemma 3 , the components in @xmath95 will be zero .",
    "we show one valid codeword in the transform domain that satisfies lemma 3 and the conjugacy constraints . as an example , @xmath96    now , using the 2d iffft equation from ( [ eq : iffft ] ) , we have the time domain codeword as @xmath97    our encoding scheme clearly avoids the creation of parity check and generator tensors to encode a message .",
    "given the considerable size of these matrices it helps to save space for storing them .",
    "lemmas 2 and 3 are sufficient to encode the code in the frequency domain .",
    "however , codewords are always stored in binary format in storage devices .",
    "this is where the 2d iffft operation comes into play .",
    "after encoding , the codeword undergoes the inverse transformation and stored as binary data .",
    "in this section , we will discuss decoding in the frequency domain . in time domain ,",
    "the received codeword @xmath98 , transmitted codeword @xmath99 , and the error vector @xmath100 are related by the following equation : @xmath101    where , @xmath102 and @xmath103 . as ffft is an linear operation , the same equality holds .",
    "let @xmath104 be the received codeword , @xmath105 be the transmitted codeword , and @xmath106 be the error vector in frequency domain .",
    "we have , @xmath107 according to lemma 3 , @xmath108    @xmath109    when we receive a codeword , the coordinates corresponding to the common zero set must be zero according to equation ( [ eq : refff ] ) .",
    "so , we need to find those frequency components of the received codeword that are equal to those components of the error vector in the frequency domain .",
    "this results in solving fewer syndrome equations that finally gives us the error locations directly in the time domain .    in 1d codewords ,",
    "the burst length is a code design parameter , and the shape of the burst is inconsequential .",
    "the situation is much more complicated in 2d .",
    "for example , a three bit burst error can be considered in three shapes as shown below :    the code is designed to correct specific error shapes as mentioned below .",
    "the same code construction is extended to correct unknown error patterns that are a disjoint combination of specific error patterns .",
    "we begin with a few definitions relating error patterns .",
    "a _ local 2d error pattern _ is defined as an error pattern which has a polynomial expression @xmath16 over @xmath6 such that the coefficient of the monomial @xmath110 in @xmath111 ) is always 1 . for a code of dimension @xmath3 ,",
    "the maximum degrees that @xmath112 and @xmath113 can take are @xmath114 and @xmath115 respectively .",
    "global 2d error pattern _ is defined for a local error pattern @xmath16 starting from position @xmath51 .",
    "this is given by the following equation :    @xmath116    as it is clear from definition 1 , an error pattern need not necessarily mean contiguous erroneous positions .",
    "this means that an isolated non - contiguous erroneous position is also considered as an error pattern .      in this paper , we have considered horizontal and vertical error patterns as our basic error patterns .",
    "let us consider a horizontal burst of error of dimension @xmath117 starting at position @xmath51 .",
    "the error vector in the time domain is @xmath118 the 2d transformed error vector for ( [ eq : t12 ] ) is given by @xmath119    the following property holds true .",
    "a horizontal burst of dimension @xmath120 i.e. , putting @xmath121 , can not be corrected .    from ( [ eq:12 ] ) , @xmath122    as @xmath123 , we have , @xmath124 it is clear from the above equations that the maximum value that @xmath125 can take is @xmath115 . if @xmath121 , from ( [ eq : z12 ] ) , @xmath126 is always zero @xmath127 which indicates undetected error .",
    "let us consider a vertical burst of error of dimension @xmath128 starting at position @xmath51 .",
    "the error vector in the time domain is @xmath129 the 2d transformed error vector is computed as @xmath130    from lemma 4 and using @xmath131 the maximum value @xmath132 can take is @xmath114 .    from here on , we will consider @xmath133 and @xmath134      simultaneous occurrence of both horizontal and vertical burst errors could result in a number of unknown error patterns . considering a horizontal error pattern of dimension @xmath135 and a vertical error pattern of dimension @xmath136 .",
    "the following figure shows some possible unknown error patterns .",
    "we restrict our code to correct errors with error pattern 1 or error pattern 2 or a combination of both .",
    "let us assume these error patterns start at position @xmath137 and @xmath138 .",
    "consider the following error polynomial .",
    "@xmath139    where @xmath140 @xmath141 and @xmath142 implies occurrence of error pattern 1 only .",
    "@xmath143 and @xmath144 implies occurrence of error pattern 2 only . @xmath141",
    "and @xmath144 implies occurrence of both error patterns .",
    "the common zero set specifies the code completely .",
    "the correction ability of the code is decided by selecting the common zero set .",
    "the common zero set is selected considering the following two salient points :    * disjoint syndrome sets among predefined error patterns . *",
    "inclusion of indicator roots that help us to check the presence of a particular type of error .",
    "we elaborate these steps now .      according to ( [ eq : refff ] ) , the syndrome components obtained at the common zero positions are equal to those corresponding components of the error vector in the frequency domain .",
    "we equate these set of equations and solve for @xmath145 and @xmath146 .",
    "a criteria for obtaining disjoint syndrome set is mentioned in @xcite .",
    "if @xmath147 and @xmath148 are the set zeros of two error patterns @xmath149 and @xmath150 respectively , and if @xmath34 is the set of common zeros , then the following result must follow to get disjoint syndrome set between the aforesaid error patterns i.e. , @xmath151 this can be understood in the frequency domain in a different way .",
    "consider only horizontal and vertical error patterns .",
    "equations ( [ eq:12 ] ) and ( [ eq:21 ] ) give us a set of equations for solving the erroneous codeword for horizontal and vertical error patterns .",
    "when a horizontal burst error occurs , the set of equations given by ( [ eq:12 ] ) can be solved . on the other hand",
    ", the system of equations from ( [ eq:21 ] ) should result in no solution .",
    "if it does not happen , we have @xmath152    where , it is assumed that the syndrome for error of pattern 1 occurring at position @xmath51 matches with the syndrome for error of pattern 2 occurring at position @xmath153 . we have taken @xmath133 and @xmath134 thus , for disjoint syndrome set , ( [ eq : syn_freq_con ] )",
    "should have no solution among @xmath154 and @xmath155 .",
    "let @xmath156 be the set of zeros of an error pattern @xmath16 .",
    "let @xmath34 be the set of common zeros for the code and @xmath157 be the roots of the received codeword .",
    "if the transmitted codeword @xmath75 is affected by @xmath16 and @xmath158 then @xmath159    @xmath160    we have ,    @xmath161    let us consider @xmath162    this implies three following cases :    * case 1 : * @xmath163 and @xmath164    ]    setting @xmath165 we get ,    @xmath166    clearly the r.h.s is not equal to zero which shows @xmath167 is not a root of @xmath168 , which is a clear contradiction .",
    "* case 2 : * @xmath169    ]    this implies @xmath170 and @xmath164 thus , we have @xmath171 which implies @xmath172 , which is again a contradiction .",
    "* case 3 : * @xmath173    ]    this implies @xmath172 and @xmath174 thus , we have @xmath171 which implies @xmath172 which is also a contradiction .    thus , we can conclude @xmath159 ,    @xmath160      _ indicator zero _ set is a subset of the common zero set which is used to identify the presence of an error pattern _ a - priori _ , but not its locations .",
    "each element of the indicator zero set is also a root of at least one of the error pattern .",
    "theorem 1 shows the necessity of including at least one zero from each possible error pattern into the common zero set .",
    "these set of zeros form the indicator zero set . evaluating the received codeword at these zero values",
    "help us to identify the error pattern .",
    "the other zeros in the common zero set are not chosen from any set of roots of the predefined error patterns .",
    "the syndromes at these positions will be non - zero if the received codeword is erroneous .",
    "the non - zero syndromes are used to construct the syndrome equation which will finally be used to solve the error locations .",
    "let @xmath156 be the set of zeros for the error pattern @xmath16 , and let @xmath157 be the set of zeros for the received codeword @xmath175 if @xmath176 then it can not identified _ a - priori _ and @xmath177    if @xmath75 is the transmitted codeword affected by @xmath16 , the received codeword @xmath168 is given by the following equation :    @xmath161    for all possible values @xmath90 , we have @xmath178 thus , @xmath179 , which means @xmath180 .",
    "thus , we can not identify such error patterns , as there could be more than one error pattern having empty root sets .    in this paper",
    "the predefined error patterns considered are of dimension @xmath135 and @xmath136 .",
    "the bi - variate polynomial expression for the 2d local error patterns are ,    @xmath181    consider a code of dimension @xmath3 .",
    "the respective set of roots for the above equations in time domain are ,    @xmath182    presence of both error patterns starting from different locations and not overlapping has the following polynomial equation ,    @xmath183    the roots of this equation are given by    @xmath184    thus , from theorem 1 , the common zero set should have the root @xmath185 to identify the presence of @xmath186 . to identify @xmath187 and @xmath188",
    ", we have to select a root from @xmath189 and @xmath190 respectively .",
    "the following set @xmath191 gives us the set of indicator zeros contained in @xmath192    @xmath193    thus , when @xmath168 is received , we evaluate it at the roots from the set @xmath191 and identify the presence of an error pattern .",
    "we have the following cases :    * case 1 : * @xmath186 is identified as the error pattern if ,    * @xmath194 * @xmath195 * @xmath196    * case 2 : * @xmath187 is identified as the error pattern if ,    * @xmath194 * @xmath197 * @xmath196    * case 3 : * @xmath188 is identified as the error pattern if ,    * @xmath194 * @xmath195 * @xmath198    * case 4 : * no error pattern is identified if ,    * @xmath199 @xmath200 and @xmath201 .",
    "* @xmath202 @xmath203 and @xmath204 .",
    "* @xmath199 @xmath200 and @xmath198 * @xmath199 @xmath203 and @xmath196 * @xmath199 @xmath203 and @xmath198    the last case signifies a uncorrectable error pattern .",
    "we illustrate this through an example and formalize the procedure within algorithm 1 .    *",
    "input : * received codeword @xmath168 and @xmath34 .",
    "* step 1 : indicator zeros . *    * * set * @xmath205 * *",
    "if * @xmath206 & & @xmath207 & & @xmath208 * * set @xmath209 * * set @xmath210 * * else if * @xmath206 & & @xmath211 & & @xmath208 * * set @xmath209 * * set @xmath212 * * else if * @xmath206 & & @xmath207 & & @xmath213 * * set @xmath214 * * set @xmath210 * * else if * @xmath206 & & @xmath211 & & @xmath213 * * proceed to step 2 .",
    "* * else * * * output `` error can not be corrected '' .",
    "* step 2 : solve syndrome equations *    * evaluate syndrome values using the remaining values in @xmath34on @xmath175 * * if * all syndrome values are zero . *",
    "* set @xmath215 * * go to * output*. * * else * * * solve the syndrome equations . * * flip the solved erroneous positions to get @xmath216 * * go to * output . *    * output : * @xmath75 .",
    "let us assume that we have transmitted the zero codeword .",
    "our basic error patterns are @xmath135 and @xmath136 .",
    "let the common zero set in the frequency domain be ,    @xmath217    consider the following two received codewords .",
    "@xmath218    the syndrome equation considered here is given by the following equation ,    @xmath219    the elements @xmath220 , @xmath221 and @xmath222 are the indicator zeros .",
    "we have ,    @xmath224    it is clear that @xmath225 @xmath226 and @xmath227 thus , the error polynomial is of the form equivalent to @xmath228 hence , we make @xmath141 and @xmath229 to solve for the error locations , we plug in @xmath230 in equation ( [ eq:2error ] ) to obtain the following syndrome equations :    @xmath231    solving the above equations , we have @xmath232 and @xmath233 .",
    "we have ,    @xmath235    it is clear that @xmath225 @xmath236 and @xmath237 thus , the error polynomial is of the form equivalent to @xmath238 hence , we make @xmath141 and @xmath239 to solve for the error locations , we plug in @xmath240 in @xmath241 to obtain the following syndrome equations :    @xmath242    solving the above equation , we have @xmath243      presence of overlapping predefined error patterns of dimension @xmath135 and @xmath136 can not be determined _ a - priori _ and hence , can not be corrected .",
    "the polynomial expression of the error pattern as a linear combination of the error pattern of dimension @xmath135 and @xmath135 at position @xmath244 and @xmath245 respectively is given by , @xmath246    without loss of generality , let @xmath247 and @xmath248 for overlapping errors .",
    "we get , @xmath249 which gives two isolated errors .",
    "such an overlapping burst can be treated as a disjoint combination of an error of dimension @xmath135 error and an isolated error , or as a disjoint combination of an error of dimension @xmath136 and an isolated error .",
    "from theorem 2 , we have established that an isolated error is not within our set of predefined error patterns .",
    "thus , an error pattern formed in combination of any valid predefined error pattern with an isolated error can not be identified _ a - priori_.      if the total number of bits in error is within the minimum distance bound , this code can be used to correct the presence of multiple bursts of an error of a particular type .",
    "let us assume that the bursts are non - overlapping .",
    "for the general case , suppose there are @xmath250 number of burst errors of type @xmath251 that are non - overlapping , we can uniquely identify the position of the errors .",
    "the following theorem summarizes this result .",
    "presence of @xmath250 number of burst errors of type @xmath251 can be uniquely identified .",
    "presence of @xmath250 number of burst errors of type @xmath251 leads to the following expression in the transformed domain : @xmath252 equation ( [ eq : mul1 ] ) can be simplified further as @xmath253    let @xmath254 and @xmath255 for @xmath256 be two solutions of the above equation with none of component of the solutions equal . as the right hand side of the above equation",
    "does not have a variable , we have @xmath257    equation ( [ eq : unique_th2 ] ) implies either the terms are all equal , or they are pairwise equal .",
    "this gives us the following ordered pairs : @xmath258    any other combination will just be a permutation of the solution set which means , the solution set is unique , proving the result .",
    "the following example will illustrate our idea .",
    "let the received codeword be @xmath259    let the two bursts start at positions @xmath51 and @xmath153 .",
    "the corresponding error polynomial is @xmath260    let the common zero in the frequency domain be @xmath94 this gives us the following equations as before i.e. , @xmath261    the solution to the above system of equations gives the result @xmath262 and @xmath263 which are exactly the positions where the @xmath135 bursts start .",
    "previous decoding schemes @xcite required storing the syndrome polynomials for each error pattern . in our case , the erroneous positions are found directly by solving the appropriate syndrome equations .",
    "we presented a 2d cyclic code construction in the frequency domain .",
    "our code is capable of correcting simultaneous occurrence of multiple predefined error patterns .",
    "the encoding and decoding steps are done entirely in the transformed domain , thereby , facilitating efficient realization .",
    "further work is needed to extend this to a broad framework of 2d codes over curves .",
    "the authors would like to thank the department of electronics and information technology , grant no .",
    "mito0101 , for supporting this work .",
    "s. g. srinivasa , y. chen , and s. dahandeh , `` a communication - theoretic framework for 2-dmr channel modeling : performance evaluation of coding and signal processing methods '' , _ ieee trans .",
    "magn_. , vol .",
    "612 , march 2014 .",
    "r. wood , m. williams , a. kav@xmath264i@xmath265 , and j. miles , the feasibility of magnetic recording at 10 terabits per square inch on conventional media , _ ieee trans .",
    "magn_. , vol .",
    "2 , pp . 917923 , feb . 2009 .",
    "s. g. srinivasa , p. lee , s. w. mclaughlin , `` post - error correcting code modeling of burst channels using hidden markov models with applications to magnetic recording '' , _ ieee trans .",
    "2007 .",
    "k. saints and c. heegard , `` algebraic - geometric codes and multidimensional cyclic codes : a unified theory and algorithms for decoding using grobner bases '' , _ ieee trans .",
    "inf . theory _ ,",
    "41 , no . 6 , pp . 1733 - 1751 , nov ."
  ],
  "abstract_text": [
    "<S> we construct two - dimensional codes for correcting burst errors using the finite field fourier transform . </S>",
    "<S> the encoding procedure is performed in the transformed domain using the conjugacy property of the finite field fourier transform . </S>",
    "<S> the decoding procedure is also done in the transformed domain . </S>",
    "<S> our code is capable of correcting multiple non - overlapping occurrence of different error patterns from a finite set of predefined error patterns . </S>",
    "<S> the code construction is useful for encoding data in two dimensions for application in data storage and bar codes .    </S>",
    "<S> 2d error correcting codes , 2d finite field fourier transform , cyclic codes . </S>"
  ]
}