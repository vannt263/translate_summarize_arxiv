{
  "article_text": [
    "designing theorem provers for nonmonotonic reasoning formalisms is challenged by the increased computational complexity compared to the inherent complexity of classical reasoning .",
    "as is well - known  @xcite , the main reasoning tasks for almost all propositional nonmonotonic logics are either @xmath0-complete or @xmath1-complete , i.e. ,  they are located at the second level of the polynomial hierarchy , whereas classical reasoning resides at the first level of that hierarchy .",
    "important constituents in establishing the @xmath0-completeness results for the different nonmonotonic reasoning tasks are so - called _ quantified boolean formulae _ ( qbfs ) , which generalize ordinary propositional formulae by the admission of quantifiers ranging over propositional variables . to wit , demonstrating @xmath0-hardness of a given nonmonotonic decision problem ,",
    "say , is usually achieved by reducing the problem @xmath2 to , where @xmath2 is the problem of deciding the truth of qbfs being in prenex normal - form whose leading quantifiers are ordered like @xmath3 ( @xmath4 are lists of propositional variables ) , which is complete for @xmath0 .",
    "( in general , for any class @xmath5 , @xmath6 , there is a corresponding decision problem , @xmath7 , complete for @xmath5 , whose task is to check the truth of qbfs of the form @xmath8 , where @xmath9 are lists of propositional variables and @xmath10 is a propositional formula . )",
    "more precisely , @xmath0-hardness of  is shown by constructing a ( polynomial ) transformation @xmath11 such that for every instance @xmath12 of @xmath2 it holds that @xmath12 is a yes - instance of @xmath2 iff @xmath13 is a yes - instance of .",
    "now , given the membership of a nonmonotonic reasoning task  in the class @xmath0 , and from the @xmath0-hardness of @xmath2 , it follows immediately that every such decision problem  can be reduced to @xmath2 , i.e. ,  there is a ( polynomial ) transformation @xmath14 such that for every instance @xmath12 of  it holds that @xmath12 is a yes - instance of  iff @xmath15 is a yes - instance of @xmath2 .    in this paper",
    ", we describe the prototype system  @xcite , an automated reasoning tool utilizing transformations of the latter kind to implement several different reasoning formalisms .",
    "the basic idea is to employ _ existing sophisticated theorem provers for quantified boolean formulae _ , taking care of evaluating the resultant instances of @xmath2 .    at present ,  handles the following propositional nonmonotonic reasoning approaches :    * abduction ; * autoepistemic logic ; * default logic ; * disjunctive stable model semantics ; * circumscription .",
    "the system has been implemented in c using standard tools like lex and yacc ( comprising a total of 2000 lines of code , excluding the used qbf - solver ) ; it runs currently in a unix environment ( sun / solaris and linux ) , but is easily portable to other operating systems as well .",
    "the use of qbfs expressing advanced reasoning tasks has been advocated in  @xcite and is a natural generalization of a similar method applied for problems in np .",
    "such problems are often solved by a reduction to , the satisfiability problem of classical propositional logic , which is np - complete ( see , e.g. ,   @xcite ) . besides the applications discussed in this paper , a reduction of planning problems",
    "to qbfs has been given in @xcite .",
    "in general , since the evaluation of _ arbitrary _ qbfs is pspace - complete ( in contrast to the @xmath5-completeness of the restricted qbfs mentioned above ) , in principle _ any _ formalism having a decision problem in pspace   can be handled by , provided a proper transformation has been found .",
    "the next section outlines the overall architecture of  and gives some background information on the different reasoning tasks implemented in .",
    "then , the usability of the approach is described .",
    "the last section contains a discussion on benchmark problems and a comparison with other implementations .",
    "the overall architecture of  is depicted in figure  [ fig : quip - arch ] .",
    "consists of three parts , namely the filter program , the qbf - evaluator boole , and the output interpreter int .",
    "the input filter translates the given problem description ( e.g. ,  a default theory , a disjunctive logic program , an abductive problem , etc . ) into a quantified boolean formula , which is then sent to the qbf - evaluator boole .",
    "the result of boole , usually a formula in disjunctive normal form ( often called _ sum of products _ , sop ) , is interpreted by int .",
    "the latter part associates a meaningful interpretation to the formulae occurring in sop and provides an explanation in terms of the underlying problem instance ( e.g. ,  an extension , a stable model , abductive explanations , etc . ) .",
    "the interpretation relies on a mapping of internal variables of the generated qbf into concepts of the problem description which is provided by filter .",
    "the qbf - evaluator boole is a commonly available propositional theorem prover based on _ binary decision diagrams _ ( bdds )  @xcite .",
    "we chose to use this particular tool because of several reasons .",
    "for one , the program , together with its source code , is in the public domain and can be downloaded from the web ( see http://www.cs.cmu.edu/@xmath16modelcheck/bdd.html ) .",
    "second , it represents a sophisticated reasoning engine with several years of development .",
    "third , it does not require of the input formula to be in a specific normal form .",
    "the latter point distinguishes boole from other qbf - solvers , like those proposed in  @xcite , which operate on formulae being in _ prenex conjunctive normal form_. although these provers can in principle also be employed in , their inclusion would require an additional normal form translation , since the `` natural '' reductions of nonmonotonic reasoning tasks to qbfs do in general _ not _ result in formulae being in a particular normal form .    in order to incorporate new formalisms into ,",
    "one has to extend the filter program responsible for the appropriate reductions , the mapping of the variables , and the interpreter int .",
    "the deductive engine remains unchanged in this process .      in this subsection",
    ", we briefly discuss the different reasoning tasks currently implemented in .",
    "we will not present the concrete transformations into qbfs expressing these tasks ; details are given in  @xcite .",
    "all formalisms processed by  are propositional . in",
    "what follows , we assume a propositional language @xmath17 generated by a finite set of propositional variables @xmath18 using the standard sentential connectives @xmath19 , @xmath20 , @xmath21 , @xmath22 , and @xmath23 .",
    "a _ theory _ is a finite set @xmath24 , which will be identified with the formula @xmath25 .",
    "note that , strictly speaking , the different decision problems presented below return either _ yes _ or _ no _ , but usually one is more interested in the corresponding _ function problem _ returning the actual objects responsible for a _ yes _ answer ( like the extensions of a default theory , the stable models of a logic program , etc . )",
    ".   permits queries of this form , by engaging the so - called _ detail mode _ ( see discussion below ) .",
    "[ [ abduction . ] ] abduction .",
    "+ + + + + + + + + +    classical abduction from a theory @xmath26 on @xmath18 may be defined as follows  @xcite .",
    "let @xmath27 be a set of _ hypotheses _ , and let @xmath28 be a distinguished atom .",
    "a subset @xmath29 is an _ abductive explanation _ for @xmath30 from @xmath26 and @xmath31 , if    : :    @xmath32 is consistent , and ( ii ) : :    @xmath33 , i.e. ,  @xmath34 logically    implies @xmath30 .",
    "an explanation @xmath35 is _ minimal _ , if no proper subset @xmath36 is an abductive explanation .",
    "the following tasks are implemented in :    * given a theory @xmath26 , a set @xmath31 of variables , and an atom @xmath30 .",
    "is there a ( minimal ) abductive explanation @xmath37 for @xmath30 from @xmath26 and @xmath31 ? * the _ relevance problem _ : given a theory @xmath26 , a set @xmath31 of variables , an atom @xmath30 , and some hypothesis @xmath38 .",
    "is there a ( minimal ) abductive explanation @xmath37 for @xmath30 from @xmath26 and @xmath31 containing @xmath39 ? * the _ necessity problem _ : given a theory @xmath26 , a set @xmath31 of variables , an atom @xmath30 , and some hypothesis @xmath38 .",
    "does @xmath39 occur in every ( minimal ) abductive explanation @xmath37 for @xmath30 from @xmath26 and @xmath31 ?",
    "[ [ autoepistemic - logic . ] ] autoepistemic logic .",
    "+ + + + + + + + + + + + + + + + + + + +    the language of moore s autoepistemic logic @xcite contains the modal operator @xmath40 , where @xmath41 intuitively means that @xmath42 is believed . by @xmath43",
    "we denote the language @xmath44 extended by @xmath40 .",
    "formulae @xmath41 are viewed as propositional variables , which are called _",
    "modal atoms_.    a _ stable expansion _ of an autoepistemic theory @xmath45 is a set @xmath46 such that @xmath47 where @xmath48 is the classical consequence operator with respect to the extended language @xmath43",
    ".    handles the following tasks :    * given an autoepistemic theory @xmath49 , is there a stable expansion @xmath35 of @xmath26 ? * _ brave reasoning _ : given an autoepistemic theory @xmath49 and some formula @xmath10 , is there a stable expansion @xmath35 of @xmath26 containing @xmath10 ? * _ skeptical reasoning _ : given an autoepistemic theory @xmath49 and some formula @xmath10 , is @xmath10 contained in every stable expansion @xmath35 of @xmath26 ?    for brave and skeptical reasoning , if the detail mode is engaged ,  returns _ witnesses _ corresponding to theses tasks : for brave reasoning , all stable expansions containing @xmath10 are returned , whereas for skeptical reasoning , all stable expansions _ not _ containing @xmath10 are returned .",
    "[ [ default - logic . ] ] default logic .",
    "+ + + + + + + + + + + + + +    a _ default theory _ is a pair @xmath50 , where @xmath51 is a set of formulae and @xmath52 is a set of _ defaults _ of the form @xmath53 .",
    "intuitively , the default is applied ( @xmath54 is concluded ) if @xmath55 is provable and the _ justification _ @xmath56 can be consistently assumed .",
    "the semantics of @xmath57 is defined in terms of _ extensions _",
    "following  @xcite , extensions can be characterized thus . for any @xmath58 , let @xmath59 be the monotonic rules @xmath60 .",
    "then , @xmath61 is an extension of @xmath62 iff @xmath63 , where @xmath64 is the set of all formulae derivable from @xmath26 using classical logic together with the rules from @xmath65 .",
    "expresses the following reasoning tasks :    * given a default theory @xmath62 , is there an extension @xmath35 of  @xmath62 ? * _ brave reasoning _ : given a default theory @xmath62 and some formula @xmath10 , is there an extension @xmath35 of @xmath62 containing  @xmath10 ? * _ skeptical reasoning _ : given a default theory @xmath62 and some formula @xmath10 , is @xmath10 contained in every extension @xmath35 of @xmath62 ?    as for stable expansions ,  returns witnesses if the detail mode is engaged .",
    "moreover , each of these reasoning tasks has been implemented in terms of two independent transformations : the first category of reductions is based on the characterization of extensions discussed above ; the second category is based on a characterization of extensions using the notion of a _ full set _  @xcite . interestingly , although the transformations based on the latter method are more succinct than the corresponding reductions of the first kind , they have often an inferior performance compared to the former transformations .    [",
    "[ disjunctive - logic - programming . ] ] disjunctive logic programming . + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a _ disjunctive logic program _ ,",
    "@xmath66 , is a set of rules @xmath67 where @xmath68 is a disjunction of variables , @xmath69 is a conjunction of variables , and @xmath70 is a conjunction of negated variables .",
    "a herbrand interpretation @xmath12 of @xmath18 is a _ stable model _ of @xmath66 @xcite , if it is a minimal model ( with respect to set - inclusion ) of the program @xmath71 resulting from @xmath66 as follows : remove each rule @xmath72 such that @xmath73 for some @xmath74 in @xmath70 , and remove @xmath70 from all remaining clauses .    similar to autoepistemic",
    "logic and default logic ,  handles the problem whether a given logic program has a stable model , as well as brave and skeptical reasoning .",
    "[ [ circumscription . ] ] circumscription .",
    "+ + + + + + + + + + + + + + + +    in contrast to the formalisms described above , propositional circumscription is already a quantified boolean formula , hence it does not require a separate reduction .",
    "so ,   can handle circumscription in a straightforward way .    in the propositional case , the parallel circumscription of a set of atoms @xmath75 in a theory @xmath26 , where the atoms @xmath76 are fixed and the remaining atoms @xmath77 may vary , is given by the following qbf @xmath78 , cf .",
    "@xcite : @xmath79   \\land ( p ' \\leq p ) ) { \\rightarrow}(p\\leq p')\\big).\\ ] ] here , @xmath80 and @xmath81 are sets of new propositional variables corresponding to @xmath82 and @xmath83 , respectively , and @xmath84 $ ] results from @xmath26 by substitution of the variables in @xmath85 for those in @xmath86 .",
    "implements circumscriptive inference of a formula @xmath42 from @xmath26 , which is expressed by the qbf @xmath87",
    "one of the basic motivations for the development of  was to make a rapid prototyping tool available , aimed for experimenting with different knowledge - representation formalisms . accordingly ,",
    "is designed in such a way that the important reasoning tasks corresponding to the different formalisms under consideration can be directly encoded as queries .",
    "so , the methodology of specifying queries suitable to be processed by  is the same as the methodology of formalizing a particular problem with one of the formalisms implemented in  ( subject to the restriction , of course , that  currently accepts only queries specified over a propositional language ; but in a future version it is planned to extend the language to allow function - free formulae with variables as well . )",
    "[ cols=\"<,>,>,>,>,>,>,>,>,>,>,>,>,>,>\",options=\"header \" , ]      let us illustrate how the queries of  are structured",
    ". generally ,  takes an input file as argument and writes the output to standard - out :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` quip  ` _ _ input_file _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the input file comprises nonmonotonic  theories and specifications of reasoning tasks .",
    "the format of the input uses two major concepts : _ definitions _ and _ commands_. in the definitions , one can specify abductive theories , autoepistemic theories , default theories , logic programs , and propositional theories in general .",
    "the commands specify which reasoning tasks ( with respect to the chosen formalism ) have to be executed .",
    "theories and formulas can be nested by using suitable names , so definitions can be edited rather conveniently .",
    "further , commands can refer to specified theories without the need to describe them more than once .",
    "an input file can contain several definitions and commands , even referring to different formalisms .    in the following",
    "we describe some of these features using a simple example from default logic .",
    "consider the following default theory @xmath57 , representing the well - known nixon - diamond : @xmath88 this default theory has two extensions :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath89 ;    @xmath90 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the extensions of this example can be computed by   using the following input file , named ` nixon ` :    ....     @set detail        t : =    republican & quaker     @d d : = { republican : ! pacifist | !",
    "pacifist ,                quaker : pacifist | pacifist              }        @dl ( t ; @d d ) ....    executing the command    _ _ _ _ _ _ _ _ _ _ _ _ ` quip  nixon ` _ _ _ _ _ _ _ _ _ _ _ _    results in the following output :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` th ( { ( republican)&(quaker ) } u { ( pacifist ) } ) ` + ` th ( { ( republican)&(quaker ) } u { ( ! pacifist ) } ) ` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the meaning of the different commands and definitions in the input file ` nixon ` can be explained as follows .",
    "first of all , the command ` @set detail ` invokes the detail mode , i.e. ,  all extensions will be displayed .",
    "( recall that   admits the processing of both _ decision problems _ and _ function problems_. ) choosing the command ` @unset detail ` would have resulted in a simple yes / no answer .",
    "the next tokens of the input file specify the constituents of the default theory  @xmath62 : ` t ` represents the background knowledge of @xmath62 , and ` d ` contains the defaults . to avoid ambiguities , references to defaults always have to start with a special string `` ` @d ` '' .",
    "the logical operators are represented in the obvious way ( `` ` & ` '' denotes conjunction , `` ` ! ` '' negation , and `` ` | ` '' separates a default s consequent from its justification ) .",
    "the command ` @dl ` tells  to compute the extensions of the specified default theory . to perform brave or skeptical reasoning , the input file ` nixon `",
    "would be changed as follows :    ....     @set detail        t : =    republican & quaker     @d d : = { republican : ! pacifist | !",
    "pacifist ,                quaker : pacifist | pacifist              }        @set brave     @dl ( w ; @d d ) |= pacifist       @set skeptical     @dl ( w ; @d d ) |= pacifist ....    the ` @set`-commands switches between the two reasoning modes ; `` ` |= ` '' is the symbol standing for the respective default consequence relations .",
    "the first command checks whether _ pacifist _ is a brave consequence of @xmath62 , the second commands checks skeptical consequence of _ pacifist _ from @xmath62 . observe that it is permitted that an input file contains a sequence of reasoning tasks .",
    "the output corresponding to the first command will be    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` th ( { ( republican)&(quaker ) } u { ( pacifist ) } ) ` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    while the second command displays the extensions from which _ pacifist _ does _ not _ follow :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` th ( { ( republican)&(quaker ) } u { ( ! pacifist ) } ) ` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      obviously , proper usage of  depends on a potential user s ability to express a given problem in terms of the implemented formalisms . however , a particular advantage of  is that it incorporates several different knowledge representation formalisms .",
    "hence , users have a _ choice _ selecting among different ( yet closely related ) approaches , singling out that particular formalism best suited for a specific purpose , or choosing a method based on a user s personal preference ( e.g. ,  because he / she understands that particular approach best ) .",
    "as well , the problem can be represented with different methods _ simultaneously _ , specifying the instances of the resultant formalizations in a single input file , which can then be processed by  requiring only one initial execution command .",
    "there are different approaches how systems handling knowledge representation formalisms can be evaluated .",
    "one is to perform comparisons taking into account the representational power of the implemented formalisms .",
    "that is to say , under such a comparison , one chooses some `` natural '' problems , encodes it with respect to the specific methodologies associated with the implemented formalisms , and uses the resultant instances as queries of the respective systems .",
    "so , basically , different systems are compared on the basis of ( possibly ) different representations _ of the same problem_. however , to achieve a fair comparison , it is necessary that the experimenter is able to encode the given problem `` in the best possible way '' with respect to the particular formalisms . also",
    ", incompatibilities of the underlying formalisms render comparisons between different systems often difficult .",
    "another possibility is to compare systems on problem classes _ common _ to each of the considered systems .",
    "such a comparison is appropriate if different implementations of _ the same formalism _ are evaluated .",
    "accepted benchmarks for nonmonotonic theorem provers have been realized by the well - known theorybase system  @xcite .",
    "this test - bed provides encodings of various graph problems in terms of default theories or equivalent logic programs .",
    "however , the generated problems are at most np - hard ( or -hard , depending on the reasoning task ) , and thus do not take full advantage of the expressibility supported by the nonmonotonic formalisms . the only practically applied benchmark test utilizing a @xmath0-hard problem is the strategic companies example carried out for testing the system ` dlv `  @xcite .    here",
    ", we propose a straightforward method how @xmath0-hard benchmark problems for propositional nonmonotonic reasoning formalisms can be generated .",
    "the idea is to use the class of problems establishing the @xmath0-hardness of a formalism .",
    "recall from our previous discussion that @xmath0-hardness of a nonmonotonic formalism is usually demonstrated by constructing a ( polynomial ) transformation @xmath11 mapping instances @xmath12 of @xmath2 ( the evaluation problem of qbfs having quantifier order @xmath91 ) into instances @xmath13 of the considered nonmonotonic reasoning task , , such that @xmath12 is a yes - instance of @xmath2 iff @xmath13 is a yes - instance of .",
    "thus , in some sense , the class of problems @xmath13 represents `` worst - case '' examples for the problem , and therefore is particularly useful estimating the performance of a theorem prover solving the task .",
    "moreover , these problems are easily scalable by parameterizing different instances of @xmath2 .",
    "an added feature of  is that these examples provide at the same time a simple method for _ testing _ whether the implementation works correct , because  turns instances @xmath13 of  back to instances @xmath92 of @xmath2 , satisfying the condition that @xmath12 is a yes - instance of @xmath2 iff @xmath92 is a yes - instance of @xmath2 .",
    "the next subsection describes comparisons between   and some state - of - the - art provers on the basis of these benchmark problems .",
    "we compare the default - logic module of  with deres  @xcite and the logic - programming module of  with ` dlv `  @xcite , using the class of examples discussed above .",
    "space limits preclude a discussion on the structure of these problems ; details can be found in the relevant literature ( e.g. ,  @xcite ) .",
    "we do not include a comparison with ` smodels `  @xcite here , because that system is currently not designed to handle @xmath0-problems ( a comparison between , deres , ` dlv ` , ` smodels ` , and theorist  @xcite , using examples from theorybase and some abduction problems , is given in @xcite ) .",
    "results of the comparison are given table  [ table : dl1 ] .",
    "all tests have been performed on a sun ultra 60 with 256 mb ram ; the run - time is measured in seconds with an upper limit of 90sec ( i.e. ,  instances requiring a longer period are not displayed ) .",
    "the first group of entries gives the results for the disjunctive logic programming test ; the second group gives the results for the default logic test ; and the final row contains some measurements using instances of the corresponding abductive problem class .",
    "the respective input - qbfs have been randomly generated and are parameterized by the number @xmath93 of existential quantifiers ( the number of variables was held fixed and was set to 20 ) . although the given results represent only a small sample , they do indicate that our _ ad hoc _ implementation performs sufficiently well .",
    "it is rather obvious that  can not compete with state - of - the - art implementations like ` dlv ` or ` smodels ` in terms of problem size .",
    "these tools are highly optimized systems developed with a particular semantics in mind , whereas the purpose of  is to provide a _ uniform _ method dealing with several knowledge representation tasks at the same time . under this perspective , and taking into account that   utilizes at present no optimizations whatsoever , our results demonstrate that implementing nonmonotonic reasoning formalisms using reductions to quantified boolean formulae is a feasible approach",
    ". moreover , the modular architecture of  allows an easy scalability and parallelization , by using , e.g. ,  several qbf - provers simultaneously , each of which with its own optimization method .",
    "egly , u. ; eiter , t. ; tompits , h. ; and woltran , s. 2000a . implementing default reasoning using",
    "quantified boolean formulae . in _",
    "proceedings 14 .",
    "workshop logische programmierung , wrzburg , germany _ , 223225 .",
    "gmd report 90 .",
    "niemel , i. , and simons , p. 1996 .",
    "efficient implementation of the well - founded and stable model semantics . in _ proceedings of the 1996 joint international conference and symposium on logic programming _ , 289303 .",
    "cambridge : mit press ."
  ],
  "abstract_text": [
    "<S> in this paper , we outline the prototype of an automated inference tool , called , which provides a uniform implementation for several nonmonotonic reasoning formalisms . </S>",
    "<S> the theoretical basis of  is derived from well - known results about the computational complexity of nonmonotonic logics and exploits a representation of the different reasoning tasks in terms of _ quantified boolean formulae _ ( qbfs ) . </S>"
  ]
}