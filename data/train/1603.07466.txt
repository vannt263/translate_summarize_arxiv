{
  "article_text": [
    "business process models often encode decision logic of varying complexity , typically via conditional expressions attached either to outgoing flows of decision gateways or to conditional events . the need to separate this decision logic from the control - flow logic  @xcite and to capture it at a higher level of abstraction",
    "has motivated the emergence of the decision model and notation ( dmn )  @xcite .",
    "a central construct of dmn is that of a decision table , which stems from the notion of decision table proposed in the context of program decision logic specification in the 1960s  @xcite .",
    "a dmn decision table consists of columns representing the inputs and outputs of a decision , and rows denoting rules .",
    "columns may be typed , meaning that they have an associated domain ( or facet ) .",
    "each rule is a conjunction of basic expressions captured in an expression language known as s - feel ( simplified friendly enough expression language ) .",
    "the use of dmn decision tables as a specification vehicle for critical business decisions raises the question of ensuring the correctness of these tables , in particular the detection of inconsistent or incomplete dmn decision tables .",
    "indeed , detecting errors in dmn tables at specification time may prevent costly defects down the road during business process implementation and execution .",
    "this paper provides a foundation for analyzing the correctness of dmn tables .",
    "the contributions of the paper are : ( i ) a formal semantics of dmn tables ; ( ii ) a formalization of correctness criteria for dmn tables ; and ( iii ) scalable algorithms for two basic correctness checking tasks over dmn tables , i.e. , detection of overlapping rules and detection of missing rules ( i.e. , incompleteness ) . the latter algorithms are based on a novel geometric interpretation of dmn tables , wherein each rule in a table is mapped to an iso - oriented hyper - rectangle in an n - dimensional space ( where n is the number of columns ) .",
    "accordingly , the problem of detecting overlapping rules is mapped to that of detecting overlapping hyper - rectangles . meanwhile ,",
    "the problem of detecting missing rules is mapped to that of differencing the n - dimensional universe defined by the n columns of a dmn table , and the set of hyper - rectangles induced by its rules .",
    "based on this geometric interpretation and inspired by sweep - based spatial join algorithms  @xcite , the paper presents scalable algorithms for these two analysis tasks .",
    "the algorithms have been implemented atop the dmn editor and evaluated over decision tables of varying sizes derived from a credit lending dataset .",
    "the rest of the paper is structured as follows .",
    "section  [ sec : back ] introduces dmn and discusses related work .",
    "section  [ sec : formal ] presents the formalization of dmn tables and their associated correctness criteria .",
    "section  [ sec : algo ] presents the algorithms for correctness analysis while section  [ sec : exper ] discusses their empirical evaluation .",
    "finally , section  [ sec : conclusion ] summarizes the contributions and outlines future work directions .",
    "a dmn table consists of columns corresponding to input or output attributes , and rows corresponding to rules .",
    "each column is associated to a type ( e.g. , a string , a number , or a date ) , and optionally to a more specific domain of possible values , which we hereby call a _ facet_. each row has an identifier , one expression for each input column ( a.k.a .  the _ input entries _ ) , and one specific value for each output column ( the _ output entries _ ) . for example , table 1 shows a dmn table with two input columns , one output column and four rules .",
    "+ = [ remember picture , baseline ] + = [ inner sep=0pt , anchor = base , minimum width=.3 cm , minimum height=.3cm , align = center , text depth=0ex , outer sep=0pt ] = [ rectangle , thin , draw = black!75,fill = orange!20,minimum height=5mm , minimum width=2.1cm , inner sep=2pt ]    .5|c|c|c||c| +    ( ) * u * ;    ( ) * c * ;     &    ( ) * annual * ;    &    ( ) * loan * ;    &    ( ) * grade * ;     + & * income * & * size * & + & @xmath0 & @xmath0 &    ( ) ` vg`,`g`,`f`,`p ` ;     + a & @xmath1 $ ] & @xmath1 $ ] & ` vg ` + b & @xmath2 $ ] & @xmath3 $ ] & ` g ` + c & @xmath4 $ ] & @xmath5 $ ] & ` f ` +    ( ) d ;     &    ( ) @xmath6 $ ] ;    &    ( ) @xmath7 $ ] ;    &    ( ) ` p ` ;     +   +    ( name ) table name ; ( hi ) hit indicator ; ( ci ) completeness + indicator ; ( in ) input attrs ; ( fac ) facet ; ( out ) output attr ; ( rule ) rule ;    ( pi ) priority + indicator ; ( ie ) input entries ; ( oe ) output entry ;    ( name ) edge ( 1 ) ; ( hi ) edge ( 2 ) ; ( ci ) edge ( 3 ) ; ( in ) edge ( 4 ) ; ( in ) edge ( 5 ) ; ( out ) edge ( 6 ) ; ( fac ) edge ( 7 ) ; ( rule ) edge ( -0.11,-0.29 ) ; ( pi ) edge ( 8) ; ( ie ) edge ( 9 ) ; ( ie ) edge ( 10 ) ; ( oe ) edge ( 11 ) ;    [ fig : decision - tab ]    given an input configuration consisting of a vector of values ( one entry per column ) , if every input entry of a row holds true for this input vector , then the vector _ matches _ the row and the output entries of the row are evaluated .",
    "for example , vector @xmath8 matches rule @xmath9 in table 1 , thus yielding @xmath10 in the output configuration . to specify how output configurations are computed from input ones , a dmn table may have a _ hit indicator _ and a _",
    "completeness indicator_. the hit indicator specifies whether only one or multiple rows of the table may match a given input , and if multiple rules match an input , how should the output configuration be computed .",
    "the completeness indicator specifies whether every input configuration must match at least one rule or potentially none .",
    "if an input configuration matches two or more rules , this may contradict the hit policy .",
    "similarly , if no rule matches an input configuration , this may contradict the completeness indicator .",
    "the former type of contradiction is called _ overlapping rules _ while the latter is called _ missing rule_.      the need to analyze decision tables from the perspective of completeness ( i.e. , detecting missing rules ) as well as consistency and non - redundancy ( i.e. , detecting overlapping rules ) is widely recognized  @xcite .",
    "these two analysis tasks have been tackled using rough sets  @xcite . however",
    ", this approach requires that the domains of the input attributes are boolean or categorical .",
    "numerical attributes need to be previously discretized into intervals . in this paper",
    ", we study the problem of analyzing decision tables with arbitrary s - feel expressions , meaning that no prior discretization of numerical domains is required .",
    "prologa  @xcite is a tool for modeling and executing classical decision tables .",
    "it supports the construction of decision tables in a way that prevents overlapping or missing rules .",
    "it also supports the optimization of a decision table via rule merging : two rules are merged when all but one of their input entries are identical , and their output entries are also identical .",
    "however , prologa presents the same intrinsic limitation of the rough set approach : it requires columns to have boolean or categorical domains .",
    "hence , numerical domains need again to be discretized into intervals when constructing a decision table .",
    "signavio s dmn editor detects overlapping and missing rules .",
    "however , the employed analysis techniques are undisclosed and no empirical evaluation thereof has been reported .",
    "also , the diagnosis of overlapping and missing rules produced by signavio is unnecessarily large : it often reports the same rule overlap multiple times .",
    "this behavior will be further explained in section  [ sec : exper ] .",
    "openrules uses constraint satisfaction techniques to analyze business rules , in particular rules encoded in decision tables . while using a general solver to analyze decision tables",
    "is an option ( e.g. , an smt solver such as z3  @xcite ) , this approach leads to a boolean output ( is the set of rules satisfiable ? ) , and can not natively highlight specific sets of rules that need to be added to a table ( missing rules ) , nor specific overlaps between pairs of rules that need to be resolved .",
    "in this section , we provide a logic - based formalization of dmn decision tables , unanmbiguously defining their input / output semantics , and at the same time introducing several analysis tasks focused on correctness checking . as a concrete specification language for input entries in dmn",
    ", we consider the s - feel language , introduced in the dmn standard itself .",
    "our formalization is based on classical predicate logic extended with data types , which are needed to capture conditions that employ domain - specific predicates such as comparisons interpreted over the total order of natural numbers .",
    "such formalization is important per s , as it defines a clear , unambiguous semantics of decision tables , and also as an interlingua supporting the comparison of different analysis techniques .",
    "we first introduce the building blocks of decision tables , i.e. , the types of the modeled attributes , and conditions over such types expressed using the s - feel language .",
    "a data type @xmath11 is a tuple @xmath12 , where @xmath13 is an _ object domain _ , and @xmath14 is a _ signature _ , constituted by a set @xmath15 of _ predicate symbols _ , and a set @xmath16 of _ function symbols _ ( disjoint from @xmath15 ) .",
    "each predicate symbol @xmath17 comes with its own arity @xmath18 , and with an @xmath18-ary predicate @xmath19 that rigidly defines its semantics .",
    "each function symbol @xmath20 comes with its own arity @xmath21 , and with a function @xmath22 that defines its semantics . to make the arity explicit in predicate and function symbols , we use the standard notation @xmath23 and @xmath24 . as usual",
    ", we assume that every data type is equipped _ equality _ as a predefined , binary predicate interpreted as the identity on the underlying domain .",
    "hence , we will not explicitly mention equality in the signatures of data types . in the following ,",
    "we show some of the s - feel data types :    @xmath25  strings .",
    "@xmath26  boolean attributes .",
    "@xmath27  integer numbers equipped with the usual comparison predicates and binary operations ;    @xmath28 ( defined as @xmath29 by replacing the domain @xmath30 with @xmath31 , and by reinterpreting all predicates and functions accordingly )  real numbers equipped with the usual comparison predicates and binary operations .",
    "the set of all such types is denoted by @xmath32 .",
    "since decision tables do not support conditions that combine multiple data types , we can safely assume that the _ object domains of all types in @xmath32 are pairwise disjoint_.    s - feel allows one to formulate conditions over types .",
    "such conditions constitute the basic building blocks for facets and rules , which in turn are the core of decision tables .",
    "the syntax of an _",
    "( s - feel ) condition _ @xmath33 over type is : + @xmath34 \" ) \\\\",
    "\\mathit{term } & : : = & v \\mid f(\\mathit{term}_1,\\ldots,\\mathit{term}_m ) \\end{array } $ ] where @xmath35 is an object and @xmath36 is an @xmath21-ary function .",
    "intuitively , s - feel supports the following conditions on a given data type @xmath37 :    `` @xmath38 '' indicates _ any value _ , i.e. , it holds for every object in @xmath13 .",
    "@xmath39 is a shortcut for `` @xmath40 '' , and indicates a _ matching expression _ , which holds for the object in @xmath13 that corresponds to the result denoted by term @xmath39 . a term , in turn",
    ", corresponds either to a specific object in @xmath13 , or to the recursive application of an @xmath21-ary function in @xmath41 to @xmath21 terms .",
    "@xmath42 is only applicable when @xmath11 is a numeric data type , and indicates a _ comparison condition _ , which holds for all objects that are related via the employed comparison predicate to the object resulting from expression @xmath39 .",
    "@xmath43 is only applicable when @xmath11 is numeric , and allows the modeler to capture membership conditions that tests whether an input object belongs to the modeled interval .",
    "`` @xmath44 '' indicates an _ alternative condition _ , which holds whenever one of the two conditions @xmath45 and @xmath46 holds .",
    "[ ex : facets ] the fact that a risk category is either high , medium or low can be expressed by the following condition over @xmath47 : `` @xmath48 '' . by using @xmath29 to denote the age of persons ( in years ) , the group of people that are underage or old ( i.e. , having at least @xmath49 years ) is captured by condition `` @xmath50{\\mathtt{,}}\\geq 70 $ ] '' .",
    "we are now in the position of defining dmn decision tables .",
    "see table 1 for a reference example . a _ decision table _",
    "@xmath51 is a tuple @xmath52 , where :    @xmath53 is the _ table name_.    @xmath54 and @xmath55 are disjoint , finite sets of _ input _ and _ output attributes _",
    "( represented as strings ) .",
    "@xmath56 is a _ typing function _ that associates each input / output attribute to its corresponding data type .",
    "@xmath57 is a _",
    "facet function _ that associates each input / output attribute @xmath58 to a condition over @xmath59 , defining the _",
    "acceptable objects _ for that attribute .",
    "facet functions are depicted as `` optional lists of values '' in table 1 .",
    "@xmath60 is a finite set of _ rules _ @xmath61 .",
    "each rule @xmath62 is a pair @xmath63 , where @xmath64 is an _ input entry function _ that associates each input attribute @xmath65 to a condition over @xmath66 , and @xmath67 is an _ output entry function _ that associates each output attribute @xmath68 an object in @xmath69 .",
    "@xmath70 is a _ priority function _",
    "injectively mapping rules in @xmath71 to a corresponding rule number defining its priority . if no priority is explicitly given , in accordance with the standard we assume that the priority is implicitly defined by the graphical ordering in which rule entries appear inside the decision table .",
    "@xmath72 is the _ completeness indicator _ , where @xmath73 is the default value and stands for _ complete _ table , while @xmath74 stands for _ incomplete _ table .",
    "@xmath75 is the _ (",
    "single ) hit indicator _ defining the policy for the rule application , where :    @xmath76 is the default value and stands for _ unique hit policy _",
    ",    @xmath77 stands for _ any hit policy _ ,    @xmath78 stands for _ priority hit policy _ , and    @xmath79 stands for _ first hit policy_.    we now informally review the intuitive semantics of rules and of completeness / hit indicators in dmn , moving to the formalization in section  [ sec : reasoning ] .",
    "* rule semantics . * intuitively ,",
    "rules follow the standard `` if - then '' interpretation .",
    "rules are matched against _ input configurations _",
    ", which map the input attributes to objects in such a way that each object    belongs to the type of the corresponding input attribute , and    satisfies the corresponding facet .",
    "if , for every input attribute , the assigned object satisfies the condition imposed by the rule on that type , then the rule _ triggers _ , and bounds the output attributes to the actual objects mentioned by the rule .",
    "consider the decision table in table 1 .",
    "the input configuration where @xmath80 is @xmath81 and @xmath82 is @xmath83 , triggers rule @xmath9 .    * completeness indicator .",
    "* when the table is declared to be complete , the intention is that every possible input configuration must trigger at least one rule .",
    "incomplete tables , instead , have input configurations with no matching rule .",
    "* hit policies .",
    "* hit policies specify how to handle the case where multiple rules are triggered by an input configuration .",
    "in particular :    `` unique hit '' indicates that at most one rule can be triggered by a given input configuration , thus avoiding the need of handling how to compute the output objects in the case of multiple triggered rules .",
    "`` any hit '' indicates that when multiple rules are triggered , they must agree on the output objects , thus guaranteeing that the output is unbambiguous .",
    "`` priority hit '' indicates that whenever multiple rules trigger , then the output is unambiguously computed by only considering the contribution of the triggered rule that has highest priority .",
    "`` first hit '' can be understood as a variant of the priority hit , in which priority is implicitly obtained from the ordering in which rules appear in the decision table . hence , this case is subsumed by that of priority hit .",
    "`` collect '' implies that multiple rules can match an input configuration and when this is the case , all matching rules are fired the the resulting output configurations are aggregated .",
    "aggregation is orthogonal to correctness checking , and thus we leave the `` collect '' policy outside the scope of the formalization below .",
    "we first define how conditions map to corresponding formulae .",
    "since each condition is applied to a single input attribute , the corresponding formula has a single free variable corresponding to that attribute .",
    "given a condition @xmath33 over type @xmath37 , the _ condition formula for @xmath33 _ , written @xmath84 , is a formula using predicates / functions in @xmath41 and objects from @xmath13 , and possibly mentioning a single free variable , constructed as follows : + @xmath85 \" \\\\ x \\geq \\phi_{\\mathit{term_1 } } \\land x <",
    "\\phi_{\\mathit{term_2 } } & \\text{if } { \\mathcal{q}}= `` [ term_1 .. term_2 ) \" \\\\ x \\geq \\phi_{\\mathit{term_1 } } \\land x \\leq \\phi_{\\mathit{term_2 } } & \\text{if } { \\mathcal{q}}= `` [ term_1 .. term_2 ] \" \\\\ { \\phi_{{\\mathcal{q}}_1}}{x } \\lor { \\phi_{{\\mathcal{q}}_2}}{x } & \\text{if } { \\mathcal{q}}= `` { \\mathcal{q}}_1 { \\mathtt{,}}{\\mathcal{q}}_2\"\\\\ \\end{cases } $ ] as usual , we also use notation @xmath86 to explicitly mention the free variable of the condition formula .    consider the s - feel conditions in example  [ ex : facets ] .",
    "the condition over the risk category is @xmath87 .",
    "the condition formula person ages is instead : @xmath88 .    with this notion at hand ,",
    "we now formalize the notions of correctness of rule specifications , semantics of rules , and semantics of completeness and hit indicators .",
    "these notions are building blocks for an overall notion of _ table correctness_.    let @xmath89 be a decision table with @xmath21 input attributes @xmath90 , @xmath18 output attributes @xmath91 , and @xmath92 rules @xmath93 .",
    "we use variables @xmath94 for objects matching the input attributes , and variables @xmath95 for those matching the output attributes .",
    "* facet correctness .",
    "* we first consider the _ facet correctness _ of @xmath51 , which intuitively amounts to check whether all the mentioned input conditions and output objects are compatible with their corresponding attribute facets .",
    "given an attribute @xmath96 and a corresponding input variable @xmath97 , the fact that _ @xmath97 is legal for @xmath98 _ is defined as : @xmath99 we use this notion in combination with a condition @xmath33 over @xmath98 , so as to check whether an input variable _ @xmath97 matches with @xmath33 _ : @xmath100 note that for output objects , @xmath86 above is a test where @xmath97 is equated to the output object .",
    "this derived predicate , in turn , can be used to identify whether _",
    "@xmath33 is compatible with @xmath98 _ ,",
    "i.e. , whether the condition is specified in such a way that can potentially trigger , or is instead contradictory with the facet attached to @xmath98 : @xmath101    * rule semantics .",
    "* a rule @xmath102 is _ triggered by _ a configuration @xmath94 of input objects whenever each such object matches with the corresponding input condition : @xmath103 two configurations @xmath104 and @xmath95 of input and output objects are _ input - output related _ by a rule @xmath105 if the rule is triggered by the input configuration , and binds the output as specified by the output configuration : @xmath106    * completeness . *",
    "when declaring that a table is ( in)complete , there is no guarantee that the specified rules guarantee this property . to check whether this is indeed the case , we introduce a formula that holds whenever each possible input configuration triggers at least one rule : @xmath107    * hit policies .",
    "* we start with the unique hit policy , which requires that each input configuration triggers at most one rule .",
    "this can be formalized as follows : @xmath108    we then continue with the any hit policy . here",
    "multiple rules may be triggered by the same input configuration , but if so , then they must agree on the output .",
    "this can be formalized as follows : @xmath109{l } { { \\mathit{triggeredby}}_{r_i}(\\vec{x } ) } \\\\ { } \\land { { \\mathit{triggeredby}}_{r_j}(\\vec{x } ) } \\rightarrow \\begin{array}[t]{l } { { \\mathit{iorel}}_{r_i}(\\vec{x},\\vec{y})}\\\\ { } \\land { { \\mathit{iorel}}_{r_j}(\\vec{x},\\vec{y } ) } \\end{array } \\end{array}\\ ] ]    we now consider the case of priority hit policy .",
    "this requires to reformulate the rule semantics , so as to consider the whole decision table and the priority of the rules .",
    "in particular , with this hit policy a rule @xmath110 is _ triggered with priority _ by an input configuration @xmath104 if it is triggered by @xmath104 in the sense specified above , and no rule of higher priority is triggered by the same input @xmath104 : @xmath111 with this policy , the relationship between input and output configurations can be lifted from the single - rule case discussed above to the whole decision table by isolating the highest - priority rule that matches with the input configuration , and by considering its output : @xmath112 finally , we observe that the priority hit policy may create a situation in which some rules are never triggered .",
    "this happens when other rules of higher priority have more general input conditions .",
    "we formalize this notion by introducing a formula dedicated to check when a rule @xmath113 _ is masked _ by another rule @xmath114 : @xmath115    * correctness formula . *",
    "we now combine the previously defined formulae into a single formula that captures the overall correctness of a decision table .",
    "we say that @xmath51 is _ correct _ if the following conditions hold :    every table cell , i.e. , every input condition or output object , is legal for the corresponding attribute ( considering the attribute type and facet ) .",
    "the completeness indicator corresponds to @xmath73 iff the table is indeed complete .",
    "the rules are compatible with the hit policy indicator :    if the hit policy is @xmath76 , each input configuration triggers at most one rule ;    if the hit policy is @xmath116 , all overlapping rules ( i.e. , rules that could simultaneously trigger ) have the same output ;    if the hit policy is @xmath117 , all rules are `` useful '' , i.e. , no rule is masked by a rule with higher priority .    based on the previously introduced formulae , we formalize correctness as : @xmath118    * global input - output formula . * we combine the previously defined formulae into a single formula that captures the overall input - output relation induced by @xmath51 .",
    "this is done by exploiting the notion of input - output related configurations by a rule , so as to cover the entire table .",
    "specifically we say that an input configuration @xmath104 and an output configuration @xmath119 are _ input - output related _ by @xmath51 if :    the hit policy is either @xmath76 or @xmath116 , and there exists a rule that relates @xmath104 to @xmath119 ( in the case of any hit policy , there could be many , but they establish the same input - output relation , so it is sufficient to pick one of them ) ;    the hit policy is @xmath117 , and there exists a rule relating @xmath104 to @xmath119 without any other rule of higher priority that is triggered by @xmath104 ( is such a rule exists , then it is such rule that has to be selected to relate input - output ) .",
    "this is formalized as follows : @xmath120{@{}l@{}l@ { } } ( { h}= { { \\mathtt{p } } } ) \\rightarrow \\bigvee_{r={\\langle { { \\mathsf{if}}},{{\\mathsf{then}}}\\rangle } \\in { { r } } } & { { \\mathit{triggeredwithpriorityby}}_{r}(\\vec{x } ) } \\\\ & \\land \\bigwedge_{j \\in { \\{1,\\ldots , n\\ } } } { { \\mathit{matches}}_{{\\mathbf{b_j}}}^{{{\\mathsf{then}}}({\\mathbf{b_j}})}(y_j ) } \\end{array } \\right )    \\tag{2}\\end{aligned}\\ ] ]",
    "we now introduce algorithms to handle the two main analysis tasks introduced in the previous section : detecting overlapping rules and ( in)completeness .",
    "the proposed algorithms rely on a geometric interpretation of a dmn table .",
    "every rule in a table is seen as an iso - oriented hyper - rectangle in an n - dimensional space ( where n is a number of columns ) .",
    "indeed , an input entry in a rule can be seen a constraint over one of the columns ( i.e.  dimensions ) . in the case of a numerical column ,",
    "an input entry is an interval ( potentially with an infinite upper or lower bound ) and thus it defines a segment or line over the dimension corresponding to that column . in the case of a categorical column",
    ", we can map each value of the column s domain to a disjoint interval ",
    "e.g. `` refinancing '' to [ 0 .. 1 ) , `` card payoff '' to [ 1 .. 2 ) , `` car leasing '' to [ 2 .. 3 ) , etc .  and we can see an input entry under this column as defining a segment ( or set of segments ) over the dimension corresponding to the column in question .",
    "the conjunction of the entries of a row hence defines a hyper - rectangle , or potentially multiple hyper - rectangles in the case of a multi - valued categorical input entry ( e.g. \\{``refinancing '' , `` car leasing '' } ) .",
    "the hyper - rectangles are iso - oriented because only constraints of the form `` attribute operator literal '' are allowed in s - feel and such constraints define iso - oriented lines or segments .    for example",
    ", the geometric interpretation of table 1 is shown in  [ fig:2d_example ] .",
    "the two dimensions , @xmath97 and @xmath121 , represent the two input columns ( _ annual income _ and _ loan size _ ) respectively .",
    "the table contains 4 rules : @xmath122 , @xmath9 , @xmath123 , and @xmath124 .",
    "some of them are overlapping .",
    "for example , rule @xmath122 overlaps with rule @xmath123 .",
    "their intersection is the rectangle @xmath125\\times[500,1000]$ ] .",
    "the table also contains missing values .",
    "for example , vector @xmath126 does not match any rule in table 1 .",
    "the algorithms are presented for numeric columns .",
    "minor adaptations ( not discussed here ) allow these algorithms to handle categorical columns as well .",
    "= [ circle , ultra thick , draw = black!75,text width=1mm , inner sep=0pt ] = [ leftnode , fill = black!75 ]      algorithm [ alg : overlap ] finds overlapping rules in a dmn table .",
    "this algorithm is an extension of line - sweep algorithm for two - dimensional spatial joins proposed in  @xcite .",
    "the idea of this latter algorithm is to pick one dimension ( e.g. x - axis ) , project all objects into this dimension , and then sweep an imaginary line orthogonal to this axis ( i.e. parallel to the y - axis ) .",
    "the line stops at every point in the x - axis where either an object starts or ends .",
    "when the line makes a `` stop '' , we gather all objects that intersect the line ( the _ active list _ ) .",
    "these objects overlap along their x - axis projection . in  @xcite",
    ", it is then checked if the objects also overlap in the y - axis , and if so they are added to the result set ( i.e.  the objects overlap ) . algorithm [ alg : overlap ] extends this idea to n dimensions .",
    "the algorithm takes as input :    rulelist , containing all rules of the input dmn table ;    i , containing the index of the column under scrutiny ;    n , representing the total number of columns ;    overlappingrulelist , storing the rules that overlap .",
    "the algorithm starts analyzing the first column of the table ( axis @xmath97 ) .",
    "all rules are projected over this column .",
    "note that the projection of a rule on a column is an interval .",
    "we indicate the projection of rule @xmath127 over axes @xmath97 and @xmath121 with @xmath128 and @xmath129 respectively .",
    "all the intervals are represented in terms of upper and lower bounds .",
    "the bounds are sorted in ascending order ( line 7 ) .",
    "the algorithm iterates over the list of sorted bounds ( line 8) . in the case of  [ fig:2d_example ] , the rules projected over the @xmath97 axis correspond are :    considering the rules above , the algorithm first analyzes the lower bound of @xmath130 .",
    "therefore , @xmath130 is added to an active list of intervals for the first column @xmath97 , @xmath131 , since the bound processed is a lower bound ( line 13 ) .",
    "next , the algorithm processes the lower bound of @xmath132 and @xmath132 is added to @xmath131 .",
    "then , the lower bound of @xmath133 is processed and @xmath133 is added to @xmath131 . finally , the algorithm processes the upper bound of @xmath132 .",
    "every time an upper bound of an interval is processed ( line 9 ) , the following column of the table is analyzed ( in this case @xmath121 ) by invoking _",
    "findoverlappingrules _ recursively ( line 10 ) .",
    "all the intervals projections on @xmath121 of the rules corresponding to intervals contained in @xmath131 ( in our example @xmath122 , @xmath9 , and @xmath123 ) are represented in terms of upper bounds and lower bounds :    the bounds are sorted in ascending order . the algorithm iterates over the list of sorted bounds .",
    "considering the intervals above , the algorithm first encounters the lower bound of @xmath134 .",
    "therefore , @xmath134 is added to the active list of intervals for the second column @xmath121 , @xmath135 .",
    "next , the algorithm processes the lower bound of @xmath136 and adds @xmath136 to @xmath135 .",
    "then , the upper bound of @xmath136 is processed .",
    "since there is no other column in the table , this means that all the rules corresponding to the intervals in @xmath135 overlap . at the end of each recursion",
    ", the interval corresponding to the current bound is removed from the current active list ( line 11 ) .",
    "in addition , when the last column of the table is processed ( line 1 ) , the algorithm checks whether the identified set of overlapping rules is contained in one of the other sets produced in a previous recursion ( lines 3 ) .",
    "if this is not the case , the new set of overlapping rules is added to the output list overlappingrulelist ( line 4 ) . in this way , the procedure outputs maximal sets of overlapping rules having a non - empty intersection stored in overlappingrulelist ( line 16 ) .    ;",
    "algorithm [ alg : missing ] describes the procedure for finding missing rules , which is also based on the line - sweep principle .",
    "the algorithm takes as inputs 5 parameters :    rulelist , containing all rules of the input dmn table ;    missingintervals , storing the current missing intervals ;    i , containing the index of the column under scrutiny ;    n , representing the total number of columns ;    missingrulelist , storing the missing rules .",
    "the algorithm starts analyzing the first column of the table ( axis @xmath97 ) .",
    "consider again the projection of the table in  [ fig:2d_example ] on @xmath97 :    upper and lower bounds of each interval are sorted in ascending order ( line 3 ) .",
    "the algorithm iterates over the list of sorted bounds ( line 4 ) .    considering the rules above",
    ", the algorithm first analyzes the lower bound of @xmath130 .",
    "therefore , @xmath130 is added to an active list of intervals for the first column @xmath97 , @xmath131 .",
    "an interval is added to the active list only if its lower bound is processed ( line 15 ) .",
    "if the upper bound of an interval is processed , the interval is removed from the list ( line 17 ) .",
    "next , the algorithm processes the lower bound of @xmath132 . since @xmath131 is not empty , @xmath132",
    "is not added to @xmath131 yet ( line 11 ) .",
    "starting from the interval @xmath137 ( line 12 ) having the lower bound of @xmath130 as lower bound and the lower bound of @xmath132 as upper bound , the following column of the table is analyzed ( in this case @xmath121 ) by invoking _",
    "findmissingrules _ recursively ( line 13 ) .",
    "all the interval projections on @xmath121 of the rules corresponding to intervals contained in @xmath131 ( in our example only @xmath122 ) are represented in terms of upper and lower bounds , obtaining in this case the following simple situation :    the bounds are sorted in ascending order .",
    "the algorithm iterates over the list of sorted bounds .",
    "the first bound taken into consideration is the lower bound of @xmath134 so that @xmath134 is added to @xmath135 ( since @xmath135 is empty ) .",
    "since this bound corresponds to the minimum possible value for @xmath121 , there are no missing values between the minimum possible value for @xmath121 and the lower bound of @xmath134 ( line 5 ) .",
    "next , the algorithm processes the second bound in @xmath135 that is the upper bound of @xmath134 . considering that the upper bound of @xmath134 is the last one in @xmath135 , the algorithm checks if this value corresponds to the maximum possible value for @xmath121 ( line 5 ) .",
    "since this is not the case , this means that there are missing values in the area between the upper bound of @xmath134 and the next bound over the same column ( in this case area 1 ) .",
    "the algorithm checks if the identified area is contiguous to an area of missing values previously found ( line 7 ) . if this is the case the two areas are merged ( line 8) . if this is not the case , the area is added to a list of missing value areas ( line 10 ) . in our case ,",
    "area 1 is added to a list of missing value areas .",
    "note that the algorithm merges two areas of missing values only when the intervals corresponding to one column are contiguous and the ones corresponding to all the other columns are exactly the same . in the example in  [ fig:2d_example ]",
    ", areas 4 and 6 are merged .    at this point",
    ", the recursion ends and the algorithm proceeds analyzing the intervals in the projection along the @xmath97 axis .",
    "the last bound processed was the lower bound of @xmath132 , so that @xmath132 is added to @xmath131 .",
    "next , the algorithm processes the lower bound of @xmath133 ( since @xmath131 is not empty , @xmath133 is not added to @xmath131 yet ) . starting from the interval @xmath138 having the lower bound of @xmath132 as lower bound and the lower bound of @xmath133 as upper bound , the following column of the table is analyzed ( in this case @xmath121 ) again through recursion .",
    "all intervals projections on @xmath121 of the rules corresponding to intervals contained in @xmath131 ( in this case @xmath122 and @xmath9 ) are represented in terms of upper and lower bounds :    the bounds are sorted in ascending order .",
    "the algorithm iterates over the list of sorted bounds . considering the rules above",
    ", the algorithm first processes the lower bound of @xmath134 so that @xmath134 is added to @xmath135 ( @xmath135 is empty ) .",
    "then , the upper bound of @xmath134 is processed .",
    "when the algorithm reaches the upper bound of an interval in a certain column the interval is removed from the corresponding active list .",
    "therefore , @xmath134 is removed from @xmath135 .",
    "next , the lower bound of @xmath139 is processed . since @xmath135 is empty , the algorithm checks if the previous processed bound is contiguous with the current one ( line 5 ) .",
    "since this is not the case , this means that there are missing values in the area between the upper bound of @xmath134 and the next bound over the same column ( in this case area 2 ) .",
    "the algorithm checks if the identified area is contiguous to an area of missing values previously found . if this is the case , the two areas are merged .",
    "if this is not the case , the area is added to a list of missing value areas ( in our case area 2 is added to a list of missing value areas ) .",
    "the list of missing areas stored in missingrulelist is returned by the algorithm ( line 19 ) .    ;",
    "we implemented the algorithms on top of : the open - source rendering and editing toolkit of camunda dmn . in it current version , does not support correctness verification .",
    "our extension with verification features can be found at https://github.com/ulaurson/dmn-js and a deployed version is available for testing at http://kodu.ut.ee/~ulaurson / dmn/.    for the evaluation , we created decision tables from a loan dataset of lendingclub  a peer - to - peer lending marketplace .",
    "the employed dataset contains data about all loans issued in 2013 - 2014 ( 23  5629 loans ) . for each loan",
    ", there are attributes of the loan itself ( e.g. , amount , purpose ) , of the lender ( e.g. , income , family status , property ownership ) , and a credit grade ( a , b , c , d , e , f , g ) .    using weka  @xcite",
    ", we trained decision trees to classify the grade of each loan from a subset of the loan attributes .",
    "we then translated each trained decision tree into a dmn table by mapping each path from the root to a leaf of the tree into a rule . using different attributes and pruning parameters in the decision tree discovery",
    ", we generated dmn tables containing approx .",
    "500 , 1000 and 1500 rules and 3 , 5 and 7 columns ( nine tables in total ) .",
    "the 3-dimensional ( i.e. 3-column ) tables have one categorical and two numerical input columns ; the 5-dimensional tables have two categorical and three numerical input columns , and the 7-dimensional tables has two categorical and five numerical input columns .    by construction",
    ", the generated tables do not contain overlapping or missing rules . to introduce",
    "missing rules in a table , we selected @xmath140 of the rules .",
    "for each of them , we then randomly selected one column , and we injected noise into the input entry in the cell in the selected column by decreasing its lower bound and increasing its upper bound in the case of a numerical domain ( e.g.  interval [ 3 .. 6 ] becomes [ 2 .. 7 ] ) and by adding one value in the case of a categorical domain ( e.g. \\ { refinancing , creditcardpayoff } becomes \\ { refinancing , creditcardpayoff , leasing } ) .",
    "these modifications make it that the rule will overlap others .",
    "conversely , to introduce missing rule errors , we selected @xmath140 of the rules , picked a random column for each row and `` shrank '' the corresponding input entry .",
    "we checked each generated table both for missing and incomplete rules and measured execution times averaged over 5 runs on a single core of a 64-bit 2.2 ghz intel core i5 - 5200u processor with 16 gb of ram .",
    "the results are shown in  [ tab : exp - time ] .",
    "execution times for missing rules detection are under 2 seconds , except for the 7-columns tables with 1000 - 1500 rules .",
    "the detection of overlapping rules leads to higher execution times , due to the need to detect sets of overlapping rules and ensure maximality .",
    "the execution times for overlapping rules detection on the 3-columns tables is higher than on the 5-columns tables because the 5-columns tables have less rule overlaps .",
    "this is because there are proportionally less categorical columns in the 5-columns tables than in the 3-columns ones , and the modifications made to categorical columns create more overlaps .",
    "in addition to implementing our algorithms , we implemented algorithms designed to produce the same output as signavio . in signavio , if multiple rules have a joint intersection ( e.g. rules \\{r1 , r2 , r3 } ) the output contains an overlap entry for the triplet \\{r1 , r2 , r3 } but also for the pairs \\{r1 , r2 } , \\{r2 , r3 } and \\{r1 , r3 } ( i.e. subsets of the overlapping set ) .",
    "furthermore , the overlap of pair \\{r1 , r2 } may be reported multiple times if r3 breaks @xmath141 into multiple hyper - rectangles ( and same for \\{r2 , r3 } and \\{r1 , r3 } ) . meanwhile",
    ", our approach produces only maximal sets of overlapping rules with a non - empty intersection .",
    "[ tab : exp - comp ] shows the number of sets of overlapping rules and the number of missing rules identified by our approach  vs.  signavio s one . in all runs ,",
    "both the number of overlapping and missing rules is drastically lower in our approach .",
    "# rules & 499&998&1492 & 505&1000&1506 & 502&1019&1496 + overlapping time & 297ms&6475ms&24530ms & 200ms&1621ms&5374ms & 5715ms&6793ms&30736ms + missing time & 160ms&611ms&1672ms & 163ms&820ms&1942ms & 2173ms&7029ms&18263ms +     & 499&998&1492 & 505&1000&1506 & 502&1019&1496 + # overlapping&our approach & 131&447&812 & 110&225&378 & 139&227&371 + rule sets&signavio & 1226&10920&23115 & 679&3692&8921 & 23175&22002&62217 + # missing&our approach & 117&330&726 & 136&254&462 & 134&322&518 + rules&signavio & 668&2655&5386 & 563&2022&4832 & 5201&18076&43552 +",
    "this paper presented a formal semantics of dmn decision tables , a notion of dmn table correctness , and algorithms that operationalize two core elements of this correctness notion : the detection of overlapping rules and of missing rules .",
    "the algorithms have been implemented atop the dmn toolkit .",
    "an empirical evaluation on large decision tables has shown the potential for scalability of the proposed algorithms and their ability to generate non - redundant feedback that is more concise than the one generated by the signavio dmn editor .",
    "the proposed algorithms rely on a geometric interpretation of rules in decision tables , which we foresee could be used to tackle other analysis problems . in particular",
    ", we foresee that the problem of simplification of decision tables ( rule merging ) could be approached from a geometric standpoint .",
    "indeed , if we see the rules as hyperrectangles , the problem of table simplification can be mapped to one of finding an optimal way of merging hyperrectangles with respect to some optimality notion . another direction for future",
    "work is to extend the proposed formal semantics to encompass other aspects of the dmn standard , such as the concept of decision requirements graphs ( drgs ) , which allow multiple decision tables to be linked in various ways . *",
    "* this research was partly funded by an institutional grant of the estonian research council ."
  ],
  "abstract_text": [
    "<S> the decision model and notation ( dmn ) is a standard notation to capture decision logic in business applications in general and business processes in particular . </S>",
    "<S> a central construct in dmn is that of a decision table . the increasing use of dmn decision tables to capture critical business knowledge </S>",
    "<S> raises the need to support analysis tasks on these tables such as correctness and completeness checking . </S>",
    "<S> this paper provides a formal semantics for dmn tables , a formal definition of key analysis tasks and scalable algorithms to tackle two such tasks , i.e. , detection of overlapping rules and of missing rules . </S>",
    "<S> the algorithms are based on a geometric interpretation of decision tables that can be used to support other analysis tasks by tapping into geometric algorithms . </S>",
    "<S> the algorithms have been implemented in an open - source dmn editor and tested on large decision tables derived from a credit lending dataset .    </S>",
    "<S> = 1 </S>"
  ]
}