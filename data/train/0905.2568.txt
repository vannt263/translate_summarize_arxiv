{
  "article_text": [
    "due to the fact , that experimental setups are usually not suited to cover the complete complete phase space , event generators are very important tools for experiments .",
    "practically , the experimental physicist needs a tool in hand which allows to control almost all kinematic variables with a manageable user interface and to exchange the physics models which have to be compared to measured data .    in our contribution",
    ", we present the software structure of the pluto event generator  @xcite originally developed for the hades experiment  @xcite but successfully used by other collaborations in the hadronic physics field as well .",
    "its recent redesign partly discussed in this contribution enhanced its flexibility and provide new features which allow to meet new challenges coming with the detector studies for the new fair experiments panda  @xcite and cbm  @xcite .",
    "pluto is a collection of c++ classes , adding up to the framework of a simulation package for hadronic physics interactions in the energy regime up to a few gev .",
    "it is launched interactively within the root  @xcite environment , and makes use of root only , without requiring additional packages .",
    "the focus is on streamlining particle generators by providing the tools to set up and manipulate particles , reaction channels , and complex reactions , as well as applying experimental filters on the reaction products , such as geometrical acceptance and kinematical conditions .",
    "typical simulations may be executed with a few lines of input , with no expertise required on the part of the user .",
    "it standardizes simulations by providing a common platform that is accessible via the analysis environment ( root ) , with a straightforward user interface that does not inhibit non - experts in simulations .",
    "the output may be analyzed on line , or further forwarded to a digitization package .",
    "the pluto framework includes models for hadronic and electromagnetic decays , resonance spectral functions with mass - dependent widths , and anisotropic angular distributions for selected channels .",
    "a decay - manager interface enables `` cocktail '' calculations .",
    "an extensive particle data base is available , with capabilities to support user - defined ones .",
    "various particle properties and decay modes are included in the data base .",
    "thermal distributions are implemented , enabling multi - hadron decays of hot fireballs .",
    "the general philosophy of pluto is that on one hand the users should be able to drive the package in a very easy way , but on the other hand are allowed to customize it without much restrictions .",
    "this means that the steering application has the opportunity to add new decays / particles among with new models up to the incorporation of plugins .",
    "structure and design of pluto : the ( orange ) boxes in the upper left show the user classes to set up and handle reactions ( and decay channels ) .",
    "the ( yellow ) box on the left is the interface for accessing the particle stream while the event loop is running .",
    "the ( blue shaded ) boxes in the lower right corner represent the data base for the particles and decays among with a user interface for customization .",
    "the ( light blue ) boxes above are the distribution interface and the included physics models ( color online ) . ]    the structure and design of pluto are sketched in fig .",
    "[ fig : pluto_at_a_glance ] . the framework can be roughly divided into 3 parts : a user interface for event production , a physics package , and an event loop interface . in this report",
    "we would like to concentrate on the latter two issues : the first one allows to add and/or select physics cases , where models can be either build - in models or runtime replacements , which will be discussed in sec .",
    "[ sec : models ] .",
    "this area of pluto works even outside the event loop for the calculation of parameters ( mass distributions , decay widths , ... ) .",
    "the other block allows for external particle decay and acceptance filter classes ( see sec .  [",
    "sec : bulk ] ) and filling of on - line histograms ( see sec .  [",
    "sec : projector ] ) .    as the interface for event production",
    "is described in detail elsewhere  @xcite in this context we will give only a short example .",
    "after all models have been configured accordingly , an elementary reaction chain is defined with a character string containing the reaction products . to perform , e.g. , the @xmath4 production in the @xmath5 reaction with a consecutive dalitz decay as discussed in the following sections , the commands as defined below are sufficient :    ....   preaction * r = new preaction(\"1.25\",\"p\",\"p \" ,                                \" p d+ [ p dilepton [ e+ e- ] ] \") ;    r->print ( ) ;    r->loop(10000 ) ; ....    with the number 1.25 as the kinetic beam energy in gev , the beam and target particle indicated by following two options and finally a string describing the decay .",
    "particles are defined via their data base name ( as `` p '' for a proton or `` d+ '' for a @xmath4 ) .",
    "the setup of the reaction channels and the attachment of all selected distributions and models is done by the framework , with the possibility to dump the complete chain and its models via the print ( ) method .",
    "finally , the command loop(n ) produces @xmath6 events .",
    "then , event - event - by - event , the individual steps in each reaction are executed via a common interface of all classes making distributions ( see  @xcite for details ) which do the calculation of final particle tracks ( also the unstable ones ) which are stored in an array .",
    "in the pluto framework , each physics process is described by a number of objects , instantiated from dedicated classes . beside the objects which communicate with the event loop and set the 4-momenta of the resulting particle tracks ( to form the above - mentioned `` distributions '' ) , pluto offers methods to make calculations including various channels and their accompanied functions in advance to ( or event without ) the event - loop . for this purpose ,",
    "a relative data base has been included , which connects particles and decays to `` models '' .",
    "at least one ( so - called `` _ primary _ '' ) model is needed per decay in order to describe the respective mass shape ( usually calculated by a mass - dependent breit - wigner in a recursive way ) and the partial / total decay width . each selected model can be accessed from all locations of the software package as well as by the user .",
    "the choice which of the allover offered physics models are linked to the data base can be done inside the production root - macro by calling a distribution manager ( for details about the handling see  @xcite ) , which itself takes care that only one primary model per decay and particle is selected , respectively .",
    "moreover , pluto offers the user the freedom to attach user - defined models based on its own sources or even new classes ( written in c++ ) at runtime , thereby replacing built - in models .",
    "these features make pluto an extremely versatile and highly configurable tool for simulations , while guaranteeing overall consistency at all times .",
    "one specific feature of pluto is that we do not use monolithic decay models only but allow for the splitting of the underlying physics process into different models in a very granular way ( e.g. , to exchange form factors or total cross sections ) .",
    "this turned out to be a very important tool in order to check various scenarios along with measured data .",
    "therefore pluto allows for the attachment of secondary models for all kinds of purposes . here",
    ", a secondary model is an object for a particle / decay returning a ( complex ) number as a function of a defined number of values .",
    "we do not attempt to have a base class for each kind of function and model ( e.g. , a total cross section base class , a base class for @xmath7 , etc . ) because this makes further extensions difficult .",
    "our approach is as follows : for each class of secondary models a new entry ( defined by a unique name ) is added dynamically to the data base .",
    "consequently , each model is bound to two data base keys : one to link it to a decay ( or particle ) and one more for the type of secondary model .",
    "anyhow , there the user does not need to take care about these issues , as the following template example shows .      in pluto ,",
    "each model is inherited from the base class pchannelmodel with a lot of useful features . in order to offer the result of the calculation the getweight ( ) method",
    "has to implemented .",
    "let us create such an example class as a template for the following discussion and future developments :    ....   class phelperfunctiontest : public pchannelmodel {   public :     phelperfunctiontest(const char_t * i d , const char_t * de ,                          int_t key ) ;       double_t getweight(double_t * x , int_t * opt = null ) ;   } ....    with an realization of the ( in this case 1-dimensional ) function :    ....   double_t phelperfunctiontest::getweight(double_t * x ,                                            int_t * opt ) {     double_t xx = x[0 ] ;     val = ...     return val ;   } ; ....    objects can be instantiated to work as a model for specific physics processes by the usage of a parser residing inside the constructor of the base class :    ....   phelperfunctiontest * obj = new     phelperfunctiontest(\"unique_name@d+_to_p_dilepton / helper \" ,                         \" test\",-1 ) ; ....    here , the unique_name is used to identify the object inside the distribution manager .",
    "the string hereafter binds the new object to a decay which is in this case @xmath8 .",
    "the optional appendix /helper enables the new object to be a secondary model of this type .",
    "let us now assume , the primary model has to access its helper function . in this case",
    "it is sufficient to execute the following command at a single place ( an init ( ) function is available for that ) :    ....   pchannelmodel * sec_model = getsecondarymodel(\"helper \" ) ; ....    and execute the daughter method sec_model->getweight(value ) whenever required .",
    "the access to alien secondary models is possible as well but a further discussion on this topic would exceed the scope of this report .",
    "the power of such a splitting can be demonstrated best with an real example .",
    "for this purpose let us use the study of the electromagnetic @xmath9 dalitz decay @xmath10 .",
    "as explained in the introduction pluto reads this as a multi - step process : in the first step , the @xmath9 mass is sampled using a mass - dependent width . in the second step ,",
    "the already sampled @xmath9 mass @xmath11 is used by the following dalitz decay model to sample the di - electron ( = virtual photon ) mass @xmath12 .    by using a dedicated plugin :    ....   makedistributionmanager()->exec(\"dalitz_mod : krivoruchenko \" ) ; ....    the following model for the di - electron mass spectrum is enabled , using the prescription of ref .",
    "@xcite with :    @xmath13    and the decay rate given by krivoruchenko _",
    "et  al _",
    "@xcite : @xmath14 where the index @xmath15 refers to the produced nucleon , @xmath16 is the electron charge , and @xmath17 represents the electromagnetic transition amplitudes . here , from the software point of view , it is important to know that this factor is a separated object in pluto making the addition of new complementary descriptions very easy .",
    "this avoids the usage of nasty flags which is error - prone .",
    "e.g. , following the qed approach ( assuming that no hadronic transition form factor is involved ) from ref.@xcite gives :    @xmath18    with @xmath19 , @xmath20 , and @xmath21 as the magnetic , electric and coulomb transition form factors .",
    "alternatively , one can switch to the vmd - like form factor of iachello and wan  @xcite which is already implemented and will be discussed in detail in a further , separate publication .    after activating this plugin , both above - mentioned versions ( vmd and qed )",
    "are offered , appearing as objects with their unique names in the directory - like distribution manager structure .    ....",
    "makedistributionmanager()->print(\"vmd \" ) ;                    -------------------- pdistributionmanager --------------------    root                 root group : 494 objects ( of 504 ) ,                           subgroups : 9       particle_models   mass sampling of particles : 27 objects                           ( of 29 )       decay_models      phase space mass sampling & decay partial                          widths : 219 objects ( of 225 )       polar_angles      polar angles in elementary particle                           production : 10 objects ( of 10 )       genbod_models     momentum sampling : 220 objects ( of 220 )           ...       vmd               vmd form factors : 0 objects ( of 2 ) ( )   d+_vmd_ff         vmd ff for d+ - > p e+e-   ( x ) d+_qed_ff         qed ff for d+ - > p e+e-           ...       qed               qed form factors : 2 objects ( of 2 ) ....    possible conflicts between the qed and vmd models are indicated .",
    "the user can now activate all models inside the directory via :    ....   makedistributionmanager()->enable(\"vmd \" ) ; ....",
    "the bulk interface . ]",
    "the aim of the event loop interface is to allow access to the particle bulk before it is written to disk by providing an interface for bulk decays ( also using 3@xmath22 party event generators such as pythia  @xcite ) , file access , implantation of embedded particles for detector studies , and filter classes .",
    "it works - like indicated in fig .",
    "[ fig : bulk_interface ] - by stacking individual bulk classes ( by preaction::addbulk(pbulkinterface * obj ) ) and making use of the base - class modify ( ) method which handles the embedding and removing of particles or mark them as decayed / invalid .",
    "like in the previous section , user classes can be compiled - if needed - and added on - the - fly , which could be very helpful in the context of fair experiments studies , as the following applications show :      particle tracks might be added from ( or written to ) user files in any self - defined format .",
    "this feature makes pluto open for other collaborations and enables it to be used as an `` afterburner '' for externally created simulation data or output of transport models .",
    "test particles can be embedded into a background reaction which is an important tool for detectors studies , e.g. to test tracking in a high multiplicity environment . moreover , among with the previous feature the mixing of embedded particles with either real events or 3@xmath22 party simulation is one of the applications . in the first case ,",
    "the reconstructed vertex of the analyzed experimental data is used to simulate rare probes ( as the di - electrons ) at exactly the same vertex . in this way the efficiency of these probes can be calculated with the best background one can have , namely measured data .",
    "in addition to a well defined reaction chain , pluto offers free `` bulk '' decays , i.e.  the decay of ( embedded ) particles following the calculated mass - dependent branching ratios . at this stage",
    "it is possible as well to employ 3@xmath22 party event generators . only to give an example",
    ": pluto can generate embedded particles like resonances with a selected distribution and the pythia package ( or pluto itself ) can be used for their realistic free decay .",
    "the particles created in the previous steps can be pre - filtered using a `` detector acceptance '' user class following a class definition as outlined below :    ....   class pmydetector : public pbulkinterface {   private :     double_t * acc ;   public :     bool_t modify(pparticle * * stack , int * decay_done , int * num ,                    int stacksize ) ;     } ;     pmydetector::pmydetector ( ) {     acc = makestaticdata()->getbatchvalue(\"acc_value \" ) ;   } ; ....    with acc_value as a booked batch value ( see below for more information ) and , e.g. :    ....   bool_t pmydetector::modify(pparticle * * stack , ... ) {   * acc=1 . ;   for ( int i=0 ; i < * num ; i++ ) {     pparticle * cur = stack[i ] ;     if ( \" check for cur \" ) * acc=0 . ;     }   } ....",
    "the usual way to analyze generated events ( beside a full monte - carlo production including digitization ) is to open the simulation file with an appropriate analysis macro , loop over the number of events , read the particle objects and do the required operations inside the loop .",
    "e.g. , in hadronic physics , in particular for exclusive studies , usually missing and invariant masses are reconstructed , and possibly after boost operations angular correlations are investigated .",
    "in addition , signal selection has to be done not only on a single track level but using particle correlations ( such as a invariant / missing mass selection ) .",
    "this prevents to use the features provided by ttree::draw ( ) only , as these are fixed to single track properties .",
    "overview of the pprojector design . ]",
    "the main aim of the `` pprojector '' ( see fig .  [",
    "fig : pluto_pprojector ] ) is to offer a simplified analysis method following a similar idea as ttree::draw ( ) in order to project particles ( and their correlations ) onto on - line histograms and/or tntuples by making use of the bulk interface described in the previous section .",
    "this means , no analysis macro is needed for a large number of typical observables .",
    "there are two ways to include the projector into the event loop .",
    "either one or more of its instances are added to the bulk interface ( for an alternating mixing with other classes ) , or , which is sufficient for the most cases , the short version preaction::do(char * command ) can be used , where command follows a c++-like ( but more simple ) syntax .",
    "each of these commands - just forming steps in a batch - is executed inside the event loop .      to fill histograms",
    "one can use the extended method preaction::do(thx * histo , char * command ) where histo points to a 1/2/3-dimensional histogram .    in this case",
    "the command has to define the key variables _ x , _ y and _ x as the respective axis value , depending on the chosen dimension of histo .",
    "the pluto particle array objects can be accessed via its pluto particle name inside brackets as with the optional num as the consecutive number of equal particles inside each event .",
    "all objects can be combined with a number of build - in methods , moreover all browsable methods of the root - class tlorentzvector can be employed , as the following example indicates :    ....   r->do(histo1,\"_x = [ d+]->m ( ) \" ) ; ....    which fills the 1-dimensional histo1 with the @xmath4 mass .",
    "invariant masses ( composite particles ) can be formed by adding the objects :    ....   \" _ x = ( [ e+ ] + [ e-])->m2 ( ) \" ....    and stored for a consequent use in semi - colon separated sub - commands without requiring a `` new '' operator :    ....   \" dilepton = ( [ e+ ] + [ e- ] ) ; _ x = dilepton->m2 ( ) \" ....    let us now come to a more complex example , which is the calculation of the polar emission angle of one of the outgoing protons in a @xmath23 reaction ( n.b .",
    "pluto treats the c.m .",
    "system as a particle named p + p ) :    ....   \" p1 = [ p,1 ] ; p1->boost([p + p ] ) ; _ x = cos(p1->theta ( ) ) \" ....    in this example , in the first sub - command the first appearing proton is copied to the object p1 which is furthermore boosted into the c.m .",
    "energy frame and in the last step the cosine of its polar angle is written as a value to the x - axis .",
    "the projection to tntuples turned out to be very useful as it allows to make additional selections ( and definition of the histogram axis ) afterwards which is a very simple task using the pprojector following the syntax as described above .",
    "let us now assume , the momenta of simulated @xmath24 s should be stored .",
    "then the first step would be to define the tntuple with branch names :    ....   tntuple * ntuple =      new tntuple(\"ntuple\",\" ... \",\"eta_px : eta_py : eta_pz \" ) ; ....    hereafter , the do()-method has to be called like in the above - indicated example but with a pointer to a tntuple - object instead of a histogram and the variable names of the ntuple instead of the axis names :    ....   \" eta_px = [ eta]->px ( ) ; eta_py = [ eta]->py ( ) ;       eta_pz = [ eta]->pz ( ) \"   ....    the filling of the ntuple is done by pluto , only ( but on purpose ) the opening and closing of the root - file has to be called externally .",
    "in addition to the writing of tntuples it is also possible to read ( back ) any ntuple , modify its values and write it back or make histograms .",
    "let us use the ntuple of the previous example which uses the ntuple ( usually from a file ) and defines an _ empty _ reaction , but attaches the ntuple as a 3rd party input :    ....   preaction my_reaction ;    my_reaction.input(ntuple ) ; ....    the next step is to use the branches of the ntuple in the batch command line to , e.g. , reconstruct the 4-momentum :    ....   \" myeta = p3m(eta_px , eta_py , eta_pz,0.54745 ) \" ....    with p3 m as the short syntax for a vector constructor with 3 momenta and the particle mass as parameters . at this point",
    "any kind of mathematical operation available via tformula can be applied as well . finally using loop ( ) without a number reads all events from the ntuple .",
    "the employment of batch commands allows to define on - line filters on single particle properties as well as kinematic variables which are accessible as indicated above .",
    "these filters can be used to select events for single histograms only or forwarded to the event loop to apply physical constraints , before a full event is written to disk , hence reducing the event file .",
    "variables prepared in a detector class as outlined in sec .  [ sec : filters ] can be integrated very easily .",
    "this is realized by using the if - command , followed by the variable or a combined condition based on particle observables .",
    "the remaining batch sub - commands are executed only under a positively evaluated condition .",
    "it goes without saying that the condition statement can combine all methods among with the established tformula syntax :    ....   \" if(obj->p ( ) > 0.3 & & obj->p ( ) < 0.6 ) ; dowhatever ... \" ....    in this case , histograms and ntuples in the do ( ) method are only filled under the defined condition , or , `` dowhatever '' can be used to re - define variables .    in this context , it should be noted , that variables , starting with `` # '' are interpreted by the pluto event loop as a condition for the final event file . in our next case ,",
    "an event is accepted if both the electron and the positron are produced with polar angles in the range of 18 to 85 degrees :    ....   \" theta_ep = ( [ e+]->theta ( ) * 180.)/tmath::pi ( ) \"    \" theta_em = ( [ e-]->theta ( ) * 180.)/tmath::pi ( ) \"    \" # filter = 1 ; if(theta_ep<18 || theta_ep>85 || theta_em<18",
    "theta_em>85 ) ; # filter = 0 \" ....    by this means it is only a single step to activate the detector class mydetector from sec .",
    "[ sec : filters ] :    ....   \" # acc_filter = acc_value \" ....    and optionally combine the prepared acceptance flag with our kinematical conditions .",
    "in summary , we presented new developments for the pluto event generator which moves this package from being a pure event generator to a comprehensive framework .",
    "the particular features are the bookkeeping of various models and the user interface for their simple selection .",
    "the new event loop interface allows to mix several sources , to define and enable online selections , project to histograms and to make a lot of operations .",
    "detector acceptance and resolution can be included without much overhead , which is of particular importance for detector studies in the context of the fair project .    in the near future",
    ", we will implement general purpose resolution scenarios using a common data format and file readers to transport models ( like urqmd  @xcite and hsd  @xcite ) .",
    "this will allow to test very rapidly the performance of different detector configuration options .",
    "this work was supported by the hessian loewe initiative through the helmholtz international center for fair ( hic for fair ) .",
    "we would like to thank b. kmpfer for reading and commenting the manuscript .",
    "g.  agakishiev _ et al . _",
    "[ the hades collaboration ] , arxiv:0902.3478 [ nucl - ex ] .",
    "j.  g.  messchendorp [ panda collaboration ] , arxiv:0711.1598 [ nucl - ex ] ; b.  seitz [ panda collaboration ] , _ prepared for 16th international workshop on deep inelastic scattering and related subjects ( dis 2008 ) , london , england , 7 - 11 apr 2008_."
  ],
  "abstract_text": [
    "<S> we present the design of the simulation package pluto , aimed at the study of hadronic interactions at sis and fair energies . </S>",
    "<S> its main mission is to offer a modular framework with an object - oriented structure , thereby making additions such as new particles , decays of resonances , new models up to modules for entire changes easily applicable . </S>",
    "<S> overall consistency is ensured by a plugin- and distribution manager . </S>",
    "<S> particular features are the support of a modular structure for physics process descriptions , and the possibility to access the particle stream for on - line modifications . </S>",
    "<S> additional configuration and self - made classes can be attached by the user without re - compiling the package , which makes pluto extremely configurable .    </S>",
    "<S> @xmath0 institut fr kernphysik , goethe - universitt , 60438  frankfurt , germany + @xmath1 gsi helmholtzzentrum fr schwerionenforschung gmbh , 64291  darmstadt , germany + @xmath2 institut de physique nuclaire dorsay , cnrs / in2p3 , 91406  orsay cedex , france + @xmath3 smoluchowski institute of physics , jagiellonian university of cracow , 30 - 059  krakw , poland </S>"
  ]
}