{
  "article_text": [
    "network functions , such as firewalls and load balancers , are increasingly moving to `` the cloud '' by means of software processes outsourced on commodity servers . using virtualization ,",
    "network functions can be emulated in software in a cost - effective manner , and outsourced to the cloud reaping the benefits of reduced management and infrastructure costs , pay - per - use , etc .",
    "specifically , network function virtualization ( nfv ) is currently being proposed by several major industrial operators like cisco , alcatel - lucent , and arista , as a service to multiple clients  @xcite .",
    "in such a multi - tenancy setting , network functions are run on virtual machines ( vms ) belonging to different clients hosted on the same hardware ( server ) .",
    "naturally , this raises a number of security concerns for clients , including confidentiality and integrity .",
    "while such issues are common to it infrastructure outsourcing in general  @xcite , more specific to nfv is the sensitivity of an organization s proprietary network policies , which instruct how network functions are to be performed .",
    "these are potentially vulnerable to compromise from competing organizations as well as the cloud service provider itself .",
    "for instance , firewall rules do not only reveal ip addresses of hosts , network topology , etc .",
    ", but also defense strategies and sensitivity of different services and resources , which , in the traditional setting , are only known to a few network administrators  @xcite . while virtual machine isolation  @xcite could potentially address some of these issues , they are inadequate to provide privacy against the operator , i.e. , the cloud service provider . * problem statement .",
    "* these challenges motivate the need to protect the privacy of network policies against an untrusted cloud provider , as well as other tenants and third parties . in the rest of the paper , we call this the _ private nfv problem _ , which",
    ", as we discuss in section  [ sec : related ] , has been largely overlooked by prior work on nfv security .",
    "we define a generic model to define privacy in nfv and propose several solutions based on different cryptographic primitives such as fully homomorphic encryption , partial homomorphic encryption and public - key encryption with keyword search .",
    "the solutions result from tradeoffs between privacy and performance , and can be instantiated depending on the adversarial model , showing that private processing of outsource network functions is already feasible today by adapting a few existing cryptographic primitives .",
    "* contributions . *",
    "we construct an abstract model of network functions which seeks to generalize most of the network functions used in practice as well as relevant adversarial models ( sections  [ sec : problem ] and  [ sec : theory ] ) .",
    "then , based on this abstraction , we propose three different solutions : an ideal , yet not very efficient , one based on fully homomorphic encryption , and two more practical solutions based on partial homomorphic encryption and public - key encryption with keyword search ( peks ) , secure in two different adversarial models , which we define as _ strong _ and _ weak _ ( section  [ sec : solutions ] ) .",
    "our solution against the weak adversary is also the first to include stateful network functions , e.g. , a stateful firewall that keeps track of open tcp / ip connections .",
    "finally , we present a proof - of - concept implementation of our schemes and evaluate their performance overhead using an outsourced firewall as a use - case ( section  [ sec : implement ] ) . using a typical 5-tuple based firewall rule , we show that a packet can be processed within 109 ms and 180 ms , respectively , using our solutions secure against the weak and the strong adversary , and demonstrate that our schemes scale quite well , as processing times reach 250 ms and 1,208 ms , respectively , using 10 rules .",
    "bearing in mind that our proof - of - concept implementation is not optimised for efficiency ( e.g. , lack of multi - threading ) , our results indicate that private nfv is feasible using existing cryptographic primitives .",
    "khakpour and liu  @xcite introduce a data structure called bloom filter firewall decision diagram ( bffdd ) in order to anonymize firewall policies built from firewall decision diagrams ( fdd )  @xcite .",
    "however , as acknowledged by the authors , bloom filters  @xcite naturally introduce false positives .",
    "thus , occasionally , packets that do not match any policy are ( mistakenly ) dropped by the firewall .",
    "furthermore , security / privacy of their solution is argued against a black - box assumption of bloom filters , which does not analyze the security properties of bloom filters themselves ( such as one - wayness ) .",
    "shi , zhang , and zhong  @xcite use multilinear maps from coron , lepoint and tibouchi ( clt ) , which are based on _ graded encoding systems _",
    "@xcite , to encode each bit of a firewall rule as a pair of level-1 encodings and a level-@xmath0 encoding for the whole rule , where @xmath1 is the length of a possible packet . following the security properties of the multilinear map ,",
    "it is not possible to obtain level-@xmath2 or lower encodings given a level-@xmath3 encoding for each @xmath2 . upon receiving a packet , the encodings corresponding to the bits of the packet are multiplied and the result is then matched with the level-@xmath4 encoding for the whole policy through a procedure called ` iszero ` .",
    "unfortunately , the clt construction has been recently shown to be insecure , due to an attack on the ` iszero ` routine  @xcite ; a key ingredient to check if a packet matches a policy .",
    "although both these constructions focus specifically on outsourcing firewalls , they exclude details of how state tables can be maintained in their framework by a stateful firewall . furthermore , due to being specific to firewalls , their solutions are only relevant to policies that result in a binary decision ( allow or deny ) , excluding network functions that modify packet contents or perform more complex actions . compared to these two solutions ,",
    "our solutions for private nfv cover a much broader range of network functions , including firewalls , and also consider state tables .",
    "private nfv also resembles real - time processing over encrypted packets .",
    "the work in @xcite discusses deep packet inspection over encrypted data , however , it requires the sender ( third party ) to be a participant in the protocol , which makes it impossible to use this solution on existing infrastructures ( a requirement that we describe as compatibility in section  [ sec : desired ] ) .",
    "somewhat related is work on outsourcing frameworks in software defined networks .",
    "specifically , sherry et al .",
    "@xcite provide a prototype of the aplomb architecture , where the middlebox functionalities ( e.g. firewall ) are outsourced to the cloud by the enterprises without greatly damaging throughput .",
    "gibb et al.@xcite then present an architecture in which enterprise networks only forward data and additional processing is performed by external feature providers without any limitation on location .",
    "however , @xcite do not consider private processing .",
    "security issues in outsourcing network functions are also studied in , e.g. , , which provide a roadmap on the construction of a verifiable network function architecture that can verify the correctness of the outsourced service w.r.t .",
    "functionality , performance , and actual workload in the cloud . in general",
    ", concerns raised from the the lack of control with cloud outsourcing have been investigated in  @xcite , while , addresses the problem of auditing outsourced computation by providing a monitor system that efficiently and verifiably tracks memory use and cpu - cycle consumption in the cloud .",
    "remote attestation and verification are also studied by haeberlen et al .",
    "@xcite , who propose an efficient method for verifying specific types of computation , while  @xcite introduces accountable virtual machines without trusted hardware .",
    "finally , zhang et al .",
    "@xcite and argyraki et al .",
    "@xcite provide mechanisms to ensure accountable networking by discovering entities that drop packets in a malicious way .",
    "this section introduces the problem of private processing of outsourced network functions .      in the rest of the paper , we consider outsourcing of simple network functions , such as those presented below , along with the related ( simplified ) policies .",
    "* firewall . *",
    "the simplest example of a firewall policy is to drop a packet if the source ip address belongs to a given ip range",
    ".    * load balancer . *",
    "a load balancer distributes incoming packets across different servers to minimize load on one or more servers .",
    "a typical load distributing algorithm is round - robin .",
    "for instance , if the ip address of the server currently at the top of the list is ` 192.168.0.1 ` , then the destination ip address of the packet should be changed to this ip address .",
    "* carrier - grade nat . * a carrier - grade network address translator maps private ip addresses ( and ports ) within a private network to one or more public ip addresses ( and ports ) , to reduce the number of public ip addresses required .",
    "an example of a nat policy is that if the destination ip of an incoming packet is ` 213.145.163.231 ` and the destination port is ` 5000 ` , the destination ip and port should be changed to ` 196.168.0.1 ` and ` 22 ` , respectively .",
    "* an intrusion detection system scans packets to detect any malicious traffic",
    ". an example policy could be that if the destination ip address of an incoming packet is ` 192.168.0.1 ` and the payload contains a ` post ` request then an ` alert ` message should be sent .",
    "* dpi . * deep packet inspection filters packets by inspecting it for viruses or other content such as pornography .",
    "an example policy could be that if an incoming packet contains the word ` adult ` in its contents , then the packet should be dropped .",
    "in the rest of the paper , we consider a scenario where an organization , the _ client _ , outsources one or more of its network functions to the _ cloud _ , as illustrated in figure  [ fig : nfv - diagram ] .",
    "the outsourced network functions run within virtual machines ( vms ) on commodity servers provided by the cloud .",
    "we call this the _ nfv setting _  as opposed to the _ traditional _ setting in which dedicated network middleboxes perform network functions within the client s private network .",
    "analogous to other cloud platforms , such vms are managed through hypervisors  @xcite .",
    "* cloud and client middleboxes . * to ease presentation ,",
    "we denote the set of all vms executing virtual network functions as the _ cloud middlebox _ , or _",
    "cloud mb _ for short .",
    "not all network functionalities need to be outsourced to the cloud , and as such the client still requires its own middlebox to carry out the remaining network functions or to communicate with the cloud mb .",
    "we call this the _ client middlebox _ , or _ client mb _ for short .",
    "the cloud mb receives inbound traffic destined for the client , processes the network functions assigned to it , and forwards the result to the client mb .",
    "outbound traffic is the one originating from within the client s private network which is forwarded by the client mb to the cloud mb to process the outsourced network functions and subsequently relay it to its intended destination .",
    "the network policies which describe how the network functions are to be processed are installed in the cloud mb by the client .    * trust assumptions .",
    "* we assume the cloud mb to be honest - but - curious , i.e. , it performs network functions dutifully yet wishes to infer the policies . later on in this paper , for some of the proposed solutions , we will assume that the cloud mb has a _ semi - trusted _ component , which we call the _ entry mb_. the entry mb receives the packet and performs some preliminary processing before handing the results over to the cloud mb .",
    "ideally there should be no entry mb , i.e. , no part of the cloud mb should be assumed to be part of black - box processing .",
    "however , inclusion of an entry mb remarkably improves performance , and its presence is reasonable assuming that the cloud is honest - but - curious . also , remark that the entry mb does not share any private keys with the client mb , and",
    "all the processing is done using public - key operations .      in the traditional",
    "setting , most network functions are run on dedicated middleboxes located at the edge of the client s private network . as a result ,",
    "the network policies are hidden from outsiders as long as the hardware is secure .",
    "once a network function is outsourced to the cloud , obviously , it is no longer the case .",
    "ideally , the client would want its network policies to remain private while maintaining the standards of service set by the traditional setting .",
    "* privacy . *",
    "the client expects its network policies to remain hidden not only from third parties , but also from other tenants and the cloud .",
    "we argue that the cloud should not be trusted to keep the policies secret , even though it processes the network functions for the client . at best",
    ", the client can only assume that the cloud is _ honest - but - curious _ , i.e. , it performs all the network functions as required due to service obligations and does not deviate from protocol specification , but it might still be interested in inferring network policies , possibly by colluding with another party . also , due to virtualization , it is likely that two vms computing network functions of two ( possibly competing ) tenants might be residing in the same physical server , thus , a client s network policies should be kept secret from another client .",
    "* performance . *",
    "the client expects the outsourced network functions to maintain the quality of service of the traditional setting .",
    "this introduces the following constraints .",
    "* _ real - time processing _ : the cloud mb should be able to process network functions in real - time . * _ minimal client - side processing _ : the client mb should be processing as little of the policies as possible in order to maintain the benefits of network function outsourcing .",
    "* compatibility . *",
    "third parties should be able to send / receive traffic to / from the client as if the network functions are implemented in the traditional setting , i.e. , third parties should not be required to undergo additional setup ( e.g. , implementation of customized network and cryptographic protocols ) to communicate with the client .    naturally , any solution for a private nfv will likely introduce a tradeoff between privacy and compatibility / performance : our goal is to explore the balance between security and performance , while satisfying the compatibility constraint .      before introducing our solutions",
    ", we discuss a few limitations of our model and make some important remarks . * traffic analysis .",
    "* an adversary may intercept and analyze traffic between the cloud mb and a third party and try to infer network policies based on the pattern of inbound and outbound packets .",
    "likewise , the adversary may generate its own traffic destined for the client ( through the cloud mb ) and analyze the packets it receives in response .",
    "for instance , if a request has been sent from a certain ip address for a tcp / ip connection , and a response has not been received , then the adversary may infer that it is a policy to drop packets from this particular ip address .",
    "however , note this can also be done in the traditional setting , and we require that solutions for private nfv do not need to provide privacy beyond what can be achieved in the traditional setting .",
    "* virtual machine isolation . *",
    "one way to achieve private nfv is through vm isolation , e.g. , isolation of memory and disk storage , together with the assumption that the hypervisor belongs to a trusted base  @xcite .",
    "a crucial aspect for secure isolation is to ensure that the hypervisor , i.e. , trusted computing base , is small in terms of lines of codes ( loc )  @xcite , which ensures that security vulnerabilities are minimized or , if identified , can be easily patched  @xcite .",
    "there are , however , several issues with this approach .",
    "( 1 )  small hypervisors are needed to formally verify correctness and security properties , and some simplifying assumptions are required , e.g. , w.r.t .",
    "the correctness of the compiler and the hardware , the presence of a uniprocessor instead of multiprocessors , etc .",
    ", as in the case of the formal verification of the operating system kernel `` sel4 ''  @xcite . also , it may be possible to iteratively verify a hypervisor by shedding each layer of simplifying assumptions .",
    "( 2 )  unfortunately , commodity hypervisors are not optimized in terms of lines of codes  @xcite , thus it is a strong assumption to assume they are trusted .",
    "( 3 )  cross - vm side - channel attacks can also enable a malicious vm to be co - located at the physical host of the target vm and exploit various side channels ( e.g. , cache ) , to obtain information such as cryptographic keys  @xcite .",
    "* coverage of network functions .",
    "* our goal is to provide solutions to private nfv that are applicable to most network functions , ideally , encompassing all possible network functions .",
    "however , one can not make such claim without checking the implementation details of each and every network function in practice .",
    "rather , we give a broad definition of network functions and provide solutions to private nfv that cover network functions satisfying this definition , which can be incrementally modified to cover more functions .",
    "for instance , we do not consider traffic shaping , where delivery of certain packets is delayed ( at the cloud s side ) to satisfy performance guarantees .",
    "* inbound vs outbound traffic . * in this work , we focus on _ inbound _ traffic , i.e. , traffic coming from third parties toward the client .",
    "although our private nfv solutions ( presented next ) are applicable to outbound traffic as well , this would require redirecting traffic from the cloud mb ( after private processing of network functions ) to the client mb , which in turn forwards it to the third party receiver .",
    "let @xmath1 be a positive integer and @xmath5 and @xmath6 be @xmath1-element vectors : then @xmath7 denotes their dot product . the dot product of a vector @xmath5 with itself , i.e.",
    ", @xmath8 is denoted by @xmath9 .",
    "the hadamard product or the entry - wise product of the vectors @xmath5 and @xmath6 is @xmath10 , i.e. , the @xmath1-element vector whose @xmath2-th element is @xmath11 .",
    "the vector @xmath12 denotes the @xmath1-element vector with all @xmath13s except a @xmath14 in the @xmath2-th position .",
    "given two positive integers @xmath15 and @xmath16 , the _ bitwise and _ operation , denoted @xmath17 , outputs @xmath14 if the binary representation of @xmath15 and @xmath16 agrees in all bit positions . more specifically , if we assume @xmath15 and @xmath16 to be @xmath1-bit binary numbers and let @xmath18 and @xmath19 denote their @xmath2-th bits with the most significant bit at position @xmath1 , then @xmath20 where @xmath21 .",
    "the _ bitwise greater than or equal to _ operation , denoted @xmath22 , is defined as @xmath23 which is @xmath14 if @xmath24 and @xmath13 otherwise .",
    "the _ bitwise less than or equal to _ operation , denoted @xmath25 , is defined similarly with the roles of @xmath15 and @xmath16 interchanged .",
    "the encryption function @xmath26 on a vector @xmath5 is defined as the vector @xmath27 for positive integers @xmath28 , the notation @xmath29 $ ] denotes all integers between @xmath15 and @xmath16 inclusive .",
    "the notation @xmath30 $ ] , for a positive integer @xmath1 , defines the set @xmath31 .",
    "let @xmath32 and @xmath33 be positive integers .",
    "we define a packet @xmath5 as a vector in @xmath34 , where @xmath1 represents the different fields of the packet ( source ip address , protocol type , etc . ) and @xmath35 is an upper bound on the length of packet fields . although it is much natural to define a packet as a bit string of bounded length ( @xmath36 in case of ipv4 packets ) , we prefer our definition as it facilitates the description of private nfv solutions later on .",
    "a network function @xmath37 from @xmath34 onto @xmath34 is the pair @xmath38 defined as @xmath39 where @xmath40 is called the matching function , and @xmath41 is the action function , or simply the _",
    "action_. the intuitive meaning of the above is that when a network function receives a packet @xmath5 the matching function decides whether the current network function applies to this packet .",
    "if yes , the relevant action is performed by the action function altering the packet to @xmath42 . if the result of the match is negative , the packet is left unchanged .    in some cases",
    ", a network policy will be composed of several network functions as defined above  in this case , we iteratively define the resulting network function as : @xmath43 for @xmath44 .    the definition of @xmath37 as a match - action pair is motivated by the openflow communications protocol between the control and forwarding planes in software defined networks ( sdn )  @xcite , which use flow tables containing match fields and the corresponding actions to be carried out .",
    "note that different fields of a packet are not necessarily of the same length , e.g. , if we consider ip packets then the version field ( i.e. , ipv4 or ipv6 ) is 4 bits long while the source ip field is 32 or 128 bits long ( ipv4 or ipv6 packets ) .",
    "therefore , we consider a value @xmath35 that is large enough to incorporate the largest header field .",
    "this is for theoretical convenience , and any superfluous bits for smaller fields can be duly discarded . the packet payload , which can be much larger , is divided into chunks of length @xmath45 bits .",
    "* virtual fields . * besides the standard fields , we assume the presence of additional ones , which we call _ virtual _ fields . these originate from the implementation of our private nfv instantiations and are inserted in the payload of the packet .",
    "for instance , a _ tag _ field will be used to model a common functionality of network functions such as the firewall and rate limiter , to drop packets matching certain criteria . to indicate that a packet is to be dropped",
    ", the cloud mb can assign the value ` drop ` to this tag ( contained in the ip packet s payload ) and send it to the client mb .",
    "how this value is added in a private way is described in section  [ sec : solutions ] and how these virtual fields can be added to the packet is described in section  [ sec : implement ] .",
    "* example .",
    "* we assume a simple network address translation ( nat ) policy as a running example .",
    "for instance , upon receiving a packet @xmath5 with destination ip in the range ` 128.*.*. * ` , the nat changes the destination ip and port to ` 196.*.*. * ` and ` 22 ` , respectively . without loss of generality , we assume that the destination ip and destination port belong to the first two elements of @xmath5 , i.e. , @xmath46 and @xmath47 . thus , the matching function is : @xmath48\\\\                  0 & \\text{otherwise }                  \\end{cases},\\ ] ] and the action is : @xmath49 ( note that the ip addresses are mapped in @xmath50 . )      some network functions such as ( stateful ) firewalls maintain dynamically generated states .",
    "when a packet arrives , it is first checked against the state table to see if any entry in the state table matches the fields of the packet .",
    "if a matching entry is found , the prescribed action is performed on the packet and it does not need to be further processed by other ( static ) policies .",
    "an example is the state of tcp connection maintained by a firewall , as depicted in table  [ table : state ] .",
    "the firewall notes a _ new _ connection when the syn flag in a packet is set , and creates an entry in the state table containing , for instance , the source / destination ips and ports and protocol type ( 6 for tcp ) along with the current state . upon receiving a syn - ack from the destination and a subsequent ack flag from the source , the firewall changes the state of this connection to _ established _",
    "( shown as ` est ` in the table ) .",
    "any subsequent packets that satisfy the headers contained in the state table entry are then allowed to go through without further processing of the network policies .",
    "the state table entry is deleted once the fin - ack part of the tcp protocol is carried out , or when the connection times out .",
    "we note that in our model , state tables can be abstracted as dynamic match - action pairs , where the state and time - out columns in the state table can be thought of as _ virtual _ fields of the ip packet and the action as the addition of the ` tag ` field with value `` allow '' .",
    "however , one key difference is that once a match has been found , further processing is discontinued .",
    "therefore , any private solution to a stateful middlebox should have the property that execution is allowed to stop once a match in the state table is found  otherwise there would be no performance gain from maintaining state .",
    "our goal is to provide privacy of an outsourced network function @xmath37 given a set of packets @xmath51 .",
    "from an adversarial perspective , the network function @xmath37 can be learned either directly through the description of @xmath38 or indirectly by deducing from the outputs @xmath52 . in order to achieve privacy",
    ", we therefore need a scheme that protects both the network function @xmath37 and its output .",
    "we call this pnfv ( private nfv ) .",
    "let @xmath5 be a packet as defined before and @xmath37 be a network function such that @xmath53 .",
    "a public - key pnfv scheme is a tuple @xmath54 of probabilistic polynomial time algorithms defined as follows :    _ key generation : _ the algorithm @xmath55 returns the secret key @xmath56 and public key @xmath57 , where @xmath58 is the security parameter .",
    "_ packet encryption : _ the algorithm @xmath59 takes as input the public key @xmath57 and the packet @xmath5 and outputs the encrypted version @xmath60 .",
    "note that this is element - wise encryption , which results in @xmath1 ciphertexts .",
    "_ network function transformation : _ the algorithm @xmath61 takes as input the network function @xmath37 and outputs a _ transformed _ network function @xmath62 .    _",
    "packet processing : _ the algorithm @xmath63 takes as input the transformed network function @xmath62 and the encrypted packet @xmath60 and outputs the encryption of @xmath42 .    _ packet decryption : _ the algorithm @xmath64 takes as input the secret key @xmath56 and the encryption of @xmath42 and outputs @xmath42 .",
    "we may write @xmath65 to represent @xmath66 .",
    "concisely , we can define the output of pnfv given @xmath5 and @xmath37 as @xmath67 .",
    "thus , @xmath68 key generation , network function transformation , and packet decryption algorithms are computed by the client mb , while the remaining two algorithms are processed by the cloud mb .",
    "we have the following definition for correctness .",
    "a _ public - key _",
    "_ pnfv _ scheme is correct if for all @xmath69 it holds that @xmath70 \\le \\mathsf{negl}(k),\\ ] ] where @xmath55 , @xmath71 is a negligible function and @xmath58 is the security parameter .",
    "as mentioned before , we consider an honest - but - curious adversary , i.e. , a passive adversary that correctly computes pnfv but would like to infer @xmath37 .",
    "more precisely , we conduct the following experiment involving an adversary @xmath72 to model pnfv security .",
    "first , @xmath72 is given the public key @xmath57 , the description of algorithms @xmath54 and the transformed network function @xmath62 .",
    "while @xmath72 is in the _ test _ state , it can sample any packet @xmath5 and obtain its output @xmath73 such that @xmath53 through the packet processing algorithm .",
    "finally , in the _ guess _ state @xmath72 outputs its guess of the network function @xmath37 as @xmath74 . if @xmath75 , @xmath76 wins .",
    "the above experiment abstracts what we call the strong adversary , denoted @xmath77 , to distinguish it from a weaker adversary , denoted @xmath78 .",
    "the weak adversary differs from the strong one in that it is only given _",
    "oracle ( black box ) access to part _ of the packet processing algorithm @xmath79 , and is not shown the incoming packet @xmath5 . instead a packet is chosen randomly from a publicly known distribution @xmath80 , whenever @xmath78 requests for outputs of the above functions on a fresh input @xmath5 .",
    "naturally , this yields a weaker security definition . in practice , this model is realized by introducing an entry mb , which is assumed to be running within a black box .",
    "the entry mb receives the packet and performs part of the packet processing algorithm @xmath79 , which is hidden from @xmath78 .",
    "we model pnfv security using the following experiment involving , as discussed in section  [ sec : desired ] , an _ honest - but - curious _ adversary .    a _ public - key pnfv _",
    "scheme is @xmath81-private if for any adversary @xmath82 that runs in time @xmath83 , it holds that @xmath84 \\le \\epsilon = \\epsilon(k),\\ ] ] where @xmath85 , @xmath72 can be either @xmath86 or @xmath87 and @xmath58 is the security parameter .      in table  [ tab : notation ] , we summarize the notation used throughout the rest of the paper .",
    ".notation [ cols=\"<,<\",options=\"header \" , ]",
    "this section presents three pnfv instantiations .",
    "first , we briefly review a few different cryptographic primitives used in our schemes .",
    "then , we describe solutions for a generic network function @xmath37 , which , given a packet @xmath5 implements the policy : @xmath88 where @xmath89 $ ] .",
    "we call this the _ equality matching _ policy , a special case of the more general _ range matching _",
    "policy defined as : @xmath90 \\texttt { then } x_j \\leftarrow z.\\end{aligned}\\ ] ] note that policy  [ eq : range - pol ] equals policy  [ eq : equal - pol ] if @xmath91",
    ".      * fully homomorphic encryption ( fhe ) . *",
    "a fhe scheme involves the following algorithms :    * _ key generation : _ given the security parameter @xmath58 , generates public and private key pair @xmath92 . * _",
    "encryption : _ given plaintext @xmath93 , outputs ciphertext @xmath94 encrypted under public key @xmath95 . * _ decryption : _ given a ciphertext @xmath96 , outputs the plaintext @xmath97 using the secret key @xmath98 . *",
    "_ homomorphic addition ( add ) : _ given two ciphertexts @xmath99 , @xmath100 , and the public key @xmath95 , produces a ciphertext @xmath101 such that @xmath102 .",
    "* _ homomorphic multiplication ( mult ) : _ given two ciphertexts @xmath99 , @xmath100 , and the public key @xmath95 , produces a ciphertext @xmath96 as @xmath103 such that @xmath104 .",
    "* the bgn cryptosystem  @xcite . * boneh , goh , and nissim ( bgn ) cryptosystem  @xcite , besides provide additive homomorphism , also allows for _ one _ multiplication of ciphertexts .",
    "the scheme is based on a bilinear map and involves the following algorithms :    * _ key generation : _ generate the tuple @xmath105 , where @xmath106 and @xmath107 are two multiplicative cyclic groups of order @xmath108 and @xmath109 is the bilinear map @xmath110 .",
    "further pick two random generators @xmath111 and @xmath112 of @xmath106 and set @xmath113 .",
    "it follows that @xmath114 is a random generator of the subgroup of @xmath106 of order @xmath115 .",
    "the public key is @xmath116 and the private key is @xmath117 . *",
    "_ encryption : _ assume the message space to be @xmath118 where @xmath119 .",
    "encryption of a message @xmath120 using public key @xmath57 is @xmath121 , where @xmath122 is randomly chosen from the set @xmath123 .",
    "@xmath96 is the resulting ciphertext and is an element of @xmath106 . *",
    "_ decryption : _ given the secret key @xmath117 , compute @xmath124 and then find its discrete log base @xmath125 using , for instance , pollard s lambda method which takes expected time @xmath126  ( * ? ? ?",
    "* , p. 128)@xcite .",
    "the bgn cryptosystem is semantically secure under the _ subgroup decision _ assumption , i.e. , given an element @xmath127 , it is hard to decide if @xmath128 is in a subgroup of @xmath129 without knowing the factorization of the group order @xmath1 ( which is @xmath130 ) .",
    "since decryption involves computing discrete logarithms , bgn is only suitable for a small message space .",
    "* peks  @xcite .",
    "* public - key encryption with keyword search ( peks )  @xcite involves the following algorithms :    * _ key generation : _ given a security parameter , generates the public key @xmath57 and private key @xmath56 . *",
    "_ peks generation : _ given a keyword @xmath131 and the public key @xmath57 , produces the searchable encryption @xmath132 of @xmath131 as @xmath133 . * _ trapdoor generation : _ given the private key @xmath56 and a keyword @xmath131 , generates the trapdoor for @xmath131 as @xmath134 . * _ test : _ given public key @xmath57 , searchable encryption @xmath133 and trapdoor @xmath135 , @xmath136 outputs @xmath14 if @xmath137 and @xmath13 otherwise .",
    "we consider the instantiation by boneh et al .",
    "@xcite , based on identity based encryption ( ibe )  @xcite , which itself is based on a bilinear map @xmath110 , where both @xmath129 and @xmath138 are of prime order @xmath57 .",
    "the resulting scheme is semantically secure against a chosen - keyword attack in the random oracle model under the bilinear diffie - hellman ( bdh ) assumption  @xcite , i.e. , that given @xmath111 , @xmath139 , @xmath140 , @xmath141 @xmath142 , where @xmath111 is a generator of @xmath129 , it is hard to compute @xmath143 . apart from this assumption , we also use the assumption that the trapdoor @xmath134 is not invertible , i.e. , is one - way . in the specific construction",
    "discussed , the trapdoor @xmath144 is computed as @xmath145 , where @xmath146 is a hash function .",
    "the one - wayness of the trapdoor follows from the one - wayness of @xmath146 .",
    "* pseudorandom permutation .",
    "* we also assume the existence of a secure pseudorandom permutation @xmath147 , mapping from @xmath30 $ ] to itself . in practice , this can be implemented using a block cipher  @xcite , such as aes . in our constructions ,",
    "the inverse permutation @xmath148 is not required and as such the private key does not need to be shared .",
    "* _ key generation . _ * the client mb creates a public - private key pair @xmath149 of the fhe scheme .",
    "it keeps @xmath98 , and sends the public key @xmath95 to the cloud mb .",
    "* _ network function transformation .",
    "_ * the client mb computes the encrypted tuple @xmath150 using the public key @xmath95 and sends them to the cloud mb .    * _ packet encryption . _ * upon receiving a packet @xmath5 , the cloud mb computes @xmath60 , using the public key @xmath95 .    *",
    "_ packet processing . _ * using @xmath60 and the encrypted tuple , the cloud mb computes @xmath151 as defined in eq .",
    "[ eq : fully - nf ] .",
    "* _ packet decryption . _ * upon receiving the encrypted packet @xmath73 , the client mb decrypts it using its private key @xmath98 to obtain the transformed packet @xmath42 .",
    "we now introduce our fist solution based on fhe that is secure against the strong adversary .",
    "consider a network function @xmath37 implementing policy  [ eq : equal - pol ] .",
    "its matching function can be written as : @xmath152 which returns @xmath14 if @xmath153 and @xmath13 otherwise . the action function can be written as : @xmath154 replacing @xmath155 with @xmath156 .",
    "thus , @xmath37 becomes : @xmath157    we can construct a public - key pnfv scheme from any fully homomorphic encryption ( fhe ) scheme , as described in figure  [ fig : fhesol ] .    for policy  [ eq : range - pol ] ,",
    "the action function is the same , but the matching function is now given as : @xmath158 which is @xmath14 if @xmath159 $ ] and @xmath13 otherwise .",
    "this can be substituted for @xmath160 in eq .",
    "[ eq : fully - nf ] to get an expression for @xmath37 .",
    "the client mb needs to send the encryptions @xmath161 and @xmath162 ( instead of @xmath163 ) to the cloud mb , while the rest is the same .",
    "since policy  [ eq : equal - pol ] equals policy  [ eq : range - pol ] with @xmath91 , we can replace the matching function of the former with the latter for a more general description , even though incurring more homomorphic computations",
    ". also note that one can sequentially process @xmath164 network functions @xmath165 using this scheme , with the client mb sending encryptions for each network function at setup , and the cloud mb sending the encryption of @xmath166 to the client mb upon receiving the packet @xmath5 .",
    "* correctness . *",
    "it is straightforward to see that , if the underlying fhe scheme is correct , the construction in figure  [ fig : fhesol ] correctly performs the network function defined by policies  [ eq : equal - pol ] and [ eq : range - pol ] .",
    "* privacy . * intuitively , privacy of",
    "the scheme stems from the fact that , as matching and action functions , together with their results , are encrypted , the adversary can not infer the network function .",
    "more formally , in appendix  [ app : sec - red ] , we prove that this scheme is private against @xmath77 if the fhe scheme is semantically secure . * fhe practicality . *",
    "although research in fhe has made tremendous progress in improving efficiency  @xcite , we do not have a truly efficient fhe instantiation providing acceptable performance in the context of network function virtualization .",
    "however , efficient partial homomorphic encryption schemes , like bgn  @xcite , could be used , as discussed next , if we modify the matching function .      as for the fhe based scheme ,",
    "we start with the function @xmath37 described by policy  [ eq : equal - pol ] , but describe the matching function as : @xmath167 if we denote @xmath168 , note that @xmath169 if @xmath153 , whereas , if @xmath170 , then @xmath171 .",
    "since we only get @xmath96 as a function of @xmath5 , the matching function will output @xmath14 only if the packet matches the policy and give any value other than @xmath14 otherwise .",
    "the action function @xmath15 is the same as before : @xmath172    * matching and action . * we need an encryption algorithm @xmath26 that can homomorphically compute both @xmath120 and @xmath15 .",
    "more specifically , @xmath26 should give the encryption of @xmath173 as : @xmath174 and , for the action function : @xmath175    the bgn cryptosystem allows to homomorphically compute one multiplication and any number of additions .",
    "therefore , we can use it to construct a pnfv scheme secure against the strong adversary : the scheme is presented in figure  [ fig : bgnsol ] .",
    "we omit the description of the key generation algorithm ( which should be obvious from the underlying cryptosystem ) , and further include the packet encryption routine within the packet processing algorithm .",
    "* _ network function transformation . _ * the client mb computes the tuple @xmath176 and sends it to the cloud mb .    * _ packet processing . _ * upon receiving a packet @xmath5 the cloud mb :    1 .",
    "encrypts the packet as @xmath60 .",
    "computes @xmath177 according to eq .",
    "[ eq : bgn - action ] as @xmath178 + and @xmath179 according to eq .",
    "[ eq : bgn - match ] as @xmath180 3",
    ".   sends @xmath60 , @xmath177 and @xmath181 to the client mb .    *",
    "_ packet decryption . _ * upon receiving @xmath60 , @xmath177 and @xmath181 the client mb :    1 .",
    "decrypts @xmath181 to obtain @xmath96 .",
    "2 .   if @xmath169 , decrypts @xmath177 to obtain the transformed packet .",
    "if @xmath171 , decrypts @xmath60 to obtain the unchanged packet .",
    "* range matching . *",
    "next , we consider range matching , i.e. , the network function @xmath37 defined by policy  [ eq : range - pol ] .",
    "observe that : @xmath182 \\\\ ( b - x_i ) ( x_i - a ) < 0   & \\text { ~~otherwise}.\\end{aligned}\\ ] ] the product above can be written as @xmath183 let @xmath184 .",
    "if we define the matching function as : @xmath185 then @xmath186 if there is a match , and negative otherwise .",
    "homomorphically , we obtain : @xmath187 here , @xmath188 , @xmath189 and @xmath190 are computed by the client mb during the setup phase as part of the network function transformation routine .",
    "since the cloud mb already knows @xmath5 , it can compute @xmath184 in the clear , and then compute @xmath191 .",
    "the action function is the same as before .",
    "the client mb receives @xmath60 , @xmath177 and @xmath179 , and decrypts @xmath181 to obtain @xmath96 .",
    "if @xmath96 is a non - negative integer then it decrypts the result of the action function as the transformed packet , otherwise , it decrypts the original packet as the packet to be retained .    *",
    "correctness . *",
    "as mentioned , bgn can successfully decrypt homomorphic encryptions of unlimited additions and one multiplication ( per ciphertext ) .",
    "the above construction of match and action functions satisfy this constraint , thus implying correctness of the pnfv scheme in figure  [ fig : bgnsol ] .    * privacy . *",
    "intuitively , the scheme can be shown to be private as the adversary only sees randomized encryptions of matching and action functions and , as such , can not infer whether the matching function resulted in @xmath14 or some other value .",
    "more formally , we prove , in appendix  [ app : sec - red ] , that , if bgn is semantically secure , our pnfv scheme is private against @xmath77 .    * discussion . *",
    "ideally , the client mb would receive the encryption of the whole network function , i.e. , @xmath192 and simply decrypt it to get the final packet . in our protocol",
    ", it actually has to perform two decryption operations instead of one ( one to check the output of the matching function and another to decrypt the result ) , and , for each packet , three encryptions need to be sent .",
    "this is due to the fact that the output of the matching function is a variable ( i.e. , not a constant value ) when there is no match , thus , we can not perform iterations of @xmath164 network functions . * asymptotic complexity . *",
    "the network function transformation phase ( which is done only once , during the setup ) requires the client mb to compute , and send to the cloud mb , @xmath193 encryptions .",
    "the packet processing at the cloud mb requires the computation of @xmath193 encryptions , which are then sent to the client mb .",
    "finally , the packet decryption at the client mb requires @xmath193 decryptions .",
    "we now present a more efficient solution that is secure against the weak adversary , based on * public - key encryption with keyword search ( peks ) *  @xcite , a probabilistic encryption scheme @xmath194 and a pseudorandom permutation @xmath147 .",
    "figure  [ fig : weakadvsol ] presents our solution , in the context of policy  [ eq : equal - pol ] .",
    "observe that @xmath195 denotes the @xmath1-element index vector whose @xmath2-th element is @xmath2 itself , and @xmath196 the @xmath1-element vector whose @xmath2-th element is @xmath197 . in this model",
    ", the weak adversary @xmath78 does not have access to the entry mb packet processing .",
    "thus , we have a somewhat stronger assumption of security in this scheme with respect to the strong adversary schemes presented in section  [ sec : strongadv ] .",
    "the advantage , compared to the bgn based scheme presented in section  [ sub : bgn - scheme ] , is that we only send one encrypted packet , and the client mb only needs to decrypt the packet .",
    "also note that the entry mb runs @xmath147 only once per packet arrival to obtain a shuffled set of indexes , and permutes the encryptions according to this set .",
    "that is , steps 1 , 2 and 3 in figure  [ fig : weakadvsol ] performed by the entry mb use the same permutation .    * _ network function transformation . _ * using peks , the client mb computes the trapdoors @xmath198 and @xmath199 . using @xmath26 , the client mb creates the encryption @xmath200 .",
    "the client mb sends @xmath198 , @xmath199 and @xmath200 to the cloud mb .    * _ packet processing . _",
    "* this is divided into entry mb and cloud mb .    _ _ entry mb _ _ : upon receiving a packet @xmath5 :    1 .   encrypts @xmath196 using @xmath26 and shuffles the result as @xmath201 .",
    "2 .   encrypts @xmath196 using peks and shuffles the result as @xmath202 .",
    "3 .   encrypts @xmath195 using peks and shuffles it as @xmath203 .",
    "4 .   deletes the original packet @xmath5 .    _ _ cloud mb _ _ : upon receiving @xmath201 , @xmath202 and @xmath203 :    1 .",
    "checks if there exists an @xmath204 $ ] such that @xmath205 .",
    "if yes , finds an @xmath206 $ ] such that @xmath207 ( which should exist ) .",
    "2 .   replaces @xmath208 with @xmath200 in @xmath201 and sends it to the client mb .",
    "2 .   else , sends @xmath201 to the client mb .    *",
    "_ packet decryption . _ * the client mb upon receiving @xmath201 , decrypts to obtain @xmath209 and then reconstructs @xmath5 according to @xmath195 .",
    "* correctness . *",
    "the client mb decrypts @xmath210 , permuted by @xmath147 , to obtain @xmath211 and reconstructs @xmath42 according to @xmath195 .",
    "note that , if the original packet matches policy  [ eq : equal - pol ] , then @xmath212 .",
    "likewise , it the packet does not match the policy , decrypted packet @xmath42 is the original packet @xmath5 .",
    "therefore , our pnfv scheme is correct .",
    "* privacy . * intuitively ,",
    "since @xmath78 does not know which packet index yields a match and which index the action applies to ( due to random shuffle by @xmath147 ) , and since the matching value @xmath213 and the action value @xmath156 are encrypted , it can not infer the policy . in appendix",
    "[ app : sec - red ] , we show that if the probabilistic encryption scheme @xmath26 is semantically secure and the peks scheme is semantically secure against a chosen keyword attack , its trapdoor function @xmath144 is not invertible , and the pseudorandom permutation @xmath147 is indistinguishable from a random permutation , then the pnfv scheme described in figure  [ fig : weakadvsol ] is private against @xmath78",
    ".    * discussion . *",
    "the obvious limitation of this scheme is that it is only private against a weaker notion of adversary .",
    "in particular , we consider a cloud mb that does not try to analyze incoming packet @xmath5 with the output of the scheme .",
    "more precisely , the cloud mb does not retain the packet @xmath5 to match its randomly permuted encryptions , neither does it attempt to find @xmath214 in @xmath199 by checking all possible encryptions under @xmath132 of all possible elements in @xmath30 $ ] .",
    "if the cloud mb tries to do either of these ( unwarranted ) actions , it will at best learn the index @xmath214 ( and not index @xmath2 , @xmath213 or @xmath156 ) . to find @xmath215 ,",
    "the cloud mb needs to do a brute force search whose complexity is @xmath216 . on the other hand ,",
    "we only need to send a number of encryptions per packet independent of the number of network functions @xmath164 , however , it is only applicable to policy  [ eq : equal - pol ]",
    ".    * asymptotic complexity . * the network function transformation , similarly to the bgn based scheme , is done only once , during the setup , by the client mb , computing @xmath217 peks trapdoors and encryptions to be sent to the cloud mb .",
    "the packet processing requires the entry mb to perform and send to the cloud mb @xmath217 encryptions , while the cloud mb performs @xmath193 equality tests ( using the peks scheme ) , for each packet , and sends @xmath218 ciphertexts to the client mb .",
    "finally , the client mb needs to decrypt @xmath218 ciphertexts .",
    "we now discuss pnfv solutions in the context of stateful network functions .",
    "recall that a stateful network function maintains a state table , which among others contains a field ( column ) labelled _",
    "we model a state table as comprising of one or more packet field headers followed by a _ state _ field and an _",
    "action tag_.    the private state table solution is built from the peks based pnfv scheme discussed above .",
    "note that fhe based solutions are not applicable to state tables , as the cloud mb should discontinue processing once a match is found in the state table .",
    "if processing needs to be continued for the packet , and the current state table only maintains statistics ( such as counters ) , then this can be implemented in the same way as a normal network function .",
    "we denote the state and tag fields by @xmath56 and @xmath219 respectively .",
    "our proposed solution is shown in figure  [ fig : statetablesol ] . in case",
    "no entry in the state table is found , the cloud mb processes the static network policies via the underlying pnfv scheme . in figure",
    "[ fig : statetablesol ] , we assume that this is the bgn based pnfv scheme from section  [ sub : bgn - scheme ] . if relying on the peks - based scheme , the entry mb needs to send @xmath201 and @xmath203 to the cloud mb instead of @xmath5 .",
    "client mb : upon receiving a packet @xmath5 from the cloud mb decides that a state table entry is to be created .    1 .",
    "identifies a subset @xmath220 of @xmath195 corresponding to packet fields to be placed in the state table .",
    "2 .   produces trapdoors @xmath221 and shuffles them using @xmath147 as @xmath222 .",
    "3 .   creates encryptions of the state and the tag as @xmath223 and @xmath224 , respectively .",
    "4 .   sends @xmath222 , @xmath223 and @xmath224 to the cloud mb .    :",
    "creates a state table entry with @xmath222 , @xmath223 and @xmath224 , and sends the @xmath225 of this entry to the client mb .",
    ": upon receiving a packet @xmath5 , encrypts @xmath196 using peks and shuffles the result as @xmath202 .    : upon receiving @xmath5 and @xmath202 , for @xmath226 checks whether there exists an @xmath204 $ ] such that @xmath227 .    1 .   if there is a match for all @xmath228 , computes @xmath60 , appends @xmath229 , @xmath223 and @xmath224 to it and sends it to the client mb .",
    "otherwise , continues processing the _",
    "static _ network functions ( using the pnfv scheme ) .    : upon receiving an encrypted packet @xmath60    1 .",
    "decrypts it to obtain @xmath5 .",
    "2 .   strips the @xmath225 , state @xmath56 and tag @xmath219 , and carries out the action according to @xmath219 .",
    "update : _ sends the tuple @xmath230 to the cloud mb , where @xmath231 is the new state .",
    "deletion : _ sends the tuple @xmath232 to the cloud mb .",
    "* example .",
    "* we illustrate the state table solution using a firewall state table as an example .",
    "the client mb identifies the index set @xmath233 which correspond to the source ip address , destination ip address , source port , destination port and protocol fields , respectively , of an ipv4 packet",
    ". the client mb creates trapdoors for the values of these fields and randomly shuffles the trapdoors creating the set @xmath234 .",
    "let @xmath235 be the possible states , where the second state is the abbreviation of `` established . ''",
    "let @xmath236 be the possible tags .",
    "suppose the client mb first receives a packet @xmath5 whose syn flag is set .",
    "the client mb then sends the set @xmath237 and @xmath238 and @xmath239 to the cloud mb .",
    "the cloud mb creates an entry for this state table .",
    "suppose the identifier of this state table entry is @xmath225 , which is sent to the client mb .",
    "the cloud mb subsequently checks each incoming encrypted and shuffled packet @xmath5 ( done by the entry mb ) to see if it matches this state table entry .",
    "if it does , it simply appends @xmath229 , @xmath240 and @xmath241 as the state and tag respectively , to the encrypted packet @xmath60 and sends it to the client mb .",
    "the client mb , after decrypting the packet , checks the state and the ack flag in @xmath5 . if the ack flag is set , the client mb sets @xmath242 and sends @xmath243 to the cloud mb . since the tag is set to @xmath244 , it forwards the packet to its intended destination within the internal network .",
    "after the current tcp connection is over ( through fin - ack exchange ) , the client mb sends the pair @xmath232 to the cloud mb , which in turn deletes the corresponding entry .    * privacy . *",
    "the privacy argument of the proposed state table solution is similar to the one for the peks based pnfv scheme , and hence we omit it here .",
    "however , two important differences are that ( i ) the adversary @xmath245 knows the number of fields being checked ( due to @xmath246 ) , and ( ii ) learns whether or not the current packet matches a state table entry .",
    "in the following , we provide a proof - of - concept of the feasibility of our pnfv schemes .",
    "we assume that private network function processing operates at the network layer in the osi model , i.e. , it processes ip packets , although it can be extended to the processing of ethernet frames as well ( mac headers ) .",
    "note that not all packet fields are needed for private processing of a given network function , e.g. , the `` header checksum '' field of an ipv4 packet is used for integrity check and does not have to be encrypted .",
    "thus , we only use a subset @xmath220 of the set of indexes @xmath195 corresponding to different fields of a packet .",
    "for instance , if the network function performs firewall actions , we assume that @xmath220 is the 5-tuple defined in eq .",
    "[ eq:5tuple ] .",
    "the packet encryption algorithm of the cloud mb , upon receiving the packet @xmath5 , computes encryptions of the above fields only . recall that , in the peks based scheme , the entry mb deletes the original packet @xmath5 : for this tuple , this implemented by the entry mb resetting the corresponding field values to @xmath13 before sending @xmath5 to the cloud mb .",
    "whenever a packet @xmath5 arrives at the cloud mb , after private processing , this is transformed into a new packet @xmath42 ( as shown in figure  [ fig : encapsulation - x ] ) which is then sent to the client mb .",
    "for instance , assume a network function implementing the policy : if @xmath247 then block the packet , otherwise allow it , and assume we are using the pnfv scheme based on bgn ( section  [ sub : bgn - scheme ] ) .",
    "the client mb constructs the transformed packet @xmath42 as follows .",
    "it first constructs a new ip header containing its ip address as the source ip and the ip address of the client mb as the destination ip ( similarly for the ports ) .",
    "the payload of @xmath42 contains the original ip packet @xmath5 , as shown in the figure , followed by pnfv related payload .",
    "the pnfv payload specific to the bgn based scheme and the above mentioned policy is :    ( 1,0.44079526 ) ( 0,0 ) within packet @xmath42 by the cloud mb .",
    "fields shaded  have identical content.,title=\"fig : \" ] ( 0.270219743,0.42047569)(0,0)[lb ] ( 0.27606589,0.00556308)(0,0)[lb ]    the first field contains the i d of the pnfv scheme being used ( in this case , the bgn based scheme ) .",
    "the second field reports the policy i d of the particular policy being processed ( in case of state tables this is the state table entry i d ) .",
    "the next two items are the two possible actions that are to be applied on packet field @xmath214 depending on whether there was a policy match . in our example , this is @xmath248 which is the action when there is no match and @xmath249 is the action when there is a match . here",
    "@xmath250 is an index for the _ virtual _ field tag , since ip packets do not have a @xmath250 field . in case of other policies",
    ", this could be a real packet field , for instance the @xmath251 ( protocol ) field .",
    "the last item is the encryption of the result of the matching function , i.e. , @xmath181 .",
    "when the client mb receives the packet @xmath42 , it first extracts @xmath5 in a straightforward manner .",
    "the client mb then checks the pnfv i d to learn which scheme is to be applied ( in this case , the bgn based scheme ) and decrypts the last item @xmath181 .",
    "if @xmath169 , it decrypts @xmath249 and then drops the packets @xmath5 , whereas , if @xmath171 , it decrypts @xmath248 , and forwards the packet @xmath5 to its intended destination . the policy i d can be used for bookkeeping . if the original packet @xmath5 has size @xmath252 , then the size of @xmath42 is given by : @xmath253 as an example , consider the smallest sized packet @xmath5 of 34 bytes ( 14 bytes for the mac header , 20 bytes for the ip header and 0 bytes for the payload ) .",
    "if pnfv i d requires 4 bits and the state / policy i d requires another 20 bits , and the bgn ciphertexts have a blocksize of @xmath254 bits , then the pnfv payload has 99 bytes , thus yielding @xmath255 bytes for @xmath42 . in the case of the peks",
    "based scheme , the overhead is actually higher since encryptions corresponding to the 5-tuples and the virtual @xmath250 field needs to be added , thus yielding a tradeoff between packet processing efficiency and bandwidth / storage overhead .",
    "we implemented the peks based and bgn based schemes in c , using the ` relic ` cryptographic library  @xcite .",
    "as discussed earlier , the peks based scheme relies on the boneh and franklin cryptosystem  @xcite , whereas , for the bgn based scheme , we modified the freeman s prime - order version  @xcite provided by ` relic ` in order to fix some bugs in the decryption phase and to implement lookup tables of pre - computed discrete logarithms in order to achieve constant - time decryption .",
    "for the two schemes , we chose a barreto - naehrig pairing - friendly elliptic curve defined on a 256-bit prime order group , achieving a 128-bit security level .",
    "for pairing computations , we used the optimal ate pairing implementation provided by ` relic ` .    in the following , we present",
    "empirical results on pnfv simulations using the generic policy  [ eq : equal - pol ] , setting the size of each packet attribute @xmath256 to 4 bytes , which is the largest size of an ip header field in ipv4 packets ( corresponding to ip addresses ) .",
    "simulations were performed on a machine running ubuntu trusty tahr ( ubuntu 14.04.2 lts ) , equipped with a 2.4 ghz cpu i5 - 520 m and 4 gb ram .    0.3        0.3        0.3        0.3        0.3        0.3     * bgn based scheme .",
    "* figures  [ fig : time_strong_attr ] and  [ fig : time_strong_policies ] report execution times of packet encryption , processing and decryption of the bgn based scheme w.r.t .",
    ", respectively , the number of packet fields ( and @xmath257 policies ) and the number of policies ( and @xmath258 packet fields ) .",
    "experiments in figure  [ fig : time_strong_policies ] are intended to simulate a typical firewall rule that uses the @xmath258-tuple given by eq .",
    "[ eq:5tuple ] .",
    "note that the execution time of all three algorithms is linear in the number of packet fields ( figure  [ fig : time_strong_attr ] ) .",
    "whereas , as shown in figure  [ fig : time_strong_policies ] , execution times of packet processing and decryption are linear in the number of policies , but constant for packet encryption . for a network function with @xmath257 policies ,",
    "private processing of @xmath258 packet fields takes 62 ms for encryption , 1,027 ms for processing , and 118 ms for decryption .",
    "then , figures  [ fig : clientmb_attributes ] and [ fig : clientmb_policies ] plot the execution time for the network function transformation algorithm : for the bgn based scheme , this is linear both as a function of the number of packet fields and policies , reaching a maximum of 7,669 ms ( 30 fields and 10 policies ) and 3,831 ms ( 5 fields and 30 policies ) . however , note that these times are acceptable since this does not have to be executed in real - time but only once , during the setup .",
    "* peks based scheme . * in figures  [ fig : time_weak_attr ] and  [ fig : time_weak_policies ] , we report the execution times of the packet processing and decryption algorithms for the peks based scheme as a function of packet fields and number of policies . as the entry mb performs packet encryption and some preliminary packet processing , we divide the corresponding times between entry mb and cloud mb .",
    "note from figure  [ fig : time_weak_attr ] that packet processing ( both at entry mb and cloud mb ) as well as decryption are linear w.r.t .",
    "increasing number of packet fields , while packet processing at entry mb and decryption are constant w.r.t . increasing number of policies ( figure  [ fig : time_weak_policies ] ) . for a network function with 10 policies ,",
    "private processing of @xmath258 packet fields takes 77 ms at the entry mb , 157 ms at the cloud mb and 16 ms for decryption .",
    "finally , figures  [ fig : clientmb_attributes ] and [ fig : clientmb_policies ] show that the network function transformation algorithm for this scheme is linear both in the number of packet fields and policies , reaching a maximum of 341 ms and 184 ms , respectively .",
    "* comparison of the two schemes .",
    "* figures  [ fig : clientmb_attributes ] and  [ fig : clientmb_policies ] show the aggregate times of the two schemes ( by adding up the times of packet encryption , processing and decryption ) against increasing number of fields ( with @xmath257 policies ) and increasing number of policies ( with @xmath258 packet fields used for private processing ) .",
    "the peks based scheme clearly outperforms the bgn based scheme .",
    "for instance , for a network function with @xmath257 policies , private processing of @xmath258 packet fields takes 250 ms in the peks based scheme and 1,208 ms in the bgn based scheme .",
    "0.26   aggregate execution times ( packet encryption , processing and decryption ) for the two schemes.,title=\"fig : \" ]       0.26   aggregate execution times ( packet encryption , processing and decryption ) for the two schemes.,title=\"fig : \" ]    translated into packets per second ( pps ) , the above two numbers translate to a modest 4 pps and 0.82 pps , respectively . however , we remark that our implementation merely stands as a proof - of - concept , and as such we did not go for further implementation efficiency by using a more powerful machine or multi - threading in c. for instance , the time taken by the entry mb , the cloud mb and the client mb for a packet with a single encrypted field and a network function with a single policy was 13.32 ms , 5.41 ms and 2.69 ms , respectively , giving a total of 21.42 ms .",
    "using multi - threading we can process a larger number of packet fields ( in the case of the entry and client mb ) and the policies ( in the case of the cloud mb ) in parallel , thus increasing the number of packets processed per second . with a modestly more powerful machine that can process say 50 threads concurrently , we can achieve a rate of more than 2,300 pps ( using 21.42 ms as the baseline ) .    even without optimizations , e.g. , multi - threading , our performance is comparable to that of the schemes proposed by shi , zhang and zhong  @xcite .",
    "the three different _ modes _ in  @xcite yield 60 ms , 1,000 ms and 3,000 ms for private processing of a @xmath258-tuple with @xmath257 firewall rules .",
    "the bloom filter based scheme from khakpour and liu  @xcite does much better , achieving 0.1 ms for a 10 rule firewall . however , as described in section  [ sec : related ] , both these works are narrower in scope and their security , at best , is questionable .",
    "this paper addressed the problem of private processing of outsourced network functions , where network function policies need to be kept private from the cloud , other tenants and third parties .",
    "we presented a cryptographic treatment of the problem , introducing security definitions as well as an abstract model of generic network functions , and proposed a few instantiations using homomorphic encryption and public - key encryption with keyword search .",
    "the performance of our proposed solutions is reasonable considering that we rely on public key operations and provide provable security in the presence of an honest - but - curious cloud , while guaranteeing that third party users , who are sending / receiving traffic , are oblivious to network function outsourcing . in future work",
    ", we plan to investigate mechanisms to further speed up computation , e.g. , assuming that part of the cloud runs on a trusted computing base .",
    "we are also working on integrating our solutions for private nfv to existing nfv frameworks such as opnfv and clickos  @xcite .",
    "the following reductionist arguments will use policy  [ eq : equal - pol ] as the base .",
    "it is straightforward to extend the arguments to policy  [ eq : range - pol ] .",
    "we assume an fhe oracle which when given a plaintext @xmath128 returns the encryption @xmath259 , and when given two ciphertexts @xmath259 and @xmath163 returns @xmath260 .",
    "we use @xmath77 as a subroutine to an adversary @xmath261 that tries to subvert the fhe scheme .",
    "@xmath261 announces @xmath262 and @xmath263 as its chosen plaintexts .",
    "@xmath261 is given @xmath264 such that @xmath265 with probability @xmath266 , and is asked to guess @xmath16 .",
    "@xmath261 begins by choosing a @xmath267 and requesting the encryptions of @xmath268 , @xmath269 and @xmath163 from the fhe oracle .- element vector actually means asking the oracle for @xmath1 encryptions , once per element .",
    "for succinctness , we omit this detail . ]",
    "@xmath261 gives @xmath268 , @xmath269 , @xmath163 and @xmath264 to @xmath77 as the description of the transformed network function @xmath62 .",
    "note that this is essentially the policy @xmath270 during the test state , whenever @xmath77 asks for the result ( encryptions from packet processing ) of a packet @xmath5 under pnfv , @xmath261 does as follows .",
    "if @xmath271 , @xmath261 asks the fhe oracle for the encryptions of @xmath272 .",
    "it further requests the oracle for the encryption of @xmath13 , and upon receiving @xmath273 , asks for the encryption of @xmath274 .",
    "@xmath261 constructs the vector @xmath275 otherwise if @xmath276 , @xmath261 asks for the encryption of @xmath47 from the fhe oracle and @xmath277 is replaced with @xmath278 in the above vector .",
    "this vector is then given to @xmath77 .",
    "when @xmath77 submits its guess for @xmath37 as the tuple @xmath279 ( as a match - action pair ) , @xmath261 does as follows . if @xmath280 and @xmath281 , then @xmath261 outputs @xmath265 as its guess , i.e. , @xmath261 guesses that @xmath264 is the encryption of @xmath262 . otherwise , if @xmath280 and @xmath282 , then @xmath261 outputs @xmath283 , i.e. , @xmath261 guesses that @xmath264 is the encryption of @xmath263 . to see that this strategy works ,",
    "notice that if @xmath284 , the above policy is @xmath285 and if @xmath286 , the above policy is @xmath287 as required .",
    "the proof is similar to above with minor differences , which we highlight here . for network function transformation",
    ", @xmath261 asks the bgn oracle the encryption of @xmath288 zeros and constructs the vector @xmath289 it then asks the oracle for encryptions of @xmath290 , @xmath268 , @xmath163 and @xmath269 , and sends the tuple @xmath291 to @xmath77 as the description of the transformed network function . during the guess state of @xmath77 , whenever a packet @xmath5 is presented to @xmath261 , it asks the bgn oracle for the encryption of @xmath292 and labels the resulting encryption as @xmath293 ( note that if @xmath271 then the matching function is simply the encryption of @xmath14 ) . for the action function , @xmath261 asks the fhe oracle for the encryptions of @xmath272 .",
    "it further requests the oracle for the encryption of @xmath13 , and upon receiving @xmath273 , asks for the encryption of @xmath274 . @xmath261 constructs the vector @xmath294 finally @xmath261 asks the bgn oracle for the encryption of @xmath60 .",
    "it sends @xmath60 , @xmath293 and @xmath177 to @xmath77 .",
    "if the probabilistic encryption scheme @xmath26 is semantically secure , the peks scheme is semantically secure against the chosen keyword ( plaintext ) attack , its trapdoor function @xmath144 is not invertible , and the pseudorandom permutation @xmath147 is indistinguishable from a random permutation , then the pnfv scheme described in section  [ sub : weak - peks ] is private against @xmath78 .",
    "* @xmath295 : the pnfv scheme described in section  [ sub : weak - peks ] is private against @xmath78 . * @xmath296 : the probabilistic encryption scheme @xmath26 is semantically secure .",
    "* @xmath297 : the peks scheme is semantically secure against the chosen keyword ( plaintext ) attack and the trapdoor function @xmath144 is not invertible . * @xmath298 : the pseudorandom permutation @xmath147 is indistinguishable from a random permutation .",
    "then it follows that : @xmath305 that is , the pnfv scheme is not private if @xmath78 knows any of the aforementioned tuples .",
    "the claim states that @xmath306 or equivalently @xmath307 in the following , in a series of `` games '' we show that for @xmath308 and @xmath309 , @xmath310 the conjunction of the above propositions is equivalent to proposition  [ eq : log - neg ] , since @xmath311 where we have implicitly used the tautology @xmath312 . for notational convenience , we shall use @xmath313 to denote the permuted vector after the application of the permutation @xmath147 . on the other hand",
    ", @xmath314 shall denote the permutation of single element @xmath315 under @xmath147 .",
    "we shall denote by @xmath195 the vector of indexes @xmath31 .",
    "the notation @xmath316 denotes the vector whose @xmath317th element is @xmath318 .",
    "_ suppose @xmath297 and @xmath298 hold",
    ". then if @xmath78 learns the tuple @xmath300 in the pnfv scheme , then the probabilistic encryption scheme @xmath26 is not semantically secure , i.e. , @xmath319 .",
    "we construct an adversary @xmath320 that uses @xmath78 as a subroutine .",
    "@xmath320 issues the challenger with @xmath321 and @xmath322 as the two plaintexts it wants to be challenged on .",
    "let @xmath323 and @xmath324 .",
    "the challenger returns @xmath264 to @xmath261 such that @xmath265 with probability @xmath266 .",
    "@xmath320 samples two uniform random bit strings with length equal to the range of the trapdoor function @xmath144 , and labels these values @xmath325 and @xmath326 .",
    "note that these are not actual trapdoors , but random values ( dummy trapdoors ) simulating the behaviour of a non - invertible trapdoor .",
    "@xmath327 gives @xmath264 , @xmath325 and @xmath326 to @xmath78 .",
    "whenever @xmath78 asks for new packet encryptions , @xmath320 samples a packet @xmath5 from the public distribution @xmath328 .",
    "if @xmath271 for a predetermined and fixed value of @xmath213 , @xmath320 asks the @xmath26 oracle for @xmath288 encryptions of @xmath329 such that @xmath330 , and an encryption of @xmath13 followed by the encryption of @xmath331 , and constructs @xmath332 , such that @xmath333 .",
    "@xmath261 then randomly generates a permutation @xmath147 and permutes @xmath332 obtaining @xmath334 . note that this permutation @xmath147 is generated by @xmath261 itself .",
    "@xmath261 also generates @xmath335 random bit strings of size equal to the range of @xmath132 .",
    "@xmath1 of these values are used to simulate @xmath336 , and the other @xmath1 to simulate @xmath203 .",
    "@xmath261 gives these permuted encryptions to @xmath78 . to simulate the @xmath337 routine ,",
    "if @xmath271 , @xmath320 gives @xmath338 and @xmath339 to @xmath78 , i.e. , the permuted indexes corresponding to the match and action .",
    "@xmath320 further replaces @xmath340 with @xmath341 in @xmath342 , and gives the resultant @xmath342 to @xmath78 .",
    "otherwise it simply gives @xmath342 to @xmath78 ( without replacing @xmath340 ) . when @xmath78 outputs @xmath343 as its guess for the policy , @xmath261 outputs @xmath13 if @xmath281 ; otherwise if @xmath344 , @xmath261 outputs @xmath14",
    ".    _ game 2 .",
    "_ suppose @xmath296 and @xmath298 hold . then if @xmath78 learns the tuple @xmath302 in the pnfv scheme , then the peks scheme is not semantically secure against the chosen keyword ( plaintext ) attack or the trapdoor function @xmath144 is invertible , i.e. , @xmath345 .",
    "_ game 2.1 .",
    "_ suppose @xmath144 is not invertible , then if @xmath78 learns the tuple @xmath346 in the pnfv scheme , the peks scheme is not semantically secure against the chosen keyword ( plaintext ) attack .",
    "we consider an adversary @xmath320 who chooses @xmath347 and @xmath348 as two chosen keywords ( plaintexts ) and is given @xmath349 such that @xmath265 with probability @xmath266 .",
    "@xmath320 has to guess @xmath16 .",
    "it can ask the challenger for further encryptions of any plaintext .",
    "@xmath320 is also given access to two instances of @xmath337 oracle ; one , labelled @xmath350 , instantiated with the trapdoor @xmath351 and the other , labelled @xmath352 , with the trapdoor @xmath199 , where @xmath214 is chosen by @xmath320 .",
    "note that @xmath320 is not given the trapdoor values themselves .",
    "we assume an oracle @xmath353 which when invoked , generates a random @xmath5 according to the distribution @xmath328 , and outputs @xmath354 , @xmath336 and @xmath355 , where @xmath354 is a vector of @xmath1 random bit strings each of length equal to the range of @xmath26 and @xmath147 is a ( truly ) random permutation .",
    "more specifically , @xmath353 is also given oracle access to @xmath132 .",
    "our adversary @xmath320 again uses @xmath78 for the rescue .",
    "it chooses @xmath356 and @xmath357 as its two chosen plaintexts . upon receiving @xmath349 , it generates two random bit strings of length equal to the range of @xmath144 .",
    "one of these simulates @xmath351 and the other @xmath358 .",
    "@xmath320 initializes the @xmath352 oracle with @xmath359 .",
    "@xmath320 also samples a bit string uniformly at random to simulate @xmath360 ( with length equal to the range of @xmath26 ) .",
    "it gives these simulations of @xmath361 , @xmath362 and @xmath360 to @xmath78 . in the testing phase ,",
    "@xmath320 queries the @xmath353 oracle and obtains @xmath363 , @xmath336 and @xmath355 as a result , and duly sends them to @xmath78 .",
    "it also runs the @xmath350 oracle to determine if there is a match , and if yes replaces the value in @xmath354 corresponding to the output of the oracle @xmath352 with @xmath360 .",
    "when @xmath78 outputs @xmath364 , @xmath320 outputs @xmath265 if @xmath365 .",
    "else if @xmath366 , @xmath320 outputs @xmath283 .    _ game 2.2 .",
    "_ suppose the peks scheme is semantically secure against the chosen keyword ( plaintext ) attack , then if @xmath78 learns the tuple @xmath302 in the pnfv scheme , the trapdoor function @xmath144 is invertible .",
    "this is similar to above .",
    "this time , instead of @xmath349 , @xmath320 is given @xmath351 .",
    "note that if @xmath144 is invertible , then finding @xmath16 is straightforward .",
    "@xmath320 chooses @xmath356 and @xmath357 as before , and further asks for the trapdoor of @xmath367 and gets @xmath326 as a result ( where @xmath359 is the instantiation of @xmath214 ) .",
    "@xmath320 can ask for any further trapdoors pertaining to the condition that the keyword should not equal @xmath347 or @xmath348 .",
    "we now also have an oracle @xmath132 which upon asked for the encryption of some plaintext @xmath128 returns a uniform random value in the range of @xmath132 .",
    "the oracle keeps the record of the value of @xmath368 against @xmath128 in a table .",
    "this oracle can also be accessed by the @xmath353 oracle and the @xmath337 oracle ( we have only one @xmath337 oracle this time ) . at the end ,",
    "@xmath320 checks the output of @xmath78 obtained as @xmath364 , and returns the bit @xmath16 as before .",
    "_ suppose @xmath296 and @xmath297 hold .",
    "then if @xmath78 learns the tuple @xmath304 in the pnfv scheme , then the pseudorandom permutation @xmath147 is distinguishable from a random permutation , i.e. , @xmath369 .",
    "we assume the following challenge game between @xmath320 and @xmath147 .",
    "@xmath320 can invoke @xmath147 as many times as it wants by making a call with the query `` next ` ' .",
    "each such call will be called an iteration of @xmath147 .",
    "note that before the first call , it is presumed that @xmath147 is in the identity configuration , i.e. , @xmath370 .",
    "@xmath320 can choose an integer @xmath371 and give it to the challenger .",
    "the challenger chooses another integer @xmath372 such that @xmath373 , which @xmath320 has to guess . for each oracle call to @xmath147",
    ", @xmath320 can ask for the permutation of the fixed integer @xmath112 as well as @xmath374 ( i.e. , the permuted value of the unknown integer @xmath120 ) .",
    "@xmath320 has to determine @xmath120 .",
    "note that if @xmath147 is indistinguishable from a random permutation then the guess of @xmath320 should be no better than @xmath375 .",
    "suppose @xmath320 chooses @xmath376 .",
    "@xmath320 gives random values to the adversary @xmath78 to substitute @xmath377 , @xmath199 , @xmath360 , @xmath354 , @xmath336 and @xmath355 , where the packet @xmath5 is generated by @xmath320 according to the public distribution @xmath80 .",
    "whenever @xmath271 , @xmath320 invokes @xmath147 , and asks for @xmath338 and @xmath374 .",
    "@xmath320 then replaces @xmath378 with @xmath360 .",
    "whenever @xmath78 outputs @xmath379 , @xmath320 outputs @xmath380 ."
  ],
  "abstract_text": [
    "<S> aiming to reduce the cost and complexity of maintaining networking infrastructures , organizations are increasingly outsourcing their network functions ( e.g. , firewalls , traffic shapers and intrusion detection systems ) to the cloud , and a number of industrial players have started to offer network function virtualization ( nfv)-based solutions . </S>",
    "<S> alas , outsourcing network functions in its current setting implies that sensitive network policies , such as firewall rules , are revealed to the cloud provider . in this paper , we investigate the use of cryptographic primitives for processing outsourced network functions , so that the provider does not learn any sensitive information . </S>",
    "<S> more specifically , we present a cryptographic treatment of privacy - preserving outsourcing of network functions , introducing security definitions as well as an abstract model of generic network functions , and then propose a few instantiations using partial homomorphic encryption and public - key encryption with keyword search . </S>",
    "<S> we include a proof - of - concept implementation of our constructions and show that network functions can be privately processed by an untrusted cloud provider in a few milliseconds . </S>"
  ]
}