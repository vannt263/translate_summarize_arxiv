{
  "article_text": [
    "finite automata on infinite trees are one of the basic tools in the verification of non - terminating programs .",
    "practical applicability of this approach relies on the simplicity of the automata used to express the specifications . on the other hand",
    "it is convenient to write the specifications in an expressive language , e.  g.  @xmath0-calculus .",
    "this motivates the search for automatic simplifications of automata .",
    "an efficient , yet reasonably expressive , model is offered by weak alternating automata .",
    "it was essentially showed by rabin @xcite that a language @xmath1 can be recognized by a weak automaton if and only if both @xmath1 and @xmath2 can be recognized by nondeterministic bchi automata .",
    "arnold and niwiski @xcite proposed an algorithm that , given two bchi automata recognizing a language and its complement , constructs a doubly exponential alternation free @xmath0-calculus formula defining @xmath1 , which essentially provides an equally effective translation to a weak automaton .",
    "kupferman and vardi @xcite gave an immensely improved construction that involves only quadratic blow - up .",
    "a more refined construction could also simplify an automaton in terms of different complexity measures .",
    "a measure that is particularly important for theoretical and practical reasons is the mostowski ",
    "rabin index .",
    "this measure reflects the alternation depth of positive and negative events in the behaviour of a verified system .",
    "the index orders automata into a hierarchy that was proved strict for deterministic @xcite , nondeterministic @xcite , alternating @xcite , and weak alternating automata @xcite . computing the least possible index for a given automaton",
    "is called the index problem . unlike for @xmath3-words , where the solution was essentially given already by wagner @xcite , for trees",
    "this problem in its general form remains unsolved . for deterministic languages ,",
    "niwiski and walukiewicz gave algorithms to compute the deterministic and nondeterministic indices @xcite .",
    "the theoretical significance of the weak index is best reflected by its coincidence with the quantifier alternation depth in the weak monadic second order logic @xcite .",
    "further interesting facts are revealed by the comparison with the borel rank . in 1993",
    "skurczyski gave examples of @xmath4 and @xmath5-complete languages recognized by weak alternating automata with index @xmath6 and @xmath7 accordingly @xcite .",
    "in @xcite it was shown that weak @xmath6-automata can only recognize @xmath4 languages ( and dually , @xmath7-automata can only recognize @xmath5 languages ) , and it was conjectured that the weak index and the borel hierarchies actually coincide .",
    "here we prove that the conjecture holds for deterministic languages .",
    "consequently , the algorithm calculating the borel rank for deterministic languages @xcite can be also used to compute the weak index .",
    "since all deterministic languages are at the first level of the alternating hierarchy , this completes the picture for the deterministic case .",
    "we also provide an effective translation to a weak automaton with a quadratic number of states and the minimal index .",
    "we will be working with deterministic and weak automata , but to have a uniform framework , we first define automata in their most general alternating form .",
    "a _ parity game _ is a perfect information game of possibly infinite duration played by two players , adam and eve .",
    "we present it as a tuple @xmath8 , where @xmath9 and @xmath10 are ( disjoint ) sets of positions of eve and adam , respectively , @xmath11 is the relation of possible moves , with @xmath12 , @xmath13 is a designated initial position , and @xmath14 is the ranking function .",
    "the players start a play in the position @xmath15 and then move a token according to relation @xmath16 ( always to a successor of the current position ) , thus forming a path in the graph @xmath17 .",
    "the move is selected by eve or adam , depending on who is the owner of the current position .",
    "if a player can not move , she / he looses .",
    "otherwise , the result of the play is an infinite path in the graph , @xmath18 .",
    "eve wins the play if the highest rank visited infinitely often is even , otherwise adam wins .    an _ alternating automaton _",
    "@xmath19 , consists of a finite input alphabet @xmath20 , a finite set of states @xmath21 partitioned into existential states @xmath22 and universal states @xmath23 with a fixed initial state @xmath24 , a transition relation @xmath25 , and a ranking function @xmath26 . instead of @xmath27 , one usually writes @xmath28 .",
    "an input tree @xmath29 is accepted by @xmath30 iff eve has a winning strategy in the parity game @xmath31 , where @xmath32 and @xmath33 .",
    "the computation tree of @xmath30 on @xmath29 is obtained by unravelling the graph above from the vertex @xmath34 and labelling the node @xmath35 with @xmath36 .",
    "the result of the parity game above only depends on the computation tree .",
    "an automaton is called _ deterministic _ iff eve has no choice at all , and adam can only choose the direction : left or right ( no @xmath37-moves ) .",
    "formally , it means that @xmath38 , and @xmath39 . for deterministic automata ,",
    "the computation tree is a full binary tree .",
    "the transitions are often written as @xmath40 , meaning @xmath41 for @xmath42 .",
    "a _ weak automaton _ is an alternating automaton satisfying the condition @xmath43 a more elegant definition of the class of weakly recognizable languages is obtained by using _",
    "weak parity games _ in the definition of acceptance by alternating automata . in those games",
    "eve wins a play if the highest rank used at least once is even . for the purpose of the following lemma , let us call the first version _ restricted alternating automata_. later , we will stick to the second definition .",
    "for every @xmath1 it holds that @xmath1 is recognized by a restricted alternating @xmath44-automaton iff it is recognized by a weak alternating @xmath44-automaton .    every restricted automaton can be transformed into an equivalent weak automaton by simply changing the acceptance condition to weak .",
    "let us , then , concentrate on the converse implication .",
    "fix a weak automaton @xmath30 using ranks @xmath45 . to construct a restricted automaton",
    "we will take one copy of @xmath30 for each rank : @xmath46 .",
    "by @xmath47 we will denote the counterpart of @xmath30 s state @xmath48 in @xmath49 .",
    "we set @xmath50 .",
    "we want the number of the copy the computation is in to reflect the highest rank seen so far . to obtain that , we set the initial state of the new automaton to @xmath51 , and for each @xmath52 and each transition @xmath53 in @xmath30 we add a transition @xmath54 . for each @xmath52 and @xmath48",
    ", @xmath47 is universal iff @xmath48 is universal . checking the equivalence is straightforward .",
    "for deterministic automata we will assume that all states are productive , i.  e. , are used in some accepting run , save for one all - rejecting state @xmath55 , and that all transitions are productive or go to @xmath55 , i.  e. , whenever @xmath56 , then either @xmath57 and @xmath58 are productive , or @xmath59 .",
    "the assumption of productivity is vital for our proofs .",
    "thanks to this assumption , in each node of an automaton s run we can plug in an accepting sub - run .    transforming a given automaton into such a form of course",
    "needs calculating the productive states , which is equivalent to deciding a language s emptiness .",
    "the latter problem is known to be in @xmath60 , but it has no polynomial solutions yet .",
    "therefore we can only claim that our algorithms are polynomial for the automata that underwent the above preprocessing .",
    "we will try to mention it whenever particularly important .",
    "the _ index of an automaton _",
    "@xmath30 is a pair @xmath61 . scaling down the rank function if necessary",
    ", one may assume that @xmath62 is either 0 or 1 .",
    "thus , the indices are elements of @xmath63 . for an index @xmath44 we shall denote by @xmath64 _ the dual index _ , i.  e. , @xmath65 , @xmath66 .",
    "let us define an ordering of indices with the following formula : @xmath67 in other words , one index is greater than another if and only if it `` uses '' more ranks .",
    "this means that dual indices are incomparable . _",
    " rabin index hierarchy _ for a certain class of automata consists of ascending sets ( levels ) of languages recognized by @xmath44-automata .    here",
    ", we are mainly interested in the _ weak index hierarchy _ , i.  e. , the hierarchy of languages recognized by weak @xmath44-automata .",
    "the strictness of this hierarchy was established by mostowski @xcite via equivalence with the quantifier - alternation hierarchy for the weak monadic second order logic , whose strictness was proved by thomas @xcite .",
    "the _ weak index problem _ , i.  e. , computing the minimal weak index needed to recognize a given weak language , for the time being remains unsolved just like other versions of the index problem .",
    "the weak index hierarchy is closely related to the borel hierarchy .",
    "we will work with the standard cantor - like topology on @xmath68 induced by the metric @xmath69 the class of borel sets of a topological space @xmath70 is the closure of the class of open sets of @xmath70 by countable sums and complementation .",
    "for a topological space @xmath70 , the initial ( finite ) levels of the _ borel hierarchy _ are defined as follows :    * @xmath71  open subsets of @xmath70 , * @xmath72  complements of the sets from @xmath73 , * @xmath74  countable unions of sets from @xmath72 .",
    "for instance , @xmath75 are the closed sets , @xmath76 are @xmath77 sets and @xmath78 are @xmath79 sets . by convention @xmath80 and @xmath81 .",
    "a straightforward inductive argument shows that the classes defined above are closed under inverse images of continuous functions .",
    "let @xmath82 be one of those classes .",
    "a set @xmath30 is called _ @xmath82-hard _ , if each set in @xmath82 is an inverse image of @xmath30 under some continuous function . if additionally @xmath83",
    ", @xmath30 is _",
    "@xmath82-complete_.    we start the discussion of the relations between the index of a weak automaton and the borel rank of the language it recognises by recalling skurczyski s results . for a tree @xmath84 and a node @xmath85",
    "let @xmath86 denote the tree rooted in @xmath87 , i. e. , @xmath88 .",
    "let us define a sequence of languages :    * @xmath89 , where @xmath90 is the tree with no @xmath91 s , * @xmath92 for @xmath93 , * @xmath94 for @xmath93 .    for each @xmath93 ,",
    "* @xmath95 is a @xmath4-complete language recognized by a weak @xmath6-automaton , * @xmath96 is a @xmath5-complete language recognized by a weak @xmath7-automaton .",
    "we will now show that this construction is as efficient as it can be : ranks @xmath6 are necessary to recognize any @xmath4-hard language ( if it can be weakly recognized at all ) .",
    "we will actually prove a  bit stronger result .",
    "we will consider _ weak game languages _",
    "@xmath97}$ ] , to which all languages recognized by weak @xmath98$]-automata can be reduced , and show that @xmath99 } \\in \\pi^0_n$ ] and @xmath100 } \\in \\sigma^0_n$ ] ( by skurczyski s results , they are hard for these classes ) .",
    "the languages @xmath97}$ ] are natural weak counterparts of strong game languages that prove the strictness of the strong alternating index hierarchy .",
    "lately arnold and niwiski proved that the strong game languages also form a  strict hierarchy with respect to continuous reductions , but they are all non - borel @xcite .",
    "fix a natural number @xmath101 . for",
    "@xmath102 and @xmath103 , let @xmath104 denote the set of full @xmath101-ary trees over the alphabet @xmath105 .",
    "let @xmath106 be the set of all trees @xmath29 for which eve has a  winning strategy in the _ weak _ parity game @xmath107 , where @xmath108 , @xmath109 , @xmath110 , @xmath111 iff @xmath112 for some @xmath113 .",
    "[ weakgamelang ] for each @xmath114 , @xmath115 and @xmath116",
    ".    we will proceed by induction on @xmath114 . for @xmath117",
    "the claim is obvious : @xmath118 , @xmath119 .",
    "take @xmath120 . for each @xmath121",
    "there exists a strategy @xmath122 for eve , such that it guarantees that the play reaches a node with the rank greater or equal to @xmath123 .",
    "by knig lemma , this must happen in a bounded number of moves .",
    "basing on this observation we will provide a @xmath5 presentation of @xmath124 .",
    "@xmath125-antichain _ be a subset of the nodes on the level @xmath125 .",
    "let @xmath126 denote the set of all possible @xmath125-antichains for all @xmath127 .",
    "obviously this set is countable . for a @xmath125-antichain @xmath30 let @xmath128 denote the set of trees such that there exists a strategy for eve that guarantees visiting a node with the rank @xmath129 during the initial @xmath125 moves and reaching a node from @xmath30",
    "this set is a clopen .",
    "we have a presentation @xmath130 where @xmath131 is obtained from @xmath29 by decreasing all the ranks by @xmath123 ( if the result is @xmath132 , take @xmath133 ) .",
    "the claim follows by induction hypothesis and the continuity of @xmath134 and @xmath135 .",
    "now , it remains to see that @xmath136 .",
    "for this , note that @xmath137 where @xmath138 is obtained from @xmath29 by swapping @xmath139 and @xmath140 , and increasing ranks by 1 .",
    "the claim follows by the continuity of @xmath141 .    as a  corollary we get the promised improvement of skurczyski s result .",
    "[ weakborel ] for every weak alternating automaton @xmath30 with index @xmath6 ( resp .",
    "@xmath7 ) it holds that @xmath142 ( resp .",
    "@xmath143 ) .",
    "let @xmath30 be an automaton with priorities inside @xmath98 $ ] . for sufficiently large @xmath101 we may assume without loss of generality that the computation trees of the automaton are @xmath101-ary trees . by assigning to an input tree the run of @xmath30 , one obtains a  continuous function reducing @xmath144 to @xmath145 .",
    "hence , the claim follows from the theorem above .",
    "in fact the corollary follows also from mostowski s theorem on equivalence of weak automata and weak monadic second order logic on trees @xcite .",
    "the present proof of theorem [ weakgamelang ] is actually just a repetition of mostowski s proof in the setting of the borel hierarchy .",
    "an entirely different proof can be found in @xcite .",
    "we believe that the converse implication is also true : a weakly recognizable @xmath4-language can be recognized by a weak @xmath6-automaton ( and dually for @xmath5 ) .    for weakly recognizable languages",
    "the weak index hierarchy and the borel hierarchy coincide .    in this paper",
    "we show that the conjecture holds true when restricted to deterministic languages .",
    "in 2002 niwiski and walukiewicz discovered a surprising dichotomy in the family of deterministic languages : a deterministic language is either very simple or very sophisticated .",
    "[ topgap ] for a deterministic automaton @xmath30 with @xmath114 states , @xmath144 is either recognizable with a weak alternating @xmath146-automaton with @xmath147 states ( and so @xmath148 ) or is non - borel ( and so not weakly recognizable ) . the equivalent weak automaton can be constructed within the time of solving the emptiness problem .",
    "@xmath149    an important tool used in the proof of the gap theorem ( theorem [ topgap ] ) is the technique of difficult patterns . in the topological",
    "setting the general recipe goes like this : for a given class identify a pattern that can be unravelled to a language complete for this class ; if an automaton does not contain the pattern , then @xmath144 should be in the dual class . the same technique was later applied to obtain effective characterisations of the remaining borel classes of deterministic languages @xcite .",
    "let us define the patterns used in these characterisations .",
    "loop _ in an automaton is a sequence of states and transitions : @xmath150 a loop is called _ accepting _ if @xmath151 is even .",
    "otherwise it is _",
    "rejecting_.    a _ @xmath44-flower _ is a sequence of loops @xmath152 starting in the same state @xmath153 , such that the highest rank appearing on @xmath154 has the same parity as @xmath52 and it is higher than the highest rank on @xmath155 for @xmath156 .",
    "a _ weak @xmath44-flower _ is a sequence of loops @xmath157 such that @xmath158 is reachable from @xmath154 , and @xmath154 is accepting iff @xmath52 is even .    a _ split _",
    "is a pair of loops @xmath159 and @xmath160 such that the highest ranks occurring on them are of different parity and the highest one is odd .",
    "a state @xmath48 is _ replicated _ by a loop @xmath161 if there exists a path @xmath162 such that @xmath163 .",
    "we will say that a loop or a flower is replicated by a loop @xmath164 if it contains a state replicated by @xmath164 .",
    "[ hardborel ] let @xmath30 be a deterministic automaton .    1 .",
    "@xmath165 iff @xmath30 contains no weak @xmath166-flower .",
    "2 .   @xmath167 iff @xmath30 contains no weak @xmath168-flower .",
    "@xmath169 iff @xmath30 contains no @xmath168-flower .",
    "4 .   @xmath170 iff @xmath30 contains neither @xmath166-flower nor a weak @xmath166-flower replicated by an accepting loop .",
    "@xmath171 iff @xmath30 contains no @xmath168-flower replicated by an accepting loop . 6 .",
    "@xmath172 iff @xmath30 contains no split .    in particular , the borel rank of @xmath144 is computable within the time of finding the productive states of @xmath30 .    the patterns defined above were originally introduced to capture the index complexity of recognizable languages .",
    "niwiski and walukiewicz used flowers to solve the deterministic index problem for word languages @xcite . their result may easily be adapted to trees ( see @xcite for details ) .",
    "[ indch ] for a deterministic tree automaton @xmath30 the language @xmath144 is recognized by a deterministic @xmath44-automaton iff @xmath30 does not contain a @xmath173-flower . an equivalent minimal index automaton with the same number of states",
    "can be constructed within the time of solving the emptiness problem .",
    "the weak flowers provide an analogous characterisation of the weak deterministic index .",
    "[ windch ] a deterministic automaton @xmath30 is equivalent to a weak deterministic @xmath44-automaton iff it does not contain a weak @xmath173-flower .",
    "an equivalent minimal index automaton with the same number of states can be constructed within the time of solving the emptiness problem .",
    "if the automaton contains a weak @xmath44-flower , for each weak @xmath173-automaton one can build a cheating tree ( see @xcite for details ) .",
    "for the converse implication , construct a weak deterministic @xmath44-automaton by modifying the ranks of the given deterministic automaton .",
    "set @xmath174 to the lowest number @xmath175 such that there exists a weak @xmath176-flower with a path from @xmath48 to @xmath177 .",
    "in this section we finally turn to the weak recognizability of deterministic languages . first we give sufficient conditions for a deterministic automaton to be equivalent to a weak alternating automaton of index @xmath178 , @xmath179 , and @xmath180 .",
    "this is the first step to the solution of the weak index problem for deterministic automata .",
    "[ weak02 ] for each deterministic @xmath166-automaton with @xmath114 states one can construct an equivalent weak @xmath178-automaton with @xmath181 states .    fix a deterministic @xmath166-automaton @xmath30 .",
    "we will construct a weak @xmath178-automaton @xmath182 such that @xmath183 .",
    "basically , for each node @xmath87 the automaton @xmath182 should check whether on each path in the subtree rooted in @xmath87 the automaton @xmath30 will reach a state with rank 2 .",
    "this can be done as follows .",
    "take two copies of @xmath30 . in the first copy ,",
    "all states are universal and have rank 0 .",
    "the transitions are like in @xmath30 plus for each state @xmath184 there is an @xmath37-transition to @xmath185 , the counterpart of @xmath184 in the second copy . in the second copy all states are universal and have rank 1 . for the states with rank 1 in @xmath30 , the transitions are like in @xmath30 . for the states with rank 2 in @xmath30 , there is just one transition to an all - accepting state @xmath186 ( rank 2 in @xmath182 ) .    before we proceed with the conditions , let us show a useful property of the replication .",
    "[ replicationlemma ] a state occurs in infinitely many incomparable nodes of an accepting run iff it is productive and is replicated by an accepting loop .",
    "if a state @xmath153 is replicated by an accepting loop , then by productivity one may easily construct an accepting run with infinitely many incomparable occurrences of @xmath153 .",
    "let us concentrate on the converse implication .",
    "let @xmath153 occur in an infinite number of incomparable nodes @xmath187 of an accepting run @xmath188 .",
    "let @xmath189 be a path of @xmath188 going through the node @xmath190 .",
    "since @xmath191 is compact , we may assume , passing to a subsequence , that the sequence @xmath189 converges to a path @xmath192 . since @xmath190 are incomparable , @xmath190 is not on @xmath192 .",
    "let the word @xmath193 be the sequence of states labeling the path from the last common node of @xmath192 and @xmath189 to @xmath190 .",
    "cutting the loops off if needed , we may assume that @xmath194 for all @xmath195 .",
    "consequently , there exist a word @xmath196 repeating infinitely often in the sequence @xmath197 .",
    "moreover , the path @xmath192 is accepting , so the starting state of @xmath196 must lay on an accepting productive loop .",
    "this loop replicates @xmath153 .",
    "[ weak13 ] for each deterministic @xmath168-automaton with @xmath114 states which contains no weak @xmath166-flower replicated by an accepting loop one can construct effectively an equivalent weak @xmath179-automaton with @xmath198 states .",
    "let @xmath30 be a deterministic @xmath168-automaton which contains no weak @xmath166-flower replicated by an accepting loop .",
    "let us call a state of @xmath30 _ relevant _ if it has the highest rank on some loop .",
    "we may change the ranks of productive irrelevant states to @xmath133 , and assume from now on that all odd states are relevant .",
    "we claim that the odd states occur only finitely many times on accepting runs of @xmath30 .",
    "suppose that an odd state @xmath153 occurs infinitely many times in an accepting run @xmath188 .",
    "then it must occur in infinitely many incomparable nodes ( otherwise we would get a rejecting path ) . by the replication lemma @xmath153",
    "is replicated by an accepting loop . as @xmath153 is odd and relevant",
    ", it lies on some nontrivial rejecting loop .",
    "since @xmath153 is also productive , some accepting loop can be reached from @xmath153 .",
    "hence , @xmath30 contains a weak @xmath166-flower replicated by an accepting loop - a contradiction    now , we can easily construct a weak @xmath179-automaton recognising @xmath144 .",
    "intuitively , we will simulate @xmath30 and check if @xmath30 s odd states occur finitely many times .",
    "this can be done as follows .",
    "take three copies of @xmath30 . in the first copy",
    "all the states are universal and have rank 1 .",
    "the transitions are just like in @xmath30 , only they go to the second copy of @xmath30 . in the second copy of @xmath30 ,",
    "all the states are existential and have rank 1 . from each state",
    "@xmath185 there are two @xmath37-transitions to @xmath184 in the first copy and to @xmath199 in the third copy .",
    "finally , in the third copy of @xmath30 all the states are universal and have rank 2 .",
    "the transitions from the states ranked 0 in @xmath30 are just like in @xmath30 , and from the states ranked @xmath200 in @xmath30 they go to an all - rejecting state @xmath55 ( rank 3 in @xmath182 ) .",
    "it is easy to see that @xmath182 recognizes @xmath144 .",
    "[ weak14 ] for each automaton with @xmath114 states containing no @xmath168-flower replicated by an accepting loop one can construct an equivalent weak alternating @xmath180-automaton with @xmath147 states .",
    "let @xmath30 be an automaton without @xmath168-flower replicated by an accepting loop .",
    "consider the dag of strongly connected components of @xmath30.for each scc @xmath70 containing at least one loop we will construct a weak automaton @xmath201 recognising the languages of trees @xmath29 such that each path of @xmath30 s run on @xmath29 that enters @xmath70 either leaves @xmath70 or is accepting .",
    "obviously , the conjunction of such automata recognizes exactly @xmath144 .",
    "let us first consider components replicated by an accepting loop . by the hypothesis ,",
    "such a component must not contain a @xmath168-flower .",
    "therefore we may assume that @xmath70 only uses ranks 1 and 2 . to obtain @xmath201",
    "take a copy of @xmath30 .",
    "the states outside @xmath70 can be divided into three disjoint groups : those that can be reached from @xmath70 , those from which @xmath70 can be reached , and the rest .",
    "give the states from the first group the rank 4 , and the states from the second and third group the rank 2 .",
    "finally , following the method from proposition [ weak02 ] , replace x with an equivalent weak alternating subautomaton using ranks 2,3 , and 4 .",
    "the constructed automaton has @xmath202 states .",
    "the case of @xmath70 not replicated by an accepting loop is more tricky .",
    "the key property follows from the replication lemma .",
    "let @xmath203 denote the restriction of the run @xmath188 to the nodes labeled with a state from @xmath70 or having a descendant labeled with a state from @xmath70 . by the replication lemma",
    ", this tree has only finitely many branches ( some of them may be infinite ) .",
    "what @xmath201 should do is to guess a node @xmath87 on each path such that in the subtree rooted in @xmath87 , @xmath203 is either empty or consists of one infinite accepting branch . in the latter case",
    "we may additionally demand that on this infinite path the highest rank that ever occurs , occurs infinitely many times .",
    "@xmath201 consists of the component @xmath204 realising the guessing , the component @xmath205 checking that no path of the computation enters @xmath70 , and components @xmath206 for all ranks @xmath207 used in @xmath70 , which check that in a given subtree of the run @xmath188 there is exactly one branch of @xmath203 and that on this branch @xmath207 occurs infinitely often and no higher rank is used .    to construct @xmath204 ,",
    "take a copy of @xmath30 and declare all the states universal and set their ranks to @xmath200 .",
    "for each @xmath48 add a fresh existential state @xmath208 of rank @xmath200 with an @xmath37-transition to @xmath48 and either to @xmath209 if @xmath210 ( @xmath203 is empty ) or to @xmath211 for all @xmath207 if @xmath212 ( @xmath203 is one infinite accepting path ) . finally replace each transition @xmath213 with @xmath214 .",
    "the component @xmath205 is a copy of @xmath30 with all ranks equal @xmath123 , and the scc @xmath70 replaced with one all - rejecting state @xmath55 with rank @xmath215 .    finally , let us now describe the automaton @xmath206 .",
    "the automaton , staying in rank 2 , works its way down the input tree just like @xmath30 would , with the following modifications :    * if @xmath30 enters a state in @xmath70 with rank greater than @xmath207 , @xmath206 moves to an all rejecting state @xmath55 ( rank 3 ) , * if @xmath30 takes a transition exiting @xmath70 on both branches or staying in @xmath70 on both branches , @xmath206 moves to @xmath55 , * if @xmath30 takes a transition whose left branch leaves @xmath70 and the right branch stays inside , @xmath206 sends to the right a @xmath216-component looking for a state from @xmath70 with the rank @xmath207 , and moves on to the right subtree ( and symmetrically ) .    in order two",
    "see that @xmath206 does the job , it is enough to observe that if the @xmath216 component always succeeds to find a state from @xmath70 with the rank @xmath207 , then on the unique path that stays forever in @xmath70 the rank @xmath207 repeats infinitely often .",
    "the @xmath216-component of @xmath206 can be constructed in such a way that it has @xmath217 states , and so in this case @xmath201 has at most @xmath218 states .    in both cases ,",
    "the number of states of @xmath201 can be bounded by @xmath219 for fixed constants @xmath220 and @xmath221 , independent of @xmath70 .",
    "since the sccs are disjoint , the number of states of the conjunction of @xmath201 s is at most @xmath222    we have now collected all the ingredients for the solution of the weak index problem for deterministic languages .",
    "what is left to be done is to glue together the sufficient conditions for index easiness and borel hardness using corollary [ weakborel ] .    for deterministic languages the borel hierarchy and the weak index hierarchy coincide ( fig .",
    "[ fig : dethierarchy ] ) and are decidable within the time of solving emptiness problem . for a deterministic automaton with @xmath114 states , an equivalent minimal index automaton with @xmath147 states can be constructed effectively within the time of solving the emptiness problem .",
    "we will abuse the notation and write @xmath45 to denote the class of languages recognized by weak @xmath45-automata .",
    "all the classes considered here are relativised to the deterministic languages .    by the two versions of the gap theorem we have the equality and decidability of the classes of the classes @xmath148 and @xmath146 .",
    "let us continue with the third level .",
    "let us see that @xmath223 .",
    "we will show that both these classes are equal to the class of languages recognized by deterministic automata without a @xmath168-flower replicated by an accessible loop .",
    "if a deterministic automaton @xmath30 does not contain this pattern , then it is equivalent to a weak @xmath180-automaton and by corollary [ weakborel ] recognizes a @xmath224 language .",
    "if @xmath30 does contain this pattern , then by proposition [ hardborel ] it is not @xmath224 and so is not equivalent to a weak @xmath180-automaton .",
    "the decidability follows easily , since checking for the pattern above can be done effectively ( in polynomial time ) .    for the equality @xmath225 , prove that both classes are equal to the class of languages recognized by deterministic automata without a @xmath168-flower .",
    "proceed just like before , only use proposition [ weak02 ] instead of proposition [ weak14 ] .",
    "analogously , using proposition [ weak13 ] , show that both @xmath226 and @xmath179 are equal to the class of languages recognized by deterministic automata admitting neither a @xmath166-flower nor a weak @xmath227-flower replicated by an accepting loop .    for the first level use the characterisation given by proposition [ windch ] .",
    "the level zero is trivial .",
    "the author thanks damian niwiski for reading carefully a preliminary version of this paper and the anonymous referees for their helpful comments ."
  ],
  "abstract_text": [
    "<S> we investigate weak recognizability of deterministic languages of infinite trees . we prove that for deterministic languages the borel hierarchy and the weak index hierarchy coincide . </S>",
    "<S> furthermore , we propose a procedure computing for a deterministic automaton an equivalent minimal index weak automaton with a quadratic number of states . </S>",
    "<S> the algorithm works within the time of solving the emptiness problem .    </S>",
    "<S> filip murlak </S>"
  ]
}