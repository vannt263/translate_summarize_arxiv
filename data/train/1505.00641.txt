{
  "article_text": [
    "this work aims to facilitate research for matrix factorization based machine learning ( ml ) models .",
    "factorization machines are able to express many different latent factor models and are widely used for collaborative filtering tasks @xcite .",
    "an important advantage of fm is that the model equation @xmath0 @xmath1 conforms to the standard notation for vector based ml .",
    "fm learn a factorized coefficient @xmath2 for each feature pair @xmath3 ( eq . [ eq : fm ] ) .",
    "this makes it possible to model very sparse feature interactions , as for example , encoding a sample as @xmath4 yields @xmath5 which is equivalent to ( biased ) matrix factorization @xmath6 @xcite",
    ". please refer to @xcite for more encoding examples .",
    "fm have been the top performing model in various machine learning competitions @xcite with different objectives ( e.g. ` what do you know ? ' challenge , emi music hackathon ) . _",
    "_ fast__fmincludes solvers for regression , classification and ranking problems ( see table [ tab : solver ] ) and addresses the following needs of the research community : ( i ) easy interfacing for dynamic and interactive languages such as r , python and matlab ; ( ii ) a python interface allowing interactive work ; ( iii ) a publicly available test suite strongly simplifying modifications or adding of new features ; ( iv ) code is released under the * bsd - license * allowing the integration in ( almost ) any open source project .",
    "the _ _ fast__fmlibrary has a multi layered software architecture ( figure [ tab : architecture ] ) that separates the interface code from the performance critical parts ( _ _ fast__fm - core ) .",
    "the core contains the solvers , is written in c and can be used stand alone .",
    "two user interfaces are available : a command line interface ( cli ) and a python interface .",
    "cython @xcite is used to create a python extension from the c library . both , the python and c interface , serve as reference implementation for bindings to additional languages .",
    "l40 mm     cython & cli +   +      fm are usually applied to very sparse design matrices , often with a sparsity over 95 % , due to their ability to model interaction between very high dimensional categorical features .",
    "we use the standard compressed row storage ( crs ) matrix format as underlying data structure and rely on the cxsparse library @xcite for fast sparse matrix / vector operations .",
    "this simplifies the code and makes memory sharing between python and c straight forward .",
    "+ _ _ fast__fmcontains a test suite that is run on each commit to the github repository via a continuous integration server .",
    "solvers are tested using state of the art techniques , such as posterior quantiles @xcite for the mcmc sampler and finite differences for the sgd based solvers .      _",
    "_ fast__fmprovides a range of solvers for all supported tasks ( table [ tab : solver ] ) .",
    "the mcmc solver implements the bayesian factorization machine model @xcite via gibbs sampling .",
    "we use the pairwise bayesian personalized ranking ( bpr ) loss @xcite for ranking .",
    "more details on the classification and regression solvers can be found in @xcite .",
    ".supported solvers and tasks [ cols=\"<,<,<\",options=\"header \" , ]      the python interface is compatible with the api of the widely - used scikit - learn library @xcite which opens the library to a large user base .",
    "the following code snippet shows how to use mcmc sampling for an fm classifier and how to make predictions on new data .",
    "[ source , python ] ---- fm = mcmc.fmclassification(init_std=0.01 , rank=8 ) y_pred = fm.fit_predict(x_train , y_train , x_test ) ----    _ _ fast__fmprovides additional features such as warm starting a solver from a previous solution ( see mcmc example ) .",
    "[ source , python ] ---- fm = als.fmregression(init_std=0.01 , rank=8 , l2_reg=2 ) fm.fit(x_train , y_train ) ----",
    "libfm is the reference implementation for fm and the only one that provides als and mcmc solver .",
    "our experiments show , that the als and mcmc solver in _ _ fast__fmcompare favorable to libfm with respect to runtime ( figure [ fig : comparision ] ) and are indistinguishable in terms of accuracy .",
    "the experiments have been conducted on the movielens 10 m data set using the original split with a fixed number of 200 iterations for all experiments .",
    "the x - axis indicates the number of latent factors ( rank ) , and the y - axis the runtime in seconds .",
    "the plots show that the runtime scales linearly with the rank for both implementations .",
    "the code snippet below shows how simple it is to write python code that allows model inspection after every iteration .",
    "the induced python function call overhead occurs only once per iteration and is therefore neglectable .",
    "this feature can be used for bayesian model checking as demonstrated in figure [ fig : mcmc_trace ] .",
    "the figure shows mcmc summary statistics for the first order hyper parameter @xmath7 .",
    "please note that the mcmc solver uses gaussian priors for the model parameter @xcite .",
    "[ source , python ] ----      fm = mcmc.fmregression(n_iter=0 )      # initialize coefficients      fm.fit_predict(x_train , y_train , x_test )        for i in range(number_of_iterations ) :          y_pred = fm.fit_predict(x_train , y_train , x_test , n_more_iter=1 )          # save , or modify ( hyper ) parameter          print(fm.w _ , fm.v _ , fm.hyper_param_ ) ----    many other analyses and experiments can be realized with a few lines of python code without the need to read or recompile the performance critical c code .",
    "0.48        0.48",
    "factorization machines are available in the large scale machine learning libraries graphlab @xcite and bidmach @xcite .",
    "the toolkit svdfeatures by @xcite provides a general mf model that is similar to a fm .",
    "the implementations in graphlab , bidmach and svdfeatures only support sgd solvers and do nt provide a ranking loss .",
    "it s not our objective to replace these distributed machine learning frameworks : but to be provide a fm implementation that is easy to use and easy to extend without sacrificing performance ."
  ],
  "abstract_text": [
    "<S> factorization machines ( fm ) are currently only used in a narrow range of applications and are not yet part of the standard machine learning toolbox , despite their great success in collaborative filtering and click - through rate prediction . however , factorization machines are a general model to deal with sparse and high dimensional features . </S>",
    "<S> our factorization machine implementation ( _ _ fast__fm ) provides easy access to many solvers and supports regression , classification and ranking tasks . </S>",
    "<S> such an implementation simplifies the use of fm for a wide range of applications . </S>",
    "<S> therefore , our implementation has the potential to improve understanding of the fm model and drive new development .    </S>",
    "<S> python , mcmc , matrix factorization , context - aware recommendation </S>"
  ]
}