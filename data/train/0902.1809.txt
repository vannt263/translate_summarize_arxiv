{
  "article_text": [
    "graph transformation  @xcite is becoming increasingly popular in order to describe system behaviour due to its graphical , declarative and formal nature .",
    "for example , it has been used to describe the operational semantics of domain specific visual languages ( dsvls )  @xcite , taking the advantage that it is possible to use the concrete syntax of the dsvl in the rules , which then become more intuitive to the designer .",
    "the main formalization of graph transformation is the so called algebraic approach  @xcite , which uses category theory in order to express the rewriting step .",
    "prominent examples of this approach are the double  @xcite and single  @xcite pushout ( dpo and spo ) , which have developed interesting analysis techniques , for example to check sequential and parallel independence between pairs of rules  @xcite , or to calculate critical pairs  @xcite .    frequently , graph transformation rules are equipped with _ application conditions _ ( acs )  @xcite , stating extra ( i.e. in addition to the left hand side ) positive and negative conditions that the host graph should satisfy for the rule to be applicable .",
    "the algebraic approach has proposed a kind of acs with predefined diagrams ( i.e. graphs and morphisms making the condition ) and quantifiers regarding the existence or not of matchings of the different graphs of the constraint in the host graph  @xcite .",
    "most analysis techniques for plain rules ( without acs ) have to be adapted then for rules with acs ( see e.g.  @xcite for critical pairs with negative acs ) .",
    "moreover , different adaptations may be needed for different kinds of acs .",
    "thus , a uniform approach to analyse rules with arbitrary acs would be very useful .",
    "in previous works  @xcite , we developed a framework ( matrix graph grammars , mggs ) for the transformation of _ simple _ digraphs .",
    "simple digraphs and their transformation rules can be represented using boolean matrices and vectors .",
    "thus , the rewriting can be expressed using boolean operators only .",
    "one important point is that , as a difference from other approaches , we explicitly represent the rule dynamics ( addition and deletion of elements ) , instead of only the static parts ( rule pre- and post - conditions ) .",
    "this fact gives an interesting viewpoint enabling useful analysis techniques , such as for example checking independence of a sequence of arbitrary length and a permutation of it , or to obtain the smallest graph able to fire a sequence . on the theoretical side",
    ", our formalization of graph transformation introduces concepts from many branches of mathematics , like boolean algebra , group theory , functional analysis , tensor algebra and logics  @xcite .",
    "this wealth of available mathematical results opens the door to new analysis methods not developed so far , like sequential independence and explicit parallelism not limited to pairs of sequences , applicability , congruence and reachability . on the practical side , the implementations of our analysis techniques ,",
    "being based on boolean algebra manipulations , are expected to have a good performance .    in this paper",
    "we improve the framework , by extending grammar rules with a matrix ( the _ nihilation _ matrix ) that contains the edges that , if present in the host graph , forbid rule application .",
    "these are potential dangling edges and newly added ones , which can not be added twice , since we work with simple digraphs .",
    "this matrix , which can be interpreted as a graph , makes explicit some implicit negative information in the rule s pre - condition . to the best of our knowledge ,",
    "this idea is not present in any approach to graph transformation .",
    "in addition , we propose a novel approach for graph constraints and acs , where the diagram and the quantifiers are not fixed .",
    "for the quantification , we use a full - fledged formula using monadic second order logic ( msol )  @xcite .",
    "we show that once the match is considered , a rule with acs can be transformed into plain rules , by adding the positive information to the left hand side , and the negative in the nihilation matrix .",
    "this way , the applicability of a rule with arbitrary acs is equivalent to the applicability of one of the sequences of plain rules in a set : analysing the latter is equivalent to analysing the former .",
    "thus , in mggs , there is no need to extend the analysis techniques to special cases of acs . although we present the concepts in the mggs framework , many of these ideas are applicable to other approaches as well .",
    "* paper organization*. section  [ sec : mggs ] gives an overview of mggs .",
    "section  [ sec : ac ] introduces our graph constraints and acs .",
    "section  [ sec : ac_rules ] shows how acs can be embedded into rules .",
    "section  [ sec : ac_seq ] presents the equivalence between acs and sequences .",
    "section  [ sec : related ] compares with related work and section  [ sec : conclusions ] ends with the conclusions .",
    "this paper is an extension of  @xcite .",
    "* simple digraphs .",
    "* we work with simple digraphs , which we represent as @xmath0 where @xmath1 is a boolean matrix for edges ( the graph _ adjacency _ matrix ) and @xmath2 a boolean vector for vertices or nodes .",
    "we use the notation @xmath3 and @xmath4 to denote the set of edges and nodes respectively .",
    "note that we explicitly represent the nodes of the graph with a vector .",
    "this is necessary because in our approach we add and delete nodes , and thus we mark the existing nodes with a @xmath5 in the corresponding position of the vector .",
    "the left of fig .",
    "[ fig : example_graph ] shows a graph representing a production system made of a machine ( controlled by an operator ) , which consumes and produces pieces through conveyors .",
    "generators create pieces in conveyors .",
    "self loops in operators and machines indicate that they are busy .",
    "note that the matrix and the vector in the figure are the smallest ones able to represent the graph . adding zero elements to the vector ( and accordingly zero rows and columns to the matrix ) would result in equivalent graphs .",
    "next definition formulates the representation of simple digraphs .",
    "[ def : simple_digraph ] a simple digraph @xmath6 is represented by @xmath7 where @xmath1 is the graph s _ adjacency _ matrix and @xmath2 the boolean vector of its nodes .    * compatibility*. well - formedness of graphs ( i.e. , absence of dangling edges ) can be checked by verifying the identity @xmath8 , where @xmath9 is the boolean matrix product ( like the regular matrix product , but with * and * and * or * instead of multiplication and addition ) , @xmath10 is the transpose of the matrix @xmath1 , @xmath11 is the negation of the nodes vector @xmath2 , and @xmath12 is an operation ( a norm , actually ) that results in the * or * of all the components of the vector .",
    "we call this property _ compatibility",
    "_  @xcite .",
    "note that @xmath13 results in a vector that contains a 1 in position @xmath14 when there is an outgoing edge from node @xmath14 to a non - existing node .",
    "a similar expression with the transpose of @xmath1 is used to check for incoming edges .",
    "the next definition formally characterizes compatibility .",
    "[ def : compatibility ] a simple digraph @xmath7 is compatible iff @xmath15 .",
    "* typing*. a type is assigned to each node in @xmath16 by a function from the set of nodes @xmath4 to a set of types @xmath17 , @xmath18 . in fig .",
    "[ fig : example_graph ] types are represented as an extra column in the matrices , the numbers before the colon distinguish elements of the same type . for edges we use the types of their source and target nodes .",
    "[ def : typed_simple_digraph ]    a typed simple digraph @xmath19 over a set of types @xmath17 , is made of a simple digraph @xmath7 , and a function from the set of nodes @xmath4 to the set of types @xmath17 , @xmath18 .",
    "next , we define the notion of partial morphism between typed simple digraphs .",
    "[ def : morphism ]    given two simple digraphs @xmath20 for @xmath21 , a morphism @xmath22 is made of two partial injective functions @xmath23 , @xmath24 between the set of nodes ( @xmath25 ) and edges ( @xmath26 ) , s.t . @xmath27 and @xmath28 ; where @xmath29 is the domain of the partial function @xmath30 .",
    "* productions . * a production , or rule , @xmath31 is a morphism of typed simple digraphs . using a _ static formulation _ , a rule is represented by two typed simple digraphs that encode the left and right hand sides ( lhs and rhs ) .",
    "the matrices and vectors of these graphs are arranged so that the elements identified by morphism @xmath32 match ( this is called completion , see below ) .",
    "[ def : static_production ]    a production @xmath33 is statically represented as @xmath34 @xmath35 , where @xmath36 stands for edges and @xmath2 for vertices .",
    "a production adds and deletes nodes and edges , therefore using a _ dynamic formulation _ , we can encode the rule s pre - condition ( its lhs ) together with matrices and vectors representing the addition and deletion of edges and nodes .",
    "we call such matrices and vectors @xmath37 for `` erase '' and @xmath38 for `` restock '' .",
    "[ def : dynamic_production ]    a production @xmath33 is dynamically represented as @xmath39 @xmath40 , where @xmath41 contains the types of the new nodes , @xmath42 and @xmath43 are the deletion boolean matrix and vector , @xmath44 and @xmath45 are the addition boolean matrix and vector .",
    "they have a 1 in the position where the element is to be deleted or added respectively .",
    "the output of rule @xmath32 is calculated by the boolean formula @xmath46 , which applies both to nodes and edges ( the @xmath47 ( * and * ) symbol is usually omitted in formulae ) .",
    "* example . * fig .",
    "[ fig : example_rule ] shows a rule and its associated matrices . the rule models the consumption of a piece by a machine .",
    "compatibility of the resulting graph must be ensured , thus the rule can not be applied if the machine is already busy , as it would end up with two self loops , which is not allowed in a simple digraph .",
    "this restriction of simple digraphs can be useful in this kind of situations , and acts like a built - in negative ac .",
    "later we will see that the _ nihilation matrix _ takes care of this restriction .",
    "* completion . * in order to operate with the matrix representation of graphs of different sizes , an operation called completion adds extra rows and columns with zeros to matrices and vectors and rearranges rows and columns so that the identified edges and nodes of the two graphs match .",
    "for example , in fig .",
    "[ fig : example_rule ] , if we need to operate @xmath48 and @xmath49 , completion adds a fourth 0-row and fourth 0-column to @xmath49 .",
    "stated in another way , whenever we have to operate graphs @xmath50 and @xmath51 , a morphism @xmath52 ( i.e. a partial function ) has to be defined .",
    "completion rearranges the matrices and vectors of both graphs so that the elements in @xmath29 end up in the same row and column of the matrices .",
    "thus , after the completion we have that @xmath53 . in the examples",
    ", we omit such operation , assuming that matrices are completed when necessary .",
    "later we will operate with the matrices of different productions , thus we have to select the elements ( nodes and edges ) of each rule that get identified to the same element in the host graph .",
    "that is , one has to establish morphisms between the lhs and rhs of the different rules , and completion rearranges the matrices according to the morphisms .",
    "note that there may be different ways to complete two matrices , by chosing different orderings for its rows and columns .",
    "this is because a simple digraph can be represented by many adjacency matrices , which differ in the order of rows and columns . in any case , the graphs represented by the matrices are the same",
    ".    * nihilation matrix . * in order to consider the elements in the host graph that disable a rule application , we extend the notation for rules with a new graph @xmath54 .",
    "its associated matrix @xmath55 specifies the two kinds of forbidden edges : those incident to nodes which are going to be erased and any edge added by the rule ( which can not be added twice , since we are dealing with simple digraphs ) .",
    "notice however that @xmath55 considers only potential dangling edges with source and target in the nodes belonging to @xmath56 .",
    "[ def : nihilation_matrix ]    given the production @xmath57 @xmath40 , its nihilation matrix @xmath55 contains non - zero elements in positions corresponding to newly added edges , and to non - deleted edges adjacent to deleted nodes .",
    "we extend the rule formulation with this nihilation matrix .",
    "the concept of rule remains unaltered because we are just making explicit some implicit information .",
    "matrices are derived in the following order : @xmath58 .",
    "thus , a rule is _ statically _ determined by its lhs and rhs @xmath59 , from which it is possible to give a dynamic definition @xmath60 , with @xmath61 and @xmath62 , to end up with a full specification including its _ environmental _ behaviour @xmath63 .",
    "no extra effort is needed from the grammar designer , because @xmath55 can be automatically calculated as the image by rule @xmath32 of a certain matrix ( see proposition  [ lemma : nihilmatrix ] ) .",
    "[ def : full_dynamic_production ]    a production @xmath33 is dynamically represented as @xmath64 @xmath65 , where @xmath55 is the nihilation matrix , @xmath42 and @xmath43 are the deletion boolean matrix and vector , and @xmath44 and @xmath45 are the addition boolean matrix and vector .",
    "next proposition shows how to calculate the nihilation matrix using the production @xmath32 , by applying it to a certain matrix .",
    "[ lemma : nihilmatrix ]    the nihilation matrix @xmath55 of a given production @xmath32 is calculated as @xmath66 with @xmath67 .",
    "denotes the tensor product , which sums up the covariant and contravariant parts and multiplies every element of the first vector by the whole second vector . ]",
    "_ matrix @xmath68 specifies potential dangling edges incident to nodes in @xmath32 s lhs : @xmath69 note that @xmath70 . every incident edge to a node that is deleted becomes dangling , except those explicitly deleted by the production .",
    "in addition , edges added by the rule can not be present in the host graph , @xmath71 .",
    "@xmath72    * example . * the nihilation matrix @xmath55 for the example rule of fig .",
    "[ fig : example_rule ] is calculated as follows :    @xmath73 \\otimes      \\left [        \\begin{array}{c }          1 \\\\          1 \\\\          1 \\\\          0 \\\\        \\end{array }      \\right]^t } =    \\left [      \\begin{array}{cccc }        0 & 0 & 0 & 1 \\\\        0 & 0 & 0 & 1 \\\\        0 & 0 & 0 & 1 \\\\        1 & 1 & 1 & 1 \\\\      \\end{array }    \\right ]    \\nonumber\\ ] ]    the nihilation matrix is then given by : @xmath74 \\vee    \\overline { \\left [        \\begin{array}{cccc }          0 & 0 & 0 & 0\\\\          0 & 0 & 0 & 0\\\\          0 & 0 & 0 & 0\\\\          1 & 0 & 0 & 0 \\\\        \\end{array }       \\right ] }    \\left [      \\begin{array}{cccc }        0 & 0 & 0 & 1 \\\\        0 & 0 & 0 & 1 \\\\        0 & 0 & 0 & 1 \\\\        1 & 1 & 1 & 1 \\\\      \\end{array }     \\right ] =    \\left [      \\begin{array}{cccc }        0 & 0 & 0 & 1 \\\\        0 & 1 & 0 & 1 \\\\        0 & 0 & 1 & 1 \\\\        0 & 1 & 1 & 1 \\\\      \\end{array }    \\right ] \\nonumber\\ ] ]    the matrix indicates any dangling edge from the deleted piece ( the edge to the conveyor is not signaled as it is explicitly deleted ) , as well as self - loops in the machine and in the operator .",
    "r0.2     matrix @xmath55 can be extended to a simple digraph by taking the nodes in the lhs : @xmath75 .",
    "note that it defines a simple digraph , as one basically needs to add the source and target nodes of the edges in @xmath55 , which are a subset of the nodes in @xmath56 , because for the calculation of @xmath55 we have used the edges stemming from the nodes in @xmath56 .",
    "[ fig : nihilation_example ] shows the graph representation for the nihilation matrix of previous example .",
    "the nihilation matrix should not be confused with the notion of _ negative application condition _",
    "( nac )  @xcite , which is an additional graph specified by the designer ( i.e. not derived from the rule ) containing extra negative conditions .",
    "@xmath72    the evolution of the rule s lhs ( i.e. how it is transformed into the rhs ) is given by the production itself ( @xmath76 ) .",
    "it is interesting to analyse the behaviour of the nihilation matrix , which is given by the next proposition .",
    "[ th : nevolution ]    let @xmath33 be a compatible production with nihilation matrix @xmath55 .",
    "then , the elements that must not appear once the production is applied are given by @xmath77 , where @xmath78 is the inverse of @xmath32 ( the production that adds what @xmath32 deletes and vice versa , obtained by swapping @xmath37 and @xmath38 ) .",
    "_ the elements that should not appear in the rhs are potential dangling edges and those deleted by the production : @xmath79 .",
    "this coincides with @xmath80 as shown by the following set of identities : @xmath81 in the last equality of compatibility has been used , @xmath82 . @xmath72",
    "* remark*. though strange at a first glance , a dual behaviour of the negative part of a production with respect to the positive part should be expected .",
    "the fact that @xmath55 uses @xmath78 rather than @xmath32 for its evolution is quite natural .",
    "when a production @xmath32 erases one element , it asks its lhs to include it , so it demands its presence .",
    "the opposite happens when @xmath32 adds some element .",
    "for @xmath55 things happen in the opposite direction . if the production asks for the addition of some element , then the size of @xmath55 ( its number of edges )",
    "is increased while if some element is deleted , @xmath55 shrinks .",
    "* example . *",
    "[ fig : nihilation_evol ] shows the calculation of @xmath83 using the graph representation of the matrices in equation  [ eq:3 ] .",
    "@xmath72    next definition introduces a functional notation for rules ( already used in  @xcite ) , inspired by the dirac or bra - ket notation  @xcite .",
    "this notation will be useful for reasoning and proving the propositions in section  [ sec : ac_seq ] .",
    "[ def : functional_rule ]    a production @xmath33 can be depicted as @xmath84 , splitting the static part ( initial state , @xmath85 ) from the dynamics ( element addition and deletion , @xmath32 ) .",
    "using such formulation , the _ ket _ operators ( i.e. those to the right side of the bra - ket ) can be moved to the _ bra _",
    "( i.e. left hand side ) by using their adjoints ( which are usually decorated with an asterisk ) .",
    "we make use of this notation in section  [ sec : ac_seq ] .    *",
    "match and derivations .",
    "* matching is the operation of identifying the lhs of a rule inside a host graph ( we consider only injective matches ) .",
    "given rule @xmath33 and a simple digraph @xmath6 , any total injective morphism @xmath86 is a match for @xmath32 in @xmath6 , thus it is one of the ways of _ completing _ @xmath85 in @xmath6 .",
    "the following definition considers not only the elements that should be present in the host graph @xmath6 ( those in @xmath85 ) but also those that should not ( those in the nihilation matrix , @xmath55 ) .",
    "[ def : directderivationdef ]    given rule @xmath33 and graph @xmath87 as in fig .",
    "[ fig : matches](a ) , @xmath88  with @xmath89  is called a direct derivation with result @xmath90 if the following conditions are satisfied :    1 .   there",
    "exist total injective morphisms @xmath91 and @xmath92 .",
    "2 .   @xmath93 , @xmath94 .",
    "the match @xmath95 induces a completion of @xmath85 in @xmath6 .",
    "matrices @xmath37 and @xmath38 are then completed in the same way to yield @xmath96 and @xmath97 .",
    "the output graph is calculated as @xmath98",
    ".    * remark .",
    "* item 2 is needed to ensure that @xmath85 and @xmath55 are matched to the same nodes in @xmath6 .",
    "* example . * fig .",
    "[ fig : matches](b ) shows the application of rule _",
    "startprocess _ to graph @xmath6 .",
    "we have also depicted the inclusion of @xmath55 in @xmath99 ( bidirectional arrows have been used for simplification ) .",
    "@xmath99 is the complement ( negation ) of matrix @xmath100 .",
    "@xmath72 it is useful to consider the structure defined by the negation of the host graph , @xmath101 .",
    "it is made up of the graph @xmath99 and the vector of nodes @xmath102 .",
    "note that the negation of a graph is not a graph because in general compatibility fails , that is why the term `` structure '' is used .",
    "the complement of a graph coincides with the negation of the adjacency matrix , but while negation is just the logical operation , taking the complement means that a completion operation has been performed before .",
    "hence , taking the complement of a matrix @xmath100 is the negation with respect to some appropriate completion of @xmath6 .",
    "that is , the complement of graph @xmath6 with respect to graph @xmath103 , through a morphism @xmath104 is a two - step operation : ( i ) complete @xmath6 and @xmath103 according to @xmath30 , yielding @xmath105 and @xmath106 ; ( ii ) negate @xmath105 . as long as no confusion arises negation and complements",
    "will not be syntactically distinguished .",
    "* examples*. suppose we have two graphs @xmath103 and @xmath6 as those depicted in fig .",
    "[ fig : negation_graph ] and that we want to check that @xmath103 is not in @xmath6 .",
    "note that @xmath103 is not contained in @xmath107 ( an operator node does not even appear ) , but it does appear in the negation of the completion of @xmath6 with respect to @xmath103 ( graph @xmath108 in the same figure ) .    in the context of fig .",
    "[ fig : matches](b ) , we see that there is an inclusion @xmath109 ( i.e. the forbidden elements after applying production @xmath110 are not in @xmath111 ) .",
    "this is so because we complete @xmath111 with an additional piece ( which was deleted from @xmath6 ) .",
    "note also that in definition  [ def : directderivationdef ] , we have to complete @xmath85 and @xmath6 ( step 3 ) .",
    "as an occurrence of @xmath85 has to be found in @xmath6 , all nodes of @xmath85 have to be present in @xmath6 and thus @xmath6 is big enough to be able to find an inclusion @xmath112 .",
    "@xmath72    when applying a rule , _ dangling edges _ can occur .",
    "this is possible because the nihilation matrix only considers dangling edges to nodes appearing in the rule s lhs .",
    "however , a dangling edge can occur between a node deleted by the rule and a node not considered by the rule s lhs . in mgg , we propose an spo - like behaviour  @xcite , where the dangling edges are deleted .",
    "thus , if rule @xmath32 produces dangling edges ( a fact that is partially signaled by @xmath113 ) it is enlarged to explicitly consider the dangling edges in the lhs .",
    "this is equivalent to adding a pre - production ( called @xmath114production ) to be applied before the original rule  @xcite .",
    "thus , rule @xmath32 is transformed into sequence @xmath115 ( applied from right to left ) , where @xmath116 deletes the dangling edges and @xmath32 is applied as it is . in order to ensure that both productions are applied to the same elements ( matches are non - deterministic ) , we defined a _ marking _ operator @xmath117 which modifies the rules , so that the resulting rule @xmath117(@xmath116 ) , in addition , adds a special node connected to the elements to be marked , and @xmath118 in addition considers the special node in the lhs and then deletes it .",
    "this is a technique to control rule application by passing the match from one rule to the next",
    ".    * analysis techniques . * in  @xcite we developed some analysis techniques for mggs",
    ", we briefly give an intuition to those that will be used in section  [ sec : analysisac ] .",
    "one of the goals of our previous work was to analyse rule sequences independently of a host graph .",
    "we represent a rule sequence as @xmath119 , where application is from right to left ( i.e. @xmath120 is applied first ) . for its analysis , we _ complete _ the sequence , by identifying the nodes across rules which are assumed to be mapped to the same node in the host graph .    once the sequence is completed , our notion of sequence _ coherence _",
    "@xcite  @xcite  @xcite permits knowing if , for the given identification , the sequence is potentially applicable ( i.e. if no rule disturbs the application of those following it ) .",
    "the formula for coherence results in a matrix and a vector ( which can be interpreted as a graph ) with the problematic elements .",
    "if the sequence is coherent , both should be zero , if not , they contain the problematic elements .",
    "a coherent sequence is _ compatible _ if its application produces a simple digraph .",
    "that is , no dangling edges are produced in intermediate steps .    given a completed sequence , the minimal initial digraph ( mid )",
    "is the smallest graph that permits applying such sequence .",
    "conversely , the negative initial digraph ( nid ) contains all elements that should not be present in the host graph for the sequence to be applicable . in this way , the nid is a graph that should be found in @xmath107 for the sequence to be applicable ( i.e. none of its edges can be found in @xmath6 ) .",
    "if the sequence is not completed ( i.e. no overlapping of rules is decided ) , we can also give the set of all graphs able to fire such sequence or spoil its application .",
    "we call them _ initial digraph set _ and _ negative digraph set _ respectively .",
    "see section  6 in  @xcite or sections  4.4 and  5.3 in  @xcite .",
    "other concepts we developed aim at checking sequential independence ( i.e. same result ) between a sequence and a permutation of it .",
    "_ g - congruence _ detects if two sequences ( one permutation of the other ) have the same mid and nid .",
    "it returns two matrices and two vectors , representing two graphs , which are the differences between the mids and nids of each sequence respectively . thus if zero , the sequences have the same mid and nid .",
    "two coherent and compatible completed sequences that are g - congruent are sequential independent .",
    "see section  7 in  @xcite or section  6.1 in  @xcite .",
    "in this section , we present our concepts of _ graph constraints _ ( gcs ) and _ application conditions _ ( acs ) .",
    "a gc is defined as a _ diagram _ plus a msol formula .",
    "the diagram is made of a set of graphs and morphisms ( _ partial _ injective functions ) which specify the relationship between elements of the graphs .",
    "the formula specifies the conditions to be satisfied in order to make a host graph @xmath6 satisfy the gc ( i.e. we check whether @xmath6 is a model for the diagram and the formula ) .",
    "the domain of discourse of the formulae are simple digraphs , and the diagram is a means to represent the interpretation function * i*.    gc formulae are made of expressions about graph inclusions . for this purpose , we introduce the following two predicates : @xmath121\\\\    q(x_1 , x_2 ) = \\exists e [ f(e , x_1 ) \\wedge f(e , x_2)]\\end{aligned}\\ ] ]    where predicate @xmath122 states that element @xmath123 ( a node or an edge ) is in graph @xmath124 . in this way ,",
    "predicate @xmath125 means that graph @xmath126 is included in @xmath127 .",
    "note that @xmath123 ranges over all nodes and edges ( edges are defined by their initial and final node ) of @xmath126 , thus ensuring the containment of @xmath126 in @xmath127 ( i.e. preserving the graph structure ) .",
    "predicate @xmath128 asserts that there is a partial morphism between @xmath126 and @xmath127 , which is defined on at least one edge .",
    "that is , @xmath126 and @xmath127 share an edge . in this case ,",
    "@xmath37 ranges over all edges .",
    "predicates decorated with superindices @xmath36 or @xmath2 refer to _ e_dges or _ v_ertices .",
    "thus , @xmath129 says that every _ vertex _ in graph @xmath126 should also be present in @xmath127 .",
    "actually @xmath125 is in fact a shortcut for stating that all vertices in @xmath126 should be found in @xmath127 ( @xmath129 ) , all edges in @xmath126 should be found in @xmath127 ( @xmath130 ) and in addition the set of nodes found should correspond to the source and target nodes of the edges .",
    "predicate @xmath125 asks for an inclusion morphism @xmath131 .",
    "the diagram of the constraint may already include such morphism @xmath132 ( i.e. the diagram can be seen as a set of restrictions imposed on the interpretation function * i * ) and we can either permit extensions of @xmath132 ( i.e. the model  host graph  may relate more elements of @xmath126 and @xmath127 ) or keep it as defined in the diagram . in this latter case , the host graph should identify exactly the specified elements in @xmath132 and keep different the elements not related by @xmath132 .",
    "this is represented using predicate @xmath133 , which can be expressed using @xmath134 : @xmath135 = p^e(d , cod ) \\wedge p^e(d^c , cod^c)\\end{aligned}\\ ] ]    where @xmath136 , @xmath137 , @xmath138 stands for the complement ( i.e. @xmath139 is the complement of @xmath140 w.r.t @xmath126 ) and @xmath141 is the * xor * operation .",
    "a similar reasoning applies to nodes .",
    "the notation ( syntax ) will be simplified by making the host graph @xmath6 the default second argument for predicates @xmath142 and @xmath143 .",
    "besides , it will be assumed that by default total morphisms are demanded : unless otherwise stated predicate @xmath142 is assumed .",
    "r0.28     * example*. before starting with formal definitions , we give an intuition of gcs .",
    "the following gc is satisfied if for every @xmath144 in @xmath6 it is possible to find a related @xmath145 in @xmath6 : @xmath146 $ ] , equivalent by definition to @xmath147 $ ] . nodes and edges in @xmath144 and @xmath145 are related through the diagram shown in fig .",
    "[ fig : diagexample ] , which relates elements with the same number and type . as a notational convenience , to enhance readability , each graph in the diagram has been marked with the quantifier given in the formula .",
    "if a total match is sought , no additional inscription is presented , but if a partial match is demanded the graph is additionally marked with a @xmath143 .",
    "similarly , if a total match is forbidden by the formula , the graph is marked with @xmath148 .",
    "this convention will be used in most examples throughout the paper .",
    "the gc in fig .",
    "[ fig : diagexample ] expresses that each machine should have an output conveyor.@xmath72    note the identity @xmath149 , which we use throughout the paper .",
    "we take the convention that negations in abbreviations apply to the predicate ( e.g. , @xmath150 \\equiv \\exists a \\left [ \\overline{p } \\left ( a ,",
    "g \\right ) \\right]$ ] ) and not the negation of the graph s adjacency matrix .",
    "a bit more formally , the syntax of well - formed formulas is inductively defined as in monadic second - order logic , which is first - order logic plus variables for subsets of the domain of discourse . across this paper",
    ", formulas will normally have one variable term @xmath6 which represents the host graph .",
    "usually , the rest of the terms will be given ( they will be constant terms ) .",
    "predicates will consist of @xmath142 and @xmath143 and combinations of them through negation and binary connectives .",
    "next definition formally presents the notion of _",
    "diagram_.    [ def : diagram ] a _ diagram _",
    "@xmath151 is a set of simple digraphs @xmath152 and a set of partial injective morphisms @xmath153 with @xmath154 .",
    "diagram @xmath151 is well defined if every cycle of morphisms commute .",
    "the formulae in the constraints use variables in the set @xmath155 , and predicates @xmath142 and @xmath143 .",
    "formulae are restricted to have no free variables except for the default second argument of predicates @xmath142 and @xmath143 , which is the host graph @xmath6 in which we evaluate the gc .",
    "next definition presents the notion of gc .",
    "[ def : graphconstraint ] @xmath156 is a graph constraint , where @xmath151 is a well defined diagram and @xmath157 a sentence with variables in @xmath158 .",
    "a constraint is called _ basic _ if @xmath159 ( with one bound variable and one free variable ) and @xmath160 .",
    "in general , there will be an outstanding variable among the @xmath161 representing the host graph , being the only free variable in @xmath157 .",
    "in previous paragraphs it has been denoted by @xmath6 , the default second argument for predicates @xmath142 and @xmath143 .",
    "we sometimes speak of a `` gc defined over g '' .",
    "a basic gc will be one made of just one graph and no morphisms in the diagram ( recall that the host graph is not represented by default in the diagram nor included in the formulas ) .",
    "next , we define an ac as a gc where exactly one of the graphs in the diagram is the rule s lhs ( existentially quantified over the host graph ) and another one is the graph induced by the nihilation matrix ( existentially quantified over the negation of the host graph ) .",
    "[ def : weakprecond ] given rule @xmath33 with nihilation matrix @xmath55 , an ac ( over the free variable @xmath6 ) is a gc satisfying :    1 .",
    "@xmath162 such that @xmath163 and @xmath164 .",
    "@xmath165 such that @xmath166 is the only free variable .",
    "@xmath157 must demand the existence of @xmath85 in @xmath6 and the existence of @xmath55 in @xmath167 .",
    "the simple graph @xmath6 can be thought of as a host graph to which some grammar rules are to be applied . for simplicity",
    ", we usually do not explicitly show the condition 3 in the formulae of acs , nor the nihilation matrix @xmath55 in the diagram .",
    "however , if omitted , both @xmath85 and @xmath55 are existentially quantified before any other graph of the ac .",
    "thus , an ac has the form @xmath168 $ ] .",
    "note the similarities between def .",
    "[ def : weakprecond ] and that of derivation in def .",
    "[ def : directderivationdef ] .",
    "actually , we can interpret the rule s lhs and its nihilation matrix as the minimal ac a rule can have .",
    "hence , any well defined production has a natural associated ac .",
    "note also that , in addition to the ac diagram , the structure of the rule itself imposes a relation between @xmath85 and @xmath55 ( and between @xmath85 and @xmath169 ) . for technical reasons , related to converting pre- into post - conditions and viceversa",
    ", we assume that morphisms in the diagram do not have codomain @xmath85 or @xmath55 . this",
    "is easily solved as we may always use their inverses due to @xmath170 s injectiveness .",
    "* semantics of quantification . * in gcs or acs ,",
    "graphs are quantified either existentially or universally .",
    "we now give the intuition of the semantics of such quantification applied to basic formulae .",
    "thus , we consider the four basic cases : ( i ) @xmath171 $ ] , ( ii ) @xmath172 $ ] , ( iii ) @xmath173 $ ] , ( iv ) @xmath174 $ ] .",
    "case ( i ) states that @xmath6 should include graph @xmath103 .",
    "for example , in fig .",
    "[ fig : quantifier_semantics ] , the gc @xmath175 @xmath176 $ ] demands an occurrence of @xmath177 in @xmath6 ( which exists ) .",
    "r0.35     case ( ii ) demands that , for all _ potential occurrences _ of @xmath103 in @xmath6 , the shape of graph @xmath103 is actually found .",
    "the term potential occurrences means all distinct maximal partial matches ( which are total on nodes ) of @xmath103 in @xmath6 . a non - empty partial match in @xmath6 is maximal , if it is not strictly included in another partial or total match .",
    "for example , consider the gc @xmath178 $ ] in the context of fig .",
    "[ fig : quantifier_semantics ]",
    ". there are two possible instantiations of @xmath177 ( as there are two machines and one operator ) , and these are the two input elements to the formula . as only one of them satisfies @xmath179  the expanded form of @xmath176 $ ]  the gc is not satisfied by @xmath6 .",
    "case ( iii ) demands that , for all potential occurrences of @xmath103 , none of them should have the shape of @xmath103 .",
    "the term potential occurrence has the same meaning as in case ( ii ) . in fig .",
    "[ fig : quantifier_semantics ] , there are two potential instantiations of the gc @xmath180 $ ] .",
    "as one of them actually satisfies @xmath179 , the formula is not satisfied by @xmath6 .",
    "finally , case ( iv ) is equivalent to @xmath181 $ ] , where by definition @xmath182 .",
    "this gc states that for all possible instantiations of @xmath103 , one of them must not have the shape of @xmath103 .",
    "this means that a non - empty partial morphism @xmath183 should be found .",
    "the gc @xmath184 $ ] in fig .",
    "[ fig : quantifier_semantics ] is satisfied by @xmath6 because , again , there are two possible instantiations , and one of them actually does not have an edge between the operator and the machine .",
    "next definition formalizes the previous intuition , where we use the following notation :    * @xmath185 is a maximal non - empty partial morphism s.t . @xmath186",
    "* @xmath187 is a total morphism @xmath188 * @xmath189 is an isomorphism @xmath190    where @xmath191 are the nodes of the graph in the domain of @xmath30 .",
    "thus , @xmath192 denotes the set of all potential occurrences of a given constraint graph @xmath103 in @xmath6 , where we require all nodes in @xmath103 be present in the domain of @xmath30 .",
    "note that each @xmath193 may be empty in edges .",
    "[ def : basicgcsatisfied ]    the host graph @xmath6 satisfies @xmath171 $ ] , written is explained in more detail after def .",
    "[ def : gcsatisfied ] . ]",
    "@xmath194 $ ] iff @xmath195 $ ] .",
    "+ the host graph @xmath6 satisfies @xmath172 $ ] , written @xmath196 $ ] iff @xmath197 $ ] .",
    "+    the diagrams associated to the formulas in previous definition have been omitted for simplicity as they consist of a single element : @xmath103 . recall that by default predicate @xmath142 is assumed as well as @xmath6 as second argument , e.g. the first formula in previous definition @xmath171 $ ] is actually @xmath198 $ ] .",
    "note also that only these two cases are needed , as one has @xmath199",
    "\\equiv \\forall a[\\overline p(a , g)]$ ] and @xmath200 \\equiv \\exists a[\\overline p(a , g ) ] $ ] .    thus",
    ", this is a standard interpretation of msol formulae , save for the domain of discourse ( graphs ) and therefore the elements of quantification ( maximal non - empty partial morphisms ) .",
    "taking this fact into account , next , we define when a graph satisfies an arbitrary @xmath201 .",
    "this definition also applies to acs .",
    "[ def : gcsatisfied ] we say that @xmath202 satisfies the graph constraint @xmath203@xmath204 under the interpretation function @xmath205 , written @xmath206 , if @xmath207 is a model for @xmath208 that satisfies the element relations assigns elements in the domain to elements in the codomain .",
    "elements so related should be mapped to the same element .",
    "for example , let @xmath209 and @xmath210 with @xmath211 and @xmath212 .",
    "further , assume @xmath213 , then @xmath214 . ] specified by the diagram @xmath215 , and the following interpretation for the predicates in @xmath157 :    1 .",
    "@xmath216 total injective morphism .",
    "@xmath217 partial injective morphism , non - empty in edges .    where @xmath218 with .",
    "] @xmath219 and @xmath220 .",
    "the interpretation of quantification is as in def .",
    "[ def : basicgcsatisfied ] but setting @xmath221 and @xmath222 instead of @xmath103 and @xmath6 , respectively .    the notation deserves the following comments :    1 .",
    "the notation @xmath223 means that the formula @xmath157 is satisfied under interpretation given by @xmath205 , assignments given by morphisms specified in @xmath207 and substituting the variables in @xmath157 with the graphs in @xmath207 .",
    "2 .   as commented after def .",
    "[ def : graphconstraint ] , in many cases the formula @xmath157 will have a single variable ( the one representing the host graph @xmath6 ) and always the interpretation function will be that given in def .",
    "[ def : gcsatisfied ] . we may thus write @xmath224 which is the notation that appears in def .",
    "[ def : basicgcsatisfied ] .",
    "the notation @xmath225 may also be used .",
    "3 .   similarly , as an ac is just a gc where @xmath85 , @xmath55 and @xmath6 are present , we may write @xmath226 . for practical purposes , we are interested in testing whether , given a host graph @xmath6 , a certain match @xmath227 satisfies the ac . in this case",
    "we write @xmath228 . in this way , the satisfaction of an ac by a match and a host graph is like the satisfaction of a gc by a graph @xmath6 , where a morphism @xmath95 is already specified in the diagram of the gc .",
    "* remark*. for technical reasons , we require all graphs in the gc for which a partial morphism is demanded to be found in the host graph to have at least one edge and be connected .",
    "that is why @xmath229 has to be non - empty in edges .",
    "* examples . * fig .",
    "[ fig : example_fulfill1 ] shows rule _ contract _ , with an ac given by the diagram in the figure ( where morphisms identify elements with the same type and number , this convention is followed throughout the paper ) , together with formula @xmath230 $ ] .",
    "the rule creates a new operator , and assigns it to a machine .",
    "the rule can be applied if there is a match of the lhs ( a machine is found ) , the machine is not busy ( @xmath231 $ ] ) , and all operators are busy ( @xmath232 $ ] ) .",
    "graph @xmath6 to the right satisfies the ac , with the match that identifies the machine in the lhs with the machine in @xmath6 with the same number .    using the terminology of acs in the algebraic approach  @xcite , @xmath231 $ ]",
    "is a negative application condition ( nac ) . on the other hand",
    ", there is no equivalent to @xmath232 $ ] in the algebraic approach , but in this case it could be emulated by a diagram made of two graphs stating that if an operator exists then it does not have a self - loop .",
    "however , this is not possible in all cases as next example shows .",
    "[ fig : example_ac ] shows rule _ move _ , which has an ac with formula : @xmath233 @xmath234 $ ] .",
    "as previously stated , in this example and the followings , the rule s lhs and the nihilation matrix are omitted in the ac s formula .",
    "the example ac checks whether all conveyors connected to conveyor 1 in the lhs reach a common target conveyor in one step .",
    "we can use `` global '' information , as graph @xmath235 has to be found in @xmath6 and then all output conveyors are checked to be connected to it ( @xmath235 is existentially quantified in the formula before the universal ) . note that we first obtain all possible conveyors ( @xmath236 ) . as the identifications of the morphism",
    "@xmath237 have to be preserved , we consider only those potential instances of @xmath238 with @xmath239 equal to @xmath239 in @xmath85 . from these ,",
    "we take those that are connected ( @xmath240 ) , and which therefore have to be connected with the conveyor identified by the lhs .",
    "graph @xmath6 satisfies the ac , while graph @xmath105 does not , as the target conveyor connected to @xmath241 is not the same as the one connected to @xmath242 and @xmath243 . to the best of our efforts",
    "it is not possible to express this condition using the standard acs in the dpo approach given in  @xcite . @xmath72",
    "in this section , the goal is to embed arbitrary acs into rules by including the positive and negative coditions in @xmath85 and @xmath55 respectively .",
    "it is necessary to check that direct derivations can be the codomain of the interpretation function , that is , intuitively we want to assert whether `` mgg + ac = mgg '' and `` mgg + gc = mgg '' .",
    "as stated in previous section , in direct derivations , the matching corresponds to formula @xmath244 @xmath245 $ ] , but additional acs may represent much more general properties , due to universal quantifiers and partial morphisms . normally , plain rules ( without acs ) in the different approaches to graph transformation do not care about elements that can not be present .",
    "if so , a match is just @xmath246 $ ] .",
    "thus , we seek for a means to translate universal quantifiers and partial morphisms into existential quantifiers and total morphisms .    for this purpose , we introduce two operations on basic diagrams :  _ closure _ ( @xmath247 ) , dealing with universal quantifiers only , and _ decomposition _ ( @xmath248 ) , for partial morphisms only ( i.e. with the @xmath143 predicate ) .",
    "the closure operator converts a universal quantification into a number of existentials , as many as maximal partial matches there are in the host graph ( see definition  [ def : basicgcsatisfied ] ) .",
    "thus , given a host graph @xmath6 , demanding the universal appearance of graph @xmath103 in @xmath6 is equivalent to asking for the existence of as many replicas of @xmath103 as partial matches of @xmath103 are in @xmath6 .",
    "[ def : closuredef ]    given @xmath249 with diagram @xmath250 , ground formula @xmath251 $ ] and a host graph @xmath6 , the result of applying @xmath247 to @xmath201 is calculated as follows : @xmath252    \\end{aligned}\\ ] ] with @xmath253 , @xmath254 , @xmath255 and @xmath256",
    ".    * remark . *",
    "completion creates a morphism @xmath257 between each different @xmath258 and @xmath259 ( both isomorphic to @xmath103 ) , but morphisms are not needed in both directions ( i.e. @xmath260 is not needed ) . the condition that morphism @xmath257 must not be an isomorphism means that at least one element of @xmath258 and @xmath259 has to be identified in different places of @xmath6 .",
    "this is accomplished by means of predicate @xmath133 ( see its definition in equation  [ def : p_u ] ) , which ensures that the elements not related by @xmath261 , are not related in @xmath6 .",
    "the interpretation of the closure operator is that demanding the universal appearance of a graph is equivalent to the existence of all of its potential instances ( i.e. those elements in @xmath262 ) in the specified digraph ( @xmath6 , @xmath263 or some other ) .",
    "some nodes can be the same for different identifications ( @xmath257 ) , so the procedure does not take into account morphisms that identify every single node , @xmath264 .",
    "therefore , each @xmath258 contains the image of a potential match of @xmath103 in @xmath6 ( there are @xmath265 possible occurrences of @xmath103 in @xmath6 ) and @xmath257 identifies elements considered equal .",
    "* example .",
    "* assume the diagram to the left of fig .",
    "[ fig : example_closure1 ] , made of just graph @xmath266 , together with formula @xmath267 $ ] , and graph @xmath6 , where such gc is to be evaluated .",
    "the gc asks @xmath6 for the existence of all potential connections between each generator and each conveyor . performing closure we obtain @xmath268))=(\\mathfrak{d}_c , \\exists gen_1 \\exists gen_2 \\exists",
    "gen_3 [ gen_1 \\wedge",
    "gen_2 \\wedge gen_3 \\wedge p_u(gen_1 , gen_2 ) \\wedge p_u(gen_1 , gen_3 ) \\wedge p_u(gen_2 , gen_3 ) ] ) $ ] , where diagram @xmath269 is shown to the right of fig .",
    "[ fig : example_closure1 ] , and each @xmath257 identifies elements with the same number and type .",
    "the closure operator makes explicit that three potential occurrences must be found ( as @xmath270 ) , thus , taking information from the graph where the gc is evaluated and placing it in the gc itself .",
    "@xmath72    the idea behind decomposition is to split a graph into its basic components to transform partial morphisms into total morphisms of one of its parts . for this purpose , the decomposition operator @xmath248 splits a digraph @xmath103 into its edges , generating as many digraphs as edges in @xmath103 . as stated in remark 1 of definition  [ def : gcsatisfied ] , all graphs for which the gc asks for a partial morphism",
    "are forbidden to have isolated nodes .",
    "we are more interested in the behaviour of edges ( which to some extent comprises nodes as source and target elements of the edges , except for isolated nodes ) than on nodes alone as they define the _ topology _ of the graph .",
    "this is also the reason why predicate @xmath143 was defined to be true in the presence of a partial morphism non - empty in edges .",
    "if so desired , in order to consider isolated nodes , it is possible to define two decomposition operators , one for nodes and one for edges , but this is left for future work .",
    "[ def : decompdef ]    given @xmath249 with ground formula @xmath271 $ ] and diagram @xmath272 , @xmath248 acts on @xmath201  @xmath273  in the following way : @xmath274 \\label{eq : decomp }    \\end{aligned}\\ ] ] with @xmath275 , the number of edges of @xmath103 , and @xmath276 , where @xmath258 contains a single edge of @xmath103 .    demanding",
    "a partial morphism is equivalent to asking for the existence of a total morphism of some of its edges , that is , each @xmath258 contains exactly one of the edges of @xmath103 .",
    "* example .",
    "* consider @xmath277)$ ] , where graph @xmath278 is shown to the left of fig .",
    "[ fig : example_decomp1 ] .",
    "the constraint is satisfied by a host graph @xmath6 if there is a partial morphism non - empty in edges @xmath279 .",
    "thus , we require that either the two conveyors are connected , or there is a piece in one of them .",
    "using decomposition , we obtain @xmath280 @xmath281)$ ] .",
    "diagram @xmath282 is shown in fig .",
    "[ fig : example_decomp1](b ) , together with a graph @xmath6 satisfying the constraint in fig .",
    "[ fig : example_decomp1](c ) .",
    "note that this constraint can be expressed more concisely than in other approaches , like the algebraic / categorical one of  @xcite .",
    "note how , decomposition is not affected by the host graph to which it is to be evaluated . also , we do not care whether some graphs in the decomposition are matched in the same place in the host graph ( e.g. @xmath283 and @xmath284 ) , as the gc just requires one of them to be found .",
    "@xmath72    now we show the main result of this section , which states that it is possible to reduce any formula in an ac ( or gc ) into another one using existential quantifiers and total morphisms only .",
    "this theorem is of interest because derivations as defined in mggs ( the matching part ) use only total morphisms and existential quantifiers .",
    "[ th : embeddinggc ]    let @xmath285 with @xmath157 a ground formula , @xmath157 can be transformed into a logically equivalent @xmath286 with existential quantifiers only .    _ proof",
    "_ let the depth of a graph for a fixed node @xmath287 be the maximum over the shortest path ( to avoid cycles ) starting in any node different from @xmath287 and ending in @xmath287 .",
    "the depth of a graph is the maximum depth for all its nodes .",
    "diagram @xmath151 is a graph where nodes are digraphs @xmath161 and edges are morphisms @xmath257 .",
    "we use @xmath288 to denote the depth of @xmath151 . in order to prove the theorem we apply induction on the depth , checking out every case .",
    "there are 16 possibilities for @xmath289 and a single element @xmath103 , summarized in table [ tab : possibilitiessinglecase ] .",
    "\\(1 ) & @xmath290 $ ] & ( 5 ) & @xmath291 $ ] & ( 9 ) & @xmath292 $ ] & ( 13 ) & @xmath293 $ ] +    \\(2 ) & @xmath294 $ ] & ( 6 ) & @xmath174 $ ] & ( 10 ) & @xmath295 $ ] & ( 14 ) & @xmath296 $ ] +    \\(3 ) & @xmath297 $ ] & ( 7 ) & @xmath298 $ ] & ( 11 ) & @xmath299 $ ] & ( 15 ) & @xmath300 $ ] +    \\(4 ) & @xmath301 $ ] & ( 8) & @xmath302 $ ] & ( 12 ) & @xmath303 $ ] & ( 16 ) & @xmath304 $ ] +    elements in the same row for each pair of columns are related using equalities @xmath173 = \\forall a[\\overline{a}]$ ] and @xmath305 = \\exists a[\\overline{a}]$ ] , so it is possible to reduce the study to cases ( 1)(4 ) and ( 9)(12 ) .",
    "identities @xmath306 and",
    "@xmath307 reduce ( 9)(12 ) to formulae ( 1)(4 ) :    @xmath308 = \\exists a\\left[p(a , \\overline{g})\\right ]    & , & \\exists a [ q(a ) ] = \\exists a\\left[\\overline{p}(a , \\overline{g})\\right ] \\nonumber \\\\    \\nexists a [ q(a ) ] = \\nexists a\\left[\\overline{p}(a , \\overline{g})\\right ] & , &    \\nexists a [ \\overline{q}(a ) ] = \\nexists a\\left[p(a , \\overline{g})\\right ] .",
    "\\nonumber\\end{aligned}\\ ] ]    thus , it is enough to study the first four cases , but we have to specify if @xmath103 must be found in @xmath6 or @xmath263 .",
    "finally , all cases in the first column can be reduced to ( 1 ) :    * \\(1 ) is the definition of match .",
    "* \\(2 ) can be transformed into total morphisms ( case 1 ) using operator @xmath248 : @xmath309    = \\exists a \\left[q(a,\\overline{g})\\right ] = \\exists a^1\\ldots\\exists    a^n \\left[\\bigvee_{i=1}^n p\\left(a^i , \\overline{g}\\right)\\right]$ ] .",
    "* \\(3 ) can be transformed into total morphisms ( case 1 ) using operator @xmath247 : @xmath310 =    \\forall a [ a ] = \\exists a^1\\ldots\\exists a^n \\left[\\bigwedge_{i=1}^n      a^i \\right]$ ] . here for simplicity , the conditions on @xmath133 are assumed to be satisfied and thus have not been included .",
    "* \\(4 ) combines ( 2 ) and ( 3 ) , where operators @xmath247 and @xmath248 are applied in order @xmath311 ( see remark below ) : @xmath312 = \\forall a    \\left[\\overline{a}\\right ] = \\exists a^{11}\\ldots\\exists a^{mn }    \\left[\\bigwedge_{i=1}^m \\bigvee_{j=1}^n p\\left(a^{ij } ,        \\overline{g}\\right)\\right]$ ] .",
    "if there is more than one element at depth 1 , this same procedure can be applied mechanically ( well - definedness guarantees independence with respect to the order in which elements are selected ) .",
    "note that if depth is 1 , graphs on the diagram are unrelated ( otherwise , depth @xmath313 1 )",
    ".    * induction step .",
    "* when there is a universal quantifier @xmath314 , according to equation [ eq : closure ] , elements of @xmath103 are replicated as many times as potential instances of @xmath103 can be found in the host graph .",
    "in order to continue the application procedure , we have to clone the rest of the diagram for each replica of @xmath103 , except those graphs which are existentially quantified before @xmath103 in the formula .",
    "that is , if we have a formula @xmath315 , when performing the closure of @xmath103 , we have to replicate @xmath316 as many times as @xmath103 , but not @xmath317 .",
    "moreover @xmath317 has to be connected to each replica of @xmath103 , preserving the identifications of the morphism @xmath318 .",
    "more in detail , when closure is applied to @xmath103 , we iterate on all graphs @xmath319 in the diagram :    * if @xmath319 is existentially quantified after @xmath103 ( @xmath320 ) then it is replicated as many times as @xmath103 .",
    "appropriate morphisms are created between each @xmath258 and @xmath321 if a morphism @xmath322 existed .",
    "the new morphisms identify elements in @xmath258 and @xmath321 according to @xmath323 .",
    "this permits finding different matches of @xmath319 for each @xmath258 , some of which can be equal . in the host graph but only one of @xmath319 ,",
    "then the three replicas of @xmath317 are matched to the same part of @xmath6 . ] * if @xmath319 is existentially quantified before @xmath103 ( @xmath324 ) then it is not replicated , but just connected to each replica of @xmath103 if necessary .",
    "this ensures that a unique @xmath319 has to be found for each @xmath258 .",
    "moreover , the replication of @xmath103 has to preserve the shape of the original diagram .",
    "that is , if there is a morphism @xmath325 , then each @xmath326 has to preserve the identifications of @xmath323 ( this means that we take only those @xmath258 which preserve the structure of the diagram ) . *",
    "if @xmath319 is universally quantified ( no matter if it is quantified before or after @xmath103 ) , again it is replicated as many times as @xmath103 .",
    "afterwards , @xmath319 will itself need to be replicated due to its universality .",
    "the order in which these replications are performed is not relevant as @xmath327 .",
    "@xmath72    * remark*.[remark : noncommutatutivity ] operators @xmath247 and @xmath248 commute , i.e. @xmath328 . in the equation of item 4 ,",
    "the application order does not matter .",
    "composition @xmath329 is a direct translation of @xmath330 $ ] , which first considers all appearances of nodes in @xmath103 and then splits these occurrences into separate digraphs .",
    "this is the same as considering every pair of connected nodes in @xmath103 by one edge and take their closure , i.e , @xmath331 .",
    "* example . * fig .",
    "[ fig : example_closure_ac ] shows rule _ endproc _ and the diagram of its ac , which has formula : @xmath332 @xmath333 $ ] .",
    "the ac allows for the application of the rule if all machines connected ( as output ) to the conveyor in @xmath85 are operated by the same operator .",
    "this is so as the ac considers all machines connected to the lhs conveyor by @xmath334 $ ] . for these machines",
    ", it should be the case that a unique operator ( @xmath335 is placed at the beginning of the formula ) is connected to them ( @xmath336 ) .",
    "the bottom of the figure shows the resulting diagram after applying the previous theorem , using graph @xmath6 to the upper right of the figure . at depth 2",
    ", graph @xmath337 is replicated three times , as it is universally quantified and there are three machines .",
    "then , the rest of the diagram is replicated , except the graphs quantified before @xmath337 ( @xmath85 and @xmath338 ) .",
    "the resulting formula of the ac is @xmath339 @xmath340 $ ] , where we have omitted the @xmath133 predicate ( asking that actually three machines have to be found in @xmath6 ) , and used the abbreviation @xmath341 .",
    "note that graph @xmath6 satisfies the ac ( using the only match of @xmath85 in @xmath6 ) as machine 1 is not operated by the same operator as machines 2 and 3 , however conveyor 1 is not connected to machine 1 as output ( thus the left part of the implication is false ) .",
    "@xmath72    as an ac is a particular case of graph constraint , we can conclude that it is not necessary to extend the notion of direct derivation in order to consider acs .",
    "[ cor : embedding ] any application condition @xmath342 with @xmath157 a ground formula can be embedded into its corresponding direct derivation .",
    "now we are able to obtain acs with existentials and total morphisms only .",
    "the next section shows how to translate rules with such acs into sets of rule sequences .",
    "one of the strengths of mgg compared to other graph transformation approaches is the possibility to analyse grammars independently ( to some extent ) of the actual host graph .",
    "however , the universal quantifier appears to be an insurmountable obstacle : the host graph seems indispensable to know how many instances there are .",
    "we will see in section [ sec : proc_ac2seq ] that this is not the case .",
    "in this section we transform arbitrary acs into sequences of plain rules , such that if the original rule with acs is applicable the sequence is applicable and viceversa .",
    "this is very useful , as we may use our analysis techniques for plain rules in order to analyse rules with acs .",
    "next , we present some properties of acs which , once the ac is translated into a sequence , can be analysed using the developed theory for sequences .",
    "[ def : consistentac ] let @xmath343 be an ac on rule @xmath33 . we say that ac is :",
    "* _ coherent _ if it is not a contradiction ( i.e. false in all scenarios ) . * _ compatible _ if , together with the rule s actions , produces a simple digraph . * _ consistent _ if @xmath344 host graph such that @xmath345 to which the production is applicable .",
    "coherence of acs studies whether there are contradictions in it preventing its application in any scenario . typically , coherence is not satisfied if the condition simultaneously asks for the existence and non - existence of some element .",
    "compatibility of acs checks whether there are conflicts between the ac and the rule s actions .",
    "here we have to check for example that if a graph of the @xmath346 demands the existence of some edge , then it can not be incident to a node that is deleted by production @xmath32 .",
    "consistency is a kind of well - formedness of the ac when a production is taken into account .",
    "next , we show some examples of non - compatible and non - coherent acs .",
    "* examples*. non - compatibility can be avoided at times just rephrasing the ac and the rule .",
    "consider the example to the left of fig .",
    "[ fig : example_non_compat ] . the rule models the breakdown of a machine by deleting it .",
    "the ac states that the machine can be broken if it is being operated . the ac has associated diagram @xmath347 and formula @xmath348 $ ] .",
    "as the production deletes the machine and the ac asks for the existence of an edge connecting the operator with the machine , it is for sure that if the rule is applied we will obtain at least one dangling edge .",
    "r0.33     the key point is that the ac asks for the existence of the edge but the production demands its non - existence as it is included in the nihilation matrix @xmath54 . in this case , the rule @xmath349 depicted to the right of the same figure is equivalent to @xmath32 but with no potential compatibility issues .",
    "notice that coherence is fulfilled in the example to the left of fig .",
    "[ fig : example_non_compat ] ( the ac alone does not encode any contradiction ) but not consistency as no host graph can satisfy it .",
    "an example of non - coherent application condition can be found in fig .",
    "[ fig : example_non_coherent ] .",
    "the ac has associated formula @xmath350 @xmath351 $ ] .",
    "there is no problem with the edge deleted by the rule , but with the self - loop of the operator .",
    "note that due to @xmath352 , it must appear in any potential host graph but @xmath353 says that it should not be present .",
    "@xmath72    we will provide a means to study such properties by converting the ac into a sequence of plain rules and studying the sequence , by applying the analysis techniques already developed in mgg .",
    "we will prove that an ac is coherent if its associated sequence is coherent and similarly for compatibility .",
    "also , we will see that an ac is consistent if its associated sequence is applicable in some host graph .",
    "as this requires sequences to be both coherent and compatible , and ac is consistent if it is both coherent and compatible  @xcite  @xcite .      in order to transform a rule with acs into sequences of plain rules , operators @xmath247 and @xmath248",
    "are expressed with the bra - ket functional notation introduced in definition  [ def : functional_rule ] .",
    "operators @xmath247 and @xmath248 will be formally represented as @xmath354 and @xmath355 , respectively , and we analyse how they act on productions and grammars .",
    "we shall follow a case by case study of the demonstration of theorem [ th : embeddinggc ] to structure this section .",
    "the first case in the proof of theorem [ th : embeddinggc ] is the simplest one : a graph @xmath103 has to be found in @xmath6 .",
    "[ lemma : firstcase ]    let @xmath356 be a rule with @xmath357)$ ] , @xmath32 is applicable to graph @xmath6 iff sequence @xmath358 is applicable to @xmath6 , where @xmath359 is a production with lhs and rhs equal to @xmath103 .",
    "_ the ac states that an additional graph @xmath103 has to be found in the host graph , related to @xmath85 according to the identifications in @xmath323",
    ". therefore we can do the * or * of @xmath103 and @xmath85 ( according to the identifications specified by @xmath323 ) , and write the resulting rule using the functional notation of definition  [ def : functional_rule ] , obtaining @xmath360 . thus applying the rule to its lhs",
    ", we obtain @xmath361 .",
    "note however that such rule is the composition of the original rule @xmath32 , and rule @xmath362 .",
    "thus , we can write @xmath363 , which proves also that @xmath364 , the adjoint operator of @xmath365 . the symbol `` @xmath366 '' denotes rule composition according to the identification across rules specified by @xmath323 ( see  @xcite ) . thus , if the @xmath346 asks for the existence of a graph , it is possible to enlarge the rule @xmath367 .",
    "the marking operator @xmath117 permits using concatenation instead of composition @xmath368 .",
    "@xmath72    * example .",
    "* the ac of rule @xmath369 in fig .",
    "[ fig : example_exists ] ( a ) has associated formula @xmath370 $ ] ( i.e. the operator may move to a machine with an incoming piece ) . using previous construction , we obtain that the rule is equivalent to sequence @xmath371 , where @xmath372 is the original rule without the ac .",
    "rule @xmath373 is shown in fig .",
    "[ fig : example_exists ] ( b ) .",
    "alternatively , we could use composition to obtain @xmath374 as shown in fig .",
    "[ fig : example_exists ] ( c ) . @xmath72",
    "the second case in the proof of theorem [ th : embeddinggc ] states that some edges of @xmath103 can not be found in @xmath6 for some identification of nodes in @xmath6 , i.e. @xmath375 = \\exists a \\left [ \\overline{a } \\right]$ ] .",
    "this corresponds to operator @xmath355 ( decomposition ) , defined by @xmath376 . for this purpose",
    ", we introduce a kind of conjugate ( for edges ) of production @xmath359 , written @xmath377 .",
    "the left of fig .",
    "[ fig : idandconj ] shows @xmath378 , which preserves ( uses but does not delete ) all elements of @xmath103 .",
    "this is equivalent to demand their existence . in the center",
    "we have its conjugate , @xmath379 , which asks for the existence of @xmath103 in the complement of @xmath6 .",
    "rule @xmath379 for edges can be defined on the basis of already known concepts ( i.e. having a `` normal '' nihilation matrix , according to proposition  [ lemma : nihilmatrix ] ) . since @xmath380 , in order to obtain a rule applicable iff @xmath381 is in @xmath99 , the only chance is to act on the elements that some rule adds .",
    "let @xmath382 be a sequence such that @xmath383 adds the edges whose presence is to be avoided and @xmath384 deletes them .",
    "the overall effect is the identity ( no effect ) but the sequence can be applied iff the edges of @xmath103 are in @xmath167 ( see the right of fig .",
    "[ fig : idandconj ] ) .",
    "a similar construction does not work for nodes because if a node is already present in the host graph a new one can always be added ( adding and deleting a node does not guarantee that the node is not present in the host graph ) .",
    "thus , we restrict to diagrams made of graphs without isolated nodes .",
    "the way to proceed is to care only about nodes that are present in the host graph as the others together with their edges will be present in the completion of the complement of @xmath6 .",
    "this is @xmath385 , where @xmath169 stands for _",
    "restriction_. next lemma uses the previous conjugate rule to convert the acs in the second case of theorem  [ th : embeddinggc ] into a set of rule sequences .",
    "[ lemma : secondcase ]    let @xmath356 be a rule with @xmath386)$ ] , @xmath32 is applicable to graph @xmath6 iff some sequence in the set @xmath387 is applicable to graph @xmath6 , with @xmath388 the edge conjugate rule obtained from each graph @xmath258 in the decomposition of @xmath103 .    _ proof .",
    "let @xmath265 be the number of edges of @xmath103 , and @xmath258 a graph consisting of one edge of @xmath103 ( together with its source and target nodes ) .",
    "applying decomposition , the formula is transformed into : @xmath389 \\longmapsto \\mathfrak{f } ' = \\exists a^1 \\ldots \\exists a^n \\left [ \\bigvee^n_{i=1 }    p \\left ( a^i , \\overline{g } \\right)\\right]$ ] .",
    "that is , the ac indicates that more edges must not appear in order to apply the production .",
    "we build the set @xmath390 , where each production @xmath391 is equal to @xmath32 , but its nihilation matrix is enlarged with @xmath392 .",
    "thus , some production in this set will be applicable iff some edge of @xmath103 is found in @xmath263 ( i.e. iff @xmath393 holds ) and @xmath32 is applicable .",
    "but note that @xmath394 , where @xmath395 is depicted in the center of fig .",
    "[ fig : idandconj ] .",
    "if composition is chosen instead of concatenation , the grammar is modified by removing rule @xmath32 and adding the set of productions @xmath396 . if the production is part of a sequence , say @xmath397 then we have to substitute it by some @xmath391 , i.e. @xmath398 . a similar reasoning applies if we use concatenation instead of composition , where we have to replace any sequence : @xmath399 , where rules @xmath32 and @xmath388 are related through marking.@xmath72    * example . * the ac of rule @xmath400 in fig .",
    "[ fig : example_decomposition ] has as associated formula @xmath401 $ ] .",
    "the formula states that the machine can be removed if there is one piece that is not connected to the input or output conveyor ( as we must not find a total morphism from @xmath402 to @xmath6 ) .",
    "applying the lemma  [ lemma : secondcase ] , rule @xmath400 is applicable if some of the sequences in the set @xmath403 @xmath404 is applicable , where productions @xmath405 and @xmath406 are like the rules in the figure , but considering conveyor 2 .",
    "thus @xmath407.@xmath72    the third case demands that for any identification of nodes in the host graph every edge must also be found : @xmath408 = \\nexists a [ \\overline{a}]$ ] , associated to operator @xmath354 ( closure ) .",
    "[ lemma : thirdcase ]    let @xmath356 be a rule with @xmath409)$ ] , @xmath32 is applicable to graph @xmath6 iff sequence @xmath410 is applicable to graph @xmath6 .",
    "@xmath411 is the composition ( through their common elements ) of the graphs resulting from the closure of @xmath103 w.r.t . @xmath6 .",
    "_ closure transforms @xmath412 \\longmapsto \\exists a^1 \\ldots \\exists a^n$ ] @xmath413 $ ] , i.e. more edges must be present in order to apply the production .",
    "thus , we have to enlarge the rule s lhs : @xmath414 . using functional notation , @xmath415 @xmath416 @xmath417 @xmath416 @xmath418 ,",
    "the adjoint operator can be calculated as @xmath419 .    as in previous cases , we may substitute composition with concatenation : @xmath420 @xmath421 , where @xmath422 .",
    "note however that , if we use the expanded sequence ( with @xmath423 instead of @xmath424 ) we have to make sure that each @xmath423 is applied at each different instance .",
    "this can be done by defining a marking operator similar to @xmath425 .",
    "@xmath72    * remark . *",
    "note that the result of closure depends on the number and type of the nodes in the host graph @xmath6 , which gives the number of replicas of @xmath103 that have to be found .",
    "* example .",
    "[ fig : example_closure2 ] shows rule _ buy _ , which creates a new generator machine .",
    "the rule has an ac whose diagram is shown in the figure , with formula @xmath426 $ ] .",
    "the ac permits applying the rule if all generators in the host graph are connected to all conveyors . applying lemma  [ lemma : thirdcase ] to the previous rule and to graph @xmath6 , we obtain sequence @xmath427 . as such sequence is not applicable in @xmath6 ,",
    "the original rule is not applicable either . @xmath72 .",
    "the fourth case is in fact similar to a nac , which is a mixture of ( 2 ) and ( 3 ) .",
    "this case says that there does not exist an identification of nodes of @xmath103 for which all edges in @xmath103 can also be found , @xmath173 $ ] , i.e. for every identification of nodes there is at least one edge in @xmath167 .",
    "[ lemma : nacs ]    let @xmath356 be a rule with @xmath428)$ ] , @xmath32 is applicable iff some sequence @xmath429 is applicable .",
    "_ let @xmath430 , then the formula is transformed as follows : @xmath431 \\longmapsto \\exists a^{11 } \\ldots \\exists$ ] @xmath432 $ ] .",
    "if we first apply closure to @xmath103 then we get a sequence of @xmath433 productions , @xmath434 , assuming @xmath123 potential occurrences of @xmath103 in @xmath6 .",
    "right afterwards , decomposition splits every @xmath258 into its components ( in this case there are @xmath265 edges in @xmath103 ) .",
    "so every match of @xmath103 in @xmath6 is transformed to look for at least one missing edge , @xmath435 .",
    "thus @xmath436 results in a set of rules @xmath437 where @xmath438 .",
    "each @xmath439 is the composition of @xmath433 productions , defined as @xmath440 .",
    "operator @xmath117 permits concatenation instead of composition @xmath441.@xmath72    * example . *",
    "[ fig : example_nac ] shows rule `` move '' and a host graph @xmath6 .",
    "a potential match identifies the elements in @xmath85 with those in @xmath6 with the same number and type .",
    "the rule has an ac with associated formula @xmath442 $ ] . applying lemma  [ lemma : nacs ] , we perform closure first , which results in four potential instances of @xmath443 : @xmath444 .",
    "note however that only two of them preserve the identification of elements given by the morphism @xmath445 ( as the conveyor in @xmath85 has to be matched to conveyor 1 in @xmath6 ) .",
    "the two instances contain the nodes @xmath446 and @xmath447 in @xmath6 , the first contains in addition edges @xmath448 and @xmath449 , while the second contains the @xmath449 edge only .",
    "as each @xmath443 has two edges , decomposition leads to two rules for each potential instance ( each one detecting that one of the edges of @xmath450 does not exist ) .",
    "thus , we end up with 4 sequences of 3 rules each ( choosing concatenation of rules instead of composition ) .",
    "the first two rules in each sequence detect that one edge is missing in each potential instance of @xmath451 , while the last rule is @xmath452 .",
    "note that choosing concatenation at this level makes necessary a mechanism to control that each rule is applied at a different potential instance of @xmath443 .",
    "this is not necessary if we compose these rules together .",
    "the right of the figure shows one of these compositions ( @xmath453 ) , which checks whether the first instance of @xmath443 is missing the edge from the operator and the machine , and the other one is missing the edge from the conveyor to the machine . as before ,",
    "we have split such rule in two : @xmath454 .",
    "thus , altogether the applicability of the original rule move is equivalent to the applicability of one of the sequences in @xmath455 , where each sequence can be applied if each one of the two potential instances of @xmath443 is missing at least one edge .",
    "rules @xmath452 and @xmath456 are related through marking . note that none of these sequences is applicable on @xmath6 ( the first instance of @xmath451 contains all edges ) , thus the original rule is not applicable either .",
    "@xmath72    previous lemmas prove that acs can be reduced to studying rule sequences .",
    "[ th : reductionpre ]    any ac can be reduced to the study of the corresponding set of sequences .",
    "_ proof _ this result is the sequential version of theorem [ th : embeddinggc ] .",
    "the four cases of its proof correspond to lemmas [ lemma : firstcase ] through [ lemma : nacs].@xmath72    * remark . *",
    "quantifiers directly affect matching morphisms .",
    "however , it is possible to some extent to apply all mgg analysis techniques independently of the host graph , even in the presence of universal quantifiers . the main idea is to consider the initial digraph set ( see @xcite ) of all possible starting graphs that enable the sequence application .",
    "some modifications of these graphs are needed to cope with universals .",
    "the modified graphs in such set is then used to generate again the sequences .",
    "some examples of this procedure are given in section  [ sec : analysisac]@xmath72    * example . * fig .",
    "[ fig : final_example_gc ] shows a gc with associated formula @xmath457 $ ] .",
    "the gc states that if an operator is connected to a machine , such machine is busy .",
    "up to now we have focussed on analyzing acs , but the previous theorem also allows analyzing a gc as a set of sequences .",
    "note however that as the formula has an implication , it is not possible to directly generate the set of sequences , as the gc is also applicable if the left of the implication is false .",
    "thus , the easiest way is to apply the @xmath458 reduction of theorem  [ th : embeddinggc ] , which in this case reduces to applying closure .",
    "the resulting diagram is shown to the right of the figure , and the modified formula is then @xmath459 $ ] .    once the formula has existentials only , we manipulate it to get rid of implications .",
    "thus , we have @xmath460= \\exists act_1 \\exists act_2 \\exists busy_1 \\exists busy_2 [ ( \\overline{act_1 } \\wedge \\overline{act_2 } ) \\vee ( \\overline{act_1 } \\wedge busy_2 ) \\vee ( busy_1 \\wedge \\overline{act_2 } ) \\vee ( busy_1 \\wedge busy_2)]$ ] .",
    "this leads to a set of four sequences : @xmath461 .",
    "thus , graph @xmath6 satisfies the gc iff some sequence in the set is applicable to @xmath6 .",
    "however in this case none is applicable .",
    "testing gcs this way allows us checking whether applying a certain rule @xmath32 preserves the gcs by testing the applicability of @xmath32 together with the sequences derived from the gcs .",
    "this in fact gives equivalent results to translating the gc into a post - condition for the rule and then generating the sequences .",
    "@xmath72      as stated throughout the paper , one of the main points of the techniques we have developed is to analyse rules with ac by translating them into sequences of flat rules , and then analysing the sequences of flat rules instead . in definition  [ def : consistentac ]",
    "we presented some interesting properties to be analysed for acs and gcs ( coherence , compatibility and consistency ) .",
    "next corollary , which is a direct consequence of theorem  [ th : reductionpre ] , deals with coherence and compatibility of acs and gcs .",
    "[ cor : equivpreac_seqs ] an ac is coherent iff if its associated sequence ( set of sequences ) is coherent ; it is compatible iff its sequence ( set of sequences ) is compatible and it is consistent iff its sequence ( set of sequences ) is applicable .",
    "in  @xcite ( theorem 5.5.1 ) we characterized sequence applicability as sequence coherence ( see section  5 in  @xcite or section  4.3 in  @xcite ) and compatibility ( see section  4 and  7 in  @xcite or section 4.5 in  @xcite ) .",
    "thus , we can state the following corollary .",
    "[ cor : precondconscohcomp ] an ac is consistent iff it is coherent and compatible .    * examples . *",
    "compatibility for acs tells us whether there is a conflict between an ac and the rule s action .",
    "as stated in corollary  [ cor : equivpreac_seqs ] , this property is studied by analysing the compatibility of the resulting sequence . rule _",
    "break _ in fig .",
    "[ fig : example_non_compat ] has an ac with formula @xmath462 $ ] .",
    "this results in sequence : @xmath463 , where the machine in both rules is identified ( i.e. has to be the same ) . our analysis technique for compatibility  @xcite outputs a matrix with a @xmath5 in the position corresponding to edge @xmath464 , thus signaling the dangling edge .",
    "coherence detects conflicts between the graphs of the ac ( which includes @xmath85 and @xmath54 ) and we can study it by analysing coherence of the resulting sequence . for the case of rule `` rest '' in fig .",
    "[ fig : example_non_coherent ] , we would obtain a number of sequences , each testing that `` busy '' is found , but the self - loop of `` work '' is not .",
    "this is not possible , because this self - loop is also part of `` busy '' .",
    "our technique for coherence detects such conflict and the problematic element .",
    "@xmath72    in addition , we can also use other techniques we have developed to analyse acs :    * * sequential independence .",
    "* we can use our results for sequential independence of sequences to investigate if , once several rules with acs are translated into sequences , we can for example delay all the rules checking the ac constraints to the end of the sequence .",
    "note that usually , when transforming an ac into a sequence , the original flat rule should be applied last .",
    "sequential independence allows us to choose some other order .",
    "moreover , for a given sequence of productions , acs are to some extent delocalized in the sequence .",
    "in particular it could be possible to pass conditions from one production to others inside a sequence ( paying due attention to compatibility and coherence ) .",
    "for example , a post - condition for @xmath120 in the sequence @xmath465 might be translated into a pre - condition for @xmath466 , and viceversa .",
    "* example .",
    "* the sequence resulting from the rule in fig .",
    "[ fig : example_exists ] is @xmath371 . in this case , both rules are independent and can be applied in any order .",
    "this is due to the fact that the rule effects do not affect the ac . @xmath72    * * minimal initial digraph and negative initial digraphs*. the concepts of mid and nid allow us to obtain the ( set of ) minimal graph(s ) able to satisfy a given gc ( or ac ) , or to obtain the ( set of ) minimal graph(s ) which can not be found in @xmath6 for the gc ( or ac ) to be applicable . in case the ac results in a single sequence ,",
    "we can obtain a minimal graph ; if we obtain a set of sequences , we get a set of minimal graphs . in case universal quantifiers",
    "are present , we have to complete all existing partial matches so it might be useful to limit the number of nodes in the host graph under study . +",
    "a direct application of the mid / nid technique allows us to solve the problem of finding a graph that satisfies a given ac .",
    "the technique can be extended to cope with more general gcs .",
    "r0.38     * example . * rule @xmath400 in fig .",
    "[ fig : example_decomposition ] results in two sequences . in this case ,",
    "the minimal initial digraph enabling the applicability for both is equal to the lhs of the rule .",
    "the two negative initial digraphs are shown in fig .",
    "[ fig : example_nid ] ( and both assume a single piece in @xmath6 ) .",
    "this means that the rule is not applicable if @xmath6 has any edge stemming from the machine , or two edges stemming from the piece to the two conveyors .",
    "@xmath72    * example . * fig .",
    "[ fig : mid_completion ] shows the minimal initial digraph for executing rule @xmath467 .",
    "as the rule has a universally quantified condition ( @xmath468 $ ] ) , we have to complete the two partial matches of the initial digraph so as to enable the execution of the rule.@xmath72    * * g - congruence . *",
    "graph congruence characterizes sequences with the same initial digraph .",
    "therefore , it can be used to study when two gcs / acs are equivalent for all morphisms or for some of them .",
    "see section  7 in  @xcite or section  6.1 in  @xcite .",
    "moreover , we can use our techniques to analyse properties which up to now have been analysed either without acs or with nacs , but not with arbitrary acs :    * * critical pairs . *",
    "a critical pair is a minimal graph in which two rules are applicable , and applying one disables the other  @xcite .",
    "critical pairs have been studied for rules without acs  @xcite or for rules with nacs  @xcite .",
    "our techniques however enable the study of critical pairs with any kind of ac .",
    "this can be done by converting the rules into sequences , calculating the graphs which enable the application of both sequences , and then checking whether the application of a sequence disables the other .",
    "+ in order to calculate the graphs enabling both sequences , we derive the minimal digraph set for each sequence as described in previous item . then , we calculate the graphs enabling both sequences ( which now do not have to be minimal , but we should have jointly surjective matches from the lhs of both rules ) by identifying the nodes in each minimal graph of each set in every possible way . due to universals , some of the obtained graphs may not enable the application of some sequence .",
    "the way to proceed is to complete the partial matches of the universally quantified graphs , so as to make the sequence applicable .",
    "+ once we have the set of starting graphs , we take each one of them and apply one sequence . then , the sequence for the second rule is recomputed  as the graph has changed  and applied to the graph .",
    "if it can be applied , there are no conflicts for the given initial graph , otherwise there is a conflict .",
    "besides the conflicts known for rules without acs or with nacs ( delete - use and produce - forbid  @xcite ) , our acs may produce additional kinds of conflicts .",
    "for example , a rule can create elements which produce a partial match for a universally quantified constraint in another ac , thus making the latter sequence unapplicable .",
    "further investigation on the issue of critical pairs is left for future work .",
    "* example . * fig .",
    "[ fig : critical_pairs](a ) shows two rules , @xmath469 and @xmath470 , with acs @xmath471 $ ] and @xmath472 $ ] respectively .",
    "the center of the same figure depicts the minimal digraphs @xmath473 and @xmath474 , enabling the execution of the sequences derived from @xmath469 and @xmath470 respectively . in this case , both are equal to the lhs of each rule .",
    "the right of the figure shows the two resulting graphs once we identify the nodes in @xmath473 and @xmath474 in each possible way .",
    "these are the starting graphs that are used to analyse the conflicts .",
    "the rules present several conflicts .",
    "first , rule @xmath469 disables the execution of @xmath470 , as the former creates a new machine , which is not connected to all conveyors , thus disabling the @xmath475 $ ] condition of @xmath470 .",
    "the conflict is detected by executing the sequence associated to @xmath469 ( starting from either @xmath476 or @xmath477 ) , and then recomputing the sequence for @xmath470 , taking the modified graph as the starting one .",
    "similarly , executing rule @xmath470 may disable @xmath469 if the new machine is created in the conveyor with the piece ( this is a produce - forbid conflict  @xcite ) .",
    "@xmath72    * * rule independence*. similarly , results for rule independence have been stated either for plain rules , or rules with nacs . in our case , we convert the rules into sets of sequences and then check each combination of sequences of the two rules .",
    "in the categorical approach to graph transformation , acs  @xcite are usually defined by boolean formulae of positive or negative atomic acs on the rule s lhs .",
    "the atomic acs are of the form @xmath478 or @xmath479 , with @xmath480 and @xmath481 total functions .",
    "the diagrams in this kind of acs are limited to depth 2 and there is no explicit control on the quantifications . in our approach ,",
    "the acs are not limited to be constraints on the lhs , thus we can use `` global '' information , as seen in the examples of figs .",
    "[ fig : example_ac ] and  [ fig : example_closure_ac ] .",
    "this is useful for instance to state that a certain unique pattern in the host graph is related to all instantiations of a certain graph in the ac .",
    "moreover , in our acs , the diagrams may have any shape ( and in particular are not limited to depth 2 ) .",
    "whether elements should be mapped differently or not is tackled by restricting the morphisms from the acs to the host graph to be injective in  @xcite . on the contrary , we use partial functions and predicate @xmath133 .",
    "our use of the closure operator takes information from the host graph and stores it in the rule .",
    "this enables the generation of plain rules , whose analysis is equivalent to the analysis of the original rule with acs .    in  @xcite ,",
    "the previous concept of gcs and acs were extended with nesting .",
    "however , their diagrams are still restricted to be linear ( which produces tree - like acs ) , and quantification is performed on the morphisms of the ac ( i.e. not given in a separate formula ) .",
    "again , this fact difficults expressing acs like those in figs .",
    "[ fig : example_ac ] and  [ fig : example_closure_ac ] , where a unique element has to be related to all instances of a given graph , which in its turn have to be related to the rule s lhs . in  @xcite ,",
    "the same authors present techniques for transforming graph constraints into right application conditions and those to pre - conditions , show the equivalence of considering non - injective and injective matchings , and the equivalence of gcs and first order graph - formulae .",
    "the work is targeted to the verification of graph transformation systems relative to graph constraints ( i.e. , to check whether the rules preserve the constraints or not , or to derive pre - conditions ensuring that the constraints are preserved ) . in our case",
    ", we are interested in analysing the rules themselves ( see section  [ sec : analysisac ] ) , e.g. checking independence , or calculating the minimal graph able to fire a sequence using the techniques already developed for plain rules . we have left out related topics , such as the transformation from pre- to post - conditions , which are developed in the doctoral thesis available at  @xcite .",
    "note however , that there are some similarities between our work and that of  @xcite .",
    "for example , in their theorem 8 , given a rule , they provide a construction to obtain a gc that if satisfied , permits applying the rule at a certain match .",
    "hence , the derived gc makes explicit the glueing condition and serves a similar purpose as our nihilation matrix .",
    "notice however that the nihilation matrix contains negative information and has to be checked on the negation of the graph .",
    "the work of  @xcite is an attempt to relate logic and algebraic rewriting , where acs are generalized to arbitrary levels of nesting ( in diagrams similar to ours , but restricted to be trees ) .",
    "translations of these acs into first order logic and back are given , as well as a procedure to flatten the acs into a normal graph , using edge inscriptions .",
    "we use arbitrary diagrams , complemented with a msol formulae , which includes quantifications of the different graphs of the diagram .",
    "our goal was to flatten such acs into sequences of plain rules .",
    "related to the previous work , in  @xcite , a logic based on first - order predicate is proposed to restrict the shape of graphs .",
    "a decidable fragment of it is given called local shape logic , on the basis of a multiplicity algebra .",
    "a visual representation is devised for monomorphic shapes .",
    "this approach is somehow different from ours , as we break the constraint into a diagram of graphs , and then give a separate formula with the quantification .",
    "thus , altogether , the advantages of our approach are the following : ( i ) we have a universal quantifier , which means that some conditions are more direct to express , for example taking the diagram of fig .",
    "[ fig : example_fulfill1 ] , we can state @xmath232 $ ] , which demands a self - loop in all operators . in the algebraic approach",
    "there is no universal quantifier , but it could be emulated by a diagram made of two graphs stating that if an operator exists then it must have a self - loop . however",
    ", this becomes more complicated as the graphs become more complex .",
    "for example , let @xmath103 be a graph with two connected conveyors ( in each direction ) .",
    "then @xmath482 $ ] asks that each two conveyors have at least a connection . in the algebraic approach",
    ", one has to take the nodes of @xmath103 and check their existence , and then take each edge of @xmath103 and demand that one of them should exist .",
    "note that this universal quantifier is also different from amalgamation approaches  @xcite , which , roughly , are used to build a match using all occurrences of a subgraph . in our case , we in addition demand each partial occurrence to be included in a total one .",
    "( ii ) we have an explicit control of the formula and the diagram , which means that we can use diagrams with arbitrary shape , and we can put existentials before universals , as in the example of fig .",
    "[ fig : example_ac ] .",
    "again , this facilitates expressing such constraints with respect to approaches like  @xcite .",
    "( iii ) sequences of plain rules can be automatically derived from rules with acs , thus making uniform the analysis of rules with acs .    on the contrary",
    ", one may argue that our universal is `` too strong '' as it demands that all possible occurrences of a given graph are actually found .",
    "this in general presents no problems , as a common technique is for example to look for all nodes of a given graph constraint with a universal , and then look for the edges with existentials .    with respect to other similar approaches to mggs , in  @xcite the dpo approach",
    "was implemented using mathematica . in that work , ( simple )",
    "digraphs were represented by boolean adjacency matrices .",
    "this is the only similarity with our work , as our goal is to develop a theory for ( simple ) graph rewriting based on boolean matrix algebra .",
    "other somehow related work is the relational approaches of  @xcite , but they rely on category theory for expressing the rewriting . similar to our dynamic formulation of production and to our deletion and addition matrices , the approach of fujaba  @xcite considers the lhs of a production and labels with `` new '' and `` del '' the elements to be created and deleted .",
    "finally , it is worth mentioning the set - theoretic approaches to graph transformation  @xcite .",
    "even though some of these approaches have developed powerful analysis techniques and efficient tool implementations , the rewriting is usually limited ( e.g. a node or edge can be replaced by a subgraph ) .",
    "we have presented a novel concept of gcs and acs based on a diagram of graphs and morphisms and a msol formulae .",
    "the concept has been incorporated into our mgg framework , which in addition has been improved by incorporating the notion of nihilation matrix .",
    "this matrix contains edges that if present forbid rule application .",
    "one interesting point of the introduced notion of ac is that it is possible to transform them into a sequence of plain rules , with the same applicability constraints as the original rule with acs .",
    "thus , in mgg we can use the same analysis techniques for plain rules and rules with acs .",
    "we have left out some related topics , such as post - conditions and transformation from pre- to post - conditions and viceversa , the handling of nodes with variable type ( i.e. nodes that in the ac can get matched to nodes with other type in the host graph ) and its relation to meta - modelling  @xcite .",
    "this notion of acs enables performing multi - graph rewriting with simple graph rewriting by representing edges as special nodes , plus a set of acs .",
    "thus , mgg can handle multigraphs with no further modification of the theory .    as future work",
    ", we are developing a tool implementation of the mgg framework , enabling interoperability with existing graph grammars tools such as atom@xmath483  @xcite or agg  @xcite .",
    "we also plan to include more complex means for typing ( like a type graph ) and attributes in our framework . defining more general acs , whose graphs are not restricted to be connected , is also under consideration .",
    "following the ideas in  @xcite it could also be interesting to permit quantification on rules themselves ( and not only the acs ) .",
    "we also plan to deepen in the analysis of critical pairs , especially analysing the new kind of conflicts arising due to our acs , as well as by using the negative initial digraphs for the analysis .",
    "finally , the presented concepts of gc and ac could be integrated with other approaches to graph transformation , like the algebraic one .",
    "there are some issues though , that can not be directly translated into dpo / spo : we use the negation of a graph , and work with simple digraphs , which have the built - in restriction that between two nodes at most one edge in each direction is allowed .",
    "corradini , a. , montanari , u. , rossi , f. , ehrig , h. , heckel , r. , lwe , m. 1999 . _ algebraic approaches",
    "to graph transformation - part i : basic concepts and double pushout approach_. in  @xcite , pp . :",
    "163 - 246        ehrig , h. , heckel , r. , korff , m. , lwe , m. , ribeiro , l. , wagner , a. , corradini , a. 1999 . _ algebraic approaches to graph transformation - part ii : single pushout approach and comparison with double pushout approach . _ in  @xcite , pp . : 247 - 312 .",
    "de lara , j. , vangheluwe , h. 2004 .",
    "_ defining visual notations and their manipulation through meta - modelling and graph transformation_. journal of visual languages and computing",
    ". special section on `` domain - specific modeling with visual languages '' , vol 15(3 - 4 ) , pp .",
    ": 309 - 330 .",
    "elsevier science .",
    "prez velasco , p. p. , de lara , j. 2006 .",
    "_ towards a new algebraic approach to graph transformation : long version",
    "rep . of the school of comp .",
    "autnoma madrid . ` http://www.ii.uam.es/\\simjlara/investigacion/techrep_03_06.pdf ` .",
    "prez velasco , p. p. , de lara , j. 2006 .",
    "_ using matrix graph grammars for the analysis of behavioural specifications : sequential and parallel independence _ proc .",
    "prole07 , pp . : 11 - 26 .",
    "notes theor .",
    "pp.:133152 . elsevier .",
    "prez velasco , p. p. , de lara , j. 2009 .",
    "_ a reformulation of matrix graph grammars with boolean complexes_. the electronic journal of combinatorics .",
    "vol 16(1 ) .",
    "available at : ` http://www.combinatorics.org/ ` ."
  ],
  "abstract_text": [
    "<S> in the matrix approach to graph transformation we represent _ simple _ digraphs and rules with boolean matrices and vectors , and the rewriting is expressed using boolean operators only . in previous works , we developed analysis techniques enabling the study of the applicability of rule sequences , their independence , state reachability and the minimal graph able to fire a sequence .    in the present paper </S>",
    "<S> we improve our framework in two ways . </S>",
    "<S> first , we make explicit ( in the form of a boolean matrix ) some negative implicit information in rules . </S>",
    "<S> this matrix ( called _ nihilation matrix _ ) contains the elements that , if present , forbid the application of the rule ( i.e. potential dangling edges , or newly added edges , which can not be already present in the simple digraph ) . </S>",
    "<S> second , we introduce a novel notion of application condition , which combines graph diagrams together with monadic second order logic . </S>",
    "<S> this allows for more flexibility and expressivity than previous approaches , as well as more concise conditions in certain cases . </S>",
    "<S> we demonstrate that these application conditions can be embedded into rules ( i.e. in the left hand side and the nihilation matrix ) , and show that the applicability of a rule with arbitrary application conditions is equivalent to the applicability of a sequence of plain rules without application conditions . </S>",
    "<S> therefore , the analysis of the former is equivalent to the analysis of the latter , showing that in our framework no additional results are needed for the study of application conditions . </S>",
    "<S> moreover , all analysis techniques of  @xcite for the study of sequences can be applied to application conditions .    </S>",
    "<S> * keywords : * graph transformation , matrix graph grammars , application conditions , monadic second order logic , graph dynamics . </S>"
  ]
}