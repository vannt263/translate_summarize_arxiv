{
  "article_text": [
    "the highly variable and unpredictable nature of some renewable energy sources ( such as wind and solar ) has been a major obstacle to their integration . for example , a recent study conducted by enernex for wind power integration in minnesota  @xcite indicates that the variability and day - ahead forecast errors will result in an additional @xmath0 ( for @xmath1 and @xmath2 penetration ) per mwh of delivered wind power . along the same lines",
    ", the caiso report  @xcite predicted that ten minute real - time energy prices could increase substantially due to wind forecasting errors and identified day - ahead and same - day forecasts and modeling as important tasks for integration of renewable resources .",
    "the necessity to offset variability by stand - by generators and system backup investments substantially increases the cost of renewables .",
    "one approach that can mitigate this problem is to couple this supply variability to demand side flexibility  @xcite .",
    "the renewable power suppliers could sell their energy at a lower price to consumers that are willing to wait in a queue , given that it will be served to them within a pre - agreed deadline .",
    "this essentially allows a lower price of renewable energy to consumers willing to provide this extra time flexibility . the renewable power supplier can now use this flexibility to deliver the energy when it is available . the supplier will sometimes , hopefully rarely , be in a situation when a prior deadline commitment can not be matched and will have to purchase the extra energy from the energy spot market ( or maintain a costly system backup ) .",
    "papavasiliou and oren  @xcite introduced this problem and proposed an exact backward dynamic programming algorithm and an efficient approximate dynamic programming algorithm for the scheduling decisions of the renewable energy supplier .    in this paper",
    "we build a similar model and utilize the technique of lyapunov optimization initially developed in @xcite@xcite@xcite for dynamic control of queueing systems for wireless networks .",
    "we show that the queuing model naturally fits in the renewable supplier scheduling problem and present a simple energy allocation algorithm that does not require prior statistical information and is provably close to optimal .",
    "the proposed framework can be extended to include pricing , multiple queues ( with different deadlines ) and different objective functions , building on the general results from  @xcite .",
    "we finally evaluate the proposed algorithm on actual caiso spot market and wind energy production data and show substantial reduction to the operating costs for the renewable supplier compared to a simple greedy algorithm .",
    "in particular , we consider a single renewable energy plant that operates in discrete time with unit timeslots @xmath3 , and provides @xmath4 units of energy on each slot @xmath5 .",
    "the @xmath4 process corresponds to the renewable supply and is assumed to be time varying and unpredictable . since we assume no storage , the energy @xmath4 must either be used or wasted .",
    "demands for this energy arrive randomly according to a process @xmath6 ( being the amount of energy that is requested on slot @xmath5 ) .",
    "we assume that consumers requesting energy are flexible , and can tolerate their energy requests being satisfied with some delay .",
    "the requests are thus stored in a queue .",
    "every slot @xmath5 , we use all of our supply @xmath4 to serve the requests in the queue in a first - in - first - out ( fifo ) manner .",
    "however , this may not be enough to meet all of the requests within a timely manner , and hence we also decide to purchase an amount of energy @xmath7 from an outside ( possibly non - renewable ) plant . letting @xmath8 represent the total energy requests in our queue on slot @xmath5 , we have the following update equation : @xmath9 + a(t)\\ ] ]    the value @xmath7 is a control decision variable , and incurs a cost @xmath10 on slot @xmath5 , where @xmath11 is a process that specifies the per - unit - cost of using the outside energy supply on slot @xmath5 .",
    "the value of @xmath11 can represent a current market price for guaranteed energy services from ( possibly non - renewable ) sources .",
    "as such , the decision to use @xmath7 units of energy on slot @xmath5 means the outside source agrees to provide this much energy at time @xmath12 for some fixed ( and small ) integer @xmath13 , for the price @xmath10 . without loss of generality ,",
    "we assume throughout that @xmath14 , so that the energy request is removed from our queue on the same slot in which we decide to use the outside source . in the actual implementation ,",
    "requests that are served from the outside source can be removed from the primary queue @xmath8 but must still wait an additional @xmath15 slots .",
    "we first look at the problem of choosing @xmath7 to stabilize our queue @xmath8 while minimizing the time average of the cost @xmath10 and also providing a guarantee on the maximum delay @xmath16 spent in the queue .",
    "if the future values of supply , demand , and market price values @xmath17 were known in advance , one could in principle make @xmath7 decisions that minimize total time average cost , possibly choosing @xmath18 for all @xmath5 if it is possible to meet all demands using only the renewable energy @xmath4 .",
    "the challenge is to provide an efficient algorithm without knowing the future . to this end",
    ", we first assume the vector process @xmath17 is i.i.d . over slots",
    "but has an unknown probability distribution . under this assumption",
    ", we develop an algorithm , parameterized by a positive value @xmath19 , that comes within @xmath20 of the minimum time average cost required to stabilize the queue , with a worst - case delay guarantee that is @xmath21 .",
    "the parameter @xmath19 can be tuned as desired to provide average cost arbitrarily close to optimal , with a tradeoff in delay .",
    "we further show that the same algorithm is provably robust to non - i.i.d .",
    "situations , and operates efficiently even for arbitrary sample paths for @xmath17 .",
    "finally , we extend the problem to consider pricing decisions at the renewable energy source , so that the requests @xmath6 are now influenced by the current prices . in this case",
    ", we design a related algorithm that maximizes time average profit .    the lyapunov optimization technique we use  @xcite@xcite@xcite is related to the primal - dual and fluid - model techniques in @xcite@xcite@xcite@xcite .",
    "the work in @xcite@xcite@xcite establishes a general @xmath22 $ ] performance - congestion tradeoff for stochastic network optimization problems with i.i.d .",
    "( and more general ergodic ) processes .",
    "recent work in @xcite@xcite provides similar results on a sample path basis , without any probabilistic assumptions .",
    "we apply these results in our current paper .",
    "further , we extend the theory by introducing a novel virtual queue that turns an average delay constraint of @xmath21 ( which is achievable with the prior analytical techniques ) into a _ worst case delay guarantee _ that is also @xmath21 .",
    "it is useful to distinguish the proposed lyapunov optimization method that we use in this paper from dynamic programming techniques .",
    "dynamic programming can be used to solve stronger versions of our problem ( such as minimizing average cost subject to a delay constraint ) see e.g.  @xcite .",
    "however , dynamic programming requires more stringent system modeling assumptions , has a more complex solution that typically requires knowledge of the supply , demand , and market price probabilities , and can not necessarily adapt if these probabilities change and/or if there are unmodeled correlations in the actual processes .",
    "it involves computation of a value function that can be difficult when the state space of the system is large , and suffers from a _ curse of dimensionality _ when applied to large dimensional systems ( such as systems with many queues ) .    in contrast , lyapunov optimization is relatively simple to implement , does not need a - priori statistical knowledge , and is robust to non - i.i.d . and non - ergodic behavior .",
    "further , it has no curse of dimensionality and hence can be applied just as easily in extended formulations that have multiple queues corresponding to multiple customers requesting different deadlines , contrary to dynamic programming  @xcite which would require exponential complexity in the number of users .",
    "the reason for this efficiency is that lyapunov optimization relaxes the question that dynamic programming asks : rather than minimizing time average cost subject to a delay constraint , it seeks to push time average cost towards the more ambitious minimum over all possible algorithms that can stabilize the queue ( without regard to the delay constraint ) .",
    "it then specifies an explicit bound on the resulting queue congestion , which depends on the desired proximity to the minimum cost ( as defined by the @xmath22 $ ] performance - congestion tradeoff ) .",
    "however , the resulting time average queue congestion ( and delay ) that is achieved is not necessarily the optimal that could be achieved over all possible algorithms that yield the same time average performance cost .    in the next section ,",
    "we formulate the basic model under the assumption that the @xmath17 vector is i.i.d . over slots , and present the main allocation algorithm .",
    "section [ section : pricing ] extends to the case when the renewable power source can set a price for its services .",
    "these algorithms are provably robust to non - i.i.d .",
    "situations and arbitrary sample paths of events , as shown in section [ section : non - iid ] .",
    "section [ section : exp ] presents an experimental evaluation of our algorithm on a real six - month data set and shows substantial gains over a simple greedy scheduling algorithm .",
    "suppose that the supply process @xmath4 , the request process @xmath6 , and the market price process @xmath11 , as described in the introduction , form a vector @xmath17 that is i.i.d . over slots with some unknown probability distribution .",
    "we further assume the values of @xmath4 , @xmath6 , @xmath11 are deterministically bounded by finite constants @xmath23 , @xmath24 , @xmath25 , so that : @xmath26    the queue backlog @xmath8 evolves according to ( [ eq : q - update ] ) .",
    "the decision variable @xmath7 is chosen every slot @xmath5 in reaction to the current @xmath17 ( and possibly additional queue state information ) subject to the constraint @xmath27 for all @xmath5 , where @xmath28 is a finite upper bound .",
    "we assume that @xmath29 so that it is always possible to stabilize the queue @xmath8 ( and this can be done with one slot delay if we choose @xmath30 for all @xmath5 ) .",
    "define @xmath31 as the time average cost incurred by our control policy ( assuming temporarily that our policy yields such a well defined limit ) : @xmath32 we want to find an allocation algorithm that chooses @xmath7 over time to solve : @xmath33 where @xmath34 is the time average expected queue backlog , defined : @xmath35 define @xmath36 as the infimum time average cost associated with the above problem , considering all possible ways of choosing @xmath7 over time .",
    "the value of @xmath36 is an ambitious target because the above problem is defined only in terms of a queue stability constraint and does not impose any additional delay constraint .",
    "we shall construct a solution , parameterized by a constant @xmath37 , that satisfies the constraints of the above problem and pushes the average cost within @xmath20 of the optimal value @xmath36 .",
    "further , we show that our algorithm has the additional property that worst case delay is no more than @xmath21 .",
    "we solve the above problem while also maintaining finite worst case delay using the following novel `` virtual queue '' @xmath38 : fix a parameter @xmath39 , to be specified later .",
    "define @xmath40 , and define the virtual queue @xmath38 for @xmath3 according to the following update : @xmath41 \\label{eq : z - update}\\end{aligned}\\ ] ] where @xmath42 is an indicator function that is 1 if @xmath43 , and zero else .",
    "the intuition is that @xmath38 has the same service process as @xmath8 ( being @xmath44 ) , but now has an arrival process that adds @xmath45 whenever the actual queue backlog is non - empty .",
    "this ensures that @xmath38 grows if there are requests in the @xmath8 queue that have not been serviced for a long time .",
    "if we can control the system to ensure that the queues @xmath8 and @xmath38 have finite upper bounds , then we can ensure all requests are served with a worst case delay given in the following lemma .",
    ", then this bound is modified in the actual implementation to @xmath46 . ]",
    "[ lem : z ] ( worst case delay ) suppose the system is controlled so that @xmath47 and @xmath48 for all @xmath5 , for some positive constants @xmath49 and @xmath50",
    ". then all requests are fulfilled with a maximum delay of @xmath16 slots , where : @xmath51    consider any slot @xmath5 for which @xmath52 .",
    "we show that the requests @xmath6 are fulfilled on or before time @xmath53 .",
    "suppose not ( we shall reach a contradiction ) .",
    "then during slots @xmath54 it must be that @xmath55 ( else the requests @xmath6 would have been served before slot @xmath56 ) .",
    "thus , @xmath57 , and from ( [ eq : z - update ] ) we have that for all @xmath54 : @xmath58 summing the above over @xmath54 yields : @xmath59 + d_{max}\\epsilon\\ ] ] rearranging and using the fact that @xmath60 and @xmath61 yields : @xmath62 \\geq d_{max}\\epsilon - z_{max } & \\label{eq : lemz1 }    \\end{aligned}\\ ] ] now note that the requests @xmath6 are first available for service at time @xmath63 , and are part of the backlog @xmath64 ( see ( [ eq : q - update ] ) ) . because @xmath65 and because service is fifo , these requests @xmath6 are served on or before time @xmath66 whenever there are at least @xmath50 units of energy served during the interval @xmath54 . because we have assumed the requests @xmath6 are _ not _ served by time @xmath66 , it must be that @xmath67 < q_{max}$ ] . using this in ( [ eq : lemz1 ] ) yields : @xmath68 this implies that @xmath69 , contradicting the definition of @xmath16 in ( [ eq : dmax ] ) .",
    "define @xmath70 as the concatenated vector of the real and virtual queues . as a scalar measure of the congestion in both the @xmath38 and @xmath8 queues ,",
    "we define the following lyapunov function : @xmath71 $ ] .",
    "define the conditional 1-slot lyapunov drift as follows : @xmath72 following the drift - plus - penalty framework of @xcite@xcite@xcite , our control algorithm is designed to observe the current queue states @xmath38 , @xmath8 and the current @xmath17 vector , and to make a decision @xmath7 ( where @xmath27 ) to minimize a bound on the following expression every slot @xmath5 : @xmath73 where @xmath19 is a positive parameter that will be useful to affect a performance - delay tradeoff .",
    "we first compute a bound on the above drift - plus - penalty expression .",
    "[ lem : drift - bound ] ( drift bound ) for any control policy that satisfies @xmath27 for all @xmath5 , the drift - plus - penalty expression for all slots @xmath5 satisfies : @xmath74 where the constant @xmath75 is defined : @xmath76}{2}\\ ] ]    see appendix a.      minimizing the right - hand - side of the drift - plus - penalty bound ( [ eq : drift - bound ] ) every slot @xmath5 leads to the following dynamic algorithm : every slot @xmath5 , observe @xmath38 , @xmath8 , @xmath17 , and choose @xmath7 according to the following optimization : @xmath77\\\\ \\mbox{subject to : } & 0 \\leq x(t ) \\leq x_{max } \\end{aligned}\\ ] ] then update the actual and virtual queues @xmath8 and @xmath38 by ( [ eq : q - update ] ) and ( [ eq : z - update ] ) .",
    "the above minimization for the @xmath7 decision reduces to the following simple threshold rule : @xmath78    the above @xmath7 value drives the queueing updates ( [ eq : q - update ] ) and ( [ eq : z - update ] ) .",
    "however , note by the @xmath79 $ ] structure of the @xmath8 update in ( [ eq : q - update ] ) that we may not need to purchase the full @xmath7 units of energy from the outside plant on slot @xmath5 . indeed , define @xmath80 as the _ actual _ amount purchased from the plant , given by : @xmath81   & \\mbox { otherwise }                               \\end{array }                                   \\right.\\ ] ] then we have @xmath82 for all @xmath5 .",
    "[ thm : performance ] ( performance analysis ) suppose @xmath83 $ ] .",
    "if @xmath84 , and if the above dynamic algorithm is implemented with any fixed @xmath85 and @xmath37 for all @xmath3 , then :    \\a ) the queues @xmath8 and @xmath38 are deterministically bounded by @xmath50 and @xmath49 every slot @xmath5 , where : @xmath86    \\b ) the worst case delay of any request is : @xmath87    \\c ) if the vector @xmath17 is i.i.d . over slots , and if the @xmath45 parameter is chosen to satisfy @xmath88 $ ] , then for all slots",
    "@xmath89 the time average cost satisfies : @xmath90 where @xmath75 is defined in ( [ eq : b ] ) .",
    "the above theorem demonstrates the @xmath22 $ ] cost - delay tradeoff , where time average cost is within @xmath91 of the minimum possible time average cost @xmath36 required for queue stability , and worst case delay is proportional to @xmath92 . to obtain the smallest @xmath16 ,",
    "the @xmath45 value should be chosen as large as possible while still maintaining @xmath88 $ ] .",
    "we can choose @xmath93 if this expectation is known .",
    "using @xmath94 preserves parts ( a ) and ( c ) but does not give a finite @xmath16 .",
    "more discussion of the @xmath94 case is given in section [ section : exp ] .",
    "( theorem [ thm : performance ] part ( a ) ) we first show that @xmath95 for all @xmath5 .",
    "this is clearly true for @xmath96 ( because @xmath97 ) .",
    "suppose it holds for slot @xmath5 .",
    "we show it also holds for slot @xmath63 .",
    "consider the case when @xmath98 .",
    "then @xmath99 , because the queue can increase by at most @xmath24 on any slot ( see dynamics ( [ eq : q - update ] ) ) .",
    "thus , the result holds in this case .",
    "now consider the opposite case when @xmath100 . in this case",
    ", we have : @xmath101 and hence the algorithm will choose @xmath30 according to ( [ eq : x - choice ] ) .",
    "if @xmath102 , then on slot @xmath5 we serve at least @xmath28 units of data . because arrivals @xmath6 are at most @xmath24 ( and @xmath103 ) , the queue can not increase on the next slot and so @xmath104 . finally ,",
    "if @xmath105 , then by ( [ eq : q - update ] ) we have @xmath106 , again being less than or equal to @xmath107 .    therefore , @xmath95 for all @xmath5 . the proof that @xmath108 for all @xmath5 is similar and omitted for brevity .",
    "( theorem [ thm : performance ] part ( b ) ) this follows immediately from lemma [ lem : z ] together with part ( a ) .",
    "the proof of theorem [ thm : performance ] part ( c ) requires a preliminary lemma from @xcite . to introduce the lemma ,",
    "@xmath109-only policy _ to be one that observes the current vector @xmath17 and makes a stationary and randomized decision @xmath110 based purely on this vector ( and independent of the queue backlogs or past system history ) , subject to the constraint @xmath111 .",
    "[ lem : optimality ] ( characterizing optimality @xcite ) if the vector @xmath17 is i.i.d . over slots , then there exists a @xmath109-only policy @xmath110 that satisfies : @xmath112 where @xmath36 is the infimum time average cost in the stochastic optimization problem ( [ eq : problem1])-([eq : problem3 ] ) , and the above expectations are with respect to the stationary distribution of the vector @xmath17 and the possibly randomized action @xmath110 made in reaction to this vector .",
    "( lemma [ lem : optimality ] ) this follows as a special case of results in @xcite .",
    "( theorem [ thm : performance ] part ( c ) ) we have assumed that @xmath88 $ ] .",
    "we first prove the result for the case when @xmath113 . on every slot @xmath5 , the dynamic choice of @xmath7 in ( [ eq : x - choice ] )",
    "minimizes the right - hand - side of the drift bound ( [ eq : drift - bound ] ) ( given the observed queue sizes @xmath114 ) , over all alternative choices @xmath110 that satisfy the required bounds @xmath111 ( including randomized choices for @xmath110 ) .",
    "thus , by ( [ eq : drift - bound ] ) we have : @xmath115 where @xmath110 is any alternative ( possibly randomized ) decision . plugging the @xmath116-only policy @xmath110 from ( [ eq : x1opt])-([eq : x2opt ] )",
    "( known to exist by lemma [ lem : optimality ] ) into the right hand side of the above inequality for slot @xmath5 , and noting that this policy makes decisions independent of queue backlogs , yields : @xmath117 where we have used the fact that : @xmath118 where ( [ eq : proofc1 ] ) follows from ( [ eq : x2opt ] ) and the fact that the @xmath116-only policy @xmath110 is i.i.d . over slots and hence independent of queue backlogs @xmath119 , and ( [ eq : proofc2 ] ) follows from ( [ eq : x2opt ] ) together with the fact that @xmath120 .",
    "taking expectations of ( [ eq : drift - almost - done ] ) and using the law of iterated expectations with the definition of @xmath121 in ( [ eq : delta - def ] ) yields : @xmath122 the above holds for all slots @xmath89 .",
    "summing over @xmath123 for some positive integer @xmath124 yields : @xmath125 using the fact that @xmath126 ( because all queues are initially empty ) , and that @xmath127 ( because the lyapunov function is non - negative ) and dividing by @xmath128 yields : @xmath129 this holds for all @xmath130 , proving the result for the case when @xmath113 .",
    "we have only used the assumption that @xmath113 to ensure the inequality ( [ eq : proofc2 ] ) holds . if @xmath131 , then clearly ( [ eq : proofc2 ] ) holds , regardless of the value of @xmath132 .",
    "thus , the result holds whenever @xmath88 $ ] , proving the theorem .",
    "we now extend the problem to consider pricing decisions . instead of a process @xmath6 that represents requests arriving at slot @xmath5 , we define a process @xmath133 , called the _ demand state _ on slot @xmath5 .",
    "the demand state captures any properties of the demand that may affect requests for the renewable energy source in reaction to the price advertised on slot @xmath5 .",
    "a simple example is when @xmath133 can take one of two possible values , such as high and low , representing different demand conditions ( such as during peak times or non - peak times for requesting energy ) .",
    "another example is when @xmath133 represents the number of consumers willing to purchase renewable energy on slot @xmath5 .",
    "we assume the demand state @xmath133 is known at the beginning of each slot @xmath5 ( we show a particular case where @xmath133 does not need to be known after our algorithm is stated ) .",
    "every slot @xmath5 , in addition to choosing the amount of energy @xmath7 purchased from outside sources , the renewable energy plant makes a binary decision @xmath134 , where @xmath135 represents a willingness to accept new requests on slot @xmath5 , and @xmath136 means no requests will be accepted .",
    "if @xmath135 is chosen , the plant also chooses a per - unit - energy price @xmath137 within an interval @xmath138 , where @xmath139 is a pre - established maximum price .",
    "the arriving requests @xmath6 are then influenced by the current price @xmath137 , the current market price @xmath11 , and the current demand state @xmath133 , according to a general _ demand function _ @xmath140 .",
    "specifically , the values of @xmath6 are assumed to be conditionally i.i.d . over all slots with the same @xmath137 , @xmath133 , @xmath11 , and",
    "satisfy : @xmath141 we assume the function @xmath142 is continuous in @xmath143 for each given @xmath144 and @xmath145 . every slot .",
    "] we further assume the arrivals @xmath6 continue to be worst - case bounded by @xmath24 , regardless of @xmath137 , @xmath133 , @xmath11 .",
    "the queue iteration @xmath8 still operates according to ( [ eq : q - update ] ) , with the understanding that @xmath6 is now influenced by the pricing decisions .",
    "let @xmath146 represent the instantaneous profit earned on slot @xmath5 , defined as : @xmath147 we now consider the following problem : @xmath148 where @xmath149 is defined as the limiting time average profit : @xmath150    to solve the problem , we use the same queueing structure for @xmath8 in ( [ eq : q - update ] ) and the same virtual queue structure for @xmath38 in ( [ eq : z - update ] ) , and use the same lyapunov function @xmath151 as defined before ( recall that @xmath119 is defined as the vector @xmath152 ) .",
    "however , we now consider the `` penalty '' @xmath153 , and so the drift - plus - penalty technique seeks to choose a vector that minimizes a bound on : @xmath154 using the same analysis as lemma [ lem : drift - bound ] , we can show the following bound on this drift - plus - penalty expression : @xmath155    our joint energy - allocation and pricing algorithm observes the current system state on each slot @xmath5 , and chooses @xmath156 , @xmath137 , and @xmath7 to minimize the right - hand side of the above drift expression ( given the observed @xmath119 ) .",
    "this reduces to the following : every slot @xmath5 , observe queues @xmath8 , @xmath38 , and observe @xmath4 , @xmath11 , @xmath133 . then choose a price @xmath137 and an allocation @xmath7 as follows :    * ( pricing @xmath137 )",
    "choose @xmath137 as the solution to : @xmath157 if the resulting maximum value is non - negative , choose @xmath158",
    ". else choose @xmath136 so that no new requests are allowed on slot @xmath5 . *",
    "( allocating @xmath7 ) choose @xmath7 according to ( [ eq : x - choice ] ) . *",
    "( queue updates ) update @xmath8 and @xmath38 by ( [ eq : q - update ] ) and ( [ eq : z - update ] )",
    ".    this pricing pricing policy does not need to know the demand state @xmath133 in the special case when @xmath159 , so that demand state simply scales the demand function .",
    "this pricing structure is similar to that considered in @xcite for wireless service providers .",
    "we define a _",
    "@xmath160-only policy _ as one that jointly chooses @xmath110 , @xmath161 , @xmath162 subject to @xmath111 , @xmath163 , @xmath164 according to a stationary and randomized decision that depends only on @xmath4 , @xmath133 , @xmath11 . as in @xcite",
    ", it can be shown that the supremum time average profit @xmath165 associated with the problem ( [ eq : newopt1])-([eq : newopt4 ] ) can be achieved over the class of @xmath160-only policies .",
    "thus , there exists a @xmath160-only policy @xmath110 , @xmath161 , @xmath162 that satisfies : @xmath166 where @xmath167 represents the random requests on slot @xmath5 associated with pricing decisions @xmath161 , @xmath162 and under the random demand state @xmath133 and the random market price @xmath11 .",
    "it is useful to define @xmath168 . in the case",
    "when the policy @xmath162 , @xmath161 , @xmath110 that satisfies ( [ eq : optimalitynew1])-([eq : optimalitynew2 ] ) is not unique , we define @xmath169 as the maximum value such that there exists an @xmath160-only policy that satisfies ( [ eq : optimalitynew1])-([eq : optimalitynew2 ] ) .",
    "[ thm:2 ] assume that @xmath83 $ ] , and that @xmath84 .",
    "if the above joint pricing and allocation policy is implemented every slot with fixed parameters @xmath170 , @xmath37 , then :    \\a ) the worst case delay @xmath16 and backlog @xmath50 are the same as before ( given in ( [ eq : dmax2 ] ) , ( [ eq : qmax ] ) ) , where @xmath50 is proportional to @xmath19 and @xmath16 is proportional to @xmath92 .",
    "\\b ) if the vector @xmath171 is i.i.d . over slots , and",
    "if @xmath172 $ ] ( where @xmath169 is defined in section [ section : price - optimality ] ) , then : , with @xmath80 defined in ( [ eq : x - tilde ] ) .",
    "clearly @xmath173 for all @xmath5 , and so the time average of the actual profit @xmath174 is even closer to the optimal value @xmath165 . ]",
    "@xmath175 where @xmath75 is defined in ( [ eq : b ] ) , and @xmath165 is the optimal time average profit that can be achieved by any algorithm that satisfies the constraints of the problem ( [ eq : newopt1])-([eq : newopt4 ] ) .",
    "see appendix c.",
    "here we extend the analysis to treat non - i.i.d . models . for brevity",
    ", we consider only the problem of section [ section : model ] that seeks to allocate @xmath7 without regard to pricing . with expectation @xmath176 , where the @xmath133 and @xmath11 processes are arbitrary sample paths . ] specifically , we assume that the processes @xmath4 , @xmath6 , @xmath11 vary randomly over slots according to any probability model ( with arbitrary time correlations ) .",
    "however , we continue to assume the sample paths are bounded so that @xmath177 , @xmath178 , @xmath179 for all @xmath5 .",
    "we show that the same algorithm of section [ section : model ] , which allocates @xmath7 according to ( [ eq : x - choice ] ) , still provides efficient performance in this context .",
    "we assume that @xmath84 , and that fixed parameters @xmath37 and @xmath85 are used .",
    "we continue to assume that @xmath83 $ ] .",
    "we first observe that the exact same worst case backlog and delay bounds @xmath50 and @xmath16 given in ( [ eq : qmax ] ) and ( [ eq : dmax2 ] ) hold in this non - i.i.d . case . thus , worst case delay is still bounded by a constant that is proportional to @xmath92 .",
    "this is because the proof of this bound in theorem [ thm : performance ] ( a ) and ( b ) was a _",
    "sample path proof _ that did not make use of the i.i.d . assumptions . indeed , it used only the fact that @xmath178 for all @xmath5 .",
    "it remains only to understand the efficiency of the time average cost . to this end , we use the @xmath180-slot lookahead metric as defined in the universal scheduling work @xcite@xcite . specifically , suppose that the sample path of @xmath17 is chosen at time @xmath181 for all @xmath5 according to some arbitrary values . for a given positive integer @xmath180 and a positive integer @xmath182 , we consider the first @xmath183 slots , composed of @xmath182 successive `` frames '' of size @xmath180 . for each frame @xmath184",
    ", we define @xmath185 as the optimum solution to the following `` ideal '' problem that uses full knowledge of @xmath17 over the frame : @xmath186 \\geq 0 \\label{eq : universal2 } \\\\ & \\ : \\ : 2 )   \\sum_{\\tau = rt}^{(r+1)t-1 } [ s(\\tau ) + x(\\tau ) - \\epsilon ] \\geq 0   \\label{eq : universal3 } \\\\ & \\ : \\ : \\ : \\ : \\ : \\ : 3 ) 0 \\leq x(\\tau ) \\leq x_{max }     \\forall \\tau \\in \\{rt , \\ldots , ( r+1)t-1\\ } \\label{eq : universal4 } \\end{aligned}\\ ] ] thus , @xmath185 is the optimal cost that can be achieved over frame @xmath187 , considering all possible ways of allocating @xmath188 over this frame using perfect knowledge of the future values of @xmath189 over this frame , subject to ensuring the total energy provided over the frame is at least as much as the total sum arrivals , and is also at least @xmath190 .",
    "[ thm : universal ] ( universal scheduling ) under the above assumptions , the worst case backlog and delay are given by @xmath50 and @xmath16 in ( [ eq : qmax ] ) and ( [ eq : dmax2 ] ) .",
    "further , for all positive integers @xmath180 and @xmath182 , we have : @xmath191 where @xmath75 is defined in ( [ eq : b ] ) .",
    "the proof combines the techniques of the proof of theorem [ thm : performance ] with the universal scheduling results in @xcite@xcite , and is given in appendix b.    the above result says that the achieved time average cost over any interval of @xmath183 slots is less than or equal to the average of the @xmath185 values , plus a `` fudge factor '' of at most @xmath192 . while the average of the @xmath185 values is _ not _ the same as the minimum cost that could be achieved with perfect knowledge of the future over the full @xmath183 slots , this result is still interesting because the @xmath185 values are still obtained by ideal algorithms implemented over @xmath180 slot frames with full knowledge of the future events in these frames .",
    "we evaluated the performance of the proposed algorithm on a six - month data set that we created by combining @xmath193-minute average spot market prices @xmath11 for los angeles area ( la1 ) from caiso  @xcite and @xmath193-minute energy production @xmath4 for a small subset of windfarms from the western wind resources dataset published by the national renewable energy laboratory  @xcite .",
    "we modeled the demand @xmath6 as i.i.d . over slots and",
    "uniformly distributed over the integers @xmath194 .",
    "we executed the proposed lyapunov drift optimization algorithm in @xmath193-minute timeslots and experimented with different values of the parameters @xmath195 and the corresponding deadlines they generate .",
    "we compare the proposed algorithm against a simple greedy strategy `` purchase at deadline , '' which tries to use all the available resource @xmath4 and only buys from the spot market as a last resort if a deadline is reached . as can be seen in fig .",
    "[ fg_comp1 ] , the proposed algorithm reduces the cost of the renewable supplier by approximately a factor of @xmath196 in the tested six - month window .",
    "the slope of the two lines is different , suggesting that the savings are unbounded as the time increases .",
    "this is not surprising since the greedy strategy does not hedge for future high prices in the spot market while the proposed algorithm learns to proactively buy when the spot market prices are lower than typical and deadline violations seem probable .",
    "the high variability of the spot market prices  @xcite makes this advantage significant .",
    "the second observation , seen in fig .",
    "[ fg_comp2 ] , is that the proposed algorithm has on average a much smaller delay than the deadline , which for our parameters was @xmath197 hours . on the contrary",
    ", the greedy algorithm makes many requests wait close to ( or exactly at ) the maximum allowed @xmath198 hours .",
    "our results use @xmath199 .",
    "we also conducted simulations with @xmath200 , which does not require knowledge of @xmath132 .",
    "while @xmath94 does not provide a finite delay guarantee , it still guarantees the same finite @xmath50 .",
    "together with fifo service , this means that the worst case delay for requests that arrive at time @xmath5 is given by the smallest integer @xmath201 such that @xmath202 .",
    "while there is no bound on this for general @xmath4 processes , it can still lead to small delays .",
    "indeed , in the simulations it _ still _ maintained all delays under @xmath203 days ( having a maximum experimental delay of 14 hours , as compared to 9.5 hours for the @xmath93 case ) .",
    "case is not shown in fig . [ fg_comp2 ] .",
    "[ fg_comp1 ] shows it gives slightly better cost , particularly because it increases delay .",
    "both lyapunov optimization algorithms provided significantly better cost and delay as compared to the greedy algorithm .",
    "it should be noted that we did not compare against dynamic programming algorithms such as the one proposed in @xcite .",
    "while it is clear that a dynamic programming approach could solve this problem optimally if the statistics of the underlying processes were known , one benefit of our approach is that no such prior knowledge is required .",
    "further , the lyapunov approach yields an efficient algorithm for multiple queues corresponding to different customers with different deadlines .     is not shown , but has max delay @xmath204 hours , as compared with the @xmath205 case ( shown ) with max delay 9.5 hours .",
    "@xmath206,width=302 ]     is not shown , but has max delay @xmath204 hours , as compared with the @xmath205 case ( shown ) with max delay 9.5 hours .",
    "@xmath206,width=302 ]    we now present some further experimental results investigating the influence of varying @xmath19 and @xmath45 in the performance of the proposed algorithm . for these simulations we used the same data set as the previous part . for the first experiment ,",
    "the performance of the algorithm for different values of parameter @xmath19 is compared .",
    "the rest of the parameters are unchanged and are @xmath207 , @xmath208 , @xmath209 , @xmath210 , and @xmath211 .",
    "the result is shown in fig .",
    "[ compv ] . as expected",
    ", the cost decreases with @xmath19 .",
    "the tradeoff is in the maximum waiting time of the packets .",
    "the maximum waiting times observed in the simulations for parameter @xmath19 being @xmath212 are @xmath213 hours , respectively . case of fig .",
    "[ compv ] was 10.2 , rather than 9.5 as in the previous simulation for the case @xmath214 .",
    "this is because this simulation used independently generated @xmath6 values . ]    . for the proposed algorithm we used the parameters @xmath215 , @xmath216 , and @xmath211 .",
    ", width=302 ]    for the second experiment , we consider the performance of our algorithm for different values of @xmath45 . here",
    ", we fixed the value @xmath217 and run the simulation for @xmath218 .",
    "the cost decreases as @xmath45 decreases , as shown in fig .",
    "[ compeps ] . however , the maximum observed waiting times increase with @xmath45 .",
    "so for @xmath219 , the maximum observed waiting times are @xmath220 hours , respectively .",
    "overall , as expected , the cost gets better as @xmath19 is increased , with a tradeoff in waiting time .",
    "further , the waiting time reduces as @xmath45 increases to @xmath221 , although waiting times are still reasonable even with @xmath200 , which is useful when @xmath221 is unknown . for non - i.i.d .",
    "situations , using a smaller value of @xmath45 may also reduce cost due to the fact that this relaxes the constraint ( [ eq : universal3 ] ) .    .",
    "for the proposed algorithm we used the parameters @xmath222 , and @xmath217 . ,",
    "this work presents a lyapunov optimization approach to the problem of efficient use of renewable energy sources .",
    "efficiency can be improved if consumers are flexible and can tolerate their requests being served with some delay .",
    "two different problems were presented : one that seeks to minimize cost associated with using an outside ( possibly non - renewable ) plant to meet the deadlines , and another that seeks to maximize profit by dynamically selecting a price for service .",
    "our algorithms are simple and were shown to operate efficiently without knowing the statistical properties of the supply , demand , and energy request processes .",
    "we first considered a simple case when these processes are i.i.d . over slots but with unknown probabilities .",
    "we next treated the general case of arbitrary ( possibly non - i.i.d . and non - ergodic ) sample paths .",
    "our analysis also contributes to the theory of lyapunov optimization by introducing a new type of virtual queue that guarantees a bounded worst case delay .",
    "our algorithms use a parameter @xmath19 that can be tuned as desired to affect a performance - delay tradeoff , where achieved cost is within @xmath20 from optimal , with a worst case delay guarantee that is @xmath21 .",
    "these techniques provide a convenient alternative to dynamic programming that leads to a general framework for problems that naturally arise in scheduling of renewable energy markets .",
    "from the @xmath38 update rule ( [ eq : z - update ] ) we have : @xmath223\\ ] ] and hence : @xmath224 thus : @xmath225 + z(t)(\\epsilon - s(t ) -x(t ) ) \\end{aligned}\\ ] ] similarly , by squaring ( [ eq : q - update ] ) and using the inequality : @xmath226 + a)^2 \\leq q^2 + \\mu^2 + a^2 + 2q(a-\\mu)\\ ] ] which holds for any @xmath227 , @xmath228 , @xmath229 , we obtain : @xmath230 \\nonumber \\\\",
    "+ q(t)(a(t ) - s(t ) - x(t ) ) \\label{eq : q - one - slot } \\end{aligned}\\ ] ] combining the above yields : @xmath231 taking conditional expectations of the above , given @xmath119 , and adding @xmath232 to both sides proves the result .",
    "again define @xmath233 $ ] , and define the lyapunov function @xmath151 the same as before : @xmath234\\ ] ] as in @xcite@xcite , for a given integer @xmath201 , we define the _ @xmath180-slot sample path drift _ @xmath235 as follows : @xmath236 this differs from our 1-slot conditional drift @xmath121 , used for the i.i.d .",
    "analysis , because ( i ) it involves @xmath180 slots , rather than 1 slot , and ( ii ) it does not use an expectation .",
    "now suppose that the values @xmath237 and @xmath188 satisfy the following for all @xmath56 : @xmath238 we have the following lemma .",
    "[ lem : t - slot - drift ] fix any slot @xmath5 , any queue state @xmath239 $ ] , and any integer @xmath201 .",
    "consider an arbitrary sample path for @xmath240 , over the interval @xmath241 , assumed only to satisfy ( [ eq : bounds1])-([eq : bounds2 ] ) .",
    "assume that the decisions for @xmath188 are given by the algorithm ( [ eq : x - choice ] ) , with queue updates for @xmath8 and @xmath38 given by ( [ eq : q - update ] ) and ( [ eq : z - update ] ) .",
    "then : @xmath242 \\\\",
    "+ z(t)\\sum_{\\tau = t}^{t-1}[\\epsilon - s(\\tau ) - x^*(\\tau)]\\end{aligned}\\ ] ] where @xmath243 are any alternative choices that satisfy @xmath244 for all @xmath245 .",
    "the constant @xmath75 is given in ( [ eq : b ] ) .    from ( [ eq : drift - step ] ) we have that for all @xmath56 : @xmath246 summing the result over @xmath247 yields : @xmath248 adding the penalty term to both sides yields : @xmath249 we now use the fact that for each slot @xmath56 , the value of @xmath188 is chosen to minimize : @xmath250\\ ] ] over all @xmath188 such that @xmath251 .",
    "it follows that : @xmath252 where for all @xmath245 , @xmath243 is any value that satisfies @xmath253 .",
    "now note that the maximum changes in the @xmath254 and @xmath255 queues on one slot are given by constants @xmath256 and @xmath257 , respectively , defined : @xmath258 \\\\ c_z & { \\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$ } } } & \\max[s_{max } + x_{max } , \\epsilon ] \\end{aligned}\\ ] ] thus : @xmath259 where we have used the fact that @xmath260 . however , it is not difficult to show that : @xmath261 and hence : @xmath262 this proves the result .",
    "now fix a frame size @xmath201 , consider the timeline decomposed into @xmath182 successive frames of size @xmath180 , and consider any frame @xmath184 .",
    "define @xmath185 as the optimum cost in the frame-@xmath187 problem ( [ eq : universal1])-([eq : universal4 ] ) , and define @xmath243 for @xmath263 as the optimal decisions for that problem , which achieve @xmath185 and satisfy the inequality constraints ( [ eq : universal2])-([eq : universal4 ] ) . then using the drift",
    "bound given in lemma [ lem : t - slot - drift ] together with the equalities and inequalities ( [ eq : universal1])-([eq : universal4 ] ) , we have : @xmath264 summing the above over @xmath184 , using the definition of @xmath235 , and dividing by @xmath265 yields : @xmath266 using the fact that @xmath126 and @xmath267 yields the result .",
    "part ( a ) follows by noting that the proof of parts ( a ) and ( b ) in theorem [ thm : performance ] hold exactly in this new context , as we have not changed the queueing dynamics for @xmath8 or @xmath38 or the fact that @xmath268 for all @xmath5 .",
    "we now prove part ( b ) .",
    "we have assumed that @xmath172 $ ] .",
    "we first prove the result for the case @xmath269 . on each slot @xmath5",
    "our dynamic algorithm makes actions @xmath156 , @xmath137 , @xmath7 that , given the observed @xmath239 $ ] , minimizes the right hand side of the drift inequality ( [ eq : price - drift ] ) over all alternative choices .",
    "thus : @xmath270 where @xmath161 , @xmath162 , @xmath110 are any other choices that satisfy : @xmath271 we now use the existence of a @xmath272-only policy @xmath110 , @xmath161 , @xmath162 that satisfies the inequalities ( [ eq : optimalitynew1])-([eq : optimalitynew2 ] ) .",
    "it is not difficult to show that ( [ eq : optimalitynew1])-([eq : optimalitynew2 ] ) are equivalent to the following : @xmath273 where the above conditional expectations ( [ eq : onew1])-([eq : onew3 ] ) given @xmath119 are the same as the unconditional expectations , because the @xmath272-only policy does not depend on the queue states @xmath119 ( recall that @xmath171 is i.i.d . over slots and hence independent of queue states ) . plugging ( [ eq : onew1])-([eq : onew3 ] ) directly into the right hand side of ( [ eq : price - drift2 ] ) yields : @xmath274 because we have assumed that @xmath269 , this reduces to : @xmath275 taking expectations of the above ( with respect to the random @xmath276 and using the law of iterated expectations gives : @xmath277 the above holds for all slots @xmath5 .",
    "summing over @xmath278 for some integer @xmath130 yields : @xmath279 dividing by @xmath128 and using the fact that @xmath280 and @xmath281 yields : @xmath282 this holds for all @xmath130 , proving the result for the case @xmath269 .",
    "we have used the fact that @xmath269 only in showing the @xmath283 term on the right hand side of ( [ eq : appcfoo1 ] ) can be removed while preserving the inequality . however , suppose that @xmath131 . then the @xmath284 term in the right hand side of ( [ eq : price - drift2 ] ) can immediately be removed ( recall that @xmath285 and @xmath286 because @xmath4 is i.i.d . over slots and",
    "hence independent of current queue backlog ) .",
    "this leads directly to ( [ eq : appcfoo2 ] ) regardless of the value of @xmath169 .",
    "thus , the result holds whenever @xmath172 $ ] , proving the theorem .              c.  loutan and d.  hawkins , `` integration of renewable resources .",
    "transmission and operating issues and recommendations for integrating renewable resources on the california iso - controlled grid , '' in _ technical report , california independent system operator _ , 2007 ."
  ],
  "abstract_text": [
    "<S> we investigate the problem of allocating energy from renewable sources to flexible consumers in electricity markets . </S>",
    "<S> we assume there is a renewable energy supplier that provides energy according to a time - varying ( and possibly unpredictable ) supply process </S>",
    "<S> . the plant must serve consumers within a specified delay window , and incurs a cost of drawing energy from other ( possibly non - renewable ) sources if its own supply is not sufficient to meet the deadlines . </S>",
    "<S> we formulate two stochastic optimization problems : the first seeks to minimize the time average cost of using the other sources ( and hence strives for the most efficient utilization of the renewable source ) . </S>",
    "<S> the second allows the renewable source to dynamically set a price for its service , and seeks to maximize the resulting time average profit . </S>",
    "<S> these problems are solved via the lyapunov optimization technique . </S>",
    "<S> our resulting algorithms do not require knowledge of the statistics of the time - varying supply and demand processes and are robust to arbitrary sample path variations . </S>"
  ]
}