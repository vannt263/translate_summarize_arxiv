{
  "article_text": [
    "determining whether two convex polytopes @xmath0 and @xmath1 , embedded in a lattice @xmath2 , are isomorphic with respect to a lattice automorphism is a fundamental computational problem .",
    "for example , in toric geometry lattice polytopes form one of the key constructions of projective toric varieties , and any classification must somehow address the issue of whether there exists an automorphism of the underlying lattice sending @xmath0 to @xmath1 . in general ,",
    "any isomorphism problem can be solved in one of two ways : on a case - by - case basis by constructing an explicit isomorphism between the two objects , or by determining a normal form for each isomorphism class .",
    "the first approach  dynamically constructing a lattice - preserving isomorphism in @xmath3 between the two polytopes  is discussed in   [ sec : iso_via_face_graph ] .",
    "we describe one possible way to determine isomorphism of polytopes via the labelled face graph @xmath4 ( see   [ subsec : labelled_face_graph ] ) .",
    "this has the advantage that it works equally well for rational polytopes and for polytopes of non - zero codimension . by reducing the problem to a graph isomorphism question",
    ", well - developed tools such as brendan mckay s  nauty software  @xcite can then be applied .    because our approach to isomorphism testing works equally well for rational polytopes , we are able to answer when two polytopes are equivalent , i.e.  when there exists an isomorphism @xmath5 and lattice translation @xmath6 such that @xmath7 .",
    "this is discussed in   [ subsec : equivalence ] .",
    "we can also calculate the automorphism group @xmath8 of @xmath0 : this is a subgroup of the automorphism group of @xmath4 , as explained in   [ subsec : aut_p ] . since our methods make no assumptions on the codimension of @xmath0 , by considering the automorphism group of @xmath9 in @xmath10 we are able to calculate the group of affine automorphisms @xmath11 . as an illustration of our methods ,",
    "we calculate the order of the automorphism group for each of the @xmath12 four - dimensional reflexive polytopes  @xcite : see table  [ tab : num_4topes ] .    the second approach  to compute a normal form @xmath13 for each isomorphism class  is discussed in   [ sec : palp_normal_form ] .",
    "this is the approach adopted by kreuzer and skarke in their palp software  @xcite , and was used to construct the classification of three- and four - dimensional reflexive polytopes  @xcite .",
    "briefly , row and column permutations are applied to the vertex ",
    "facet pairing matrix @xmath14 of @xmath0 , placing it in a form @xmath15 that is maximal with respect to a certain ordering .",
    "this in turn defines an order in which to list the vertices of @xmath0 ; the choice of basis is fixed by taking the hermite normal form . in   [ subsec : affine_normal_form ] we address how this can be modified to give an affine normal form for @xmath0 , and in   [ subsec : palp_normal_form ] we describe how palp applies an additional reordering of the columns of @xmath15 before computing the normal form .",
    "the palp source code for computing @xmath13 is analyzed in detail in appendix  [ apx : palp_source_code ] .    in   [ sec : exploiting_aut ] we address the problem of calculating @xmath15 .",
    "we describe an inductive algorithm which attempts to exploit automorphisms of the matrix in order to simplify the calculation ; pseudo - code is given in appendix  [ apx : matrix_isomorphism ] . applying our algorithm to smooth fano polytopes  @xcite , which often have large numbers of symmetries ,",
    "illustrates the advantage of this approach : see   [ subsec : analysis_smooth_db ] and table  [ tab : timings ] .",
    "we end by giving , in   [ sec : laurent_normal_form ] , an application of normal form to laurent polynomials .",
    "the algorithms described in   [ sec : iso_via_face_graph ] were implemented using magma in  @xmath16 and officially released as part of magma  v@xmath17  @xcite ; palp normal form was introduced by kreuzer and skarke in their palp software  @xcite and reimplemented natively in magma  v@xmath18 by the authors .",
    "the magma algorithms , including the reimplementation of palp normal form , have recently been ported to the sage project  @xcite by samuel gonshaw .",
    "] , assisted by tom coates and the second author , and should appear in the  @xmath19 release .",
    "this work was motivated in part by discussions with max kreuzer during august and september 2010 , shortly before his death that november .",
    "we are honoured that he found the time and energy for these conversations during this period .",
    "it forms part of the collaborative @xmath20 project envisioned in  @xcite .",
    "our thanks to tom coates for many useful discussions , to harald skarke and dmitrii pasechnik for several helpful comments on a draft of this paper , to john cannon for providing copies of the computational algebra software magma , and to andy thomas for technical assistance .",
    "the first author was funded by a summer studentship as part of tom coates royal society university research fellowship .",
    "the second author is supported by epsrc grant ep / i008128/1 .",
    "throughout this section we work with very general convex polytopes ; we assume only that @xmath21 is a ( non - empty ) rational convex polytope , not necessarily of maximum dimension in the ambient lattice @xmath2 .",
    "the dual lattice @xmath22 is denoted by @xmath23 .    given two polytopes @xmath0 and @xmath24 , how can we decide whether they are isomorphic and , if they are , how can we construct an isomorphism between them ? there are , of course , some obvious checks that can quickly provide a negative answer .",
    "we give a few examples , although this list is far from comprehensive .",
    "* do the dimensions of the polytopes agree ?",
    "* does @xmath0 contain the origin in its relative interior ?",
    "is the same true for @xmath24 ?",
    "* are @xmath0 and @xmath24 both lattice polytopes ?",
    "* are the @xmath25-vectors of @xmath0 and @xmath24 equal ?",
    "* do @xmath0 and @xmath24 have the same number of primitive vertices ? * are @xmath0 and @xmath24 simplicial ?",
    "are they simple ? * if @xmath0 is of codimension one then there exists a unique hyperplane @xmath26 containing @xmath0 , where @xmath27 for some non - negative rational value @xmath28 and primitive dual lattice point @xmath29",
    ". in particular , @xmath28 is invariant under change of basis .",
    "does @xmath28 agree for both @xmath0 and @xmath24 ? *",
    "if @xmath0 is of maximum dimension , any facet @xmath30 can be expressed in the form @xmath31 , where @xmath32 is a primitive inward - pointing vector normal to @xmath30 , and @xmath33 is the lattice height of @xmath30 over the origin .",
    "the value of @xmath34 is invariant under change of basis .",
    "do the facet heights of @xmath0 and @xmath24 agree , up to permutation ? * if @xmath0 is a rational polytope , let @xmath35 be the smallest positive integer such that the dilation @xmath36 is a lattice polytope .",
    "do @xmath35 and @xmath37 agree ?    from a computational point of view , the intention with the above list is to suggest tests that are easy to perform .",
    "we assume that data such as the vertices and supporting hyperplanes of @xmath0 have already been calculated .",
    "some computations , such as finding the @xmath25-vector , are more involved , but since the calculations will be required in what follows it seems sensible to use them at this stage .    in practice a number of other invariants may already be cached and could also be used : the volume @xmath38 or boundary volume @xmath39 ; the number of lattice points @xmath40 or boundary lattice points @xmath41 ; the ehrhart @xmath42-vector ; information about the polar polyhedron @xmath43 . in particular cases",
    "some of this additional data may be easy to calculate ; in general they are usually more time - consuming to compute than the isomorphism test described below .",
    "there are a few potential catches for the unwary when considering rational polytopes with @xmath44 .",
    "for example , care needs to be taken when defining the supporting hyperplanes .",
    "also , the notion of ( normalised ) volume @xmath38 requires some attention : the affine sublattice @xmath45 may be empty , forcing us to either accept that @xmath38 can be undefined , or to employ interpolation .",
    "there is a natural dichotomy between those polytopes whose affine span contains the origin and those where @xmath46 . in the latter case ,",
    "it is often better to consider the cone @xmath47 equipped with an appropriate grading such that dilations of @xmath0 can be realised by taking successive slices through @xmath48 .      in order to determine isomorphism we make use of the face graph @xmath49 of @xmath0 .",
    "let @xmath0 be an @xmath50-dimensional polytope with @xmath25-vector @xmath51 , where @xmath52 denotes the number of @xmath28-faces of @xmath0 . by convention we set @xmath53 , representing , respectively , the empty set @xmath54 and the polytope @xmath0 .",
    "the _ face graph _",
    "@xmath49 is the graph consisting of @xmath55 vertices , where each vertex @xmath56 corresponds to a face @xmath57 .",
    "two vertices @xmath56 and @xmath58 are connected by an edge if and only if @xmath59 and @xmath60 . here",
    "the dimension of the empty face @xmath54 is taken to be @xmath61 .",
    "the face graph of a polytope is completely determined by the vertex ",
    "facet relations , and is the standard tool for determining combinatorial isomorphism of polytopes . we augment @xmath49 by assigning labels to the vertices determined by some invariants of the corresponding face . reducing a symmetry problem to the study of a ( labelled ) graph",
    "is a well - established computational technique : see , for example ,  @xcite . the intention is to decorate the graph with data capturing how @xmath0 lies in the underlying lattice @xmath2 .",
    "to that end , we make the following definition .    for a point @xmath62 ,",
    "let @xmath63 be the unique primitive lattice point such that @xmath64 for some non - negative value @xmath65 ( set @xmath66 , @xmath67 if @xmath68 ) .",
    "we define @xmath69 to be given by @xmath70 , i.e. @xmath69 is the first lattice point after or equal to @xmath56 on the ray defined by @xmath56 .",
    "let @xmath71 be a polytope with vertices @xmath72 .",
    "then the _ index _ @xmath73 of @xmath0 is the index of the sublattice generated by @xmath74 in @xmath75 .",
    "[ def : labelled_face_graph ] let @xmath0 be an @xmath50-dimensional polytope with face graph @xmath49 .",
    "to each vertex @xmath56 of @xmath49 we assign the label @xmath76 we denote this labelled graph by @xmath4 .    in place of the index @xmath77 , it is tempting to use the volume @xmath78 .",
    "however , computing the index is basic linear algebra , whereas computing the volume is generally difficult .      when @xmath0 contains the origin strictly in its interior , we can make use of the _ special facets_. recall from  @xcite that a facet @xmath30 is said to be special if @xmath79 , where @xmath80 is the sum of the vertices of @xmath0 .",
    "since @xmath0 contains the origin , there exists at least one special facet ; we can extend the labelling to indicate which vertices of @xmath4 correspond to a special facet .",
    "the polytope @xmath81 and its labelled face graph @xmath4 are depicted below . in the graph , the top - most vertex represents @xmath0 and the bottom vertex @xmath54 .",
    "the sum of the vertices is @xmath82 , so there is a unique special facet : the edge joining vertices @xmath83 and @xmath84 of index three , labelled @xmath85 in @xmath4 .",
    "the edge joining vertices @xmath83 and @xmath86 is of index one and labelled @xmath87 ; the remaining edge is of index two and labelled @xmath88 .",
    "the final entry of each facet label is used to indicate whether this is a special facet .",
    "if @xmath0 is a rational polytope , the vertices of @xmath0 provide an augmentation to the labelling of @xmath4 . for any vertex @xmath89",
    "there exists a primitive lattice point @xmath63 and a non - negative rational value @xmath65 such that @xmath64 . since @xmath65 is invariant under change of basis ,",
    "the corresponding labels can be extended with this information .",
    "( note that @xmath90 when @xmath56 is a lattice point , so this only provides additional information in the rational case . )",
    "we do not claim that these are the only easily - computed invariants that can be associated with @xmath4 .",
    "other possibilities include encoding the linear relations between the vertices @xmath72 of @xmath0 in the graph labelling , and , in the maximum dimensional case , adding information about the lattice height of the supporting hyperplanes for each face .",
    "we now describe our algorithm for computing an isomorphism between two polytopes @xmath0 and @xmath24 .",
    "the initial step is to normalise the polytopes .",
    "if @xmath0 and @xmath24 are not of maximum dimension in the ambient lattice @xmath2 , then we first restrict to the sublattice @xmath75 ( and , respectively , @xmath91 ) .",
    "it is possible that , even after restriction , @xmath0 and @xmath24 are of codimension one . in that case",
    ", we work with the convex hull @xmath92 ( and similarly for @xmath24 ) .",
    "the important observations are that , after normalisation , @xmath0 is of maximum dimension , and that there exists at least one facet @xmath93 of @xmath0 such that @xmath94 .",
    "now we calculate an arbitrary graph isomorphism @xmath95 . by restricting to the vertices of @xmath4 corresponding to the vertices @xmath72 of @xmath0",
    ", @xmath96 induces a map from the vertices of @xmath0 to the vertices of @xmath24 .",
    "the two polytopes @xmath0 and @xmath24 are isomorphic only if @xmath96 exists , and any isomorphism @xmath97 mapping @xmath0 to @xmath24 can be factored as @xmath98 , where @xmath99 .",
    "it remains to decide whether a particular choice of @xmath99 determines a lattice isomorphism @xmath100 sending @xmath0 to @xmath24 .",
    "for this we make use of the facet @xmath93 . by construction @xmath93",
    "is of codimension one , and does not lie in a hyperplane containing the origin .",
    "hence there exists a choice of vertices @xmath101 of @xmath93 which generate @xmath102 ( over @xmath103 ) .",
    "denote the image of @xmath104 in @xmath24 by @xmath105 , and consider the @xmath106 matrices @xmath107 and @xmath108 whose rows are given by , respectively , the @xmath104 and the @xmath105 . in order for @xmath98 to be a lattice map",
    "we require that @xmath109 . in order for this to be an isomorphism from @xmath0 to @xmath24",
    "we require that @xmath110 .",
    "we make two brief observations .",
    "first , in practice the automorphism group @xmath111 is often small .",
    "second , it is an easy exercise in linear algebra to undo our normalisation process , lifting @xmath112 back to act on the original polytope .",
    "recall that two polytopes @xmath113 are said to be _ equivalent _ if there exists an isomorphism @xmath5 and a translation @xmath6 such that @xmath114 .",
    "let @xmath72 be the set of vertices of a polytope @xmath0 .",
    "then the _ vertex average _ of @xmath0 is the point @xmath115    two polytopes @xmath0 and @xmath24 are equivalent if and only if @xmath116 and @xmath117 is isomorphic to @xmath118 .",
    "consider the simplices @xmath119 the vertex averages are @xmath120 and @xmath121 , and @xmath122 , where @xmath123 hence @xmath0 and @xmath24 are equivalent .",
    "we can use the labelled face graph @xmath4 to compute the automorphism group @xmath124 .",
    "we simply use the elements @xmath125 of @xmath111 to construct @xmath126 .",
    "notice that there is no requirement that @xmath0 is of maximum dimension in the ambient lattice @xmath2 .",
    "given this , we can also compute the affine automorphism group @xmath127 . begin by embedding @xmath0 at height one in the lattice @xmath10 ( equivalently , consider the cone @xmath48 spanned by @xmath0 with appropriate grading ) .",
    "we refer to this embedded image of @xmath0 as @xmath128 .",
    "the action of the automorphism group @xmath129 on @xmath128 restricts to an action on @xmath0 , realising the full group of affine lattice automorphisms of  @xmath0 .",
    "a detailed discussion of polyhedral symmetry groups and their applications can be found in  @xcite .",
    "[ ex : involution ] let @xmath0 be the three - dimensional simplicial polytope with seven vertices given by @xmath130 , @xmath131 , @xmath132 , @xmath87 , @xmath133 .",
    "this is sketched below ; the @xmath25-vector is @xmath134 .",
    "the index @xmath135 of each face @xmath30 is one ( in fact @xmath0 is a smooth fano polytope in the graded ring database  @xcite . ] ) , and @xmath0 has four special facets ( the four facets incident to the vertex @xmath136 ) .",
    "the resulting labelled graph @xmath4 has automorphism group of order four , however @xmath124 has order two , and is generated by the involution @xmath137 .",
    "[ ex:24cell ] the four - dimensional centrally symmetric polytope @xmath0 with vertices @xmath138 is the reflexive realisation of the @xmath139-cell , with @xmath25-vector @xmath140 .",
    "it is unique amongst all @xmath12 reflexive polytopes in having @xmath141 ; in fact @xmath124 is isomorphic to the weyl group @xmath142 . in particular",
    ", @xmath0 must be self - dual .",
    "the number of four - dimensional reflexive polytopes with @xmath143 of given size are recorded in table  [ tab : num_4topes ] .",
    "cc    .the number @xmath144 of four - dimensional reflexive polytopes with automorphism group of size @xmath143 . [ cols=\"^,^\",options=\"header \" , ]",
    "let @xmath145 $ ] be a laurent polynomial in @xmath50 variables , and let @xmath146 denote the newton polytope of @xmath25 .",
    "we require throughout that @xmath147 , i.e.  that @xmath0 is of maximum dimension in the ambient lattice .",
    "an element @xmath5 corresponds to the invertible monomial transformation @xmath148 and @xmath149 is also a laurent polynomial .",
    "in particular , @xmath150 .",
    "as when working with lattice polytopes , it can be advantageous to be able to present @xmath25 in a normal form with respect to transformations of type  .    [",
    "defn : laurent_ordering ] given two laurent polynomials @xmath25 and @xmath151 such that @xmath152 , we define an order @xmath153 on @xmath25 and @xmath151 as follows .",
    "let @xmath154 be the lattice points in @xmath155 , listed in lexicographic order .",
    "to each point @xmath104 there exists a ( possibly zero ) coefficient @xmath156 of @xmath157 in @xmath25 , and coefficient @xmath158 in @xmath151 .",
    "define @xmath159 .",
    "we write @xmath160 if and only if @xmath161 .",
    "any laurent polynomial @xmath25 determines a pair @xmath162 .",
    "conversely , given any pair @xmath163 , where @xmath164 and @xmath71 is a maximum - dimensional lattice polytope such that @xmath165 , we can associate a laurent polynomial . if we insist that the @xmath156 associated with the vertices @xmath72 are non - zero then we have a one - to - one correspondence .",
    "[ defn : laurent_normal_form ] let @xmath25 be a laurent polynomial , and set @xmath146 .",
    "let @xmath5 be such that @xmath166 .",
    "the _ normal form _ for @xmath25 is @xmath167    [ eg : laurent_normal_form ] consider the laurent polynomial @xmath168 then @xmath13 has vertices @xmath83 , @xmath86 , and @xmath169 , with corresponding transformation matrix @xmath170 under this transformation , @xmath171 and @xmath172 . the automorphism group @xmath173 acts by permuting the non - zero elements in the coefficient vector , hence @xmath174    a nave implementation of laurent normal form faces a serious problem : listing the points in a polytope is computationally expensive , and will often be the slowest part of the algorithm by many orders of magnitude . with a little care this can be avoided .",
    "what is really needed in definition  [ defn : laurent_normal_form ] is not the entire coefficient vector , but the closure of the non - zero coefficients under the action of @xmath175 .",
    "we illustrate this observation with an example .",
    "[ eg : orbit_closure ] consider the laurent polynomial @xmath176 set @xmath177 .",
    "notice that @xmath178 ; enumerating the points in @xmath0 is clearly not the correct approach .",
    "the normal form @xmath13 is given by change of basis @xmath179 with @xmath180 the automorphism group @xmath181 is of order two , generated by the involution @xmath182 .",
    "we consider the closure of the nine lattice points corresponding to the exponents of @xmath151 under the action of @xmath183 .",
    "the only additional point is @xmath184 .",
    "thus we can express @xmath185 with respect to these ten points : @xmath186 the key observation is that the action of @xmath183 on @xmath151 will not introduce any additional points , hence the lexicographically smallest coefficient sequence with respect to these points will also be the smallest coefficient sequence with respect to all the points of @xmath13 . by applying the involution",
    "we obtain the smaller coefficient sequence @xmath187 , hence @xmath188    we conclude this section by remarking that the automorphism group @xmath189 of a laurent polynomial @xmath25 can easily be constructed from @xmath190 by restricting to the subgroup that leaves @xmath191 invariant .",
    "we describe in detail the algorithm used by kreuzer and skarke in palp  @xcite to compute the normal form of a lattice polytope @xmath0 of maximum dimension @xmath50 .",
    "any such polytope can be represented by a @xmath192 matrix @xmath107 whose columns correspond to the vertices of @xmath0 .",
    "this matrix is unique up to permutation of columns and the action of @xmath3 ; i.e. one can change the order of the vertices and the underlying basis for the lattice to obtain a different matrix @xmath108 .    the palp normal form is a unique representation of the polytope @xmath0 such that if @xmath1 is any other maximum dimensional lattice polytope , then @xmath0 and @xmath1 are isomorphic if and only if their normal forms are equal . for any matrix @xmath107 with integer entries , and any @xmath193 , the hermite normal form of @xmath194",
    "is uniquely defined .",
    "the question is how to define a canonical order for the vertices , since permuting the vertices will lead to a different hermite normal form .    in what follows",
    ", the line numbers refer to the palp source file  ` polynf.c ` , updated november  @xmath195 ,  @xmath196 .",
    "http://hep.itp.tuwien.ac.at/~kreuzer/cy/palp/palp-1.1.tar.gz[`http://hep.itp.tuwien.ac.at/\\simkreuzer/cy/palp/palp-1.1.tar.gz ` ] ] .",
    "we have chosen our notation to correspond as closely as possible to the source code .",
    "the algorithm will be described in eight stages :    1 .   the pairing matrix ; 2 .   the maximal pairing matrix ; 3 .   constructing the first row ; 4 .   computing the restricted automorphism group ,",
    "step i ; 5 .   constructing the @xmath28-th row ; 6 .   updating the set of permutations ; 7 .   computing the restricted automorphism group , step ii ; 8 .   computing the normal form of the polytope .",
    "we start by constructing the pairing matrix @xmath14 .",
    "0.9rx line:&197 ( ` init_rvm_vpm ` ) + input:&a list of vertices and a list of equations for the supporting hyperplanes .",
    "+ output:&the pairing matrix @xmath14 .",
    "+    let @xmath197 be the vertices of @xmath0 , in some order , and @xmath198 , @xmath199 , be the equations of the supporting hyperplanes of @xmath0 . here",
    "@xmath200 is equal to the number of vertices of @xmath0 , and @xmath201 is equal to the number of facets of @xmath0 .",
    "the @xmath202 are the inward - pointing primitive facet normals , and the @xmath156 are necessarily integers .",
    "the pairing matrix @xmath14 is the @xmath203 matrix @xmath204 with integral coefficients .",
    "the order of the columns of @xmath14 corresponds to an order of the vertices of @xmath0 , and the order of the rows of @xmath14 corresponds to an order of the facets of @xmath0 .",
    "let @xmath205 act on @xmath14 via @xmath206      let @xmath15 denote the maximal lexicographic matrix ( when reading row by row ) obtained from @xmath14 by reordering rows and columns , so that @xmath207    it can happen that @xmath208 is non - trivial , say @xmath209 .",
    "then we have @xmath210 permutations @xmath211 such that @xmath212 , and @xmath210 corresponding orders for the vertices of the polytope .",
    "our main task is to compute @xmath15 and @xmath211 from @xmath14 .",
    "this will be done by induction on the rows of @xmath15 .",
    "we begin by constructing the first row of @xmath15 .",
    "0.9rx line:&348 ( ` aux_vnf_line ` ) + input:&the paring matrix @xmath14",
    ". + output:&an array of permutations giving the first row of @xmath15 .",
    "+    set @xmath213 and maximise the first row of @xmath14 , i.e. find a permutation @xmath214 such that @xmath215 , @xmath216 :    @xmath217 @xmath218 @xmath219 @xmath220 @xmath221    suppose we have computed the first @xmath222 lines , @xmath210 of which could be chosen to be the first row of @xmath15 ( i.e.  up to reordering of the facets they are maximal among other lines and equal to the reference line , denoted @xmath223 ) .",
    "then we have integers @xmath224 with corresponding permutations @xmath225 , @xmath226 , and a reference line defined by @xmath227 such that : @xmath228 set @xmath229 to be the permutation which moves the line in question to the first row of @xmath14 .",
    "now we consider the @xmath28-th row of @xmath14 .",
    "find the maximal element @xmath230 , say @xmath231 , and let @xmath232 .",
    "we compare this against the reference line .",
    "if @xmath233 then continue with the next line ( or stop if we are at the last line ) , otherwise continue constructing @xmath234 . if @xmath235 then let @xmath236 and verify that @xmath237 ; if this inequality fails to hold then continue with the next element .",
    "if the line @xmath28 is not less than the reference line @xmath223 then we set @xmath238 and have two cases to consider :    1 .",
    "if @xmath239 , @xmath240 , then we have a new case of symmetry .",
    "we set @xmath241 and increment the number of symmetries @xmath210 .",
    "otherwise we have found a ( lexicographically ) bigger row and so obtain a new reference line .",
    "we set @xmath242 , @xmath243 , and @xmath244 , and reset the number of symmetries @xmath210 .",
    "@xmath245 @xmath246 @xmath247 @xmath248 * continue * @xmath249 @xmath250 @xmath251 * break * * continue*@xmath252 @xmath253 @xmath254",
    "@xmath217 @xmath255      once the first row of @xmath15 has been constructed , it imposes restrictions on any future column permutations : they must fix the first row .",
    "0.9rx line:&376 ( ` aux_vnf_line ` ) + input:&the first line of the maximal pairing matrix",
    ". + output:&the array @xmath256 capturing its automorphism group .",
    "+    suppose that the row is equal to blocks of @xmath257 s , each of size @xmath258 , @xmath259 , where @xmath260 : @xmath261    it is clear that if we had such a row , the only permutations of columns allowed in the construction of later rows will be those factoring through @xmath262 .",
    "the symmetry of this row is encoded in an array @xmath256 such that if @xmath263 and @xmath264 then the index @xmath265 is in the block delimited by the indices @xmath266 and @xmath267 ( depending on whichever is greater ) .",
    "we represent @xmath256 as an array @xmath268    [ aex : first_s ] the symmetries of the row @xmath269 are encoded by the array @xmath270    when @xmath271 the columns are fixed and we may only permute the rows .",
    "the computation of @xmath256 is summarised in the following pseudo - code :    @xmath272 @xmath273 @xmath274 @xmath275      proceeding by induction on the rows , we construct the remaining rows of @xmath15 .    0.9rx line:&289 ( ` aux_vnf_line ` ) + input:&@xmath14 , the permutations @xmath276 , and the array @xmath256 .",
    "+ output:&the @xmath28-th line of the maximal pairing matrix .",
    "+    assume we have computed the first @xmath277 rows of @xmath15 and the associated symmetry array @xmath256 ( notice that the last row of @xmath15 need not be computed as it is completely determined ) , together with @xmath210 distinct permutations @xmath225 such that @xmath278    we have to consider each configuration given by the permutations @xmath211 .",
    "for each configuration we generally obtain @xmath279 ways to construct the line @xmath280 , moreover some constructions might give a smaller line , hence @xmath210 will have to be updated as we proceed .",
    "let @xmath281 record the initial value of @xmath210 .",
    "first consider the case @xmath282 .",
    "we will construct a candidate line for the @xmath280-th row of @xmath15 ; this will be our reference line against which the other cases will be compared .",
    "if a greater candidate is found , all the preceding computations will have to be deleted and redone with the new candidate .",
    "if a given case lead to a smaller line than the reference , it will have to be deleted .",
    "initially set the local number of symmetries , @xmath279 , to zero and initialise the permutation @xmath283 .",
    "we start with the line @xmath284 by finding the maximal element of the first symmetry block .",
    "suppose that @xmath285 then we update @xmath286 to @xmath287 .",
    "this maximal value is saved in the reference line which we denote @xmath288 ( if it were already constructed , @xmath289 , we move straight to the tests below ) .",
    "we increment @xmath279 by one to reflect this new candidate , initialise @xmath290 , and proceed to consider the maximal entries in the first symmetry block for other lines @xmath291 , @xmath292 .",
    "inductively , suppose we have considered @xmath293 lines where @xmath279 of them have a maximal element in the first symmetry block equal to the one of the reference line @xmath294 , and the others have smaller values .",
    "we also have @xmath295 from the initialisation .",
    "consider the line @xmath296 and find its maximal element in @xmath297 as above , updating @xmath286 . now",
    "if @xmath298 then proceed to the case @xmath299 , if possible .",
    "otherwise @xmath300 and there are two possibilities : if @xmath301 then increase the number of symmetries @xmath302 and move to @xmath299 , after initialising the new permutation @xmath303 ; if @xmath304 then redefine the first element of the reference line @xmath305 , update the first permutation @xmath306 , and reset @xmath307 ready for the next permutation @xmath283 .",
    "@xmath308 @xmath309 @xmath310 @xmath311 @xmath312 @xmath313 @xmath314 @xmath315 @xmath316 @xmath311 @xmath317 * continue * @xmath314 @xmath315 @xmath311 @xmath313 @xmath318 @xmath319 @xmath320 @xmath311 @xmath321 @xmath322    note that the initial value of the _ comparison flag _ @xmath323 is @xmath324 .",
    "this indicates that the reference line has not been initialised ; it is also reset to zero when a greater candidate is found .",
    "we will see later how @xmath323 is updated .",
    "we need to construct other elements of @xmath288 .",
    "inductively , suppose we are constructing the entry @xmath265 of @xmath288 and we have @xmath279 symmetries with corresponding permutations @xmath325 , @xmath326 .",
    "if @xmath327 we move to the next configuration @xmath222 after having updated the symmetries accordingly , i.e.  we do not save the current configuration . otherwise , start with the last @xmath328 .",
    "determine where the corresponding block of symmetry ends for @xmath265 by looking at the maximum of @xmath329 and @xmath330 , which we will call @xmath267 . then compute @xmath331 and update @xmath332 .",
    "this value is saved in the reference line @xmath333 .",
    "then we consider ( inductively ) any cases of symmetry with @xmath334 and compute the @xmath265-th entry in the same manner as above : if @xmath335 then continue with the next @xmath266 ; if @xmath336 then the current case is removed and we update @xmath337 ; finally if @xmath338 then all cases previously considered are irrelevant , so we let @xmath339 and the reference line is updated @xmath340 .",
    "@xmath341 @xmath310 @xmath342 @xmath343 @xmath344 @xmath345 @xmath346 @xmath316 @xmath347 @xmath348 @xmath349 @xmath346 @xmath318 @xmath350 @xmath321      the last step in the construction of the line @xmath280 is to organise the new symmetries for a given case @xmath28 .",
    "0.9rx line:&333 ( ` aux_vnf_line ` ) + input:&the permutations @xmath276 and the newly computed @xmath351 .",
    "+ output:&the updated set @xmath276 .",
    "+    recall that @xmath281 denotes the number of symmetries we had before performing the computations for the line @xmath280 of @xmath15 , and @xmath352 represents the updated number symmetries . our current construction of the line @xmath280 may well introduce new symmetries , so - called  _ local symmetries _ , of which there are @xmath279 .",
    "we can have @xmath327 , in which case all the configurations in the case @xmath28 lead to a smaller candidate for @xmath280 .",
    "when @xmath353 the local symmetries are represented by the set @xmath351 of new permutations .",
    "we now update the array of all permutations .",
    "if @xmath354 we set @xmath355 ; we want the set of permutations @xmath356 to be updated so that the only cases which need to be considered are those with index @xmath357 .",
    "since we are appending @xmath279 new permutations at end for the indices @xmath358 , so @xmath359 . if @xmath327 then nothing is appended and @xmath210 decreases by one as required .",
    "finally , we update the comparison flag @xmath323 to reflect the current number of symmetries .",
    "@xmath360 @xmath361 @xmath362 @xmath363 @xmath253      once a new row of @xmath15 has been compute we need to update @xmath256 to reflect the symmetries of this row .",
    "this is done by restricting the blocks previously delimited by @xmath256 to reflect any additional constraints imposed by the row .",
    "continuing example  [ aex : first_s ] , suppose that the second row of the candidate @xmath15 has been computed , and that the two rows are given by @xmath364 the corresponding array @xmath256 is @xmath365    0.9rx line:&376 ( ` aux_vnf_line ` ) + input:&the newly computed upper block of the maximal pairing matrix .",
    "+ output:&the updated array @xmath256 capturing the automorphism group of the matrix .",
    "+    @xmath308 @xmath366 @xmath367 @xmath368 @xmath369 @xmath370 @xmath367 @xmath368      inductively , we have obtained @xmath210 permutations @xmath371 such that @xmath212 .",
    "we are really only interested in the permutations of the columns , since they correspond to permutations of the vertices of @xmath0 .",
    "the palp algorithm computes a new order for the columns of @xmath15 based on the following : the maximum coefficient in the column ; the sum of the coefficients in the column ; and the relative position of the column in @xmath15 .",
    "let @xmath372 denote this column permutation .",
    "0.9rx line:&216 ( ` new_pnf_order ` ) + input:&the maximal pairing matrix @xmath15 .",
    "+ output:&the column permutation @xmath372 .",
    "+    @xmath373 @xmath374 @xmath375 @xmath376 @xmath377 @xmath378 @xmath379 @xmath380 @xmath381    given the column permutations @xmath382 and @xmath156 , @xmath383 , we obtain a permutation of the vertices of @xmath0 , and hence of the columns of the vertex matrix @xmath107 .",
    "we let @xmath384 denote this reordered vertex matrix .",
    "the remaining freedom ",
    "the action of @xmath3 corresponding to the choice of lattice basis  is removed by computing the hermite normal form @xmath385 .",
    "0.9rx line:&134 ( ` glz_make_trian_nf ` ) + input:&a matrix with integer coefficents .",
    "+ output:&the hermite normal form of the matrix .",
    "+    the palp normal form is simply the minimum amongst the @xmath385 .",
    "0.9rx line:&399 ( ` aux_make_triang ` ) + input:&the column permutations @xmath382 and @xmath386 , and the vertex matrix @xmath107",
    ". + output:&the normal form .",
    "let @xmath387 be an @xmath388 matrix . recall that we define an action of @xmath389 on the rows and columns of @xmath387 via @xmath390 , and that we call two matrices @xmath387 and @xmath391 isomorphic if there exists some permutation @xmath392 such that @xmath393 .",
    "we begin by briefly describing one approach to determining when two matrices are isomorphic .    given a matrix @xmath387 , we associate a bipartite graph @xmath394 with @xmath395 vertices , where the vertices @xmath104 , @xmath396 are connected by an edge @xmath397 for all @xmath398 , @xmath399 .",
    "each edge @xmath397 is labelled with the corresponding value @xmath400 .",
    "the vertices @xmath104 , @xmath398 , are labelled with one colour , whilst the vertices @xmath396 , @xmath399 , are labelled with a second colour .",
    "this distinguishes between vertices representing rows of @xmath387 and vertices representing columns of @xmath387 .",
    "clearly two matrices @xmath387 and @xmath391 are isomorphic if and only if the graphs @xmath394 and @xmath401 are isomorphic .",
    "we note also that the automorphism group @xmath402 is given by the automorphism group of @xmath394 .        throughout",
    "we set @xmath403 and @xmath404 equal to , respectively , the number of rows and the number of columns of the input matrix @xmath14 . a vector @xmath405 of length @xmath404 is used to represent the permitted permutations of the columns of @xmath14 .",
    "initially @xmath405 is defined as @xmath406 where @xmath407 is larger than any entry of the matrix @xmath14 . at each step of the recursion ,",
    "the value of @xmath404 remains unchanged , but the value of @xmath403 will decrease by one as a row of @xmath14 is removed from consideration . the vector @xmath405 will be modified to reflect the symmetries of the previously steps ; two coefficients @xmath408 and @xmath409 are equal if and only if the columns @xmath266 and @xmath28 can be exchanged without affecting the computations so far . by construction @xmath405",
    "will always satisfy :      the first stage is to calculate the maximum possible row @xmath414 of @xmath14 , where each row is sorted in decreasing order .",
    "once done , we update the vector @xmath405 to reflect the possible column permutations that will leave @xmath414 unchanged .",
    "when all possible symmetries of the columns have been exhausted , the vector @xmath429 will be equal to the sequence @xmath430 if this is the case , then @xmath15 is the maximum matrix in @xmath420 , once the rows have been placed in decreasing order .",
    "if there remain symmetries to explore , then we recurse on each of the matrices in @xmath420 using the new permutation vector @xmath429 ; @xmath15 is given by the largest resulting matrix .",
    "gavin brown , jarosaw buczyski , and alexander  m. kasprzyk , _ convex polytopes and polyhedra _ , handbook of magma functions , edition 2.16 ,",
    "november 2009 , available online at http://magma.maths.usyd.edu.au/magma/handbook/convex_polytopes_and_polyhedra[`http://magma.maths.usyd.edu.au/ ` ] .",
    "wieb bosma , john cannon , and catherine playoust , _ the magma algebra system .",
    "i. the user language _ , j. symbolic comput . * 24 * ( 1997 ) , no .  3 - 4 , 235265 , computational algebra and number theory ( london , 1993 ) .",
    "david bremner , mathieu dutour  sikiri , and achill schrmann , _ polyhedral representation conversion up to symmetries _ , polyhedral computation , crm proc .",
    "lecture notes , vol .",
    "48 , amer .",
    "soc . , providence , ri , 2009 , pp .",
    "4571 .",
    "mikkel bro , _ an algorithm for the classification of smooth fano polytopes _ , http://arxiv.org/abs/0704.0049[`arxiv:0704.0049v1 [ math.co ] ` ] , classifications available from http://grdb.lboro.ac.uk/[`http://grdb.lboro.ac.uk/ ` ] ."
  ],
  "abstract_text": [
    "<S> we describe an algorithm for determining whether two convex polytopes @xmath0 and @xmath1 , embedded in a lattice , are isomorphic with respect to a lattice automorphism . we extend this to a method for determining if @xmath0 and @xmath1 are equivalent , i.e.  whether there exists an affine lattice automorphism that sends @xmath0 to @xmath1 . </S>",
    "<S> methods for calculating the automorphism group and affine automorphism group of @xmath0 are also described .    </S>",
    "<S> an alternative strategy is to determine a normal form such that @xmath0 and @xmath1 are isomorphic if and only if their normal forms are equal . </S>",
    "<S> this is the approach adopted by kreuzer and skarke in their palp software . </S>",
    "<S> we describe the kreuzer  </S>",
    "<S> skarke method in detail , and give an improved algorithm when @xmath0 has many symmetries . </S>",
    "<S> numerous examples , plus two appendices containing detailed pseudo - code , should help with any future reimplementations of these techniques . </S>",
    "<S> we conclude by explaining how to define and calculate the normal form of a laurent polynomial . </S>"
  ]
}