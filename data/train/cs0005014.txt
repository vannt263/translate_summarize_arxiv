{
  "article_text": [
    "description logics ( dls ) are a well - known family of knowledge representation formalisms  @xcite .",
    "they are based on the notion of concepts ( unary predicates , classes ) and roles ( binary relations ) , and are mainly characterised by constructors that allow complex concepts and roles to be built from atomic ones .",
    "sound and complete algorithms for the interesting inference problems such as subsumption and satisfiability of concepts are known for a wide variety of dls  @xcite .",
    "to be used in a specific application , the expressivity of the dl must be sufficient to describe relevant properties of objects in the application domain .",
    "for example , transitive roles ( e.g. `` ancestor '' ) and inverse roles ( e.g. `` successor''/``predecessor '' ) play an important rle not only in the adequate representation of complex , aggregated objects  @xcite , but also for reasoning with conceptual data models  @xcite .",
    "moreover , reasoning with respect to cyclic definitions is crucial for applying dls to reasoning with database schemata @xcite .",
    "the relevant inference problems for ( extensions of ) dls that allow for transitive and inverse roles are known to be decidable  @xcite , and appropriate inference algorithms have been described  @xcite , but their high degree of non - determinism appears to prohibit their use in realistic applications .",
    "this is mainly due to the fact that these algorithms can handle not just transitive roles but also the transitive closure of roles .",
    "it has been shown  @xcite that restricting a dl to transitive roles can lead to a lower complexity , and that transitive roles ( even when combined with role hierarchies ) allow for algorithms that behave quite well in realistic applications  @xcite",
    ". however , it remained to show that this is still true when inverse roles and qualifying number restrictions are also present .",
    "this paper extends our understanding of these issues in several directions .",
    "firstly , we present an algorithm that decides satisfiability of @xmath0@xcite ( which can be seen as a notational variant of the multi modal logic @xmath1 ) extended with transitive and inverse roles , role hierarchies , and qualifying number restrictions , i.e. , concepts of the form @xmath2 that allow the description of objects by restricting the number of objects of a given type they are related to via a certain role .",
    "the algorithm can also be used for checking satisfiability and subsumption with respect to general concept inclusion axioms ( and thus cyclic definitions ) because these axioms can be `` internalised '' .",
    "the absence of transitive closure leads to a lower degree of non - determinism , and experiments indicate that the algorithm is well - suited for implementation .    secondly , we show that @xmath0extended with both transitive _ and _ inverse roles is still in pspace .",
    "the algorithm used to prove this rather surprising result introduces an enhanced _ blocking _ technique . in general , blocking is used to ensure termination of the algorithm in cases where it would otherwise be stuck in a loop .",
    "the enhanced blocking technique allows such cases to be detected earlier and should provide useful efficiency gains in implementations of this and more expressive dls .",
    "finally , we investigate the limits of decidability for this family of dls , showing that relaxing the constraints placed on the kinds of roles allowed in number restrictions leads to the undecidability of all inference problems .    due to a lack of space we can only present selected proofs . for full details",
    "please refer to @xcite .",
    "in this section , we present the syntax and semantics of the various dls that are investigated in subsequent sections .",
    "this includes the definition of inference problems ( concept subsumption and satisfiability , and both of these problems with respect to terminologies ) and how they are interrelated .",
    "the logics we will discuss are all based on an extension of the well known dl @xmath0",
    "@xcite to include transitively closed primitive roles  @xcite ; we will call this logic @xmath3due to its relationship with the proposition ( multi ) modal logic @xmath4",
    "@xcite.has previously been called @xmath5 , but this becomes too cumbersome when adding letters to represent additional features . ]",
    "this basic dl is then extended in a variety of ways  see figure  [ fig : sfamily ] for an overview .",
    "[ syntax+semantics ] let @xmath6 be a set of _ concept names _ and @xmath7a set of _ role names _ with transitive role names @xmath8 .",
    "the set of @xmath9-_roles _ is @xmath10 .",
    "the set of @xmath9-_concepts _ is the smallest set such that every concept name is a concept , and , if @xmath11 and @xmath12 are concepts and @xmath13 is an @xmath9-role , then @xmath14 , @xmath15 , @xmath16 , @xmath17 , and @xmath18 are also concepts . to avoid considering roles such as @xmath19",
    ", we define a function @xmath20 on roles such that @xmath21 if @xmath13 is a role name , and @xmath22 if @xmath23 .",
    "we also define a function @xmath24 which returns @xmath25 iff @xmath13 is a transitive role . more precisely , @xmath26 iff @xmath27 or @xmath28 .",
    "@xmath29is obtained from @xmath9by allowing , additionally , for a set of _ role inclusion axioms _ of the form @xmath30 , where @xmath13 and @xmath31 are two roles , each of which can be inverse .",
    "for a set of role inclusion axioms @xmath32 , @xmath33 is called a _ role hierarchy _ , where @xmath34 is the transitive - reflexive closure of @xmath35 over @xmath36 .",
    "@xmath37is obtained from @xmath29by allowing , additionally , for _ qualifying number restrictions _ ,",
    "i.e. , for concepts of the form @xmath38 and @xmath39 , where @xmath13 is a _ simple _ ( possibly inverse ) role and @xmath40 is a non - negative integer .",
    "a role is called _ simple _ iff it is neither transitive nor has transitive sub - roles .",
    "@xmath41is the restriction of @xmath37where qualifying number restrictions may only be of the form @xmath42 and @xmath43 . in this case , we omit the symbol @xmath44 and write @xmath45 and @xmath46 instead .    an _ interpretation _ @xmath47 consists of a set @xmath48 , called the _ domain _ of @xmath49 , and a _ valuation _",
    "@xmath50 which maps every concept to a subset of @xmath48 and every role to a subset of @xmath51 such that , for all concepts @xmath11 , @xmath12 , roles @xmath13 , @xmath31 , and non - negative integers @xmath40 , the properties in figure  [ fig : sfamily ] are satisfied , where @xmath52 denotes the cardinality of a set @xmath53 .",
    "an interpretation satisfies a role hierarchy @xmath54 iff @xmath55 for each @xmath56 ; we denote this fact by @xmath57 and say that @xmath49 is a model of @xmath54 .",
    "a concept @xmath11 is called _ satisfiable _ with respect to a role hierarchy @xmath54 iff there is some interpretation @xmath49 such that @xmath57 and @xmath58 .",
    "such an interpretation is called a _ model of _",
    "@xmath11 w.r.t .",
    "a concept @xmath12 _ subsumes _ a concept @xmath11 w.r.t .",
    "@xmath54 ( written @xmath59 ) iff @xmath60 holds for each model @xmath49 of @xmath54 . for an interpretation @xmath49 , an individual @xmath61",
    "is called an _ instance _ of a concept @xmath11 iff @xmath62 .",
    "all dls considered here are closed under negation , hence subsumption and ( un)satisfiability w.r.t .",
    "role hierarchies can be reduced to each other : @xmath63 iff @xmath64 is unsatisfiable w.r.t .",
    "@xmath54 , and @xmath11 is unsatisfiable w.r.t . @xmath54",
    "iff @xmath65 for some concept name @xmath66 .    [ cols=\"<,^,^,^\",options=\"header \" , ]     in @xcite ,",
    "the _ internalisation _ of terminological axioms is introduced , a technique that reduces reasoning with respect to a ( possibly cyclic ) terminology to satisfiability of concepts . in @xcite",
    ", we saw how role hierarchies can be used for this reduction . in the presence of inverse roles , this reduction must be slightly modified .    a _ terminology _ @xmath67is a finite set of _ general concept inclusion axioms _ , @xmath68 , where @xmath69 are arbitrary @xmath37-concepts .",
    "an interpretation @xmath49 is said to be a _ model _ of @xmath67iff @xmath70 holds for all @xmath71 .",
    "@xmath11 is _ satisfiable _ with respect to @xmath67 iff there is a model @xmath49 of @xmath67with @xmath72 . finally , @xmath12 _ subsumes _ @xmath11 with respect to @xmath67iff for each model @xmath49 of @xmath67 we have @xmath73 .",
    "the following lemma shows how general concept inclusion axioms can be _ internalised _ using a `` universal '' role @xmath74 , that is , a transitive super - role of all roles occurring in @xmath67and their respective inverses .",
    "[ lemma : terminologies ] let @xmath67be a terminology , @xmath75 a set of role inclusion axioms and @xmath76 @xmath37-concepts and let @xmath77 let @xmath74 be a transitive role that does not occur in @xmath78 , or @xmath75 .",
    "we set @xmath79 then @xmath11 is satisfiable w.r.t .",
    "@xmath67and @xmath54 iff @xmath80 is satisfiable w.r.t .",
    "moreover , @xmath12 subsumes @xmath11 with respect to @xmath67and @xmath54 iff @xmath82 is unsatisfiable w.r.t . @xmath81 .",
    "the proof of lemma  [ lemma : terminologies ] is similar to the ones that can be found in @xcite .",
    "most importantly , it must be shown that , ( a ) if a @xmath37-concept @xmath11 is satisfiable with respect to a terminology @xmath67and a role hierarchy @xmath54 , then @xmath83 have a _ connected _ model , and ( b ) if @xmath84 is reachable from @xmath85 via a role path ( possibly involving inverse roles ) , then @xmath86 .",
    "these are easy consequences of the semantics and the definition of @xmath74 .",
    "[ theorem : internal ] satisfiability and subsumption of @xmath37-concepts ( resp .",
    "@xmath29-concepts ) w.r.t .",
    "terminologies and role hierarchies are polynomially reducible to ( un)satisfiability of @xmath37-concepts ( resp .",
    "@xmath29-concepts ) w.r.t .",
    "role hierarchies .",
    "in this section , we present two tableaux algorithms : the first decides satisfiability of @xmath37-concepts , and can be used for all @xmath37reasoning problems ( see theorem  [ theorem : internal ] ) ; the second decides satisfiability ( and hence subsumption ) of @xmath9-concepts in pspace .",
    "please note that @xmath41(and hence @xmath37 ) no longer has the finite model property : for example , the following concept , where @xmath13 is a transitive super - role of @xmath87 , is satisfiable , but each of its models has an infinite domain .",
    "@xmath88    this concept requires the existence of an infinite @xmath89-path , where the first element on the path satisfies @xmath90 while all other elements satisfy @xmath91 . this path can not collapse into a cycle : ( a ) it can not return to the first element because this element can not satisfy both @xmath11 and @xmath90 ; ( b ) it can not return to any subsequent element on the path because then this node would not satisfy @xmath92 .    the correctness of the algorithms we are presenting can be proved by showing that they create a _ tableau _ for a concept iff it is satisfiable . for ease of construction",
    ", we assume all concepts to be in _ negation normal form _ ( nnf ) , that is , negation occurs only in front of concept names .",
    "any @xmath37-concept can easily be transformed to an equivalent one in nnf by pushing negations inwards  @xcite ; with @xmath93 we denote the nnf of @xmath90 . for a concept @xmath11 in nnf",
    "we define @xmath94 as the smallest set of concepts that contains @xmath11 and is closed under subconcepts and @xmath95",
    ". please note that size of @xmath94 is linearly bounded by the size of @xmath11 .",
    "[ def : alchr2 ] let @xmath12 be a @xmath37-concept in nnf , @xmath54 a role hierarchy , and @xmath96 the set of roles occurring in @xmath12 and @xmath54 together with their inverses . then @xmath97 is a _ tableau _ for @xmath12 w.r.t .",
    "@xmath54 iff @xmath98 is a set of individuals , @xmath99 maps each individual to a set of concepts , @xmath100 maps each role to a set of pairs of individuals , and there is some individual @xmath101 such that @xmath102 .",
    "furthermore , for all @xmath103 , @xmath104 , and @xmath105 , it holds that :    1 .",
    "if @xmath106 , then @xmath107 , 2 .   if @xmath108 , then @xmath109 and @xmath110 , 3 .   if @xmath111 , then @xmath109 or @xmath110 , 4 .   if @xmath112 and @xmath113 , then @xmath114 , 5 .",
    "if @xmath115 , then there is some @xmath116 such that @xmath113 and @xmath117 , 6 .   if @xmath112 and @xmath118 for some @xmath119 with @xmath120 , then @xmath121 , 7 .   @xmath122 iff @xmath123 , 8 .   if @xmath118 and @xmath124 , then @xmath125 , 9 .   if @xmath126 , then @xmath127 , 10 . if @xmath128 , then",
    "@xmath129 , 11 .",
    "if @xmath130 and @xmath113 then @xmath117 or @xmath131 ,    where we use @xmath132 as a placeholder for both @xmath133 and @xmath134 and we define @xmath135    tableaux for @xmath9-concepts are defined analogously and must satisfy properties 1 - 7 , where , due to the absence of a role hierarchy , @xmath34 is the identity .    due to the close relationship between models and tableaux ,",
    "the following lemma can be easily proved by induction . as a consequence ,",
    "an algorithm that constructs ( if possible ) a tableau for an input concept is a decision procedure for satisfiability of concepts .",
    "[ lemma : shin - tabl ] a @xmath37-concept ( resp .",
    "@xmath9-concept ) @xmath12 is satisfiable w.r.t .",
    "a role hierarchy @xmath54 iff @xmath12 has a tableau w.r.t . @xmath54 .      in the following ,",
    "we give an algorithm that , given a @xmath37-concept @xmath12 , decides the existence of a tableaux for @xmath12 .",
    "we implicitly assume an arbitrary but fixed role hierarchy @xmath54 .",
    "the tableaux algorithm works on a finite _ completion tree _ ( a tree some of whose nodes correspond to individuals in the tableau , each node being labelled with a set of @xmath37-concepts ) , and employs a _ blocking _ technique @xcite to guarantee termination : if a path contains two pairs of successive nodes that have pair - wise identical label and whose connecting edges have identical labels , then the path beyond the second pair is no longer expanded , it is said to be blocked .",
    "blocked paths can be `` unravelled '' to construct an infinite tableau .",
    "the identical labels make sure that copies of the first pair and their descendants can be substituted for the second pair of nodes and their respective descendants .",
    "[ def : shin - algo ] a _ completion tree _ for a @xmath37-concept @xmath12 is a tree where each node @xmath85 of the tree is labelled with a set @xmath136 and each edge @xmath137 is labelled with a set @xmath138 of ( possibly inverse ) roles occurring in @xmath139 ; explicit inequalities between nodes of the tree are recorded in a binary relation @xmath140 that is implicitly assumed to be symmetric .    given a completion tree , a node @xmath84 is called an @xmath13-_successor _ of a node @xmath85 iff @xmath84 is a successor of @xmath85 and @xmath141 for some @xmath31 with @xmath142 .",
    "a node @xmath84 is called an @xmath13__-neighbour _ _ of @xmath85 iff @xmath84 is an @xmath13-successor of @xmath85 , or if @xmath85 is an @xmath143-successor of @xmath84 .",
    "predecessors and ancestors are defined as usual .",
    "a node is _ blocked _ iff it is directly or indirectly blocked .",
    "a node @xmath85 is _ directly blocked _",
    "iff none of its ancestors are blocked , and it has ancestors @xmath144 , @xmath84 and @xmath145 such that    1 .",
    "@xmath85 is a successor of @xmath144 and @xmath84 is a successor of @xmath145 _ and _ 2 .",
    "@xmath146 and @xmath147 _ and _ 3 .",
    "@xmath148 .    in this case",
    "we will say that @xmath84 _ blocks _ @xmath85 .",
    "since this blocking technique involves pairs of nodes , it is called _ pair - wise _ blocking .",
    "a node @xmath84 is _ indirectly blocked _",
    "iff one of its ancestors is blocked , or it is a successor of a node @xmath85 and @xmath149 ; the latter condition avoids wasted expansions after an application of the @xmath133-rule .    for a node @xmath85",
    ", @xmath150 is said to contain a _ clash _",
    "iff @xmath151 or if , for some concept @xmath11 , some role @xmath31 , and some @xmath152 : @xmath153 and there are @xmath154 @xmath31-neighbours @xmath155 of @xmath85 such that @xmath156 and @xmath157 for all @xmath158 .",
    "a completion tree is called _ clash - free _ iff none of its nodes contains a clash ; it is called _ complete _ iff none of the expansion rules in figure  [ table : alchfi ] is applicable .    for a @xmath37-concept @xmath12 ,",
    "the algorithm starts with a completion tree consisting of a single node @xmath85 with @xmath159 and @xmath160 .",
    "it applies the expansion rules in figure  [ table : alchfi ] , stopping when a clash occurs , and answers `` @xmath12 is satisfiable '' iff the completion rules can be applied in such a way that they yield a complete and clash - free completion tree .",
    "the soundness and completeness of the tableaux algorithm is an immediate consequence of lemmas  [ lemma : shin - tabl ] and [ lemma : shin - algo - correct ] .",
    "[ lemma : shin - algo - correct ] let @xmath12 be an @xmath37-concept .    1 .",
    "the tableaux algorithm terminates when started with @xmath12 .",
    "if the expansion rules can be applied to @xmath12 such that they yield a complete and clash - free completion tree , then @xmath12 has a tableau .",
    "if @xmath12 has a tableau , then the expansion rules can be applied to @xmath12 such that they yield a complete and clash - free completion tree .",
    "the proof can be found in the appendix . here",
    ", we will only discuss the intuition behind the expansion rules and their correspondence to the constructors of @xmath37 .",
    "roughly speaking , the completion tree is a partial description of a model whose individuals correspond to nodes , and whose interpretation of roles is taken from the edge labels . since the completion tree is a tree , this would not yield a correct interpretation of transitive roles , and thus the interpretation of transitive roles is built via the transitive closure of the relations induced by the corresponding edge labels .",
    "the @xmath161- , @xmath162- , @xmath163- and @xmath164-rules are the standard tableaux rules for @xmath0or the propositional modal logic @xmath165 .",
    "the @xmath166-rule is the standard rule for @xmath167 or the propositional modal logic @xmath168 extended to deal with role - hierarchies as follows .",
    "assume a situation that satisfies the precondition of the @xmath166-rule , i.e. , @xmath169 , and there is an @xmath13-neighbour @xmath84 of @xmath85 with @xmath120 , @xmath170 and @xmath171 .",
    "if @xmath84 has an @xmath13-successor @xmath172 , then , due to the transitivity of @xmath13 , @xmath172 is also an @xmath13-successor of @xmath85 .",
    "since @xmath124 , it is also an @xmath31-successor of @xmath85 and hence must satisfy @xmath11 .",
    "this is ensured by adding @xmath173 to @xmath174    the rules dealing with qualifying number restrictions work similarly to the rules given in @xcite . for a concept @xmath175 ,",
    "the @xmath134-rule generates @xmath40 @xmath13-successors @xmath176 of @xmath85 with @xmath177 . to prevent the @xmath133-rule from indentifying the new nodes",
    ", it also sets @xmath157 for each @xmath178 .",
    "conversely , if @xmath179 and @xmath85 has more than @xmath40 @xmath13-neighbours that are labelled with @xmath11 , then the @xmath133-rule chooses two of them that are not in @xmath180 and merges them , together with the edges connecting them with @xmath85 .",
    "the definition of a clash takes care of the situation where the @xmath180 relation makes it impossible to merge any two @xmath13-neighbours of @xmath85 , while the _ choose_-rule ensures that all @xmath13-neighbours of @xmath85 are labelled with either @xmath11 or @xmath93 . without this rule ,",
    "the unsatisfiability of concepts like @xmath181 would go undetected .",
    "the relation @xmath180 is used to prevent infinite sequences of rule applications for contradicting number restrictions of the form @xmath38 and @xmath182 , with @xmath183 .",
    "labelling edges with sets of roles allows a single node to be both an @xmath13 and @xmath31-successor of @xmath85 even if @xmath13 and @xmath31 are not comparable with respect to @xmath34 .",
    "the following theorem is an immediate consequence of lemma  [ lemma : shin - tabl ] and [ lemma : shin - algo - correct ] , and theorem  [ theorem : internal ] .    [",
    "theorem : dec - shin ] the tableaux algorithm is a decision procedure for the satisfiability and subsumption of @xmath37-concepts with respect to terminologies .      to obtain a ( worst - case ) optimal algorithm for @xmath9 , the @xmath37algorithm is modified as follows .",
    "( a ) since @xmath9does not allow for qualifying number restrictions the @xmath134- , @xmath133- , and _",
    "choose_-rule can be omitted . in the absence of the _",
    "choose_-rule we may assume all concepts appearing in labels to be in nnf from the ( smaller ) set of all subconcepts of @xmath12 denoted by @xmath184 , and in the absence of role hierarchies , edge labels can be restricted to roles ( instead of sets of roles ) .",
    "due to the absence of number restrictions the logic still has the finite model property , and blocking no longer need involve two pairs of nodes with identical labels , but only two nodes with ( originally ) identical labels .",
    "( b ) to obtain a pspacealgorithm , we employ a refined blocking strategy which further loosens this `` identity '' condition to a `` similarity '' condition .",
    "this is achieved by using a second label @xmath185 for each node . in the following",
    ", we will describe and motivate this blocking technique ; detailed proofs as well as an extension of this result to @xmath186can be found in @xcite .    establishing a pspace - result for @xmath9is not as straightforward as it might seem at a first glance .",
    "one problem is the presence of inverse roles which might lead to constraints propagating upwards in the tree .",
    "this is not compatible with the standard trace technique @xcite that keeps only a single path in memory at the same time , because constraints propagating upwards in the tree may have an influence on paths that have already been visited and have been discarded from memory .",
    "there are at least two possibilities to overcome this problem : ( 1 ) by guessing which constraints might propagate upwards beforehand ; ( 2 ) by a _",
    "reset - restart _ extension of the trace technique described later in this section .",
    "unfortunately , this is not the only problem . to apply",
    "either of these two techniques , it is also necessary to establish a polynomial bound on the length of paths in the completion tree .",
    "this is easily established for logics such as @xmath0that do not allow for transitive roles . for @xmath0with transitive roles ( i.e. , @xmath3 ) , this bound is due to the fact that , for a node @xmath85 to block a node @xmath84 , it is sufficient that @xmath187 . in the presence of inverse roles , we use a more sophisticated blocking technique to establish the polynomial bound .",
    "[ def : si - algo ] a _ completion tree _ for an @xmath9concept @xmath12 is a tree where each node @xmath85 of the tree is labelled with two sets @xmath188 , and each edge @xmath137 is labelled with a ( possibly inverse ) role @xmath138 occurring in @xmath184 .",
    "@xmath13-neighbours , -successors , and -predecessors are defined as in definition  [ def : shin - algo ] where , in the absence of role hierarchies , @xmath34 is the identity on @xmath7 .    a node @xmath85 is _ blocked _",
    "iff @xmath85 has a blocked ancestor @xmath84 , or @xmath85 has an ancestor @xmath84 and a predecessor @xmath144 with @xmath189 , and @xmath190 where @xmath191 .    for a node @xmath85 , @xmath150",
    "is said to contain a _ clash _",
    "iff @xmath192 . a completion tree",
    "to which none of the expansion rules given in figure  [ table : alci ] is applicable is called _",
    "complete_.    for an @xmath9-concept @xmath12 ,",
    "the algorithm starts with a completion tree consisting of a single node @xmath85 with @xmath193 .",
    "it applies the expansion rules in figure  [ table : alci ] , stopping when a clash occurs , and answers `` @xmath12 is satisfiable '' iff the completion rules can be applied in such a way that they yield a complete and clash - free completion tree .    as for @xmath37 , correctness of the algorithm",
    "can be proved by first showing that a @xmath9-concept is satisfiable",
    "iff it has a tableau , and next proving the @xmath9-analogue of lemma  [ lemma : shin - algo - correct ] , see @xcite .",
    "[ theo : si - algo ] the tableaux algorithm is a decision procedure for satisfiability and subsumption of @xmath9-concepts .    since blocking plays a major rle both in the proof of theorem  [ theo : si - algo ] and especially in the following complexity considerations",
    ", we will discuss it here in more detail .",
    "blocking guarantees the termination of the algorithm .",
    "for dls such as @xmath0 , termination is mainly due to the fact that the expansion rules can only add new concepts that are strictly smaller than the concept that triggered their application .    for @xmath3this is no longer true : the @xmath166-rule introduces new concepts that are the same size as the triggering concept . to ensure termination , nodes labelled with a subset of the label of an ancestor are _",
    "blocked_. since rules can be applied `` top - down '' ( successors are only generated if no other rules are applicable , and the labels of inner nodes are never touched again ) and subset - blocking is sufficient ( i.e. , for a node @xmath85 to be blocked by an ancestor @xmath84 , it is sufficient that @xmath194 ) , it is possible to give a polynomial bound on the length of paths .    for @xmath9 , _ dynamic blocking _ was introduced in  @xcite , i.e. , blocks are not established on a once - and - for - all basis , but established and broken dynamically .",
    "moreover , blocks must be established on the basis of label _ equality _ , since value restrictions can now constrain predecessors as well as successors .",
    "unfortunately , this may lead to completion trees with exponentially long paths because there are exponentially many possibilities to label sets on such a path .",
    "due to the non - deterministic @xmath162-rule , these exponentially many sets may actually occur .",
    "this non - determinism is not problematical for @xmath3 because disjunctions need not be completely decomposed to yield a subset - blocking situation . for an optimal @xmath9algorithm ,",
    "the additional label @xmath185 was introduced to enable a sort of subset - blocking which is independent of the @xmath162-non - determinism . intuitively , @xmath195 is the restriction of @xmath150 to those non - decomposed concepts that @xmath85 must satisfy , whereas @xmath150 contains boolean decompositions of these concepts as well as those that are imposed by value restrictions in descendants .",
    "if @xmath85 is blocked by @xmath84 , then all concepts in @xmath195 are eventually decomposed in @xmath196",
    ". however , in order to substitute @xmath85 by @xmath84 , @xmath85 s constraints on predecessors must be at least as strong as @xmath84 s ; this is taken care of by the second blocking condition .",
    "let us consider a path @xmath197 where all edges are labelled @xmath13 with @xmath120 , the only kind of path along which the length of the longest concept in the labels might not decrease .",
    "if no rules can be applied , then we have , for @xmath198 , @xmath199{rcl }    { \\ensuremath{\\euscript{l}}\\xspace}(x_{i+1})/{\\mathop{\\mathsf{inv}}}(r ) &   \\subseteq & { \\ensuremath{\\euscript{l}}\\xspace}(x_{i})/{\\mathop{\\mathsf{inv}}}(r ) \\mbox{\\ \\ and}\\\\    { \\ensuremath{\\euscript{b}}\\xspace}(x_i)&\\subseteq & { \\ensuremath{\\euscript{b}}\\xspace}(x_{i+1 } ) \\cup\\{c_i\\ } \\end{array}\\ ] ] ( where @xmath200 triggered the generation of @xmath201 ) .",
    "this limits the number of different labels and guarantees blocking after a polynomial number of steps .",
    "[ lemma : poly_paths ] the paths of a completion tree for a concept @xmath12 have a length of at most @xmath202 where @xmath203 .",
    "finally , a slight modification of the expansion rules given in figure  [ table : alci ] yields a pspacealgorithm .",
    "this modification is necessary because the original algorithm must keep the whole completion tree in memory  which needs exponential space even though the length of its paths is polynomially bounded .",
    "the original algorithm may not forget about branches because restrictions which are pushed _ upwards _ in the tree might make it necessary to revisit paths which have been considered before .",
    "reset - restart _ mechanism solves this problem as follows :    whenever the @xmath164- or the @xmath166-rule is applied to a node @xmath85 and its _ predecessor _ @xmath84 ( case 2 of these rules ) , we delete all successors of @xmath84 from the completion tree ( _ reset _ ) . while this makes it necessary to _ restart _ the generation of successors for @xmath84 , it makes it possible to implement the algorithm in a depth - first manner which facilitates the re - use of space",
    ".    this modification does not affect the proof of soundness and completeness for the algorithm , but of course we have to re - prove termination @xcite as it formerly relied on the fact that we never removed any nodes from the completion tree .",
    "summing up we get :    the modified algorithm is a pspacedecision procedure for satisfiability and subsumption of @xmath9-concepts .",
    "like earlier dls that combine a hierarchy of ( transitive and non - transitive ) roles with some form of number restrictions  @xcite , @xmath41only allows _ simple _ roles in restrictions , i.e. roles that are neither transitive nor have transitive subroles .",
    "the justification for this limitation has been partly on the grounds of a doubtful semantics ( of transitive functional roles ) and partly to simplify decision procedures . in this section",
    ", we will show that allowing arbitrary roles in @xmath41number restrictions leads to undecidability . for convenience ,",
    "we denote @xmath41with arbitrary roles in number restrictions by @xmath204 .",
    "the undecidability proof uses a reduction of the domino problem  @xcite adapted from  @xcite .",
    "this problem asks whether , for a set of domino types , there exists a _",
    "tiling _ of an @xmath205 grid such that each point of the grid is covered with exactly one of the domino types , and adjacent dominoes are `` compatible '' with respect to some predefined criteria .",
    "a domino system @xmath206 consists of a non - empty set of domino types @xmath207 , and of sets of horizontally and vertically matching pairs @xmath208 and @xmath209 . the problem is to determine if , for a given @xmath210 , there exists a _",
    "tiling _ of an @xmath211 grid such that each point of the grid is covered with a domino type in @xmath12 and all horizontally and vertically adjacent pairs of domino types are in @xmath212 and @xmath213 respectively , i.e. , a mapping @xmath214 such that for all @xmath215 , @xmath216 and @xmath217 .",
    "this problem can be reduced to the satisfiability of @xmath204-concepts , and the undecidability of the domino problem implies undecidability of satisfiability of @xmath204-concepts .    ensuring that each point is associated with exactly one domino type and that a point and its neighbours satisfy the compatibility conditions induced by @xmath212 and @xmath213 is simple for most logics ( via the introduction of concepts @xmath218 for domino types @xmath219 , and the use of value restrictions and boolean connectives ) , and applying such conditions throughout the grid is also simple in a logic such as @xmath204which can deal with arbitrary axioms .",
    "the crucial difficulty is representing the @xmath220 grid using `` horizontal '' and `` vertical '' roles @xmath221 and @xmath222 , and in particular forcing the coincidence of @xmath223- and @xmath224-successors .",
    "this can be accomplished in @xmath204using an alternating pattern of two horizontal roles @xmath225 and @xmath226 , and two vertical roles @xmath227 and @xmath228 , with disjoint primitive concepts @xmath66 , @xmath229 , @xmath11 , and @xmath12 being used to identify points in the grid with different combinations of successors .",
    "the coincidence of @xmath230 and @xmath224 successors can then be enforced using number restrictions on transitive super - roles of each of the four possible combinations of @xmath221 and @xmath222 roles .",
    "a visualisation of the resulting grid and a suitable role hierarchy is shown in figure  [ fig : grid ] , where @xmath231 are transitive roles .",
    "the alternation of @xmath221 and @xmath222 roles in the grid means that one of the transitive super - roles @xmath232 connects each point @xmath233 to the points @xmath234 , @xmath235 and @xmath236 , and to no other points . a number restriction of the form @xmath237",
    "can thus be used to enforce the necessary coincidence of @xmath223- and @xmath224-successors .",
    "a complete specification of the grid is given by the following axioms : @xmath238 it only remains to add axioms which encode the local compatibility conditions ( as described in  @xcite ) and to assert that @xmath66 , @xmath229 , @xmath11 , and @xmath12 are subsumed by the disjunction of all domino types to enforce the placement of a tile on each point of the grid .",
    "the concept @xmath66 is now satisfiable w.r.t .",
    "the various axioms ( which can be internalised as described in lemma  [ lemma : terminologies ] ) iff there is a compatible tiling of the grid .",
    "a new dl system is being implemented based on the @xmath37algorithm described in section  [ sec : shin - algo ] .",
    "pending the completion of this project , the existing factsystem  @xcite has been modified to deal with inverse roles using the @xmath37blocking strategy , giving a dl which is equivalent to @xmath29extended with functional roles  @xcite ; we will refer to this dl as @xmath239and to the modified factsystem as i - fact .",
    "i - facthas been used to conduct some initial experiments with a terminology representing ( fragments of ) database schemata and inter schema assertions from a data warehousing application  @xcite ( a slightly simplified version of the proposed encoding was used to generate @xmath239terminologies ) .",
    "i - factis able to classify this terminology , which contains 19 concepts and 42 axioms , in less than 0.1s of ( 266mhz pentium ) cpu time .",
    "in contrast , eliminating inverse roles using an embedding technique  @xcite gives an equisatisfiable factterminology with an additional 84 axioms , but one which factis unable to classify in 12 hours of cpu time .",
    "an extension of the embedding technique can be used to eliminate number restrictions  @xcite , but requires a target logic which supports the transitive _ closure _ of roles , i.e. , _",
    ". the even larger number of axioms which this embedding would introduce makes it unlikely that tractable reasoning could be performed on the resulting terminology .",
    "moreover , we are not aware of any algorithm for _ converse_-pdlwhich does not employ a so - called _ cut rule _",
    "@xcite , the application of which introduces considerable additional non - determinism .",
    "it seems inevitable that this would lead to a further degradation in empirical tractability .",
    "as far as complexity is concerned , we have already been successful in extending the pspace - result for @xmath9to @xmath186  @xcite .",
    "currently we are working on an extension of this result to @xmath240combining the techniques from this paper with those presented in @xcite .",
    "bbn@xmath24193    f.  baader .",
    "augmenting concept languages by transitive closure of roles : an alternative to terminological cycles . in _ proc .",
    "of ijcai-91 _ , 1991 .",
    "f.  baader , m.  buchheit , and b.  hollunder .",
    "cardinality restrictions on concepts .",
    ", 88(12):195213 , 1996 .",
    "f.  baader , h .- j .",
    "brckert , b.  nebel , w.  nutt , and g.  smolka . on the expressivity of feature logics with negation , functional uncertainty , and sort equations .",
    ", 2:118 , 1993 .",
    "r.  berger .",
    "the undecidability of the dominoe problem . , 66 , 1966 .",
    "f.  baader and u.  sattler .",
    "number restrictions on complex roles in description logics . in _ proc .  of kr-96",
    "_ , pages 328339 , 1996 .",
    "d.  calvanese , g.  de giacomo , and m.  lenzerini . on the decidability of query containment under constraints . in _ proc . of the 17th acm sigact sigmod sigart sym . on principles of database systems ( pods98 )",
    "_ , pages 149158 , 1998 .",
    "d.  calvanese , g.  de  giacomo , m.  lenzerini , d.  nardi , and r.  rosati .",
    "source integration in data warehousing . in _ proc . of dexa-98_. ieee computer society press , 1998 .",
    "d.  calvanese , g.  de giacomo , and m.  lenzerini .",
    "reasoning in expressive description logics with fixpoints based on automata on infinite trees . in _ proc . of the 16th int .",
    "joint . conf . on artificial intelligence",
    "( ijcai99 ) _ , 1999 .",
    "d.  calvanese , g.  de giacomo , and r.  rosati . a note on encoding inverse roles and functional restrictions in @xmath0 knowledge bases . in _ proc .",
    "of dl98 _ , 1998 .",
    "diego calvanese , maurizio lenzerini , and daniele nardi . a unified framework for class based representation formalisms .",
    ", pages 109120",
    ". m. kaufmann , los altos .",
    "g.  de  giacomo and m.  lenzerini .",
    "what s in an aggregate : foundations for description logics with tuples and sets . in _ proc .",
    "of ijcai-95 _ , 1995 .",
    "g.  de giacomo and m.  lenzerini .",
    "tbox and abox reasoning in expressive description logics . in _ proc .",
    "of kr-96 _ , pages 316327 .",
    "m. kaufmann , los altos , 1996 .",
    "f.  donini , m.  lenzerini , d.  nardi , and w.  nutt .",
    "the complexity of concept languages . in _ proc .  of kr-91",
    "_ , boston , ma , usa , 1991 .",
    "f.  m. donini , m.  lenzerini , d.  nardi , and a.  schaerf .",
    "reasoning in description logics . in g.",
    "brewka , editor , _ foundation of knowledge representation_. csli publication , cambridge university press , 1996 .",
    "g.  de giacomo and f.  massacci . combining deduction and model checking into tableaux and algorithms for converse - pdl . , 1998 .",
    "to appear .",
    "b.  hollunder , w.  nutt , and m.  schmidt- schauss .",
    "subsumption algorithms for concept description languages . in _",
    "ecai-90 _ , pitman publishing , london , 1990 .",
    "i.  horrocks . using an expressive description logic : fact or fiction ? in _ proc .  of kr-98",
    "_ , pages 636647 , 1998 .",
    "i.  horrocks and u.  sattler . a description logic with transitive and inverse roles and role hierarchies . , 1999 .",
    "to appear .",
    "i.  horrocks , u.  sattler , and s.  tobies . a pspace - algorithm for deciding @xmath242-satisfiability .",
    "technical report 98 - 08 , lufg theoretical computer science , rwth aachen , 1998 .    see http://www-lti.informatik.rwth-aachen.de/forschung/papers.html .",
    "i.  horrocks , u.  sattler , and s.  tobies . a description logic with transitive and converse roles , role hierarchies and qualifying number restrictions .",
    "ltcs - report 99 - 08 , lufg theoretical computer science , rwth aachen , germany , 1999 .",
    "u.  sattler . a concept language extended with different kinds of transitive roles . in _ 20 .",
    "deutsche jahrestagung fr ki _ , lnai 1137 .",
    "springer - verlag , 1996 .",
    "k.  schild . a correspondence theory for terminological logics : preliminary report . in _ proc .  of ijcai-91",
    "_ , pages 466471 , sydney , 1991 .",
    "m.  schmidt- schau and g.  smolka .",
    "attributive concept descriptions with complements . , 48(1):126 , 1991 .",
    "s.  tobies . a pspace algorithm for graded modal logic . in _ proc . of cade-16",
    "springer , 1999 .",
    "in this appendix we present the proof of lemma  [ lemma : shin - algo - correct ] , which is repeated here for easier reference .        1 .   ( termination )",
    "the tableaux algorithm terminates when started with @xmath12 .",
    "2 .   ( soundness )",
    "if the expansion rules can be applied to @xmath12 such that they yield a complete and clash - free completion tree , then @xmath12 has a tableau .",
    "3 .   ( completeness )",
    "if @xmath12 has a tableau , then the expansion rules can be applied to @xmath12 such that they yield a complete and clash - free completion tree .",
    "* the expansion rules never remove nodes from the tree or concepts from node labels .",
    "edge labels can only be changed by the @xmath133-rule which either expands them or sets them to @xmath247 ; in the latter case the node below the @xmath247-labelled edge is blocked and this block is never broken .",
    "* each successor of a node @xmath85 is the result of the application of the @xmath163-rule or the @xmath134-rule to @xmath85 . for a node @xmath85",
    ", each concept in @xmath150 can trigger the generation of successors at most once .",
    "+ for the @xmath163-rule , if a successor @xmath84 of @xmath85 was generated for a concept @xmath248 and later @xmath138 is set to @xmath247 by the @xmath133-rule , then there is some @xmath31-neighbour @xmath172 of @xmath85 with @xmath249 .",
    "+ for the @xmath134-rule , if @xmath250 were generated by the @xmath134-rule for @xmath251 , then @xmath157 holds for all @xmath252 .",
    "this implies that there are always @xmath40 @xmath31-neighbours @xmath253 of @xmath85 with @xmath254 and @xmath255 for all @xmath252 , since the @xmath133-rule never merges two nodes @xmath256 with @xmath257 , and , whenever an application of the @xmath133-rule sets @xmath258 to @xmath247 , there is some @xmath31-neighbour @xmath172 of @xmath85 which `` inherits '' both @xmath11 and all inequalities from @xmath259 .",
    "+ since @xmath139 contains a total of at most @xmath260 @xmath261 and @xmath262 concepts , the out - degree of the tree is bounded by @xmath263 .",
    "* nodes are labelled with non - empty subsets of @xmath139 and edges with subsets of @xmath264 , so there are at most @xmath265 different possible labellings for a pair of nodes and an edge . therefore ,",
    "if a path @xmath266 is of length at least @xmath265 , then from the pair - wise blocking condition there must be two nodes @xmath267 on @xmath266 such that @xmath85 is directly blocked by @xmath84 .",
    "furthermore , if a node was generated at distance @xmath268 from the root node , it always remains at this distance , and thus paths are not curled up or shortened . since a path on which nodes are blocked can not become longer , paths are of length at most @xmath269 .",
    "50 2em = 0      let @xmath270be a complete and clash - free completion tree .",
    "a path is a sequence of pairs of nodes of @xmath270of the form @xmath271 $ ] .",
    "for such a path we define @xmath272 and @xmath273 . with @xmath274 $ ]",
    "we denote the path @xmath275 $ ] .",
    "the set @xmath276 is defined inductively as follows :    * for the root node @xmath277 of @xmath270 , @xmath278 \\in      { \\ensuremath{\\mathsf{paths}}\\xspace } ( {         \\ensuremath{\\mathbf{t}}\\xspace})$ ] , and * for a path @xmath279 and a node @xmath172 in @xmath270 : * * if @xmath172 is a successor of @xmath280 and @xmath172 is not blocked , then @xmath281 \\in { \\ensuremath{\\mathsf{paths}}\\xspace } ( {         \\ensuremath{\\mathbf{t}}\\xspace})$ ] , or * * if , for some node @xmath84 in @xmath270 , @xmath84 is a successor of @xmath280 and @xmath172 blocks @xmath84 , then @xmath282 \\in { \\ensuremath{\\mathsf{paths}}\\xspace } ( {         \\ensuremath{\\mathbf{t}}\\xspace})$ ] .",
    "please note that , due to the construction of @xmath283 , for @xmath279 with @xmath284 $ ] , we have that @xmath85 is not blocked , @xmath144 is blocked iff @xmath285 , and @xmath144 is never indirectly blocked .",
    "furthermore , @xmath286 holds .",
    "now we can define a tableau @xmath287 with : @xmath288      { \\ensuremath{\\euscript{l}}\\xspace}(p ) & = & { \\ensuremath{\\euscript{l}}\\xspace}({\\mathop{\\mathsf{tail}}}(p))\\\\[0.5ex ]      { \\ensuremath{\\euscript{e}}\\xspace}(r ) & = & \\ { {         \\ensuremath{\\langle p , q \\rangle } } \\in \\mathbf{s } \\times \\mathbf{s } \\mid      \\begin{array}[t]{l@{\\,}l }        \\multicolumn{2}{l}{\\mbox{either $ q = [ p|\\frac{x}{x'}]$ and}}\\\\        \\quad \\text{$x'$ is an $ r$-successor of $ { \\mathop{\\mathsf{tail}}}(p)$}\\\\        \\multicolumn{2}{l}{\\mbox{or $ p",
    "= [ q|\\frac{x}{x'}]$   and}}\\\\        \\quad \\text{$x'$ is an $ { \\mathop{\\mathsf{inv}}}(r)$-successor of $ { \\mathop{\\mathsf{tail}}}(q)$}\\}.      \\end{array }    \\end{array}\\ ] ] claim : @xmath289 is a tableau for @xmath12 with respect to @xmath290 .      * @xmath291)$ ] since @xmath292 . * * property 1 * holds because @xmath270is clash - free ; * properties 2,3 * hold because @xmath280 is not blocked and @xmath270 is complete . *",
    "* property 4 * : assume @xmath293 and @xmath294 . if @xmath295 $ ] , then @xmath144 is an @xmath31-successor of @xmath280 and thus @xmath296 ( because the @xmath164-rule is not applicable ) . since @xmath297 , we have @xmath298 .",
    "if @xmath299 $ ] , then @xmath144 is an @xmath300-successor of @xmath301 and thus @xmath302 ( because @xmath144 is not indirectly blocked and the @xmath164-rule is not applicable ) , hence @xmath298 . * * property 5 * : assume @xmath303 .",
    "define @xmath304 . in @xmath270there",
    "is an @xmath31-neighbour @xmath84 of @xmath85 with @xmath305 , because the @xmath163-rule is not applicable .",
    "there are two possibilities : * * @xmath84 is a successor of @xmath85 in @xmath270 .",
    "if @xmath84 is not blocked , then @xmath306 \\in \\mathbf{s}$ ] and @xmath307 as well as @xmath298 .",
    "if @xmath84 is blocked by some node @xmath172 in @xmath270 , then @xmath308 \\in \\mathbf{s}$ ] . *",
    "* @xmath84 is a predecessor of @xmath85 .",
    "again , there are two possibilities : * * * @xmath266 is of the form @xmath309 $ ] with @xmath310 . *",
    "* * @xmath266 is of the form @xmath309 $ ] with @xmath311 .",
    "@xmath85 only has one predecessor in @xmath312 , hence @xmath313 is not the predecessor of @xmath85 .",
    "this implies @xmath285 , @xmath85 blocks @xmath144 in @xmath270 , and @xmath313 is the predecessor of @xmath144 due to the construction of @xmath314 .",
    "together with the definition of the blocking condition , this implies @xmath315 as well as @xmath316 due to the pair - wise blocking condition .",
    "+ in all three cases , @xmath307 and @xmath298 . *",
    "* property 6 * : assume @xmath293 , @xmath317 for some @xmath124 with @xmath120 .",
    "if @xmath318 $ ] , then @xmath144 is an @xmath13-successor of @xmath280 and thus @xmath319 ( because otherwise the @xmath166-rule would be applicable ) .",
    "from @xmath297 it follows that @xmath320 .",
    "if @xmath309 $ ] , then @xmath144 is an @xmath300-successor of @xmath301 and hence @xmath301 is an @xmath13-neighbour of @xmath144 . because @xmath144 is not indirectly blocked , this implies @xmath321 and hence @xmath320 . * * property 11 * : assume @xmath322 , @xmath307 .",
    "if @xmath295 $ ] , then @xmath144 is an @xmath31-successor of @xmath280 and thus @xmath323 ( since the _ choose_-rule is not applicable ) . since @xmath297 , we have @xmath324 .",
    "if @xmath299 $ ] , then @xmath144 is an @xmath300-successor of @xmath301 and thus @xmath325 ( since @xmath144 is not indirectly blocked and the _ choose_-rule is not applicable ) , hence @xmath326 .",
    "* assume * property 9 * is violated .",
    "hence there is some @xmath327 with @xmath328 and @xmath329 .",
    "we show that this implies @xmath330 , in contradiction of either the clash - freeness or completeness of @xmath270 .",
    "define @xmath331 and @xmath332 .",
    "due to the assumption , we have @xmath333 .",
    "we distinguish two cases : * * @xmath334 contains only paths of the form @xmath335 $ ] .",
    "we claim that the function @xmath336 is injective on @xmath334 .",
    "assume that there are two paths @xmath337 with @xmath338 and @xmath339 .",
    "then @xmath340 is of the form @xmath341 $ ] and @xmath342 is of the form @xmath343 $ ] with @xmath344 . if @xmath145 is not blocked in @xmath270 , then @xmath345 , contradicting @xmath346 . if @xmath145 is blocked in @xmath270 , then both @xmath347 and @xmath348 block @xmath145 , which implies @xmath349 , again a contradiction .",
    "+ since @xmath336 is injective on @xmath334 , it holds that @xmath350 . also for each @xmath351 , @xmath145 is an @xmath31-successor of @xmath85 and @xmath352 .",
    "this implies @xmath353 .",
    "* * @xmath334 contains a path @xmath354 where @xmath266 is of the form @xmath355 $ ] .",
    "obviously , @xmath334 may only contain one such path .",
    "as in the previous case , @xmath336 is an injective function on the set @xmath356 , each @xmath357 is an @xmath31-successor of @xmath85 and @xmath352 for each @xmath357 . to show that indeed @xmath358 holds , we have to prove the existence of a further @xmath31-neighbour @xmath313 of @xmath85 with @xmath359 and @xmath360 .",
    "this will be `` supplied '' by @xmath361 .",
    "we distinguish two cases : * * * @xmath362 .",
    "hence @xmath85 is not blocked .",
    "this implies that @xmath85 is an @xmath300-successor of @xmath172 in @xmath270 .",
    "since @xmath363 contains only successors of @xmath85 , we have that @xmath364 and , by construction , @xmath172 is an @xmath31-neighbour of @xmath85 with @xmath249 .",
    "* * * @xmath285 .",
    "this implies that @xmath144 is blocked in @xmath270by @xmath85 and that @xmath144 is an @xmath300-successor of @xmath172 in @xmath270 .",
    "the definition of pairwise - blocking implies that @xmath85 is an @xmath300-successor of some node @xmath313 in @xmath270with @xmath365 .",
    "again , since @xmath363 contains only successors of @xmath85 we have that @xmath366 and , by construction , @xmath313 is an @xmath31-neighbour of @xmath85 and @xmath359 .",
    "* * property 10 * : assume @xmath367 .",
    "completeness of @xmath270implies that there exist @xmath40 individuals @xmath250 in @xmath270 such that each @xmath368 is an @xmath31-neighbour of @xmath280 and @xmath369 .",
    "we claim that , for each of these individuals , there is a path @xmath370 such that @xmath371 , @xmath372 , and @xmath373 for all @xmath252 .",
    "obviously , this implies @xmath374 .",
    "for each @xmath368 there are three possibilities : * * @xmath368 is an @xmath31-successor of @xmath85 and @xmath368 is not blocked in @xmath270 . then @xmath375 $ ] is a path with the desired properties . * * @xmath368 is an @xmath31-successor of @xmath85 and @xmath368 is blocked in @xmath270by some node @xmath172 .",
    "then @xmath376 $ ] is the path with the desired properties .",
    "since the same @xmath172 may block several of the @xmath377s , it is indeed necessary to include @xmath368 explicitly into the path to make them distinct . * * @xmath85 is an @xmath300-successor of @xmath368 .",
    "there may be at most one such @xmath368 .",
    "this implies that @xmath266 is of the form @xmath355 $ ] with @xmath378 .",
    "again , @xmath354 has the desired properties and , obviously , @xmath354 is distinct from all other paths @xmath379 . *",
    "* property 7 * is satisfied due to the symmetric definition of @xmath380 . *",
    "property 8 * is satisfied due to the definition of @xmath13-successor that takes into account the role hierarchy @xmath34 .",
    "50 2em = 0      let @xmath287 be a tableau for @xmath12 w.r.t . @xmath290 .",
    "we use this tableau to guide the application of the non - deterministic rules . to do this",
    ", we will inductively define a function @xmath381 , mapping the individuals of the tree @xmath270to @xmath98 such that , for each @xmath267 in @xmath270 : @xmath382    claim : let @xmath270be a completion - tree and @xmath381 a function that satisfies @xmath383 .",
    "if a rule is applicable to @xmath312 then the rule is applicable to @xmath312 in a way that yields a completion - tree @xmath384 and an extension of @xmath381 that satisfy @xmath383 .",
    "* * the @xmath161-rule : * if @xmath385 , then @xmath386 .",
    "this implies @xmath387 due to property 2 from definition  [ def : alchr2 ] , and hence the rule can be applied without violating @xmath383 . *",
    "* the @xmath162-rule : * if @xmath388 , then @xmath389 . since @xmath289 is a tableau , property 3 from definition [ def : alchr2 ] implies @xmath390 .",
    "hence the @xmath162-rule can add a concept @xmath391 to @xmath150 such that @xmath392 holds .",
    "* * the @xmath163-rule : *",
    "if @xmath248 , then @xmath393 and , since @xmath289 is a tableau , property 5 of definition [ def : alchr2 ] implies that there is an element @xmath116 such that @xmath394 and @xmath117 .",
    "the application of the @xmath163-rule generates a new variable @xmath84 with @xmath395 and @xmath396 .",
    "hence we set @xmath397 $ ] which yields a function that satisfies @xmath383 for the modified tree .",
    "* * the @xmath164-rule : * if @xmath398 , then @xmath399 , and if @xmath84 is an @xmath31-neighbour of @xmath85 , then also @xmath400 due to @xmath383 .",
    "since @xmath289 is a tableau , property 4 of definition  [ def : alchr2 ] implies @xmath401 and hence the @xmath164-rule can be applied without violating @xmath383 . * * the @xmath166-rule : * if @xmath398 , then @xmath399 , and if there is some @xmath124 with @xmath120 and @xmath84 is an @xmath13-neighbour of @xmath85 , then also @xmath402 due to @xmath383 . since @xmath289 is a tableau , property 6 of definition [ def : alchr2 ] implies @xmath403 and hence the @xmath166-rule can be applied without violating @xmath383 . * * the _ choose_-rule : * if @xmath404 , then @xmath405 , and , if there is an @xmath31-neighbour @xmath84 of @xmath85 , then @xmath406 due to @xmath383 .",
    "since @xmath289 is a tableau , property 11 of definition  [ def : alchr2 ] implies @xmath407 .",
    "hence the _ choose_-rule can add an appropriate concept @xmath408 to @xmath150 such that @xmath409 holds . * * the @xmath134-rule : * if @xmath410 , then @xmath411 .",
    "since @xmath289 is a tableau , property 10 of definition [ def : alchr2 ] implies @xmath412 .",
    "hence there are individuals @xmath413 such that @xmath414 , @xmath415 , and @xmath416 for @xmath252 .",
    "the @xmath134-rule generates @xmath40 new nodes @xmath250 . by setting @xmath417 $ ] , one obtains a function @xmath381 that satisfies @xmath383 for the modified tree . * * the @xmath133-rule : * if @xmath153 , then @xmath418 .",
    "since @xmath289 is a tableau , property 9 of definition  [ def : alchr2 ] implies @xmath419 . if the @xmath133-rule is applicable , we have @xmath353 , which implies that there are at least @xmath154 @xmath31-neighbours @xmath155 of @xmath85 such that @xmath156 .",
    "thus , there must be two nodes @xmath420 such that @xmath421 ( because otherwise @xmath422 would hold ) .",
    "from @xmath421 we have that @xmath423 can not hold because of @xmath383 , and @xmath424 can be chosen such that @xmath84 is not an ancestor of @xmath172 .",
    "hence the @xmath133-rule can be applied without violating @xmath383 .",
    "why does this claim yield the completeness of the tableaux algorithm ?",
    "for the initial completion - tree consisting of a single node @xmath277 with @xmath425 and @xmath426 we can give a function @xmath381 that satisfies @xmath383 by setting @xmath427 for some @xmath428 with @xmath429 ( such an @xmath430 exists since @xmath289 is a tableau for @xmath12 ) . whenever a rule is applicable to @xmath270 , it can be applied in a way that maintains @xmath383 , and , since the algorithm terminates , we have that any sequence of rule applications must terminate .",
    "properties @xmath383 imply that any tree @xmath270generated by these rule - applications must be clash - free as there are only two possibilities for a clash , and it is easy to see that neither of these can hold in @xmath270 :    *   @xmath270cannot contain a node @xmath85 such that @xmath431 because @xmath392 and hence property 1 of definition [ def : alchr2 ] would be violated for @xmath432 . *",
    "@xmath270cannot contain a node @xmath85 with @xmath153 and @xmath154 @xmath31-neighbours @xmath433 of @xmath85 with @xmath156 and @xmath434 for @xmath158 because @xmath435 , and , since @xmath157 implies @xmath436 , @xmath422 , in contradiction to property 9 of definition  [ def : alchr2 ] ."
  ],
  "abstract_text": [
    "<S> description logics ( dls ) are a family of knowledge representation formalisms mainly characterised by constructors to build complex concepts and roles from atomic ones . </S>",
    "<S> expressive role constructors are important in many applications , but can be computationally problematical . </S>",
    "<S> we present an algorithm that decides satisfiability of the dl @xmath0extended with transitive and inverse roles , role hierarchies , and qualifying number restrictions . </S>",
    "<S> early experiments indicate that this algorithm is well - suited for implementation . </S>",
    "<S> additionally , we show that @xmath0extended with just transitive and inverse roles is still in pspace . </S>",
    "<S> finally , we investigate the limits of decidability for this family of dls . </S>"
  ]
}