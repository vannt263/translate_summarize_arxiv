{
  "article_text": [
    "branching programs are one of the well known models of computation .",
    "these models have been shown useful in a variety of domains , such as hardware verification , model checking , and other cad applications ( see for example the book by wegener @xcite ) .",
    "it is known that the class of boolean functions computed by polynomial size branching programs are coincide with the class of functions computed by non - uniform log - space machines . moreover branching program",
    "is a convenient model for considering different ( natural ) restrictive variants and different complexity measures such as size ( number of inner nodes ) , length , and width .",
    "one of important restrictive branching programs is oblivious read once branching programs , also known in applied computer science as ordered binary decision diagrams ( obdd ) @xcite . since the length of an obdd is at most linear ( in the length of the input ) , the main complexity measure is `` width '' .",
    "obdds also can be seen as nonuniform automata ( see for example @xcite ) . during the last decades",
    "different variants of obdds were considered , i.e. deterministic , nondeterministic , probabilistic , and quantum , and many results have been proved on comparative power of deterministic , nondeterministic , and randomized obdds @xcite .",
    "for example , ablayev and karpinski @xcite presented the first function that is polynomially easy for randomized and exponentially hard for deterministic and even nondeterministic obdds .",
    "more specifically , it was proven that obdd variants of @xmath4 and @xmath5 are different",
    ".    in the last decade quantum model of obdd came into play @xcite,@xcite,@xcite .",
    "it was proven that quantum obdds can be exponentially cheaper than classical ones and it was shown that this bound is tight @xcite .    in this paper",
    "we present the first results on comparative complexity for classical and quantum obdds computing partial functions .",
    "then , we focus on the width complexity of deterministic and nondeterministic obdds , which have been investigated in different papers ( see for more information and citations @xcite , @xcite ) . here",
    "we present very strict hierarchies for the classes of boolean functions computed by deterministic and nondeterministic obdds .",
    "the paper is organized as follows .",
    "the section 2 contains the definitions and notations used in the paper . in section 3 ,",
    "we compare classical and exact quantum obdds .",
    "we consider a partial function depending on parameter @xmath0 such that , for any @xmath1 , this function is computed by an exact quantum obdd of width @xmath2 but deterministic or bounded error probabilistic obdds need width @xmath3 .",
    "also it is easy to show that nondeterministic obdd needs width @xmath6 . in section 4 ,",
    "we consider quantum and classical nondeterminism .",
    "we show that quantum nondeterministic obdds can be more efficient than their classical counterparts .",
    "we present an explicit function which is computed by a quantum nondeterministic obdd with constant width but any classical nondeterministic obdd needs non - constant width .",
    "the section 5 contains our results on hierarchies on the sublinear ( 5.1 ) and larger ( 5.2 ) widths of deterministic and nondeterministic obdds .",
    "the proofs of lower bounds results ( theorem [ th - dobdd1 ] and lemma [ peq1s ] ) are based on pigeonhole principle .",
    "the lower bound on theorem [ th - pobdd1 ] uses the technique of markov chains .",
    "we refer to @xcite for more information on branching programs .",
    "the main model investigated throughout the paper is obdd ( ordered binary decision diagram ) , a restricted version of branching program .    in this paper",
    "we use following notations for vectors .",
    "we use subscript for enumerating elements of vector and strings and superscript for enumerating vectors and strings . for a binary string @xmath7 ,",
    "@xmath8 and @xmath9 are the number of @xmath10 s and @xmath11 s in @xmath7 , respectively .",
    "we denote @xmath12 and @xmath13 to be the numbers of @xmath10 s and @xmath11 s in the first @xmath0 elements of string @xmath7 , respectively .    for a given @xmath14 , a probabilistic obdd @xmath15 with width @xmath16 , defined on @xmath17 ,",
    "is a 4-tuple @xmath18 where    * @xmath19 is an ordered pairs of ( left ) stochastic matrices representing the transitions , where , at the @xmath20-th step , @xmath21 or @xmath22 , determined by the corresponding input bit , is applied .",
    "* @xmath23 is a zero - one initial stochastic vector ( initial state of @xmath24 ) .",
    "* @xmath25 is the set of accepting nodes .",
    "* @xmath26 is a permutation of @xmath27 defining the order of testing the input bits .    for any given input @xmath28 ,",
    "the computation of @xmath24 on @xmath7 can be traced by a stochastic vector which is initially @xmath23 . in each step",
    "@xmath20 , @xmath29 , the input bit @xmath30 is tested and then the corresponding stochastic operator is applied : @xmath31 where @xmath32 represent the probability distribution vector of nodes after the @xmath33-th steps , @xmath34 .",
    "the accepting probability of @xmath15 on @xmath35 is @xmath36    we say that a function @xmath37 is computed by @xmath15 with bounded error if there exists an @xmath38 $ ] such that @xmath15 accepts all inputs from @xmath39 with a probability at least @xmath40 and @xmath15 accepts all inputs from @xmath41 with a probability at most @xmath42 .",
    "we say that @xmath24 computes @xmath37 _ exactly _ if @xmath43 .",
    "a deterministic obdd is a probabilistic obdd restricted to use only 0 - 1 transition matrices . in the other words , the system is always being in a single node and , from each node , there is exactly one outgoing transition for each tested input bit .",
    "a nondeterministic obdd ( nobdd ) can have the ability of making more than one outgoing transition for each tested input bit from each node and so the program can follow more than one computational path and if one of the path ends with an accepting node , then the input is accepted ( rejected , otherwise ) .",
    "* an obdd is called _ stable _ if each transition set @xmath44 is identical for each level . * an obdd is called i d ( id - obdd ) if the input bits are tested in order @xmath45 . if a _",
    "stable _ id - obdd has a fixed width and transition rules for each @xmath46 , then it can be considered as a realtime finite automaton .    quantum computation is a generalization of classical computation @xcite .",
    "therefore , each quantum model can simulate its probabilistic counterparts . in some cases ,",
    "on the other hand , the quantum models are defined in a restricted way , e.g. , using only unitary operators during the computation followed by a single measurement at the end , and so they may not simulate their probabilistic counterparts .",
    "quantum automata literature has a lot of such results such as @xcite .",
    "a similar result was also given for obdds in @xcite , in which a function with a small size of deterministic obdd was given but the quantum obdd defined in a restricted way needs exponential size to solve this function .",
    "quantum obdds that defined with the general quantum operators , i.e. superoperator @xcite , followed by a measurement on the computational basis at the end can simulate its classical counterpart with the same size and width .",
    "so we can always follow that any quantum class contains its classical counterpart .    in this paper ,",
    "we follow our quantum results based stable id - obdds , which are realtime quantum finite automata .",
    "but , we give the definition of quantum obdds for the completeness of the paper .",
    "a quantum obdd is the same as a probabilistic obdd with the following modifications :    * the state set is represented by a @xmath47-dimensional hilbert space over field of complex numbers .",
    "the initial one is @xmath48 where @xmath49 corresponds to the initial node . * instead of a stochastic matrix , we apply a unitary matrix in each step .",
    "that is , @xmath50 , where , at the @xmath20-th step , @xmath51 or @xmath52 , determined by the corresponding input bit , is applied , * at the end , we make a measurement on the computational basis .    the state of the system is updated as follows after the @xmath33-th step : @xmath53 where @xmath54 and @xmath55 represent the state of the system after the @xmath56-th and @xmath33-th steps , respectively , where @xmath34 .",
    "the accepting probability of the quantum program on @xmath35 is calculated from @xmath57 as @xmath58",
    "in @xcite , ambainis and yakaryilmaz defined a new family of unary promise problems : for any @xmath59 , @xmath60 such that @xmath61 and @xmath62 .",
    "they showed that each member of this family ( @xmath63 ) can be solved exactly by a 2-state realtime quantum finite automaton ( qfa ) but any exact probabilistic finite automaton ( pfa ) needs at least @xmath64 states .",
    "recently , rashid and yakaryilmaz @xcite showed that bounded - error realtime pfas also needs at least @xmath64 states for solving @xmath63 .",
    "based on this promise problem , we define a partial function : @xmath65 where the function is not defined for the inputs mapping to `` * '' .",
    "we call the inputs where the function takes the value of 1 ( 0 ) as yes - instances ( no - instances ) .    for any @xmath66",
    ", @xmath67 can be solved by a stable quantum id - obdd with width 2 exactly .",
    "the obdd can be construct by the same way as qfa , which solves promise problem @xmath68 @xcite .",
    "we show that the width of deterministic , or bounded - error stable probabilistic obdds that solve @xmath67 can not be less than @xmath64 .",
    "note that , a proof for deterministic obdd is not similar to the proof for automata because potentially nonstability can give profit .",
    "also this proof is different from proofs for total functions ( for example , @xmath69 ) due to the existence of incomparable inputs .",
    "note that , classical one - way communication complexity techniques also fail for partial functions ( for example , it can be shown that communication complexity of @xmath67 is @xmath10 ) , and we need to use more careful analysis in the proof .    deterministic stable id - obdd with width @xmath3 for @xmath67 can be easy constructed .",
    "we left open the case for bounded - error non - stable probabilistic obdds .",
    "[ th - dobdd1 ] for any @xmath70 , there are infinitely many @xmath71 such that any deterministic obdd computing the partial function @xmath67 has width at least @xmath3 .",
    "let @xmath72 .",
    "we call @xmath73 valid for @xmath74 if @xmath75 we call two substrings @xmath76 and @xmath77 comparable if for all @xmath73 it holds that @xmath73 is valid for @xmath76 iff @xmath73 is valid for @xmath77 .",
    "we call two substrings @xmath76 and @xmath77 nonequivalent if they are comparable and there exists a valid substring @xmath73 such that @xmath78 .",
    "let @xmath79 be a deterministic obdd computing the partial function @xmath67 .",
    "note that paths associated with nonequivalent strings must lead to different nodes .",
    "otherwise , if @xmath74 and @xmath76 are nonequivalent , there exists a valid string @xmath73 such that @xmath80 and computations on these inputs lead to the same final node .",
    "let @xmath81 and @xmath82 .",
    "we will naturally identify any string @xmath7 with the element @xmath83 of additive group @xmath84 .",
    "we call two strings of the same length different if the numbers of ones by modulo @xmath85 in them are different .",
    "we denote by @xmath86 the distance between numbers @xmath87 note that @xmath88 .",
    "let the width of @xmath79 is @xmath89 on each step @xmath90 ( @xmath91 ) of the proof we will count the number of different strings , which lead to the same node ( denote this node @xmath92 ) . on @xmath90-th step we consider @xmath93-th level of @xmath79 .",
    "let @xmath94 . by pigeonhole principle there exist two different strings @xmath95 and @xmath96 from the set @xmath97 such that corresponding paths lead to the same node @xmath98 of the @xmath99-th level of @xmath79 .",
    "note that @xmath100 because in this case @xmath95 and @xmath101 are nonequivalent and can not lead to the same node .",
    "we will show by induction that on each step of the proof the number of different strings which lead to the same node increases .",
    "step 2 . by pigeonhole principle there exist two different strings @xmath102 and @xmath103 from the set @xmath97 such that corresponding paths from the node @xmath98 lead to the same node @xmath104 of the @xmath105-th level of @xmath79 . in this case ,",
    "the strings @xmath106 , and @xmath107 lead to the node @xmath104 . note that @xmath108 because in this case @xmath109 and @xmath110 are nonequivalent and can not lead to the same node .",
    "adding the same number does not change the distance between the numbers , so we have @xmath111 and @xmath112 let @xmath113 .",
    "denote @xmath114 .",
    "let us count the number of different numbers among @xmath115 @xmath116 , @xmath117 , and @xmath118 .",
    "because @xmath95 and @xmath101 are different and @xmath119 , the numbers from the pair @xmath120 , and @xmath116 coincide with corresponding numbers from the pair @xmath117 and @xmath118 iff @xmath121 . but",
    "@xmath122 since the numbers @xmath123 and @xmath103 are different and @xmath124 the numbers @xmath117 and @xmath125 can not be a permutation of numbers @xmath120 and @xmath116 since @xmath126 and @xmath119 . in this case",
    ", at least 3 numbers from @xmath120 , @xmath127 @xmath128 , and @xmath129 are different .",
    "step of induction .",
    "let the numbers @xmath130 be different on the step @xmath131 and the corresponding paths lead to the same node @xmath132 of the @xmath133-th level of @xmath79",
    ".    by pigeonhole principle there exist two different strings @xmath123 and @xmath103 from the set @xmath97 such that the corresponding paths from the node @xmath132 lead to the same node @xmath92 of the @xmath93-th level of @xmath79 .",
    "so paths @xmath134 lead to the same node @xmath92 .",
    "let us estimate a number of different strings among them .",
    "note that @xmath126 since , in this case , the strings @xmath109 and @xmath135 are nonequivalent but lead to the same node .",
    "the numbers @xmath136 are different and @xmath137 for each pair @xmath138 such that @xmath139 .",
    "let @xmath140 .",
    "we will show that among @xmath141 and @xmath142 at least @xmath143 numbers are different .",
    "the sequence of numbers @xmath144 coincide with the the sequence @xmath142 iff @xmath121 . but",
    "@xmath145 since @xmath102 and @xmath103 are different and @xmath124    suppose that the sequence @xmath142 is a permutation of the sequence @xmath120,@xmath146 @xmath147 . in this case",
    ", we have numbers @xmath148 from @xmath84 such that all @xmath149 are from the sequence @xmath120,@xmath146 @xmath147 , @xmath150 , and @xmath151 , where @xmath152 . in this case , @xmath153 because @xmath81 , @xmath154 , and @xmath155 we have that @xmath156 is even .",
    "for @xmath157 we have @xmath158 .",
    "since all numbers from @xmath159 are different , we have that @xmath160 .",
    "so we have that @xmath161 and @xmath162 are nonequivalent but the corresponding strings lead to the same node @xmath92 .",
    "so after @xmath90-th step , we have that at least @xmath143 different strings lead to the same node @xmath163    on the @xmath164-th step , we have that @xmath165 different strings lead to the same node @xmath166 . among these strings , there must be at least two nonequivalent strings .",
    "thus we can follow that @xmath79 can not compute the function @xmath167 correctly .",
    "[ th - nobdd1 ] for any @xmath70 , there are infinitly many @xmath71 such that any nondeterministic obdd computing the partial function @xmath67 has width at least @xmath3 .",
    "the proof is similar to deterministic case with the following modifications .",
    "let @xmath79  nobdd , that computes @xmath67 . we consider only accepting pathes in @xmath168 .",
    "note that if @xmath79 computes @xmath67 correctly then accepting paths associated with nonequivalent strings can not pass through the same nodes .",
    "denote @xmath81 .",
    "let @xmath169 .",
    "denote @xmath170  a set of nodes on the @xmath171-th level of @xmath168 .",
    "assume that the width of @xmath79 is less than @xmath85 , that is , @xmath172 for each @xmath173 .",
    "denote @xmath174  a set of nodes of @xmath171-th level through which accepting paths , leading from the nodes of set @xmath175 and corresponding to string @xmath73 , pass .    on step @xmath90 ( @xmath176 ) of the proof we consider @xmath93-th level of @xmath79 .",
    "because @xmath177 , on the first step of the proof we have that there exists two different strings @xmath178 from the set @xmath97 such that @xmath179 .",
    "denote this nonempty intersection @xmath180 .",
    "next we continue our proof considering only accepting paths which pass through the nodes of @xmath181    using the same ideas as for deterministic case we can show that the number of strings with different numbers of ones by modulo @xmath85 , such that corresponding accepting paths lead to the same set of nodes , increases with each step of the proof .    on the @xmath164-th step of the proof we will have that there must be two different nonequivalent strings such that corresponding accepting paths lead to the same set @xmath182 of nodes .",
    "that implies that @xmath79 does not compute the function @xmath167 correctly .",
    "[ th - pobdd1 ] for any @xmath70 , there are infinitely many @xmath71 such that any stable probabilistic obdd computing @xmath67 with bounded error has width at least @xmath3 .",
    "the proof of the theorem is based on the technique of markov chains and the details are given in appendix [ app - pobdd1 ] .",
    "in @xcite , yakaryilmaz and say showed that nondeterministic qfas can define a super set of regular languages , called exclusive stochastic languages @xcite . this class contains the _ complements _ of some interesting languages : @xmath183 , where @xmath184 is a reverse of @xmath185 , @xmath186 , @xmath187 , and @xmath188 .",
    "based on these languages , we define three symmetric functions for any input @xmath189 : @xmath190 @xmath191 @xmath192    boolean functions @xmath193 , @xmath194 , and @xmath195 can be solved by a nondeterministic quantum obdd with constant width .",
    "for all these three functions , we can define nondeterministic quantum ( stable id- ) obdd with constant width based on nondeterministic qfas for languages @xmath196 , @xmath197 , and @xmath198 , respectively @xcite .",
    "the complements of @xmath199 and @xmath198 can not be recognized by classical nondeterministic finite automata .",
    "but , for example , the function version of the complement of @xmath200 , @xmath201 , which returns 1 only for the non - palindrome inputs , is quite easy since it can be solved by a deterministic obdd with width @xmath202 .",
    "note that the order of such an obdd is not natural @xmath203 .",
    "however , as will be shown soon , this is not the case for the function versions of the complements of the other three languages .",
    "[ nondetermenisticboundtheorem ] there are infinitely many @xmath71 such that any nobdd @xmath24 computing @xmath193 has width at least @xmath204 .    the proof of theorem is based on the complexity properties of boolean function @xmath205 . at first",
    "we will discuss complexity properties of this function in lemma [ leqn ] .",
    "after that we will prove claim of theorem .",
    "[ leqn ] there are infinitely many @xmath71 such that any obdd computing @xmath193 has width at least @xmath206 .",
    "( for the proof see [ app - leqn ] ) .",
    "_ proof of theorem [ nondetermenisticboundtheorem ] _ let function @xmath205 is computed by @xmath207 @xmath24 of width @xmath16 , then by the same way as in the proof of theorem [ th - nobdd1 ] we have @xmath208 @xmath209 +    by the same way we can show that there are infinitely many @xmath71 such that any nobdd @xmath24 computing function @xmath210 has width at least @xmath211 and any nobdd @xmath212 computing function @xmath213 has width at least @xmath214 .",
    "we denote @xmath215 and @xmath216 to be the sets of boolean functions that can be computed by @xmath217 and @xmath207 of width @xmath218 , respectively , where @xmath71 is the number of variables . in this section",
    ", we present some width hierarchies for @xmath215 and @xmath216 .",
    "moreover , we discuss relations between these classes .",
    "we consider @xmath215 and @xmath216 with small ( sublinear ) widths and large widths .",
    "we have the following width hierarchy for deterministic and nondeterministic models .    [ smallwh ] for any integer @xmath71 , @xmath218 , and @xmath219",
    ", we have @xmath220    [ [ proof - of - theorem - smallwh . ] ] proof of theorem [ smallwh ] .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    it is obvious that @xmath221 and @xmath222 .",
    "let us show the inequalities of these classes .",
    "for this purpose we use the complexity properties of known boolean function @xmath223 .",
    "let @xmath0 be a number such that @xmath224 .",
    "for any given input @xmath225 ,    @xmath226    [ peq2s ]    there is an obdd ( and so a nobdd ) @xmath24 of width @xmath16 which computes boolean function @xmath223 and @xmath227 .",
    "_ proof _ in each level , @xmath24 counts number of @xmath10 s by modulo @xmath0 . @xmath24 answers @xmath10 iff the number in the last step is zero .",
    "it is clear that the width of @xmath24 is @xmath0 .",
    "@xmath209 +    [ peq1s ] any obdd and nobdd computing @xmath223 has width at least @xmath228 .",
    "_ proof_the proof is based on pigeonhole principle .",
    "let @xmath79 be a deterministic obdd computing the function @xmath229 . for each input",
    "@xmath7 from @xmath230 there must be exactly one path in @xmath79 leading from source node to accepting node .",
    "let us consider @xmath0 inputs @xmath231 from this set such that the last @xmath0 bits in @xmath232 contains exactly @xmath20 1 s and @xmath233 0 s .",
    "let us consider the @xmath234-th level of @xmath79 .",
    "the acceptance paths for different inputs from @xmath231 must pass trough different nodes of the @xmath234-th level of @xmath79 .",
    "so the width of the @xmath234-th level of @xmath79 is at least @xmath0 .",
    "the proof for nondeterministic case is similar to deterministic one . for each input from @xmath230 for the function @xmath229 there must be at least one path in @xmath79 leading from the source node to an accepting node labelling this input .",
    "the accepting paths for different inputs from the set @xmath235 must go through different nodes of @xmath234-th level of @xmath79 .",
    "@xmath209 +    boolean function @xmath236 and @xmath237 due to lemma [ peq2s ] and boolean function @xmath238 and @xmath239 due to lemma [ peq1s ] .",
    "this completes the proof of the theorem [ smallwh ] .",
    "we have the following relationships between deterministic and nondeterministic models .    [ smallwh2 ] for any integer @xmath71 , @xmath218 , and @xmath240 such that @xmath241 and @xmath242 ,",
    "we have @xmath243    [ [ proof - of - theorem - smallwh2 ] ] proof of theorem [ smallwh2 ] + + + + + + + + + + + + + + + + + + + + + + + + + + +    we start with ( [ st4s ] ) . by the same way as in the proof of theorem [ th - nobdd1 ]",
    ", we can show that @xmath244 and , from lemma [ peq1s ] , we know that @xmath245 .",
    "then we have @xmath246",
    ".    we continue with ( [ st3s ] ) .",
    "let @xmath0 be even and @xmath247 .",
    "for any given input @xmath225 , @xmath248 note that function @xmath249 is identical to @xmath250 .",
    "[ pneq1s ] any obdd computing @xmath251 has width at least @xmath252 .",
    "_ proof _ the proof can be followed by the same technique given in the proof of lemma [ leqn ] .",
    "@xmath209 +    [ pneq4s ] there is nobdd @xmath24 of width @xmath16 that computes boolean function @xmath251 and @xmath253 .",
    "( for the proof see [ app - pneq4s ] ) .    remember that @xmath254 , and , by lemma [ peq2s ] and lemma [ peq1s ] , we have @xmath236 and @xmath255 ; by lemma [ pneq4s ] , we have @xmath256 ; and , by lemma [ pneq1s ] , we have @xmath257 . therefore ,",
    "we can not compare these classes and so we can follow theorem [ smallwh2 ] .      in this section , we consider obdds of large width .",
    "we obtain some hierarchies which are different from the ones in the previous section ( theorem [ smallwh ] ) .",
    "[ hi1 ] for any integer @xmath71 , @xmath218 , @xmath258 , we have @xmath259    [ [ proof - of - theorem - hi1 . ] ] proof of theorem [ hi1 ] .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    it is obvious that @xmath260 and @xmath261 @xmath262 .",
    "we define boolean function @xmath263 as a modification of boolean function _ shuffled equality _ which was defined in @xcite and @xcite .",
    "the proofs of inequalities are based on the complexity properties of @xmath263 .",
    "let @xmath0 be multiple of @xmath264 such that @xmath265 .",
    "the boolean function @xmath266 depends only on the first @xmath0 bits .    for any given input @xmath225 , we can define two binary strings @xmath267 and @xmath268 in the following way .",
    "we call odd bits of the input _ marker bits _ and even bits _ value bits_. for any @xmath90 satisfying @xmath269 , the value bit @xmath270 belongs to @xmath267 if the corresponding marker bit @xmath271 and @xmath270 belongs to @xmath268 otherwise .",
    "@xmath272    [ peq1 ]    there is obdd @xmath24 of width @xmath273 which computes boolean function @xmath263 .",
    "( for the proof see [ app - peq1 ] ) .",
    "[ peq2 ] there are infinitely many @xmath71 such that any obdd and nobdd @xmath24 computing @xmath274 has width at least @xmath275 .",
    "( for the proof see [ app - peq2 ] ) .",
    "( for the proof see [ app - peq2 ] )    boolean function @xmath276 and @xmath277 due to lemma [ peq1 ] .",
    "boolean function @xmath278 and @xmath279 due to lemma [ peq2 ] .",
    "so @xmath280 and @xmath261 @xmath281 .",
    "these inequalities prove statements ( [ st1 ] ) and ( [ st2 ] ) and complete the proof of the theorem [ hi1 ] .    in the following theorem",
    ", we present a relationship between deterministic and nondeterministic models .",
    "[ hi3 ] for any integer @xmath71 , @xmath218 , and @xmath240 satisfying @xmath282 and @xmath283 , we have @xmath284    [ [ proof - of - theorem - hi3 . ] ] proof of theorem [ hi3 ] .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    we start with ( [ st4 ] ) . by the same way as in proof of theorem [ th - nobdd1 ]",
    ", we can show that @xmath285 . by lemma [ peq2 ]",
    ", we have @xmath286 which means @xmath287 @xmath288 .",
    "now we continue with ( [ st3 ] ) .",
    "we use the complexity properties of boolean function @xmath289 , which is the inversion of @xmath263 .",
    "[ pneq2 ] there are infinitely many @xmath71 such that any obdd @xmath24 computing @xmath290 has width at least @xmath275 .    _ proof_we can prove it by the same way as in the proof of lemma [ peq2 ] .",
    "@xmath209 +    [ pneq1 ] there is a nobdd @xmath24 of width @xmath16 computing boolean function @xmath289 where @xmath291 .",
    "( for the proof see [ app - pneq1 ] ) .    remember that @xmath292 , and , by lemma [ peq2 ] and lemma [ peq1 ] , we have @xmath293 and @xmath294 ; by lemma [ pneq1 ] , we have @xmath295 ; and , by lemma [ pneq2 ] , we have @xmath296",
    ". therefore we can not compare this classes and so we can follow theorem [ hi3 ] .",
    "99 f. ablayev .",
    "randomization and nondeterminsm are incomparable for ordered read- once branching programs .",
    "electronic colloquium on computational complexity ( eccc ) , 4(21 ) , 1997 .",
    "f. ablayev and a. gainutdinova .",
    "complexity of quantum uniform and nonuniform automata . in developments in language theory ,",
    "volume 3572 of lncs , pages 78 87 .",
    "springer , 2005 .",
    "f. ablayev , a. gainutdinova , and m. karpinski .",
    "on computational power of quan- tum branching programs .",
    "in fct , volume 2138 of lncs , pages 5970 .",
    "springer , 2001 .",
    "f. m. ablayev , a. gainutdinova , m. karpinski , c. moore , and c. pollett . on the computational power of probabilistic and quantum branching program .",
    "informa- tion computation , 203(2):145162 , 2005 .",
    "f. m. ablayev and m. karpinski . on the power of randomized branching programs . in icalp ,",
    "volume 1099 of lncs , pages 348356 .",
    "springer , 1996 .",
    "a. ambainis and r. freivalds .",
    "1-way quantum finite automata : strengths , weak- nesses and generalizations .",
    "in focs , pages 332341 .",
    "ieee computer society , 1998 .",
    "( http://arxiv.org/abs/quant-ph/9802062 ) .",
    "a. ambainis and a. yakaryilmaz .",
    "superiority of exact quantum automata for promise problems .",
    "information processing letters , 112(7):289291 , 2012 .",
    "a. bertoni and m. carpentieri .",
    "analogies and differences between quantum and stochastic automata .",
    "theoretical computer science , 262(1 - 2):6981 , 2001 .",
    "r. freivalds .",
    "fast probabilistic algorithms . in mathematical foundations of com- puter science 1979 ,",
    "volume 74 of lncs , pages 5769 , 1979 .",
    "v. geffert and a. yakaryilmaz .",
    "classical automata on promise problems . in dcfs 2014 ,",
    "springer , 2014 .",
    "( to appear ) .",
    "j. hromkovic and m. sauerhoff .",
    "tradeoffs between nondeterminism and complexity for communication protocols and branching programs .",
    "in stacs , volume 1770 of lncs , pages 145156 .",
    "springer , 2000 .",
    "j. hromkovic and m. sauerhoff .",
    "the power of nondeterminism and randomness for oblivious branching programs .",
    "theory of computing systems , 36(2):159182 , 2003 .",
    "a. kondacs and j. watrous . on the power of quantum finite state automata . in focs ,",
    "pages 6675 .",
    "ieee computer society , 1997 .",
    "m. nakanishi , k. hamaguchi , and t. kashiwabara . ordered quantum branching programs are more powerful than ordered probabilistic branching programs under a bounded - width restriction . in cocoon ,",
    "volume 1858 of lncs , pages 467476 .",
    "springer , 2000 .",
    "introduction to probabilistic automata . academic press , new york , 1971 .",
    "j. rashid and a. yakaryilmaz .",
    "implications of quantum automata for contextual- ity . in ciaa ,",
    "springer , 2014 ( to appear ) .",
    "arxiv:1404.2761 .    m.sauerhoff and d. sieling .",
    "quantum branching programs and space - bounded nonuniform quantum complexity .",
    "theoretical computer science , 334(1 - 3):177225 , 2005 .",
    "j. watrous .",
    "on the complexity of simulating space - bounded quantum computa- tions .",
    "computational complexity , 12(1 - 2):4884 , 2003 .",
    "j. watrous .",
    "encyclopedia of complexity and system science , chapter quantum computational complexity .",
    "springer , 2009 .",
    "arxiv:0804.3401 .",
    "i. wegener .",
    "branching programs and binary decision diagrams .",
    "siam , 2000 .",
    "a. yakaryilmaz and a. c. c. say .",
    "languages recognized by nondeterministic quantum finite automata . quantum information and computation , 10(9&10):747 770 , 2010 .",
    "a. yakaryilmaz and a. c. c. say .",
    "unbounded - error quantum computation with small space bounds . information and computation , 279(6):873892 , 2011 .",
    "assume that there is a stable probabilistic obdd @xmath24 of width @xmath297 computing @xmath67 with probability @xmath298 for a fixed @xmath299 $ ] .",
    "let @xmath300 be a probability distribution of nodes of @xmath24 at the @xmath20-th level , where @xmath301 is the probability of being in the @xmath90-th node at the @xmath20-th level .",
    "we can describe the computation of @xmath24 on the input @xmath302 as follows :    * the computation of @xmath24 starts from the initial probability distributions vector @xmath303 . * on the @xmath20-th step , @xmath304 , @xmath24 reads input @xmath305 and transforms the vector @xmath306 to @xmath307 , where @xmath308 is the @xmath309 stochastic matrix , @xmath310 if @xmath311 and @xmath312 if @xmath313 . * after the last ( @xmath71-th ) step of the computation @xmath24 accepts the input @xmath7 with probability @xmath314 . if @xmath315 then we have @xmath316 and if @xmath317 then we have @xmath318 .    without loss of generality , we assume that @xmath24 reads the inputs in the natural order @xmath319 .",
    "we consider only inputs @xmath320 such that @xmath321 where @xmath322 @xmath323    for @xmath324 , we denote by @xmath325 the probability distribution after reading the part @xmath326 , i.e. @xmath327 . there are only ones in the @xmath328 , hence the computation after reading @xmath329 can be described by a markov chain . that is , @xmath325 is the initial probability distribution for a markov process and @xmath330 is the transition probability matrix .",
    "according to the classification of markov chains described in the section 2 of the book by kemeny and snell , the states of the markov chain are divided into ergodic and transient states .",
    "ergodic set of states _ is a set which a process can not leave once it has entered .",
    "transient set of states _ is a set which a process can leave , but can not return once it has left .",
    "ergodic state _ is an element of an ergodic set .",
    "transient state _ is an element of a transient set .",
    "an arbitrary markov chain @xmath331 has at least one ergodic set .",
    "@xmath331 can be a markov chain without any transient set .",
    "if a markov chain @xmath331 has more than one ergodic set , then there is absolutely no interaction between these sets .",
    "hence we have two or more unrelated markov chains lumped together .",
    "these chains can be studied separately .",
    "if a markov chain consists of a single ergodic set , then the chain is called an _",
    "ergodic chain_. according to the classification mentioned above , every ergodic chain is either regular or cyclic .",
    "if an ergodic chain is regular , then for sufficiently high powers of the state transition matrix , @xmath308 has only positive elements .",
    "thus , no matter where the process starts , after a sufficiently large number of steps it can be in any state .",
    "moreover , there is a limiting vector of probabilities of being in the states of the chain , that does not depend on the initial state .",
    "if a markov chain is cyclic , then the chain has a period @xmath332 and all its states are subdivided into @xmath332 cyclic subsets @xmath333 .",
    "for a given starting state a process moves through the cyclic subsets in a definite order , returning to the subset with the starting state after every @xmath332 steps .",
    "it is known that after sufficient time has elapsed , the process can be in any state of the cyclic subset appropriate for the moment .",
    "hence , for each of @xmath332 cyclic subsets the @xmath332-th power of the state transition matrix @xmath334 describes a regular markov chain .",
    "moreover , if an ergodic chain is a cyclic chain with the period @xmath332 , it has at least @xmath332 states .",
    "let @xmath335 be cyclic subsets of states of markov chain with periods @xmath336 , respectively , and @xmath337 be the least common multiple of @xmath336 .",
    "@xmath337 must be a multiple of @xmath3 .",
    "assume that @xmath337 is not a multiple of @xmath338 after every @xmath337 steps , the process can be in any set of states containing the accepting state and the @xmath337-th power of @xmath339 describes a regular markov chain . from the theory of markov chains , we have that there exists an @xmath340 such that @xmath341 , where @xmath342 represents the probability of process being in accepting state(s ) after @xmath90th step .",
    "hence , for any @xmath343 , it holds that @xmath344 for some big enough @xmath345 .",
    "since @xmath337 is not a multiple of @xmath3 , it can be represented as @xmath346 ( @xmath347 , @xmath348 is odd ) . for any odd @xmath349 ,",
    "the number @xmath350 is not a multiple of @xmath3 .",
    "@xmath24 is supposed to solve @xmath67 with probability @xmath298 so we have @xmath351 and @xmath352 this contradicts with the inequality above for big enough @xmath349 .",
    "there is a circle of period @xmath332 , where @xmath332 is a multiple of @xmath338    the proof is followed from the facts that @xmath337 is a multiple of @xmath3 that implies existence of @xmath353 such that @xmath332 is a power of 2 . among such @xmath332",
    "there must be a multiple of @xmath3 .",
    "otherwise @xmath337 ( the least common multiple of @xmath354 ) can not be a multiply of @xmath3 .",
    "since there is a circle of period @xmath332 where @xmath332 is a multiple of @xmath3 , we have @xmath355",
    "let @xmath71 be an even integer and @xmath24 be an obdd that computes @xmath193 .",
    "assume that @xmath24 uses the natural order .",
    "the proof is similar for any other order .",
    "now we compute the width of level @xmath356 .",
    "we construct the nobdd @xmath24 .",
    "we use the fingerprinting method given in @xcite .",
    "let @xmath374 be the first @xmath156 prime numbers satisfying that @xmath375 where @xmath156 is the minimal value .",
    "note that @xmath376 since @xmath377 .",
    "the nobdd @xmath24 consists of @xmath156 parallel parts , each of them corresponds to one of @xmath378 from @xmath379 . in the first step",
    ", @xmath24 nondeterministically picks a @xmath378 .",
    "then , this branch counts the number of @xmath10 s by modulo @xmath378 .",
    "if it is not equal to @xmath380 at the end , @xmath24 gives the answer of @xmath10 and @xmath11 otherwise .",
    "we need @xmath378 nodes for each value from @xmath11 to @xmath381 .    by the chinese remainder theorem , if @xmath382 then there are at least one @xmath383 such that @xmath384 .",
    "this means at least one branch gives the answer of @xmath10 .",
    "but if @xmath385 , then for all @xmath383 we have @xmath386 .",
    "this means each branch gives the answer of @xmath11 .",
    "hence , @xmath24 computes @xmath387 .    by prime number theorem , we know that @xmath388 . and so @xmath389 for @xmath390 since @xmath391 .",
    "this means the width of @xmath90-th part is @xmath392 . since @xmath376 ,",
    "the width of @xmath24 is @xmath393 .",
    "we construct the nobdd @xmath24 with the natural order .",
    "we use the fingerprinting method given in @xcite .",
    "we will use the same notation given in the proof of lemma [ peq1 ] .",
    "let @xmath394 be the first @xmath395 prime numbers satisfying that @xmath396 where @xmath395 is the minimal value .",
    "note that @xmath397 since @xmath398 .        for computing @xmath404 in @xmath90-th step",
    ", we should know three numbers : the value of @xmath405 , the length of @xmath406 , and the length of @xmath407 . note that @xmath408 and @xmath409 . if , in last step , @xmath410 is not zero or @xmath411 , then this part answers @xmath10 and @xmath11 otherwise . we need @xmath412 nodes for each value of triple @xmath413 and two times more nodes in order to check the value of odd bits for knowing whether the following bit belongs to @xmath267 or to @xmath268 .",
    "this means that the width of this branch is @xmath414 .    by the chinese remainder theorem ,",
    "if @xmath415 , then there is at least one @xmath383 such that @xmath416 .",
    "that is , at least one branch gives the answer of @xmath10 .",
    "if the lengths are different , then each branch gives the answer of @xmath10 .",
    "but if @xmath417 , then , for all @xmath383 , we have @xmath418 and @xmath419 .",
    "that is , each branch gives the answer of @xmath11 .",
    "hence @xmath24 computes @xmath289 .    by prime number theorem , we know that @xmath420 and so @xmath421 for @xmath422 since @xmath423 .",
    "this means that the width of @xmath90-th part is @xmath424 . since @xmath425 ,",
    "the width of @xmath24 is @xmath426 .",
    "we construct such obdd @xmath24 which uses the natural order of variables .",
    "let @xmath225 be the input .",
    "the main idea is to remember the bits from @xmath267 and @xmath268 which have not been compared yet .",
    "suppose that @xmath24 has already read @xmath20 bits of @xmath267 and @xmath171 bits of @xmath268 at the @xmath427-th level .",
    "each node of the level is associated with the value of string @xmath428 of bits which are not compared yet .",
    "for example , if @xmath429 , then @xmath430 ; if @xmath431 , then @xmath432 ; and , if @xmath433 , then @xmath434 is empty string .",
    "note that @xmath434 always contains the bits either from @xmath267 or from @xmath268 but never both .",
    "if some nodes @xmath434 contain the bits from @xmath267 and @xmath24 reads such a bit from @xmath267 , then it adds this bit to @xmath434 .",
    "otherwise this bit belongs to @xmath268 and @xmath24 compares it with the first bit of @xmath434 .",
    "if both bits are equal , then @xmath24 removes this bit from @xmath434 and rejects the input otherwise .    more formally ,",
    "let us consider @xmath427-th level .",
    "it contains four groups of nodes .",
    "first of them are the nodes associated with @xmath434 that contains the bits from @xmath267 .",
    "the second ones are the nodes for @xmath434 which contains bits from @xmath268 .",
    "the third one contains only one `` equals '' node for empty @xmath434 , and , the fourth one contains only one `` rejecting '' node .",
    "let @xmath435 be a node from the first group and @xmath428 be the string associated with @xmath435 such that @xmath434 contains the bits from @xmath267 . at the @xmath427-th level",
    ", @xmath24 reads a marker bit @xmath436 .",
    "if @xmath437 , that means the next value bit @xmath438 belongs to @xmath267 and then @xmath24 stores bit @xmath438 at the level @xmath439 and goes to the node corresponding to @xmath440 .",
    "otherwise , the next value bit @xmath438 belongs to @xmath268 and @xmath24 compares it with @xmath441 .",
    "if these bits are the same , then @xmath24 goes to the node corresponding to @xmath442 or to `` equals '' node if @xmath443 , and goes to `` rejecting '' node if the bits are different .",
    "if @xmath434 is empty , then @xmath24 goes to the node of the first or the second group associated to @xmath444 which contains bit from @xmath445 or from @xmath446 .",
    "if length of @xmath434 is greater than @xmath447 , then @xmath24 goes to `` rejecting '' node .    for the second group of nodes , @xmath24 works by the same way but the string @xmath434 stores the bits from @xmath268 .",
    "@xmath24 gives the answer @xmath10 iff it reaches the `` equals '' node at the last level .",
    "now we compute the width of @xmath24 . at the @xmath427-th level ,",
    "the first two groups of nodes contain nodes for each value of @xmath434 both for @xmath267 and for @xmath268 .",
    "the third and forth groups contain `` equal '' and `` rejecting '' nodes , respectively .",
    "the width of such level is      the level @xmath439 have twice more nodes for the first three groups since @xmath24 needs to remember the value of marker bit , which indicates the next bit belongs to @xmath267 or @xmath268 .",
    "so , the widths of these levels are @xmath273 and so the width of @xmath24 is @xmath273 .",
    "let @xmath24 be an obdd with order @xmath450 that computes @xmath274 and @xmath171 be the number of level such that the @xmath171-th level of @xmath24 has already read exactly @xmath447 value bits from @xmath451 .",
    "let us consider partition of variables @xmath452 and input @xmath453 with respect to this partition .",
    "let set @xmath454 is all value bits from @xmath455 and set @xmath456 is all marker bits from @xmath455 .",
    "let set @xmath457 marker bits for variables from @xmath458 fixed such that value bits for variables from @xmath454 belongs to @xmath267 and other value bit from @xmath459 belongs to @xmath460 .",
    "note that @xmath461 ."
  ],
  "abstract_text": [
    "<S> we present several results on comparative complexity for different variants of obdd models .    * </S>",
    "<S> we present some results on comparative complexity of classical and quantum obdds . </S>",
    "<S> we consider a partial function depending on parameter @xmath0 such that for any @xmath1 this function is computed by an exact quantum obdd of width @xmath2 but any classical obdd ( deterministic or stable bounded error probabilistic ) needs width @xmath3 . </S>",
    "<S> * we consider quantum and classical nondeterminism . </S>",
    "<S> we show that quantum nondeterminism can be more efficient than classical one . </S>",
    "<S> in particular , an explicit function is presented which is computed by a quantum nondeterministic obdd with constant width but any classical nondeterministic obdd for this function needs non - constant width . </S>",
    "<S> * we also present new hierarchies on widths of deterministic and nondeterministic obdds . </S>",
    "<S> we focus both on small and large widths . </S>"
  ]
}