{
  "article_text": [
    "iterative reconstruction algorithms @xcite for x - ray computed tomography ( ct ) @xcite have been extensively applied and studied recently as an approach for lowering radiation exposure to x - rays @xcite during clinical examinations .",
    "iterative techniques have been used for a long time in nuclear medicine , but only during the last few years several manufacturers have made available and suggested the use of iterative methods for routine ct imaging that simultaneously provide for acceptable image quality with detectability of low - contrast objects and significant dose reduction .    comparing to the filtered back - projection algorithm ( fbp ) @xcite , iterative reconstruction algorithms such as art @xcite ,",
    "sart @xcite , and sirt @xcite normally take significantly more time for obtaining reconstructed tomograms of comparable accuracy . however , recently proposed algorithms such as the adaptive statistical iterative reconstruction ( asir ) @xcite and the sinogram - affirmed iterative reconstruction ( safire ) @xcite provide clinically acceptable results within a reconstruction time comparable with that of the fbp algorithm . statistical reconstruction algorithms such as asir",
    "have been criticized for their `` plastic - like '' reconstruction @xcite . in the majority of case studies",
    "undertaken , the potential dose reduction of safire is around @xmath0 , and in some cases around @xmath1 ( for example , for a number of chest ct examinations ) . for some other case studies ,",
    "the potential dose reduction that can be achieved is around @xmath2 , as in    \\(1 ) @xcite , where the authors have applied computed tomography of cervical spine , and compared reduced - dose safire with standard dose of @xmath3 fbp ; it has been concluded that the dose can be reduced up to @xmath4 with safire in order to provide results comparable with @xmath3 dose fbp , although `` the former protocol provides lower image quality of the soft tissues and vertebrae '' which means that the dose reduction would be actually slightly lower than 40% ;    \\(2 ) @xcite , where comparisons between safire and automated kv modulation ( care kv ) for abdominal ct imaging are made , and it is stated that `` dose can be decreased up to 41.3% '' ;    \\(3 ) @xcite , where performance of iterative image reconstruction of the paranasal sinuses is studied , and it is stated that `` subjective quality evaluation of the noise - adapted images showed preference for those acquired at 100% tube current with fbp ( 4.7 - 5.0 ) versus 50% dose with safire ( 3.4 - 4.4 ) ''",
    ".    adaptive iterative methods such as those used in the asir and safire algorithms could be as well applied not only in clinical ct , but also in other routine x - ray examinations such as non - destructive testing of materials , for speed - up .",
    "as the algorithmic details of these methods are proprietary , we aim in this report to describe our proposal for an adaptive iterative reconstruction algorithm , that is shown to have potential dose reduction of @xmath0 with reconstruction times comparable to the safire algorithm . after presenting in detail the algorithm and providing illustrative results",
    ", we then discuss a number of possible optimizations .",
    "in this section we describe , step - by - step , the details of our proposed adaptive iterative reconstruction algorithm . let @xmath5 be the density matrix ( of size _ nx _ lines by _ ny _ columns ) to be reconstructed from sinogram @xmath6 , @xmath7 the number of detectors , and @xmath8 the number of projection angles .",
    "@xmath9 $ ] is the sinogram value corresponding to detector @xmath10 , for the @xmath11-th projection angle .",
    "there are two main steps in the reconstruction process :    1 .",
    "initialization of the reconstruction matrix @xmath5 with initial solution , 2 .   and iterations .",
    "the detailed description of the reconstruction is as follows .",
    "before the two main steps proceed , we have the following initializations of variables : @xmath12\\leftarrow{0.0}\\textnormal { , } 1\\leq{i}\\leq{\\it nx } , 1\\leq{j}\\leq{\\it ny}},\\ ] ]    @xmath13\\leftarrow{0.0}\\textnormal { , } 1\\leq{i}\\leq{\\it nx } , 1\\leq{j}\\leq{\\it ny}},\\ ] ]    @xmath14\\leftarrow{0.0}\\textnormal { , } 1\\leq{i}\\leq{\\it nx } , 1\\leq{j}\\leq{\\it ny}}.\\ ] ]    after these initializations of variables , the initialization of the reconstruction matrix @xmath5 with initial solution is done as in the algorithm given in fig .",
    "[ fig : initialization ] , shown in pseudocode .",
    "_ for every @xmath11 , @xmath15 do _    _ for every @xmath10 , @xmath16 do _",
    "_ let @xmath17 be the x - ray beam that corresponds to the sinogram value @xmath9 $ ] ; _    _ let @xmath18 , @xmath19 be 2 vectors with @xmath20,c_{i , j}[1]]$ ] , ",
    ", @xmath21,c_{i , j}[c_{i , j}]]$ ] being all @xmath22 entries of @xmath5 that correspond to the beam @xmath17 ; _    _ let @xmath23 be a vector such that @xmath24 $ ] is the length of the segment corresponding to the path that @xmath17 follows through the entry @xmath25,c_{i , j}[k]]$ ] , @xmath26 ; _    _ @xmath27 ; _    _ for every @xmath28 , @xmath26 do _    _",
    "@xmath29 $ ] ; _    _ endfor _    _ for every @xmath28 , @xmath26 do _    _",
    "@xmath30,c_{i , j}[k]]\\leftarrow{o_{1}[l_{i , j}[k],c_{i , j}[k]]}+{\\it seg}_{i , j}[k]$ ] ; _    _ endfor _    _ for every @xmath28 , @xmath26 do _    _",
    "@xmath25,c_{i , j}[k]]\\leftarrow{\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]}+{\\it seg}_{i , j}[k]*(s[i , j]/{\\it sum})$ ] ; _    _ endfor _    _ endfor _    _ endfor _    _ for every @xmath10 , @xmath31 do _    _ for every @xmath11 , @xmath32 do _    _",
    "@xmath33\\leftarrow\\mu_{1}[i , j]/o_{1}[i , j]$ ] ; _    _ endfor _    _ endfor _    the initialization with the initial solution is very simple , and can be explained as follows .",
    "for every @xmath11 and @xmath10 , @xmath15 , @xmath16 : let @xmath17 be the x - ray beam that corresponds to the sinogram value @xmath9 $ ] , and suppose that @xmath17 goes through @xmath22 entries of @xmath5 .",
    "let @xmath18 , @xmath19 be two vectors such that @xmath34,c_{i , j}[1 ] ] , \\ldots , \\mu_{1}[l_{i , j}[c_{i , j}],c_{i , j}[c_{i , j}]]\\ ] ] are all entries of @xmath5 that correspond to the beam @xmath17 . for the current @xmath11 and @xmath10 ,",
    "@xmath35 is the sum of all segments corresponding to beam @xmath17 ( the entries of @xmath5 that correspond to the current beam @xmath17 , and the associated segments , are computed in the same way when the sinogram was formed ) .",
    "then , for every @xmath28 , @xmath26 , @xmath30,c_{i , j}[k]]$ ] is the sum of all segments ( that is , from all beams ) corresponding to the entry @xmath25,c_{i , j}[k]]$ ] ; so , for the current beam @xmath17 we add the current segments @xmath36 $ ] , @xmath37 , @xmath38 $ ] to the corresponding entries in @xmath39 ( that is , to @xmath40,c_{i , j}[1]]$ ] , @xmath41 , @xmath42,c_{i , j}[c_{i , j}]]$ ] ) .",
    "since @xmath35 is the sum of all segments corresponding to the current beam @xmath17 , it follows that @xmath43/{\\it sum}\\ ] ] is the current average sinogram value per unit of segment .",
    "but , the current beam @xmath17 goes through @xmath25,c_{i , j}[k]]$ ] for distance @xmath24 $ ] , and not for unit distance 1.0 , so it follows that @xmath44*(s[i , j]/{\\it sum})\\ ] ] is an approximation of the contribution of @xmath25,c_{i , j}[k]]$ ] to @xmath9 $ ] .",
    "we add to @xmath25,c_{i , j}[k]]$ ] all these approximations .    for every @xmath10 and @xmath11 , @xmath31 , @xmath32 we finally initialize @xmath33 $ ] by dividing the sum of approximations of contributions by the sum of segments corresponding to @xmath33 $ ] .",
    "after the initialization step follows the iterations step ; at each iteration the algorithm from fig .",
    "[ fig : iteration ] , shown in pseudocode , is executed .",
    "_ for every @xmath11 , @xmath15 do _    _ for every @xmath10 , @xmath16 do _",
    "_ let @xmath17 be the x - ray beam that corresponds to the sinogram value @xmath9 $ ] ; _    _ let @xmath18 , @xmath19 be 2 vectors with @xmath20,c_{i , j}[1]]$ ] , ",
    ", @xmath21,c_{i , j}[c_{i , j}]]$ ] being all @xmath22 entries of @xmath5 that correspond to the beam @xmath17 ; _    _ let @xmath23 be a vector such that @xmath24 $ ] is the length of the segment corresponding to the path that @xmath17 follows through the entry @xmath25,c_{i , j}[k]]$ ] , @xmath26 ; _    _ @xmath45 ; _    _ for every @xmath28 , @xmath26 do _    _",
    "@xmath46*\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]$ ] ; _    _ endfor _    _ for every @xmath28 , @xmath26 do _    _",
    "@xmath47,c_{i , j}[k]]\\leftarrow{\\mu_{2}[l_{i , j}[k],c_{i , j}[k]]}+{\\it seg}_{i , j}[k]*\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]*(s[i , j]/{\\it sit})$ ] ; _    _ endfor _    _ endfor _    _ endfor _    _ for every @xmath10 , @xmath31 do _    _ for every @xmath11 , @xmath32 do _    _",
    "@xmath33\\leftarrow\\mu_{2}[i , j]/o_{1}[i , j]$ ] ; _    _ @xmath48\\leftarrow{0.0}$ ] ; _    _ endfor _    _ endfor _    the code executed at each iteration is similar with the initialization with initial solution , but with some difference .",
    "for every @xmath11 and @xmath10 , @xmath15 , @xmath16 : @xmath18 , @xmath19 , @xmath23 are already calculated from the initialization with initial solution ; then , the corresponding situation @xmath49 in the reconstruction , for the current x - ray beam @xmath17 , is calculated ; @xmath50,c_{i , j}[k]]*(s[i , j]/sit)\\ ] ] is the corrected value of @xmath25,c_{i , j}[k]]$ ] for the current detector and projection angle , and @xmath44*\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]*(s[i , j]/{\\it sit})\\ ] ] is the exact contribution of this corrected value of @xmath25,c_{i , j}[k]]$ ] ; in the variable @xmath51 , we add these exact contributions of the corrected values .    for every @xmath10 and @xmath11 , @xmath31 , @xmath32",
    "we finally compute @xmath33 $ ] by dividing the current sum of exact contributions of the corrected values by the sum of segments corresponding to @xmath33 $ ] . also , @xmath51 is re - initialized for the next iteration .",
    "the iterations stop when the difference between reconstructions from two consecutive iterations reaches a predefined threshold .",
    "in this section , we examine the performance of the described adaptive iterative reconstruction algorithm .",
    "consider the shepp - logan tomogram shown in fig .",
    "[ fig:1 ] , of size 250 by 250 pixels .",
    "this tomogram has been generated using the matlab software @xcite , using the command @xmath52        for this cross - section , consider the following parameters :    1 .",
    "distance from fan - beam source to origin of rotation of inspected object = 800 , 2 .",
    "distance from fan - beam source to line of detectors = 1500 , 3 .",
    "number of detectors equally spaced on the detector line = 359 , 4 .",
    "number of projection angles = 198 .",
    "the corresponding sinogram is a matrix with 359 lines and 198 columns . for this set of parameters , and fan - beam scanning with detectors",
    "arranged equally spaced on the detector line , the initial solution is as given in fig .",
    "[ fig : result - of - initialsolution ] ; the result obtained by the the fbp algorithm is shown in fig .",
    "[ fig : fbp198 ] ; as it is visible , there are many artifacts .",
    "the result by the adaptive iterative reconstruction , for the same set of parameters , and run with 285 iterations , is shown in fig .",
    "[ fig : comparison1 ] ( b ) ; in fig .",
    "[ fig : comparison1 ] ( a ) , the result obtained by the fbp algorithm is shown , but for 360 projection angles .",
    "the result obtained with the adaptive iterative reconstruction ( fig .",
    "[ fig : comparison1 ] ( b ) , 198 projection angles ) is of the same quality as the result obtained by the fbp algorithm ( fig .",
    "[ fig : comparison1 ] ( a ) , 360 projection angles ) , which means an x - ray dose reduction of @xmath53 .",
    "the result for the adaptive iterative reconstruction has been obtained using a desktop computer with intel xeon e5 - 2697 v2 , 2.70ghz processor , by parallelization on all 12 cores available , using visual studio 2013 software .",
    "the execution time for the inspected tomogram was about 1.75 seconds .",
    "from all the tests which have been run , it has been concluded that the dose can be reduced up to @xmath0 for the considered shepp - logan tomogram , but using @xmath54 more iterations .",
    "this result is thus comparable with those obtained by the safire algorithm , both in terms of dose reduction and execution time ( the safire algorithm takes , to the best of our knowledge , around 1 second for tomograms of this size ) , but as opposed to the safire algorithm , whose details are proprietary , the described adaptive iterative reconstruction algorithm is provided for free to the community of researchers working on tomographic reconstruction ( not only in the medical sector where the safire algorithm is used , but also for non - destructive testing of objects , etc . ) , for regular use .",
    "the execution time of the described iterative reconstruction algorithm could be reduced by using more powerful processors , or on parallelization on graphical processing units ( gpus ) .",
    "in this section , we discuss possible optimizations . the execution time that we have reported in the previous section",
    "was obtained by parallelization of the proposed algorithm on multi - core processors .",
    "both the initialization step and the iterations step can be parallelized easily by splitting the work done for all detector ",
    "projection angle pairs equally among all cores available . for the example that we have analyzed , where we have @xmath55 detectors and @xmath56 projection angles , and if we have 11 cores available , then the first core would deal with all detector ",
    "projection angles pairs @xmath57 for @xmath58 , @xmath59 , the second core would deal with all detector ",
    "projection angles pairs @xmath57 for @xmath58 , @xmath60 , etc .",
    "for the iterations step , clearly the calculation of @xmath5 from the variables @xmath51 ,",
    "@xmath39 at the end of each iteration would be done only by one of the cores , and the others would wait before all cores start the next iteration , as each core needs the same matrix @xmath5 at the start of each iteration .",
    "besides parallelization on multi - core processors , one other possible optimization in practice could be the following : in the code executed at each iteration , for each of the @xmath61 x - ray beams , a number of entries of the matrix @xmath5 are used for calculating @xmath49 , the situation for the current x - ray beam .",
    "if some of these entries are exactly @xmath62 then the addition of the respective @xmath44*\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]\\ ] ] terms to the @xmath49 variable becomes useless .",
    "also , after calculating the @xmath49 variable , the addition of the respective @xmath44*\\mu_{1}[l_{i , j}[k],c_{i , j}[k]]*(s[i , j]/{\\it sit})\\ ] ] terms to the @xmath51 variable also becomes useless .",
    "therefore , it is desirable to not examine the respective @xmath62 entries of @xmath5 .",
    "this could be realized by running , once at every few iterations , a test that checks which entries of @xmath5 have become @xmath62 and eliminate them from the @xmath18 , @xmath19 vectors , for all @xmath61 detector ",
    "projection angle pairs . eliminating these @xmath62 entries is a correct procedure , as once an entry has become @xmath62 , it will remain @xmath62 until the end of all iterations , regardless of how many iterations are run .",
    "however , for the shepp - logan tomogram of size 250 by 250 that we have tested , none of the entries has reached the exact value @xmath62 , but for other tomograms it may happen .",
    "another possible optimization would be to use a different initial solution for the described adaptive iterative reconstruction algorithm .",
    "the second generation of iterative reconstruction algorithms for x - ray ct , such as the asir and safire adaptive algorithms , have been followed up by many case studies where it is shown that potential dose reduction of around 50% can be applied as compared to the filtered back - projection algorithm . in this report , we have described our proposal for an adaptive iterative reconstruction algorithm that is shown to produce very good accuracy , is fast , and provided for free to the scientific community for regular use , and possible further improvement .",
    "in this section , we show the visual c++ 2013 main code implementing the described adaptive iterative reconstruction algorithm .",
    "this is a usual win32 application , and an example of the interface is shown in fig .",
    "[ fig : rec1 ] . the function executed by each thread",
    "is called `` mythreadfunction ''",
    ". this implementation uses barriers ( for synchronization of threads after each iteration during the reconstruction process ) , a facility that requires windows 8 or higher .",
    "int apientry _",
    "twinmain (      _ in _ hinstance hinstance ,                  _",
    "in_opt _ hinstance hprevinstance ,                  _ in _ lptstr lpcmdline ,                  _ in _ int ncmdshow    ) {     unreferenced_parameter(hprevinstance ) ;     unreferenced_parameter(lpcmdline ) ;                           wcex.style        = cs_hredraw | cs_vredraw ;     wcex.lpfnwndproc = wndproc ;     wcex.cbclsextra   = 0 ;     wcex.cbwndextra   = 0 ;     wcex.hinstance    = hinstance ;     wcex.hicon        = loadicon(hinstance , makeintresource(idi_rec1 ) ) ;     wcex.hcursor      = loadcursor(null , idc_arrow ) ;     wcex.hbrbackground    = ( hbrush)(color_window+1 ) ;     wcex.lpszmenuname     = makeintresource(idc_rec1 ) ;     wcex.lpszclassname    = szwindowclass ;     wcex.hiconsm      = loadicon(wcex.hinstance , makeintresource(idi_small ) ) ;             hwnd = createwindow ( szwindowclass ,              sztitle ,              ws_overlappedwindow ,              cw_usedefault ,              0 ,              cw_usedefault ,              0 ,              null ,              null ,              hinstance ,              null ) ;                               switch ( message )     {        case wm_command :           wmid = loword(wparam ) ;           wmevent = hiword(wparam ) ;           switch ( wmid )           {              case id_x_iterativemethod1 :              {                 setcursor(loadcursor(null , idc_wait ) ) ;                 invalidaterect(hwnd , null , true ) ;                 status = 0 ;                 msg msg ;                 msg.hwnd = hwnd ;                 msg.message = wm_paint ;                 dispatchmessage(&msg ) ;                       int i ;                 int j ;                 int k ;                 mu1 = ( double*)malloc(nx*ny*sizeof(double ) ) ;                 ri1 = ( double*)malloc(nx*ny*sizeof(double ) ) ;                 rig = ( double*)malloc(nx*ny*sizeof(double ) ) ;                 mo1 = ( double*)malloc(nx*ny*sizeof(double ) ) ;                 z    = ( inf *    ) malloc(np*nf*sizeof(inf    ) ) ;                      double d1 ;                 if ( fopen_s(&f1 , \" ph-250x250.txt \" , \" r \" ) = = 0 )                 {                    for ( i = 0 ; i < nx ; i++ )                    {                       for ( j = 0 ; j < ny ; j++ )                       {                          fscanf_s(f1 , \" % lf \" , & d1 ) ;                          mu1[i*ny + j ] = d1 ;                       }                    }                    fclose(f1 ) ;                 }                 else                    messagebox (    hwnd ,                  ( lpcwstr)l\"problem opening the file ! \" ,                  ( lpcwstr)l \" ! \" ,                  mb_ok    ) ;                              for ( i = 0 ; i < nx ; i++ )                 for ( j = 0 ; j < ny ; j++ )                 {                    ri1[i*ny + j ] = 0.0 ;                    rig[i*ny + j ] = 0.0 ;                    mo1[i*ny + j ] = 0.0 ;                 }                                 xlolimit = -((((double)ny ) - 1.0 ) / 2.0 + 0.5 ) ;                 xuplimit = ( ( ( ( double)ny ) - 1.0 ) / 2.0 + 0.5 ) ;                 ylolimit = -((((double)nx ) - 1.0 ) / 2.0 + 0.5 ) ;                 yuplimit = ( ( ( ( double)nx ) - 1.0 ) / 2.0 + 0.5 ) ;                               double * xv = ( double*)malloc(((ny + 1 ) + ( nx + 1))*sizeof(double ) ) ;                 double * yv = ( double*)malloc(((ny + 1 ) + ( nx + 1))*sizeof(double ) ) ;                 vector < pair < double , double > > v ;                 int nel ;                                for ( j = 0 ; j < np ; j++ )                    {                       z[j*nf + i].count = 0 ;                       z[j*nf + i].lin = null ;                       z[j*nf + i].col = null ;                       z[j*nf + i].ind = null ;                       z[j*nf + i].seg = null ;                       z[j*nf + i].sumofsegs = 0.0 ;                                                                      nel = 0 ;                                                                      x2 = cosf*dc[j ] - sinfa ;                       y2 = sinf*dc[j ] + cosfa ;                         if ( x1 !",
    "= x2 )                       {                          if ( y1 !",
    "= y2 )                          {                             m = ( y2 - y1 ) / ( x2 - x1 ) ;                             b = y1 - m*x1 ;                               for ( k = 0 ; k < nyplusone ; k++ )                             {                                xhrz = ( xl[k ] - b ) / m ;                                yhrz = xl[k ] ;                                if ( ( xhrz > = xlolimit ) & &                                    ( xhrz",
    "< = xuplimit ) & &                                    ( yhrz > = ylolimit ) & &                                    ( yhrz < = yuplimit ) )                                {                                   v.push_back(make_pair(xhrz , yhrz ) ) ;                                   nel++ ;                                }                             }                             for ( k = 0 ; k < nxplusone ; k++ )                             {                                xvrt = yl[k ] ;                                yvrt = m*yl[k ] + b ;                                if ( ( xvrt > = xlolimit ) & &                                    ( xvrt < = xuplimit ) & &                                    ( yvrt > = ylolimit ) & &                                    ( yvrt < = yuplimit ) )                                {                                   v.push_back(make_pair(xvrt , yvrt ) ) ;                                   nel++ ;                                }                             }                               sort(v.begin ( ) , v.end ( ) ) ;                             for ( k = 0 ; k < nel ; k++ )                             {                                xv[k ] = v[k].first ;                                yv[k ] = v[k].second ;                             }                               if ( nel > = 2 )                             {                                z[j*nf+i].count = nel-1 ;                                z[j*nf+i].lin=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                z[j*nf+i].col=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                z[j*nf+i].seg=(double*)malloc(z[j*nf+i].count*sizeof(double ) ) ;                                z[j*nf+i].ind=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                  for ( k = 1 ; k < nel ; k++ )                                {                                   xcm = ( xv[k - 1 ] + xv[k ] ) / 2.0 ;                                   ycm = ( yv[k - 1 ] + yv[k ] ) / 2.0 ;                                   col = ( int)floor(xcm + var1 ) ;                                   if ( col > nyminusone )                                      col = col - 1 ;                                   lin = ( int)floor(var2 - ycm ) ;                                   if ( lin > nxminusone )                                      lin = lin - 1 ;                                   seg = sqrt(pow(xv[k]-xv[k-1],2)+pow(yv[k]-yv[k-1],2 ) ) ;                                   s[j*nf + i ] = s[j*nf + i ] + seg*mu1[lin*ny + col ] ;                                     z[j*nf + i].lin[k - 1 ] = lin ;                                   z[j*nf + i].col[k - 1 ] = col ;                                   z[j*nf + i].ind[k - 1 ] = lin*ny + col ;                                   z[j*nf + i].seg[k - 1 ] = seg ;                                   z[j*nf + i].sumofsegs + = seg ;                                     mo1[lin*ny + col ] = mo1[lin*ny + col ] + 1.0 ;                                }                             }                          }                          else                          {                             if ( ( y1 > = ylolimit ) & & ( y1 < = yuplimit ) )                             {                                z[j*nf+i].count = ny ;                                z[j*nf+i].lin=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                z[j*nf+i].col=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                z[j*nf+i].seg=(double*)malloc(z[j*nf+i].count*sizeof(double ) ) ;                                z[j*nf+i].ind=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                                  ycm = y1 ;                                lin = ( int)floor(var2 - ycm ) ;                                if ( lin > nxminusone )                                   lin = lin - 1 ;                                for ( k = 1 ; k < = ny ; k++ )                                {                                   xcm = ( xl[k - 1 ] + xl[k ] ) / 2.0 ;                                   col = ( int)floor(xcm + var1 ) ;                                   if ( col > nyminusone )                                      col = col - 1 ;                                   s[j*nf + i ] = s[j*nf + i ] + mu1[lin*ny + col ] ;                                     z[j*nf + i].lin[k - 1 ] = lin ;                                   z[j*nf + i].col[k - 1 ] = col ;                                   z[j*nf + i].ind[k - 1 ] = lin*ny + col ;                                   z[j*nf + i].seg[k - 1 ] = 1.0 ;                                   z[j*nf + i].sumofsegs + = 1.0 ;                                     mo1[lin*ny + col ] = mo1[lin*ny + col ] + 1.0 ;                                }                             }                          }                       }                       else                       {                          if ( ( x1 > = xlolimit ) & & ( x1 < = xuplimit ) )                          {                             z[j*nf+i].count = nx ;                             z[j*nf+i].lin=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                             z[j*nf+i].col=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                             z[j*nf+i].seg=(double*)malloc(z[j*nf+i].count*sizeof(double ) ) ;                             z[j*nf+i].ind=(int *    ) malloc(z[j*nf+i].count*sizeof(int    ) ) ;                               xcm = x1 ;                             col = ( int)floor(xcm + var1 ) ;                             if ( col > nyminusone )                                col = col - 1 ;                             for ( k = 1 ; k < = nx ; k++ )                             {                                ycm = ( yl[k - 1 ] + yl[k ] ) / 2.0 ;                                lin = ( int)floor(var2 - ycm ) ;                                if ( lin > nxminusone )                                   lin = lin - 1 ;                                s[j*nf + i ] = s[j*nf + i ] + mu1[lin*ny + col ] ;                                  z[j*nf + i].lin[k - 1 ] = lin ;                                z[j*nf + i].col[k - 1 ] = col ;                                z[j*nf + i].ind[k - 1 ] = lin*ny + col ;                                z[j*nf + i].seg[k - 1 ] = 1.0 ;                                z[j*nf + i].sumofsegs + = 1.0 ;                                  mo1[lin*ny + col ] = mo1[lin*ny + col ] + 1.0 ;                             }                          }                       }                       if ( z[j*nf + i].count > 0 )                       for ( k = 0 ; k < z[j*nf + i].count ; k++ )                          ri1[z[j*nf+i].lin[k]*ny+z[j*nf+i].col[k]]+=z[j*nf+i].seg[k ] *                          ( s[j*nf+i]/z[j*nf+i].sumofsegs ) ;                             for ( i = 0 ; i < nthreads ; i++ )                 {                    hthreadarray[i ] = createthread (                       null ,                       0 ,                       mythreadfunction ,                       inttoptr(i ) ,                       0 ,                       & dwthreadidarray[i ] ) ;                                             for ( i = 0 ; i <",
    "nx ; i++ )                 {                    for ( j = 0 ; j < ny ; j++ )                    {                       c = ( unsigned char)(mu1[i*ny + j]*255.0 ) ;                       cs1[i * 3 * ny + i * 2 + 3 * j ] = c ;                       cs1[i * 3 * ny + i * 2 + 3 * j + 1 ] = c ;                       cs1[i * 3 *",
    "ny + i * 2 + 3 * j + 2 ] = c ;                    }                 }                             pixels[i * 3 * ny + i * 2 + 3 * j ] = c ;                       pixels[i",
    "* 3 * ny + i * 2 + 3 * j + 1 ] = c ;                       pixels[i * 3 * ny + i * 2 + 3 * j + 2 ] = c ;                    }                 }                     if ( z )                 for ( i = 0 ; i < np ; i++ )                 for ( j = 0 ; j < nf ; j++ )                 {                    free(z[i*nf + j].lin ) ;                    free(z[i*nf + j].col ) ;                    free(z[i*nf + j].ind ) ;                    free(z[i*nf + j].seg ) ;                 }                 if ( z )    free(z ) ;                   if ( dc )   free(dc ) ;                 if ( xl )   free(xl ) ;                 if ( yl )   free(yl ) ;                 if ( s )    free(s ) ;                 if ( xv )   free(xv ) ;                 if ( yv )   free(yv ) ;                   setcursor(loadcursor(null , idc_wait ) ) ;                 invalidaterect(hwnd , null , true ) ;                 status = 1 ;                 msg msg1 ;                 msg1.hwnd = hwnd ;                 msg1.message = wm_paint ;                 dispatchmessage(&msg1 ) ;              }             break ;           case idm_about :              dialogbox(hinst , makeintresource(idd_aboutbox ) , hwnd , about ) ;              break ;           case idm_exit :              destroywindow(hwnd ) ;              break ;           default :              return defwindowproc(hwnd , message , wparam , lparam ) ;           }           break ;        case wm_paint :           hdc = beginpaint(hwnd , & ps ) ;           rect prect ;                     bmih.bisize = sizeof(bitmapinfoheader ) ;                 bmih.biwidth = ny ;                 bmih.biheight = -nx ;                 bmih.biplanes = 1 ;                 bmih.bibitcount = 24 ;                 bmih.bicompression = bi_rgb ;                 bmih.bisizeimage = 0 ;                 bmih.bixpelspermeter = 10 ;                 bmih.biypelspermeter = 10 ;                 bmih.biclrused = 0 ;                 bmih.biclrimportant = 0 ;                    zeromemory(&dbmi , sizeof(dbmi ) ) ;                 dbmi.bmiheader = bmih ;                 dbmi.bmicolors->rgbblue = 0 ;                 dbmi.bmicolors->rgbgreen = 0 ;                 dbmi.bmicolors->rgbred = 0 ;                 dbmi.bmicolors->rgbreserved = 0 ;                 bits = ( void*)&(cs1[0 ] ) ;                     if ( hbmp = = null )                    messagebox (                       hwnd ,                       ( lpcwstr)l\"couldn't create bitmap ! \" ,                       ( lpcwstr)l\"error ! \" ,                       mb_ok | mb_iconexclamation ) ;                 memcpy(bits , cs1 , 3 * nx * ny + 2 * nx ) ;                       hdcmem = createcompatibledc(hdc ) ;                 hbmold = selectobject(hdcmem , hbmp ) ;                 getobject(hbmp , sizeof(bmp ) , & bmp ) ;                 bitblt(hdc , prect.right/2-ny,0,bmp.bmwidth , bmp.bmheight , hdcmem,0,0,srccopy ) ;                 selectobject(hdcmem , hbmold ) ;                 deletedc(hdcmem ) ;                 // end displaying cross - section                    bmih.bisize = sizeof(bitmapinfoheader ) ;                 bmih.biwidth = ny ;                 bmih.biheight = -nx ;                 bmih.biplanes = 1 ;                 bmih.bibitcount = 24 ;                 bmih.bicompression = bi_rgb ;                 bmih.bisizeimage = 0 ;                 bmih.bixpelspermeter = 10 ;                 bmih.biypelspermeter = 10 ;                 bmih.biclrused = 0 ;                 bmih.biclrimportant = 0 ;                    zeromemory(&dbmi , sizeof(dbmi ) ) ;                 dbmi.bmiheader = bmih ;                 dbmi.bmicolors->rgbblue = 0 ;                 dbmi.bmicolors->rgbgreen = 0 ;                 dbmi.bmicolors->rgbred = 0 ;                 dbmi.bmicolors->rgbreserved = 0 ;                 bits = ( void*)&(pixels[0 ] ) ;                     if ( hbmp = = null )                    messagebox (                       hwnd ,                       ( lpcwstr)l\"couldn't create bitmap ! \" ,                       ( lpcwstr)l\"error ! \" ,                       mb_ok | mb_iconexclamation ) ;                 memcpy(bits , pixels , 3 * nx * ny + 2 * nx ) ;                       hdcmem = createcompatibledc(hdc ) ;                 hbmold = selectobject(hdcmem , hbmp ) ;                 getobject(hbmp , sizeof(bmp ) , & bmp ) ;                 bitblt(hdc , prect.right/2,0,bmp.bmwidth , bmp.bmheight , hdcmem,0,0,srccopy ) ;                 selectobject(hdcmem , hbmold ) ;                 deletedc(hdcmem ) ;                 // end displaying reconstruction                     rect rep , r1 , r2 , r3 , r4 ;                 rep.left = 0 ;                 rep.top = nx + 10 ;                 rep.right = prect.right ;                 rep.bottom = nx + 40 ;                 r1.left = 0 ;                 r1.top = nx + 40 ;                 r1.right = prect.right / 2 ;                 r1.bottom = nx + 70 ;                 r2.left = 0 ;                 r2.top = nx + 70 ;                 r2.right = prect.right / 2 ;                 r2.bottom = nx + 100 ;                 r3.left = 0 ;                 r3.top = nx + 100 ;                 r3.right = prect.right / 2 ;                 r3.bottom = nx + 130 ;                 r4.left = 0 ;                 r4.top = nx + 130 ;                 r4.right = prect.right / 2 ;                 r4.bottom = nx + 160 ;                               rect r5 , r6 , r7 , r8 ;                 r5.left = prect.right / 2 ;                 r5.top = nx + 40 ;                 r5.right = prect.right / 2 + 100 ;                 r5.bottom = nx + 70 ;                 r6.left = prect.right / 2 ;                 r6.top = nx + 70 ;                 r6.right = prect.right / 2 + 100 ;                 r6.bottom = nx + 100 ;                 r7.left = prect.right / 2 ;                 r7.top = nx + 100 ;                 r7.right = prect.right / 2 + 100 ;                 r7.bottom = nx + 130 ;                 r8.left = prect.right / 2 ;                 r8.top = nx + 130 ;                 r8.right = prect.right / 2 + 100 ;                 r8.bottom = nx + 160 ;                           movetoex(hdc , 0 , nx + 25 , null ) ;                 lineto(hdc , prect.right , nx + 25 ) ;                 movetoex(hdc , 0 , nx + 55 , null ) ;                 lineto(hdc , prect.right , nx + 55 ) ;                 movetoex(hdc , 0 , nx + 85 , null ) ;                 lineto(hdc , prect.right , nx + 85 ) ;                 movetoex(hdc , 0 , nx + 115 , null ) ;                 lineto(hdc , prect.right , nx + 115 ) ;                 movetoex(hdc , 0 , nx + 145 , null ) ;                 lineto(hdc , prect.right , nx + 145 ) ;                   break ;              case 2 :                 getclientrect(hwnd , & prect ) ;                 drawtext(hdc , ( lptstr)msg1 , 50 , & prect , dt_center ) ;                 break ;              default :                 break ;           }           endpaint(hwnd , & ps ) ;           break ;        case wm_destroy :           deleteobject(hbmp ) ;           postquitmessage(0 ) ;           break ;        default :           return defwindowproc(hwnd , message , wparam , lparam ) ;     }         return 0 ; }    // message handler for about box int_ptr callback about(hwnd hdlg , uint message , wparam wparam , lparam lparam ) {     unreferenced_parameter(lparam ) ;     switch ( message )     {        case wm_initdialog :           return ( int_ptr)true ;        case wm_command :           if ( loword(wparam ) = = idok || loword(wparam ) = = idcancel )           {              enddialog(hdlg , loword(wparam ) ) ;              return ( int_ptr)true ;           }           break ;     }     return ( int_ptr)false ; }                     switch ( i d )     {        case 3 :           i1 = 0 ;           i2 = 45 ;           break ;        case 2 :           i1 = 45 ;           i2 = 90 ;           break ;        case 1 :           i1 = 90 ;           i2 = 135 ;           break ;        case 0 :           i1 = 135 ;           i2 = 180 ;           break ;        default :           break ;     }       for ( z = ni ; z ! = 0 ; z-- )     {        for (",
    "i = i1 ; i < i2 ; i++ )        {           for ( j = 0 ; j < np ; j++ )           {              if ( z[j*nf + i].count > 0 )              {                 index1 = j*nf + i ;                 index2 = z[index1].count ;                                   pi++ ;                    }                 }                 else                 {                    if ( s[index1 ] > 0.0 )                    {                       messagebox(null , ( lpcwstr)l \" ! ! \" , ( lpcwstr)l \" ! \" , mb_ok ) ;                       pi = z[index1].ind ;                       ps = z[index1].seg ;                       for ( k = 0 ; k < index2 ; k++ )                       {                          ri2[(*pi ) ] + = ( * ps)*(s[index1 ] / z[index1].sumofsegs ) ;                          pi++ ;                          ps++ ;                       }                    }                 }              }           }        }                      if ( i d = = 0 )        {           for ( i = 0 ; i < nx ; i++ )           for ( j = 0 ; j < ny ; j++ )           {              rig[i*ny + j]+= ri2[i*ny + j ] ;              ri1[i*ny + j ] = rig[i*ny + j ] / mo1[i*ny + j ] ;              rig[i*ny + j ] = 0.0 ;           }        }              99 m. beister , d. kolditz , w.a .",
    "kalender , iterative reconstruction methods in x - ray ct , physica medica , vol .",
    "28 , p. 94 - 108",
    "( 2012 ) f. natterer , the mathematics of computerized tomography , pages : xiv + 226 , siam , series classics in applied mathematics ( 2001 ) r. gordon , r. bender , g.t .",
    "herman , algebraic reconstruction techniques ( art ) for three - dimensional electron microscopy and x - ray photography , journal of theoretical biology , vol .",
    "29 , p. 471",
    "- 482 ( 1970 ) a.h .",
    "andersen , a.c .",
    "kak , simultaneous algebraic reconstruction technique ( sart ) : a superior implementation of the art algorithm , ultrasonic imaging , vol . 6 , p. 81 - 94",
    "( 1984 ) p. gilbert , iterative methods for the three - dimensional reconstruction of an object from projections , journal of theoretical biology , vol .",
    "36 , p. 105",
    "- 117 ( 1972 ) a. silva , h. lawder , a. hara , j. kujak , q. pavlicek , innovations in ct dose reduction strategy : application of the adaptive statistical iterative reconstruction algorithm , american journal of roentgenology , vol .",
    "194 , p.191 - 199 ( 2010 ) y. xu , w. he , h. chen , z. hu , j. li , t. zhang , impact of the adaptive statistical iterative reconstruction technique on image quality in ultra - low - dose ct , clinical radiology , vol .",
    "68 , p. 902",
    "- 908 ( 2013 ) m.e .",
    "al , contrast - to - noise ratio and low - contrast object resolution on full- and low - dose mdct : safire versus filtered back projection in a low - contrast object phantom and in the liver , american journal of roentgenology , vol .",
    "199 , p. 8 - 18",
    "( 2012 ) r. wang et .",
    "al , image quality and radiation dose of low dose coronary ct angiography in obese patients : sinogram affirmed iterative reconstruction versus filtered back projection , european journal of radiology , vol .",
    "81 , p. 3141 - 3145",
    "( 2012 ) b. schulz , m. beeres , b. bodelle , r. bauer , f. al - butmeh , a. thalhammer , t.j .",
    "vogl , j.m .",
    "kerl , performance of iterative image reconstruction in ct of the paranasal sinuses : a phantom study , american journal of neuroradiology , vol .",
    "34 , p. 1072 - 1076",
    "( 2013 ) f. pontana , j. pagniez , a. duhamel , t. flohr , j .- b .",
    "faivre , c. murphy , j. remy , m. remy - jardin , reduced - dose low - voltage chest ct angiography with sinogram - affirmed iterative reconstruction versus standard - dose filtered back projection , radiology , vol .",
    "267 , p. 609 - 618 ( 2013 ) r. wang , u.j .",
    "schoepf , r. wu , k.p .",
    "gibbs , w. yu , m. li , z. zhang , ct coronary angiography : image quality with sinogram - affirmed iterative reconstruction compared with filtered back - projection , clinical radiology , vol .",
    "68 , p. 272",
    "- 278 ( 2013 ) f. becce , y.b .",
    "salah , f.r .",
    "verdun , b.c .",
    "vande berg , f.e .",
    "lecouvet , r. meuli , p. omoumi , computed tomography of the cervical spine : comparison of image quality between a standard - dose and a low - dose protocol using filtered back - projection and iterative reconstruction , skeletal radiology , vol .",
    "42 , p. 937",
    "- 945 ( 2013 ) h.j .",
    "shin , y.e .",
    "chung , y.h .",
    "lee , j .- y .",
    "choi , m .- s .",
    "park , m .- j .",
    "kim , k.w .",
    "kim , radiation dose reduction via sinogram affirmed iterative reconstruction and automatic tube voltage modulation ( care kv ) in abdominal ct , korean journal of radiology , vol .",
    "14 , p. 886 - 893 ( 2013 ) f. pontana , s. henry , a. duhamel , j .- b .",
    "faivre , n. tacelli , j. pagniez , j. remy , m. remy - jardin , impact of iterative reconstruction on the diagnosis of acute pulmonary embolism ( pe ) on reduced - dose chest ct angiograms , european radiology , vol .",
    "25 , p. 1182 - 1189",
    "( 2015 ) sinogram affirmed iterative reconstruction ( safire ) , brochure available at the official page www.healthcare.siemens.com/computed-tomography/options-upgrades/clinical-applications/safire/data-sheet matlab , www.mathworks.com"
  ],
  "abstract_text": [
    "<S> with the availability of more powerful computing processors , iterative reconstruction algorithms have recently been successfully implemented as an approach to achieving significant dose reduction in x - ray ct . in this report , we descrive our recent work on developing an adaptive iterative reconstruction algorithm for x - ray ct , that is shown to provide results comparable to those obtained by proprietary algorithms , both in terms of reconstruction accuracy and execution time . </S>",
    "<S> the described algorithm is thus provided for free to the scientific community , for regular use , and for possible further optimization . </S>"
  ]
}