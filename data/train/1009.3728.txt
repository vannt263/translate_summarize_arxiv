{
  "article_text": [
    "network coding was introduced in @xcite as a means to improve the rate of transmission in networks .",
    "linear network coding was introduced in @xcite .",
    "deterministic algorithms exist @xcite to construct _ scalar network codes _ ( in which the input symbols and the network coding coefficients are scalars from a finite field ) which achieve the maxflow - mincut capacity in the case of acyclic networks with a single source which wishes to multicast a set of finite field symbols to a set of @xmath0 sinks , as long as the field size @xmath1 . finding the minimum field size over which a network code exists for a given network",
    "is known to be a hard problem @xcite .",
    "most recently , an algorithm was proposed in @xcite which attempts to find network codes using small field sizes , given a network coding solution for the network over some larger field size @xmath2 the algorithms of @xcite also apply to linear deterministic networks @xcite , and for _ vector network codes _ ( where the source seeks to multicast a set of vectors , rather than just finite field symbols ) . in this work ,",
    "we are explicitly concerned about the scalar network coding problem , although the same techniques can be easily extended to accommodate for vector network coding and linear deterministic networks , if permissible , as in the case of @xcite .",
    "network - error correction , which involved a trade - off between the rate of transmission and the number of correctable network - edge errors , was introduced in @xcite as an extension of classical error correction to a network setting .",
    "along with subsequent works @xcite and @xcite , this generalized the classical notions of the hamming weight , hamming distance , minimum distance and various classical error control coding bounds to their network counterparts .",
    "algorithms for constructing network - error correcting codes which meet a generalization of the classical singleton bound for networks can be found in @xcite . using the algorithm of @xcite , a network code which can correct any errors occurring in at most @xmath3 edges",
    "can be constructed , as long as the field size @xmath4 is such that @xmath5 where @xmath6 is the set of edges in the network .",
    "the algorithms of @xcite have similar requirements to construct such network - error correcting codes .",
    "this can be prohibitive when @xmath7 is large , as the sink nodes and the coding nodes of the network have to perform operations over this large field , possibly increasing the overall delay in communication .    in this work ,",
    "we extend the ef algorithm to block network - error correction using small fields . as in @xcite",
    ", we shall restrict our algorithms and analysis to fields with binary characteristic .",
    "the techniques presented can be extended to finite fields of other characteristics without much difficultly .",
    "the contributions of this work are as follows .",
    "* we extend the ef algorithm of @xcite to construct network - error correcting codes using small fields , by bridging the techniques of the ef algorithm and the network - error correction algorithm of @xcite . *",
    "the major step in the ef algorithm is to compute a polynomial of least degree coprime with a polynomial , @xmath8 of possibly large degree . while it is shown in @xcite that this can be done in polynomial time",
    ", the complexity can still be large .",
    "optimizing based on our requirement , we propose a alternate algorithm for computing the polynomial coprime with @xmath9 this is shown to have lesser complexity than that of the ef algorithm , which simply adopts a brute force method to do the same .",
    "the rest of this paper is organized as follows . in section [ sec2 ] ,",
    "we give the basic notations and definitions related to network coding , required for our purpose . in section [ sec3 ] ,",
    "we review the ef algorithm briefly and then propose our modification to it , and prove that the modified algorithm has lesser complexity than the original technique in the ef algorithm .",
    "section [ sec4 ] presents our algorithm for constructing network - error correcting codes using small field sizes , along with calculations of the complexity of the algorithm .",
    "examples illustrating the algorithm performance for network coding and error correction are presented in section [ sec5 ] .",
    "finally , we conclude the paper in section [ sec6 ] with comments and directions for further research .",
    "the model for acyclic networks considered in this paper is as in @xcite .",
    "an acyclic network can be represented as a acyclic directed multi - graph @xmath10 , where @xmath11 is the set of all nodes and @xmath6 is the set of all edges in the network .",
    "we assume that every edge in the directed multi - graph representing the network has unit _ capacity _ ( can carry utmost one symbol from @xmath12 ) . network links with capacities greater than unity are modeled as parallel edges .",
    "the network is assumed to be instantaneous , i.e. , all nodes process the same _ generation _ ( the set of symbols generated at the source at a particular time instant ) of input symbols to the network in a given coding order ( ancestral order @xcite ) .",
    "let @xmath13 be the source node and @xmath14 be the set of @xmath15 receivers .",
    "let @xmath16 be the unicast capacity for a sink node @xmath17 , i.e. , the maximum number of edge - disjoint paths from @xmath18 to @xmath19 .",
    "then @xmath20 is the max - flow min - cut capacity of the multicast connection .",
    "an @xmath21-dimensional network code ( @xmath22 ) is one which can be used to transmit @xmath21 symbols simultaneously from @xmath18 to @xmath23 and can be described by the three matrices @xmath24 ( of size @xmath25 ) , @xmath26 ( of size @xmath27 ) , and @xmath28 ( of size @xmath29 for every sink @xmath30 ) , each having elements from some finite field @xmath12 .",
    "further details on the structure of these matrices can be found in @xcite and @xcite .",
    "we then have the following definition .",
    "@xcite [ nettransfermatrix ] _ the network transfer matrix _ , @xmath31 for a @xmath21-dimensional network code , , corresponding to a sink node @xmath32 is a full rank @xmath33 matrix defined as @xmath34    the matrix @xmath35 governs the input - output relationship at sink @xmath36 the problem of designing a @xmath21-dimensional network code then implies making a choice for the matrices @xmath37 and @xmath38 such that the matrices @xmath39 have rank @xmath21 each .",
    "we thus consider each element of @xmath40 , and @xmath28 to be a variable @xmath41 for some positive integer @xmath42 , which takes values from the finite field @xmath43 let @xmath44 be the set of all variables , whose values define the network code .    the variables @xmath41s are known as the _ local encoding coefficients _ @xcite . for an edge @xmath45 in a network with a @xmath21-dimensional network code in place , the _ global encoding vector _",
    "@xcite is a @xmath21 dimensional vector which defines the particular linear combination of the @xmath21 input symbols which flow through @xmath46 it is known @xcite that deterministic methods of constructing a @xmath47-dimensional network code exist , as long as @xmath48    let @xmath49 be the length of the longest path from the source to any sink . because of the structure of the matrices @xmath40 and @xmath28 ,",
    "it is seen @xcite that the matrix @xmath35 has degree at most @xmath49 in any particular variable @xmath41 and also a total degree ( sum of the degrees across all variables in any monomial ) of @xmath49 .",
    "let @xmath50 be the determinant of @xmath35 and @xmath51 then the degree in any variable ( and the total degree ) of the polynomials @xmath52 and @xmath53 are at most @xmath54 and @xmath55 respectively .",
    "after briefly recollecting the ef algorithm , we shall proceed to modify its key step so that the overall complexity of the algorithm is reduced .",
    "@xmath56 assign values @xmath57s to the scalar coding coefficients @xmath41s from an appropriate field @xmath58 such that the network transfer matrices @xmath35s to all the sinks are invertible .",
    "@xmath59 express every @xmath60 as a binary polynomial @xmath61 of degree at most @xmath62 using the usual polynomial representation of the finite field @xmath63 for a particular choice of the primitive polynomial of degree @xmath64    @xmath65 substituting these polynomials representing the @xmath41s in the matrices @xmath66 calculate the determinants of @xmath35 as the polynomials @xmath67,$ ] and also find @xmath68 then , @xmath69 is non - zero and has degree at most @xmath70 in the variable @xmath71    @xmath72 find an irreducible polynomial of least degree , @xmath73 which is coprime with @xmath9    @xmath74 let @xmath75 thus , each @xmath41 can be viewed as an element in @xmath76}{\\left(g(x)\\right)}.$ ] also , for each sink @xmath23 the matrices @xmath35 remain invertible as @xmath77 as @xmath78    the following lemma ensures that such a coprime @xmath79 exists and can be found in polynomial time .",
    "@xcite [ coprimeexistence ] if @xmath69 is a non - zero binary polynomial of degree @xmath80 , there exists a coprime polynomial @xmath79 of degree at most @xmath81 , and we can identify it in polynomial time .",
    "@xcite [ rem1 ] the worst - case complexity of computing @xmath79 is @xmath82 where @xmath83      we now present a fast algorithm for computing the least degree irreducible polynomial @xmath79 that is coprime with @xmath9 note that any polynomial @xmath79 coprime with @xmath69 is useful only if the degree of @xmath79 is less than @xmath84 as only such a @xmath79 can result in a network code using a smaller field than the one we started with . using this fact , we give algorithm [ alg : coprime ] which computes a least degree irreducible polynomial @xmath79 that is coprime with @xmath9    @xmath56 let @xmath85    @xmath59    @xmath65 let @xmath86 be the first polynomial for which @xmath87 is non - zero . note that every @xmath88 is the product of all irreducible polynomials whose degree divides @xmath89 also , all irreducible polynomials of degree @xmath90 divide @xmath69 as all @xmath91 for all @xmath92 therefore , at least one of the irreducible polynomials of degree @xmath93 is coprime with @xmath9 find one such polynomial @xmath94      the following lemma ensures that all polynomials which are found to be coprime with @xmath69 by directly computing the gcd ( or the remainder for irreducible polynomials ) in the brute force method ( as done in algorithm [ alg : construction ] ) , can also be found by running algorithm [ alg : coprime ] , using the set of polynomials @xmath95 upto the appropriate degree .",
    "[ lemmafindingg ] for some field @xmath96 let @xmath97 $ ] be two polynomials relatively prime with each other .",
    "let @xmath98 $ ] such that @xmath99 then @xmath100 is also relatively prime with the polynomial @xmath101    as @xmath53 and @xmath100 are coprime with each other , we can obtain polynomials @xmath102 $ ] such that @xmath103 let @xmath104 for the appropriate quotient and remainder polynomials @xmath105 $ ] with @xmath106 also , as @xmath107 let @xmath108 then , @xmath109 which means that @xmath100 and @xmath110 are coprime with each other , hence proving the lemma .",
    "we now prove that our method for step @xmath111 of algorithm [ alg : construction ] has less complexity than that of @xcite . towards that end , we first prove the following lemma .",
    "[ lemmafindinggcomplexity ] let @xmath112,$ ] be such that @xmath113 and @xmath114 for some non - negative integers @xmath115 and @xmath116 the polynomial @xmath117 can be calculated using at most @xmath118 bit additions .",
    "let @xmath119 we arrange the coefficients of @xmath53 as follows .",
    "@xmath120 where @xmath121 is the largest positive integer such that @xmath122    now , note that calculating the polynomial @xmath117 , is equivalent to adding up the rows of the arrangement , while retaining the coefficient @xmath123 as it is .",
    "there are @xmath124 rows in the arrangement , and adding any two rows requires at most @xmath125 additions .",
    "thus , the total number of bit additions is @xmath126    [ propcomplexitygcd ] the complexity of algorithm [ alg : coprime ] is at most @xmath127    the worst - case for algorithm [ alg : coprime ] would be @xmath128 by lemma [ lemmafindinggcomplexity ] , computing @xmath129 for some @xmath130 takes at most @xmath131 operations . as there are @xmath132 such @xmath61s , evaluating the remainders @xmath87s costs @xmath133 operations at most .",
    "let @xmath134 be the polynomial of degree at most @xmath135    now , we have to determine the complexity in obtaining the polynomial of degree @xmath136 which is coprime with @xmath69 ( or equivalently with @xmath137 ) .",
    "there are approximately @xmath138 irreducible polynomials of order @xmath139 it is known ( see @xcite , for example ) that for any two polynomials @xmath140 and @xmath141 ( atleast one of them of degree @xmath142 ) , the complexity of dividing @xmath140 by @xmath141 ( or equivalently , calculating @xmath143 ) is @xmath144 thus , the complexity of dividing @xmath137 by every possible irreducible polynomial of degree @xmath145 is at most @xmath146    thus , the total complexity for finding the least degree polynomial @xmath79 coprime with @xmath69 ( which is assured of having a coprime factor of degree @xmath147 ) is at most @xmath127    note that the worst - case complexity of algorithm [ alg : coprime ] is lesser than the worst - case complexity of finding the coprime polynomial @xmath79 according to @xcite ( which assumes a direct test for coprimeness of @xmath69 and the candidate polynomials ) , indicated in remark [ rem1 ] . even if we test for coprimeness only for polynomials upto degree @xmath148 the algorithm of @xcite would still have a worst - case complexity of @xmath149 where @xmath83",
    "this section presents the major contribution of this work . after briefly reviewing the network - error correcting code construction algorithm in @xcite ,",
    "we proceed to give an algorithm which can obtain network - error correcting codes using small finite fields .",
    "an edge is said to be in error if its input symbol and output symbol ( both from some appropriate field @xmath12 ) are not the same .",
    "we model the edge error as an additive error from @xmath12 .",
    "network - error _ is a @xmath7 length vector over @xmath12 , whose components indicate the additive errors on the corresponding edges . a network code which enables every sink to correct any errors in any set of edges of cardinality at most @xmath3",
    "is said to be a @xmath3 _ network - error correcting code_. there have been different approaches to network - error correction @xcite .",
    "we concern ourselves with the notations and approach of @xcite , as the algorithm in @xcite lends itself to be extended according to the techniques of @xcite .",
    "it is known @xcite that the number of messages @xmath115 in an @xmath3 network - error correcting code is upper bounded according to the _ network singleton bound _ as @xmath150    assuming that the message set is a vector space over @xmath12 of dimension @xmath151 we have @xmath152 this bound was later refined @xcite to accommodate for the different mincuts and different error capabilities at different sinks as @xmath153 where sink @xmath17 can correct any network - error with errors in at most @xmath154 edges .",
    "algorithm [ alg : necc ] is a brief version of the algorithm given in @xcite for constructing an @xmath3 network - error correcting code for a given single source , acyclic network that meets the network singleton bound .",
    "the construction of @xcite is based on the network code construction algorithm of @xcite .",
    "the algorithm constructs a network code such that all network - errors in upto @xmath155 edges will be corrected as long as the sinks know where the errors have occurred .",
    "such a network code is then shown @xcite to be equivalent to an @xmath3 network - error correcting code .",
    "@xmath56 let @xmath156 be the set of all subsets of edge set of size @xmath157 add an imaginary source @xmath158 and draw @xmath159 edges from @xmath158 to @xmath160    @xmath59    it is shown in @xcite that algorithm [ alg : necc ] results in a network code which is a @xmath3 network - error correcting code meeting the network singleton bound , as long as the field size @xmath161",
    "algorithm [ alg : necclowfieldsize ] , shown in the next page , constructs a network - error correcting code using small field sizes ( conditioned on the existence of an irreducible polynomial of small degree satisfying the necessary requirements ) .",
    "@xmath56 with @xmath162 run algorithm [ alg : necc ] to find an @xmath3 network - error correcting code meeting the network singleton bound .",
    "let the encoding coefficients for @xmath41 be @xmath163    @xmath59 express every @xmath60 as a binary polynomial @xmath61 of degree at most @xmath62 using the usual polynomial representation of the finite field @xmath164",
    "@xmath65    @xmath72 calculate the polynomial @xmath165    @xmath74 using algorithm [ alg : coprime ] with the set @xmath166 , find an irreducible polynomial of least degree , @xmath73 which is coprime with @xmath9    @xmath167 let @xmath75 thus , each @xmath41 can be viewed as an element in @xmath76}{\\left(g(x)\\right)}.$ ] because of the fact that @xmath168 the new @xmath169 matrices obtained after the modulo operation are also full rank , which implies that the error correcting capability of the code is preserved .",
    "in order to ensure that the error correction property of the original network code is preserved , it is sufficient if a polynomial @xmath79 is coprime with each polynomial @xmath171 rather than their product @xmath8 as shown in step @xmath170 of algorithm [ alg : necclowfieldsize ] .",
    "however , the following lemma shows that both are equivalent .",
    "let @xmath172 , i=1,2, ... ,n\\right\\}$ ] be a collection of univariate polynomials with coefficients from some field @xmath173 a polynomial @xmath174 $ ] is relatively prime with all the polynomials in @xmath175 if and only if it is relatively prime with their product .",
    "_ if part : _ if @xmath100 is relatively prime with the product of all the polynomials in @xmath176 then there exist polynomials @xmath102 $ ] such that @xmath177 for each @xmath178 we can rewrite ( [ eqn102 ] ) as @xmath179 which implies that @xmath100 is coprime with each @xmath180    _ only if part : _ suppose @xmath100 is relatively prime with all the polynomials in @xmath181 then , for each @xmath178 we can find polynomials @xmath182 and @xmath183 such that , @xmath184 in particular , @xmath185 using ( [ eqn104 ] ) in ( [ eqn103 ] ) , @xmath186 thus , @xmath100 is relatively prime with @xmath187 continuing with the same argument , it is clear that @xmath100 is relatively prime with @xmath188      the complexity of algorithm [ alg : necclowfieldsize ] is given by table [ tab1 ] , along with the references and reasoning for the mentioned complexities for every step of the algorithm .    the only complexity calculation of table [ tab1 ] which remains to be explained is the complexity involved in identifying and calculating the non - zero minor of the matrix @xmath189 there are @xmath190 such minors , and calculating each takes @xmath191 multiplications over @xmath43 as @xmath192 can take values upto @xmath193 clearly the function to be maximized is of the form @xmath194 for @xmath195 proposition [ thmcomplexity ] gives the value of @xmath196 for which such a function is maximized , based on which the value in table [ tab1 ] has been calculated .",
    "[ thmcomplexity ] for some positive integer @xmath197 let @xmath196 be an integer such that @xmath198 the function @xmath199 is maximized at @xmath200    the statement of the theorem is easy to verify for @xmath201 therefore , let @xmath202 let @xmath203 for some @xmath151 such that @xmath204 then , @xmath205 where @xmath206 proving the statement of the theorem is then equivalent to showing that both of the following two statements are true , which we shall do separately for even and odd values of @xmath80 .    * @xmath207 for all integers @xmath208 * @xmath209 for all integers @xmath210    _ case - a _ ( @xmath80 _ is even _ ) : let @xmath211 for some integer @xmath42 such that @xmath212 then , @xmath213 for @xmath214 it is clear from ( [ eqn100 ] ) that @xmath215 if @xmath216 it is clear that @xmath217 thus , for even values of @xmath80 , the theorem is proved .",
    "+ _ case - b _",
    "( @xmath80 _ is odd _ ) : let @xmath218 for some integer @xmath42 such that @xmath219 then , @xmath220 now , for @xmath221 @xmath222 ( as @xmath223 and is odd ) .",
    "hence , @xmath224 for @xmath225 if @xmath226 then by ( [ eqn101 ] ) , it is clear that @xmath215 thus for all @xmath227 @xmath215    for @xmath228 again by ( [ eqn101 ] ) , it is clear that @xmath229 and thus the theorem holds for odd values of @xmath116 this completes the proof",
    ".    [ cols=\"^,^,^,^\",options=\"header \" , ]     [ tab3 ]    according to the algorithm in @xcite , a @xmath230 network - error correcting code can be constructed deterministically if @xmath231 in fig .",
    "[ fig : necnetwork ] , let the variable @xmath232 denote the encoding coefficient between edges @xmath233 and @xmath234 similarly , the variable @xmath235 denote the local encoding coefficients between @xmath236 and @xmath237        let @xmath238 let @xmath239 and @xmath240 , where @xmath241 is a primitive element of @xmath242 let @xmath243 be the primitive polynomial of degree @xmath244 under consideration .",
    "consider two such @xmath230 network - error correcting codes obtained using algorithm [ alg : necc ] for the network of fig .",
    "[ fig : necnetwork ] as follows .",
    "let @xmath245 and @xmath246 be two choices for the set @xmath247 with all the other local encoding coefficients being unity .",
    "it can be verified that these two network codes can be used to transmit one error - free @xmath248 symbol from the source to both sinks , as long as not more than single edge errors occur in the network .",
    "table [ tab3 ] gives the results of running algorithm [ alg : necclowfieldsize ] for this network starting from these two codes , with @xmath249 and @xmath250 being the primitive elements of @xmath251 and @xmath252 respectively . except for @xmath253",
    "all the other coding coefficients remain @xmath230 over the respective fields . as in example",
    "[ exm1 ] , the initial choice of the sets @xmath245 and @xmath246 for @xmath247 results in the final network code being over different field sizes . with @xmath246 ,",
    "the resultant network - error correcting code is over @xmath254 exactly the one reported in @xcite by brute force construction .",
    "a new and faster method of computing a coprime polynomial to a given polynomial has been presented . thereby improving the performance of the ef algorithm , which is applicable to scalar and vector network coding .",
    "based on the ef algorithm , a method has been presented which can obtain network - error correcting codes using small fields that meet the network singleton bound . this technique can be adapted to obtain network - error correcting codes meeting the refined singleton bound , or for linear deterministic networks which permit solutions similar to those obtained in @xcite .    as in the original paper @xcite",
    ", questions remain open about the achievability of a code using the minimal field size .",
    "as illustrated by the examples in section [ sec5 ] , factors such as the initial choice of the network code and the primitive polynomial of the field over which the initial code is defined ( using which the local encoding coefficients are represented as polynomials ) , control the resultant field size after the algorithm .",
    "the authors would like to thank raman sankaran of the csa dept .",
    ", iisc , for useful discussions regarding the complexity calculations of the algorithms presented in this paper .",
    "this work was supported partly by the drdo - iisc program on advanced research in mathematical engineering through a research grant and partly by the inae chair professorship grant to b.  s.  rajan .",
    "s. jaggi , p. sanders , p.a .",
    "chou , m. effros , s. egner , k. jain and l.m.g.m .",
    "tolhuizen , `` polynomial time algorithms for multicast network code construction '' , ieee trans .",
    "theory , vol .",
    "51 , no . 6 , june 2005 , pp.1973 - 1982 .",
    "s. avestimehr , s n. diggavi and d.n.c .",
    "tse , `` wireless network information flow '' proceedings of allerton conference on communication , control , and computing , illinois , september 26 - 28 , 2007 , pp ."
  ],
  "abstract_text": [
    "<S> recently , ebrahimi and fragouli proposed an algorithm to construct scalar network codes using small fields ( and vector network codes of small lengths ) satisfying multicast constraints in a given single - source , acyclic network . </S>",
    "<S> the contribution of this paper is two fold . </S>",
    "<S> primarily , we extend the scalar network coding algorithm of ebrahimi and fragouli ( henceforth referred to as the ef algorithm ) to block network - error correction . </S>",
    "<S> existing construction algorithms of block network - error correcting codes require a rather large field size , which grows with the size of the network and the number of sinks , and thereby can be prohibitive in large networks . </S>",
    "<S> we give an algorithm which , starting from a given network - error correcting code , can obtain another network code using a small field , with the same error correcting capability as the original code . </S>",
    "<S> our secondary contribution is to modify the ef algorithm itself . </S>",
    "<S> the major step in the ef algorithm is to find a least degree irreducible polynomial which is coprime to another large degree polynomial . </S>",
    "<S> we suggest an alternate method to compute this coprime polynomial , which is faster than the brute force method in the work of ebrahimi and fragouli . </S>"
  ]
}