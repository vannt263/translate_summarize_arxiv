{
  "article_text": [
    "support for computing with _ functions _ , that is , solutions of linear differential equations with polynomial coefficients , has become a common feature of computer algebra systems .",
    "for instance , mathematica now provides a data structure called ` differentialroot ` to represent arbitrary functions by differential equations they satisfy and initial values .",
    "maple s ` desol ` is similar but more limited .",
    "an important source of such general functions is combinatorics , due to the fact that many combinatorial structures have generating functions .",
    "moreover , powerful methods allow to get from a combinatorial description of a class of objects to a system of differential equations that `` count '' these objects , and then to extract precise asymptotic information from these equations , even when no explicit counting formula is available  @xcite .",
    "a second major application of is concerned with special functions .",
    "indeed , many classical functions of mathematical physics are ( often by virtue of being defined as `` interesting '' solutions of simple differential equations ) , which allows to treat them uniformly in algorithms .",
    "this is exploited by the _ encyclopedia of special functions _",
    "@xcite and its successor under development , the _ dynamic dictionary of mathematical functions _",
    "@xcite , an interactive computer - generated handbook of special functions .",
    "these applications require at some point the ability to perform `` analytic '' computations with functions , starting with their numerical evaluation .",
    "relevant algorithms exist in the literature .",
    "in particular , functions may be computed with an absolute error bounded by @xmath0 in @xmath1 bit operations  that is , in softly linear time in the size of the result written in fixed - point notation  at any point of their riemann surfaces  @xcite , the necessary error bounds also being computed from the differential equation and initial values  @xcite .",
    "however , these algorithms have remained theoretical  @xcite .",
    "the ability of computer algebra systems to work with functions is ( mostly ) limited to symbolic manipulations , and the above - mentioned fast evaluation algorithm has served as a recipe to write numerical evaluation routines for specific functions rather than as an algorithm for the entire class of functions .",
    "this article introduces numgfun , a maple package that attempts to fill this gap , and contains , among other things , a general implementation of that algorithm .",
    "numgfun is distributed as a subpackage of gfun  @xcite , under the gnu lgpl .",
    "note that it comes with help pages : the goal of the present article is not to take the place of user documentation , but rather to describe the features and implementation of the package , with supporting examples , while providing an overview of techniques relevant to the development of similar software .",
    "the following examples illustrate typical uses of numgfun , first to compute a remote term from a combinatorial sequence , then to evaluate a special function to high precision near one of its singularities .",
    "[ ex : motzkin]the motzkin number @xmath2 is the number of ways of drawing non - intersecting chords between @xmath3 points placed on a circle .",
    "motzkin numbers satisfy @xmath4 . using numgfun ,",
    "the command ` nth_term({(n+4)*m(n+2)=3*(n+1)*m(n)+(2*n+5)*m(n+1 ) , m(0)=1,m(1)=1},m(n),k ) ` computes @xmath5 in 4.7  s and @xmath6 in 1  min .",
    "navely unrolling the recurrence ( using maple ) takes 10.7  s for @xmath7 , and 41  s for @xmath8 . on this ( non - generic ) example , ` nth_term `",
    "could be made competitive for smaller indices by taking advantage of the fact that the divisions that occur while unrolling the recurrence are exact .",
    "[ ex : heun]the double confluent heun function @xmath9 satisfies @xmath10 , @xmath11 , @xmath12 .",
    "it is singular at @xmath13 .",
    "the command ` evaldiffeq(eq , y(z ) , -0.99,1000 ) ` where ` eq ` is this differential equation yields @xmath14 in 22  s.    [ [ related - work ] ] related work + + + + + + + + + + + +    most algorithms implemented in numgfun originate in work of chudnovsky  & chudnovsky and of van der hoeven .",
    "perhaps the most central of these is the `` bit burst '' numerical evaluation method  @xcite .",
    "it belongs to the family of binary splitting algorithms for series , hints at the existence of which go back to  @xcite , and generalizes earlier work of brent  @xcite for specific elementary functions .",
    "better known ( thanks among others to  @xcite ) binary splitting algorithms can be seen as special cases of the bit burst algorithm .",
    "one reason why , unlike these special cases , it was not used in practice is that in  @xcite , none of the error control needed to ensure the accuracy of the computed result is part of the algorithm .",
    "van der hoeven s version  @xcite addresses this issue , thus giving a full - fledged evaluation algorithm for the class of functions , as opposed to a method to compute any function given certain bounds .",
    "these algorithms extend to the computation of limits of functions at singularities of their defining equation .",
    "the case of regular singularities is treated both in  @xcite , and more completely in  @xcite , that of irregular singular points in  @xcite .",
    "see  @xcite , @xcite for more history and context .    on the implementation side , routines based on binary splitting for the evaluation of various elementary and special functions",
    "are used in general - purpose libraries such as cln  @xcite and mpfr  @xcite .",
    "binary splitting of fast converging series is also the preferred algorithm of software dedicated to the high - precision computation of mathematical constants on standard pcs , including the current record holder for  @xmath15  @xcite . finally , even the impressive range of built - in functions of computer algebra systems is not always sufficient for applications .",
    "works on the implementation of classes of `` less common '' special functions that overlap those considered in numgfun include  @xcite .",
    "this work is based in part on the earlier  @xcite .",
    "[ [ contribution ] ] contribution + + + + + + + + + + + +    the main contribution presented in this article is numgfun itself .",
    "we recall the algorithms it uses , and discuss various implementation issues . some of these descriptions include improvements or details that do not seem to have appeared elsewhere . specifically :",
    "( i )  we give a new variant of the analytic continuation algorithm for d - finite functions that is faster with respect to the order and degree of the equation ; ( ii )  we improve the complexity analysis of the bit burst algorithm by a factor @xmath16 ; ( iii )  we point out that poole s method to construct solutions of differential equations at regular singular points can be rephrased in a compact way in the language of noncommutative polynomials , leading to faster evaluation of functions in these points ; and ( iv )  we describe in some detail the practical computation of all the bounds needed to obtain a provably correct result .",
    "[ [ what - numgfun - is - not ] ] what numgfun is not + + + + + + + + + + + + + + + + + + +    despite sharing some of the algorithms used to compute mathematical constants to billions of digits , our code aims to cover as much as possible of the class of functions , not to break records . also",
    ", it is limited to `` convergent '' methods : asymptotic expansions , summation to the least term , and resummation of divergent power series are currently out of scope .",
    "[ [ terminology ] ] terminology + + + + + + + + + + +    like the rest of gfun , numgfun works with _ functions _ and _ p - recursive sequences_. we recall only basic definitions here ; see @xcite for further properties .",
    "a formal power series @xmath17 $ ] is _ _ over @xmath18 if it solves a non - trivial linear differential equation @xmath19 with coefficients @xmath20 .",
    "the same definition applies to analytic functions .",
    "a sequence @xmath21 is _ p - recursive _ over  @xmath22 if it satisfies a non - trivial linear recurrence relation @xmath23 a sequence @xmath24 is p - recursive if and only if its generating series @xmath25 is .",
    "the poles of the coefficients @xmath26 of  ( [ eq : deq ] ) are its _ singular points _ ; nonsingular points are called _",
    "ordinary_. in gfun , a function is represented by a differential equation of the form  ( [ eq : deq ] ) and initial values at the origin , which we assume to be an ordinary point .",
    "similarly , p - recursive sequences are encoded by a recurrence relation plus initial values , as in ex .",
    "[ ex : motzkin ] above .",
    "if @xmath27 , we let @xmath28 and @xmath29 .",
    "the _ height _ of an object is the maximum bit - size of the integers appearing in its representation : the height of a rational number @xmath30 is @xmath31 , and that of a complex number ( we assume that elements of number fields @xmath32 are represented as @xmath33 with @xmath34 ) , polynomial , matrix , or combination thereof with rational coefficients is the maximum height of its coefficients .",
    "we assume that the bit complexity @xmath35 of @xmath3-bit integer multiplication satisfies @xmath36 , @xmath37 , and @xmath38 , and that @xmath39 matrices can be multiplied in @xmath40 operations in their coefficient ring .",
    "`` unrolling '' a recurrence relation of the form  ( [ eq : rec ] ) to compute @xmath41 takes @xmath42 bit operations , which is almost linear in the total size of @xmath41 , but quadratic in that of  @xmath43 .",
    "the binary splitting algorithm computes a single term  @xmath43 in essentially linear time , as follows :  ( [ eq : rec ] ) is first reduced to a matrix recurrence of the first order with a single common denominator : @xmath44^{s \\times    s } , q ( n ) \\in \\mathbbm{z}[n],\\ ] ] so that @xmath45 , where @xmath46 .",
    "one then computes @xmath47 recursively as @xmath48 , and the denominator @xmath49 in a similar fashion ( but separately , in order to avoid expensive gcd computations ) .",
    "the idea of using product trees to make the most of fast multiplication dates back at least to the seventies  @xcite .",
    "the general statement below is from  ( * ? ? ?",
    "* theorem  2.2 ) , except that the authors seem to have overlooked the cost of evaluating the polynomials at the leaves of the tree .",
    "[ thm : binsplit ] let @xmath50 be a p - recursive sequence over @xmath51 , defined by  .",
    "assume that the coefficients @xmath52 of   have no poles in  @xmath53 .",
    "let @xmath54 denote bounds on their degrees ( of numerators and denominators ) and heights , and @xmath55 corresponding bounds for the coefficients of @xmath56 and @xmath57 in  .",
    "assuming @xmath58 , the binary splitting algorithm outlined above computes one term  @xmath43 of @xmath50 in @xmath59 , that is , @xmath60 , bit operations .",
    "write @xmath61 .",
    "computing the product tree @xmath47 takes @xmath62 bit operations  @xcite ( see also prop .  [",
    "prop : cste ] below ) , and the evaluation of each leaf @xmath63 may be done in @xmath64 operations  @xcite .",
    "this gives @xmath43 as a fraction that is simplified in @xmath65 operations  @xcite .",
    "now consider how   is rewritten into  . with coefficients in",
    "@xmath66 $ ] rather than @xmath51 , the  @xmath52 have height @xmath67 . to get @xmath68 and",
    "@xmath69 , it remains to reduce to common denominator the whole equation ; hence @xmath70 and @xmath71 .",
    "these two conversion steps take @xmath72 and @xmath73 operations respectively , using product trees .",
    "the assumption @xmath74 allows to write @xmath75 and get rid of some terms , so that the total complexity simplifies as stated .",
    "since the height of @xmath43 may be as large as @xmath76 , this result is optimal with respect to @xmath77 and @xmath78 , up to logarithmic factors .",
    "the same algorithm works over any algebraic number field instead of @xmath51 .",
    "this is useful for evaluating functions `` at singularities '' (  [ sec : regsing ] ) .",
    "more generally , similar complexity results hold for product tree computations in torsion - free @xmath79-algebras ( or @xmath80-algebras : we then write @xmath81 for some @xmath79-algebra @xmath82 and multiply in @xmath83 ) , keeping in mind that , without basis choice , the height of an element is defined only up to some additive constant .",
    "[ [ constant - factor - improvements ] ] constant - factor improvements + + + + + + + + + + + + + + + + + + + + + + + + + + + +    several techniques permit to improve the constant hidden in the @xmath84 of theorem  [ thm : binsplit ] , by making the computation at each node of the product tree less expensive .",
    "we consider two models of computation .    in the _ fft model _ , we assume that the complexity of long multiplication decomposes as @xmath85 , where @xmath86 is the cost of a discrete fourier transform of size  @xmath3 ( or of another related linear transform , depending on the algorithm ) .",
    "fft - based integer multiplication algorithms adapt to reduce the multiplication of two matrices of height  @xmath3 in @xmath87 to @xmath88 multiplications of matrices of height  @xmath89 , for a total of @xmath90 bit operations .",
    "this is known as `` fft addition ''",
    "@xcite , `` computing in the fft mode ''  @xcite , or `` fft invariance '' . a second improvement ( `` fft doubling '' , attributed to r.  kramer in  @xcite ) is specific to the computation of product trees .",
    "the observation is that , at an internal node where operands of size @xmath3 get multiplied using three ffts of size  @xmath91 , every second coefficient of the two direct dfts is already known from the level below .",
    "the second model is _ black - box multiplication_. there , we may use fast multiplication formulae that trade large integer multiplications for additions and multiplications by constants .",
    "the most obvious example is that the products in @xmath51 may be done in four integer multiplications using karatsuba s formula instead of five with the nave algorithm . in general , elements of height @xmath77 of an algebraic number field of degree @xmath92 may be multiplied in @xmath93 bit operations using the toom - cook algorithm .",
    "the same idea applies to the matrix multiplications .",
    "most classical matrix multiplication formulae such as strassen s are so - called bilinear algorithms .",
    "since we are working over a commutative ring , we may use more general _ quadratic _ algorithms  @xcite .",
    "in particular , for all  @xmath94 , waksman s algorithm  @xcite multiplies @xmath95 matrices over a commutative ring  @xmath96 using @xmath97 multiplications in  @xmath96 , and makarov s  @xcite multiplies @xmath98 matrices in @xmath99 scalar multiplications .",
    "these formulas alone or as the base case of a strassen scheme achieve what seems to be the best known multiplication count for matrices of size up to @xmath100 .    exploiting these ideas leads to the following refinement of theorem  [ thm : binsplit ] .",
    "similar results can be stated for general @xmath79-algebras , using their rank and multiplicative complexity  @xcite .",
    "[ prop : cste ] let @xmath101 and @xmath102 denote bounds on the degrees and heights ( respectively ) of @xmath68 and @xmath69 in eq .",
    "( [ eq : bsrec ] ) . as @xmath103 ( @xmath94 and @xmath101 being fixed ) ,",
    "the number of bit operations needed to compute the product tree @xmath47 is at most @xmath104 , with @xmath105 in the fft model , and @xmath106 in the black - box model . here",
    "@xmath107 is the algebraic complexity of @xmath108 matrix multiplication over @xmath79 .",
    "each node at the level @xmath109 ( level  0 being the root ) of the tree essentially requires multiplying @xmath95 matrices with entries in @xmath66 $ ] of height @xmath110 , plus denominators of the same height . in the fft model , this may be done in @xmath111 operations . since we assume @xmath112 , we have @xmath113 ( a remark attributed to d.  stehl in  @xcite ) .",
    "kramer s trick saves another factor @xmath114 . in the black - box model ,",
    "the corresponding cost for one node is @xmath115 with karatsuba s formula .",
    "stehl s argument applies again .",
    "note that the previous techniques save time only for dense objects .",
    "in particular , one should not use the `` fast '' matrix multiplication formulae in the few bottom levels of product trees associated to recurrences of the form  ( [ eq : bsrec ] ) , since the matrices at the leaves are companion .",
    "continuing on this remark , these matrices often have some structure that is preserved by successive multiplications .",
    "for instance , let @xmath116 where @xmath117 satisfies  ( [ eq : rec ] ) .",
    "it is easy to compute a recurrence and initial conditions for @xmath118 and go on as above .",
    "however , unrolling the recurrences ( [ eq : rec ] ) and s@xmath119 simultaneously as @xmath120 is more efficient .",
    "indeed , all matrices in the product tree for the numerator of  ( [ eq : recseries ] ) then have a rightmost column of zeros , except for the value in the lower right corner , which is precisely the denominator . with the notation @xmath121 of proposition  [ prop : cste ] , each product of these special matrices uses @xmath122 multiplications , _ vs. _",
    "@xmath123 for the dense variant .",
    "hence the formula  ( [ eq : recseries ] ) is more efficient as soon as @xmath124 , which is true both for the nave multiplication algorithm and for waksman s algorithm ( compare  @xcite ) . in practice , on ex .",
    "[ ex : gamma ] below , if one puts @xmath125 in ( [ eq : rec ] , [ eq : bsrec ] ) instead of using  ( [ eq : recseries ] ) , the computation time grows from 1.7  s to 2.7  s.    the same idea applies to any recurrence operator that can be factored .",
    "further examples of structure in product trees include even and odd series ( _ e.g. _ , @xcite ) . in all these cases ,",
    "the nave matrix multiplication algorithm automatically benefits from the special shape of the problem ( because multiplications by constants have negligible cost ) , while fast methods must take it into account explicitly .",
    "a weakness of binary splitting is its comparatively large space complexity @xmath126 .",
    "techniques to reduce it are known and used by efficient implementations in the case of recurrences of the first order  @xcite .",
    "[ [ implementation ] ] implementation + + + + + + + + + + + + + +    the implementation of binary splitting in numgfun includes some of the tricks discussed in this section .",
    "fft - based techniques are currently not used because they are not suited to implementation in the maple language .",
    "this implementation is exposed through two user - level functions , ` nth_term ` and ` fnth_term ` , that allow to evaluate p - recursive sequences ( ` fnth_term ` replaces the final gcd by a less expensive division and returns a floating - point result ) . additionally ,",
    "` gfun[rectoproc ] ` , which takes as input a recurrence and outputs a procedure that evaluates its solution , automatically calls the binary splitting code when relevant .",
    "examples  [ ex : motzkin ] and  [ ex : gamma ] illustrate the use of these functions on integer sequences and convergent series respectively .",
    "[ ex : gamma]@xcite repeated integration by parts of the integral representation of @xmath127 yields for @xmath128 @xmath129 taking @xmath130 , it follows that the sum @xmath131 , where @xmath132 and @xmath133 , is within @xmath134 of @xmath135 , whence @xmath136 .",
    "this computation takes  1.7  s.",
    "we now recall the numerical evaluation algorithms used in numgfun , and discuss their implementation .",
    "let @xmath137 be a series with radius of convergence  @xmath138 at the origin .",
    "let @xmath139 be such that @xmath140 and @xmath141 .",
    "the sequence @xmath142 is p - recursive , so that the binary splitting algorithm yields a fast method for the high - precision evaluation of @xmath143 .",
    "here `` high - precision '' means that we let the precision required for the result go to infinity in the complexity analysis of the algorithm .",
    "more precisely , @xmath142 is canceled by a recurrence relation of height @xmath144 . by theorem  [ thm : binsplit ] ,",
    "@xmath143 may hence be computed to the precision @xmath145 in @xmath146 bit operations , where @xmath78 is chosen so that @xmath147 , _",
    "i.e. _ @xmath148 if @xmath149 , and @xmath150 for some @xmath151 if @xmath152 .",
    "in practice , the numbers of digits of ( absolute ) precision targeted in numgfun range from the hundreds to the millions . accuracies of this order of magnitude are useful in some applications to number theory  @xcite , and in heuristic equality tests  @xcite .",
    "it can also happen that the easiest way to obtain a moderate - precision output involves high - precision intermediate computations , especially when the correctness of the result relies on pessimistic bounds .",
    "[ [ analytic - continuation ] ] analytic continuation + + + + + + + + + + + + + + + + + + + + +    solutions of the differential equation  ( [ eq : deq ] ) defined in the neighborhood of @xmath153 extend by analytic continuation to the universal covering of @xmath154 , where @xmath155 is the ( finite ) set of singularities of the equation .",
    "functions may be evaluated fast at any point by a numerical version of the analytic continuation process that builds on the previous algorithm  @xcite .",
    "rewrite  ( [ eq : deq ] ) in matrix form @xmath156 this choice of @xmath157 induces , for all @xmath158 , that of a family of _ canonical solutions _ of  ( [ eq : deq ] ) defined by @xmath159 ( z ) = ( z - z_0)^j + o \\bigl((z - z_0)^r\\bigr ) , \\hspace{2em } 0     \\leq j < r,\\ ] ] that form a basis of the solutions of  ( [ eq : deq ] ) in the neighborhood of @xmath160 .",
    "stated otherwise , the vector @xmath161 = ( y [ z_0 , j])_{0 \\leq j < r}$ ] of canonical solutions at @xmath160 is the first row of the fundamental matrix @xmath162 ( z)$ ] of ( [ eq : matrixdeq ] ) such that @xmath162 ( z_0 ) = \\operatorname{id}$ ] .    by linearity , for any path @xmath163 in @xmath164 , there exists a _ transition matrix _ @xmath165 that `` transports initial conditions '' ( and canonical solutions ) along the path : @xmath166    ( z ) = \\boldsymbol{y}[z_1 ] ( z ) m_{z_0 \\rightarrow z_1 } .\\ ] ] this matrix is easy to write out explicitly : @xmath167 ( z_1 ) = \\bigl ( \\frac{1}{i ! }",
    "y    [ z_0 , j]^{(i ) } ( z_1 ) \\bigr)_{0 \\leq i , j < r},\\ ] ] evaluations at @xmath168 being understood to refer to the analytic continuation path @xmath163 .",
    "transition matrices compose : @xmath169    numgfun provides functions to compute @xmath170 for a given path @xmath171 ( ` transition_matrix ` ) , and to evaluate the analytic continuation of a function along a path starting at  @xmath153 ( ` evaldiffeq ` ) . in both cases ,",
    "the path provided by the user is first subdivided into a new path @xmath172 , @xmath173 , such that , for all @xmath174 , the point @xmath175 lies within the disk of convergence of the taylor expansions at @xmath176 of all solutions of  ( [ eq : deq ] ) . using  ( [ eq : transition ] ) , approximations @xmath177 of @xmath178 are computed by binary splitting .    more precisely , we compute all entries of  @xmath179 at once , as follows . for a generic solution  @xmath180 of  , the coefficients @xmath181 of @xmath182",
    "are canceled by a recurrence of order  @xmath94 .",
    "hence the partial sums @xmath183 of  @xmath50 satisfy @xmath184 where @xmath185 and @xmath186 . introducing an indeterminate  @xmath187 ,",
    "we let @xmath188 $ ] and compute @xmath189 by binary splitting ( an idea already used in  @xcite ) , for some suitable  @xmath78 .",
    "the upper left blocks of the subproducts are _ kept factored _ as a power of  @xmath190 times a matrix independent on  @xmath190 . in other words , clearing denominators ,",
    "the computation of each subproduct @xmath191 is performed as @xmath192 ; @xmath193 ; @xmath194 ; @xmath195 .",
    "the powers of  @xmath190 can be computed faster , but the saving is negligible . applying the row submatrix @xmath96 of the full product to the matrix @xmath196^{(i)}(z_\\ell))_{0 \\leqslant i < s , 0 \\leqslant j < r}$ ] yields a row vector equal to @xmath197 _ { ; n } ( z_{\\ell+1 } + \\delta))_{0 \\leqslant j < r } + o ( \\delta^r)$ ] , each entry of which is a truncated power series whose coefficients are the entries of the corresponding column of @xmath198 .",
    "this way of computing @xmath179 is roughly @xmath199 times more efficient than the fastest of the variants from  @xcite .    in the function ` transition_matrix ` , we then form the product @xmath200 , again by binary splitting . in the case of ` evaldiffeq ` , we compute only the first row @xmath201 of @xmath202 , and we form the product @xmath203 , where @xmath204 is an approximation with coefficients in @xmath51 of the vector @xmath205 of initial conditions ( or this vector itself , if it has symbolic entries ) .",
    "the whole computation is done on unsimplified fractions , controlling all errors to guarantee the final result .",
    "let us stress that no numerical instability occurs since all numerical operations are performed on rational numbers .",
    "we postpone the discussion of approximation errors ( including the choice of  @xmath78 ) to   [ sec : errorcontrol ] .",
    "transition matrices corresponding to paths that `` go round '' exactly one singularity once are known as local monodromy matrices .",
    "a simple example is that of the equation @xmath206 , whose solution space is generated by @xmath207 and @xmath208 . rather unsurprisingly , around  @xmath209 :    .... > transition_matrix((1+z^2)*diff(y(z),z ,",
    "y(z),z )    + 2*z*diff(y(z),z ) , y(z ) , [ 0,i+1,2*i , i-1,0 ] , 20 ) ; ....",
    "@xmath210 more generally , expressing them as entries of monodromy matrices is a way to compute many mathematical constants .",
    "another use of analytic continuation appears in ex .",
    "[ ex : heun ] : there , despite the evaluation point lying within the disk of convergence , numgfun performs analytic continuation along the path @xmath211 to approach the singularity more easily ( _ cf .",
    "3.3 ) ) .",
    "[ [ the - bit - burst - algorithm ] ] the `` bit burst '' algorithm + + + + + + + + + + + + + + + + + + + + + + + + + + +    the complexity result  ( [ eq : stepcomplexity ] ) is quasi - optimal for @xmath212 , but becomes quadratic in  @xmath213 for @xmath214 , which is the size of the approximation @xmath215 needed to compute @xmath143 for arbitrary @xmath216 .",
    "this issue can be avoided using analytic continuation to approach  @xmath190 along a path @xmath217 made of approximations of  @xmath190 whose precision grow geometrically : @xmath218 thus balancing @xmath77 and @xmath219 .",
    "this idea is due to chudnovsky and chudnovsky  @xcite , who called it the bit burst algorithm , and independently to van der hoeven with a tighter complexity analysis  @xcite .",
    "the following proposition improves this analysis by a factor @xmath220 in the case where @xmath180 has a finite radius of convergence .",
    "no similar improvement seems to apply to entire functions .",
    "let @xmath180 be a function .",
    "one may compute a @xmath221-approximation of @xmath180 at a point @xmath222 of height @xmath223 in @xmath224 bit operations .    by  ( [ eq : stepcomplexity ] ) and  ( [ eq : bitburst ] )",
    ", the step @xmath225 of the bit - burst algorithm takes @xmath226 bit operations .",
    "now @xmath227 and @xmath228 , hence the total complexity .",
    "[ ex : randeq]consider the function @xmath180 defined by the following equation , picked at random : @xmath229 the singular points are @xmath230 and @xmath231 . by analytic continuation ( along a path @xmath232 homotopic to a segment ) followed by bit - burst evaluation , we obtain @xmath233 after about 5  min .",
    "this example is among the `` most general '' that numgfun can handle .",
    "intermediate computations involve recurrences of order  @xmath234 and degree  @xmath235 .",
    "the algorithms of the previous section extend to the case where the analytic continuation path passes through _ regular singular points _ of the differential equation  @xcite .",
    "work is in progress to support this in numgfun , with two main applications in view , namely special functions ( such as bessel functions ) defined using their local behaviour at a regular singular point , and `` connection coefficients '' arising in analytic combinatorics  @xcite .",
    "we limit ourselves to a sketchy ( albeit technical ) discussion .",
    "recall that a finite singular point @xmath160 of a linear differential equation with analytic coefficients is called _ regular _ when all solutions @xmath143 have moderate growth @xmath236 as @xmath237 in a sector with vertex at @xmath160 , or equivalently when the equation satisfies a formal property called fuchs criterion .",
    "the solutions in the neighborhood of @xmath160 then have a simple structure : for some @xmath238 , there exist linearly independent formal solutions of the form ( with @xmath239 ) @xmath240\\ ] ] in number equal to the order @xmath241 of the differential equation",
    ". additionally , the @xmath242 converge on the open disk centered at  0 extending to the nearest singular point , so that the solutions   in fact form a basis of analytic solutions on any open sector with vertex at the origin contained in this disk .",
    "( see for instance  @xcite for proofs and references . )",
    "several extensions of the method of indeterminate coefficients used to obtain power series solutions at ordinary points allow to determine the coefficients of the series @xmath242 .",
    "we proceed to revisit poole s variant  @xcite of heffter s method  ( * ? ? ?",
    "8) using the `` operator algebra point of view '' on indeterminate coefficients : a recursive formula for the coefficients of the series expansion of a solution is obtained by applying simple rewriting rules to the equation .",
    "this formulation makes the algorithm simpler for our purposes ( compare @xcite ) and leads to a small complexity improvement .",
    "it also proves helpful in error control (  6 ) .",
    "since our interest lies in the case , we assume that  @xmath153 is a regular singular point of equation  ( [ eq : deq ] ) .",
    "letting @xmath243 , the equation rewrites as @xmath244 where @xmath245 is a polynomial in two noncommutative indeterminates ( and @xmath246 has no nontrivial left divisor in @xmath247 $ ] ) .",
    "based on  ( [ eq : fuchs ] ) , we seek solutions as _ formal logarithmic sums _ @xmath248 let us call the double sequence @xmath249 the _ coefficient sequence _ of @xmath180 .",
    "the _ shift operators _ @xmath250 and @xmath251 on such double sequences are defined by @xmath252 , and @xmath253 .",
    "the heart of the method lies in the following observation .",
    "[ prop : poole]let @xmath143 be a formal logarithmic sum . the relation @xmath254 holds ( formally ) iff the coefficient sequence @xmath255 of @xmath180 satisfies @xmath256 .",
    "the operators @xmath190 and @xmath257 act on logarithmic sums by @xmath258 and @xmath259 .",
    "thus the coefficient sequence of @xmath260 is @xmath261 .",
    "assume that @xmath143 satisfies  ( [ eq : deq ] )",
    ". then @xmath262 ; additionally , ( [ eq : fuchs ] ) implies that @xmath263 for @xmath264 , which translates into @xmath265 .",
    "set @xmath266 , and fix @xmath267 . if @xmath268 , then @xmath269 is invertible in @xmath270 $ ] , and @xmath271 in general , let @xmath272 be the multiplicity of @xmath3 as a root of  @xmath273 .",
    "take @xmath274 $ ] such that @xmath275 ( explicitly , @xmath276 ) .",
    "then , it holds that @xmath277 hence the @xmath278 with @xmath279 determine @xmath280 , while the @xmath281 , @xmath282 remain free .",
    "coupled with the condition @xmath283 for @xmath284 following from  ( [ eq : fuchs ] ) , this implies that a solution @xmath180 is characterized by @xmath285 , where @xmath286 . as in ",
    "[ sec : evaldiffeq ] , this choice of initial values induces that of canonical solutions ( at @xmath153 ) @xmath287 $ ] defined by @xmath287_{n , k } = 1 $ ] and @xmath287_{n ' , k ' } = 0 $ ] for @xmath288 .",
    "the notion of transition matrix extends , see  @xcite for a detailed discussion .",
    "equation  ( [ eq : regsingrec2 ] ) is a `` recurrence relation '' that lends itself to binary splitting .",
    "the main difference with the setting of   [ sec : binsplit ] is that the companion matrix of the `` recurrence operator '' now contains truncated power series , _",
    "i.e. _ , @xmath289 / ( s_k^t)$ ] .",
    "the coefficients @xmath290_n = \\sum_{k = 0}^{t - 1 } y [ u , v]_{n , k } \\log^k z$ ] of canonical solutions may be computed fast by forming the product @xmath291 / ( s_k^t)$ ] and applying it to the initial values @xmath292 . compared to the algorithm of  @xcite , multiplications of power",
    "series truncated to the order @xmath293 replace multiplications of @xmath294 submatrices , so that our method is slightly faster . as in   [ sec : evaldiffeq ] , all entries of @xmath295 may ( and should ) be computed at once .",
    "performing numerical analytic continuation rigorously requires a number of bounds that control the behaviour of the function under consideration .",
    "we now describe how error control is done in numgfun .",
    "some of the ideas used in this section appear scattered in  @xcite@xcite .",
    "numgfun relies almost exclusively on _ a priori _ bounds ; see  @xcite for pointers to alternative approaches , and  @xcite for further useful techniques , including how to refine rough _ a priori _ bounds into better _ a posteriori _ bounds .",
    "we start by discussing the computation of _ majorant series _ for the canonical solutions of the differential equation .",
    "then we describe how these are used to determine , on the one hand , at which precision each transition matrix should be computed for the final result to be correct , and on the other hand , where to truncate the series expansions to achieve this precision .",
    "finally , we propose a way to limit the cost of computing bounds in `` bit burst '' phases .    in practice , numerical errors that happen while computing the error bounds themselves are not always controlled , due to limited support for interval arithmetic in maple .",
    "however , we have taken some care to ensure that crucial steps rely on rigorous methods .    [",
    "[ majorant - series ] ] majorant series + + + + + + + + + + + + + + +    a formal power series @xmath296 $ ] is a _ majorant series _ of @xmath17 $ ] , which we denote by @xmath297 , if @xmath298 for all @xmath3 .",
    "if @xmath299 and @xmath300 , then @xmath301 we shall allow majorant series to be formal logarithmic sums or matrices .",
    "the relation @xmath302 extends in a natural way : we write @xmath303 iff @xmath304 for all @xmath3 and @xmath109 , and @xmath305 iff @xmath306 and @xmath307 have the same format and @xmath308 for all @xmath309 .",
    "in particular , for scalar matrices , @xmath310 if @xmath311 for all @xmath309 .",
    "the inequalities  ( [ eq : majseriesprop ] ) still hold .",
    "[ [ bounds - on - canonical - solutions ] ] bounds on canonical solutions + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the core of the error control is a function that computes @xmath312 such that @xmath313(z_0+z ) \\trianglelefteq g ( z)\\ ] ] ( in the notations of   [ sec : evaldiffeq ] ) given equation  ( [ eq : deq ] ) and a point @xmath160 . this function is called at each step of analytic continuation .",
    "the algorithm is based on that of  @xcite ( `` sb '' in what follows ) , designed to compute `` asymptotically tight '' _ symbolic _ bounds .",
    "run over @xmath51 instead of @xmath80 , sb returns ( in the case of convergent series ) a power series satisfying  ( [ eq : majcansol ] ) of the form @xmath314 , where @xmath315 , @xmath316 , and @xmath317 .",
    "the series  @xmath318 is specified by @xmath151 , @xmath319 , and other parameters of no interest here that define  @xmath320 .",
    "the tightness property means that @xmath151 and @xmath319 are the best possible .",
    "however , the setting of numerical evaluation differs from that of symbolic bounds in several respects : ( i )  the issue is no more to obtain human - readable formulae , but bounds that are easy to evaluate ; ( ii )  bound computations should be fast ; ( iii )  at regular singular points , the fundamental solutions are logarithmic sums , not power series . for space reasons ,",
    "we only sketch the differences between sb and the variant we use for error control .",
    "first , we take advantage of  ( i ) to solve  ( ii ) .",
    "the most important change is that the parameter  @xmath319 is replaced by an approximation @xmath321 .",
    "this avoids computations with algebraic numbers , the bottleneck of sb . strictly speaking",
    ", it also means that we are giving up the tightness of the bound .",
    "however , in constrast with the `` plain '' majorant series method  @xcite , we are free to take @xmath322 arbitrarily close to @xmath319 , since we do not use the ratio @xmath323 to mask subexponential factors .",
    "the algorithms from  @xcite adapt without difficulty .",
    "specifically , algorithms  3 and 4 are modified to work with  @xmath324 instead of  @xmath319 .",
    "equality tests between `` dominant roots '' ( line  9 of algorithm  3 , line  5 of algorithm  4 ) can now be done numerically and are hence much less expensive . as a consequence , the parameter  @xmath325 from   3.3",
    "is also replaced by an upper bound .",
    "this affects only the parameter @xmath326 of the bound , which is already pessimistic .",
    "the issue  ( iii ) can be dealt with too .",
    "one may compute a series @xmath318 such that @xmath327 ( with the notations of   [ sec : regsing ] ) by modifying the choice of  @xmath22 in  @xcite so that @xmath328 , and replacing  ( * ? ? ?",
    "* eq .  ( 14 ) ) by eq .",
    "( [ eq : regsingrec2 ] ) above in the reasoning .",
    "[ [ global - error - control ] ] global error control + + + + + + + + + + + + + + + + + + + +    we now consider the issue of controlling how the approximations at each step of analytic continuation accumulate .",
    "starting with a user - specified error bound @xmath329 , we first set @xmath330 so that an @xmath330-approximation @xmath331 of the exact result @xmath241 rounds to @xmath332 $ ] with @xmath333 .",
    "no other _ rounding _ error occur , since the rest of the computation is done on objects with coefficients in @xmath51 .",
    "however , we have to choose the precision at which to compute each factor of the product @xmath334 ( in ` evaldiffeq ` , and of similar products for other analytic continuation functions ) so that @xmath335 .",
    "as is usual for this kind of applications , we use the frobenius norm , defined for any ( not necessarily square ) matrix by @xmath336 .",
    "the frobenius norm satisfies @xmath337 for any matrices @xmath338 of compatible dimensions . if @xmath339 is a square @xmath340 matrix , @xmath341 where @xmath342 is the matrix norm induced by the euclidean norm while @xmath343 denotes the _ entrywise _ uniform norm .",
    "most importantly , the computation of @xmath344 is numerically stable , and if @xmath339 has entries in @xmath51 , it is easy to compute a good upper bound on @xmath345 in floating - point arithmetic .",
    "we bound the total error @xmath346 on @xmath347 using repeatedly the rule @xmath348 .",
    "from there , we compute precisions @xmath349 such that having @xmath350 for each factor @xmath339 of @xmath347 ensures that @xmath351 .",
    "upper bounds on the norms @xmath352 and @xmath353 appearing in the error estimate are computed either from an approximate value of @xmath339 ( usually @xmath354 itself ) if one is available at the time , or from a matrix  @xmath307 such that @xmath355 given by  ( [ eq : majseriesprop ] , [ eq : majcansol ] ) .",
    "[ [ local - error - control ] ] local error control + + + + + + + + + + + + + + + + + + +    let us turn to the computation of individual transition matrices .",
    "we restrict to the case of ordinary points . given a precision @xmath329 determined by the `` global error control '' step ,",
    "our task is to choose  @xmath78 such that @xmath356 if @xmath357 is computed by truncating the entries of  ( [ eq : transition ] ) to the order  @xmath78 . if @xmath318 satisfies  ( [ eq : majcansol ] ) , it suffices that @xmath358 for all  @xmath209 , as can be seen from  ( [ eq : majseriesprop ] , [ eq : propfrobenius ] ) .",
    "we find a suitable  @xmath78 by dichotomic search .",
    "for the family of majorant series  @xmath318 used in numgfun , the @xmath359 are not always easy to evaluate , so we bound them by expressions involving only elementary functions  @xcite .",
    "the basic idea , related to the saddle - point method from asymptotic analysis , is that if @xmath360 , inequalities like @xmath361 are asymptotically tight for suitably chosen @xmath362 .    [ [ points - of - large - bit - size ] ] points of large bit - size + + + + + + + + + + + + + + + + + + + + + + + +    computing the majorants  ( [ eq : majcansol ] ) is expensive when the point @xmath160 has large height .",
    "this can be fixed by working with an approximate value @xmath363 of @xmath160 to obtain a bound valid in a neighborhood of @xmath363 that contains  @xmath160 .",
    "this technique is useful mainly in `` bit burst '' phases ( where , additionally , we can reuse the same @xmath363 at each step ) .",
    "assume that @xmath364 ( c + z ) \\trianglelefteq g ( z)$ ] for some @xmath365 .",
    "since @xmath162 ( z_0 + z ) = \\boldsymbol{y}[c ] ( c + ( z_0 - c ) + z ) m_{c \\rightarrow z_0}^{- 1}$ ] by  ( [ eq : ancont ] ) , it follows that @xmath162 ( z_0 + z ) \\trianglelefteq g ( |z_0 - c| + z)\\,\\mathopen\\|m_{c \\rightarrow z_0}^{- 1 } \\mathclose{\\| } \\boldsymbol{1}$ ] where  @xmath366 is a square matrix filled with ones .",
    "now @xmath367 , whence @xmath368 .",
    "for @xmath369 , this implies @xmath370 .",
    "choosing @xmath371 small enough that @xmath372 , we get @xmath373 . if @xmath307 was computed from  ( [ eq : majcansol ] ) , _ i.e. _ , for @xmath374 , this finally gives the bound @xmath159 ( z_0+z ) \\trianglelefteq \\frac{r}{j !",
    "\\ , ( 1 - \\delta ) } g^{(j ) } ( \\eta + z),\\ ] ] valid for all @xmath160 in the disk @xmath369 .",
    "note however that simple differential equations have solutions like @xmath375 ) with large @xmath22 .",
    "the condition @xmath372 then forces us to take @xmath363 of size @xmath376 .",
    "our strategy to deal with this issue in numgfun is to estimate @xmath22 using a point  @xmath363 of size @xmath377 and then to choose a more precise @xmath363 ( as a last resort , @xmath378 ) based on this value if necessary .",
    "if the evaluation point @xmath190 is given as a program , a similar reasoning allows to choose automatically an approximation @xmath215 of @xmath190 such that @xmath379 is below a given error bound  @xcite .",
    "in other applications , it is useful to have bounds on transition matrices that hold uniformly for _ all _ small enough steps in a given domain .",
    "such bounds may be computed from a majorant differential equation with constant coefficients  @xcite .",
    "drawing plots or computing integrals numerically requires to evaluate the same function at many points , often to a few digits of precision only .",
    "numgfun provides limited support for this through the function ` diffeqtoproc ` , which takes as input a function @xmath180 , a target precision @xmath329 , and a list of disks , and returns a maple procedure that performs the numerical evaluation of @xmath180 . for each disk @xmath380 , ` diffeqtoproc ` computes a polynomial @xmath381 $ ] such that @xmath382 for @xmath383 , where @xmath384 again denotes rounding to complex decimal .",
    "the procedure returned by ` diffeqtoproc ` uses the precomputed @xmath213 when possible , and falls back on calling ` evaldiffeq ` otherwise .",
    "the approximation polynomial @xmath213 is constructed as a linear combination of truncated taylor series of fundamental solutions @xmath385 $ ] , with coefficients obtained by numerical analytic continuation from @xmath153 to @xmath363 .",
    "the way we choose expansion orders is similar to the error control techniques of   [ sec : errorcontrol ] : we first compute a bound @xmath386 on the fundamental solutions and their first derivatives on the disk  @xmath387 .",
    "the vector @xmath388 of `` initial values '' at @xmath363 is computed to the precision @xmath389 where @xmath390 .",
    "we also compute @xmath391 .",
    "each @xmath392 $ ] is expanded to an order @xmath78 such that @xmath393_{n ; } \\mathclose\\|_{\\infty , d } \\leq \\epsilon ' / b_{\\operatorname{ini}}$ ] , so that finally @xmath394 for @xmath395 .",
    "the most important feature of ` diffeqtoproc ` is that it produces certified results . at low precisions and in the absence of singularities , we expect that interval - based numerical solvers will perform better while still providing ( _ a posteriori _ ) guarantees . also note that our simple choice of  @xmath213 is far from optimal .",
    "if approximations of smaller degree or height are required , a natural approach is to aim for a slightly smaller error @xmath396 above , and then replace  @xmath213 by a polynomial  @xmath397 for which we can bound @xmath398  @xcite .    the following plot of the function  @xmath180 defined by @xmath399 with the initial values @xmath400 , @xmath401 , @xmath402 was obtained using polynomial approximations on several disks that cover the domain of the plot while avoiding the pole @xmath403 .",
    "the whole computation takes about 9  s. simple numerical integrators typically fail to evaluate  @xmath180 beyond  @xmath403 .",
    "not all of numgfun was described in this article .",
    "the symbolic bounds mentioned in   [ sec : errorcontrol ] are also implemented , with functions that compute majorant series or other kinds of bounds on rational functions ( ` bound_ratpoly ` ) , functions ( ` bound_diffeq ` and ` bound_diffeq_tail ` ) and p - recursive sequences ( ` bound_rec ` and ` bound_rec_tail ` ) .",
    "this implementation was already presented in  @xcite .",
    "current work focuses on adding support for evaluation `` at regular singular points '' ( as outlined in  [ sec : regsing ] ) , and improving performance .",
    "the development version of numgfun already contains a second implementation of binary splitting , written in  c and called from the maple code . in the longer term ,",
    "i  plan to rewrite other parts of the package `` from the bottom up '' , both for efficiency reasons and to make useful subroutines independant of maple .",
    "i am grateful to my advisor , b.  salvy , for encouraging me to conduct this work and offering many useful comments .",
    "thanks also to a.  benoit , f.  chyzak , p.  giorgi , j.  van der hoeven and a.  vaugon for stimulating conversations , bug reports , and/or comments on drafts of this article , and to the anonymous referees for helping make this paper more readable ."
  ],
  "abstract_text": [
    "<S> this article describes the implementation in the software package numgfun of classical algorithms that operate on solutions of linear differential equations or recurrence relations with polynomial coefficients , including what seems to be the first general implementation of the fast high - precision numerical evaluation algorithms of chudnovsky  & chudnovsky . in some cases , </S>",
    "<S> our descriptions contain improvements over existing algorithms . </S>",
    "<S> we also provide references to relevant ideas not currently used in numgfun .    </S>",
    "<S> * categories and subject descriptors : * i.1.2 [ * symbolic and algebraic manipulation * ] : algorithms    * general terms : * algorithms , experimentation , theory    * keywords : * functions , linear differential equations , certified numerical computation , bounds , maple </S>"
  ]
}