{
  "article_text": [
    "online analytical processing(olap )  @xcite comprises a set of tools and algorithms that allow efficiently querying multidimensional ( md ) databases containing large amounts of data , usually called data warehouses ( dw ) .",
    "conceptually , in the md model , data can be seen as a _ cube _",
    ", where each cell contains one or more _ measures _ of interest , that quantify _",
    "facts_. measure values can be aggregated along _ dimensions _ , which give context to facts .",
    "at the logical level , olap data are typically organized as a set of _ dimension and fact tables . _",
    "current database technology allows alphanumerical warehouse data to be integrated for example , with geographical or social network data , for decision making . in the era of so - called `` big data '' , the kinds of data that could be handled by data management tools , are likely to increase in the near future .",
    "moreover , olap and business intelligence ( bi ) tools allow to capture , integrate , manage , and query , different kinds of information .",
    "for example , alphanumerical data coming from a local dw , spatial data ( e.g. , temperature ) represented as rasterized images , and/or economical data published on the semantic web . ideally , a bi user would just like to deal with what she knows well , namely the data cube , using only the classical olap operators , like _ roll - up _",
    ", _ drill - down _ , _ slice _ , and _ dice _ ( among other ones ) , regardless the cube s underlying data type .",
    "data types should only be handled at the logical and physical levels , not at the conceptual level .",
    "building on this idea , ciferri et al .",
    "@xcite proposed a _",
    "conceptual _ , _ user - oriented _ model , independent of olap technologies . in this model ,",
    "the user only manipulates a data cube .",
    "associated with the model , there is a query language providing high - level operations over the cube .",
    "this language , called cube algebra , was sketched informally in the mentioned work .",
    "extensive examples on the use of cube algebra presented in  @xcite , suggest that this idea can lead to a language much more intuitive and simple than mdx , the _ de facto _ standard for olap .",
    "nevertheless , these works do not give any evidence of the correctness of the languages and operations proposed , other than examples at various degrees of comprehensiveness .",
    "in fact , surprisingly , and in spite of the large corpus of work in the field , a formally - defined reference language for olap is still needed  @xcite .",
    "there is not even a well - defined , accepted semantics , for many of the usual olap operations .",
    "we believe that , far for being just a problem of classical olap , this formalization is also needed in current `` big data '' scenarios , where there is a need to efficiently perform real - time olap operations  @xcite , that , of course , must be well defined .",
    "[ [ contributions ] ] contributions + + + + + + + + + + + + +    in this paper we ( a ) introduce a collection of operators that manipulate a data cube , and clearly define their semantics ; and ( b ) prove , formally , that our operators can be composed , yielding a language powerful enough to express complex queries and cube navigation ( `` _ _  la _ _ olap '' ) paths .    we achieve the above representing the data cube as a fixed @xmath0-dimensional matrix , and a set of @xmath1 measures , and expressing each olap operation as a sequence of atomic transformations .",
    "each transformation produces a new measure , and , additionally , when a sequence forms an olap operation , a flag that indicates which are the cells that must be considered as input for the next operation .",
    "this formalism allows us to elegantly define an algebra as a collection of operations , and give a series of properties that show their correctness .",
    "we provide the proofs in the full paper .",
    "we limit ourselves to the most usual operations , namely slice , dice , roll - up and drill - down , which constitute the core of all practical olap tools .",
    "we denote these the _ classical olap operations_. this allows us to focus on our main interest , which is , to prove the feasibility of the approach .",
    "other not - so - usual operations are left for future work .",
    "the main contribution of our work , with respect to other similar efforts in the field is that , for the first time , a formal proof to practical problems is given , so the present work will serve as a basis to build more solid tools for data analysis . existing work either lacks of formalism , or of applicability , and no work of any of these kinds give sound mathematical prove of its claims . in this extended abstract",
    "we present the main properties , and leave the proofs for the full paper .",
    "the remainder of the paper is organized as follows . in section  [ sec : data - model ] , we present our md data model , on which we base the rest of our work .",
    "section  [ sec : olap - tando ] presents the atomic transformations that we use to build the olap operations . in section  [ sec : classicalolap ] we discuss the classical olap operations in terms of the transformations , show how they can be composed to address complex queries .",
    "we conclude in section  [ sec : conclusion ] .",
    "in this section we describe the olap data model we use in the sequel .",
    "we next give the definitions of multidimensional matrix schema and instance . in the sequel ,",
    "@xmath0 , with @xmath2 , is a natural number representing the number of dimensions of a data cube .",
    "[ def : matrix - schema ] a _",
    "@xmath0-dimensional matrix schema _ is a sequence @xmath3 of @xmath0 dimension names .    as illustrated in the following example",
    ", the convention will be that dimension names start with a capital letter .    [",
    "ex : matrix - schema ] the running example we use in this paper , deals with sales information of certain products , at certain locations , at certain moments in time . for this purpose",
    ", we will define a @xmath4-dimensional matrix schema @xmath5 .",
    "[ def : matrix - instance ] a _ @xmath0-dimensional matrix instance _",
    "( _ matrix _",
    ", for short ) over the @xmath0-dimensional matrix schema @xmath6 is the product @xmath7 @xmath8 , where @xmath9 is a non - empty , finite , ordered set , called the _ domain _ , that is associated with the dimension name @xmath10 . for all @xmath8 ,",
    "we denote by @xmath11 , the order that we assume on the elements of @xmath9 . for @xmath12",
    ", we call the tuple @xmath13 , a _ cell _ of the matrix .    the cells of a matrix serve as placeholders for the measures that are contained in the data cube ( see definition  [ def : data - cube - instance ] below ) .",
    "note that , as it is common practice in olap , we assumed an order @xmath11 on the domain .",
    "the role of the order is further discussed in section  [ subsec : order ] .    as a notational convention , elements of the domains @xmath9",
    "start with a lower case letter , as it is shown in the following example .",
    "[ ex : matrix - instance ] for the @xmath4-dimensional matrix schema @xmath14 of example  [ ex : matrix - schema ] , the non - empty sets @xmath15 , @xmath16 , and @xmath17 produce the matrix instance @xmath18 the cells of the matrix will contain the sales for each combination of values in the domain . in @xmath19 , we have , for instance , the order @xmath20 over the dimension @xmath21 , we have the usual temporal order .",
    "we now define the notions of dimension schema and instance .",
    "[ def : dimension - schema ] let @xmath22 be a name for a dimension .",
    "a _ dimension schema @xmath23 for @xmath22 _ is a lattice , with a unique top - node , called @xmath24 ( which has only incoming edges ) and a unique bottom - node , called @xmath25 ( which has only outgoing edges ) , such that all maximal - length paths in the graph go from @xmath25 to @xmath24 .",
    "any path from @xmath25 to @xmath24 in a dimension schema @xmath23 is called a _ hierarchy _ of @xmath23 .",
    "each node in a hierarchy ( i.e. , in a dimension schema ) is called a _ level _ ( of @xmath23 ) .    as a convention ,",
    "level names start with a capital letter .",
    "note that the @xmath25 node is often renamed , depending on the application .",
    "[ ex : dimension - schema ] fig .",
    "[ fig : dimension - schema ] gives examples of dimension schemas @xmath26 and @xmath27 for the dimensions @xmath28 and @xmath21 in example  [ ex : matrix - schema ] .",
    "for the dimension @xmath28 , we have @xmath29 , and there is only one hierarchy , denoted @xmath30 the node @xmath31 is an example of a level in this hierarchy . for the dimension @xmath21 , we have @xmath32 , and two hierarchies , namely @xmath33 and @xmath34 .    , in ( @xmath35 ) , and @xmath21 , in ( @xmath36 ) . ]",
    "[ def : instancegraph ] let @xmath22 be a dimension with schema @xmath23 , and let @xmath37 be a level of @xmath23 .",
    "a _ level instance of @xmath37 _ is a non - empty , finite set @xmath38 .",
    "if @xmath39 , then @xmath40 is the singleton @xmath41 .",
    "if @xmath42 , then @xmath43 is the the domain of the dimension @xmath22 , that is , @xmath44 ( as in definition  [ def : matrix - instance ] ) .    a _ dimension graph ( or instance ) _ @xmath45 the dimension schema @xmath23 is a directed acyclic graph with node set @xmath46 where the union is taken over all levels in @xmath23 .",
    "the edge set of this directed acyclic graph is defined as follows .",
    "let @xmath37 and @xmath47 be two levels of @xmath23 , and let @xmath48 and @xmath49 .",
    "then , only if there is a directed edge from @xmath37 to @xmath47 in @xmath23 , there can be a directed edge in @xmath45 from @xmath35 to @xmath50 .    if @xmath51 is a hierarchy in @xmath23 , then the _ hierarchy instance _",
    "( relative to the dimension instance @xmath45 ) is the subgraph of @xmath45 with nodes from @xmath38 , for @xmath37 appearing in @xmath51 .",
    "this subgraph is denoted @xmath52 .    as notational convention",
    ", the names of objects in a set @xmath38 start with a lower case character .",
    "we remark that a hierarchy instance @xmath52 is always a ( directed ) tree .",
    "also , if @xmath35 and @xmath36 are two nodes in a hierarchy instance @xmath52 , such that @xmath53 is in the transitive closure of the edge relation of @xmath52 , we will say that @xmath35 _ rolls - up _ to @xmath36 and we denote this by @xmath54 ( or @xmath55 if @xmath51 is clear from the context ) .",
    "[ ex : instancegraph ] consider the @xmath28 dimension , whose schema @xmath26 is given in fig .",
    "[ fig : dimension - schema ] ( @xmath35 ) . from example",
    "[ ex : matrix - instance ] , we have @xmath56 @xmath57 @xmath58 @xmath59 , which is @xmath60 , or @xmath61 .",
    "an example of a dimension instance @xmath62 is depicted in fig .",
    "[ fig : dimension - instance ] .",
    "this example expresses , for instance , that the city @xmath63 is located in the region @xmath64 which is part of the country @xmath65 , meaning that @xmath63 rolls - up to @xmath64 and to @xmath65 , that is , @xmath66 and @xmath67 .    .",
    "]    in a dimension graph , we must guarantee that rolling - up through different paths gives the same results .",
    "this is formalized by the concept of `` sound '' dimension graph .",
    "[ def : sound - graph ] let @xmath45 be a dimension graph ( as in definition  [ def : instancegraph ] ) .",
    "we call this dimension graph _ sound _ , if for any level @xmath37 in @xmath23 and any two hierarchies @xmath68 and @xmath69 that reach @xmath37 from the @xmath25 level and any @xmath70 and @xmath71 , we have that @xmath72 and @xmath73 imply that @xmath74 .    in this paper , we assume that dimension graphs are always sound .      essentially , a data cube is a matrix in which the cells are filled with measures that are taken from some _ value domain _ @xmath75 . for many applications",
    ", @xmath75 will be the set of real or rational numbers , although some other ones may include , e.g. , spatial regions or geometric objects .",
    "[ def : data - cube - schema ] a _ @xmath0-dimensional data cube schema _ consists of ( a ) a @xmath0-dimensional matrix schema @xmath6 ; and ( b ) a hierarchy schema @xmath76 for each dimension @xmath10 , with @xmath77 .",
    "[ def : data - cube - instance ] let @xmath75 be a non - empty set of `` values '' . a _",
    "@xmath0-dimensional , @xmath1-ary data cube instance _ ( or _ data cube _ , for short ) @xmath78 over the @xmath0-dimensional matrix schema @xmath6 and hierarchy schemas @xmath76 for @xmath10 , for @xmath77 , with values from @xmath75 , consists of ( a ) a @xmath0-dimensional matrix instance over the matrix schema @xmath6 , @xmath79 ; ( b ) for each @xmath77 , a _ sound _",
    "dimension graph @xmath80 over @xmath76 ; ( c ) @xmath1 _ measures _ @xmath81 , which are functions from @xmath82 to the value domain @xmath75 ; and ( d ) a _ flag _ @xmath83 , which is a function from @xmath84 to the set @xmath85 .    also ,",
    "as a notational convention , we use calligraphic characters , like @xmath78 , to represent data cube instances .",
    "the flag @xmath83 can be considered as a @xmath86-st boolean measure .",
    "the role of @xmath83 is to indicate which of the matrix cells are currently `` active '' .",
    "the active cells have a flag value @xmath87 and the others have a flag value @xmath88 .",
    "when we operate over a data cube , flags are used to indicate the input or output parts of the matrix of the cube .",
    "typically , in the beginning of the operations , all cells have a flag value of @xmath87 .",
    "the role of flags will become more clear in the next sections , when we discuss olap transformations and operations .",
    "when performing olap transformations and operations , we may need to store aggregate information about certain measures up to some level above the @xmath25 one .",
    "we do not want to use extra space for this in the data cube .",
    "instead , we use the available cells of the original data cube to store this information . for this , we make use of the order assumed in definition  [ def : matrix - instance ] , for the representation of high - level objects by @xmath25-level objects .",
    "[ def : represents ] let @xmath89 be an arbitrary dimension with domain @xmath90 .",
    "let @xmath37 be a level of @xmath23 .",
    "an element @xmath91 is _ represented _ by the smallest element @xmath92 ( according to @xmath11 ) for which @xmath55 holds .",
    "we denote this as , and say that .",
    "[ ex : order ] continuing with the previous examples , we consider the dimension @xmath28 with @xmath93 ( i.e. , @xmath61 . on this set ,",
    "we _ assume _ the order @xmath94 .",
    "for this dimension , we have the hierarchy and the dimension instance , given in figs .  [",
    "fig : dimension - schema ] and  [ fig : dimension - instance ] , respectively . at the @xmath29 level ,",
    "cities represent themselves . at higher levels , regions and countries",
    "are represented by their `` first '' city in @xmath95 ( according to @xmath11 ) .",
    "thus , @xmath96 and @xmath65 are represented by @xmath97 , @xmath98 is represented by @xmath99 , and @xmath100 is represented by @xmath101 . at the level @xmath24",
    ", @xmath97 represents @xmath102    note that the @xmath25-level representatives of higher - level objects , will be flagged @xmath87 , and other cells flagged @xmath88 .",
    "also , in our example , if we aggregate information at level @xmath31 , with @xmath103 , then all cities in @xmath95 become flagged .",
    "thus , it would not be clear if the cube contains information at the level @xmath104 or at the level @xmath31 .",
    "the following property shows how the order on the @xmath25 level induces and order on higher levels .",
    "[ prop : order - higher - level ] let @xmath89 be a ( sound ) dimension of a data cube @xmath78 and let @xmath37 be a level in the dimension schema @xmath23 .",
    "the order @xmath11 on @xmath44 induces an order on @xmath38 as follows .",
    "if @xmath71 , then @xmath105 if and only if @xmath106 .",
    "a typical olap user manipulates a data cube by means of well - known operations .",
    "for instance , using our running example , the query `` total sales by region , for regions in belgium or france '' , is actually expressed as a sequence of operations , whose semantics should be clearly defined , and which can be applied in different order . for example , we can first apply a _ roll - up _",
    "( i.e. , an aggregation ) to the _ country _ level , and once at that level apply a _ dice _ operation , which keeps the cube cells corresponding to belgium or france .",
    "finally , a _ drill - down _ can be applied to disaggregate the sales down to the level _ region _ , returning the desired result . in what follows ,",
    "we characterize olap operations as the result of sequences of olap transformations , which are measure - creating updates to a data cube .      an _ atomic olap transformation _",
    "acts on a data cube instance , by adding a measure to the existing data cube measures .",
    "olap operations like the ones informally introduced above are defined , in our approach , as a sequence of transformations .",
    "the process of olap transformations starts from a given _ input data cube _ .",
    "we assume that this original data cube has @xmath1 given measures @xmath81 ( as in definition  [ def : data - cube - instance ] ) .",
    "these @xmath1 measures have a special status in the sense that they are `` protected '' and can never be altered ( see section  [ subsec : olap - operation ] ) .    typically , the input - flag @xmath83 of the original data cube @xmath107 is set to @xmath87 in every cell and signals that every cell of @xmath108 is part of the input cube .",
    "atomic olap transformations can be applied to data cubes .",
    "they add ( or create ) new measures to the sequence of existing measures by adding new measure values in each cell of the data cube s matrix . at any moment in this process",
    ", we may assume that the data cube @xmath78 has @xmath109 measures @xmath110 , where the first @xmath1 are the original measures of @xmath107 , and the last @xmath111 ( with @xmath112 ) ones have been created subsequently by @xmath111 olap transformations ( where @xmath113 is the empty sequence of @xmath114 s , for @xmath115 ) .",
    "the next olap transformation adds a new measure @xmath116 to the matrix cells .",
    "we have said that we use olap transformations to compute olap operations .",
    "we indicate that the computation of an olap operation @xmath117 is finished by creating an @xmath118-ary output flag @xmath119 .",
    "this output flag is a boolean measure , that is created via atomic olap transformations .",
    "it indicates which of the cells of @xmath79 should be considered as belonging to the output of @xmath117 .",
    "it is @xmath118-ary in the sense that it keeps the last @xmath118 created measures @xmath120 and `` trashes '' the rest .",
    "it also removes the previous flag , which it replaces .",
    "the initial measures @xmath81 of the input data cube @xmath107 are never removed ( unless they are `` destroyed '' in some cells ) .",
    "they remain in the cube throughout the process of applying one olap operation after another to @xmath107 , and can be used at any stage .",
    "summarizing , after an olap operation of output arity @xmath118 is completed on some cube @xmath78 , the measures in the cells of the output data cube @xmath121 are of the form @xmath122 here , the underlining indicates the protected status of these measures . after each olap operation ,",
    "the unprotected measures with the symbols @xmath123 and the output measures become @xmath124 the next olap operation @xmath125 can then act on @xmath126 and use in its computation all the measures above .",
    "we remark that the dimensions , the hierarchy schemas and instances of @xmath78 remain unaltered during the entire olap process .",
    "we end this description with a remark on _",
    "destructors_. a destructor , optionally , precedes the creation of an output flag .",
    "a destructor @xmath127 takes the value @xmath87 for some cells of the matrix of a data cube , and @xmath88 on other cells .",
    "when @xmath127 is invoked ( and activated by the output flag that follows it ) on a data cube @xmath78 with measures @xmath128 and flag @xmath129 , it empties all cells for which the value of the destructor @xmath127 is @xmath88 by removing all measures from them , even the protected ones , thereby effectively `` destroying '' these cells .",
    "this is the only case where the protected measures are altered ( see operations slice or dice , later ) .",
    "the output of a destructive operation @xmath117 looks like @xmath130 in which the destructor precedes the output flag .",
    "the effect of the presence of a destructor is the following .",
    "a cell such that @xmath131 is emptied , after which it contains no more measures and flag . for cells with @xmath132 , the sequence of measures @xmath133",
    "is transformed to @xmath134 which is renamed as @xmath135 before the next transformation takes place .",
    "this transformation will act , cell per cell , on the matrix of a cube , and it does nothing with emptied cells .",
    "that is , no new measure can ever be added to a destroyed cell .",
    "the following definition specifies how an olap transformation acts on a data cube .",
    "we then address in detail each atomic olap transformation appearing in this definition .",
    "[ def : olap - transformation ]    let @xmath78 be a @xmath0-dimensional , @xmath136-ary data cube instance with given ( or protected ) measures @xmath81 , created measures @xmath137 ( with @xmath112 ) and flag @xmath83 over some value domain @xmath75 .",
    "olap transformation _ @xmath138 , applied to @xmath78 , results in the creation of a new measure @xmath116 in @xmath78 .",
    "transformation @xmath138 adds measure @xmath116 ; @xmath116 is produced from : @xmath81 ; @xmath83 ; @xmath139 and the hierarchy schemas and instances of @xmath78 ; and belongs to one of the following classes : ( a ) arithmetic transformations ( definition  [ def : trans - arith ] ) ; ( b ) boolean transformations ( definition  [ def : trans - boolean ] ) ; ( c ) selectors ( definition  [ def : trans - selector ] ) ; ( d ) counting , sum , min - max ( definitions  [ def : trans - counting ] , [ def : trans - min - max - revisited ] ) ; ( e ) grouping ( definition  [ def : trans - grouping ] ) .",
    "an olap transformation can also result in the creation of a measure that is an output flag @xmath140 of arity @xmath118 .",
    "this should be a measure with a boolean value . to indicate that it is a flag of arity @xmath118",
    ", we use the reserved symbol @xmath140 instead of @xmath116 .",
    "an output flag @xmath140 may ( optionally ) be preceded by a destructor @xmath127 .",
    "this should be a measure with a boolean value ( to indicate which cells are destroyed ) .",
    "we use the reserved symbol @xmath127 instead of @xmath116 .",
    "before we give the definition of an olap operation , we describe the _ input _ to the olap process ( this process may involve multiple olap operations ) .",
    "such input is a @xmath0-dimensional , @xmath1-ary data cube instance @xmath107 , with measures @xmath81 and flag @xmath83 .",
    "these measures are _ protected _ in the sense that they remain the first @xmath1 measures throughout the entire olap process and are never altered or removed unless they are destroyed in some cells .",
    "the cube @xmath107 has also a boolean flag @xmath83 , which typically has value @xmath87 in all cells of @xmath108 .",
    "thus , the measures of the input cube @xmath107 are denoted @xmath141    after applying a sequence of olap operations to @xmath107 , we obtain a data cube @xmath142 .    let be a @xmath0-dimensional , @xmath136-ary _ input _ data cube instance with given measures @xmath81 , computed measures @xmath113 and flag @xmath83 .",
    "the data cube @xmath78 acts as the input of an _ olap operation _",
    "@xmath117 ( of arity @xmath118 ) , which consists of a sequence of @xmath143 consecutive olap transformations that create the additional measures @xmath144 , followed by the creation of an @xmath118-ary flag @xmath119 . as the result of the creation of @xmath119 ,",
    "the measures in the cells of the data cube are changed from @xmath145 to @xmath146 which become @xmath147 after renaming .",
    "the output cube @xmath121 has the same dimensions , hierarchy schemas and instances as @xmath142 , and measures @xmath148 @xmath149 in the case where @xmath119 is preceded by a destructor @xmath127 , the same procedure is followed , except for the cells of @xmath79 for which @xmath127 takes the value @xmath88 .",
    "these cells of @xmath79 are emptied , contain no measures , and become inaccessible for future transformations .",
    "we now address the five classes of atomic olap transformations of definition  [ def : olap - transformation ] .",
    "we use the following notational convention . for a measure @xmath150",
    ", we write @xmath151 to indicate the value of @xmath150 in the cell @xmath152 we remark that @xmath151 does not exist for empty cells and it is thus not considered in computations .",
    "also , we assume that there are _ protected _ measures @xmath81 , and _ computed _",
    "measures @xmath113 in the non - empty cells , and call @xmath116 the next computed measure .",
    "[ def : trans - arith ] the following creations of a new measure @xmath116 are _ arithmetic transformations _ :    1 .",
    "( * constant * ) @xmath153 , with @xmath154 , a rational number .",
    "( * sum * ) @xmath155 , with @xmath156 .",
    "( * product * ) @xmath157 , with @xmath156 .",
    "( * quotient * ) @xmath158 , with @xmath156 .",
    "[ def : trans - boolean ] the following creations of a new measure @xmath116 are _ boolean transformations _ :    1 .",
    "( * equality test on measures * ) @xmath159 , with @xmath160 . here , the result of @xmath161 is a boolean 1 or 0 ( ) .",
    "( * comparison test on measures * ) @xmath162 , with @xmath163 . here",
    ", the result of the comparison @xmath164 is a boolean 1 or 0 ( ) .",
    "( * equality test on levels * ) 4 .",
    "( * comparison test on levels * ) for a level @xmath37 in the dimension schema @xmath76 of dimension @xmath10 , and a constant @xmath165 , @xmath166 is a `` comparison '' test .",
    "the result of @xmath167 is a boolean 1 or 0 ( ) , such that @xmath168 is @xmath87 if and only if @xmath169 rolls - up to an object @xmath36 at level @xmath37 for which @xmath170 .",
    "the order @xmath171 can be any order that is defined on level @xmath37 .",
    "transformation @xmath172 is defined similarly .",
    "[ ex : trans - boolean-1 ] we illustrate the use of boolean transformations by means of a sequence of transformations that implement a `` dice '' ( see section  [ subsec : dice ] for more details ) .",
    "the query @xmath173 asks for the cells in the matrix of @xmath78 which contain sales that are higher than 50 .",
    "this query can be implemented by the following sequence of transformations :    * @xmath174 ( rational constant ) ; * @xmath175 ( comparison test on measures ) ; * @xmath176 ( product ) ; * @xmath177 ( destructor ) ; and * @xmath178 ( unary flag )    the measure @xmath179 contains the @xmath180 values larger than or equal to 50 ( and a 0 if the @xmath180 are lower ) .",
    "the destructor @xmath127 destroys the cells that contain a o. finally , the flag @xmath181 selects all cells from the input as output cells ( it will contain a 1 for all such cells that satisfy the condition ) , and concludes the @xmath173 operation .",
    "the output of this operation is @xmath182 which is then renamed to @xmath183      [ def : trans - selector ] the following creations of a new measure @xmath116 are _ selector transformations _ ( or _ selectors _ ) , and their definition is cell per cell of @xmath79 :    1 .",
    "( * constant selector * ) for a level @xmath37 in the dimension schema @xmath76 of a dimension @xmath10 , and @xmath165 , @xmath116 can be a _ constant - selector for @xmath184 _ , denoted @xmath185 , 2 .",
    "( * level selector * ) for a level @xmath37 in the dimension schema @xmath76 of a dimension @xmath10 , @xmath116 can be a _ level - selector for @xmath37 _ , denoted by @xmath186 , which means that we have , for all @xmath187 with @xmath188 , @xmath189    the _ constant _ selector in definition  [ def : trans - selector ] , corresponds to the equality test on levels ( see 3 . in definition  [ def : trans - boolean ] ) . here",
    ", this transformation appears with a different functionality and we reserve a special notation for it , and we repeated it .",
    "also , note that the _ level _ selector selects all representatives ( at the @xmath25 level ) of objects at level @xmath37 of dimension @xmath10 .",
    "[ ex : trans - selector-2 ] the query @xmath190 asks for the sales in the cities of @xmath97 and @xmath63",
    ". it can be implemented by the following sequence of transformations , where @xmath179 can take values @xmath88 or @xmath87 , since the cities @xmath97 and @xmath63 do not overlap :    * @xmath191 ( constant selector ) ; * @xmath192 ( constant selector ) ; * @xmath193 ( sum ) ; * @xmath194 ( product ) ; *   * @xmath195 ( unary flag creation ) .",
    "[ def : trans - counting ] the creations of a new measure @xmath116 defined next , are denoted    1 .",
    "( * count - distinct * ) @xmath196 , @xmath197 counts the number of distinct values of measure @xmath150 in the complete matrix @xmath79 of the data cube .",
    "( * @xmath0-dimensional sum * ) @xmath198 with @xmath199 @xmath200 , gives the sum of the measure @xmath150 over all matrix cells .",
    "we abbreviate this operation by writing @xmath201 and call this transformation the _",
    "@xmath0-dimensional sum_. 3 .",
    "( * min - max * ) @xmath202 , with @xmath197 , gives the smallest value of the measure @xmath150 the matrix @xmath79 .",
    "similarly , @xmath203 , gives the largest value of the measure @xmath150 in the matrix @xmath79 .",
    "it is important to remark that the above transformations create the _",
    "same new measure value _ for all cells of the matrix @xmath79 .",
    "[ ex : trans - counting-2 ] now , we look at the query @xmath204 the query can be computed as follows , given @xmath205 :    * @xmath191 ( constant selector on @xmath97 ) ; * @xmath206 ( product that selects the sales in @xmath97 , puts a 0 in all other ones ) ; * @xmath207 ( this is the total sales in @xmath97 in every cell ) ; * @xmath208 ( this is the total sales in @xmath97 in the cells of @xmath97 ) ; * @xmath209 ( this flag creation selects the cells of @xmath97 ) .",
    "the output measures are @xmath210 , which are renamed @xmath211 .",
    "thus , the value of the total of sales in @xmath97 is now available in every cell corresponding to @xmath97 . for the cells outside @xmath97",
    "there is a @xmath88 .",
    "the most common olap operations ( e.g. , roll - up , slice ) , require grouping data before aggregating them .",
    "for example , typically we will ask queries like `` total sales by city '' , which requires grouping facts by city , and , for each group , sum all of its sales .",
    "therefore , we need a transformation to express `` grouping '' .",
    "to deal with grouping , we use the concept of `` prime labels '' for sets and products of sets .",
    "we will use these labels to identify elements in dimensions and in dimension levels . before giving the definition of the grouping transformations , we elaborate on . as we show , these prime labels work in the context of measures that take rational values ( as it is often the case , in practice ) .",
    "the following definition specifies our infinite supply of prime labels .",
    "[ def : prime - labels ] let @xmath212 denote the @xmath143-th prime number , for @xmath213 .",
    "we define the sequence of _ prime labels _ as follows : @xmath214 we denote the set of all prime labels by @xmath215 .",
    "[ def : prime - labelling - of - sets ] let @xmath216 , @xmath217 be ( finite ) sets .",
    "a _ prime labeling _ of the set @xmath216 is an injective function @xmath218 . for @xmath219 , we call @xmath220 the _ prime label _ of @xmath35 ( for the prime labeling @xmath221 )",
    ".    let @xmath222 be a subset of @xmath223 , which serves as an index set .",
    "a of the cartesian product @xmath224 consists of prime labelings @xmath225 of the sets @xmath226 , for @xmath227 , that satisfy the condition that @xmath228 is empty for @xmath229 and @xmath230 . for @xmath231 , we call @xmath232 the _ prime product @xmath222-label _ of @xmath233 ( given the prime labelings @xmath225 , for @xmath227 )",
    ". when @xmath222 is a strict subset of @xmath223 , we speak about a and when @xmath234 , we speak about a .    if we view a cartesian product @xmath224 as a finite matrix , whose cells contain rational - valued measures , we can use prime ( product ) labelings as follows in the aggregation process .",
    "let us assume that the cells of @xmath224 contain rational values of a measure @xmath235 and let us denote the value of this measure in the cell @xmath233 by @xmath236 .",
    "if we have a full prime product labeling on @xmath224 , then we can consider the sum over this cartesian product of the product of the prime product labels with the value of @xmath235 : @xmath237    since each cell of @xmath224 has a unique prime product label , and since these labels are rationally independent ( see property  [ prop : prime - sum ] ) , this sum enables us to retrieve the values",
    "@xmath238    if we have a partial prime product labeling on @xmath224 , determined by an index set @xmath222 , then , again , we can consider the sum over this cartesian product of the product of the partial prime product labels with the value of @xmath235 : @xmath239    now , all cells in @xmath224 above a cell in the projection of @xmath224 , receive the same prime label .",
    "this means that these cells are `` grouped '' together and the above sum allows us to retrieve the part of the sum that belongs to each group .",
    "the following definition gives a name to the above sums .",
    "[ def : prime - sums ]    the following property can be derived from the well - known fact that the field extension @xmath240 has degree @xmath241 over @xmath242 and corollaries of this property ( see chapter 8 in  @xcite ) .",
    "no square root of a prime number is a rational combination of square roots of other primes .",
    "[ prop : prime - sum ] let @xmath213 and let @xmath224 be a cartesian product of finite sets .",
    "we assume that the cells @xmath233 of this set contain rational values @xmath236 of a measure @xmath235 .",
    "let @xmath222 be a subset of @xmath223 and let @xmath225 be prime labelings of the sets @xmath226 , for @xmath227 , that form a prime product @xmath222-labeling .",
    "then , the prime sum @xmath243 uniquely determines the values @xmath244 for all cells of @xmath245 .",
    "we remark that we use these prime ( product ) labels in a purely _ symbolic _ way without actually calculating the square root values in them .",
    "we are now ready to define atomic olap operations that allow us to implement grouping . in what follows",
    ", we apply these prime labels to the case where the sets @xmath226 in @xmath246 are domains of dimensions ( e.g. , at the bottom level ) , or domains of dimensions at some level .",
    "[ def : trans - grouping ] the following creations of a new measure @xmath116 are _ grouping transformations _ :",
    "( * * ) let @xmath10 be a dimension and @xmath37 a level in the dimension schema @xmath76 of a dimension @xmath10 .",
    "let @xmath247 with induced order @xmath248 ( see property  [ prop : order - higher - level ] ) .",
    "if the prime labels @xmath249 have been used by previous transformations , then for , we have @xmath250 if @xmath251 .",
    "we denote this transformation by @xmath252 or @xmath253 , for short , and call the result of such a transformation a _ prime labeling_. 2 .",
    "( * projection of a prime sum * ) if the result of some previous transformation @xmath254 is a @xmath255 ( over the complete matrix @xmath79 ) in which prime ( product ) labels @xmath256 ( computed in a previous transformation @xmath257 ) are used , then @xmath116 is a new measure that `` projects '' on the appropriate component from the prime sum , that is , @xmath258 if the prime ( product ) label @xmath259 .",
    "we denote this .",
    "[ ex : trans - grouping-3 ] consider the query @xmath260 @xmath261 this query can be implemented as follows ( explained below , using the data in example  [ ex : instancegraph ] ) :    * @xmath262 ( this gives each country a prime label ) ; * @xmath263 ( this gives each city a prime label ) ; * @xmath264 ( this gives each city a product of prime labels ) ; * @xmath265 ; * @xmath266 ( gives each product a different prime label ) ; * @xmath267 ( counts the number of products ) ; * @xmath268 ( gives each time moment a different prime label ) ; * @xmath269 ( counts the number of moments in time ) ; * @xmath270 ( is the number of products times the number of time moments ) ; * @xmath271 ( normalization of the sum ) ; * @xmath272 ; ( projection over the prime labels of city ) ; * @xmath273 ( 3-dimensional sum ) ; * @xmath274 ( normalization of the sum ) ; * @xmath275 ( projection over the prime labels of country ) ; * @xmath276 ( this flag creation selects all cells of the matrix ) .",
    "transformation @xmath277 gives each country a next available prime label .",
    "since no labels have been used yet , @xmath65 gets label @xmath87 and @xmath98 gets label @xmath278 .",
    "transformation @xmath279 gives each city a next available prime label .",
    "since @xmath87 and @xmath278 have been used , @xmath97 gets label @xmath280 , @xmath63 gets label @xmath281 , @xmath99 gets label @xmath282 , and @xmath101 gets label @xmath283 .",
    "transformation @xmath284 gives @xmath97 the value @xmath280 ( i.e. , @xmath285 , @xmath63 the value @xmath281(@xmath286 ) , @xmath99 the value @xmath287 ( @xmath288 ) , and @xmath101 the value @xmath289 ( @xmath290 ) .",
    "if there are 10 products and 100 time moments , then @xmath291 puts the value @xmath292 in each cell of the matrix @xmath79 .",
    "transformations @xmath293 and @xmath294 count the number of products and the number of time moments ( using fresh prime labels ) , and the product of these quantities is computed in @xmath295 . in @xmath296 , @xmath179 is divided by this product , putting @xmath297 in every cell .",
    "transformation @xmath298 is a projection on the prime labels of @xmath104 .",
    "since @xmath280 , @xmath281 , @xmath282 , and @xmath283 are the prime labels for the cities , and since @xmath299 , this will put @xmath87 in the cells of @xmath97 and @xmath63 , and @xmath278 in the cells of @xmath99 and @xmath101 .",
    "next , @xmath300 puts @xmath301 in every cell of the cube and @xmath302 puts @xmath303 in every cell of the cube . finally , @xmath304 projects on the prime labels of countries , which are 1 and @xmath278 .",
    "this puts a 2 in every cell of a belgian city and a 2 in every cell in a french city .",
    "this is the result of the query , as the flag indicates , that is returned in every cell .",
    "now every cell of a city in @xmath65 has the count of @xmath305 cities , as has every city in @xmath98 .",
    "we can now extend the transformations of definition  [ def : trans - counting ] , in a way that the counting , minimum , and maximum , are taken over cells which share a common prime product label .",
    "[ def : trans - min - max - revisited ]    the following creations of a new measure @xmath116 are :    1 .",
    "( * count - distinct * ) 2 .",
    "( * min - max * )    we remark that when there is only one prime label throughout @xmath79 , the above generalization of the counting and min - max transformations correspond to definition  [ def : trans - counting ] .",
    "in this section , we prove that the classical olap operations can be expressed using the olap transformations from section  [ sec : olap - tando ] .",
    "these classic operations can be combined to express complex analytical queries .",
    "the classical olap operations are dice , slice , slice - and - dice , roll - up and drill - down ( see section  [ subsec : rollup ] ) .",
    "we assume in the sequel , that the input data cube has @xmath1 given measures @xmath81 , and that at some point in the olap process this cube is transformed to a cube , having measures @xmath306 where @xmath307 , with @xmath112 , are created measures and @xmath83 is an input / output flag .",
    "before we start , we need to define the notion of a boolean cell - selection condition , and give a lemma about its expressiveness we will use throughout section  [ sec : classicalolap ] .    [ def : cell - selection ] let @xmath308 be the matrix of @xmath78 .",
    "a _ boolean condition on the cells of @xmath79 _ is a function @xmath309 from @xmath79 to @xmath85 .",
    "we say that a boolean condition @xmath309 is _ transformation - expressible _ if there is a sequence of olap transformations @xmath310 such that @xmath311 for all @xmath312 .",
    "[ lemma : boolean - closure ] if @xmath313 are transformation - expressible boolean conditions on cells , then @xmath314 , @xmath315 , and @xmath316 are transformation - expressible boolean conditions on cells .      intuitively , the _ dice _ operation selects the cells in a cube @xmath78 that satisfy a boolean condition @xmath309 on the cells .",
    "the syntax for this operation is @xmath317 where @xmath309 is a boolean condition over level values and measures .",
    "the resulting cube has the same dimensionality as the original cube .",
    "this operation is analogous to a selection in the relational algebra . in a data cube",
    ", it selects the cells that satisfy the condition @xmath309 by flagging them with a @xmath87 in the output cube .",
    "our approach covers all typical cases in real - world olap  @xcite .",
    "we next formalize the operator s definition in terms of our transformation language . in the remainder",
    ", we use the term _ olap operation _ to express a sequence of olap transformations .",
    "[ def : dice ] given a data cube @xmath318 , the operation @xmath317 selects all cells of the matrix @xmath79 that satisfy the boolean condition @xmath309 by giving them a @xmath87 flag in the output .",
    "the condition @xmath309 is a boolean combination of conditions of the form : ( a ) a selector on a value @xmath36 at a certain level @xmath37 of some dimension @xmath10 ; ( b ) a comparison condition at some level @xmath37 from a dimension schema @xmath76 of a dimension @xmath10 of the cube of the form @xmath319 or @xmath320 , where @xmath184 is a constant ( at that level @xmath37 ) ; ( c ) an equality or comparison condition on some measure @xmath150 of the form @xmath321 , @xmath322 or @xmath323 , where @xmath184 is a ( rational ) constant .    [ prop : dice ] let @xmath78 be a data cube en let @xmath309 be a boolean condition on the cells of @xmath79 ( as in definition  [ def : dice ] ) .",
    "the @xmath324 is expressible .",
    "intuitively , the _ slice _",
    "operation takes as input a @xmath0-dimensional , @xmath1-ary data cube @xmath78 and a dimension @xmath10 and returns as output @xmath325 , which is a `` @xmath326-dimensional '' data cube in which the original measures @xmath327 are replaced by their aggregation ( sum ) over different values of elements in @xmath9 . in other words ,",
    "dimension @xmath10 is removed from the data cube , and will not be visible in the next operations .",
    "that means , for instance , that we will not be able to dice on the levels of the removed dimension .",
    "as we will see , the `` removal '' of dimensions is , in our approach , implemented by means of the destroyer measure @xmath127 .",
    "we remark that the aggregation above is due to the fact that , in order to eliminate a dimension @xmath10 , this dimension should have exactly one element  @xcite , therefore a roll - up ( which we explain later in section  [ subsec : rollup ] ) to the level _ all _ in @xmath10 is performed .",
    "[ def : slice ]    given a data cube @xmath318 , and one of its dimensions @xmath10 , the operation @xmath325 `` replaces '' the measures @xmath328 by their aggregation ( sum ) @xmath329 ( for @xmath330 ) as : @xmath331 for all @xmath332 .",
    "we abbreviate the above @xmath87-dimensional sum as @xmath333    [ prop : slice ] let @xmath318 be a data cube and let @xmath10 be one of its dimensions .",
    "the @xmath325 is expressible as an olap operation .",
    "[ ex : slice ] consider dimensions @xmath334 @xmath335 and @xmath336 , and measure @xmath337 in our running example .",
    "the operation @xmath338 returns a cube with @xmath339-cells containing the sums of @xmath340 for each product - time combination , over all location .",
    "all cells not belonging to the representative of @xmath341 in the dimension @xmath28 ( i.e. , @xmath97 ) , are destroyed .",
    "the query is expressed by the following transformations .",
    "* @xmath342 ( prime labels on products ) ; * @xmath343 ( fresh prime labels on time moments ) ; * @xmath344 ( product of the two previous prime labels ) ; * @xmath345 ( product ) ; * @xmath346 ( @xmath4-dimensional sum ) ; * @xmath347 ( projection on prime product labels ) ; * @xmath348 ( selects the representative of @xmath341 in the dimension @xmath28 ) ; *   * @xmath349 ( this flag creation selects the relevant cells of the matrix ) .",
    "transformation @xmath350 gives each @xmath339-combination a unique prime product label .",
    "this label is multiplied by the @xmath180 in each cell .",
    "then , @xmath351 is the global sum over @xmath79 ; @xmath347 is the projection over the prime product labels for @xmath339-combinations .",
    "this gives each cell above some fixed @xmath339-combination , the sum of the @xmath180 , over all locations , for that combination .",
    "all cells of @xmath79 that do not belong to @xmath97 ( selected in @xmath352 ) , which represents @xmath341 , are destroyed by @xmath127 .",
    "a particular case of the _ slice _ operation occurs when the dimension to be removed already contains a unique value at the bottom level .",
    "then , we can avoid the roll - up to _ all _ , and define a new operation , called _ slice - and - dice_. although this can be seen as a _ dice _ operation followed by a @xmath353 one , in practice , both operations are usually applied together .",
    "[ def : slice - dice ]    [ prop : slice - dice ] let @xmath78 be a data cube , @xmath10 on of its dimensions en let @xmath354 .",
    "the operation @xmath355 is expressible as an olap operation .",
    "[ ex : slice - dice ] in our running example , the operation @xmath356 is implemented by the output flag @xmath357 .      intuitively , _",
    "roll - up _ aggregates measure values along a dimension up to a certain level , whereas _ drill - down _ disagregates measure values down to a dimension level . although at first sight it may appear that _ drill - down _ is the inverse of _ roll - up _",
    "@xcite , this is not always the case , e.g. , if a _",
    "roll - up _ is followed by a @xmath353 or a @xmath358 ; here , we can not just undo the _ roll - up _ , but we need to account for the cells that have been eliminated on the way .",
    "more precisely , the _ roll - up _ operation takes as input a data cube @xmath78 , a dimension @xmath10 and a subpath @xmath359 of a hierarchy @xmath51 over @xmath10 , starting in a node @xmath47 and ending in a node @xmath360 , and returns the aggregation of the original cube along @xmath10 up to level @xmath37 for some of the input measures @xmath361 . _",
    "roll - up _ uses one of the classic sql aggregation functions , applied to the indicated protected and computed measures @xmath361 ( selected from @xmath362 ) , namely sum ( @xmath363 ) , average ( @xmath364 ) , minimum /maximum ( @xmath365 and @xmath366 ) , count and count - distinct ( @xmath367 and @xmath368 ) .",
    "usually , measures have an associated _ default _ aggregation function .",
    "the typical aggregation function for the measure @xmath180 , e.g. , is @xmath363 .",
    "we denote the above operation as @xmath369 where @xmath370 is one of the above aggregation functions that is associated to @xmath371 , for @xmath372 .",
    "since we are mainly interested in the expressiveness of this operation as a sequence of atomic transformations , only the destination node @xmath37 in the path @xmath359 is relevant . indeed",
    ", the result of this roll - up remains the same if the subpath @xmath359 is extended to start from the @xmath25 node of dimension @xmath10 .",
    "so , we can simplify the notation , replacing @xmath373 with @xmath374 and assume that the roll - up starts at the @xmath25 level .",
    "the _ drill - down _ operation takes as input a data cube @xmath78 , a dimension @xmath10 and a subpath @xmath359 of a hierarchy @xmath51 over @xmath10 , starting in a node @xmath37 and ending in a node @xmath375 ( at a lower level in the hierarchy ) , and returns the aggregation of the original cube along @xmath10 from the bottom level up to level @xmath47 .",
    "the drill - down uses the same type of aggregation functions as the roll - up . again",
    ", since we are only interested in the expressiveness of this operation , the drill - down operation @xmath376 has the same output as @xmath377    [ def : rollup ] given a data cube @xmath318 , one of its dimensions @xmath10 , and a hierarchy @xmath51 over @xmath10 , ending in a node @xmath360 , the operation @xmath378 computes the aggregation of the measures @xmath371 by their aggregation functions @xmath370 , for @xmath372 , as follows : @xmath379 for all @xmath332 , for which @xmath380 , for some @xmath381 .",
    "this roll - up flags all representative @xmath25-level objects as active .",
    "[ prop : rollup ] let @xmath318 be a data cube , let @xmath10 be one of its dimensions , and let @xmath51 be a hierarchy over @xmath10 ending in a node @xmath37 .",
    "let @xmath382 be a set of selected measures ( taken from the protected measures @xmath383 and the computed measures @xmath384 of @xmath318 ) , with their associated aggregation functions .",
    "the operation @xmath385 is expressible as an olap operation .",
    "[ ex : rollup-1 ] we next express the _ roll - up _ operation , using prime ( product ) labels , sums , projections , and the @xmath4-dimensional sum .",
    "we look at the query `` total sales per country '' .",
    "we use the simplified syntax , only indicating the target level of the roll - up on the _ location _ dimension ( i.e. , _ country _ ) .",
    "the query @xmath386 is the result of the following transformations , given the measure @xmath205 :    1 .",
    "@xmath387 ( prime labels on products ) ; 2 .   @xmath388 ( prime labels on time moments ) ; 3 .",
    "@xmath389 ( prime labels on countries ) ; 4 .",
    "@xmath390 ; ( prime product label  in one step ) ; 5 .",
    "@xmath391 ( product of labels with @xmath180 ) ; 6 .",
    "@xmath392 ( @xmath4-dimensional sum ) ; 7 .   @xmath393 ( projection on prime product labels )",
    "@xmath394 ( output flag on country - representatives ) .",
    "transformation @xmath395 gives every product - date - country combination a unique prime product label .",
    "normally this product takes more steps . above",
    ", we have abbreviated it to one transformation .",
    "the transformation @xmath396 gives the aggregation result , and @xmath397 is the flag that says that only the cities @xmath97 and @xmath99 , which represent the level @xmath398 , are active in the output ( and nothing else of the original cube ) .",
    "the main result of this paper is the proof of the completeness of an olap algebra , composed of the olap operations dice ( section  [ subsec : dice ] , slice ( section  [ subsec : slice ] ) , slice - and - dice ( section  [ subsec : sandd ] ) , roll - up , and drill - down ( section  [ subsec : rollup ] ) .",
    "this is summarized by theorem [ theo : main ] .",
    "[ theo : main ] the classical olap operations and their composition are expressible by olap operations ( that is , as sequences of atomic olap transformations ) .",
    "we next illustrate the power and generality of our approach , combining a sequence of olap operations , and expressing them as a sequence of olap transformations .",
    "[ ex : rollup-3 ]    an olap user is analyzing sales in different countries and regions .",
    "she wants to compare sales in the north of belgium ( the flanders region ) , and in the south of france ( which we , generically , have denoted _ south _ in our running example ) .",
    "she first filters the cube , keeping just the cells of those two regions .",
    "this is done with the expression : @xmath399 we showed that this can be implemented as a sequence of atomic olap transformations .",
    "now she has a cube with the cells that have not been destroyed .",
    "next , within the same navigation process , she obtains the total sales in france and belgium , only considering the desired regions , by means of : @xmath400 this will only consider the valid cells for rolling up .",
    "after this , our user only wants to keep the sales in france .",
    "thus , she writes : @xmath401 finally , she wants to go back to the details , one level below in the hierarchy , so she writes : @xmath402 implemented as a roll - up from the bottom level to _ region _ , only considering the cells that have not been destroyed .",
    "we have presented a formal , mathematical approach , to solve a practical problem , which is , to provide a formal semantics to a collection of the olap operations most frequently used in real - world practice .",
    "although olap is a very popular field in data analytics , this is the first time a formalization like this is given .",
    "the need for this formalization is clear : in a world being flooded by data of different kinds , users must be provided with tools allowing them to have an abstract `` cube view '' and cube manipulation capabilities , regardless of the underlying data types . without a solid basis and unambiguous definition of cube operations ,",
    "the former could not be achieved .",
    "we claim that our work is the first one of this kind , and will serve as a basis to build more robust practical tools to address the forthcoming challenges in this field .",
    "we have addressed the four core olap operations : slice , dice , roll - up , and drill - down .",
    "this does not harm the value of the work . on the contrary , this approach allows us to focus on our main interest , that is , to study the formal basis of the problem .",
    "our line of work can be extended to address other kinds of olap queries , like queries involving more complex aggregate functions like moving averages , rankings , and the like .",
    "further , cube combination operations , like drill - across , must be included in the picture .",
    "we believe that our contribution provides a solid basis upon which , a complete olap theory can be built .",
    "* acknowledgements : * alejandro vaisman was supported by a travel grant from hasselt university ( korte verblijven  inkomende mobiliteit , bof15kv13 ) .",
    "he was also partially supported by pict-2014 project 0787 .",
    "r.  agrawal , a.  gupta , and s.  sarawagi .",
    "modeling multidimensional databases . in _ proceedings of the 15th international conference on data engineering , ( icde ) _ , pages 232243 ,",
    "birmingham , uk , 1997 .",
    "ieee computer society .",
    "f.  dehne , q.  kong , a.  rau - chaplin , h.  zaboli , and r.  zhou .",
    "scalable real - time olap on cloud architectures .",
    ", 7980:31  41 , 2015 .",
    "special issue on scalable systems for big data management and analytics .        o.  romero and a.  abell . on the need of a reference algebra for olap . in _ proceedings of the 9th international conference on data warehousing and knowledge discovery , dawak07 _ , pages 99110 , regensburg , germany , 2007 ."
  ],
  "abstract_text": [
    "<S> online analytical processing ( olap ) comprises tools and algorithms that allow querying multidimensional databases . </S>",
    "<S> it is based on the multidimensional model , where data can be seen as a cube , where each cell contains one or more measures can be aggregated along dimensions . despite the extensive corpus of work in the field , a standard language for olap </S>",
    "<S> is still needed , since there is no well - defined , accepted semantics , for many of the usual olap operations . in this paper , we address this problem , and present a set of operations for manipulating a data cube . </S>",
    "<S> we clearly define the semantics of these operations , and prove that they can be composed , yielding a language powerful enough to express complex olap queries . </S>",
    "<S> we express these operations as a sequence of atomic transformations over a fixed multidimensional matrix , whose cells contain a sequence of measures . </S>",
    "<S> each atomic transformation produces a new measure . </S>",
    "<S> when a sequence of transformations defines an olap operation , a flag is produced indicating which cells must be considered as input for the next operation . in this way , an elegant algebra is defined . </S>",
    "<S> our main contribution , with respect to other similar efforts in the field is that , for the first time , a formal proof of the correctness of the operations is given , thus providing a clear semantics for them . </S>",
    "<S> we believe the present work will serve as a basis to build more solid practical tools for data analysis .    </S>",
    "<S> * keywords * : olap ; data warehousing ; algebra ; data cube ; dimension hierarchy    . </S>"
  ]
}