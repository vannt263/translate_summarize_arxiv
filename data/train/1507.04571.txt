{
  "article_text": [
    "the following basic example illustrates what we would like to visualize .",
    "let @xmath0 be the square root of @xmath1 , @xmath2 if @xmath1 is a non - negative real number , we typically define @xmath0 as the non - negative real number whose square equals @xmath1 , i.e.  we always choose the non - negative solution of the equation @xmath3 as @xmath4 . for negative real numbers @xmath1 , no real number @xmath0 solves .",
    "however , if we define the imaginary unit @xmath5 as a number with the property that @xmath6 then the square root of @xmath1 becomes the purely imaginary number @xmath7 together , these two conventions yield a continuous square root function @xmath8 for complex numbers @xmath1 , has exactly two complex solutions ( counted with multiplicity ) , the square roots of @xmath1 .",
    "we have seen that , for real numbers @xmath1 , we can choose one solution of   for the square root and obtain a square root function that is continuous over the real numbers .",
    "in contrast , we can not for every complex number @xmath1 choose one solution of   so that we obtain a square root function that is continuous over the complex numbers : if we plot the two solutions of   as @xmath1 runs along a circle centred at the origin of the complex plane , we observe that @xmath0 moves at half the angular velocity of @xmath1 ( see  ) .",
    "( 0,0 ) circle ( 2 ) ; ( 0,0 ) circle ( sqrt(2 ) ) ; ( -2.5,0 )  ( 2.5,0 ) node[right ] @xmath9 ; ( 0,-2.5 )  ( 0,2.5 ) node[above ] @xmath10 ; in 0,10, ... ,90 ( : 2 ) circle ( 0.05 ) ; ( 0.5*:sqrt(2 ) ) circle ( 0.05 ) ; ( 0.5*+180:sqrt(2 ) ) circle ( 0.05 ) ;    ( -2.5,0 )  ( 2.5,0 ) node[right ] @xmath9 ; ( 0,-2.5 )  ( 0,2.5 ) node[above ] @xmath10 ; ( 0:2 ) circle ( 0.05 ) ; ( 0:sqrt(2 ) ) circle ( 0.05 ) ; ( 180:sqrt(2 ) ) circle ( 0.05 ) ; ( 2:sqrt(2 ) ) arc ( 2:178:sqrt(2 ) ) ; ( 182:sqrt(2 ) ) arc ( 182:358:sqrt(2 ) ) ; ( 2:2 ) arc ( 2:358:2 ) ;    when @xmath1 completes one full circle and reaches its initial position again , the square roots have interchanged signs . therefore",
    ", a discontinuity occurs when @xmath1 returns to its initial position after one full turn and the square root jumps back to its initial position .",
    "note that by choosing the values of the square root in a different manner , or , equivalently , letting @xmath1 start at at a different position , we can move the discontinuity to an arbitrary position on the circle .",
    "moreover , note that there is ( at least ) one discontinuity on any circle of any radius centred at the origin .    in order to define the principal branch of the complex square root function ,",
    "we usually align the discontinuities along the negative real axis , the canonical branch cut of the complex square root function , and choose those values that on the real axis agree with the square root over the real numbers .",
    "alternatively , we can extend the domain of the complex square root to make it a single - valued and continuous function .",
    "to that end , we take two copies of the extended complex plane and slit them along the negative real axis . on the first copy ,",
    "we choose the solution of   with non - negative real part as the complex square root of @xmath1 ; on the second copy , we choose the other solution .",
    "we glue the upper side ( lower side ) of the slit of the first copy to the lower side ( upper side ) of the slit of the second copy and obtain a riemann surface of the complex square root .",
    "( in three dimensions , this is not possible without self - intersections . )    on the riemann surface , the complex square root is single - valued and continuous .",
    "it is even analytic except at the origin and at infinity , which are exactly the points where the two solutions of coincide .",
    "the branch cut is not a special curve of the riemann surface .",
    "when we glue the riemann surface together , the branch cut becomes a curve like every other curve on the riemann surface .",
    "if we had used a different curve between the origin and infinity as branch cut , we would have obtained the same result .    describes a parabola .",
    "we can proceed analogously to obtain riemann surfaces for other plane algebraic curves .",
    "probably the most common approach for visualization of functions is to plot a function graph .",
    "however , for a complex function @xmath11 the function graph @xmath12 is a ( real ) two - dimensional surface in ( real ) four - dimensional space .",
    "one way to visualize a four - dimensional object is to plot several two- or three - dimensional slices .",
    "this approach seems less useful for understanding the overall structure of the object .",
    "another traditional method to visualize complex functions is domain colouring .",
    "the principle of domain colouring is to colour every point in the domain of a function with the colour of its function value in a reference image .",
    "if we choose the reference image wisely , a lot of information about the complex function can be read off from the resulting two - dimensional image ( see e.g.  @xcite and  @xcite ) .",
    "the idea of lifting domain colouring to riemann surfaces is due to .    we can interpret a riemann surface of a plane algebraic curve @xmath13 as a function graph of a multivalued complex function , which maps every @xmath1 to multiple values of @xmath0 .",
    "if @xmath14 is a polynomial of degree @xmath15 in @xmath0 , there are exactly @xmath15 values of @xmath0 for every value of @xmath1 that satisfy @xmath16 ( counted with multiplicity ) .",
    "every such pair @xmath17 corresponds to a point on the riemann surface . in other words ,",
    "the riemann surface is an @xmath15-fold cover of the complex plane .",
    "let @xmath18 denote a projection function on the riemann surface .",
    "then the values of @xmath0 at @xmath1 correspond to the elements of the fibre @xmath19 .",
    "the situation is analogous to function graphs of single - valued functions from the real numbers ( or the real plane ) to the real numbers , where one function value lies above every point in the domain .",
    "we can transfer the riemann surface from ( real ) four - dimensional space into ( real ) three - dimensional space by introducing a height function @xmath20 .",
    "we typically use the real part as a height function .",
    "we plot the surface @xmath21 and use domain colouring to represent the value of @xmath0 at every point of the surface .    in practice , we want to generate a triangle mesh that approximates the riemann surface as the graph of a multivalued function over a triangulated domain in the complex plane .",
    "the riemann surface mesh approximates the continuous riemann surface in the following sense : the @xmath0-values at the vertices of a triangle of the riemann surface mesh result from each other under analytic continuation along the edges of the underlying triangle in the triangulated domain . if @xmath22 is a polynomial of degree @xmath15 in @xmath0 there are @xmath15 values of @xmath0 above every vertex @xmath1 of the triangulated domain",
    "hence , we have to determine which of the @xmath23 values of @xmath0 above a triangle in the triangulated domain form triangles of the riemann surface mesh .",
    "a wrong combination of values of @xmath0 to triangles might for example occur due to discontinuity if we used the principal branch of the square root function for the computation of @xmath0 .",
    "this would produce artefacts in the visualization for which there is no mathematical justification .    for the generation of such a riemann surface mesh ,",
    "previous algorithms have solved systems of differential equations  @xcite or explicitly identified and analyzed branch cuts to remove discontinuities  .    in the next section",
    ", we discuss an algorithm based on a different idea : we can exploit that @xmath24 is continuous almost everywhere on the riemann surface and therefore , if @xmath1 changes little , so does @xmath24 .",
    "in this section , we describe algorithms for generating and visualizing domain - coloured riemann surface meshes of plane algebraic curves .",
    "let @xmath25 be a complex plane algebraic curve .",
    "in particular , let @xmath26 be a polynomial with complex coefficients of degree @xmath15 in @xmath0",
    ". moreover let @xmath27 be a triangulated domain in the complex plane .",
    "( in practice , @xmath28 is typically rectangular . )",
    "we want to generate a riemann surface mesh of @xmath29 .",
    "the mesh discretizes a part of a ( real ) two - dimensional surface in ( real ) four - dimensional space .",
    "we can visualize it using a height function and domain colouring , as described in the previous section .",
    "we obtain a riemann surface mesh of @xmath29 as a graph of the multivalued function induced by  , which maps every value of @xmath1 in @xmath28 to @xmath15 values of @xmath0 such that @xmath30 .    for every triangle in @xmath28",
    ", we thus obtain @xmath15 values of @xmath0 at each of its three vertices .",
    "the problem is to determine whether , and if so , how , the @xmath23 values of @xmath0 can be combined to form triangles of the riemann surface mesh .",
    "the resulting triangles should be consistent with the fact that @xmath0 as a function of @xmath1 is analytic almost everywhere on the riemann surface .",
    "this is impossible if the triangle in @xmath28 contains a ramification point of @xmath24 . in this case",
    ", we subdivide the triangle to obtain smaller triangles mostly free of ramification points .",
    "otherwise , the triangles of the riemann surface mesh are uniquely determined by analytic continuation of @xmath24 along the edges of the triangle in @xmath28 .    in order to find these triangles of the riemann surface mesh",
    ", we use the following idea : consider a triangle @xmath31 in @xmath28 that is free of ramification points of @xmath24 . under this assumption",
    ", @xmath24 is continuous on those parts of the riemann surface that lie above @xmath31 .",
    "hence , for every @xmath32 there exists @xmath33 such that @xmath34 for all @xmath35 with @xmath36 . if @xmath37 is half the minimum distance between the @xmath15 values of @xmath24 at @xmath38 and @xmath39 is smaller than the corresponding @xmath40 , then the values of @xmath24 at @xmath41 are closer to the corresponding values of @xmath24 at @xmath38 than to any other value of @xmath24 at @xmath38 .    in other words ,",
    "if triangle @xmath31 is small enough , we can combine the values of @xmath0 at its vertices to triangles of the riemann surface mesh based on proximity : among the @xmath23 values of @xmath0 at the vertices of triangle @xmath31 , every three values of @xmath0 closest to each other form a triangle of the riemann surface mesh .",
    "we can algorithmically compute a @xmath33 as above using the epsilon - delta bound for plane algebraic curves of  .",
    "is of essential importance for our approach .",
    "our approach only works because provides us with a reliable bound computable as a function of @xmath1 that depends only on a few constants derived from the coefficients of @xmath14 .",
    "if triangle @xmath31 is not small enough to correctly combine the values of @xmath0 at its vertices based on proximity , we subdivide the triangle .    in summary",
    ", we obtain the following algorithm :    [ alg : riemann - surface - mesh ] let @xmath27 be a triangulated domain in the complex plane .",
    "let @xmath42 be a complex plane algebraic curve and @xmath43 a polynomial of degree @xmath15 in @xmath0 .",
    "we prescribe a maximal subdivision depth ( as a maximal number of iterations or as a minimal edge length ) .    1 .",
    "compute the global ingredients of the epsilon - delta bound of for @xmath44 .",
    "2 .   for every triangle @xmath31 in @xmath28 : 1 .   compute the @xmath23 values of @xmath24 at @xmath45 , @xmath46 2 .",
    "compute half the minimum distance between the values of @xmath24 at each of the vertices of @xmath31 , @xmath47 3 .",
    "compute @xmath48 by the epsilon - delta bound of so that @xmath49 4 .   determine which of the edges of @xmath31 are longer than the minimum of the @xmath48 at their endpoints and must be subdivided .",
    "select the right adaptive refinement pattern ( see  ) and subdivide @xmath50 accordingly .",
    "repeat step 2 until the maximal subdivision depth is reached .",
    "4 .   discard every triangle in @xmath28 with an edge longer than the minimum of the @xmath48 at its endpoints .",
    "5 .   for every triangle @xmath31 in @xmath28 ,",
    "combine the values of @xmath24 at its vertices to triangles of the riemann surface mesh based on proximity .",
    "more formally , the triangles added to the riemann surface mesh comprise the vertices @xmath51 for @xmath52 . 6 .",
    "output the riemann surface mesh and stop .",
    "\\(a ) at ( 210:1 ) ; ( b ) at ( 330:1 ) ; ( c ) at ( 90:1 ) ; ( a )  ( b ) ",
    "( c )  cycle ;    \\(a )  ( b ) ",
    "( c )  cycle ; ( b )  ( @xmath53 ) ;    \\(a ) ",
    "( b )  ( c )  cycle ; ( a )  ( @xmath54 ) ;    \\(a ) ",
    "( b )  ( c )  cycle ; ( a )  ( @xmath54 ) ; ( @xmath53 )  ( @xmath54 ) ;    \\(a )  ( b )  ( c )  cycle ; ( c )  ( @xmath55 ) ;    \\(a )  ( b )  ( c )  cycle ; ( @xmath55 )  ( @xmath53 ) ; ( b )  ( @xmath53 ) ;    \\(a )  ( b )  ( c )  cycle ; ( c )  ( @xmath55 ) ; ( @xmath55 )  ( @xmath54 ) ;    \\(a )  ( b )  ( c )  cycle ; ( @xmath55 )  ( @xmath54 ) ; ( @xmath54 )  ( @xmath53 ) ; ( @xmath53 )  ( @xmath55 ) ;    by construction , generates a riemann surface mesh that is consistent with the analytic structure of the riemann surface of @xmath29 .",
    "the adaptive refinement patterns used for the subdivision of triangles , whose edges are too long , produce a watertight subdivision .",
    "step 4 of   produces holes around the ramification points of @xmath24 .",
    "we can make these holes very small if we choose the maximal subdivision depth appropriately .    for the visualization of a riemann surface mesh , we use the following algorithm :    [ alg : visualization ] let a riemann surface mesh and a domain colouring reference image be given .",
    "we choose a height function @xmath20 to transform a point on the riemann surface mesh from ( real ) four - dimensional space to a point in ( real ) three - dimensional space , @xmath56    1 .",
    "draw the mesh that results from transforming every vertex of the riemann surface mesh as above .",
    "2 .   interpolate the value of @xmath24 on the transformed mesh .",
    "3 .   assign to every point on the transformed mesh the colour in the reference image of the value that @xmath24 attains at that point on the transformed mesh .    if we choose the real ( or imaginary ) part of @xmath24 as a height function , the transformation from ( real ) four - dimensional to ( real ) three - dimensional space becomes a projection .",
    "using the real part of @xmath24 as a height function has the advantage that the visualization then contains the image of @xmath29 interpreted as a real plane algebraic curve .",
    "it is the intersection of the visualization of the riemann surface mesh in ( real ) three - dimensional space with the @xmath57-@xmath58-plane ( the @xmath59-plane , if we label the coordinate axes of real three - dimensional space such that the @xmath1-axis points to the right and the @xmath60-axis points upwards ) .",
    "the computation of the riemann surface mesh by is independent of the choice of height function used for its visualization .",
    "in this section , we discuss how   and   can be implemented using opengl and webgl .",
    "since webgl targets a much wider range of devices , its api is more limited than that of opengl . consequently , our implementation using webgl differs substantially from our implementation using opengl . before we discuss each setup separately ,",
    "let us talk about what they have in common .",
    "the main part of our programs is written in shading language ( glsl for opengl and essl for webgl ) and runs on the gpu .",
    "we use the cpu to compute the global ingredients for the epsilon - delta bound , to generate shading language code that computes the epsilon - delta bound for @xmath61 as a function of @xmath1 , and to generate a coarse triangulation of the input domain .",
    "the implementations in opengl and webgl share some shading language code .",
    "since there is no native type for complex numbers , we represent them using two - dimensional floating point vectors .",
    "common routines include complex arithmetic , numerical root - finding algorithms , the computation of the epsilon - delta bound , and domain colouring .",
    "the implementation of complex arithmetic is straightforward and we shall not go into detail about it .",
    "we need numerical root - finding algorithms to approximate roots of polynomials in order to compute values of @xmath24 ( and to compute the global ingredients of the epsilon - delta bound ) .",
    "for instance , laguerre s method  @xcite*section  9.5.1 and deflation  @xcite*section  9.5.3 or weierstra  durand  kerner method  @xcite are well - suited .",
    "the latter may be a little easier to implement in shading language ( due to the absence of variable - length arrays ) .    for the computation of the epsilon - delta bound , we use the following theorem :    [ thm : epsilon - delta - bound ] let @xmath62 be a complex plane algebraic curve , where @xmath63 is a polynomial of degree @xmath15 in @xmath0 whose coefficients @xmath64 are polynomials in @xmath1 of the form @xmath65 let @xmath66 be a point in the complex plane at which neither the leading coefficient @xmath67 nor the discriminant of @xmath14 w.r.t .",
    "@xmath0 vanish .",
    "then for every @xmath32 , we can algorithmically compute @xmath68 such that @xmath69 for all holomorphic functions @xmath70 , @xmath71 , which satisfy @xmath72 in a neighbourhood of @xmath38 and for all @xmath41 with @xmath36 .",
    "we obtain @xmath73 where @xmath74 @xmath75 denotes the @xmath0-discriminant of @xmath14 , and @xmath76 , @xmath77 , are the zeros of @xmath78 .",
    "note that the computation is parallelizable since the epsilon - delta bound can be implemented as a function of @xmath1 that depends on only a few constants derived from the coefficients of @xmath14 .    instead of computing texture coordinates , which would depend on the range of @xmath24 on the input domain",
    ", we generate the domain colouring procedurally on - the - fly . to that end",
    ", we use a variation of the enhanced phase portrait colour scheme of  @xcite*section  2.5 .",
    "the reference image is shown in  .",
    "we discuss the colour scheme in  .",
    "the main difference between the implementations in opengl and webgl is how the common routines can be combined to realize and  .",
    "our implementation of   in opengl comprises three glsl programs , for initialization , subdivision , and assembly of the riemann surface mesh .",
    "we cache the output of each program using transform feedback and feed it back to the next program .",
    "the initialization program consists only of a vertex shader , which operates on the vertices of the triangulated input domain . for every vertex @xmath1",
    ", we compute @xmath79 , @xmath52 , and @xmath80 .",
    "after initialization , we run the subdivision program .",
    "the program consists of a pass - through vertex shader and a geometry shader .",
    "the geometry shader operates on the triangles of the triangulated input domain or of its last subdivision , respectively .",
    "we have access to the values of @xmath81 , @xmath48 , and @xmath82 , @xmath52 , @xmath83 , at the vertices of each triangle @xmath31 .",
    "we determine which edges of triangle @xmath31 are longer than the minimum of the @xmath48 at their endpoints . in order to subdivide these edges",
    ", we compute their midpoints @xmath1 , and @xmath84 and @xmath79 , @xmath52 , at the midpoints .",
    "we use the appropriate adaptive refine pattern of and output between one and four triangles for every input triangle . in doing so , we reuse previously computed values rather than recomputing them .",
    "we run the subdivision program iteratively until we reach the prescribed maximal subdivision depth .",
    "the assembly program consists of a pass - through vertex shader and a geometry shader .",
    "the geometry shader operates on the triangles of the adaptively subdivided input domain .",
    "we again have access to the values of @xmath81 , @xmath48 , and @xmath82 , @xmath52 , @xmath85 , at the vertices of each triangle @xmath31 . for every triangle @xmath31",
    ", we test whether one of its edges is longer than the minimum of the @xmath48 at its endpoints . in this case",
    ", we discard the triangle . otherwise , we determine the triangles of the riemann surface mesh by proximity ( see  , step  5 ) and output these @xmath15 triangles .",
    "we also cache the assembled riemann surface mesh using transform feedback so that we can pass it as input to our implementation of the visualization algorithm ( ) .",
    "our implementation of   in opengl consists of one glsl program with a vertex and a fragment shader .",
    "the vertex shader operates on the vertices of a riemann surface mesh generated by our implementation of  .",
    "we apply height function @xmath20 to map each ( real ) four - dimensional vertex @xmath86 to a ( real ) three - dimensional vertex @xmath87 we homogenize the coordinates of this vertex and transform them using the model - view - projection matrix .",
    "we pass @xmath44 as a varying variable to the fragment shader .",
    "the fragment shader operates on the interpolated value of @xmath44 at a fragment of a pixel of the output device .",
    "we compute the colour of @xmath44 according to our domain colouring reference image .",
    "using our implementation , the generation of a riemann surface mesh takes little but noticeable time .",
    "the bottlenecks of the implementation are numerical root - finding and iterative subdivision . however ,",
    "if we use transform feedback to cache the riemann surface mesh and pass it to the implementation of the visualization algorithm , we obtain interactive performance .",
    "another advantage of using transform feedback to cache the riemann surface mesh is that we can easily export the data .",
    "if we additionally compute texture coordinates and a high - resolution reference image , we can even print our visualization using a full colour 3d printer ( see ) .          in order to support a wider range of devices ,",
    "the webgl api is much more limited than the opengl api .",
    "particularly , in webgl , geometry shaders and transform feedback are currently unavailable .",
    "( the webgl 2 draft includes transform feedback and compute shaders . )",
    "therefore our implementation in webgl differs substantially from our implementation in opengl .      instead of",
    "transform feedback , our implementation in webgl uses floating point textures ( specified in the ` oes_texture_float ` extension ) and multiple render targets ( specified in the ` webgl_draw_buffers ` extension ) .",
    "i do not claim originality of this approach .",
    "it is commonly used for running simulations on the gpu .",
    "the original idea may be due to  @xcite .",
    "we number the vertices of every mesh consecutively and pass this number ( index ) to the vertex shaders along with the other attributes .",
    "in particular , vertices that are shared among several triangles must be duplicated and numbered separately .",
    "hence , we assume that every triangle appears as three consecutive vertices in array buffer storage ( triangle soup ) .",
    "we use floating point textures essentially as we would arrays of floats , indexed by vertex number .",
    "we store values corresponding to the @xmath88-th vertex in the @xmath88-th pixel of a texture . we can store up to four floats per pixel of a floating point texture , namely one float each in the red , green , blue , and alpha channel .",
    "if we need to store more than four floats , we use multiple render targets which allows us to colour the same pixel of several textures simultaneously .",
    "we want to store values we compute for a vertex in textures ( ` transform ' in transform feedback ) .",
    "to that end , we bind the array buffers and draw the contents as points ( as opposed to triangles ) . in the vertex shader , we compute the positions of the point with index @xmath88 ( in normalized device coordinates ) so that it is rasterized as the @xmath88-th pixel of the render target textures .",
    "recall that normalized device coordinates range in @xmath89}^3 $ ] .",
    "for example , if @xmath90 and @xmath91 denote the height and width of the textures in pixels , we assign to the point with index @xmath88 the position @xmath92 in the fragment shader , we compute the values to be stored and assign them as output colours in a specific order ( as we later want to retrieve them ) .",
    "we want to read stored values for a vertex from textures ( ` feedback ' in transform feedback ) . to that end , we bind the textures and an array buffer containing a range of vertex numbers ( indices ) .",
    "we draw the contents of the array buffer as points or triangles ( depending on whether we want to send the output to different textures or to the screen ) . in the vertex shader",
    ", we compute texture coordinates for the point with index @xmath88 which allow us to lookup the @xmath88-th pixel from the textures . recall that texture coordinates range in @xmath93}^2 $ ] . for a texture of height @xmath90 and width @xmath91 , we compute the texture coordinates @xmath94 adding @xmath95 in the numerators accounts for the fact that we want to obtain coordinates for the centre of a pixel in order to avoid interpolation with adjacent pixels .",
    "we pass the texture coordinates to the fragment shader , where we can use them to perform a texture lookup .    in order to access data of a whole triangle ( as in geometry shaders ) ,",
    "we can , in the vertex shader , determine the indices of the other vertices of the triangle .",
    "for example , the point with index @xmath88 is part of the triangle whose vertices have indices @xmath96 we compute normalized device coordinates or texture coordinates for all three indices and pass them to the fragment shader , together with the index of the triangle vertex currently under consideration .",
    "we replace the geometry shader of the subdivision program of our implementation in opengl using a variation of a method proposed by .",
    "the method works as follows : we precompute all adaptive refinement patterns up to a certain subdivision depth , in our case eight adaptive refinement patterns up to depth one ( see  ) .",
    "we use barycentric coordinates to store the positions of the triangle vertices of each refinement pattern in an array buffer .",
    "using array buffers of different lengths allows us to achieve variable - length output , as with geometry shaders . for every triangle of a coarse input mesh ,",
    "we draw the triangles in the array buffer of the appropriate adaptive refinement pattern .",
    "we use the vertex positions of the input triangle ( read from a texture or from uniform variables ) and the barycentric coordinates of the triangles of the adaptive refinement pattern to compute the vertex positions of the output triangle .",
    "we can combine this method with floating point texture and multiple render targets as outlined above , if we number the vertices of each adaptive refinement pattern consecutively and store those indices together with the barycentric coordinates .",
    "we pass an offset as a uniform variable to the vertex shader that needs to be added to the indices .",
    "we draw the adaptive refinement pattern and increment the offset by the number of vertices in the adaptive refinement pattern .    the geometry shader of the assembly program has fixed - length output .",
    "it generates exactly @xmath15 triangles of the riemann surface mesh per triangle of the ( subdivided ) input mesh .",
    "we can replace it with @xmath15 invocations of a vertex shader , one for every sheet of the riemann surface mesh .",
    "we pass the number of the current sheet to the vertex shader as a uniform variable .",
    "we can not expect our webgl implementation to reach the same performance as our opengl implementation . in the subdivision program ,",
    "since we draw a different adaptive refinement pattern for every triangle of the input mesh , we lose parallelism .",
    "consequently , subdivision in webgl is much slower than its opengl counterpart .",
    "however , if we cache the assembled riemann surface mesh ( in textures ) and pass it to our implementation of the visualization algorithm , we can still achieve interactive performance .",
    "in this section , we discuss domain - coloured riemann surface meshes for the complex square root function and for the folium of descartes . before that , let us explain our domain colouring reference image so that we can interpret the domain - coloured riemann surface meshes .",
    "recall that the basic idea of domain colouring is the following : if we want to visualize a complex function @xmath97 we face the problem that its graph is real four - dimensional",
    ". however , we can visualize the behaviour of the function by colouring every point in its domain with the colour of the function value at that point in a reference image .",
    "the reference image is the domain colouring of the complex identity function .",
    "depending on what reference image we choose , we can read off various properties of a function from its domain colouring .",
    "for an overview of different colour schemes , we refer to  @xcite .    as our reference image , we use a variation of the enhanced phase portrait colour scheme of  @xcite*section  2.5 .",
    "the reference image is best described using polar coordinates @xmath98 of a complex number with _",
    "modulus _ @xmath99 and _ phase _ @xmath100 .",
    "firstly , we encode the phase at any point in the domain as the hue of its colour ( in hsi colour space ) . in a square with side length",
    "@xmath101 centred at the origin , we thus obtain the colour wheel shown in  . as the phase changes from @xmath102 to @xmath103",
    ", we obtain every colour of the rainbow .",
    "positive real numbers , which have phase @xmath102 , are coloured in pure red .",
    "negative real numbers , which have phase @xmath104 , are coloured in cyan . purely imaginary numbers do not have such distinctive colours .",
    "( this can be fixed using the nist continuous phase mapping , which scales the phase piecewise linearly so that purely imaginary numbers with positive imaginary part become yellow and purely imaginary numbers with negative imaginary part become blue .",
    "see  @xcite*http://dlmf.nist.gov / help / vrml / aboutcolor#s2.ss2 .",
    "for simplicity , we do not follow this approach here . )",
    "0.32     0.32     0.32     secondly , we add contour lines of complex numbers of the same phase at integer multiples of @xmath105 degrees ( see  ) . to that end , we change the intensity of the colour by multiplying it with a sawtooth function @xmath106 because phase corresponds to hue , the points of such a contour line are all of the same colour .",
    "finally , we add contour lines of complex numbers of the same modulus on a log - scale ( see  ) . to that end",
    ", we change the intensity of the colour by multiplying it with a sawtooth function @xmath107 note that the contour lines of phase and modulus intersect each other orthogonally .",
    "the scaling factor @xmath108 in the sawtooth function for the modulus contour lines deliberately matches the scaling factor used in the sawtooth function for the phase contour lines .",
    "consequently , the regions enclosed by the contour lines of phase and modulus are squarish in appearance .",
    "recall the construction of a riemann surface of the complex square root from where we glued together its two branches at a branch cut along the negative real axis .",
    "0.49     0.49     the domain colouring of the two branches of the complex square root over a square of side length @xmath101 centred at the origin is shown in .",
    "on the sheet shown in  , the complex square root takes values with negative real part ( coloured green to blue ) . on the sheet shown in  , it takes values with positive real part ( coloured purple to yellow ) .",
    "( the sheet shown in   corresponds to the principal branch of the complex square root . )    on both sheets , twelve contour lines of phase are visible , half as many as in the reference image .",
    "we can see that the phase of the complex square root function changes at half the angular velocity of its argument .    moreover , the discontinuity at the branch cut along the negative real axis is clearly visible .",
    "we also see that there is a smooth transition between the second ( third ) quadrant of and the third ( second ) quadrant of  .    if we cut the two sheets along the negative real axis and glue the upper side of the cut of one sheet to the lower side of the cut of the other sheet , and vice versa , we obtain a riemann surface of the complex square root .",
    "the resulting riemann surface , produced with and   using real part as height function , is shown in ( perspective ) and ( multiview orthogonal ) .        0.24     0.24     0.24     0.24     note that the self - intersection of the surface in is only an artefact of using a height function to map the riemann surface mesh from real four - dimensional to real three - dimensional space .",
    "evidently , the two values of the complex square root at each point of the self - intersection do not agree : they are coloured differently , in green and purple , respectively .    in",
    ", we see the parabola that the real parts of the @xmath0-values describe according to the equation @xmath109 when @xmath1 takes values on the non - negative real axis .",
    "( -5,-5 ) grid ( 5,5 ) ; ( -5,0 )  ( 5,0 ) node[below left ] @xmath1 ; ( 0,-5 )  ( 0,5 ) node[below right ] @xmath0 ; ( -5,-5 ) rectangle ( 5,5 ) ; plot ( ( 6*(-1+^2)^2)/(-1 + 3*^2 + 8*^3 - 3*^4+^6 ) , 12*(^4-^2)/(3*^2 + 8*^3 - 3*^4+^6 - 1 ) ) ; plot ( ( -6*(-1+^2)^2)/(-1 + 3*^2 - 8*^3 - 3*^4+^6 ) , 12*(^4-^2)/(3*^2 - 8*^3 - 3*^4+^6 - 1 ) ) ;    the folium of descartes is a classical plane algebraic curve of order three , @xmath110 the cubic curve is nowadays called ` folium ' after the leaf - shaped loop that it describes in the first quadrant of the real plane ( see  ) .",
    "it is named in honour of the french geometer ren descartes ( 15961650 ) , who was among the first mathematicians to introduce coordinates into geometry .",
    "originally , the curve was called _",
    "fleur de jasmin _ since descartes and some of his contemporaries , who were working out the principles of dealing with negative and infinite coordinates , initially wrongly believed that the leaf - shaped loop repeated itself in the other quadrants and therefore resembled a jasmine flower  @xcite*p .",
    "0.32     0.32     0.32     shows three domain - coloured sheets of the folium of descartes over a square of side length @xmath101 centred at the origin of the complex plane .",
    "we can generate these sheets by sorting the @xmath0-values that satisfy   at every point @xmath1 of the domain according to their real part .",
    "the sheet shown in   uses the @xmath0-value with the smallest real part , the sheet shown in   the @xmath0-value with the second - smallest real part , and the sheet shown in   the @xmath0-value with the largest real part .",
    "we see that the first sheet carries @xmath0-values with negative real part ( coloured green to blue ) . at the centre of the second sheet ,",
    "we identify a zero of order two , which we can recognize from the fact that the colours of the colour wheel used in our reference image wind around it twice in the same order as in the reference image .",
    "it is the node of the leaf - shaped loop .",
    "the third sheet carries @xmath0-values with positive real part ( coloured purple to yellow ) .",
    "there are three branch cuts ( discontinuities of hue ) on the first sheet , six on the second sheet and three on the third sheets .",
    "we can see how the sheets of the riemann surface are connected to each other along the branch cuts : first and second sheet are connected at the branch cuts of the first sheet .",
    "second and third sheet are connected at the branch cuts of the third sheet .",
    "first and third sheet are not connected directly with each other .",
    "( imagine how much harder it would be to read this off from . )",
    "apart from the branch cuts , the map from @xmath1 to @xmath24 is conformal ( angle - preserving ) on every sheet .",
    "we can see that the contour lines of phase and modulus intersect each other orthogonally on every sheet , as in our reference image .",
    "if we cut the sheets along the branch cuts and glue them together correctly , we obtain a riemann surface for the folium of descartes .",
    "the resulting riemann surface , produced with and   using real part as height function , is shown in   ( perspective ) and   ( multiview orthogonal ) .",
    "again , the self - intersections of the surface in are only an artefact of using a height function to map the riemann surface mesh from ( real ) four - dimensional to ( real ) three - dimensional space",
    ".    makes it obvious that cutting a riemann surface into sheets by sorting @xmath0-values by real part may be the most straightforward but not necessarily the geometrically most appropriate method .",
    "our riemann surface of the folium of descartes in large part appears to be composed of three copies of the complex plane ( which looks like our reference image ) .",
    "complications seem to arise only near the origin .    0.24     0.24     0.24     0.24",
    "if we look closely at  , we may see how we obtain the real folium of descartes ( as a real plane algebraic curve ) as the intersection of our riemann surface mesh with the @xmath57-@xmath58-plane .",
    "the leaf - shaped loop is clearly visible as a hole in our visualization .",
    "one of the ` complex planes of which the riemann surface is composed ' is so thin that it is barely visible from this perspective .",
    "it is almost asymptotic to the ` wings ' of the folium of descartes ( as a real plane algebraic curve ) in the second and fourth quadrant of the real @xmath111-plane .",
    "right below the centre of  , we see two leaf - shaped loops in complex directions .",
    "perhaps descartes and his contemporaries were not entirely wrong after all to believe that the folium of descartes has more than one leaf . indeed , if we let @xmath112 , we discover that in the @xmath113-@xmath58-plane the curve describes a leaf - shaped loop , which is exactly half as high as that in the @xmath57-@xmath58-plane ( this also holds for the ` wings ' ) and rotated into a different quadrant ( see  ) .",
    "0.49     0.49",
    "we have discussed algorithms for the generation of a riemann surface mesh of a plane algebraic curve ( ) and its visualization as a domain - coloured surface ( ) and their implementation using opengl and webgl .",
    "the webgl implementation combines floating point textures , multiple render targets , and a method due to to replace the use of transform feedback and geometry shaders of the opengl implementation .",
    "while the generation of the surface takes noticeable time in both implementations , the visualization of a cached riemann surface mesh is possible with interactive performance .",
    "this allows us to visually explore otherwise almost unimaginable mathematical objects .",
    "sometimes the visualization makes properties of the plane algebraic curves immediately apparent that may not so easily be read off from its equation .",
    "it is possible to turn these domain - coloured riemann surface meshes into physical models using a full colour 3d printer .",
    "this research was supported by dfg collaborative research center trr 109 , `` discretization in geometry and dynamics '' ."
  ],
  "abstract_text": [
    "<S> we examine an algorithm for the visualization of domain - coloured riemann surfaces of plane algebraic curves . </S>",
    "<S> the approach faithfully reproduces the topology and the holomorphic structure of the riemann surface . </S>",
    "<S> we discuss how the algorithm can be implemented efficiently in opengl with geometry shaders , and ( less efficiently ) even in webgl with multiple render targets and floating point textures . </S>",
    "<S> while the generation of the surface takes noticeable time in both implementations , the visualization of a cached riemann surface mesh is possible with interactive performance . </S>",
    "<S> this allows us to visually explore otherwise almost unimaginable mathematical objects . as examples , we look at the complex square root and the folium of descartes . for the folium of descartes , </S>",
    "<S> the visualization reveals features of the algebraic curve that are not obvious from its equation . </S>"
  ]
}