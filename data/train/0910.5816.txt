{
  "article_text": [
    "this paper focuses on a class of distributed optimization problems and its application to target localization and formation control . distributed optimization and computation have recently received widespread attention in the context of distributed estimation in sensor networks , distributed control of actuator networks and consensus algorithms . an early established reference on distributed optimization is @xcite , whereas a non - exhaustive set of recent references includes @xcite .",
    "we consider a distributed version of abstract optimization problems .",
    "abstract optimization problems , sometimes referred to as abstract linear programs or as lp - type programs , generalize linear programming and model a variety of machine learning and geometric optimization problems .",
    "examples of geometric optimization problems include the smallest enclosing ball , the smallest enclosing stripe and the smallest enclosing annulus problems .",
    "early references to abstract optimization problems include  @xcite . in this paper",
    "we are interested in abstract optimization problems where the number of constraints @xmath0 is much greater than the number of constraints @xmath1 that identify the optimum solution ( and where , therefore , there is a large number of redundant constraints ) .",
    "for example , we are interested in linear programs where @xmath0 is much greater than the number of variables @xmath2 ( in linear programs , @xmath3 ) . under this dimensionality assumption ,",
    "we consider distributed versions of abstract optimization programs , where @xmath0 is also the number of network nodes and where each constraint is associated to a node .",
    "we consider processor networks described by arbitrary , possibly time - dependent communication topologies and by computing nodes with tight memory constraints . after presenting and analyzing constraints consensus algorithms for distributed abstract optimization",
    ", we apply them to target localization in sensor networks and to formation control in robotic networks .",
    "the relevant literature is vast ; we organize it in three broad areas .",
    "first , linear programming and its generalizations , including abstract optimization , have received widespread attention in the literature . for linear programs in a fixed number of variables subject to @xmath0 linear inequalities , the earliest algorithm with time complexity in @xmath4",
    "is given in  @xcite .",
    "an efficient randomized algorithm is proposed in  @xcite , where a linear program in @xmath2 variables subject to @xmath0 linear inequalities is solved in expected time @xmath5 ; the expectation is taken over the internal randomizations executed by the algorithm . an elegant survey on randomized methods in linear programming and on abstract",
    "optimization is  @xcite ; see also  @xcite .",
    "the survey  @xcite , see also @xcite , discusses the application of abstract optimization to a number of geometric optimization problems . regarding parallel computation approaches to linear programming ,",
    "linear programs with @xmath0 linear inequalities can be solved  @xcite by @xmath0 parallel processors in time @xmath6 .",
    "however , the approach in  @xcite , see also references therein , is limited to parallel random - access machines , where a shared memory is readable and writable to all processors .",
    "other references on distributed linear programming include  @xcite",
    ".    a second relevant literature area is distributed training of support vector machines ( svms ) . a randomized parallel algorithm for svm training",
    "is proposed in  @xcite by using methods from abstract optimization and by exploiting the idea of exchanging only active constraints . along these lines",
    ", @xcite extends the algorithm to parallel computing over strongly connected networks , @xcite contains a comprehensive discussion of svm training via abstract optimization , and @xcite applies similar algorithmic ideas to wireless sensor networks .",
    "the algorithms in  @xcite , independently developed at the same time of our works  @xcite , differ from our constraint consensus algorithm in the following ways .",
    "first , the number of constraints stored at the nodes grows at each iteration so that both the memory and the local computation time at each node may be of order @xmath0 .",
    "second , our algorithm is proposed for general abstract optimization problems and thus may be applied to a variety of application domains .",
    "third , our algorithm exploits a novel re - examination idea , is shown to be correct for time - varying ( jointly strongly connected ) digraphs , and features a distributed halting condition .    as third and final set of relevant references ,",
    "we include a brief synopsis of recent progress in target localization in sensor networks and formation control in robotic networks .",
    "the problem of target localization has been widely investigated and recent interest has focused on sensors and wireless networks ; e.g. , see the recent text  @xcite . in this paper",
    "we take a deterministic worst - case approach to localization , adopting the set membership estimation technique proposed in  @xcite .",
    "a related sensor selection problem for target tracking is studied in @xcite .",
    "regarding the literature on formation control for robotic networks , an early reference on distributed algorithms and geometric patterns is @xcite . regarding the rendezvous problem , that is , the problem of gathering the robots at a common location , an early reference is  @xcite .",
    "the `` circle formation control '' problem , i.e. , the problem of steering the robots to a circle formation , is discussed in  @xcite .",
    "the references  @xcite are based on , respectively , control - lyapunov functions , input - to - state stability and cyclic pursuit .",
    "the contributions of this paper are twofold .",
    "first , we identify and study distributed abstract programming as a novel class of distributed optimization problems that are tractable and widely applicable .",
    "we propose a novel algorithmic methodology , termed _",
    "constraints consensus _ , to solve these problems in networks with various connectivity and memory constraints : as each node iteratively identifies locally active constraints and exchanges them with its neighbors , the globally active constraints determining the global optimum are collectively identified .",
    "a constraint re - examination idea is the distinctive detail of our algorithmic design .",
    "we propose three algorithms , a nominal one and two variations , to solve abstract programs depending on topology , memory and computation capabilities of the processor network .",
    "we formally establish various algorithm properties , including monotonicity , finite - time convergence to consensus , and convergence to the possibly - unique correct solution of the abstract program .",
    "moreover , we provide a distributed halting conditions for the nominal algorithm . we provide a conservative upper bound on the completion time of the nominal algorithm and conjecture that the completion time depends linearly on @xmath0 ( i.e. , the number of constraints and the network dimension ) .",
    "next , we evaluate the algorithm performance via a monte carlo probability - estimation analysis and we substantiate our conjecture on stochastically - generated sample problems .",
    "sample problems are randomly generated by considering two classes of linear programs , taken from  @xcite , and three types of graphs ( line - graph , erds - rnyi random graph and random geometric graph ) . as a second set of contributions ,",
    "we illustrate how distributed abstract programs are relevant for distributed target localization in sensor networks and for formation control problems , such as the rendezvous problem and the line or circle formation problems .",
    "specifically , for the target localization problem , we design a distributed algorithm to estimate a convex polytope , specifically an axis - aligned bounding box , containing the moving target .",
    "our proposed _",
    "eight half - planes consensus algorithm _ combines ( i ) distributed linear programs to estimate the convex polytope at a given instant and ( ii ) a set - membership recursion , consisting of prediction and update steps , to dynamically track the region .",
    "we discuss correctness and memory complexity of the distributed estimation algorithm .",
    "next , regarding formation control problems , we design a joint communication and motion coordination scheme for a robotic networks model involving range - based communication .",
    "we consider formations characterized by the geometric shapes of a point , a line , or a circle .",
    "we solve these formation control problems in a time - efficient distributed manner combining two algorithmic ideas : ( i ) the robots implement a constraints consensus algorithm to compute a common shape reachable in minimum - time , and ( ii ) the network connectivity is maintained by means of an appropriate standard connectivity - maintenance strategy . in the limit of vanishing robot displacement per communication round ,",
    "our proposed _ move - to - consensus - shape _ strategy solves the optimal formation control tasks .",
    "the paper is organized as follows .",
    "section  [ sec : lp - type problems ] introduces abstract optimization problems .",
    "section  [ sec : network - modeling ] introduces network models .",
    "section  [ sec : network - alp ] contains the definition of distributed abstract program and the constraints consensus algorithms .",
    "section  [ sec : computations ] contains the monte carlo analysis of the time - complexity of the constraints consensus algorithm .",
    "sections  [ sec : target - localization ] and  [ sec : mintime - formation ] contain the application of the proposed constraints consensus algorithms to target localization and formation control .",
    "we let @xmath7 , @xmath8 , and @xmath9 denote the natural numbers , the non - negative integer numbers , and the positive real numbers , respectively . for @xmath10 and @xmath11 , we let @xmath12 denote the closed ball centered at @xmath13 with radius @xmath14 , that is , @xmath15 . for @xmath16 , we @xmath17 and @xmath18 denote the vectors in @xmath19 whose entries are all @xmath20 and @xmath21 , respectively . similarly , we let @xmath22 and @xmath23 the vectors with @xmath2 entries @xmath24 and @xmath25 , respectively . for a finite set @xmath26 , we let @xmath27 denote its cardinality . for two functions @xmath28 , we write @xmath29 ( respectively , @xmath30 ) if there exist @xmath31 and @xmath32 such that @xmath33 for all @xmath34 ( respectively , @xmath35 for all @xmath36 ) .",
    "finally , we introduce the convention that sets are allowed to contain multiple copies of the same element .",
    "given @xmath37 and @xmath11 , let @xmath38 denote the distance from @xmath13 to @xmath39 , that is , @xmath40 . for distinct @xmath41 and @xmath42 ,",
    "let @xmath43 be the line through @xmath44 and @xmath45 . in what follows , a set of distinct points @xmath46",
    ", @xmath47 , is in _ stripe - generic position _ if , given any two ordered subsets @xmath48 and @xmath49 , either @xmath50 or @xmath51 .",
    "in this section we present an abstract framework  @xcite that captures a wide class of optimization problems including linear programming and various machine learning and geometric optimization problems .",
    "abstract optimization problems are also known as _ abstract linear programs _ , _ generalized linear programs _ or _ lp - type problems_.      we consider optimization problems specified by a pair @xmath52 , where @xmath53 is a finite set , and @xmath54 is a function , the set @xmath55 is the set of all subsets of @xmath53 ] with values in a linearly ordered set ( @xmath57 ) ; we assume that @xmath58 has a minimum value @xmath25 .",
    "the elements of @xmath53 are called _ constraints _ , and for @xmath59 , @xmath60 is called the _ value _ of @xmath61 . intuitively , @xmath60 is the smallest value attainable by a certain objective function while satisfying the constraints of @xmath61 .",
    "an optimization problem of this sort is called an _ abstract optimization program _ if the following two axioms are satisfied :    1 .",
    "_ monotonicity _ : if @xmath62 , then @xmath63 ; 2 .",
    "_ locality _ : if @xmath64 with @xmath65 , then , for all @xmath66 , @xmath67    a set @xmath68 is _ minimal _ if @xmath69 for all proper subsets @xmath70 of @xmath71 .",
    "a minimal set @xmath71 with @xmath72 is a @xmath73 .",
    "given @xmath74 , a _ basis of @xmath61 _ is a minimal subset @xmath75 , such that @xmath76 .",
    "a constraint @xmath77 is said to be _ violated _ by @xmath61 , if @xmath78 .",
    "a _ solution _ of an abstract optimization program @xmath79 is a minimal set @xmath80 with the property that @xmath81 .",
    "the _ combinatorial dimension _",
    "@xmath1 of @xmath52 is the maximum cardinality of any basis .",
    "finally , an abstract program is called _ basis regular _ if , for any basis with @xmath82 and any constraint @xmath66 , every basis of @xmath83 has the same cardinality of @xmath71 .",
    "we now define two important primitive operations that are useful to solve abstract optimization problems :    1 .",
    "_ violation test _ : given a constraint @xmath77 and a basis @xmath71 , it tests whether @xmath77 is violated by @xmath71 ; we denote this primitive by @xmath84 ; 2 .   _",
    "basis computation _ : given a constraint @xmath77 and a basis @xmath71 , it computes a basis of @xmath85 ; we denote this primitive by @xmath86 .",
    "[ ex : abstract - framework - for - lp ] we recall from @xcite how to transcribe a linear program into an abstract optimization program . a linear program ( lp ) in @xmath87",
    "is given by @xmath88 where @xmath89 is the state dimension , @xmath90 characterizes the linear cost function to minimize , and @xmath91 and @xmath92 describe @xmath93 inequality constraints . in order to transcribe the lp into an abstract program , we need to specify the constraint set @xmath53 and the value @xmath60 for each @xmath59 .",
    "the constraint set @xmath53 is simply the set of half - spaces @xmath94 , where @xmath95 . defining the value function in order to satisfy the",
    "monotonicity and locality axioms is more delicate : if @xmath96 and @xmath60 is the minimum of @xmath97 subject to the constraint set @xmath61 , then the locality axiom no longer holds ( see section  4 in @xcite for a counterexample ) .",
    "a correct choice is as follows : let @xmath98 be the set @xmath19 with the _ lexicographical order _ , , we have @xmath99 if and only if @xmath100 or ( @xmath101 and @xmath102 ) .",
    "] and define @xmath103 , where @xmath104 is the ( unique ) _ lexicographically minimal _",
    "point @xmath105 minimizing @xmath97 over the constraint set @xmath61 , when it exists and is bounded .",
    "if the problem is infeasible ( the intersection of the constraints in @xmath61 is empty ) , then @xmath106 .",
    "if the problem is unbounded ( no lexicographically minimal point exists ) , then @xmath107 .",
    "if @xmath108 is finite , then a basis of @xmath61 is a minimal subset of constraints @xmath109 such that @xmath110 .",
    "it is known  @xcite that the abstract optimization program transcription of a feasible lp is basis regular and has combinatorial dimension @xmath2 . a constraint @xmath66 is violated by @xmath61 if and only if @xmath111 .",
    "* * [ rem : examples ] we present three useful geometric examples , illustrated in figure  [ fig : geometric - alp ] .    1 .",
    "_ smallest enclosing ball : _ given @xmath0 distinct points in  @xmath19 , compute the center and radius of the ball of smallest volume containing all the points .",
    "this problem is  @xcite an abstract optimization program with combinatorial dimension  @xmath112 .",
    "smallest enclosing stripe : _ given @xmath0 distinct points in  @xmath113 in stripe - generic positions , compute the center and the width of the stripe of smallest width containing all the points . in the appendix we prove ( for the first time at the best of our knowledge )",
    "that this problem is an abstract optimization program with combinatorial dimension  @xmath114 .",
    "smallest enclosing annulus : _ given @xmath0 distinct points in  @xmath113 , compute the center and the two radiuses of the annulus of smallest area containing all the points .",
    "this problem is  @xcite an abstract optimization program with combinatorial dimension  @xmath115 .        in all three examples , the violation test and",
    "the basis computation primitives amount to low - dimensional geometric problems and are more or less straightforward .",
    "numerous other geometric optimization problems can be cast as abstract optimization programs as discussed in  @xcite    we end this section with a useful lemma , that is an immediate consequence of locality , and a useful rare property .",
    "[ lemma : locality2 ] for any @xmath116 and @xmath61 subsets of @xmath53 , @xmath117 if and only if there exists @xmath118 such that @xmath119 .",
    "if there exists @xmath118 such that @xmath119 , then by monotonicity @xmath120 .",
    "for the other implication , assume @xmath121 for some @xmath122 , and define @xmath123 for @xmath124 .",
    "we may rewrite the assumption @xmath117 as @xmath125 .",
    "if @xmath126 , then the locality axiom implies @xmath127 and the thesis follows with @xmath128 .",
    "otherwise , the same argument may be applied to @xmath129 .",
    "the recursion stops either when @xmath130 ( and the thesis follows with @xmath131 ) for some @xmath132 or when @xmath133 ( and the thesis follows with @xmath134 ) .",
    "next , given an abstract optimization program @xmath135 , let @xmath136 denote the basis of any @xmath137 .",
    "an element @xmath77 of @xmath138 is _ persistent _ if @xmath139 for all @xmath137 containing @xmath77 .",
    "an abstract optimization program @xmath135 is _ persistent _ if all elements of @xmath138 are persistent .",
    "the persistence property is useful , as we state in the following result .",
    "[ lemma : all - is - simple - if - persistent ] any persistent abstract optimization program @xmath135 can be solved in a number of time steps equal to the dimension of @xmath53 .",
    "let @xmath140 .",
    "set @xmath141 and then update @xmath142 for @xmath143 .",
    "because of persistency , each @xmath144 is added to @xmath71 once it is selected as @xmath145 and is not removed from @xmath71 in subsequent basis computations .",
    "unfortunately , the persistence property is rare .",
    "indeed , in figure  [ fig : lp_counter_example ] we show an lp problem where the persistency property does not hold . in fact , it can be easily noticed that @xmath146 is a basis for @xmath147 , but @xmath148 is a basis for @xmath149 . in other words @xmath150",
    "is not violated by @xmath151 .",
    "the lack of persistency complicates the design of centralized and distributed solvers for abstract optimization problems . for example , in network settings , flooding algorithms are not sufficient .          in the following sections we will assume that each node in the network possesses a routine capable of solving small - dimensional abstract optimization programs . for completeness sake",
    ", this section reviews the randomized algorithm proposed in @xcite .",
    "this algorithm has expected running time with linear dependence on the number of constraints , whenever the combinatorial dimension @xmath1 is fixed , and with sub - exponential dependence on the @xmath1 ; these bounds are proven in @xcite for linear programs and in @xcite for general abstract optimization programs .",
    "the algorithm , called @xmath152 , has a recursive structure and is based on the violation test and the basis computation primitives .",
    "given a set of constraints @xmath61 and a candidate basis @xmath153 , the algorithm is stated as follows :    * function * @xmath154    * if * @xmath155 , * then * * return * @xmath156 * else * choose a random @xmath157 and compute @xmath158 * if * @xmath84 ( that is , @xmath77 is violated by @xmath71 ) , * then * compute @xmath159 basis for @xmath85 * return * @xmath160 * else * * return * @xmath71 * endif * * endif *    for the abstract optimization program @xmath79 , the routine is invoked with @xmath161 , given any initial candidate basis @xmath71 .",
    "following @xcite , we define a synchronous network system as a `` collection of computing elements located at nodes of a directed network graph . ''",
    "we refer to computing elements are processors .",
    "we let @xmath162 denote a directed graph ( or digraph ) , where @xmath163 is the set of nodes and @xmath164 is the set of edges . for each node @xmath132 of @xmath165 , the number of edges going out from ( resp . coming into ) node @xmath132",
    "is called _ out - degree _ ( resp . _ in - degree _ ) .",
    "a digraph is _ strongly connected _ if , for every pair of nodes @xmath166 , there exists a path of directed edges that goes from @xmath132 to @xmath167 .",
    "a digraph is _ weakly connected _ if replacing all its directed edges with undirected edges results in a connected undirected graph . in a strongly connected digraph , the minimum number of edges between node @xmath132 and @xmath167 is called the _ distance from @xmath132 to @xmath167 _ and is denoted @xmath168 .",
    "the maximum @xmath168 taken over all pairs @xmath169 is the _ diameter _ and is denoted @xmath170 . finally , we consider time - dependent digraphs of the form @xmath171 . the time - dependent digraph @xmath165 is _",
    "jointly strongly connected _ if , for every @xmath172 , the digraph @xmath173 is strongly connected .    in a time - dependent digraph ,",
    "the set of outgoing ( incoming ) neighbors of node @xmath132 at time @xmath174 are the set of nodes to ( from ) which there are edges from ( to ) @xmath132 at time @xmath174 .",
    "they are denoted by @xmath175 and @xmath176 , respectively .",
    "a _ synchronous network _ is a time - dependent digraph @xmath177 , where @xmath163 is the set of _ identifiers _ of the processors , and the time - dependent set of edges @xmath178 describes communication among processors as follows : @xmath169 is in @xmath179 if and only if processor @xmath132 can communicate to processor @xmath167 at time @xmath180 .    for a synchronous network @xmath165 with processors @xmath163 , a _ distributed algorithm _ consists of ( 1 ) the set @xmath181 , called the set of _ processor states _",
    "@xmath182}}$ ] , for all @xmath183 ; ( 2 ) the set @xmath184 , called the _ message alphabet _ , including the @xmath185 symbol ; ( 3 ) the map @xmath186 , called the _ message - generation function _ ; and ( 4 ) the map @xmath187 , called the _ state - transition function_. the execution of the distributed algorithm by the network begins with all processors in their start states . the processors repeatedly perform the following two actions .",
    "first , the @xmath132th processor sends to each of its outgoing neighbors in the communication graph a message ( possibly the @xmath185 message ) computed by applying the message - generation function to the current value of @xmath182}}$ ] . after a negligible period of time",
    ", the @xmath132th processor computes the new value of its processor state @xmath182}}$ ] by applying the state - transition function to the current value of @xmath182}}$ ] , and to the incoming messages ( present in each communication edge ) .",
    "the combination of the two actions is called a _ communication round _ or simply a round .    in this execution scheme",
    "we have assumed that each processor executes all the calculations in one round . if it is not possible to upper bound the execution - time of the algorithm , then one may consider a slightly different network model that allows the state - transition function to be executed across multiple rounds .",
    "when this happens , the message is generated by using the processor state at the previous round .",
    "the last aspect to consider is the _ algorithm halting _ , that is a situation such that the network ( and therefore each processor ) is in a idle mode .",
    "such status can be used to indicate the achievement of a prescribed task .",
    "formally we say that a distributed algorithm is in halting status if the processor state is a fixed point for the state - transition function ( that becomes a self - loop ) and no message ( or equivalently the @xmath185 message ) is generated at each node .",
    "in this section we define distributed abstract programs , propose novel distributed algorithms for their solutions and analyze their correctness .      informally , a _ distributed abstract program _ consists of three main elements : a network , an abstract optimization program and a mechanism to distribute the constraints of the abstract program among the nodes of the network .",
    "a distributed abstract program is a tuple @xmath188 consisting of    1 .",
    "@xmath189 , a synchronous network ; 2 .",
    "@xmath52 , an abstract program ; and 3 .",
    "@xmath190 , a surjective map called _ constraint distribution map _ that associates to each constraint one network node .",
    "if the map @xmath191 is a bijection , we denote the distributed abstract program with the pair @xmath192 .",
    "solution _ of @xmath193 is attained when all network processors have computed a solution to @xmath52 .",
    "the most natural choice of constraint distribution map @xmath191 is a bijection ; in this case , ( i ) the network dimension is equal to the dimension of the abstract optimization program and ( ii ) precisely one constraint is assigned to each network node .",
    "more complex distribution maps are interesting depending on the computation power and memory of the network processors . in",
    "what follows , we typically assume @xmath191 to be a bijection .      here",
    "we propose three novel distributed algorithms that solve distributed abstract programs .",
    "first , we describe a distributed algorithm that is well - suited for time - dependent networks whose nodes have bounded computation time , memory and in - degree .",
    "equivalently , the algorithm is applicable to networks with arbitrary in - degree , but also arbitrary computation time and memory .",
    "then we describe two variations that deal with arbitrary in - degree versus short computation time and small memory .",
    "the second version of the algorithm is well - suited for time - dependent networks that have arbitrary in - degree and bounded computation time , but also arbitrary memory ( in the sense that the number of stored messages may depend on the number of nodes of the network ) .",
    "the third algorithm considers the case of time - independent networks with arbitrary in - degree and bounded computation time and memory .    in all algorithms",
    "we consider a synchronous network @xmath165 and an abstract program @xmath52 with @xmath194 and with combinatorial dimension @xmath1 .",
    "we define a distributed abstract program by assuming that constraints and nodes are in a one - to - one relationship , and we let @xmath195 be the constraint associated with network node @xmath132 . here is an informal description of our first algorithm .    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ constraints consensus algorithm _ : beside having access to the constraint @xmath195 , the @xmath132th processor state contains a candidate basis @xmath196}}$ ] consisting of @xmath1 elements of @xmath53 .",
    "the processor state @xmath196}}$ ] is initialized to @xmath1 copies of @xmath195 . at each communication round",
    ", the processor performs the following tasks : ( i ) it transmits @xmath196}}$ ] to its out - neighbors and acquires from its in - neighbors their candidate bases ; ( ii ) it solves an abstract optimization program with constraint set given by the union of : its constraint @xmath195 , its candidate basis @xmath196}}$ ] and its in - neighbors candidate bases ; ( iii ) it updates @xmath196}}$ ] to be the solution of the abstract program computed at step ( ii ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    for completeness sake , the following table presents the algorithm in a way that is compatible with the model given in section  [ subsec : networkmodel+distributedalgos ] .",
    "the @xmath152 algorithm is adopted as local solver for abstract optimization programs .    ' '' ''    width    * ` problem data : ` *    @xmath197    * ` algorithm : ` *    constraints consensus    * ` message alphabet : ` *    @xmath198    * ` processor state : ` *    @xmath196}}\\subset h$ ] with @xmath199}})=\\delta$ ]    * ` initialization : ` *    @xmath196 } } : = \\{h_i,\\dots , h_i\\}$ ]    * ` function ` * @xmath200 } } , j)$ ]    * return * @xmath196}}$ ]    * ` function ` * @xmath201 } } , y)$ ] + _ % executed by node  @xmath132 , with @xmath202}},i)={{b}^{[j]}}$ ] _ +    @xmath203 } } { \\cup}\\big (    { \\cup}_{j\\in { { { \\mathcal{n}}_{\\textup{in}}}}(i ) } y_j \\big)$ ] * return * @xmath204}})$ ]    ' '' ''    width    * * in order for the algorithm to compute a correct solution , it is necessary that each node continuously re - examine its associated constraint throughout algorithm execution . in other words ,",
    "step 1 : of the state - transition function @xmath205 in the algorithm may _ not _ be replaced by @xmath206 } } { \\cup}\\big ( { \\cup}_{j\\in      { { { \\mathcal{n}}_{\\textup{in}}}}(i ) } y_j \\big)$ ] .",
    "this continuous re - examination is required because of the lack of the persistency property discussed after lemma  [ lemma : all - is - simple - if - persistent ] .    in the second scenario",
    "we consider a time - dependent network with no bounds on the in - degree of the nodes and on the memory size . in this",
    "setting the execution of the @xmath152 may exceed the computation time allocated between communication rounds . to deal with this problem",
    ", we introduce an `` asynchronous '' version of the network model described in section  [ sec : network - modeling ] : we allow a processor to execute message - transmission and state - transition functions at instants that are not necessarily synchronized .",
    "here is an informal description of the algorithm .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ multi - round constraints consensus algorithm",
    "_ each processor has the same message alphabet , processor state , and initialization settings as in the previous _ constraints consensus algorithm_. the processor performs two tasks in parallel .",
    "task # 1 : at each communication round , the processor transmits to its out - neighbors its candidate basis @xmath196}}$ ] and acquires from its in - neighbors their candidate bases .",
    "task # 2 : independently of communication rounds , the processor repeatedly solves an abstract optimization program with constraint set given by the union of : its constraint @xmath195 , its candidate basis @xmath196}}$ ] and its in - neighbors candidate bases ; the solution of this abstract program becomes the new candidate basis @xmath196}}$ ] .",
    "the abstract program solver is invoked with the most - recently available in - neighbors candidate bases and , throughout its execution , this information does not change .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in the third scenario we consider a time - independent network with no bounds on the in - degree of the nodes .",
    "we suppose that each processor has limited memory capacity , so that it can store at most @xmath207 constraints in @xmath53 .",
    "the memory is dimensioned so as to guarantee that the abstract optimization program is always solvable during two communication rounds ( e.g. , by adopting the @xmath152 solver ) .",
    "the memory constraint is dealt with by processing only part of the incoming messages at each round , and by cycling among incoming messages in such a way as to process all the messages in multiple rounds .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cycling constraints consensus algorithm _ the processor state contains and initializes a candidate basis @xmath196}}$ ] as in the basic constraints consensus algorithm .",
    "additionally , the processor state includes a counter variable that keeps track of communication rounds . at each communication round",
    ", the processor performs the following tasks : ( i ) it transmits @xmath196}}$ ] to its out - neighbors and receives from its in - neighbors their candidate bases ; ( ii ) among the incoming messages , it chooses to store @xmath207 messages according to a scheduled protocol and the counter variable ; ( iii ) it solves an abstract optimization program with constraint set given by the union of : its constraint @xmath195 , its candidate basis @xmath196}}$ ] and the @xmath207 candidate bases from its in - neighbors ; ( iv ) it updates @xmath196}}$ ] to be the solution of the abstract program computed at step ( iii ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      we are now ready to analyze the algorithms . in",
    "what follows , we discuss correctness , halting conditions , memory complexity and time complexity .    * * [ thm : correctness - of - constraints - consensus ] let @xmath197 be a distributed abstract program with nodes and constraints in one - to - one relationship . assume the time - dependent network @xmath165 is jointly strongly connected .",
    "consider a constraint consensus algorithm in which a network node initializes its candidate basis to a constraint set with finite value .",
    "the following statements hold :    1 .",
    "[ fact : monotonicity ] along the evolution of the constraints consensus algorithm , the basis value @xmath208}}(t))$ ] at each node @xmath183 is monotonically non - decreasing and converges to a constant finite value in finite time ; 2 .",
    "[ fact : convergence ] the constraints consensus algorithm solves the distributed abstract program @xmath197 , that is , in finite time the candidate basis @xmath196}}$ ] at each node @xmath132 is a solution of @xmath79 ; and 3 .",
    "[ fact : uniqueness ] if the distributed abstract program has a unique minimal basis @xmath138 , then the final candidate basis @xmath196}}$ ] at each node @xmath132 is equal to @xmath138 .    from the monotonicity axiom of abstract optimization and from the finiteness of @xmath53",
    ", it follows that each sequence @xmath209}}(t))$ ] , @xmath210 , is monotone non - decreasing , upper bounded and can assume only a finite number of values .",
    "additionally , in finite time , each node has a candidate basis that has finite value because , by assumption , one node starts with a candidate basis with finite value and the digraph is jointly strongly connected .",
    "therefore , the constraints consensus algorithm at every node converges to a constant candidate basis with finite value in a finite number of steps .",
    "this concludes the proof of fact  [ fact : monotonicity ] . in what follows ,",
    "let @xmath211}},\\dots,{{b}^{[n]}}$ ] denote the limiting candidate bases at each node in the graph .",
    "we prove fact  [ fact : convergence ] in three steps .",
    "first , we proceed by contradiction to prove that all the nodes converge to the same value ( but not necessarily the same basis ) .",
    "the following fact is known : if a time - dependent digraph is jointly strongly connected , then the digraph contains a time - dependent directed path from any node to any other node beginning at any time , that is , for each @xmath172 and each pair @xmath169 , there exists a sequence of nodes @xmath212 and a sequence of time instants @xmath213 with @xmath214 , such that the directed edges @xmath215 belong to the digraph at time instants @xmath216 , respectively . the proof by contradiction of a closely related fact is given in ( * ? ? ? * theorem  9.3 ) . now",
    ", suppose that at time @xmath217 all the nodes have converged to their limit bases and that there exist at least two nodes , say @xmath132 and @xmath167 , such that @xmath209 } } ) \\neq     \\phi({{b}^{[j]}})$ ] . for @xmath218 , for every @xmath219 , no constraint in @xmath196}}$ ] violates @xmath220}}$ ] ,",
    "otherwise node @xmath221 would compute a new distinct basis with strictly larger value , thus violating the assumption that all nodes have converged .",
    "therefore , @xmath209 } } ) \\leq     \\phi({{b}^{[k_1]}})$ ] . using the same argument at @xmath222 , for every @xmath223 , no constraint in @xmath220}}$ ]",
    "violates @xmath224}}$ ] .",
    "therefore , @xmath209 } } ) \\leq     \\phi({{b}^{[k_1 ] } } ) \\leq \\phi({{b}^{[k_2]}})$ ] . iterating this argument",
    ", we can show that for every @xmath225 , every node @xmath226 , that is reachable from @xmath132 in the time - dependent digraph with a time - dependent directed path of length at most @xmath39 , has a basis @xmath227}}$ ] such that @xmath209 } } ) \\leq \\phi({{b}^{[k]}})$ ] .",
    "however , because the digraph is jointly strongly connected , we know that there exists a time - dependent directed path from node @xmath132 to node @xmath167 beginning at time @xmath217 , thus showing that @xmath209 } } ) \\leq \\phi({{b}^{[j]}})$ ] . repeating the same argument by starting from node @xmath167",
    "we obtain that @xmath228 } } ) \\leq \\phi({{b}^{[i]}})$ ] . in summary",
    ", we showed that @xmath209 } } ) = \\phi({{b}^{[j]}})$ ] , thus giving the contradiction .",
    "note that this argument also proves that , if @xmath169 is an edge of the digraph @xmath173 , then no constraint in @xmath132 violates @xmath229}}$ ] and , therefore , @xmath209}}{\\cup}{{b}^{[j]}})=\\phi({{b}^{[j]}})$ ] .",
    "also , the equality @xmath196}}{\\cup}{{b}^{[j]}}={{b}^{[j]}}{\\cup}{{b}^{[i]}}$ ] implies that there exists @xmath230 such that @xmath231 } } ) = \\phi({{b}^{[j ] } } )     = \\phi({{b}^{[i]}}{\\cup}{{b}^{[j ] } } )     = \\phi({{b}^{[j]}}{\\cup}{{b}^{[i]}})$ ] for all @xmath183 and @xmath169 edges of @xmath173 .",
    "second , we claim that the value of the basis at each node is equal to the value of the union of all the bases . in other words",
    ", we claim that @xmath232}}{\\cup}\\cdots { \\cup}{{b}^{[n]}}).\\ ] ] we prove equation   by induction .",
    "first , we note that @xmath233}}{\\cup}{{b}^{[j]}})$ ] for any nodes @xmath132 and @xmath167 such that either @xmath169 or @xmath234 is a directed edge in @xmath173 . without loss of generality ,",
    "let us assume @xmath235 and @xmath236",
    ". now assume that @xmath237}}{\\cup}\\cdots { \\cup}{{b}^{[k ] } } )       = \\bar{\\phi},\\ ] ] for an arbitrary @xmath226-dimensional weakly - connected subgraph @xmath238 of @xmath173 and we prove such a statement for a weakly - connected subgraph of dimension @xmath239 containing @xmath238 . by contradiction , we assume the statement is not true for @xmath239 . assuming , without loss of generality , that node @xmath239 is connected to @xmath238 in @xmath173 , we aim to find a contradiction with the statement @xmath240}}{\\cup}\\cdots { \\cup}{{b}^{[k ] } }       { \\cup}{{b}^{[k+1 ] } } )       > \\bar{\\phi}.\\ ] ] plugging the induction assumption into equation  , we have @xmath241}}{\\cup}\\cdots { \\cup}{{b}^{[k ] } } { \\cup}{{b}^{[k+1 ] } } ) >       \\phi({{b}^{[1]}}{\\cup}\\cdots { \\cup}{{b}^{[k]}}).\\ ] ] from lemma  [ lemma : locality2 ] with @xmath242}}{\\cup}\\cdots     { \\cup}{{b}^{[k]}}$ ] and @xmath243}}$ ] and noting equation  , we conclude that there exists @xmath244}}$ ] such that @xmath245}}{\\cup}\\cdots { \\cup}{{b}^{[k]}}{\\cup}\\{g\\ } ) > \\phi({{b}^{[1]}}{\\cup}\\cdots { \\cup}{{b}^{[k]}}).\\ ] ] next , select a node @xmath246 such that either @xmath247 or @xmath248 is a directed edge of @xmath173 and note that @xmath249 } } \\subset { { b}^{[1]}}{\\cup}\\cdots { \\cup}{{b}^{[k]}}$ ] and @xmath250 } } ) = \\phi (     { { b}^{[1]}}{\\cup}\\cdots { \\cup}{{b}^{[k]}})$ ] by the induction assumption . from these two facts",
    "together with equation  , the locality property implies that @xmath251}}{\\cup}\\{g\\ } ) >   \\phi({{b}^{[p]}}).\\ ] ] finally , the contradiction follows by noting : @xmath252 } } ) & \\overset{\\text{bases have converged}}{= }       \\phi({{b}^{[p]}}{\\cup}{{b}^{[k+1 ] } } )            \\overset{\\text{monotonicity}}{\\geq }       \\phi({{b}^{[p]}}{\\cup}\\{g\\ } )            \\overset{\\text{by equation}~\\eqref{eq : four } } { > } \\phi({{b}^{[p ] } } ) .",
    "\\end{aligned}\\ ] ] this concludes the proof of equation  .",
    "third and final , because no constraint in @xmath253 violates the set @xmath211}}{\\cup}\\cdots{\\cup}{{b}^{[n]}}$ ] and because @xmath211}}{\\cup}\\cdots{\\cup}{{b}^{[n ] } } \\subset h$ ] , lemma  [ lemma : locality2 ] and equation   together imply @xmath254}}{\\cup}\\cdots{\\cup}{{b}^{[n ] } } )       = \\phi(h).\\ ] ] this equality proves that in a finite number of rounds the candidate basis at each node is a solution to @xmath79 and , therefore , this concludes our proof of fact  [ fact : convergence ] .",
    "the proof of fact  [ fact : uniqueness ] is straightforward .    * * correctness of the other two versions of the constraints consensus algorithm may be established along the same lines .",
    "for example , it is immediate to establish that the basis at each node reaches a constant value in finite time .",
    "it is easy to show that this constant value is the solution of the abstract optimization program for the multi - round algorithm over a time - dependent graph . for the cycling algorithm over a time - independent graph",
    "we note that the procedure used to process the incoming data is equivalent to considering a time - dependent graph whose edges change with that law .",
    "[ thm : halting - condition ] consider a network described by a time - independent strongly - connected digraph @xmath165 implementing a constraints consensus algorithm in which a network node initializes its candidate basis to a constraint set with finite value .",
    "each processor can halt the algorithm execution if the value of its basis has not changed after @xmath255 communication rounds .    for all @xmath256 and for every @xmath169 edge of @xmath165 , @xmath257}}(t ) ) \\leq \\phi({{b}^{[j]}}(t+1)),\\ ] ] because , by construction along the constraints consensus algorithm , the basis @xmath229}}(t+1)$ ] is not violated by any constraint in the basis @xmath196}}(t)$ ] .",
    "assume that node @xmath132 satisfies @xmath196}}(t ) =    b$ ] for all @xmath258 , and pick any other node @xmath167 .",
    "without loss of generality , set @xmath259 . because of equation  , if @xmath260 , then @xmath261}}(1 ) ) \\geq \\phi(b)$ ] and , recursively , if @xmath262 , then @xmath263}}(2 ) ) \\geq    \\phi({{b}^{[k_1]}}(1 ) ) \\geq \\phi(b)$ ] .",
    "therefore , iterating this argument @xmath168 times , the node @xmath167 satisfies @xmath228}}({\\operatorname{dist}}(i , j ) ) ) \\geq \\phi(b)$ ] .",
    "now , consider the out - neighbors of node @xmath167 . for every @xmath264",
    ", it must hold that @xmath265}}({\\operatorname{dist}}(i , j)+1 ) ) \\geq    \\phi({{b}^{[j]}}({\\operatorname{dist}}(i , j)))$ ] . iterating this argument @xmath266 times",
    ", the node @xmath132 satisfies @xmath209}}({\\operatorname{dist}}(i , j)+{\\operatorname{dist}}(j , i ) ) )    \\geq \\phi({{b}^{[j]}}({\\operatorname{dist}}(i , j)))$ ] . in summary , because @xmath267 , we know that @xmath209}}({\\operatorname{dist}}(i , j)+{\\operatorname{dist}}(j , i)))=\\phi(b)$ ] and , in turn , that @xmath268}}({\\operatorname{dist}}(i , j ) ) ) \\geq \\phi(b).\\ ] ] thus , if basis @xmath132 does not change for @xmath255 time instants , then its value will never change afterwards because all bases @xmath229}}$ ] , for @xmath269 , have cost equal to @xmath270 at least as early as time equal to @xmath271 .",
    "therefore , node @xmath132 has sufficient information to stop the algorithm after a @xmath255 duration without value improvement .",
    "next , let us state some simple memory complexity bounds for the three algorithms .",
    "assume that @xmath1 is the combinatorial dimension of the abstract program @xmath52 and call a memory unit is the amount of memory required to store a constraint in @xmath53 .",
    "each node @xmath132 of the network requires @xmath272 memory units in order to implement the constraints consensus algorithm and its multi - round variation , and @xmath273 in order to implement the cycling constraints consensus algorithm .",
    "we conclude this section with some incomplete results about the _ completion time _ of the constraints consensus algorithm , i.e. , the number of communication rounds required for a solution of the distributed abstract program , and about the _ time complexity _ ,",
    "i.e. , the functional dependence of the completion time on the number of agents .",
    "first , it is straightforward to show that there exist distributed abstract programs of dimension @xmath0 for which the time complexity can be lower bounded by @xmath274 .",
    "indeed , it takes order @xmath0 communication rounds to propagate information across a path graph of order @xmath0 . on the other hand ,",
    "it is also easy to provide a _",
    "loose _ upper bound by noting that ( i ) the number of possible distinct bases for an abstract optimization program with @xmath0 constraints and combinatorial dimension @xmath1 is upper bounded by @xmath275 , and ( ii ) at each communication round at least one node in the network increases its basis .",
    "therefore , the worst - case time complexity is upper bounded by @xmath276 .",
    "it is our conjecture that the average time complexity of the constraints consensus algorithm is much better than the loose analysis we are able to provide so far .",
    "[ conjecture : linear ] over the set of time - independent strongly - connected digraphs and distributed abstract programs , the average time complexity of the constraints consensus algorithm belongs to @xmath277 .",
    "this section presents a simulation - based analysis of the time complexity of the constraints consensus algorithm for stochastically generated distributed abstract programs . to define a numerical experiment ,",
    "i.e. , a stochastically - generated distributed abstract program , we need to specify ( 1 ) the communication graph , ( 2 ) the abstract optimization problem and ( 3 ) various parameters describing a nominal set of problems and some variations of interest .",
    "we discuss these three degrees of freedom in the next three subsections and perform two sets of monte carlo analysis in the two subsequent subsections .",
    "we consider time - independent undirected communication graphs generated according to one of the following three graph models .",
    "the first model is the _",
    "line graph_. it has bounded node degree and the largest diameter . then we consider two random graphs models , namely the well - known _ erds - rnyi graph _ and _ random geometric graph_. in the erds - rnyi graph an edge is set between each pair of nodes with equal probability @xmath13 independently of the other edges .",
    "a known result  @xcite is that the average degree of the nodes is @xmath278 . also ,",
    "if @xmath279 , @xmath280 , the graph is almost surely connected and the average diameter of the graph is @xmath281 .",
    "indeed , we use the probability @xmath282 to generate the graph .",
    "this gives an average node degree that is unbounded as @xmath0 grows , but the growth is logarithmic and so the local computations are still tractable . a random geometric graph in a bounded region is generated by ( i ) placing nodes at locations that are drawn at random uniformly and independently on the region and ( ii ) connecting two vertices if and only if the distance between them is less than or equal to a threshold @xmath283 .",
    "we generate random geometric graphs in a unit - length square of @xmath113 . to obtain a connected graph we set the radius @xmath14 to the minimum value that guarantees connectivity .      in our experiments we consider stochastically - generated linear programs according to well - known models proposed in the literature .",
    "a detailed survey on stochastic models for linear programs and their use to study the performance of the simplex method is @xcite .",
    "we consider standard lps in @xmath2-dimensions with @xmath0 constraints of the form @xmath284 where @xmath285 , @xmath286 and @xmath90 are generated according to the following stochastic models .    _",
    "model a. _ in this model the elements @xmath287 and @xmath288 are independently drawn from the standard gaussian distribution .",
    "the vector @xmath289 is defined by @xmath290 , @xmath183 .",
    "this corresponds to generating hyperplanes ( corresponding to the constraints ) whose normal vectors are uniformly distributed on the unit sphere and that are at unit distance from the origin .",
    "the lp problems generated according to this model are always feasible .",
    "this model was originally proposed by  @xcite and is a special case of a class of models introduced by  @xcite see @xcite for details .",
    ", model n problems require more iterations on average than model o ones . indeed , for fixed @xmath2 and increasing @xmath0 , all constraints in model n problems are relevant , whereas many constraints in model o problems are not .",
    "]    _ model b. _ in this model the vector @xmath291 is obtained as @xmath292 .",
    "the vector @xmath293 is uniformly randomly generated in @xmath294^{2n}$ ] and @xmath26 is a standard gaussian random matrix independent of @xmath295 .",
    "the lp problems generated according to this model are always feasible .",
    "this lp model , with a more general stochastic model for @xmath295 , was proposed by todd in @xcite ( where it is the model indicated as `` model 1 '' in a collection of three ) .",
    "first , as _ nominal set of problems _ we consider a set of distributed abstract programs with the following characteristics : @xmath296 , @xmath297 , the graphs are equal to the line graphs of dimension @xmath0 , and the linear problems are generated from model a.    second , as variations of the nominal set of problems , we generate lps of dimension @xmath298 with a number of constraints @xmath299 .",
    "for each value of @xmath2 we generate a graph according to one of the three graph models and an lp according to one of the two lp models . for each configuration ( dimension , number of constraints , graph model , and lp model )",
    ", we generate different problems , we solve each problem with the constraints consensus algorithm , and we store worst - case and average completion time .",
    "results for the nominal set of problems and for its variations are given in the next sections .",
    "for the nominal set of problems , we study the time complexity via the student @xmath174-test and via monte carlo probability estimation .    for each value of @xmath0 , we perform a student s @xmath174-test with the null hypothesis being that the average completion time divided by the graph diameter is greater than @xmath300  against the alternate hypothesis that the same ratio is less than or equal to that ( at the @xmath301 confidence level ) .",
    "( note that the diameter is @xmath302 . )",
    "the results for @xmath303 are shown in table  [ tab : ttest ] .",
    "the tests show that we can reject the null hypothesis . in figure",
    "[ fig : nst_vs_n_line ] we show the linear dependence of the completion time with respect to the number of agents ( and therefore with respect to the diameter ) and provide the corresponding @xmath301 confidence intervals .",
    ".student s t - test results for demonstrating the linear dependence of the completion time with respect to the diameter .",
    "problem : graph = line graph , lp model = model a , @xmath296 , @xmath303 , @xmath304 , null hypothesis : average completion time @xmath305 . [ cols=\"^,^,^,^,^,^ \" , ]     . specifically : graph = line graph , lp model = model a , @xmath296 , @xmath297 , @xmath304 , performance = average .",
    "the solid line is the least - square interpolation of the average completion times . ]",
    "next , we aim to upper bound the worst - case completion time .",
    "to do so we use a monte carlo probability estimation method , that we review from  @xcite .",
    "[ rem : probability - estimation - via - montecarlo ] we aim to estimate the probability that a random variable is less than or equal to a given threshold .",
    "let @xmath306 be a compact set and @xmath307 be a random variable taking values in @xmath306 .",
    "given a scalar threshold @xmath308 , define the probability @xmath309 , where @xmath310 is a given measurable performance function .",
    "we estimate @xmath311 as follows .",
    "first , we generate @xmath31 independent identically distributed random samples @xmath312 .",
    "second , we define the indicator function @xmath313 by @xmath314 if @xmath315 , and @xmath20 otherwise . third and final , we compute the _ empirical probability _ as @xmath316 next , we adopt the chernoff bound in order to provide a bound on the number of random samples required for a certain level of accuracy on the probability estimate . for any accuracy @xmath317 and confidence level @xmath318 , we know that @xmath319 with probability greater than @xmath320 if @xmath321 for @xmath322 , the chernoff bound   is satisfied by @xmath323 samples .    adopting the same notation as in remark  [ rem : probability - estimation - via - montecarlo ] , here",
    "is our setup : first , the random variable of interest is a collection of @xmath0 unit - length vectors ( i.e. , our random variable takes values in the compact space @xmath324 ) .",
    "second , the function @xmath325 is the completion time of the constraints consensus algorithm in solving a nominal problem with constraints determined by @xmath307 .",
    "third , we want to estimate the probability that , for @xmath326 , the completion time is less than or equal to @xmath115 times the diameter of the chain graph of dimension @xmath0 . in order to achieve an accuracy @xmath327 with confidence level @xmath328 , we run @xmath329 experiments for each value of @xmath0 and we compute the maximum completion time in each case .",
    "the experiments show that for each @xmath0 the worst - case completion time is less than @xmath330 times the graph diameter .",
    "therefore , we have established the following statement .    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ with @xmath328 confidence level , there is at least @xmath328 probability that a nominal problem ( @xmath296 , graph = line graph , lp model = model a ) with number of constraints @xmath326 is solved by the constraints consensus algorithm in time upper bounded by @xmath331 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      next we perform a comparison among different graph models , lp models and lp dimensions . in order to compare the performance of different graphs we consider problems with : graph @xmath332 \\{line graph , erds - rnyi graph , random geometric graph } , lp model = model a , @xmath296 , @xmath297 , @xmath304 .",
    "we compute the average completion time to diameter ratio for increasing values of @xmath0 .",
    "the results with the @xmath301 confidence interval are shown in figure  [ fig : nst_vs_n_graph ] .    .",
    "specifically : graph @xmath332 \\{line graph ( circle ) , erds - rnyi graph ( square ) , random geometric graph ( diamond ) } , lp model = model a , @xmath296 , @xmath297 , @xmath304 , performance = average . ]    .",
    "[ fig : nst_vs_n_graph ]    to compare the performance for different lp models , we consider problems with : graph = line graph , lp model @xmath332 \\{model a , model b } , @xmath296 , @xmath297 , @xmath304 . the results with the @xmath301 confidence interval are shown in figure  [ fig : nst_vs_n_line_lp ] .    .",
    "specifically : graph = line graph , lp model @xmath332 \\{model a ( circle ) , model b ( diamond ) } @xmath333 , @xmath297 , @xmath304 , performance = average . ]    .",
    "[ fig : nst_vs_n_line_lp ]    next , to compare the performance for different dimensions @xmath2 , we consider problems with : graph = line graph , lp model = model a , @xmath298 , @xmath297 , @xmath304 . the results with the @xmath301 confidence interval are shown in figure  [ fig : nst_vs_n_line_dim ] .",
    "the comparisons show that , the linear dependence of the completion time with respect to the number of constraints is not affected by the graph topology , the lp model and the dimension @xmath2 . as regards the dimension @xmath2 , as expected , for fixed @xmath0 the average completion time grows with the dimension . also , the growth appears to be linear for @xmath334 ( for @xmath335 the algorithm seems to perform much better ) . in figure",
    "[ fig : nstdiam_vs_d_line ] we plot the least square value of the completion time to diameter ratio over the number of agents @xmath0 versus the dimension @xmath2 .     and for increasing number of constraints @xmath0 . specifically :",
    "graph = line graph , lp model = model a , @xmath336 , @xmath297 , @xmath304 , performance = average . ]    .",
    "[ fig : nst_vs_n_line_dim ]    ) for increasing problem dimensions @xmath2 . specifically :",
    "graph = line graph , lp model = model a , @xmath298 , @xmath297 , @xmath304 , performance = average . ]    .",
    "[ fig : nstdiam_vs_d_line ]",
    "in this section we discuss an application of distributed abstract programming to sensor networks , namely a distributed solution for target localization . essentially , we propose a distributed algorithm to approximately compute the intersection of time - varying convex polytopes .",
    "we consider a target moving on the plane with unknown but bounded velocity .",
    "the first - order dynamics is given by @xmath337 where @xmath338\\times[{{{y}_{\\textup{min}}}},{{{y}_{\\textup{max}}}}]}\\subset{{\\mathbb{r}}}^2 $ ] is the target position at time @xmath256 and @xmath339 is unknown but satisfies @xmath340 for given @xmath341 .",
    "a set of sensors @xmath163 deployed in the environment measures the target position .",
    "we assume that the measurement noise is unknown and such that , at each time instant , each sensor @xmath132 measures a possibly - unbounded region of the plane , @xmath342}}(p(t ) ) \\subset { { \\mathbb{r}}}^2 $ ] , containing the target . the set @xmath343}}(p(t))$ ] , called the measurement set , provides the best estimate of the target position based on instantaneous measures only .",
    "an example scenario is illustrated in figure  [ fig : target - localization - scen ] . in what follows",
    ", we make a critical assumption and a convenient one .",
    "first , we assume that each measured region @xmath342}}(p(t))$ ] is a possibly - unbounded convex polygon .",
    "second , for simplicity of notation , we assume that each measured region @xmath342}}(p(t))$ ] is a half - plane , so that the measurement set @xmath344 is a non - empty possibly - unbounded convex polygon equal with up to @xmath0 edges .     sensor measurements . ]",
    "compute the smallest set @xmath345 that contains the target position @xmath346 at @xmath180 and that is consistent with the dynamic model   and the sensor measurements @xmath342}}(p(t))$ ] , @xmath183 .",
    "we adopt the _ set - membership approach _ described in  @xcite . for @xmath347 , define the sets @xmath348 and @xmath349 as the _ feasible position sets _ containing all the target positions at time @xmath174 that are compatible with the dynamics and the available measurements up to time @xmath350 and @xmath174 , respectively . with this notation ,",
    "the recursion equations are :    [ eq : set_memb_recurs ] @xmath351    where the sum set of two sets @xmath352 is defined as @xmath353 .",
    "equation   is justified as follows : since the target speed satisfies @xmath354 , if the target is at position @xmath13 at time @xmath174 , then the target must be inside @xmath355 at time @xmath356 , for any positive @xmath357 .",
    "equation   is a direct consequence of the definition of measurement set .",
    "equations  ,  , and   are referred to as _ initialization _ , _ time update _ and _ measurement update _ , respectively .",
    "the time and measurement updates are akin to prediction and correction steps in kalman filtering .",
    "running the recursion   in its exact form is often computationally intractable due to the large and increasing amount of data required to describe the sets @xmath348 and @xmath349 . to reduce the computational complexity one typically over - approximates these sets with bounded - complexity simple - structure sets , called _ approximating sets_. for example , a common approximating set is the _ axis - aligned bounding box _",
    ", i.e. , the smallest rectangle aligned with the reference axes containing the set . if @xmath358 denotes the projection from the subsets of @xmath113 onto the collection of approximating sets , then the recursion   is rewritten as    [ eq : set_memb_recurs_approx ] @xmath359    where now the sets @xmath348 and @xmath349 are only approximations of the feasible position sets .      in this section we propose a convenient choice of approximating sets for set - membership localization and we discuss the corresponding time and measurement updates .",
    "we begin with some preliminary notation .",
    "we let @xmath360 be the set containing all possible collections of @xmath226 half - planes ; in other words , an element of @xmath360 is a collection of @xmath226 half - planes . given an angle @xmath361 and a set of half - planes @xmath362 with @xmath363 , define the linear program @xmath364 by @xmath365 \\cdot x\\\\      { \\text{subject to}}&\\quad a_i^t x \\leq b_i , \\quad i\\in{\\{1,\\dots , k\\ } } , \\\\      & \\quad { { { x}_{\\textup{min}}}}\\leq{x}\\leq{{{x}_{\\textup{max } } } } , \\quad { { { y}_{\\textup{min}}}}\\leq{y}\\leq{{{y}_{\\textup{max}}}}.    \\end{split}\\ ] ] as in example  [ ex : abstract - framework - for - lp ] , transcribe @xmath364 into an abstract optimization program @xmath366 . recall that @xmath366 is basis regular and has combinatorial dimension @xmath367 , so that its solution , i.e.",
    ", the lexicographically - minimal minimum point of @xmath364 , is always a set of @xmath367 constraints , say @xmath368}}_{h,\\theta}$ ] and @xmath369}}_{h,\\theta}$ ] .",
    "in other words , the pair @xmath370}}_{h,\\theta},{{h}^{[2]}}_{h,\\theta}\\ } \\in { \\mathcal{h}}_2 $ ] is computed as a function of an angle @xmath361 and of a @xmath226-tuple @xmath371 .",
    "now , as collection of approximating sets we consider the set @xmath372 containing the collections of @xmath373 half - planes .",
    "note that the subset of elements @xmath374 such that @xmath375 is bounded is in bijection with the set of convex polygons with at most @xmath373 edges .",
    "additionally , for arbitrary @xmath226 , we define the projection map @xmath376 as follows : given @xmath377 , define @xmath378 to be the collection of half - planes @xmath368}}_{h,\\theta}$ ] and @xmath369}}_{h,\\theta}$ ] , for @xmath379 .",
    "note that our approximating set @xmath380 contains @xmath53 and is contained in the smallest axis - aligned bounding box containing @xmath53 ; additionally , note that @xmath380 contains some possibly repeated half - planes because the same half - plane could be part of the solution for distinct values of @xmath381 .",
    "our definition of @xmath382 has the following interpretation : assuming the target is known to satisfy all half - plane constraints in a set @xmath53 , the reduced - complexity possibly - unbounded polygon containing the target is computed by solving four linear programs @xmath364 , @xmath383 ; see figure  [ fig : target - localization - bounding - rectangle ] .    .",
    "the dashed rectangle is the smallest axis - aligned bounding box containing the measurement set . ]",
    "finally , we review the approximated set - membership localization recursion  .",
    "we assume @xmath342}}(t ) = { \\{x\\in{{\\mathbb{r}}}^2 \\ ; | \\ ; { { a}^{[i]}}(t)^tx\\leq{{b}^{[i]}}(t ) ,    { \\|a_i\\|}{}=1\\}}$ ] is the half - plane containing the target measured by sensor @xmath183 at time @xmath180 .",
    "the approximated feasible position sets , elements of @xmath372 , are @xmath384    _ initialization : _",
    "equation   reads @xmath385}}(0),\\dots,{{h}^{[n]}}(0)\\ } \\big).\\ ] ]    _ time update : _ assume @xmath386 , that is , @xmath387 is characterized by the coefficients @xmath388 . since the target speed satisfies @xmath354 , at instant @xmath356 the target",
    "is contained in the half - planes @xmath389 therefore , the time update consists in defining each @xmath390 to be @xmath391 ; we refer to this operation as to a _ time - translation _ by an amount @xmath341 of the half - plane @xmath387 .",
    "this time - update operation is equivalent to equation   and does not explicitly require an application of the projection @xmath382 .",
    "_ measurement update : _ equation   reads @xmath392 where the collection of constraints at time @xmath174 is @xmath393}}(t),\\dots,{{h}^{[n]}}(t)\\}.\\ ] ]    1 .   during each iteration of the localization recursion ,",
    "the time update step requires @xmath373 sums and the measurement update steps requires the solution of @xmath115 linear programs in @xmath367 variables and @xmath394 constraints .",
    "similar localization algorithms arise by selecting @xmath395 and by solving @xmath396 lp at each iteration parametrized by @xmath397 .",
    "larger values of @xmath396 lead to tighter approximating polygons .",
    "we consider a scenario in which the sensors measuring the target position also have computation and communication capabilities so that they form a synchronous network as described in section  [ sec : network - modeling ] .",
    "let @xmath398 be the undirected communication graph among the sensors @xmath163 ; assume @xmath165 is connected . assume the sensors communicate at each time @xmath180 and perform measurements of the target at unspecified times in @xmath399 ( communication takes place at higher rate than sensing ) . for simplicity , we assume the first measurement at each node happens at time @xmath20 .",
    "we aim to design a distributed algorithm for the sensor network to localize a moving target .",
    "the idea is to run _ local set - membership recursions _ ( with time and measurement updates ) at each node while exchanging constraints in order to achieve constraints consensus on a set - membership estimate .",
    "distributed constraint re - examination is obtained as follows : at each time , each node keeps in memory the last @xmath400 measurements it took and , after an appropriate time - update , re - introduces them into the @xmath382 computation . we begin with an informal description .    _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ eight half - planes consensus algorithm _ : the processor state at each processor @xmath132 contains a set @xmath401}_{\\textup{optimal}}}$ ] of @xmath373 candidate optimal constraints and a set @xmath401}_{\\textup{sensed}}}$ ] containing the last @xmath400 measurements , for some @xmath402 .",
    "these sets are initialized to the first sensor measurement . at each communication round",
    ", the processor performs the following tasks : ( i ) it transmits @xmath401}_{\\textup{optimal}}}$ ] to its out - neighbors and acquires from its in - neighbors their candidate constraints ; ( ii ) it performs a time - update , that is , a time - translation by an amount @xmath403 , of all candidate optimal , measured and received constraints ; ( iii ) it updates the set of measured constraints if a new measurement is taken ; and ( iv ) it updates @xmath401}_{\\textup{optimal}}}$ ] to be the projection @xmath382 of all candidate optimal , measured and received constraints . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    next we give a pseudo - code description .    ' '' ''    width    * ` problem data : ` *    a network @xmath404 of sensors that measure half - plane constraints    * ` algorithm : ` *    eight half - planes consensus    * ` message alphabet : ` *    @xmath405    * ` processor state : ` *    @xmath401}_{\\textup{optimal } } } \\in { \\mathcal{h}}_8 $ ] + @xmath401}_{\\textup{sensed } } } \\in { \\mathcal{h}}_m$ ] for some @xmath402    * ` initialization : ` *    @xmath401}_{\\textup{optimal } } } : = \\{{{h}^{[i]}}(0),\\dots,{{h}^{[i]}}(0)\\}$ ] + @xmath401}_{\\textup{sensed } } } : = \\{{{h}^{[i]}}(0),\\dots,{{h}^{[i]}}(0)\\}$ ]    * ` function ` * @xmath406}_{\\textup{optimal } } } , { h^{[i]}_{\\textup{sensed } } } ) , j\\big)$ ]    * return * @xmath401}_{\\textup{optimal}}}$ ]    * ` function ` * @xmath407}_{\\textup{optimal } } } , { h^{[i]}_{\\textup{sensed } } } ) , y\\big)$ ] + _ % executed by node  @xmath132 , with @xmath408}_{\\textup{optimal}}}$ ] _ +    time - translate by an amount @xmath403 all constraints constraints in @xmath401}_{\\textup{sensed}}}$ ] , @xmath401}_{\\textup{optimal}}}$ ] , and @xmath409    add it to @xmath401}_{\\textup{sensed}}}$ ] ; drop oldest measurement from @xmath401}_{\\textup{sensed}}}$ ]    set @xmath401}_{\\textup{optimal } } } : = { \\pi_{\\textup{lp}}}\\big ( { h^{[i]}_{\\textup{sensed } } } { \\cup}{h^{[i]}_{\\textup{optimal } } } { \\cup}_{j\\in { { { \\mathcal{n}}_{\\textup{in}}}}(i ) } y_j \\big)$ ]    * return * @xmath410}_{\\textup{optimal}}},{h^{[i]}_{\\textup{sensed}}})$ ]    ' '' ''    width    finally , we collect some straightforward facts about this algorithm ; we omit the proof in the interest of brevity .    * * consider a connected network @xmath404 of sensors that measure half - plane constraints and that implement the eight half - plane consensus algorithm .",
    "assume the target does not move , that is , set @xmath411 .",
    "the following statements hold :    1 .",
    "the candidate optimal constraints at each node contain the target at each instant of time ; 2 .",
    "the candidate optimal constraints at each node monotonically improve over time ; and 3 .   additionally , if each node makes at most @xmath400 measurements in finite time , then the candidate optimal constraints at each node converge in finite time to the globally optimal @xmath373 half - plane constraints .",
    "next , let us state some memory complexity bounds for the eight half - plane consensus algorithm .",
    "again , we adopt the convention that a memory unit is the amount of memory required to store a constraint in @xmath53 .",
    "each node @xmath132 of the network requires @xmath412 memory units in order to implement the algorithm .",
    "if we assume that number @xmath400 of stored measurements is independent of @xmath0 and that the indegree of each node is bounded irrespectively of @xmath0 , then the algorithm memory complexity is in @xmath413 .",
    "vice - versa , in worst - case graphs , the algorithm memory complexity is in @xmath4 .",
    "in this section we apply constraints consensus ideas to formation control problems for networks of mobile robots .",
    "we focus on formations with the shapes of a point , a line , or a circle .",
    "( the problem of formation control to a point is usually referred to as the rendezvous or gathering problem . )",
    "we solve these formation control problems in a time - efficient manner via a distributed algorithm regulating the communication among robots and the motion of each robot .",
    "we define a robotic network as follows .",
    "each robot is equipped with a processor and robots exchange information via a communication graph .",
    "therefore , the group of robots has the features of a synchronous network and can implement distributed algorithms as defined in section  [ sec : network - modeling ] .",
    "however , as compared with a synchronous network , a robotic network has two distinctions : ( i ) robots control their motion in space , and ( ii ) the communication graph among the robots depends upon the robots positions , rather than time .    specifically , the _ robotic network _ evolves according to the following discrete - time communication , computation and motion model .",
    "each robot @xmath183 moves between rounds according to the first order discrete - time integrator @xmath414}}(t+1 ) = { { p}^{[i]}}(t ) + { { u}^{[i]}}(t)$ ] , where @xmath414}}\\in{{\\mathbb{r}}}^2 $ ] and @xmath415}}\\|^2\\leq { { { u}_{\\textup{max}}}}>0 $ ] . at each discrete time instant , robots at positions @xmath416 communicate according to the disk graph @xmath417 defined as follows : an edge @xmath418 , @xmath419 , belongs to @xmath420 if and only if @xmath421}}-{{p}^{[j]}}\\|}{}\\leq { { { r}_{\\textup{cmm}}}}$ ] for some @xmath422 .    a _ distributed algorithm for a robotic network _",
    "consists of ( 1 ) a distributed algorithm for a synchronous network , that is , a processor state , a message alphabet , a message - generation and a state - transition function , as described in section  [ sec : network - modeling ] , ( 2 ) an additional function , called the _ control function _",
    ", that determines the robot motion , with the following domain and co - domain : @xmath423 additionally , we here allow the message generation and the state transition to depend upon not only the processor state but also the robot position .",
    "the state of the robotic network evolves as follows .",
    "first , at each communication round @xmath174 , each processor @xmath132 sends to its outgoing neighbors a message computed by applying the message - generation function to the current values of @xmath414}}$ ] and @xmath182}}$ ] . after a negligible period of time",
    ", the @xmath132th processor resets the value of its processor state @xmath182}}$ ] by applying the state - transition function to the current values of @xmath414}}$ ] and @xmath182}}$ ] , and to the messages received at time @xmath174 .",
    "finally , the position @xmath414}}$ ] of the @xmath132th robot at time @xmath174 is determined by applying the control function to the current value of @xmath414}}$ ] and @xmath182}}$ ] , and to the messages received at time @xmath174 .    in formal terms , if @xmath424}}(t)$ ] denotes the message vector received at time @xmath174 by agent @xmath132 ( with @xmath424}}_j(t)$ ] being the message received from agent @xmath167 ) , then the evolution is determined by @xmath425}}_j(t ) & = { \\textup{msg}}(p^{[j]}(t-1),w^{[j]}(t-1),i),\\\\          { { w}^{[i]}}(t ) &      = { \\textup{stf}}(p^{[i]}(t-1),{{w}^{[i]}}(t-1 ) , y^{[i]}(t ) ) , \\\\",
    "p^{[i]}(t ) & = p^{[i]}(t-1 ) +      { \\textup{ctl}}(p^{[i]}(t-1 ) , { { w}^{[i]}}(t ) , y^{[i]}(t ) ) ,    \\end{split}\\ ] ] with the convention that @xmath426}(t-1),w^{[j]}(t-1),i)={\\textup{\\texttt{null}}\\xspace}$ ] if @xmath427}(t-1),\\dots , p^{[n]}(t-1))$ ] .",
    "numerous definitions of robot formation are considered in the multi - agent literature .",
    "here we consider a somehow specific situation .",
    "let @xmath428 , @xmath429 , and @xmath430 be the set of points , lines and circles in the plane , respectively .",
    "we refer to these three sets as the _ shape sets_. we aim to lead all robots in a network to a single element of one of the shape sets if @xmath39 is a selected shape set , the _ formation task _ is achieved by the robotic network if there exists a time @xmath431 such that for all @xmath432 , all robots @xmath183 satisfy @xmath414}}(t ) \\in s$ ] for some element @xmath433 . specifically , the _ point - formation , or rendezvous task _ requires all connected robots to be at the same position , the _ line - formation task _ requires all connected robots to be on the same line , and the _ circle - formation task _ requires all connected robots to be on the same circle .",
    "we are interested in distributed algorithms that achieve such formation tasks optimally with respect to a suitable cost function .",
    "for the point - formation and line - formation tasks , we aim to minimize completion time , i.e. , the time required by all robots to reach a common shape . for the circle - formation task , we aim to minimize the product between the time required to reach a common circle , and the diameter of the common circle .    for the circle - formation problem we do not select the completion time as cost function , because of the following reasons .",
    "the centralized version of the minimum time circle - formation problem is equivalent to finding the minimum - width annulus containing the point - set . for arbitrary data sets , the minimum - width annulus has arbitrarily large minimum radius and bears similarities with the solution to the smallest stripe problem . for some configurations ,",
    "all points are contained only in a small fraction of the minimum - width annulus ; this is not the solution we envision when we consider moving robots in a circle formation .",
    "therefore , we consider , instead , the smallest - area annulus .",
    "this cost function penalizes both the difference of the radiuses of the annulus ( width of the annulus ) and their sum .    the key property of the _ minimum - time point - formation task _ , _ minimum - time line - formation task _ , and _ optimum circle - formation task",
    "_ is that their centralized versions are equivalent to finding the smallest ball , stripe and annulus , respectively , enclosing the @xmath0 agents initial positions .",
    "we state these equivalences in the following lemma without proof .",
    "given a set of distinct points @xmath434 , consider the three optimization problems : @xmath435 where @xmath436 denotes the radius of the circle @xmath291 .",
    "these three optimization problems are equivalent to the smallest enclosing ball , the smallest enclosing stripe ( for points in stripe - generic position ) , and the smallest enclosing annulus problem , respectively .    therefore , they are abstract optimization problems with combinatorial dimension @xmath437 , @xmath114 and @xmath115 , respectively .",
    "we conclude this section with some useful notation .",
    "we let @xmath438 denote the point , the line or the circle equidistant from the boundary of the smallest enclosing ball , stripe or annulus , respectively .",
    "we assume that the robotic network is connected at initial time , i.e. , that the graph @xmath439 is connected , and we aim to achieve the formation task while guaranteeing that the state - dependent communication graph remains connected during the evolution .",
    "the following connectivity maintenance strategy was originally proposed in  @xcite and a comprehensive discussion is in  @xcite . the key idea is to restrict the allowable motion of each robot so as to preserve the existing edges in the communication graph .",
    "we present this idea in three steps .",
    "first , in a network with communication edges @xmath440 , if agents @xmath132 and @xmath167 are neighbors at time @xmath256 , then we require that their positions at time @xmath441 belong to @xmath442}}(t ) , { { p}^{[j]}}(t ) ) =    { b\\big(\\frac{{{p}^{[i]}}(t)+{{p}^{[j]}}(t)}{2},{\\frac{1}{2}}{{{r}_{\\textup{cmm}}}}\\big)}.\\ ] ] if all neighbors of agent @xmath132 at time @xmath174 are at locations @xmath443}}(t ) = \\{q_1,\\dots , q_l\\}$ ] , then the ( convex ) _ constraint set _ of agent @xmath132 is @xmath442}}(t ) , { { q}^{[i]}}(t ) )      = \\bigcap_{q\\in \\{q_1,\\dots , q_l\\ } }      { b\\big(\\frac{{{p}^{[i]}}(t)+q}{2},{\\frac{1}{2}}{{{r}_{\\textup{cmm}}}}\\big)}.\\ ] ]    second , given @xmath13 and @xmath444 in @xmath113 and a convex closed set @xmath445 with @xmath446 , we introduce the _ from - to - inside _ function , denoted by @xmath447 and illustrated in figure  [ fig : fti ] , that computes the point in the closed segment @xmath448 $ ] which is at the same time closest to @xmath444 and inside @xmath306 .",
    "formally , @xmath449 { \\ensuremath{\\operatorname{\\cap}}}\\partial q , \\quad &   \\text{if } q\\notin q.      \\end{cases}\\ ] ]     function ; courtesy of the authors of  @xcite.,title=\"fig : \" ]    function ; courtesy of the authors of  @xcite.,title=\"fig : \" ]    third and final , we assume that , independent of whatever control algorithm dictates the robots evolution , if @xmath414}}_{\\text{target}}(t)$ ] denote the desired target positions of agent @xmath132 at time @xmath441 , then we allow robot @xmath132 to move towards that location only so far as the constraint set allows .",
    "this is encoded by : @xmath450}}(t+1 ) = { \\text{fti}}({{p}^{[i]}}(t ) ,    { { p}^{[i]}}_{\\text{target}}(t ) , { \\mathcal{x}}({{p}^{[i]}}(t ) ,    { { q}^{[i]}}(t ) ) ) .\\ ] ]      the minimum - time point - formation , minimum - time line - formation , and optimum circle formation tasks appear intractable in their general form due to the state - dependent communication constraints .",
    "to attack these problem , we search for an efficient strategy that converges to the optimal one when the upper bound on the robot speed @xmath451 goes to zero or , in other words , when information transmission tends to be infinitely faster than motion . to design such a strategy",
    ", we aim to reach consensus on the centralized solution to the problem , i.e. , the optimal shape , and use the solution as a reference for the agents motion .",
    "a simple sequential solution is as follows : first , the agents compute the optimal shape via constraints consensus , and then , when consensus is achieved , they move toward the closest point in the target shape ( point , line or circle ) .",
    "an improved strategy allows concurrent execution of constraints consensus and motion : while the constraints consensus algorithm is running , each agent moves toward the estimated target position while maintaining connectivity of the communication graph .",
    "we first provide an informal description .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ move - to - consensus - shape strategy _ : the processor state at each robot @xmath132 consists of a set @xmath196}}$ ] of @xmath1 candidate optimal constraints and a binary variable @xmath452}}\\in\\{0,1\\}$ ] . the set @xmath196}}$ ] is initialized to @xmath414}}(0)$ ] and @xmath452}}$ ] is initialized to @xmath20 .",
    "at each communication round , the processor performs the following tasks : ( i ) it transmits @xmath414}}$ ] and @xmath196}}$ ] to its neighbors and acquires its neighbors candidate constraints and their current position ; ( ii ) it runs an instance of the constraints consensus algorithm for the geometric optimization program of interest ( smallest enclosing ball , stripe or annulus ) ; if the constraints consensus halting condition is satisfied , it sets @xmath452}}$ ] to @xmath21 ; ( iii ) it computes a robot target position based on the current estimate of the optimal shape ; ( iv ) it moves the robot towards the target position while respect input constraint and , if @xmath452}}$ ] is still zero , enforcing connectivity with its current neighbors .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    next we give a pseudo - code description .",
    "we let @xmath453}}(0),\\ldots,{{p}^{[n]}}(0)\\}$ ] .    ' '' ''",
    "width    * ` problem data : ` *    a robotic network and a shape set    * ` algorithm : ` *    move - to - consensus - shape    * ` message alphabet : ` *    @xmath454    * ` processor state : ` *    @xmath196 } } \\subset p_n(0)$ ] with @xmath199}})=\\delta$ ] + @xmath455}}\\in\\{0,1\\}$ ]    * ` physical state : ` *    @xmath414 } } \\in { { \\mathbb{r}}}^2 $ ]    * ` initialization : ` *    @xmath196 } } : = \\{{{p}^{[i]}}(0),\\dots,{{p}^{[i]}}(0)\\}$ ] + @xmath455}}:=0 $ ]    * ` function ` * @xmath456}},{{b}^{[i]}},j\\big)$ ]    * return * @xmath457}},{{b}^{[i]}})$ ]    * ` function ` * @xmath458 } } , { { \\texttt{halt}}^{[i ] } } , y\\big)$ ] + _ % executed by node  @xmath132 , with @xmath459}},{{b}^{[j ] } } )    : = { \\textup{msg}}({{b}^{[j]}},i)$ ]",
    "_ +    @xmath460}}(0)\\ } { \\cup}{{b}^{[i ] } } { \\cup}\\big (    { \\cup}_{j\\in { { { \\mathcal{n}}_{\\textup{in}}}}(i ) } { { b}^{[j ] } } \\big)$ ] @xmath196 } } : = { \\textup{\\texttt{subex\\_lp } } } ( { { s}_{\\textup{tmp } } } , { { b}^{[i]}})$ ] * if * @xmath196}}$ ] has not changed for @xmath461 rounds , * then * @xmath455}}:=1;$ ] * end if * * return * @xmath462 } } , { { \\texttt{halt}}^{[i]}})$ ]    * ` function ` * @xmath463 } } , { { p}^{[i ] } } , y\\big)$ ] + _ % executed by node  @xmath132 , with @xmath459}},{{b}^{[j ] } } )    : = { \\textup{msg}}({{b}^{[j]}},i)$ ] _ + _ % map ` target_set ` defined in section  [ sec : mintime - formation_optimal - formation ] _ +    @xmath464}})$ ] + @xmath465 } } - p\\|}{}$ ] * if * @xmath455}}=0 $ ] , * then * + @xmath466}}+{{p}^{[j]}}}{2},{\\frac{1}{2}}{{{r}_{\\textup{cmm}}}}\\big ) }    \\bigcap { b\\big({{p}^{[i]}},{{{u}_{\\textup{max}}}}\\big)}$ ] + * else * @xmath467}},{{{u}_{\\textup{max}}}}\\big)};$ ] * end if * * return * @xmath468 } } , { { p}_{\\textup{trgt } } } , { { { \\mathcal{x}}}_{\\textup{cnstr}}})-{{p}^{[i]}}$ ]    ' '' ''    width    we refer the interested reader to  @xcite for numerical simulation results for the move - to - consensus - shape strategy . finally , we state the correctness of the algorithm and omit the proof in the interest of brevity .    * * on a robotic network with communication graph @xmath469 and bounded control inputs @xmath451 , the move - to - consensus - shape strategy achieves the desired formation control tasks .    in the limit as @xmath470 , the move - to - consensus - shape strategy solves the optimal formation control tasks , i.e. , the minimum - time point - formation , minimum - time line - formation , and optimum circle formation tasks .",
    "we have introduced a novel class of distributed optimization problems and proposed a simple and intuitive algorithmic approach . additionally , we have rigorously established the correctness of the proposed algorithms and presented a thorough monte carlo analysis to substantiate our conjecture that , for a broad variety of settings , the time complexity of our algorithms is linear .",
    "finally , we have discussed in detail two modern applications : target localization in sensor networks and formation control in robotic networks .",
    "promising avenues for further research include proving the linear - time - complexity conjecture , as well as applying our algorithms to ( i ) optimization problems for randomly switching graphs and gossip communication , ( ii ) distributed machine learning problems  @xcite , and ( iii ) convex quadratic programming  @xcite . additionally , it is of interest to verify the performance of our proposed target localization and formation control algorithms in experimental setups .      in this appendix",
    "we consider the smallest enclosing stripe problem in example  [ rem : examples ] for stripe - generic points and show that is satisfies the abstract optimization axioms .",
    "we begin with some notation .",
    "let @xmath53 be the set of constraints , i.e. , the set of points in the plane for which we aim to compute the smallest enclosing stripe . with a slight abuse of notation",
    ", @xmath66 denotes both a constraint and a point depending on the context .",
    "let @xmath60 , @xmath59 , be the width of the smallest stripe enclosing the points in @xmath61 .",
    "a constraint @xmath77 is violated by the set @xmath61 , i.e. , @xmath471 , if the point @xmath77 does not belong to the smallest stripe enclosing @xmath61 .",
    "first , note that three points are necessary , but in general not sufficient , to uniquely identify the smallest enclosing stripe of a set @xmath53 of three or more points .",
    "indeed , the boundary of the smallest stripe enclosing @xmath53 contains at least three points of @xmath53 , e.g. , point @xmath472 on one line and points @xmath473 on the other line .",
    "so , the smallest enclosing stripe identifies the triplet @xmath474 .",
    "however , a simple geometric argument shows that the converse is not true , i.e. , three points are not sufficient .",
    "three points would be sufficient if the triplet was an ordered set and uniquely identified a stripe .",
    "to uniquely identify the smallest enclosing stripe for a set @xmath53 of five or more points , one needs to add to the triplet @xmath474 another two points of @xmath53 that belong to the correctly stripe among the three stripes determined by @xmath474 . in summary",
    ", this discussion shows that the combinatorial dimension is @xmath114 .",
    "second , we prove that the two axioms of abstract optimization are satisfied . as usual , monotonicity is trivially satisfied , thus we need to prove locality .",
    "suppose , by contradiction , that locality does not hold .",
    "therefore there exist @xmath116 , @xmath61 and @xmath77 , @xmath475 and @xmath66 , with @xmath476 such that @xmath477 and @xmath478 .",
    "let @xmath479 and @xmath480 be the smallest stripes for @xmath61 and @xmath116 , so that @xmath481 and @xmath482 are the ordered triplets of points defining @xmath479 and @xmath480 , respectively .",
    "since @xmath77 is violated by @xmath61 but not by @xmath116 , this means that @xmath77 belongs to @xmath480 but not to @xmath479 .",
    "therefore , the stripes @xmath479 and @xmath480 must be different , i.e. , @xmath483 . because the points are in stripe - generic positions , we know that @xmath484 and , therefore , @xmath485 .",
    "this proves the contradiction .",
    " , `` network abstract linear programming with application to cooperative target localization , '' in _ modelling , estimation and control of networked complex systems _ , ser . understanding complex systems , a.  chiuso , l.  fortuna , m.  frasca , l.  schenato , and s.  zampieri , eds.1em plus 0.5em minus 0.4emspringer , 2009 , pp . 177190",
    ".    j.  n. tsitsiklis , d.  p. bertsekas , and m.  athans , `` distributed asynchronous deterministic and stochastic gradient optimization algorithms , '' _ ieee transactions on automatic control _ , vol .  31 , no .  9 , pp . 803812 , 1986 .",
    "d.  p. palomar and m.  chiang , `` alternative distributed algorithms for network utility maximization : framework and applications , '' _ ieee transactions on automatic control _ , vol .",
    "52 , no .  12 , pp . 22542269 , 2007 .",
    "b.  grtner and e.  welzl , `` linear programming - randomization and abstract frameworks , '' in _",
    "symposium on theoretical aspects of computer science _ ,",
    "lecture notes in computer science , vol . 1046 , 1996 , pp . 669687 .",
    "p.  k. agarwal and s.  sen ,",
    "`` randomized algorithms for geometric optimization problems , '' in _ handbook of randomization _ , p.  pardalos , s.  rajasekaran , j.  reif , and j.  rolim , eds.1em plus 0.5em minus 0.4emkluwer academic publishers , 2001 .",
    "y.  bartal , j.  w. byers , and d.  raz , `` fast , distributed approximation algorithms for positive linear programming with applications to flow control , '' _ siam journal on computing _ , vol .",
    "33 , no .  6 , pp .",
    "12611279 , 2004 .",
    "h.  dutta and h.  kargupta , `` distributed linear programming and resource management for data mining in distributed environments , '' in _ ieee int . conference on data mining _ , pisa , italy , dec .",
    "2008 , pp .",
    "543552 .",
    "y.  lu and v.  roychowdhury , `` parallel randomized support vector machine , '' in _ advances in knowledge discovery and data mining ( 10th pacific - asia conference , singapore 2006 ) _ , ser .",
    "lecture notes in artificial intelligence , w.  k. ng , m.  kitsuregawa , and j.  li , eds.1em plus 0.5em minus 0.4emspringer , 2006 , pp . 205214 .",
    "y.  lu , v.  roychowdhury , and l.  vandenberghe , `` distributed parallel support vector machines in strongly connected networks , '' _ ieee transactions on neural networks _ , vol .",
    "19 , no .  7 , pp . 11671178 , 2008 .",
    "h.  ando , y.  oasa , i.  suzuki , and m.  yamashita , `` distributed memoryless point convergence algorithm for mobile robots with limited visibility , '' _ ieee transactions on robotics and automation _",
    "15 , no .  5 , pp . 818828 , 1999 .",
    "x.  defago and a.  konagaya , `` circle formation for oblivious anonymous mobile robots with no common sense of orientation , '' in _ acm int .",
    "workshop on principles of mobile computing _",
    ", toulouse , france , oct .",
    "2002 , pp . 97104 .",
    "j.  r. dunham , d.  g. kelly , and j.  w. tolle , `` some experimental results concerning the expected number of pivots for solving randomly generated linear programs , '' operations research and system analysis department , university of north carolina at chapel hill , tech .",
    "77 - 16 , 1977 .",
    "f.  bullo , j.  corts , and s.  martnez , _ distributed control of robotic networks _",
    ", ser . applied mathematics series.1em plus 0.5em minus 0.4emprinceton university press , 2009 , available at http://www.coordinationbook.info ."
  ],
  "abstract_text": [
    "<S> distributed abstract programs are a novel class of distributed optimization problems where ( i ) the number of variables is much smaller than the number of constraints and ( ii ) each constraint is associated to a network node . </S>",
    "<S> abstract optimization programs are a generalization of linear programs that captures numerous geometric optimization problems . </S>",
    "<S> we propose novel constraints consensus algorithms for distributed abstract programs : as each node iteratively identifies locally active constraints and exchanges them with its neighbors , the network computes the active constraints determining the global optimum . </S>",
    "<S> the proposed algorithms are appropriate for networks with weak time - dependent connectivity requirements and tight memory constraints . </S>",
    "<S> we show how suitable target localization and formation control problems can be tackled via constraints consensus .    </S>",
    "<S> distributed optimization , linear programming , consensus algorithms , target localization , formation control . </S>"
  ]
}