{
  "article_text": [
    "let @xmath1 be an edge - labeled directed graph ( referred to hereafter simply as a graph ) , where @xmath2 is the vertex set , @xmath3 is the edge set , and @xmath4 is the edge labeling taking values on a finite alphabet @xmath5  @xcite .",
    "we require that the labeling @xmath6 is deterministic : edges that start at the same vertex have distinct labels .",
    "we further assume that @xmath7 has finite memory  @xcite . the one - dimensional ( 1-d ) _ constraint _ @xmath8 that is presented by @xmath7 is defined as the set of all words that are generated by paths in @xmath7 ( i.e. , the words are obtained by reading - off the edge labels of such paths ) .",
    "examples of 1-d constraints include runlength - limited ( rll ) constraints  @xcite , symmetric runlength - limited ( srll ) constraints  @xcite , and the charge constraints  @xcite .",
    "the capacity of @xmath9 is given by @xmath10    an @xmath11-track _ parallel encoder _ for @xmath8 at rate @xmath12 is defined as follows ( see figure  [ fig : encoder ] ) .",
    "-track parallel encoder.,title=\"fig : \" ]    1 .   at stage @xmath13 ,",
    "the encoder ( which may be state - dependent ) receives as input @xmath14 ( unconstrained ) information bits . 2 .",
    "the output of the encoder at stage @xmath15 is a word @xmath16 of length @xmath11 over @xmath5 .",
    "3 .   for @xmath17 ,",
    "@xmath18th track _",
    "@xmath19 of any given length @xmath20 , belongs to @xmath9 .",
    "4 .   there are integers @xmath21 such that the encoder is _ @xmath22-sliding - block decodable _ ( in short , @xmath22-sbd ) : for @xmath23 , the @xmath14 information bits which were input at stage @xmath15 are uniquely determined by ( and can be efficiently calculated from ) @xmath24 .",
    "the decoding window size of the encoder is @xmath25 , and it is desirable to have a small window to avoid error propagation . in this work , we will be mainly focusing on the case where @xmath26 , in which case the decoding requires no look - ahead .    in  @xcite",
    ", it was shown that by introducing parallelism , one can reduce the window size , compared to conventional serial encoding .",
    "furthermore , it was shown that as @xmath11 tends to infinity , there are @xmath27-sbd parallel encoders whose rates approach @xmath28 . a key step in  @xcite",
    "is using some perturbation of the conditional probability distribution on the edges of @xmath7 , corresponding to the maxentropic stationary markov chain on @xmath7 .",
    "however , it is not clear how this perturbation should be done : a naive method will only work for unrealistically large @xmath11 .",
    "also , the proof in  @xcite of the @xmath27-sbd property is only probabilistic and does not suggest encoders and decoders that have an acceptable running time .    in this work , we aim at making the results of  @xcite more tractable . at the expense of possibly increasing the memory of the encoder ( up to the memory of @xmath7 )",
    "we are able to define a suitable perturbed distribution explicitly , and provide an efficient algorithm for computing it .",
    "furthermore , the encoding and decoding can be carried out in time complexity @xmath29 , where the multiplying constants in the @xmath30 term are polynomially large in the parameters of @xmath7 .",
    "denote by @xmath31 the diameter of @xmath7 ( i.e. , the longest shortest path between any two vertices in @xmath7 ) and let @xmath32 be the adjacency matrix of @xmath7 , i.e. , @xmath33 is the number of edges in @xmath7 that start at vertex @xmath34 and terminate in vertex @xmath35 .",
    "our main result , specifying the rate of our encoder , is given in the next theorem .",
    "[ theo : main ] let @xmath7 be a deterministic graph with memory @xmath36 .",
    "for @xmath11 sufficiently large , one can efficiently construct an @xmath11-track @xmath37-sbd parallel encoder for @xmath38 at a rate @xmath12 such that @xmath39 where @xmath40 ( respectively , @xmath41 ) is the smallest ( respectively , largest ) _ nonzero _ entry in @xmath42 .",
    "the structure of this paper is as follows . in section  [ sec : twodimensionalconstraints ] we show how parallel encoding can be used to construct an encoder for a 2-d constraint .",
    "as we will show , a parallel encoder is essentially defined through what we term a multiplicity matrix .",
    "section  [ sec : encoder ] defines how our parallel encoder works , assuming its multiplicity matrix is given .",
    "then , in section  [ sec : computingmultiplicitymatrix ] , we show how to efficiently calculate a good multiplicity matrix .",
    "although 2-d constraints are our main motivation , section [ sec:1d ] shows how our method can be applied to 1-d constraints .",
    "section  [ sec : twoopt ] defines two methods by which the rate of our encoder can be slightly improved .",
    "finally , in section  [ sec : fastenumerativecoding ] we show a method of efficiently realizing a key part of our encoding procedure .",
    "our primary motivation for studying parallel encoding is to show an encoding algorithm for a family of two - dimensional ( 2-d ) constraints .",
    "the concept of a 1-d constraint can formally be generalized to two dimensions ( see  @xcite ) .",
    "examples of 2-d constraints are 2-d rll constraints  @xcite , 2-d srll constraints  @xcite , and the so - called square constraint  @xcite .",
    "let @xmath43 be a given 2-d constraint over a finite alphabet @xmath5 .",
    "we denote by @xmath44 $ ] the set of all @xmath45 arrays in @xmath43 .",
    "the capacity of @xmath43  @xcite is given by @xmath46\\right| } \\ ; .\\ ] ]    suppose we wish to encode information to an @xmath45 array which must satisfy the constraint @xmath43 ; namely , the array must be an element of @xmath44 $ ] . as a concrete example , consider the square constraint  @xcite : its elements are all the binary arrays in which no two ` 1 ' symbols are adjacent on a row , column , or diagonal .",
    "we first partition our array into two alternating types of vertical strips : _ data strips _ having width @xmath47 , and _ merging strips _ having width @xmath48 . in our example , let @xmath49 and @xmath50 ( see figure  [ fig : example : square ] ) .",
    "@xmath51    secondly , we select a graph @xmath1 with a labeling @xmath52 $ ] such that @xmath53 , i.e. , each path of length @xmath20 in @xmath7 generates a ( column ) word which is in @xmath54 $ ] .",
    "we then fill up the data strips of our @xmath45 array with @xmath55 arrays corresponding to paths of length @xmath20 in @xmath7 .",
    "thirdly , we assume that the choice of @xmath48 allows us to fill up the merging strips in a row - by - row ( causal ) manner , such that our @xmath45 array is in @xmath43 .",
    "any 2-d constraint @xmath43 for which such @xmath47 , @xmath48 , and @xmath7 can be found , is in the family of constraints we can code for ( for example , the 2-d srll constraints belong to this family  @xcite ) .",
    "consider again the square constraint : a graph which produces _ all _ @xmath55 arrays that satisfy this constraint is given in figure  [ fig : example : g ] .",
    "also , for @xmath56 , we can take the merging strips to be all - zero .",
    "( there are cases , such as the 2-d srll constraints , where determining the merging strips may be less trivial  @xcite . )",
    "whose paths generate all @xmath57 arrays satisfying the square constraint .",
    "the label of an edge is given by the label of the vertex it enters.,title=\"fig : \" ]    suppose we have an @xmath37-sbd parallel encoder for @xmath38 at rate @xmath12 with @xmath58 tracks .",
    "we may use this parallel encoder to encode information in a row - by - row fashion to our @xmath45 array : at stage @xmath15 we feed @xmath14 information bits to our parallel encoder .",
    "let @xmath16 be the output of the parallel encoder at stage @xmath15 .",
    "we write @xmath59 to row @xmath15 of the @xmath18th data strip , and then appropriately fill up row @xmath15 of the merging strips .",
    "decoding of a row in our array can be carried out based only on the contents of that row and the previous @xmath36 rows .    since",
    "@xmath14 information bits are mapped to @xmath60 symbols in @xmath5 , the rate at which we encode information to the array is @xmath61 we note the following tradeoff : typically , taking larger values of @xmath47 ( while keeping @xmath48 constant ) will increase the right - hand side of the above inequality .",
    "however , the number of vertices and edges in @xmath7 will usually grow exponentially with @xmath47 .",
    "thus , @xmath47 is taken to be reasonably small .",
    "note that in our scheme , a single error generally results in the loss of information stored in the respective vertical sliding - block window .",
    "namely , a single corrupted entry in the array may cause the loss of @xmath62 rows .",
    "thus , our method is only practical if we assume an error model in which whole rows are corrupted by errors .",
    "this is indeed the case if each row is protected by an error - correcting code ( for example , by the use of unconstrained positions @xcite ) .",
    "let @xmath63 be a positive integer which will shortly be specified .",
    "the @xmath63 words @xmath19 , @xmath64 , that we will be writing to the first @xmath63 tracks are all generated by paths of length @xmath20 in @xmath7 . in",
    "what follows , we find it convenient to regard the @xmath65 arrays @xmath66 as ( column ) words of length @xmath20 of some new 1-d constraint , which we define next .",
    "@xmath63th kronecker power _ of @xmath1 , denoted by @xmath67 , is defined as follows .",
    "the vertex set @xmath68 is simply the @xmath63th cartesian power of @xmath2 ; that is , @xmath69 an edge @xmath70 goes from vertex @xmath71 to vertex @xmath72 and is labeled @xmath73 whenever for all @xmath64 , @xmath74 is an edge from @xmath75 to @xmath76 labeled @xmath77 .",
    "note that a path of length @xmath20 in @xmath78 is just a handy way to denote @xmath63 paths of length @xmath20 in @xmath7 .",
    "accordingly , the @xmath65 arrays @xmath79 are the words of length @xmath20 in @xmath80 .",
    "let @xmath7 be as in section  [ sec : introduction ] and let @xmath32 be the adjacency matrix of @xmath7 . denote by @xmath81 the @xmath82 all - one row vector .",
    "the description of our @xmath11-track parallel encoder for @xmath8 makes use of the following definition .",
    "a @xmath83 nonnegative integer matrix @xmath84 is called a ( valid ) _ multiplicity matrix _ with respect to @xmath7 and @xmath11 if @xmath85 ( while any multiplicity matrix will produce a parallel encoder , some will have higher rates than others . in section  [ sec : computingmultiplicitymatrix ] , we show how to compute multiplicity matrices @xmath86 that yield rates close to @xmath28 . )",
    "recall that we have at our disposal @xmath11 tracks .",
    "however , we will effectively be using only the first @xmath87 tracks in order to encode information .",
    "the last @xmath88 tracks will all be equal to the first track , say .",
    "write @xmath89 .",
    "a vertex @xmath90 is a _ typical vertex _",
    "( with respect to @xmath86 ) if for all @xmath34 , the vertex @xmath91 appears as an entry in @xmath92 exactly @xmath93 times . also , an edge @xmath94 is a _ typical edge _ with respect to @xmath86 if for all @xmath95 , there are exactly @xmath96 entries @xmath74 which  as edges in @xmath7start at vertex @xmath34 and terminate in vertex @xmath35 .",
    "a simple computation shows that the number of outgoing typical edges from a typical vertex equals @xmath97 ( where @xmath98 ) .",
    "for example , in the simpler case where @xmath7 does not contain parallel edges ( @xmath99 ) , we are in effect counting in   permutations with repetitions , each time for a different vertex @xmath91 .",
    "the encoding process will be carried out as follows .",
    "we start at some fixed typical vertex @xmath100 . out of the set of outgoing edges from @xmath101",
    ", we consider only typical edges .",
    "the edge we choose to traverse is determined by the information bits .",
    "after traversing the chosen edge , we arrive at vertex @xmath102 . by  , @xmath102 is also a typical vertex , and the process starts over .",
    "this process defines an @xmath11-track parallel encoder for @xmath8 at rate @xmath103 this encoder is @xmath37-sbd , where @xmath36 is the memory of @xmath7 .",
    "consider now how we map @xmath14 information bits into an edge choice @xmath104 at any given stage @xmath15 .",
    "assuming again the simpler case of a graph with no parallel edges , a natural choice would be to use an instance of enumerative coding  @xcite .",
    "specifically , suppose that for @xmath105 , a procedure for encoding information by an @xmath106-bit binary vector with hamming weight @xmath107 were given .",
    "suppose also that @xmath108 .",
    "we could use this procedure as follows .",
    "first , for @xmath109 and @xmath110 , the binary word given as output by the procedure will define which @xmath111 of the possible @xmath112 entries in @xmath113 will be equal to the edge in @xmath3 from the vertex @xmath114 to itself ( if no such edge exists , then @xmath115 ) .",
    "having chosen these entries , we run the procedure with @xmath116 and @xmath117 to choose from the remaining @xmath118 entries those that will contain the edge in @xmath3 from @xmath114 to @xmath119 .",
    "we continue this process , until all @xmath112 entries in @xmath113 containing an edge outgoing from @xmath114 have been picked .",
    "next , we run the procedure with @xmath120 and @xmath121 , and so forth .",
    "the more general case of a graph containing parallel edges will include a preliminary step : encoding information in the choice of the @xmath96 edges used to traverse from @xmath34 to @xmath35 ( @xmath33 options for each such edge ) .",
    "a fast implementation of enumerative coding is presented in section  [ sec : fastenumerativecoding ] .",
    "the above - mentioned preliminary step makes use of the schnhage  strassen integer - multiplication algorithm  @xcite , and the resulting encoding time complexity is proportional , with a negligible penalty in terms of rate : fix @xmath34 and @xmath35 , and let @xmath122 be an integer design parameter .",
    "assume for simplicity that @xmath123 .",
    "the number of vectors of length @xmath122 over an alphabet of size @xmath33 is obviously @xmath124 .",
    "so , we can encode @xmath125 bits through the choice of such a vector . repeating this process",
    ", we can encode @xmath126 bits through the choice of @xmath127 such vectors .",
    "the concatenation of these vectors is taken to represent our choice of edges .",
    "note that the encoding process is linear in @xmath11 for constant @xmath122 .",
    "also , our losses ( due to the floor function ) become negligible for modestly large @xmath122 . ] to @xmath128 .",
    "it turns out that this is also the decoding time complexity .",
    "further details are given in section  [ sec : fastenumerativecoding ] .",
    "the next section shows how to find a good multiplicity matrix , i.e. , a matrix @xmath86 such that @xmath129 is close to @xmath28 .",
    "in order to enhance the exposition of this section , we accompany it by a running example ( see figure  [ fig : running1 ] ) .    throughout this section ,",
    "we assume a probability distribution on the edges of @xmath7 , which is the maxentropic stationary markov chain @xmath130 on @xmath7  @xcite . without real loss of generality",
    ", we can assume that @xmath7 is irreducible ( i.e. , strongly - connected ) , in which case @xmath130 is indeed unique .",
    "let the matrix @xmath131 be the transition matrix induced by @xmath130 , i.e. , @xmath132 is the probability of traversing an edge from @xmath91 to @xmath133 , conditioned on currently being at vertex @xmath91 .",
    "let @xmath134 be the @xmath82 row vector corresponding to the stationary distribution on @xmath2 induced by @xmath135 ; namely , @xmath136 and @xmath137 .",
    "let @xmath138 and define @xmath139    taking the number of tracks in our running example ( figure  [ fig : running1 ] ) to be @xmath140 gives @xmath141 .",
    "also , our running example has @xmath142 and @xmath143 thus , @xmath144 and @xmath145    note that @xmath146 also , observe that   hold when we substitute @xmath147 for @xmath86 . thus ,",
    "if all entries of @xmath147 were integers , then we could take @xmath86 equal to @xmath147 . in a way , that would be the best choice we could have made : by using stirling s approximation , we could deduce that @xmath129 approaches @xmath28 as @xmath148 .",
    "however , the entries of @xmath147 , as well as @xmath149 , may be non - integers .",
    "we say that an _ integer _",
    "matrix @xmath150 is a _ good quantization _ of @xmath151 if    @xmath152{$\\sum_{j \\in v } { \\tilde{p}}_{i , j}$ } } \\;\\;\\leq\\;\\ ; { \\left\\lceil\\sum_{j \\in v } { p}_{i , j}\\right\\rceil } \\ ; , \\\\ \\label{eq : preflow_entries } { \\left\\lfloor{p}_{i , j}\\right\\rfloor } & \\leq & \\textstyle { \\makebox[3.4em]{${\\tilde{p}}_{i , j}$ } } \\;\\;\\leq\\;\\ ; { \\left\\lceil{p}_{i , j}\\right\\rceil } \\ ; , \\quad \\textrm{and---}\\qquad \\\\ \\label{eq : preflow_sumi } \\textstyle { \\left\\lfloor\\sum_{i \\in v } { p}_{i , j}\\right\\rfloor } & \\leq & \\textstyle { \\makebox[3.4em]{$\\sum_{i \\in v } { \\tilde{p}}_{i , j}$ } } \\;\\;\\leq\\;\\ ; { \\left\\lceil\\sum_{i \\in v } { p}_{i , j}\\right\\rceil } \\ ; .\\end{aligned}\\ ] ]    namely , a given entry in @xmath153 is either the floor or the ceiling of the corresponding entry in @xmath147 , and this also holds for the sum of entries of a given row or column in @xmath153 ; moreover , the sum of entries in both @xmath153 and @xmath147 are exactly equal ( to @xmath154 ) .",
    "[ lemm : preflow ] there exists a matrix @xmath153 which is a good quantization of @xmath147 .",
    "furthermore , such a matrix can be found by an efficient algorithm .    .",
    "an edge labeled @xmath155 has lower and upper bounds @xmath156 and",
    "@xmath157 , respectively.,title=\"fig : \" ]    we recast   as an integer flow problem ( see figures  [ fig : preflow ] and  [ fig : running3 ] ) . consider the following flow network , with upper and lower bounds on the flow through the edges  @xcite .",
    "the network has the vertex set @xmath158 with source @xmath159 and target @xmath160 .",
    "henceforth , when we refer to the upper ( lower ) bound of an edge , we mean the upper ( lower ) bound on the flow through it .",
    "there are four kinds of edges :    1 .",
    "an edge @xmath161 with upper and lower bounds both equaling to @xmath162 .",
    "2 .   @xmath163 for every @xmath91 , with the upper and lower bounds @xmath164 and @xmath165 , respectively .",
    "3 .   @xmath166 for every @xmath95 , with the upper and lower bounds @xmath167 and @xmath168 , respectively .",
    "4 .   @xmath169 for every @xmath133 , with the upper and lower bounds @xmath170 and @xmath171 , respectively .",
    "we claim that   can be satisfied if a legal integer flow exists : simply take @xmath172 as the flow on the edge from @xmath173 to @xmath174 .",
    "it is well known that if a legal _ real _ flow exists for a flow network with integer upper and lower bounds on the edges , then a legal _ integer _",
    "flow exists as well  ( * ? ? ?",
    "* theorem 6.5 ) .",
    "moreover , such a flow can be efficiently found  @xcite .",
    "to finish the proof , we now exhibit such a legal real flow :    1 .",
    "the flow on the edge @xmath161 is @xmath175 .",
    "the flow on an edge @xmath163 is @xmath176 .",
    "the flow on an edge @xmath166 is @xmath177 .",
    "the flow on an edge @xmath169 is @xmath178 .     in running example 2 .",
    "an edge labeled @xmath179 has lower and upper bounds @xmath180 and @xmath181 , respectively .",
    "a legal real flow is given by @xmath156 .",
    "a legal integer flow is given by @xmath182 .",
    "the matrix @xmath153 resulting from the legal integer flow is given , as well as the matrix @xmath147 ( again).,title=\"fig : \" ]    @xmath183    for the remaining part of this section , we assume that @xmath153 is a good quantization of @xmath147 ( say , @xmath153 is computed by solving the integer flow problem in the last proof ) . the next lemma states that @xmath153 `` almost '' satisfies ( [ eq : sum_up ] ) .",
    "[ lemm : disc ] let @xmath184 and @xmath185 .",
    "then , for all @xmath91 , @xmath186    from , we get that for all @xmath91 , @xmath187 recall that is satisfied if we replace @xmath86 by @xmath147 . thus , by , we have that also holds if we replace @xmath188 by @xmath189 .",
    "we conclude that @xmath190 .",
    "the proof follows from the fact that entries of @xmath153 are integers , and thus so are those of @xmath191 and @xmath192",
    ".    the following lemma will be the basis for augmenting @xmath153 so that ( [ eq : sum_up ] ) is satisfied .",
    "[ lemm : fmat ] fix two distinct vertices @xmath193 .",
    "we can efficiently find a @xmath83 matrix @xmath194 with non - negative integer entries , such that the following three conditions hold .    1 .",
    "[ eq : fsumentries ] @xmath195 2 .   for all @xmath196 , [ eq : fsane ]",
    "@xmath197 3 .",
    "denote @xmath198 and @xmath199 .",
    "then , for all @xmath91 , @xmath200    let @xmath201 be the vertices along a shortest path from @xmath202 to @xmath15 in @xmath7 . for all @xmath196 , define @xmath203 namely , @xmath204 is the number of edges from @xmath34 to @xmath35 along the path .    conditions ( [ eq : fsumentries ] ) and ( [ eq : fsane ] ) easily follow from ( [ eq : f ] ) .",
    "condition ( [ eq : fsurp ] ) follows from the fact that @xmath205 ( @xmath206 ) is equal to the number of edges along the path for which @xmath34 is the start ( end ) vertex of the edge",
    ".    the matrix @xmath153 will be the basis for computing a good multiplicity matrix @xmath86 , as we demonstrate in the proof of the next theorem .",
    "[ theo : dfromptilde ] let @xmath207 be a good quantization of @xmath147 .",
    "there exists a multiplicity matrix @xmath208 with respect to @xmath7 and @xmath11 , such that    1 .",
    "[ it : dagreaterthandalpha ] @xmath209 for all @xmath95 , and 2 .",
    "@xmath210    ( where @xmath154 is as defined in  ) .",
    "moreover , the matrix @xmath86 can be found by an efficient algorithm .",
    "consider a vertex @xmath91 .",
    "if @xmath211 , then we say that vertex @xmath34 has a _ surplus _ of @xmath212 . in this case , by lemma  [ lemm : disc ] , we have that the surplus is equal to 1 . on the other hand , if @xmath213 then vertex @xmath34 has a _ deficiency _ of @xmath214 , which again is equal to 1 .    of course , since @xmath215 , the total surplus is equal to the total deficiency , and both are denoted by @xmath216 : @xmath217    denote the vertices with surplus as @xmath218 and the vertices with deficiency as @xmath219 .",
    "recalling the matrix @xmath220 from lemma  [ lemm : fmat ] , we define @xmath221    we first show that @xmath86 is a valid multiplicity matrix .",
    "note that @xmath222 .",
    "thus , ( [ eq : sum_entries ] ) follows from ( [ eq : malpha ] ) , ( [ eq : preflow_sumij ] ) , and ( [ eq : fsumentries ] ) .",
    "the definitions of surplus and deficiency vertices along with ( [ eq : fsurp ] ) give ( [ eq : sum_up ] ) .",
    "lastly , recall that ( [ eq : sane_entries ] ) is satisfied if we replace @xmath96 by @xmath177 .",
    "thus , by ( [ eq : preflow_entries ] ) , the same can be said for @xmath172 .",
    "combining this with ( [ eq : fsane ] ) yields ( [ eq : sane_entries ] ) .",
    "since the entries of @xmath223 are non - negative for every @xmath18 , we must have that @xmath209 for all @xmath95 .",
    "this , together with ( [ eq : sum_entries ] ) and ( [ eq : preflow_sumij ] ) , implies in turn that @xmath210 .    for the matrix @xmath153 in figure  [ fig : running3 ]",
    ", we have @xmath224 thus , @xmath225 .",
    "namely , the vertex @xmath226 has a surplus while the vertex @xmath227 has a deficiency .",
    "taking @xmath228 and @xmath229 we get @xmath230    now that theorem  [ theo : dfromptilde ] is proved , we are in a position to prove our main result , theorem  [ theo : main ] .",
    "essentially , the proof involves using the stirling approximation and taking into account the various quantization errors introduced into @xmath86 .",
    "the proof itself is given in the appendix .",
    "the main motivation for our methods is 2-d constrained coding . however , in this section , we show that they might be interesting in certain aspects of 1-d coding as well .",
    "given a labeled graph @xmath7 , a classic method for building an encoder for the 1-d constraint @xmath231 is the state - splitting algorithm @xcite .",
    "the rate of an encoder built by @xcite approaches the capacity of @xmath231 . also , the word the encoder outputs has a corresponding path in @xmath7 , with the following favorable property : the probability of traversing a certain edge approaches the maxentropic probability of that edge ( assuming an unbiased source distribution ) .",
    "however , what if we d like to build an encoder with a different probability distribution on the edges ?",
    "this scenario may occur , for example , when there is a requirement that all the output words of a given length @xmath63 that are generated by the encoder have a prescribed hamming weight yielding a stationary markov chain with largest possible entropy , subject to a set of edges ( such as the set of edges with label ` 1 ' ) having a prescribed cumulative probability . ] .",
    "more formally , suppose that we are given a labeled graph @xmath232 ; to make the exposition simpler , suppose that @xmath7 does not contain parallel edges .",
    "let @xmath135 and @xmath233 be a transition matrix and a stationary probability distribution corresponding to a stationary ( but not necessarily maxentropic ) markov chain @xmath130 on @xmath7 .",
    "we assume w.l.o.g .  that each edge in @xmath7 has a positive conditional probability .",
    "we are also given an integer @xmath11 , which we will shortly elaborate on .",
    "we first describe our encoder in broad terms , so as that its merits will be obvious .",
    "let @xmath234 and @xmath63 be as previously defined , and let @xmath235 be specified shortly .",
    "we start at some fixed vertex @xmath236 . given @xmath237 information bits ,",
    "we traverse a soon to be defined cyclic path of length @xmath63 in @xmath7 .",
    "the concatenation of the edge labels along the path is the word we output .",
    "of course , since the path is cyclic , the concatenation of such words is indeed in @xmath231 .",
    "moreover , the path will have the following key property : the number of times an edge from @xmath34 to @xmath35 is traversed equals @xmath238 .",
    "namely , if we uniformly pick one of the @xmath63 edges of the path , the probability of picking a certain edge @xmath239 is constant ( not a function of the input bits ) , and is equal to the probability of traversing @xmath239 on the markov chain @xmath130 , up to a small quantization error .",
    "the rate @xmath240 of our encoder will satisfy ( [ eq : rbound ] ) , where we replace @xmath12 by @xmath240 and @xmath241 by the entropy of @xmath130 .",
    "we would like to be able to exactly specify the path length @xmath63 as a design parameter .",
    "however , we specify @xmath11 and get an @xmath63 between @xmath11 and @xmath242",
    ".    our encoding process will make use of an _ oriented tree _ , a term which we will now define .",
    "a set of edges @xmath243 is an oriented tree of @xmath7 with root @xmath244 if @xmath245 and for each @xmath246 there exists a path from @xmath247 to @xmath244 consisting entirely of edges in @xmath248 ( see figure  [ fig : orientedtree ] ) . note that if we reverse the edge directions of an oriented tree , we get a directed tree as defined in ( * ? ? ?",
    "* theorem 2.5 ) . since reversing the directions of all edges in an irreducible graph results in an irreducible graph",
    ", we have by ( * ? ? ?",
    "* lemma 3.3 ) that an oriented tree @xmath248 indeed exists in @xmath7 , and can be efficiently found .",
    "so , let us fix some oriented tree @xmath248 with root @xmath244 . by (",
    "* theorem 2.5 ) , we have that every vertex @xmath246 which is not the root @xmath244 has an out - degree equal to 1 .",
    "thus , for each such vertex @xmath247 we may define @xmath249 as the destination of the single edge in @xmath248 going out of @xmath247 .",
    ".,title=\"fig : \" ]    we now elaborate on the encoding process .",
    "the encoding consists of two steps . in the first step , we map the information bits to a collection of lists . in the second step ,",
    "we use the lists in order to define a cyclic path .",
    "first step : given @xmath237 information bits , we build for each vertex @xmath91 a list @xmath250 of length @xmath93 , @xmath251 the entries of each @xmath250 are vertices in @xmath2 .",
    "moreover , the following properties are satisfied for all @xmath34 :    * the number of times @xmath35 is an entry in @xmath250 is exactly @xmath238 . * if @xmath252 , then the last entry of the list equals the parent of @xmath34 .",
    "namely , @xmath253    recalling ( [ eq : r_d ] ) , a simple calculation shows that the number of possible list collections is @xmath254 thus , we define the rate of encoding as @xmath255 also , note that as in the 2-d case , we may use enumerative coding in order to efficiently map information bits to lists .",
    "second step : we now use the lists @xmath250 , @xmath91 , in order to construct a cyclic path starting at vertex @xmath244 .",
    "we start the path at @xmath244 and build a length-@xmath63 path according to the following rule : when exiting vertex @xmath34 for the @xmath18th time , traverse the edge going into vertex @xmath256 .    of course , our encoding method is valid ( and invertible ) iff we may always abide by the above - mentioned rule .",
    "namely , we do nt get `` stuck '' , and manage to complete a cyclic path of length @xmath63 .",
    "this is indeed the case : define an auxiliary graph @xmath257 with the same vertex set , @xmath2 , as @xmath7 and @xmath238 parallel edges from @xmath34 to @xmath35 ( for all @xmath196 ) .",
    "first , recall that for sufficiently large @xmath11 , the presence of an edge from @xmath34 to @xmath35 in @xmath7 implies that @xmath258 .",
    "thus , since @xmath7 was assumed to be irreducible , @xmath257 is irreducible as well .",
    "also , an edge in @xmath248 from @xmath34 to @xmath35 implies the existence of an edge in @xmath257 from @xmath34 to @xmath35 . secondly , note that by ( [ eq : sum_up ] ) , the number of times we are supposed to exit a vertex is equal to the number of times we are supposed to enter it .",
    "the rest of the proof follows from ( * ? ? ?",
    "* , claim 2 ) , applied to the auxiliary graph @xmath257 .",
    "namely , our encoder follows directly from van aardenne - ehrenfest and de bruijn s @xcite theorem on counting eulerian cycles in a graph .",
    "we now return to the rate , @xmath240 , of our encoder . from ( [ eq : malpha ] ) , ( [ eq : preflow_entries ] ) , ( [ eq : preflow_sumi ] ) and theorem [ theo : dfromptilde ] , we see that for @xmath11 sufficiently large , @xmath259 is greater than some positive constant times @xmath260 .",
    "thus , ( [ eq : rbound ] ) still holds if we replace @xmath12 by @xmath240 and @xmath241 by the entropy of @xmath130 .",
    "recall from section  [ sec : twodimensionalconstraints ] the square constraint : its elements are all the binary arrays in which no two ` 1 ' symbols are adjacent on a row , column , or diagonal . by employing the methods presented in @xcite , we may calculate an upper bound on the rate of the constraint .",
    "this turns out to be @xmath261 .",
    "we will show an encoding / decoding method with rate slightly larger than @xmath262 ( about @xmath263 of the upper bound ) . in order to do this",
    ", we assume that the array has @xmath264 columns .",
    "our encoding method has a fixed rate and has a vertical window of size 2 and vertical anticipation 0 .",
    "we should point out now that a straightforward implementation of the methods we have previously defined gives a rate which is strictly @xmath265 than @xmath262 .",
    "namely , this section also outlines two improvement techniques which help boost the rate .",
    "we start out as in the example given in section  [ sec : twodimensionalconstraints ] , except that the width of the data strips is now @xmath266 ( the width of the merging strips remains @xmath50 ) .",
    "the graph @xmath7 we choose produces all width-@xmath47 arrays satisfying the square constraint , and we take the merging strips to be all - zero .",
    "our array has @xmath264 columns , so we have @xmath267 tracks ( the last , say , column of the array will essentially be unused ; we can set all of its values to 0 ) .",
    "define the normalized capacity as @xmath268 the graph @xmath7 has @xmath269 vertices and normalized capacity @xmath270 this number is about @xmath271 from the upper bound on the capacity of our 2-d constraint .",
    "thus , as expected , there is an inherent loss in choosing to model the 2-d constraint as an essentially 1-d constraint .",
    "of course , this loss can be made smaller by increasing @xmath47 ( but the graph @xmath7 will grow as well ) .    from theorem  [ theo : main ]",
    ", the rate of our encoder will approach the normalized capacity of @xmath272 as the number of tracks @xmath11 grows .",
    "so , once the graph @xmath7 is chosen , the parameter we should be comparing ourselves to is the normalized capacity .",
    "we now apply the methods defined in section  [ sec : computingmultiplicitymatrix ] and find a multiplicity matrix @xmath86 .",
    "recall that the matrix @xmath86 defines an encoder . in our case",
    ", this encoder has a rate of about @xmath273 .",
    "this is @xmath274 of the normalized capacity , and is quite disappointing ( but the improvements shown in sections  [ ssec : moore ] and [ ssec : breakmerge ] below are going to improve this rate ) . on the other hand ,",
    "note that if we had limited ourselves to encode to each track independently of the others , then the best rate we could have hoped for with 0 vertical anticipation turns out to be @xmath275 ( see ( * ? ? ?",
    "* theorem 5 ) ) .",
    "we now define a graph @xmath276 which we call the reduction of @xmath7 .",
    "essentially , we will encode by constructing paths in @xmath276 , and then translate these to paths in @xmath7 . in both @xmath7 and @xmath276 ,",
    "the maxentropic distributions have the same entropy .",
    "the main virtue of @xmath276 is that it often has less vertices and edges compared to @xmath7 .",
    "thus , the penalty in ( [ eq : rbound ] ) resulting from using a finite number of tracks will often be smaller .    for @xmath277 , we now recursively define the concept of @xmath202-equivalence ( very much like in the moore algorithm @xcite ) .    * for @xmath278 , any two vertices @xmath279 are 0-equivalent . * for @xmath280 , two vertices @xmath279 are @xmath202-equivalent iff 1 ) the two vertices @xmath281 are @xmath282-equivalent , and 2 ) for each @xmath282-equivalence class @xmath283 , the number of edges from @xmath284 to vertices in @xmath283 is equal to the number of edges from @xmath285 to vertices in @xmath283 .",
    "denote by @xmath286 the partition induced by @xmath202-equivalence .",
    "for the graph @xmath7 given in figure  [ fig : example : g ] , @xmath287 note that , by definition , @xmath288 is a refinement of @xmath286 .",
    "thus , let @xmath289 be the smallest @xmath202 for which @xmath286 = @xmath288 .",
    "the set @xmath290 can be efficiently found ( essentially , by the moore algorithm @xcite ) .",
    "define a ( non - labeled ) graph @xmath291 as follows .",
    "the vertex set of @xmath276 is @xmath292 for each @xmath293 , let @xmath294 be a fixed element of @xmath283 ( if @xmath283 contains more than one vertex , then pick one arbitrarily ) .",
    "also , for each @xmath295 , let @xmath296 be the class @xmath293 such that @xmath297 .",
    "let @xmath298 ( @xmath299 ) and @xmath300 ( @xmath301 ) denote the start and end vertex of an edge @xmath239 in @xmath7 ( @xmath302 ) , respectively .",
    "the edge set @xmath303 is defined as @xmath304 where @xmath305 namely , the number of edges from @xmath306 to @xmath307 in @xmath302 is equal to the number of edges in @xmath7 from some fixed @xmath308 to elements of @xmath307 , and , by the definition of @xmath289 , this number does not depend on the choice of @xmath284 .",
    "the graph @xmath302 is termed the _ reduction _ of @xmath7 .",
    "the reduction of @xmath7 from figure  [ fig : example : g ] is given in figure  [ fig : example : greduced ] .",
    "note that since @xmath7 was assumed to be irreducible , we must have that @xmath302 is irreducible as well .     from figure",
    "[ fig : example : g].,title=\"fig : \" ]    the entropies of the maxentropic markov chains on @xmath7 and @xmath302 are equal .",
    "let @xmath309 be the adjacency matrix of @xmath302 , and recall that @xmath310 is the adjacency matrix of @xmath7 .",
    "let @xmath311 and @xmath312 be the perron eigenvalue and right perron eigenvector of @xmath313 , respectively @xcite . next ,",
    "define the vector @xmath314 as @xmath315 it is easily verifiable that @xmath316 is a right eigenvector of @xmath317 , with eigenvalue @xmath318 .",
    "now , since @xmath319 is a perron eigenvector of an irreducible matrix , each entry of it is positive .",
    "thus , each entry of @xmath316 is positive as well .",
    "since @xmath317 is irreducible , we must have that @xmath316 is a perron eigenvector of @xmath317 .",
    "so , the perron eigenvalue of @xmath317 is also @xmath318 .",
    "the next lemma essentially states that we can think of paths in @xmath302 as if they were paths in @xmath7 .",
    "[ lemm : pathconversion ] let @xmath320 .",
    "fix some @xmath321 , and @xmath322 .",
    "there exists a one - to - one correspondence between the following sets .",
    "first set : paths of length @xmath20 in @xmath302 with start vertex @xmath323 and end vertex @xmath324 .",
    "second set : paths of length @xmath20 in @xmath7 with start vertex @xmath244 and end vertex in @xmath324 .",
    "moreover , for @xmath325 , the first @xmath15 edges in a path belonging to the second set are a function of only the first @xmath15 edges in the respective path in the first set .",
    "we prove this by induction on @xmath20 .",
    "for @xmath326 , we have @xmath327 to see this , note that we can assume w.l.o.g .  that @xmath328 , and then recall ( [ eq : etag ] ) . for @xmath329 , combine the claim for @xmath330 with that for @xmath331 .    notice that @xmath332 .",
    "we now show why @xmath302 is useful .",
    "let @xmath333 be the multiplicity matrix found by the methods previously outlined , where we replace @xmath7 by @xmath302 .",
    "let @xmath334 .",
    "we may efficiently encode ( and decode ) information to @xmath335 in a row - by - row manner at rate @xmath336 .",
    "we conceptually break our encoding scheme into two steps . in the first step ,",
    "we `` encode '' ( map ) the information into @xmath337 paths in @xmath302 , each path having length @xmath20 .",
    "we do this as previously outlined ( through typical vertices and edges in @xmath302 ) .",
    "note that this step is done at a rate of @xmath336 .",
    "in the second step , we map each such path in @xmath302 to a corresponding path in @xmath7 . by lemma  [ lemm : pathconversion ] , we can indeed do this ( take @xmath323 as the first vertex in the path , @xmath324 as the last vertex , and @xmath328 ) .    by lemma  [ lemm : pathconversion ]",
    "we see that this two - step encoding scheme can easily be modified into one that is row - by - row .    applying the reduction to our running example ( square constraint with @xmath266 and @xmath50 ) ,",
    "reduces the number of vertices from @xmath338 in @xmath7 to @xmath339 in @xmath302 .",
    "the computed @xmath333 increases the rate to about @xmath340 , which is @xmath341 of the normalized capacity .",
    "let @xmath342 be the @xmath337th kronecker power of the moore - style reduction @xmath302 .",
    "recall that the rate of our encoder is @xmath343 where @xmath260 is the number of typical edges in @xmath342 going out of a typical vertex .",
    "the second improvement involves expanding the definition of a typical edge , thus increasing @xmath260 .",
    "this is best explained through an example .",
    "suppose that @xmath302 has figure  [ fig : breakmerge ] as a subgraph ; namely , we show all edges going out of vertices @xmath344 and @xmath227 .",
    "also , let the numbers next to the edges be equal to the corresponding entries in @xmath333 .",
    "the main thing to notice at this point is that if the edges to @xmath345 and @xmath346 are deleted ( `` break '' ) , then @xmath344 and @xmath227 have exactly the same number of edges from them to vertex @xmath35 , for all @xmath347 ( after the deletion of edges , vertices @xmath344 and @xmath227 can be `` merged '' ) .",
    "let @xmath92 be a typical vertex .",
    "a short calculation shows that the number of entries in @xmath92 that are equal to @xmath344 ( @xmath227 ) is @xmath348 ( @xmath349 ) .",
    "recall that the standard encoding process consists of choosing a typical edge @xmath113 going out of the typical vertex @xmath92 and into another typical vertex @xmath350 .",
    "we now briefly review this process . consider the @xmath351 entries in @xmath92 that are equal to @xmath344 .",
    "the encoding process with respect to them will be as follows ( see figure [ fig : breakmerge1 ] ) :    * out of these @xmath351 entries , choose @xmath352 for which the corresponding entry in @xmath350 will be @xmath353 . since there is exactly one edge from @xmath344 the @xmath353 in @xmath302 , the corresponding entries in @xmath113 must be equal to that edge . * next , from the remaining @xmath354 entries , choose @xmath355 for which the corresponding entries in @xmath350 will be @xmath226 .",
    "there are two parallel edges from @xmath344 to @xmath226 , so choose which one to use in the corresponding entries in @xmath113 .",
    "* we are left with @xmath356 entries , the corresponding entries in @xmath350 will be @xmath107 . also , we have one option as to the corresponding entries in @xmath113 .",
    "a similar process is applied to the entries in @xmath92 that are equal to @xmath227 .",
    "thus , the total number of options with respect to these entries is @xmath357    , @xmath350 , where we got from @xmath92 to @xmath350 by the standard encoding process.,title=\"fig : \" ]    next , consider a different encoding process ( see figure [ fig : breakmerge2 ] ) .    * out of the @xmath351 entries in @xmath92 that are equal to @xmath344 , choose @xmath352 for which the corresponding entry in @xmath350 will be @xmath353 . as before ,",
    "the corresponding entries in @xmath113 have only one option . * out of the @xmath358 entries in @xmath92 that are equal to @xmath227 ,",
    "choose @xmath359 for the corresponding entry in @xmath350 will be @xmath346 . again , one option for entries in @xmath113 . * now , of the remaining @xmath360 entries in @xmath92 that are equal to @xmath344 or @xmath227 , choose @xmath361 for which the corresponding entry in @xmath350 will be @xmath226 .",
    "we have two options for the entries in @xmath113 .",
    "* we are left with @xmath362 entries in @xmath92 that are equal to @xmath344 or @xmath227 .",
    "these will have @xmath107 as the corresponding entry in @xmath350 , and one option in @xmath113 .",
    ", @xmath350 , where we got from @xmath92 to @xmath350 by the improved encoding process .",
    "the shaded part corresponds to vertices that were merged.,title=\"fig : \" ]    thus , the total number of options is now @xmath363 the important thing to notice is that in both cases , we arrive at a typical vertex @xmath350 .    to recap , we first `` broke '' the entries in @xmath92 that are equal to @xmath344 into two groups : those which will have @xmath353 as the corresponding entry in @xmath350 and those which will have @xmath226 or @xmath107 as the corresponding entry . similarly , we broke entries in @xmath92 that are equal to @xmath227 into two groups .",
    "next , we noticed that of these four groups , two could be `` merged '' , since they were essentially the same .",
    "namely , removing some edges from the corresponding vertices in @xmath302 resulted in vertices which were mergeable .",
    "of course , these operations can be repeated .",
    "the hidden assumption is that the sequence of breaking and merging is fixed , and known to both the encoder and decoder . the optimal sequence of breaking and merging is not known to us .",
    "we used a heuristic .",
    "namely , choose two vertices such that the sets of edges emanating from both have a large overlap",
    ". then , break and merge accordingly .",
    "this was done until no breaking or merging was possible .",
    "we got a rate of about @xmath262 , which is @xmath364 of the normalized capacity .",
    "recall from section  [ sec : encoder ] that in the course of our encoding algorithm , we make use of a procedure which encodes information into fixed - length binary words of constant weight .",
    "a way to do this would be to use enumerative coding  @xcite .",
    "immink  @xcite showed a method to significantly improve the running time of an instance of enumerative coding , with a typically negligible penalty in terms of rate .",
    "we now briefly show how to tailor immink s method to our needs .",
    "denote by @xmath106 and @xmath107 the length and hamming weight , respectively , of the binary word we encode into .",
    "some of our variables will be _ floating - point _",
    "numbers with a mantissa of @xmath365 bits and an exponent of @xmath345 bits : each floating - point number is of the form @xmath366 where @xmath156 and @xmath157 are integers such that @xmath367 note that @xmath368 bits are needed to store such a number .",
    "also , note that every positive real @xmath369 such that @xmath370 has a floating point approximation @xmath371 with relative precision @xmath372 we assume the presence of two look - up tables .",
    "the first will contain the floating - point approximations of @xmath373 .",
    "the second will contain the floating - point approximations of @xmath374 , where @xmath375 in order to exclude uninteresting cases , assume that @xmath376 and is such that @xmath377 .",
    "also , take @xmath345",
    "large enough so that @xmath378 is less than the maximum number we can represent by floating point . thus , we can assume that @xmath379 and @xmath380 .",
    "notice that in our case , we can bound both @xmath106 and @xmath107 from above by the number of tracks @xmath11 .",
    "thus , we will actually build beforehand two look - up tables of size @xmath381 bits .",
    "let @xmath371 denote the floating - point approximation of @xmath369 , and let @xmath382 and @xmath383 denote floating - point multiplication and division , respectively .",
    "for @xmath384 we define @xmath385 note that since we have stored the relevant numbers in our look - up table , the time needed to calculate the above function is only @xmath386 .",
    "the encoding procedure is given in figure  [ fig : enumerativecoder ] .",
    "we note the following points :    * the variables @xmath106 , @xmath387 , @xmath107 and @xmath388 are integers ( as opposed to floating - point numbers ) . * in the subtraction of @xmath389 from @xmath387 in line 5 , the floating - point number @xmath389 is `` promoted '' to an integer ( the result is an integer ) .",
    "* name : * @xmath390 +    * input : * integers @xmath391 such that @xmath105 and @xmath392 .",
    "* output : * a binary word of length @xmath106 and weight @xmath107 .",
    "if ( @xmath107 = = @xmath393 ) // stopping condition : / * 1 * / + return @xmath394 ; / * 2 * / + for ( @xmath395 ; @xmath396 ; @xmath388++ ) \\ { / * 3 * / + if ( @xmath397 ) / * 4 * / + @xmath398 ; / * 5 * / + else / * 6 * / + return @xmath399 ; / * 7 * / + } / * 8 * / +    we must now show that the procedure is valid , namely , that given a valid input , we produce a valid output . for our procedure , this reduce to showing two things : 1 ) if the stopping condition is not met , a recursive call will be made .",
    "2 ) the recursive call is given valid parameters as well .",
    "namely , in the recursive call , @xmath387 is non - negative .",
    "also , for the encoding to be invertible , we must further require that 3 ) @xmath400 for @xmath401 .",
    "condition 2 is clearly met , because of the check in line 4 .",
    "denote @xmath402 ( and so , @xmath403 ) .",
    "condition 3 follows from the next lemma .",
    "[ lemm : boundroundoff ] fix @xmath105 .",
    "then , @xmath404    the proof is essentially repeated invocations of ( [ eq : fp ] ) on the various stages of computation .",
    "we leave the details to the reader .",
    "finally , condition 1 follows easily from the next lemma .",
    "fix @xmath105 .",
    "then , @xmath405    the claim will follow if we show that @xmath406 this is immediate from lemma  [ lemm : boundroundoff ] and the binomial identity @xmath407    note that the penalty in terms of rate one suffers because of using our procedure ( instead of plain enumerative coding ) is negligible .",
    "namely , @xmath408 can be made arbitrarily close to @xmath409 .",
    "since we take @xmath380 and @xmath379 , we can show by amortized analysis that the running time of the procedure is @xmath410 .",
    "specifically , see ( * ? ? ?",
    "* section 17.3 ) , and take the potential of the binary vector corresponding to @xmath387 as the number of entries in it that are equal to ` @xmath393 ' .",
    "the decoding procedure is a straightforward `` reversal '' of the encoding procedure , and its running time is also @xmath410 .",
    "let @xmath411 be as in  , where we replace @xmath96 by @xmath172 and @xmath412 by @xmath188 . by the combinatorial interpretation of  , and the fact that @xmath209 for all @xmath95",
    ", it easily follows that @xmath413 .",
    "thus , @xmath414    denote by @xmath415 the base of natural logarithms . by stirling s formula",
    "we have @xmath416 and from we get that @xmath417 by ( [ eq : preflow_sumij ] ) and , @xmath418 since @xmath419 , we have @xmath420 moreover , by and , the rhs of the last equation equals @xmath421    we conclude that @xmath422    lastly , recall that @xmath423 and @xmath424 .",
    "thus , @xmath425 where @xmath426 is the entropy of the stationary markov chain @xmath130 with transition matrix @xmath135 . recall that @xmath130 was selected to be maxentropic : @xmath427 .",
    "this fact , along with and a short calculation , finishes the proof .",
    "the first author would like to thank roee engelberg for very helpful discussions .",
    "b.  h. marcus , r.  m. roth , and p.  h. siegel , `` constrained systems and coding for recording channels , '' in _ handbook of coding theory _ , v.  pless and w.  huffman , eds.1em plus 0.5em minus 0.4emamsterdam : elsevier , 1998 , pp ."
  ],
  "abstract_text": [
    "<S> a constant - rate encoder  decoder pair is presented for a fairly large family of two - dimensional ( 2-d ) constraints . encoding and decoding is done in a row - by - row manner , and is sliding - block decodable .    </S>",
    "<S> essentially , the 2-d constraint is turned into a set of independent and relatively simple one - dimensional ( 1-d ) constraints ; this is done by dividing the array into fixed - width vertical strips . each row in the strip </S>",
    "<S> is seen as a symbol , and a graph presentation of the respective 1-d constraint is constructed . </S>",
    "<S> the maxentropic stationary markov chain on this graph is next considered : a perturbed version of the corresponding probability distribution on the edges of the graph is used in order to build an encoder which operates _ in parallel _ on the strips . </S>",
    "<S> this perturbation is found by means of a network flow , with upper and lower bounds on the flow through the edges .    </S>",
    "<S> a key part of the encoder is an enumerative coder for constant - weight binary words . </S>",
    "<S> a fast realization of this coder is shown , using floating - point arithmetic .    </S>",
    "<S> @xmath0 the work of tuvi etzion was supported in part by the united states  </S>",
    "<S> israel binational science foundation ( bsf ) , jerusalem , israel , under grant no . </S>",
    "<S> 2006097 .    </S>",
    "<S> the work of ron m. roth was supported in part by the united states  </S>",
    "<S> israel binational science foundation ( bsf ) , jerusalem , israel , under grant no . </S>",
    "<S> 2002197 . </S>"
  ]
}