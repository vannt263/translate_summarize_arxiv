{
  "article_text": [
    "in the orthogonal range reporting problem , we store a set of points @xmath5 in a data structure so that for an arbitrary range @xmath6\\times \\ldots\\times [ a_d , b_d]$ ] all points from @xmath7 can be reported . due to its importance",
    ", one- and multi - dimensional range reporting was extensively studied in computational geometry and database communities .",
    "the following situation frequently arises in different areas of computer science : a set of @xmath8-dimensional objects @xmath9 must be preprocessed so that we can enumerate all objects satisfying @xmath10 for arbitrary @xmath11 , @xmath12 .",
    "this scenario can be modeled by the orthogonal range reporting problem .",
    "the objects in the input set can be distributed into _",
    "categories_. instead of enumerating all objects , we may want to report distinct categories of objects in the given range .",
    "this situation can be modeled by the color ( or categorical ) range reporting problem : every point in a set @xmath5 is assigned a color ( category ) ; we pre - process @xmath5 , so that for any @xmath6\\times \\ldots\\times [ a_d , b_d]$ ] the distinct colors of points in @xmath7 can be reported .",
    "color range reporting is usually considered to be a more complex problem than point reporting .",
    "for one thing , we do not want to report the same color multiple times . in this paper",
    "we show that complexity gap can be closed for one - dimensional color range reporting .",
    "we describe color reporting data structures with the same space usage and query time as the best known corresponding structures for point reporting .",
    "moreover we extend our result to the external memory model .",
    "[ [ previous - work . ] ] previous work .",
    "+ + + + + + + + + + + + + +    we can easily report points in a one - dimensional range @xmath13 $ ] by searching for the successor of @xmath14 in @xmath5 , @xmath15 .",
    "if @xmath16 is known , we can traverse the sorted list of points in @xmath5 starting at @xmath17 and report all elements in @xmath18 $ ] .",
    "we can find the successor of @xmath14 in @xmath5 in @xmath19 time  @xcite ; if the universe size is @xmath20 , i.e. , if all points are positive integers that do not exceed @xmath20 , then the successor can be found in @xmath21 time  @xcite .",
    "thus we can report all points in @xmath18 $ ] in @xmath22 time for @xmath23 .",
    "henceforth @xmath3 denotes the number of elements ( points or colors ) in the query answer .",
    "it is not possible to find the successor in @xmath24 time unless the universe size @xmath20 is very small or the space usage of the data structure is very high ; see e.g. ,  @xcite .",
    "however , reporting points in a one - dimensional range takes less time than searching for a successor . in their fundamental paper",
    "@xcite , miltersen et al . showed that one - dimensional point reporting queries can be answered in @xmath25 time using an @xmath26 space data structure .",
    "alstrup et al .",
    "@xcite obtained another surprising result : they presented an @xmath1-space data structure that answers point reporting queries in @xmath25 time and thus achieved both optimal query time and optimal space usage for this problem .",
    "the data structure for one - dimensional point reporting can be dynamized so that queries are supported in @xmath25 time and updates are supported in @xmath27 time  @xcite ; henceforth @xmath28 denotes an arbitrarily small positive constant .",
    "we refer to  @xcite for further update - query time trade - offs .",
    "solutions of the one - dimensional point reporting problem are based on finding an arbitrary element @xmath29 in a query range @xmath30 $ ] ; once such @xmath29 is found , we can traverse the sorted list of points until all points in @xmath30 $ ] are reported .",
    "therefore it is straightforward to extend point reporting results to the external memory model .",
    "janardan and lopez  @xcite and gupta et al .",
    "@xcite showed that one - dimensional color reporting queries can be answered in @xmath31 time , both in the static and the dynamic scenarios .",
    "muthukrishnan  @xcite described a static @xmath1 space data structure that answers queries in @xmath25 time if all point coordinates are bounded by @xmath4 .",
    "we can obtain data structures that use @xmath1 space and answer queries in @xmath32 or @xmath33 time using the reduction - to - rank - space technique .",
    "no data structure that answers one - dimensional color reporting queries in @xmath34 time was previously known .",
    "a dynamic data structure of mortensen  @xcite supports queries and updates in @xmath35 and @xmath36 time respectively if the values of all elements are bounded by @xmath4 .",
    "recently , the one- and two - dimensional color range reporting problems in the external memory model were studied in several papers  @xcite .",
    "larsen and pagh  @xcite described a data structure that uses linear space and answers one - dimensional color reporting queries in @xmath37 i / os if values of all elements are bounded by @xmath1 . in the case when values of elements are unbounded the best previously known data structure needs @xmath38 i / os to answer a query ; this result can be obtained by combining the data structure from  @xcite and reduction of one - dimensional color reporting to three - sided\\times [ 0,c]$ ] and @xmath30\\times [ c,+\\infty]$ ] are three - sdied queries . ]",
    "point reporting  @xcite .",
    "in another recent paper  @xcite , chan et al . described a data structure that supports the following queries on a set of points whose values are bounded by @xmath1 : for any query point @xmath39 and any integer  @xmath3 , we can report the first @xmath3 colors that occur after @xmath39 . this data structure can be combined with the result from  @xcite to answer queries in @xmath2 time .",
    "unfortunately , the solution in  @xcite is based on the hive graph data structure  @xcite . therefore it can not be used to solve the problem in external memory or to obtain a dynamic solution .",
    "[ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + +    as can be seen from the above discussion and table  [ tab : res ] , there are significant complexity gaps between color reporting and point reporting data structures in one dimension .",
    "we show in this paper that it is possible to close these gaps .    in this paper",
    "we show that one - dimensional color reporting queries can be answered in constant time per reported color for an arbitrarily large size of the universe .",
    "our data structure uses @xmath1 space and supports color reporting queries in @xmath2 time .",
    "this data structure can be dynamized so that query time and space usage remain unchanged ; the updates are supported in @xmath27 time where @xmath20 is the size of the universe .",
    "the new results are listed at the bottom of table  [ tab : res ] .",
    "our internal memory results are valid in the word ram model of computation , the same model that was used in e.g.  @xcite . in this model , we assume that any standard arithmetic operation and the basic bit operations can be performed in constant time .",
    "we also assume that each word of memory consists of @xmath40 bits , where @xmath20 is the size of the universe .",
    "that is , we make a reasonable and realistic assumption that the value of any element fits into one word of memory .",
    "furthermore , we also extend our data structures to the external memory model .",
    "our static data structure uses linear space and answers color reporting queries in @xmath41 i / os . our dynamic external data structure also has optimal space usage and query cost ; updates are supported in @xmath42 i / os .    [ cols=\"<,<,^,^,^,^ \" , ]",
    "we start by describing a static data structure that uses @xmath1 space and answers color reporting queries in @xmath2 time .",
    "all elements of a set @xmath5 are stored in a balanced binary tree @xmath43 .",
    "every leaf of @xmath43 , except for the last one , contains @xmath44 elements , the last leaf contains at most @xmath44 elements , and every internal node has two children . for any node @xmath45 , @xmath46 denotes the set of all elements stored in the leaf descendants of @xmath47 . for every color @xmath48 that occurs in @xmath46 ,",
    "the set @xmath49 ( @xmath50 ) contains the minimal ( maximal ) element @xmath51 of color @xmath48 . the list @xmath52 contains the @xmath44 smallest elements of @xmath49 in increasing order .",
    "the list @xmath53 contains the @xmath44 largest elements of @xmath50 in decreasing order . for every internal non - root node @xmath47 we store the list",
    "@xmath52 if @xmath47 is the right child of its parent ; if @xmath47 is the left child of its parent , we store the list @xmath53 for @xmath47 .",
    "all lists @xmath52 and @xmath53 , @xmath45 , contain @xmath1 elements in total since the tree has @xmath54 internal nodes .",
    "we define the middle value @xmath55 for an internal node @xmath47 as the minimal value stored in the right child of @xmath47 , @xmath56 where @xmath57 is the right child of @xmath47 . the following _ highest range ancestor _ query plays a crucial role in the data structures of this and the following sections .",
    "the answer to the highest range ancestor query @xmath58 for a leaf @xmath59 and values @xmath60 is the highest ancestor @xmath47 of @xmath59 , such that @xmath61 ; if @xmath18=\\emptyset$ ] , the answer is undefined .",
    "the following fact elucidates the meaning of the highest range ancestor .",
    "[ fact : eluc ] let @xmath62 be the leaf that holds the smallest @xmath63 , such that @xmath64 ; let @xmath65 be the leaf that holds the largest @xmath63 , such that @xmath66 .",
    "suppose that @xmath67\\not=\\emptyset$ ] for some leaf @xmath59 and @xmath47 is the answer to the highest range ancestor query @xmath58 .",
    "then @xmath47 is the lowest common ancestor of @xmath62 and @xmath65 .",
    "let @xmath68 denote the lowest common ancestor of @xmath62 and @xmath65 .",
    "then @xmath62 and @xmath65 are in @xmath68 s left and right subtrees respectively .",
    "hence , @xmath69 and @xmath68 is not an ancestor of @xmath47 .",
    "if @xmath68 is a descendant of @xmath47 and @xmath68 is in the right subtree of @xmath47 , then @xmath70 . if @xmath68 is in the left subtree of @xmath47 , then @xmath71 .",
    "we will show that we can find @xmath47 without searching for @xmath62 and @xmath65 and answer highest range ancestor queries on a balanced tree in constant time .    for every leaf @xmath59 , we store two auxiliary data structures .",
    "all elements of @xmath72 are stored in a data structure @xmath73 that uses @xmath74 space and answers color reporting queries on @xmath72 in @xmath2 time .",
    "we also store a data structure @xmath75 that uses @xmath76 space ; for any @xmath60 , such that @xmath67\\not=\\emptyset$ ] , @xmath75 answers the highest range ancestor query @xmath58 in @xmath77 time .",
    "data structures @xmath73 and @xmath75 will be described later in this section .",
    "moreover , we store all elements of @xmath5 in the data structure described in  @xcite that supports one - reporting queries : for any @xmath60 , some element @xmath78 $ ] can be found in @xmath77 time ; if @xmath18=\\emptyset$ ] , the data structure returns a dummy element @xmath79 . finally , all elements of @xmath5 are stored in a slow data structure that uses @xmath1 space and answers color reporting queries in @xmath80 time .",
    "we can use e.g. the data structure from  @xcite for this purpose .",
    "[ [ answering - queries . ] ] answering queries .",
    "+ + + + + + + + + + + + + + + + + +    all colors in a query range @xmath30 $ ] can be reported with the following procedure . using the one - reporting data structure from  @xcite , we search for some @xmath81 $ ] if at least one such @xmath29 exists .",
    "if no element @xmath29 satisfying @xmath82 is found , then @xmath18=\\emptyset$ ] and the query is answered .",
    "otherwise , let @xmath83 denote the leaf that contains @xmath29 .",
    "using @xmath84 , we search for the highest ancestor  @xmath47 of @xmath83 such that @xmath85 . if no such @xmath47 is found , then all @xmath29 , @xmath82 , are in @xmath86 .",
    "we can report all colors in @xmath87 $ ] using @xmath88 .",
    "if @xmath84 returned some node @xmath47 , we proceed as follows .",
    "let @xmath89 and @xmath57 denote the left and the right children of @xmath47 .",
    "we traverse the list @xmath90 until an element @xmath91 is found or the end of @xmath90 is reached .",
    "we also traverse @xmath92 until an element @xmath93 is found or the end of @xmath92 is reached . if we reach neither the end of @xmath90 nor the end of @xmath92 , then the color of every encountered element @xmath94 , @xmath66 , and @xmath95 , @xmath64 , is reported . otherwise the range @xmath30 $ ] contains at least @xmath44 different colors . in the latter case",
    "we can use any data structure for one - dimensional color range reporting  @xcite to identify all colors from @xmath96 $ ] in @xmath97 time .",
    "[ [ leaf - data - structures . ] ] leaf data structures . + + + + + + + + + + + + + + + + + + + + +    a data structure @xmath73 answers color reporting queries on @xmath72 as follows . in  @xcite , the authors show how a one - dimensional color reporting query on a set of @xmath98 one - dimensional elements can be answered by answering a query @xmath30\\times [ 0,a]$ ] on a set of @xmath98 uncolored two - dimensional points .",
    "a standard priority search tree  @xcite enables us to answer queries of the form @xmath30\\times [ 0,a]$ ] on @xmath98 points in @xmath99 time .",
    "using a combination of fusion trees and priority search trees , described by willard  @xcite , we can answer queries in @xmath100 time .",
    "the data structure of willard  @xcite uses @xmath101 space and a universal look - up table of size @xmath102 for an arbitrarily small @xmath28 .",
    "updates are also supported in @xmath100 time points , but extension to the case of any @xmath103 is straightforward . ] .",
    "since @xmath72 contains @xmath104 elements , we can answer colored queries on @xmath72 in @xmath105 time .",
    "updates are also supported in @xmath77 time ; this fact will be used in section  [ sec : dyncol ] .",
    "now we describe how @xmath75 is implemented .",
    "suppose that @xmath67\\not=\\emptyset$ ] for some leaf @xmath59 .",
    "let @xmath106 be the path from @xmath59 to the root of @xmath43 .",
    "we say that a node @xmath107 is a _ left parent _ if @xmath108 for the left child @xmath89 of @xmath47 ; a node @xmath107 is a _ right parent _ if @xmath109 for the right child @xmath57 of @xmath47 .",
    "if @xmath72 contains at least one @xmath110 $ ] , then the following is true .",
    "[ fact : val ] if @xmath107 is a left parent , then @xmath111 .",
    "if @xmath107 is a right parent , then @xmath112 .",
    "if @xmath113 is a left parent , then @xmath72 is in its left subtree .",
    "hence , @xmath55 is greater than any @xmath114 and @xmath111 . if @xmath47 is the right parent , than @xmath72 is in its right subtree .",
    "hence , @xmath55 is smaller than or equal to any @xmath114 and @xmath115 .",
    "[ fact : mono ] if @xmath116 is a left parent and @xmath117 is an ancestor of @xmath118 , then @xmath119 . if @xmath116 is a right parent and @xmath117 is an ancestor of @xmath118 , then @xmath120 .",
    "if @xmath117 is a left parent , then @xmath121 is in its left subtree .",
    "hence , @xmath122 by definition of @xmath55 .",
    "if @xmath121 is a right parent , then @xmath117 is in its right subtree .",
    "hence , @xmath123 by definition of @xmath55 .",
    "suppose that we want to find the highest range ancestor of @xmath59 for a range @xmath30 $ ] such that @xmath67\\not=\\emptyset$ ] .",
    "let @xmath124 be the set of middle values @xmath55 for left parents",
    "@xmath113 sorted by height ; let @xmath125 be the set of @xmath55 for right parents @xmath113 sorted by height .",
    "by fact  [ fact : mono ] , elements of @xmath126 ( @xmath127 ) increase ( decrease ) monotonously .",
    "by fact  [ fact : val ] , @xmath111 for any @xmath128 and @xmath129 for any @xmath130 . using fusion trees  @xcite",
    ", we can search in @xmath126 and find the highest node @xmath131 such that @xmath117 is a left parent and @xmath132 .",
    "we can also search in @xmath127 and find the highest node @xmath118 such that @xmath121 is a right parent and @xmath133 .",
    "let @xmath47 denote the higher node among @xmath117 , @xmath121 .",
    "then @xmath47 is the highest ancestor of @xmath59 such that @xmath134 $ ] .",
    "= 1000    [ [ removing - duplicates . ] ] removing duplicates",
    ". + + + + + + + + + + + + + + + + + + + +    when a query is answered , our procedure returns a color @xmath48 two times if @xmath48 occurs in both @xmath135 $ ] and @xmath136 $ ] .",
    "we can easily produce a list without sorting in which each color occurs exactly once .",
    "let @xmath137 denote an array with one entry for every color that occurs in a data structure .",
    "initially @xmath138=0 $ ] for all @xmath139 .",
    "we traverse the list of colors @xmath140 produced by the above described procedure .",
    "every time when we encounter a color @xmath48 in @xmath140 such that @xmath141=0 $ ] , we set @xmath141=1 $ ] ; when we encounter a color @xmath48 such that @xmath141=1 $ ] , we remove the corresponding entry from @xmath140 .",
    "when the query is answered , we traverse @xmath140 once again and set @xmath142=0 $ ] for all @xmath143 .",
    "[ theor : col1d ] there exists an @xmath1-space data structure that supports one - dimensional color range reporting queries in @xmath2 time .",
    "the static data structure of section  [ sec : statcol ] can be used for answering queries in external memory . we only need to increase the sizes of @xmath72 , @xmath53 , and @xmath52 to @xmath144 , and use an external memory variant of the slow data structure for color reporting  @xcite .",
    "this approach enables us to achieve @xmath41 query cost , but one important issue should be addressed . as explained in section  [ sec : statcol ] , the same color can be reported twice when a query is answered . however , we can not get rid of duplicates in @xmath41 i / os using the method of section  [ sec : statcol ] because of its random access to the list of reported colors .",
    "therefore we need to make further changes in our internal memory solution . for an element @xmath63 ,",
    "let @xmath145 denote the largest element @xmath146 of the same color .",
    "for every element @xmath29 in @xmath52 and any @xmath147 , we also store the value of @xmath145 .",
    "we define each set @xmath72 for a leaf @xmath59 to contain @xmath148 points .",
    "lists @xmath149 and @xmath150 for an internal node @xmath151 contain @xmath144 leftmost points from @xmath152 ( respectively , @xmath144 rightmost points from @xmath153 ) .",
    "data structures @xmath75 are implemented as in section  [ sec : statcol ] .",
    "a data structure @xmath73 supports color reporting queries on @xmath72 and is implemented as follows .",
    "we can answer a one - dimensional color reporting query by answering a three - sided point reporting query on a set @xmath154 of @xmath155 two - dimensional points ; see e.g. ,  @xcite . if @xmath156 , @xmath72 and @xmath154 contain @xmath157 points . in this case",
    "we can use the data structure from  @xcite that uses linear space and answers three - sided queries in @xmath158 i / os . if @xmath159 , @xmath72 and @xmath154 contain @xmath160 points . using the data structure from  @xcite",
    ", we can find the predecessor of any value @xmath151 in a set of @xmath160 points in @xmath77 i / os .",
    "therefore we can apply the rank - space technique  @xcite and reduce three - sided point reporting queries on @xmath154 to three - sided point reporting queries on a grid of size @xmath161 ( i.e. , to the case when coordinates of all points are integers bounded by @xmath161 ) using a constant number of additional i / os .",
    "larsen and pagh  @xcite described a linear space data structure that answers three - sided point reporting queries for @xmath98 points on an @xmath162 grid in @xmath41 i / os . summing up",
    ", we can answer a three - sided query on a set of @xmath144 points in @xmath41 i / os .",
    "hence , we can also answer a color reporting query on @xmath72 in @xmath41 i / os using linear space .",
    "a query @xmath13 $ ] is answered as follows .",
    "we find the highest range ancestor @xmath47 for any @xmath78 $ ] exactly as in section  [ sec : statcol ] .",
    "if @xmath47 is a leaf , we answer the query using @xmath163 .",
    "otherwise the reporting procedure proceeds as follows .",
    "we traverse the list @xmath92 for the left child @xmath89 of @xmath47 until some point @xmath164 is found .",
    "if @xmath64 for all @xmath95 , then there are at least @xmath144 different colors in @xmath30 $ ] and we can use a slow data structure to answer a query in @xmath165 i / os . otherwise we traverse @xmath90 and report all elements @xmath29 such that @xmath166 . if @xmath167 for @xmath168 , then an element of the same color was reported when @xmath92 was traversed .",
    "traversal of @xmath90 stops when an element @xmath169 is encountered or the end of @xmath90 is reached . in the former case , we reported all colors in @xmath30 $ ] . in the latter case",
    "the number of colors in @xmath30 $ ] is at least @xmath144 .",
    "this is because every element in @xmath90 corresponds to a distinct color that occurs at least once in @xmath30 $ ] .",
    "hence , we can use the slow data structure and answer the query in @xmath170 i / os .    [ theor : col1dext ] there exists a linear - space data structure that supports one - dimensional color range reporting queries in @xmath171 i / os .",
    "in this section we show how the base tree and auxiliary data structures of the static solution can be modified for usage in the dynamic scenario .",
    "to dynamize the data structure of section  [ sec : statcol ] , we slightly change the balanced tree @xmath43 and secondary data structures : every leaf of @xmath43 now contains @xmath172 elements of @xmath5 and each internal node has @xmath173 children .",
    "we store the lists @xmath52 and @xmath53 in each internal non - root node of @xmath47 .",
    "we associate several values @xmath174 to each node @xmath47 : for every child  @xmath175 of  @xmath47 , except the leftmost child @xmath117 , @xmath176 .",
    "the highest range ancestor of a leaf @xmath59 is the highest ancestor @xmath47 of @xmath59 such that @xmath177 for at least one @xmath178 .",
    "data structures @xmath73 and @xmath75 are defined as in section  [ sec : statcol ] .",
    "we also maintain a data structure of  @xcite that reports an arbitrary element @xmath78 $ ] if the range @xmath30 $ ] is not empty .",
    "we implement the base tree @xmath43 as the weight - balanced b - tree  @xcite with the leaf parameter @xmath44 and the branching parameter @xmath179 .",
    "this means that every internal node has between @xmath180 and @xmath181 children and each leaf contains between @xmath182 and @xmath183 elements .",
    "each internal non - root node on level @xmath184 of @xmath43 has between @xmath185 and @xmath186 elements in its subtree .",
    "if the number of elements in some node @xmath47 exceeds @xmath185 , we split @xmath47 into two new nodes , @xmath187 and @xmath188 . in this case",
    "we insert a new value @xmath189 for the parent @xmath68 of @xmath47 .",
    "hence , we may have to update the data structures @xmath75 for all leaf descendants of @xmath68 .",
    "a weight - balanced b - tree is engineered in such a way that a split occurs at most once in a sequence of @xmath190 insertions ( for our choice of parameters ) . since @xmath75 can be updated in @xmath77 time",
    ", the total amortized cost incurred by splitting nodes is @xmath77 .",
    "when an element @xmath29 is deleted , we delete it from the set @xmath72 .",
    "if @xmath191 for a deleted element @xmath29 and some node @xmath47 , we do not change the value of @xmath174 .",
    "we also do not start re - balancing if some node contains too few elements in its subtree .",
    "but we re - build the entire tree @xmath43 if the total number of deleted elements equals @xmath192 , where @xmath193 is the number of elements that were stored in @xmath43 when it was built the last time .",
    "updates can be de - amortized without increasing the cost of update operations by scheduling the procedure of re - building nodes ( respectively , re - building the tree )  @xcite    [ [ auxiliary - data - structures . ] ] auxiliary data structures .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    we implement @xmath73 in the same way as in section  [ sec : statcol ] .",
    "hence color queries on @xmath72 are answered in @xmath194 time and updates are also supported in @xmath77 time  @xcite .    we need to modify data structures @xmath75 , however , because @xmath43 is not a binary tree in the dynamic case .",
    "let @xmath106 denote a path from @xmath59 to the root for some leaf @xmath59 .",
    "we say that a node @xmath47 is an @xmath139-node if @xmath195 for the @xmath139-th child @xmath175 of @xmath47 .",
    "[ fact : val2 ] suppose that @xmath67\\not=\\emptyset$ ] and @xmath106 is the path from @xmath59 to the root .",
    "if @xmath113 is an @xmath139-node , then @xmath196 for @xmath197 and @xmath198 for @xmath199 .",
    "we say that a value @xmath200 for @xmath113 is a _ left value _ if @xmath201 and @xmath47 is an @xmath139-node .",
    "a value @xmath200 for @xmath113 is a _",
    "right value _ if @xmath202 and @xmath47 is an @xmath139-node .",
    "[ fact : mono2 ] if @xmath203 is a left value and @xmath131 is an ancestor of @xmath118 , then @xmath204 for any @xmath205 .",
    "if @xmath203 is a right value and @xmath131 is an ancestor of @xmath118 , then @xmath206 for any @xmath205 .",
    "it is easy to check facts  [ fact : val2 ] and  [ fact : mono2 ] using the same arguments as in section  [ sec : statcol ] .",
    "we store all left values @xmath200 , @xmath113 , in a set @xmath126 ; @xmath200 in @xmath126 are sorted by the height of  @xmath47 .",
    "we store all right values @xmath200 , @xmath113 , in a set @xmath127 ; @xmath200 in @xmath127 are also sorted by the height of @xmath47 .",
    "using fusion trees on @xmath126 , we can find the highest node @xmath117 , such that at least one left value @xmath207 .",
    "we can also find the highest @xmath121 such that at least one right value @xmath208 .",
    "since @xmath126 and @xmath127 contain @xmath76 elements , we can support searching and updates in @xmath77 time ; see  @xcite .",
    "by fact  [ fact : val2 ] , @xmath209 and @xmath210 .",
    "if @xmath47 is the higher node among @xmath117 , @xmath121 , then @xmath47 is an answer to the highest range ancestor query @xmath30 $ ] for a node @xmath59 .",
    "in this section we describe a dynamic data structure with optimal query time .",
    "our improvement combines an idea from  @xcite with the highest range ancestor approach .",
    "we also use a new solution for a special case of two - dimensional point reporting problem presented in section  [ sec : fast3sid ] .",
    "let @xmath211 denote the height of a node @xmath47 .",
    "for an element @xmath63 let @xmath212 , where @xmath187 is the highest ancestor of the leaf containing @xmath29 , such that @xmath213 .",
    "we define @xmath214 in the same way with respect to @xmath50 .",
    "all colors in a range @xmath30 $ ] can be reported as follows .",
    "we identify an arbitrary @xmath78 $ ] . using the highest range ancestor data structure ,",
    "we can find the lowest common ancestor @xmath47 of the leaves that contain @xmath14 and @xmath215 .",
    "let @xmath216 and @xmath217 be the children of @xmath47 that contain the successor of @xmath14 and the predecessor of @xmath215 .",
    "let @xmath218 , @xmath219 ; let @xmath220 for @xmath221 and @xmath222 for @xmath223 .",
    "we can identify unique colors of relevant points stored in each node @xmath224 , @xmath225 , by finding all @xmath226 $ ] such that @xmath227 .",
    "this condition is equivalent to reporting all @xmath226 $ ] such that @xmath228 .",
    "we can identify all colors of relevant points in @xmath216 by reporting all @xmath229 $ ] such that @xmath230 .",
    "queries of the form @xmath110 $ ] , @xmath231 , ( respectively @xmath110 $ ] , @xmath232 ) can be supported using lemma  [ lemma : fast ] .",
    "while the same color can be reported several times , we can get rid of duplicates as explained in section  [ sec : statcol ] .    when a new point is inserted into @xmath5 or when a point is deleted from @xmath5",
    ", we can update the values of @xmath233 and @xmath214 in @xmath234 time .",
    "we refer to  @xcite for details .",
    "while updates of data structures of lemma  [ lemma : fast ] are fast , re - balancing the base tree can be a problem . as described in section  [ sec : dyncol ] , when the number of points in a node @xmath47 on level @xmath184 exceeds @xmath235 , we split it into two nodes , @xmath187 and @xmath188 . as a result ,",
    "the values @xmath233 for @xmath29 stored in the leaves of @xmath188 can be incremented .",
    "hence , we would have to examine the leaf descendants of @xmath188 and recompute their values for some of them .",
    "since the height of @xmath43 is logarithmic , the total cost incurred by re - computing the values @xmath233 and @xmath214 is @xmath76 .",
    "the problem of reducing the cost of re - building the tree will be solved in the following sections . in appendix",
    "[ sec : slow ] we describe another data structure that supports fast updates but answering queries takes polynomial time in the worst case . in section  [ sec : fullydyn ] we show how the cost of splitting can be reduced by modifying the definition of @xmath233 , @xmath214 and using the slow data structure from appendix  [ sec : slow ] when the number of reported colors is sufficiently large .",
    "let @xmath236 denote the number of leaves in the subtree of a node @xmath47 .",
    "let @xmath237 denote the set of @xmath238 smallest elements in @xmath49 ; let @xmath239 denote the set of @xmath238 largest elements in @xmath50 .",
    "we maintain the values @xmath240 and @xmath241 for @xmath63 , such that for any @xmath45 we have : @xmath242 if @xmath243 and",
    "@xmath244 if @xmath245 ; @xmath246 if @xmath247 and @xmath248 if @xmath249",
    ". we keep @xmath240 and @xmath241 in data structures of lemma  [ lemma : fast ] .",
    "we maintain the data structure described in section  [ sec : slow ] .",
    "this data structure is used to answer queries when the number of colors in the query range is large .",
    "it is also used to update the values of @xmath240 and @xmath241 when a node is split .    to answer a query @xmath30 $ ]",
    ", we proceed in the same way as in section  [ sec : del ] .",
    "let @xmath47 , @xmath216 , @xmath217 , and @xmath250 , @xmath251 , @xmath252 be defined as in section  [ sec : del ] .",
    "distinct colors in each @xmath253 $ ] , @xmath252 , can be reported using the data structure of lemma  [ lemma : fast ] .",
    "if the answer to at least one of the queries contains at least @xmath254 elements , then there are at least @xmath254 different colors in @xmath30 $ ] .",
    "the total number of elements in @xmath30\\cap s$ ] does not exceed @xmath255 .",
    "hence , we can employ the data structure from section  [ sec : slow ] to report all colors from @xmath30 $ ] in @xmath256\\cap s)^{1/2}+k)=o(k)$ ] time .",
    "if answers to all queries contain less than @xmath254 elements , then for every distinct color that occurs in @xmath30 $ ] there is an element @xmath29 such that @xmath257 $ ] , @xmath258 , or @xmath259 $ ] . by definition of @xmath260 and @xmath261",
    "we can correctly report up to @xmath254 leftmost colors in @xmath262 or up to @xmath254 rightmost colors in @xmath263 .",
    "= 500 when a new element @xmath29 is inserted , we compute the values of @xmath233 , @xmath214 and update the values of @xmath264 , @xmath265 , where @xmath266 is the element of the same color as @xmath29 that follows @xmath29 .",
    "this can be done in the same way as in section  [ sec : del ] .",
    "when a node @xmath47 on level @xmath184 is split into @xmath187 and @xmath188 , we update the values of @xmath233 and @xmath214 for @xmath267 .",
    "if @xmath268 , we examine all @xmath267 and re - compute the values of @xmath145 , @xmath233 , and @xmath214 . amortized cost of re - building nodes @xmath47 on @xmath269 lowest tree levels is @xmath36 . if @xmath270 , @xmath46 contains @xmath271 elements .",
    "we can find @xmath272 elements in @xmath273 , @xmath274 , @xmath275 , and @xmath276 using the data structure from lemma  [ lemma : slowcount ] .",
    "this takes @xmath277 time . since we split a node @xmath47 one time after @xmath278 insertions ,",
    "the amortized cost of splitting nodes on level @xmath279 is @xmath77 .",
    "thus the total cost incurred by splitting nodes after insertions is @xmath36 .",
    "deletions are processed in a symmetric way .",
    "thus we obtain the following result    [ theor : dyn ] there exists a linear space data structure that supports one - dimensional color range reporting queries in @xmath2 time and updates in @xmath42 amortized time .    10    s.  alstrup , g.  s. brodal , and t.  rauhe .",
    "new data structures for orthogonal range searching . in _ proc .",
    "41st annual symposium on foundations of computer science ( focs 2000 ) _ , pages 198207 , 2000 .",
    "s.  alstrup , g.  s. brodal , and t.  rauhe .",
    "optimal static range reporting in one dimension . in _ proc .",
    "33rd annual acm symposium on theory of computing ( stoc ) _ , pages 476482 , 2001 .",
    "l.  arge , v.  samoladas , and j.  s. vitter . on two - dimensional indexability and optimal range search indexing . in _ proc .",
    "18th acm sigact - sigmod - sigart symposium on principles of database systems ( pods ) _ , pages 346357 , 1999 .",
    "l.  arge and j.  s. vitter .",
    "optimal external memory interval management .",
    ", 32(6):14881508 , 2003 .",
    "p.  beame and f.  e. fich .",
    "optimal bounds for the predecessor problem and related problems . , 65(1):3872 , 2002 .",
    "t.  m. chan , s.  durocher , m.  skala , and b.  t. wilkinson .",
    "linear - space data structures for range minority query in arrays . in _ 13th scandinavian symposium and workshops on algorithm theory ( swat ) _ , pages 295306 , 2012 .",
    "b.  chazelle .",
    "filtering search : a new approach to query - answering .",
    ", 15(3):703724 , 1986 .",
    "m.  l. fredman and d.  e. willard .",
    "trans - dichotomous algorithms for minimum spanning trees and shortest paths .",
    ", 48(3):533551 , 1994 .",
    "h.  n. gabow , j.  l. bentley , and r.  e. tarjan .",
    "scaling and related techniques for geometry problems . in _ proc .",
    "16th annual acm symposium on theory of computing ( stoc 1984 ) _ , pages 135143 , 1984 .",
    "p.  gupta , r.  janardan , and m.  h.  m. smid .",
    "further results on generalized intersection searching problems : counting , reporting , and dynamization .",
    ", 19(2):282317 , 1995 .",
    "r.  janardan and m.  a. lopez .",
    "generalized intersection searching problems .",
    ", 3(1):3969 , 1993 .    k.  g. larsen and r.  pagh .",
    "-efficient data structures for colored range and prefix reporting . in _ proc .",
    "23rd annual acm - siam symposium on discrete algorithms ( soda ) _ , pages 583592 , 2012 .    k.  g. larsen and f.  van walderveen .",
    "near - optimal range reporting structures for categorical data . in _ proc .",
    "24th annual acm - siam symposium on discrete algorithms ( soda ) _",
    ", page to appear , 2013 .",
    "e.  m. mccreight .",
    "priority search trees . , 14(2):257276 , 1985 .",
    "b. miltersen , n.  nisan , s.  safra , and a.  wigderson . on data structures and asymmetric communication complexity .",
    ", 57(1):3749 , 1998 .    c.  w. mortensen .",
    "generalized static orthogonal range searching in less space .",
    "technical report , it university technical report series 2003 - 33 , 2003 .    c.  w. mortensen , r.  pagh , and m.  patrascu . on dynamic range reporting in one dimension . in _ proc .",
    "37th annual acm symposium on theory of computing ( stoc ) _ , pages 104111 , 2005 .",
    "s.  muthukrishnan .",
    "efficient algorithms for document retrieval problems . in _ proc .",
    "13th annual acm - siam symposium on discrete algorithms ( soda ) _ , pages 657666 , 2002 .",
    "y.  nekrich .",
    "space - efficient range reporting for categorical data . in _ proc .",
    "31st acm sigmod - sigact - sigart symposium on principles of database systems ( pods ) _ , pages 113120 , 2012 .",
    "q.  shi and j.  jj .",
    "optimal and near - optimal algorithms for generalized intersection reporting on pointer machines .",
    ", 95(3):382388 , 2005 .",
    "m.  thorup .",
    "undirected single - source shortest paths with positive integer weights in linear time .",
    ", 46(3):362394 , 1999 .",
    "p.  van emde  boas , r.  kaas , and e.  zijlstra .",
    "design and implementation of an efficient priority queue .",
    ", 10:99127 , 1977 .",
    "d.  e. willard . examining computational geometry , van emde boas trees , and hashing from the perspective of the fusion tree .",
    ", 29(3):10301049 , 2000 .",
    "in this section we describe a data structure that efficiently supports ( uncolored ) two - dimensional queries in the case when the @xmath280-coordinate @xmath281 of each point @xmath282 does not exceed @xmath44 and the query range is bounded on three sides , two sides in the @xmath283-dimension and one side in the @xmath280-dimension ; the @xmath283-coordinate @xmath284 of each @xmath282 does not exceed the value of parameter @xmath20 .",
    "this result is used in the dynamic solution of the color range reporting problem .",
    "we also believe it to be of independent interest .",
    "[ lemma : fast ] let @xmath5 be a set of two - dimensional points such that @xmath285 for all @xmath282 . there exists a linear - space data structure that reports all points @xmath286\\times [ c,\\log n]$ ] in @xmath2 time and supports updates in @xmath42 time , where @xmath20 is the size of the universe .",
    "we divide the points into consecutive groups @xmath287 according to their @xmath283-coordinates .",
    "each group , except the last one , contains @xmath288 points ; the last group contains @xmath76 points . for every group @xmath287 and for each value @xmath289 , we keep two values @xmath290 and @xmath291 . intuitively , we can access the value of @xmath292 and @xmath293 for any @xmath294 and @xmath139 by examining @xmath77 values @xmath290 or @xmath291 .",
    "we remark that we can not directly store the values of @xmath295 in @xmath291 because an update operation would be too costly .",
    "let @xmath296 .",
    "when a new point @xmath297 is inserted , we represent @xmath298 in base @xmath299 as a sum of powers is a power of @xmath299 .",
    "] of @xmath299 : @xmath300 where @xmath301 and @xmath302 .",
    "let @xmath303 for @xmath304 and @xmath305 be defined as @xmath306 .",
    "let @xmath287 denote the group into which @xmath297 must be inserted .",
    "we examine the values @xmath307 and @xmath308 for all @xmath304 and @xmath305 .",
    "if @xmath309 or @xmath310 , we update their values .",
    "the deletion procedure is symmetric . in both cases ,",
    "we examine and update @xmath102 values .",
    "[ fact : simp ] suppose that some @xmath311 contains at least one point @xmath297 such that @xmath312 $ ] and @xmath313 .",
    "suppose further that @xmath314 or @xmath315 .",
    "then either @xmath316 $ ] or @xmath317 $ ] .",
    "[ fact : sel ] for any @xmath294 , we can select @xmath77 values @xmath318 , such that for any @xmath139 there is at least one @xmath319 , @xmath320 , satisfying @xmath321 and at least one @xmath322 , @xmath323 , satisfying @xmath324 .",
    "let @xmath325 where @xmath301 .",
    "we set @xmath326 , @xmath327 , @xmath328 , @xmath329 , @xmath328 , @xmath330 .",
    "if @xmath331 , then there is a point @xmath297 , such that @xmath332 and @xmath333 .",
    "let @xmath334 .",
    "if @xmath335 , we consider an index @xmath336 such that @xmath337 and @xmath338 for @xmath339 . by definition of @xmath340 , @xmath341 , where @xmath342 . by our choice of @xmath343 , @xmath344",
    "hence , @xmath345 . if @xmath346 , then @xmath347 and @xmath348 .",
    "the statement concerning @xmath349 can be proved in the same way .",
    "facts  [ fact : simp ] and  [ fact : sel ] suggest the following method for answering queries . for any @xmath294 , @xmath350 , we store all @xmath290 and @xmath291 in a data structure @xmath351 that supports one - dimensional point reporting queries .",
    "data structure @xmath352 contains @xmath283-coordinates of all points in @xmath5 and also supports one - dimensional reporting queries . using the result from  @xcite , @xmath352 and all @xmath351 support queries in @xmath2 time and updates in @xmath102 time . for each @xmath287",
    ", we maintain a data structure @xmath353 .",
    "for any @xmath354 and @xmath355 , @xmath353 can report all points @xmath356 , @xmath357 and @xmath358 .",
    "@xmath353 uses @xmath359 space and supports updates in @xmath77 time .",
    "we can implement @xmath287 in the same way as the data structure @xmath73 in section  [ sec : statcol ] .    given a query @xmath13\\times [ c,\\log n]$ ]",
    ", we use @xmath352 for identifying an arbitrary @xmath360 , such that @xmath361 $ ] .",
    "let @xmath362 be the group that contains @xmath363 .",
    "if all points @xmath297 such that @xmath312 $ ] are contained in @xmath362 , we use the data structure @xmath364 to answer the query . if @xmath30 $ ] spans several groups , then we generate the values @xmath365 as in the proof of fact  [ fact : sel ] .",
    "we query data structures @xmath366 and identify all values @xmath367 $ ] and @xmath368 $ ] . for every such @xmath369 and @xmath370",
    ", we visit the corresponding group @xmath287 and answer the query @xmath30\\times [ c,\\log n]$ ] on @xmath287 using @xmath353 .    by facts  [",
    "fact : simp ] and  [ fact : sel ] , queries to @xmath366 return at least one representative element from every @xmath287 such that @xmath371 and only such groups will be visited . since we ask @xmath372 queries to @xmath366 , every group @xmath287 is visted at most @xmath373 times .    when a new point @xmath297 is inserted into @xmath5",
    ", we identify the group @xmath287 where it belongs in @xmath374 time .",
    "then we re - examine the values of @xmath307 and @xmath308 for @xmath298 . if necessary , we update the data structures @xmath375 . when the number of elements in some @xmath287 becomes equal to @xmath376 , we split @xmath287 into two groups in a standard way .",
    "deletions are symmetric .",
    "thus updates are supported in @xmath377 time and queries can be answered in @xmath77 time .",
    "we obtain the result of lemma  [ lemma : fast ] if we replace @xmath28 by @xmath378 into the above proof .",
    "in this section we describe a linear - space data structure that supports color reporting queries in @xmath379 time , where @xmath380|$ ] is the number of elements in the query range @xmath30 $ ] .",
    "although the query cost is high for large @xmath381 , updates are supported in @xmath27 time , where @xmath20 is the size of the universe .",
    "[ lemma : slowrep ] there exists a linear space data structure that reports all distinct colors in a query range @xmath30 $ ] .",
    "queries are supported in @xmath382 time where @xmath383\\cap s|$ ] is the number of elements in the query range @xmath30 $ ] .",
    "updates are supported in @xmath42 time .",
    "let @xmath384 be a range tree of the set @xmath5 .",
    "leaves of @xmath384 contain the elements of @xmath5 in sorted order .",
    "the root of @xmath384 has @xmath385 children .",
    "each child of the root node has @xmath386 children and @xmath385 leaf descendants .",
    "a node of depth @xmath8 has @xmath387 children and @xmath388 leaf descendants where @xmath389 .",
    "thus the height of @xmath384 is @xmath390 .",
    "as before , @xmath46 denotes the set of elements stored in leaf descendants of @xmath47 . recall that @xmath145 for @xmath63 denotes the largest element @xmath146 of the same color .",
    "the set @xmath391 , @xmath45 , contains all elements @xmath51 , such that @xmath392 .",
    "we maintain a balanced tree @xmath43 and sets @xmath391 in all nodes @xmath393 .",
    "further , all elements of every @xmath391 are kept in two sorted lists , @xmath394 and @xmath395 .",
    "elements @xmath396 are sorted by @xmath145 ; elements in @xmath395 are sorted by their values .",
    "finally , we also maintain a data structure , described in  @xcite , that supports reporting queries on @xmath391 in @xmath2 time and updates in @xmath42 time .",
    "to answer a query @xmath13 $ ] , we identify the leaves @xmath62 and @xmath65 that hold @xmath397 and @xmath398 respectively , where @xmath397 is the smallest element that is greater than @xmath14 and @xmath398 is the largest element that is smaller than @xmath215 .",
    "let @xmath399 be the lowest common ancestor of @xmath62 and @xmath65 .",
    "suppose that @xmath30 $ ] covers children @xmath400 , @xmath328 , @xmath401 of @xmath399 and intersects with @xmath72 and @xmath402 .",
    "let @xmath403 denote the path from @xmath399 to @xmath62 .",
    "the query answering procedure works as follows .",
    "[ list : slowstep1 ] we visit all @xmath404 and report all elements @xmath405 , @xmath64 , in each @xmath47 using @xmath395 .",
    "[ list : slowstep2 ] then we visit all right siblings @xmath187 of nodes @xmath404 except @xmath59 ; in every @xmath187 , we report colors of @xmath406 , @xmath166 , using @xmath407 .",
    "we also report all colors of @xmath408 ) , @xmath409 .",
    "[ list : slowstep3 ] we also report colors of all @xmath410 , @xmath66 , using @xmath411 .",
    "[ list : slowstep4 ] finally we visit all proper ancestors @xmath68 of @xmath399 ; in every @xmath68 we report all elements @xmath412 , @xmath82 , using the reporting data structure .",
    "correctness of our procedure can be demonstrated as follows .",
    "suppose that @xmath29 is the leftmost occurrence of some color in @xmath30 $ ] .",
    "we consider two different cases .",
    "( 1 ) @xmath413 .",
    "then @xmath412 for some ancestor @xmath68 of @xmath399 and it will be reported when @xmath414 is queried .",
    "( 2 ) @xmath415 where @xmath89 is the left sibling of some node @xmath47 on @xmath403 .",
    "then @xmath29 is stored in @xmath391 or in @xmath416 for a right sibling @xmath187 of @xmath47 .",
    "hence @xmath29 was reported when @xmath47 ( resp .",
    "@xmath187 ) was visited . each color",
    "is reported at most two times . if the color of an element @xmath417 is reported during step ( ii ) , then @xmath417 is the leftmost element of that color in @xmath30 $ ] because we only output elements @xmath29 such that @xmath409 . if the color of an element @xmath417 is reported during step ( i ) or step ( iv ) , than @xmath417 is likewise the leftmost element of that color .",
    "this is because @xmath418 ( resp .",
    "@xmath405 ) and the leftmost occurrence of a color in @xmath419 ( or @xmath46 ) is also the leftmost occurrence in @xmath30 $ ] .",
    "the only situation when we report the color of an element @xmath417 and @xmath417 is not the leftmost occurrence of that color is during step  ( [ list : slowstep3 ] ) . we can get rid of duplicates by traversing the list of answers and removing elements @xmath29 , such that @xmath167 .    the time needed to answer a query can be estimated by counting the number of visited nodes .",
    "let @xmath420 denote the highest node on @xmath403 such that at least one sibling @xmath47 of @xmath420 is visited .",
    "the number of leaves in the subtree of @xmath47 is @xmath421 , where @xmath8 is the depth of @xmath47 .",
    "we consider all nodes @xmath422 below @xmath420 on @xmath403 , the total number of siblings of such @xmath422 is bounded by @xmath423 .",
    "thus @xmath424 , where @xmath425 is the time needed to answer a query and @xmath380|$ ] is the total number of elements in @xmath30 $ ] .",
    "when an element @xmath29 is inserted into @xmath5 , we identify the greatest @xmath426 and the smallest @xmath427 such that @xmath428 and @xmath266 are of the same color as @xmath29 .",
    "we insert @xmath29 into an appropriate leaf @xmath59 and find the ancestor @xmath47 of @xmath59 , such that @xmath429 , @xmath430 . the element @xmath29 is inserted into the set @xmath391 and into lists @xmath394 , @xmath395 .",
    "suppose that @xmath266 was stored in a set @xmath431 ; we remove @xmath266 from @xmath431 , @xmath432 , @xmath433 and insert it into corresponding secondary structures in the node @xmath121 .",
    "the node @xmath121 is chosen in such way that @xmath434 and @xmath435 . when the number of elements in some node @xmath47 becomes equal to @xmath436 , where @xmath8 is the depth of @xmath47 , we split @xmath47 into @xmath187 and @xmath188 .",
    "when a node is split , we re - build the data structures in @xmath187 , @xmath188 and all their descendants .",
    "thus the total amortized cost incurred by splitting a node is @xmath437 .",
    "the total cost of an insertion is dominated by the time necessary to update the data structure that supports reporting queries on @xmath391 .",
    "deletions are symmetric .",
    "we will also need another result that uses almost the same data structure , but reports only the @xmath3 leftmost colors in the query range .",
    "[ lemma : slowcount ] there exists a linear - space data structure that reports , for any integer @xmath3 , the @xmath3 leftmost ( rightmost)colors in a query range @xmath30 $ ] .",
    "queries are supported in @xmath438 time where @xmath383\\cap s|$ ] is the number of elements in the query range @xmath30 $ ] .",
    "updates are supported in @xmath27 time .",
    "the data structure from lemma  [ lemma : slowrep ] can be used to determine whether the number of points in a query range exceeds a threshold value @xmath299 . to compare the number of points , with @xmath299 ,",
    "we proceed as in lemma  [ lemma : slowrep ] and use the fact that every color is reported at most twice . if the number of reported elements in visited nodes exceeds @xmath439 at some point , we stop processing the query and report that the number of distinct colors exceeds @xmath299 .",
    "otherwise , we answer a color reporting query and determine whether the number of colors exceeds @xmath299 . in both cases ,",
    "a comparison of the number of colors with @xmath299 is performed in @xmath440 time .",
    "we identify the range @xmath441 $ ] that contains at least @xmath3 and at most @xmath442 colors by binary search .",
    "we start by setting @xmath443 and comparing the number of colors @xmath444 in @xmath445 $ ] with @xmath3 .",
    "if @xmath444 is larger than ( smaller than ) @xmath3 , we move @xmath446 to the left ( to the right ) using a standard binary search procedure .",
    "after @xmath447 iterations we obtain  @xmath446 , such that @xmath448 . then we answer a color reporting query on @xmath441 $ ] as in lemma  [ lemma : slowrep ] .",
    "each comparison query is answered in @xmath449 .",
    "@xmath76 iterations take @xmath438 time .",
    "our dynamic external memory data structure is based on the same approach as the data structure of theorem  [ theor : dyn ] .",
    "but we need to change some of the auxiliary data structures .",
    "[ lemma : extmem3sid ] there exists a data structure that supports three - sided queries on a set @xmath5 , such that @xmath450 , in @xmath77 i / os .",
    "this data structure uses linear space and supports updates in @xmath102 i / os .",
    "if @xmath451 , the data structure from  @xcite gives us the desired query and update bounds because @xmath452 in this case .",
    "if @xmath453 , we implement our data structure as external priority search tree @xmath384 .",
    "every leaf of @xmath384 contains @xmath454 points sorted by their @xmath283-coordinates . as before @xmath455 denotes the set of all points stored in the leaves of @xmath151 .",
    "let @xmath456 denote the set of @xmath454 points @xmath457 with highest @xmath280-coordinates satisfying @xmath458 for any ancestor @xmath68 of @xmath151 .",
    "each internal node has @xmath459 children .",
    "we keep a data structure @xmath460 in each internal node @xmath151 ; @xmath460 contains all points @xmath461 , where the union is over all children @xmath462 of @xmath151 , and answers three - sided queries .",
    "@xmath460 is implemented as a static data structure described in  @xcite .",
    "when a set @xmath463 is updated , we re - build @xmath460 .",
    "since @xmath460 contains @xmath464 points , it can be re - built in @xmath465 i / os .    the query answering procedure is the same as in the external priority tree . for a query @xmath13\\times [ c,+\\infty]$ ] , let @xmath403 and @xmath466 denote the search paths for @xmath14 and @xmath215 respectively .",
    "we visit all nodes @xmath47 on @xmath403 and @xmath466 and report all points in @xmath467 .",
    "then we visit relevant descendants of nodes @xmath47 on @xmath468 . in each visited node @xmath47 , we report all points in @xmath469 ; we visit a child @xmath175 of @xmath47 only if @xmath470 .",
    "details of the reporting procedure and a proof of its correctness can be found in  @xcite .",
    "since the height of our priority tree is @xmath77 , we can update our data structure by updating @xmath77 structures @xmath460 . replacing @xmath28 by @xmath378",
    ", we obtain the result of this lemma .",
    "[ lemma : extfast ] let @xmath5 be a set of two - dimensional points such that @xmath285 for all @xmath282 .",
    "there exists a linear - space data structure that reports all points @xmath286\\times [ c,\\log n]$ ] in @xmath171 i / os and supports updates in @xmath42 i / os .",
    "the structure of lemma  [ lemma : fast ] can not be directly extended to the external memory .",
    "the reason is that we have to visit a number of groups @xmath287 when a query is processed .",
    "we would have to spend @xmath77 i / os in each group ; thus the query time would be @xmath471 .",
    "we need further modifications to obtain the desired @xmath41 query cost .",
    "our external memory solution is based on increasing the group size . essentially , we answer a three - sided query in a group @xmath287 only if we know that @xmath287 contains a sufficient number of points from the query range .",
    "otherwise we resort to the data structure that is based on range trees .    as in lemma  [ lemma :",
    "fast ] we divide points into groups @xmath287 .",
    "each group , except the last one , contains @xmath472 points ; the last group contains @xmath473 points .",
    "we distinguish between _ group - stored _ and _ directly stored _ points .",
    "let @xmath474=\\{\\,p\\in g_i\\,|\\,p.y = h\\,\\}$ ] .",
    "a point @xmath297 is group - stored if @xmath356 and @xmath475=\\omega(b\\log n)$ ] . otherwise @xmath297 is directly stored .",
    "either all points in @xmath474 $ ] for a fixed value of @xmath294 are group - stored or all points in @xmath474 $ ] are directly stored .",
    "we maintain the values of @xmath290 and @xmath291 , defined in the same way as in lemma  [ lemma : fast ] , with respect to group - stored points .",
    "let @xmath476 denote the set of directly stored points @xmath282 ; let @xmath477 denote the set of group - stored points in @xmath5 .",
    "all points in @xmath476 are kept in the standard range tree @xmath478 with node degree @xmath479 .",
    "@xmath478 allows us to reduce a three - sided query on @xmath476 to @xmath77 one - dimensional point reporting queries .",
    "we refer to  @xcite for details .",
    "the space usage of @xmath478 is @xmath480 ; updates can be implemented by @xmath481 updates of one - dimensional auxiliary structures stored in the nodes of @xmath478 .",
    "we implement these one - dimensional reporting data structures using the result of mortensen et al .",
    "@xcite . thus @xmath478 supports queries and updates in @xmath77 and @xmath102 i / os respectively .",
    "all points in @xmath482 for each group @xmath287 are kept in a data structure @xmath353 that supports three - sided range reporting queries as described in lemma  [ lemma : extmem3sid ] .    when a new point @xmath282 is inserted into @xmath5",
    ", we identify the group @xmath287 where it belongs .",
    "if points in @xmath475 $ ] are group - stored , then @xmath297 should be group - stored .",
    "we compute @xmath303 for @xmath298 and update the values of @xmath307 , @xmath308 as in lemma  [ lemma : fast ] .",
    "if points in @xmath475 $ ] are directly stored , then we check how many points are currently in @xmath475 $ ] .",
    "if @xmath483|=(3b\\log n)/2 $ ] , then points in @xmath484 $ ] will be group - stored .",
    "we remove all points of @xmath475 $ ] from the tree @xmath478 and add them to @xmath353 .",
    "then we identify the leftmost and the rightmost points in @xmath475 $ ] and update @xmath307 , @xmath308 for @xmath298 .",
    "if @xmath483| < ( 3b\\log n)/2 $ ] , we continue to store @xmath475 $ ] directly . in the latter case we simply add @xmath297 to @xmath478 .",
    "deletions are symmetric to insertions .",
    "however if points in @xmath475 $ ] are group - stored and @xmath297 is deleted , we continue to group - store the points in @xmath475 $ ] if @xmath475\\ge ( b\\log n)/2 $ ] .    for a query",
    "@xmath13\\times [ c,+\\infty]$ ] , we report all points in @xmath485 using @xmath478 . we identify groups @xmath287 such that @xmath486 in the same way as in lemma  [ lemma : fast ] . for every such @xmath287",
    "we report all points in @xmath487 using @xmath353 . if @xmath488 and @xmath489 for some group @xmath311 , then either @xmath490 or @xmath491 .",
    "hence , the total cost of answering queries in all @xmath353 is @xmath492 .",
    "thus a query @xmath0 is answered in @xmath41 i / os .      we observe that only the case when the block size @xmath493 should be considered . if @xmath494 , then we can use the reduction of color reporting queries to three - sided queries .",
    "the data structure of arge et al  @xcite supports three - sided queries and updates in @xmath495 i / os for @xmath494 . in the rest of this section",
    "we assume that @xmath493 .",
    "we will only sketch the differences of our data structure and the data structure of theorem  [ theor : dyn ]"
  ],
  "abstract_text": [
    "<S> color ( or categorical ) range reporting is a variant of the orthogonal range reporting problem in which every point in the input is assigned a _ </S>",
    "<S> color_. while the answer to an orthogonal point reporting query contains all points in the query range @xmath0 , the answer to a color reporting query contains only distinct colors of points in @xmath0 . in this paper </S>",
    "<S> we describe an @xmath1-space data structure that answers one - dimensional color reporting queries in optimal @xmath2 time , where @xmath3 is the number of colors in the answer and @xmath4 is the number of points in the data structure . </S>",
    "<S> our result can be also dynamized and extended to the external memory model . </S>"
  ]
}