{
  "article_text": [
    "counting the set bits in a given computer word lies at the heart of the discussions in this paper .",
    "there are a variety of ways to accomplish this .",
    "some computers have an assembly instruction that directly returns this `` population count . ''",
    "however in the interest of portability it is useful to implement this counting in a higher level language .",
    "a variety of fast schemes exist , but one well known approach increments a counter while @xmath9 is non vanishing and repeatedly takes @xmath9 to @xmath69 .",
    "this latter operation resets the lowest non - vanishing bit of @xmath9 , and the repetition stops when all bits are cleared . thus the following implementation in c :    .... inline int bitcount(int i ) {     / * counts the set bits in a word * /    int result = 0 ;    while ( i ) {      result++ ;      i & = ( i - 1 ) ;                / * finds and resets rightmost set bit * /    }    return result ; } ....    another useful operation given an integer @xmath9 is to find the next integer with the same number of set bits . for",
    "this first locate the lowest run of set bits .",
    "move the highest of these up one position and slide the remainder down to start at bit 0 .",
    "for example , if our integer in binary is , say , ( 0011001110 ) , we take the run of three set bits from position 1 to 3 , move the highest of these to position 4 , drop the other two to the beginning of the word , and obtain ( 0011010011 ) as the next integer with five set bits .",
    "this leads to the following implementation    .... int nextone(int i ) {    / * find the next integer with the same bitcount as i * /    int bit=1,count=-1 ;    if ( i==0 ) return 1<<nsites ;    / * find first one bit * /    while ( ! ( bit&i ) ) {      bit<<=1 ;    }    /",
    "* find next zero bit * /    while ( bit&i ) {      count++ ;      bit<<=1 ;    }    if ( ! bit ) die(\"overflow in nextone \" ) ;    i & = ( ~(bit-1 ) ) ;            / * clear lower bits * /    i |= bit | ( ( 1<<count)-1 ) ; / * put them in new places * /    return i ; } ....    defining a variety of routines for manipulating wave functions can be quite useful . for these",
    "i define a `` wavefunction '' type as a pointer to a complex array .",
    "once a generic set of routines is set up , one can quickly run through a variety of experiments as discussed above . some such functions whose action should be clear from their names are    .... double complex overlap(wavefunction psi1 , wavefunction psi2 ) ;   double norm2(wavefunction psi ) ;   double normalize(wavefunction psi ) ;   void cmultiply(double complex factor , wavefunction psi ) ;   void caxpby(double complex a , wavefunction dest , ....      m.  creutz , phys .",
    "d * 38 * , 1228 ( 1988 ) .",
    "r.  d.  mawhinney , parallel comput .",
    "* 25 * , 1281 ( 1999 ) [ arxiv : hep - lat/0001033 ] .",
    "d.  chen _ et al .",
    "_ , nucl .",
    "suppl .   * 94 * , 825 ( 2001 ) [ arxiv : hep - lat/0011004 ] ."
  ],
  "abstract_text": [
    "<S> i explore computer simulations of the dynamics of small multi - fermion lattice systems . </S>",
    "<S> the method is more general , but i concentrate on hubbard type models where the fermions hop between a small number of connected sites . </S>",
    "<S> i use the natural mapping of fermion occupation numbers onto computer bits . </S>",
    "<S> signs from fermion interchange are reduced to bit counting . </S>",
    "<S> the technique inherently requires computer resources growing exponentially with the system volume ; so , it restricted to modestly small systems . </S>",
    "<S> large volume results would require combining these techniques with further approximations , perhaps in a recursive renormalization group manner .    </S>",
    "<S> quantum systems involving fermions have proven elusive for computer simulation . </S>",
    "<S> a plethora of cancellations in all but a few cases impedes the use of monte carlo methods , which have been so successful for bosonic systems . here </S>",
    "<S> i explore the direct application of the relevant hamiltonians to wave function representations stored in computer memory . </S>",
    "<S> i work with large but sparse matrices acting in a finite dimensional hilbert space . </S>",
    "<S> as the methods are inherently exponential in volume , i concentrate on smaller systems . </S>",
    "<S> thus i am admitting defeat in terms of a thermodynamic limit , hoping instead to find interesting physics with finite systems . to obtain results for larger volumes </S>",
    "<S> , these techniques could form the basis for approximate techniques , such as solving small blocks of variables to form the starting point for a renormalization group approach . </S>",
    "<S> note that i am discussing directly simulating the behavior of quantum systems on a classical computer . in this way one can also study various models for quantum computers . </S>",
    "<S> the storage required does grow exponentially with the number of q - bits under study , but if this is fairly modest , say of order 20 , the methods exploited here are straightforward .    consider a fock basis @xmath0 for a many fermion system , where the @xmath1 are the occupation numbers for some set of orthogonal single particle states . </S>",
    "<S> each @xmath1 is either 0 or 1 . for a lattice model </S>",
    "<S> these might represent the occupations on given sites with given spins . </S>",
    "<S> this basis naturally maps onto computer words , which are sets of bits also either 0 or 1 . </S>",
    "<S> a 1 bit is `` set '' and a 0 bit `` unset . '' </S>",
    "<S> this raw mapping is instinctive for numerical simulations of multi fermion systems . </S>",
    "<S> a subroutine representing a creation operator for a fermion would set the corresponding bit in the appropriate word . </S>",
    "<S> an annihilation operator resets the bit . </S>",
    "<S> such can all be done with simple bitwise logical operations . </S>",
    "<S> this naive observation , however , requires embellishment so that fermion exchanges will give rise to the appropriate relative negative signs . </S>",
    "<S> simple bit counting techniques allow us to track these .    to start , consider @xmath2 creation / annihilation pairs @xmath3 for @xmath4 . </S>",
    "<S> these satisfy the usual fermion commutation relations @xmath5_+ & = & a_ia_j^\\dagger+a_j^\\dagger a_i=\\delta_{ij } \\\\ { } [ a_i , a_j ] _ + & = & 0\\end{aligned}\\ ] ]    the vacuum state @xmath6 is annihilated by all @xmath7 ; i.e. impose @xmath8 for every @xmath9 . </S>",
    "<S> a general fock state is given by applying creation operators to this state @xmath10 each of the occupation numbers @xmath1 is either zero or one . </S>",
    "<S> note that my sign conventions are buried in the ordering convention with increasing index . </S>",
    "<S> the concept being explored here identifies each of these basis states with an integer @xmath11 whose binary representation is given by the corresponding occupation numbers @xmath12 given a fock state , the occupation number of a particular site is then easily determined by testing whether the bitwise logical operation @xmath13 is zero or not . </S>",
    "<S> ( i assume the reader is familiar with standard c notation for logical operations . )    of course , in a computer the natural word length is finite , 32 bits in today s typical personal computer , 64 in most larger machines . </S>",
    "<S> if we want to study systems of more fermions , we need to combine several words into a higher precision integer . </S>",
    "<S> this technicality is straightforward , and i will not discuss it further here .    a general quantum state is a superposition of states in this fock basis @xmath14 this involves specifying a complex number @xmath15 for each integer representing one of our fock states . </S>",
    "<S> the computer storage required to hold this information grows exponentially . </S>",
    "<S> indeed , if i need to keep all @xmath2 bit states , i need storage for @xmath16 complex numbers . in many cases symmetries </S>",
    "<S> allow us to reduce this number considerably , although the basic growth with @xmath2 remains exponential .    </S>",
    "<S> one particularly useful symmetry occurs when fermion number is conserved . </S>",
    "<S> then for a given filling @xmath17 , we only need to keep track of integers up to @xmath16 containing exactly @xmath17 set bits . for half filling this </S>",
    "<S> involves a memory saving by a factor of order @xmath18 , while for other fillings the saving is greater . </S>",
    "<S> if we deal with two species of fermions each of which is separately conserved , such as the hubbard type models discussed later , the resulting savings can be even more . to enumerate states with a given total occupation </S>",
    "<S> it is useful to have a function that returns the next integer with the same number of bits as its argument ; an implementation is discussed briefly in appendix a.    another symmetry in many systems is translational invariance , which manifests itself in momentum conservation . for a given momentum , </S>",
    "<S> states which are related by translation have their wave functions related by a phase , and thus only one of them needs to be stored . for my discussion here </S>",
    "<S> i will not make use of this symmetry </S>",
    "<S> .    so given @xmath19 states to be stored , we can do this in various ways . </S>",
    "<S> one is to use a hash table , keying wave function components to the corresponding fock states , as discussed in @xcite . </S>",
    "<S> if the fock states are ordered in some manner , one can instead use a binary search . </S>",
    "<S> this is the method used here , where for each wave function under consideration i keep an array of @xmath20 complex numbers . by having the state table ordered , </S>",
    "<S> a given state can be quickly located . </S>",
    "<S> then the corresponding location in the coefficient table contains the desired component of the wave function .    as storage represents the main bottleneck in this type of algorithm , tricks to reduce this are desirable . if we can deal with a real hamiltonian , the wave function storage drops by a factor of two . with several species </S>",
    "<S> each separately conserved , the table of states separates into multiple tables representing the fock states for the individual species . in this case </S>",
    "<S> the bulk of the storage is for the complex numbers representing the wave function . in any case </S>",
    "<S> , the type of simulation discussed here spends the dominant amount of its computer time doing the searches through these tables for desired states . </S>",
    "<S> floating point arithmetic operations tend to be insignificant .    </S>",
    "<S> i now become more specific and consider an annihilation operator @xmath21 . </S>",
    "<S> i implement this as subroutine which takes as arguments the specific location @xmath22 and a pointer to a fock state labeled as above by an integer @xmath23 . </S>",
    "<S> it should return zero unless bit @xmath22 is set in @xmath11 . </S>",
    "<S> a simple test for this is whether , the integer @xmath24 is non - vanishing . when this is true the function returns the corresponding sign obtained after the annihilation flips this bit . </S>",
    "<S> the resulting fock state is represented by @xmath25 . </S>",
    "<S> the sign returned is associated with bringing the operator @xmath21 into the canonical ordering above . </S>",
    "<S> this is determined by the parity of the number of set bits lower than @xmath22 . </S>",
    "<S> this can be quickly found by logical operations , beginning with a masking off of the lower bits by the considering the integer @xmath26 . </S>",
    "<S> we need to include a negative sign if the population count of this integer is odd . </S>",
    "<S> the population count of an integer is the number of set bits it contains . </S>",
    "<S> appendix a discusses one simple way to implement such a count . for a creation operator </S>",
    "<S> , one does exactly the same thing except checking that the initial bit is not set .    to apply some combination of creation and annihilation operators to </S>",
    "<S> a wave function @xmath27 involves looping over all the component fock states @xmath28 . </S>",
    "<S> on each of these in succession we apply the above subroutines , multiply the component of the wave function by the returned sign , and then store the result . for a simple hopping hamiltonian , </S>",
    "<S> it is useful to make a table of the bit locations for the neighbors of any given site . </S>",
    "<S> this small array is set up once at the beginning of a simulation . </S>",
    "<S> then the hopping term in the hamiltonian becomes another subroutine which loops over sites , spins , and neighbors . </S>",
    "<S> it successively applies the corresponding creation and annihilation pairs to the components of the source wave function . </S>",
    "<S> the results accumulate in a destination wave function .    </S>",
    "<S> these bit manipulations do not depend in any deep way on the type of fermion interaction used . here for convenience i consider a simple hubbard form @xcite . </S>",
    "<S> thus i will consider two types of fermions distinguished by `` spin '' and have them interact by adding an energy @xmath29 for each site with both spin states occupied . </S>",
    "<S> such an interaction is also easily implemented by logical operations ; on looping over states one multiplies the coefficient of each component of the wave function by @xmath29 times the number of doubly occupied sites . </S>",
    "<S> the latter is the population count of @xmath30 .    to be more specific , </S>",
    "<S> consider a set of sites with nearest neighbors connected by bonds . </S>",
    "<S> on each site @xmath9 the operator @xmath31 creates a fermion with a spin index @xmath32 . </S>",
    "<S> my hamiltonian is @xmath33 where @xmath34 and @xmath35 denotes the set of neighboring pairs . </S>",
    "<S> for simplicity i set the energy scale to make the hopping parameter unity . in one dimension </S>",
    "<S> this model is exactly solvable @xcite . for a more detailed discussion of this solution see @xcite . </S>",
    "<S> monte carlo methods for this system are discussed in ref . </S>",
    "<S> @xcite . in more dimensions </S>",
    "<S> the monte carlo approach only works effectively for the half filled case @xcite .    </S>",
    "<S> i now illustrate several simple numerical `` experiments . '' </S>",
    "<S> i will first play with a six membered ring of sites , thus mimicking a benzene molecule . with a nearest neighbor hopping </S>",
    "<S> , we have the standard undergraduate example for using linear combinations of atomic orbitals to illustrate hybridization of the pi electrons . </S>",
    "<S> when @xmath36 this has single fermion states with energies @xmath37 . </S>",
    "<S> filling the lowest levels with three spin up and three spin down electrons gives a total ground state energy of -8 . </S>",
    "<S> this is the energy gained from the delocalization of the electron wave functions . </S>",
    "<S> this should be compared with the value -6 which would be obtained from three fixed double bonds and no hybridization .    turning on </S>",
    "<S> the hubbard interaction raises the ground state energy . as @xmath29 goes to infinity the ground state energy rises , with the largest components of the wave function alternating spin up and down around the ring . </S>",
    "<S> they prefer to alternate rather than some other pattern since as long as @xmath29 is not infinity , this state maximizes delocalization . for this case of half filling , i.e. 3 electrons of each spin , </S>",
    "<S> there are 400 fock states . </S>",
    "<S> this corresponds to twenty possible arrangements for each set of spins . </S>",
    "<S> this is not a particularly large matrix and could presumably be treated by conventional matrix methods , but it enables fast experiments with the table manipulation ideas discussed here . </S>",
    "<S> the computer time for these experiments is insignificant , easily practical on a pc .    for most of the following experiments </S>",
    "<S> i start with a random initial state . to construct such </S>",
    "<S> , i set each of the components of the wave function to a gaussian random number and then normalize the state . from this </S>",
    "<S> i repeatedly apply the hamiltonian in various ways discussed below . </S>",
    "<S> formally i work with what is known as a krylov space . </S>",
    "<S> note that when there are degenerate states , a krylov procedure does not span the full space , but leaves the relative contribution of the degenerate states unchanged . to separate them one must consider multiple starting states . </S>",
    "<S> for example , one can first extract a state of interest , construct a random state orthogonal to it , and construct a new krylov space which will involve different combinations of the degenerate states . </S>",
    "<S> if the degeneracy is due to some symmetry , an alternative is to use starting states which are eigenvectors of this symmetry .    a particularly intuitive way to find </S>",
    "<S> the ground state is to start with a random state as above and directly apply @xmath38 . for large @xmath39 </S>",
    "<S> this should project out the ground state . for moderate @xmath39 </S>",
    "<S> one can use the rapidly convergent power series expansion for the exponential . for larger </S>",
    "<S> @xmath39 break the evolution into smaller time intervals and apply the exponentiated hamiltonian repeatedly . in fig .  </S>",
    "<S> [ fig : emth ]  i show the behavior of the expectation value of the energy as a function of @xmath39 for our benzene system where i take the parameter @xmath40 .        </S>",
    "<S> there are a variety of ways to obtain information on the first excited state from this experiment . </S>",
    "<S> the value of its energy can be extracted from the approach to the ground state via the formula @xmath41 solving three successive times for @xmath42 gives the results shown by boxes in fig .  </S>",
    "<S> [ fig : excited ] . </S>",
    "<S> alternatively , as time evolves we can extract the part of @xmath43 that is orthogonal to @xmath27 via the construction @xmath44 while @xmath27 evolves , this should be dominated by the first excited state . </S>",
    "<S> measuring the expectation of the hamiltonian in this state gives the points represented by bursts in fig .  </S>",
    "<S> [ fig : excited ] . </S>",
    "<S> both the above techniques will fail when @xmath39 is large enough that we have the ground state to machine precision .        </S>",
    "<S> the above evolution is effectively in `` imaginary time , '' and damps the system to its ground state . since all signs are being included , one can also work in real time and calculate the evolution of a state under application of @xmath45 . </S>",
    "<S> since this involves no damping , it will leave the expectation value of the energy unchanged . </S>",
    "<S> fig .  </S>",
    "<S> [ fig : rxn ]  shows a simple experiment where the initial state has all six fermions placed on the first three sites and then observes the expected occupation number of either spin on the sites as a function of time . </S>",
    "<S> again i use @xmath40 . observe the particles spreading towards a uniform distribution . note that if i did not include the interaction @xmath29 , then all energy levels are spaced by integer amounts and instead of a relaxation we have a sloshing of the fermions back and forth with a periodic return to the original state . working in real time provides a means to study finite temperature , or more precisely , allows a micro - canonical evolution at energies above the ground state .        </S>",
    "<S> while working well for this small system , the calculation of @xmath38 is somewhat tedious . </S>",
    "<S> a more efficient but still simplistic algorithm for finding the ground state is to repeatedly apply @xmath46 to the current state and then form the linear combination of @xmath47 and @xmath48 that minimizes the expectation value of the energy . at each stage </S>",
    "<S> this requires calculating @xmath49 as well , but is straightforward to implement . </S>",
    "<S> fig .  </S>",
    "<S> [ fig : iter ]  shows the convergence of this procedure for our half filled benzene system with @xmath36 and @xmath40 . using this technique to find the ground state energy , i plot in fig .  </S>",
    "<S> [ fig : eofu ]  the ground state energy as a function @xmath29 .            </S>",
    "<S> the methods described here do not have any `` sign problems '' since all signs are kept track of at all times . while the above experiments were done at half filling , there is nothing that requires this . in fig  [ fig : </S>",
    "<S> filling ]  i show the ground state energy as a function of filling fraction for the 6 membered ring . </S>",
    "<S> i keep the spin up and spin down filling fraction the same . </S>",
    "<S> note how at @xmath50 the on - site repulsion is sufficiently strong to make the lowest energy state at 1/3 filling , rather than the 1/2 of the free case . </S>",
    "<S> the @xmath36 points in this figure show the successive fermions contribute increasing values to the energy , demonstrating the pauli exclusion principle as the lower levels are filled .        </S>",
    "<S> the standard technique for dealing with these large sparse matrices is the lanczos scheme . </S>",
    "<S> this iteratively constructs a sequence of vectors @xmath51 that form a basis under which the hamiltonian is real and tri - diagonal ; it has non - vanishing elements only between diagonal and sequential states in the sequence . </S>",
    "<S> the construction is recursive and makes use of an auxiliary sequence of states @xmath52 which satisfy a matrix orthogonality condition @xmath53 whenever @xmath54 . </S>",
    "<S> the construction starts from an arbitrary initial @xmath55 . </S>",
    "<S> the higher states are given by @xmath56 for convenience i choose the proportionality constants so that both vectors are normalized . </S>",
    "<S> the orthogonality of the @xmath57 and the matrix orthogonality of the @xmath58 are easily proven by induction . </S>",
    "<S> the matrix elements of the tri - diagonalized hamiltonian can be calculated during the recursion without generating any additional vectors by expanding @xmath59 @xmath60 and using the orthogonality constraints to obtain @xmath61    the iteration procedure should formally terminate at the dimension of the krylov space generated by applications of @xmath46 to @xmath62 . if there are no degenerate eigenvalues and if @xmath62 has non - zero overlap with all states , then this is the dimension of our hilbert space . </S>",
    "<S> however , any degenerate states can not be separated in this process , and thus the dimension of the generated space is reduced by one for each degenerate state . in a practical simulation on a large system one will usually stop the series at much earlier stage . for a small system , </S>",
    "<S> however , the termination is usually signaled by an extremely large normalization factor in the construction of @xmath63 , which would be zero were it not for finite machine precision . </S>",
    "<S> after this occurs the orthogonality with earlier @xmath64 is lost .    in fig .  </S>",
    "<S> [ fig : lanczos ]  i plot the eigenvalues of the truncated tri - diagonal hamiltonian from our benzene system as a function of the number of steps taken in this process . </S>",
    "<S> the lowest and highest eigenvalues rapidly converge to their respective state energies , while new eigenvalues appear in the middle of the spectrum . </S>",
    "<S> the lanczos procedure converges more rapidly to the true ground state energy than the previous schemes . for long runs , however </S>",
    "<S> , it can become unstable as roundoff errors accumulate in the sequence . </S>",
    "<S> the approach also gives information on the higher levels , although , as can be seen in the figure , intermediate states taking successively longer to converge . </S>",
    "<S> note that for the filling discussed here both the first and second excited states should be doubly degenerate with non - zero angular momentum around the ring . </S>",
    "<S> as discussed earlier , this single krylov space approach can not separate such degeneracies .        </S>",
    "<S> note how in only a few tens of iterations we have a reasonably accurate estimate of the ground state energy . compared to other methods discussed above , </S>",
    "<S> this involves a substantially smaller number of applications of the hamiltonian to our starting state , and thus is generally regarded as the method of choice for larger systems . using the states generated in this procedure as a basis reduces our 400 state system to , say , a 20 by 20 tridiagonal matrix that reproduces well the lowest few eigenvalues . </S>",
    "<S> truncating to states of this reduced matrix could provide a useful starting point for an approximate iterative growth to larger systems . </S>",
    "<S> nevertheless , for the small systems considered here , the computer time is insignificant ; thus , the earlier more intuitive but less efficient methods still work quite well .    fig .  [ </S>",
    "<S> fig : lanczos ] displays an interesting symmetry between the highest and the lowest energy levels . </S>",
    "<S> this is a consequence of half filling on a bipartite lattice . </S>",
    "<S> changing the sign of the fermionic operators on half of our lattice shows that the sign of the kinetic term does not affect the spectrum our hamiltonian . </S>",
    "<S> doing a particle hole transformation for a fermion @xmath65 changes @xmath66 . doing this on all sites for either value of the spin and then shifting the spectrum by the filling of the other spin changes the sign of the potential term . </S>",
    "<S> thus , whenever either spin state is half filled , we have a symmetry in the spectrum under a combined shift and sign change .    </S>",
    "<S> having the ground state at hand enables one to look at correlations . in fig .  </S>",
    "<S> [ fig : correlation ]  i plot the correlation between a spin up on one site and either spin up or spin down on another site as a function of the separation between them . </S>",
    "<S> this graph is for @xmath40 note the tendency for the system to become anti - ferromagnetic ; such a configuration maximizes the stabilization by delocalization . </S>",
    "<S> note also the stronger correlation between same versus opposite spins . </S>",
    "<S> when @xmath36 the up and down spins are totally decorrelated , while the pauli principle leaves a correlation between parallel spins . of course the correlation between parallel spins on the same site is the filling factor , .5 in this case . for larger systems this figure should match onto the monte carlo results shown in fig .  </S>",
    "<S> 8 of ref .  </S>",
    "<S> @xcite .        </S>",
    "<S> the primary difficulty with these direct approaches is that memory needs grow exponentially with system size . </S>",
    "<S> generalizing the benzene system to an @xmath2 site ring , the number of basis states for the half filled case is @xmath67 . </S>",
    "<S> the 400 states needed for the 6 site case rapidly rises to 853,776 for a 12 member ring . </S>",
    "<S> the half filled hubbard model on a two dimensional lattice of size 4 by 4 involves 165,636,900 states . </S>",
    "<S> after a few megabytes of storage , one leaves the realm of current personal computers . in fig .  </S>",
    "<S> [ fig : size ]  i show the ground state energy density @xmath68 as a function of the ring size @xmath2 . </S>",
    "<S> the filling is one half in all cases , with the number of up and down spins differing by zero ( one ) for the odd ( even ) rings . </S>",
    "<S> the points for @xmath36 were obtained from the analytic formula . </S>",
    "<S> note the extra stability when the ring size is twice an odd number . in this case ref .  </S>",
    "<S> @xcite proved that the ground state is unique . for odd </S>",
    "<S> ring sizes the ground state should be doubly degenerate . </S>",
    "<S> this is the case in the non - interacting case where the final fermion has non - zero angular momentum around the ring .        </S>",
    "<S> i note that as with the algorithm discussed in ref .  </S>",
    "<S> @xcite , this approach does parallelize quite well if storage and computation can be done in parallel . </S>",
    "<S> if a creation or annihilation operator flips a high bit in a fock state , this will relate components that are far apart in storage . </S>",
    "<S> thus the algorithm requires long range communications . </S>",
    "<S> nevertheless , the loops over components do not need the results immediately . </S>",
    "<S> thus the results for the new wave function can be sent off to storage while a given processor continues to work on further components that are locally stored . </S>",
    "<S> these vectors tend to be quite long , and thus most communication is completed before the new results are needed . thus we expect good performance from massively parallel mimd machines , including ones designed primarily for local communication , such as the qcdsp @xcite and the qcdoc @xcite . as the problem is primarily combinatorial , the performance is not determined or properly measured in terms of floating point operations . </S>"
  ]
}