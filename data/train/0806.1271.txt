{
  "article_text": [
    "sensors are sometimes distributed in a regular fashion to monitor an area .",
    "we assume that the sensors use wireless communication .",
    "most wireless communication protocols allow the sensors to send at arbitrary times . however , this can cause the following _ collision problems _ : if two distinct sensors @xmath0 and @xmath1 send at the same time and @xmath1 is within the interference range of @xmath0 , then frequently hardware limitations prevent @xmath1 from receiving the message of @xmath0 correctly . in addition , if two distinct sensors @xmath0 and @xmath1 send at the same time and a sensor @xmath2 is within interference range of both @xmath0 and @xmath1 , then @xmath2 will not be able to correctly receive either message . in these cases , the sensors @xmath0 and",
    "@xmath1 need to resend their messages , which is evidently a waste of energy .",
    "let us assume that the sensors have access to the current time , represented by an integer @xmath3 .",
    "one can assign each sensor node an integer @xmath4 and set up a periodic schedule such that a node with integer @xmath4 is allowed to broadcast messages at time @xmath3 if and only if @xmath5 . the goal of this paper is to give a convenient combinatorial formulation using lattice tilings that allows one to assign optimal schedules with minimal number of time slots @xmath6 such that no two sensors that are scheduled to broadcast simultaneously have intersecting interference ranges ; we call such schedules _ collision - free_.    [ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    since most communication protocols for wireless sensor networks are probabilistic in nature , there exist few prior works that are directly related to our approach .",
    "however , there exist a few notable exceptions that we want to discuss here .",
    "suppose for the moment that we are given a finite set of @xmath4 sensors that share the same frequency band for communication .",
    "the simplest way to ensure that the communication will be collision - free , is to use a time division multiple access ( tdma ) scheme . here",
    "each of the @xmath4 sensors is assigned a different time slot and scheduling is done in a round robin fashion . because of its simplicity , this scheme is used in many systems , see e.g.  ( * ? ? ?",
    "* chapter 3.4 ) . the obvious disadvantage of tdma is that it does not scale : if the number @xmath4 of sensors is large , then the sensors can not communicate frequently enough .",
    "the basic tdma scheme does not take advantage of the fact that each sensor typically affects only small number of neighboring sensors by its radio communication .",
    "this prompts the question whether one can modify the tdma scheme and find a schedule with @xmath6 time slots that is collision - free . to answer this question , consider a directed graph that has a node for each sensor and an edge from vertex @xmath7 to vertex @xmath8 if and only if @xmath8 is affected by the radio communication of @xmath7",
    "a valid schedule with @xmath6 time slots corresponds to a distance-2 coloring with @xmath6 colors , that is , all vertices of distance @xmath9 must be assigned a different color (= time slot ) to avoid collision problems .",
    "therefore , the number of time slots @xmath6 of an optimal collision - free schedule coincides with the chromatic number of a distance-2 coloring .",
    "the distance-2 coloring problem is also known as the broadcast scheduling problem in the networking community .",
    "mccormick has shown that the decision problem whether a given graph has a distance-2 coloring with @xmath6 colors is np - complete  @xcite .",
    "lloyd and ramanathan showed that the broadcast schedule problem even remains np - complete when restricted to planar graphs and @xmath10 time slots  @xcite .    due to these intractability results ,",
    "much of the subsequent research focused on heuristics for finding optimal schedules ; for instance , wang and ansari used simulated annealing  @xcite , and shi and wang used neural networks  @xcite to find optimal schedules .",
    "another popular direction of research are approximation algorithms for broadcast scheduling algorithms , see e.g.  @xcite .",
    "[ [ contributions . ] ] contributions .",
    "+ + + + + + + + + + + + + +    the main contributions of this paper can be briefly summarized as follows ( the terminology is explained in the subsequent sections ) :    we develop a method that allows one to derive an optimal collision - free schedule from the tiling of a lattice .",
    "our scheme scales to an arbitrary number of sensors ; in fact , we formulate our schedules for an infinite number of sensors .",
    "schedules for a finite number of sensors are obtained by restriction , and these schedules remain optimal under very mild conditions ( given in the conclusions ) .",
    "our assumption on the set of prototiles ensures that an optimal schedule is obtained regardless of the chosen tiling . in section 4",
    ", we show that if our assumption on the set of prototiles is removed , then in general one will not obtain an optimal schedule .",
    "we formulate our results for arbitrary lattices in arbitrary dimensions , since the proofs are not more complicated than in the familiar case of the two - dimensional square lattice . for the square lattice ,",
    "there are polynomial - time algorithms available to check whether a given prototile can tile the lattice ; thus , despite the fact that finding optimal schedules is np - hard in general , one can use our method to easily construct optimal schedules in the case of a single prototile .",
    "this method of creating simple instances of an np - hard problem might be of independent interest .",
    "a euclidean lattice @xmath11 is a discrete subgroup of @xmath12 that spans the euclidean space @xmath12 as a real vector space . in other words ,",
    "there exist @xmath13 vectors @xmath14 in @xmath11 that are linearly independent over the real numbers such that @xmath15 and for each vector @xmath7 in @xmath11 there exists an open set containing @xmath7 but no other element of @xmath11 .",
    "in particular , the group @xmath11 is isomorphic to the additive abelian group @xmath16 .",
    "two examples of lattices in two dimensions are illustrated in figure  [ fig : lattice ] .",
    "( 40,40 ) z1 = ( 1,0 ) ; z2 = ( 0,1 ) ; s = 12 ;    drawarrow s*z1+s*z2  2*s*z1+s*z2 ; drawarrow s*z1+s*z2 ",
    "s*z1 + 2*s*z2 ; pickup pencircle scaled 3 ;    for k = 1 step s until 5*s : draw k*z1 + 1*z2 scaled 2 ; endfor ; for k = 1 step s until 5*s : draw k*z1+(s)*z2 ; endfor ; for k = 1 step s until 5*s : draw k*z1+(2*s)*z2 ; endfor ; for k = 1 step s until 5*s : draw k*z1+(3*s)*z2 ; endfor ; for k = 1 step s until 5*s : draw k*z1+(4*s)*z2 ; endfor ;    label.lrt(btex @xmath17 etex , s*z1+s*z2 ) ; label.lrt(btex @xmath18 etex,2*s*z1+s*z2 ) ; label.lrt(btex @xmath19 etex , s*z1 + 2*s*z2 ) ; label.lrt(btex @xmath20 etex,2*s*z1 + 2*s*z2 ) ;    @xmath21    ( 40,40 ) z1 = ( 1,0 ) ; z2 = ( 0.5,0.866 ) ;    drawarrow s*z1+s*z2  2*s*z1+s*z2 ; drawarrow s*z1+s*z2 ",
    "s*z1 + 2*s*z2 ; pickup pencircle scaled 3 ;    for k = 1 step s until 5*s : draw k*z1 + 1*z2 scaled 2 ; endfor ; for k = 1 step s until 5*s : draw k*z1+(s)*z2 ; endfor ; for k = 1 step s until 5*s : draw ( -s+k)*z1+(2*s)*z2 ; endfor ; for k = 1 step s until 5*s : draw ( -s+k)*z1+(3*s)*z2 ; endfor ; for k = 1 step s until 5*s : draw ( -2*s+k)*z1+(4*s)*z2 ; endfor ;    label.lrt(btex @xmath17 etex , s*z1+s*z2 ) ; label.lrt(btex @xmath22 etex,2*s*z1+s*z2 ) ; label.lrt(btex @xmath23 etex , s*z1 + 2*s*z2 ) ; label.lrt(btex @xmath24 etex,2*s*z1 + 2*s*z2 ) ;    our goal is to find a deterministic collision - free periodic schedule for sensors located at the points of a lattice @xmath11 that is optimal in the number of time slots , _",
    "i.e. _ , no periodic schedule with a shorter period can be found that is collision - free .",
    "we call a finite subset @xmath25 of @xmath11 a _ prototile _ or a _ neighborhood _ of the point  @xmath17 if and only if it contains @xmath17 itself . the particular nature of @xmath25 will be determined for instance by the type of antenna and by the signal strength used by the sensor .",
    "the elements in @xmath25 are the sensors affected by wireless communication of the sensor located at the point @xmath17 ( that is , only the elements in @xmath25 are within interference range of the sensor located at the point @xmath17 ) .",
    "we will first assume a homogeneous situation , namely the neighborhood affected by communication of the sensor located at a point @xmath3 in @xmath11 is of the form @xmath26 where the addition denotes the usual addition of vectors in @xmath12 .",
    "the set @xmath27 contains @xmath3 , since @xmath17 is contained in @xmath25 .",
    "some examples of neighborhoods @xmath25 are given in figure  [ fig : neighborhoods ] .",
    "( 50,50 ) t = 12 ; z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    def cross(expr a , b ) = begingroup pair g ; g = a*z3+b*z4 ; pickup pencircle scaled 2 ; draw ( g-(1,1))(g+(1,1 ) ) ; draw ( g-(1,-1))(g+(1,-1 ) ) ; endgroup ; enddef ;    pickup pencircle scaled 3 ; for k = 1 step 1 until 7 : for l = 1 step 1 until 7 : draw k*z3+l*z4 ; endfor ; endfor ; label.lrt(btex 0 etex , 4*z3 + 4*z4 ) ;    for k = 3 upto 5 : for l = 3 upto 5 : cross(k , l ) ; endfor ; endfor ;    pickup pencircle scaled 1 ; pair tg ; tg = 2.5*(z3+z4 ) ; draw ( ( 0,0)(0,1)(1,1)(1,0)cycle ) scaled 36 shifted tg withcolor 0.8white ;    @xmath28    ( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    def cross(expr a , b ) = begingroup pair g ; g = a*z3+b*z4 ; pickup pencircle scaled 2 ; draw ( g-(1,1))(g+(1,1 ) ) ; draw ( g-(1,-1))(g+(1,-1 ) ) ; endgroup ; enddef ;    pickup pencircle scaled 3 ; for k = 1 step 1 until 7 : for l = 1 step 1 until 7 : draw k*z3+l*z4 ; endfor ; endfor ; label.lrt(btex 0 etex , 4*z3 + 4*z4 ) ;    for k = 3 upto 5 : cross(k,4 ) ; cross(4,k ) ; endfor ;    pickup pencircle scaled 1 ; draw ( ( 0,1)(0,2)(1,2)(1,3)(2,3)(2,2)(3,2)(3,1)(2,1)(2,0)(1,0)(1,1)cycle ) scaled ( t ) shifted ( 2.5*(z3+z4 ) ) withcolor 0.8white ;    @xmath28    ( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    def cross(expr a , b ) = begingroup pair g ; g = a*z3+b*z4 ; pickup pencircle scaled 2 ; draw ( g-(1,1))(g+(1,1 ) ) ; draw ( g-(1,-1))(g+(1,-1 ) ) ; endgroup ; enddef ;    pickup pencircle scaled 3 ; for k = 1 step 1 until 7 : for l = 1 step 1 until 7 : draw k*z3+l*z4 ; endfor ; endfor ;    for k = 5 upto 6 : for l = 3 upto 5 : cross(k , l ) ; endfor ; endfor ; cross(3,4 ) ; cross(4,4 ) ; pickup pencircle scaled 1 ; draw ( ( 0,1)(0,2)(2,2)(2,3)(4,3)(4,0)(2,0)(2,1)(0,1 ) ) scaled t shifted ( 2.5*(z3+z4 ) ) withcolor 0.8white ; label.lrt(btex 0 etex , 3*z3 + 4*z4 ) ;    our schedule will be a deterministic periodic schedule , that is , each sensor is assigned a certain time slot and it is only allowed to send during that time slot . since our schedule is required to be free of collision problems , it follows that the sensors located at distinct points @xmath29 and @xmath3 in @xmath11 can not broadcast at the same time unless @xmath30    let @xmath31 denote a subset of @xmath11 .",
    "we say that @xmath31 provides a _ tiling _ of @xmath11 with neighborhoods ( or tiles ) of the form @xmath25 if and only if the following two conditions hold :    @xmath32 ,    @xmath33 for all distinct @xmath34 in @xmath31 .",
    "the set @xmath31 contains all the vectors that translate the prototile @xmath25 .",
    "condition * t1 * says that the whole lattice @xmath11 is covered by the translates @xmath27 of the prototile @xmath25 , when @xmath3 ranges over the elements of @xmath31 .",
    "condition * t2 * simply says that the translates of the tile @xmath25 do not overlap .",
    "the tilings provide us with an elegant means to construct an optimal deterministic schedule .",
    "[ th : thm1 ] let @xmath31 be a tiling of a euclidean lattice @xmath11 in @xmath12 with neighborhoods of the form @xmath25 . then there exists a deterministic periodic schedule that avoids collision problems using @xmath35 time slots .",
    "the schedule is optimal in the sense that one can not achieve this property with fewer than @xmath6 time slots .",
    "suppose that @xmath36 is the neighborhood of @xmath17 .",
    "for @xmath4 in the range @xmath37 , we schedule the sensors located at the points @xmath38 at time @xmath5 .",
    "we first notice that each sensor located at a point in @xmath11 is scheduled at some point in time , since @xmath39 by property * t1 * of a tiling .    seeking a contradiction",
    ", we assume that the schedule is not collision - free .",
    "this means that at some time @xmath4 in the range @xmath40 there exist sensors located at the positions @xmath41 and @xmath42 with distinct @xmath29 and @xmath3 in @xmath31 such that @xmath43 .",
    "however , this would imply that @xmath44 for distinct @xmath29 and @xmath3 in @xmath31 , contradicting property * t2 * of a tiling .",
    "it follows that our schedule is collision - free .",
    "it remains to prove the optimality of the schedule .",
    "seeking a contradiction , we assume that there exists a schedule with @xmath45 time slots that is collision - free . this means that for some time slot @xmath4 in the range @xmath46 two elements @xmath47 and @xmath48 of @xmath25 must be scheduled .",
    "however , this would imply that the element @xmath49 is contained in both sets @xmath50 and @xmath51 , contradicting the assumption that the schedule with @xmath52 time slots is collision - free .",
    "we illustrate some aspects of the proof of the previous theorem in figure  [ fig : thm1a ] .",
    "( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    picture tile ; vardef pnt(expr a , b ) = (",
    "a*z3+b*z4 ) enddef ;    pickup pencircle scaled 1 ; path p ; p = ( ( 0,1)(0,2)(2,2)(2,3)(4,3)(4,0)(2,0)(2,1)(0,1)cycle ) ; draw p scaled t shifted ( 0.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath53 etex , pnt(1,2 ) ) ; label(btex @xmath54 etex , pnt(2,2 ) ) ; label(btex @xmath55 etex , pnt(3,3 ) ) ; label(btex @xmath56 etex , pnt(4,3 ) ) ; label(btex @xmath57 etex , pnt(3,2 ) ) ; label(btex @xmath58 etex , pnt(4,2 ) ) ; label(btex @xmath59 etex , pnt(3,1 ) ) ; label(btex @xmath60 etex , pnt(4,1 ) ) ;    tile : = currentpicture ; currentpicture : = nullpicture ;    draw tile ; draw tile shifted pnt(2,2 ) ; draw tile shifted pnt(0,4 ) ; draw tile shifted pnt(4,0 ) ; draw tile shifted pnt(4,4 ) ; draw tile shifted pnt(6,2 ) ; draw tile shifted pnt(8,0 ) ; draw tile shifted pnt(8,4 ) ;    label(btex @xmath61 etex , pnt(0,4 ) ) ; label(btex @xmath61 etex , pnt(13,4 ) ) ;    @xmath21    ( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    picture tile ; vardef pnt(expr a , b ) = ( a*z3+b*z4 ) enddef ;    pickup pencircle scaled 1 ; path p ; p = ( ( 0,1)(0,2)(2,2)(2,3)(4,3)(4,0)(2,0)(2,1)(0,1)cycle ) ; draw p scaled t shifted ( 0.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath53 etex , pnt(1,2 ) ) ; label(btex @xmath54 etex , pnt(2,2 ) ) ; label(btex @xmath55 etex , pnt(3,3 ) ) ; label(btex @xmath56 etex , pnt(4,3 ) ) ; label(btex @xmath57 etex , pnt(3,2 ) ) ; label(btex @xmath58 etex , pnt(4,2 ) ) ; label(btex @xmath59 etex , pnt(3,1 ) ) ; label(btex @xmath60 etex , pnt(4,1 ) ) ;    tile : = currentpicture ; currentpicture : = nullpicture ;    draw tile ; draw tile shifted pnt(2,2 ) ; draw tile shifted pnt(0,4 ) ; draw tile shifted pnt(4,0 ) ; draw tile shifted pnt(4,4 ) ; draw tile shifted pnt(6,2 ) ; draw tile shifted pnt(8,0 ) ; draw tile shifted pnt(8,4 ) ;    label(btex @xmath61 etex , pnt(0,4 ) ) ; label(btex @xmath61 etex , pnt(13,4 ) ) ;    draw p scaled t shifted pnt(3.5,2.5 ) dashed evenly ;",
    "our concept of tiling a lattice with translates of a prototile @xmath25 turned out to be convenient for our purposes . in this section",
    ", we relate the tilings of a lattice to tilings of the euclidean space @xmath12 , so that we can benefit from the large number of results that are available in the literature .",
    "any tiling of a lattice @xmath11 can be converted into a tiling of @xmath12 as follows .",
    "let @xmath62 denote the union of the closed voronoi regions about the points in @xmath25 .",
    "then the translates @xmath63 with @xmath3 in @xmath31 yield a tiling of @xmath12 .",
    "conversely , any tiling of @xmath12 with translates of a tile consisting of the union of voronoi regions of points in @xmath11 evidently yields a tiling of the lattice @xmath11 in our sense .",
    "figure  [ fig : quasipolyominoes ] shows some two - dimensional examples of voronoi regions .",
    "( 40,40 ) z1 = ( 1,0 ) ; z2 = ( 0,1 ) ;    pickup pencircle scaled 1 ; fill ( ( 0,0)(1,0)(1,1)(0,1)cycle ) scaled s shifted ( 6.4*(z1+z2 ) ) withcolor 0.8white ;    pickup pencircle scaled 3 ;    for k = 1 step s until 3*s : draw k*z1 + 1*z2 scaled 2 ; endfor ; for k = 1 step s until 3*s : draw k*z1+(s)*z2 ; endfor ; for k = 1 step s until 3*s : draw k*z1+(2*s)*z2 ; endfor ;    @xmath64    ( 40,40 ) z1 = ( 1,0 ) ; z2 = ( 0.5,0.866 ) ;    vardef pnt(expr a , b ) = ( a*z1+b*z2 ) enddef ;    pickup pencircle scaled 1 ; fill ( pnt(0,0)pnt(1,0)pnt(1,1)pnt(0,2 ) pnt(-1,2)pnt(-1,1)pnt(0,0)cycle ) scaled ( 0.5*s ) shifted ( z1+pnt(1*s,0.5*s ) ) withcolor 0.8white ;    pickup pencircle scaled 3 ;    for k = 1 step s until 3*s : draw k*z1 + 1*z2 scaled 2 ; endfor ; for k = 1 step s until 3*s : draw k*z1+(s)*z2 ; endfor ; for k = 1 step s until 3*s : draw ( -s+k)*z1+(2*s)*z2 ; endfor ;    the union of voronoi regions about points in a lattice are also known as quasi - polyforms .",
    "a quasi - polyform that is homeomorphic to the unit ball in @xmath12 is known as a polyform .",
    "the books by grnbaum and shepherd  @xcite and by stein and szab  @xcite contain numerous examples of tilings obtained by translating quasi - polyforms ( and especially polyforms ) .",
    "the polyforms in the square grid @xmath65 are called polyominoes , the most well - known type of polyforms ; see golomb s book  @xcite . by abuse of language",
    ", we will also refer to a prototile @xmath25 in @xmath66 as a polyomino if the union of the voronoi regions of @xmath25 form a polyomino .    a prototile @xmath25 in a lattice @xmath11 that admits a tiling is called _",
    "exact_. it is natural to ask the following question :    when is a given prototile @xmath25 exact , _",
    "i.e. _ , when does there exist a subset @xmath31 of @xmath11 such that the conditions * t1 * and * t2 * are satisfied ?",
    "beauquier and nivat gave a simple criterion that allows one to answer * q1 * for polynominos in the square lattice @xmath66 .",
    "roughly speaking , their criterion says that if @xmath25 can be surrounded by translates of itself such that there are no gaps or holes , then @xmath25 is exact ; see  @xcite for details .",
    "in particular , it immediately follows that each prototile shown in figure  [ fig : neighborhoods ] is exact .",
    "algorithmic criteria for deciding the question * q1 * are particularly interesting . for polyominoes in the square lattice @xmath66 , one can decide this question in time polynomial in the length of the boundary of the polyomino ( described by a word over the alphabet @xmath67 , which is short for up , down , left , and right ) , as wijshoff and van leeuwen have shown  @xcite .",
    "the characterization of exactness of a polyomino by beauquier and nivat @xcite mentioned above leads to an @xmath68 algorithm , where @xmath69 is the length of the word describing the boundary .",
    "recently , gambini and vuillon  @xcite derived an improved @xmath70 algorithm for this problem .",
    "less is known for arbitrary ( not necessarily connected ) prototiles in a general lattice .",
    "szegedy  @xcite derived an algorithm to decide whether a prototile @xmath25 in a lattice @xmath11 is exact assuming that the cardinality of @xmath25 is a prime or is equal to 4 .",
    "we have seen that the conditions for tiling a lattice with a single prototile are somewhat restrictive .",
    "for example , we might want to allow different rotated versions of the tile if the radiation pattern of the antenna used by a sensor is asymmetrical .",
    "we might want to consider different tiles corresponding to various different signal strength settings .",
    "furthermore , we might want to allow sensors with various different styles of antenna .",
    "we can accommodate all these different situations by allowing translates of several prototiles instead of just a single one . in this section , we show that one can still obtain an optimal periodic schedule which guarantees that the schedule is collision - free , as long as sensors of the same type and setting are deployed within each tile and a constraint on the tiles is satisfied .",
    "let @xmath11 be a lattice in @xmath12 .",
    "let @xmath71 be prototiles in the lattice @xmath11 , that is , @xmath72 is a subset of @xmath11 that contains @xmath17 for @xmath73 .",
    "let @xmath74 be pairwise disjoint nonempty subsets of @xmath11 .",
    "we say that @xmath75 provide a tiling of @xmath11 with prototiles @xmath76 if and only if the following two conditions are satisfied :    @xmath77    for all @xmath78 , we have @xmath79 for all @xmath80 in @xmath81 and @xmath82 in @xmath83 such that @xmath84 .",
    "condition * gt1 * ensures that the lattice @xmath11 is covered by translates of the prototiles @xmath71 .",
    "condition * gt2 * ensures that two distinct tiles will not overlap .",
    "the set @xmath81 contains all vectors that are used to translate the tile @xmath72 , that is , the set @xmath85 contains all shifted versions of @xmath72 that occur in the tiling of @xmath11 . since the sets @xmath75 are pairwise disjoint , it is clear that @xmath86 whenever @xmath87 .",
    "condition * gt2 * requires further that the translates of the prototile @xmath72 with elements in @xmath81 do not overlap .",
    "we will call a tiling of @xmath11 _ respectable _ if and only if the prototile @xmath88 contains all other prototiles @xmath72 , that is , @xmath89 for @xmath90 .",
    "if this is the case , then we call @xmath88 the",
    "_ respectable prototile_.    suppose that we are given a tiling @xmath74 of @xmath11 respectively with neighborhoods of the form @xmath76 .",
    "we will assume that the sensors are deployed in the following fashion :    a sensor at location @xmath80 in the neighborhood @xmath91 of an element @xmath92 in @xmath81 affects precisely the neighbors @xmath93 by interference , where @xmath4 is in the range @xmath73 .",
    "loosely speaking , condition * d1 * says that all elements in the neighborhood @xmath91 have neighborhood type @xmath72 .",
    "[ th : thm2 ] let @xmath74 be a respectable tiling of a euclidean lattice @xmath11 with neighborhoods of the type @xmath71 .",
    "suppose that the sensors are deployed according to the scheme  * d1*. then there exists a deterministic periodic schedule that avoids collision problems using @xmath94 time slots .",
    "the schedule is optimal in the sense that one can not achieve this property with fewer than @xmath6 time slots .",
    "the periodic schedule is specified as follows .",
    "let @xmath95 . for all @xmath96 in the range @xmath97 , we schedule the elements @xmath98 at time @xmath5 if and only if @xmath99 is contained in the neighborhood @xmath100 .",
    "notice that all elements in @xmath11 will be scheduled at some point in time by property * gt1*. furthermore , condition * gt2 * ensures that an element in @xmath11 is not scheduled more than once within @xmath6 consecutive time steps .",
    "we claim that this schedule is collision - free . seeking a contradiction",
    ", we assume that two distinct elements in @xmath11 are scheduled at the same time , but yield a collision problem .",
    "in other words , there must exist integers @xmath4 and @xmath96 in the range @xmath101 , an element @xmath102 such that @xmath69 is contained in both @xmath72 and @xmath100 , and elements @xmath103 and @xmath104 with @xmath84 such that @xmath105 .",
    "this implies that @xmath106 for @xmath84 , contradicting property * gt2*. therefore , our schedule is collision - free .    without loss of generality ,",
    "we may assume that the point @xmath17 in @xmath11 has a respectable neighborhood @xmath88 ( otherwise , simply shift the tiling such that this condition is satisfied ) . seeking a contradiction , we assume that there exists a deterministic periodic schedule with @xmath45 time slots that is collision - free .",
    "it follows that there must exist two distinct elements @xmath47 and @xmath48 in @xmath88 that are scheduled at the same time .",
    "however , this would imply that the element @xmath49 is contained in both @xmath107 and @xmath108 ; thus , @xmath109 , contradicting the fact that the schedule with @xmath52 time slots is collision - free .    the previous theorem is a natural generalization of theorem  [ th : thm1 ] .",
    "a salient feature of theorems  [ th : thm1 ] and  [ th : thm2 ] is that the optimal schedule is independent of the nature of the tiling of @xmath11 .",
    "notice that one can obtain a collision - free periodic schedule even when there does not exist a respectable prototile .",
    "in fact , the respectable prototile was only used in the last part of the proof of theorem  [ th : thm2 ] to establish the optimality of the schedule .",
    "therefore , one might wonder what will happen in the non - respectable case .",
    "let us agree on some ground rules .",
    "we would like to maintain the fact that for each translated version of a prototile the schedule is the same , as this simplifies configuring the sensor network .",
    "however , in the non - respectable case we might have different prototiles of the same size , so we allow that the schedules in the different prototiles can be independently chosen , as long as this does not lead to collision problems",
    ". figure  [ fig : non - respectable ] shows that the number of time steps in an optimal schedule depends on the chosen tiling when the tiling is non - respectable .",
    "( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    picture ltile , rtile ; vardef pnt(expr a ,",
    "b ) = ( a*z3+b*z4 ) enddef ;    pickup pencircle scaled 1 ; path p ; p = ( ( 0,1)(0,3)(1,3)(1,2)(2,2)(2,0)(1,0)(1,1)(0,1)cycle ) ; draw p scaled t shifted ( 0.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath53 etex , pnt(1,2 ) ) ; label(btex @xmath54 etex , pnt(1,3 ) ) ; label(btex @xmath57 etex , pnt(2,2 ) ) ; label(btex @xmath58 etex , pnt(2,1 ) ) ;    ltile : = currentpicture ; currentpicture : = nullpicture ;    path q ; q = p reflectedabout ( ( 2,0),(2,1 ) ) ; draw q scaled t shifted ( -1.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath56 etex , pnt(1,1 ) ) ; label(btex @xmath55 etex , pnt(1,2 ) ) ; label(btex @xmath53 etex , pnt(2,2 ) ) ; label(btex @xmath54 etex , pnt(2,3 ) ) ;    rtile : = currentpicture ; currentpicture : = nullpicture ;    draw ltile shifted pnt(0,5 ) ; draw ltile shifted pnt(1,2 ) ; draw ltile shifted pnt(3,0 ) ; draw ltile shifted pnt(4,1 ) ; draw ltile shifted pnt(5,2 ) ; draw ltile shifted pnt(4,5 ) ; draw ltile shifted pnt(2,7 ) ; draw ltile shifted pnt(1,6 ) ;    draw rtile shifted pnt(3,3 ) ; draw rtile shifted pnt(2,4 ) ;    @xmath21    ( 50,50 ) z3 = t*(1,0 ) ; z4 = t*(0,1 ) ;    picture ltile , rtile ; vardef pnt(expr a , b ) = ( a*z3+b*z4 ) enddef ;    pickup pencircle scaled 1 ; path p ; p = ( ( 0,1)(0,3)(1,3)(1,2)(2,2)(2,0)(1,0)(1,1)(0,1)cycle ) ; draw p scaled t shifted ( 0.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath53 etex , pnt(1,2 ) ) ; label(btex @xmath54 etex , pnt(1,3 ) ) ; label(btex @xmath55 etex , pnt(2,2 ) ) ; label(btex @xmath56 etex , pnt(2,1 ) ) ;    ltile : = currentpicture ; currentpicture : = nullpicture ;    path q ; q = p reflectedabout ( ( 2,0),(2,1 ) ) ; draw q scaled t shifted ( -1.5*z3 + 0.5*z4 ) withcolor 0.8white ;    label(btex @xmath56 etex , pnt(1,1 ) ) ; label(btex @xmath55 etex , pnt(1,2 ) ) ; label(btex @xmath53 etex , pnt(2,2 ) ) ; label(btex @xmath54 etex , pnt(2,3 ) ) ;    rtile : = currentpicture ; currentpicture : = nullpicture ;    for j = 0 step 2 until 4 : for i = 0 step 2 until 2 : draw rtile shifted pnt(i , j ) ; endfor ; endfor ;    for j = 0 step 2 until 4 : for i = 4 step 2 until 6 : draw ltile shifted pnt(i , j ) ; endfor ; endfor ;    draw pnt(4.5,0)pnt(4.5,9 ) dashed evenly ;",
    "we have introduced a deterministic periodic schedule for sensors using wireless communication that are placed on the points of a lattice .",
    "we have shown that the schedule is optimal assuming that there exists a respectable prototile .",
    "a natural question is whether the schedule remains optimal if one restricts the schedule from the lattice @xmath11 to a finite subset @xmath110 of @xmath11 .",
    "this question has an affirmative answer if @xmath110 contains a translate of the set @xmath111 , as the latter set consists of the respectable prototile @xmath88 and its neighbors , in which case our optimality proof carries over without change .",
    "another natural question is whether one can extend the method to the case of mobile sensors .",
    "this question has an affirmative answer . indeed , one straightforward way is to use our schedule to assign time slots to the locations rather than to the sensors .",
    "let us assume that the lattice points are spaced fine enough to ensure that only one sensor is within a voronoi region of a lattice point .",
    "if the time slot @xmath4 is assigned to a lattice point @xmath112 , then a sensor @xmath29 within the open voronoi region about @xmath112 can send at time @xmath3 if and only if @xmath5 and the interference range of @xmath29 fits within the tile of @xmath112 .",
    "clearly , this yields a collision - free schedule for mobile sensors .",
    "however , it should be stressed that there are many other solutions possible , but a comparison of such methods is beyond the scope of this paper ."
  ],
  "abstract_text": [
    "<S> suppose that wirelessly communicating sensors are placed in a regular fashion on the points of a lattice . </S>",
    "<S> common communication protocols allow the sensors to broadcast messages at arbitrary times , which can lead to problems should two sensors broadcast at the same time . </S>",
    "<S> it is shown that one can exploit a tiling of the lattice to derive a deterministic periodic schedule for the broadcast communication of sensors that is guaranteed to be collision - free . </S>",
    "<S> the proposed schedule is shown to be optimal in the number of time slots .    </S>",
    "<S> * keywords : * distributed computing , scheduling sensors , lattice tiling , wireless communication . </S>"
  ]
}