{
  "article_text": [
    "storage is a new paradigm of storing data .",
    "it allows users to access data anywhere and anytime .",
    "companies such as google and apple are providing this service through their data centers , which are network - connected .",
    "such an architecture is called the distributed storage system ( dss ) .",
    "storage nodes in a dss are generally unreliable and subject to failure .",
    "when a failure occurs , a newcomer needs to _ repair _ the lost data by retrieving data from surviving storage nodes , called helper nodes , so as to maintain the _ reliability _ of the dss . besides",
    ", the dss should be able to provide data _ availability _ , which allows users to access their data anywhere and with low delay .    to provide reliability and availability ,",
    "erasure codes such as replication or reed - solomon ( rs ) code are commonly used . while replication requires less network bandwidth during node repair , rs code is more efficient in terms of storage space . in 2007 , dimakis et al . showed that there is a fundamental tradeoff between storage space and repair bandwidth  @xcite .",
    "points on the tradeoff curve can be achieved by a class of codes called _ regenerating codes _ , which is based on the concept of network coding . in their formulation ,",
    "a newcomer is able to recover the lost data by connecting to any @xmath0 surviving storage nodes , and a data collector is able to retrieve the data object by downloading data from any @xmath1 out of the @xmath2 storage nodes .",
    "we call this distributed storage model the _ regular _ model .",
    "since then , many codes that achieve points on the tradeoff curve have been constructed ( e.g.  @xcite ) .",
    "the design rationale of regenerating codes is to minimize repair bandwidth .",
    "these codes , however , generally incur high disk i / o access during repair , since helper nodes need to read its stored data and linearly combine them to form packets to be sent to a newcomer .",
    "the stored data that needs to be read is often much more than the data to be sent to the newcomer .",
    "the disk access bandwidth thus becomes the bottleneck . in  @xcite ,",
    "the repair problem is considered in a different way .",
    "it aims to minimize the amount of information to be accessed when the number of node failures is smaller than the erasure correcting capability of an mds code .",
    "another approach is considered in  @xcite .",
    "it proposes a new code formed by concatenating an outer mds code with an inner fractional repetition ( fr ) code .",
    "we call it mds - fr code .",
    "this code is a minimum bandwidth regenerating ( mbr ) code , which means that it minimizes the repair bandwidth of the system .",
    "furthermore , it has the nice _ uncoded repair _ property : a helper node only needs to read the exact amount of data that it needs to forward to the newcomer without any processing . in other words",
    ", it minimizes both repair bandwidth and disk access bandwidth at the same time .",
    "while the original construction of the fr code in  @xcite is based on regular graph and steiner system , other constructions exist , which are based on bipartite graph  @xcite , randomized algorithm  @xcite , resolvable designs  @xcite , and incidence matrix  @xcite .",
    "note that the above mentioned works do not strictly follow the regular model , as they have different design considerations in mind .",
    "another notable example is the locally repairable code  @xcite , which aims at reducing the number of nodes that need to be contacted during repair .    in this paper",
    ", we focus on heterogeneous distributed storage systems .",
    "examples include heterogenous data centers , peer - to - peer cloud storage systems ( e.g. space monkey )  @xcite , peer - assisted cloud storage systems , and some wired or wireless caching systems  @xcite . in these applications , the storage nodes and the network links",
    "are _ heterogeneous _ , meaning that the storage capacities and costs associated with different storage nodes may not be the same , and the communication links between each pair of storage nodes may have different characteristics in terms of bandwidth , communication cost , and transmission rate . furthermore , it is also possible that some storage nodes are not directly connected . in such an environment ,",
    "new issues arise .",
    "the storage allocation problem , which focuses on how to allocate a given storage budget over the storage nodes such that the probability of successful recovery is maximized , is studied in  @xcite . a distributed storage system in which the storage nodes have different download costs",
    "is considered in  @xcite . in a distributed storage system with storage cost , how to allocate storage capacities among the storage nodes",
    "so as to minimize the total storage cost is investigated in  @xcite . in  @xcite , the bandwidth heterogeneity is taken into account to demonstrate that the tree - structured regeneration topology is an efficient topology to reduce the regeneration time . under functional repair model ,",
    "the link costs and the impact of network topology are jointly considered in  @xcite , and an information - theoretic study is performed in  @xcite .    to address the design issues of heterogenous cloud storage systems , we set up a flexible model , called the _ irregular _ model , in which the underlying network topology can be arbitrary , the storage capacities and costs of different storage nodes are allowed to be different , and the bandwidth and costs of communication links need not be the same .",
    "we relax the constraints of data repair and data retrieval in the regular model by introducing the concepts of repair overlay and retrieval sets .",
    "we use the term repair overlay to refer to the structure of an overlay network for data repairing .",
    "note that it is called repair table in  @xcite . in the work of  @xcite , for single failure case ,",
    "the repair overlay is restricted to be a regular graph with each vertex having degree @xmath0 , and the graph is randomly generated . in this paper , we do not restrict the repair overlay to be a regular graph .",
    "for the general case of multiple failures , the repair overlay in  @xcite is a steiner system .",
    "however , the existence of a steiner system requires the system parameters to satisfy some specific conditions , which makes the system design inflexible . in this paper , hypergraph",
    "is used to model the repair overlay , which exists for arbitrary system parameters and can be constructed easily compared with steiner system .",
    "recall that the code used in  @xcite is a concatenation of an outer mds code and an inner fr code .",
    "we call this construction the mds - fr code .",
    "we extend the idea and propose the use of the _ irregular fractional repetition _ ( ifr ) code as the inner code .",
    "while it preserves the desirable uncoded repair property , it further allows more flexibility in system design .",
    "when the distributed storage system and the underlying network is heterogeneous , the ifr code can be constructed and adapted to the given environment by solving an optimization problem , thus further reducing repair bandwidth . in our formulation , we minimize the system repair cost by properly choosing the mds - ifr code .",
    "the problem is shown to be an integer linear programming ( ilp ) problem . when the number of storage nodes is small , the optimal solution can be found in a reasonable time . for larger networks ,",
    "we decompose the problem into subproblems and propose a heuristic solution . for small network sizes ,",
    "our heuristic is shown to be nearly optimal by comparing it with the optimal ilp method .",
    "the rest of the paper is organized as follows .",
    "a motivating example is given in section  [ sec : motivation ] .",
    "section  [ sec : model ] states our irregular model for distributed storage systems . in section  [ sec : code ] , we describe the construction of mds - ifr code and its relationship with the concept of relay overlay . in section  [ sec : formulation ] , we formulate the repair cost minimization problem as an integer linear problem ( ilp ) . in section  [ sec : tradeoff ] , we describe how the storage - repair tradeoff of our code can be found . in section  [ sec : heuristic ] , we design heuristic algorithms to find suboptimal repair overlay and retrieval sets .",
    "section  [ sec : simulation ] provides our simulation results .",
    "we conclude the paper in section  [ sec : conclusion ] .",
    "the regular model assumes that a newcomer is able to replace a failed storage node by contacting any @xmath0 surviving storage nodes and a data collector can retrieve the stored data object by downloading data from any @xmath1 out of the @xmath2 storage nodes . in some practical scenarios , however , the communication costs between a newcomer and each of the surviving storage nodes are different . furthermore , the distances and transmission rates between a data collector and each of the @xmath2 storage nodes vary with the location of the data collector .",
    "the @xmath0 surviving nodes to be contacted by a newcomer and the @xmath1 storage nodes to be contacted by a data collector need not be arbitrary .",
    "it is reasonable to determine some sets of helper nodes , called _",
    "helper sets _ , for a newcomer and some subsets of the @xmath2 storage nodes , called _ retrieval sets _ , for a data collector .",
    "the collection of helper sets of all the @xmath2 storage nodes defines the repair overlay .",
    "thus , we modify data repair and data retrieval mechanisms based on the concepts of repair overlay and retrieval sets .",
    "we only require that a newcomer can rebuild the corresponding failed node by contacting the storage nodes in any one of its helper sets and a data collector can retrieve the data object by contacting the storage nodes in any one of the retrieval sets .",
    "consider a distributed storage system that can tolerate single failures with the following parameters : @xmath3 , and @xmath4 .",
    "a data object consisting of four packets would be stored in this distributed storage system . for the regular model ,",
    "the corresponding tradeoff between storage amount and repair bandwidth under functional repair is shown in fig .",
    "[ fi : ringtradeoff ] , where the feasible region is shown as the shaded area .",
    "note that all points on the tradeoff curve are normalized by the number of packets contained in the data object .",
    "the points below the tradeoff curve are impossible to achieve by functional repair .",
    "clearly , they can not be achieved by exact repair either .",
    "now we consider the irregular model , which includes the concepts of repair overlay and retrieval sets .",
    "we require that the number of retrieval sets are large enough . in this example",
    ", we require that there should be at least @xmath5 retrieval sets .",
    "assume that the chosen repair overlay , denoted by @xmath6 , is a ring with six nodes , as shown in fig .",
    "[ fi : ringexample](a ) ( solid lines ) .",
    "we show how to construct mds - fr code based on the repair overlay .",
    "the data object consisting of four packets are first encoded into six packets , @xmath7 , @xmath8 ,  , @xmath9 by a @xmath10-mds code .",
    "each edge in the 6-node ring is then associated with a coded packet .",
    "each node stores the two packets that are associated with its incident edges , as shown in fig .",
    "[ fi : ringexample](a ) .",
    "thus , the storage amount of each of the six storage nodes is @xmath11 . in this example",
    ", each storage node has one helper set and a newcomer can recover the lost data by connecting to @xmath12 nodes in its helper set , i.e. , its two neighboring nodes in the ring , rather than _ any _ @xmath12 surviving nodes .",
    "since each newcomer downloads one packet from each of its two helper nodes to recover the lost data , the repair bandwidth of a failed node is @xmath11 .",
    "suppose node 3 fails",
    ". a newcomer can replace it by downloading coded packets @xmath8 and @xmath13 from its two helper nodes 2 and 4 , respectively , as shown in fig .",
    "[ fi : ringexample](b ) . as for data retrieval",
    ", we can have nine retrieval sets of cardinality @xmath14 , which are listed as @xmath15 , @xmath16 , @xmath17 , @xmath18 , @xmath19 , @xmath20 , @xmath21 , @xmath22 and @xmath23 .",
    "a data collector can reconstruct the data object by connecting to the @xmath14 storage nodes in any one of the nine retrieval sets .",
    "after normalizing by the number of packets of the original data object , the storage amount of each storage node is @xmath24 and the repair bandwidth per failed node is also @xmath24 .",
    "this point is also plotted in fig .",
    "[ fi : ringtradeoff ] , which is below the tradeoff curve of the regular model . from fig .",
    "[ fi : ringtradeoff ] , we can see that with the same storage amount per node , the repair bandwidth is reduced by @xmath25 , which shows that the potential gain can be enormous _ if the constraints of data repair and data retrieval are relaxed_.    in the irregular model , different storage nodes are allowed to have different storage costs and different links are allowed to have different communication costs .",
    "an irregular model with storage cost and communication cost is given in fig .",
    "[ fi : ringexample](c ) , where node @xmath26 has a ( per - packet ) storage cost @xmath27 and the link connecting node @xmath26 and node @xmath28 has a ( per - packet ) communication cost @xmath29 . for both fr code and ifr code , we assume that the number of packets assigned to edge @xmath30 is @xmath31 and the number of packets stored in node @xmath26 is @xmath32 .",
    "the total storage cost can then be obtained as @xmath33 and the total repair cost of all possible single node failures can be calculated as @xmath34 . if we use the same mds - fr code as before , the total storage cost of the six storage nodes is @xmath35 since each node stores @xmath11 packets , and the total repair cost of all possible single node failures can be calculated as @xmath36 , where the six components of the summation correspond to the repair costs of node 1 to node 6 , respectively .",
    "if we use mds - ifr code , we first encode the data object into seven packets by using a @xmath37-mds code .",
    "then we assign coded packet @xmath7 to edge @xmath38 , @xmath8 to edge @xmath39 , @xmath13 to edge @xmath40 , @xmath41 , @xmath42 , and @xmath9 to edge @xmath43 , and @xmath44 to edge @xmath45 .",
    "each node then stores the packets associated with its incident edges , as shown in fig .",
    "[ fi : ringexample](d ) . in this example",
    ", a newcomer can recover the lost data by connecting to only one node or to two nodes , depending on which node is failed .",
    "this contrasts with the mds - fr code , in which a newcomer always connects to _ exactly _ @xmath0 nodes .",
    "for example , if node 4 fails , a newcomer can replace it by downloading packet @xmath13 from node 3 .",
    "as for data retrieval , we can have ten retrieval sets of cardinality @xmath14 , which are listed as @xmath15 , @xmath46 , @xmath47 , @xmath48 , @xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath23 and @xmath53 .",
    "the total storage cost of the six nodes is @xmath54 and the total repair cost of all possible single node failures can be calculated as @xmath55 , where the six components of the summation corresponding to the repair costs of node 1 to node 6 , respectively .",
    "compared with mds - fr code , we can see that both storage cost and repair cost can be reduced if mds - ifr code is adopted in the irregular model .",
    "although the retrieval sets in the two cases are different , in the latter case , more retrieval sets are provided , which is often more desirable .",
    "should exactly the same number of retrieval sets are needed for a fairer comparison , one can simply remove one of the retrieval sets for the latter case , as that would not affect the storage and repair costs .    in the above example",
    ", we show that there can be large performance gain in designing distributed storage systems .",
    "however , the result should be interpreted with caution .",
    "we do not claim that mds - ifr code outperforms well - known regenerating code and mds - fr code under their respective problem settings .",
    "in fact , they are known to be optimal under their respective problem definitions . instead , the example serves two purposes .",
    "first , it justifies the setup of the irregular model , which is more appropriate for heterogeneous cloud storage systems .",
    "second , it explains the irregular model and the mds - ifr code in an intuitive way , which facilitates the understanding of the next two sections , which formally define these concepts .",
    "consider a distributed storage network , in which @xmath2 storage nodes are distributed across a wide geographical area and connected by a network with a specific topology .",
    "a data object is encoded and distributed among the @xmath2 storage nodes .",
    "let the data object be represented by a collection of @xmath56 packets , where each packet is an element drawn from a finite field gf(@xmath57 ) of size @xmath57 .",
    "note that a packet is the minimum unit for all storage and transmission operations in a storage system .",
    "we model the underlying storage network as a connected weighted undirected graph @xmath58 , where the storage nodes are vertices in the vertex set @xmath59 and the communication links correspond to the edges in the edge set @xmath60 . throughout this paper , we assume that @xmath61 .",
    "each vertex @xmath62 has an associated storage cost @xmath27 indicating the cost of storing a packet in node @xmath26 .",
    "we define the storage cost vector @xmath63 $ ] . besides , each edge @xmath64 connecting vertices @xmath26 and @xmath28 ( @xmath65 ) has an associated weight @xmath66 , called single - hop cost , which represents the cost of transmitting a packet along this edge .",
    "if there is no direct communication link between two vertices , we let the corresponding single - hop cost be infinite .",
    "the cost to transmit a packet from vertex  @xmath26 to vertex  @xmath28 is called the communication cost and is denoted by @xmath29 .",
    "the values of @xmath29 s can be obtained from @xmath66 , depending on the underlying communication assumptions .",
    "for example , if multi - hop transmissions are allowed , then @xmath29 can be defined as the cost of the minimum - cost path from  @xmath26 to  @xmath28 , where the cost of a path is the sum of the single - hop costs of its constituent edges .",
    "if only single - hop transmissions are allowed , then @xmath29 equals @xmath66 for all @xmath26 and @xmath28 .",
    "the matrix @xmath67 $ ] is called the single - hop cost matrix , and the matrix @xmath68 $ ] is called the communication cost matrix . note that both @xmath69 and @xmath70 are symmetric .    in this paper ,",
    "multi - hop transmissions are allowed in the underlying storage network .",
    "since the storage network is assumed to be connected , we can construct a complete weighted graph @xmath71 on the vertex set @xmath59 , where the weight of an edge @xmath72 is equal to the cost of the minimum - cost path between vertices @xmath26 and @xmath28 , say the communication cost @xmath29 .",
    "we call @xmath73 the metric closure of @xmath74 .",
    "to compute the metric closure @xmath73 of @xmath74 , we can use johnson s algorithm  ( * ? ? ?",
    "* chapter 25 ) to find the costs of the minimum - cost paths between all pairs of vertices in @xmath59 .",
    "we formally define a distributed storage system with specific repair and retrieval requirements as follows :    dss(@xmath75 ) is a distributed storage system with @xmath2 storage nodes which satisfies the following requirements :    1 .",
    "( data repair ) as long as there are no more than @xmath76 simultaneous node failures , the lost packets of any failed node can be exactly recovered from no more than @xmath0 surviving nodes .",
    "2 .   ( data retrieval )",
    "a collection of @xmath77 retrieval sets of cardinality @xmath1 , denoted by @xmath78 , is specified such that the data object can be obtained from any retrieval set in @xmath79 .    in realistic distributed storage systems",
    ", @xmath76 is typically a small value .",
    "for example , the 3-replication scheme where @xmath80 serves the google file system ( gfs ) well  @xcite . on the other hand ,",
    "the data repair requirement is different from the regular model in that we do not require that a failed node can be repaired by contacting _ any _",
    "@xmath0 surviving nodes .",
    "as for data retrieval , we require that the storage system has @xmath77 retrieval sets of cardinality @xmath1 . this encompasses the data retrieval requirement of the regular model as a special case , which corresponds to the setting of @xmath81 .",
    "although in our formulation , all the retrieval sets have the same cardinality , it does not mean that all the storage nodes in a retrieval set need to be contacted for data retrieval , since it is allowed that the data object can be retrieved from a subset of @xmath82 .",
    "our code construction is a concatenation of an outer mds code and an inner irregular fractional repetition ( ifr ) code .",
    "we call it mds - ifr code . the data object comprised of @xmath56 packets",
    "is first encoded into @xmath83 packets over gf(@xmath57 ) by using an @xmath84-mds code .",
    "note that such code exists provided that @xmath85 ( e.g.  @xcite ) . in practice",
    ", the decoding complexity may be high for large values of @xmath57 . in that case ,",
    "the vector linear code recently proposed in  @xcite can be used instead .",
    "this code is easy to decode as it has the property called zigzag decodability and all computations are performed over gf(2 ) .",
    "the price to pay is some extra storage overhead .",
    "we refer interested readers to  @xcite for details .",
    "after encoding by the outer code , the set of the @xmath83 coded packets , denoted by @xmath86 , is partitioned into @xmath87 _ coded blocks _ , @xmath88 , where @xmath89 for all @xmath26 .",
    "note that @xmath90 denotes the number of packets in @xmath91 , and @xmath92 .",
    "we call @xmath93 $ ] the _ block assignment vector _ , which will be optimized in the next section .",
    "we remark that the block assignment vector @xmath94 , rather than what packets contained in @xmath91 for @xmath95 , will affect the solution of minimizing the system repair cost in the next section .",
    "that is why we introduce the definition of coded blocks instead of working directly on packets .",
    "each coded block is then replicated @xmath96 times and stored on @xmath96 different storage nodes according to an ifr code , defined as follows :    an irregular fractional repetition ( ifr ) code @xmath97 for dss(@xmath98 ) is a collection @xmath97 of @xmath2 subsets of @xmath99 , satisfying the requirements that each set in @xmath97 has cardinality at most @xmath0 and each element of @xmath100 belongs to exactly @xmath96 sets in @xmath97 .",
    "note that ifr code generalizes fr code in that it only requires the cardinality of each set in @xmath97 to be no more than @xmath0 , rather than exactly @xmath0 .",
    "that is why we call it _",
    "irregular_. besides , it addresses only the repair issue , which will become clear after we introduce the concept of repair overlay , and is independent of the parameters related to data retrieval , that is , @xmath1 and @xmath77 .",
    "an ifr code can be represented by a hypergraph @xmath101 , where @xmath59 is the vertex set and @xmath102 is a family of @xmath87 non - empty subsets of @xmath59 , called hyperedges .",
    "a hypergraph is said to be @xmath103-uniform if all of its hyperedges have the same size @xmath103 .",
    "the following fact is evident :    an irregular fractional repetition ( ifr ) code @xmath97 for dss(@xmath75 ) is equivalent to a @xmath104-uniform hypergraph @xmath6 with @xmath87 hyperedges and @xmath2 vertices , each of which has degree less than or equal to @xmath0 .",
    "we call such kind of hypergraph @xmath6 a _ repair overlay _ , or an _ overlay hypergraph_. the above fact follows directly from the definitions of ifr code and uniform hypergraph , which can be illustrated by the example below .",
    "* example * : let @xmath105 and @xmath106 . note that @xmath107 . furthermore , it can be checked that each element of @xmath100 belongs to three sets in @xmath97 , so @xmath108 .",
    "besides , the cardinality of each set in @xmath97 is at most three , so @xmath109 . therefore , @xmath97 is an ifr code for dss@xmath110 .",
    "this ifr code @xmath97 can be represented by a @xmath111-uniform hypergraph @xmath112 , where @xmath113 and @xmath114 , as shown in fig .",
    "[ fi : ifr_hypergraph_example ] .",
    "the hypergraph @xmath6 has @xmath3 vertices , each of which has degree less than or equal to @xmath115 .",
    "each hyperedge in @xmath6 contains @xmath116 vertices .",
    "let @xmath117 be a given repair overlay . as described before ,",
    "the data object is first encoded into @xmath87 coded blocks by an outer mds code . for @xmath95 , the coded block @xmath91",
    "is then assigned to @xmath118 .",
    "all vertices contained in @xmath119 then store @xmath91 in common .",
    "the storage amount @xmath120 of a vertex @xmath121 can then be obtained as @xmath122 .",
    "note that @xmath83 and @xmath120 are related by @xmath123 , since each coded block is replicated @xmath96 times .",
    "data repair is very simple .",
    "when there is a node failure , a newcomer will replace the failed node by retrieving the previously stored data from a set of helper nodes . for example , suppose node @xmath124 which contains coded blocks @xmath125 fails , the newcomer can directly retrieve @xmath91 from any surviving node in @xmath119 for all @xmath26 such that @xmath126 .",
    "this is what we call _ uncoded _ and _ exact _ repair .",
    "since the cardinality of a hyperedge is @xmath96 , this kind of repair can be done successfully provided that the number of node failures is no more than @xmath76 .",
    "* example * : consider a distributed storage network @xmath74 shown in fig .",
    "[ fi : repairexample]@xmath127 .",
    "the number associated with an edge denotes the single - hop cost between its two endpoints .",
    "[ fi : repairexample]@xmath128 is the metric closure , @xmath73 , of @xmath74 , where the number associated with an edge is the corresponding communication cost .",
    "suppose this storage network can tolerate up to @xmath80 node failures , and each failed node can be recovered from at most @xmath115 available storage nodes .",
    "one feasible repair overlay is shown in fig .  [",
    "fi : repairexample]@xmath129 , where every hyperedge has @xmath116 nodes and the degree of each node is less than or equal to @xmath115 .",
    "assign coded blocks @xmath130 , @xmath131 , @xmath132 and @xmath133 to hyperedges @xmath134 , @xmath135 , @xmath136 and @xmath137 respectively . then node @xmath138 would store blocks @xmath130 and @xmath131 , node @xmath11 would store @xmath130 and @xmath133 , node @xmath111 would store @xmath130 , @xmath132 and @xmath133 , node @xmath139 would store @xmath131 , @xmath132 and @xmath133 , and node @xmath140 would store @xmath131 and @xmath132 .",
    "suppose nodes @xmath138 and @xmath11 fail .",
    "the newcomer for node  1 can download @xmath130 from node  3 and download @xmath131 from either node  4 or node  5 , while the newcomer for node  2 can download @xmath130 from node  3 and download @xmath133 from node  3 or node  4 .",
    "in this section , we consider the problem of minimizing repair cost .",
    "we first present an algorithm to find optimal repair order when there is more than one failed node . based on this result",
    ", we further construct an optimization framework to determine the rate of the outer mds code , the structure of the ifr code by means of repair overlay , the storage amount of each node , and the collection of retrieval sets .      in this subsection",
    ", we assume that a repair overlay , @xmath6 , is given .",
    "we use @xmath141 to denote a set of failed nodes and call it a failure pattern . let @xmath142 be the set of failed nodes in hyperedge @xmath143 under failure pattern @xmath141 . to repair all the failed nodes in @xmath141 , we need @xmath144 newcomers in total . all lost blocks , i.e. , @xmath145 , need to be regenerated in the corresponding newcomers .",
    "this can always be done provided that @xmath146 . in that case",
    ", we say that @xmath141 is _",
    "repairable_.    let us focus on one particular lost block , @xmath91 . each newcomer of a failed node in @xmath147 needs to get a copy of @xmath91 from a certain helper node , which can be a surviving node or another newcomer that has already recovered the coded block @xmath91 .",
    "the cost for a newcomer to repair @xmath91 is simply the block size , @xmath90 , multiplied by the communication cost between the newcomer and its helper node .",
    "if there is only one node in @xmath147 , then it is clear that the only newcomer , say node @xmath124 , should choose a helper node @xmath148 that minimizes the communication cost @xmath149 .",
    "if there are multiple nodes in @xmath147 , the repair order will affect the total repair cost . to minimize the total repair cost for @xmath91 , a greedy algorithm , which is stated in algorithm  [ alg : repairprocess ] , can be used .    1 .",
    "pick the minimum - weight edge @xmath150 , where @xmath151 and @xmath152 .",
    "then the newcomer of node @xmath124 chooses node @xmath148 to be its helper node and downloads a copy of @xmath91 from node @xmath148 along the minimum - cost path .",
    "2 .   remove node @xmath124 from @xmath147 , i.e. , @xmath153 , which means that the newcomer of node @xmath124 has already recovered @xmath91 and is able to act as helper node of other newcomers that still need to recover @xmath91 .",
    "repeat steps 1 ) and 2 ) until all the newcomers in @xmath119 recover @xmath91 , i.e. , @xmath154 .    for any given repairable failure pattern @xmath141",
    ", algorithm  [ alg : repairprocess ] minimizes the cost of repairing @xmath91 , for all @xmath26 such that @xmath155 .",
    "replace all nodes @xmath156 by a virtual node @xmath157 . for @xmath152 ,",
    "let @xmath158 .",
    "a weighted complete graph @xmath159 can be constructed on the vertex set @xmath160 , where the edge weight is the corresponding communication cost .",
    "the repairing of @xmath91 is equivalent to sending @xmath91 from node @xmath157 to all nodes in @xmath147 .",
    "therefore , the minimum cost of repairing @xmath91 is equal to @xmath90 times the weight of the minimum spanning tree of the graph @xmath159 .",
    "let @xmath161 be the sequence of edges of @xmath73 chosen by algorithm  [ alg : repairprocess ] .",
    "let @xmath162 be the sequence of edges of @xmath159 chosen by the well - known prim s algorithm  ( * ? ? ?",
    "* chapter 23 ) for finding a minimum spanning tree on graph @xmath159 with @xmath157 being the initial vertex .",
    "it can be seen that the communication cost of @xmath163 is equal to the weight of @xmath164 for all @xmath26 .",
    "therefore , algorithm  [ alg : repairprocess ] is optimal .",
    "note that the repair processes of different coded blocks are independent , and thus can be executed in parallel . in repairing @xmath91 under the failure pattern @xmath141 , let the set of edges chosen by algorithm  [ alg : repairprocess ] be denoted by @xmath165 . given a repair overlay @xmath6 and a block assignment vector @xmath166 ,",
    "the total repair cost , normalized by the object size @xmath56 , under failure pattern @xmath141 is then given by @xmath167      our objective is to design the mds - ifr code so as to minimize the system repair cost .",
    "if a non - repairable failure pattern @xmath141 occurs , the whole data object will be decoded by downloading data from one of the retrieval sets and then re - encoded for storage in the newcomers .",
    "we assume that the system is properly designed so that the probability of occurrence of a non - repairable failure pattern is small . therefore , we focus on minimizing the expected repair cost per unit data , where the expectation is taken over all repairable patterns .",
    "we call it the _ system repair cost _ and denote it by @xmath168 . given a repair overlay @xmath6 and a block assignment vector @xmath94 ,",
    "it can be written as @xmath169 where @xmath170 be the probability of occurrence of @xmath141 , on the condition that the failure pattern @xmath141 is repairable .",
    "let @xmath171 be all the @xmath104-subsets of @xmath59 .",
    "we use a binary variable to indicate whether @xmath172 belongs to the hyperedge set @xmath173 of a repair overlay @xmath6 : @xmath174 let @xmath175 $ ] .",
    "we call it an _ overlay selection vector_. to ensure that the degree of each vertex @xmath124 in @xmath59 is not larger than @xmath0 , we have the following constraints @xmath176 note that the binary vector @xmath177 defines a repair overlay , which we denote it by @xmath178 .    as a coded block @xmath179 is assigned to hyperedge @xmath172 if and only if it would be contained in the overlay hypergraph , we therefore have the constraints @xmath180    for each storage node , it stores all the coded blocks associated with the hyperedges containing it .",
    "thus the storage amount of node @xmath124 , denoted by @xmath120 , can be obtained as @xmath181 note that considering data retrieval , @xmath120 need not be greater than @xmath56 due to the outer mds code . to facilitate efficient uncoded repair ,",
    "however , we allow @xmath120 to exceed @xmath56 .",
    "given a repair overlay @xmath6 and a block assignment vector @xmath94 , we assume that there is a constraint on the _ system storage cost _ , denoted by @xmath182 , which is defined as the cost of storing one unit data object in dss(@xmath75 ) .",
    "let @xmath183 be the maximum allowable system storage cost .",
    "then we have @xmath184 note that @xmath183 is a given constant , which constrains the total storage cost in the system .",
    "we do not impose any constraint on the storage amount of each storage node .",
    "if needed , that kind of constraints can be easily added , and our proposed algorithm , to be described in a later section , can still be applied without any modification .",
    "recall that the dss(@xmath75 ) needs to satisfy the data retrieval requirement .",
    "there is a collection of retrieval sets , @xmath185 .",
    "part or all of these sets may be pre - determined based on considerations other than storage and repair costs .",
    "for example , if a data object is mainly needed by users in a specific geographical region , it would be more convenient if one or more retrieval sets are formed by storage nodes in that region , so that the response time for a user to download that object can be shortened . to provide more flexibility in our optimization framework ,",
    "we allow @xmath186 retrieval sets be given while the remaining @xmath187 retrieval sets are obtained by our optimization procedure .",
    "for the pre - determined retrieval sets , @xmath188 , we need to ensure that each of them stores at least @xmath56 coded packets in @xmath86 .",
    "therefore , we have the following constraints : @xmath189 it remains to determine the other @xmath190 retrieval sets .",
    "denote the @xmath1-subsets of @xmath59 , excluding the pre - determined retrieval sets , by @xmath191 , where @xmath192 . to indicate whether @xmath193 is a retrieval set or not",
    ", we introduce a binary variable @xmath194 let @xmath195 $ ] .",
    "we call it a _ retrieval set selection vector_. to guarantee that there are @xmath190 more retrieval sets , we have @xmath196 note that @xmath197 defines a collection of retrieval sets , which we denote it by @xmath198 .",
    "similar as before , we have @xmath199    as mentioned before , our objective function is the system repair cost of dss(@xmath75 ) .",
    "formally , the repair cost minimization problem can be stated as follows .",
    "@xmath200 subject to @xmath201    @xmath202    @xmath203    @xmath204    the optimization is an integer linear programming ( ilp ) problem , where @xmath205 , @xmath197 , and @xmath94 are the optimization variables .",
    "in our formulation , it is clear that there is a tradeoff between the system storage cost , @xmath206 , and the system repair cost , @xmath207 . to make this relationship more explicit , we introduce the following notions . for the ease of presentation , we assume that @xmath208 for the rest of this paper .",
    "a cost pair @xmath209 is @xmath56-achievable by the mds - ifr code if given any data object of size @xmath56 , there exists a repair overlay @xmath6 , a collection of retrieval sets @xmath79 , and a block assignment vector @xmath166 such that @xmath210 , @xmath211 , and the data repair and retrieval requirements are satisfied .    note that @xmath90 s must be integers no more than @xmath56 .",
    "therefore , the achievable region enlarges when @xmath56 increases .",
    "it is therefore natural to define the asymptotic achievable region for arbitrarily large value of @xmath56 :    a cost pair @xmath209 is asymptotically achievable by the mds - ifr code if for any @xmath212 , there exists for sufficiently large @xmath56 , a repair overlay @xmath6 , a collection of retrieval sets @xmath79 , and a block assignment vector @xmath166 such that @xmath213 , @xmath214 , and the data repair and retrieval requirements are satisfied .",
    "the following result shows that the asymptotically achievable cost can be obtained by relaxing the integer constraint on @xmath166 :    given any @xmath56 and @xmath183 , let @xmath215 $ ] , @xmath216 , and @xmath217 be the solution to the repair cost minimization after relaxing the integer constraint on @xmath166 , and @xmath218 be the corresponding system repair cost .",
    "the cost pair @xmath219 is asymptotically achievable by the mds - ifr code .",
    "first of all , note that @xmath207 and @xmath206 are invariant to scaling @xmath56 and all @xmath220 s by the same amount , no matter whether @xmath220 s are integers or not .",
    "suppose we scale up @xmath56 and @xmath220 s all by @xmath221",
    ". then we round _ up _ all @xmath220 s to the nearest integers . by   and",
    ", the new system repair cost is given by @xmath222 where @xmath223 .",
    "since @xmath224 can be arbitrarily large , the second term can always be made smaller than @xmath225 .",
    "similarly , the new storage cost can be proven to be smaller than @xmath226 for sufficiently large @xmath224 .",
    "therefore , @xmath219 is asymptotically achievable .    to identify the optimal tradeoff between system repair cost and system storage cost , we need to introduce the following two concepts :",
    "a @xmath56-achievable cost pair @xmath209 is called pareto - optimal if and only if there does not exist other @xmath56-achievable cost pair @xmath227 such that the following two conditions are satisfied :    1 .",
    "@xmath228 and @xmath229 , and 2 .",
    "@xmath230 or @xmath231 .    roughly speaking , pareto - optimal @xmath56-achievable cost pairs are  on the boundary \" of the set of all @xmath56-achievable cost pairs .",
    "in fact , to characterize the set of @xmath56-achievable cost pairs , it is necessary and sufficient to characterize only the so - called pareto frontier :    the pareto frontier is the set of all pareto - optimal @xmath56-achievable cost pairs .    [",
    "th : finite_front ] the pareto frontier is a finite set .    note that @xmath90 s are non - negative integers . according to  , they are all less than or equal to @xmath56 .",
    "since the other variables , @xmath232 s and @xmath233 s , are all binary , the solution space is finite .",
    "hence , the pareto frontier is finite too .",
    "since the pareto frontier is finite , it is possible to list all of them in finite time , which can be done by algorithm  [ alg : paretofront ] .    1 .",
    "generate a solution which minimizes @xmath207 subject to the constraints - , - and - .",
    "exit if no solution is found .",
    "otherwise , let @xmath234 be the optimal value for @xmath207 .",
    "constrain @xmath207 to be equal to @xmath234 , and generate a solution which minimize @xmath206 subject to constraints - , - and - .",
    "let @xmath235 be the optimal value for @xmath206 .",
    "output @xmath209 .",
    "replace the constraint @xmath236 ( which was added in step  2 ) by the constraint @xmath231 .",
    "+ 4 .   go to step 1 .",
    "all the cost pairs in the pareto frontier can be listed by algorithm  [ alg : paretofront ] in finite time .    by theorem",
    "[ th : finite_front ] , there is a finite number of pareto - optimal @xmath56-achievable cost pairs .",
    "denote them by @xmath237 , where @xmath238 is the cardinality of the pareto frontier .",
    "furthermore , let them be ordered so that @xmath239 and @xmath240 for @xmath241 .",
    "we claim that the first point output by algorithm  [ alg : paretofront ] is @xmath242 . to see this , note that it first minimizes @xmath207 , without any constraint on @xmath206 .",
    "the result so obtained must be @xmath243 , for otherwise @xmath244 would not be the first point in the pareto frontier . then in step  2 , it minimizes @xmath206 , with the constraint @xmath245 .",
    "the result @xmath235 must be less than or equal to @xmath246 , since @xmath242 is @xmath56-acheivable .",
    "moreover , @xmath235 can not be strictly less than @xmath246 , for otherwise @xmath242 is not pareto - optimal . as a consequence , the first point @xmath242 is output .    by the same argument",
    ", we can see that all points output by algorithm  [ alg : paretofront ] must be pareto - optimal , and thus belong to the pareto frontier . assume the pair @xmath247 has just been output .",
    "algorithm  [ alg : paretofront ] first minimizes @xmath207 , with the constraint @xmath248 .",
    "the result so obtained must be @xmath249 , for otherwise , @xmath247 is not a pareto - optimal point",
    ". it must be equal to @xmath250 , for otherwise @xmath251 is not in the pareto frontier .",
    "next , algorithm  [ alg : paretofront ] minimizes @xmath206 , with the constraint @xmath252 .",
    "the result will then be @xmath253 .",
    "therefore , the next pareto - optimal pair @xmath251 is output .    as a result",
    ", all points in the pareto frontier will be output .",
    "the algorithm terminates when no more pareto - optimal points can be found .",
    "we remark that algorithm 2 can not be replaced by solving a family of weighted sum minimization problems ( with different weights ) , since not all pareto optimal cost pairs lie on the boundary of the convex hull of all achievable cost pairs .",
    "our repair cost minimization problem is a joint repair overlay , retrieval sets , and block assignment optimization problem . in theory , it can be solved by ilp . for large network size",
    ", however , ilp is too time consuming due to the fast - growing problem dimension . in this section",
    ", we present an efficient heuristic to solve the problem .",
    "our heuristic algorithm is divided into the following three steps :    1 .",
    "determine the repair overlay , @xmath6 , or equivalently , the overlay selection vector @xmath205 .",
    "2 .   determine the collection of retrieval sets , @xmath79 , or equivalently , the retrieval set selection vector , @xmath197 .",
    "3 .   determine the block assignment vector , @xmath94 .",
    "first , we determine the repair overlay @xmath254 by a greedy approach .",
    "we examine all @xmath255 possible hyperedges that could be put into @xmath256 .",
    "let them be @xmath171 .",
    "let @xmath257 be the subgraph of the metric closure @xmath73 induced by the vertices in @xmath172 .",
    "the cost of the minimum spanning tree of @xmath257 is called the _ mst weight _ of @xmath172 . at each step , we choose an hyperedge , not previously chosen , with the smallest mst weight while obeying the degree constraint .",
    "such an hyperedge is then added to @xmath256 .",
    "the procedure then repeats .",
    "we formally state our method as algorithm  [ alg : repairoverlay ] .    1 .",
    "compute the metric closure @xmath73 of @xmath258 .",
    "initialize @xmath6 with @xmath259 , and @xmath260 for all @xmath121 .",
    "( note that @xmath261 represents the degree of vertex @xmath124 in @xmath6 . )",
    "sort all the @xmath104-subsets of @xmath59 in ascending order of mst weight and get the sequence @xmath171 .",
    "4 .   * for * @xmath262 to @xmath255 * do * + @xmath263 for all @xmath264 * then * + @xmath265 + @xmath266 for all @xmath267 +   + * end * 5 .",
    "return @xmath112 .",
    "+    let @xmath268 be the number of edges in the underlying storage network @xmath58 .",
    "the complexity of algorithm  [ alg : repairoverlay ] is @xmath269 , since computing the metric closure @xmath73 of @xmath74 by johnson s algorithm has the complexity of @xmath270 , finding the mst weight of the @xmath255 hyperedges has the complexity of @xmath271 , the sorting in the second step has complexity of @xmath272 and the third step has complexity of @xmath273 . since @xmath274 , the complexity of algorithm  [ alg : repairoverlay ] can be simplified as @xmath275 .",
    "next , we need to find @xmath79 , given a fixed repair overlay @xmath6 obtained in the previous step .",
    "according to the structure of the mds - ifr code , we know that the coded blocks associated with two different hyperedges are distinct .",
    "for this reason , we require the @xmath1 storage nodes in a retrieval set jointly hit as many hyperedges of @xmath6 as possible .",
    "in other words , we require @xmath79 be the collection of the first @xmath77 @xmath1-subsets of @xmath59 that hit the maximum number of hyperedges of @xmath6 . to find it , we use a recursive approach , which is formally stated as algorithm  [ alg : retrievalsets ] . note that in step  4 of algorithm  [ alg : retrievalsets ] , we use @xmath276 , where @xmath148 is a",
    "vertex and @xmath79 is a collection of vertex sets , to denote the operation of adding @xmath148 to each set in @xmath79 .",
    "for example , @xmath277 .",
    "we remark that algorithm  [ alg : retrievalsets ] is for the case where @xmath278 .",
    "if there are @xmath279 pre - determined retrieval sets , algorithm  [ alg : retrievalsets ] can be applied with a very minor modification . before a @xmath1-subset of @xmath59",
    "is added to the collection of retrieval sets @xmath79 , the algorithm first check whether that @xmath1-subset happens to be one of the pre - determined retrieval sets .",
    "it would be added if and only if it is not one of them .",
    "the procedure repeats until @xmath280 retrieval sets have been added to @xmath79 .    1 .",
    "* if * @xmath281 * do * + return @xmath79 + * end * 2 .",
    "find @xmath282 that hits the maximum number of hyperedges in @xmath173 .",
    "let @xmath283 be the hypergraph obtained from @xmath284 by removing @xmath148 from @xmath59 and all hyperedges containing @xmath148 from @xmath173 .",
    "@xmath285 + 5 .",
    "* if * @xmath286 * do * + @xmath287 + * end * 6 .",
    "return @xmath79    the complexity of step 2 in algorithm  [ alg : retrievalsets ] is @xmath288 , which is the same as @xmath289 , since @xmath290 .",
    "step 2 would be implemented @xmath1 times to find a retrieval set containing @xmath1 vertices , and algorithm  [ alg : retrievalsets ] needs to find @xmath77 retrieval sets .",
    "thus , the complexity of algorithm  [ alg : retrievalsets ] is @xmath291 .",
    "last , we need to find @xmath94 , given a fixed repair overlay @xmath6 and a fixed collection of retrieval sets @xmath79 .",
    "this can be done by solving the ilp problem while fixing @xmath205 and @xmath197 to the values corresponding to @xmath6 and @xmath79 , respectively .",
    "alternatively , we can solve the lp problem by relaxing the integer constraint on @xmath166 if we want to minimize the asymptotically achievable cost .",
    "for our ilp formulation of the repair cost minimization problem , the number of variables is @xmath292 and the number of constraints is @xmath293 .",
    "if the repair overlay and the collection of retrieval sets are fixed , the number of variables can be reduced to @xmath294 while the number of constraints can be reduced to @xmath295 . since @xmath296 and @xmath297",
    ", the number of variables and constraints of the ilp problem can be reduced from @xmath298 and @xmath273 , both to @xmath299 .",
    "to conclude , the heuristic method consists of three steps .",
    "the first two steps have complexities @xmath275 and @xmath300 , respectively . for practical scenarios ,",
    "@xmath76 is a small constant , typically equal to 1 or 2 . in theory ,",
    "linear programming can be solved in polynomial time .",
    "therefore , regarding @xmath76 as a constant , the overall computational complexity of the heuristic method is polynomial in  @xmath2 .",
    "* example * : consider a 5-node ring , @xmath74 , shown in fig .",
    "[ fi : heurexample]@xmath127 .",
    "the number associated with an edge denotes the single - hop cost between its two endpoints .",
    "[ fi : heurexample]@xmath128 shows @xmath73 , the metric closure of @xmath74 , where the number associated with an edge is the corresponding communication cost .",
    "suppose the storage network is able to tolerate double failures , i.e. , @xmath80 , and the degree constraint is @xmath115 .",
    "we need to consider all hyperedges whose cardinality is equal to @xmath301 , i.e. , @xmath302 .",
    "their mst weights are 5 , 5 , 6 , 6 , 7 , 7 , 8 , 9 , 9 , 10 , respectively . according to algorithm  [ alg : repairoverlay ] ,",
    "the hyperedges @xmath303 and @xmath304 are successively added into @xmath173 .",
    "the resulting repair overlay @xmath6 is shown in fig .",
    "[ fi : heurexample]@xmath129 . furthermore , suppose that @xmath305 and @xmath306 . according to algorithm  [ alg : retrievalsets ] , we can obtain a collection of retrieval sets @xmath307 .",
    "in this section , we consider heterogeneous storage systems . we compare the optimal tradeoff between system storage cost and system repair cost that can be achieved by the mds - ifr code with that achieved by the regenerating code .",
    "moreover , we compare the minimum system repair cost that can be achieved by the mds - ifr code with that achieved by the regenerating code for different network size . here",
    ", we use the term `` regenerating code '' to refer to any code that achieve points on the tradeoff curve under the regular model .    in our simulations ,",
    "both the storage cost vector @xmath308 $ ] and the single - hop cost matrix @xmath67 $ ] are randomly generated .",
    "for the storage system whose size is less than or equal to @xmath309 , each entry in @xmath310 and @xmath69 is an integer selected from the uniform distribution on the interval @xmath311 $ ] . for the storage system",
    "whose size is larger than @xmath309 , each entry in @xmath310 and @xmath69 is an integer selected from the uniform distribution on the interval @xmath312 $ ] .",
    "we assume that the probabilities of occurrence of all repairable failure patterns are the same .",
    "consider a distributed storage system with parameters : @xmath313 , @xmath80 , @xmath115 , @xmath305 .",
    "for the mds - ifr code , all pareto - optimal @xmath56-achievable cost pairs @xmath314 can be obtained by running algorithm  [ alg : paretofront ] and solving the corresponding ilp problems .",
    "the curve connecting all pareto - optimal @xmath56-achievable cost pairs is the optimal tradeoff between system storage cost and system repair cost that can be achieved by the mds - ifr code , as shown in fig .",
    "[ fi : pareto ] .",
    "for the regenerating code , there exists a fundamental tradeoff between the storage amount per node , @xmath315 , and the amount of data downloaded from each surviving node when repairing a failed node , @xmath316 .",
    "based on the tradeoff between @xmath315 and @xmath316 , if each newcomer downloads data along the @xmath0 paths with the least communication costs , the optimal tradeoff between system storage cost and system repair cost can be obtained . from fig .",
    "[ fi : pareto ] , it can be seen that , compared with the regenerating code , under the same data retrieval requirement , i.e. , @xmath317 , the system repair cost that achieved by the mds - ifr code can be reduced if the system storage cost are increased .",
    "if the data retrieval requirement are properly relaxed , i.e. , @xmath318 , both the system repair cost and system storage cost achieved by the mds - ifr code can be reduced .    for the heuristic of minimizing repair cost in the irregular model by using the mds - ifr code , to illustrate the integrality gap , we consider a distributed storage system with parameters : @xmath319 , @xmath320 , and @xmath321 .",
    "we increase the data object size @xmath56 from @xmath322 to @xmath323 , with step size @xmath322 . for each value of @xmath56",
    ", we increase the maximum system storage cost per unit data object , @xmath183 , from @xmath324 to @xmath325 and solve the corresponding ilp .",
    "the tradeoff curves between system storage cost , @xmath206 , and system repair cost , @xmath207 , are plotted in fig .",
    "[ fi : ipvslp ] .",
    "we can observe that the gap between the solution of the ilp and of its relaxation is tiny and decreases with the growing of the data object size @xmath56 .",
    "thus , to improve the efficiency of simulation , we solve the lp problem by relaxing the integer constraints on @xmath166 to minimize the asymptotically achievable repair cost in our simulation .",
    "we next compare the minimum system repair cost of the mds - ifr code with that of the regenerating code for different network size .",
    "the maximum allowable system storage cost per unit data object @xmath183 is set to a sufficiently large value , @xmath326 .",
    "the simulation for each value of @xmath2 is averaged over @xmath325 runs . for small storage networks , from fig .",
    "[ fi : cr_vs_n ] , it can be seen that if the number of retrieval sets is equal to @xmath327 , the minimum system repair cost that can be achieved by the mds - ifr code is roughly reduced at least by @xmath328 . moreover , the asymptotically achievable minimum system repair cost found by our heuristic is near - optimal .",
    "the gap between heuristic solution and optimal solution is at most @xmath329 .",
    "if the data retrieval requirement is relaxed , for example the number of retrieval sets is reduced to @xmath330 , the asymptotically achievable minimum system repair cost achieved by the mds - ifr code can be reduced at least by @xmath331 . since the constraints of data repair and data retrieval are relaxed in the irregular model , it is not surprising that there exists a performance gain .",
    "nevertheless , it demonstrates that there is a large room for improvement if the regular model is refined .",
    "this is particularly relevant when the networking environment is heterogeneous .",
    "to gain more understanding about the computational efficiency of our heuristic , we increase the network size and measure its running time .",
    "the machine employed for simulation is a dell computer with an intel(r ) core(tm)2 quad cpu running at 3 ghz with 4 gb ram .",
    "the operating system is windows 7 , and the computer is a 32-bit machine .",
    "the simulation programs were written in matlab .",
    "our method requires solving lp and ilp problems .",
    "these tasks were done by a free linear integer programming solver called `` lpsolve '' , which was called from our matlab program . in our simulation ,",
    "the system parameters are set as follows : @xmath332 and @xmath333 .",
    "the simulation for each value of @xmath2 is averaged over @xmath325 runs . the minimum system repair cost obtained by using our heuristic for different network size",
    "is shown in fig .",
    "[ fi : cr_vs_n_large ] .",
    "the average running time of the three steps of our heuristic for a given problem instance is also recorded in fig .",
    "[ fi : time ] . from fig .",
    "[ fi : time ] , it can be seen that the most time consuming step of our heuristic is solving the lp problem after determining the repair overlay and retrieval sets . moreover ,",
    "the total time consumed by our heuristic is less than @xmath139 minutes when the network size is less than @xmath334 .    )",
    ".,width=340,height=264 ]    ) .,width=340,height=264 ]    ) .,width=340,height=226 ]    ) .,width=340,height=264 ]    ) .,width=340,height=264 ]",
    "due to the emergence of heterogeneous cloud storage systems , we generalize the concept of the fr code and propose the ifr code .",
    "a key property of the fr code is its uncoded repair process .",
    "this simple repair mechanism minimizes the repair bandwidth and the disk access bandwidth simultaneously , without any computational cost .",
    "the ifr code preserves this nice property .",
    "moreover , its irregular structure allows the repair pattern and the storage amount of each node to be different , thus enabling the cloud system to be optimized according to network heterogeneity including different storage costs of the storage nodes and different communication costs of the links . to determine the repair pattern , which we call the repair overlay , and the storage allocation , we formulate the whole problem based on a new irregular model , with the aim of minimizing the system repair cost by properly designing the mds - ifr code and the retrieval sets . for large networks ,",
    "we decompose the repair cost minimization problem into three subproblems : repair overlay selection , retrieval sets selection , and block assignment , and propose a heuristic solution . for small network sizes ,",
    "it is shown to be nearly optimal by comparing it with the optimal ilp method .    while the optimization framework established in this paper concerns mainly on system repair cost , it can be modified to include other system objectives and extended by incorporating more resource constraints .",
    "on the other hand , as it is based on the mds - ifr code , it provides very low repair cost at the expense of higher storage overhead .",
    "if higher storage efficiency is needed in some applications , other codes will be needed ( using at the expense of higher repair cost or computing cost ) .",
    "this problem is beyond the scope of this paper .",
    "nevertheless , we have demonstrated how optimization techniques can be used to construct good codes , providing insights and new methodology on how to design future heterogeneous cloud storage systems .",
    "the authors would like to thank the anonymous reviewers for their constructive comments and suggestions to improve the quality of the paper .",
    "a.  g. dimakis , p.  b. godfrey , y.  wu , m.  j. wainwright , and k.  ramchandran , `` network coding for distributed storage systems , '' in _ proc .",
    "conf . on computer commun .",
    "( infocom ) _ , anchorage , alaska , may 2007 , pp . 20002008 .",
    "k.  v. rashmi , n.  b. shah , and p.  v. kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee trans .",
    "inf . theory _",
    "57 , no .  8 , pp .",
    "52275239 , aug .",
    "2011 .",
    "n.  b. shah , k.  v. rashmi , p.  v. kumar , and k.  ramchandran , `` explicit codes minimizing repair bandwidth for distributed storage , '' in _ ieee information theory workshop ( itw ) _ , cairo , jan .",
    "2010 , pp . 15 .",
    "s.  el rouayheb and k.  ramchandran , `` fractional repetition codes for repair in distributed storage systems , '' in _ proc .",
    "48th annual allerton conference on commun . control and computing _ , monticello , il , sep .",
    "2010 , pp . 15101517 .",
    "j.  c. koo and j.  t. gill , `` scalable constructions of fractional repetition codes in distributed storage systems , '' in _ proc .",
    "49th annual allerton conference on commun . control and computing _ , monticello , il , sep .",
    "2011 , pp . 13661373 .",
    "s.  pawar , n.  noorshams , s.  el rouayheb , and k.  ramchandran , `` dress codes for the storage cloud : simple randomized constructions , '' in _ proc .",
    "theory ( isit ) _ , saint petersburg , 2011 , pp .",
    "23382342 .",
    "o.  olmez and a.  ramamoorthy , `` repairable replication - based storage systems using resolvable designs , '' in _ proc .",
    "50th annual allerton conference on commun . control and computing _ , monticello , il , oct .",
    "2012 , pp . 11741181 .",
    "j.  kubiatowicz , d.  bindel , y.  chen , s.  czerwinski , p.  eaton , d.  geels , r.  gummadi , s.  rhea , h.  weatherspoon , w.  weimer , c.  wells , and b.  zhao , `` oceanstore : an architecture for global - scale persistent storage , '' in _ proc .",
    "9th int . conf . on architectural support for programming languages and operating systems ( asplos )",
    "_ , cambridge , ma , nov . 2000 ,",
    "190201 .",
    "s.  pawar , s.  e. rouayheb , h.  zhang , k.  lee , and k.  ramchandran , `` codes for a distributed caching based video - on - demand system , '' in _ proc .",
    "asilomar conference on signals , systems , and computers _ , pacific grove , ca ,",
    "2011 , pp .",
    "17831787 .",
    "n.  golrezaei , a.  g. dimakis , and a.  f. molisch , `` wireless device - to - device communications with distributed caching , '' in _ proc .",
    "inf . theory ( isit ) _ , cambridge , ma , jul .",
    "2012 , pp . 27812785 .        q.  yu , k.  w. shum , and c.  w. sung , `` minimization of storage cost in distributed storage systems with repair consideration , '' in _ proc .",
    "ieee telecommunications conference ( globecom ) _ , houston , texas , dec .",
    "2011 , pp . 15 .",
    "j.  li , s.  yang , x.  wang , and b.  li , `` tree - structured data regeneration in distributed storage systems with regenerating codes , '' in _ proc .",
    "conf . on computer commun .",
    "( infocom ) _ , san diego , mar .",
    "2010 , pp . 19 .",
    "t.  ernvall , s.  e. rouayheb , c.  hollanti , and h.  v. poor , `` capacity and security of heterogeneous distributed storage systems , '' in _ proc .",
    "inf . theory ( isit ) _ , istanbul , jul .",
    "2013 , pp . 12471251 ."
  ],
  "abstract_text": [
    "<S> this paper presents a flexible irregular model for heterogeneous cloud storage systems and investigates how the cost of repairing failed nodes can be minimized . </S>",
    "<S> the fractional repetition code , originally designed for minimizing repair bandwidth for homogeneous storage systems , is generalized to the irregular fractional repetition code , which is adaptable to heterogeneous environments . </S>",
    "<S> the code structure and the associated storage allocation can be obtained by solving an integer linear programming problem . for moderate sized networks , </S>",
    "<S> a heuristic algorithm is proposed and shown to be near - optimal by computer simulations .    </S>",
    "<S> cloud storage , distributed storage systems , irregular fractional repetition code , regenerating code </S>"
  ]
}