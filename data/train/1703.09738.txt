{
  "article_text": [
    "computer algebra systems are essential tools for theoretical physics for some decades .",
    "they are mainly important in general relativity ( gr ) where lengthy tensorial and differential geometry calculations are inevitable .",
    "many of these programs have special internal or external packages for tensor manipulation and differential geometry calculations . for comprehensive reviews , see @xcite .",
    "the review of early works can be found in @xcite .",
    "these packages can also be extended for more specialized calculations @xcite .",
    "even though commercial programs dominate the area , codes written on commercial programs can not be distributed easily since those programs may not be available for scientists with lack of resources for purchasing such software .",
    "besides , many of the manipulations treated in calculations do not need a sophisticated computation engine .",
    "open source computer algebra systems such as sagemath ( also known as  sage \" ) @xcite and maxima @xcite provide a complete toolkit for general relativity and quantum field theory applications with their particular packages .",
    "some freely available programming languages such as python @xcite also offer special tools for abovementioned manipulations .",
    "we choose to study general systems rather than specialized tensor manipulation or general relativity packages ( e.g. cadabra @xcite , redberry @xcite , etc . ) .",
    "the reason for this choice is that tensor manipulation is generally an auxiliary step in gr calculations . a general program which can deal with symbolic and numerical analysis of the results constitute a complete calculation toolkit . in most cases , computer algebra systems ( or programming languages )",
    "are supported with particular packages for tensor manipulation .",
    "we also exclude specialized tools like gyoto @xcite in our analysis .    in this work",
    ", we will employ sagemath ( with sagemanifolds package @xcite ) , maxima ( with ctensor package @xcite ) , and python language ( with sympy and gravipy modules @xcite ) for some essential calculations in general relativity and present benchmark results for these systems .",
    "the ever - developing open source sagemath program has gathered many utilities such as maxima , gap , r , and the power of python language with well - known python modules like numpy , sympy and matplotlib .",
    "sagemath can be installed on personal computers and moreover it has a powerful cloud computing server on which the user can work on projects anywhere and share them with other users easily @xcite .",
    "the recent package sagemanifolds for tensor and differential geometry calculations is also installed on the cloud server .",
    "these properties make the sage+sagemanifolds system the best open source choice for general relativity and quantum field theory .",
    "analysis of the klein ",
    "gordon equation , mainly its radial part is the first step in most quantum gravity problems involving black holes @xcite .",
    "we will study its solution using sagemath .",
    "computationally , it is easier to define and solve the first order differential equations rather than the second order equations .",
    "jacobi formalism yields first order differential equations for the geodesic motion @xcite .",
    "we will use this formalism to derive the equations and solve them as a numerical initial value problem with sagemath routines .",
    "numerical results need to be presented in a graphical way to see their structure efficiently .",
    "sagemath system is equipped with comprehensive visualization tools and we will use these tools to present our results .    in the next section ,",
    "we define the spacetimes to be used . in the third section",
    "we review three computation systems and give simple examples .",
    "we also give a benchmark of these systems as a subsection .",
    "in the fourth section we focus on the sagemath+sagemanifolds system to analyze the massless klein ",
    "gordon equation and geodesic motion .",
    "we will be working for schwarzschild and kerr spacetimes . in general , a line element is defined by @xmath0 if one takes @xmath1 ( where @xmath2 is newton s gravitational constant in four dimensions and @xmath3 is the speed of light in vacuum ) , the schwarzschild metric can be written as @xcite @xmath4 .",
    "\\label{schwmetric}\\ ] ] we will take the order of coordinates as @xmath5 and @xmath6 is the mass of the black hole . the coefficient of the radial part is singular at @xmath7 which describes the  event horizon \" .",
    "the kerr black hole has the metric @xcite @xmath8 \\end{array}\\right ] .",
    "\\label{kerrmetric}\\ ] ] here , @xmath6 is the mass and @xmath9 where @xmath10 is the angular momentum .",
    "two functions are defined as @xmath11 the roots of @xmath12 correspond to the locations of the cauchy horizon ( the smaller root ) and the event horizon ( the larger root ) of the black hole .",
    "we will only focus on the procedures of    * defining a spacetime * calculating christoffel symbols ( @xmath13 ) * calculating ricci tensor ( @xmath14 ) * calculating einstein tensor ( @xmath15 ) * displaying components    in our examples .",
    "the examples will be studied using three computation systems , namely    * sagemath+sagemanifolds * maxima+ctensor * python+gravipy    the codes are enhanced with comment lines which can be helpful for analyzing the procedures step by step .",
    "details on the procedures and further examples can be found in related references .",
    "sagemath is an open source computer algebra system which collects many powerful open source packages and modules with a python - like language @xcite .",
    "sagemanifolds was first started as an independent tensor analysis and differential geometry package to be installed on sagemath @xcite .",
    "now , sagemanifolds is an internal package for sagemath and does not require an additional installation .",
    "we start our program by reseting the sagemath environment .",
    "then we define the four - dimensional manifold , the black hole mass and the coordinates .",
    "the coordinates are defined along with their ranges .",
    "we define the lorentzian metric by giving its components as a matrix . finally , we calculate and display christoffel symbols , ricci tensor and einstein tensor elements .    ....",
    "reset ( ) ; # define 4-dim . the manifold \" man \" : man = manifold(4 , '",
    "man ' , r'\\mathcal{m } ' ) ;    # define the parameter \" m \" ( mass ) : m = var('m ' ) ;    # define the coordinates { t=0 , r=1 , theta(=th)=2 , phi=3 } with ranges # ( bl = boyer - lidquist ) bl.<t , r , th , ph > = man.chart(r't r:(0,+oo ) th:(0,pi):\\theta ph:(0,2*pi):\\phi ' ) ;    # define the metric \" g \" on manifold \" man \" : g = man.lorentzian_metric('g ' ) ;    # enter the schwarzschild metric components : g[0,0 ] = ( 1-(2*m)/r ) ; ( * @\\label{schwstart}@ * )   g[1,1 ] = -1/(1-(2*m)/r ) ; g[2,2 ] = -r^2 ; g[3,3 ] = -(r*sin(th))^2 ; ( * @\\label{schwstop}@ * )    # display the metric show('the schwarzschild metric : ' ) ; show(g.display ( ) ) ; # # # # # # # # # # # # # # # # # # # # # # christoffel symbols nab = g.connection ( ) # display all components show(nab.display ( ) ) # display a single component show(nab[1,1,1 ] ) # # # # # # # # # # # # # # # # # # # # # # ricci tensor ric = g.ricci ( ) ; # display all components show(ric.display ( ) ) # display a single component show(ric[1,1 ] ) # # # # # # # # # # # # # # # # # # # # # # einstein tensor et = g.ricci()-(1/2)*g*g.ricci_scalar ( ) # display all components et.set_name('e ' ) show(et.display ( ) ) # display a single component show(et[1,2 ] ) ....    the lines between [ schwstart]-[schwstop ] defines the schwarzschild metric . in order to define the kerr metric",
    ", we need to change this part with    .... a = var('a ' ) ; rhosq = r^2+(a^2)*cos(th)^2 ; delta = r^2 - 2*m*r+a^2 ;    g[0,0 ] = ( 1-(2*m*r)/rhosq ) ; g[1,1 ] = -rhosq / delta ; g[2,2 ] = -rhosq ; g[3,3 ] = -(sin(th)^2)*((r^2+a^2)+(2*(a^2)*m*r*sin(th)^2)/rhosq ) ; g[0,3 ] = ( 2*a*m*r*sin(th)^2)/rhosq ; ....    it should be noted that , we defined the functions @xmath16 and @xmath17 , and the rotation parameter @xmath18 .",
    "the kerr black hole has non - diagonal , symmetric components unlike the schwarzschild metric which is diagonal .",
    "maxima computer algebra system is the new and freely available version of macsyma @xcite .",
    "macsyma is known as the first general , multipurpose computer algebra system which inspired many other systems for years . v. toth reviews tensor packages in maxima in his article @xcite .",
    "here , we will use the ctensor package which provides component tensor manipulation .",
    "we first kill all environmental variables , then load the ctensor package .",
    "we set ratwtlvl : false for no truncation and ratfac : true to factorize the tensor components automatically .",
    "we then define the dimension of the spacetime and the coordinates .",
    "we enter the metric as a matrix . before the calculation of christoffel symbols , ricci tensor and einstein tensor elements",
    ", we find the inverse tensor with invert .    ....",
    "kill(all ) ; if get('ctensor,'version)=false then load(ctensor ) ; ( ratwtlvl : false , ratfac : true ) ; ( \" specify the dimension of the manifold and the coordinate labels.\")$ ( dim:4,ct_coords:[t , r , theta , phi ] ) ; ( \" enter the metric.\")$ ( * @\\label{schwmax1}@ * ) lg : matrix([(1 - 2*m / r),0,0,0],[0,-1/(1 - 2*m / r),0,0],[0,0,-r^2,0],[0,0,0,-(r^2)*sin(theta)^2 ] ) ; ( * @\\label{schwmax2}@ * ) ug : invert(lg)$ ( \" compute the christoffel symbols and display all components\")$ christof(mcs)$ ( \" compute the ricci tensor and display all components\")$ uricci(true ) ( \" compute the einstein tensor and display all components\")$ einstein(true ) ; ( \" display single components\")$ mcs[1,1,2 ] ; ric[1,2 ] ; ein[2,2 ] ; ....    the lines [ schwmax1]-[schwmax2 ] should be changed as    .... rhosq : r^2+(a^2)*cos(theta)^2 $ delta : r^2 - 2*m*r+a^2 $ ( \" enter the general static spherically symmetric metric.\")$ lg : matrix([(1-(2*m*r)/rhosq),0,0,(2*a*m*r*sin(theta)^2)/rhosq],[0,-rhosq / delta,0,0],[0,0,-rhosq,0],[(2*a*m*r*sin(theta)^2)/rhosq,0,0,-(sin(theta)^2)*((r^2+a^2)+(2*(a^2)*m*r*sin(theta)^2)/rhosq ) ] ) ; ....    for the kerr metric .",
    "python is a multipurpose , object - oriented programming language @xcite which can easily be expanded with modules .",
    "the module gravipy provides tensor calculation methods and it works on a freely available symbolic analysis module sympy @xcite .",
    "we start our program by importing the gravipy module .",
    "then we define the four  vector of coordinates and the black hole mass .",
    "we define the metric as a diagonal matrix .",
    "we then calculate and display christoffel symbols , ricci tensor and einstein tensor elements .    .... from gravipy import * # # # # # # # # # # # # # # # # # # # # # ( * @\\label{schwpy1}@ * ) # coordinates ( \\chi is the four - vector of coordinates ) t , r , theta , phi , m = symbols('t , r , theta , phi , m ' )   x = coordinates('\\chi ' , [ t , r , theta , phi ] ) # # # # # # # # # # # # # # # # # # # # # # metric tensor metric = diag((1 - 2*m / r ) , -1/(1 - 2*m /",
    "r ) , -r**2 , -r**2*sin(theta)**2 ) ( * @\\label{schwpy2}@ * ) g = metrictensor('g ' , x , metric ) # # # # # # # # # # # # # # # # # # # # # # christoffel symbols ga = christoffel('ga ' , g ) # display all components print(ga(all , all , all ) ) # display a single component print(ga(1,2,1 ) ) # # # # # # # # # # # # # # # # # # # # # # ricci tensor ri = ricci('ri ' , g ) # display all components print(ri(all , all ) ) # display a single component print(ri(1 , 2 ) ) # # # # # # # # # # # # # # # # # # # # # # einstein tensor g = einstein('g ' , ri ) # display all components print(g(all , all ) ) # display a single component print(g(3 , 3 ) ) # # # # # # # # # # # # # # # # # # # # # ....    the lines [ schwpy1]-[schwpy2 ] should be modified as    .... # # # # # # # # # # # # # # # # # # # # # # coordinates ( \\chi is the four - vector of coordinates ) t , r , theta , phi , m , a , rhosq , delta = symbols('t , r , theta , phi , m , a , rhosq , delta ' )   x = coordinates('\\chi ' , [ t , r , theta , phi ] ) # # # # # # # # # # # # # # # # # # # # # # metric tensor rhosq = r**2+(a**2)*cos(theta)**2 delta = r**2 - 2*m*r+a**2 metric = matrix([[(1-(2*m*r)/rhosq),0,0,(2*a*m*r*sin(theta)**2)/rhosq],[0,-rhosq / delta,0,0],[0,0,-rhosq,0],[(2*a*m*r*sin(theta)**2)/rhosq,0,0,-(sin(theta)**2)*((r**2+a**2)+(2*(a**2)*m*r*sin(theta)**2)/rhosq ) ] ] ) ....    in order to define the kerr metric . the diagonal matrix definition of the schwarzschild case is changed with a general metric .",
    "we performed some calculations for the schwarzschild and kerr spacetimes on python+gravipy ( python 2.7.12 ) , sagemath+sagemanifolds ( sagemath 7.5.1 ) and maxima+ctensor ( maxima 5.37.2 ) systems .",
    "the schwarzschild metric has only diagonal elements , while kerr solution has non  diagonal elements in its metric .",
    "we aimed to measure the effect of this difference in the computations .",
    "we used the metric given in equation [ schwmetric ] for the schwarzschild case and for the kerr metric the metric is given in equation [ kerrmetric ] .",
    "the sagemath+sagemanifolds system allows parallel computing on cpu by adding the line parallelism().set(nproc=4 ) for 4cores .",
    "we also measured the effect of this option in calculations .    for our analysis",
    ", we used the code ",
    "block profiling method and measured the wall ",
    "clock time as it has more importance for the general user .",
    "we calculated the christoffel symbols , ricci tensor and einstein tensor one by one on each system .",
    "metric definition and displaying the results are not included in the time measurement . by averaging the timing results for 10 runs on each system , the table [ bench ]",
    "is generated .    in python",
    ", we used the datetime module .",
    "this method shows the time value up to six decimals .    .... from gravipy import * from datetime",
    "import datetime ...",
    "riccitime_=datetime.now ( ) ri = ricci('ri',g ) _ riccitime = datetime.now ( ) print \" elapsed time ... \" , _ riccitime - riccitime _ ... ....    in sagemath , we employed the inline time command .",
    "this command shows time with two decimals .    ....",
    "time ric = g.ricci ( ) ... ....    in maxima , we used elapsed_real_time ( ) command which also shows time with two decimals .    .... ... t0:elapsed_real_time()$",
    "uricci(false ) ; t1:elapsed_real_time()-t0 ; ... ....    the test computer has an intel i7 4500u cpu ( 4096 kb cache for each 4 cores ) , 8 gb ( ddr3 ) ram , nvidia geforce 840 m gpu and 1 tb hdd with 8 gb swap .",
    ".benchmark results .",
    "( all numbers are in seconds ) .",
    "[ cols=\"<,<,<,<,<\",options=\"header \" , ]     as seen from the table [ bench ] , some calculations for the schwarzschild metric seem unsuitable for parallelization due to chunk sizes of the cpu cores .",
    "however , using multiple cores for kerr calculations makes a significant effect on calculation time .    according to these results , python and maxima would be the best choices for tensor manipulation",
    "however , sagemath being powered by sagemanifolds , provides an easy - to - use and combined toolkit for the general user .",
    "we will focus on the sagemath+sagemanifolds system to perform a set of calculations for the schwarzschild metric .",
    "we will first define the spacetime by giving its variables and components .",
    "then we will perform calculations for two examples . in the first one , we calculate the klein ",
    "gordon equation for a massless scalar field , extract its radial part and solve this differential equation numerically .",
    "we will further compare our numerical result graphically with the asymptotic form of the analytical result . in the next example",
    ", we will perform a very simple geodesic analysis for this spacetime using the hamilton ",
    "jacobi formalism .",
    "generalization of the example codes to other metrics is straightforward .",
    "the codes for the calculation of klein  gordon and hamilton ",
    "jacobi equations can be used for general metrics without modification .",
    "for the detailed calculations , we applied some metric - related information in the code to see the manipulation , equation solving and plotting capabilities of the computation system .    the reader should follow the line numbers to execute the codes without problem .",
    "the code for the definition of the spacetime is between lines ( [ ex1]-[ex2 ] ) . the analysis of the klein ",
    "gordon equation starts in line [ ex3 ] and ends in line [ ex4 ] .",
    "then in the next section , the study of geodesics starts again with line [ ex5 ] and ends in line [ ex6 ] .",
    "this means that , the reader should first execute the lines ( [ ex1]-[ex2 ] ) for the metric definition before each physical example .",
    "this part was studied before in section 3.1 , while giving examples for simple calculations in gr .",
    "nevertheless , we will place it here in order to present a complete code structure .    .... reset ( ) ; ( * @\\label{ex1}@ * )    # define 4-dim . the manifold \" man \" : man = manifold(4 , ' man ' , r'\\mathcal{m } ' ) ;    # define the parameter \" m \" ( mass ) : m = var('m ' ) ;    # define the coordinates { t=0 , r=1 , theta(=th)=2 , phi=3 } with ranges # ( bl = boyer - lidquist ) bl.<t , r , th , ph > = man.chart(r't r:(0,+oo ) th:(0,pi):\\theta ph:(0,2*pi):\\phi ' ) ;    # define the metric \" g \" on manifold \" man \" : g = man.lorentzian_metric('g ' ) ;    # enter the schwarzschild metric components : g[0,0 ] = ( 1-(2*m)/r ) ; g[1,1 ] = -1/(1-(2*m)/r ) ; g[2,2 ] = -r^2 ; g[3,3 ] = -(r*sin(th))^2 ;    # display the metric show('the schwarzschild metric : ' ) ; show(g.display ( ) ) ; ( * @\\label{ex2}@ * ) ....    in the schwarzschild case , the manifold has four dimensions and the only variable is the black hole mass @xmath6 .",
    "we define four spacetime coordinates and enter the components of the diagonal metric .",
    "these definitions may need some modifications for other spacetimes .",
    "klein  gordon equation for a massless scalar field can be written as @xcite @xmath19 where @xmath20 is the scalar field and it can be decomposed with the ansatz @xmath21 for the schwarzschild metric .",
    "we will first define the variables @xmath22 , @xmath23 and the result kg .",
    "the inverse metric and @xmath24 are needed in calculation , thus are calculated .",
    "then the full scalar function @xmath20 , radial and angular parts of the solution ansatz are defined . after giving the ansatz , we start calculating the klein - gordon equation in two for loops .",
    "the outer loop is over @xmath25 components and the inner one is over @xmath26 components .",
    ".... # defining variables : ( * @\\label{ex3}@ * ) var('omega , k , kg ' ) ;    # inverse metric : ginv = g.inverse ( ) ;    # the square root of the absolute value   # of the metric determinant : sqrtabsdetg = g.sqrt_abs_det().expr ( ) ;    # the scalar function phi(t , r , th , phi ) : # the dependence on all coordinates   # is provided by \" ( * bl ) \"   phi = function('phi')(*bl )    # the scalar field ansatz is given here .",
    "# r : radial part , # s : angular part r = function('r')(r ) ; s = function('s')(th ) ; phi = exp(-i*omega*t)*exp(i*k*ph)*r*s ;    # calculating the klein - gordon equation : kg=0 ; for mu in range(len(bl [ : ] ) ) :      for nu in range(len(bl [ : ] ) ) :          kg = kg+diff((ginv[mu , nu].expr()*sqrtabsdetg*diff(phi , bl[nu])),bl[mu ] ) ;    # displaying the klein - gordon equation \" kg \" show('the full klein - gordon equation ( variable name is kg ) : ' ) show(kg ) ....    this part of the code is general .",
    "the reader should only change the solution ansatz accordingly and the code can find the klein - gordon equation for any spacetime with any number of dimensions . the result is stored in variable kg .    in our example ,",
    "the klein ",
    "gordon equation is found as @xmath27 we can find the radial and angular parts of the klein - gordon equation after analyzing its structure .",
    "this part is semi - automatic and the user should supply some information .",
    "we first divide the equation by the common factors and extract its operands in a vector .",
    "then we define the separation constant @xmath28 . using a loop over all operands ,",
    "we decide which one belongs to the radial part and which one belongs to the angular part of the equation .",
    "we take the radial derivative of the components and if the result is zero , the component is angular , if it is not zero , we add it to the radial part .",
    "we use collection and simplification commands to see the results in a good shape .",
    ".... # we can analyze the klein - gordon equation # to see how it is separated into # radial and angular parts .",
    "# common factors will be divided # this part should be given by the user dividekgby = exp(-i*omega*t)*exp(i*k*ph)*sin(th)*r*s ; finalkg = expand(kg / dividekgby ) ;    # extract the operands in the expression : fkgops = finalkg.operands ( )    # find radial and angular parts : # lambda_aux is the separation constant var('lambda_aux ' ) ; kgradialpart = lambda_aux ; kgangularpart =- lambda_aux ; for term in fkgops :      if diff(term , r)==0 :           kgangularpart = kgangularpart+term ;      else :           kgradialpart = kgradialpart+term ;    kgradialpart = expand(kgradialpart*r).simplify_full().collect(r).collect(diff(r , r)).collect(diff(r , r , r ) ) ; kgangularpart = expand(kgangularpart*s).simplify_full().collect(s).collect(diff(s , th)).collect(diff(s , th , th ) ) ;    show('the radial part ( variable name is kgradialpart ) : ' ) show(kgradialpart ) ; show('the angular part ( variable name is kgangularpart ) : ' ) show(kgangularpart ) ; ....    the radial part is then found as @xmath29 and the angular part is @xmath30 further simplifications are obvious but sagemath s ` desolve ` command can not give symbolic solutions for these equations .",
    "however , numerical solutions can be studied using related methods .",
    "we will use ` desolve_system_rk4 ` as an example and solve the radial equation numerically .",
    "this method uses a fourth  order runge  kutta scheme and in fact , the command ` desolve_system_rk4 ` is used as a wrapper for the maxima command ` rk ` @xcite .",
    "numerical solvers can generally deal with first order equations .",
    "our second order equation will yield two first order differential equations which will be solved simultaneously .",
    "we will define the first derivative of the radial function as an auxiliary function @xmath31 and place it in the equation [ radialkg ] to have @xmath32 the following code finds this set of equations as ` radial1 ` and ` radial2 ` .",
    "the solver can deal with the right hand sides of @xmath33 type equations .",
    "thus we isolate the derivatives by solving the differential equations as algebraic equations .",
    "radial1 and radial2 are the right hand sides of our equations to be solved .    .... # the auxiliary function r_aux = function('r_aux')(r )    # two auxiliary equations radial1aux",
    "= diff(r , r)-r_aux ; radial2aux = kgradialpart.subs(diff(r , r)==r_aux).subs(diff(r , r , r)==diff(r_aux , r ) ) ;    # right hand sides of the derivatives radial1=(solve(radial1aux==0,diff(r , r)))[0].right ( ) ; radial2=(solve(radial2aux==0,diff(r_aux , r)))[0].right ( ) ;    # getting the outputs in input format # ( outputs will be copied ) print(radial1 ) print(radial2 ) ....    in their present forms , @xmath34 and @xmath35 are defined as functions . however , in order to use ` desolve_system_rk4 ` we need to define unknowns as variables . to do this , we need to copy the outputs for ` radial1 ` and ` radial2 ` and change them accordingly .",
    "we display the outputs by print command to see them in the input form which enables us to copy them easily .",
    "after a formal analysis of the radial part , one can see that the radial solution can be given in terms of confluent heun functions @xcite .",
    "general and confluent forms of the heun function are encountered in many applications in physics , especially as solutions of the wave equations @xcite .",
    "the general heun function is adapted by oleg v. motygin for gnu octave @xcite .",
    "however , no freely available packages or modules can deal with confluent heun functions .",
    "therefore we can not compare our result with the full analytical solution .",
    "the asympotic form of the confluent heun function is given in reference @xcite as @xmath36,\\ ] ] where @xmath37 .",
    "we first import the differential equation solver from sage.calculus.desolvers .",
    "we then define the variables ( including the unknown functions ) and the equations and copy the equations from the outputs of the code above .",
    "we give some numerical values to the parameters arbitrarily and solve the system for some arbitrary set of initial conditions .",
    "in our example we have @xmath38 and @xmath39 .",
    "the solution is stored in radsol .",
    "radsol has the structure @xmath40 $ ] .",
    "points=[[i , j ] for i , j , k in radsol ] command creates ( or @xmath41 $ ] ) points for plotting .",
    "radialsolution stores the plot of the numerical result .    in the next part",
    ", we define the asymptotic form of the analytical solution and plot it for the same parameter set ( we take @xmath42 to match the amplitude ) .",
    "we display both plots together to show the agreement .",
    ".... # import the solver from sage.calculus.desolvers import desolve_system_rk4    # define unknowns as variables var('r , r_aux , r ' ) ;    # define equations radial1=r_aux ; radial2=-(4*m^2*r_aux + 2*r^2*r_aux + 2*(lambda_aux*r - 3*r*r_aux)*m + ( omega^2*r^3 - lambda_aux*r)*r)/(4*m^2*r - 4*m*r^2 + r^3 ) ;    # substitute numerical values for parameters radial2=radial2.subs(m=0.1,omega=0.2,k=2.0,lambda_aux=2.0 )    # solve the system and plot the solution radsol = desolve_system_rk4([radial1,radial2],[r , r_aux],ics=[0.3,1,0.5],ivar = r , end_points=100,step=0.01 ) ; points=[[i , j ] for i , j , k in radsol ] ; radialsolution = list_plot(points , axes_labels=['$r$','$r$'],legend_label='numerical solution ' ) ;    # asymptotic form of the analytic solution var('cl , l ' ) ; rasym = cl*(1/r)*sin(omega*r+2*m*omega*log(r)-(l*pi/2)+arg(gamma(l+1 - 2*i*m*omega ) ) ) rasymnum = rasym.subs(cl=250,m=0.1,omega=0.2,l=1.0 ) asympplot = plot(rasymnum,(r , 20 , 100),linestyle='',marker='x',color='red',legend_label='asymptotic solution ' )    # display both plots show(asympplot+radialsolution ) ( * @\\label{ex4}@ * ) ....    the plot [ fig : fig1 ] of the solution gives an idea on the behavior of the radial function . numerical solution and the asymptotic form of the analytical solution",
    "are plotted together to show that they agree for large @xmath43 .",
    "the geodesic motion in a spacetime can be described by the hamilton ",
    "jacobi equation @xcite .",
    "@xmath44 where @xmath45 denotes the hamilton s principal function , @xmath46 is the inverse metric and @xmath47 is an affine parameter .",
    "the orbital equations then found using @xmath48 this formalism gives first order differential equations which are needed in numerical schemes as mentioned in the previous section .",
    "the hamilton s principal function is decomposed as @xmath49 for the schwarzschild spacetime . for the equatorial geodesics",
    "we take @xmath50 and thus @xmath51 .",
    "the metric components also change according to this constraint .    before beginning our analysis ,",
    "it should be emphasized that decomposition of the hamilton s principle function @xmath45 ( and the scalar field @xmath20 in the previous section ) is not evident and needs a detailed analysis in general spacetimes , which is beyond the scope of our work .",
    "moreover , analysis of geodesics is a very detailed study and our primitive example here aims only to visualize some geodesics .",
    "the user should execute the lines ( [ ex1]-[ex2 ] ) for the definition of the spacetime before running the codes below .",
    "we start by defining our variables and functions .",
    "we also calculate the inverse metric as needed in the equations .",
    "after giving the hamilton s principle function ansatz , we calculate the hamilton ",
    "jacobi equation in two loops and set it to the variable hjfull .",
    "we call it hjfull as we have not put any conditions ( @xmath50 , etc . ) on the equation yet .",
    "the right hand sides ( as needed by differential equation solvers ) of the geodesic ( orbital ) equations are then calculated ( using nested loops ) and put in the vector geodeqnrhs .",
    "we display the equations both in the latex format and as a vector .",
    ".... # define variables , functions and calculate inverse metric ( * @\\label{ex5}@ * ) var('eta , m , e , l , s , hjfull ' ) ; f = function('f')(r ) ; g = function('g')(th ) ; ginv = g.inverse ( ) ;    # define the principal function ansatz s=((eta*m^2)/2)-e*t+l*ph+f+g    # calculate the hamilton - jacobi equation hjfull=0 ; for i in range(len(bl [ : ] ) ) :      for j in range(len(bl [ : ] ) ) :          hjfull = hjfull+ginv[i , j].expr()*diff(s , bl[i])*diff(s , bl[j ] ) ; hjfull=(diff(s , eta)-(1/2)*hjfull ) ; show('the full hamilton - jacobi equation ( variable name is hjfull ) : ' ) show(hjfull ) ;    show('the geodesic equations in latex form ( variable name is geodeqnrhs ) : ' ) geodeqnrhs = zero_vector(sr , len(bl [ : ] ) )    for mu in range(len(bl [ : ] ) ) :      for nu in range(len(bl [ : ] ) ) :          geodeqnrhs[mu]=geodeqnrhs[mu]-(ginv[mu , nu].expr())*diff(s , bl[nu ] ) ;      writeresult='d[0](%s)($\\eta$ ) = $ % s$ ' % ( bl[mu],latex(geodeqnrhs[mu ] ) ) ;      show(writeresult ) ;    show('right hand sides of the geodesic equations as a vector ' ) show(geodeqnrhs ) ....    the code above is general and it can work for any spacetime if the hamilton s principal function is given accordingly .",
    "the codes below depend on the schwarzschild metric .    conventionally , we take @xmath50 to find the equatorial geodesics .",
    "we call the hamilton  jacobi equation with this constraint as hjst and the right hand sides of the orbital equations as geodeqnrhsst .",
    "we substitute @xmath50 and @xmath51 in the equations found in the general code .    .... # take theta = pi/2 : var('hjst ' )    # hamilton - jacobi equation for theta = pi/2 ( variable name is hjst ) hjst=(hjfull.subs(diff(g)==0)).subs(th = pi/2 ) show(hjst )    # right hand sides of the geodesic equations for theta = pi/2   # ( variable name is geodeqnrhsst ) geodeqnrhsst=(geodeqnrhs.subs(diff(g)==0)).subs(th = pi/2 ) show(geodeqnrhsst )",
    "....    we find @xmath52 and the nonzero components of geodeqnrhsst are @xmath53 we are now ready to solve the orbital equations . here",
    ", we will use another solver , desolve_odeint by importing from sage.calculus.desolvers .",
    "this solver uses scipy.integrate module of python",
    ". we will plot the geodesic curve , and a black disc with a radius equal to the event horizon radius will indicate the black hole .",
    "thus , we import circle from sage.plot.circle .",
    "we define the variables and give them arbitrary numerical values .",
    "we isolate @xmath54 as derofradfun from hjst and place it in @xmath55 equation .",
    "we would like to solve time - dependent @xmath56 and @xmath57 equations , instead of the equations with affine - parameter ( @xmath47 ) dependence .",
    "thus , we divide @xmath55 and @xmath58 by @xmath59 , and set them as our equations : geodeqn1 and geodeqn2 .",
    "we solve our equations for arbitrarily set initial conditions and put the results in the variable sol .",
    "the @xmath60 column of sol carries the @xmath43 values and the @xmath61 column carries the @xmath62 values . using these , we generate @xmath63 points , where @xmath64 and @xmath65 . the line plot of these points forms the geodesic curve .",
    "we plot this curve and the black disc ( a circle with parameters fill = true , rgbcolor=`black ' ) together to display the behavior .",
    ".... # importing the solver from sage.calculus.desolvers import desolve_odeint # importing circle for visualizing the black hole from sage.plot.circle import circle    var('m_aux , l_aux , e_aux , m_aux , r_initial , ph_initial , eta_end , step_size ' ) ;    # # # # # # # # # # # # # # # # # # # # # # # # # # # variables m_aux=0 ; # either 1 ( timelike ) or 0 ( null ) .",
    "m_aux=10 ; l_aux=23 ; e_aux=0.4429 ; step_size=1 ; eta_end=10000 ; r_initial=10*m_aux ; ph_initial=0.3 ; # # # # # # # # # # # # # # # # # # # # # # # # # #    # derivative of f ( the radial function ) # ( variable name is derofradfun ) # we will use the first root derofradfun = solve(hjst , diff(f , r ) ) ;    # define equations to solve   # dr / dt = geodeqn1 # dphi / dt = geodeqn2 geodeqn1=((geodeqnrhsst[1]/geodeqnrhsst[0]).subs(diff(f , r)==derofradfun[1].rhs())).subs(e = e_aux , l = l_aux , m = m_aux , m = m_aux ) ; geodeqn2=(geodeqnrhsst[3]/geodeqnrhsst[0]).subs(e = e_aux , l = l_aux , m = m_aux , m = m_aux ) ;    # solve the equations sol = desolve_odeint([geodeqn1,geodeqn2],[r_initial , ph_initial],srange(0,eta_end , step_size),[r , ph ] ) p = line(zip(sol[:,0]*cos(sol[:,1]),sol[:,0]*sin(sol[:,1 ] ) ) )    # plot the black hole as a circle   # show the geodesics and the circle on the same plot c = circle((0,0),2*m_aux , fill = true , rgbcolor='black ' ) ; show(c+p ) ( * @\\label{ex6}@ * ) ....    the figure [ fig : fig2 ] shows an example of a null geodesic ( @xmath66 ) for an arbitrary set of parameters .",
    "figure [ fig : fig3 ] shows the stable circular orbit for a timelike particle ( @xmath67 ) and figure [ fig : fig4 ] shows another example of a timelike geodesic .    ) . ]    ) . ]    ) . ]",
    "we studied three computer algebra systems which allow tensor manipulation for gr calculations , and showed how one can define a spacetime , calculate christoffel symbols , ricci tensor and einstein tensor for this spacetime using the specialized commands of these systems .",
    "we used sagemath with its tensor manipulation and differential geometry module sagemanifolds , maxima with its tensor component manipulation package ctensor and the python language with the gravipy module which runs on the symbolic analysis module sympy .",
    "a benchmark for these systems is also provided .    in the next part ,",
    "our main focus was the sagemath+sagemanifolds system to perform two examples : massless klein ",
    "gordon equation calculations and geodesic analysis for the schwarzschild geometry .",
    "first , general codes that can run for general spacetimes are given , and then the analysis is specialized for the schwarzschild case .    in our first example , we found the massless klein ",
    "gordon equation as a partial differential equation .",
    "we then separated it to the radial and angular parts and analyzed the radial part in detail .",
    "we confirmed our numerical result graphically using the asymptotic form of the analytical result .    in the second example , the orbit of a null or timelike particle around a schwarzschild black hole was constructed from the geodesic equations .",
    "there are multiple methods of doing that , and among them , the chosen one here is the hamilton ",
    "jacobi formalism as it yields first order differential equations that can be treated easier than the second order equations on the computer .",
    "the orbits are visualized using the plotting tools of sagemath .",
    "a computation system should be chosen according to the needs of the problem .",
    "for example , if a research topic depends on the symbolic manipulations of special functions of mathematical physics , commercial packages are inevitable for most of the cases in the present situation .",
    "however , many problems do not need such specialized calculations and numerical analysis is sufficient to see the result .",
    "therefore freely available packages offer complete computation systems for most of the scientific problems .",
    "we would like to thank profs .",
    "nee zdemir and durmu ali demir for stimulating discussions .",
    "this work is partially supported by tbitak , the scientific and technological council of turkey .",
    "a.  v.  korolkova , d.  s.  kulyabov and l.  a.  sevastyanov , `` tensor computations in computer algebra systems , '' a. v. korolkova , d. s. kulyabov , and l. a. sevastyanov .",
    "tensor computations in computer algebra systems . programming and computer software , 39(3):135142 , 2013 doi:10.1134/s0361768813030031 [ arxiv:1402.6635 [ cs.sc ] ] .",
    "f.  h.  vincent , t.  paumard , e.  gourgoulhon and g.  perrin , `` gyoto : a new general relativistic ray - tracing code , '' class .",
    "* 28 * , 225011 ( 2011 ) doi:10.1088/0264 - 9381/28/22/225011 [ arxiv:1109.4769 [ gr - qc ] ] http://gyoto.obspm.fr/index.html .",
    "e.  gourgoulhon , m.  bejger and m.  mancini , `` tensor calculus with open - source software : the sagemanifolds project , '' j.  phys .  conf .",
    "* 600 * , no . 1 , 012002 ( 2015 ) doi:10.1088/1742 - 6596/600/1/012002 [ arxiv:1412.4765 [ gr - qc ] ] . http://sagemanifolds.obspm.fr/              h.  s.  vieira and v.  b.  bezerra , `` confluent heun functions and the physics of black holes : resonant frequencies , hawking radiation and scattering of scalar waves , '' annals phys .",
    "* 373 * , 28 ( 2016 ) doi:10.1016/j.aop.2016.06.016 [ arxiv:1603.02233 [ gr - qc ] ] .",
    "m.  hortasu ,  heun functions and their uses in physics \" in proceedings of the 13th regional conference on mathematical physics , antalya , turkey , october 27 - 31 , 2010 , u. camci and i. semiz ( eds . ) , p. 23",
    ", world scientific , singapore ( 2013 ) [ arxiv:1101.0471 [ math - ph ] ] .",
    "t.  birkandan and m.  hortasu , `` examples of heun and mathieu functions as solutions of wave equations in curved spaces , '' j.  phys .  a * 40 * , 1105 ( 2007 ) [ j.  phys .  a * 40 * , 11203 ( 2007 ) ] doi:10.1088/1751 - 8113/40/5/016 , 10.1088/1751 - 8121/40/36/c01 [ gr - qc/0607108 ] .",
    "p.  fiziev and d.  staicova , `` application of the confluent heun functions for finding the quasinormal modes of nonrotating black holes , '' phys .",
    "d * 84 * , 127502 ( 2011 ) doi:10.1103/physrevd.84.127502 [ arxiv:1109.1532 [ gr - qc ] ] .",
    "o.  v.  motygin ,  on numerical evaluation of the heun functions , \" proc .",
    "days on diffraction p. 222",
    "( 2015 ) doi : 10.1109/dd.2015.7354864 [ arxiv:1506.03848 [ math.na ] ] https://github.com / motygin / heun_functions/."
  ],
  "abstract_text": [
    "<S> we study three computer algebra systems , namely sagemath ( with sagemanfolds package ) , maxima ( with ctensor package ) and python language ( with gravipy module ) , which allow tensor manipulation for general relativity calculations . </S>",
    "<S> we present simple examples and give a benchmark of these systems . after the general analysis </S>",
    "<S> , we focus on the sagemath+sagemanifolds system to analyze and visualize the solutions of the massless klein  gordon equation and geodesic motion with hamilton  </S>",
    "<S> jacobi formalism . </S>"
  ]
}