{
  "article_text": [
    "a wealth of functionality is available in object - oriented systems and libraries .",
    "this paper addresses the issue of how such libraries can be made available in prolog , in particular libraries for creating user interfaces .    almost any modern prolog system can call routines in c and be called from c ( or other imperative languages ) .",
    "also , most systems provide ready - to - use libraries to handle network communication .",
    "these primitives are used to build bridges between prolog and external libraries for ( graphical ) user - interfacing ( guis ) , connecting to databases , embedding in ( web-)servers , etc .",
    "some , especially most gui systems , are object - oriented ( oo ) .",
    "the rest of this paper concentrates on guis , though the arguments apply to other systems too .",
    "guis consist of a large set of entities such as windows and controls that define a large number of operations .",
    "these operations often involve destructive state changes and the behaviour of gui components normally involves handling spontaneous input in the form of _",
    "oo techniques are very well suited to handle this complexity .    a concrete gui is generally realised by sub - classing base classes from the gui system . in for example java and c++",
    ", the language used for the gui and the application is the same .",
    "this is achieved by either defining the gui base classes in this language or by encapsulating foreign gui classes in classes of the target language .",
    "this situation is ideal for application development because the user can develop and debug both the gui and application in one language .    for prolog , the situation is more complicated .",
    "diversity of prolog implementations and target platforms , combined with a relatively small market share of the prolog language make it hard to realise the ideal situation sketched above .",
    "in addition , prolog is not the most suitable language for implementing fast and space - efficient low - level operations required in a gui .",
    "the main issue addressed in this paper is how prolog programmers can tap on the functionality provided by object - oriented libraries without having to know the details of such libraries .",
    "work in this direction started in 1985 and progresses to today . over these years",
    "our understanding of making prolog an allround programming environment has matured from a basic interface between prolog and object - oriented systems ( section [ basic ] ) , through introducing object - oriented programming techniques in prolog ( section [ extending ] ) , and finally to make it possible to handle prolog data transparently ( section [ data ] ) .",
    "we see several solutions for making oo systems available from prolog .",
    "one is a rigid separation of the gui , developed in an external gui development environment , from the application .",
    "a narrow bridge links the external system to prolog .",
    "various styles of ` bridges ' are used , some based on tcp / ip communication and others on local in - process communication .",
    "eclipse @xcite defines a neat generic interface for exchanging messages between eclipse and external languages that exploits both in - process and remote communication .",
    "@xcite defines a c++ class derived from a prolog - vendor defined c++/prolog interface class that encapsulates the prolog application in a set of c++ methods . the gui part of the application is now written using the normal guidelines of the c++ gui library .",
    "these approaches have advantages such as modularity and using the most appropriate tools for the various functions of the application .",
    "stream - based communication is limited by communication protocol bandwidth and latency .",
    "whether or not using streams , the final application consists of two programs , one in prolog and one in an external language between which a proper interface needs to be defined .",
    "for each new element in the application the programmer needs to extend the prolog program as well as the gui program and maintain the interface consistency .    for applications that require a wide interface between the application and gui code we would like to be able to write the application and gui both in prolog .",
    "here we see two approaches .",
    "one is to write a prolog layer around the ( possibly extended ) api of an existing gui system @xcite .",
    "this option is unattractive as gui systems contain a large number of primitives and data types . developing and maintaining the interface is costly .",
    "the alternative is to consider an existing oo system where methods can be called from the c - language based on their name .",
    "most non - c++ gui toolkits fulfill this requirement .    in the remainder of this article we concentrate on this interesting class of oo systems .",
    "the simplest view on an oo system is that it provides a set of methods ( functions ) that can be applied to objects .",
    "this uniformity of representation ( objects ) and functionality ( methods ) makes it possible to define a very small interface between prolog and an oo system .",
    "all that is required to communicate is to represent object - identity in prolog , translate prolog data to types ( objects ) of the oo system , invoke a method and translate the result back to prolog .",
    "this idea has been implemented in xpce , and throughout this paper we will use examples based on xpce .",
    "we add four predicates to prolog :     +    create an object as an instance of _ class _ using the given arguments to initialise the object .",
    "make the resulting instance known as _ reference _ from prolog .",
    "is atomic , convert it to a natural counterpart in xpce ( integer , float , atom ) .",
    "if it is compound , create an instance using the functor as the class name and the arguments as initialising arguments .",
    "unbound variables have no sensible counterpart in xpce and therefore raise an exception .",
    "the example below creates a box ( graphical rectangle ) with specified width and height .    .... ?",
    "- new(x , box(100,100 ) ) .",
    "x = @459337 ....     +    given a reference to an object , invoke the named method with the given arguments .",
    "the arguments are translated as with * new/2*. xpce uses * send/2 * for methods returning either no value or a boolean success / failure indication .",
    "the example creates a picture ( graphics window ) and displays a box at a given location .    .... ? - new(p , picture ) ,     send(p , display(box(100,50 ) , point(20,20 ) ) ) . ....",
    "+    used for methods that return a ` true ' result value .",
    "if the returned value is primitive , it is converted to a prolog integer , float or atom . in all other cases",
    "an object reference is returned .",
    "the following code gets the left - edge of the visible part of a window .    .... ? - new(p , picture ) ,     get(p , visible , visible ) ,     get(visible , x , x ) .",
    "p = @1072825 visible = @957733 x = 0   ....     +    destroy the referenced object .",
    "minimalists may claim that three of these four primitives are redundant .",
    "generating an instance of a class is an operation of the class and can thus be performed by a method of the class if classes can be manipulated as objects ( or by a ` pseudo - method ' of the interface otherwise ) .",
    "destroying an object is an operation on the object itself and * send/2 * is a special case of * get/3*.    we perceive the distinction between _ telling _ an object to perform an action without interest for the result ( i.e. _ move _ to a location ) and _ asking _ an object to return , compute or create something improves readability .",
    "the * new/2 * and * free/1 * predicates are pleasant short - hands , also improving readability of the code .",
    "xpce defines access to object attributes using two methods , one for retrieving the current value and one for setting it . for object systems that make a distinction between accessing attributes and methods two more",
    "predicates are required to set and retrieving attribute values .",
    "life - time is an important aspect of objects and their references .",
    "object references ( e.g.   in the example above ) are prolog terms acting as an opaque handle to an object .",
    "the life - time of the object is totally unrelated to the life - time of the prolog reference .",
    "the user must be aware of the object life - time rules of the object system .",
    "xpce defines methods to lock , unlock and free objects . in the jpl ( http://sourceforge.net/projects/jpl/ project , interfacing swi - prolog to java",
    ", paul singleton has used prolog atoms for representing object - identity , synchronising object and reference life - time using low - level hooks at both ends .",
    "the four predicates suffice to invoke behaviour in the oo system from prolog .",
    "events and other requests from the oo system can be placed in a queue object and prolog can read this queue .",
    "another possibility is to embed prolog in a class of the oo system and define a method _ call _ that takes a predicate name and a list of oo arguments as input .",
    "these arguments are translated to prolog the same way as the return value of * get/3 * and the method is executed by calling the predicate . in xpce , class * prolog * has a single instance with a public reference ( ) .",
    "this object can , of course , also be activated from prolog with the following result :    .... ? - send(@prolog , writeln('hello world ' ) ) .",
    "hello world .",
    "....      the above has been defined and implemented around 1985 for the first xpce / prolog system .",
    "it can be realised for any oo system that provides runtime invocation of methods by name and the ability to query and construct primitive data types .",
    "the basic oo interface is simple to implement and use .",
    "unfortunately it also has some drawbacks as it does not take advantage of some fundamental advantages of object - oriented programming : specialisation through sub - classing and the ability to create abstractions in new classes .",
    "these drawbacks become very apparent in the context of creating interactive graphical applications .",
    "normally , application gui - objects are created by sub - classing a base class of the toolkit and refining methods such as _ ondraw _ and _ onclick _ to perform the appropriate actions . in our interface",
    ", the implication is that we need to program the oo system .    for xpce , defined in the c - language ,",
    "this is highly unattractive for prolog programmers .",
    "for this reason we invented _ message objects_. message objects are executed on pre - defined events , causing some method to be called .",
    "the following example illustrates this with a push button calling a prolog predicate :    .... ?",
    "- new(b , button(hello ,                   message(@prolog , call ,                           writeln , ' hello world ' ) ) ) .",
    "....    this is quite satisfactory for simple cases .",
    "gui objects however tend to have a large number of ` events ' one might wish to intercept , resulting in a large number of messages that may have to be attached to objects .",
    "moreover , this type of programming occurs at the _ object _ rather than the _ class _ level , thereby impairing re - use and efficiency",
    ".    still , even with the possibility to program in the oo system easily , this is not always the best solution .",
    "the programmer has to work in prolog and the oo language at the same time . with decoupled systems as explained before , the revenue is clean modularization . in this case",
    "the revenues are small and the costs are large . debugging hybrid environments",
    "is difficult , especially if one of the languages is not designed for this .",
    "in addition it requires programmers that can handle both languages .",
    "if we can extend the oo system from prolog with new classes and methods that are executed in prolog we have realised two major improvements .",
    "we have access to functionality of the oo system that must be realised by refining ` virtual ' methods and , with everything running in prolog we only need the prolog debugger .",
    "figure  [ fig : subclass ] illustrates our aim .    in xpce , methods are primary objects consisting of a name , argument type definition and a handle to the implementation . before introducing sub - classing from prolog ,",
    "the implementation was a simple pointer to the c - function realising the method .",
    "we decided to extend this , allowing for arbitrary handles that can be interpreted by the ( prolog ) interface .",
    "on top of that we defined a specification for writing classes in prolog and implemented a compiler for this specification using prolog s * term_expansion/2 * based macro - facility .",
    "a small example of the `` classes in prolog '' notation :    .... : - pce_begin_class(my_box , box ) .",
    "event(box , event : event ) :->          (    send(event , is_a , area_enter )          - >   send(box , fill_pattern , colour(red ) )          ;    send(event , is_a , area_exit )          - >   send(box , fill_pattern , @nil )          ;    send_super(box , event , event )          ) .",
    ": - pce_end_class(my_box ) . ....",
    "this program fragment defines a derived class of the base class * box*. event processing is extended such that the box is red if the pointer ( mouse ) is inside and transparent ( ) otherwise .",
    "xpce is a ` soft typed ' language .",
    "method arguments may have type specifiers and if they do the system performs runtime checks on these .",
    "the method above requires the first argument to be an instance of the class * event*.      the code from figure  [ fig : defclass ] is translated into a clause for the predicate pce_principal : * send_implementation/3 * described below and prolog facts describing method and class properties .",
    "the xpce class and methods are created just - in - time from these facts . representing the class and methods in prolog rather than creating them directly in xpce",
    "reduces program startup time and exploits the runtime generation facilities of the prolog system .",
    "+    multifile predicate created by the xpce class compiler .",
    "_ i d _ is a indexable prolog identifier of the method , _ method _ is a term denoting method name and arguments and _ object _ is the receiver of the method .",
    "the method of figure  [ fig : defclass ] is translated into the clause below .",
    "note that the head is re - arranged to allow for a fast ( indexed ) call , while the body remains unchanged .",
    ".... pce_principal : send_implementation('my_box->event ' , event(a ) , b ) : -      user :      (    (    send(a , is_a(area_enter ) )          - >   send(b , fill_pattern(colour(red ) ) )          ;    send(a , is_a(area_exit ) )          - >   send(b , fill_pattern(@nil ) )          ;    send_class(b , box , event(a ) )          )      ) .",
    "....      our implementation is based on xpce s the ability to refine class * method * , such that the implementation can be handled by a new entity ( the prolog interface ) based on a handle provided by this interface ( the atom ` ' my_box-``>event ' ` in the example ) .",
    "unfortunately very few todays object systems have this ability .",
    "fortunately , we can achieve the same result with virtually any oo system by defining a small wrapper - method in the oo language that calls the prolog interface . ideally , we are able to create this method on demand through the oo systems interface . in the least attractive scenario",
    "we generate a source - file for all required wrapper classes and methods and compile the result using the target oo systems compiler . even in this unattractive",
    "setting , we can still debug and reload the method _ implementation _ using the normal prolog interactive debugging cycle , but we can only extend or modify the class and method _ signatures _ by running the class - compiler and restarting the application .      the first version of xpce where classes could be created from prolog was developed around 1992 . over the years",
    "we have improved performance and the ability to generate compact fast starting saved states .",
    "initially the user community was reluctant , but the system proved valuable for us , making more high - level functionality available to the xpce user using the uniform class based framework .",
    "we improved the usability of creating classes from prolog by making the prolog development environment aware of classes and methods .",
    "we united listing , setting spy - points , locating sources and cross - referencing .",
    "support requests indicate that nowadays a large share of experienced xpce users define classes .",
    "problems are rarely related to the class definition system itself .",
    "user problems concentrate on how to find and combine classes and methods of the base system that fulfill their requirements .",
    "xpce shares this problem with other large and powerful gui libraries .    with the acceptance of xpce / prolog classes a new style of application development emerged .",
    "in this style classes became the dominant structuring factor of the application .",
    "persistent storage and destructive assignment make xpce data representation attractive alternatives to prolog s assert / retract .    these growing expectations however exposed a problem .",
    "as long as the xpce / prolog classes only extend xpce it is natural to be restricted to xpce data . as more application - oriented code",
    "is involved , so is application - oriented data .",
    "we needed a way to pass native prolog data efficiently between methods .",
    "xpce version 5 allows method arguments to be typed as _",
    "prolog_. whenever prolog passes an argument to such a method , it is passed without modification . the passed term need not be ground and can be ( further ) initialised by the called method implementation .",
    "see figure  [ fig : plterm ] .    for the technical realisation we introduced class * host_data * providing xpce with an opaque handle to data of the _ host _ , the term xpce uses for the language(s ) that extend it .",
    "the prolog interface sub - classes this type to * prolog_term*. prolog data is opaque from xpce s perspective .",
    "this is sufficient , as extending xpce itself is not envisioned as part of normal application development . on oo systems where this is a likely scenario ( e.g.  java ) ,",
    "it is desirable to extend the opaque handle with methods to access the prolog term .",
    "this is a natural extension to the currently used implementation .",
    "when preparing an xpce method invocation , we check whether an argument is of type _ prolog _ , a type that refers to * prolog_term * as well as primitive data .",
    "if the argument is not primitive ( integer , float or atom ) , the interface creates an instance of * prolog_term * and stores the _",
    "term_t _ term reference in this object .",
    "whenever an instance of * prolog_term * is passed from xpce to prolog , it is presented to prolog as a normal prolog term .",
    "it is natural to the xpce programmer to be able to store data in instance variables ( slots ) .",
    "xpce uses a reference count based garbage collector , freeing the programmer from lifetime considerations for most objects .",
    "the lifetime of prolog term references however is only guaranteed during the foreign language call where it was created .",
    "prolog data can only survive as a _ copy _ in the prolog permanent heap .",
    "we realised a seamless integration exploiting reference count information . after a method for which we created instances of class * prolog_term * returns",
    ", we check the reference count of the created instances .",
    "if they are just referenced by the creator , we can safely discard them .",
    "otherwise , we can no longer guarantee the prolog term reference .",
    "the term is copied onto the permanent heap and the reference to the term on the stacks is replaced by a reference to the database record in the permanent heap .",
    "the prolog record is destroyed if xpce s garbage collection destroys the object .",
    "see figure  [ fig : pldata ] .",
    "the example below creates a graphical tree where each node has a permanent pay load of prolog data associated .",
    "the hierarchy is created directly from a complex prolog data structure . after creating a hierarchy this way ,",
    "the prolog tree as a whole is always passed _ by reference _ as illustrated in figure  [ fig : plterm ] .",
    "each node contains a permanent copy of the associated pay load .    .... : - pce_begin_class(my_node , node ) .",
    "variable(data , prolog , both , \" associated data \" ) .",
    "initialise(node , tree : prolog ) :->          \" the constructor \" : :          tree = node(name , data , sons ) ,          send_super(node , initialise , text(name ) ) ,          send(node , data , data ) ,          forall(member(son , sons ) ,                 send(node , son , my_node(son ) ) ) .",
    ": - pce_end_class(my_node ) .",
    "....      modern object systems generally have a more subtle view on garbage collection and therefore the reference - count transparent change of status from term - reference to copy is often not feasible .",
    "it could be argued that such an important transition should not go by unintentionally anyhow and it is much better to define a class that represents a prolog term as a reference to a copy in the prolog permanent heap ( record ) .",
    "introduction of such a class avoids the need for reference - counting while making the programmers intention clear .",
    "swi - prolog contains a fast c - interface to transfer terms between the stacks and the permanent heap .",
    "this should be easily achieved in other prolog systems , while the slower route using * assert/1 * through the prolog interface works in any implementation .",
    "the possibility to pass prolog data around has been introduced about 18 months ago , after which it has been used locally to become documented in the official manual about 8 months ago .",
    "we have little insight how much it is used externally .",
    "locally it is now in frequent use , clearly simplifying and improving efficiency of methods that have to deal with application data that is already represented in prolog , such as the parse tree generated by the swi - prolog sgml / xml parser .",
    "method invocation currently always passes the foreign interface , losing non - determinism .",
    "if the implementation is in prolog , it is desirable to be able to exploit non - determinism .",
    "the interface may call the method implementation directly after it detects the method is defined in prolog .",
    "we have experimented with an implementation following the following schema :    .... send(object , message ) : -          resolve_implementation(object , method , implementation ) ,          implementation . ....    for methods defined in prolog , the implementation as shown in section  [ sec : methodimpl ] is called immediately , retaining non - determinism as well as last - call optimization . for methods defined externally , _",
    "implementation _ calls a foreign - language routine realising the method .",
    "we have not yet included this mechanism as too much existing code relies on implicit argument type conversion provided by the interface ( not discussed here ) and the fact that currently , every prolog method implementation implicitly ends with pruning the choice points it may have created .",
    "probably the best solution is to introduce additional syntax declaring a method to be _ pure - prolog_.",
    "xpce / prolog message passing implies data conversion and foreign code invocation , slowing down execution .",
    "however , xpce provides high - level ( graphical ) operations limiting the number of messages passed .",
    "computation inside the prolog application runs in native prolog and is thus not harmed .",
    "bottlenecks appear for example when manipulating bitmapped images at the pixel - level or when using xpce storage classes as the basis for high - performance and low - level object - oriented modeling .    calling a typical method with two arguments defined in prolog from prolog costs , depending on the nature of the arguments , between 2.4 and 5.2 @xmath0 on an amd 1600 + processor ( linux 2.4 , gcc ) .",
    "table table  [ tab : perform ] illustrates the performance on some typical calls .",
    "the first two calls are to a c - defined built - in class involving no significant ` work ' and taking no or one integer argument .",
    "the class * bench * is implemented in prolog as a subclass of the ` root ' object called * object*. the three methods accept no arguments , an integer argument and a prolog term argument .    .",
    "[ cols= \" < , < , < \" , ]",
    "xpce / swi - prolog is a single - threading environment .",
    "where many todays candidate object systems are multi - threaded , the communication with prolog often requires serialization or a prolog system that can cooperate with the threading model of the oo system .",
    "this problem is not unique to the presented design , though the more fine - grained interaction between prolog and the object - system make the problem more urgent .",
    "an important advantage of the described interface is that all application - code is executed in prolog and can therefore be debugged and developed using prolog s native debugger and , with some restrictions described in section  [ sec : portcompile ] , prolog s incremental compilation to update the environment while the application is running .",
    "the prolog debugger is faced with phenomena uncommon to the traditional prolog world .",
    "the event - driven nature of gui systems causes ` spontaneous ' calls .",
    "many user - interactions consist of a sequence of actions each causing their own events and prolog call - backs .",
    "user interaction with the debugger may be difficult or impossible during such sequences .",
    "for example , call - backs resulting from dragging an object in the interface with the mouse can not easily be debugged on the same console .",
    "the design also involves deeply nested control switches between foreign code and prolog .",
    "the swi - prolog debugger is aware of the possibilities of interleaved control and provides hooks for presenting method - calls in a user - friendly fashion .",
    "break - points in addition to the traditional spy - points make it easier to trap the debugger at interesting points during user - interaction .",
    "figure  [ fig : debug ] shows the source - level debugger in action on xpce / prolog code .",
    "psfigfile = debug.eps , width=0.8",
    "to our best knowledge , there are no systems with a similar approach providing gui to prolog . other approaches for accessing foreign gui systems have been explored in section  [ sec : approaches ]",
    ".    started as a mechanism to provide a gui , our approach has developed into a generic design to integrate prolog seamlessly with an external oo programming language .",
    "the integrated system also functions as an object extension to prolog and should therefore be compared to other approaches for representing objects in prolog . given the great diversity of such systems , we consider this beyond the scope of this discussion .",
    "we have presented a generic architecture for integrating oo systems with prolog .",
    "the design allows for extending many existing oo systems naturally from prolog . using this interface",
    "the user can add new classes to the oo system entirely from prolog which can be used to extend the oo system as well as for object - oriented programming in prolog .",
    "no knowledge of details of the oo system , such as syntax , is required .    using dynamically typed oo systems where classes and methods can be created at runtime through the interface ( i.e.  without generating a source file , compiling this and loading the object code ) a quick and natural development cycle is achieved .",
    "if however , less of the oo system is accessible at runtime , development becomes more cumbersome .",
    "xpce / swi - prolog is a free software project which , by nature , profits heavily from user feedback and participation .",
    "we would like to thank mats carlson in particular for his contribution to designing the representation of xpce methods in prolog .",
    "we also acknowedge the reviewers for their extensive comments and suggestions , many of which have been used to clarify this paper .",
    "kish shen , joachim schimpf , stefano novello , and josh singer . a high - level generic interface to external programming language for eclipse . in _ practical aspects of declarative languages _ ,",
    "berlin , germany , 2002 .",
    "springer verlag .",
    "lncs 2257 ."
  ],
  "abstract_text": [
    "<S> it is next to impossible to develop real - life applications in just pure prolog . </S>",
    "<S> with xpce @xcite we realised a mechanism for integrating prolog with an external object - oriented system that turns this oo system into a natural extension to prolog . </S>",
    "<S> we describe the design and how it can be applied to other external oo systems . </S>"
  ]
}