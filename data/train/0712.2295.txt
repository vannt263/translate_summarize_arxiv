{
  "article_text": [
    "the _ one - way quantum computation ( 1wqc ) _ model @xcite , due to its simplicity , universality and parallelism , is widely considered as a very promising scheme for the experimental development of a quantum computer @xcite .    the 1wqc model starts with a highly entangled cluster state and performs quantum computing simply by a sequence of adaptive single - qubit measurements and post - measurement local corrections .",
    "thus the whole computation is separated into four parts : 1 ) preparing cluster states , 2 ) performing single - qubit measurements , 3 ) classically processing measurement outcomes , and 4 ) performing post - measurement local unitary corrections .",
    "such a simple model has been proved to be universal for quantum computation since any quantum circuit can be efficiently simulated on it . moreover , by translating normal quantum circuits into 1wqc - compatible circuits , it is possible to reduce circuit depth and increase parallelism , which is critical to overcome the quantum decoherence problem @xcite .    in this paper",
    ", we reproduce the previous encoding procedure for quantum error correction @xcite under one - way quantum computation model . using only @xmath0 single - bit operations and a small amount of two - bit measurements ,",
    "we encode any given @xmath1-qubit stabilizer code with @xmath2 generators .",
    "furthermore , we will show that the depth of our construction is constant .",
    "our construction is derived using the graphic description for stabilizer codes .",
    "this paper is organized as follows : in section ii , we review the connections between graph states and stabilizer codes . in section iii , we produce an @xmath0 size and constant - depth 1wqc - compatible circuit for the encoding and decoding procedure of arbitrary graph codes .",
    "in this section , let us recall some basic notions concerning this paper .",
    "more details can be reviewed in @xcite .      the _ pauli group _ @xmath3 on @xmath1 qubits is defined to consist of @xmath1-fold tensor products of the pauli matrices \\{i , x , y , z } @xmath4 with multiplicative factors \\{@xmath5 , @xmath6}.    the _ clifford group _",
    "@xmath7 is defined as the normalizer of the pauli group @xmath3 ,    @xmath8    the _ local clifford group _",
    "@xmath9 is a subgroup of @xmath7 which only consists of the tensor products of local unitary operations .",
    "@xmath10 can be generated , up to a global phase factor , by the hadamard gate _",
    "h _ , the phase gate _",
    "s _ and the cnot gate , while the local clifford group @xmath11 can be generated by the _",
    "h _ and _ s _ only .",
    "there are only 24 elements in @xmath12 , up to a global phase .",
    "_ stabilizer group _ @xmath13 is an abelian subgroup of _ pauli group _ @xmath3 without @xmath14 .",
    "any @xmath13 is a stabilizer for a non - trivial vector space , which can be defined as the codespace of a _ stabilizer code _ , the codewords of the stabilizer code form the + 1-eigenspace of the all the operations in @xmath13 .",
    "a @xmath1-qubit _ stabilizer code _ with @xmath2 generators can encode a @xmath15-qubit state into a @xmath1-qubit state .",
    "the stabilizer group @xmath13 corresponding to the stabilizer code can be generated by @xmath2 independent elements @xmath16 .",
    "other elements in @xmath13 can be represented as products of @xmath16 .",
    "thus we can use @xmath16 to describe a stabilizer code .",
    "we will use the _ binary framework _ of stabilizer formalism to represent elements in stabilizer group efficiently .    define a homomorphic map from @xmath17 to @xmath18 as the following : @xmath19 after mapping , an element of pauli group @xmath20 can be described by a binary vector @xmath21,where x is the vector consisting of the first bits of @xmath22 while z is the vector consisting of the second bits .",
    "therefore a @xmath1-qubit stabilizer code @xmath23 with @xmath2 generators @xmath16 can be described by a @xmath24 _ check matrix _ : @xmath25 $ ] where both x and z are @xmath26 matrices .",
    "a @xmath1-qubit _ stabilizer state _ @xmath27 is a @xmath1-qubit stabilizer code with exactly @xmath1 generators . in this case , the dimension of the code space is one .",
    "@xmath27 is the only vector stabilized by @xmath1 generators , up to a global phase .",
    "the stabilizer of @xmath27 can be described by a @xmath28 check matrix .",
    "a _ graph state _",
    "@xmath29 is a stabilizer state with graphical check matrix @xmath30 = [ i|g]$ ] , where @xmath31 is the adjacency matrix of the underlying graph of the graph state .",
    "a @xmath1-qubit _ graph code _ with @xmath2 generators is generated by check matrix @xmath32 = [                                                                 \\begin{array}{cc }                                                                   i , & r \\\\",
    "\\end{array }                                                                 | \\begin{array}{cc } a+rc^t , & c \\\\",
    "\\end{array } ] $ ] , which is closely related to the graph state stabilized by @xmath32 = [                                                                 \\begin{array}{cc }                                                                   i & 0 \\\\                                                                   0 & i \\\\",
    "\\end{array }                                                                 | \\begin{array}{cc } a & c \\\\",
    "c^t & 0 \\\\                                                                 \\end{array } ] $ ] .",
    "an important result @xcite is that any stabilizer state can be transformed into a graph state with generator matrix @xmath32 = [ i|g]$ ] by a local unitary operation u @xmath33 .",
    "similarly , any @xmath1 qubits stabilizer code with @xmath2 generators can be transformed into a graph code with generator matrix @xmath32 = [                                                                 \\begin{array}{cc }                                                                   i , & r \\\\",
    "\\end{array }                                                                 | \\begin{array}{cc } a+rc^t , & c \\\\",
    "\\end{array } ] $ ] related to the graph state stabilized by @xmath32 = [                                                                 \\begin{array}{cc }                                                                   i & 0 \\\\                                                                   0 & i \\\\",
    "\\end{array }                                                                 | \\begin{array}{cc } a & c \\\\",
    "c^t & 0 \\\\                                                                 \\end{array } ] $ ] .",
    "the adjacency matrix of the underlying graph is @xmath34 .      in this subsection",
    ", we give an example to demonstrate how to generate graph codes based on graph state . according to the relationship between stabilizer codes and graph codes",
    ", the basic idea can be generalized to find the relationship between stabilizer codes and graph states .",
    "suppose we have a six - qubit graph code with four generators @xmath35 which is stabilized by @xmath36    suppose we also have a graph state @xmath37 with generators @xmath38",
    "which is stabilized by @xmath39    it s not hard to see following equations relating the two sets of generators : @xmath40    based on the above relation between the generators of the graph code and the graph state , we can obtain the graphic representation of the graph code as shown in the fig.1 .",
    "let @xmath41 denote the graph which includes @xmath31 plus input nodes @xmath42 and @xmath43 .",
    "let @xmath44 denote the graph state corresponding to @xmath41 .",
    "suppose the codewords of the graph code are \\",
    "{ @xmath45 } , then we have : @xmath46 and @xmath47 where @xmath48 denotes local unitary @xmath49 on qubit @xmath50 .",
    "fault - tolerant @xmath51 and @xmath49 operations on the first and second qubit of the encoded state are @xmath52 , @xmath53 , @xmath54 and @xmath55 .",
    "more details about graph states will be explained in the next section .",
    "* remark : * if we can construct the uniform encoded state @xmath56 in a stabilizer code , then we can encode any given unknown @xmath57-qubit state @xmath27 in a stabilizer code by quantum teleportation @xcite . in the next section , we focus on using cluster states to generate any graph state including uniform encoded states for graph codes .",
    "according to the section above , for the purpose of encoding , we have to prepare the graph state we need . in this subsection",
    ", we focus on this topic .",
    "firstly , let us recall the definition of graph states . actually , this definition itself is a method of creating graph states .",
    "let @xmath58 be a graph with @xmath59 vertices and @xmath60 edges , then graph state @xmath29 corresponding to the graph @xmath31 is the following superposition over all basis states , @xmath61    here @xmath62 denotes the controlled phase gate between qubit @xmath50 and qubit @xmath63 .",
    "latexmath:[\\[z_{ij}|+\\rangle_i|+\\rangle_j = |0\\rangle_i|+\\rangle_j +     q(x ) is a quadratic function related to the graph @xmath31 @xmath65 .",
    "we can verify that @xmath29 is the stabilizer state with the graphical check matrix @xmath30 = [ i|g]$ ] .",
    "thus we have the following procedure of preparing the graph state @xmath29 by its natural definition :    * the qubit at each vertex @xmath66 has the initial state @xmath67 , * apply the hadamard gate on each qubit , so each qubit is now in the state @xmath68 * apply the controlled phase gate @xmath62 to each edge @xmath69 .",
    "actually , cluster states and graph states are used so widely in quantum information processing that the preparation of them becomes an important issue .",
    "many efforts have been made on this problem .",
    "on one hand , it has been shown that cluster states can be grown using a divide - and - conquer approach @xcite . in this approach ,",
    "bigger cluster states are created by iteratively connecting smaller clusters together .    on the other hand , another scheme for the preparation of cluster states is based on optical lattice of ultracold atoms @xcite . in this proposal ,",
    "the cluster state can be prepared in one step using a natural nearest - neighbour interaction .",
    "though this is a theoretical proposal at the present time because of the difficulties in experiments , it may be a promising and efficient method of preparing cluster states in the future .",
    "in this situation , it seems necessary to propose a general method for preparing arbitrary graph states from 2d clusters states . in the following",
    ", we will give such a procedure .",
    "firstly , let us recall some properties about graph states in the next subsection .",
    "we start by describing some graphical rules of the operations on the graph states .",
    "let @xmath70 denote the _ local complement _",
    "operation on vertex @xmath71 which replaces the subgraph induced by @xmath71 s neighbors with its complement .",
    "let @xmath72_a$ ] , @xmath73_a$ ] , @xmath74_a$ ] denote single qubit _ pauli measurements _",
    "@xmath51 , @xmath75 , @xmath49 on qubit @xmath71 respectively .",
    "after each pauli measurement , a graph state @xmath76 will transform into another graph state @xmath77 , up to a local clifford unitary depending on the measurement outcome @xcite .",
    "the graphical rules are the following :    * @xmath74_a$ ] : deletes vertex @xmath71 and related edges from @xmath31 ,  @xmath78 .",
    "* @xmath73_a$ ] : first applies local complement on vertex @xmath71 , then delete vertex a ,  @xmath79 . * @xmath72_a$ ] : chooses any of @xmath71 s neighbor @xmath80 , applies local complement on vertex @xmath80 , then applies local complement on @xmath71 , deletes vertex @xmath71 and applies local complement on @xmath80 again ,  @xmath81 .    in summary ,",
    "two graph operations , local complement and vertex deletion , can be achieved by single qubit pauli measurements and local clifford operations .",
    "based on above simple graphic rules , two more graph operations , crossing and contraction , can be implemented as the following :        ( crossing ) two chains crossing each other without sharing any qubit can be simulated in the cluster state of 2d lattice .",
    "as shown in fig.2 , chain crossing can be implemented by performing some pauli measurements in a @xmath82 lattice cluster state . in the first step ,",
    "we perform all @xmath49 measurements and correct the related byproduct local unitaries",
    ". then , we do all @xmath75 measurements except the central one and correct them .",
    "finally , we perform the @xmath75 measurement on the central qubit and correct it . the result is a chain from 1 to 2 and another chain from 3 to 4 .",
    "the two chains cross each other without sharing any qubit .",
    "* remark : * one can use the rewrite rules of the measurement calculus @xcite , to reduce the running time by postponing the local corrections till the end of @xmath83 .",
    "however it is unnecessary here since the running time of simulating chain crossing is already constant .",
    "( contraction@xcite)[contraction ] let graph g(l - v - a - b - r ) consists of subgraph l and r and three vertices @xmath84,@xmath71 and @xmath80 .",
    "vertex @xmath71 has two edges ( a , v ) and ( a , b ) .",
    "vertices @xmath84 and @xmath80 have edges connected to the vertices in the subgraphs @xmath85 and @xmath86 respectively . after applying @xmath51 measurements on vertices",
    "@xmath71 and @xmath80 , the graph state corresponding to graph @xmath31 ( l - v - a - b - r ) will change to the graph state corresponding to the graph @xmath87 ( l - v - r ) .",
    "the lemma can be verified by applying the basic graphic rule about @xmath88_a$ ] .",
    "the contractions through a chain can be done simultaneously .",
    "for example in fig.3 . if @xmath51 measurements are applied on the qubits 5 , 6 , 7 and 8 at the same time , the graph will contract to the vertex 0 , whether or not a @xmath49 operation on the qubit 0 is needed for local correction depends on the sum of measurement outcomes of the qubits 6 and 8 .",
    "local @xmath49 corrections on the qubits 1 and 2 depend on the measurement outcome of the qubit 5 .",
    "local @xmath49 corrections on the qubits 3 , 4 and 9 depend on the sum of measurement outcomes of qubit 5 and 7 .    to understand why the contractions through a chain can be done simultaneously and",
    "how local operations can be postponed to the end of the computing , we have to go through some complicated calculations step by step carefully .",
    "a detailed proof of the lemma is included in the appendix .",
    "any graph state with the underlying graph @xmath31 can be generated from a @xmath89 cluster state by local measurements and local unitaries in constant time .    given a graph @xmath90 with @xmath1 vertices @xmath91 and",
    "@xmath92 edges @xmath93 , we need to perform some crossings and contractions on a cluster state of 2d lattice to generate a graph state @xmath29 .",
    "we need some several auxiliary qubits .",
    "a @xmath94 lattice is required for implementing crossings whereas contractions between any two vertices with degree great than two requires degree two auxiliary qubits .",
    "however , we can introduce those auxiliary qubits by increasing the length and width of the 2d lattice only by a constant value .",
    "thus to simplify the proof , we ignore those auxiliary qubits and only consider an @xmath95 lattice .    in the first step , we perform @xmath49 measurements on the qubit located at the intersection of the @xmath50th row and the @xmath63th column where @xmath96 and @xmath97 . in the second step ,",
    "we perform a crossing operation for any qubit on the location @xmath98 which satisfies @xmath99 and @xmath100 . in the final step ,",
    "we contract simultaneously through the columns @xmath101 to the locations ( 1,1),(2,2), ... ,(n , n ) .",
    "we show an example in fig.4 .",
    "in fact , since we only need to generate the specific graph states related to the graph codes , by carefully rearranging the protocol in theorem iii.1 , it is not difficult to reduce the size of the cluster state needed by our encoding method , to @xmath102 .",
    "( for convenience , we introduce the above one )      combining separate pieces of the operations together , our encoding algorithm is the following : given any @xmath1-qubit stabilizer code with @xmath2 generators , we first determine the equivalent graph code and the graphic representation of the graph code .",
    "then we build the cluster state of 2d lattice and generate the corresponding graph state from the cluster state of 2d lattice .",
    "finally , we encode any unknown quantum state by quantum teleportation .",
    "according to the above section , the whole computation which generates the graph state related to any @xmath1-qubit graph code with @xmath2 generators can be conducted on an @xmath103 lattice .",
    "therefore the total number of quantum operations of the 1wqc is bounded by @xmath0 , which is the length of the description of generating matrix of the stabilizer code .",
    "therefore , both the size and the depth of our 1wqc are most likely optimal in general case .",
    "note that our construction has a constant running time .",
    "since qubit coherent time is limited , improving the temporal overhead of encoding procedure will be helpful for its physical implementation .",
    "furthermore , it should be pointed out that in the procedure of preparing graph state based on cluster states , most operations we need are single - qubit operation ( except when teleportating unknown state , where a small mount of two - qubit measurements are involved ) . usually , in experiments",
    "the fidelity of one - qubit operations is very high .",
    "thus , ignoring errors introduced by one - qubit operations , our encoding procedure will be reasonable as long as the quality of cluster states we use as foundation is good enough .",
    "the decoding procedure can be done in a similar way as the encoding procedure , if one can implement the quantum teleportation on an encoded state . for the error detecting and fault tolerant computation on the states encoded in the stabilizer codes",
    ", one can apply methods in @xcite .",
    "in this paper , we have shown how to use one - way quantum computation to implement an encoding and decoding procedure for quantum error correction .",
    "we have constructed an @xmath0 size and constant - depth 1wqc - compatible circuit which encodes any given @xmath1-qubit stabilizer code with @xmath2 generators .",
    "the result demonstrates that the cluster states can be used as the scalable resources for many multi - qubit entangled states and the one - way quantum computation model can help to design better quantum algorithms than the traditional quantum circuit model .    w. huang thanks y. y. shi and y .- j .",
    "han , z. wei thanks l. m. duan and y. -j .",
    "han for discussions about graph states .",
    "w. huang would also like to thank labmates d. r. vandenberg and r. duan for interesting discussions about local complement operations .",
    "this work was supported in part by the china scholarship council , the nsf awards ( 0431476 ) , the arda under aro contracts and the a. p. sloan fellowship .",
    "more generally , we consider the effect of graph contraction on generalized graph state @xmath113 , where @xmath114 . in this case , we first apply some local z operations on graph state @xmath115 , then apply @xmath51 measurements on qubits a and b , denoted as @xmath72_a$ ] and @xmath72_b$ ] .",
    "suppose measurement results are x and y respectively .",
    "applying @xmath49 operation before x measurement @xmath72 $ ] on a qubit does nothing but flip the measurement outcome , therefore @xmath116_a[x]_bz_l^{u_0}z_v^{v_0}z_r^{w_0}z_a^{x_0}z_b^{y_0}{| g \\rangle}\\\\&= z_l^{u_0}z_v^{v_0}z_r^{w_0}[x]_az_a^{x_0}[x]_bz_b^{y_0}{| g \\rangle}\\\\&=z_l^{u_0}z_v^{v_0+y_0+y}z_r^{w_0+x_0+x}{| \\widetilde{g } \\rangle}\\end{aligned}\\ ] ]"
  ],
  "abstract_text": [
    "<S> we show how to explicitly construct an @xmath0 size and constant quantum depth circuit which encodes any given @xmath1-qubit stabilizer code with @xmath2 generators . our construction is derived using the graphic description for stabilizer codes and the one - way quantum computation model . </S>",
    "<S> our result demonstrates how to use cluster states as scalable resources for many multi - qubit entangled states and how to use the one - way quantum computation model to improve design of quantum algorithms . </S>"
  ]
}