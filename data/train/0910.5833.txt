{
  "article_text": [
    "many static analyses have been developed to check safety properties of sequential programs @xcite while more and more software applications are multithreaded .",
    "naive approaches to analyze such applications would run by exploring all possible interleavings , which is impractical .",
    "some previous proposals avoid this combinatorial explosion ( see related work ) .",
    "our contribution is to show that _ every _ static analysis framework for single - thread programs extends to one that analyzes multithreaded code with dynamic thread creation and with only a modest increase in complexity .",
    "we ignore concurrency specific bugs , e.g. , race conditions or deadlocks , as do some other authors @xcite .",
    "if any , such bugs can be detected using orthogonal techniques @xcite .",
    "[ [ outline ] ] outline + + + + + + +    we describe in section [ syntax ] a toy imperative language .",
    "this contains essential features of c with posix threads @xcite with a thread creation primitive .",
    "the main feature of multithreaded code is that parallel threads may _ interfere _ , i.e. , side - effects of one thread may change the value of variables in other threads . to take interference between threads into account ,",
    "we model the behavior of a program by an infinite transition system : this is the operational semantics of our language , which we describe in section [ subsection : evol ] .",
    "it is common practice in abstract interpretation to go from the concrete to the abstract semantics through an intermediate so - called collecting semantics @xcite . in our case",
    "a different but similar concept is needed , which we call semantics , and which we introduce in section [ section : nonst ] .",
    "this semantics will discover states , accumulate transitions encountered in the current thread and collect interferences from other threads .",
    "the main properties of this semantics  proposition [ prop : basic ] and theorem [ theorem : denot]are the technical core of this paper .",
    "these properties allow us to overapproximate the semantics by a denotational semantics .",
    "section [ abstract ] then derives an abstract semantics from the semantics through abstract interpretation .",
    "we discuss algorithmic issues , implementation , question of precision , and possible extensions in section [ algosm ] , and examine the complexity of our analysis technique in section [ section : complexity ] , and conclude in section [ section : conclusion ] .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    a great variety of static analyses that compute safety properties of single - thread programs have been developed , e.g. , intervals @xcite , points - to - graph @xcite , non - relational stores @xcite or relational stores such as octagons @xcite .",
    "our approach is similat to rugina and rinard , in the sens that we also use an abstract semantics that derives tuples containing information about current states , transitions of the current thread , and interference from other threads . while their main parallel primitive is @xmath1 , which runs too threads ans waits for their completion before resuming computation , we are mostly interested in the more challenging thread creation primitive @xmath2 , which spawn a thread that can survive its father . in section",
    "[ improvement ] , we handle @xmath1 to show how they can be dealt with our techniques .    some authors present generalizations of specific analyses to multithreaded code , e.g. , venet and brat @xcite and lammich and mller - olm @xcite , while our framework extends any single - threaded code analysis .    our approach also has some similarities with flanagan and qadeer @xcite .",
    "they use a model - checking approach to verify multi - threaded programs .",
    "their algorithm computes a guarantee condition for each thread ; one can see our static analysis framework as computing a guarantee , too .",
    "furthermore , both analyses abstract away both number and ordering of interferences from other threads .",
    "flanagan and qadeer s approach still keeps some concrete information , in the form of triples containing a thread i d , and concrete stores before and after transitions .",
    "they claim that their algorithm takes polynomial time in the size of the computed set of triples",
    ". however , such sets can have exponential size in the number of global variables of the program .",
    "when the nesting depth of loops and thread creation statements is bounded , our algorithm works in polynomial time . moreover ,",
    "we demonstrate that our analysis is still precise on realistic examples . finally , while flanagan and qadeer assume a given , static , set of threads created at program start - up , we handle dynamic thread creation .",
    "the same restriction is required in malkis _",
    "_ @xcite .",
    "the 3vmc tool @xcite has a more general scope .",
    "this is an extension of tvla designed to do shape analysis and to detect specific multithreaded bugs .",
    "however , even without multithreading , tvla already runs in doubly exponential time @xcite .",
    "other papers focus on bugs that arise because of multithreading primitives .",
    "this is orthogonal to our work .",
    "see @xcite for atomicity properties , locksimth and goblint tools @xcite for data - races and @xcite for deadlock detection using geometric ideas .",
    "the syntax of our language is given in fig .",
    "[ figsyntax ] .",
    "the syntax of the language is decomposed in two parts : commands ( @xmath3 ) and statements ( @xmath4 ) .",
    "a statement @xmath5 is a command with a return label where it should go after completion .",
    "e.g. , in fig [ subfig : while ] , a thread at label @xmath6 will execute @xmath7\\ccreate(\\nr[a3 ] x:=x+1),\\nlrefb{a1}$ ] . commands and statements are labeled , and we denote by @xmath8 the set of labels .",
    "labels represent the control flow : the statement @xmath9 begins at label @xmath10 and terminates at label @xmath11 , e.g. , in fig [ subfig : create ] , a thread at label @xmath12 will execute the assignment @xmath13 and go to label @xmath6 . it is assumed that in a given command or statement each label appears only once . furthermore , to represent the end of the execution",
    ", we assume a special label @xmath14 which never appears in a command , but may appear as the return label of a statement .",
    "intuitively , this label represents the termination of a thread : a thread in this label will not be able to execute any statement .",
    "notice that sequences @xmath15 are not labeled .",
    "indeed , the label of a sequence is implicitly the label of the first command , e.g. , the program of fig .",
    "[ subfig : create ] is a sequence labeled by @xmath16 .",
    "we write @xmath17 when the label of @xmath3 is @xmath10 and we write @xmath9 the statement @xmath4 labeled by @xmath10 and @xmath11 .",
    "a program is represented by a statement of the form @xmath18 .",
    "other statements represent a partial execution of a program .",
    "the statements @xmath2 , @xmath19 and @xmath20 are not atomic , there are composed of several basic steps , e.g. , to enter in a @xmath19 loop . to model these basic steps , we introduce the statements @xmath21 and @xmath22 .",
    "then , the semantics of @xmath2 , @xmath19 and @xmath20 will be defined using the semantics of @xmath21 and @xmath22 .",
    "local variables are irrelevant to our work .",
    "then , all variables in our language are global .",
    "nevertheless , local variables have been implemented ( see section [ algosm ] ) as a stack .",
    "this is a toy imperative language with dynamic thread creation .",
    "it can easily be extended to handle real - world languages like c or ada , see sections [ subsec : extensions ] and [ algosm ] .      to represent threads",
    ", we use a set @xmath23 of _ thread identifiers_. during an execution of a program , each thread is represented by a different identifier .",
    "we assume a distinguished identifier @xmath24 , and take it to denote the initial thread .",
    "when a program is executed , threads go from a label to another one independently .",
    "control point _ is a partial function @xmath25 that maps thread identifiers to labels and that is defined in @xmath26 .",
    "a control point associates each thread with its current label .",
    "the domain of @xmath25 is the set of created threads , the other identifiers may be used after in the execution , for new threads .",
    "let @xmath27 be the set of control points .",
    "we write @xmath28 the domain of @xmath25 and let @xmath29}$ ] be the partial function defined by @xmath29}(j){\\stackrel{\\text{\\tiny def}}{=}}\\begin{cases }   \\ell & \\text{if } i = j\\\\",
    "p(j ) & \\text{if } i\\in\\dom(p)\\smallsetminus\\{j\\}\\\\   \\text{undefined } & \\text{else}\\\\ \\end{cases } $ ]    furthermore , threads may create other threads at any time .",
    "a _ genealogy _ of threads is a finite sequence of tuples @xmath30 such that    each two tuples @xmath31 and @xmath32 have distinct third component ( i.e. , @xmath33 ) ,    @xmath26 is never the third component of a tuple .",
    "such a tuple @xmath34 means that thread @xmath35 created thread @xmath36 at label @xmath10 .",
    "we write @xmath36 has been _ created _ in @xmath37 to say that a uple @xmath34 appears in @xmath37 .",
    "let @xmath38 be the set of genealogies .",
    "we write @xmath39 the _ concatenation _ of the genealogies @xmath37 and @xmath40 .",
    "the hypothesis ( a ) means that a thread is never created twice , the hypothesis ( b ) means that the thread @xmath26 is never created : it already exists at the begining of the execution .",
    "we let @xmath41 be the set of _",
    "stores_. we leave the precise semantics of stores undefined for now , and only require two primitives @xmath42 and @xmath43 . given a store @xmath44",
    ", @xmath45 returns the store modified by the assignment @xmath46 .",
    "the function @xmath47 evaluates a condition @xmath48 in a store @xmath44 , returning @xmath49 or @xmath50 .",
    "a uple @xmath51 is a _ state _",
    "if    @xmath52 ,    @xmath28 is the disjoint union between @xmath53 and the set of threads created in @xmath37 .",
    "let @xmath54 be the set of states .",
    "a state is a tuple @xmath55 where @xmath35 is the currently running thread , @xmath25 states where we are in the control flow , @xmath44 is the current store and @xmath37 is the genealogy of thread creations .",
    "@xmath28 is the set of existing threads .",
    "the hypothesis ( a ) means that the current thread exists , the hypothesis ( b ) means that the only threads that exist are the initial threads and the thread created in the past .    in the single - threaded case , only the store and the control point of the unique thread is needed . in the case of several threads ,",
    "the control point of each thread is needed : this is @xmath25 .",
    "there are two standard ways to model interferences between threads :    * either all threads are active , and at any time any threads can fire a transition , * or , in each state there is an `` active thread '' , a.k.a . ,",
    "a `` current thread '' , and some so called schedule transitions can change the active thread .",
    "our model rests on latter choice : this allows us to keep track of a thread during execution .",
    "thread ids do not carry information as to how threads were created .",
    "this is the role of the @xmath37 component of states .",
    "given a program @xmath56 the set @xmath57 of initial states is the set of tuples @xmath58 where @xmath59 , @xmath60 , @xmath44 is an arbitrary store , and @xmath61 is the empty word .",
    "a _ transition _ is a pair of states @xmath62 such that @xmath63 and if @xmath64 is a letter of @xmath40 , then @xmath65 and @xmath66 .",
    "we denote by @xmath67 the set of all transitions and we denote by @xmath68 the set of transitions that may appear in the conclusion of rule `` schedule '' , respectively .",
    "a transition in @xmath69 only changes the identifier of the current thread .      to model interleavings ,",
    "we use a small step semantics : each statement gives rise to an infinite transition system over states where edges @xmath70 correspond to elementary computation steps from state @xmath71 to @xmath72 .",
    "we define the judgment @xmath73 to state that @xmath70 is one of these global computation steps that arise when @xmath3 is executed , to label @xmath11 on termination . to simplify semantic rules",
    ", we use an auxiliary judgment @xmath74 to describe evolutions that are local to a given thread .",
    "judgments are derived using the rules of fig .",
    "[ figrules ] .",
    "the rule `` parallel '' transforms local transitions into global transitions .",
    "`` while body '' and `` sequence '' rules are global because while loop and sequences may contain global subcommands , e.g. , @xmath75 . in `` spawn '' ,",
    "the expression `` @xmath36 is fresh in @xmath76 '' means that @xmath77 and @xmath78 is not defined and @xmath36 nevers appears in @xmath37 , i.e. , in @xmath37 , there is no tuples @xmath79 with @xmath35 or @xmath80 equal to @xmath36 .",
    "intuitively , a fresh identifier is an identifier that has never been used ( we keep track of used identifiers in @xmath37 ) .",
    "we define the set of transitions generated by the statement @xmath81 : @xmath82    notice that , unlike flanagan and qadeer @xcite , an arbitrary number of threads may be spawned , e.g. , with the program @xmath83 of fig .",
    "[ subfig : while ] . therefore ,",
    "@xmath23 is infinite , an so are @xmath27 and @xmath84 .",
    "furthermore , @xmath41 may be infinite , e.g. , if store maps variables to integers .",
    "therefore , we can not have a complexity depending of cardinal of @xmath84 .",
    "[ [ example ] ] example + + + + + + +    let us consider stores that are maps from a unique variable to an integer .",
    "we write @xmath85 $ ] the store that maps @xmath86 to the integer @xmath0 .",
    "the transitions generated by the statements extracted from fig .",
    "[ subfig : while ] are : @xmath87 x:=0,\\nlref{a1}}=&\\{((i , p,[x = n],\\h),(i,{p[i \\fleche \\nlrefb{a1}]},[x=0],\\h))\\mid p(i)=\\nlrefb{init1}\\\\ & \\wedge i\\in\\ids\\wedge n\\in\\mathbb{z}\\}.\\\\   \\tr{\\nr[a3 ] x:=x+1,\\lend}= &    \\{((i , p,[x = n],\\h),(i,{p[i \\fleche \\lend]},[x = n+1],\\h))\\mid p(i)=\\nlrefb{a3 } \\\\&\\wedge i\\in\\ids\\wedge n\\in\\mathbb{z}\\}.\\end{aligned}\\ ] ]",
    "let @xmath88 be the set of labels of the statement @xmath18 .",
    "we also define by induction on commands , the set of labels of subthreads @xmath89 by @xmath90 , + @xmath91 , + @xmath92 , + @xmath93 , + and , for basic commands @xmath94 .",
    "a statement generates only transitions from its labels and to its labels , this is formalized by the following lemma :    [ lemma : a ] if @xmath95 then @xmath96 and @xmath97 and @xmath98 .    as a consequence of lemma [ lemma : a ] , we have the following lemma :    [ lemma : abis ] if @xmath99 then for all state @xmath100 , @xmath101    if , during the execution of a statement @xmath9 , a thread creates another thred , then , the subthread is in a label of the command , furthermore , it is in @xmath102 .",
    "[ lemma : asub ] if @xmath103 and @xmath104 then @xmath105 .",
    "[ lemma : asub2 ] if @xmath95 and @xmath106 then @xmath97 .",
    "furthermore @xmath107 and @xmath108 .",
    "notice that in fig .",
    "[ figrules ] some statements are `` atomic '' .",
    "we call these statements _ basic statements_. formally , a basic statement is a statement of the form @xmath109 , @xmath22 or @xmath110 .    on basic statement , we have a more precise lemma on labels :    [ lemma : a]let @xmath111 be a basic statement .",
    "+ if @xmath112 then @xmath98 and @xmath113 and @xmath114 .",
    "to prepare the grounds for abstraction , we introduce an intermediate semantics , called semantics , which associates a function on configurations with each statement .",
    "the aim of this semantics is to associate with each statement a transfer function that will be abstracted ( see section [ abstract ] ) as an abstract transfer function .",
    "a _ concrete configuration _ is a tuple @xmath115 :    @xmath116 is the current state of the system during an execution ,    @xmath117 , for _ guarantee _ , represents what the current thread and its descendants can do    and @xmath118 , for _ assume _ , represents what the other threads can do .",
    "formally , @xmath116 is a set of states , and @xmath117 and @xmath118 are sets of transitions containing @xmath69 .",
    "the set of concrete configurations is a complete lattice for the ordering @xmath119 .",
    "proposition [ prop : coroc ] will establish the link between operational and semantics .",
    "figure  [ fig : states ] illustrates the execution of a whole program .",
    "each vertical line represents the execution of a thread from top to bottom , and each horizontal line represents the creation of a thread . at the beginning ( top of the figure ) , there is only the thread @xmath120 .    during execution ,",
    "each thread may execute transitions . at state @xmath121",
    ", @xmath122 denotes the _ currently running thread _ ( or _ current thread _ ) , see fig .",
    "[ fig : opfunc ] . on fig .",
    "[ fig : states ] , the current thread of @xmath121 is @xmath123 and the current thread of @xmath124 is @xmath125 .    during the program execution given in fig .",
    "[ fig : states ] , @xmath123 creates @xmath126 .",
    "we say that @xmath126 is a _ child _ of @xmath123 and @xmath123 is the _ parent _ of @xmath126 .",
    "furthermore , @xmath126 creates @xmath127 .",
    "we then introduce the concept of _ descendant _ : the thread @xmath127 is a descendant of @xmath123 because it has been created by @xmath126 which has been created by @xmath123 .",
    "more precisely , descendants depend on genealogies .",
    "consider the state @xmath128 with @xmath129 $ ] : the set of descendants of @xmath123 from @xmath130 ( written @xmath131 , see fig .",
    "[ fig : opfunc ] ) is just @xmath132 .",
    "the set of descendants of a given thread increases during the execution of the program . in fig .",
    "[ fig : states ] , the genealogy of @xmath124 is of the form @xmath133 for some @xmath134 , here @xmath135 $ ] .",
    "when the execution of the program reaches the state @xmath124 , the set of descendants of @xmath123 from @xmath133 is @xmath136 .    in a genealogy",
    ", there are two important pieces of information .",
    "first , there is a tree structure : a thread creates children that may creates children and so on ... second , there is a global time , e.g. , in @xmath134 , the thread @xmath125 has been created before the thread @xmath127 .",
    "[ lemma : descendant ] let @xmath137 a genealogy and @xmath35 , @xmath36 which are not created in @xmath40 .",
    "therefore , either @xmath138 or @xmath139 .",
    "we prove this lemma by induction on @xmath40 . if @xmath140 , then @xmath141 .",
    "let us consider the case @xmath142 .",
    "by induction hypothesis either @xmath143 or @xmath144 .    in the first case ,",
    "if @xmath145 , therefore @xmath146 and @xmath147 , else @xmath148 .    in the second case ,",
    "let us consider the subcase @xmath145 .",
    "therefore @xmath149 .",
    "in addition to this , @xmath36 is not created in @xmath150 ( a thread can not be created twice in a genealogy ) , therefore @xmath151 . hence @xmath146 and @xmath152 .",
    "the subcase @xmath153 is similar .",
    "let us consider the subcase @xmath154",
    ". therefore @xmath155 and @xmath156 .",
    "we also need to consider sub - genealogies such as @xmath134 . in this partial genealogy",
    ", @xmath126 has not been created by @xmath123 .",
    "hence @xmath157 .",
    "notice that @xmath158 even though the creation of @xmath127 is in the genealogy @xmath134 .    during an execution ,",
    "after having encountered a state @xmath128 we distinguish two kinds of descendants of @xmath123 :    [ enum : past]those which already exist in state @xmath121 ( except @xmath123 itself ) and their descendants ,    [ enum : future]@xmath123 and its other descendants .",
    "each thread of kind ( [ enum : past ] ) has been created by a statement executed by @xmath123 .",
    "we call @xmath159 the states from which a thread of kind ( [ enum : future ] ) can execute a transition . in fig .",
    "[ fig : states ] , the thick lines describe all the states encountered while executing the program that fall into @xmath159 .    the following lemma explicits some properties of @xmath160 :    [ lemma : f+ ] let @xmath161 a set of transitions .",
    "let @xmath162 therefore :    1 .   if @xmath163 then @xmath164 2 .",
    "if @xmath164 then @xmath165    let @xmath166 and @xmath167 .",
    "by definition of transitions , there exists @xmath168 such that @xmath169 . because @xmath170 , @xmath171 .",
    "therefore , if @xmath98 , i.e. , @xmath172 , then @xmath164 ( by definition of @xmath160 ) .",
    "let us assume that @xmath164 .",
    "let @xmath173 .",
    "therefore , there exists @xmath174 such that @xmath175 and @xmath176 . because @xmath164 , by definition , @xmath177 .",
    "therefore @xmath178 .",
    "according to lemma [ lemma : descendant ] , @xmath179 .",
    "hence @xmath180 and therefore @xmath181 .    when a schedule transition is executed , the current thread change .",
    "the futur descendants of the past current thread and the new current thread are diffents .",
    "this is formalized by the following lemma :    [ lemma : f- ] if @xmath182 then @xmath183 .",
    "let @xmath167 and @xmath184 .",
    "therefore @xmath185 .",
    "let @xmath186 .",
    "by definition of @xmath160 , there exists @xmath40 such that @xmath187 , @xmath188 and @xmath189 .",
    "furthermore @xmath190 and @xmath191 are in @xmath192 .",
    "therefore @xmath190 and @xmath191 are either created in @xmath193 , or are @xmath26 .",
    "hence , @xmath190 and @xmath191 can not be created in @xmath40 .",
    "therefore , @xmath194 and therefore @xmath195 .",
    "using lemma [ lemma : descendant ] we conclude that @xmath196 .",
    "this is a contradiction with @xmath188 and @xmath189 .    during the execution of a set of transition @xmath161",
    "that do not create threads , the set of descendants does not increase :    [ lemma : ndesce ] let @xmath161 a set of transitions such that : + for all @xmath197 .",
    "+ let @xmath198 , @xmath199 and @xmath200 .    if @xmath201 then @xmath202 .",
    "let @xmath203 a sequence of states such that @xmath204 , for all @xmath205 , @xmath206 , and @xmath207 .",
    "let @xmath208 .    if @xmath209 then , @xmath210 and then @xmath211 and then @xmath212 .",
    "therefore , in all cases @xmath213 and then , by straightforward induction , @xmath214 .",
    "[ lemma : ndescew ] let @xmath161 a set of transitions such that : + for all @xmath197 .",
    "+ let @xmath215 and @xmath216 .    if @xmath201 then @xmath217 .",
    "apply lemma [ lemma : ndesce ] with @xmath218 .",
    "these lemmas has a consequence on @xmath160 :    [ lemma : e ] let @xmath161 a set of transitions such that : + for all @xmath197 .",
    "+ if @xmath219 and @xmath164 then @xmath220 .",
    "let @xmath221 and @xmath222 .",
    "by lemma [ lemma : ndescew ] @xmath223 and by definition of @xmath160 , @xmath224 .",
    "[ lemma : h ] let @xmath225 a set of transitions such that : + for all @xmath197 .",
    "+ let @xmath226 a set of transitions .",
    "let @xmath227 three states such that @xmath228 , @xmath163 and @xmath229 .    if @xmath230 then @xmath231 .",
    "let @xmath221 , @xmath222 and @xmath232 . by lemma",
    "[ lemma : ndescew ] @xmath223 and by definition of @xmath160 , @xmath224 . therefore @xmath233 .    because @xmath230 , @xmath234 , therefore @xmath235",
    ". hence @xmath231 .",
    "let us recall some classical definitions",
    ". for any binary relation @xmath236 on states let @xmath237 be the _ restriction _ of @xmath236 to @xmath238 and @xmath239 be the _ application _ of @xmath236 on @xmath238 .",
    "@xmath240 is the _ composition _ of @xmath236 and @xmath241 .",
    "let @xmath242 where @xmath243 and @xmath244 . finally , for any set of states @xmath238 , let @xmath245 be the _ complement _ of @xmath116 .",
    "the definition of the semantics @xmath246 of a statement @xmath9 requires some intermediate relations and sets .",
    "the formal definition is given by the following definition :    let us read together , on some special cases shown in fig .",
    "[ fig : illusconcr ] .",
    "this will explain the rather intimidating of definition [ def : concrsem ] step by step , introducing the necessary complications as they come along .",
    "the statement is executed between states @xmath247 and @xmath248 .",
    "figure   describes the single - thread case : there is no thread interaction during the execution of @xmath9 .",
    "the thread @xmath249 is spawned after the execution of the statement .",
    "e.g. , in fig .",
    "[ subfig : create ] , @xmath250 y:=0;\\nlref{b2}$ ] .    in this simple case ,",
    "a state @xmath124 is reachable from @xmath121 if and only if there exists a path from @xmath121 to @xmath124 using only transitions done by the unique thread ( these transitions should be in the guarantee @xmath117 ) and that are generated by the statement .",
    "@xmath251 represents the final states reachable from @xmath116 .",
    "finally , in this case : @xmath252^{\\star}| { \\mathit{label}}(\\sinit)=\\ell\\}\\\\   \\concr{s } ' & = \\{\\send \\mid \\send\\in\\col(\\concr{s } ) \\wedge { \\mathit{label}}(\\send)=\\ell ' \\ } \\\\   \\se&=\\{(\\sinter,\\sinterb)\\in \\tri { {   { } ^{\\ell}}\\stmt,\\ell ' } \\mid \\sinter\\in \\col(\\concr{s } )",
    "\\}\\\\   \\av { {   { } ^{\\ell}}\\stmt,\\ell'}&\\langle \\concr{s } , \\concr{g } , \\sche \\rangle = \\langle \\concr{s } ' ,   \\concr{g}\\cup\\se ,   \\sche    \\rangle \\vspace{-1.5 mm }   \\su&=\\sud=\\emptyset   \\end{aligned}\\ ] ]    figure   is more complex : @xmath123 interferes with threads @xmath126 and @xmath127 .",
    "these interferences are assumed to be in @xmath118 .",
    "some states can be reached only with such interference transitions .",
    "e.g , consider the statement @xmath253 in fig .",
    "[ fig : example : inter ] : at the end of this statement , the value of @xmath254 may be @xmath255 , because the statement @xmath256 may be executed when the thread @xmath26 is at label @xmath257 .",
    "therefore , to avoid missing some reachable states , transitions of @xmath118 are taken into account in the definition of @xmath258 . in fig .",
    ", the statement @xmath9 is executed by descendants of @xmath123 of kind ( [ enum : future ] ) ( i.e. , @xmath159 ) , and the interferences come from @xmath126 and @xmath127 which are descendants of kind ( [ enum : past ] ) ( i.e. , in @xmath259 ) .",
    "finally , we find the complete formula of definition  [ def : concrsem ] : @xmath260    in fig .  , when @xmath123 executes the statement @xmath9 it creates subthreads ( @xmath125 and @xmath261 ) which execute transitions in parallel of the statement .",
    "the guarantee @xmath117 is not supposed to contain only transitions executed by the current thread but also these transitions .",
    "these transitions , represented by thick lines in fig .  , are collected into the set @xmath262 .",
    "consider such a transition , it is executed in parallel of the statement , i.e. , from a state of @xmath263 .",
    "furthermore , this transition came from the statement , and not from an earlier thread , hence from @xmath159 . @xmath264    the threads created by @xmath123",
    "when it executes the statement @xmath9 may survive when this statement in @xmath265 , as shown in fig .  .",
    "such a thread @xmath35 ( here , @xmath35 is @xmath261 or @xmath249 or @xmath266 ) can execute transitions that are not in @xmath262 .",
    "@xmath267 collects these transitions .",
    "the creation of @xmath35 results of a @xmath2 statement executed between @xmath121 and @xmath265 .",
    "hence , such a transition @xmath268 is executed from a state in @xmath269 .",
    "the path from @xmath265 to @xmath270 is comprised of transitions in @xmath271 ( similarly to @xmath258 ) and of transitions of @xmath123 or @xmath249 under the dotted line , i.e. , transitions in @xmath272 .      to prepare for our static analysis we provide a compositional analysis of the semantics in theorem [ theorem : denot ] below . to this end",
    ", we introduce a set of helper functions , see fig .",
    "[ concrfcts ] .",
    "we define , for any extensive of domain @xmath273 is _ extensive _ if and only if for every set @xmath274 , @xmath275 function @xmath276 , @xmath277 .",
    "the function @xmath278 returns states that are reachable from @xmath116 by applying interferences in @xmath118 .",
    "notice that these interferences do not change the label of the current thread :    [ lemma : b ] let @xmath279 and @xmath280 . if @xmath281 then @xmath282 , i.e. , @xmath283 .",
    "if furthermore @xmath98 then @xmath284 .",
    "there exists a sequence of states @xmath285 , ",
    ", @xmath286 such that @xmath218 and @xmath207 and for all @xmath287 , @xmath288 .",
    "let @xmath289 .",
    "let us prove by induction that @xmath290 .",
    "if @xmath291 and @xmath290 then @xmath292 . if @xmath293 and @xmath290 then @xmath294 and then @xmath295 and then @xmath296 .",
    "the function @xmath297 computes the set of states that may be reached after having created a thread at label @xmath10 ; @xmath298 applies a schedule transition to the last child of the current thread .",
    "the function @xmath299 computes a configuration for the last child created at @xmath10 , taking into account interferences with its parent using @xmath297 ; notice that we need here the genealogies to define @xmath297 and then to have theorem [ theorem : denot ] .",
    "the function @xmath300 computes a part of the guarantee ( an under - approximation ) , given the semantics of a command represented as a function @xmath276 from configuration to configuration .",
    "and @xmath301 iterates @xmath300 to compute the whole guarantee .    during the execution of a statement @xmath9",
    ", some interference transition may be fired at any time .",
    "nevertheless , the labels of the thread(s ) executing the statement are still in a label of the statement :    [ lemma : f ] if @xmath302 , @xmath303 and @xmath230 then @xmath304 .",
    "futhermore , if @xmath305 or @xmath306 then @xmath307 .",
    "there exists a path @xmath203 such that @xmath308 and for all @xmath287 , @xmath309 .",
    "let @xmath166 and for @xmath310 , let @xmath311 .",
    "let us prove by induction on @xmath312 that @xmath313 and for all @xmath314 , @xmath315 .",
    "let us assume that @xmath312 satisfy the induction property , and let us show that @xmath316 satifies the induction property .    in the case",
    "@xmath317 , @xmath318 and then for all @xmath319 , @xmath320 .    in the case @xmath321 and @xmath322 , by lemma [ lemma : a ] , @xmath323 .",
    "furthermore , if @xmath324 then @xmath320 . if @xmath325 , then @xmath326 and by lemma [ lemma : asub ] , @xmath327 .    in the case@xmath321 and @xmath322",
    ", we conclude similarly by lemma [ lemma : asub2 ] . if @xmath230 , then @xmath328 and therefore @xmath304 .",
    "if @xmath305 or @xmath306 , then , because by lemma [ lemma : asub2 ] , @xmath10 and @xmath11 are not in @xmath102 , we have @xmath307 .",
    "the following lemma summarizes the consequences on @xmath258 of lemmas",
    "[ lemma : f+ ] and [ lemma : f ] :    [ lemma : r ] let @xmath329 .",
    "if @xmath330 therefore @xmath230 , @xmath331 and @xmath332 .",
    "@xmath333^{\\star } $ ] , then by lemma [ lemma : f+ ] , @xmath230 and @xmath331 . furthermore , by lemma [ lemma : f ] , @xmath332 .",
    "the following proposition show that @xmath334 collect all transitions generated by a statement .",
    "[ proposition : guarantee ] let @xmath335 a concrete configuration , @xmath9 a statement and @xmath336 .",
    "let @xmath337 and @xmath230 such that @xmath338 .",
    "if @xmath339^{\\star}$ ] then @xmath340    let @xmath341 + and @xmath342 + and @xmath343    let @xmath344 a path such that @xmath308 , @xmath345 and for all @xmath312 , @xmath346^{\\star}$ ] .",
    "let @xmath347 an arbitrary integer .",
    "then , let @xmath348 the smallest @xmath312 ( if it exists ) such that @xmath349",
    ". then , by definition , @xmath350 .",
    "basic statement have common properties , therefore , we will study them at the same time .",
    "proposition [ prop : basic ] explain how to overapproximate the semantics of a basic statement .",
    "it will be used in the abstract semantics .",
    "an execution path of a basic statement can be decomposed in interferences , then one transition of the basic statement , and then , some other interferences .",
    "the following lemma show this .",
    "this lemma will allow us to prove proposition [ prop : basic ] .",
    "[ lemma : c]let @xmath111 be a basic statement , + and @xmath351 .",
    "let @xmath352 then :    * either @xmath353 and @xmath113 , * or @xmath354 + and @xmath355    let us consider the case @xmath356 . by definition of @xmath258 , @xmath307",
    ". therefore @xmath353 . by lemma [ lemma : b ] , @xmath357 , hence , @xmath113 .",
    "let us consider the case @xmath358 because @xmath330 , @xmath359^{\\star}$ ] .",
    "so @xmath360;[(\\restrict{\\concr{g}}{{\\after(s_0)}}\\cap\\tr { { { } ^{\\ell_{1 } }   } basic,\\ell_2})\\restrict{\\concr{a}}{\\compl{\\after(s_0)}}]^{\\star}$ ] .",
    "let @xmath361 a sequence of states such that @xmath362 and @xmath363 and for all @xmath364 , @xmath365 .",
    "notice that @xmath366 and therefore @xmath164 . by lemma [ lemma : e ] ,",
    "therefore @xmath367 .    by lemma [ lemma : a ] , @xmath368 .",
    "let @xmath348 the smallest ( if it exists ) @xmath369 such that @xmath370 .",
    "therefore @xmath371 . by lemma [ lemma : b ] , @xmath372 .",
    "according to lemma [ lemma : a ] , this is a contradiction .",
    "therefore , for all @xmath364 , @xmath373 .    by lemma [ lemma : a ] , @xmath374 , hence @xmath375 .",
    "therefore @xmath376    now , we introduce some claims on the semantics of basic statements .",
    "claims [ claim : suv ] and [ claim : sudv ] say that when a basic statement is executed , only one thread is executed .",
    "notice that @xmath377 creates a subthread , but does not execute it .",
    "the claim [ claim : sev ] caracterizes the transitions done by the current thread .",
    "the claim [ claim : bs ] gives an overapproximation of @xmath251 , the set of states reached at the end of the execution of a basic statement .",
    "[ claim : suv ] let @xmath111 a basic statement and @xmath378 .",
    "therefore , @xmath379 .",
    "let @xmath380 .",
    "therefore , @xmath381 .",
    "so , there exists @xmath382 and @xmath71 such that @xmath383 , @xmath384 and @xmath230 .",
    "hence , by lemma [ lemma : f+ ] , @xmath98 . given that @xmath385 , @xmath386 .",
    "but , because @xmath384 , @xmath387 .",
    "there is a contradiction .",
    "hence @xmath379 .",
    "[ claim : sudv ] let @xmath111 a basic statement and @xmath378 .",
    "therefore , @xmath388 .",
    "let @xmath389 .",
    "there exists @xmath337 and @xmath71 such that @xmath383 , @xmath390 and @xmath391 .",
    "let @xmath166 and @xmath392 .",
    "because @xmath383 , @xmath163 .",
    "let @xmath393 .",
    ". therefore @xmath395 and @xmath396 . by lemma [ lemma : e ] ,",
    "hence @xmath398 .",
    "let @xmath232 . by definition of @xmath399 and a straightforward induction on @xmath37 , @xmath400 .    because @xmath230 , then @xmath401",
    "therefore @xmath402 . by lemma [ lemma : f+ ] ,",
    "this is contradictory with @xmath391 .",
    "hence @xmath388 .",
    "[ claim : sev ] let @xmath111 a basic statement and @xmath378 . + therefore , @xmath403 .",
    ". then @xmath405 and @xmath406 .",
    "then , there exists @xmath407 such that @xmath330 . because @xmath408 , by lemma [ lemma : a ] , @xmath409 . by lemma [ lemma : c ] , @xmath410 . because @xmath307 , @xmath411 .",
    "[ claim : bs ] let @xmath111 a basic statement , @xmath412 and @xmath378 .",
    "+ therefore , @xmath413 .",
    "let @xmath414 .",
    "therefore , @xmath355 and there exists @xmath337 such that @xmath330 .    because @xmath415 , according to lemma [ lemma : c ] , @xmath416    [ prop : basic ] let @xmath111 be a basic statement , then : @xmath417 where @xmath418 + and @xmath419    this proposition is a straightforward consequence of claims [ claim : suv ] , [ claim : sudv ] , [ claim : sev ] and [ claim : bs ] .      the next theorem shows how the semantics can be over - approximated by a denotational semantics , and is the key point in defining the abstract semantics .",
    "[ theorem : denot ]    1 .",
    "[ fcomposition]@xmath420 2 .",
    "[ fif]@xmath421 3 .",
    "[ fwhile ] @xmath422 + with @xmath423 4 .",
    "[ fcreate]@xmath424 + with @xmath425    while points [ fcomposition ] and [ fwhile ] are as expected , the overapproximation of semantics of @xmath426 ( point [ fcreate ] ) computes interferences which will arise from executing the child and its descendants with @xmath301 and then combines this result with the configuration of the current thread .",
    "this theorem will be proved later .",
    "the following proposition consider a statement @xmath9 set of transition @xmath161 .",
    "the only constraint on @xmath161 is on the use of labels of @xmath9 .",
    "the proposition consider an execution of the statement from a state @xmath285 to a state @xmath71 , and , after , an execution @xmath427 of other commands .",
    "the labels of @xmath9 mays only be used :    * for interferences , * or by the statement , * after having applied the statement , i.e. , after @xmath71 .    .",
    "this proposition ensures us that any transition executed by a thread created during the execution of @xmath9 ( i.e. , between @xmath285 and @xmath71 ) is a transition generated by the statement @xmath9 .",
    "[ prop : apres1 ] let @xmath9 a statement , + @xmath428 .",
    "let @xmath383 and @xmath161 a set of transitions such that for all @xmath429 , if @xmath332 then @xmath430 or @xmath431 .",
    "let @xmath427 a sequence of states such that for all @xmath205 , @xmath432 .",
    "therefore , if @xmath433 then either @xmath434 or @xmath435    let for all @xmath310 , let @xmath311 .",
    "let us show by induction on @xmath310 that for all @xmath36 , if @xmath436 then @xmath437 .",
    "let @xmath438 and @xmath439 .",
    "therefore @xmath395 . given that@xmath440 , by lemma [ lemma : r ] , @xmath441 .",
    "by induction hypothesis , for all @xmath36 , if @xmath442 then @xmath443 .",
    "let @xmath444 .    if @xmath445 , therefore , @xmath446 .",
    "furthermore , by induction hypothesis , @xmath447 . by definition of @xmath161 , @xmath448 . by lemma [ lemma : a ] , @xmath449 .    if @xmath450 , then , @xmath451 .",
    "hence , as above , @xmath448 . hence , according to lemma [ lemma : asub ] , @xmath449 .",
    "else , by definition of a transition , @xmath452 .",
    "let @xmath312 such that @xmath433 , hence , either @xmath434 , or @xmath453 .",
    "in the last case @xmath454 , and therefore @xmath455 . hence , by definition of @xmath161 , @xmath321 .",
    "[ lemma : g ] @xmath456    in this section , we consider an initial configuration : @xmath457 and a sequence @xmath458 .",
    "we write @xmath459 and @xmath460 and @xmath461    define : + @xmath462 + @xmath463 + @xmath464 + @xmath465 + @xmath466 + @xmath467    [ lemma : g+ ] if @xmath468 and @xmath469 then @xmath470 .    if @xmath468 and @xmath471 then @xmath472 .",
    "let us consider that @xmath469 . hence because labels of @xmath473 are pairwise distinct , @xmath474 .",
    "by lemma [ lemma : abis ] , @xmath475 .",
    "hence , by lemma [ lemma : g ] , @xmath476    the case @xmath471 is similar .",
    "[ lemma : cbis ] using the above notations , for every @xmath330 such that @xmath477 ,    * either @xmath478 and @xmath479 * or there exists @xmath480 such that @xmath481 , @xmath482    let @xmath330 . either @xmath478 or @xmath483 .    in the first case , either @xmath479 , or @xmath355 .",
    "if @xmath355 , then , by definition , @xmath484 . by definition , @xmath485 and @xmath486{s_0}{s }",
    "we just have to choose @xmath204 .    in the second case , @xmath483 .",
    "let @xmath487 . since @xmath488 , @xmath307 and @xmath489 .",
    "furthermore @xmath490 , so @xmath491 .",
    "since @xmath492^{\\star }   $ ] , @xmath493 ( using lemma [ lemma : g ] ) and @xmath494 , therefore @xmath495^{\\star}$ ] .",
    "recall @xmath496 , hence @xmath497^{\\star}$ ] .",
    "therefore , there exists @xmath71 , @xmath72 such that :    * @xmath498 * @xmath499 * @xmath500^{\\star}$ ]    since @xmath477 , @xmath501 . since @xmath502 , @xmath164 .",
    "furthemore @xmath503 , so , according to lemma [ lemma : f ] , @xmath504 .",
    "given that @xmath505 , according to lemma [ lemma : abis ] , @xmath506 .",
    "hence @xmath507 . because the labels of @xmath458 are pairwise distincts , @xmath508 .",
    "using lemma [ lemma : f ] , we conclude that @xmath163 .",
    "given that @xmath307 and @xmath489 and @xmath509 , we conclude that @xmath481 .",
    "furthermore @xmath510 and @xmath382 , therefore @xmath480 .",
    "@xmath511^{\\star}$ ] .",
    "therefore , by proposition [ prop : apres1 ] , @xmath512^{\\star}{\\subseteq}\\ext[_1]{s_0}{s_1}$ ] .",
    "recall that @xmath500^{\\star}$ ] , then there exists @xmath513 such that for all @xmath514 , @xmath515 . by definition , if @xmath516 , then @xmath517 .",
    "we show by induction on @xmath312 that if @xmath518 , then @xmath453 . by induction hypothesis , @xmath519^{\\star}$ ] .",
    "therefore , by lemma [ lemma : f ] , if @xmath520 , then @xmath521 . therefore , because labels are pairwise distinct , if @xmath520 , then @xmath522 .",
    "therefore , by lemma [ lemma : abis ] , if @xmath520 , then @xmath523 .",
    "hence , @xmath524^{\\star}$ ] . by lemma [ lemma : f+ ] ,",
    "@xmath165 , hence @xmath525^{\\star}{\\subseteq}[\\restrict{\\concr{{a_1}}}{\\compl{\\after(s_0)}}\\cup ( \\restrict{\\concr{g_0}}{\\after(s_0)}\\cap\\tr_2)]^{\\star } $ ] .",
    "therefore @xmath482 .",
    "[ lemma : cter ] using the above notations , for every @xmath330 such that @xmath477 and @xmath526 , there exists @xmath480 such that @xmath481 , @xmath482 and @xmath527{s_0}{s_1}$ ] .    if @xmath478 , then , according to lemma [ lemma : r ] , @xmath528 . in this case",
    "this is not possible because @xmath530 .",
    "therefore , according to lemma [ lemma : cbis ] there exists @xmath480 such that @xmath481 , @xmath482 and @xmath527{s_0}{s_1}$ ]    [ lemma : ext1 ] using the notations of this section , let @xmath531 such that @xmath481 , @xmath532{s_0}{s_1}$ ] and @xmath533 .",
    "therefore @xmath527{s_0}{s_1}$ ] .",
    "notice that , by lemma [ lemma : f+ ] , @xmath534 .    recall that :    @xmath535^{\\star}$ ]    @xmath536{s_0}{s_1}=\\big [ ( \\restrict{\\concr{g_0}}{\\after(s_0)}\\cap\\tr_1)\\cup \\restrict{\\concr{a_0}}{\\compl{\\after(s_0 ) } } \\cup \\restrict{\\concr{g_0}}{\\after(s_1 ) }   \\big]^{\\star}$ ]    by lemma [ lemma : g ] , @xmath537^{\\star}$ ] .",
    "let @xmath538 .",
    "therefore , because @xmath539 , @xmath540^{\\star}$ ] .    by proposition",
    "[ prop : apres1 ] , @xmath541^{\\star}$ ] . because @xmath534 , @xmath542 .",
    "hence @xmath543{s_0}{s_1}$ ] .",
    "hence @xmath544{s_0}{s_1};\\ext[_1]{s_0}{s_1}=\\ext[_1]{s_0}{s_1 } $ ] .",
    "[ lemma : ext2 ] using the notations of this section , let @xmath531 such that @xmath481 , @xmath532{s_0}{s_1}$ ] and @xmath533 .",
    "therefore @xmath545{s_1}{s_2}$ ] .",
    "notice that , by lemma [ lemma : f+ ] , @xmath534 .    recall that    @xmath535^{\\star}$ ]    @xmath546{s_1}{s_2}=\\big [ ( \\restrict{\\concr{g_1}}{\\after(s_1)}\\cap\\tr_2)\\cup \\restrict{\\concr{a_1}}{\\compl{\\after(s_1 ) } } \\cup \\restrict{\\concr{g_1}}{\\after(s_2 ) }   \\big]^{\\star}$ ]    since @xmath533 , @xmath547 , @xmath548 , and @xmath165 there exists @xmath513 such that @xmath308 and for all @xmath549 , @xmath550 .    due to lemma",
    "[ lemma : g ] , for all @xmath549 , @xmath551 .",
    "because @xmath552 , @xmath553^{\\star } { \\subseteq}\\big[(\\restrict{\\concr{g_1}}{\\after(s_0)}\\cap\\tr_2 ) \\cup ( \\restrict{\\concr{g_1}}{\\after(s_0)}\\cap\\tr_2)\\cup \\restrict{\\concr{a_1}}{\\compl{\\after(s_1 ) } } \\cup \\restrict{\\concr{g_1}}{\\after(s_2)}\\big]^{\\star}$ ] .",
    "hence , by proposition [ prop : apres1 ] applied on the statement @xmath554 , for all @xmath549 , @xmath555 .",
    "given that @xmath556 and @xmath557 , by proposition [ prop : apres1 ] applied on the statement @xmath558 , we conclude that for all @xmath549 , @xmath559 .",
    "let @xmath348 such that @xmath560 .",
    "by lemma [ lemma : ext1 ] , @xmath561{s_0}{s_1}$ ] . therefore @xmath562 .",
    "hence @xmath563^{\\star}$ ] .",
    "because @xmath564 , we conclude that @xmath545{s_1}{s_2}$ ] .",
    "to prove the property [ fcomposition ] of theorem [ theorem : denot ] , we have to prove that @xmath565 .",
    "we claim that    @xmath566    @xmath567    @xmath568    @xmath569    . using this claims and the definition of the semantics @xmath570",
    ", we conclude that @xmath565 .",
    "now , we prove these claims :    [ lemma : seq : s ] using the notations of this section , @xmath566 .",
    "let @xmath414 , so there exists @xmath337 such that @xmath571 and @xmath572 . according to lemma [ lemma : cter ] there exists @xmath480 such that @xmath482",
    ". therefore @xmath573 .",
    "[ lemma : seq : par ] using the notations of this section , @xmath567 .",
    "let @xmath574 .",
    "so @xmath468 , and there exists @xmath337 such that @xmath571 .    according to lemma [ lemma : cbis ] either @xmath478 and @xmath575 , or there exists @xmath480 such that @xmath481 and @xmath482 .",
    "in the first case , according to lemma [ lemma : r ] , @xmath576 . since @xmath575 and by lemma",
    "[ lemma : g+ ] , @xmath470 .",
    "hence , by definition , @xmath577    in the second case , by lemma [ lemma : f ] , @xmath578 . since @xmath468 , by lemma [ lemma : g+ ] @xmath472 . given that @xmath579 and @xmath472 , we conclude that @xmath580 .",
    "[ lemma : seq : par2 ] using the notations of this section @xmath568 .",
    "let @xmath581 .",
    "therefore , @xmath468 and there exists @xmath382 and @xmath72 such that @xmath582 , @xmath583 and @xmath230 . according to lemma [ lemma : cbis ]",
    "there are two cases :    first case : @xmath584 and @xmath585 .",
    "then , using the fact that @xmath586 , @xmath587 . because @xmath230 , by lemma [ lemma : f ] , @xmath588 .",
    "hence , according to lemma [ lemma : g+ ] , @xmath470 .",
    "we conclude that @xmath589 .",
    "second case : there exists @xmath480 such that @xmath481 , @xmath552 and @xmath590{s_0}{s_1}$ ] .",
    "hence @xmath544{s_0}{s_1};\\sche=\\ext[_1]{s_0}{s_1}$ ] .",
    "if @xmath231 , then , because @xmath591 , by lemma [ lemma : f ] , @xmath592 .",
    "so , in this case , by lemma [ lemma : g+ ] , @xmath472 and then @xmath593 .",
    "let us consider the case @xmath594 .",
    "given that @xmath383 , @xmath544{s_1}{s_2}$ ] , so by proposition [ prop : apres1 ] , @xmath470 .",
    "hence , @xmath595 .",
    "[ lemma : seq : sub ] using the notations of this section @xmath569 .",
    "let @xmath596 .",
    "then , there exists @xmath285 and @xmath72 such that @xmath582 and @xmath597 . according to lemma [ lemma : cter ] ,",
    "there exists @xmath480 such that @xmath481 and @xmath552 and @xmath598{s_0}{s_1}$ ] .    by lemma [ lemma : ext1 ] and lemma [ lemma : ext2 ] , @xmath544{s_0}{s_1}$ ] and @xmath545{s_1}{s_2}$ ] .",
    "let us consider the case @xmath594 .",
    "because @xmath230 , then @xmath391 . furthermore , given that @xmath481 and @xmath482 , by proposition [ prop : apres1 ] , @xmath470 .",
    "we conclude that @xmath595 .",
    "let us consider the case @xmath231 .",
    "because @xmath599 , @xmath600 . by lemma [ lemma : f ] , @xmath601 .",
    "hence , by lemma [ lemma : g+ ] , @xmath472 and therefore , @xmath602 .      in this section ,",
    "we consider a command @xmath603 and an initial configuration @xmath604 + let @xmath605 .",
    "+ let @xmath606 .",
    "+ let @xmath607 .",
    "+ let @xmath608 .",
    "+ let @xmath609 .",
    "+ let @xmath610 .",
    "[ lemma : gif ] @xmath611 .",
    "[ lemma : cif ] if @xmath330 and @xmath477 , then , one of the three folowing properties hold :    1 .",
    "@xmath612 , 2 .   or there exists @xmath613 such that @xmath614{s_0}{s_1}$ ] 3 .   or there exists @xmath615 such that @xmath616{s_0}{s_1}$ ]    let us consider the case @xmath617 . because @xmath330 , @xmath618^{\\star}$ ]",
    ".    therefore , there exists @xmath619 and @xmath71 such that @xmath620 , @xmath621 and @xmath622^{\\star } $ ] . because @xmath621 , @xmath230 . by lemma [ lemma : e ] , @xmath623 . by lemma [ lemma : b ] ,",
    "@xmath624 . therefore , due to lemmas [ lemma : a ] and [ lemma : gif ] , @xmath625 .",
    "either @xmath626 or @xmath627 .",
    "in the first case , by lemma [ lemma : a ] , @xmath628 and @xmath510 . therefore , @xmath629 and @xmath613 .",
    "there exists a sequence @xmath630 such that @xmath308 and @xmath631 , @xmath632 .",
    "let us prove by induction on @xmath312 , that @xmath633 , @xmath634 .",
    "let us consider the case @xmath635 .",
    "by induction hypothesis @xmath636^{\\star } $ ] .",
    "hence , by proposition [ prop : apres1 ] , either @xmath637 or @xmath434 .",
    "if @xmath637 and @xmath434 then @xmath638 .",
    "this is contradictory with claim [ claim : sudv ] .",
    "therefore @xmath434 . by lemma [ lemma : f ] , @xmath639 . hence , by lemmas [ lemma : a ] and [ lemma : gif ] , @xmath640 .",
    "we conclude that @xmath641^{\\ast}{\\subseteq}\\col_1\\cap \\ext[_{{+}}]{s_0}{s_1}$ ] .",
    "the second case is similar .",
    "[ claim : ifs ] @xmath642    let @xmath530 .",
    "therefore there exists @xmath477 such that @xmath330 and @xmath643 .",
    "hence , due to lemma [ lemma : b ] , @xmath644 .",
    "according to lemma [ lemma : cif ] , there exists @xmath71 such that either    @xmath613 and @xmath614{s_0}{s_1}$ ] ,    or , @xmath615 and @xmath616{s_0}{s_1}$ ] .    in the first case , by definition , @xmath645 and in the second case @xmath646    [ claim : ifse]@xmath647 .",
    "let @xmath648 .",
    "then , there exists @xmath649 such that @xmath330 .",
    "let us consider the case @xmath612 .",
    "by lemma [ lemma : b ] , @xmath113 .",
    "hence , by lemmas [ lemma : a ] and [ lemma : gif ] , @xmath650 . hence , @xmath651 .    according to lemma [ lemma : cif ] ,",
    "if @xmath617 , then , there exists @xmath71 such that either    @xmath613 and @xmath614{s_0}{s_1}$ ] ,    or , @xmath615 and @xmath616{s_0}{s_1}$ ] .    in the first case , by lemma [ lemma : f ] , @xmath639 .",
    "hence , by lemmas [ lemma : a ] and [ lemma : gif ] , @xmath640 and therefore @xmath577 .    in the second case , we similarly conclude that @xmath580 .",
    "[ claim : ifsu]@xmath652 .",
    "let @xmath380 .",
    "therefore , there exists @xmath382 and @xmath72 such that @xmath653 and @xmath583 and @xmath230 .",
    "notice that @xmath654 .",
    "assume by contradiction that @xmath655 .",
    "hence , due to lema [ lemma : e ] , @xmath656 .",
    "this is contradictory .",
    "therefore , according to lemma [ lemma : cif ] , there exists @xmath71 such that either    @xmath613 and @xmath614{s_0}{s_1}$ ] ,    or , @xmath615 and @xmath616{s_0}{s_1}$ ] .    in the two cases , by lemma",
    "[ lemma : h ] , @xmath231 .    in the first case , by lemma [ lemma : f ] ,",
    "@xmath657 and therefore , by lemmas [ lemma : gif ] and [ lemma : a ] , @xmath658 .",
    "hence , @xmath589    in the second case , we similarly conclude that @xmath593 .",
    "[ claim : ifsud]@xmath659 .",
    "let @xmath389 .",
    "therefore , there exists @xmath382 and @xmath660 such that @xmath653 and @xmath533 and @xmath599 .",
    "notice that @xmath654 .",
    "assume by contradiction that @xmath655 .",
    "hence , due to lemma [ lemma : b ] , @xmath661 .",
    "this is contradictory with @xmath660 .",
    "therefore , according to lemma [ lemma : cif ] , there exists @xmath71 such that either    @xmath613 and @xmath614{s_0}{s_1}$ ] ,    or , @xmath615 and @xmath616{s_0}{s_1}$ ] .    in the two cases , by lemma",
    "[ lemma : h ] , @xmath231 .    in the first case , because @xmath662 , by proposition [ prop : apres1 ] , @xmath663 .",
    "hence , @xmath595    in the second case , we similarly conclude that @xmath602 .",
    "property [ fif ] of theorem [ theorem : denot ] is a straightforward consequence of claims [ claim : ifs ] , [ claim : ifse ] , [ claim : ifsu ] , [ claim : ifsud ] .      in this section ,",
    "we consider a command @xmath664 and an initial configuration @xmath604 .",
    "+ let @xmath665 .",
    "+ let @xmath666 .",
    "+ let @xmath667 .",
    "+ let @xmath668 .",
    "+ let @xmath669 .",
    "+ let @xmath670 .",
    "+ let @xmath671 .",
    "+ let @xmath672 .",
    "+ let @xmath673 .",
    "+ let @xmath674 .",
    "[ lemma : gw ] @xmath675    notice that , by definition , @xmath676    [ lemma : apresw ] we use the above notations .",
    "let @xmath677 a sequence of states such that @xmath678 , @xmath679 , @xmath680 and for all @xmath681 , @xmath682 .",
    "therefore , @xmath683 .    for all @xmath312 , @xmath684 .",
    "let @xmath685 such that @xmath686 .",
    "notice that @xmath687{s_0}{s_n}$ ] and @xmath688 .",
    "hence , @xmath689 . therefore @xmath690 .",
    "in addition to this , according to lemma [ lemma : r ] , @xmath691 , so , for all @xmath692 , @xmath693 .",
    "[ lemma : cw ] using the notations of this section , if @xmath694 , then , there exists @xmath695 such that :    1 .",
    "either @xmath696 , 2 .   or there exists @xmath697 such that @xmath698 and @xmath699 and @xmath700",
    ".    let @xmath701 .",
    "we consider a sequence @xmath702 of minimal length such that the following properties hold :    @xmath308 ,    @xmath695 ,    for all @xmath287 , @xmath703    .",
    "a such sequence exists because @xmath704 .    if for all @xmath287 , @xmath705 then @xmath706 .",
    "let us assume , from now , that there exists @xmath287 such that @xmath707 .",
    "let @xmath348 the smallest such @xmath312 .",
    "therefore @xmath708 , so , @xmath709 .",
    "according to lemma [ lemma : e ] , @xmath710 . by lemma [ lemma : b ] , @xmath711 .",
    "but @xmath489 , therefore , by lemma [ lemma : abis ] , @xmath712 .",
    "therefore , by lemma [ lemma : gw ] , either @xmath713 or @xmath714 .    in the first case , by lemma [ lemma : a ] , @xmath715 .",
    "let us prove by induction on @xmath312 that for all @xmath716 , @xmath717 .",
    "by induction hypothesis @xmath718^{\\star}$ ] .",
    "let us consider the case @xmath719 .",
    "therefore @xmath433 , then by lemma [ lemma : e ] , @xmath720 . by lemma [ lemma : b ] ,",
    "so , by lemma [ lemma : abis ] , @xmath291 .",
    "hence @xmath722 .    in the second case ,",
    "@xmath723 and therefore , by lemma [ lemma : a ] , @xmath724 .",
    "either there exists @xmath725 such that @xmath726 or there does not exists a such @xmath727 .",
    "assume by contradiction that @xmath727 exists , therefore , by lemma [ lemma : a ] , @xmath728 . according to lemma [ lemma : f ] , @xmath656 .",
    "so , by lemma [ lemma : apresw ] , @xmath730 .",
    "this is contradictory with the minimality of the path @xmath203 .",
    "therefore @xmath727 does not exists .",
    "hence , for all @xmath716 , @xmath731 . according to proposition [ prop : apres1 ] , for all @xmath716 , @xmath732 .",
    "therefore , @xmath733    [ claim : ws ] using the notation of this section @xmath734 .",
    "let @xmath530 , therefore , @xmath735 .",
    "furthermore , @xmath572 . hence , according to lemma [ lemma : r ] , for all @xmath71 , @xmath736 .",
    "therefore , according to lemma [ lemma : cw ] , there exists @xmath737 such that @xmath696 .",
    "hence @xmath738 .",
    "[ claim : wse ] @xmath739    let @xmath740 . according to lemma [ lemma : gw ] , @xmath741 .",
    "let us consider the case @xmath742 .",
    "due to lemma [ lemma : a ] , @xmath113 hence , according to lemma [ lemma : cw ] , either @xmath696 or there exists @xmath697 such that @xmath699 ( contradiction with lemma [ lemma : r ] and @xmath113 ) . according to lemma [ lemma : c ] , either @xmath415 ( contradiction ) or @xmath743 . therefore either @xmath744 or @xmath745 .",
    "let us consider the case @xmath746 .",
    "therefore , according to lemma [ lemma : a ] , @xmath747 . if @xmath748 , then , by lemma [ lemma : c ] , @xmath749 .",
    "hence , @xmath750 .",
    "so , by lemma [ lemma : cw ] , there exists @xmath751 and @xmath752 such that @xmath629 and @xmath753 . according to proposition [ prop : apres1 ] , @xmath754 and therefore @xmath755 .",
    "[ claim : wsu ] @xmath756    let @xmath380 .",
    "there exists @xmath285 and @xmath72 such that @xmath757 . by lemma [ lemma : c ] , either @xmath758 or there exists @xmath752 such that @xmath629 and @xmath759 and @xmath585 .    in the first case , because @xmath230 , by lemma [ lemma : e ] , @xmath656 .",
    "but , by definition of @xmath69 and @xmath760 , @xmath761 and @xmath762 .",
    "this is contradictory .    in the second case , by proposition [ prop : apres1 ] , @xmath763 . because @xmath764 , by lemma [ lemma : f ] , @xmath765 .",
    "therefore , by lemmas [ lemma : gw ] and [ lemma : a ] , @xmath766 .",
    "hence @xmath767    [ claim : wsud ] @xmath768    let @xmath389 .",
    "therefore , there exists @xmath769 and @xmath770 such that @xmath383 and @xmath771 .",
    "notice that @xmath772 , therefore , according to lemma [ lemma : r ] , @xmath773 .",
    "hence , by lemma [ lemma : cw ] , @xmath774 .",
    "@xmath775 . by proposition [ prop : apres1 ] ,",
    "@xmath776{s_1}{s_2}$ ] .",
    "property [ fwhile ] of theorem [ theorem : denot ] is a straightforward consequence of claims [ claim : ws ] , [ claim : wse ] , [ claim : wsu ] and [ claim : wsud ] .",
    "let @xmath457 a configuration .",
    "+ let @xmath777 + let @xmath778 + let @xmath779 + let @xmath780 + let @xmath781 + let @xmath782 + let @xmath783 + let @xmath784 let @xmath785    [ lemma : gcr ] @xmath786    [ lemma : apresc0 ] let @xmath161 a set of transitions .",
    "let @xmath285 , @xmath71 , @xmath72 , @xmath270 and @xmath100 such that @xmath481 , @xmath787 , @xmath772 , @xmath788 and @xmath230 .",
    "therefore , @xmath789 .    according to lemma [ lemma : c ]",
    ", there exists @xmath619 and @xmath790 such that , @xmath791 , @xmath792 , and @xmath793 .    by lemmas [ lemma : e ] and [ lemma : a ] , @xmath794 .",
    "let @xmath795 and @xmath796 .",
    "let @xmath797 , @xmath798 , @xmath36 , @xmath193 and @xmath37 such that , respectively , the genealogy of @xmath285 , @xmath619 , @xmath799 , @xmath71 , @xmath72 , @xmath270 is @xmath797 , @xmath800 , @xmath801 , @xmath802 , @xmath802 , @xmath803 .",
    "notice that @xmath71 and @xmath72 have the same genealogy .    because @xmath804^{\\ast}$ ] , by lemma [ lemma : ndescew ] , @xmath805 .    because @xmath806^{\\ast}$ ] , by lemma [ lemma : ndescew ] , @xmath807 .    by definition of @xmath399 , @xmath808=\\desce_{\\h}\\{i_0,j\\}$ ] by definition of @xmath399 , @xmath809 .    because @xmath230 , @xmath810 . therefore either @xmath811 or @xmath812 . if @xmath811 then @xmath231 . if @xmath812 then @xmath813 .",
    "[ lemma : apresc ] let @xmath285 , @xmath71 , @xmath72 , @xmath270 and @xmath100 such that @xmath481 , @xmath787 , @xmath772 , @xmath814 and @xmath815 .",
    "therefore , @xmath813 ( i.e. , @xmath816 ) .    due to lemma [ lemma : apresc0 ] , @xmath789",
    ". assume by contradiction that @xmath231 .",
    "therefore , by lemma [ lemma : e ] , @xmath386 and by lemma [ lemma : b ] , @xmath817 .",
    "this is contradictory with lemma [ lemma : a ] which implies @xmath529 .",
    "[ lemma : ccr ] if @xmath330 then :    * either @xmath818 and @xmath113 * or there exists @xmath819 such that @xmath481 , @xmath820 , @xmath821{s_0}{s_1}$ ] , @xmath822 and @xmath787 . furthermore @xmath823 and @xmath824 .",
    "if @xmath825^{\\ast}$ ] then @xmath818 and by lemma [ lemma : b ] , @xmath113 .    then , let us consider the other case : @xmath826^{\\ast}$ ] .",
    "therefore , there exists @xmath619 and @xmath71 such that @xmath804^{\\ast}$ ] , @xmath827 and @xmath622^{\\star}$ ] .",
    "due to lemma [ lemma : e ] , because @xmath828 , @xmath829 .",
    "according to lemma [ lemma : a ] , @xmath830 and @xmath831",
    ". therefore @xmath832 .",
    "let @xmath167 .",
    "let @xmath168 and @xmath36 such that @xmath833 .",
    "let @xmath834 .",
    "therefore , @xmath787 and @xmath820 .",
    "let @xmath835 and @xmath836 .",
    "therefore , @xmath822 .",
    "given that @xmath837 , we conclude that @xmath838^{\\star}$ ] . using lemma [ lemma : apresc ] and a straightforward induction , @xmath839^{\\star}$ ] .",
    "then @xmath840{s_0}{s_1}$ ] .",
    "furthermore by lemma [ lemma : f+ ] , @xmath539 .",
    "hence @xmath841^{\\star}$ ] .",
    "therefore , by proposition [ proposition : guarantee ] , @xmath842 .",
    "@xmath843 .",
    "let @xmath530 .",
    "therefore there exists @xmath382 such that @xmath330 and @xmath844 . according to lemma [ lemma : ccr ]",
    "there exists @xmath71 such that @xmath481 , @xmath772 and @xmath824 .",
    "therefore @xmath480 and @xmath845 .",
    "@xmath846 .",
    "let @xmath740 . according to lemma [ lemma : a ] , @xmath529 .",
    "there exists @xmath382 such that @xmath847 .",
    "therefore , according to lemma [ lemma : ccr ] , @xmath848 . therefore @xmath478 and , by lemma [ lemma : b ] , @xmath113 . due to lemmas [ lemma : abis ] and [ lemma : gcr ] , @xmath849 .",
    "hence @xmath577 .",
    "@xmath850 .",
    "let @xmath851 .",
    "therefore , there exists @xmath477 such that @xmath852 and @xmath230 .",
    "notice that by definition of @xmath69 , @xmath853 .",
    "assume by contradiction , that @xmath854 . due to lemma",
    "[ lemma : e ] , @xmath307 .",
    "this is contradictory .",
    "hence , by lemma [ lemma : ccr ] , there exists @xmath855 such that @xmath481 , @xmath820 , @xmath842 , @xmath822 , @xmath787 , and @xmath823 .    hence , @xmath856 , @xmath857 .    according to lemma [ lemma : f- ] @xmath183 .",
    "given that @xmath858 , @xmath859 .",
    "hence , du to lemma [ lemma : apresw ] , @xmath813 .",
    "if @xmath860 , then @xmath861 and @xmath862 . if @xmath863 , then @xmath864 .",
    "@xmath865 .",
    "let @xmath866 .",
    "there exists @xmath867 such that @xmath868 and @xmath869 and @xmath870 . by lemma [ lemma : ccr ]",
    ", there exists @xmath819 such that @xmath481 , @xmath871 , @xmath872{s_0}{s_1}$ ] and @xmath873 .",
    "furthermore , @xmath874 . due to lemma [ lemma : apresc0 ] , either @xmath875 or @xmath876 .",
    "assume by contradiction that @xmath875 .",
    "therefore @xmath877 .",
    "but , by claim [ claim : sudv ] , @xmath878 . therefore @xmath876 .",
    "let @xmath879 and @xmath880 .",
    "given that @xmath869 , @xmath881^{\\ast}$ ] and by lemma [ lemma : apresc0 ] , @xmath882^{\\ast}$ ] .    by definition of @xmath883 ,",
    "furthermore by lemma [ lemma : f- ] , @xmath183 .",
    "therefore @xmath885 .",
    "hence , @xmath886^{\\ast}$ ] . by lemma [ lemma : f+ ] ,",
    "@xmath887 , therefore @xmath888^{\\ast}$ ] . by proposition [ proposition :",
    "guarantee ] , @xmath889^{\\ast}$ ] .",
    "let @xmath879 and @xmath890 .",
    "therefore , @xmath891 .    if @xmath892 , then @xmath893 and @xmath862 . if @xmath894 , then @xmath895 and @xmath864 .",
    "[ lemma : init ] for all @xmath25 and @xmath44 , @xmath896 .    in particular , if @xmath57 is the set of initial states of a program and @xmath897 , then @xmath898 .",
    "the following proposition shows the connection between the operational and the semantics .",
    "[ prop : coroc ] consider a program @xmath899 and its set of initial states @xmath57 .",
    "let : @xmath900 @xmath901 then : @xmath902    we only have to prove that @xmath903 .",
    "let @xmath904 .",
    "there exists @xmath337 such that @xmath905 by proposition [ proposition : guarantee ] , @xmath906    by lemma [ lemma : init ] , @xmath907 .",
    "hence @xmath908 .",
    "it is straightforward to check that @xmath909 .",
    "recall that @xmath910 is the set of states that occur on paths starting from @xmath57 .",
    "@xmath251 represents all final states reachable by the whole program from an initial state .",
    "@xmath911 represents all transitions that may be done during any execution of the program and @xmath912 represents transitions of children of @xmath26 .",
    "recall from the theory of abstract interpretation @xcite that a _ galois connection _",
    "@xcite between a concrete complete lattice @xmath913 and an abstract complete lattice @xmath914 is a pair of monotonic functions @xmath915 and @xmath916 such that @xmath917 ; @xmath918 is called the _ abstraction _ function and @xmath919 the _ concretization _ function .",
    "product lattices are ordered by the product ordering and sets of functions from @xmath913 to a lattice @xmath920 are ordered by the pointwise ordering @xmath921 .",
    "a monotonic function @xmath922 is an _ abstraction _ of a monotonic function @xmath923 if and only if @xmath924 .",
    "it is a classical result @xcite that an adjoint uniquely determines the other in a galois connection ; therefore , we sometimes omit the abstraction function ( lower adjoint ) or the concretization function ( upper adjoint ) .",
    "our concrete lattices are the powersets @xmath925 and @xmath926 ordered by inclusion .",
    "remember , our goal is to adapt any given single - thread analysis in a multithreaded setting .",
    "accordingly , we are given an abstract complete lattice @xmath927 of abstract states and an abstract complete lattice @xmath928 of abstract transitions .",
    "these concrete and abstract lattices are linked by two galois connections , respectively @xmath929 and @xmath930 .",
    "we assume that abstractions of states and transitions depend only on stores and that all the transitions that leave the store unchanged are in @xmath931 .",
    "this assumption allows us to abstract @xmath932 and @xmath933 as the least abstract transition @xmath934 .",
    "we also assume we are given the abstract operators of table [ fig : abstractions ] , which are correct abstraction of the corresponding concrete functions .",
    "we assume @xmath935 a special label which is never used in statements .",
    "furthermore , we define @xmath936 .",
    "we define a galois connection between @xmath937 and @xmath938 : @xmath939 and @xmath940 ( by convention , this set is @xmath54 when @xmath941 ) .",
    "the set @xmath942 represents the set of labels that may have been encountered before reaching this point of the program .",
    "note that we have two distinct ways of abstracting states @xmath943 , either by using @xmath944 , which only depends on the store @xmath44 , or by using @xmath945 which only depends on the genealogy @xmath37 and the current thread @xmath35 .",
    "the latter is specific to the multithreaded case , and is used to infer information about possible interferences .",
    "just as @xmath944 was not enough to abstract states in the multithreaded setting , @xmath946 is not enough , and lose the information that a given transition is or not in a given @xmath297 .",
    "this information is needed because @xmath947 is used in theorem [ theorem : denot ] and fig .",
    "[ concrfcts ] .",
    "let us introduce the following galois connection between the concrete lattice @xmath926 and the abstract lattice @xmath948 , the product of @xmath949 copies of @xmath926 , to this end : @xmath950 + @xmath951 .",
    "+ @xmath952 is an abstraction of the `` guarantee condition '' : @xmath953 represents the whole set @xmath117 , and @xmath954 represents the interferences of a child with its parent , i.e. , abstracts @xmath947 .",
    "_ abstract configurations _ are tuples @xmath955 such that @xmath956 and @xmath957 .",
    "the meaning of each component of an abstract configuration is given by the galois connection @xmath958 : @xmath959 @xmath960 abstracts the possible current stores @xmath116 .",
    "@xmath961 abstracts the labels encountered so far in the execution .",
    "@xmath962 is an abstraction of interferences @xmath118 .      as an application",
    ", we show some concrete and abstract stores that can be used in practice .",
    "we define a galois connection @xmath963 between concrete and abstract stores and encode both _",
    "abstract states _ and _ abstract transitions _ as abstract stores , i.e. , @xmath964 .",
    "abstract states are concretized by : @xmath965    [ [ non - relational - store ] ] non - relational store + + + + + + + + + + + + + + + + + + + +    such a store is a map from the set of variables @xmath966 to some set @xmath967 of _ concrete values _ , and abstract stores are maps from @xmath966 to some complete lattice @xmath968 of _ abstract values_. given a galois connection @xmath969 between @xmath967 and @xmath968 , the following is a classical , so called non - relational abstraction of stores : @xmath970    let @xmath971 and @xmath972 be the abstract value of the expression @xmath973 and the set of variables that may be represented by @xmath974 , respectively , in the context @xmath960 .",
    "@xmath975}\\\\ { \\aecr{lv:=e}(\\abstr{c})}&{\\stackrel{\\text{\\tiny def}}{= } } & \\bigcup_{x\\in \\addr{\\abstr{c}}{lv } } { \\aecr{x:=e}(\\abstr{c})}\\\\    { { \\abstr{write\\text{-}inter}_{lv:=e}}(\\abstr{c } ) } & { \\stackrel{\\text{\\tiny def}}{=}}&{\\lambda x.   \\text{if } x\\in\\addr{\\abstr{c}}{lv } \\text { then } \\valeur{\\abstr{c}}{e}\\text { else } \\bot   } \\\\    \\acinter{\\abstr{i}}(\\abstr{c})&{\\stackrel{\\text{\\tiny def}}{=}}&\\abstr{i}\\sqcup\\abstr{c}\\\\    { \\abstr{enforce}}_{x}({\\sigma})&{\\stackrel{\\text{\\tiny def}}{=}}&{{\\sigma}[x \\fleche { \\mathit{true}}^{\\sharp}]}\\text { and } { \\abstr{enforce}}_{\\neg x}({\\sigma})={{\\sigma}[x \\fleche { \\mathit{false}}^{\\sharp } ] }   \\end{aligned}\\ ] ]    [ [ genkill - analyses ] ] gen /",
    "kill analyses + + + + + + + + + + + + + + + + +    in such analyses @xcite , stores are sets , e.g. , sets of initialized variables , sets of edges of a point - to graph .",
    "the set of stores is @xmath976 for some set @xmath913 , @xmath977 , and the abstraction is trivial @xmath978 .",
    "each gen / kill analysis gives , for each assignment , two sets : @xmath979 and @xmath980 . these sets may take the current store @xmath44 into account ( e.g. rugina and rinard s `` strong flag '' ) ; @xmath981 ( resp .",
    "@xmath982 ) is monotonic ( resp .  decreasing ) in @xmath44 .",
    "we define the concretization of transitions and the abstract operators : + @xmath983      [ lemma : l ] @xmath984 .",
    "[ lemma : ll ] @xmath985 .",
    "[ lemma : kunion ] let @xmath986 and @xmath987 two set of transitions and @xmath988 .",
    "+ hence , @xmath989    the functions of fig .",
    "[ fig : basicabstract ] abstract the corresponding functions of the semantics ( see fig .  [ concrfcts ] ) .",
    "[ prop : abstract ] the abstract functions @xmath990 , @xmath991 , @xmath992 , @xmath993 , @xmath994 and @xmath995 are abstractions of the concrete functions @xmath996 , @xmath997 , @xmath998 , @xmath999 , @xmath1000 and @xmath1001 respectively .",
    "the cases of @xmath994 and @xmath995 are straightforward .",
    "the case of @xmath993 is a straightforward consequence of lemma [ lemma : ll ] .",
    "let @xmath1002 an abstract configuration and @xmath1003",
    ". therefore @xmath1004 .",
    "let @xmath1005 and @xmath1006 .",
    "therefore , by definition , @xmath1007 . by proposition",
    "[ prop : basic ] , @xmath1008 .",
    "hence @xmath1009 .    according to proposition [ prop : basic ] , @xmath1010 with @xmath1011 .",
    "hence @xmath1012 .",
    "therefore by lemma [ lemma : kunion ] : + @xmath1013    if @xmath1014 then , @xmath1015 .",
    "therefore , by lemma [ lemma : l ] , @xmath1016 .",
    "hence @xmath1017 .",
    "given that @xmath1018 and @xmath1019 , we prove in the same way that @xmath991 is an abstraction of @xmath997 .    given that @xmath1020 and @xmath1021 , we prove in the same way that@xmath992 is an abstraction of@xmath998 .",
    "the @xmath990 function updates @xmath1022 by adding the modification of the store to all labels encountered so far ( those which are in @xmath961 ) .",
    "it does not change @xmath961 because no thread is created .",
    "notice that in the case of a non - relational store , we can simplify function @xmath1023 using the fact that @xmath1024 } $ ] .",
    "the abstract semantics is defined by induction on syntax , see fig .",
    "[ fig : abstract ] , and , with prop.[prop : abstract ] , it is straightforward to check the soundness of this semantics :    [ sounda ] @xmath1025 is an abstraction of @xmath1026 .",
    "consider fig .",
    "[ fig : example ] and the non - relational store of ranges @xcite . we will apply our algorithm on this example .",
    "our algorithm computes a first time @xmath1027 , then , the fixpoint is not reached , and then , @xmath1027 is computed another time .    1",
    ".   initial configuration : @xmath1028 where @xmath1029 $ ] and @xmath1030 and @xmath1031 and @xmath1032 .",
    "2 .   the configuration @xmath1033 is computed .",
    "@xmath1034 where @xmath1035 $ ] and @xmath1036 $ ] .",
    "the @xmath961 and @xmath962 componnents are not changed because no new thread is created .",
    "[ item : child - spawn ] the configuration @xmath1037 is computed .",
    "@xmath1038 where @xmath1039 and @xmath1040 .",
    "notice that because @xmath1041 the equality @xmath1039 holds .",
    "4 .   the configuration @xmath1042 is computed .",
    "@xmath1043 where @xmath1044 $ ] and @xmath1045 $ ] .",
    "5 .   the configuration @xmath1046 is computed .",
    "@xmath1047 . @xmath1048 $ ] and @xmath1049 $ ] and @xmath1050 $ ] .",
    "6 .   the configuration @xmath1051 is computed .",
    "@xmath1053 $ ] and @xmath1054 $ ] and @xmath1055 .    then",
    ", we compute a second time @xmath1027 , on a new initial configuration @xmath1056 .    noting change , except at the step [ item : child - spawn ] , when @xmath1057 is applied .",
    "the configuration obtained is then @xmath1058 where @xmath1059 $ ] and @xmath1060 $ ] .",
    "then , the algorithm discovers that the value of @xmath1061 may be 3 .",
    "the details of the execution of the algorithm is given in the following tabular :    [ 1 ]    lcc & & y=#1 , z=[0,3 ] + _ 3 & & z=3    [ 2 ]    lcc y & = & # 1 + z&=&#2    @xmath1062 } & \\{\\fin\\ } & { \\lambda \\ell .",
    "\\bot } & z=3 \\\\",
    "\\hline   \\osem { { { } ^{\\ell_{4 } }   } y:=y+z,\\lend } & \\exstore{[0,3]}{[0,3 ] } &   \\{\\fin\\ } & \\fin\\mapsto y=[0,3 ] & z=3\\\\ \\hline   \\glue{\\aspawn{\\ell_3}(\\cdot ) } & \\exstore{[0,3]}{0 } & \\{\\fin,\\ell_3\\ } & \\bigk{[0,3 ] } & y=[0,3]\\\\ \\hline   \\osem { { { } ^{\\ell_{5 } }   } z:=3,\\lend } & \\exstore{[0,3]}{3 } & \\{\\fin,\\ell_3\\ } & \\bigk{[0,3 ] } & y=[0 , 3 ] \\\\",
    "\\hline \\end{array}$ ]",
    "the abstract semantics is denotational , so we may compute it recursively .",
    "this requires to compute fixpoints and may fail to terminate . for this reason , each time we have to compute @xmath1063 we compute instead the overapproximation @xmath1064 , where @xmath1065 is a widening operator , in the following way :    assign @xmath1066    [ algo : whilebody ] compute @xmath1067    if @xmath1068",
    "then returns @xmath1069 , otherwise ,    assign @xmath1070 and go back to [ algo : whilebody ] .",
    "our final algorithm is to compute recursively @xmath1071 applied to the initial configuration @xmath1072 , overapproximating all fixpoint computations .",
    "we have implemented two tools , and , in ocaml with the front - end c2newspeak , with two different abstract stores .",
    "the first one maps variables to integer intervals and computes an overapproximation of the values of the variables .",
    "the second one extends the analysis of allamigeon et al .",
    "@xcite , which focuses on pointers , integers , c - style strings and structs and detects array overflows .",
    "it analyzes programs in full fledged c ( except for dynamic memory allocation library routines ) that use the pthreads multithread library .",
    "we ignore mutexes and condition variables in these implementations .",
    "this is sound because mutexes and condition variables only restrict possible transitions .",
    "we lose precision if mutexes are used to create atomic blocks , but not if they are used only to prevent data - races .    in table [ table : benchmarks ] we show some results on benchmarks of differents sizes .",
    "means `` lines of code '' .",
    "`` '' is a c file , with 3 threads : one thread sends an integer message to another through a shared variable .",
    "`` '' is extracted from embedded c code with two threads . `` '' and `` '' are sets of 12 and 15 files respectively , each one focusing on a specific thread interaction .",
    "to give an idea of the precision of the analysis , we indicate how many false alarms were raised .",
    "our preliminary experiments show that our algorithm loses precision in two ways :    through the ( single - thread ) abstraction on stores    by abstraction on interferences .    indeed , even though our algorithm takes the order of transitions into account for the current thread , it considers that interference transitions may be executed in an arbitrary order and arbitrary many times .",
    "this does not cause any loss in `` '' , since the thread which send the message never put an incorrect value in the shared variable .",
    "despite the fact that `` '' is a large excerpt of an actual industrial code , the loss of precision is moderate : 7 false alarms are reported on a total of 27 100 lines .",
    "furthermore , because of this arbitrary order , our analysis straightforwardly extends to models with `` relaxed - consistency '' and `` temporary '' view of thread memory due to the use of cache , e.g. , openmp .",
    "the complexity of our algorithm greatly depends on widening and narrowing operators . given a program @xmath1073 , the _ slowness _ of the widening and narrowing in an integer @xmath1074 such that : widening - narrowing stops in always at most @xmath1074 steps on each loop and whenever @xmath1075 is computed ( which also requires doing an abstract fixpoint computation ) .",
    "let the _ nesting depth _ of a program be the nesting depth of @xmath19 and of @xmath2 which needs a fixpoint computation , except @xmath2 with no subcommand @xmath2 .",
    "] have a subcommand @xmath2 .",
    "[ prop : complexity ] let @xmath1076 be the nesting depth , @xmath0 the number of commands of our program , and , @xmath1074 the slowless of our widening .",
    "the time complexity of our analysis is @xmath1077 assuming operations on abstract stores are done in constant time .",
    "this is comparable to the @xmath1078 complexity of the corresponding single - thread analysis , and certainly much better that the combinatorial explosion of interleaving - based analyses .",
    "furthermore , this is beter than polynomial in an exponential number of states @xcite .",
    "let @xmath1079 , @xmath1080 and @xmath1081 and @xmath1082 be the complexity of analyzing @xmath1083 , the size of @xmath1083 and the nesting depth of @xmath1083 , the slowless of the widening and narrowing on @xmath1083 respectively .",
    "let @xmath1084 and @xmath312 the complexity of assign and of reading @xmath954 respectively .",
    "proposition [ prop : complexity ] is a straightforward consequence of the following lemma :    the complexity of computing @xmath1085 is @xmath1086    this lemma is proven by induction .",
    "+ @xmath1087 + @xmath1088 + @xmath1089 + if @xmath1090 does not contain any subcommand @xmath2 , then the fixpoint computation terminates in one step : @xmath1091 + else : @xmath1092      notice that we have assumed that operation on @xmath948 are done in constant time in proposition [ prop : complexity ] . this abstract store may be represented in different ways .",
    "the main problem is the complexity of the @xmath1023 function , which computes a union for each element in @xmath961 .",
    "the naive approach is to represent @xmath1093 as a map from @xmath1094 to @xmath928 . assuming that operations on maps are done in constant time",
    ", this approach yields a @xmath1095 complexity where @xmath1096 is the number of @xmath2s in the program .",
    "we may also represent @xmath1093 as some map @xmath1097 from @xmath1094 to @xmath928 such that @xmath1098 and the function @xmath1023 is done in constant time : @xmath1099 } , \\abstr{i}\\rangle$ ] .",
    "nevertheless , to access to the value @xmath954 may need up to @xmath1096 operations , which increases the complexity of @xmath1057 and @xmath994 .",
    "the complexity is then @xmath1100 .",
    "the slowness of the widening and narrowing operators , @xmath1074 , depends on the abstraction .",
    "nevertheless , a widening is supposed to be fast .",
    "consider the naive widening on intervals : @xmath1101\\widen[y , y ' ] = [ z',z']$ ] where @xmath1102 and @xmath1103 .",
    "+ this widening never widen more than two times on the same variable . therefore this naive widening is linear in the worst case .",
    "our technique also applies to other forms of concurrency , fig .",
    "[ mfeatures ] displays how rugina and rinard s @xmath1 constructor would be computed with our abstraction .",
    "correctness is a straightforward extension of the techniques described in this paper .",
    "our model handle programs that use @xmath2 and @xmath1 .",
    "then , it can handle openmp programs with `` parallel '' and `` task '' constructors .",
    "we have described a generic static analysis technique for multithreaded programs parametrized by a single - thread analysis framework and based on a form of rely - guarantee reasoning . to our knowledge , this is the first such _ modular _ framework : all previous analysis frameworks concentrated on a particular abstract domain .",
    "such modularity allows us to leverage any static analysis technique to the multithreaded case .",
    "we have illustrated this by applying it to two abstract domains : an interval based one , and a richer one that also analyzes array overflows , strings , pointers @xcite . both have been implemented .",
    "we have shown that our framework only incurred a moderate ( low - degree polynomial ) amount of added complexity .",
    "in particular , we avoid the combinatorial explosion of all interleaving based approaches .",
    "our analyses are always correct , and produce reasonably precise information on the programs we tested .",
    "clearly , for some programs , taking locks / mutexes and conditions into account will improve precision .",
    "we believe that is an orthogonal concern : the non - trivial part of our technique is already present _ without _ synchronization primitives , as should be manifest from the correctness proof of our semantics .",
    "we leave the integration of synchronisation primitives with our technique as future work",
    ". however , locks whose sole purpose are to prevent data races ( e.g. ensuring that two concurrent accesses to the same variable are done in some arbitrary sequential order ) have no influence on precision . taking locks into account may be interesting to isolate atomic blocks .",
    "we thank jean goubault - larrecq for helpful comments .",
    "a.  min , field - sensitive value analysis of embedded c programs with union types and pointer arithmetics , in : acm sigplan lctes06 , acm press , 2006 , pp .",
    "5463 , http://www.di.ens.fr/~mine/publi/article-mine-lctes06.pdf .",
    "x.  allamigeon , w.  godard , c.  hymans , static analysis of string manipulations in critical embedded c programs , in : k.  yi ( ed . ) , static analysis , 13th international symposium ( sas06 ) , vol .",
    "4134 of lecture notes in computer science , springer verlag , seoul , korea , 2006 , pp . 3551 .",
    "b.  steensgaard , points - to analysis in almost linear time , in : popl 96 : proceedings of the 23rd acm sigplan - sigact symposium on principles of programming languages , acm press , new york , ny , usa , 1996 , pp . 3241 . http://dx.doi.org/http://doi.acm.org/10.1145/237721.237727 [ ] .",
    "a.  min , a new numerical abstract domain based on difference - bound matrices , in : pado ii , vol .",
    "2053 of lncs , springer - verlag , 2001 , pp .",
    "155172 , http://www.di.ens.fr/~mine/publi/article-mine-padoii.pdf .",
    "p.  lammich , m.  mller - olm , precise fixpoint - based analysis of programs with thread - creation and procedures , in : l.  caires , v.  t. vasconcelos ( eds . ) , concur , vol .",
    "4703 of lecture notes in computer science , springer , 2007 , pp .",
    "287302 .",
    "p.  pratikakis , j.  s. foster , m.  hicks , locksmith : context - sensitive correlation analysis for race detection , in : pldi 06 : proceedings of the 2006 acm sigplan conference on programming language design and implementation , acm press , new york , ny , usa , 2006 , pp .",
    "l.  fajstrup , e.  goubault , m.  rauen , detecting deadlocks in concurrent systems , in : concur 98 : proceedings of the 9th international conference on concurrency theory , springer - verlag , london , uk , 1998 , pp .",
    "332347 .",
    "l.  o. andersen , http://repository.readscheme.org/ftp/papers/topps/d-203.ps.gz[program analysis and specialization for the c programming language ] , ph.d .",
    "thesis , diku , university of copenhagen ( may 1994 ) .",
    "http://repository.readscheme.org / ftp / papers / topps / d-203% .ps.gz[http://repository.readscheme.org",
    "/ ftp / papers / topps / d-203% .ps.gz ]        a.  venet , g.  brat , precise and efficient static array bound checking for large embedded c programs , in : pldi 04 : proceedings of the acm sigplan 2004 conference on programming language design and implementation , acm press , new york , ny , usa , 2004 , pp .",
    "http://dx.doi.org/http://doi.acm.org/10.1145/996841.996869 [ ] .",
    "e.  yahav , verifying safety properties of concurrent java programs using 3-valued logic , in : popl 01 : proceedings of the 28th acm sigplan - sigact symposium on principles of programming languages , acm press , new york , ny , usa , 2001 , pp . 2740 . http://dx.doi.org/http://doi.acm.org/10.1145/360204.360206 [ ] ."
  ],
  "abstract_text": [
    "<S> a great variety of static analyses that compute safety properties of single - thread programs have now been developed . </S>",
    "<S> this paper presents a systematic method to extend a class of such static analyses , so that they handle programs with multiple posix - style threads . </S>",
    "<S> starting from a pragmatic operational semantics , we build a denotational semantics that expresses reasoning _  la _ assume - guarantee . the final algorithm </S>",
    "<S> is then derived by abstract interpretation . </S>",
    "<S> it analyses each thread in turn , propagating interferences between threads , in addition to other semantic information . the combinatorial explosion , ensued from the explicit consideration of all interleavings , is thus avoided . </S>",
    "<S> the worst case complexity is only increased by a factor @xmath0 compared to the single - thread case , where @xmath0 is the number of instructions in the program . </S>",
    "<S> we have implemented prototype tools , demonstrating the practicality of the approach . </S>"
  ]
}