{
  "article_text": [
    "standard software architectures tend to be too brittle , and typical software systems are of discrete nature and not sufficiently robust with respect to small changes .",
    "the ability to take linear combinations of execution runs allows one to change software in a continuous fashion . in this paper , we consider two classes of computations which admit taking linear combinations of execution runs : probabilistic sampling and generalized animation . because these two classes are both stream - based , dataflow programming is a natural programming paradigm for this situation .",
    "dataflow paradigm develops since at least early 1960s  @xcite .",
    "many dozens of text - based and visual programming dataflow systems have been created since then . for a very extensive and still incomplete overview of state of the field",
    "ten years ago see  @xcite .",
    "many dataflow programming systems are in active use today , and new dataflow programming systems keep emerging .    the descriptions of dataflow formalisms and syntax of visual dataflow programs are sometimes centered around transformations of data streams . during our experiments with prototype dataflow systems in this paper",
    "we found this practice to be inconvenient .",
    "we explored two alternatives .",
    "for the first - order dataflow programming we found it convenient to consider a formalism based on bipartite dataflow graphs with two kinds of vertices : nodes representing data streams and nodes representing transformations . under this approach ,",
    "the two kinds of nodes are equally important , and there is often a duality between them .    for the higher - order dataflow programming",
    ", we found it convenient to be able to copy subgraphs of a dataflow graph in meaningful ways , and for that it is convenient to take an approach centered around target nodes .",
    "so the datastreams take the central role under this approach , and transformations are made subordinate to the streams they produce .",
    "what we have described so far is applicable to any dataflow programming situations .",
    "the ability to take linear combinations comes into play because it enables the following sequence of reversible transformations .",
    "we start with the following two steps we call _ benign discontinuities_. first , we take a datastream node @xmath0 and replace it with nodes @xmath1 and @xmath2 connected by an identity transformation .",
    "node @xmath1 inherits from node @xmath0 its incoming links and their transformation .",
    "node @xmath2 inherits from node @xmath0 its outgoing links .",
    "second , we replace @xmath3 , with @xmath4 where @xmath5 , so a zero weight link from some node @xmath6 to @xmath2 is added . finally , we can continuously vary @xmath7 .",
    "we call this process of continuously varying linear coefficients in a dataflow graph punctuated by benign discontinuities at a discrete set of moments in time an _ almost continuous transformation_.    the goal of this paper is to give a detailed informal overview of this approach to dataflow graphs and to describe fluid  @xcite , an experimental open source system providing first - order and higher - order prototype implementations . a system like",
    "fluid should be applicable both to streams of probabilistic samples and streams of generalized images .",
    "the current prototype works with streams of ordinary images .",
    "it became apparent in our earlier work  @xcite that having an ability to consider linear combinations of execution runs should be conducive for program learning in the context of genetic programming and higher - order probabilistic sampling .",
    "it also became apparent to us that two major classes of computations with the ability to take linear combinations of execution runs , probabilistic sampling and generalized animations , are both stream - based , and hence it is natural to use dataflow architecture in this context .",
    "moreover , dataflow architecture is convenient in the context of program learning , because syntax of dataflow diagrams tends to be tied closer to their semantics than the syntax of programs in more conventional software architectures .",
    "this paper contributes the ability to almost continuously evolve dataflow programs while they are running .",
    "this makes it possible to sample almost continuous trajectories in the space of dataflow programs , in addition to the usual practice of sampling the program syntax trees , thus enabling us to try new evolutionary and probabilistic schemas for program learning .",
    "the paper is structured as follows .",
    "section  [ linear ] introduces both classes of stream - based computations admitting linear combinations of execution runs .",
    "this section also briefly describes context : the ability to take linear combinations should be quite useful , if one wants to enrich genetic programming with mechanisms inspired by regulation of levels of protein expression ; there are recent interesting advances in probabilistic programming within the higher - order  sampling the samplers \" paradigm ; and there are deep connections between the ability to have negative coefficients in linear models of computations and various mathematical motives which together constitute the so - called  partial inconsistency landscape \"  @xcite .",
    "section  [ first ] describes using bipartite graphs for the first - order dataflow programming and fluid implementation of this architecture .",
    "section  [ continuous ] describes the notion of almost continuous transformations of dataflow graphs and the resulting streams of dataflow graphs .",
    "the fluid implementation of this architecture is discussed .",
    "an important feature of this implementation is that the dataflow program in question is normally running as it changes in almost continuous fashion .",
    "we find ourselves in a situation where in addition to ordinary datastreams one has datastreams of dataflow graphs available .",
    "this opens a variety of possibilities for higher - order dataflow programming , some of which are discussed in section  [ higher ] .",
    "in this section we are briefly reviewing the relevant material from  @xcite .      here",
    "we are considering linear combinations @xmath8 , where @xmath9 .",
    "a generalized image is a set of points , together with any secondary structure on this set , and with points taking real values .",
    "an ordinary monochrome image corresponds to the situation when this secondary structure is a continuous or discrete rectangle , and for the color image one typically considers the cartesian product of this rectangle and the three - element set representing colors , @xmath10 .",
    "if two generalized images have the same secondary structure on their points , one can take convex linear combinations of those images point - wise .",
    "a generalized animation is a function from discrete or continuous time to generalized images with the same secondary structure .",
    "if two generalized animations have the same secondary structure for their images and are synchronized time - wise , one can take convex linear combinations of those animations by taking convex linear combinations of their images corresponding to the same point on the time axis .",
    "if two probabilistic samplers produce points independently sampled from distributions @xmath11 and @xmath12 at the rate of one sample per clock tick , one can obtain a sampler from the convex linear combination of these distributions by taking the latest sample from @xmath11 with probability @xmath13 and the latest sample from @xmath12 otherwise at each clock tick .      to quote from  @xcite :",
    "`` biological systems tend to be much more flexible and adaptive with respect to variation .",
    "in particular , biological cells are capable of functioning at wide ranges of the level of expressions of various proteins , which are machines working in parallel .",
    "regulation of the level of expression of specific proteins is a key element of flexibility of biological systems",
    ". it is argued in evolutionary developmental biology that the flexible architecture together with conservation of core mechanisms is crucial for the observed rate of biological evolution  @xcite .",
    "it is suggested that morphology evolves largely by altering the expression of functionally conserved proteins  @xcite . ''",
    "computational architectures which admit the notion of linear combination of execution runs with non - negative coefficients are particularly attractive in this sense",
    ". then one can regulate the system simply by controlling coefficients in a linear combination of its components , as computational equivalent of the level of expression of a particular protein .",
    "the term  higher - order probabilistic programming \" usually means a higher - order functional programming language implementing sampling semantics .",
    "we have recently seen examples of research implementing higher - order sampling schemas in a more narrow and focused sense of the word : samplers which generate other samplers , probabilistic programs sampling the space of probabilistic programs .",
    "in particular , one should mention the recent work on learning probabilistic programs by yura perov and frank wood  @xcite and recent advances in compositional concept learning obtained by brenden lake  @xcite ( see section 3 of  @xcite for the brief overview of these two sets of results ) .",
    "we ll return to these two possible ways to understand the notion of  higher - order programming \" for stream - based program architectures in section  [ higher ] .",
    "the availability of negation is not strictly necessary for the material of this paper .",
    "nevertheless , one often finds that the presence of negation ( that is , the ability to have negative coefficients in linear combinations ) is very useful computationally . for animations ,",
    "one simply sets zero at the appropriate gray level and uses the standard color inversion operation as negation ( we are using this operation in the fluid demo examples ) .    for probabilistic sampling , one needs to use two sampling channels , positive and negative , in order to implement negation .",
    "the formalism allowing negative probabilities is convenient for this situation .",
    "the ability to take negation is often closely linked with the ability to handle partial and graded contradictions ( see the material in  @xcite and references therein for more details ) .",
    "for a static dataflow graph , and assuming no need to manage subgraphs and make their copies , we found it convenient to use a bipartite dataflow graph model : two main types of nodes are data steams ( in this case , image streams ) and transforms . directed links can only go from data streams to transforms ( the case of data stream being a source for a transform ) , or from transforms to data streams ( target nodes for transforms ) .",
    "links from data streams to data streams , or from transforms to transforms are not allowed .    in a typical situation",
    ", many data streams can have links into the same transform , but a transform only generates one data stream .",
    "exceptions from this typical situation exist , nevertheless this points to a certain kind of duality : in a typical situation a data stream has one incoming graph edge and many outgoing graph edges , while a transform has many incoming graph edges and one outgoing graph edge .    invoking neural analogies ,",
    "a data stream is similar to an axon , and a transform is similar to a body of a neuron together with its dendrites .",
    "one often wants to modulate the transforms with the controls . one can think about controls as special kinds of data streams ( in a typical situation , the values stay constant until changed by a mouse click ) . unlike images , the amount of data in a control is usually small .    in this study , most dataflow computations",
    "are synchronous and are coordinated by global clock .",
    "the stream of values of global clock is a special type of control ( it is not clickable , but just advances at a constant rate ) .",
    "implementation of this architecture in fluid is rather straightforward : under 300 lines of code in processing  @xcite + about 70 lines of code for each of the example dataflow graphs ( see may_9_15_experiment subdirectory of the fluid project ) .",
    "the object oriented design of this experiment is as follows .",
    "the program @xmath11 is an object of masterconfig class , which is built during the initial setup .",
    "the work cycle of the program at every clock tick is as follows .",
    "first , the system draws all images registered with @xmath11 as outputs .",
    "then , the system applies all transforms registered with @xmath11 as transforms . finally , the system shifts the target instances of images into the source position for all data streams registered as ( dynamic ) data with @xmath11 . in this fashion , a new frame",
    "is produced for all dynamic data streams on each work cycle .",
    "images / data streams are of two types .",
    "datarectangle objects contain constant images , which can be used as sources for transforms ( and visualized if desired ) . in principle",
    ", nothing prevents us from adding input movies , but we have not done so for this experiment .",
    "the objects of class datarectangledynamic inherit from datarectangle , and also provide the target instances of images for the transforms to write to , and the ability to shift the target and source images on each step of the work cycle .",
    "transforms all inherit from the abstract class transform with the single method apply .",
    "three types of transforms turn out to be sufficient to provide rich behavior of the demos .",
    "the negation transform reads the image on top of the source stream and produces its color inversion on the output .",
    "the sum - of-2 transform reads images which are on top of its two source streams and produces on the output their convex sum , @xmath14 where @xmath9 . the value of @xmath7 is determined by the associated instance of numericcontrol , which tends to be located to the right of the drawing field of the image stream generated by the sum - of-2 transform in question .",
    "customwavetransform reads the image on the top of the source stream and produces an image on the output which can be thought of as a  reflection in a snapshot of a synthetic water wave \" .",
    "the parameters of this synthetic wave depend on the implicit global clock control framecount built into processing , and also on the values stored in the associated customclickcontrol .",
    "therefore , a wave transform takes an input stream of images and produces a stream of the reflections of the input stream in the moving waves ( no physical realism is attempted ) . the customclickcontrol associated with the wave simply uses the drawing field of the image stream generated by the wave transform in question in order to catch clicks .    upon click",
    ", the wave is effectively restarted in the position of the click as the new center , and the frame_count_base of the control is set to the current framecount ( the wave dynamics depends only on framecount - frame_count_base ) .",
    "all controls inherit from clickcontrol class and need to be registered with the program as controls in order to work .",
    "two examples of a first - order dataflow program are included in the subdirectory , one is based on a directed acyclic graph , and one contains a loop .",
    "a short video demonstrating work with the first of these examples is posted on youtube.com ( see the main page of the fluid repository  @xcite for details ) .",
    "in this study , we support  almost continuous evolution \" of dataflow graphs while they are running as programs . _ almost continuous evolution _ of dataflow graphs is understood as continuous evolution of their coefficients punctuated by _",
    "benign discontinuities _ at discrete moments of time .",
    "one type of benign discontinuity is creation of new dataflow circuits which do nt have outgoing links to the currently existing and running dataflow circuits and thus do nt affect the existing behavior ( unless the outside environment provides feedback based on the output of the program ) .",
    "we find it convenient to implement this type of benign discontinuity not by building new circuits vertex by vertex , but by copying the intact dataflow graphs and subgraphs ( see _ limited deep copy _ in section  [ limited_deep_copy ] below ) .",
    "it turns out the bipartite graph approach of the previous section makes it difficult to correctly identify and copy subgraphs .",
    "hence we adopt an entirely different architecture , which is grouped around the notion of _ dataflow vertex _ ( also known as _ target node _ ) , with necessary transforms , controls , references to sources , and associated datastreams all being subordinate to the target nodes they belong to .",
    "two other kinds of benign discontinuity mentioned in the introduction are combined into an _",
    "s - insert _ operation ( see section  [ special_insert ] below for details and discussion ) .",
    "all benign discontinuities described here are reversible , and it seems likely that one can almost continuously deform any dataflow graph into any other via these benign discontinuities , their reversals , and continuous changes of coefficients , as long as one type of data streams and a fixed set of built - in transform operations is used .      in this study , a _ dataflow program _",
    "@xmath11 is a finite collection of dataflow graphs , dataflow vertices , and data associated with dataflow vertices .",
    "this collection varies with time and is organized as folllows .    a _ dataflow graph _",
    "@xmath15 in @xmath11 consists of a finite , possibly empty collection @xmath16 of dataflow vertices in @xmath11 called _ immediate target nodes _ of @xmath15 and a finite , possibly empty collection @xmath17 of dataflow graphs in @xmath11 called _ immediate subgraphs _ of @xmath15 .    for each @xmath18 graph @xmath15",
    "is called a _ parent graph _ of @xmath19 . for each @xmath20 graph @xmath15",
    "is called a _ parent graph _ of @xmath21 . in this study",
    "we require that for every vertex @xmath19 in a given program @xmath11 there is one and only one parent graph in @xmath11 , and that for every dataflow graph @xmath15 in a given program @xmath11 there is no more than one parent graph in @xmath11 . a dataflow graph @xmath15 in @xmath11 which does not have a parent graph in @xmath11",
    "is called a _ top - level graph _ of @xmath11 .",
    "typically , exactly one of the top - level graphs of @xmath11 is called the _ main graph _ of @xmath11 and is executed , while it varies in time .",
    "a _ dataflow vertex _ @xmath19 in @xmath11 consists of a finite , possibly empty collection of references to other dataflow vertices in @xmath11 ( those references are called _ sources _ of @xmath19 ) , a structure representing _ data associated with _ @xmath19 , and a reference to its parent graph .",
    "the set of all vertices of a dataflow graph can be obtained by a recursively defined flattening operation , @xmath22 .",
    "the set of all vertices of a program is @xmath23 is a top - level graph of @xmath24 .    in the software implementation of this study , dataflow programs , dataflow graphs , and dataflow vertices",
    "are represented by classes programeditor , dataflowgraph , and dataflowvertex respectively .      a structure @xmath6 called _ data associated with a dataflow vertex _ in @xmath11 consists of the reference to the unique dataflow vertex @xmath19 containing @xmath6 , and the data itself . in the software implementation of this study ,",
    "data associated with a dataflow vertex are represented by subclasses of class vertexdata .    in this study ,",
    "the most important type of data associated with a dataflow vertex is a stream of images , which comes in several varieties .",
    "class vertexdataimage and its subclass vertexdataimagedynamic correspond to classes datarectangle and datarectangledynamic from section  [ first_fluid ] respectively . the three types of transforms described in section  [ first_fluid ] and their associated controls are now subclasses of datarectangledynamic .",
    "in section  [ higher ] , we also consider streams of dataflow graphs as data associated with a dataflow vertex .      _ limited deep copy _ of a dataflow graph @xmath15 in @xmath11 , where @xmath15 can be a top - level graph or a subgraph , is a dataflow graph @xmath25 in @xmath11 constructed by the following algorithm in the current implementation .",
    "@xmath25 can be added to @xmath11 as a top - level graph or as a subgraph to an existing dataflow graph in @xmath11 .",
    "@xmath25 is created as a recursive copy of @xmath15 , by recursive traversal of @xmath15 .",
    "structures for data associated with dataflow vertices of @xmath26 are copied , because the corresponding data streams in @xmath15 and @xmath25 might differ , so they need to be able to unfold in different memory spaces . for each dataflow vertex @xmath19 in @xmath26 , a forward reference to the correspondent @xmath27 in @xmath28",
    "is created .",
    "the source references of @xmath19 at this stage are copied intact into @xmath27 .",
    "source references of dataflow vertices of @xmath25 are updated , by recursive traversal of @xmath25 .",
    "if a vertex @xmath27 in @xmath28 has a source link to vertex @xmath29 , and if vertex @xmath29 has a forward reference to vertex @xmath30 , then this source link is set to point to @xmath30 .",
    "step 3 . the clean - up step .",
    "forward references set in step 1 are reset to null values , by recursive traversal of @xmath15 .",
    "the result is that the references to the sources external to @xmath15 are preserved in the newly created copies , the internal structure of @xmath15 including dataflow vertices , references to sources within @xmath26 , and the data associated with the dataflow vertices in @xmath26 are subject to the usual  deep copy \" procedures , and no outgoing external links from @xmath28 are created ( in the current implementation this is facilitated by the fact that all explicit links are from target nodes to their sources ; if a different implementation were to require explicit outgoing links , one would then need to take special care to only include internal outgoing links in the  deep copy \" and to omit the external outgoing links ) .",
    "we have described the following two _ benign discontinuities _ in the introduction .",
    "first , one takes a datastream node @xmath0 and replaces it with nodes @xmath1 and @xmath2 connected by an identity transformation .",
    "node @xmath1 inherits from node @xmath0 its incoming links and their transformation .",
    "node @xmath2 inherits from node @xmath0 its outgoing links .",
    "second , one replaces @xmath3 , with @xmath4 where @xmath5 , so a zero weight link from some node @xmath6 to @xmath2 is added .    _",
    "s - insert _ ( soft insert / special insert ) combines these two steps without going through the intermediate state of explicitly having @xmath3 configuration .",
    "the two main parameters of this operation are dataflow vertices target_vertex and side_vertex .",
    "first a dataflow vertex new_vertex is created and references to sources and to the parent graph are copied from target_vertex to new_vertex . then vertex data associated with target_vertex are _ moved _ to new_vertex .",
    "then target_vertex obtains two new sources , new_vertex and side_vertex , instead of its old sources .",
    "then new vertex data based on sum - of-2 transform is created for target_vertex and the coefficients of this transform are set in such a way that 1 corresponds to new_vertex and 0 corresponds to side_vertex .",
    "if the time step were infinitely small ( a system similar to differential equations ) , this transformation would not have any immediate effect on the dynamics , which is why we call it _",
    "benign discontinuity_. however , one should keep in mind that the replacement of node @xmath0 by @xmath3 actually introduces time delay of one clock tick here in our typical situation of discrete time .",
    "normally one would expect the effect of this extra time delay not to be too noticeable , but certainly there are some situations when precise synchronization might matter , and then the operation is no longer innocent .    the main effect of the _ s - insert _ operation is , however , that it enriches the space of possibilities to continuously change the system , by allowing us to continuously vary @xmath7 .",
    "implementation of this architecture in fluid is around 700 lines of code in processing ( see jun_21_15_experiment subdirectory of the fluid project ) .",
    "the setup of this experiment starts with the empty main graph ( program ) and two small _ template _ top - level graphs , each consisting of two nodes , a constant image node being a source for a transform node ( in one case , the negation transform node , in another case , the wave transform node ) .",
    "the work cycle at every clock tick consists of two steps .",
    "one is execution of the work cycle of the main graph ( which is well defined even when the main graph is empty and is similar to the work cycle described in section  [ first_fluid ] ) , and another is an optional transformation of a program by benign discontinuities ( in this experiment , this transformation is programmed in the tweak_optionally method of the programeditor class , eventually one should be able to also associate an edit control with the graph node containing the program itself ( see section  [ higher ] ) ) .    in this particular experiment , a limited deep copy of a wave",
    "transform _ template _ is added first , then while the program is running , a limited deep copy of the negation transform _ template _ is added at a later point , and then while the program is running , the s - insert is used to link the output of the copy of the wave transform template to the input of the copy of negation transform template .",
    "section  [ higher ] describes a follow - up experiment visualizing this program evolution ( see fig .",
    "1 ) .    while the program is running , one can also change wave parameters and linear coefficients by clicking on controls which are associated with the drawing fields of the respective target nodes in this experiment .",
    "those changes constitute more abrupt discontinuities , so strictly speaking when those happen , it s not almost continuous anymore .",
    "but they only affect the parameters of the transformations , not the structure of the program , so we still tend to consider them to be within this programming paradigm overall .",
    "there are two major classes of approaches to higher - order stream - based programming .",
    "one approach takes standard higher - order functional programming as a starting point , and focuses on integrating stream - based programming into the standard higher - order paradigm .",
    "the second approach takes the notion of streams of programs as its starting point and develops from there .",
    "the third approach which must be mentioned is an approach based on multidimensional streams  @xcite .",
    "this second approach is the one we are pursuing in this paper .",
    "we have already mentioned the dichotomy between the first two approaches in section  [ sampling_the_samplers ] for the case of probabilistic programming .",
    "the body of research on higher - order dataflow programming based on streams of functions is modest .",
    "an early work which should be mentioned in connection with this is the preprint  @xcite by the second author .",
    "there are recent related papers exploring various aspects of this approach , for example  @xcite .",
    "the previous section introduces streams of dataflow graphs which is the first step towards adopting this approach to higher - order dataflow programming for fluid .",
    "the next step is to include such streams of dataflow graphs as datastreams contained in the nodes of other dataflow graphs ( self - reference is , of course , possible and is a natural starting point as we ll see in a moment ) .",
    "pragmatically speaking , one needs to add the capabilities for imaging a dynamically changing dataflow graph , and it is desirable to enable the use of such an image as an edit control capable of editing the underlying dataflow program while it is running ( just like we use drawing fields of ordinary moving images as controls altering their dynamics in the examples above ) .",
    "it is easier to achieve those goals if one includes a node containing a reference to the main graph of the program into the main graph itself .",
    "our most recent experiment represents a partial step in this direction .",
    "a node containing a reference to the main graph of the program is included into the main graph itself , but this setup is only used to provide visualization of a dynamically evolving dataflow graph , there is no associated edit control yet ( see jun_28_15_experiment subdirectory of the fluid project ) .",
    "one starts with the main graph containing only the node containing a reference to the main graph itself , and then gradually adds functionality as in section  [ continuous_fluid ] . a short video demonstrating gradual evolution of this data flow program while it is running and being used in an interactive fashion is posted on youtube.com ( see the main page of the fluid repository  @xcite for the link to the video and see the legend included with the video for details ;",
    "see fig . 1 for a screenshot ) .",
    "[ bukatin_figure ]          this is a very modest start on the road towards real - life higher - order dataflow programming and program evolution involving streams of almost continuously changing programs .",
    "one would like the node containing a dataflow graph to depend on other nodes as sources .    then in a higher - order setting one",
    "could , for example , modulate the evolution and behavior of a stream of dataflow graphs by a moving image , etc .",
    "one circumstance to keep in mind is that in order to evolve a program while it is running , the changing program must inherit state from the earlier moments in time , just like it is done in section  [ continuous ] .",
    "this seems to imply that the node containing a dataflow graph must be one of its own sources .",
    "most of the formalism we described is applicable to any kind of streams .",
    "however , the ability to evolve streams of programs via almost continuous transformations requires the ability to take convex linear combinations of two streams . in the absence of such an ability , one might need to rely on discontinuous transformations , such as abrupt switching of a link from one source to another .    the ability to almost continuously evolve dataflow programs while they are running makes it possible to sample almost continuous trajectories in the space of dataflow programs",
    "this should allow us to try new evolutionary and probabilistic schemas for program learning .",
    "stream based architecture is conductive to various modalities such as audio streams , streams of text snippets , etc . , and also for streams of samples from probability distributions of arbitrarily structured objects .",
    "many of them , in particular audio steams and streams of probabilistic samples , admit convex linear combinations .",
    "the  code sensory modality \" ( see section 3.1 in  @xcite ) is the most fundamental one , since everything in the digital world is made from code .",
    "moving from discrete representations of code to streams of code , and , in particular , to almost continuous streams of code is likely to be fruitful in this context .",
    "wadge w. : higher - order lucid . in : jagannathan , r. ( ed . ) , proceedings of the 4th international symposium on lucid and intensional programming , sri international , menlo park , ca , usa april 29 - 30th , 1991 , pp.62 - 69 , http://www.cse.unsw.edu.au/~plaice/archive/www/1991/u-islip91-lucidhigher.pdf"
  ],
  "abstract_text": [
    "<S> we consider two classes of stream - based computations which admit taking linear combinations of execution runs : probabilistic sampling and generalized animation . </S>",
    "<S> the dataflow architecture is a natural platform for programming with streams . </S>",
    "<S> the presence of linear combinations allows us to introduce the notion of almost continuous transformation of dataflow graphs . </S>",
    "<S> we introduce a new approach to higher - order dataflow programming : a dynamic dataflow program is a stream of dataflow graphs evolving by almost continuous transformations . a dynamic dataflow program would typically run while it evolves . </S>",
    "<S> we introduce fluid , an experimental open source system for programming with dataflow graphs and almost continuous transformations . </S>"
  ]
}