{
  "article_text": [
    "efficient computing of x - ray ( and neutron ) scattering from crystals has been the subject of intense work since computers became available . except in the case of small structures ( @xmath21000 atoms ) or small number of reflections ( @xmath21000 ) , the method of choice has long been to use the fast - fourier transform @xcite of the crystal s scattering density . by computing this density inside the crystal s unit cell over a suitable grid @xcite , it is possible to compute structure factors at nodes of the reciprocal lattice .    in the case of strained @xcite or disordered @xcite crystals , the scattering must take into account a large part of the crystal ( or possibly the entire crystal ) instead of a single unit cell , in order to describe the departure from an infinite , triperiodic structure .",
    "this requires either using approximations , or a large computing power .",
    "moreover , both strain and disorder lead to non - discrete scattering , so that the scattered amplitude must be evaluated on a fine grid around or between bragg diffraction peaks .",
    "this type of computations can greatly benefit from fast calculations , which we will present in this paper .",
    "this article is organized as follows : in section [ secscattering ] we describe the formulas used for computing the scattering from an atomistic model , how it can be efficiently computed using a graphical processing unit ( gpu ) , and what performance can be achieved . in section [ secpynx ] we present the open - source package pynx which can be used to easily compute scattering with little programming knowledge . in section [ secapplication ]",
    "a few examples are given .",
    "x - ray and neutron scattering can generally be calculated , in the kinematic approximation , as : @xmath3\\ ] ] where @xmath4 is the scattered amplitude , @xmath5 is the scattering vector , @xmath6 represents the scattering density ( electronic or nuclear ) at position @xmath7 inside the crystal , and @xmath8 denotes the fourier transform .",
    "this equation can be used to determine the scattering from a crystal as long as @xmath6 is described on a grid fine enough to resolve the atomic positions , which is easy if the crystal can be described from a single unit cell .    in the case of an aperiodic object ( crystal with an inhomogeneous strain or disordered ) , it is simpler to compute the scattering from an atomistic model , which can be obtained using reverse monte - carlo @xcite , atomic potentials combined with molecular dynamics or a direct minimization of the crystal energy @xcite .",
    "the scattered amplitude is then derived from the atomic positions :    @xmath9    where @xmath10 is the scattering length ( either the thomson scattering factor for x - rays or the nuclear scattering length for neutrons ) of atom @xmath11 and @xmath12 its position .",
    "the number of floating - point operations ( @xmath13 ) required to evaluate equation ( [ eqn : eqnscattatoms ] ) is approximately equal ( see section [ secimplemgpu ] ) to : @xmath14    for a structure with @xmath15 ( e.g. a cube of silicon of @xmath16 ) and @xmath17 points in reciprocal space , this corresponds to @xmath18 , which can be compared to the current computing power of today s consumer micro - processors of @xmath19 per core .    in the case of large nano ( and micro)-structures , for which the description of the atomic structure is not possible in practice , a model based on continuum elasticity can be used , either with an analytical or numerical approach ( see and references within ) .",
    "the most popular method in the case of epitaxial nanostructures currently is the finite element method- see for a recent discussion .",
    "this model can then be used to calculate the scattering using groups of atoms : @xmath20 where @xmath21 is the structure factor for the @xmath22 block of atoms ( generally a group of unit cells ) , @xmath23 its original position , and @xmath24 its displacement from the ideal structure .",
    "assuming that all blocks of atoms are identical and on a triperiodic grid , it is possible to rewrite eqn .",
    "[ eqn : eqnscattblock ] as : @xmath25\\ ] ] where @xmath26 denotes the bragg peak position around which the calculation is made , @xmath27 is the structure factor calculated for a block of atoms , and @xmath28 the displacement field inside the crystal .    if the composition of the blocks of atoms vary ( e.g. due to interdiffusion ) , it is also possible to include a variation of the average scattering density in the @xmath8 @xcite : @xmath29\\ ] ]    where @xmath30 is the relative scattering density in the crystal .",
    "both equation ( [ eqn : eqnscattblockft ] ) and ( [ eqn : eqnrhoftdispl ] ) allow the use of a _ fast _ fourier transform , but are only valid as long as : @xmath31    moreover , use of equations ( [ eqn : eqnscattblockft ] ) and ( [ eqn : eqnrhoftdispl ] ) with a _",
    "fast _ fourier transform restricts the computation of scattering on a triperiodic grid in reciprocal space - this is a limitation since modern data collection often use 2d detectors , and the measured points in reciprocal space are located on a _ curved _ surface ( the projection of the detector on ewald s sphere ) .",
    "furthermore , as the resolution in reciprocal space is inversely proportional to the size in real space , analysis of high - resolution data using a fft calculation demands a large model - even if the extent in reciprocal space is very limited .",
    "therefore , even if the speed of the fft is optimal for large crystalline structures - for @xmath32 points in real space , @xmath32 points in reciprocal space are calculated with a cost proportional to @xmath33 instead of @xmath34 - it is still interesting to consider a _",
    "direct _ computation using equation ( [ eqn : eqnscattatoms ] ) or ( [ eqn : eqnscattblock ] ) because it allows computation for :    * _ any _ assembly of points in reciprocal space * from _ any _ structural model ( no matter how severely distorted or disordered )      in order to achieve the calculations in a reasonable time , it is useful to consider current graphics cards as general - purpose gpu . this has already been reported in the scope of crystallography , for computing scattering maps from disordered crystals @xcite , powder pattern computing using the debye equation @xcite , and for single - particle electron microscopy @xcite .    to summarize basic principles behind gpu computing ,",
    "it is possible to accelerate any calculation provided that :    1 .",
    "it is * highly parallel * , _ i.e. _ the same formula must be applied on large amounts of data , independently 2 .",
    "the number of * memory * transfers required is much smaller than the number of mathematical operations 3 .",
    "the calculation pathway is determined in advance ( at compilation time ) , which excludes any _ if ... then ... else _ operation in the inner computation loop    moreover , many classical functions ( e.g. : @xmath35 , @xmath36 , @xmath37 , fused @xmath38 evaluation , ... ) are highly optimized on gpus - an algorithm requiring many such operations will be greatly accelerated .",
    "equation ( [ eqn : eqnscattatoms ] ) fulfills all requirements , assuming that both the number of atoms and the number of points in reciprocal space are large ( @xmath391000 ) .",
    "[ figspeed ]   indicates the number of reflections for the gpu calculations ( black lines ) .",
    "the cpu ( central processing unit ) curves ( red lines ) correspond to a computing using a vectorized ( sse - optimized ) c++ code running on a _ single _ core of an intel core2 quad q9550 running at 2.83 ghz , for @xmath40 ( the curves for @xmath41 and @xmath42 are almost identical).,title=\"fig:\",scaledwidth=95.0% ]    the implementation presented in this article uses the cuda @xcite toolkit .",
    "it is beyond the scope of this article to detail the exact algorithm used for computation , as the implementation is freely available as an open - source project ( see section [ secpynx ] ) .",
    "however , it should be noted that the calculations are made in parallel for all reflections , with the atomic coordinates shared between parallel threads ( to minimize memory transfers ) - this method is optimal for large number of atoms . for some configurations ( large number of reflections and small number of atoms ) , it may be more optimal to parallelize on the atoms and share the reflection coordinates between parallel processes .",
    "the achieved speed is shown in fig .",
    "[ figspeed ] , for a calculation of scattering for a random list of points in reciprocal space , and random coordinates for the atoms - the occupancy of all atoms is assumed in this test to be equal to 1 , and the atomic scattering factor is not evaluated- in practice the atomic scattering factors can be factorized and represent a negligible amount of computing ( see section [ sec : secexampleinas ] ) - the same is true for debye - waller factors .    as can be seen in fig .",
    "[ figspeed ] , there is a strong dependence of the speed with the number of reflections and the number of atoms per second - the maximum speed ( @xmath43 ) is only reached if both numbers are larger than @xmath42 .",
    "each couple ( reflection , atom ) corresponds to 8 floating - point operations ( 3 multiplications , 4 additions , one @xmath44 evaluation ) operation is hardware - accelerated , it is 4 to 8 times slower than a simple addition . if the @xmath44 evaluation is counted as 4 @xmath13 , the achieved speed is @xmath45500 @xmath46 . ] , so that the overall speed is equal to @xmath45367 @xmath46 .",
    "this can be compared to the peak theoretical speed of 1.7 @xmath47 for this graphics card , which is only achieved when using fused add - multiply operations , without any bottleneck due to memory transfers .    by comparison , when computing on the cpu ( see fig .",
    "[ figspeed ] ) , the maximum speed is reached sooner : for 100 atoms and @xmath481000 reflections , or for @xmath481000 atoms when using @xmath48100 reflections .",
    "the top speed for a _ single _ core ( intel core2 quad q9550 running at 2.83 ghz ) , using sse - vectorized sine and cosine functions @xcite , is @xmath49 - @xmath45380 times slower than the gpu version .",
    "un_-optimized ( without using sse code ) c++ code runs about 3 times slower , or @xmath451000 times slower than the gpu version .",
    "using multiple cores , the speed increases linearly ( except for small number of atoms ) with the number of cores .",
    "as was already pointed out by , accuracy is an important issue since gpus are most efficient when using single precision floating - point operations .",
    "moreover , the accuracy of operations can be slightly relaxed @xcite compared to ieee standards @xcite .    for example , since single - precision floating - point use 24 bits mantissa ( _ i.e. _ a relative accuracy of @xmath50 ) , precision may be expected to become problematic when the total scattered amplitude varies on more than 7 orders of magnitude .    a simple test can be made : computing the scattering for a linear , perfectly periodic chain of identical atoms , and comparing it to the analytical formula : @xmath51 ( where @xmath52 is the reciprocal lattice unit and @xmath32 the number of atoms in the chain ) .",
    "this is shown in fig.[figaccuracy ] , for chains of atoms of different lengths .",
    "the discrepancy between the analytical calculation and the single - precision gpu calculation is clearly visible in the regions where the intensity is minimal - however in practice , the dynamic range where the calculation is reliable is always larger than @xmath53 , and most of the time ( @xmath54 of the points ) around @xmath55 - these numbers refer to the intensity ( squared modulus of the scattered amplitude ) .",
    "[ figaccuracy ]     ( b ) @xmath42 and ( c ) @xmath56 atoms , using a perfectly periodic chain calculated using the gpu ( black line ) , the analytical model ( red line ) , and for a chain where the atoms are randomly displaced with a gaussian distribution with a standard deviation of @xmath57 ( gray line ) .",
    "the atoms where located at @xmath58 , and the h coordinates are located every 0.001 in reciprocal lattice units ( r.l.u.).,scaledwidth=95.0% ]    such a dynamic range should be sufficient for most applications , as the practical range for experimentally measured intensities is usually lower , except in the case of perfect crystals . in fig.[figaccuracy ] a gray curve is superposed to the simulations , and corresponds to the gpu calculation for a chain of atoms with random displacements with a gaussian standard deviation of @xmath57 of their fractional coordinate . the error due to",
    "the single - precision computing is generally lower than the noise level represented by the gray curve .",
    "we have found that errors due to single precision floating point calculations were not significant _ in practice _ : indeed , most of the time structural models for which this type of computation is used are not ideal ( see examples of simulated calculations using our code in and ) and therefore do not present a very large dynamic range ( larger than 8 orders of magnitude ) .",
    "it should however be noted that gpus can also perform calculations using double precision floating point , but with a lower performance , as the number of available processing units are generally smaller ( 8 times in the case of cuda graphics cards with capability less than 2.0 @xcite ) than for single precision calculations .",
    "more recent graphics cards ( available since mid-2010 ) , using the fermi architecture ( ` http://www.nvidia.com/object/fermi_architecture.html ` ) provide a higher computing power dedicated to double - precision computing ( about half the speed of single - precision ) .",
    "writing programs using gpu computing is a relatively complex process , as it is necessary to fine - tune the algorithm , notably in order to optimize memory transfers - which can make a very significant difference in terms of performance .",
    "for example an early version of the presented algorithm did not perform in a synchronized way between parallel computing threads , and its performance was @xmath59 slower than the final algorithm used .",
    "moreover , all data has to be allocated both in the computer s main memory as well as on the graphics card , which can be tedious to write .    for this reason",
    ", we have written an open - source library , pynx `` python tools for nanostructure xtallography '' , using the python language .",
    "the main features of this software package are the following :    * computing of scattering for a given list of atomic positions and points in reciprocal space does not require _ any _ gpu - computing knowledge * it is possible to input either a list of @xmath60 coordinates , or also include their occupancy @xmath61 * the shape and order of the @xmath60 and @xmath62 coordinates ( i.e. 1d , 2d or 3d , sorted or not ) is irrelevant - all calculations are made _ in fine _ on 1d vectors * the computation can be distributed on several gpus - e.g. such cards as nvidia s gtx 295 are seen as two independent gpu units - the calculation is distributed transparently over the two gpu * a pure sse - optimized cpu computation is also available when no gpu is available , and can take advantage of all the computing cores available .",
    "three modules are available :    * ` pynx.gpu ` , which is the main module allowing fast , parallel computation of @xmath63 , either using a gpu or the cpu * ` pynx.fthomson ` , which gives access to the analytic approximation for the x - ray atomic scattering factors @xcite extracted from the cctbx library @xcite * ` pynx.gid ` , which provides transmission and reflection coefficients at an interface @xcite , which is required for grazing incidence diffraction analysis @xcite using the distorted wave born approximation ( dwba ) , as is demonstrated in section [ sec : dwba ] .",
    "[ figstrainedcube ]    .",
    "intensities are color - coded on a logarithmic scale.,scaledwidth=95.0% ]    to compute the scattering around the @xmath65 reflection of a simple cubic structure with a lateral size of 100 unit cells , the following code is used :    .... # import libraries from numpy import arange , float32,newaxis , log10,abs from pynx import gpu    # create array of 3d coordinates , 100x100x100 cells x = arange(-50,50,dtype = float32 ) y = arange(-50,50,dtype = float32)[:,newaxis ] z = arange(0,100,dtype = float32)[:,newaxis , newaxis ]    # hkl coordinates as a 2d array h = arange(-.1,.1,0.001 ) k=0 l = arange(3.9,4.1,0.001)[:,newaxis ]    # the actual computation fhkl , dt = gpu.fhkl_thread(h , k , l , x , y , z , gpu_name=\"295 \" )    # display using matplotlib from pylab import imshow imshow(log10(abs(fhkl)**2),vmin=0 ,     extent=(-.1,.1,3.9,4.1 ) ) ....    in this example , the calculation takes 0.93s on a gtx 295 graphics card .",
    "the library used for graphics display is matplotlib ( http://matplotlib.sourceforge.net/ ) .    of course scattering from this cube",
    "could be calculated analytically - if we introduce a simple displacement field in the z - direction : @xmath66 , the following line can be inserted after the `` ` z = arange ... ` '' instruction :    .... z = z+1e-6*z*(x**2+y**2 ) ....    the computed diffraction map is shown in fig.[figstrainedcube ] .      in the previous example , the atomic scattering factor is not taken into account - since this factor is the same for all atoms of the same type , it is easy to group all atoms of the same type together and calculate first @xmath63 , and then multiply it by the value of the atomic scattering factor dependent on the position in reciprocal space ( and the energy if anomalous scattering terms are to be taken into account ) , as well as the debye - waller factor .",
    "these atomic scattering factors can be extracted from the ` pynx.fthomson ` module .",
    "let us consider an inas nano - structure , for which we have atomic coordinates in separate files ` in.dat ` and `",
    "as.dat ` , each file having 3 columns corresponding to the x , y , z orthonormal coordinates ( in nanometers ) .",
    "the scattering around reflection @xmath65 for this data can be calculated in the following way ( the f and f \" resonant terms were taken manually from the cctbx library @xcite ) :    .... # import libraries from numpy import arange , newaxis , sqrt , abs , loadtxt from pynx import gpu , fthomson    # hkl coordinates as a 2d array h = arange(-.1,.1,0.001 ) k=0 l = arange(3.9,4.1,0.001)[:,newaxis ]    # load orthonormal coordinates xas , yas , zas = loadtxt(\"as.dat\",unpack = true ) xin , yin , zin = loadtxt(\"in.dat\",unpack = true )    # convert to fractional coordinates xas/=.6036 yas/=.6036 zas/=.6036 xin/=.6036 yin/=.6036 zin/=.6036    # compute scattering fhklin , dt = gpu.fhkl_thread(h , k , l , xin , yin , zin ,                            gpu_name=\"295 \" ) fhklas , dt = gpu.fhkl_thread(h , k , l , xas , yas , zas ,                            gpu_name=\"295 \" )    # apply scattering factors at 10kev s=6.036/sqrt(h**2+k**2+l**2 )   fas = fthomson.fthomson(s,\"as\")-1.64 + 0.70j fin = fthomson.fthomson(s,\"in\")+0.09 + 3.47j    # full structure factor fhkl = fhklas*fas + fhklin*fin ....      a specific module ( ` pynx.gid ` ) is available for grazing incidence diffraction - this module allows to compute the complex refraction index of a crystalline material ( the substrate ) and determine the reflection and transmission coefficients at the interface @xcite .",
    "it is therefore possible to simulate grazing incidence x - ray scattering using the dwba approximation , by taking into account the reflections before and after diffraction by the object at the surface , which influence the shape of the scattering in reciprocal space @xcite .    in fig.[figdwba ]",
    "is shown the simulated scattering for a germanium quantum dot on a silicon substrate .",
    "for the sake of demonstrating the use of pynx , a simple analytical model is used :    * the quantum dot shape corresponds to a portion of a sphere , with a radius equal to 50 unit cells and a height of 20 unit cells . *",
    "the germanium content varies linearly from @xmath67 ( bottom ) to @xmath68 ( top ) * the relaxation ( x , y , z being the fractional coordinates relative to the silicon substrate lattice ) are : + @xmath69    moreover , in this example only the scattering from the quantum dot is calculated , ignoring any contribution from the substrate .",
    "the corresponding script is provided as a supplementary file . a more complete description of the scattering , taking into account scattering from the ( strained ) substrate @xcite ,",
    "could also be added in the future .",
    "[ figdwba ]     reflection , and is plotted against @xmath52 ( reciprocal lattice unit ) and the outgoing angle @xmath70 .",
    "the location ( outgoing angle ) of the intensity maximum as a function of @xmath52 varies as the in - plane strain changes with the height of the corresponding layer in the dot , due to interferences between the four scattered beams @xcite .",
    "see text for details.,scaledwidth=95.0% ]",
    "the pynx library is freely available from the project website at : http://pynx.sourceforge.net .",
    "it is open - source software , distributed under the cecill - b license ( http://www.cecill.info/index.en.html ) , a permissive license similar to the freebsd license .    although this library has been developed and tested only under linux , it should work on any operating system ( including macos x and windows ) supported by the pycuda @xcite library .",
    "it has been tested on a variety of graphics card ( 9600 gt , gtx 295 , 8800 gtx ) .",
    "although it is recommended to use a dedicated graphics card ( not used for display ) for gpu computing , it is not a requirement - the library automatically cuts the number of atoms in order to decompose the calculation in batches which last less than 5s ( a limit imposed by the cuda library for graphics cards attached to a display ) . and",
    "it is also possible to use the cpu for calculations .",
    "this library uses the scipy ( http://www.scipy.org ) and pycuda @xcite libraries , and optionally the cctbx @xcite to determine the refraction index for the computing of transmission and reflection coefficients for grazing incidence x - ray scattering .",
    "the main interest from this computing project is the ability to compute scattering for non - ideal structures without any approximation .",
    "this is particularly important for strained nano - structures where the calculation often uses a fast fourier transform approximation , even though the displacements from the ideal structure are large .",
    "this could also be useful for coherent diffraction imaging in bragg condition for strained nano - structures @xcite , especially in order to extend this method to severely distorted lattices ( e.g. near an epitaxial interface with dislocations , a grain boundary , ... ) .",
    "a current limitation of this project is related to the toolkit used - the cuda development package is the most popular gpu computing tool available at the moment , but it depends on a single manufacturer , and remains proprietary . an important development in that regard is the creation of the opencl language ( http://www.khronos.org/opencl/ ) , which is intended to allow gpu - computing _ independently of the graphics card_. a future implementation of the proposed algorithm could use opencl and ensure its usability on a larger range of computing equipment ."
  ],
  "abstract_text": [
    "<S> scattering maps from strained or disordered nano - structures around a bragg reflection can either be computed quickly using approximations and a ( fast ) fourier transform , or using individual atomic positions . in this article </S>",
    "<S> we show that it is possible to compute up to @xmath0 @xmath1 using a single graphics card , and we evaluate how this speed depends on number of atoms and points in reciprocal space . </S>",
    "<S> an open - source software library ( pynx ) allowing easy scattering computations ( including grazing incidence conditions ) in the python language is described , with examples of scattering from non - ideal nanostructures .    </S>",
    "<S> coraux    richard    renevier    scattering calculations from atomistic models using graphical processing units are presented , and compared to the speed achieved using normal cpu calculations . an open - source software toolbox ( pynx ) is presented , with a few examples showing the fast calculation of scattering maps from strained nanostructures , including grazing - incidence conditions . </S>"
  ]
}