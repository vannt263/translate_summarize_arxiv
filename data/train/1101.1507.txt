{
  "article_text": [
    "combinatorial games are perfect - information games played between two players .",
    "the game proceeds by alternating turns where each player makes one move . under normal play ,",
    "the last player to make a move wins ( if you ca nt make a move , you lose the game ) .",
    "a game ruleset is the description of the moves (  options \" ) available to each player from a given position .",
    "all rulesets studied in this paper are _ impartial _ , meaning that at any state , both players always have the same move options .",
    "thus , the identities of the players do not matter as far as strategies are concerned . with impartial game rules ,",
    "game states ( or `` positions '' ) fall into one of two categories : and . ,",
    "or `` zero '' , is the class of positions where the previous player has a winning strategy ( the next player then does not ) . , or",
    "`` fuzzy '' games are the opposite : the next player does have a winning strategy from positions in this class .",
    "the `` success '' of a combinatorial game ruleset is partially dependent on the difficulty of the game : given a position , how hard is it to determine which player has a winning strategy , i.e. , is that position in a or position ?",
    "luckily , we can use a tool in computer science to help answer this question .",
    "computational complexity is a worst - case description of the amount of time ( or other resources ) required for an algorithm to solve a problem .",
    "some problems do not have a known  efficient \" algorithm and many of these are categorized into a hierarchy of partially - ordered complexity classes ( , , , , etc . ) .",
    "for example , we know that the hardest problems in ( known as -complete ) are at least as difficult as the hardest in ( -complete ) . although it is not known whether problems in these classes can be efficiently solved , at the time of this writing no such algorithm has been discovered , and these classes provide a suitable metric for determining the difficulty of evaluating the outcome class of a game position .    in this paper , we show that is a -hard ruleset , meaning it is at least as hard to solve as any problem in . to do this",
    ", we will show that any other problem in can be rewritten as an equivalent instance of .",
    "thus , if an efficient solution to exists , that algorithm can be used to solve any other problem in . since there are other known -hard problems , it is sufficient to show a reduction from only one of those",
    "this reduction is described in section [ section : hardness ] .",
    "all of the assertions above forgive a polynomial quantity . to learn more about this and algorithmic combinatiorial game theory , see @xcite .",
    "[ [ section ] ]    is an impartial game played on a collection of piles (  heaps \" ) , each with a non - negative number of  sticks \" . on a player s turn ,",
    "they choose a non - empty pile and remove as many sticks as desired ( at least one ) from that one pile .",
    "a player loses when they have no non - empty piles to choose from .",
    "the game of is the classic impartial game , being the basis of nimbers and sprague - grundy theory@xcite@xcite . has a simple definition and lots of nice properties , from easy evaluation of games to obvious composition of two games ( the sum is just a new game ) .",
    "[ [ section-1 ] ]    has been extended to incorporate graphs so that nim heaps are assigned to either edges or vertices .",
    "there are three different versions of the game named . in all three versions ,",
    "a turn consists of both traversing an edge of the graph and removing sticks from a visited element .",
    "fukuyama describes where nim heaps are embedded into the edges of the graph@xcite . on each turn",
    ", the current player chooses an edge to traverse ( which has at least 1 stick on it ) and removes any number of sticks from that edge .",
    "the next player then starts on the vertex on the other end of that edge and must choose an adjacent edge for their move . when there are no more edges with sticks adjacent to the current vertex , the current player loses .",
    "this game continues to be studied , with recent results on complete graphs@xcite .    in 2004 , stockman studied as part of an reu@xcite . here",
    "players similarly move from one vertex to another , but heaps are connected to the vertices instead of edges .",
    "the two variants can be easily described here as : `` remove sticks , then move '' and `` move , then remove sticks '' . in both cases ,",
    "a player loses if they can not complete their turn .",
    "we begin by presenting some notation used throughout the paper .",
    "a game _ position _ is a description of a game state .    rigorously speaking , a _ ruleset _",
    "is a function from positions to sets of positions , describing the move options for either player .",
    "since all rulesets studied here are impartial , the range of all rulesets will be the power set of positions .",
    "often , the word , _ game _ , is overloaded to refer either to a position or a ruleset .",
    "this happens in this work as well , though the context should clarify the meaning .",
    "we use the word _ sticks _ to refer to the objects in nim heaps .",
    "thus , a nim heap of size six contains six sticks .",
    "an _ optimal sequence set _ is a set of sequences of plays for both players such that any move deviating from one of the sequences results in an -position .",
    "no move in that sequence should be non - optimal for either player .",
    "thus , if a player does not know whether they have a winning strategy , adhering to an optimal sequence is at least as good as any other move .",
    "[ [ section-2 ] ]    we define the ruleset to be similar to the `` move then remove '' version of , but also allow players to choose to play on the same vertex as the last move as though each vertex has a self - loop .",
    "note that standard is equivalent to a game of on a complete graph with each heap on a separate vertex .",
    "@xmath2 given an undirected graph , @xmath3 and weights on the vertices @xmath4 , _ _ is the ruleset where a move is made by choosing a vertex , @xmath5 , where @xmath6 and reducing the weight of that vertex .",
    "if there was a previous move ( in all but the first move ) at vertex @xmath7 , then @xmath5 must be chosen so that either @xmath8 or @xmath5 neighbors @xmath7 .",
    "( meaning , @xmath9 or @xmath10 ) .",
    "our main result for this paper is that this game is -hard .",
    "since our analysis uses graphs with a small number of sticks on each vertex , we define a version of the game with a bounded number of sticks per vertex .",
    "@xmath11 _ _ is the same ruleset as , except that the weight function @xmath12 has bounded range : @xmath13 $ ] .",
    "we are able to show that is -complete , and thus is also -complete for any constant @xmath14 .",
    "the case for is solvable in polynomial time , since this game is equivalent to @xcite .",
    "thus , if @xmath15 , allowing a second stick on some vertex - heaps can greatly increase the computational hardness of determining the winning player .",
    "consider the problem of deciding who can win a game of :    @xmath11 is the problem of determining whether the current player has a winning strategy in a given game of .",
    "this is equivalent to determining whether the current position is in or .",
    "the following is the main result of this paper .",
    "is -hard .",
    "we will show the hardness of this problem by reducing from the game problem , which is -hard@xcite .",
    "given any position , we will give an algorithm to construct an equivalent state , meaning that there is a win in the position exactly when there is a win in corresponding position .",
    "first we will describe the method for generating these positions , then prove their equivalence .",
    "let @xmath16 be a position on the directed and unweighted graph @xmath17 .",
    "we define a new undirected graph , @xmath18 with weights on the vertices @xmath19 in the following way .",
    "@xmath20 let @xmath21 and set @xmath22 .",
    "also , @xmath23 ( edge directed from @xmath24 to @xmath25 ) let @xmath26 where , ignoring the @xmath27-subscripts , @xmath28 , @xmath29 and ,    @xmath30 .",
    "see figure [ fig : edgereduction ] for a visual description .",
    "the resulting @xmath31 is the graph for our position equivalent to @xmath16 .",
    "the only final step is to declare that if @xmath16 has a starting vertex , @xmath5 , then @xmath21 is the starting vertex ( where the previous play had been made ) in our game and @xmath32 is set to 0 instead of 1 .    to complete the reduction",
    ", we must show that the structure in figure [ fig : edgereduction ] `` acts '' like a directed edge in .",
    "thus , we must prove :    * moving `` backwards '' is a losing play .",
    "if the previous play was at @xmath33 , then a backwards play would be to remove the only stick at @xmath34 . a backwards play results in an @xmath35-position .",
    "* the same player moving into the gadget should also move out .",
    "if a player moves from @xmath36 to @xmath37 , then in an optimal sequence of plays , the same player will move from @xmath34 to @xmath38 .",
    "we prove the former in lemma [ lemma : dontgobackwards ] and the latter in lemma [ lemma : sticktothescript ] .",
    "the result is that each of these gadgets ( as in figure [ fig : edgereduction ] ) in the position works just like a ( directed ) edge in . trying to go backwards will result in losing and , if players play optimally , they both might as well continue through each gadget .",
    "[ lemma : dontgobackwards ] any play from @xmath39 to @xmath34 ( for all @xmath24 ) results in an @xmath35-position .",
    "( see appendix [ appendix : dontgobackwards ] for a proof of this claim . )",
    "this implies that our gadgets are directed : if a player tries to go `` backwards '' : from an @xmath40-vertex to an @xmath41-vertex , the opponent will have a winning strategy .    to finish showing that our gadget acts like a directed edge",
    ", we must prove that `` nothing can go wrong '' during a regular forward traversal of the structure . to this end , we find two sequences that constitute an optimal sequence set through the gadget , thus showing that neither player benefits from deviating from the sequence . in order to get from one end of the gadget ( as in figure [ fig : edgereduction ] ) to the other , the following sequence of moves suffices ( let alice and bob be our two players ; we will again ignore subscripts ) : alice `` takes '' @xmath42 , bob takes @xmath43 , alice takes @xmath44 , bob takes @xmath45 , alice decrements @xmath46 by 1 , bob takes @xmath47 , alice takes @xmath38 .",
    "note that the same player ( in this example , alice ) who chooses to take @xmath42 also moves to @xmath38 .",
    "the other sequence is where bob takes @xmath48 instead of @xmath47here alice will take the remaining object at @xmath46 and bob will be forced to take @xmath47 , rejoining with the first sequence .",
    "see figure [ fig : safesequence ] for a visual description of the safe sequences .",
    "we must prove that neither player benefits from deviating from these sequences . to do this , we show that any deviation is a losing move .",
    "[ lemma : sticktothescript ] let the notation @xmath49 denote taking @xmath50 objects from vertex @xmath51 in a turn . then , after the plays @xmath52 any play deviating from the following sequences is a losing move : + @xmath53 + @xmath54 .",
    "( see appendix [ appendix : sticktothescript ] for the proof of this claim . )",
    "this implies that once a player makes an appropraite move onto the gadget ( playing on an @xmath42-node ) any `` safe '' sequence of moves in the gadget results in that same player making the play at the opposite @xmath40 node .",
    "the two above claims combined show that our gadget correctly models a directed edge in a graph just between the @xmath40 nodes .",
    "thus , for any edge @xmath27 in our position , @xmath16 , the move to @xmath55 will result in the same player moving to @xmath38 as desired . also , since we proved players should nt go backwards , this game is equivalent to @xmath16 ; the first player has a winning strategy in @xmath16 exactly when the first player has a winning strategy in this position .",
    "thus , is -hard .",
    "unfortunately , is not automatically -complete as games could have a number of moves exponential in the size of the description of the game .",
    "for example , a vertex can have a number of sticks exponential in the amount of bits needed to express that number and the rest of the graph .",
    "we leave this as an open problem .",
    "[ open : inpspace ] is in",
    "?    we can sidestep this problem a bit by using our bounded - sticks version of the game .",
    "first , let s define the problem .",
    "@xmath11 is the problem of determining whether the current player has a winning strategy in a game of .    for any constant @xmath51 ,",
    "we note that our reduction for general has a maximum weight of 2 , and thus works for any game where @xmath56 .",
    "this leads to our completeness result .",
    "@xmath11 is -complete for any @xmath56 .",
    "building on algorithmic work analyzing different versions on , we present , a new -hard game .",
    "an interesting aspect of the hardness of is the juxtaposition with .",
    "is the same ruleset as , which is solvable efficiently@xcite .",
    "however , by adding an extra stick to just a few vertices , we can push the game into -hardness !    additionally , we see that we can use this graph - embedding technique with games other than . given a graph ,",
    "assign different game states to the vertices , and use similar rules : players may make one move legal in the game in any vertex neighboring the last play . for any game which has instances equivalent to @xmath1 and @xmath0 , the `` neighboring''-version of that game is hard , using an analogous construction to the one specific to . with this",
    ", we have our main result .    for any two game positions , @xmath57 and @xmath58 , with values @xmath0 and @xmath1 ,",
    "respectively , we can define a new ruleset , , which is -complete .",
    "note that we are not restricted to adding instances of the same game .",
    "this is a general method for adding games together ; the standard ( disjunctive ) sum of @xmath59 games here is equivalent to the `` neighboring''-version played on the complete graph with @xmath59 vertices .",
    "the authors would like to thank those who played with them , including three excellent wittenberg students : deanna fink , dang mai and ernie heyder , as well as professor doug andrews who defeated the first author over and over again .",
    "we would also like to thank adam parker for listening to initial versions of the hardness proof as well as proofreading this paper .",
    "1    lindsay erickson .",
    "nim on complete graphs .",
    "ars combinatoria , accepted for publication in 2009 .",
    "aviezri  s. fraenkel , edward  r. scheinerman , and daniel ullman .",
    "undirected edge geography .",
    ", 112(2):371381 , 1993 .",
    "masahiko fukuyama . a nim game played on graphs .",
    ", 1 - 3(304):387399 , 2003 .    p.  m. grundy .",
    "mathematics and games . , 2:198211 , 1939 .",
    "david lichtenstein and michael sipser .",
    "go is polynomial - space hard .",
    ", 27(2):393401 , 1980 .",
    "r.  p. sprague .",
    "ber mathematische kampfspiele . , 41:438444 , 1935 - 36 .",
    "gwendolyn stockman .",
    "presentation : the game of nim on graphs : nimg , 2004 .",
    "available at http://www.aladdin.cs.cmu.edu / reu / mini_probes / papers / final_stockman.ppt% [ http://www.aladdin.cs.cmu.edu / reu / mini_probes / papers / final_stockman.ppt% ] .",
    "any play from @xmath39 to @xmath34 ( for all @xmath24 ) is suboptimal",
    ".    we will refer to the player who moves from @xmath38 to @xmath47 ( we will leave out the subscript for the internal vertices ) as the `` foe '' while the other player is the `` hero ''",
    ". we will show that the hero has a winning strategy after a backwards move .",
    "we can now look at two cases , each depending on the state of the game outside the gadget .",
    "the first is the case where the move from @xmath42 to @xmath36 would be a winning play . in this case",
    ", the hero can next move from @xmath47 to @xmath46 and take both of the objects there .",
    "the foe has two options , both of which , we show , allow the hero to win .    *",
    "* the foe moves to @xmath48 .",
    "* in this case the hero must choose to go to @xmath43 .",
    "the foe can now either choose to move to @xmath42in which case the hero will gladly move to @xmath36 and win as we assumed  or to @xmath44 . then the hero simply takes the object at @xmath45 and , as there are no more moves , the hero has won . * * the foe moves to @xmath45 .",
    "* the hero must then take @xmath44 and the foe must take @xmath43 . the hero can then move to @xmath48 and win the game .",
    "the second major case assumes that the move from @xmath42 to @xmath36 is a losing play . here",
    ", the hero can still move to @xmath46 ( from @xmath47 ) but will take only one of the objects .",
    "now the foe has three options : taking the other object at @xmath46 , moving to @xmath48 or moving to @xmath45 .",
    "we show all to be losses .    * * foe moves to @xmath48 . * now the hero should take the remaining object at @xmath46 .",
    "the following sequence must occur : foe must take @xmath45 , hero at @xmath44 , foe at @xmath43 , hero at @xmath42 , followed by the foe at @xmath36 , a losing move by our assumption . *",
    "* foe takes the remaining object at @xmath46 .",
    "* the hero will choose to take @xmath48 , so the foe must take @xmath43 . the hero can then take @xmath42 , forcing the foe to take @xmath36 , a losing move by our assumption . *",
    "* foe takes @xmath45 . * the hero should then take @xmath44 so the foe must take @xmath43 . again",
    ", the hero can take @xmath42 , so the foe must move to @xmath36 , a losing move by our assumption .",
    "let the notation @xmath49 denote taking @xmath50 objects from vertex @xmath51 in a turn . then , after the plays @xmath52 any play deviating from the following sequences is a losing move : + @xmath53 + @xmath54 .",
    "we continue by analyzing all possible deviations from these sequences and show that they result in a loss . in this claim",
    ", we will refer to the deviating player as the foe and the other player as the hero .",
    "we will show that the foe loses in each case",
    ". it may be helpful to refer to figure [ fig : safesequence ] during these case descriptions .",
    "* * @xmath60 instead of @xmath61 . * here we have two subcases : either moving from @xmath47 to @xmath38 is a winning ( result is a @xmath62-position ) or losing ( a @xmath35-position ) move .",
    "if it s in @xmath35 , then the hero can respond to @xmath60 with @xmath63 .",
    "if the foe then chooses @xmath64 , the hero can take the remaining stick in @xmath46 with @xmath63 .",
    "@xmath65 and @xmath61 must follow with the hero winning .",
    "if the foe instead chooses @xmath65 , the hero can win instantly by choosing @xmath61 .",
    "for the foe s last chance , they could select @xmath63 , removing the other stick from @xmath46 .",
    "the hero should respond with @xmath64 .",
    "the foe will lose by selecting @xmath65 , because the hero will win at @xmath61 , but the foe will also lose with @xmath66 , an @xmath35-position as assumed .",
    "+ if @xmath66 is instead leaves the board in @xmath62 , the hero should respond to @xmath60 with @xmath67 .",
    "the foe could choose @xmath65 , but the hero can then win with @xmath61 . instead , the foe can choose @xmath64 in which case the hero can choose @xmath66 and win , as assumed . *",
    "* @xmath67 instead of ( the first ) @xmath63 . * here the hero has a simple move to win . by taking @xmath60",
    "there are no further moves and the foe has lost .",
    "* * @xmath64 instead of ( the first ) @xmath63 .",
    "* the hero can respond with @xmath63 .",
    "this leaves two different adjacent vertices with 1 object apiece and no other adjacent non - empty vertices .",
    "either move by the foe results in one remaining move and a win for the hero .",
    "* * @xmath63 instead of @xmath60 .",
    "* the hero can respond with @xmath60 and win .",
    "* * @xmath63 instead of @xmath66 .",
    "* this can not happen in the second sequence , but if it happens in the first , the hero can respond with @xmath60 and win ."
  ],
  "abstract_text": [
    "<S> we build off the game , @xcite to create a version named . by reducing from , </S>",
    "<S> we show that this game is -hard . the games created by the reduction share strong similarities with and regular , both of which are solvable in polynomial - time . </S>",
    "<S> we show how to construct -complete versions with nim heaps @xmath0 and @xmath1 . </S>",
    "<S> this application of graphs can be used as a form of game sum with any games , not only . </S>"
  ]
}