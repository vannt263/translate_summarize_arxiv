{
  "article_text": [
    "traditional methods for visual cryptography have been established , are consistent and easily understood .",
    "unfortunately , these methods exist for black and white pictures only , leaving the encryption of colour images wanting . while there are a handful of attempts at bringing colour to visual cryptography",
    ", it is still an open field with implementations of varying efficiency . in this paper",
    ", we will establish some basic standards for encrypting colour pictures , as well as a simple , yet efficient method for encryption based upon those rules .    while black and white pictures are fairly easy to work with due to their simple nature , colour pictures contain much more information and possibly details that may not be lost in the process .",
    "this leads to a need for the static that normally appears in the decryption of black and white pictures to have to be absent[1 ] .",
    "however , a partial reconstruction of the picture ( such as having less than all the necessary parts for full restoration ) may not hint at what the final image is meant to be .",
    "in addition to the standard of security for the traditional black and white pictures , we set the following points as mandatory for encryption of colour images .    * full restoration upon decryption . * no indication as to the original image , whether by eye or any other method , when combining a subset of all available parts .",
    "* usability for any type of image , whether that image contains a mixture of colours , is black and white or is simply one single colour . *",
    "destruction of intermediary steps in the encryption process .",
    "our method of encryption is , due to the process of creating images within visual cryptography and the expanse of computer use , based around the rgb colour model for computers and other , similar devices .",
    "this does not prevent implementation of this process with any other model as long as the information is stored as bits .",
    "the encryption is fairly straightforward and can be easily understood as well as implemented .",
    "although it is easy to handle , it is efficient , provides the necessary security and fulfills every point previously stated . for the process , the thought was to work on the bitwise level that represents the colours themselves ; in this case , the rgb values are used . as each pixel",
    "is processed , two random values are generated ; the first one is compared to the rgb value of the current pixel and it is then separated into two values : an rgb value with the bits that were set in both the original as well as the first random value , and another one with the set bits left over from the original .    next , the second random value is compared to the two new results from the previous step .",
    "if both values are not set while the bit at the same position in the random value is , those bits for the values from the previous step are set .",
    "these steps are repeated for every pixel and then the encryption is finished .",
    "decryption is easily done via a bitwise xor of the rgb values of the two resulting pictures and we effectively have a one - time pad implementation on the colour values of an image .",
    "the random values from the process of encryption are discarded alongside any other values we might have produced .",
    "the encryption algorithm will `` split '' the original image into two so called _ shadow images_. let @xmath0 denote one pixel in the original image , and let @xmath1 and @xmath2 denote the corresponding pixels in the shadow images , respectively . here",
    "@xmath0 , @xmath1 , and @xmath2 are vectors , representing the channels used , e.g. red , green and blue in the rgb colour model . the calculations during the encryption are carried out both bitwise and channel - wise .",
    "@xmath3 @xmath4 @xmath5 @xmath6    we illustrate the encryption with an example .",
    "assume that we want to encrypt the image in figure  [ fig : ex1 ] .",
    "then if we apply the algorithm , it may result in the two shadow images in figure  [ fig : ex2]remember that the algorithm is probabilistic .             to restore the original image , we compute @xmath7 for each pixel .",
    "the result will give us back the original image , without any loss of quality , that is , figure  [ fig : ex1 ] .",
    "as with both visual cryptography and the one time pad , this method offers complete security as there is neither a repetition to be found , nor is a brute force attack possible as every possible result within the picture s resolution will show up .",
    "this method does not only fulfill the standards we previously set , it even leaves the resolution of the original image intact .",
    "of course , it should be noted that for this encryption to work to its full potential , the results must be saved as a lossless image type . in the event that one would wish to separate the original into more than two pictures , reapplying this process to the results until a satisfactory amount is reached is all one needs to do .",
    "it could be argued that all this encryption would need is random values generated and applied with a bitwise xor to the original image , leaving the randomly generated sequence as one of the resulting images and the result of the bitwise xor as the other .",
    "while this could be done , let us take a look at the absolute worst case scenario , disregarding the possibilities that an attacker knows the original or has access to all parts of the picture .",
    "the scenario in mind would be in the highly unlikely event that an attacker would have an intimate enough knowledge of the encryption process to know exactly how it is implemented as well as knowing exactly which random values were generated .",
    "if the method of encryption would be nothing more than the simplified version suggested , then having the result of the bitwise xor in your possession would be enough to get the original as being able to predict the exact pseudo - random values would mean that you effectively have the key .",
    "this is not the case for the method we propose as depending on the random values and how they interact with the original data , only some bits could possibly be decided , as shown in table  [ tab : values ] .",
    "there are four possible cases for the pair @xmath8 .",
    "each case can be divided into two subcases , where each corresponds to the possible value @xmath9 of @xmath0 . without loss of generality , we consider the cases on bit - level .    * 5c case & @xmath10 & @xmath11 & @xmath9 & @xmath0 + 1 & 0 & 0 & 0 &  + 2 & 0 & 0 & 1 & 1 + 3 & 0 & 1 & 0 & 1 + 4 & 0 & 1 & 1 & ",
    "+ 5 & 1 & 0 & 0 &  + 6 & 1 & 0 & 1 & 1 + 7 & 1 & 1 & 0 & 1 + 8 & 1 & 1 & 1 &  +    as seen , even in the case of knowing the generated pseudo - random values , half the possible combinations lack a value , thus mitigating such an attack .",
    "the method of encryption presented here could also be applied to the one time pad due to the likeness of them , so providing the extra bit of security by mitigating this most unlikely of scenarios .",
    "the reasoning for the received original value presented in the above table is shown with simple boolean algebra .",
    "the equations used are the ones presented in the pseudocode , also presented here for ease of following .",
    "keep in mind that we do not know which one of the values we have and thus not what the other one could be .",
    "[ [ case-1-and-2 ] ] * case 1 and 2 * + + + + + + + + + + + + + +    here is @xmath12 and @xmath13 . while we know for sure that at least one of the values must be @xmath14 , the other could be either possible value .",
    "this means that if our available result ( @xmath9 ) is @xmath14 , we have no way of knowing which value we have in our possession , which in turn means that @xmath1 and @xmath2 are equal in terms of possibility .",
    "thus , since the original value could be either for @xmath1 , it remains undetermined .",
    "if , on the other hand , our available value is @xmath15 , then we can logically conclude that it is @xmath2 that we are dealing with and we only have to complete the following equation : @xmath16 and therefore @xmath17 .",
    "[ [ case-3-and-4 ] ] * case 3 and 4 * + + + + + + + + + + + + + +    here is @xmath18 and @xmath19 . as per the same logic as in the previous one : if the available result is the same as the one we know must exist ( in this case one ) , then we can not tell which equation it is we have .",
    "if it is the opposing value , then we can in this case rule out @xmath2 and calculate the equation : @xmath20 and hence @xmath17 .",
    "[ [ case-5-and-6 ] ] * case 5 and 6 * + + + + + + + + + + + + + +    here is @xmath21 and @xmath22 .",
    "following the previous logical steps gives us an unknown for the available result of @xmath14 , but the following result for @xmath15 is @xmath17 .",
    "[ [ case-7-and-8 ] ] * case 7 and 8 * + + + + + + + + + + + + + +    here is @xmath23 and @xmath24 .",
    "once again we can not say for sure which case is before us if our available result is the same as the one we know with certainty to exist , but in the case of a differing result , we know the following : @xmath25 and @xmath17 .",
    "we would like to thank robert nyqvist for :"
  ],
  "abstract_text": [
    "<S> while strictly black and white images have been the basis for visual cryptography , there has been a lack of an easily implemented format for colour images . </S>",
    "<S> this paper establishes a simple , yet secure way of implementing visual cryptography with colour , assuming a binary data representation . </S>"
  ]
}