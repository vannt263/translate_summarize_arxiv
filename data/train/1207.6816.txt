{
  "article_text": [
    "constructs for delaying calls have long been a popular extension to conventional prolog .",
    "such constructs allow sound implementation of negation , more efficient versions of `` generate and test '' algorithms , more flexible modes and data - flow , a mechanism for coordinating concurrent execution and forms of constraint programming .",
    "they also introduce a new class of errors into logic programming : rather than computing the desired result , a computation may _ flounder _ ( some calls are delayed and never resumed ) .",
    "tools for locating possible bugs , either statically or dynamically , are desirable .",
    "static analysis can also be used to improve efficiency and in the design of new languages where data and control flow are known more precisely at compile time .",
    "the core contribution of this paper is to show how a program with `` delays '' can be transformed into a program without delays whose ( ground ) success set contains much information about floundering and computed answers of the original program .",
    "some technical results are given which extend known results about floundering , and these are used to establish the properties of two new program transformations .",
    "the main motivation we discuss is program analysis , though we also mention declarative debugging .",
    "analysis of properties such as which goals flounder can be quite subtle , even for very simple programs .",
    "the term floundering was originally introduced in the context of negation , where negated calls delay until they are ground , and sometimes they never become ground . in this paper",
    "we do nt directly deal with negation but our approach can equally be used for analysing this form of delaying of negated calls .",
    "subcomputations are also delayed in some other forms of resolution , for example , those which use tabling . for these computational models delaying",
    "is more determined by the overall structure of the computation ( for example , recursion ) rather than the instantiation state of variables in the call , and it is doubtful our methods could be adapted easily .",
    "this paper is structured as follows . in section [ sec : delprim ] delay declarations are described and the procedural semantics of prolog with delays is discussed informally . in section [ sec : examples ] we give some sample programs which use delays . in section [ sec : anal1 ]",
    "we discuss in more detail some properties of delaying code which , ideally , we would like to be able to analyse . in section [ sec : ground ] we briefly discuss an observation concerning computed answers which is important to our approach . in section [ sec : sldf ]",
    "we review a theoretical model of prolog with delays and extend some previous results concerning floundering . in section [ sec : elim ] we give a program transformation that converts floundering into success . in section [ sec : cfs ] a more precise characterisation of floundering is provided , along with a second transformation . in section [ sec : ddis ] we briefly discuss declarative debugging of floundering and a related model - theoretic semantics . in section [ sec : related ] we discuss some related work and we conclude in section [ sec : conc ] .",
    "dozens of different control annotations have been proposed for logic programming languages . in the programs in this paper we use `` delay '' declarations of the form ` : - delay a if c ` where ` a ` is an atom @xmath0 , the @xmath1 are distinct variables , @xmath2 is a predicate and ` c ` is a condition consisting of ` var/1 ` , ` nonground/1 ` ( with arguments the @xmath1 ) , `` ` , ` '' and `` ` ; ` '' .",
    "procedurally , a call @xmath3 delays if ` c ` holds ( with the conventional meaning of ` var ` and ` nonground ` ) .",
    "the procedural semantics of prolog with delays is typically difficult to describe precisely and , to our knowledge , is not done in any manuals for the various prolog systems which support delays .",
    "here we describe the procedural semantics of nu - prolog , and where the imprecision lies ; other systems we know of are very similar . by default",
    ", goals are executed left to right , as in standard prolog . if the leftmost sub - goal delays ( due to some delay annotation in the program ) , the next leftmost is tried .",
    "thus the leftmost non - delaying subgoal is selected .",
    "complexities arise when delayed goals become further instantiated and may be resumed .",
    "when a delayed goal becomes instantiated enough to be called ( due to unification of another call with the head of a clause ) , the precise timing of when is it resumed can be difficult to predict . with a single call to resume ,",
    "it is done immediately after the head unification is completed . with multiple calls to resume , they are normally resumed in the order in which they were first delayed .",
    "it is as if they are inserted at the start of the current goal in this order .",
    "however , this is not always the case .",
    "some calls may delay until multiple variables are instantiated to non - variable terms .",
    "this is implemented by initially delaying until one of those variables is instantiated .",
    "when that occurs , the call is effectively resumed but may immediately delay again if the other variables are not instantiated . similarly , when delaying until some term is ground , the delaying occurs on one variable at a time and the call can be resumed and immediately delayed again multiple times .",
    "the order in which multiple calls are resumed depends on when they were _ most recently _ delayed .",
    "this depends on the order in which the variables are considered , which is not specified . in nu - prolog ,",
    "the code generated to delay calls is combined with the code for clause indexing and it is difficult to predict the order in which different variables are considered without understanding a rather complex part of the compiler .",
    "the situation is even worse in parallel logic programming systems . in parallel nu - prolog @xcite",
    "the default computation rule is exactly the same as for nu - prolog .",
    "however , if an idle processor is available a call which is instantiated enough may delay and be ( almost ) immediately resumed on another processor . even with total knowledge of the implementation , the precise execution of a program can not be determined .",
    "any program analysis based on procedural semantics must respect the fact that the computation rule is generally not known precisely but ( we hope ) not lose too much information .",
    ".... : - delay append(as , bs , cs ) if var(as ) , var(cs ) .",
    "append ( [ ] , as , as ) .",
    "append(a.as , bs , a.cs ) : - append(as , bs , cs ) .",
    "append3(as , bs , cs , abcs ) : - append(bs , cs , bcs ) , append(as , bcs , abcs ) .    : - delay reverse(as , bs ) if var(as ) , var(bs ) . reverse ( [ ] , [ ] ) .",
    "reverse(a.as , bs ) : - append(cs , [ a ] , bs ) , reverse(as , cs ) . ....",
    "we now present two small examples of code which uses delays .",
    "the first will be used later to explain our techniques .",
    "figure  gives a version of ` append ` which delays until the first or third argument is instantiated .",
    "this delays ( most ) calls to ` append ` which have infinite derivations . delaying such calls",
    "allows ` append ` to be used more flexibly in other predicates .",
    "for example , ` append3 ` can be used to ` append ` three lists together or to split one list into three . without the delay declaration for ` append ` , the latter `` backwards '' mode would not terminate . with the delay declaration , the first call to ` append ` delays .",
    "the second call then does one resolution step , instantiating variable ` bcs ` .",
    "this allows the first call to resume , do one resolution step and delay again , et cetera .    in a similar way ,",
    "this version of ` reverse ` works in both forwards and backwards modes  if either argument is instantiated to a list it will compute the other argument .",
    "if the second argument is instantiated , no calls are delayed .",
    "however , if only the first argument is instantiated , all the calls to ` append ` initially delay and after the last recursive call to ` reverse ` succeeds , the multiple calls to ` append ` proceed in an interleaved fashion . for any given mode , the code for ` append3 ` and ` reverse ` can be statically reordered to produce a version which works without delaying .",
    "the mercury compiler does such reordering automatically @xcite , but without automatic reordering it requires some slightly tricky coding to produce such flexible versions of these predicates .    ....",
    "submaxtree(tree , newtree ) : -          submaxtree1(tree , max , max , newtree ) .",
    "submaxtree1(nil , _ , 0 , nil ) .",
    "submaxtree1(t(l , e , r ) , gmax , max , t(newl , newe , newr ) ) : -          submaxtree1(l , gmax , maxl , newl ) ,          submaxtree1(r , gmax , maxr , newr ) ,          max3(e , maxl , maxr , max ) ,          plus(newe , gmax , e ) .",
    "% delays ; later mode o , i , i    max3(a , b , c , d ) : - ...    : - delay plus(a , b , c ) if var(a ) , var(b ) ; var(a ) , var(c ) ; var(b ) , var(c ) .",
    "....    figure  is a variant of the ` maxtree ` program ( see @xcite , for example ) which takes a tree and constructs a new tree containing copies of a logic variable in each node , then binds the variable to a number ( the maximum number in the original tree ) .",
    "the ` submaxtree ` program fills each node in the new tree with the original value _ minus _ the maximum .",
    "this is done by delaying a call to ` plus ` for each node until the maximum is known , then resuming all these delayed calls .",
    "we assume a version of ` plus ` which delays until two of its three arguments are instantiated ; nu - prolog has such a predicate built in .",
    "all calls to ` plus ` become sufficiently instantiated at the same time ( when ` gmax ` becomes instantiated ) . in most systems",
    "they will be called in the order they were delayed .",
    "if ` plus ` only worked in the forward mode the calls would not be sufficiently instantiated and the computation would flounder .",
    "we also assume a predicate ` max3/4 ` which calculates the maximum of three numbers .",
    "it is not possible to statically reorder the clause bodies to eliminate the delays .",
    "even dynamic reordering clause bodies each time a clause instance is introduced ( also known as a _",
    "computation rule ) is insufficient . without coroutining , two passes over the tree",
    "are necessary , doubling the amount of `` boilerplate '' traversal code  the first to compute ` gmax ` and the second to build the new tree .",
    "delays can be used to write concise and flexible code , the behaviour of which can be very subtle .",
    "for example , @xcite shows that when bugs are introduced to a four - clause permutation program with delays , a wide variety of counter - intuitive behaviour results .",
    "even with such a tiny program , the combination of interleaved execution and backtracking makes understanding why it misbehaves very challenging .",
    "another tiny example is the ( arguably correct ) definition of ` reverse ` in figure [ fig_rev ] .",
    "having first written and used equivalent code around twenty - five years ago , the author did not become fully aware of its floundering properties until the preparation of this paper .",
    "it was incorrectly thought that all calls to ` reverse ` which have an infinite number of solutions with different list lengths ( such as ` reverse([a , b , c|xs],ys ) ` ) would flounder .",
    "section  [ sec_using_f ] gives a precise characterisation of the actual behaviour .",
    "automated methods of analysis of code with delays are highly desirable because manual analysis is just too complex to be reliable .",
    "analysis of code with delays can address many different issues",
    ". it may be that we expect code to succeed or finitely fail for certain classes of goals but some such goals may actually flounder , typically with a computed answer less instantiated than expected  this is the main focus of the declarative debugging work of @xcite , also discussed in section [ sec : ddis ] . in section [ sec : elim ]",
    "we give a transformation which allows analysis of computed answers ( of successful or floundered derivations ) which can detect such cases .",
    "conversely , we may expect certain goals to flounder when actually they succeed .",
    "this is particularly important if the goal has an infinite number of solutions and is part of a larger computation  success can result in non - termination where floundering would not . in section [ sec : cfs ]",
    "we give a further transformation which captures floundering precisely .",
    "both methods reduce the problem of analysing a program with delays to analysing the success set of a program without delays . a deeper understanding of floundering can also help us in other ways .",
    "for example , although the declarative debugger of @xcite does nt rely on either of these transformations directly , it is based on the insights of this paper .",
    "similarly , these insights may help us optimise code , either by simplifying delay annotations or , more significantly , eliminating them entirely ( possibly with some reordering of code ) .",
    "they may also help our understanding of termination properties of code with delays .",
    "[ cols=\"^,^,^ \" , ]     before proceeding further , with more technical material , we make an observation about computed answers which is fundamental to our work .",
    "the conventional approach to the semantics of logic programs is that the set of function symbols in the language is precisely that in the program ",
    "see , for example , the textbook @xcite which combines and refines some of the original work of van emden , kowalski , apt and others .",
    "this means that , unlike in prolog , new function symbols can not occur in the goal ( or the semantics of the program differs depending on the goal ) . an alternative is to define the ( typically infinite ) set of function symbols _ a priori _ and assume that both the program and goals use a subset of these function symbols .",
    "this approach has been examined in @xcite , where various results are given , and earlier in @xcite , where forms of equivalence of logic programs are explored .",
    "for example , figure  gives three programs with different sets of computed answers for ` p(y ) ` .",
    "they are all equivalent using the `` lloyd '' declarative semantics but with extra function symbols programs @xmath4 and @xmath5 are equivalent but @xmath6 is not .",
    "one advantage of the latter semantics is that the universal closure of a goal is true if and only if it succeeds with a computed answer substitution which is empty ( or simply a renaming of variables)see the discussion in @xcite .",
    "another is that the model - theoretic and fixed - point semantics can capture information about ( non - ground ) computed answers and , as we will show later , floundering !",
    "since the lloyd semantics deals only with sets of ground atoms , this fact is somewhat surprising , and does not seem to have been exploited for program analysis until now .",
    "we partition the set of function symbols into _ program function symbols _ and _ extraneous function symbols_. programs and goals may only contain program function symbols . _ program atoms _ are atoms containing only program function symbols .",
    "substitutions in derivations ( including computed answer substitutions ) contain only program function symbols .",
    "[ obs_pfs ]    this is a consequence of _ most general _ unifiers being used ( indeed , programming with delays makes little sense without this ) .",
    "non - ground computed answers can be identified in the success set by the presence of extraneous function symbols .",
    "for example , if @xmath7 is an extraneous function symbol then an atom such as ` p(\\bowtie ) ` appears in the success set if and only if it is an instance of some non - ground computed answer .",
    "if we assume there are an infinite number of terms whose principal function symbol is an extraneous function symbol then computed answers can be captured more precisely  we make this assumption later for our analysis of floundering .",
    "note this semantics can not determine whether a variable exists in _ all _ computed answers ( or derivations ) of a goal  in both @xmath4 and @xmath5 of figure  the success set contains ` p(\\bowtie ) ` and ` p(a ) ` .",
    "however , it does precisely capture groundness in all computed answers ( or variables in _ some _ computed answer ) , a property which has attracted much more interest .",
    "for example , many consider it of interest that in all computed answers of ` append ` , if the third argument is ground the second argument is also ground . using the semantics",
    "we suggest , this is equivalent to saying if @xmath7 occurs in the second argument it also occurs in the third argument . if we can find a superset of the success set ( for example , a model ) which has this property , the groundness dependency must hold .",
    "thus a small variation to the lloyd semantics leads to significant additional precision while retaining the simple model - theoretic and fixed - point semantics and the relationship between them .",
    "a model of prolog with delays , sldf resolution , is presented in @xcite . here",
    "we review the model and main results , concerning ground atoms , and extend these result to non - ground atoms .",
    "we define the non - ground flounder set , which approximates the floundering behaviour of a program . however , we first give discuss two important closure properties which hold for sld resolution ( where there is no floundering ) .",
    "[ clprops ] if an atom @xmath8 has a successful sld derivation with computed answer @xmath8 ( an empty computed answer substitution ) then , using the same program clauses in the derivation    * any atom with @xmath8 as an instance has a computed answer with @xmath8 as an instance , and * any atom @xmath9 has a computed answer @xmath9 .",
    "such properties allow computed answers to be captured precisely by the set of computed answers of maximally general atoms , and generally simplifies analysis .",
    "when delays are introduced ( sldf resolution ) , only closure property 2 holds for successful atoms  a less instantiated version of a successful atom may flounder rather than succeed . for floundered atoms only closure property 1 holds ( see proposition [ prop_gth_ca])an instance of a floundered atom may succeed , loop , finitely fail or flounder with an even more instantiated floundered computed answer . the weaker closure properties ( compared to sld resolution ) means it is harder to precisely characterise the behaviour of sldf resolution using sets of atoms .",
    "we now review sldf resolution , define the set of atoms we use to approximate its behaviour and show the relationship between the two .",
    "sldf resolution is similar to sld resolution ( see @xcite ) , but the computation ( atom selection ) rule is restricted to be _ safe _ : an atom may only be selected if it is in the `` callable atom set '' .",
    "it is desirable that this set is closed under instantiation and the results below and those in this paper rely on this property .",
    "this property seems quite intuitive and holds for most logic programming systems with flexible computation rules .",
    "another restriction suggested in @xcite is that all ground atoms should be callable .",
    "while this is not required for our technical results , it is a pragmatic choice .",
    "sldf derivations can be failed , successful , infinite or _ floundered _ , in which the last resolvent consists only of atoms which are not callable ( we say it is _ immediately floundered _ ) .",
    "given the assumption above , for a program @xmath10 the following sets of ground atoms can be defined independently of the ( safe , and also fair in the case of finite failure ) computation rule :    * the success set @xmath11 ( ground atoms with successful derivations ) . * the finite failure set @xmath12 ( ground atoms with finitely failed sld trees ) . *",
    "the flounder set @xmath13 ( ground atoms with floundered derivations ) .",
    "note that some atoms in @xmath13 may also be in @xmath11 and have infinite ( fair ) derivations .",
    "the fact that floundering is independent of the computation rule suggests it is a declarative property in some sense .",
    "however , it has not been fully exploited for analysis until now , perhaps due to the lack of non - procedural definitions of @xmath13 .",
    "note also that the results above only refer to ground atoms .",
    "an atom such as ` q(x ) ` may have floundered derivations but no instance may appear in @xmath14 because no ground instance flounders .",
    "however , @xmath14 can contain information about floundering of non - ground atoms and conjunctions .",
    "for example , if the program contains the definition ` p : - q(x ) ` , @xmath14 will contain ` p ` if and only if ` q(x ) ` flounders . relying on the existence of such definitions is a problem unless we know a priori which goals we want to analyse , and @xmath14 gives us no information about substitutions in floundered derivations .",
    "substitutions in floundered ( sub)computations can influence termination and are very important for certain programming styles , particularly those associated with parallel programming . most prolog systems which support delays print variable bindings at the top level for both successful and floundered derivations .",
    "thus we use the term(s ) computed answer ( substitution ) for both successful and floundered derivations , explicitly adding the words `` successful '' or `` floundered '' where we feel it aids clarity .",
    "the analysis proposed in this paper can be seen as being based on the following generalisation of @xmath14 .",
    "the _ non - ground flounder set _",
    ", @xmath15 , of a program @xmath10 is the set of program atoms which have floundered derivations with empty floundered computed answer substitutions .",
    "successful derivations can be conservatively approximated by simply ignoring delays  the lack of closure property 1 for successful atoms and the fact that an atom may have both successful and floundered derivations prevents our approach being more precise for analysis of success .",
    "the key results of this section , propositions [ prop_gth_nfs ] and [ prop_gth_ca ] , show how @xmath15 contains much but not all information about computed answers of floundered derivations .    the results in @xcite , and some we prove in this paper , rely on the notion of two derivations of the same goal using the same clause selection .",
    "used in @xcite in the context of successful derivations , we formalise it here .",
    "we assign each clause in the program a unique positive integer and use zero for the top level goal .",
    "we annotate each atom used in a derivation with a superscript to indicate the sequence of clauses and atoms within those clauses used to introduce it .",
    "annotations are lists of pairs @xmath16 , where @xmath17 is a clause number and @xmath18 is the number of an atom within the clause .",
    "we use these annotations for both sld and sldf resolution .",
    "the _ annotation _ @xmath19 of an atom used in a derivation is as follows . if goal @xmath20 is the top level goal , @xmath21 .",
    "applying substitutions to atoms does not change their annotation .",
    "if @xmath22 is selected and resolved with a variant of clause number @xmath23 , @xmath24 , each @xmath25 atom is annotated with @xmath26 .",
    "two atoms in different derivations or goals are _ corresponding atoms _ if they have the same annotation .",
    "two derivations with the same top level goal , or with one top level goal an instance of the other , have _ the same clause selection _ if all pairs of corresponding selected atoms in the two derivations are matched with the same clause .",
    "although not explicitly stated , the proofs in @xcite can easily be adapted to show that ( successful and floundered ) computed answers of successful and floundered derivations are independent of the computation rule ( see lemma [ lem_mgi_gth ] ) . for any",
    "two successful or floundered derivations of the same goal with the same clause selection but a different ( safe ) computation rule , each selected atom in one has a corresponding atom selected in the other .",
    "derivation length , computed answer substitutions and the last resolvent are all the same , up to renaming .",
    "[ lem_mgi_gth ]    suppose @xmath27 is the sld derivation @xmath28 , where @xmath29 is the composition of the most general unifiers used in the first @xmath30 steps , and @xmath31 is the sld derivation @xmath32 , where @xmath33 affects only variables in @xmath34 .",
    "suppose also that @xmath27 and @xmath31 use the same set of program clauses and corresponding set of selected atoms in the first @xmath35 steps .",
    "then @xmath36 , is a most general instance ( m.g.i . ) of @xmath37 and @xmath38 , and @xmath39 is a m.g.i of @xmath40 and @xmath41 .",
    "let @xmath42 , @xmath43 , be the @xmath44 program clause variant used in the first @xmath35 steps of @xmath27 , @xmath45 , @xmath46 , be the atom in a body of one of these clauses or in @xmath34 whose corresponding instance is selected and matched with @xmath47 , and @xmath48 , @xmath49 be the atoms as above corresponding to those in @xmath50 ( they are not selected in the first @xmath35 steps ) .",
    "let terms @xmath51 and @xmath52 be as follows , where the connectives and predicate symbols are mapped to function symbols .",
    "@xmath53    a m.g.i . of @xmath51 and @xmath52 can be obtained by left to right unification of the arguments of @xmath51 and a variant of @xmath52 which shares no variables with @xmath51 . the first @xmath54 argument unifications yield a renaming substitution , resulting in the same variants of program clause heads and bodies in the instances of @xmath52 and @xmath51 .",
    "the next @xmath35 are the same as the unifications in @xmath27 , modulo the clause variants used , and the other unifications yield empty unifiers . thus @xmath55 is a m.g.i . of @xmath51 and @xmath52 .",
    "other orders of the arguments @xmath45 and @xmath47 ( or unification orders ) correspond to different computation rules but result is the same most general instance , or a variant .",
    "so , by the same construction , @xmath56 is a m.g.i . of @xmath52 and @xmath57 , and must be an instance of @xmath55 .",
    "@xmath55 is an instance of @xmath52 so @xmath58 must be a m.g.i . of @xmath57 and @xmath55 .",
    "the instances of the initial goals and @xmath59 resolvents can be extracted from the arguments of @xmath55 , @xmath57 and @xmath58 so the result follows .",
    "we can now show something similar to the converse of closure property 1 , for floundering .",
    "this allows us to infer certain information about program behaviour from @xmath15 .",
    "[ prop_gth_nfs ] if @xmath27 is the floundered sldf derivation @xmath60 with floundered computed answer @xmath40 , then @xmath61 has a floundered sldf derivation @xmath31 with a renaming ( or empty ) floundered computed answer substitution ( @xmath62 ) .",
    "let @xmath31 be a derivation using the same selection and computation rule as @xmath27 .",
    "@xmath31 can not flounder before @xmath35 steps because the @xmath44 resolvent is an instance of @xmath63 and the callable atom set is closed under instantiation .",
    "@xmath31 can not fail before @xmath35 steps because the @xmath44 resolvent is no more instantiated than @xmath64 , and @xmath65 is a unifier of all pairs of calls and clause heads in the first @xmath35 steps .",
    "consider the @xmath59 resolvent , @xmath66 . by lemma [ lem_mgi_gth ]",
    ", @xmath66 is a m.g.i . of @xmath37 and @xmath38 and since @xmath38 is an instance of @xmath67 , @xmath66 must be a variant of @xmath38 , so it is immediately floundered . similarly , @xmath39 is a variant of @xmath40 , so the floundered computed answer substitution is a renaming .",
    "[ lem_fi_inst ] if @xmath40 has a floundered sldf derivation @xmath31 with the last resolvent being @xmath68 and @xmath34 has a sldf derivation @xmath27 using the same clause selection rule then each @xmath69 is an instance of all its corresponding atoms in @xmath27 .",
    "if @xmath34 is immediately floundered the result is trivial .",
    "we use induction on the length of @xmath31 . for length 0 , since the callable atom set is closed under instantiation and @xmath40 is immediately floundered , @xmath34 must also be immediately floundered .",
    "assume it is true for length @xmath35 .",
    "suppose the first selected atom in @xmath27 is @xmath8 .",
    "@xmath9 is also callable , so we can construct a derivation @xmath70 using the same clause selection as @xmath31 but with @xmath9 as the first selected atom .",
    "the lengths of @xmath70 and @xmath31 are equal and their last resolvents are variants due to the result stated earlier .",
    "the first resolvent in @xmath70 ( after selecting @xmath9 ) is an instance of the first resolvent in @xmath27 and has a derivation of length @xmath35 so the result follows .",
    "we can now show that closure property 1 holds for floundering :    [ prop_gth_ca ] if @xmath40 has a floundered sldf derivation @xmath31 with a renaming ( or empty ) floundered computed answer substitution ( @xmath71 ) , then @xmath34 has a floundered sldf derivation @xmath27 with a floundered computed answer with @xmath40 as an instance .    from @xmath34 we can construct a derivation @xmath27 using the same clause selection as that used in @xmath31 and any safe computation rule .",
    "the callable atom set is closed under instantiation so by lemma [ lem_fi_inst ] , any atom selected in @xmath27 must have a corresponding atom selected in @xmath31 and thus @xmath27 can not be successful or longer that @xmath31 .",
    "@xmath27 uses the variants of the same clauses used in @xmath31 , which has a more ( or equally ) instantiated top level goal , @xmath40 , so @xmath27 can not be failed .",
    "it must therefore be floundered and have a computed answer with @xmath40 as an instance .    from these propositions we know that an atom @xmath8 will flounder if and only if it has an instance in @xmath15 . also , the maximally general instances of @xmath8 in @xmath15 will be floundered computed answers .",
    "the imprecision of @xmath15 with respect to floundered computed answers is apparent when there are atoms in @xmath15 which are instances of other atoms in @xmath15 .",
    "if @xmath72 for example , we know @xmath73 will have the first atom as a floundered computed answer .",
    "the second atom may also be a floundered computed answer ( via a different floundered derivation ) or it may only be returned for more instantiated goal such as @xmath74 . in practice , there is usually a single maximally general instance of a goal in @xmath15 and this is the only answer computed , even when there are an infinite number of instances .",
    "for example , the non - ground flounder set for ` append ` has an infinite number of instances of the atom ` append(a , [ b ] , c ) ` , including ` append(xs , [ y ] , zs ) ` , ` append([x1|xs ] , [ y ] , [ x1|zs ] ) ` and ` append([x1 , x2|xs ] , [ 42 ] , [ x1 , x2|zs ] ) ` , but only the first is computed .",
    "we now present a program transformation which converts a program @xmath10 , with delays , into a program @xmath75 , without delays .",
    "the success set of @xmath75 is the union of the success set of @xmath10 and a set isomorphic to the non - ground flounder set of @xmath10 .",
    "thus analysis of some properties of programs with delays can be reduced to analysis of programs without delays .",
    "type , groundness and other dependencies are of interest in programs with and without delays as they give us important information concerning correctness . in the version of naive reverse without delays ,",
    "analysis can tell us that in all computed answers of ` reverse/2 ` both arguments are lists . in the delaying version ( figure [ fig_rev ] ) this is not the case , since there are floundered computed answers where both arguments are variables .",
    "this increases the flexibility of ` reverse/2 ` since it can delay rather than computing an infinite number of answers ( this is particularly important when ` reverse/2 ` is called as part of a larger computation ) .    in ( successful and floundered )",
    "computed answers for the delaying version of ` reverse/2 ` , the first argument of is a list if and only if the second argument is a list .",
    "this tells us that if either argument is a list in a call , the other argument will be instantiated to a list by the ` reverse/2 ` computation ( assuming it terminates ) .",
    "if the delay declaration for ` append/3 ` was changed so it delayed if just the first argument was a variable , ` reverse/2 ` would not work backwards .",
    "it would flounder rather than instantiate the first argument to a list and the `` if '' part of this dependency would not hold .",
    "this section shows how a program with delays can be very simply transformed into a program without delays which can be analysed to reveal information such as this .",
    "analysis of success in a program without delays can not give us information about ( non - ground ) delayed calls directly because success is closed under instantiation ( closure property 2 ) whereas floundering is not .",
    "however , extraneous function symbols allow us to _ encode _ non - ground atoms using ground atoms , re - establishing this proposition and allowing analysis .",
    "the encoding uses an isomorphism between the ( infinite ) set of variables and the set of terms with extraneous principal function symbols ( this set must also be infinite to avoid loss of precision in the encoding ; it is sufficient to have a single extraneous function symbol with arity greater than zero ) .",
    "the _ encoded flounder set ( @xmath77 ) _ of a program @xmath10 is the set of ground instances of atoms in @xmath15 such that distinct variables are replaced by distinct terms with extraneous principal function symbols .",
    "@xmath15 can be reconstructed from the atoms in @xmath77 by finding the set of most specific generalisations which contain only program function symbols .",
    "for example , the non - ground flounder set for append contains atoms such as ` append(xs , [ y ] , zs ) ` whereas the encoded flounder set contains atoms such as ` append(\\bowtie , [ \\otimes(1 ) ] , \\otimes(2 ) ) ` , assuming @xmath7 and @xmath78 are extraneous function symbols .",
    "we introduce two new `` builtin '' predicates , ` evar/1 ` and ` enonground/1 ` , which are true if their argument is an _ encoded _ variable or non - ground term , respectively . for simplicity ,",
    "our treatment assumes they are defined using an ( infinite ) set of facts : ` evar(t ) ` for all terms @xmath79 where the principal function symbol is not a program function symbol and ` enonground(t ) ` for all terms @xmath79 which have at least one extraneous function symbol .",
    "this can cause an infinite branching factor in sld trees ( for example , a call such as ` evar(x ) ` ) .",
    "however , since in this paper we deal with single derivations but not sld trees ( or finite failure ) , it causes us no difficulties .    ....",
    "evar('var ' ( _ ) ) .",
    "enonground(a ) : - evar(a ) . enonground([a|b ] ) : - enonground(a ) .",
    "enonground([a|b ] ) : - enonground(b ) .",
    "....    it is also possible to define ` evar/1 ` and ` enonground/1 ` in prolog .",
    "figure  gives a definition which assumes ` var/1 ` is the only extraneous function symbol of the original program and ` ./2 ` is the only program function symbol with arity greater than zero for the original program ( if there are other such function symbols , more clauses are needed for ` enonground/1 ` ) .",
    "these definitions depart from our theoretical treatment in that they can involve deeper proof trees ( due to recursive calls ) and they can have non - ground computed answers .",
    "however , they can be useful for observing floundering behaviour , especially with a fair ( or depth - bounded ) search strategy ",
    "see section [ sec_using_f ] .",
    "we now define the @xmath76 transformation :    given a program @xmath10 ( not defining predicates ` evar/1 ` or ` enonground/1 ` ) containing delay declarations , @xmath80 is the program with all clauses of @xmath10 plus , for each delay declaration ` : - delay a if c ` in @xmath10 , the clause ` a : - c ` where ` c ` is ` c ` with ` var ` replaced by ` evar ` and ` nonground ` replaced by ` enonground ` .",
    "these additional clauses introduced for delay declarations and those in the definitions of ` evar/1 ` and ` enonground/1 ` are referred to as _ delay clauses_.    .... append_sf(as , bs , cs ) : - evar(as ) , evar(cs ) .",
    "append_sf ( [ ] , as , as ) .",
    "append_sf(a.as , bs , a.cs ) : - append_sf(as , bs , cs ) .",
    "reverse_sf(as , bs ) : - evar(as ) , evar(bs ) .",
    "reverse_sf ( [ ] , [ ] ) .",
    "reverse_sf(a.as , bs ) : - append_sf(cs , [ a ] , bs ) , reverse_sf(as , cs ) . ....    to avoid possible confusion , the code in this paper uses `` ` _ sf ` '' suffixes for the new predicate definitions ; our theoretical treatment assumes the original predicate names are used for the new predicate definitions .",
    "for example , figure  shows the transformed version of ` reverse ` ( from figure [ fig_rev ] ) .",
    "figures [ fig_extra_d ] and [ fig_extra_du ] give further examples",
    ".    immediately floundered atoms in @xmath15 have matching delay declarations with true right hand sides .",
    "corresponding ( encoded ) atoms in @xmath77 have matching ground delay clause instances with successful bodies .",
    "we have described how ` evar ` and ` enonground ` behave .",
    "some languages have delay conditions which can not be expressed using _ var _ and _",
    "nonground_. for example , in nu - prolog ` x ~= y ` delays whereas ` x ~= x ` does not . to analyse such constructs we need additional primitives similar to ` evar ` and ` enonground ` .",
    "the key to designing such constructs is that the delay clauses should implement the encoding as defined above .",
    "the following propositions show how successful derivations in @xmath80 correspond to successful or floundered derivations in @xmath10 : the success set of @xmath80 is the union of the success set of @xmath10 without delays and the encoded flounder set of @xmath10 ( proposition [ prop_ss_sf_p ] ) .",
    "note that when we talk of successful derivations and/or @xmath11 here , sld resolution rather than sldf resolution is used ( delays are ignored when dealing with success ) .",
    "the lack of closure property 2 is problematic when dealing with success if delays are considered and sldf resolution used .",
    "[ prop_no_del_iff ] a goal @xmath34 has a successful sld derivation @xmath27 with program @xmath10 ( ignoring delays ) if and only if it has a successful derivation @xmath27 with @xmath80 which uses no delay clauses .",
    "@xmath80 without delay clauses is the same as @xmath10 without delays .",
    "we now deal with floundering , which is more complex .",
    "[ lem_im_fl ] a goal @xmath34 is immediately floundered with program @xmath10 if and",
    "only if it has a successful derivation @xmath27 with @xmath80 which uses only delay clauses .    follows from the way in which delay clauses implement the encoding of the flounder set .",
    "[ lem_subs_efs ]    a goal @xmath34 which is immediately floundered with program @xmath10 has a computed answer substitution @xmath33 in sf(p ) such that all variables bound by @xmath33 are bound to distinct terms with extraneous principal function symbols ( or are simply renamed ) .    by lemma [ lem_im_fl ] , there is a derivation where all non - renaming substitutions are due to calls to ` evar/1 ` and ` enonground/1 ` .",
    "a call to ` evar/1 ` binds its argument to a term with an extraneous principal function symbol .",
    "multiple calls with distinct variables will have some of the infinite number of computed answers binding their arguments to distinct terms .",
    "similarly , some computed answers to ` enonground/1 ` will bind all distinct variables in its argument to distinct terms with extraneous principal function symbols .",
    "[ lem_nfs_iff_sf_del ] given a program @xmath10 , a goal @xmath34 has a floundered derivation @xmath27 with an empty floundered computed answer substitution if and only if it has a successful derivation @xmath31 with @xmath80 in which delay clauses are selected and the successful computed answer , @xmath40 , is such that all variables bound by @xmath33 are bound to distinct terms with extraneous principal function symbols ( or are simply renamed ) .",
    "( only if ) derivation @xmath27 can be reproduced with @xmath80 since it has all the clauses of @xmath10 and the computation rule is unrestricted . by lemma [ lem_subs_efs ] the last resolvent in @xmath27 must have a successful derivation such that the computed answer substitution has the desired property .",
    "( if ) by repeated application of the switching lemma @xcite to @xmath31 we can construct a successful derivation @xmath81 with @xmath80 such that callable atoms are selected in preference to atoms which would delay in @xmath10 .",
    "the derivation has a prefix @xmath82 where only callable atoms are selected , except for @xmath83 , which would be immediately floundered in @xmath10 ( a delay clause is used in @xmath70 so an immediately floundered goal must be reached at some stage ) .",
    "callable atoms are not matched with delay clauses ( by lemma [ lem_im_fl ] , if a callable atom is resolved with a delay clause the resolvent can not succeed ) .",
    "variables bound by the computed answer substitution @xmath33 of @xmath70 are bound to distinct terms with extraneous principal function symbols ( or simply renamed ) , and all of the non - renaming bindings must be due to delay clauses .",
    "thus @xmath27 is a floundered sldf derivation in @xmath10 with an empty ( or renaming ) answer substitution .",
    "[ lem_sf_all_subs ] given a program @xmath10 , a goal @xmath34 has a successful derivation with @xmath80 with computed answer , @xmath40 , such that all variables bound by @xmath33 are bound to distinct terms with extraneous principal function symbols ( or are simply renamed ) if and only if there are successful derivations with all such computed answers .",
    "all such substitutions are due to delay clauses and the sets of ` enonground/1 ` and ` evar/1 ` atoms which succeed are closed under the operation of replacing one extraneous function symbol with another .",
    "[ prop_fl_iff_sf_del ] goal @xmath34 has a floundered sldf derivation @xmath27 with program @xmath10 if and only if it has a successful derivation @xmath31 with @xmath80 in which delay clauses are selected .",
    "propositions [ prop_gth_nfs ] and [ prop_gth_ca ] imply @xmath34 flounders if and only if an instance flounders with an empty floundered computed answer substitution so by lemma [ lem_nfs_iff_sf_del ] it is sufficient to show that an instance of @xmath34 has a successful derivation with @xmath80 in which delay clauses are selected and all variables bound by the computed answer substitution are bound to distinct terms with extraneous principal function symbols ( or are simply renamed ) iff @xmath34 has a successful derivation @xmath31 with @xmath80 in which delay clauses are selected .",
    "( only if ) by closure property 1 .",
    "( if ) consider a derivation @xmath84 using the same clause selection as in @xmath31 but with a computation rule such that atoms resolved with delay clauses are selected at the end , from @xmath85 . by lemma [ lem_mgi_gth ] , @xmath86 has a derivation where the @xmath87 resolvent is a variant of @xmath85 and the substitution at that point is a renaming substitution for @xmath86 . by lemma [ lem_subs_efs ] ,",
    "a computed answer substitution for @xmath85 has the desired property .",
    "[ prop_ss_sf_p ] for any program @xmath10 , @xmath88 .",
    "the set of atoms in @xmath89 with derivations which do nt use delay clauses is @xmath11 by proposition [ prop_no_del_iff ] .",
    "the set of atoms in @xmath89 with derivations which use delay clauses is @xmath77 by lemmas [ lem_nfs_iff_sf_del ] and [ lem_sf_all_subs ] .",
    "note that although there is a bijection between successful sld derivations with @xmath10 and successful sld derivations with @xmath80 which do nt use delay clauses , there is not a bijection between floundered sldf derivations with @xmath10 and successful derivations with @xmath80 which use delay clauses , even if multiple solutions to ` evar/1 ` and ` enonground/1 ` are ignored .",
    "@xmath80 generally has additional derivations .",
    "this is unavoidable due to the imprecision of @xmath15 mentioned in section [ sec : sldf ] .    ....",
    "p(x , y ) : - q(x ) , q(y ) .",
    "p_sf(x , y ) : - q_sf(x ) , q_sf(y ) .",
    ": - delay q(v ) when var(v ) .",
    "q_sf(v ) : - evar(v ) .",
    "q(a ) .                                   q_sf(a ) . ....    for example , consider the definition of ` p/2 ` in figure .",
    "the success set , ignoring delays , is \\{`p(a , a ) ` } and @xmath15 is \\{`p(x , y ) ` , ` p(a , v ) ` , ` p(v , a)`}. thus the computed answers of ` p_sf(x , y ) ` encode all these four atoms , since @xmath80 computes the union of the success set and the encoded flounder set . however , ` p(x ,",
    "y ) ` only has one floundered derivation , with the empty answer substitution .",
    "the other two atoms in @xmath15 are only computed for more instantiated goals and the derivations in @xmath80 correspond to these computations ( the same atoms are selected , ignoring ` evar/1 ` and ` enonground/1 ` ) .",
    ".... p : - q(x ) .",
    "p_sf : - q_sf(x )    : - delay q(v ) when var(v ) .",
    "q_sf(v ) : - evar(v ) .",
    "q(a ) .",
    "q(x ) : - q(x ) .",
    "q_sf(x ) : - q_sf(x ) . ....",
    "it is also possible to have successful derivations in @xmath80 which do not correspond to any sld or sldf derivation in @xmath10 .",
    "for example , in figure , the goal ` p ` has a single floundered sldf derivation , where ` q(x ) ` immediately flounders , whereas ` p_sf ` has an infinite number of derivations which use delay clauses and the derivations of ` q(x ) ` have unbounded length .",
    "this is related to the fact that ` p ` has an infinite sld tree .",
    "type dependencies of @xmath80 can be analysed in the same ways as any other prolog program .",
    "the following set of atoms , where @xmath90 means @xmath91 is a list , is a model of the transformed reverse program , showing these type dependencies hold ( and thus they hold for computed answers in the original reverse program with delays ) : @xmath92 it is not necessary to consider the complex procedural semantics of prolog with delays , or even the procedural semantics of prolog without delays since bottom - up analysis can be used .",
    "similarly , the @xmath76 transformation makes it relatively easy to show that ` submaxtree/2 ` can indeed compute a tree of integers when given a tree of integers as the first argument .",
    "groundness in @xmath10 can also be analysed by analysing @xmath80 using specialised types .",
    "we can define the type @xmath93 to be the set of terms constructed from only program function symbols .",
    "the dependencies which hold for lists above also hold for type @xmath93 , indicating the corresponding groundness dependencies hold for computed answers of reverse with delays . similarly , @xmath94 can be defined as the set of terms with a program principal function symbol . by extending the type / mode checker described in @xcite",
    "we have demonstrated it is possible to check non - trivial useful properties of @xmath10 by checking models of @xmath80 . for more complicated cases",
    "it is necessary to support sub - types , as @xmath94 and @xmath95 are both subtypes of @xmath93 .",
    "this approach to groundness analysis is not reliant on the @xmath76 transformation  it can be applied to any logic program due to observation [ obs_pfs ] .",
    "the analysis can be identical to conventional groundness analysis using boolean functions because logic programs can be abstracted in an identical way .",
    "a unification @xmath96 can be abstracted by @xmath97 , assuming @xmath98 is a program function symbol .",
    "calls @xmath99 and @xmath100 can be abstracted as @xmath101 .",
    "we now present a second transformation , which allows us to capture the non - ground flounder set more precisely .",
    "the results here suggest a solution to the open problem posed in @xcite : how the flounder set can be defined inductively . such a definition may be a very useful basis for analysis of floundering as an alternative to a purely model theoretic approach .",
    "the semantics of @xmath80 captures both successful and floundered derivations of @xmath10 . by defining a variant of the immediate consequence operator @xmath103",
    "we can distinguish atoms with derivations which use delay clauses .",
    "an _ f - interpretation _ is a set of ground atoms , some of which may be flagged ( to indicate floundering ) .",
    "if @xmath104 is an f - interpretation , @xmath105 is the set of atoms in @xmath104 and @xmath106 is the set of atoms in @xmath104 which are flagged .",
    "the union of two f - interpretations @xmath104 and @xmath107 is the f - interpretation @xmath108 such that @xmath109 and @xmath110 .    given a program @xmath10",
    ", @xmath111 is a mapping from f - interpretations to f - interpretations , defined as follows .",
    "@xmath112 and an atom @xmath8 in this set is flagged if there is a ground instance of a clause in @xmath80 , @xmath113 , such that each @xmath114 is in @xmath104 and some @xmath114 is flagged in @xmath104 or if the predicate of @xmath8 is ` evar/1 ` or ` enonground/1 ` . @xmath115 and @xmath116 are defined in the same way as @xmath117 and @xmath118 .",
    "[ prop_flag_iff_sf_del ] a ground atom other than ` evar/1 ` or ` enonground/1 ` is flagged in @xmath115 if and only if it has a proof tree of height @xmath119 in @xmath80 which uses a delay clause , and is flagged in @xmath116 if and only if it has a successful derivation in @xmath80 which uses a delay clause .",
    "a standard result is that @xmath120 ( and @xmath121 ) contains exactly those ground atoms with proof trees in @xmath80 ( of height @xmath119 , respectively ) .",
    "@xmath122 since @xmath123 . from the definition of @xmath111 ,",
    "these atoms are flagged if and only if they are derived using ` evar/1 ` or ` enonground/1 ` , that is , if a delay clause is used in the derivation .",
    "a ground atom @xmath8 other than ` evar/1 ` or ` enonground/1 ` is flagged in @xmath116 if and only if it is in the encoded flounder set of @xmath10 .    by proposition [ prop_flag_iff_sf_del ]",
    "it is sufficient to show that @xmath124 iff @xmath8 has a successful derivation @xmath27 in @xmath80 which uses a delay clause .",
    "if : the decoded version of @xmath8 ( distinct terms with extraneous principal function symbols are replaced by distinct variables ) , @xmath125 , has a successful derivation @xmath31 in @xmath80 using the same clause selection as that in @xmath27 , with a computed answer @xmath126 , which has @xmath8 as an instance .",
    "since @xmath126 has @xmath8 as an instance , any variables bound by @xmath33 must be bound to distinct terms with extraneous principal function symbols ( or simply renamed ) .",
    "thus @xmath31 satisfies the condition of lemma [ lem_nfs_iff_sf_del ] so @xmath125 is in @xmath15 .    only if : @xmath124 , so @xmath127 , where @xmath128 . by lemmas [ lem_nfs_iff_sf_del ] and [ lem_sf_all_subs ] , @xmath125 has a derivation which uses delay clauses and has a computed answer with an instance @xmath129 .",
    "@xmath8 has a successful derivation using the same clause selection .",
    "thus we have an inductive / fixed - point characterisation of ( a set isomorphic to ) the non - ground flounder set .",
    "it may be practical to base floundering analysis on @xmath111 .",
    "it is monotonic with respect to the set of atoms ( @xmath130 if @xmath131 ) and for a given set of atoms it is monotonic with respect to the flagged atoms in the set ( @xmath132 if @xmath133 and @xmath134 ) .",
    "monotonicity is important for the structure of fixed - points , particularly the existence of a least fixed - point .",
    "alternatively , the definition of @xmath111 can be mirrored by a further transformation which produces a program whose success set is the encoded flounder set of @xmath10 .",
    "an advantage is that it can then be analysed using standard techniques .",
    "a disadvantage is that the transformation increases the program size , which will affect analysis time .    given a horn clause program @xmath10 , @xmath135 is the program consisting of the predicate definitions in @xmath80 ( we assume each predicate has a @xmath136 subscript / postfix ) plus the following new definitions . for each clause @xmath137 in @xmath80",
    "we add a clause @xmath138 . for delay clauses , @xmath139 .",
    "for other clauses , @xmath140 , where @xmath27 is the disjunction of all calls in @xmath125 , with `` ` _ sf ` '' replaced by `` ` _ f ` '' .",
    "if @xmath125 is the empty conjunction ( ` true ` ) then @xmath141 is the empty disjunction ( ` fail ` ) .    ....",
    "append_f(as , bs , cs ) : - evar(as ) , evar(cs ) .",
    "append_f ( [ ] , as , as ) : - fail .",
    "append_f(a.as , bs , a.cs ) : -          append_sf(as , bs , cs ) , append_f(as , bs , cs ) .",
    "reverse_f(as , bs ) : - evar(as ) , evar(bs ) .",
    "reverse_f ( [ ] , [ ] ) : - fail .",
    "reverse_f(a.as , bs ) : -          reverse_sf(as , cs ) , append_sf(cs , [ a ] , bs ) ,          ( reverse_f(as , cs ) ; append_f(cs , [ a ] , bs ) ) .",
    "....    figure  gives the new clauses generated for ` reverse ` . note that we assume the original program consists of only horn clauses but the transformed program contains disjunctions .",
    "these could be eliminated by further transformation .",
    "the transformation is designed so that @xmath142 ( extended to handle disjunctions ) is essentially the same as @xmath111 : flagged atoms correspond to the @xmath143 subscripted predicates and the set of all atoms corresponds to the @xmath136 subscripted predicates .",
    "the success set of the @xmath143 subscripted predicates in @xmath135 is the encoded non - ground flounder set of the corresponding predicates in @xmath10 .",
    "the transformation allows us to observe the floundering behaviour of the original program very clearly . if we define ` evar ` as in figure [ fig_evar ] and run the goal ` append_f(x , y , z ) ` using a fair search strategy , we get computed answers of the form ` x = [ a`@xmath144`,a`@xmath145`, ... ,a`@xmath146`|'var'(b ) ] ` , ` y = c ` , ` z = [ a`@xmath144`,a`@xmath145`, ... ,a`@xmath146`|'var'(d ) ] ` .",
    "occurrences of ` var/1 ` in answers correspond to variables in computed answers of floundered derivations of the original program and variables correspond to arbitrary terms .",
    "thus a call to ` append ` flounders if and only if it has an instance such that the first and third arguments are `` incomplete lists '' ( lists with a variable at the tail rather than nil ) of the same `` length '' with pair - wise identical elements .",
    "for example , ` append(x,[a],[a|z ] ) ` flounders ( it also has a successful derivation ) whereas ` append([a , v|x],y,[v , b|z ] ) ` does not .",
    "running ` reverse_f ` we discovered to our surprise ( as mentioned in section [ sec : examples ] ) that ` reverse ` flounders if and only if the first argument is an incomplete list and the second argument is a _",
    "( rather than incomplete list ) . a call such as ` reverse(x,[a|y ] )",
    "` returns an infinite number of answers rather than floundering !    with a suitably expressive domain the transformed program can be analysed with established techniques to obtain precise information about the original program with delays .",
    "powerful techniques have been developed to help construct domains .",
    "for example , we can start with a simple domain containing four types : lists , @xmath147 ( the complement of our type @xmath94 ) , incomplete lists ( this is a supertype of @xmath147 ) , and a `` top '' element ( the universal type ) . completing this domain using disjunction",
    "@xcite adds two additional elements : `` list or var '' and `` list or incomplete list '' .",
    "the heyting completion @xcite of this domain introduces implications or dependencies such as @xmath91 is a list if @xmath148 is a list .",
    "this domain can be used as a basis for interpretations of the program and to infer and express useful information about floundering .",
    "@xmath149 @xmath150 @xmath151 @xmath152 @xmath153    for example , figure  gives the minimal model of the program for this domain , where @xmath154 represents the type @xmath147 , @xmath155 the type @xmath95 and @xmath156 the set of incomplete lists ( this was found using the system described in @xcite , with additional modifications and manual intervention ) .",
    "it expresses the fact that ` reverse ` flounders only if the first argument is an incomplete list and the second is a variable .",
    "the condition for ` append ` is somewhat more complex .",
    "it is possible to drop the last conjunct for @xmath157 and replace @xmath158 by @xmath159 for @xmath160 to obtain a simpler model .",
    "further simplification does not seem possible without weakening the condition for ` reverse ` .",
    "we note that careful design of the types in the domain is crucial for the precision .",
    "the incomplete list type is able to make the important distinction between ( encoded versions of ) ` [ x ] ` and ` [ [ ] |x ] ` .",
    "analysis without this distinction must conclude that calls to ` reverse/2 ` where both arguments are ( complete ) lists may flounder . to see this , consider the following instance of the recursive clause for ` reverse/2 ` .    ....",
    "reverse([a , x ] , [ x ] ) : - append([x ] , [ a ] , [ x ] ) , reverse([x ] , [ x ] ) .",
    "....    if we replace the two occurrences of ` [ x ] ` in ` append ` by ` [ [ ] |x ] ` then the clause body flounders with an empty computed answer substitution . thus any safe approximation to the set of floundering atoms must include the head of this clause .",
    "inferring models is significantly more challenging than checking models .",
    "the domain is huge and the models can be quite complex , even for simple programs ( see the condition for @xmath157 in figure , for example ) .",
    "after some ad hoc attempts to find models for @xmath135 , particularly minimum models within our abstract domain , a more systematic approach was developed .",
    "we use the relationship between predicates in @xmath10 and their subscripted variants in minimum models .",
    "we first compute a model @xmath161 for @xmath10 ( the minimum model for @xmath10 in our abstract domain ) .",
    "we use this as a starting point to compute a ( larger ) model @xmath162 for the ` \" _ sf \" ` predicates .",
    "we then use @xmath163 as a starting point to compute a model for the ` \" _ f \" ` predicates .",
    "this strategy may also be useful for automatic inference of precise floundering information since although there are three separate fixed - point calculations , each one is relatively simple and should converge quickly .",
    "declarative debugging @xcite can be an attractive alternative to static analysis since more information is known at debug time than at static analysis time and hence bugs can potentially be located more easily and precisely .",
    "the @xmath102 transformation of section [ sec : cfs ] potentially provides a mechanism for declarative debugging of incorrectly floundered computations ",
    "a floundered derivation of @xmath10 corresponds to a successful derivation of @xmath135 and debugging of incorrect successful derivations is well understood .",
    "the main novel requirement is that the user must be able to determine which ( encoded ) atoms should flounder ( that is , an intended interpretation for the ` _ f ` predicates ) .",
    "it is also important for the debugger to understand the relationship between the ` _ f ` and ` _ sf ` predicates because their intended interpretations are not independent .    in @xcite",
    "we propose a more practical approach which does nt use the transformations and encoding explicitly , but does use them to guide the design .",
    "it uses the three - valued debugging scheme of @xcite , where atoms can be correct , incorrect or _",
    "inadmissible _ , meaning they should never occur .",
    "atoms which have insufficiently instantiated `` inputs '' ( and hence flounder ) are considered inadmissible .",
    "the user effectively supplies a three - valued interpretation in the style of @xcite for @xmath80 and the debugger finds a clause ( possibly a delay clause ) for which this interpretation is not a ( three - valued ) model . as well as model - theoretic semantics",
    ", @xcite provides a fixed - point semantics .",
    "this could also be applied to analysis of delays by using transformation and encoding , particularly if the user specifies intended modes in some way .",
    "the transformation - based method used to detect deadlocks in parallel logic programs @xcite bears superficial similarity to our work here .",
    "however , those transformations do not eliminate delays , and both the original code and transformed code have impure features such as pruning operators for committed choice non - determinism and nonvar checks .",
    "our approach to analysis of floundering here is unusual in that it supports a declarative , `` bottom - up '' or `` goal independent '' approach .",
    "analysis of logic programs with the conventional left to right computation rule has been done using both top - down and bottom - up methods .",
    "the top - down methods are based on the procedural semantics ",
    "sld resolution  maintaining information about variables and substitutions to obtain approximations to the sets of calls and answers to procedures .",
    "the bottom - up methods ( which are independent of the computation rule ) are based on the fixed - point semantics ( the immediate consequence operator , which is very closely related to the model theoretic semantics ) to obtain approximations to the set of answers to procedures .",
    "an advantage of the bottom - up approach is its simplicity . using the standard fixed point semantics @xcite",
    "( see also @xcite ) the domain contains sets of ground atoms and a clause can be treated as equivalent to the set of its ground instances .",
    "the disadvantage is lack of precision : the naive bottom - up approach obtains no information about calls or non - ground computed answers , both of which seem important for modeling systems with flexible computation rules .",
    "two methods are used to re - gain this information .",
    "non - ground computed answers can be captured by using a more complicated immediate consequence operator , such as the s - semantics , making the domain more complex by re - introducing variables .",
    "calls can be captured by using the magic set ( or similar ) transformation , adding complexity to the program being analysed , but this assumes a left to right computation rule . since there has been no known bottom - up method for approximating the instantiation states of calls in logic programs with delays , it is natural that most other work on analysis of such programs @xcite @xcite @xcite @xcite @xcite @xcite @xcite has been based on the top - down procedural semantics .",
    "the more recent approach of @xcite uses bottom - up analysis , and argues strongly for the practicality of bottom - up methods .",
    "a relatively standard bottom - up least fixed - point analysis is used to compute groundness dependencies for successful computed answers of all predicates using the @xmath164 domain ( positive boolean functions ) .",
    "in addition , a novel greatest fixed - point computation is used to find sufficient conditions for predicates to be flounder - free , using the @xmath165 domain ( monotonic boolean functions ) . however",
    ", this analysis assumes a local computation rule is used .",
    "programs such as ` submaxtree/2 ` ( and examples given in @xcite ) have cyclic data - flow and do not work with a local computation rule , so the greatest fixed - point computation results in significant loss of precision .",
    "our transformations make no assumptions about the computation rule other than it is safe with respect to the delay declarations , so ( in this respect ) it can be more precise .",
    "we have shown an alternative way the `` lloyd '' semantics can be adapted to capture information about variables : simply change the set of function symbols rather than the immediate consequence operator .",
    "the extra function symbols allow us to encode and capture the behaviour of non - ground atoms . furthermore , by encoding the non - ground flounder set it becomes closed under instantiation , allowing safe approximation by the success set of a ( transformed ) program without delays .",
    "floundering information can then be obtained by a simple bottom - up analysis using sets of ground atoms .",
    "the complexity associated with variables does not magically disappear entirely . in practice",
    "it can re - emerge in the abstract domain of types used in the analysis .",
    "however , careful integration of type and instantiation information seems unavoidable if analysis of floundering is to be precise , so combining both in the type domain is probably a good idea .",
    "using the procedural semantics has the advantage of being ( strictly ) more expressive than the declarative approach , so analysis of more properties is possible .",
    "analysis of ( for example ) whether a particular sub - goal will ever delay ( for a particular computation rule ) is beyond the scope of our approach and can only be done with procedural information .",
    "a disadvantage is the additional complexity .",
    "each ( non - ground ) atom has a set of computed answers and for each one there is a set of immediately floundered atoms .",
    "the analysis domain typically contains representations of sets of these triples .",
    "we believe that analysis of such things as computed answers and whether a computation flounders is likely to benefit from the declarative approach we have proposed , where the analysis domain can contain just sets of ground atoms .",
    "expressive languages for defining such sets have been developed for type - related analysis .",
    "with an intuitive restriction on delay primitives , floundering is independent of the computation rule .",
    "however , the development of a declarative rather than procedural understanding of floundering has been hindered because it is not closed under instantiation . in this paper",
    "we have shown how non - ground atoms can be encoded by ground atoms , using function symbols which do not occur in the program or goal .",
    "some may consider this to be a theoretical `` hack '' , but it has numerous advantages .",
    "this technique , along with two quite simple program transformations , allows floundering behaviour of a logic program with delays to be precisely captured by the success set of a logic program without delays . by simply executing the transformed program using a fair search strategy ,",
    "the delaying behaviour can be exposed .",
    "declarative debugging can be used to diagnose errors related to control as well as logic , and alternative semantic frameworks can be applied .",
    "finally , the wealth of techniques which have been developed for analysing downward closed properties such as groundness and type dependencies can be used to check or infer floundering behaviour .            , codognet , p. , and corsini , m .- m .",
    "abstract interpretation for concurrent logic languages . in _ proceedings of the north american conference on logic programming _ ,",
    "s.  debray and m.  hermenegildo , eds . the mit press , austin , texas , 215232 .    , le  charlier , b. , and rossi , s. 2001 .",
    "reexecution - based analysis of logic programs with delay declarations . in _ proc . of the andrei ershov fourth international conference on perspectives of system informatics ( psi01)_. lncs 2244 .",
    "springer - verlag , 395405 .",
    ", sndergaard , h. , and dart , p. 1990 . a characterization of non - floundering logic programs . in _ proceedings of the north american conference on logic programming",
    ", s.  debray and m.  hermenegildo , eds . the mit press , austin , texas , 661680 .                        ,",
    "henderson , f.  j. , and conway , t. 1995 .",
    "mercury : an efficient purely declarative logic programming language . in _ proceedings of the australian computer science conference_. glenelg , australia , 499512 ."
  ],
  "abstract_text": [
    "<S> we show how logic programs with `` delays '' can be transformed to programs without delays in a way which preserves information concerning floundering ( also known as deadlock ) . </S>",
    "<S> this allows a declarative ( model - theoretic ) , bottom - up or goal independent approach to be used for analysis and debugging of properties related to floundering . </S>",
    "<S> we rely on some previously introduced restrictions on delay primitives and a key observation which allows properties such as groundness to be analysed by approximating the ( ground ) success set . </S>",
    "<S> this paper is to appear in theory and practice of logic programming ( tplp ) .    </S>",
    "<S> floundering , delays , coroutining , program analysis , abstract interpretation , program transformation , declarative debugging </S>"
  ]
}