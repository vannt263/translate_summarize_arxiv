{
  "article_text": [
    "the simplest formulation of planning  referred to as classical planning  entails finding a sequence of actions that takes a world from a completely known initial state to a state that satisfies certain goal conditions .",
    "the inputs to a corresponding planner are the descriptions ( in a compact description language such as strips @xcite ) of the effects of actions on the world , the description of the initial state and the description of the goal conditions , and the output is a plan ( if it exists ) consisting of a sequence of actions .",
    "the complexity of classical planning is known to be undecidable in the general case @xcite .",
    "it reduces to pspace - complete for finite and deterministic domains @xcite . by making certain assumptions such as fixing the length of plans , and requiring actions to be deterministic",
    "the complexity reduces to np - complete .",
    "the ability to plan is widely recognized to be an important characteristic of an intelligent entity .",
    "thus , when developing intelligent systems , we often need to incorporate planning capabilities , despite their inherent complexity . since the complexity is due to the exponential size of the search space ,",
    "planning approaches that overcome this complexity require efficient and intelligent search .",
    "this is at the crux of three common and successful approaches to planning : ( i ) using heuristics @xcite that are derived from the problem description , ( ii ) translating the planning problem into a model finding problem in a suitable logic and using model finding techniques for that logic @xcite , and ( iii ) using domain - dependent control knowledge @xcite .",
    "the use of domain - dependent control knowledge has led to several successful planners , including tlplan @xcite , talplan @xcite and shop @xcite , which have performed very well on planning benchmarks .",
    "strictly speaking , planners that use control knowledge are no longer considered to be classical planners since they require the addition of domain - dependent control knowledge to the problem specification .",
    "nevertheless , such planners are predicted to be the most scalable types of planning systems in the long term @xcite . in this paper",
    "we integrate the second and the third approaches identified above by translating a planning problem with domain - dependent control knowledge into a problem of model finding in logic programming .",
    "we integrate domain - dependent control knowledge into our planner in such a way that planning can still be performed without this extra control knowledge .",
    "the control knowledge may simply improve the speed with which a plan is generated or may result in the generation of plans with particular desirable characteristics . in this respect",
    "our approach is similar in spirit to the planning systems tlplan @xcite , and talplan @xcite , but differs from typical hierarchical task network ( htn ) planners ( e.g. , shop @xcite ) because htn planners require integration of domain - dependent control knowledge into the specification of the planning problem . as such , htn planning can not be performed without the existence of this knowledge , unlike our planner .    in this paper , we explore three kinds of domain control knowledge : temporal knowledge , procedural knowledge , and htn - based knowledge . our treatment of temporal knowledge is similar to that used in both the tlplan and talplan systems .",
    "our formulation of procedural knowledge is inspired by golog , referred to alternatively as a logic programming language , or an action execution language @xcite .",
    "although our procedural knowledge is similar to the syntax of a golog program , how this knowledge is used in planning is quite different .",
    "similarly , our formulation of htn - based knowledge is inspired by the partial - ordering constructs used in htn planners , but our use of this type of knowledge during planning is very different from the workings of htn planners .",
    "the main difference is that both golog programming and htn planning rely on the existence of domain - dependent control knowledge within the problem specification and can not perform classical planning in the absence of this knowledge .",
    "in contrast , our approach , which is similar to the approach in @xcite , separates the planner module from the domain knowledge ( encoding temporal , procedural , or htn - based knowledge ) , and can plan independent of the domain knowledge .    to achieve our goal of planning using domain - dependent control knowledge ,",
    "an important first step is to be able to both reason about actions and their effects on the world , and represent and reason about domain - dependent control knowledge .",
    "this leads to the question of choosing an appropriate language for both reasoning and representation tasks .",
    "for this we choose the action language @xmath0 from @xcite and the language of logic programming with answer set semantics ( ansprolog * ) @xcite , also referred to as a - prolog @xcite .",
    "we discuss our choice on @xmath0 in section [ s2 ] .",
    "we selected ansprolog * over other action languages for a number of important reasons , many of which are listed below .",
    "these points are elaborated upon in @xcite .",
    "* ansprolog * is a non - monotonic language that is suitable for knowledge representation .",
    "it is especially well - suited to reasoning in the presence of incomplete knowledge . *",
    "the non - classical constructs give a structure to ansprolog * programs and statements , such as a head and a body , which allows us to define various subclasses of the language , each with different complexity and expressivity properties @xcite .",
    "the subclass of ansprolog * programs in which no classical negation is allowed has the same complexity as propositional logic , but with added expressivity . the most general class of ansprolog * programs , which allows `` * or * '' in the head , has the complexity and expressivity of the seemingly more complicated default logic @xcite .",
    "in general , ansprolog * is syntactically simpler than other non - monotonic logics while equally as expressive as many .",
    "* there exists a sizable body of `` building block '' results about ansprolog * which we may leverage both in knowledge representation tasks and in the analysis of the correctness of the representations .",
    "this includes result about composition of several ansprolog * programs so that certain original conclusions are preserved ( referred to as ` restricted monotonicity ' ) , a transformation of a program so that it can deal with incomplete information , abductive assimilation of new knowledge , language independence and tolerance , splitting an ansprolog * program to smaller components for computing its answer sets , and proving properties about the original program .",
    "* there exist several efficient ansprolog * interpreters @xcite and ansprolog * has been shown to be useful in several application domains other than knowledge representation and planning .",
    "this includes policy description , product configuration , cryptography and encryption , wire routing , decision support in a space shuttle and its ` if'`then ' structure has been found to be intuitive for knowledge encoding from a human expert point of view . * finally ,",
    "ansprolog * has already been used in planning @xcite , albeit in the absence of domain - dependent control knowledge . in this regard ansprolog",
    "* is suitable for concisely expressing the effects of actions and static causal relations between fluents .",
    "note that concise expression of the effects of actions requires addressing the ` frame problem ' which was one of the original motivation behind the development of non - monotonic logics . together with its ability to enumerate possible action occurrences ansprolog",
    "* is a suitable candidate for model - based planning , and falls under category ( ii ) ( above ) of successful approaches to planning .    as evident from our choice of language ,",
    "our main focus in this paper is the knowledge representation aspects of planning using domain - dependent control knowledge .",
    "in particular , our concerns includes :    * the ease of expressing effects of actions on the world , and reasoning about them , * the ease of expressing and reasoning about various kinds of domain constraints , * the ease of adding new kinds of domain constraints , and * correctness results for the task of planning using an ansprolog * representation that includes domain constraints .",
    "we also perform a limited number efficiency experiments , but leave more detailed experimentation to future work .    with the above focus , the contributions of the paper and the outline of the paper is as follows :    1 .",
    "in section  [ asp - sec ] we encode planning ( without domain constraints ) using ansprolog * in the presence of both dynamic effects of actions and static causal laws , and with goals expressed as a conjunction of fluent literals .",
    "we then formally prove the relationship between valid trajectories of the action theory and answer sets of the encoded program .",
    "our approach is similar to @xcite but differs from @xcite .",
    "the main difference between our formulation and earlier ansprolog * encodings in @xcite is in our use of static causal laws , and our consideration of trajectories instead of plans .",
    "our trajectories are similar to histories in @xcite and to optimistic plans in @xcite .",
    "the reason we relate answer sets to trajectories rather than relating them to plans is because in the presence of static causal laws the effects of actions may be non - deterministic .",
    "2 .   in section  [ s31 ]",
    "we show how to incorporate temporal constraints for planning into our formulation of the planning problem .",
    "incorporating temporal constraints simply requires the addition of a few more rules , illustrating the declarative nature and elaboration tolerance of our approach .",
    "we define formulas for representing temporal constraints and specify when a trajectory satisfies a temporal constraint .",
    "we then formally prove the relationship between valid trajectories of the action theory satisfying the temporal constraints , and answer sets of the updated program .",
    "our approach differs from @xcite in that we use ansprolog * for both the basic encoding of planning and the temporal constraints , while the planners in @xcite are written in procedural languages .",
    "preliminary experiments show that our approach is less efficient than tlplan and talplan .",
    "nevertheless , both these systems are highly optimized , so the poorer performance may simply reflect the lack of optimizations in our implementation .",
    "on the other hand , our use of ansprolog * facilitates the provision of correctness proofs , which is one of our major concerns .",
    "neither of @xcite provide correctness proofs of their planners .",
    "3 .   in section  [ s32 ]",
    "we consider the use of procedural domain knowledge in planning .",
    "an example of a procedural domain knowledge is a program written as a@xmath1 ; a@xmath2 ; ( a@xmath3 @xmath4 a@xmath5 @xmath4 a@xmath6);f ? .",
    "this program tells the planner that it should make a plan where @xmath7 is the first action , @xmath8 is the second action and then it should choose one of @xmath9 , @xmath10 or @xmath11 such that after the plan s execution @xmath12 will be true .",
    "+ we define programs representing procedural domain knowledge and specify when a trajectory is a trace of such a program .",
    "we then show how to incorporate the use of procedural domain knowledge in planning to the initial planning formulation described in item ( 1 . ) . as in ( 2 . )",
    "the incorporation involves only the addition of a few more rules .",
    "we then formally prove the relation between valid trajectories of the action theory satisfying the procedural domain knowledge , and answer sets of the updated program .",
    "we also present experimental results ( section  [ s34 ] ) showing the improvement in planning time due to using such knowledge over planning in the absence of such knowledge .",
    "4 .   in section  [ s33 ]",
    "we motivate the need for additional constructs from htn planning to express domain knowledge and integrate features of htns with procedural constructs to develop a more general language for domain knowledge .",
    "we then define trace of such general programs and show how to incorporate them in planning .",
    "we then formally prove the relation between valid trajectories of the action theory satisfying the general programs containing both procedural and htn constructs , and answer sets of the updated program . to the best of our knowledge",
    "this is the first time an integration of htn and procedural constructs has been proposed for use in planning .",
    "as noted above , a significant contribution of our work is the suite of correctness proofs for our ansprolog * formulations .",
    "all the proofs appear in appendix a. for completeness appendix b presents results concerning ansprolog * that we use in the appendix a proofs .    in regards to closely related work , although satisfiability planning ( see e.g. , @xcite ) has been studied quite a bit , those papers do not have correctness proofs and do not use the varied domain constraints that we use in this paper .",
    "we now start with some preliminaries and background material about reasoning about actions and ansprolog * , which will be used in the rest of the paper .",
    "in this section , we review the basics of the action description language @xmath0 , the answer set semantics of logic programs ( ansprolog ) , and key features of problem solving using ansprolog .",
    "recall that planning involves finding a sequence of actions that takes a world from a given initial state to a state that satisfies certain goal conditions . to do planning",
    ", we must first be able to reason about the impact of a single action on a world .",
    "this is also the first step in ` reasoning about actions ' . in general , reasoning about action involves defining a transition function from states ( of the world ) and actions to sets of states where the world might be after executing the action .",
    "since explicit representation of this function would require exponential space in the size of the number of fluents ( i.e. , properties of the world ) , actions and their effects on the world are described using an action description language , and the above mentioned transition function is implicitly defined in terms of that description . in this paper , we adopt the language @xmath0 @xcite , which is a subset of the language proposed in @xcite , for its simple syntax and its capability to represent relationships between fluents , an important feature lacking in many variants of the action description language @xmath13 @xcite .",
    "we note that the main results of this paper can be used in answer set planning systems which use other languages for representing and reasoning about the effects of actions .",
    "we now present the basics of the action description language @xmath0 . an action theory in @xmath0",
    "is defined over two disjoint sets , a set of actions * a * and a set of fluents * f * , which are defined over a signature @xmath14 where    * @xmath15 is a finite set of object constants ; * * an * is a finite set of _ action names _ , each action name is associated with a number @xmath16 , @xmath17 , which denotes its arity ; and * * fn * is a finite set of _ fluent names _ , each fluent name is associated with a number @xmath16 , @xmath17 , which denotes its arity .",
    "an action in * a * is of the form @xmath18 where @xmath19 is a n - ary action name and @xmath20 is a constant in * o*. a fluent in * f * is of the form @xmath21 where @xmath22 is an m - ary fluent name and @xmath20 is a constant in * o*. for simplicity , we often write @xmath23 and @xmath12 to represent an action or a fluent whenever it is unambiguous .",
    "furthermore , we will omit the specification of @xmath24 when it is clear from the context .",
    "a _ fluent literal _ is either a fluent @xmath25 or its negation @xmath26 .",
    "fluent formula _ is a propositional formula constructed from fluent literals .",
    "an action theory is a set of propositions of the following form : @xmath27 where @xmath12 and @xmath28 s are fluent literals and @xmath23 is an action .",
    "( [ static ] ) represents a _",
    "static causal law _ ,",
    "i.e. , a relationship between fluents and @xmath29 . ] .",
    "it conveys that whenever the fluent literals @xmath30 hold in a state , that causes @xmath12 to also hold in that state .",
    "( [ dynamic ] ) , referred to as a _ dynamic causal law _ , represents the ( conditional ) effect of @xmath23 while ( [ exec ] ) encodes an executability condition of @xmath23 .",
    "intuitively , an executability condition of the form ( [ exec ] ) states that @xmath23 can only be executed if @xmath28 s holds .",
    "a dynamic law of the form ( [ dynamic ] ) states that @xmath12 is caused to be true after the execution of @xmath23 in any state of the world where @xmath30 are true .",
    "propositions of the form ( [ init ] ) are used to describe the initial state .",
    "they state that @xmath12 holds in the initial state .",
    "an _ action theory _ is a pair @xmath31 where @xmath32 , called the _ initial state _ , consists of propositions of the form ( [ init ] ) and @xmath33 , called _ the domain description _ , consists of propositions of the form ( [ static])-([exec ] ) . for convenience ,",
    "we sometimes denote the set of propositions of the form ( [ static ] ) , ( [ dynamic ] ) , and ( [ exec ] ) by @xmath34 , @xmath35 , and @xmath36 , respectively .",
    "[ ex1 ]    let us consider a modified version of the suitcase @xmath37 with two latches from @xcite .",
    "we have a suitcase with two latches @xmath38 and @xmath39 .",
    "@xmath38 is up and @xmath39 is down . to open a latch ( @xmath38 or @xmath39 )",
    "we need a corresponding key ( @xmath40 or @xmath41 , respectively ) . when the two latches are in the up position , the suitcase is unlocked .",
    "when one of the latches is down , the suitcase is locked .",
    "the signature of this domain consists of    * @xmath42 ; * @xmath43 , both action names are associated with the number 1 , and * @xmath44 , all fluent names are associated with the number 1 .    in this domain , we have that @xmath45 and @xmath46 we now present the propositions describing the domain .    opening a latch puts it into the up position .",
    "this is represented by the dynamic laws : @xmath47 closing a latch puts it into the down position .",
    "this can be written as : @xmath48 we can open the latch only when we have the key .",
    "this is expressed by : @xmath49 no condition is required for closing a latch .",
    "this is expressed by the two propositions : @xmath50 the fact that the suitcase will be unlocked when the two latches are in the up position is represented by the static causal law : @xmath51 finally , to represent the fact that the suitcase will be locked when either of the two latches is in the down position , we use the following static laws : @xmath52 the initial state of this domain is given by @xmath53    a domain description given in @xmath0 defines a transition function from pairs of actions and states to sets of states whose precise definition is given below . intuitively , given an action @xmath23 and a state @xmath37",
    ", the transition function @xmath54 defines the set of states @xmath55 that may be reached after executing the action @xmath23 in state @xmath37 . if @xmath55 is an empty set it means that the execution of @xmath23 in @xmath37 results in an error .",
    "we now formally define @xmath54 .",
    "let @xmath33 be a domain description in @xmath0 .",
    "a set of fluent literals is said to be _ consistent _ if it does not contain @xmath12 and @xmath26 for some fluent @xmath12 . an _ interpretation _",
    "@xmath56 of the fluents in @xmath33 is a maximal consistent set of fluent literals of @xmath33 .",
    "a fluent @xmath12 is said to be true ( resp .",
    "false ) in @xmath56 iff @xmath57 ( resp .",
    "@xmath58 ) .",
    "the truth value of a fluent formula in @xmath56 is defined recursively over the propositional connectives in the usual way .",
    "for example , @xmath59 is true in @xmath56 iff @xmath12 is true in @xmath56 and @xmath60 is true in @xmath56 .",
    "we say that a formula @xmath61 holds in @xmath56 ( or @xmath56 satisfies @xmath61 ) , denoted by @xmath62 , if @xmath61 is true in @xmath56 .",
    "let @xmath63 be a consistent set of fluent literals and @xmath64 a set of static causal laws .",
    "we say that @xmath63 is closed under @xmath64 if for every static causal law @xmath65 in @xmath64 , if @xmath66 then @xmath67 .",
    "by @xmath68 we denote the least consistent set of literals from @xmath33 that contains @xmath63 and is also closed under @xmath64 .",
    "it is worth noting that @xmath68 might be undefined .",
    "for instance , if @xmath63 contains both @xmath12 and @xmath26 for some fluent @xmath12 , then @xmath68 can not contain @xmath63 and be consistent ; another example is that if @xmath69 and @xmath64 contains @xmath70 and @xmath71 then @xmath68 does not exist because it has to contain both @xmath72 and @xmath73 , which means that it is inconsistent .    formally ,",
    "a _ state _ of @xmath33 is an interpretation of the fluents in * f * that is closed under the set of static causal laws @xmath34 of @xmath33 .",
    "an action @xmath23 is _ executable _ in a state @xmath37 if there exists an executability proposition @xmath74 in @xmath33 such that @xmath75 . clearly , if @xmath76 belongs to @xmath33 , then @xmath23 is executable in every state of @xmath33 .",
    "the _ direct effect of an action a _ in a state @xmath37 is the set @xmath77    for a domain description @xmath33 , @xmath55 , the set of states that may be reached by executing @xmath23 in @xmath37 , is defined as follows .",
    "if @xmath23 is executable in @xmath37 , then @xmath78 2 .",
    "if @xmath23 is not executable in @xmath37 , then @xmath79 .    the intuition behind the above formulation is as follows .",
    "the direct effects of an action @xmath23 in a state @xmath37 are determined by the dynamic causal laws and are given by @xmath80 .",
    "all fluent literals in @xmath80 must hold in any resulting state .",
    "the set @xmath81 contains the fluent literals of @xmath37 which continue to hold by inertia ,",
    "i.e they hold in @xmath82 because they were not changed by an action .",
    "in addition , the resulting state must be closed under the set of static causal laws @xmath34 .",
    "these three aspects are captured by the definition above .",
    "observe that when @xmath34 is empty and @xmath23 is executable in state @xmath37 , @xmath55 is equivalent to the set of states that satisfy @xmath80 and are closest to @xmath37 using symmetric difference is strictly closer to @xmath37 than @xmath83 if @xmath84 .",
    "] as the measure of closeness  @xcite .",
    "additional explanations and motivations behind the above definition can be found in @xcite .",
    "every domain description @xmath33 in @xmath0 has a unique transition function @xmath54 , and we say @xmath54 is the transition function of @xmath33 .",
    "we illustrate the definition of the transition function in the next example .",
    "[ ex2 ] for the suitcase domain in example [ ex1 ] , the initial state given by the set of propositions @xmath85 is @xmath86 in state @xmath87 , the three actions @xmath88 , @xmath89 , and @xmath90 are executable .",
    "@xmath88 is executable since @xmath91 is true in @xmath87 while @xmath89 and @xmath90 are executable since the theory ( implicitly ) contains the propositions : @xmath92 which indicate that these two actions are always executable .",
    "the following transitions are possible from state @xmath87 : @xmath93    for a domain description @xmath33 with transition function @xmath54 , a sequence @xmath94 where @xmath95 s are states and @xmath96 s are actions is called a _ trajectory _ in @xmath33 if @xmath97 for @xmath98 .",
    "a trajectory @xmath94 achieves a fluent formula @xmath99 if @xmath100 .",
    "a domain description @xmath33 is _ consistent _ iff for every action @xmath23 and state @xmath37 , if @xmath23 is executable in @xmath37 , then @xmath101 .",
    "an action theory @xmath31 is consistent if @xmath33 is consistent and @xmath102 is a state of @xmath33 . in what follows , we will consider only - complete even with respect to a complete initial state .",
    "] consistent action theories .",
    "a _ planning problem _ with respect to @xmath0 is specified by a triple @xmath103 where @xmath31 is an action theory in @xmath0 and @xmath99 is a fluent formula ( or _ goal _ ) , which a goal state must satisfy .",
    "a sequence of actions @xmath104 is then called a _",
    "possible plan for @xmath99 _ if there exists a trajectory @xmath105 in @xmath33 such that @xmath87 and @xmath106 satisfies @xmath32 and @xmath99 , respectively .",
    "note that we define a ` possible plan ' instead of a ` plan ' .",
    "this is because the presence of static causal laws in @xmath33 allows the possibility that the effects of actions may be non - deterministic , and planning with non - deterministic actions has the complexity of @xmath107-complete @xcite and hence is beyond the expressiveness of ansprolog .",
    "however , if @xmath33 is deterministic , i.e. , @xmath108 for every pair @xmath109 of actions and states , then the notions of ` possible plan ' and ` plan ' coincide .      in this section",
    "we review ansprolog ( a sub - class of ansprolog * ) and its applicability to problem solving .",
    "although the programming language prolog and the field of logic programming have been around for several decades , the answer set semantics of logic programs  initially referred to as the stable model semantics , was only proposed by gelfond and lifschitz in 1988 @xcite . unlike earlier characterizations of logic programs where the goal was to find a unique appropriate ` model ' of a logic program , the answer set semantics allows the possibility that a logic program may have multiple appropriate models , or no appropriate models at all .",
    "initially , some considered the existence of multiple or no stable models to be a drawback of stable model semantics , while others considered it to be a reflection of the poor quality of the program in question . nevertheless , it is this feature of the answer set semantics @xcite that is key to the use of ansprolog for problem solving .",
    "we now present the syntax and semantics of ansprolog , which we will simply refer to as a logic program .    a logic program",
    "@xmath110 is a set of rules of the form @xmath111 or @xmath112 where @xmath113 , each @xmath96 is an atom of a first - order language @xmath114 , @xmath115 is a special symbol denoting the truth value _ false _ , and @xmath116 is a connective called _ negation - as - failure_. a negation as failure literal ( or naf - literal ) is of the form @xmath117 where @xmath23 is an atom . for a rule of the form ( [ lprule1])-([lprule2 ] ) , the left and right hand side of the rule are called the _ head _ and the _ body _ , respectively . a rule of the form ( [ lprule2 ] ) is also called a constraint .    given a logic program @xmath110 , we will assume that each rule in @xmath110 is replaced by the set of its ground instances so that all atoms in @xmath110 are ground .",
    "consider a set of ground atoms @xmath118 .",
    "the body of a rule of the form ( [ lprule1 ] ) or ( [ lprule2 ] ) is satisfied by @xmath118 if @xmath119 and @xmath120 .",
    "a rule of the form ( [ lprule1 ] ) is satisfied by @xmath118 if either its body is not satisfied by @xmath118 or @xmath121 .",
    "a rule of the form ( [ lprule2 ] ) is satisfied by @xmath118 if its body is not satisfied by @xmath118 .",
    "an atom @xmath23 is supported by @xmath118 if @xmath23 is the head of some rule of the form ( [ lprule1 ] ) whose body is satisfied by @xmath118 .    for a set of ground atoms @xmath122 and a program @xmath110",
    ", the reduct of @xmath110 with respect to @xmath122 , denoted by @xmath123 , is the program obtained from the set of all ground instances of @xmath110 by deleting    1 .",
    "each rule that has a naf - literal @xmath117 in its body with @xmath124 , and 2 .",
    "all naf - literals in the bodies of the remaining clauses .",
    "@xmath122 is an _ answer set ( or a stable model ) _ of @xmath110 if it satisfies the following conditions .    1 .",
    "if @xmath110 does not contain any naf - literal ( i.e. @xmath125 in every rule of @xmath110 ) then @xmath122 is the smallest set of atoms that satisfies all the rules in @xmath110 .",
    "if the program @xmath110 does contain some naf - literal ( @xmath126 in some rule of @xmath110 ) , then @xmath122 is an answer set of @xmath110 if @xmath122 is the answer set of @xmath123 .",
    "( note that @xmath123 does not contain naf - literals , its answer set is defined in the first item . )    a program @xmath110 is said to be _ consistent _ if it has an answer set .",
    "otherwise , it is inconsistent .",
    "many robust and efficient systems that can compute answer sets of propositional logic programs have been developed .",
    "two of the frequently used systems are * dlv * @xcite and * smodels * @xcite .",
    "recently , two new systems * cmodels * @xcite and * assat * @xcite , which compute answer sets by using sat solvers , have been developed .",
    "* xsb * @xcite , a system developed for computing the well - founded model of logic programs , has been extended to compute stable models of logic programs as well .",
    "prolog and other early logic programming systems were geared towards answering yes / no queries with respect to a program , and if the queries had variables they returned instantiations of the variables together with a ` yes ' answer .",
    "the possibility of multiple answer sets and no answer sets has given rise to an alternative way to solve problems using ansprolog . in this approach , referred to as answer set programming ( also known as stable model programming ) @xcite , possible solutions of a problem are enumerated as answer set candidates and non - solutions are eliminated through rules with @xmath115 in the head , resulting in a program whose answer sets have one - to - one correspondence with the solutions of the problem .",
    "we illustrate the concepts of answer set programming by showing how the 3-coloring problem of a bi - directed graph @xmath127 can be solved using ansprolog .",
    "let the three colors be red ( @xmath128 ) , blue ( @xmath129 ) , and green ( @xmath60 ) and the vertex of @xmath127 be @xmath130 .",
    "let @xmath131 be the program consisting of    * the set of atoms @xmath132 for every edge @xmath133 of @xmath127 , * for each vertex @xmath63 of @xmath127 , three rules stating that @xmath63 must be assigned one of the colors red , blue , or green : @xmath134 and * for each edge @xmath133 of @xmath127 , three rules representing the constraint that @xmath63 and @xmath135 must have different color : @xmath136    it can be shown that for each graph @xmath127 , ( i ) @xmath131 is inconsistent iff the 3-coloring problem of @xmath127 does not have a solution ; and ( ii ) if @xmath131 is consistent then each answer set of @xmath131 corresponds to a solution of the 3-coloring problem of @xmath127 and vice versa .    to make answer set style programming easier , niemel et al .",
    "@xcite introduce a new type of rules , called _ cardinality constraint rule _",
    "( a special form of the _ weight constraint rule _ ) of the following form : @xmath137 where @xmath96 and @xmath138 are atoms and @xmath139 and @xmath63 are two integers , @xmath140 .",
    "the intuitive meaning of this rule is that whenever its body is satisfied then at least @xmath139 and at most @xmath63 atoms of the set @xmath141 must be true . using rules of this type",
    ", one can greatly reduce the number of rules of programs in answer set programming .",
    "for instance , in the above example , the three rules representing the constraint that every node @xmath63 needs to be assigned one of the three colors can be packed into one cardinality constraint rule : @xmath142 the semantics of logic programs with such rules is given in @xcite where a program with weight constraint rules is translated into a normal logic program whose answer sets define the answer sets of the original program . for our purpose in this paper",
    "we only need to consider rules with @xmath143 , @xmath144 , and restrict that if we have rules of the form ( [ weight ] ) in our program then there are no other rules with any of @xmath145 in their head .",
    "the idea of using logic programming with answer set semantics for planning was first introduced in @xcite .",
    "it has become more feasible since the development of fast and efficient answer set solvers such as * smodels * @xcite and * dlv * @xcite .",
    "the term `` _ answer set planning _ '' was coined by lifschitz in @xcite referring to approaches to planning using logic programming with answer set semantics , where the planning problem is expressed as a logic program and the answer sets encode plans . in that paper answer set planning",
    "is illustrated with respect to some specific examples .",
    "we now present the main ideas of answer set planning to logic programming .",
    "] when the effects of actions on the world and the relationships between fluents in the world are expressed in the action description language @xmath0 .",
    "given a planning problem @xmath146 , answer set planning solves it by translating it into a logic program @xmath147 ( or @xmath110 , for short ) consisting of _ domain - dependent _ rules that describe @xmath33 , @xmath32 , and @xmath99 and _ domain - independent _ rules that generate action occurrences and represent the inertial law .",
    "we assume that actions and fluents in * a * and * f * are specified by facts of the form @xmath148 and @xmath149 , respectively . the rules of @xmath110 are adapted mainly from @xcite and based on conversations with michael gelfond in 1998 - 99 . as customary in the encoding of planning problems , we assume that the length of plans we are looking for is given .",
    "we denote the length by the constant @xmath150 and use a sort _ time _ , whose domain is the set of integers from 0 to @xmath150 , to represent the time moment the system is in .",
    "we begin with the set of domain - dependent rules .      for an action theory @xmath31 ,",
    "the encoding of @xmath31 uses the following predicates :    1 .",
    "@xmath151  the fluent literal @xmath152 holds at the time moment @xmath153 ; 2 .",
    "@xmath154  the action @xmath155 occurs at the time moment @xmath153 ; and 3 .",
    "@xmath156  the action @xmath155 is executable at the time moment @xmath153 .",
    "the translation is as follows planning problems into their corresponding * smodels * encodings is available at http://www.cs.nmsu.edu/~tson/asplan/knowledge .",
    "( an earlier version of this translator was posted to the tag discussion web site http://www.cs.utexas.edu/users/vl/tag/discussions.html ) . ] .    1 .   for each proposition @xmath157 in @xmath32 , the fact @xmath158 belongs to @xmath110 .",
    "this says that at the time moment @xmath159 , the fluent literal @xmath139 holds .",
    "2 .   for each executability condition @xmath160 in @xmath33",
    ", @xmath110 contains the rule : @xmath161 this rules states that it is possible to execute the action @xmath23 at the time moment @xmath153 if @xmath162 holds at @xmath153 .",
    "3 .   for each dynamic causal law @xmath163 in @xmath33",
    ", @xmath110 contains the rule : @xmath164 this rule says that if @xmath23 occurs at the time moment @xmath153 and @xmath23 is executable at @xmath153 then the fluent literal @xmath12 becomes true at @xmath165 if there exists a dynamic law @xmath163 in @xmath33 and the @xmath28 s hold at @xmath153 .",
    "4 .   for each static causal law @xmath166 in @xmath33",
    ", @xmath110 contains the following rule : @xmath167 this rule is a straightforward translation of the static causal law into logic programming rule .",
    "we demonstrate the above translation by encoding the blocks world domain from example [ ex1 ] .",
    "[ ex4 ] the rules encoding the fluents and actions of the suitcase domain in example [ ex1 ] are : @xmath168 the first group of rules ( left column ) define the set * a * and the second group of rules ( right column ) define * f*. the dynamic law @xmath169 is translated into the rule : @xmath170 the dynamic law @xmath171 is translated into the rule : @xmath172 the executability condition @xmath173 is translated into the rule : @xmath174 the static causal law @xmath175 is encoded by the rule : @xmath176 the static causal law @xmath177 is encoded by the rule : @xmath178 the encoding of other propositions of the domain is similar .",
    "the set of domain independent rules of @xmath110 consists of rules for generating action occurrences and rules for defining auxiliary predicates .",
    "first , we present the rules for the generation of action occurrences . @xmath179 in the above rules , @xmath155 and @xmath180 are variables representing actions .",
    "these rules generate action occurrences , one at a time . ] and a set of constraints that requires that actions can occur only when they are executable and when some actions are executable then one must occur . in",
    "many of our experiments , programs with these rules yield better performance .",
    "] the rules of inertia ( or the frame axioms ) and rules defining literals are encoded using the following rules : @xmath181 the first two rules define what is considered to be a literal .",
    "the next two rules say that @xmath182 and @xmath152 are contrary literals .",
    "the last rule says that if @xmath183 holds at @xmath153 and its contrary does not hold at @xmath165 , then @xmath183 continues to hold at @xmath165 .",
    "finally , to represent the fact that @xmath182 and @xmath152 can not be true at the same time , the following constraint is added to @xmath110 .",
    "@xmath184      the goal @xmath99 is encoded by two sets of rules .",
    "the first set of rules defines @xmath99 as a formula over fluent literals and the second set of rules evaluates the truth value of @xmath99 at different time moments . in a later section , we show how fluent formulas can be represented and evaluated . in this section",
    ", we will assume that @xmath99 is simply a conjunction of literals , i.e. , @xmath185 where @xmath28 are literals .",
    "then , @xmath99 is represented by the following rules : @xmath186 ( recall that the constant @xmath16 denotes the maximal length of trajectories that we are looking for . )      let @xmath187 be the logic program consisting of    * the set of rules encoding @xmath33 and @xmath32 ( rules ( [ ir_init])-([ir_sta ] ) ) in which the domain of @xmath153 is @xmath188 and the rules define actions and fluents of @xmath31 , * the set of domain - independent rules ( rules ( [ ir_occ])-([constraint ] ) ) in which the domain of @xmath153 is @xmath188 , * the rule in ( [ goal ] ) and the constraint @xmath189 that encodes the requirement that @xmath99 holds at @xmath16 .    in what follows",
    ", we will write @xmath190 instead of @xmath187 when it is clear from the context what @xmath33 , @xmath32 , and @xmath99 are .",
    "the following result ( similar to the correspondence between histories and answer sets in @xcite ) shows the equivalence between trajectories achieving @xmath99 and answer sets of @xmath190 . before stating the theorem",
    ", we introduce the following notation : for an answer set @xmath191 of @xmath190 , we define @xmath192    [ th1 ]    for a planning problem @xmath193 with a consistent action theory @xmath31 ,    * if @xmath194 is a trajectory achieving @xmath99 , then there exists an answer set @xmath191 of @xmath190 such that 1 .",
    "@xmath195 for @xmath98 and 2 .",
    "@xmath196 for @xmath197 .",
    "+ and * if @xmath191 is an answer set of @xmath190 , then there exists an integer @xmath198 such that @xmath199 is a trajectory achieving @xmath99 where @xmath200 for @xmath201 and if @xmath202 then no action is executable in the state @xmath203 .",
    "see appendix a.1    note that the second item of the theorem implies that the trajectory achieving @xmath99 corresponds to an answer set @xmath191 of @xmath190 that could be shorter than the predefined length @xmath16 .",
    "this happens when the goal is reached with a shorter sequence of actions and no action is executable in the resulting state .",
    "recall that the sequence of actions @xmath204 , where @xmath205 is a trajectory achieving @xmath99 , is _ not necessarily a plan achieving the goal _",
    "@xmath99 because the action theory @xmath31 may be non - deterministic .",
    "it is easy to see that whenever @xmath31 is deterministic , if @xmath205 is a trajectory achieving @xmath99 then @xmath204 is indeed a plan achieving @xmath99 .",
    "the next corollary follows directly from theorem [ th1 ] .",
    "[ cth1 ]    for a planning problem @xmath193 with a consistent and deterministic action theory @xmath31 ,    1 .   for each plan @xmath206 achieving @xmath99 from @xmath32",
    ", there exists an answer set @xmath191 of @xmath190 such that @xmath195 for @xmath98 ; and 2 .   for each answer",
    "set @xmath191 of @xmath190 , there exists an integer @xmath207 such that @xmath208 is a plan achieving @xmath99 from @xmath32 where @xmath200 for @xmath201 and if @xmath202 then no action is executable in the state reached after executing @xmath208 in the initial state .",
    "the first item of the corollary follows from item ( i ) of theorem [ th1 ] . nevertheless , we do not need to include the condition on the states @xmath209 because @xmath209 is uniquely determined by the initial state @xmath87 and the sequence of actions @xmath210 .",
    "the second item of the corollary follows from item ( ii ) of theorem [ th1 ] . again , because of the determinism of @xmath31 , we do not need to include the conditions on the states @xmath209 .",
    "in this section , we present the main contribution of this paper : augmenting the answer set planning program @xmath110 , introduced in the previous section , with different kinds of domain knowledge , namely temporal knowledge , procedural knowledge , and htn - based knowledge .",
    "the domain knowledge acts as constraints on the answer sets of @xmath110 . for each kind of domain knowledge ( also referred to as constraints )",
    "we introduce new constructs for its encoding and present a set of rules that check when a constraint is satisfied .",
    "we now proceed to introduce the different types of control knowledge .",
    "we start with temporal knowledge .",
    "use of temporal domain knowledge in planning was first proposed by bacchus and kabanza in @xcite . in their formulation",
    ", temporal knowledge is used to prune the search space while planning using forward search . in their paper , temporal constraints",
    "are specified using a future linear temporal logic with a precisely defined semantics . since their representation is separate from the action and goal representation , it is easy to add them to ( or remove them from ) a planning problem . planners exploiting temporal knowledge to control the search process have proven to be highly efficient and to scale up well @xcite . in this paper , we represent temporal knowledge using temporal constraints .",
    "temporal constraints are built from fluent formulae using the _ temporal operators _ * always * , * until * , * next * , and * eventually * , and a special _ goal operator _ * goal*. for simplicity of the presentation , we will write fluent formulae in prefix notation and use the _ propositional connectives _ * and , or * , and * negation*. given a signature @xmath211 we define term , formula , and closed formula , as follows .    a _ term _ is a variable or a constant in * o*.    a formula is either    * an expression of the form @xmath212 where @xmath12 is a n - ary fluent name and each @xmath213 is a term ; * an expression of the form @xmath214 , where @xmath215 and @xmath216 are formulae ; * an expression of the form @xmath217 , where @xmath215 and @xmath216 are formulae ; * an expression of the form @xmath218 , where @xmath215 is a formula ; or * an expression of the form @xmath219 or @xmath220 where @xmath118 is a variable , @xmath221 is a set of constants in @xmath15 , and @xmath215 is a formula .",
    "we next define the notion of a _ closed formula_.    the formula over which a quantifier applies",
    "is called the _",
    "scope _ of the quantifier . the scope of @xmath222 ( resp .",
    "@xmath223 ) in @xmath224 ( resp .",
    "@xmath225 ) is @xmath215 .",
    "an occurrence of a variable in a formula is a bounded occurrence iff the occurrence is within the scope of a quantifier which has the same variable immediately after the quantifier or is the occurrence of that quantifier .",
    "an occurrence of a variable in a formula is a free occurrence iff the occurrence is not bound .",
    "a variable is free in a formula if at least one of its occurrences is a free occurrence .",
    "[ clsformula ] a formula without free variables is called a _",
    "closed formula_.    the truth or falsity of a formula is evaluated with respect to state in the standard way .",
    "it is easy to see that formulae with quantifiers can be translated into equivalent formulae without quantifier as follows : @xmath226 is equivalent to @xmath227 and @xmath228 is equivalent to @xmath229 where @xmath230 is the formula obtained from @xmath215 by replacing every free occurrence of @xmath118 in @xmath215 with @xmath20 . for this reason",
    ", we will be dealing with formulae without quantifiers hereafter .",
    "we are now ready to define the notion of a temporal constraint .",
    "[ d - formula ]    a _ temporal constraint _ is either    * a closed formula ( definition [ clsformula ] ) * an expression of the form @xmath231 where @xmath215 is a closed formula ; or * an expression of the form @xmath232 , @xmath233 , @xmath234 , @xmath235 , @xmath236 , @xmath237 , or @xmath238 where @xmath215 and @xmath216 are temporal constraints .",
    "a temporal constraint is an _ atomic _ constraint if it is a fluent literal .",
    "otherwise , it is called _ non - atomic_. in what follows , a constraint @xmath215 will be referred as a _ sub - constraint _ of a constraint @xmath216 if @xmath215 occurs in @xmath216 .",
    "we will write @xmath239 to denote the set of constraints consisting of @xmath215 and its sub - formulae .",
    "it is easy to see that constraints without temporal operators or the goal operator are indeed _ fluent formulae_. temporal operators are understood with their standard meaning while the goal operator @xmath240 provides a convenient way for expressing the control knowledge which depends on goal information .",
    "a temporal constraint is said to be goal - independent if no goal formula occurs in it . otherwise , it is goal - dependent .",
    "bacchus and kabanza @xcite observed that useful temporal knowledge in planning is often goal - dependent . in the blocks world domain , the following goal - dependent constraint ) can be replaced by @xmath241 and @xmath242 , we omit it in the definition but use it in writing the constraints , to simplify reading . as before , we use the convention that a formula with variables represents the set of its ground instantiations . ] : ( ( ( on(x , tbl)),on(x , tbl ) ) ( on(x , tbl ) ) ) can be used to express that if the goal is to have a block on the table and it is already on the table then it should be still on the table in the next moment of time .",
    "this has the effect of preventing the agent from superfluously picking up a block from the table if it is supposed to be on the table in the goal state .",
    "notice that under this definition , temporal operators can be nested many times but the goal operator @xmath240 can not be nested . for instance , if @xmath61 is a fluent formula , @xmath243 is a temporal formula , but @xmath244 is not .",
    "goal - independent formulae will be interpreted over an infinite sequence of states of @xmath33 , denoted by @xmath245 . on the other hand ,",
    "goal - dependent formulae will be evaluated with respect to a pair @xmath246 where @xmath56 is a sequence of states and @xmath61 is a fluent formula . in the next two definitions ,",
    "we formally define when a constraint is satisfied .",
    "definition [ tpl - semantics ] deals with goal - independent constraints while definition [ tpl - semantics1 ] is concerned with general constraints",
    ".    [ goal - ind - def ] [ tpl - semantics ]    ( see @xcite ) let @xmath247 be a sequence of states of @xmath33 .",
    "let @xmath248 and @xmath249 be goal - independent temporal constraints , @xmath250 be a non - negative integer , and @xmath251 be a fluent formula .",
    "let @xmath252 denote the subsequence of @xmath56 starting from @xmath253 .",
    "we say that @xmath56 satisfies @xmath12 ( @xmath12 is either @xmath254 , or @xmath251 ) , denoted by @xmath255 , iff @xmath256 where    * @xmath257 iff @xmath258 . *",
    "@xmath259 iff there exists @xmath260 such that @xmath261 and for all @xmath262 we have @xmath263 . *",
    "@xmath264 iff @xmath265 .",
    "* @xmath266 iff there exists @xmath267 such that @xmath268 . *",
    "iff for all @xmath267 we have @xmath263 .",
    "for a finite sequence of states @xmath270 and a goal - independent temporal constraint @xmath12 , we say that @xmath56 satisfies @xmath12 , denoted by @xmath271 , if @xmath272 where @xmath273 .",
    "@xmath274    next we define when goal - dependent temporal constraints are satisfied by a sequence of states and a goal .",
    "intuitively , this should be a straightforward extension of the previous definition in which formulas of the form @xmath275 need to be accounted for .",
    "obviously , such a constraint can only be evaluated with respect to a sequence of states and a formula encoding the goal .",
    "furthermore , the intuition behind the formula @xmath276 is that @xmath216 is true whenever the goal is true , i.e. , @xmath216 is entailed by the goal .",
    "this is detailed in the second item of the following definition .",
    "[ tpl - semantics1 ]    let @xmath277 be a sequence of states of @xmath33 and @xmath61 be a fluent formula denoting the goal .",
    "let @xmath248 and @xmath249 be temporal constraints ( possibly goal dependent ) , @xmath250 be a non - negative integer , and @xmath251 be a fluent formula .",
    "let @xmath278 .",
    "we say that @xmath56 satisfies @xmath12 ( @xmath12 is either @xmath254 , or @xmath251 ) with respect to @xmath61 , denoted by @xmath279 , iff @xmath280 where    * @xmath281 iff @xmath258 . *",
    "@xmath282 iff @xmath283 .",
    "we mean that @xmath61 entails @xmath251 .",
    "* @xmath284 iff there exists @xmath260 such that @xmath285 and for all @xmath262 we have @xmath286 . *",
    "@xmath287 iff @xmath288 . *",
    "@xmath289 iff there exists @xmath267 such that @xmath286 . *",
    "iff for all @xmath267 we have @xmath286 .    for a finite sequence of states @xmath270 , a temporal constraint @xmath12 , and a fluent formula @xmath61",
    "we say that @xmath56 satisfies @xmath12 with respect to @xmath61 , denoted by @xmath291 , if @xmath292 where @xmath293 .",
    "@xmath274    to complete the encoding of temporal constraints , we now provide the rules that check the satisfiability of a temporal constraint given a trajectory .",
    "we define the predicate @xmath294 whose truth value determines whether @xmath152 is satisfied by @xmath295 , where @xmath296 refers to the state corresponding to time point @xmath153 .",
    "it is easy to see that rules for checking the satisfiability of temporal constraints can be straightforwardly developed in logic programming with function symbols .",
    "for example , the rules @xmath297 can be used to determine whether or not the constraint @xmath298 is true at the time moment @xmath153 .",
    "the first rule is for atomic constraints and the second rule is for non - atomic ones .",
    "although these rules are intuitive and correct , we will need to modify them for use with the currently available answer set solvers such as * dlv * and * smodels*. this is because * dlv * does not allow function symbols and * lparse *  the parser of the * smodels * system  requires that variables occurring in the head of a rule are domain variables , i.e. , in the second rule , we have to specify the domain of @xmath299 and @xmath300 .",
    "we will now present two possible ways to deal with the answer set solver s restriction , a rule @xmath301 this method , however , can not be easily extended for temporal constraints with temporal operators or the goal operator . ] .",
    "the first way is to represent a constraint by a set of rules that determine its truth value . in other words , we specify the domains of @xmath299 and @xmath300 in the above rules by grounding them . for example , for the conjunction @xmath302 , the rules @xmath303 can be used . for the disjunction , @xmath304 , the rules @xmath305 can be used .",
    "the encodings of other constraints are similar .",
    "observe that the number of rules for encoding a formula depends on the number of its sub - constraints .",
    "an alternative to the above encoding is to assign names to non - atomic constraints , to define a new type , called _ formula _ , and to provide the constraint - independent rules for checking the truth value of constraints .",
    "atomic constraints are defined by the rule : @xmath306 for each non - atomic formula @xmath215 , we associate with it a unique name @xmath307 and encode it by a set of facts , denoted by @xmath308 .",
    "this set is defined inductively over the structure of @xmath215 as follows .    * if @xmath215 is a fluent literal @xmath139 then @xmath309 ; * if @xmath310 then @xmath311 ; * if @xmath312 then @xmath313 ; * if @xmath314 then @xmath315 ; * if @xmath316 then @xmath317 ; * if @xmath318 then @xmath319 * if @xmath320 then @xmath321 ; * if @xmath322 then @xmath323 .    for simplicity",
    ", the names assigned to a constraint can be used in encoding other constraints .",
    "for example , the constraints @xmath324 is encoded by the atoms @xmath325 we note that the above encodings can be generated automatically using a program front - end to * smodels * that is available on the web - site containing the experimental results presented in this paper .",
    "note that during the grounding phase of * smodels * ( by * lparse * ) , atoms of the form @xmath326 will be removed .",
    "for this reason , we use the second encoding in our experiments because it is easier to deal with changes in the constraints used for encoding the control knowledge .",
    "we now present the formula - independent rules for evaluating temporal constraints . as with defining the satisfaction of temporal constraints ,",
    "we first consider goal - independent temporal constraints .",
    "the rules needed for evaluating temporal constraints whose first level operator is different than the * goal * operator are as follows :    @xmath327 the meaning of these rules is straightforward .",
    "the first rule defines the truth value of an atomic formula ( a literal ) .",
    "rule ( [ fol_and ] ) says that a conjunction holds if its conjuncts hold",
    ". rules ( [ fol_or1])-([fol_or2 ] ) say that a disjunction holds if one of its disjuncts holds .",
    "the rule ( [ fol_neg ] ) states that the negation of a formula holds if its negation does not hold .",
    "its correctness is due to the assumption that initial states are complete",
    ". rules ( [ lt_until])-([lt_during ] ) deal with formulae containing temporal operators .",
    "the constant @xmath16 denotes the maximal length of trajectories that we are looking for . in the following ,",
    "we refer to this group of rules by @xmath328 .",
    "the next theorem shows that rules ( [ fol_lit_tran])-([lt_during ] ) correctly implement the semantics of goal - independent temporal formulae .",
    "[ the - lt - sem ]    let @xmath122 be a finite set of goal - independent temporal formulae , @xmath329 be a sequence of states , and @xmath330 where    * @xmath331 is the set of atoms used in encoding @xmath122 , and * @xmath332 is a fluent literal and @xmath333 .",
    "then ,    * the program @xmath334 has a unique answer set , @xmath118 .",
    "* for every temporal formula @xmath215 such that @xmath335 , @xmath215 is true in @xmath336 , i.e. , @xmath337 , if and only if @xmath338 belongs to @xmath118 where @xmath339 .",
    "see appendix a.2    having defined temporal constraints and specified when they are satisfied , adding temporal knowledge to a planning problem in answer set planning is easy .",
    "we must encode the knowledge as a temporal formula and then add the set of rules representing this formula and the rules ( [ fol_lit_tran])-([lt_during ] ) to @xmath110 . finally , we need to add the constraint that requires that the goal is true at the final state and the temporal formula is satisfied .",
    "more precisely , for a planning problem @xmath340 and a goal - independent temporal formula @xmath215 , let @xmath341 be the program consisting of    * the program @xmath190 ( defined as in sub - section [ correctness - pi ] ) , * the rules ( [ fol_lit_tran])-([lt_during ] ) * the rules encoding @xmath215 and the constraint @xmath342 .",
    "the next theorem is about the correctness of @xmath341 .",
    "[ thtlp ]    for a planning problem @xmath343 with a consistent action theory @xmath31 and a goal - independent temporal formula @xmath215 ,    * if @xmath194 is a trajectory achieving @xmath99 and @xmath344 where @xmath345 , then there exists an answer set @xmath191 of @xmath341 such that 1 .",
    "@xmath195 for @xmath98 , 2 .",
    "@xmath196 for @xmath197 , and 3 .",
    "@xmath346 . + and * if @xmath191 is an answer set of @xmath341 , then there exists an integer @xmath198 such that 1 .",
    "@xmath199 is a trajectory achieving @xmath99 where @xmath200 for @xmath347 and 2 .",
    "@xmath344 where @xmath348 .",
    "observe that the set of literals of the program @xmath190 , @xmath349 , is a splitting set of the program @xmath350 and @xmath351 .",
    "thus , @xmath191 is an answer set of @xmath350 iff @xmath352 where @xmath118 is an answer set of @xmath190 and @xmath353 is an answer set of @xmath354 which consists of the set of rules ( [ fol_and])-([lt_during ] ) , the set of atoms @xmath355 , the rules encoding @xmath215 , and the constraint @xmath356 .",
    "this constraint implies that @xmath357 must belong to every answer set @xmath191 of @xmath350 .",
    "we now prove ( i ) .",
    "it follows from theorem [ th1 ] that there exists an answer set @xmath118 of @xmath190 such that the first two conditions are satisfied . because @xmath358 , we can apply theorem [ the - lt - sem ] to show that any answer set @xmath353 of @xmath359 contains @xmath357 .",
    "thus , @xmath360 is an answer set satisfying ( i ) .    to prove ( ii )",
    ", it is enough to notice that the answer set @xmath118 of @xmath190 , constructed in the proof of lemma [ smodel - traject2-add ] , can be used to construct an answer set @xmath191 of @xmath350 such that @xmath191 satisfies ( ii ) .",
    "the above theorem shows how control knowledge represented as goal - independent temporal formulae can be exploited in answer set planning .",
    "we will now extend this result to allow control knowledge expressed using goal - dependent temporal formulae .",
    "based on definition  [ tpl - semantics1 ] , where satisfaction of goal - dependent temporal formulae is defined , we will need to encode @xmath361 where @xmath99 is the goal and @xmath276 is a formula occurring in a control knowledge that we wish to use . to simplify this encoding",
    "we make the same assumption that is made in most classical planning literature including @xcite : the goal @xmath99 in a planning problem @xmath362 is a set of literals and each goal formula occurring in a temporal formula representing our control knowledge is of the form @xmath363 where @xmath152 is a fluent literal . in the rest of this section , whenever we refer to a planning problem or a goal - dependent temporal formula we assume that they satisfy this assumption .",
    "let @xmath362 be a planning problem and @xmath215 be a temporal formula .",
    "@xmath364 be the program consisting of @xmath341 , the set of atoms @xmath365 is a goal formula occurring in @xmath215 , and the set of rules @xmath366 for each @xmath367 . intuitively , these rules assert that @xmath12 is a part of the goal @xmath99 .",
    "the next theorem is about the correctness of @xmath364 .",
    "[ thtlp - goal ]    for a planning problem @xmath193 with a consistent action theory @xmath31 and a temporal formula @xmath215 ,    * if @xmath194 is a trajectory achieving @xmath99 and @xmath368 where @xmath369 , then there exists an answer set @xmath191 of @xmath364 such that 1 .",
    "@xmath195 for @xmath98 , 2 .",
    "@xmath196 for @xmath197 , and 3 .",
    "+ and * if @xmath191 is an answer set of @xmath364 , then there exists an integer @xmath198 such that 1 .",
    "@xmath199 is a trajectory achieving @xmath99 where @xmath200 for @xmath347 and 2 .",
    "@xmath370 where @xmath371 .    to prove this theorem",
    ", we first need to modify theorem [ the - lt - sem ] by ( i ) allowing goal - dependent formulae to be in the set @xmath122 ; ( ii ) adding a goal @xmath99 and the rule ( [ lt_e1 ] ) to the program @xmath110 of theorem [ the - lt - sem ] .",
    "the proof of this modified theorem is very similar to the proof of theorem [ the - lt - sem ] .",
    "we omit it here for brevity .",
    "this result , together with theorem [ th1 ] , proves the conclusion of this theorem .",
    "procedural knowledge can be thought of as an under - specified sketch of the plans to be generated .",
    "the language constructs that we use in this paper to describe procedural knowledge are inspired by golog , an algol - like logic programming language for agent programming , control and execution ; and based on a situation calculus theory of action @xcite .",
    "golog has primarily been used as a programming language for high - level agent control in dynamical environments ( see e.g. @xcite ) .",
    "although a planner can itself be written as a golog program ( see chapter 10 of @xcite ) , in this paper , we view a golog program as an incompletely specified plan ( or as a form of procedural knowledge ) that includes non - deterministic choice points that are filled in by the planner . for example , the procedural knowledge ( which is very similar to a golog program ) @xmath372 represents plans which have @xmath7 followed by @xmath8 , followed by one of @xmath9 , @xmath10 , or @xmath11 such that @xmath12 is true in the following ( terminating ) state of the plan .",
    "a planner , when given this procedural knowledge needs only to decide which one of @xmath9 , @xmath10 , or @xmath11 it should choose as its third action .",
    "we now formally define the syntax of our procedural knowledge , which  keeping with the golog terminology  we refer to as a _",
    "program_. a program is built from _ complex actions _ and _ procedures_. complex actions , procedures , and programs are constructed using variables , actions , formulae , and procedural program constructs such as * sequence * , * if - then - else * , * while - do * , or * choice * , etc .",
    "they are defined as follows .",
    "[ ca ]    a _ complex action _",
    "@xmath373 with a sequence of variables @xmath374 is    * _ a basic complex action _ : * * an expression of the form @xmath375 where @xmath23 is an m - ary action name , @xmath213 is either a variable or a constant of the type @xmath376 , and if @xmath213 is a variable then it belongs to @xmath377 or * * an expression of the form @xmath215 where @xmath215 is a formula whose free variables are from @xmath377 ; * _ a sequence _ : an expression of the form @xmath378 where @xmath379 and @xmath380 are complex actions whose free variables are from @xmath377 ; * _ a choice of actions _ : an expression of the form @xmath381 where @xmath382 s are complex actions whose free variables are from @xmath377 ; * _ a if - then - else _ : an expression of the form @xmath383 where @xmath215 is a formula and @xmath379 and @xmath380 are complex actions whose free variables are from @xmath377 ; * _ a while - do _ : an expression of the form @xmath384 where @xmath215 is a formula and @xmath379 is a complex action whose free variables are from @xmath377 ; * _ a choice of arguments _ : an expression of the form @xmath385 where @xmath386 , @xmath221 is a set of constants , and @xmath379 is a complex action whose free variables are from @xmath387 ; and * _ a procedure call _ : an expression of the form @xmath388 where @xmath389 is a procedure name whose variables are @xmath374 .    [ pr ]    a _ procedure _ with the name @xmath389 and a sequence of variables @xmath374 is of the form @xmath390 where @xmath373 , called the _ body _ , is a complex action whose free variables are from @xmath377 .",
    "a procedure @xmath390 is called a _ nested procedure _ if @xmath373 is a procedure call .",
    "intuitively , a complex action @xmath373 represents a sketch of a plan whose variations are given by its variables and its structure .",
    "the execution of @xmath373 is done recursively over its structure and starts with the instantiation of @xmath374 with some constants @xmath391 . in the process",
    ", an action might be executed , a formula might be evaluated , other complex actions or procedures might be instantiated and executed . in other words ,",
    "the execution of @xmath373 might depend on the execution of other complex actions .",
    "let @xmath373 be a complex action with variables @xmath392 and @xmath391 be constants . in the following ,",
    "we define    * the ground instance of @xmath373 with respect to the substitution @xmath393 , denoted by @xmath394 , and * the set of complex actions that the execution of @xmath394 might depend on , denoted by @xmath395 .",
    "@xmath394 and @xmath395 are defined recursively as follows :    * if @xmath396 , then @xmath394 is the action @xmath397 where @xmath398 if @xmath213 is the variable @xmath399 and @xmath400 if @xmath213 is a constant and @xmath401 , * if @xmath402 then @xmath403 where @xmath404 is obtained from @xmath215 by simultaneously replacing every free occurrence of @xmath405 in @xmath215 by @xmath20 and @xmath406 , * if @xmath407 then @xmath408 and + @xmath409 , * if @xmath410 then @xmath411 and + @xmath412 , * if @xmath413 then + @xmath414 and + @xmath415 , * if @xmath416 then @xmath417 and + @xmath418 , * if @xmath419 then @xmath420 for some @xmath421 , @xmath422 , and + @xmath423 ; and * if @xmath424 where @xmath425 is a procedure then @xmath426 and @xmath427 .",
    "a ground instance of a procedure @xmath390 is of the form @xmath428 where @xmath391 are constants and @xmath394 is a ground instance of @xmath373 .    in what follows , @xmath394 ( resp .",
    "@xmath428 ) will be referred to as a ground complex action ( resp .",
    "ground procedure ) . as with complex actions , for a procedure @xmath390 and the constants @xmath391",
    ", we define the set of actions that the execution of @xmath429 might depend on by @xmath430 .",
    "it is easy to see that under the above definitions , a procedure @xmath389 may depend on itself .",
    "for example , for two procedures `` @xmath431 '' and `` @xmath432 '' , we have that @xmath433 and @xmath434 .",
    "intuitively , this will mean that the execution of @xmath389 ( and @xmath435 ) might be infinite .",
    "since our goal is to use programs , represented as a set of procedures and a ground complex action , to construct plans of finite length , procedures that depend on themselves will not be helpful .",
    "for this reason , we define a notion called _ well - defined _ procedures and limit ourselves to this type of procedure hereafter .",
    "we say that a procedure @xmath389 with variables @xmath436 is _ well - defined _ if there exists no sequence of constants @xmath391 such that @xmath437 .",
    "we will limit ourselves to sets of procedures in which no two procedures have the same name and every procedure is well - defined and is not a nested procedure .",
    "we call such a set of procedures _ coherent _ and define programs as follows .",
    "[ program ] [ prog1 ] a _ program _ is a pair @xmath438 where @xmath122 is a coherent set of procedures and @xmath373 is a ground instantiation of a complex action .",
    "we illustrate the above definition with the following example .",
    "[ ex5 ]    in this example , we introduce the elevator domain from @xcite which we use in our initial experiments ( section  [ s34 ] ) .",
    "the set of constants in this domain consists of integers between @xmath159 and @xmath439 representing the floor numbers controlled by the elevator .",
    "the fluents in this domain and their intuitive meaning are as follows :    * @xmath440 - the request service light of the floor @xmath441 is on , indicating a service is requested at the floor @xmath441 , * @xmath442 - the door of the elevator is open , and * @xmath443 - the elevator is currently at the floor @xmath441 .    the actions in this domain and their intuitive meaning are as follows :    * @xmath444 - move up to floor @xmath441 , * @xmath445 - move down to floor @xmath441 , * @xmath446 - turn off the indicator light of the floor @xmath441 , * @xmath447 - open the elevator door , and * @xmath448 - close the elevator door .",
    "the domain description is as follows : @xmath449    we consider arbitrary initial states where @xmath442 is false , @xmath443 is true for a particular @xmath441 and a set of @xmath440 is true ; and our goal is to have @xmath450 for all @xmath441 . in planning to achieve such a goal , we can use the following set of procedural domain knowledge . alternatively , in the terminology of golog , we can say that the following set of procedures , together with the ground complex action _ control _ , can be used to control the elevator , so as to satisfy service requests  indicated by the light being on  at different floors .",
    "that is , the program for controlling the elevator is @xmath451 where @xmath452 ) \\\\ ( control   & : &   [ \\wwhile \\exists n.\\{0,\\ldots , k\\ } \\ ; [ on(n ) ] \\ddo serve\\_a\\_floor ] ; park ) .",
    "\\\\ \\end{array } \\right.\\ ] ]    observe that the formula @xmath453 $ ] , as discussed before , is the shorthand of the disjunction @xmath454 where @xmath455 are the floor constants of the domain .",
    "the operational semantics of programs specifies when a trajectory @xmath205 , denoted by @xmath456 , is _ a trace of a program @xmath438_. intuitively , if @xmath456 is a trace of a program @xmath438 then that means @xmath457 is a sequence of actions ( and @xmath456 is a corresponding trajectory ) that is consistent with the sketch provided by the complex action @xmath373 of the program @xmath438 starting from the initial state @xmath87 .",
    "alternatively , it can be thought of as the program @xmath438 _ unfolding _ to the sequence of actions @xmath458 in state @xmath87 .",
    "we now formally define the notion of a @xmath459 .",
    "[ trace ] [ deftrace1 ]    let @xmath460 be a program .",
    "we say that a trajectory @xmath205 is a trace of @xmath389 if one of the following conditions is satisfied :    * @xmath461 and @xmath23 is an action , @xmath462 and @xmath463 ; * @xmath402 , @xmath464 and @xmath215 holds in @xmath87 ; * @xmath465 , and there exists an @xmath466 such that @xmath467 is a trace of @xmath468 and @xmath469 is a trace of @xmath470 ; * @xmath471 , and @xmath194 is a trace of @xmath472 for some @xmath466 ; * @xmath473 , and @xmath194 is a trace of @xmath468 if @xmath215 holds in @xmath87 or @xmath194 is a trace of @xmath470 if @xmath474 holds in @xmath87 ; * @xmath475 , @xmath476 and @xmath474 holds in @xmath87 , or + @xmath215 holds in @xmath87 and there exists some @xmath477 such that @xmath467 is a trace of @xmath468 and @xmath469 is a trace of @xmath438 ; or * @xmath478 and @xmath205 is a trace of @xmath479 for some @xmath421 , @xmath422 . * @xmath480 where @xmath481 is a procedure , and + @xmath205 is a trace of @xmath482 .",
    "the above definition allows us to determine whether a trajectory @xmath456 constitutes a trace of a program @xmath438 .",
    "this process is done recursively over the structure of @xmath373 .",
    "more precisely , if @xmath373 is not an action or a formula , checking whether @xmath456 is a trace of @xmath438 amounts to determining whether @xmath456 is a trace of @xmath483 for some component @xmath484 of @xmath373 .",
    "we note that because @xmath373 is grounded , @xmath484 is also a ground complex action ; thus , guaranteeing that @xmath483 is a program and hence the applicability of the definition .",
    "it is easy to see that @xmath484 belongs to @xmath485 . because of the coherency of @xmath122 and the finiteness of the domains",
    ", this process will eventually stop .",
    "we will now present the * smodels * encoding for programs .",
    "the encoding of a program @xmath438 will include the encoding of all procedures in @xmath122 and the encoding of @xmath373 .",
    "the encoding of a complex action or a procedure consists of the encoding of all of its ground instances .",
    "similar to the encoding of formulae , each complex action @xmath373 will be assigned a distinguished name , denoted by @xmath486 , whenever it is necessary . because procedure names are unique in a program",
    ", we assign the name @xmath429 to the complex action @xmath394 where @xmath390 is a procedure and @xmath391 is a sequence of constants . in other words , @xmath487 .",
    "we note that since the body of a procedure is not a procedure call , this will not cause any inconsistency in the naming of complex actions .",
    "we now describe the set of rules encoding a complex action @xmath373 , denoted by @xmath488 , which is defined inductively over the structure of @xmath373 as as follows :    * for @xmath461 or @xmath402 , @xmath488 is the action @xmath23 or the rules encoding @xmath215 , respectively . * for @xmath465 , @xmath489 .",
    "* for @xmath490 , @xmath491 * for @xmath473 , @xmath492 * for @xmath493 , @xmath494 * for @xmath478 , @xmath495 where @xmath496 . * for @xmath480 where @xmath497 is a procedure , @xmath498 .    a procedure @xmath497 is encoded by the set of rules encoding the collection of its ground instances .",
    "the encoding of a program @xmath438 consists of @xmath488 and the rules encoding the procedures in @xmath122 .",
    "observe that because of @xmath122 s coherence , the set of rules encoding a program @xmath438 is uniquely determined .",
    "[ ex6 ]    in this example we present the encoding of the program @xmath451 from example  [ ex5 ] .",
    "we start with the set of rules encoding the ground procedure @xmath499 where @xmath466 is a floor constant .",
    "first , we assign the name @xmath500 to the complex action @xmath501 and encode this complex action by the set @xmath502 .",
    "this set consists of the following facts : @xmath503 similar atoms are needed to encode other instances of the procedure @xmath504 .    for each floor @xmath466 ,",
    "the following facts encode the complex action @xmath505 , which is the body of a ground instance of the procedure @xmath506 : @xmath507 to encode the procedure @xmath508 , we need the set of rules which encode @xmath509 , @xmath510 , ( above ) and the rules encode the complex action @xmath511 for every @xmath466 .",
    "these rules are : @xmath512 where @xmath513 is the name assigned to the complex action @xmath511 , and the following rule : @xmath514 the following facts encode the procedure @xmath515)$ ] : @xmath516 finally , the encoding of the procedure @xmath517 consists of the rules encoding the formula @xmath454 which is assigned the name @xmath518 and the following rules : @xmath519    we now present the ansprolog rules that realize the operational semantics of programs .",
    "we define a predicate @xmath520 where @xmath521 is a program and @xmath522 and @xmath523 are two time points , @xmath524 .",
    "intuitively , we would like to have @xmath525 be true in an answer set @xmath191 iff @xmath526 is a trace of the program @xmath389 is a fluent literal@xmath527 . ] .",
    "@xmath528 here @xmath529   denotes a dummy program that performs no action .",
    "this action is added to allow programs of the form @xmath530 to be considered ( this will be represented as @xmath531 ) .",
    "the rules are used for determining whether a trajectory  encoded by answer sets of the program @xmath190  is a trace of a program or not . as with temporal constraints ,",
    "this is done inductively over the structure of programs .",
    "the rules ( [ tr_act ] ) and ( [ tr_form ] ) are for programs consisting of an action and a fluent formula respectively .",
    "the other rules are for the remaining cases .",
    "for instance , the rule ( [ tr_while_true ] ) states that the trajectory from @xmath522 to @xmath523 is a trace of a while loop `` @xmath532 '' , named @xmath533 and encoded by the atom @xmath534 , if the formula @xmath152 holds at @xmath522 and there exists some @xmath535 , @xmath536 such that the trajectory from @xmath522 to @xmath535 is a trace of @xmath521 and the trajectory from @xmath535 to @xmath523 is a trace of @xmath533 ; and the rule ( [ tr_while_false ] ) states that the trajectory from @xmath153 to @xmath153 is a trace of @xmath533 if the formula @xmath152 does not holds at @xmath153 .",
    "these two rules effectively determine whether the trajectory from @xmath522 to @xmath523 is a trace of @xmath534 .",
    "the meanings of the other rules are similar .    observe that we do not have specific rules for complex actions which are procedure calls .",
    "this is because of every trace of a procedure call @xmath429 , where @xmath537 is a procedure , is a trace of the complex action @xmath394  whose name is @xmath429 , as described earlier  and vice versa .",
    "furthermore , @xmath373 is not a procedure call , traces of @xmath379 can be computed using the above rules .",
    "the correctness of the above set of rules ( see theorem [ th2 ] ) means that procedure calls are treated correctly in our implementation .    to specify that a plan of length @xmath16 starting from an initial state must obey the sketch specified by a program @xmath538 , all we need to do is to add the rules encoding @xmath389 and the constraint @xmath539 to @xmath190 .",
    "we now formulate the correctness of our above encoding of procedural knowledge given as programs , and relate the traces of program with the answer sets of its ansprolog encoding .",
    "let @xmath540 be the program obtained from @xmath190 by ( i ) adding the rules ( [ tr_act])-([tr_null ] ) and ( [ fol_lit_tran])-([lt_during ] ) , ( ii ) adding @xmath541 , and ( iii ) replacing the goal constraint with @xmath542 .",
    "the following theorem is similar to theorem [ th1 ] .",
    "[ th2 ]    let @xmath31 be a consistent action theory and @xmath538 be a program .",
    "then ,    * for every answer set @xmath191 of @xmath543 with @xmath195 for @xmath98 , @xmath544 is a trace of @xmath389 ; and * if @xmath545 is a trace of @xmath389 then there exists an answer set @xmath191 of @xmath543 such that @xmath546 and @xmath547 for @xmath548 and @xmath549",
    ".    see appendix a.3    to do planning using procedural constraints all we need to do is to add the goal constraint to @xmath540 , which will filter out all answer sets where the goal is not satisfied in time point @xmath16 , and at the same time will use the sketch provided by the program @xmath389 .",
    "the programs in the previous subsections are good for representing procedural knowledge but prove cumbersome for encoding partial - ordering information .",
    "for example , to represent that any sequence containing the @xmath16 programs @xmath550 , in which @xmath551 occurs before @xmath552 , is a valid plan for a goal @xmath99 , one would need to list all the possible sequences and then use the non - determinism construct . for @xmath553 ,",
    "the program fragment would be @xmath554 .",
    "alternatively , the use of the _ concurrent construct _",
    "@xmath555 from @xcite , where @xmath556 represents the set consisting of two programs @xmath557 and @xmath558 , is not very helpful either .",
    "this deficiency of pure procedural constructs of the type discussed in the previous section prompted us to look at the constructs in htn planning @xcite .",
    "the partial - ordering information allowed in htn descriptions serves the purpose .",
    "thus all we need is to add constraints that says @xmath551 must occur before @xmath552 .",
    "the constructs in htn by themselves are not expressive enough either as they do not have procedural constructs such as procedures , conditionals , or loops , and expressing a while loop using pure htn constructs is not trivial .",
    "thus we decided to combine the htn and procedural constructs and to go further than the initial attempt in @xcite where complex programs are not allowed to occur within htn programs .",
    "we now define a more general notion of program that allows both procedural and htn constructs . for",
    "that we need the following notion .",
    "let @xmath559 be a set of procedures with free variables @xmath377 .",
    "* an ordering constraint over @xmath560 has the form @xmath561 where @xmath562 . *",
    "a truth constraint is of the form @xmath563 , @xmath564 , or @xmath565 , where @xmath215 is a formula whose free variables are from the set @xmath377 .    given a set of procedures @xmath560 and a set of constraints @xmath566 over @xmath560 , the execution of @xmath560 will begin with the grounding of @xmath560 and @xmath566 , i.e. , the variables @xmath374 are substituted by some constants @xmath391 .",
    "the constraints in @xmath566 stipulate an order in which the procedures in @xmath560 is executed .",
    "the intuition behind these types of constraints is as follows :    * an ordering constraint @xmath561 requires that the procedure @xmath28 has to be executed before the procedure @xmath567 . * a truth constraint of the form @xmath563 ( resp .",
    "@xmath564 ) requires that immediately after ( resp . immediately before ) the execution of @xmath28 , @xmath215 must hold . *",
    "a constraint of the form @xmath565 indicates that @xmath215 must hold immediately after @xmath28 is executed until @xmath568 begins its execution .",
    "because a constraint of the form @xmath565 implicitly requires that @xmath28 is executed before @xmath568 , for convenience , we will assume hereafter that whenever @xmath565 belongs to @xmath566 , so does @xmath569 .",
    "the definition of general complex actions follows .",
    "[ general complex action ] [ ca1 ]    for an action theory @xmath31 , a general complex action with variables @xmath374 is either    * a complex action ( definition [ ca ] ) ; or * a pair @xmath570 where @xmath560 is a set of procedures and @xmath566 is a set of constraints over @xmath560 and the variables of each procedure in @xmath560 are from @xmath374",
    ".    the definition of a procedure or program does not change . the notion of ground instantiation , dependency , and well - definedness of a procedure",
    "can be extended straightforwardly to general programs .",
    "we will continue to assume that programs in consideration are well - defined .",
    "as in the case of programs , the operational semantics of general programs is defined using the notion of trace . in the next definition ,",
    "we extend the notion of a _ trace _ to cover the case of general programs .",
    "[ trace of general programs ] [ deftrace2 ]    let @xmath538 be a general program .",
    "we say that a trajectory @xmath194 is a trace of @xmath389 if one of the following conditions is satisfied :    * @xmath194 and @xmath438 satisfy one of the condition in definition [ deftrace1 ] ; or * @xmath571 , @xmath572 , and there exists @xmath573 and a permutation @xmath574 of @xmath575 such that the sequence of trajectories @xmath576 , @xmath577 , @xmath578 , @xmath579 satisfies the following conditions : 1 .   for each @xmath139 , @xmath580",
    ", @xmath581 is a trace of @xmath582 , 2 .   if @xmath583 then @xmath584 , 3 .   if @xmath585 ( or @xmath586 ) then @xmath215 holds in the state @xmath587 ( or @xmath588 ) , and 4 .",
    "if @xmath589 then @xmath215 holds in @xmath590 .",
    "the last item of the above definition can be visualized by the following illustration : @xmath591    next we show how to represent general programs .",
    "similar to programs in the previous section , we will assign names to general programs and their elements . a general program @xmath592",
    "is encoded by the set of atoms and rules @xmath593 where @xmath331 and @xmath594 is the set of atoms and rules encoding @xmath122 and @xmath566 and is described below .",
    "recall that @xmath122 is a set of programs and @xmath566 is a set of constraints .",
    "both @xmath122 and @xmath566 are assigned unique names , @xmath595 and @xmath596 .",
    "the atoms @xmath597 and @xmath598 are added to @xmath331 and @xmath594 respectively .",
    "each element of @xmath122 and @xmath566 is encoded by a set of rules which are added to @xmath331 and @xmath594 , respectively .",
    "finally , the predicate @xmath599 is used to specify what belongs to @xmath122 and @xmath566 , respectively .",
    "elements of @xmath566 are represented by the predicates @xmath600 , @xmath601 , @xmath602 , and @xmath603 where the place holders ` * ' , ` + ' , and ` - ' denote the name of a constraint , a general program , and a formula , respectively .",
    "for example , if @xmath604 belongs to @xmath566 then the set of atoms encoding @xmath566 will contain the atom @xmath605 where @xmath606 and @xmath596 are the names assigned to the ordering constraint @xmath604 and @xmath566 , respectively .",
    "similarly , if @xmath566 contains @xmath607 then @xmath608 ( again , @xmath609 and @xmath596 are the name assigned to the truth constraint @xmath604 and @xmath566 , respectively ) will belong to the set of atoms encoding @xmath566 .    in the following example , we illustrate the encoding of a general program about the blocks world domain .",
    "consider a general program , @xmath610 , to build a tower from blocks @xmath611 that achieves the goal that @xmath23 is on top of @xmath129 and @xmath129 is on top of @xmath612 , i.e. , the goal is to make @xmath613 hold .",
    "we have @xmath614 , and @xmath615 the constant preceding the semicolon is the name assigned to the formula of @xmath566 .",
    "the encoding of @xmath592 is as follows :    * @xmath616 ; * @xmath617 ; and * @xmath594 consists of * * the facts defining @xmath596 and declaring its elements @xmath618 * * the facts defining each of the constraints in @xmath566 : * * * the order constraint @xmath619 : @xmath620 , * * * the precondition constraints @xmath621 : * * * * @xmath622 , * * * * @xmath623 , * * * * @xmath624 , and * * * * @xmath625 .",
    "we now present the ansprolog rules that realize the operational semantics of general programs . for this purpose",
    "we need the rules ( [ tr_act])-([tr_null ] ) and the rules for checking the satisfiability of formulae that were presented earlier .",
    "these rules are for general programs whose top level structure is not an htn . for general programs",
    "whose top level feature is an htn we add the following rule : @xmath626    intuitively , the above rule states that the general program @xmath441 can be unfolded between time points @xmath522 and @xmath523 ( or alternatively : the trajectory from @xmath522 and @xmath523 is a trace of @xmath441 ) if @xmath441 is an htn construct @xmath610 , and it is not the case that the trajectory from @xmath522 and @xmath523 is not a trace of @xmath441 .",
    "the last phrase is encoded by @xmath627 and is true when the trajectory from @xmath522 and @xmath523 violates one of the many constraints dictated by @xmath628 . the main task that now remains is to present ansprolog rules that define @xmath627 . to do that , as suggested by the definition of a trace of a program @xmath610",
    ", we will need to enumerate the permutations @xmath574 of @xmath575 and check whether particular permutations satisfy the conditions in @xmath566 .",
    "we now introduce some necessary auxiliary predicates and their intuitive meaning .",
    "* @xmath629  this means that @xmath56 , a general program belonging to @xmath441 , starts its execution at time @xmath630 , and @xmath441 starts and ends its execution at @xmath522 and @xmath523 respectively . *",
    "@xmath631  this means that @xmath56 , a general program belonging to @xmath441 , ends its execution at time @xmath632 , and @xmath441 starts and ends its execution at @xmath522 and @xmath523 , respectively . * @xmath633  this is an auxiliary predicate indicating that the inequalities @xmath634 hold . * @xmath635  this means that there exists no sub - program @xmath56 of @xmath441 whose execution covers the time moment @xmath153 , i.e. , @xmath636 or @xmath637 where @xmath180 and @xmath638 are the start and finish time of @xmath56 , respectively .",
    "* @xmath639  this indicates that there exists at least two general programs @xmath640 and @xmath641 in @xmath441 whose intervals contain @xmath153 , i.e. , @xmath642 and @xmath643 where @xmath644 and @xmath645 ( @xmath646 ) is the start- and finish - time of @xmath647 , respectively",
    ".    we will now give the rules that define the above predicates .",
    "first , to specify that each general program @xmath56 belonging to the general program @xmath610 , i.e. , @xmath648 , must start and end its execution exactly once during the time @xmath610 is executed , we use the following rules : @xmath649 the first ( resp .",
    "second ) rule says that @xmath56  a program belonging to @xmath122  must start ( resp .",
    "end ) its execution exactly once between @xmath522 and @xmath523 . here",
    ", we use cardinality constraints with variables @xcite in expressing these constraints .",
    "such constraints with variables are short hand for a set of instantiated rules of the form ( [ weight ] ) .",
    "for example , the first rule is shorthand for the set of rules corresponding to the following cardinality constraint : @xmath650 we now give the rules defining @xmath651 and @xmath652 . @xmath653 the rule ( [ thtn11 ] ) states that if a general program @xmath56 in @xmath441 starts its execution at @xmath180 and ends its execution at @xmath638 then its execution spans over the interval @xmath654 $ ] , i.e. , every time moment between @xmath180 and @xmath638 is _ used _ by some general program in @xmath441 .",
    "the rule ( [ thtn12 ] ) states that if a time moment between @xmath522 and @xmath523 is not used by some general program in @xmath441 then it is _",
    "not_used_. the last rule in this group specifies the situation when two general programs belonging to @xmath441 overlap .",
    "we are now ready to define @xmath655 .",
    "there are several conditions whose violation make @xmath656 true .",
    "the first condition is that the time point when a program starts must occur before its finish time .",
    "next , each general program belonging to the set @xmath122 of @xmath610 must have a single start and finish time .",
    "the violation of these two conditions is encoded by the following rules which are added to @xmath110 .",
    "@xmath657    together the rules ( [ thtn2])-([thtn15 ] ) define when the permutation determined by the set of atoms of the form @xmath658 and @xmath659 violates the initial part of condition 8 of definition [ deftrace2 ] .",
    "the rules ( [ thtn2])-([thtn3 ] ) require each general program in @xmath441 to have a unique start and finish time and the rule ( [ thtn4 ] ) encodes the violation when the finish time is earlier than the start time .",
    "the rule ( [ thtn5 ] ) encodes the violation when the trace of a general program in @xmath441 does not correspond to its start and finish times .",
    "the rule ( [ thtn13 ] ) encodes the violation when some time point on the trajectory of @xmath441 is not covered by the trace of a general program in @xmath441 ; and the rule ( [ thtn15 ] ) encodes the violation when the trace of two general programs in @xmath441 overlap .",
    "the next group of rules encode the violation of conditions 8(b ) ",
    "8(d ) of definition [ deftrace2 ] .",
    "@xmath660    the rule ( [ thtn7 ] ) encodes the violation when the constraint @xmath566 of the general program @xmath661 contains @xmath662 , but @xmath641 starts earlier than @xmath640 .",
    "the rule ( [ thtn8 ] ) encodes the violation when @xmath566 contains @xmath663 but the formula @xmath152 does not hold in some point between the end of @xmath640 and start of @xmath641 . the rules ( [ thtn9 ] ) and ( [ thtn10 ] ) encode the violation when @xmath566 contains the constraint @xmath664 or @xmath665 and @xmath152",
    "does not hold immediately before or after respectively , the execution of @xmath56 .",
    "we now formulate the correctness of our above encoding of procedural and htn knowledge given as general programs , and relate the traces of a general program with the answer sets of its ansprolog encoding . for an action theory @xmath31 and a general program @xmath389 ,",
    "let @xmath666 be the ansprolog program obtained from @xmath190 by ( i ) adding the rules ( [ tr_act])-([tr_null ] ) and ( [ thtn1])-([thtn10 ] ) , ( ii ) adding @xmath541 , and ( iii ) replacing the goal constraint with @xmath667 .",
    "the following theorem extends theorem [ th2 ] .",
    "[ th3 ]    let @xmath31 be a consistent action theory and @xmath389 be a general program .",
    "then ,    * for every answer set @xmath191 of @xmath668 with @xmath195 for @xmath98 , @xmath544 is a trace of @xmath389 ; and * if @xmath545 is a trace of @xmath389 then there exists an answer set @xmath191 of @xmath668 such that @xmath546 and @xmath547 for @xmath548 and @xmath549 and @xmath669",
    ".    see appendix a.4    as before , to do planning using procedural and htn constraints all we need to do is to add the goal constraint to @xmath666 , which will filter out all answer sets where the goal is not satisfied in time point @xmath16 , and at the same time will use the sketch provided by the general program @xmath389 .",
    "we tested our implementation with some domains from the general planning literature and from the aips planning competition @xcite .",
    "in particular , we tested our program with the miconic-10 elevator domain .",
    "we also tested our program with the block domain . in both domains , we conducted tests with procedural control knowledge .",
    "our motivation was : ( i ) it has already been established that well - chosen temporal and hierarchical constraints will improve a planner s efficiency ; ( ii ) we have previously experimented with the use of temporal knowledge in the answer set planning framework @xcite ; and ( iii ) we are not aware of any empirical results indicating the utility of procedural knowledge in planning , especially in answer set planning .",
    "( note that @xcite concentrates on using golog to do planning in domains with incomplete information , not on exploiting procedural knowledge in planning . )",
    "we report the results obtained from our experiment with the elevator example from @xcite ( elp1-elp3 ) and the miconic-10 elevator domain ( s1 - 0,",
    " ,s5 - 0 ) , proposed by schindler lifts ltd . for the aips 2000 competition @xcite .",
    "note that some of the planners , that competed in aips 2000 , were unable to solve this problem .",
    "the domain description for this example is described earlier in example [ ex5 ] and the * smodels",
    "* code can be downloaded from http://www.cs.nmsu.edu/~tson/asplan/knowledge .",
    "we use a direct encoding of procedural knowledge in the block domain to avoid the grounding problem . for this reason",
    ", we do not include the results of our experiments on the block domain in this paper .",
    "the results and the encodings of this domain are available on the above mentioned web site .",
    "we note that the direct encoding of procedural knowledge in the block domain yields significantly better results , both in terms of the time needed to find a trajectory as well as the number of problems that can be solved . whether or not the methodology used in the block domain can be generalized and applied to other domains is an interesting question that we would like to investigate in the near future .",
    "the initial state for the elevator planning problem encodes a set of floors where the light is on and the current position of the elevator .",
    "for instance , @xmath670 .",
    "the goal formula is represented by the conjunction @xmath671 .",
    "sometimes , the final position of the elevator is added to the goal .",
    "the planning problem is to find a sequence of actions that will serve all the floors where the light is on and thus make the @xmath672 predicate false for all floors , and if required take the elevator to its destination floor .",
    "since there are a lot of plans that can achieve the desired goal , we can use procedural constraints to guide us to preferable plans .",
    "in particular , we can use the procedural knowledge encoded by the following set of simple golog programs from @xcite , which we earlier discussed in example  [ ex5 ] .",
    "@xmath673)\\\\ ( control & : & [ \\wwhile \\exists n.\\{0,1,\\ldots , k\\ } \\ ; [ on(n ) ] \\ddo serve\\_a\\_floor(n ) ] ; park)\\end{aligned}\\ ] ] we ran experiments on a sony vaio laptop with 256 mb ram and an intel pentium 4 1.59 ghz processor , using * lparse * version 1.00.13 ( windows , build aug 12 , 2003 ) and * smodels * version 2.27 . for planning in this example with and without the procedural control knowledge .",
    "the timings obtained are given in the following table .",
    "[ cols=\"^,^,^,^,^,^ \" , ]     as can be seen , the encoding with control knowledge yields substantially better performance in situations where the plan length is longer . in some instances with small plan lengths , as indicated through boldface in column 6 , the speed up due to the use of procedural knowledge does not make up for the overhead needed in grounding the knowledge .",
    "the output of * smodels * for each run is given in the file _ result _ at the above mentioned url . for larger instances of the elevator domain @xcite ( 5 persons or more and 10 floors or more ) ,",
    "our implementation terminated prematurely with either a stack overflow error or a segmentation fault error .",
    "in this paper we considered three different kinds of domain - dependent control knowledge ( temporal , procedural and htn - based ) that are useful in planning .",
    "our approach is declarative and relies on the language of logic programming with answer set semantics .",
    "we showed that the addition of these three kinds of control knowledge only involves adding a few more rules to a planner written in ansprolog that can plan without any control knowledge .",
    "we formally proved the correctness of our planner , both in the absence and presence of the control knowledge .",
    "finally , we did some initial experimentation that illustrates the reduction in planning time when procedural domain knowledge is used and the plan length is big .    in the past , temporal domain knowledge has been used in planning in @xcite . in both cases ,",
    "the planners are written in a procedural language , and there is no correctness proof of the planners .",
    "on the other hand the performance of these planners is much better than our implementation using ansprolog . in comparison ,",
    "our focus in this paper is on the ` knowledge representation ' aspects of planning with domain dependent control knowledge and demonstration of relative performance gains when such control knowledge is used .",
    "thus , we present correctness proofs of our planners and stress the ease of adding the control knowledge to the planner . in this regard ,",
    "an interesting observation is that it is straightforward to add control knowledge from multiple sources or angles .",
    "thus say two different general programs can be added to the planner , and any resulting plan must then satisfy the two sketches dictated by the two general programs .    as mentioned earlier",
    "our use of htn - based constraints in planning is very different from htn - planning and the recent htn - based planner @xcite . unlike our approach in this paper",
    ", these planners can not be separated into two parts : one doing planning that can plan even in the absence of the knowledge encoded as htn and the other encoding the knowledge as an htn . in other words ,",
    "these planners are not extended classical planners that allow the use of domain knowledge in the form of htn on top of a classical planner .",
    "the timings of the planner @xcite on aips 2000 planning domains are very good though . to convince ourselves of the usefulness of procedural constraints we used their methodology with respect to procedural domain knowledge and wrote general programs for planning with blocks world and the package delivery domain and as in @xcite we wrote planners in a procedural language ( the language c to be specific ) for these domains and also observed similar performance .",
    "we plan to report this result in a future work . with our focus on the knowledge representation aspects",
    "we do not further discuss these experiments here .",
    "although we explored the use of each of the different kinds of domain knowledge separately , the declarative nature of our approach allows us to use the different kinds of domain knowledge for the same planning problem .",
    "for example , for a particular planning problem we may have both temporal domain knowledge and a mixture of procedural and hierarchical domain knowledge given as a general program .",
    "in such a case , planning will involve finding an action sequence that follows the sketch dictated by the general program and at the same time obeys the temporal domain knowledge .",
    "this distinguishes our work from other related work @xcite where the domain knowledge allowed was much more restricted .",
    "a byproduct of the way we deal with procedural knowledge is that , in a propositional environment , our approach to planning with procedural knowledge can be viewed as an off - line interpreter for a golog program . because of the declarative nature of ansprolog the correctness of this interpreter is easier to prove than the earlier interpreters which were mostly written in prolog .",
    "we wish to thank the anonymous reviewers for their detailed comments and suggestions that have helped us to improve the paper in several ways .",
    "the first two authors would like to acknowledge the support of the nasa grant ncc2 - 1232 .",
    "the fourth author would like to acknowledge the support of nasa grant nag2 - 1337 .",
    "the work of chitta baral was also supported in part by the nsf grant 0070463 .",
    "the work of tran cao son was also supported in part by nsf grant 0220590 .",
    "the work of sheila mcilraith was also supported by nserc . a preliminary version of this paper appeared in @xcite .    .",
    "using temporal logics to express search control knowledge for planning .",
    "_ 116 , _  1,2 , 123191 .",
    ", kautz , h. , smith , d. , long , d. , geffner , h. , and koehler , j. 2000 . -00 planning competition . in _ the fifth international conference on artificial intelligence planning and scheduling systems_.    \\2003 . .",
    "cambridge university press , cambridge , ma .",
    "in _ proceedings of the 14th international joint conference on artificial intelligence_. morgan kaufmann publishers , san francisco , ca , 20172023 .    \\1999 . extending congolog to allow partial ordering . in _ proceedings of the 6th international workshop on agent theories , architectures , and languages ( atal ) , lncs ,",
    "1757_. 188204 .",
    "fast planning through planning graph analysis .",
    "_ 90 _ , 281300 .",
    "planning as heuristic search .",
    "_ 129 , _  1 - 2 , 533 .    ,",
    "cremers , a.  b. , fox , d. , hhnel , d. , lakemeyer , g. , d. , s. , steiner , w. , and thrun , s. 1998 . the interactive museum tour - guide robot . in",
    "_ proceedings of the 15th national conference on artificial intelligence ( aaai-98)_. aaai press , 1118 .",
    "the computational complexity of propositional strips planning .",
    "_ 69 _ , 161204 .    \\1987 . planning for conjunctive goals . ,",
    "333377 .    ,",
    "eiter , t. , gottlob , g. , and voronkov , a. 2001 . complexity and expressive power of logic programming .",
    "_ 33 , _  3 ( sept . ) , 374425 .    ,",
    "lesprance , y. , and levesque , h. 2000 . , a concurrent programming language based on the situation calculus .",
    "_ 121 , _  1 - 2 , 109169 .    ,",
    "nebel , b. , and koehler , j. 1997 .",
    "encoding planning problems in nonmonotonic logic programs . in _ proceedings of european conference on planning_. 169181 .",
    "in _ proceedings of the 6th intl workshop on the temporal representation and reasoning , orlando , fl .",
    "( time99)_.    , faber , w. , leone , n. , pfeifer , g. , and polleres , a. 2000 .",
    "planning under incomplete information . in _ proceedings of the first international conference on computational logic ( cl00)_. springer verlag , lnai 1861 , 807821 .    ,",
    "leone , n. , mateis , c. , pfeifer , g. , and scarcello , f. 1998 . .",
    "in _ international conference on principles of knowledge representation and reasoning_. 406417 .    , nau , d. , and subrahmanian , v. 1995 .",
    "complexity , decidability and undecidability results for domain - independent planning .",
    "_ 76 , _  1 - 2 , 7588 .",
    "\\1971 . : a new approach to the application of theorem proving to problem solving .",
    "_ 2 , _  34 , 189208 .",
    "\\2002 . logic programming and knowledge representation  the a - prolog perspective .",
    "_ 138 , _  1 - 2 , 338 .",
    "the stable model semantics for logic programming . in _ logic programming : proceedings  of the fifth international conf .  and symp .",
    "_ , r.  kowalski and k.  bowen , eds .",
    "10701080 .    \\1993 .",
    "representing actions and change by logic programs .",
    "_ 17 , _  2,3,4 , 301323 .",
    "action languages .",
    "_ 3 , _  6 .",
    "\\2001 . .",
    "_ 14 _ , 253302 .    ,",
    "selman , b. , and kautz , h. 1999 .",
    "control knowledge in planning : benefits and tradeoffs . in _ proceedings of the 16th national conference on artificial intelligence ( aaai-99)_. aaai press , 511517 .    ,",
    "mcallester , d. , and selman , b. 1994 .",
    "encoding plans in propositional logic . in _ proceedings  of kr 94_. 374384 .",
    "planning as satisfiability . in _",
    "proceedings  of ecai-92_. 359363 .",
    "\\1996 . pushing the envelope : planning , propositional logic , and stochastic search . in _ proceedings of the 13th national conference on artificial intelligence ( aaai-96)_. aaai press , 11941199 .",
    ": a new approach to the application of theorem proving to problem solving . in _",
    "workshop planning as combinatorial search , aips-98 , pittsburgh_.    1998b .",
    "the role of domain - specific knowledge in the planning as satisfiability framework . in _ proceedings of the 4th international conference on artificial intelligence planning and scheduling",
    "systems_.    , reiter , r. , lesperance , y. , lin , f. , and scherl , r. 1997 . : a logic programming language for dynamic domains .  _ 31 ,",
    "_  1 - 3 ( april - june ) , 5984",
    ".    1999a .",
    "action languages , answer sets and planning . in _ the logic programming paradigm : a 25-year perspective_. springer verlag , 357373 .",
    "answer set planning . in _ proceedings of iclp_. 2337 .",
    "\\2002 . .",
    "_ 138 , _  12 , 3954 .",
    "splitting a logic program . in _",
    "proceedings  of the eleventh international conf .  on logic programming _ , p.  van  hentenryck ,",
    "\\1999 . representing transition systems by logic programs . in _ proceedings of the 5th international conference on logic programming and",
    "nonmonotonic reasoning_. 92106 .",
    "\\1995 . embracing causality in specifying the indirect effects of actions . in _ proceedings of the 14th international joint conference on artificial intelligence_. morgan kaufmann publishers , san mateo , ca , 19851993 .",
    "in _ aaai_.    \\1999 .",
    "stable models and an alternative logic programming paradigm . in _ the logic programming paradigm : a 25-year perspective_. 375398 .",
    ". a causal theory of ramifications and qualifications . in _ proceedings of the 14th international joint conference on artificial intelligence_. morgan kaufmann publishers , san mateo , ca , 19781984 .",
    "modeling and programming devices and web agents . in _ proc . of the nasa goddard workshop on formal approaches to agent - based systems , lncs_. springer - verlag .    , cao , y. , lotem , a. , and mu@xmath674oz - avila , h. 1999 . .",
    "in _ proceedings of the 16th international conference on artificial intelligence_. aaai press , 968973 .",
    "logic programming with stable model semantics as a constraint programming paradigm .",
    "_ 25 , _  3,4 , 241273 .    ,",
    "simons , p. , and soininen , t. 1999 .",
    "stable model semantics for weight constraint rules . in _ proceedings of the 5th international conference on on logic programming and nonmonotonic reasoning_. 315332 .",
    "a logic for default reasoning .",
    "_ 13 , _  1,2 , 81132",
    ".    \\2000 . on knowledge - based programming with sensing in the situation calculus . in _ proc . of the second international cognitive robotics workshop ,",
    "berlin_.    \\1974 .",
    "planning in a hierarchy of abstraction spaces .",
    "_ 5 _ , 115135 .    , swift , t. , and warren , d. 1994 .",
    "as an efficient deductive database engine . in _ proceedings of the sigmod_. 442  453 .    ,",
    "niemel , n. , and soininen , t. 2002 . .",
    "_ 138 , _  12 , 181234 .    ,",
    "baral , c. , and mcilraith , s. 2001 .",
    "domain dependent knowledge in planning - an answer set planning approach . in _ proceedings of the 6th international conference on logic programming and nonmonotonic reasoning_. vienna , 226239 .",
    "\\1995 . relating stable models and ai planning domains . in _ proceedings of the international conference on logic programming_. 233247 .",
    "effect of knowledge representation on model based planning : experiments using logic programming encodings . in _ proc . of aaai spring symposium on `` answer set programming : towards efficient and scalable knowledge representation and reasoning''_. 110115 .",
    "\\1997 . representing actions in logic programs and default theories .  _",
    "31(1 - 3 ) _ , 245298 .",
    "polynomial - length planning spans the polynomial hierarchy . in _ proc . of eighth european conf . on logics in artificial intelligence ( jelia02 )",
    "111 - 124 , 2002 .",
    "spring 2001 .",
    "a call for knowledge - based planning .",
    "_ 22 , _  1 , 99115 .",
    "we apply the splitting theorem and splitting sequence theorem @xcite several times in our proof ) which were not discussed in @xcite .",
    "the modification is discussed in appendix b. ] .",
    "for ease of reading , the basic notation and the splitting theorem are included in appendix b. since we assume a propositional language any rule in this paper can be considered as a collection of its ground instances . therefore , throughout the proof , we often say a rule @xmath128 whenever we refer to a ground rule @xmath128 .",
    "by @xmath675 , we denote the set of literals of a program @xmath676 .",
    "for a planning problem @xmath340 , let @xmath677 i.e. , @xmath676 is obtained from @xmath187 by removing the rules encoding @xmath99 and the constraint @xmath678 .",
    "let @xmath122 be a set of literals of the form @xmath679 . abusing the notation",
    ", we say that @xmath122 is _ consistent with respect to * f * _ ( or consistent , for short ) if for every pair of a fluent @xmath680 and a time moment @xmath250 , @xmath122 does not contain both @xmath681 and @xmath682 . for a set of causal laws @xmath64 and a set of fluent literals @xmath353 , let    @xmath683    it is easy to see that @xmath684 is a monotonic function and bounded above by * f*. thus , the sequence @xmath685 , where @xmath686 and @xmath687 for @xmath688 , is a convergent sequence . in other words , there exists some @xmath689 such that @xmath690 for @xmath691 .",
    "let @xmath692 .",
    "we have that @xmath693 is closed under @xmath64 .",
    "we can prove the following lemma .",
    "[ ladd00 ] for a set of causal laws @xmath64 and a set of fluent literals @xmath353 ,    1 .",
    "@xmath693 is consistent and @xmath694 iff @xmath695 is defined ; and 2 .",
    "@xmath693 is inconsistent iff @xmath695 is undefined .",
    "the lemma is trivial for inconsistent set of literals @xmath353 .",
    "we need to prove it for the case where @xmath353 is consistent .    1 .",
    "consider the case where @xmath693 is consistent . from the definition of the function @xmath696 in ( [ def - mky ] )",
    ", we have that @xmath697 for every set of literals @xmath122",
    ". therefore , @xmath698 for every @xmath466 .",
    "thus , @xmath699 . because @xmath693 is closed under @xmath64 and @xmath695 is the least set of literals closed under @xmath64 , we can conclude that @xmath700 .",
    "+ to complete the proof of the first item , we need to show that if @xmath695 is defined , then @xmath693 is consistent and @xmath701 . again",
    ", it follows immediately from equation ( [ def - mky ] ) that @xmath697 for every consistent set @xmath122 .",
    "this implies that @xmath698 for every @xmath466 .",
    "thus , we have that @xmath699 .",
    "this implies the consistency of @xmath693 .",
    "the equality @xmath701 follows from the closeness of @xmath693 with respect to @xmath64 and the definition of @xmath695 .",
    "this concludes the first item of the lemma .",
    "2 .   consider the case where @xmath693 is inconsistent .",
    "assume that @xmath695 is defined .",
    "by definition of @xmath702 , we know that if @xmath702 is inconsistent then @xmath703 is also inconsistent .",
    "thus , there exists an integer @xmath439 such that @xmath704 is consistent and @xmath705 is inconsistent .",
    "because of the consistency of @xmath695 and @xmath706 , we conclude that @xmath707 .",
    "consider @xmath708 . by the definition of @xmath696",
    ", there exists some static causal law @xmath709 in @xmath64 such that @xmath710 .",
    "this implies that @xmath695 is not closed under @xmath64 , which contradicts the definition of @xmath695 .",
    "this shows that @xmath695 is undefined .",
    "+ now , consider the case where @xmath695 is undefined . using contradiction and the result of the first item , we can also show that @xmath693 is inconsistent .",
    "this concludes the proof of the second item of the lemma .",
    "[ ladd0 ] for a set of causal laws @xmath64 and a set of fluent literals @xmath353 , for every integer @xmath439 , the program consisting of the following rules : @xmath711    1 .   has a unique answer set @xmath712 iff @xmath695 is defined ; and 2 .",
    "does not have an answer set iff @xmath695 is undefined .",
    "let us denote the given program by @xmath713 and @xmath521 be the program consisting of the rules of @xmath713 with the head different than @xmath115 . since @xmath521 is a positive program , we know that it has a unique answer set",
    ", says @xmath118 .",
    "it is easy to see that if @xmath118 is consistent with respect to * f * , then @xmath118 is the unique answer set of @xmath713 ; otherwise , @xmath713 does not have an answer set .",
    "it is easy to see that @xmath714 is the unique answer set of @xmath521 .",
    "consider the two cases :    1 .",
    "@xmath695 is defined .",
    "lemma [ ladd00 ] implies that @xmath715 , and hence , @xmath118 is consistent with respect to * f*. this implies that @xmath118 is the unique answer set of @xmath713 .",
    "@xmath695 is undefined .",
    "lemma [ ladd00 ] implies that @xmath693 is inconsistent , which implies that @xmath118 is inconsistent with respect to * f * , and hence , @xmath713 does not have an answer set .",
    "we now prove some useful properties of @xmath676 .",
    "we will prove that if @xmath31 is consistent then @xmath676 is consistent ( i.e. , @xmath676 has an answer set ) and that @xmath676 correctly implements the transition function @xmath54 of @xmath33 .",
    "first , we simplify @xmath676 by using the splitting theorem @xcite ( theorem [ spl1 ] , appendix b ) .",
    "let @xmath716 be the set of literals in the language of @xmath676 whose parameter list does not contain the time parameter , i.e. , @xmath716 consists of auxiliary atoms of the form @xmath717 , @xmath718 , @xmath719 , @xmath720 .",
    "it is easy to see that @xmath716 is a splitting set of @xmath676 .",
    "furthermore , it is easy to see that the bottom program @xmath721 consists of the rules that define actions , fluents , and the rules ( [ fol_lit1])([ir_contra2 ] ) .",
    "obviously , @xmath721 is a positive program , and hence , it has a unique answer set .",
    "let us denote the unique answer set of @xmath721 by @xmath722 .",
    "the partial evaluation of @xmath676 with respect to @xmath723 , @xmath724 , is the collection of the following rules : @xmath725    it follows from the splitting theorem that to prove the consistency and correctness of @xmath676 it is enough to prove the consistency of @xmath726 and that @xmath726 correctly implements the transition function @xmath54 of @xmath33 .",
    "we prove this in the next lemmas .",
    "[ smodel - traject1-add ]",
    "let @xmath31 be a consistent action theory .",
    "let @xmath118 be an answer set of @xmath726 .",
    "then ,    1 .",
    "@xmath727 is a state of @xmath33 for every @xmath728 , @xmath729 is the set @xmath730 for every @xmath731 , 2 .",
    "if @xmath118 contains @xmath732 then @xmath23 is executable in @xmath727 and @xmath733 , and 3 .   for every @xmath731 , if @xmath734 for every action @xmath23 , then @xmath735 .",
    "it is easy to see that the sequence @xmath736 , where    @xmath737 is a splitting sequence of @xmath726 .",
    "since @xmath118 is an answer set of @xmath726 , by the splitting sequence theorem ( theorem [ spl2 ] , appendix b ) , there exists a sequence of sets of literals @xmath738 such that @xmath739 , and    * @xmath740 , * @xmath741 is an answer set of @xmath742 and * for every @xmath743 , @xmath744 is an answer set of @xmath745 .",
    "we will prove the lemma by inductively proving that for every @xmath250 , @xmath746 , the following holds :    * @xmath744 is complete and consistent with respect to @xmath747 in the sense that for each fluent @xmath12 , @xmath744 contains either @xmath681 or @xmath682 but not both , * @xmath744 contains at most one atom of the form @xmath732 , * @xmath748 is a state of @xmath33 , and * if @xmath749 then @xmath23 is executable in @xmath750 and @xmath751 ; if no atom of the form @xmath752 belongs to @xmath753 then @xmath754 .",
    "trivially , @xmath741 satisfies ( iv ) .",
    "so , we only need to show that @xmath741 satisfies ( i)-(iii ) .",
    "let @xmath756 .",
    "we have that @xmath757 consists of only rules of the form ( [ pi2_cau])-([pi2_nocc ] ) and ( [ pi2_constraint ] ) with @xmath758 .",
    "let @xmath759 is a fluent@xmath760 is a fluent@xmath527 .",
    "we can easily checked that @xmath761 is a splitting set of @xmath757 .",
    "thus , by the splitting theorem , @xmath762 where @xmath763 is an answer set of @xmath764 and @xmath765 is an answer set of @xmath766 .",
    "because @xmath763 contains only literals of the form @xmath767 and @xmath765 contains only literals of the form @xmath768 , @xmath769 , and @xmath770 , we have that @xmath771 and @xmath772 iff @xmath773 .",
    "hence , to prove that @xmath741 satisfies ( i)-(iii ) , we show that @xmath763 satisfies ( i ) and ( iii ) and @xmath765 satisfies ( ii ) .",
    "we have that the bottom program @xmath764 consists of rules of the form ( [ pi2_init ] ) and ( [ pi2_cau ] ) . because of the consistency of @xmath31 ,",
    "we have that @xmath774 is consistent and hence @xmath775 is consistent with respect to * f*. it follows from lemma [ ladd0 ] that @xmath776 is the unique answer set of @xmath764 where @xmath87 is the initial state of @xmath31 .",
    "because of the completeness of @xmath32 and the consistency of @xmath31 , we can conclude that @xmath763 is complete and consistent .",
    "thus , @xmath763 satisfies ( i ) .",
    "furthermore , because @xmath777 , we conclude that @xmath763 satisfies ( iii ) .",
    "the partial evaluation of @xmath757 with respect to @xmath778 , @xmath779 , consists of @xmath780 let @xmath781 be the set of atoms occurring in the rule ( a1 ) of @xmath779 .",
    "there are two cases :    * * case 1 : * @xmath782 . obviously , the empty set is the unique answer set of @xmath779 .",
    "thus , @xmath765 does not contain any atom of the form @xmath768 . * * case 2 : * @xmath783 . by applying the splitting theorem one more time with the splitting set @xmath781",
    "we can conclude that @xmath765 is an answer set of @xmath779 if and only if there exists some action @xmath23 , @xmath784 , and @xmath785 thus , @xmath765 contains only one atom of the form @xmath768 .",
    "the above two cases show that @xmath765 contains at most one atom of the form @xmath768 .",
    "this concludes the proof of the base case .",
    "assume that @xmath744 , @xmath786 , satisfies ( i)-(iv ) .",
    "we will show that @xmath787 also satisfies ( i)-(iv ) .",
    "let @xmath788 .",
    "the splitting sequence theorem implies that @xmath787 is an answer set of @xmath789 that consists of the following rules : @xmath790 from the constraint ( [ pik_constr2 ] ) , we have that for every fluent @xmath12 , @xmath787 can not contain both @xmath791 and @xmath682 .",
    "this means that @xmath787 is consistent .",
    "we now show that @xmath787 is also complete .",
    "assume the contrary , i.e. , there exists a fluent @xmath12 such that neither @xmath791 nor @xmath792 belongs to @xmath787 . because of the completeness of @xmath793 ( item ( i ) , inductive hypothesis ) , either @xmath794 or @xmath795 .",
    "if the first case happens , rule ( [ pik_in1 ] ) belongs to @xmath789 , and hence , @xmath787 must contain @xmath791 , which contradicts our assumption that @xmath796 . similarly , if the second case happens , because of rule ( [ pik_in2 ] ) , we can conclude that @xmath797 which is also a contradiction .",
    "thus , our assumption on the incompleteness of @xmath787 is incorrect . in other words",
    ", we have proved that @xmath787 is indeed complete and consistent , i.e. , ( i ) is proved for @xmath787 .",
    "we now prove the other items of the conclusion .",
    "let @xmath798 and @xmath799 @xmath800 is a splitting set of @xmath789 .",
    "let @xmath801 . from the splitting theorem ,",
    "we know that @xmath802 must be an answer set of the program @xmath803 that consists of the following rules : @xmath804 let @xmath805 and @xmath806 be the set of atoms occurring in the rule ( b1 ) and ( b3)-(b4 ) , respectively .",
    "let @xmath807 and @xmath808 .",
    "there are two cases :    * * case 1 : * @xmath809 does not contain an atom of the form @xmath810 .",
    "we have that @xmath811 and @xmath812 . from lemma [ ladd0 ] , we know that @xmath803 has a unique answer set @xmath813 which is @xmath802 . because @xmath814 and the definition of @xmath815 , we have that @xmath816 .",
    "the completeness and consistency of @xmath817 and @xmath793 implies that @xmath818 . because @xmath819 satisfies ( i)-(iv ) , @xmath787 also satisfies ( i)-(iv ) .",
    "* * case 2 : * there exists an action @xmath23 such that @xmath820 . because of the rule ( b1 ) we have that @xmath821 .",
    "the completeness of @xmath817 and @xmath793 and the rules ( b3)-(b4 ) imply that @xmath822 .",
    "furthermore , lemma [ ladd0 ] implies that @xmath803 has a unique answer set @xmath823 which is @xmath802 ( because @xmath802 is an answer set of @xmath824 ) .",
    "hence , @xmath825 .",
    "this implies that @xmath826 . in other words , we have proved that @xmath787 satisfies ( iii)-(iv ) .",
    "the above two cases show that @xmath787 satisfies ( iii ) and ( iv ) .",
    "it remains to be shown that @xmath787 contains at most one atom of the form @xmath827 .",
    "again , by the splitting theorem , we can conclude that @xmath828 must be an answer set of the following program @xmath829 let @xmath830 be the set of atoms occurring in the first rule of @xmath831 .",
    "similar to the proof of the base case , we can show that for every answer set @xmath832 of @xmath831 , either @xmath832 does not contain an atom of the form @xmath827 or there exists one and only one action @xmath23 such that @xmath833 and @xmath834 is an action , @xmath835 . in either case",
    ", we have that @xmath836 satisfies the conditions ( ii ) .",
    "the inductive step is proved .",
    "the conclusion of the lemma follows immediately from the fact that @xmath837 for every @xmath250 and @xmath838 iff @xmath839 and @xmath744 satisfies the property ( i)-(iv ) .",
    "the lemma is proved .",
    "[ smodel - traject2-add ] for every trajectory @xmath194 in @xmath33 and a consistent action theory @xmath31 , @xmath726 has an answer set @xmath118 such that    1 .",
    "@xmath840 for every @xmath250 , @xmath746 , and 2 .",
    "@xmath841 for every @xmath250 , @xmath842 .",
    "we prove the theorem by constructing an answer set @xmath118 of @xmath726 that satisfies the items 1 and 2 .",
    "again , we apply the splitting sequence theorem with the splitting sequence @xmath843 , where @xmath844 for every @xmath250 , @xmath746 , let @xmath845 is executable in @xmath846 .",
    "we define a sequence of sets of literals @xmath847 as follows .    * for @xmath842 , @xmath848 * if @xmath849 , then let @xmath850 be an arbitrary action that is executable in @xmath851 and @xmath852 * if @xmath853 , then @xmath854    we will prove that @xmath847 is a solution to @xmath726 with respect to @xmath855 .",
    "this amounts to prove that    * @xmath741 is an answer set of @xmath742 and * for every @xmath743 , @xmath744 is an answer set of @xmath745 .",
    "we first prove that @xmath741 is an answer set of @xmath756 . by the construction of @xmath757 and @xmath741",
    ", we have that @xmath856 consists of the following rules : @xmath857 we will show that @xmath741 is a minimal set of literals closed under the rules ( a1)-(a6 ) and therefore is an answer set of @xmath757 .",
    "since @xmath858 iff @xmath859 ( definition of @xmath741 ) and @xmath860 iff @xmath861 ( definition of @xmath87 ) , we conclude that @xmath741 is closed under the rule of the form ( a1 ) . because of",
    "@xmath87 is closed under the static causal laws in @xmath33 , we conclude that @xmath741 is closed under the rule of the form ( a2 ) . the definition of @xmath862 guarantees that @xmath741 is closed under the rule of the form ( a3 ) . since @xmath194 is a trajectory of @xmath33",
    ", @xmath863 is executable in @xmath864 .",
    "this implies that @xmath865 .",
    "this , together with the fact that @xmath866 , implies that @xmath741 is closed under the rule ( a4 ) .",
    "the construction of @xmath741 also implies that @xmath741 is closed under the rule ( a5 ) . finally ,",
    "because of the consistency of @xmath32 , we have that @xmath741 does not contain @xmath867 and @xmath868 for any fluent @xmath12 .",
    "thus , @xmath741 is closed under the rules of @xmath856 .    to complete the proof , we need to show that @xmath741 is minimal .",
    "consider an arbitrary set of atoms @xmath869 that is closed under the rules ( a1)-(a6 ) .",
    "this implies the following :    * @xmath870 for every @xmath859 ( because of the rule ( a1 ) ) . *",
    "@xmath871 ( because of the rule ( a3 ) and the definition of @xmath862 ) . * @xmath872 ( because of the rule ( a4 ) ) .",
    "* @xmath873 is an action , @xmath874 ( because @xmath872 and the rule ( a5 ) ) .",
    "the above items imply that @xmath875 . in other words , we show that @xmath741 is a minimal set of literals that is closed under the rules ( a1)-(a6 ) .",
    "this implies that @xmath741 is an answer set of @xmath856 , which implies that @xmath741 is an answer set of @xmath757 .    to complete the proof of the lemma , we will prove by induction over @xmath250 , @xmath743 , that @xmath744 is an answer set of @xmath876 . since the proof of the base case ( @xmath877 ) and the inductive step is similar ,",
    "we skip the base case and present only the proof for the inductive step . now , assuming that @xmath744 , @xmath786 , is an answer set of @xmath878 .",
    "we show that @xmath787 is an answer set of @xmath789 .",
    "let @xmath879 .",
    "the program @xmath789 consists of the following rules : @xmath880 it is easy to see that @xmath789 can be split by the set of literal @xmath881 is a fluent literal@xmath527 and the bottom program @xmath801 consists of the rules ( [ pik1_dyn])-([pik1_cau ] ) and ( [ pik1_in1])-([pik1_in2 ] ) .",
    "we will prove first that @xmath882 is an answer set of the program @xmath803 that consists of the following rules : @xmath883    let @xmath805 and @xmath806 be the set of atoms occurring in the rule ( b1 ) and ( b3)-(b4 ) , respectively .",
    "let @xmath884 and @xmath808 .",
    "rule ( b1 ) and the fact that @xmath885 iff @xmath886 imply that @xmath887 .",
    "similar argument allows us to conclude that @xmath888 .",
    "lemma [ ladd0 ] implies that @xmath803 has a unique answer set @xmath889 . since @xmath890 and @xmath891",
    ", we have that @xmath892 .",
    "it follows from the definition of @xmath802 that @xmath893 .",
    "thus , @xmath802 is an answer set of @xmath824 .",
    "it follows from the splitting theorem that to complete the proof of the inductive step , we need to show that @xmath828 is an answer set of the partial evaluation of @xmath789 with respect to @xmath894 , @xmath895 , which is the following program @xmath896 it is easy to see that the reduct of @xmath897 with respect to @xmath832 , @xmath898 , consists of the following rules @xmath899 let @xmath830 be the set of atoms occurring in the first rule of @xmath898 . because @xmath900 is a trajectory in @xmath33 , @xmath901 is executable in @xmath902 .",
    "thus , @xmath903 belongs to @xmath830 .",
    "it is easy to see that @xmath832 is the unique answer set of @xmath898 . in other words",
    ", @xmath832 is an answer set of @xmath897 .",
    "the inductive step is proved .",
    "the property of @xmath744 implies that the sequence @xmath904 is a solution to @xmath726 with respect to the sequence @xmath855 . by the splitting sequence theorem ,",
    "@xmath905 is an answer set of @xmath726 .",
    "because of the construction of @xmath744 , we have that @xmath906 for every @xmath250 and @xmath841 for every @xmath250 , @xmath746 .",
    "the lemma is proved .",
    "the above lemmas lead to the following corollaries .",
    "[ smodel - traject1 ] let @xmath118 be an answer set of @xmath676 .",
    "then ,    * @xmath727 is a state of @xmath33 for every @xmath250 , @xmath907 , * if @xmath118 contains @xmath732 then @xmath23 is executable in @xmath727 and @xmath733 for every @xmath250 , @xmath908 , and * if @xmath734 for every action @xmath23 , then @xmath909 for every @xmath250 , @xmath842 .",
    "it follows from the splitting theorem that @xmath910 is an answer set of @xmath726 . because @xmath911 and lemma [ smodel - traject1-add ]",
    ", we conclude that @xmath118 satisfies the ( i)-(iii ) .",
    "[ smodel - traject2 ] for every trajectory @xmath194 in @xmath33 and a consistent action theory @xmath31 , @xmath676 has an answer set @xmath118 such that    * @xmath840 for every @xmath250 , @xmath746 , and * @xmath841 for every @xmath250 , @xmath842 .    from lemma [ smodel - traject2-add ] ,",
    "there exists an answer set @xmath353 of @xmath726 such that @xmath912 and @xmath913 .",
    "again , from the splitting theorem , we can conclude that there exists an answer set @xmath118 of @xmath676 such that @xmath910 . because @xmath911 , we conclude that @xmath118 satisfies ( i)-(ii ) .",
    "the next observation is also useful .",
    "[ smodel - observation ] for every answer set @xmath118 of @xmath676 , if there exists an @xmath250 such that @xmath118 does not contain an atom of the form @xmath732 , then @xmath118 does not contain an atom of the form @xmath914 for @xmath915 .    using the result of the above corollaries we can prove theorem [ th1 ] .    for a planning problem @xmath193 ,    *",
    "if @xmath194 is a trajectory achieving @xmath99 , then there exists an answer set @xmath191 of @xmath190 such that 1 .",
    "@xmath195 for @xmath98 and 2 .",
    "@xmath196 for @xmath197 .",
    "+ and * if @xmath191 is an answer set of @xmath190 , then there exists an integer @xmath198 such that @xmath199 is a trajectory achieving @xmath99 where @xmath200 for @xmath916 and if @xmath202 then no action is executable in the state @xmath203 .",
    "we have that @xmath917 .",
    "assume that @xmath918 .    .",
    "since @xmath194 is a trajectory achieving @xmath99 , the existence of @xmath118 that satisfies the condition ( i ) of the theorem follows from corollary [ smodel - traject2 ] .",
    "furthermore , because of @xmath919 , we can conclude that @xmath920 for every @xmath466 , @xmath921 .",
    "thus , @xmath922 is an answer set of @xmath190 .",
    "this implies the existence of @xmath191 satisfying ( i ) .    .",
    "let @xmath191 be an answer set of @xmath190 .",
    "it is easy to see that this happens iff @xmath923 and @xmath924 is an answer set of @xmath676 and @xmath920 for every @xmath466 , @xmath921 .",
    "it follows from observation [ smodel - observation ] that there exists an integer @xmath925 such that for each @xmath466 , @xmath347 , there exists an action @xmath96 such that @xmath195 and for @xmath926 , @xmath927 for every action @xmath23 . by corollary [ smodel - traject1 ] , we know that @xmath96 is executable in @xmath209 and @xmath928 .",
    "this means that @xmath929 is a trajectory and @xmath930 .",
    "moreover , @xmath99 holds in @xmath931 .",
    "thus , @xmath929 is a trajectory achieving @xmath99 .",
    "furthermore , it follows from corollary [ smodel - traject1 ] and the rules ( [ pi2_occ ] ) and ( [ pi2_nocc ] ) that if @xmath202 then @xmath191 does not contain literals of the form @xmath932 .",
    "this implies that no action is executable in @xmath203 if @xmath933 .",
    "let @xmath122 be a finite set of goal - independent temporal formulae , @xmath329 be a sequence of states , and @xmath330 where    * @xmath331 is the set of atoms used in encoding @xmath122 , and * @xmath332 is a fluent literal and @xmath333 .",
    "then ,    * the program @xmath334 has a unique answer set , @xmath118 .",
    "* for every temporal formula @xmath215 such that @xmath335 , @xmath215 is true in @xmath336 , i.e. , @xmath337 , if and only if @xmath338 belongs to @xmath118 where @xmath339 .",
    "first , we prove ( i ) . we know that if a program is locally stratified then it has a unique answer set",
    ". we will show that @xmath334 ( more precisely , the set of ground rules of @xmath334 ) is indeed locally stratified . to accomplish that we need to find a mapping @xmath934 from literals of @xmath334 to @xmath935 that has the property : if @xmath936 is a rule in @xmath334 , then @xmath937 for all @xmath938 and @xmath939 for all @xmath940 . to define @xmath934 , we first associate to each constant @xmath215 that occurs as the first parameter of the predicate @xmath941 in @xmath334 a non - negative number @xmath942 as follows .",
    "* @xmath943 if @xmath139 is a literal ( recall that if @xmath139 is a literal then @xmath944 ) . *",
    "@xmath945 if @xmath215 has the form @xmath946 , @xmath947 , @xmath948 , or @xmath949 .",
    "* @xmath950 if @xmath215 has the form @xmath951 , @xmath952 , or @xmath953 .",
    "we define @xmath934 as follows .",
    "* @xmath954 , * @xmath955 , and * @xmath956 for every other literal of @xmath334 .    examining all the rules in @xmath334",
    ", we can verify that @xmath934 has the necessary property .",
    "we now prove ( ii ) .",
    "let @xmath118 be the answer set of @xmath334 .",
    "we prove the second conclusion of the lemma by induction over @xmath957 .",
    "let @xmath215 be a formula with @xmath958 . by the definition of @xmath24 , we know that @xmath215 is a literal",
    ". then @xmath215 is true in @xmath253 iff @xmath215 is in @xmath253 , that is , iff @xmath959 belongs to @xmath118 , which , because of rule ( [ fol_lit_tran ] ) , proves the base case .",
    "assume that for all @xmath960 and formula @xmath215 such that @xmath961 , the formula @xmath215 is true in @xmath253 iff @xmath338 is in @xmath118 .",
    "let @xmath215 be such a formula that @xmath962 .",
    "because of the definition of @xmath24 , @xmath215 is a non - atomic formula .",
    "we have the following cases :    * * case 1 : * @xmath963 .",
    "we have that @xmath964 . because of @xmath965 and @xmath966 , @xmath967 iif the body of rule ( [ fol_neg ] ) is satisfied by @xmath118 iff @xmath968 iff @xmath969 ( by inductive hypothesis ) iff @xmath970 .",
    "* * case 2 : * @xmath971 .",
    "similar to the first case , it follows from the rule ( [ fol_and ] ) and the facts @xmath972 and @xmath973 that @xmath967 iif the body of rule ( [ fol_and ] ) is satisfied by @xmath118 iff @xmath974 and @xmath975 iff @xmath976 and @xmath977 ( inductive hypothesis ) iff @xmath978 . * * case 3 : * @xmath979 .",
    "the proof is similar to the above cases , relying on the two rules ( [ fol_or1 ] ) , ( [ fol_or2 ] ) , and the fact @xmath980 and @xmath981 . * * case 4 : * @xmath318 .",
    "we have that @xmath982 and @xmath983 .",
    "assume that @xmath337 . by definition [ tpl - semantics",
    "] , there exists @xmath984 such that @xmath985 and for all @xmath262 , @xmath986 . by inductive hypothesis , @xmath987 and for all @xmath988 , @xmath262 , @xmath989 .",
    "it follows that @xmath990 .",
    "because of rule ( [ lt_until ] ) , we have @xmath967 .",
    "+ on the other hand , if @xmath967 , because the only rule supporting @xmath338 is ( [ lt_until ] ) , there exists @xmath984 such that @xmath990 and @xmath991 .",
    "it follows from @xmath990 that @xmath989 for all @xmath262 . by inductive hypothesis",
    ", we have @xmath986 for all @xmath992 and @xmath993 .",
    "thus @xmath994 , i.e. , @xmath337 .",
    "* * case 5 : * @xmath316 .",
    "note that @xmath982 .",
    "rule ( [ lt_next ] ) is the only rule supporting @xmath338 where @xmath316 .",
    "so @xmath995 iff @xmath996 iff @xmath997 iff @xmath998 iff @xmath337 . *",
    "* case 6 : * @xmath320 .",
    "we note that @xmath999 .",
    "observe that @xmath338 is supported only by rule ( [ lt_always ] ) .",
    "so @xmath995 iff @xmath1000 .",
    "the latter happens iff @xmath989 for all @xmath1001 , that is , iff @xmath986 for all @xmath1001 which is equivalent to @xmath1002 , i.e. , iff @xmath1003 . *",
    "* case 7 : * @xmath322 .",
    "we know that @xmath1004 is supported only by rule ( [ lt_event ] ) .",
    "so @xmath967 iff there exists @xmath1005 such that @xmath989 . because @xmath999 , by induction , @xmath967 iff there exists @xmath1001 such that @xmath1006 , that is , iff @xmath1007 , i.e. , iff @xmath337 .",
    "the above cases prove the inductive step , and hence , the theorem .",
    "we first prove some lemmas that are needed for proving theorem [ th2 ] . abusing the notation , by @xmath1008",
    "we denote the program consisting of the rules of @xmath676 ( appendix a.1 ) and the set of rules @xmath328 where the time constant @xmath153 takes the value between @xmath159 and @xmath16 .",
    "[ lemtrace1 ] for a consistent action theory @xmath31 , a ground complex action @xmath389 , and an answer set @xmath191 of @xmath1009 with @xmath195 for @xmath1010 , @xmath1011 is a trace of @xmath389 .",
    "it is easy to see that the union of the set of literals of @xmath1008 and the set of rules and atoms encoding @xmath389 , i.e. , @xmath1012 , is a splitting set of @xmath1009 .",
    "furthermore , @xmath1013 .",
    "thus , by the splitting theorem , @xmath191 is an answer set of @xmath540 iff @xmath352 where @xmath118 is an answer set of @xmath1014 , and @xmath353 is an answer set of @xmath1015 . because of the constraint @xmath1016 , we know that if @xmath191 is an answer set of @xmath1009 then every answer set @xmath353 of @xmath1017 must contain @xmath1018 .",
    "furthermore , we have that @xmath1019 for every @xmath250 .",
    "hence , in what follows we will use @xmath727 and @xmath1020 interchangeably .",
    "we prove the conclusion of the lemma by proving a stronger conclusion or @xmath23 as the name associated to @xmath139 or @xmath23 , respectively . ] :    * for every ground complex action @xmath435 with the name @xmath1021 and two time points @xmath1022 such that @xmath1023 and @xmath1024 , @xmath1025 is a trace of @xmath435 ( the states @xmath209 and actions @xmath96 are given in the lemma s statement ) .",
    "denote @xmath1026 .",
    "we have that @xmath1027 consists of the following rules : @xmath1028    clearly , @xmath1027 is a positive program .",
    "thus , the unique answer set of @xmath1027 , denoted by @xmath353 , is the fix - point of the @xmath1029 operator , defined by @xmath1030 there exists a rule @xmath1031 in @xmath1027 such that @xmath1032 for @xmath1033 .",
    "let @xmath1034 . by definition @xmath1035 .    for every atom @xmath1036 ,",
    "let @xmath1037 denote the smallest integer @xmath439 such that for all @xmath1038 , @xmath1039 and for all @xmath1040 , @xmath1041 .",
    "( notice that the existence of @xmath1037 is guaranteed because @xmath1029 is a monotonic , fix - point operator . )",
    "we prove ( * ) by induction over @xmath1042 .",
    "then @xmath1027 contains a rule of the form @xmath1044 . because @xmath1023 , we know that @xmath1044 comes from a rule @xmath128 of the form ( [ pi1tr_act ] ) , ( [ pi1tr_form ] ) , or ( [ pi1tr_while_false ] ) .",
    "* @xmath128 is of the form ( [ pi1tr_act ] ) .",
    "so , @xmath435 is some action @xmath23 , i.e. , @xmath719 and @xmath732 both belong to @xmath118 .",
    "further , @xmath1045 . because of corollary [ smodel - traject1 ] we know that @xmath23 is executable in @xmath1046 and @xmath1047 . since @xmath1048 for every @xmath250 , we have that @xmath1049 is a trace of @xmath435 .",
    "* @xmath128 is of the form ( [ pi1tr_form ] ) .",
    "then @xmath1050 , where @xmath215 is a formula and @xmath338 is in @xmath118 . by theorem",
    "[ the - lt - sem ] , @xmath215 holds in @xmath727 . again , because @xmath1048 , we have that @xmath1020 is a trace of @xmath435 .",
    "* @xmath128 is of the form ( [ pi1tr_while_false ] ) .",
    "then , @xmath1051 , @xmath1052 , and @xmath1053 .",
    "that is , @xmath435 is the program `` @xmath1054 '' and @xmath215 does not holds in @xmath1055 .",
    "thus , @xmath1055 is a trace of @xmath435 .",
    "assume that we have proved ( * ) for @xmath1056 .",
    "we need to prove it for the case @xmath1057 .    because @xmath1058 is in @xmath1059 ,",
    "there is some rule @xmath1060 in @xmath1027 such that all @xmath1061 are in @xmath802 . from the construction of @xmath1027",
    ", we have the following cases :    * @xmath128 is a rule of the form ( [ pi1tr_proc ] )",
    ". then , there exists @xmath1062 such that @xmath1063 , @xmath1064 , and @xmath1065 .",
    "hence , @xmath1066 and @xmath1067 . by inductive hypothesis",
    ", @xmath1068 is a trace of @xmath1069 and @xmath1070 is a trace of @xmath1071 . since @xmath1072 we know that @xmath1073 . by definition [ deftrace1 ] , @xmath1074 is a trace of @xmath435 .",
    "* @xmath128 is a rule of the form ( [ pi1tr_choice ] ) .",
    "then , @xmath1075 is in @xmath118 .",
    "so , @xmath435 is a choice program , say @xmath1076 .",
    "in addition , there exists @xmath1077 such that @xmath1078 and @xmath1079 . by the definition of @xmath1080 ,",
    "@xmath1081 . by inductive hypothesis",
    ", @xmath1074 is a trace of @xmath1082 . by definition [ deftrace1 ] , it is also a trace of @xmath435 .",
    "* @xmath128 is a rule of the form ( [ pi1tr_if_true ] ) .",
    "then , by the construction of @xmath1027 , there exists @xmath215 , @xmath1069 , @xmath1071 such that @xmath1083 , @xmath1084 , and @xmath1085 .",
    "thus @xmath435 is the program `` @xmath1086 '' and @xmath1087 .",
    "again , by inductive hypothesis , @xmath1025 is a trace of @xmath1069 . because of theorem [ the - lt - sem ]",
    ", @xmath215 holds in @xmath1055 .",
    "hence , @xmath1074 is a trace of @xmath435 .",
    "* @xmath128 is a rule of the form ( [ pi1tr_if_false ] ) .",
    "similarly to the previous items , we know that there exist @xmath215 , @xmath435 , @xmath1069 , and @xmath1071 such that @xmath1088 , @xmath1053 , and @xmath1089 .",
    "this means that @xmath1090 .",
    "hence , by inductive hypothesis and theorem [ the - lt - sem ] , @xmath1074 is a trace of @xmath1071 and @xmath215 is false in @xmath1055 , which mean that @xmath1074 is a trace of `` @xmath1086 '' , i.e. , a trace of @xmath435 .",
    "* @xmath128 is a rule of the form ( [ pi1tr_while_true ] ) .",
    "this implies that there exist a formula @xmath215 , a program @xmath1069 and a time point @xmath1091 such that @xmath1092 and @xmath1084 , @xmath1093 and @xmath1094 are in @xmath802 .",
    "it follows that @xmath435 is the program `` @xmath1095 '' .",
    "furthermore , @xmath215 holds in @xmath1055 , and @xmath1068 is a trace of @xmath1069 and @xmath1070 is a trace of @xmath435 . by definition [ deftrace1 ] , this implies that @xmath1074 is a trace of @xmath435 .",
    "* @xmath128 a rule of the form is ( [ pi1tr_pick ] ) .",
    "then , @xmath435 has the form @xmath1096 .",
    "therefore , @xmath1097 is in @xmath118 for @xmath1098 .",
    "@xmath1099 implies that there exists an integer @xmath421 , @xmath1100 , such @xmath1101 . by the definition of @xmath1080 ,",
    "@xmath1102 . by inductive hypothesis",
    ", @xmath1025 is a trace of program @xmath1103 .",
    "thus , we can conclude that @xmath1025 is a trace of @xmath435 .",
    "the above cases prove the inductive step for ( * ) .",
    "the lemma follows immediately since @xmath1018 belongs to @xmath191 .    to prove the reverse of lemma [ lemtrace1 ]",
    ", we define a function @xmath1104 that maps each ground complex action @xmath435 into an integer @xmath1105 that reflects the notion of complexity of @xmath435 ( or the number of nested constructs in @xmath435 ) .",
    "@xmath1105 is defined recursively over the construction of @xmath435 as follows .",
    "* for @xmath1106 and @xmath215 is a formula , or @xmath1107 and @xmath23 is an action , @xmath1108 . * for @xmath1073 or @xmath1109 , @xmath1110 . * for @xmath1111 , @xmath1112 .",
    "* for @xmath1113 , @xmath1114 .",
    "* for @xmath1115 , @xmath1116 .",
    "* for @xmath1117 where @xmath1118 is a procedure , @xmath1119 .",
    "it is worth noting that @xmath1105 is always defined for programs considered in this paper .",
    "[ lemtrace2 ] let @xmath31 be a consistent action theory , @xmath389 be a program , and @xmath1120 be a trace of @xmath389 .",
    "then @xmath1009 has an answer set @xmath191 such that    * @xmath1121 for @xmath1122 , * @xmath1123 for every @xmath1124 , and * @xmath1125 .",
    "we prove the lemma by constructing an answer set of @xmath1009 that satisfies the conditions of the lemma .",
    "similar to the proof of lemma [ lemtrace1 ] , we split @xmath1009 using @xmath1012 .",
    "this implies that @xmath191 is an answer set of @xmath1009 iff @xmath352 where @xmath118 is an answer set of @xmath1126 and @xmath353 is an answer set of @xmath1127 , which is the program consisting of the rules ( [ pi1tr_act])-([pi1tr_null ] ) with the corresponding conditions .",
    "because @xmath194 is a trace of @xmath389 , it is a trajectory in @xmath33 . by corollary [ smodel - traject2 ] , we know that @xmath1008 has an answer set @xmath869 that satisfies the two conditions :    * @xmath1128 for @xmath1122 and * @xmath1129 for every @xmath1124 .",
    "because @xmath541 consists of only rules and atoms encoding the program @xmath389 , it is easy to see that there exists an answer set @xmath118 of @xmath1014 such that @xmath1130 .",
    "clearly , @xmath118 also satisfies the two conditions :    * @xmath1131 for @xmath1122 and * @xmath1132 for every @xmath1124 .    since @xmath1027 is a positive program we know that @xmath1027 has a unique answer set , say @xmath353 . from the splitting theorem",
    ", we have that @xmath352 is an answer set of @xmath1009 . because @xmath1019 , @xmath191 satisfies the first two conditions of the lemma .",
    "it remains to be shown that @xmath191 also satisfies the third condition of the lemma .",
    "we prove this by proving a stronger conclusion :    * if @xmath435 is a program with the name @xmath1021 and there exists two integers @xmath988 and @xmath1133 such that @xmath1134 is a trace of @xmath435 then @xmath1024 .",
    "( the states @xmath1135  see above  and the actions @xmath96 are defined as in the lemma s statement )    we prove ( * ) by induction over @xmath1105 , the complexity of the program @xmath435 .",
    "there are only two cases :    * @xmath1106 for some formula @xmath215 , and hence , by definition [ deftrace1 ] , we have that @xmath1136 .",
    "it follows from the assumption that @xmath1055 is a trace of @xmath435 that @xmath1055 satisfies @xmath215 . by theorem",
    "[ the - lt - sem ] , @xmath1137 , and hence , we have that @xmath1138 ( because of rule ( [ pi1tr_form ] ) ) . *",
    "@xmath1139 where @xmath23 is an action .",
    "again , by definition [ deftrace1 ] , we have that @xmath1140 . from the assumption that @xmath1141 is a trace of @xmath435 we have that @xmath1142 .",
    "thus , @xmath1143 . by rule ( [ pi1tr_act ] ) of @xmath1027 , we conclude that @xmath1144 , and thus , @xmath1145 .",
    "the above two cases prove the base case .",
    "assume that we have proved ( * ) for every program @xmath435 with @xmath1146 .",
    "we need to prove it for the case @xmath1147 . because @xmath1148 , we have the following cases :    * @xmath1073 . by definition [ deftrace1 ] ,",
    "there exists @xmath1149 , @xmath1150 , such that @xmath1151 is a trace of @xmath1069 and @xmath1152 is a trace of @xmath1071 . because @xmath1153 and @xmath1154 , by inductive hypothesis , we have that @xmath1155 and @xmath1156 .",
    "@xmath1073 implies @xmath1157 . by rule ( [ pi1tr_proc ] )",
    ", @xmath1058 must be in @xmath191 .",
    "* @xmath1158 .",
    "again , by definition [ deftrace1 ] , @xmath1159 is a trace of some @xmath1082 .",
    "since @xmath1160 , by inductive hypothesis , we have that @xmath1161 .",
    "because of rule ( [ pi1tr_choice ] ) , @xmath1058 is in @xmath191 .",
    "* @xmath1109 .",
    "consider two cases : * * @xmath215 holds in @xmath1162 .",
    "this implies that @xmath1134 is a trace of @xmath1069 .",
    "because of theorem [ the - lt - sem ] , @xmath1163 . since @xmath1153 , @xmath1164 by inductive hypothesis .",
    "thus , according to rule ( [ pi1tr_if_true ] ) , @xmath1058 must belong to @xmath191 . *",
    "* @xmath215 does not holds in @xmath1162 .",
    "this implies that @xmath1134 is a trace of @xmath1071 .",
    "because of theorem [ the - lt - sem ] , @xmath1165 does not hold in @xmath191 .",
    "since @xmath1153 , @xmath1166 is in @xmath191 by inductive hypothesis .",
    "thus , according to rule ( [ pi1tr_if_false ] ) , @xmath1024 . * @xmath1167 .",
    "we prove this case by induction over the length of the trace , @xmath1168 .",
    "* * * base : * @xmath1169 .",
    "this happens only when @xmath215 does not hold in @xmath1055 .",
    "as such , because of rule ( [ pi1tr_while_false ] ) , @xmath1058 is in @xmath191 .",
    "the base case is proved . * * * step : * assume that we have proved the conclusion for this case for @xmath1170 .",
    "we will show that it is also correct for @xmath1171 . since @xmath1172",
    ", we conclude that @xmath215 holds in @xmath1162 and there exists @xmath1173 such that @xmath1151 is a trace of @xmath1069 and @xmath1152 is a trace of @xmath435 .",
    "we have @xmath1174 , @xmath1175 and @xmath1176 . by inductive hypothesis , @xmath1177 and @xmath1094 are in @xmath191 . by theorem",
    "[ the - lt - sem ] , @xmath1165 is in @xmath191 and from the rule ( [ pi1tr_while_true ] ) , @xmath1058 is in @xmath191 . *",
    "so , there exists an integer @xmath421 , @xmath1100 , such that the trace of @xmath435 is a trace of @xmath1103 . since @xmath1179 , we have that @xmath1180 .",
    "this , together with the fact that @xmath1181 , and the rule ( [ pi1tr_pick ] ) imply that @xmath1058 is in @xmath191 .",
    "* @xmath1117 for some procedure @xmath1182 .",
    "this implies that @xmath1134 is a trace of @xmath1183 . since @xmath1184",
    ", we have that @xmath1185 . since @xmath1186 and @xmath1187",
    ", we have that @xmath1188 .",
    "this proves the inductive step for this case as well .",
    "the above cases prove the inductive step of ( * ) .",
    "the conclusion of the lemma follows .",
    "we now prove the theorem [ th2 ] .",
    "let @xmath31 be a consistent action theory and @xmath389 be a program .",
    "then ,    * for every answer set @xmath191 of @xmath543 with @xmath195 for @xmath98 , @xmath544 is a trace of @xmath389 ; and * if @xmath545 is a trace of @xmath389 then there exists an answer set @xmath191 of @xmath543 such that @xmath1189 and @xmath547 for @xmath548 and @xmath549 .",
    "\\(i ) follows from lemma [ lemtrace1 ] and ( ii ) follows from lemma [ lemtrace2 ] .",
    "let @xmath389 now be a general program . to prove theorem [ th3 ]",
    ", we will extend the lemmas [ lemtrace1]-[lemtrace2 ] to account for general programs . similarly to the proofs of lemmas [ lemtrace1]-[lemtrace2 ] , we will split @xmath666 by the set @xmath1012 . thus @xmath191 is an answer set of @xmath666 iff @xmath352 where @xmath118 is an answer set of @xmath1014 and @xmath353 is an answer set of the program @xmath1190 , denoted by @xmath1191 , which consists of the rules of program @xmath1027 ( with the difference that a program is now a general program ) and the following rules : @xmath1192 we will continue to use the complexity of program defined in the last appendix and extend it to allow the htn - construct by adding the following to the definition of @xmath1105 .    * for @xmath1193 , @xmath1194 .",
    "notice that every literal of the program @xmath1191 has the first parameter as a program .",
    "hence , we can associate @xmath1105 to each literal @xmath139 of @xmath1191 where @xmath435 is the first parameter of @xmath139 .",
    "for instance , @xmath1195 or @xmath1196 etc .. since we will continue to use splitting theorem in our proofs , the following observation is useful .",
    "[ obs2 ] the two cardinality constraint rules ( [ pi1thtn2])-([pi1thtn3 ] ) can be replaced by the following normal logic program rules : @xmath1197 that is , let @xmath1198 be the program obtained from @xmath1191 by replacing the rules ( [ pi1thtn2])-([pi1thtn3 ] ) with the above set of rules .",
    "then , @xmath191 is an answer set of @xmath1191 iff @xmath1199 is an answer set of @xmath1198 .",
    "the next lemma generalizes lemma [ lemtrace1 ] .",
    "[ lemtrace3 ] let @xmath435 be a general program , @xmath353 be an answer set of the program @xmath1200 ( i.e. program @xmath1191 ) , and @xmath1022 be two time points such that @xmath1023  and @xmath1099 .",
    "then , @xmath1074 is a trace of @xmath435 where @xmath352 .",
    "let @xmath1201 .    from observation [ obs2 ] , we know that we can use the splitting theorem on @xmath1191 .",
    "it is easy to see that @xmath1202 is a splitting sequence of @xmath1191 . from the finiteness of @xmath1191 and the splitting sequence theorem",
    ", we have that @xmath1203 where    1 .",
    "@xmath1204 is an answer set of the program @xmath1205 and 2 .   for every integer @xmath466 ,",
    "@xmath1206 is an answer set for @xmath1207 .",
    "we prove the lemma by induction over @xmath1105 .    @xmath1108 . from @xmath1099",
    ", we have that @xmath1208 .",
    "it is easy to see that @xmath1205 consists of all the rules of @xmath1191 whose program has level @xmath159 .",
    "it follows from lemma [ lemtrace1 ] @xmath1074 is a trace of @xmath435 .",
    "the base case is proved .",
    "assume that we have proved the lemma for @xmath1209 .",
    "we prove it for @xmath1210 .",
    "from the fact that @xmath1024 and @xmath1211 we have that @xmath1212 where @xmath1213 is an answer set of the program @xmath1214 which consists of rules of the form ( [ pi1thtn1])-([pi1thtn10 ] ) and ( [ pi1tr_proc])-([pi1tr_pick ] ) whose program has the level @xmath1215 , i.e. , @xmath1210 . because @xmath1099 we know that there exists a rule that supports @xmath1058 .",
    "let @xmath128 be such a rule .",
    "there are following cases :    * @xmath128 is a rule of the form ( [ pi1tr_proc])-([pi1tr_pick ] ) , the argument is similar to the argument using in the inductive step for the corresponding case in lemma [ lemtrace1 ] . notice a minor difference though : in lemma [ lemtrace1 ] , we do not need to use @xmath1105 .",
    "* @xmath128 is a rule of the form ( [ pi1thtn1 ] ) , which implies that @xmath1193 where @xmath122 is a set of programs and @xmath566 is a set of constraints @xmath566 . by definition of answer sets ,",
    "we know that @xmath1216 .",
    "furthermore , because of the rules ( [ pi1thtn2 ] ) and ( [ pi1thtn3 ] ) , the fact that @xmath1212 and the definition of weight constraint rule , we conclude that for each @xmath1217 there exists two numbers @xmath1218 and @xmath1219 , @xmath1220 such that @xmath1221 and @xmath1222 .",
    "because of rule ( [ pi1thtn5 ] ) , we conclude that @xmath1223 .",
    "otherwise , we have that @xmath1224 , and hence , @xmath1225 , which is a contradiction . by definition of @xmath1105",
    ", we have that @xmath1160 .",
    "thus , by inductive hypothesis , we can conclude that : for every @xmath1217 , there exists two numbers @xmath1218 and @xmath1219 , @xmath1226 , @xmath1227 is a trace of @xmath1082 .",
    "+ furthermore , rules ( [ pi1thtn11])-([pi1thtn15 ] ) imply that the set @xmath1228 creates a permutation of @xmath1229 that satisfies the first condition of definition [ deftrace2 ] .",
    "+ consider now an ordering @xmath1230 in @xmath566 .",
    "this implies that the body of rule ( [ pi1thtn7 ] ) will be satisfied if @xmath1231 which would lead to @xmath1232 .",
    "again , this is a contradiction .",
    "hence , we must have @xmath1233 that means that the permutation @xmath1234 also satisfies the second condition of definition [ deftrace2 ] . + similarly , using ( [ pi1thtn8])-([pi1thtn10 ] ) we can prove that the permutation @xmath1228 also satisfies the third and fourth conditions of definition [ deftrace2 ] . +",
    "it follows from the above arguments that @xmath1235 is a trace of @xmath1236 .",
    "the inductive step is proved for this case .",
    "the above cases prove the inductive step .",
    "this concludes the lemma .    in the next lemma",
    ", we generalize the lemma [ lemtrace2 ] .",
    "[ lemtrace4 ] let @xmath31 be a consistent action theory , @xmath389 be a general program , and @xmath1237 be a trace of @xmath389 .",
    "then , there is an answer set @xmath191 of @xmath666 such that @xmath1135 and @xmath195 and @xmath1125 .",
    "based on our discussion on splitting @xmath666 using @xmath1238 and the fact that @xmath1239 is also a trace in @xmath33 , we know that there exists an answer set @xmath118 of @xmath1240 such that @xmath1241 and @xmath1242 . thus , it remains to be shown that there exists an answer set @xmath353 of @xmath1191 such that @xmath1243 .",
    "similar to the proof of lemma [ lemtrace3 ] , we use @xmath1202 as a splitting sequence of @xmath1191 where @xmath1244 . from the splitting sequence theorem",
    ", we have that @xmath1245 where    1 .",
    "@xmath1204 is an answer set of the program @xmath1205 and 2 .   for every integer @xmath466",
    ", @xmath1206 is an answer set for @xmath1246 .",
    "we prove the lemma by induction over @xmath1105 .",
    "similar to lemma [ lemtrace2 ] , we prove this by proving a stronger conclusion :    * there exists an answer set @xmath1245 of @xmath1191 such that for every program @xmath1247 occurring in @xmath389 , @xmath1248 is a trace of @xmath435 iff @xmath1249 .",
    "( the states @xmath95 and the actions @xmath96 are defined as in the lemma s statement )    we will prove ( * ) by induction over @xmath1105 .    @xmath1108 .",
    "similar to the base case in lemma [ lemtrace2 ] .",
    "assume that we have proved ( * ) for @xmath1146 .",
    "we need to prove ( * ) for @xmath1210 .",
    "we will construct an answer set of @xmath1250 such that for every program @xmath435 occurring in @xmath389 with @xmath1210 , if @xmath1251 is a trace of @xmath435 then @xmath1212 .",
    "let @xmath1213 be the set of atoms defined as follows .",
    "* for every program @xmath435 with @xmath1210 , if @xmath435 is not of the form @xmath610 and @xmath1248 is a trace of @xmath435 , @xmath1213 contains @xmath1058 . * for every program @xmath435 with @xmath1210 , @xmath1193 , and @xmath1248 is a trace of @xmath435 . by definition , there exists a permutation @xmath1252 of @xmath1229 satisfying the conditions ( a)-(d ) of item 8 ( definition [ deftrace2 ] ) .",
    "consider such a permutation .",
    "to simplify the notation , let us denote the begin- and end - time of a program @xmath1217 in the trace of @xmath435 by @xmath138 and @xmath1253 , respectively , i.e. , @xmath1254 is a trace of @xmath1082 .",
    "then , @xmath1213 contains @xmath1058 and the following atoms : 1 .",
    "@xmath1255 for every @xmath1217 , 2 .",
    "@xmath1256 for every @xmath1217 , and 3 .",
    "@xmath1257 for for every @xmath1217 and @xmath1258 .",
    "* @xmath1213 does not contain any other atoms except those mentioned above .",
    "it is easy to see that @xmath1213 satisfies ( * ) for every program @xmath435 with @xmath1210 .",
    "thus , we need to show that @xmath1213 is indeed an answer set of @xmath1259 .",
    "first , we prove that @xmath1213 is closed under @xmath1260 .",
    "we consider the following cases :    * @xmath128 is a rule of the form ( [ pi1tr_proc ] ) .",
    "obviously , if @xmath128 belongs to @xmath1260 , then @xmath1073 and there exists a @xmath1261 such that @xmath1093 and @xmath1065 belong to @xmath1262 because @xmath1153 and @xmath1154 . by inductive hypothesis",
    ", @xmath1263 is a trace of @xmath1069 and @xmath1264 is a trace of @xmath1071 . by definition [ deftrace1 ]",
    ", @xmath1265 is a trace of @xmath435 . by construction of @xmath1213",
    "we have that @xmath1212 .",
    "this shows that @xmath1213 is closed under @xmath128 .",
    "similar arguments conclude that @xmath1213 is closed under the rule of the form ( [ pi1tr_choice])-([pi1tr_pick ] ) .",
    "* @xmath128 is a rule of the form ( [ pi1thtn1 ] ) of @xmath1260 .",
    "then , @xmath1193 and by construction of @xmath1213 , if @xmath1265 is a trace of @xmath435 then we have @xmath1212 . thus .",
    "@xmath1213 is closed under the rules of the form ( [ pi1thtn1 ] ) too .",
    "* @xmath128 is a rule of the form ( [ pi1thtn2 ] ) and ( [ pi1thtn3 ] ) .",
    "@xmath1213 is also closed under @xmath128 because whenever @xmath1212 , we now that there is a trace @xmath1265 of @xmath435 , and hence , by definition [ deftrace2 ] , we conclude the existence of the begin- and end - time points @xmath138 and @xmath1253 of @xmath1082 , respectively . by construction of @xmath1213",
    ", we have that @xmath1266 and @xmath1267 belong to @xmath1213 and for each @xmath1082 , there is a unique atom of this form in @xmath1213 .",
    "hence , @xmath1213 is closed under rules of the form ( [ pi1thtn2 ] ) and ( [ pi1thtn3 ] ) .",
    "* @xmath128 is a rule of the form ( [ pi1thtn12])-([pi1thtn10 ] ) .",
    "the construction of @xmath1213 ensures that the body of @xmath128 is not satisfied by @xmath1213 , and hence , @xmath1213 is closed under @xmath128 .",
    "* @xmath128 is a rule of the form ( [ pi1thtn11 ] ) . because @xmath1257 belongs to @xmath1213 for every @xmath250 , @xmath1268 .",
    "we have that @xmath1213 is closed under @xmath128 too .",
    "the conclusion that @xmath1213 is closed under @xmath1260 follows from the above cases .    to complete the proof",
    ", we need to show that @xmath1213 is minimal . assume the contrary , there exists a proper subset @xmath1269 of @xmath1213 such that @xmath1269 is closed under @xmath1260 .",
    "let @xmath1270 .",
    "since @xmath1271 , we have the following cases :    * @xmath63 is the head of a rule of the form ( [ pi1tr_proc])-([pi1tr_pick ] ) . by definition of @xmath1259",
    ", we know that a rule of this form belongs to @xmath1259 iff its body is empty .",
    "thus , from the closeness of @xmath1269 we have that @xmath1272 .",
    "this contradicts the fact that @xmath1273 .",
    "* @xmath63 is the head of a rule of the form ( [ pi1thtn1 ] ) .",
    "similar to the above case , we can conclude that @xmath1272 which again contradicts the fact that @xmath1273 .",
    "* @xmath63 is the head of a rule @xmath128 of the form ( [ pi1thtn2 ] ) . because of @xmath1271",
    "we conclude that @xmath1274 .",
    "the above case concludes that @xmath1275 . since the body of @xmath128 is true ,",
    "we conclude that there exists some @xmath1217 such that @xmath1269 does not contain an atom of the form @xmath1266 .",
    "thus , @xmath1269 is not closed under @xmath128 .",
    "this contradicts the assumption that @xmath1269 is closed under @xmath1260 .",
    "* @xmath63 is the head of a rule @xmath128 of the form ( [ pi1thtn3 ] ) .",
    "similar to the above case , we can prove that it violates the assumption that @xmath1269 is closed under @xmath1260 .",
    "* @xmath63 is the head of a rule @xmath128 of the form ( [ pi1thtn11 ] ) . because @xmath1271 we know that the body of @xmath128 is satisfied by @xmath1213 , and hence , @xmath128 belongs to @xmath1260",
    "again , because of the closeness of @xmath1269 , we conclude that @xmath1272 which violates the assumption that @xmath1273 .",
    "the above cases imply that @xmath1269 is not closed under @xmath1260 .",
    "thus , our assumption that @xmath1213 is not minimal is incorrect . together with the closeness of @xmath1213",
    ", we have that @xmath1213 is indeed an answer set of @xmath1259 .",
    "the inductive step is proved since @xmath1213 satisfies ( * ) for every program @xmath435 with @xmath1210 .",
    "this proves the lemma .",
    "let @xmath31 be a consistent action theory and @xmath389 be a general program . then ,    * for every answer set @xmath191 of @xmath668 with @xmath195 for @xmath98 , @xmath544 is a trace of @xmath389 ; and * if @xmath545 is a trace of @xmath389 then there exists an answer set @xmath191 of @xmath668 such that @xmath546 and @xmath547 for @xmath548 and @xmath549 and @xmath669 .",
    "\\(i ) follows from lemma [ lemtrace3 ] and ( ii ) follows from lemma [ lemtrace4 ] .",
    "in this appendix , we review the basics of the splitting theorem @xcite . because programs in this paper do not contain classical negations , some of the definitions have been modified from the original presentation in @xcite .",
    "let @xmath128 be a rule@xmath1276 by @xmath1277 , @xmath1278 , and @xmath1279 we denote @xmath863 , @xmath1280 , and @xmath1281 , respectively .",
    "@xmath1282 and @xmath1283 denote the set @xmath1284 and @xmath1285 , respectively .        given a splitting set @xmath155 for @xmath110 , and a set @xmath118 of atoms from @xmath1290 , the _ partial evaluation of @xmath110 by x with respect to a _ , denoted by @xmath1291 , is the program obtained from @xmath110 as follows . for each rule",
    "@xmath1292 such that                [ splitting set theorem , @xcite ] [ spl1 ] let @xmath155 be a splitting set for a program @xmath110 .",
    "a set @xmath122 of atoms is a consistent answer set of @xmath110 iff @xmath1301 for some solution @xmath1299 to @xmath110 with respect to @xmath155 .",
    "a _ sequence _ is a family whose index set is an initial segment of ordinals @xmath1302 .",
    "a sequence @xmath1303 of sets is _",
    "monotone _ if @xmath1304 whenever @xmath1305 , and _ continuous _ if , for each limit ordinal @xmath1306 , @xmath1307 .",
    "[ splitting sequence theorem , @xcite ] [ spl2 ] let @xmath1317 be a splitting sequence of the program @xmath110 .",
    "a set of atoms @xmath638 is an answer set of @xmath110 iff @xmath1318 for some solution @xmath1319 to @xmath110 with respect to @xmath155 .",
    "let @xmath1320 be a program with constrains where @xmath1321 is a set of rules of the form ( [ lprule1 ] ) and @xmath1322 is a set of rules of the form ( [ lprule2 ] ) .",
    "for a splitting set @xmath155 of @xmath110 , we define @xmath1323 where @xmath1324 .    we can prove that theorems [ spl1]-[spl2 ] hold for programs with constraints .",
    "for example , if @xmath155 is a splitting of the program @xmath110 , then @xmath122 is an answer set of @xmath110 iff @xmath1325 where @xmath118 is an answer set of @xmath1289 and @xmath353 is an answer set of @xmath1326 .",
    "the proof of the modified theorems is based on two observations : ( i ) a set @xmath155 of atoms from @xmath1327 is a splitting set of @xmath110 iff it is a splitting set of @xmath1321 ( because @xmath1328 ) ; and ( ii ) a set of atoms @xmath122 is an answer set of @xmath110 iff @xmath122 is answer set of @xmath1321 and @xmath122 satisfies the rules of @xmath1322 ."
  ],
  "abstract_text": [
    "<S> in this paper we consider three different kinds of domain - dependent control knowledge ( temporal , procedural and htn - based ) that are useful in planning . </S>",
    "<S> our approach is declarative and relies on the language of logic programming with answer set semantics ( ansprolog * ) . </S>",
    "<S> ansprolog * is designed to plan without control knowledge . </S>",
    "<S> we show how temporal , procedural and htn - based control knowledge can be incorporated into ansprolog * by the modular addition of a small number of domain - dependent rules , without the need to modify the planner . </S>",
    "<S> we formally prove the correctness of our planner , both in the absence and presence of the control knowledge . </S>",
    "<S> finally , we perform some initial experimentation that demonstrates the potential reduction in planning time that can be achieved when procedural domain knowledge is used to solve planning problems with large plan length .    </S>",
    "<S> author s address : t.  c.  son , computer science department , po box 30001 , msc cs , new mexico state university , las cruces , nm 88003 , usa . c.  baral and n.  tran , computer science and engineering , arizona state university , tempe , az 85287 , usa . </S>",
    "<S> s.  mcilraith , department of computer science , university of toronto , toronto , canada m5s 5h3 </S>",
    "<S> .    [ plan generation ]    [ logic programming ]    [ representation languages ] </S>"
  ]
}