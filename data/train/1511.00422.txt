{
  "article_text": [
    "consider a network of finite - state automata , each with a finite input and output alphabet .",
    "what can such a network reliably compute if the wires connecting its components are subject to unpredictable delays ?",
    "the networks we will consider have a finite set of @xmath2 input wires and @xmath3 output wires . even these are subject to delays , so the network computes a function @xmath4 : the input is a @xmath2-tuple of natural numbers ( @xmath5 ) indicating how many letters are fed along each input wire , and the output is an @xmath3-tuple indicating how many letters are emitted along each output wire .",
    "the essential issue such a network must overcome is that the order in which input letters arrive at a node must not affect the output . to address this issue , bond and levine @xcite , following dhar @xcite , proposed the class of _ abelian networks_. these are networks",
    "each of whose components is a special type of finite automaton called an _",
    "abelian processor_. certain abelian networks such as sandpile @xcite and rotor @xcite networks produce intricate fractal outputs from a simple input . from the point of view of computational complexity , predicting the final state of a sandpile on a simple undirected graph can be done in polynomial time @xcite , and in fact this problem is @xmath6-complete @xcite .",
    "computing the sum of two elements in the sandpile group is also @xmath6-complete @xcite .",
    "but on finite directed multigraphs , deciding whether a sandpile will halt is already @xmath7-complete @xcite .",
    "analogous problems on infinite graphs are undecidable : an abelian network whose underlying graph is @xmath8 , or a sandpile network whose underlying graph is the product of @xmath8 with a finite path , can emulate a turing machine @xcite .",
    "the following definition is equivalent to that in @xcite but simpler to check . a processor with input alphabet @xmath9 , output alphabet @xmath10 and state space @xmath11 is a collection of transition maps and output maps @xmath12 indexed by @xmath13 .",
    "the processor is abelian if @xmath14 for all @xmath15 .",
    "the interpretation is that if the processor receives input letter @xmath16 while in state @xmath17 , then it transitions to state @xmath18 and outputs @xmath19 .",
    "the first equation in above asserts that the processor moves to the same state after receiving two letters , regardless of their order .",
    "the second guarantees that it produces the same output .",
    "the processor is called finite if both the alphabets @xmath9 , @xmath10 and the state space @xmath11 are finite . in this paper ,",
    "all abelian processors are assumed to be finite and to come with a distinguished starting state @xmath20 that can access all states : each @xmath21 can be obtained by a composition of a finite sequence of transition maps @xmath22 applied to @xmath20 .",
    "we say that an abelian processor computes the function @xmath23 if inputting @xmath24 letters @xmath25 for each @xmath26 results in the output of @xmath27 letters @xmath28 for each @xmath29 .",
    "our convention that the various inputs and outputs are represented by different letters is useful for notational purposes .",
    "an alternative viewpoint would be to regard all inputs and outputs as consisting of indistinguishable `` particles '' , whose roles are determined by which input or output wire they pass along .",
    "an abelian network is a directed graph with an abelian processor located at each node , with outputs feeding into inputs according to the graph structure , and some inputs and outputs designated as input and output wires for the entire network .",
    "( we give a more formal definition below in [ s.network ] . )",
    "an abelian network can compute a function as follows .",
    "we start by feeding some number of letters along each input wire .",
    "then , at each step , we choose any processor that has at least one letter waiting at one of its inputs , and process that letter , resulting in a new state of that processor , and perhaps some letters emitted from its outputs .",
    "if after finitely many steps all remaining letters are located on the output wires of the network , then we say that the computation halts .",
    "the following is a central result of @xcite , generalizing the `` abelian property '' of dhar  @xcite and diaconis and fulton ( * ? ? ?",
    "* theorem  4.1 ) ( see @xcite for further background ) . provided the computation halts , it does so regardless of the choice of processing order .",
    "moreover , the letters on the output wires and the final states of the processors are also independent of the processing order .",
    "thus , a network that halts on all inputs computes a function from @xmath0 to @xmath1 ( where @xmath2 and @xmath3 are the numbers of input and output wires respectively ) .",
    "this function is itself of a form that can be computed by some abelian processor , and we say that the network emulates this processor",
    ".    the main goal of this paper is to prove a result in the opposite direction .",
    "just as any boolean function @xmath30 can be computed by a circuit of and , or and not gates , we show that any function @xmath31 computed by an abelian processor can be computed by a network of simple _ abelian logic gates_. furthermore ( as in the boolean case ) , the network can be made directed acyclic , which is to say that the graph has no directed cycles .",
    "we will define our gates immediately after stating the main theorems .",
    "[ t.eventually.intro ] any finite abelian processor can be emulated by a finite , directed acyclic network of , , , and .",
    "if the processor satisfies certain additional conditions , then some gates are not needed .",
    "an abelian processor is called bounded if the range of the function that it computes is a finite subset of @xmath32 .",
    "[ t.bounded.intro ] any bounded finite abelian processor can be emulated by a finite , directed acyclic network of , , and .",
    "an abelian processor @xmath33 is called recurrent if for every pair of states @xmath34 there is a finite sequence of input letters that causes it to transition from @xmath17 to @xmath35 .",
    "an abelian processor that is not recurrent is called transient .",
    "[ t.recurrent.intro ] any recurrent finite abelian processor can be emulated by a finite , directed acyclic network of , and .",
    "& & @xmath36 + & & @xmath37 +   +  @xmath38 ) & & @xmath39 + primed  ( @xmath40 ) & & @xmath41 +   + & & @xmath42 + & & @xmath43 +    table  [ fig : gates ] lists our abelian logic gates , along with the symbols we will use when illustrating networks .",
    "a splitter has one incoming edge , two outgoing edges , and a single internal state .",
    "when it receives a letter , it sends one letter along each outgoing edge . on the other hand ,",
    "an adder has two incoming edges , one outgoing edge , and again a single internal state . for each letter received on either input ,",
    "it emits one letter .",
    "the rest of our gates each have just one input and one output .    for integer @xmath44 ,",
    "a @xmath45-toppler has internal states @xmath46 . if it receives a letter while in state @xmath47 , it transitions to state @xmath48 and sends nothing . if it receives a letter while in state @xmath49 , it  topples \" : it transitions to state @xmath50 and emits one letter . a @xmath45-toppler that begins in state",
    "@xmath50 computes the function @xmath51 ; if begun in state @xmath52 it computes the function @xmath53 .",
    "a toppler is called unprimed if its initial state is @xmath50 , and primed otherwise .",
    "the above gates are all recurrent . finally , we have two transient gates whose behaviors are complementary to one another .",
    "a delayer has two internal states @xmath54 .",
    "if it receives an input letter while in state @xmath50 , it moves permanently to state @xmath55 , emitting nothing . in state @xmath55 it sends out one letter for every letter it receives",
    "thus , begun it state @xmath50 , it computes the function @xmath56 .",
    "a presink has two internal states @xmath54 .",
    "if it receives a letter while in state @xmath50 , it transitions permanently to state @xmath55 and emits one letter .",
    "all subsequent inputs are ignored . from initial state",
    "@xmath50 it computes @xmath57 $ ] .",
    "the topplers form an infinite family indexed by the parameter @xmath44 .",
    "if we allow our network to have feedback ( i.e. , drop the requirement that it be directed acyclic ) then we need only the case @xmath58 , and in particular our palette of gates is reduced to a finite set .",
    "feedback also allows us to eliminate one further gate , the delayer .",
    "[ p.feedback ] for any @xmath59 , a @xmath45-can be emulated by a finite abelian network of , and @xmath60- .",
    "so can a .",
    "the toppler is a very close relative of the two most extensively studied abeilan processors : the sandpile node and the rotor router node ( see e.g.  @xcite ) .",
    "specifically , for a node of degree @xmath2 , either of these is easily emulated by @xmath2 suitably primed topplers in parallel , as in [ f - rotor ] .",
    "( sandpiles and rotors are typically considered on undirected graphs , in which case the @xmath2 inputs and @xmath2 outputs of a vertex are both routed along its @xmath2 incident edges ) .",
    "rotor aggregation @xcite can also be emulated , by inserting a delayer into the network for the rotor .",
    "( a ) ; ( s ) ; ( t2)@xmath61 ; ( t1)@xmath61 ; ( t3)@xmath61 ; ( a)++(-1,0 ) ; ( a)++(-1,-1 ) ; ( a)++(-1,1 ) ; ( a)(s ) ; ( s ) edge[bend left=20](t1.west ) ; ( s ) edge(t2 ) ; ( s ) edge[bend right=20](t3.west ) ; ( t1)++(1,0 ) ; ( t2)++(1,0 ) ; ( t3)++(1,0 ) ;      a processor has unary input if its input alphabet @xmath9 has size @xmath55 ( so that it computes a function @xmath62 ) .",
    "it is easy to see from the definition that _ any _ finite - state processor with unary input is automatically abelian .",
    "indeed , the same holds for any processor with _",
    "exchangeable _ inputs , i.e.  one whose transition maps and output maps are identical for each input letter .",
    "( such a processor can be emulated by adding all its inputs and feeding them into a unary - input processor ) .",
    "note that all our gates have unary input except for the adder , which has exchangeable inputs .",
    "theorems  [ t.eventually.intro][t.recurrent.intro ] become rather straightforward if we restrict to unary - input processors .",
    "( see lemmas  [ unary - recurrent ] and [ unary - trans ] . )",
    "our main contribution is that unary - input gates ( and adders ) suffice to emulate processors with any number of inputs .",
    "( in contrast , elementary considerations will show that there is no loss of generality in restricting to processors with unary _ output _ ; see lemma  [ l.unaryoutput ] . )      .",
    "the height of a bar gives the value of the function , and the origin is at the front of the picture .",
    "the periodic component has periods @xmath63 and @xmath64 in the two coordinates , as indicated by the highlighted bars ; the linear part has slopes @xmath65 and @xmath66 respectively .",
    "_ right : _ a zilep function comprising the same  recurrent part \" together with added ",
    "transient margins\".,title=\"fig : \" ] .",
    "the height of a bar gives the value of the function , and the origin is at the front of the picture .",
    "the periodic component has periods @xmath63 and @xmath64 in the two coordinates , as indicated by the highlighted bars ; the linear part has slopes @xmath65 and @xmath66 respectively .",
    "_ right : _ a zilep function comprising the same  recurrent part \" together with added  transient margins\".,title=\"fig : \" ]    an important preliminary step in the proofs of [ t.eventually.intro,t.bounded.intro,t.recurrent.intro ] will be to characterize the functions that can be computed by abelian processors ( as well as by the bounded and recurrent varieties ) .",
    "the characterizations turn out to be quite simple .",
    "a function @xmath67 is computed by some finite abelian processor if and only if : ( i ) it maps the zero vector @xmath68 to @xmath69 ; ( ii ) it is ( weakly ) increasing ; and ( iii ) it can be expressed as a linear function plus an _ eventually periodic _ function ( see [ ep - def ] for precise meanings ) .",
    "we call a function satisfying ( i)(iii ) zilep ( zero at zero , increasing , linear plus eventually periodic ) .",
    "on the other hand , a function is computed by some _ recurrent _ finite abelian processor if it is zilp : _ eventually periodic _ is replaced with _",
    "periodic_. [ bar - graph ] shows examples of zilp and zilep functions of two variables , illustrating some of the difficulties to be overcome in computing them by networks .",
    "our main theorems may be recast in terms of functions rather than processors .",
    "table  [ table.summary ] summarizes our main results from this perspective .",
    "( a function is @xmath70-linear if it is linear and takes values in @xmath1 for some @xmath3 ; @xmath71-linear is defined similarly ) . for instance , the following is a straightforward consequence of [ t.recurrent.intro ] .",
    "[ t.functions ] _ ( recurrent abelian functions ) _ let @xmath72 be the smallest set of functions @xmath73 containing the constant function @xmath55 and the coordinate functions @xmath74 , and closed under addition and compositions of the form @xmath75 for integer @xmath44 . then @xmath72 is the set of all increasing functions @xmath76 expressable as @xmath77 where @xmath78 with @xmath79 linear and @xmath80 periodic .",
    ".four different classes of abelian network .",
    "the second column indicates the class of increasing functions @xmath4 computable by a finite , directed acyclic abelian network whose components are splitters , adders and the gates listed in the first column . [",
    "cols=\"^,^,^,^,^\",options=\"header \" , ]",
    "we thank ben bond , sergey fomin and jeffrey lagarias for inspiring conversations , and swee hong chan for carefully reading an early draft .",
    "alexander e. holroyd , lionel levine , karola mszros , yuval peres , james propp and david b. wilson , chip - firing and rotor - routing on directed graphs , in _ in and out of equilibrium 2 _ , pages 331364 , progress in probability * 60 * , birkhuser , 2008 .",
    "http://arxiv.org/abs/0801.3306[arxiv:0801.3306 ]    alexander e. holroyd and james g. propp ,",
    "rotor walks and markov chains , in _ algorithmic probability and combinatorics _ , american mathematical society , 2010 ."
  ],
  "abstract_text": [
    "<S> an abelian processor is an automaton whose output is independent of the order of its inputs . </S>",
    "<S> bond and levine have proved that a network of abelian processors performs the same computation regardless of processing order ( subject only to a halting condition ) . </S>",
    "<S> we prove that any finite abelian processor can be emulated by a network of certain very simple abelian processors , which we call gates . </S>",
    "<S> the most fundamental gate is a _ </S>",
    "<S> toppler _ , which absorbs input particles until their number exceeds some given threshold , at which point it topples , emitting one particle and returning to its initial state . with the exception of an _ adder _ gate , </S>",
    "<S> which simply combines two streams of particles , each of our gates has only one input wire . </S>",
    "<S> our results can be reformulated in terms of the functions computed by processors , and one consequence is that any increasing function from @xmath0 to @xmath1 that is the sum of a linear function and a periodic function can be expressed in terms of floors of quotients by integers , and addition . </S>"
  ]
}