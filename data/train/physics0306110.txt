{
  "article_text": [
    "the parallel root facility , proof , is an extension of the well known root system ( http://root.cern.ch/ )  @xcite that allows the easy and transparent analysis of large sets of root files in parallel on remote computer clusters .",
    "the main design goals for the proof system are transparency , scalability and adaptability . with transparency",
    "we mean that there should be as little difference as possible between a local root based analysis session and a remote parallel proof session , both being interactive and giving the same results .",
    "with scalability we mean that the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel . and",
    "with adaptability we mean that the system should be able to adapt itself to variations in the remote environment ( changing load on the cluster nodes , network interruptions , etc . ) .    being an extension of the root system , proof is designed to work on objects in root data stores",
    ". these objects can be individually _ keyed _ objects as well as ttree based object collections . by logically grouping many root files into a single object",
    "very large data sets can be created . in a local cluster environment",
    "these data files can be distributed over the disks of the cluster nodes or made available via a nas or san solution .    in the near future , by employing grid technologies , we plan to extend proof from single clusters to virtual global clusters .",
    "in such an environment the processing may take longer ( not interactive ) , but the user will still be presented with a single result , like the processing was done locally .    the proof development is a joint effort between cern and mit .",
    "proof consists of a 3-tier architecture , the root client session , the proof master server and the proof slave servers .",
    "the user connects from his root session to a master server on a remote cluster and the master server in turn creates slave servers on all the nodes in the cluster .",
    "queries are processed in parallel by all the slave servers . using a pull protocol",
    "the slave servers ask the master for work packets , which allows the master to distribute customized packets for each slave server .",
    "slower slaves get smaller work packets than faster ones and faster ones process more packets . in this scheme",
    "the parallel processing performance is a function of the duration of each small job , packet , and the networking bandwidth and latency . since the bandwidth and latency of a networked cluster",
    "are fixed the main tunable parameter in this scheme is the packet size .",
    "if the packet size is chosen too small the parallelism will suffer due to the communication overhead caused by the many packets sent over the network between the master and the slave servers .",
    "if the packet size is too large the effect of the difference in performance of each node is not evened out sufficiently .",
    "this allows the proof system to adapt itself to the performance and load on each individual cluster node and to optimize the job execution time .",
    "the tselector framework plays a central role in the proof system .",
    "it allows users to write their analysis code in a way that enables them to process small data samples locally on a workstation and using the same code to process large data sets in parallel on a cluster or the grid using proof .    ....",
    "class tselector {      tlist       * finput ;      tlist       * foutput ;      tobject     * fobject ;        void         init(ttree * tree ) ;      void         begin(ttree * tree ) ;      const char * getoption ( ) const ;      bool_t       process(int_t entry ) ;      void         terminate ( ) ;    } ; ....    to use the framework a user derives a class from tselector and implements the member functions that are part of the protocol .",
    "the framework also specifies how input objects are made available to the selector object and how output objects are returned to the user or client session .",
    "the ttree::makeselector ( ) function generates a skeleton version of a tselector derived class that should be used as the basis for the analysis code .",
    "the user can either edit the generated files directly or create a class that inherits from the generated class .",
    "the second option makes sense if the definition of the tree is expected to change .",
    "it allows for the class to be easily regenerated without modifying the user class .",
    "table  [ selector_api ] lists the most important functions and members which we will describe in some more detail .",
    "the input objects are made available to the selector in the list pointed to by finput .",
    "the list is available throughout the life of the selector .",
    "the objects in the list are owned by the system .",
    "each of the slaves has a full copy of the list .",
    "the begin ( ) function is called before any object or event is processed .",
    "it is a good place to create things like histograms and initialize data that is needed to process each event .",
    "the begin ( ) function is called once in each slave .",
    "the init ( ) function is called each time a new file is opened by the system .",
    "the generated code takes care of setting up the branches in case of a tree analysis .",
    "the user can extend this routine for example to read a calibration object that pertains to the objects or tree in that file .",
    "the process ( ) function is called for each object or event in the tree . when processing a tree it is up to the user to decided which branches should be read and when .",
    "generally it is most efficient to read branches as they are used .",
    "e.g. read the branch(es ) that are used to make the selection and only if the event is to be processed read the rest of the branches that are needed . when processing _ keyed _ objects the pointer to the object is stored in the fobject member .    the terminate ( ) function",
    "is called after all objects or events have been processed .",
    "it allows the user to do a cleanup , like deleting temporary objects and closing auxiliary files .",
    "it is also the place to do final calculations .",
    "the terminate ( ) function is called once in each slave .",
    "finally the contents of the foutput lists of all the slaves are merged in the master and send back to the client .",
    "the merging uses the special merge(tlist * ) api .",
    "the objects are fist grouped by name . using the introspection features provided by cint  @xcite , the c++ interpreter used by root , it is then determined if the merge ( ) function is implemented for those objects . for histograms",
    "this is available by default .",
    "user classes can implement the api if merging makes sense .",
    "if the merge function is not available the individual objects are returned to the client .",
    "the tdset class is used to specify the collection of objects or trees that are to be processed with proof .",
    "when analyzing trees the user must pass `` ttree '' to the tdset constructor .",
    "the tdset::add ( ) function is then used to add a file , directory within that file and tree name to the set .    to process a collection of objects",
    ", the user must pass the name of the class of the objects to the constructor . in that case tdset::add",
    "( ) is used to add files and the directories within them that contain the objects .",
    "the contents of one tdset can also be added to another tdset .",
    "the tdset implements the print ( ) function which allows the contents to be inspected .",
    "users can create tdsets `` by hand '' but it is also foreseen that ( grid ) catalogs will provide query interfaces that return tdsets .",
    "it will be possible to use logical filenames rather then physical filenames to specify files .",
    "the translation will be done using the api defined by the abstract class tgrid in combination with plugins implementing the communication with available catalogs .      in complex analysis environments the analysis scripts",
    "very likely depend on one or more external libraries containing common algorithms . to be able to run these scripts successfully on proof",
    "it is required that these external libraries are available on each slave node .",
    "the proof package manager has been designed to distribute and install these libraries on a proof cluster .",
    "packages are compressed _ tar _",
    "files containing the library source or binaries with one additional proof - inf directory ( like java jar files ) .",
    "this proof - inf directory contains a setup.c script and , optionally , a build.sh shell script .",
    "the build.sh script is used to compile the library source on the proof cluster , which might have a different type of cpu or os than the user s local system .",
    "the setup.c script is used to load the libraries into the proof server processes .",
    "package files are called par ( proof archive ) files and must have a .par extension .    for example",
    "an event.par file which provides a library called libevent.so has the following build.sh :    ....    make libevent.so ....    and setup.c :    ....    int_t setup ( )    {      gsystem->load(\"libevent \" ) ;      return 1 ;    } ....    in a two step process packages are first uploaded to proof and then enabled as required .",
    "the proof package api ( see table  [ package_api ] ) gives the user full control . to avoid unnecessary transfer of par files the upload command",
    "first asks the md5 checksum of the remote version of the package and , if it exists , checks it with the one of the local version .",
    "only when the checksums are different will the par file be transfered to the proof cluster .    ....",
    "int_t   uploadpackage(const char * par , int_t par = 1 ) ;    void    clearpackage(const char * package ) ;    void    clearpackages ( ) ;    int_t   enablepackage(const char * package ) ;    void    showpackages(bool_t all = kfalse ) ;    void    showenabledpackages(bool_t all = kfalse ) ; ....",
    "in this section we will use a simple but full fledged example to illustrate the use of proof and to describe some of the features of the implementation .",
    "the data model underlying the tree in this example is typical for a hep experiment ( see fig  [ ant_datamodel ] ) .",
    "the tree contains a tclonesarray for a hit , track and vertex class and a single event class .",
    "relations between hits , tracks and vertexes are expressed using tref and trefarray .    for this example we use a very simple example script .",
    "the relevant parts are included below .",
    "all error checking has been omitted for brevity . in the init ( )",
    "function a single histogram is created which is stored in the data member fvtx_x of the selector class .    ....",
    "void antsel::begin(ttree * tree )    {      // initialize the tree branches .",
    "init(tree ) ;        fvtx_x = new th1f(\"v\",\"v\",100,-10.,10 . )",
    ";    } ....    the process ( ) function reads the data , makes a simple selection and fills the histogram .",
    "it uses the frmsselvtx reference to get the proper vertex . in a more elaborate version",
    "it would only read the event branch for the test and read the vertex branch as needed .    ....",
    "void antsel::process(int_t entry )    {      fchain->gettree()->getentry(entry ) ;        if ( eventinfo->fpdlmean > 1500 ) {        tphantvertex * vtx = ( tphantvertex * )          eventinfo->frmsselvtx->getobject ( ) ;        fvtx_x->fill(vtx->fpos.x ( ) ) ;      }    } ....    the terminate ( ) function adds the histogram to the output list foutput such that it will be returned to the client by proof .    ....",
    "void antsel::terminate ( )    {      foutput->add(fvtx_x ) ;    } ....    running the script on a typical laptop we can analyze 2000 events , or 8  mbyte , in about 6  seconds ( root i / o has compressed the data in the tree by a factor 5 . ) once the script works as required we are ready to run it using proof .",
    "we start by creating a proof session .",
    "the argument specifies the proof cluster we want to connect to .    ....",
    "root[1 ] groot->proof(\"pgate.lns.mit.edu \" ) ....",
    "we first have to authenticate ourselves to the proof server .",
    "all authentication methods implemented in the standard root tauthenticate class are available .",
    "the proof master server is then created .",
    "the master server reads the proof.conf configuration file and uses the information to start a number of slave servers .",
    "the configuration file is provided by the administrator of the proof cluster .",
    "it contains information about the nodes that make up the proof cluster , the relative performance of the nodes and which nodes share a file system .",
    "when all the slaves are started we are ready to run queries .",
    "but before that we can configure packages .",
    "for this example we ll upload and enable a single package    ....",
    "root[2 ] gproof->uploadpackage(\"ant.par \" )    root[3 ] gproof->enablepackage(\"ant \" ) ....    normally we only need to upload a package if it has changed .",
    "the enablepackage ( ) function will cause the package to be build in the case of a _ source _ package .",
    "finally the setup.c script is run on all slaves , loading our library and making available its classes .",
    "we will use a previously loaded script to create the data set    ....",
    "root[4 ] tdset * d = get_dataset ( ) ....    instead of creating the tdset it might be returned by a database or catalog query .",
    "we are now ready to use proof to process our query . using the same script that was used previously and",
    "the data set we just created we issue the command    ....",
    "root[5 ] d->process(\"antsel.c \" , \" \" , 60000 ) ....    the system goes through a number of steps to implement this command .",
    "first the selector script and possibly its corresponding include file are send to the master and from the master to the slaves .",
    "the system will optimize this step if an up to date version of the script is already available in the cluster .",
    "it also makes use of the shared file system(s ) if available .    then the client sends the query message , including the input objects , option and parameters , to the master .",
    "the master determines the total number of events in the dataset by having the slaves open the files in the dataset in parallel .",
    "this information could in the future also be obtained from a database , avoiding this step in he process .",
    "the master server creates a list of nodes with the files to be processed and their sizes .",
    "this list will be used to optimize the distribution of work over the slaves .",
    "the files have to be specified as rootd urls for this optimization to be available , e.g. `` root://proof.mit.edu / data / file.root '' .",
    "the master now forwards the query to the slaves .",
    "each slave starts the script and enters a loop in which it asks the master for work packets .",
    "the master will allocate work to each slave using the information about the location of the files .",
    "a slave will first be assigned files which are on its local disk . when a slave has exhausted all local files",
    "the rootd protocol is used to process files on other nodes . if no location information was available , .e.g if the files are stored on a central nfs server , the algorithm reduces to a round robin assignment of the files to the slaves .",
    "an heuristic is used to determine the packet size .",
    "it takes into account the number of slaves and their relative performance as well as the total number of events to be processed .",
    "the master monitors the real - time performance of each slave allowing this heuristic to be refined .",
    "the master also records which packet is processed by which slave allowing error recovery to be implemented in the case of slave failure .",
    "when all events are processed the slaves send the partial results to the master . using the previously described merge ( ) algorithm",
    "the master combines the partial results and sends them to the client .",
    "the processing of the above query ran in about 12  seconds using 8  slaves on 4  dual athlon 1.4  ghz machines .",
    "the amount of data processed was 240  mbyte .",
    "this shows the large improvement of even a small dedicated cluster over a typical desktop workstation .",
    "a more precise measurement of the proof performance will be presented in the next section .",
    "first performance measurements show a very good and efficient scalability ( see fig  [ proof_scale ] ) . for the tests we used a linux cluster of 32 nodes .",
    "each node had two itanium  2 1  ghz cpu s , 2x75  gb 15k scsi disk , 2  gb ram and fast ethernet .",
    "the data set to be analyzed consisted of 128 files totaling 8.8  gb of data ( 9 million events ) .",
    "each cluster node had 4 files ( 277  mb ) .",
    "processing these 128 files using one node took 325  seconds and 32  nodes in parallel only 12  seconds .",
    "one node processing only its 4  local files took 9  seconds .",
    "this shows that the efficiency is about 88% .",
    "we also ran tests using all 64  cpu s in the cluster ( two slaves per node ) .",
    "this showed the same linearity but less efficiency , due to overhead in the linux smp implementation and resource contention in each node .",
    "all in all we expect an efficient scalability to at least a 100  node cluster .",
    "to be able to build a global virtual proof cluster we need to use the grid services that are currently being developed .",
    "the interfacing of proof to the grid can be done at several levels .",
    "the following levels have been identified :    * interface to the grid file catalog allowing a user to select a data set based on tags or logical file names ( using wildcards etc ) . * interface to the grid resource broker to find the best location(s ) , based on the data set , where to run the query .",
    "this could trigger the replication of some missing files to a cluster ( only when the amount of data in the files is relatively small ) . *",
    "interface to the grid job queue manager to start proof master and slave daemons on the remote cluster .",
    "the root client will then connect to these pre - started daemons to create a proof session .",
    "this will require the grid queuing system to support interactive high priority jobs .",
    "we are currently working with the alien  @xcite grid developers on a prototype that implements step wise the above scenarios .",
    "alien ( http://alien.cern.ch ) is a grid solution tuned for typical hep data processing .",
    "it has been developed by the alice collaboration but is experiment independent .",
    "it provides all commonly understood grid services , like : file catalog , replication service , job queue manager , resource broker , authentication service , monitoring , etc .",
    "it is entirely implemented in perl and has a c client api .",
    "alien is simple to install and works reliably . in alice",
    "it is routinely used for simulation and reconstruction .",
    "alien has also been chosen as the grid component for the eu mammogrid project .",
    "the root and proof interface to alien , and other grid middleware , will be via a tgrid abstract interface .",
    "currently we are fine tuning proof for a single cluster and are working with some `` early adopter sites '' that have setup dedicated clusters .    several smaller and larger additions and refinements of the system are already foreseen .",
    "general infrastructure for dynamic startup of the session will allow proof to co - exist with traditional batch system as well as grid based environments . this could be extended to dynamic allocation and release of slaves during the session , e.g. based on the data set to be processed .",
    "we are also working at combining multiple clusters at geographically separated sites which will require a hierarchy of master servers .",
    "further integration of proof and root will drive the implementation of event lists and friend trees .",
    "we are also working on ttree::draw ( ) style functionality .",
    "the grid middle - ware is in wild development at the moment and we are following closely these developments to make sure it will support the features we need , especially facilities for interactive high priority jobs and data services .",
    "we demonstrated the proof system , part of the widely adopted root analysis environment , that allows users to harness the power of a large cluster of workstations from their desktops .",
    "proof greatly extends the amount and range of data that can be interactively analyzed .",
    "9 rene brun and fons rademakers , root - an object oriented data analysis framework , proceedings aihenp96 workshop , lausanne , sep .",
    "1996 , nucl .",
    "inst . & meth . in phys",
    "res . a 389 ( 1997 ) 81 - 86 .",
    "see also http://root.cern.ch/. c++ interpreter - cint , masaharu goto , cq publishing , isbn4 - 789 - 3085 - 3 ( japanese ) .",
    "see also http://root.cern.ch/root/cint.html .",
    "p. buncic et al , http://alien.cern.ch ."
  ],
  "abstract_text": [
    "<S> the development of the parallel root facility , proof , enables a physicist to analyze and understand much larger data sets on a shorter time scale . </S>",
    "<S> it makes use of the inherent parallelism in event data and implements an architecture that optimizes i / o and cpu utilization in heterogeneous clusters with distributed storage . </S>",
    "<S> the system provides transparent and interactive access to gigabytes today . </S>",
    "<S> being part of the root framework proof inherits the benefits of a performant object storage system and a wealth of statistical and visualization tools . </S>",
    "<S> this paper describes the key principles of the proof architecture and the implementation of the system . </S>",
    "<S> we will illustrate its features using a simple example and present measurements of the scalability of the system . </S>",
    "<S> finally we will discuss how proof can be interfaced and make use of the different grid solutions . </S>"
  ]
}