{
  "article_text": [
    "answer set programming ( asp ) is a form of non - monotonic reasoning based on the stable model semantics  @xcite .",
    "asp has proven successful as an elegant and convenient vehicle for commonsense reasoning in discrete domains and to encode combinatorial optimization problems in a purely declarative way .",
    "it has been applied in , for example , plan generation  @xcite , diagnosis  @xcite and biological networks  @xcite .",
    "being an active field of research , a large body of extensions have been proposed that improve upon the basics of asp and offer , for example , cardinality constraints  @xcite or nested expressions  @xcite .",
    "not all of these extensions provide an increase in terms of computational expressiveness and some are merely convenient syntactic sugar .    one particularly interesting extension of asp is called communicating asp .",
    "it allows for a number of asp programs to communicate , _",
    "i.e. _  share information about their knowledge base , giving them the ability to cooperate with each other to solve the problem at hand",
    ". each asp program involved , called a component program , has individual beliefs and reasoning capabilities .",
    "one of the benefits of this extension is that it eases the declarative formulation of a problem originating in a multi - agent context .",
    "quite a number of different flavours of communicating asp have been proposed in the literature , both in the narrow domain of asp and in the broader domain of logic programming , where each of these papers presents intriguing examples that highlight the usefulness of communicating asp , for example @xcite , @xcite , @xcite , @xcite and @xcite . in particular , all the examples involve multi - dimensional problems ( _ e.g. _  a police investigation with multiple witnesses ) where each agent only has the knowledge contained in one or a few of the dimensions ( _ e.g. _  the witness only saw the burglar enter the building ) .",
    "a standard example to illustrate the usefulness in this area is shown in  figure  [ fig : magicbox ] .",
    "the figure depicts two people who are looking at a box .",
    "the box is called magic because neither agent can make out its depth .",
    "the information the agents know is further limited because parts of the box are blinded . by cooperation",
    ", both agents can pinpoint the exact location of the ball .",
    "indeed , @xmath2 sees a ball on his left side . from this information @xmath3",
    "knows that there is a ball and that it must therefore be on his left ( since he can not see a ball on his right ) .",
    "this knowledge can be relayed back to @xmath2 .",
    "both agents now know the exact position and depth of the ball .",
    "complexity results from  @xcite show that computing the answer sets of a communicating logic program is in @xmath1 . in general",
    ", however , only few results exist regarding the expressiveness of such communicating asp programs . in addition , for many of the known results , it is not clear whether an increase in expressiveness is due to the type of component programs considered ( _ i.e. _  the expressiveness of the individual programs involved ) or due to the use of communication .    in communicating asp , the notion of an answer set can be defined in different ways ; we refer to the specific definition that is used as the communication mechanism .",
    "answer set semantics is based on the idea of stable minimal models .",
    "when dealing with agents that can communicate , it becomes unclear how we should interpret the notion of minimality .",
    "one option is to assume global minimality , _",
    "i.e. _  we minimise over the conclusions of all the agents in the network .",
    "another option is to assume minimality on the level of a single agent . since in general it",
    "is not possible to find a model that is minimal for all individual agents , the order in which we minimise over the agents matters .",
    "the main contributions of this paper are as follows .",
    "we present a systematic study of the additional expressiveness offered by allowing asp programs to communicate , where , for the most part , we deliberately only consider component programs that are simple , _",
    "i.e. _  programs for which computing the answer sets is in  @xmath0 .",
    "clearly any step we move up in the polynomial hierarchy is then due to the ability of these simple asp programs to communicate and collaborate with each other .",
    "we show that the problem of deciding whether a literal is in any answer set of a communicating asp program using simple communication is in @xmath1 .",
    "we also provide a simulation using a network of simple programs that is capable of modeling any program with negation - as - failure .",
    "these results are extended with complexity results for when the network consists of disjunctive programs . in all cases ,",
    "we examine the complexity of determining whether an answer set exists as well as whether a literal is true in any ( brave reasoning ) or all answer sets ( cautious reasoning ) .",
    "furthermore , we introduce the notion of multi - focused answer sets of communicating asp programs , which allows us to successively focus ( _ i.e. _  minimise ) on different agents . as it turns out , using multi - focused answer set programs it is possible to express any problem in pspace .",
    "this means in particular that communicating asp could be used to solve problems that are above the second level of the polynomial hierarchy , such as some forms of abductive reasoning  @xcite as well as pspace - complete problems such as strips planning  @xcite .",
    "we show that these results hold for any choice of program in the network , being it either simple , normal or disjunctive , and we provide the complexity of determining whether a multi - focused answer set exists .    this paper aggregates and extends our work from  @xcite . the first work is extended with completeness results and an elaborate overview of the simulation of negation - as - failure .",
    "furthermore , we provide more detailed complexity results including the complexity of determining whether an answer set exists and the complexity of determining whether some literal is true in some or all of the answer sets .",
    "the focused answer sets introduced in section  [ sec : focused ] are from  @xcite and are more general than the corresponding notion that we introduced in  @xcite .",
    "additional results are provided , such as the complexity of determining whether a multi - focused answer set exists , as well as new results concerning the use of disjunctive programs as component programs .",
    "we also provide the proofs of all results in the appendix .",
    "we first recall the basic concepts and results from asp that are used in this paper . to define asp programs , we start from a countable set of atoms and we define a  _ literal _ @xmath4 as an atom @xmath5 or its classical negation @xmath6",
    ". if @xmath7 is a set of literals , we use @xmath8 to denote the set @xmath9 where , by definition , @xmath10 .",
    "a set of literals @xmath7 is _ consistent _ if @xmath11 .",
    "an  _ extended literal _ is either a literal or a literal preceded by @xmath12 which we call the negation - as - failure operator .",
    "intuitively we say that @xmath13 is true when we have no proof to support @xmath4 . for a set of literals",
    "@xmath7 , we use @xmath14 to denote the set @xmath15 .    a _ disjunctive rule _",
    "is an expression of the form @xmath16 where @xmath17 is a set of literals ( interpreted as a disjunction , denoted as @xmath18 ) called the head of the rule and @xmath19 ( interpreted as a conjunction ) is the body of the rule with @xmath20 and @xmath21 sets of literals . when the body is empty , the rule is called a  _ fact_. when the head is empty , the rule is called a  _ constraint_. in this paper , we do not consider constraints as they can readily be simulated using extended literals . by @xmath22 with @xmath23 a fresh atom . ]",
    "a _ positive disjunctive rule _ is a disjunctive rule without negation - as - failure in the body , _",
    "i.e. _  with @xmath24",
    ". a _ disjunctive program _",
    "@xmath25 is a finite set of disjunctive rules .",
    "the _ herbrand base _",
    "@xmath26 of @xmath25 is the set of atoms appearing in program  @xmath25 .",
    "a ( partial ) _ interpretation _ @xmath27 of @xmath25 is any consistent set of literals @xmath28 .",
    "@xmath27 is _ total _",
    "iff @xmath29 .",
    "a _ normal rule _ is a disjunctive rule with exactly one literal @xmath4 in the head .",
    "a _ normal program _",
    "@xmath25 is a finite set of normal rules .",
    "a _ simple rule _ is a normal rule without negation - as - failure in the body .",
    "a _ simple program _",
    "@xmath25 is a finite set of simple rules .",
    "the satisfaction relation @xmath30 is defined for an interpretation @xmath27 as @xmath31 iff @xmath32 , otherwise @xmath33 . for an interpretation @xmath27 and @xmath7 a set of literals ,",
    "we define @xmath34 iff @xmath35 .",
    "an interpretation @xmath27 is a _ model _ of a positive disjunctive rule @xmath36 , denoted @xmath37 , if @xmath38 or @xmath39 , _",
    "i.e. _  the body is false or at least one of the literals in the head can be true .",
    "an interpretation @xmath27 of a positive disjunctive program @xmath25 is a _ model _ of @xmath25 iff @xmath40 .",
    "answer sets are defined using the _ immediate consequence operator _",
    "@xmath41 for a simple program @xmath25 _ w.r.t . _  an interpretation @xmath27 as @xmath42 we use @xmath43 to denote the fixpoint which is obtained by repeatedly applying @xmath41 starting from the empty interpretation , _",
    "i.e. _  the least fixpoint of @xmath41 _ w.r.t .",
    "_  set inclusion .",
    "an interpretation @xmath27 is an _ answer set _ of a simple program @xmath25 iff @xmath44 .",
    "the _ reduct @xmath45 _ of a disjunctive program @xmath25 _ w.r.t .",
    "_  the interpretation @xmath27 is defined as @xmath46 we say that @xmath27 is an answer set of the disjunctive program @xmath25 when @xmath27 is a minimal model of @xmath45 _ w.r.t . _  set inclusion .    in the specific case of normal programs",
    ", answer sets can also be characterised in terms of fixpoints . specifically , it is easy to see that in this case the reduct @xmath45 is a simple program .",
    "we say that @xmath27 is an answer set of a normal program @xmath25 iff @xmath47 , _",
    "i.e. _  if @xmath27 is the answer set of the reduct @xmath48 .",
    "the underlying intuition of communication between asp programs is that of a function call or , in terms of agents , asking questions to other agents .",
    "this communication is based on a new kind of literal ` @xmath49 ' , as in  @xcite .",
    "if the literal @xmath4 is not in the answer set of program @xmath50 then @xmath51 is false ; otherwise @xmath51 is true .",
    "the semantics presented in this section are closely related to the minimal semantics of @xcite and especially the semantics of @xcite .",
    "let @xmath52 be a finite set of program names .",
    "@xmath52-situated literal _ is an expression of the form @xmath51 with @xmath53 and @xmath4 a literal . for @xmath54 , a @xmath52-situated literal @xmath49 is called _ @xmath55-local _ if @xmath56 . for a set of literals",
    "@xmath7 , we use @xmath57 as a shorthand for @xmath58 . for a set of @xmath52-situated literals",
    "@xmath59 and @xmath60 , we use @xmath61 to denote @xmath62 , i.e. the projection of @xmath59 on @xmath50 .",
    "a set of @xmath52-situated literals @xmath59 is _ consistent _ iff @xmath61 is consistent for all @xmath60 . by @xmath63",
    "we denote the set @xmath64 where we define @xmath65 . an _",
    "extended @xmath52-situated literal _ is either a @xmath52-situated literal or a @xmath52-situated literal preceded by @xmath12 . for a set of @xmath52-situated literals",
    "@xmath59 , we use @xmath66 to denote the set @xmath67 . for a set of extended @xmath52-situated literals @xmath59",
    "we denote by @xmath68 the set of @xmath52-situated literals in @xmath59 , _",
    "i.e. _  those extended @xmath52-situated literals in @xmath59 that are not preceded by negation - as - failure , while @xmath69 .    a _ @xmath52-situated disjunctive rule _",
    "is an expression of the form @xmath70 where @xmath17 is a set of literals , called the head of the rule , and @xmath19 is called the body of the rule with @xmath20 and @xmath21 sets of @xmath71-situated literals .",
    "a @xmath52-situated disjunctive rule @xmath72 is called @xmath55-local whenever @xmath56 .",
    "a _ @xmath52-component disjunctive program _",
    "@xmath50 is a finite set of @xmath50-local @xmath71-situated disjunctive rules .",
    "henceforth we shall use @xmath71 both to denote the set of program names and to denote the set of actual @xmath52-component disjunctive programs .",
    "communicating disjunctive program _",
    "@xmath52 is then a finite set of @xmath71-component disjunctive programs .",
    "@xmath52-situated normal rule _ is an expression of the form @xmath73 where @xmath49 is a single @xmath52-situated literal .",
    "@xmath52-situated simple rule _ is an expression of the form @xmath74 , _",
    "i.e. _  a @xmath52-situated normal rule without negation - as - failure",
    "@xmath52-component normal ( resp .",
    "simple ) program _",
    "@xmath50 is a finite set of @xmath50-local @xmath71-situated normal ( resp .",
    "simple ) rules . a _ communicating normal ( resp .",
    "simple ) program _",
    "@xmath52 is then a finite set of @xmath71-component normal ( resp .",
    "simple ) programs .    in the remainder of this paper",
    "we drop the @xmath71-prefix whenever the set @xmath71 is clear from the context . whenever the name of the component disjunctive program @xmath50 is clear ,",
    "we write @xmath4 instead of @xmath49 for @xmath50-local situated literals .",
    "note that a communicating disjunctive ( resp .",
    "normal , simple ) program with only one component program thus trivially corresponds to a classical disjunctive ( resp .",
    "normal , simple ) program .",
    "finally , for notational convenience , we write communicating program when it is clear from the context whether the program is a communicating simple program or a communicating normal program .",
    "[ ex : terminology ] consider the communicating normal program @xmath75 with the following situated rules : @xmath76 @xmath77 , @xmath78 , @xmath79 , @xmath80 and @xmath81 are situated literals .",
    "the situated simple rules on the top line are @xmath50-local since we respectively have @xmath77 , @xmath78 and @xmath79 in the head of these rules .",
    "the situated normal rules on the bottom line are @xmath55-local .",
    "hence @xmath82 and @xmath83 .",
    "similar as for a classical program , we can define the _ herbrand base _ for a component program @xmath50 as the set of atoms @xmath84 = @xmath85 , _ i.e. _  the set of atoms occurring in the @xmath50-local situated literals in @xmath50 .",
    "we then define @xmath86 as the herbrand base of the communicating program @xmath52 .",
    "[ ex : herbrand ] given the communicating normal program @xmath75 from example  [ ex : terminology ] we have that @xmath87 , @xmath88 and @xmath89 .",
    "we say that a ( partial ) interpretation @xmath27 of a communicating disjunctive program @xmath71 is any consistent subset @xmath90 .",
    "given an interpretation @xmath27 of a communicating disjunctive program @xmath71 , the reduct @xmath91 for @xmath53 is the component disjunctive program obtained by deleting    * each rule with an extended situated literal ` @xmath92 ' such that @xmath93 ; * each remaining extended situated literal of the form ` @xmath92 ' ; * each rule with a situated literal ` @xmath94 ' that is not @xmath50-local such that @xmath95 ; * each remaining situated literal ` @xmath94 ' that is not @xmath50-local .",
    "note that this definition actually combines two types of reducts together . on the one hand",
    ", we remove the negation - as - failure according to the given knowledge .",
    "on the other hand , we also remove situated literals that are not @xmath50-local , again according to the given knowledge .",
    "the underlying intuition of the reduct remains unchanged compared to the classical case : we take the information into account which is encoded in the guess @xmath27 and we simplify the program so that we can easily verify whether or not @xmath27 is stable , _ i.e. _  whether or not @xmath27 is a minimal model of the reduct .",
    "analogous to the definition of the reduct for disjunctive programs  @xcite , the reduct of a communicating disjunctive program thus defines a way to reduce a program relative to some guess @xmath27 .",
    "the reduct of a communicating disjunctive program is a communicating disjunctive program ( without negation - as - failure ) that only contains component disjunctive programs @xmath50 with @xmath50-local situated literals .",
    "that is , each remaining component disjunctive program @xmath50 corresponds to a classical disjunctive program .",
    "let us once again consider the communicating normal program @xmath75 from example  [ ex : terminology ] .",
    "given @xmath96 we find that @xmath97 and @xmath98 .",
    "we can easily treat @xmath91 and @xmath99 separately since they now correspond to classical programs .",
    "[ def : answerset - communicating ] we say that an interpretation @xmath27 of a communicating disjunctive program @xmath71 is an _ answer set _ of @xmath52 if and only if @xmath100 is the minimal model _",
    "_  set inclusion of @xmath91 .",
    "in other words : an interpretation @xmath27 is an answer set of a communicating disjunctive program @xmath71 if and only if for every component program @xmath50 we have that the projection of @xmath27 on @xmath50 is an answer set of the component program @xmath91 under the classical definition .    in the specific case of a communicating normal program",
    "@xmath71 we can equivalently say that @xmath27 is an answer set of @xmath52 if and only if we have that @xmath101 .",
    "the communicating normal program @xmath75 from example  [ ex : terminology ] has two answer sets , namely @xmath102 and @xmath103 .",
    "note that while most approaches do not allow self - references of the form @xmath104 , in our approach this poses no problems as it is semantically equivalent to @xmath105 .",
    "also note that our semantics allow for `` mutual influence '' as in @xcite where the belief of an agent can be supported by the agent itself , via belief in other agents , _ e.g. _  @xmath106 .",
    "furthermore we want to point out that the belief between agents is the belief as identified in  @xcite , _ i.e. _  the situated literal @xmath49 is true in our approach whenever `` @xmath107 '' is true in the approach introduced in  @xcite for nested logic programs and treating @xmath49 as a fresh atom .",
    "before we introduce our first proposition , we generalise the immediate consequence operator for ( classical ) normal programs to the case of communicating simple programs .",
    "specifically , the operator @xmath108 is defined _ w.r.t .",
    "_  an interpretation @xmath27 of @xmath71 as @xmath109 where @xmath20 is a set of @xmath71-situated literals .",
    "it is easy to see that this operator is monotone .",
    "together with a result from @xcite we know that this operator has a least fixpoint .",
    "we use @xmath110 to denote this fixpoint obtained by repeatedly applying @xmath108 starting from the empty interpretation .",
    "clearly , this fixpoint can be computed in polynomial time .",
    "furthermore , just like the immediate consequence operator for ( classical ) normal programs , this generalised operator only derives the information that is absolutely necessary , _ i.e. _  the fixpoint @xmath110 is globally minimal .",
    "[ prop : one - simple - is - polynomial ] let @xmath52 be a communicating simple program .",
    "we then have that :    = 2em    there always exists at least one answer set of @xmath71 ;    there is always a unique answer set of @xmath71 that is globally minimal ;    we can compute this unique globally minimal answer set in polynomial time .",
    "consider the communicating simple program @xmath71 with the rules @xmath111 this communicating simple program has two answer sets , namely @xmath112 and @xmath113 .",
    "we have that @xmath114 , _ i.e. _  @xmath113 is the answer set that can be computed in polynomial time . intuitively , this is the answer set of the communicating simple program @xmath71 where we treat every situated literal as an ordinary literal .",
    "for example , if we replace the situated literal @xmath77 ( resp .",
    "@xmath115 , @xmath116 ) by the literals @xmath117 ( resp .",
    "@xmath118 ) we obtain the simple program @xmath119 which has the unique answer set @xmath120 , with @xmath121 the literal that replaced @xmath78 .",
    "note that the procedure involving the generalised fixpoint does not allow us to derive the second answer set .",
    "in general , no polynomial procedure will be able to verify whether there is some answer set in which a given literal is true ( unless @xmath122=@xmath1 ) .",
    "although finding an answer set of a communicating simple program can be done in polynomial time , we will see in the next section that brave reasoning ( the problem of determining whether a given situated literal @xmath49 occurs in any answer set of a communicating simple program ) is @xmath1-hard .",
    "consequently , cautious reasoning ( the problem of determining whether a given literal @xmath49 occurs in all answer sets of a communicating simple program ) is @xmath123-hard .",
    "the addition of communication to asp programs can provide added expressiveness over simple programs and a resulting increase in computational complexity for brave reasoning and cautious reasoning . to illustrate this observation , in this section",
    "we show that a communicating simple program can simulate normal programs .-",
    "complete and normal programs are @xmath1-complete  @xcite .",
    "] furthermore , we illustrate that , surprisingly , there is no difference in terms of computational complexity between communicating simple programs and communicating normal programs ; a communicating simple program can be constructed which simulates any given communicating normal program .    for starters",
    ", we recall some of the notions of complexity theory . the complexity classes @xmath124 , @xmath125 and @xmath126 are defined as follows , for @xmath127  @xcite : @xmath128 where @xmath129 ( resp .",
    "@xmath130 ) is the class of problems that can be solved in polynomial time on a non - deterministic machine ( resp .",
    "deterministic machine ) with an @xmath131 oracle , _",
    "i.e. _  assuming a procedure that can solve @xmath131 problems in constant time .",
    "for a general complexity class @xmath132 , a problem is @xmath132-hard if any other problem in @xmath133  can be efficiently reduced to this problem a problem is said to be @xmath133-complete if the problem is in @xmath133  and the problem is @xmath133-hard . deciding the validity of a qbf @xmath134 with @xmath135 if @xmath136 is odd and @xmath137 otherwise , is the canonical @xmath138-complete problem .",
    "deciding the validity of a qbf @xmath139 with @xmath137 if @xmath136 is odd and @xmath135 otherwise , is the canonical @xmath140-complete problem .",
    "moreover , these results also hold when we restrict ourselves to problems with @xmath141 in disjunctive normal form , except when the last quantifier is an @xmath142 . and a formula in disjunctive normal form",
    ", we can reduce the problem in polynomial time to a new qbf without the last quantifier . to do this , for every variable quantified by this last quantifier we remove those clauses in which both the quantified variable and its negation occur ( contradiction ) and then remove all occurrences of the quantified variables in the remaining clauses as well as the quantifier itself .",
    "the new qbf is then valid if and only if the original qbf is valid .",
    "] brave reasoning as well as answer set existence for simple , normal and disjunctive programs is @xmath0-complete , @xmath143-complete and @xmath144-complete , respectively  @xcite .",
    "cautious reasoning for simple , normal and disjunctive programs is @xmath145-complete , @xmath123-complete and @xmath146-complete  @xcite .    in this section",
    "we start by giving an example of the transformation that allows us to simulate ( communicating ) normal programs using communicating simple programs . a formal definition of the simulation is given below in  definition  [ def : simulateextended ] .",
    "the correctness is proven by propositions  [ prop : partialanswerset ] and [ prop : converse ] .",
    "[ ex : simulation ] consider the communicating normal program @xmath52 with the rules @xmath147 note that if we were to take @xmath148 then this example corresponds to a normal program . in our simulation ,",
    "the communicating normal program @xmath52 is transformed into the following communicating simple program @xmath149 : @xmath150 the transformation creates two types of component programs or _",
    "` worlds ' _ , namely @xmath151 and @xmath152 .",
    "the component program @xmath151 is similar to @xmath153 but occurrences of extended situated literals of the form @xmath154 are replaced by @xmath155 , with @xmath156 a fresh literal .",
    "the non - monotonicity associated with negation - as - failure is simulated by introducing the rules @xmath157 and @xmath158 in @xmath151 and @xmath152 , respectively .",
    "finally , we add rules of the form @xmath159 to @xmath152 , creating an inconsistency when @xmath152 believes @xmath160 and @xmath151 believes @xmath4 .",
    "the resulting communicating simple program @xmath161 is an equivalent program in that its answer sets correspond to those of the original communicating normal program , yet without using negation - as - failure .",
    "indeed , the answer sets of @xmath52 are @xmath162 and @xmath163 and the answer sets of @xmath161 are @xmath164 and @xmath165 .",
    "note that the simulation given in example  [ ex : simulation ] can in fact be simplified .",
    "indeed , in this particular example there is no need to have two additional component programs @xmath166 and @xmath167 since @xmath168 and @xmath169 do not share literals .",
    "also , in this particular example , we need not use ` @xmath170 ' and ` @xmath171 ' since the simulation would work just as well if we simply considered ` @xmath5 ' and ` @xmath172 ' instead .",
    "nonetheless , for the generality of the simulation such technicalities are necessary . without adding an additional component program @xmath152 for every original component program @xmath153 the simulation would in general not work",
    "when two component programs shared literals , _ e.g. _  @xmath173 and @xmath174 .",
    "furthermore , we need to introduce fresh literals as otherwise the simulation would in general not work when we had true negation in the original program , _ e.g. _  @xmath175 .",
    "we now give the definition of the simulation which works in the general case .",
    "[ def : simulateextended ] let @xmath176 be a communicating normal program . the communicating simple program @xmath177 with @xmath178 that simulates @xmath52 is defined by @xmath179 with @xmath180 , @xmath181 and with @xmath182 and @xmath183 as defined before .",
    "note how this is a polynomial transformation with at most @xmath184 additional rules .",
    "this is important when later we use the @xmath1-completeness results from normal programs to show that communicating simple programs are @xmath1-complete as well .",
    "recall that both @xmath185 and @xmath171 are fresh literals that intuitively correspond to @xmath186 and @xmath172 .",
    "we use @xmath187 to denote the set of rules in @xmath151 defined by ( [ simulation - q - pos ] ) and @xmath188 to denote the set of rules in @xmath151 defined by ( [ simulation - q - neg ] ) .",
    "the intuition of the simulation in definition  [ def : simulateextended ] is as follows .",
    "the simulation uses the property of mutual influence to mimic the choice induced by negation - as - failure .",
    "this is obtained from the interplay between rules and . as such",
    ", we can use the new literal ` @xmath189 ' instead of the original extended ( situated ) literal ` @xmath190 ' , allowing us to rewrite the rules as we do in . in order to ensure that the simulation works even when the program we want to simulate already contains classical negation ,",
    "we need to specify some additional bookkeeping  .",
    "as will become clear from proposition  [ prop : partialanswerset ] and proposition  [ prop : converse ] , the above transformation preserves the semantics of the original program . since we can thus rewrite any normal program as a communicating normal program ,",
    "the importance is twofold . on one hand",
    ", we reveal that communicating normal programs do not have any additional expressive power over communicating simple programs . on the other hand",
    ", it follows that communicating simple programs allow us to solve @xmath143-complete problems .",
    "before we show the correctness of the simulation in definition  [ def : simulateextended ] , we introduce a lemma .",
    "[ lem : analogousanswerset ] let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath192 the communicating simple program that simulates @xmath52 defined in definition  [ def : simulateextended ] .",
    "let @xmath193 be an answer set of @xmath52 and let the interpretation @xmath194 be defined  as : @xmath195 for each @xmath196 it holds that @xmath197 with @xmath198 the set of rules defined in with @xmath199 .    using this lemma , we can prove that @xmath194 as defined in  lemma  [ lem : analogousanswerset ] is indeed an answer set of the communicating simple program that simulates the communicating normal program @xmath71 when @xmath193 is an answer set of @xmath71 .    [",
    "prop : partialanswerset ] let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath192 the communicating simple program that simulates @xmath52 as defined in definition  [ def : simulateextended ] . if @xmath193 is an answer set of @xmath52 , then @xmath194 is an answer set of @xmath192 with @xmath194 defined as in lemma  [ lem : analogousanswerset ] .",
    "next we introduce lemma  [ lem : reverseanalogousanswerset ] , which is similar to lemma  [ lem : analogousanswerset ] in approach but which states the converse .",
    "[ lem : reverseanalogousanswerset ] let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath200 the communicating simple program that simulates @xmath52 .",
    "assume that @xmath194 is an answer set of @xmath200 and that @xmath201 is total _",
    "_  @xmath202 for all @xmath196 .",
    "let @xmath193 be defined as @xmath203 for each @xmath196 , it holds that @xmath197 with @xmath199 .",
    "[ prop : converse ] let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath200 the communicating simple program that simulates @xmath52 .",
    "assume that @xmath194 is an answer set of @xmath200 and that @xmath201 is total _",
    "_  @xmath202 for all @xmath196 .",
    "then the interpretation @xmath193 defined in lemma  [ lem : reverseanalogousanswerset ] is an answer set of @xmath52 .",
    "it is important to note that lemma  [ lem : reverseanalogousanswerset ] and , by consequence , proposition  [ prop : converse ] require ( part of ) the answer set @xmath194 to be total .",
    "this is a necessary requirement , as demonstrated by the following example .",
    "[ ex : needs - total ] consider the normal program @xmath204 which has no answer sets .",
    "the corresponding communicating simple program @xmath205 has the following rules : @xmath206 it is easy to see that @xmath207 is an answer set of @xmath192 since we have @xmath208 . notice that @xmath27 does not correspond with an answer set of @xmath55 , which is due to @xmath209 not being total and hence we can not apply  proposition  [ prop : converse ] .    regardless , it is easy to see that the requirement for the answer set to be total can be built into the simulation program . indeed",
    ", it suffices to introduce additional rules to every @xmath152 with @xmath210 in the simulation defined in definition  [ def : simulateextended ] .",
    "these rules are @xmath211 thus the requirement that ( part of ) the answer set must be total can be replaced by the requirement that the situated literals @xmath212 must be true in the answer set .",
    "hence , if we want to check whether a literal @xmath49 is true in at least one answer set of a ( communicating ) normal program , it suffices to check whether @xmath49 and @xmath212 can be derived in the communicating simple program that simulates it .",
    "clearly we find that brave reasoning for communicating simple programs is @xmath1-hard .",
    "what we have done so far is important for two reasons .",
    "first , we have shown that the complexity of brave reasoning for communicating normal programs is no harder than brave reasoning for communicating simple programs .",
    "indeed , the problem of brave reasoning for communicating normal programs can be reduced in polynomial time to the problem of brave reasoning for communicating simple programs .",
    "second , since normal programs are a special case of communicating normal programs and since we know that brave reasoning for normal programs is an @xmath1-complete problem , we have successfully shown that brave reasoning for communicating simple programs is @xmath1-hard . in order to show",
    "that brave reasoning for communicating simple programs is @xmath1-complete , we need to additionally show that this is a problem in @xmath1 .",
    "to this end , consider the following algorithm to find the answer sets of a communicating simple program @xmath71 : @xmath213    the first step of the algorithm requires a choice , hence the algorithm is non - deterministic .",
    "next we determine whether this guess is indeed a communicating answer set , which involves taking the reduct , computing the fixpoint and verifying whether this fixpoint coincides with our guess .",
    "clearly , verifying whether the interpretation is an answer set can be done in polynomial time and thus the algorithm to compute the answer sets of a communicating simple program is in @xmath1 , and thus @xmath1-complete , regardless of the number of component programs .",
    "these same results hold for communicating normal programs since the reduct also removes all occurrences of negation - as - failure .    for communicating disjunctive programs",
    "it is easy to see that the @xmath144-completeness of classical disjunctive asp carries over to communicating disjunctive programs .",
    "cautious reasoning is then @xmath123 and @xmath146 for communicating normal programs and communicating disjunctive programs , respectively , since this decision problem is the complement of brave reasoning .",
    "finally , the problem of answer set existence is carried over from normal programs and disjunctive programs  @xcite and is @xmath143-hard and @xmath146-hard , respectively .",
    "most of these complexity results correspond with classical asp , with the results from communicating simple programs being notable exceptions ; indeed , for communicating simple programs the communication aspect clearly has an influence on the complexity .",
    "table  [ tbl : complexity ] summarises the main complexity results .",
    ".completeness results for the main reasoning tasks for a communicating program @xmath214 [ cols=\">,^,^,^ \" , ]     due to the extra expressiveness and complexity of multi - focused answer sets , it is clear that no translation to classical asp is possible .",
    "possible future implementations may , however , be based on a translation to other pspace complete problems such as qbf formulas or modal logics .",
    "a translation to qbf formulas seems to be the most natural , especially since the proof of the complexity of multi - focused answer sets involves reducing qbf formulas to multi - focused answer sets .",
    "however , any such translation falls beyond the scope is this paper and is the subject of future research .",
    "in this section we work out an example that highlights the usefulness of multi - focused answer sets . the use of multi - focused answer sets has already proven itself useful in modeling problems where one can use a negotiation paradigm , _",
    "e.g. _  in  @xcite . however , the main goal in  @xcite was to show that such a paradigm is possible , rather than actually trying to encode a problem that is known to be more complex that @xmath144 . though a lot of interesting problems are indeed in @xmath122 , @xmath1  or @xmath215 , there are still some important problems that are even higher up in the polynomial hierarchy .",
    "one such a problem is a special form of abductive diagonistics .",
    "an abductive diagnostic problem is encoded as a triple @xmath216@xcite , where @xmath217 is a set of atoms referred to as hypotheses , @xmath218 is an asp program referred to as the theory and @xmath219 is a set of literals referred to as observations .",
    "intuitively , the theory @xmath218 describes the dynamics of the system , the observations @xmath219 describe the observed state of the system and the hypotheses @xmath217 try to explain these observations within the theory .",
    "the goal in subset - minimal abductive diagnosis is to find the minimal set of hypotheses that explain the observation .",
    "that is , we want to find the minimal set of hypotheses such that @xmath220 with @xmath193 an answer set of @xmath221 .",
    "subset - minimal abductive diagnostics over a theory consisting of a disjunctive program is a problem in @xmath222 and hence we can not rely on classical asp to find the solutions to this problem .",
    "however , as we will see in the next example , we can easily solve this problem using multi - focused answer sets .",
    "[ ex : diagnosis ] consider an electronic circuit , as in figure  [ fig : diagnosis ] , where we have a power source , a control lamp , three hot - plates wired in parallel and a fuse to protect each hot - plate .",
    "it is known that some of the fuses are sensitive to high current and may consequently blow , but it is not known which fuses .",
    "furthermore , plate a sits near a source of water ( _ e.g. _  a tap ) .",
    "if water comes into contact with plate a , this causes a short circuit which blows the nearest fuse , _",
    "i.e. _  fuse a , to prevent any damage .        upon inspection",
    ", we find that the control lamp is on and that plate a feels cold to the touch .",
    "we want to find the subset minimal diagnoses that would explain the problem , _",
    "i.e. _  we want to find the minimal causes that can explain this situation",
    ".    first we need to describe the theory , _",
    "i.e. _  the schematics .",
    "the theory describes the dynamics of the system and thus also how the system may fail .",
    "we can describe the theory as follows . for starters",
    ", a melted fuse can be caused by a high current , or , for fuse a , due to a hazardous water leak : @xmath223 we now encode the hypotheses .",
    "we have a number of causes , each of which may by itself or in conjunction with other causes explain our observation . in total , we have four causes .",
    "the power can be off ( @xmath224 ) , the light bulb might be broken ( @xmath225 ) , there may have been a high current ( @xmath226 ) and/or a water leak may have occurred ( @xmath227 ) .",
    "we describe all these hypotheses as follows : @xmath228 it is easy to see that these rules in @xmath50 encode all possible subsets of hypotheses that may have occurred .",
    "we then add rules to a separate component program @xmath217 which merely relays the information on the set of hypotheses that we chose .",
    "the reason for this separate component program @xmath217 is that we can now minimise over the set of hypotheses that is assumed , simply by focusing on @xmath217 .",
    "@xmath229 finally , we model the observation .",
    "we observe that the control light is on and that plate a is cold .",
    "in other words , we obtain the rules ( which encode constraints ) : @xmath230 which intuitively tell us that we can not have that the light is off , nor can we have that plate a is hot .",
    "the @xmath231-focused answer sets give us the subset minimal abductive diagnoses .",
    "it is easy to see that the focus on @xmath217 is needed to minimise over the hypotheses .",
    "the program @xmath232 has two @xmath231-focused answer sets @xmath233 and @xmath234 , both containing @xmath235 : @xmath236 hence the minimal sets of hypotheses that support our observation , _",
    "i.e. _  @xmath237 with @xmath193 an @xmath231-focused answer set , are that either there was a high current ( which melted fuse a ) or there was a water leak ( which also melted fuse a ) .",
    "a large body of research has been devoted to combining logic programming with multi - agent or multi - context ideas , with various underlying reasons .",
    "one reason for such a combination is that the logic can be used to describe the ( rational ) behaviour of the agents in a multi - agent network , as in  @xcite .",
    "alternately , it can be used to combine different flavours of logic programming languages  @xcite .",
    "it can also be used to externally solve tasks for which asp is not suited , while remaining in a declarative framework  @xcite . as a final example , it can be used as a form of cooperation , where multiple agents or contexts collaborate to solve a difficult problem  @xcite .",
    "the approach in this paper falls in the last category and is concerned with how the collaboration of different asp programs affects the expressiveness of the overall system .",
    "important work has been done in the domain of multi - context systems ( mcs ) and multi - agent asp to enable collaboration between the different contexts / asp programs .",
    "we discuss some of the more prominent work in these areas .",
    "the work of  @xcite proposes an extension of multi - context systems or mcss  @xcite that allows mcss to reason about absent information , _",
    "i.e. _  they introduce non - monotonicity in the context of mcss .",
    "the idea of a mcs is that we have a number of contexts that each have access to only a subset of the available information .",
    "each context has a local model and reasoning capabilities , but there is also an information flow defined by the system between the different contexts .",
    "it is this idea that was later adopted in the asp community and in our paper in particular .",
    "our paper has a comparable syntax as  @xcite but rather different semantics .",
    "the semantics in  @xcite are closely related to the well - founded semantics  @xcite , while our semantics are closer in spirit to the stable model semantics  @xcite .",
    "another point where our semantics differ is that we allow a restricted circular explanation of why a literal is true , if that circular explanation is due to our reliance on other component programs .",
    "this particular form of circular reasoning has been identified in  @xcite as a requirement in the representation of social reasoning .",
    "the work in  @xcite further extends the work in  @xcite and addresses a number of problems and deficiencies .",
    "the paper is , to the best of our knowledge , the first to offer a syntactical rather than semantical description of communication in multi - context systems , making it easier to implement an actual algorithm .",
    "a number of interesting applications of contextual frameworks , including information fusion , game theory and social choice theory are highlighted in the paper .",
    "lastly , the paper identifies that the complexity of the main reasoning task is on the second level of the polynomial hierarchy .    along similar lines",
    "@xcite combines the non - monotonicity from  @xcite with the heterogeneous approach presented in  @xcite into a single framework for heterogenous non - monotonic multi - context reasoning .",
    "the work in  @xcite introduces several notions of equilibria , including minimal and grounded equilibria . in our approach ,",
    "local reasoning is captured by grounded equilibria ( which does not allow circular explanations ) while communicating with other component programs is captured by the weaker minimal equilibria .",
    "the work in  @xcite offers various membership results on deciding the existence of an equilibrium and is one of the first to note that multi - context systems , due to the nature of the bridge rules / situated literals , can be non - monotonic even if all the logics in the component programs themselves are monotonic .",
    "work on a distributed solver for heterogenous multi - context systems commenced in  @xcite .",
    "while solvers exist to compute multi - context systems locally , this is the first work to consider an algorithm which is both distributed ( _ i.e. _  no shared memory ) and modular ( _ i.e. _  computation starting from partial models ) . when the context under consideration uses _",
    "e.g. _  asp , loop formulas can be devised which allow bridge rules to be compiled into local classical theories .",
    "it is then possible to use sat solvers to compute the grounded equilibria of the heterogenous multi - context system .",
    "later work in  @xcite improved on the idea by offering a mechanism to identify and break symmetries ( _ i.e. _  permutations of belief which result in identical knowledge ) .",
    "as such , the solver need never visit two points in the search space that are symmetric , thus potentially offering a considerable speedup .",
    "experimental results show that the solution space can indeed be ( significantly ) compressed .",
    "a similar idea might be used to compute answer sets of a communicating asp program in a distributed fashion . indeed , such answer sets are closely related to the idea of minimal equilibria from  @xcite .",
    "a few modifications should nonetheless be made .",
    "for example , the herbrand base needs to be redefined in a way that is safe in such a distributed setting , _ e.g. _  by only taking situated literals into account that occur in a given component program .",
    "optimizations to the distributed algorithm also seem likely to be applicable to the setting of communicating asp . on the other hand",
    ", it does not seem to be straightforward to extend these ideas to compute multi - focused answer sets in a distributed fashion .",
    "one of the most recent extensions to multi - context systems are managed multi - context systems or mmcs  @xcite .",
    "normally , bridge rules can only be used to pass along information which allows for _ e.g. _  selection and abstraction of information between contexts . in an mmcs ,",
    "however , additional operations on knowledge bases can be freely defined .",
    "for example , operations may be defined that remove or revise information .",
    "such operations are performed by the context itself , _",
    "i.e. _  by the legacy system that is used such as asp , but mmcs allow to cope with this additional functionality in a principled way . as one would expect , adding such complex operations increases the expressiveness of the resulting system considerably .",
    "our work , on the other hand , only allows for information to be passed along . by varying the way that the communication works",
    ", we achieved a comparable expressiveness .",
    "we now direct our attention to work done within the asp community .",
    "the ideas presented in this paper are related to hex programs  @xcite in which asp is extended with higher - order predicates and external atoms .",
    "these external atoms allow to exchange knowledge in a declarative way with external sources that may implement functionality which is inconvenient or impossible to encode using current answer set programming paradigms .",
    "application - wise , hex is mainly proposed as a tool for non - monotonic semantic web reasoning under the answer set semantics .",
    "hence hex is not primarily targeted at increasing the expressiveness , but foremost at extending the applicability and ease of use of asp .",
    "two other important works in the area of multi - agent asp are  @xcite and  @xcite . in both  @xcite and  @xcite",
    "a multi - agent system is developed in which multiple agents / component programs can communicate with each other .",
    "most importantly from the point of view of our work , both approaches use asp and have agents that are quite expressive in their own right . indeed , in  @xcite",
    "each agent is an ordered choice logic program ( oclp )  @xcite and in  @xcite each agent uses the extended answer set semantics .",
    "the framework introduced in  @xcite is called laima .",
    "each of the agents is an oclp .",
    "the agents can communicate with whoever they want and circular communication is allowed ( where agent @xmath238 tells something to agent @xmath239 which tells something to @xmath238  ) .",
    "however , only positive information can be shared and the authors do not look at the actual expressiveness of the framework . in",
    "@xcite each agent uses the extended answer set semantics .",
    "the network is a linear `` hierarchical '' network ( _ i.e. _  information only flows in one direction ) , yet they employ the idea of a failure feedback mechanism .",
    "intuitively , a failure feedback mechanism allows the previous agent in a network to revise his conclusion when the conclusion leads to an unresolvable inconsistency for the next agent in the network .",
    "it is this mechanism that gives rise to a higher expressiveness , namely @xmath125 for a hierarchical network of @xmath136 agents .",
    "our work is different in that we start from simple and normal asp programs for the agents .",
    "our communication mechanism is also quite simple and does not rely on any kind of feedback .",
    "regardless , we obtain a comparable expressiveness",
    ".    we also mention  @xcite where recursive modular non - monotonic logic programs ( mlp ) under the asp semantics are considered .",
    "the main difference between mlp and our work is that our communication mechanism is parameter - less , _ i.e. _  the truth of a situated literal is not dependent on parameters passed by the situated literal to the target component program .",
    "our approach is clearly different and we can not readily mimic the behaviour of the networks presented in  @xcite .",
    "our expressiveness results therefore do not directly apply to mlps .",
    "finally , there is an interesting resemblance between multi - focused answer sets and the work on multi - level integer programming  @xcite . in multi - level integer programming ,",
    "different agents control different variables that are outside of the control of the other agents , yet are linked by means of linear inequalities ( constraints ) .",
    "the agents have to fix the values of the variables they can control in a predefined order , such that their own linear objective function is optimized . similarly , in communicating asp , literals belong to different component programs ( agents ) , and their values are linked through constraints , which in this case take the form of rules .",
    "again the agents act in a predefined order , but now they try to minimise the set of literals they have to accept as being true , rather than a linear objective function .",
    "though there is an intuitive link , further research is required to make this link between multi - focused answer sets and the work on multi - level integer programming explicit .",
    "we have systematically studied the effect of adding communication to asp in terms of expressiveness and computational complexity . we start from simple programs , _",
    "i.e. _  definite programs extended with true negation . determining whether a literal belongs to an answer set of a simple program is a problem in @xmath122 . a network of these simple programs , which we call communicating simple programs , is however expressive enough to simulate normal programs . in other words ,",
    "determining whether a literal belongs to an answer set of a communicating simple program is @xmath1-hard .",
    "furthermore , communicating simple programs can also simulate communicating normal programs provided that the resulting answer sets are partially complete , thus showing that adding negation - as - failure to communicating simple programs does not further increase the expressiveness .",
    "we have introduced multi - focused answer sets for communicating programs .",
    "the underlying intuition is that of leaders and followers , where the choices available to the followers are limited by what the leaders have previously decided . on a technical level",
    ", the problem translates to establishing local minimality for some of the component programs in the communicating program . since in general it is not possible to ensure local minimality for all component programs , an order must be defined among component programs on which to focus .",
    "the result is an increase in expressiveness , where the problem of deciding whether @xmath240 with @xmath193 a @xmath241-focused answer set of @xmath71 is @xmath242-complete . in our work",
    "we thus find that the choice of the communication mechanism is paramount _ w.r.t .",
    "_  the expressiveness of the overall system , in addition to the expressiveness of the individual agents .",
    "table  [ tbl : results ] highlights the membership results for brave reasoning obtained in section  [ sec : focused ] .",
    "one - simple - is - polynomial let @xmath52 be a communicating simple program .",
    "we then have that :            we can easily generalise the immediate consequence operator for ( classical ) simple programs to the case of communicating simple programs . specifically ,",
    "the operator @xmath108 is defined _ w.r.t .",
    "_  an interpretation @xmath27 of @xmath71 as @xmath243 where @xmath20 is a set of @xmath71-situated literals .",
    "it is easy to see that this operator is monotone .",
    "together with a result from @xcite we know that this operator has a least fixpoint .",
    "we use @xmath110 to denote this fixpoint obtained by repeatedly applying @xmath108 starting from the empty interpretation .",
    "clearly , this fixpoint can be computed in polynomial time .",
    "we need to verify that @xmath110 is indeed an answer set . since @xmath52 is a communicating simple program , we know that the reduct @xmath244 will only remove rules that contain situated literals @xmath94 that are not @xmath50-local with @xmath245 . in other words , rules that are not applicable ( @xmath246 ) and that contain non-@xmath50-local situated literals are removed . furthermore",
    ", remaining situated literals of the form @xmath94 that are not @xmath50-local ( _ i.e. _  those where @xmath247 ) are removed from the body of the remaining rules .",
    "hence the remaining rules are all @xmath50-local .",
    "notice that the operator @xmath108 is clearly an extension of the operator @xmath248 .",
    "indeed , for a component simple program @xmath249 that is @xmath249-local it is easy to verify that if @xmath250 then @xmath251 with @xmath252 .",
    "it then readily follows , since all rules are @xmath50-local and therefore independent of all other component programs , that @xmath253 for all @xmath53 .",
    "so far we found that an answer set exists and that it can be computed in polynomial time .",
    "all that remains to be shown is that this answer set is globally minimal .",
    "this trivially follows from the way we defined the operator @xmath108 since it only makes true the information that is absolutely necessary , _ i.e. _  the information that follows directly from the facts in the communicating simple program .",
    "hence this is the minimal amount of information that needs to be derived for a set of situated literals to be a model of the communicating simple program at hand and thus the fixpoint @xmath110 is the globally minimal answer set .",
    "analogousanswerset let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath192 the communicating simple program that simulates @xmath52 as defined in definition  [ def : simulateextended ] .",
    "let @xmath193 be an answer set of @xmath52 and let the interpretation @xmath194 be defined  as : @xmath254 for each @xmath196 it holds that @xmath197 with @xmath198 the set of rules defined in with @xmath199 .    to prove this ,",
    "we first show that any rule of the form @xmath255 reappears in @xmath256 under the form @xmath257 for any @xmath196 .",
    "the second step , showing that the converse also holds , can then be done in an analogous way .",
    "suppose @xmath255 for some @xmath196 . by the definition of the reduct",
    "we know that there is some rule of the form @xmath258 such that @xmath259 and @xmath260 is a set of situated literals of the form @xmath261 with @xmath262 , @xmath263 . from definition  [ def : simulateextended ] , we know that the communicating normal rule @xmath264 is transformed into the rule @xmath265 with @xmath266 , @xmath267 and @xmath268 .",
    "we show that , indeed , @xmath255 reappears in @xmath256 under the form @xmath257 .    first , whenever @xmath269 , we know that @xmath270 since @xmath259 . from the construction of @xmath194 we have that @xmath271 . similarly , since @xmath260 we know from the construction of @xmath194 that @xmath272 whenever @xmath273 .",
    "hence when determining the reduct  @xmath274 , the extended situated literals in @xmath275 and @xmath276 will be deleted .",
    "finally , whenever @xmath277 we know from the construction of @xmath194 that @xmath278 whenever @xmath279 . clearly , when determining the reduct , none of these extended situated literals will be deleted as they are @xmath151-local .",
    "hence it is clear that the reduct of the communicating rule ( @xmath280 ) is the rule @xmath281 .",
    "this completes the first part of the proof .",
    "as indicated , the second part of the proof is completely analogous .",
    "partialanswerset let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath192 the communicating simple program that simulates @xmath52 as defined in definition  [ def : simulateextended ] .",
    "if @xmath193 is an answer set of @xmath52 , then @xmath194 is an answer set of @xmath192 with @xmath194 defined as in lemma  [ lem : analogousanswerset ] .",
    "this proof is divided into two parts . in part 1",
    "we only consider the component programs @xmath151 with @xmath196 and show that @xmath282 . in part 2",
    "we do the same , but we only consider the component programs @xmath152 with @xmath196 . as per definition",
    "[ def : answerset - communicating ] we have then shown that @xmath194 is indeed an answer set of @xmath192 .",
    "consider a component program @xmath151 with @xmath196 . by definition  [ def : simulateextended ] we have that @xmath283 and thus @xmath284 for @xmath285 we know by construction that it only contains rules that are of the form @xmath286 and that the only rules of this form are in @xmath287 .",
    "therefore , due to the definition of the reduct , we have @xmath288 hence @xmath289 only contains facts about literals that , by construction of @xmath151 , do not occur in @xmath198 .",
    "this means that from ( [ prop - part1 ] ) and ( [ prop - part2 ] ) we obtain @xmath290 from lemma  [ lem : analogousanswerset ] we know that @xmath197 where @xmath266 . because of the definition of an answer set of a communicating program we have @xmath291 combining this with we get @xmath292 this concludes the first part of the proof .    in the second part of the proof",
    ", we only consider the component programs @xmath293 with @xmath196 . by construction of @xmath152 we know that all the rules of the form @xmath294 and @xmath295 are in @xmath152 and that all the rules in @xmath152 are of this form .",
    "we have @xmath296 from which it follows that @xmath297    reverseanalogousanswerset let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath200 the communicating simple program that simulates @xmath52 .",
    "assume that @xmath194 is an answer set of @xmath200 and that @xmath201 is total _",
    "_  @xmath202 for all @xmath196 .",
    "let @xmath193 be defined as @xmath203 for each @xmath196 , it holds that @xmath197 with @xmath199 .    to prove this ,",
    "we first show that any rule of the form @xmath298 reappears in @xmath299 under the form @xmath300 for any @xmath196 .",
    "we then show that the converse also holds , which is rather analogous to the proof of the first part of lemma  [ lem : analogousanswerset ] . due to some technical subtleties in the second part of the proof , however , we present the proof in detail .",
    "suppose @xmath298 . by the definition of the reduct of a communicating simple program",
    "we know that there is some communicating simple rule of the form @xmath301 such that @xmath302 is a set of situated literals of the form @xmath303 and @xmath304 is a set of situated literals of the form @xmath305 with @xmath262 and @xmath306 .    from the definition of @xmath198",
    ", we know that @xmath265 corresponds to a rule @xmath258 where we have that @xmath307 , @xmath308 and @xmath309 . we show that , indeed , @xmath298 reappears in @xmath299 under the form @xmath310 .",
    "first , since @xmath302 , whenever @xmath311 we know that @xmath271 .",
    "since @xmath194 is a model ( indeed , it is an answer set ) it is an interpretation ( and thus consistent ) .",
    "therefore , if @xmath271 then surely @xmath312 .",
    "now , if we were to have @xmath313 , then applying the immediate consequence operator on the rule @xmath314 found in the component program @xmath315 would force us to have @xmath316 which results in a contradiction .",
    "hence we find that @xmath317 . by definition  [ def : simulateextended ] we know that @xmath318 and thus , by the definition of the reduct , we know that @xmath319 .",
    "then we find that @xmath320 since all the rules in @xmath321 have fresh literals in the head and literals from @xmath315 in the body and hence can not interact with the rules from @xmath322 which only depend on information derived from @xmath322 and @xmath315 in their bodies .",
    "recall from the definition of an answer set of a communicating program that @xmath323 . since we already found that @xmath317 we must have @xmath324 , or , because of the definition of @xmath193 , that @xmath270 .",
    "hence when determining the reduct @xmath325 , the extended situated literals in @xmath326 will be deleted .    in a similar way of reasoning , since @xmath304 and because @xmath309 we know from the construction of @xmath193 that @xmath260 .",
    "hence when determining the reduct , the situated literals in @xmath17 will be deleted . finally , since @xmath327 and because @xmath328 we know from the construction of @xmath193 that @xmath329 . clearly , when determining the reduct , none of the situated literals in @xmath20 will be deleted as they are @xmath153-local .",
    "hence the reduct of the communicating rule ( @xmath330 ) is the rule @xmath331 .",
    "this completes the first part of the proof .",
    "suppose @xmath255 for some @xmath196 . by the definition of the reduct",
    "we know that there is some rule of the form @xmath258 such that @xmath259 and @xmath260 is a set of situated literals of the form @xmath261 with @xmath262 , @xmath263 . from definition  [ def : simulateextended ] , we know that the communicating normal rule @xmath264 is transformed into the rule @xmath265 with @xmath266 , @xmath267 and @xmath268 .",
    "we show that , indeed , @xmath255 reappears in @xmath256 under the form @xmath257 when @xmath332 is total _",
    "_  @xmath202 for all @xmath196 .",
    "first , since @xmath260 we know from the construction of @xmath193 that @xmath333 whenever @xmath334 . also , when @xmath269 , we know that @xmath270 since @xmath259 . from the construction of @xmath193 we then know that @xmath317 and since @xmath194 is an answer set we readily obtain that @xmath312 due to the construction of @xmath315 . together with the requirement that @xmath335 is total",
    "_ w.r.t . _",
    "we then must have that @xmath271 .",
    "hence when determining the reduct  @xmath274 , the extended situated literals in @xmath275 and @xmath276 will be deleted .",
    "finally , whenever @xmath277 we know from the construction of @xmath194 that @xmath278 whenever @xmath279 . clearly , when determining the reduct , none of these extended situated literals will be deleted as they are @xmath151-local .",
    "hence it is clear that the reduct of the communicating rule ( @xmath280 ) is the rule @xmath281 .",
    "this completes the second part of the proof .",
    "converse let @xmath176 and let @xmath191 with @xmath71 a communicating normal program and @xmath200 the communicating simple program that simulates @xmath52 .",
    "assume that @xmath194 is an answer set of @xmath200 and that @xmath201 is total _",
    "_  @xmath202 for all @xmath196 .",
    "then the interpretation @xmath193 defined in lemma  [ lem : reverseanalogousanswerset ] is an answer set of @xmath52 .",
    "lemma  [ lem : reverseanalogousanswerset ] tells us that @xmath197 where we have @xmath199 .",
    "hence we have @xmath337 since repeatedly applying the immediate consequence operator must conclude the same literals  @xmath4 due to the correspondence of the rules in the reducts and because of the way @xmath338 is defined .",
    "since we defined @xmath193 as @xmath339 it follows immediately that @xmath193 is an answer set of @xmath52 since @xmath340 which completes the proof .",
    "we know from proposition  [ prop : one - simple - is - polynomial ] that we can always find a globally minimal answer of @xmath71 in polynomial time .",
    "due to the way we defined the immediate fixpoint operator @xmath108 this operator only makes true the information that is absolutely necessary , _ i.e. _  the minimal amount of information that can be derived ( for each component program ) .",
    "it is then easy to see that no component program can derive any less information ( we have no negation - as - failure ) and thus that this globally minimal answer set is also locally minimal and thus a @xmath341-focused answer set of @xmath71 .",
    "qbf let @xmath342 and @xmath52 be as in definition  [ def : simulation - qbf ] .",
    "we have that a qbf @xmath342 of the form @xmath134 is satisfiable if and only if @xmath343 is true in some @xmath344-focused answer set of @xmath71 .",
    "furthermore , we have that a qbf @xmath342 of the form @xmath139 is satisfiable if and only if @xmath343 is true in all @xmath344-focused answer sets of @xmath71 .",
    "we give a proof by induction .",
    "assume we have a qbf @xmath345 of the form @xmath346 with @xmath347 the communicating normal program corresponding with @xmath345 according to  definition  [ def : simulation - qbf ] .",
    "if the formula @xmath348 of the qbf @xmath345 is satisfiable then we know that there is a @xmath349-focused answer set @xmath193 of @xmath350 such that @xmath351 . otherwise , we know that @xmath352 for all @xmath349-answer sets @xmath193 of @xmath350 .",
    "hence the induction hypothesis is valid for @xmath353 .",
    "assume the result holds for any qbf @xmath354 of the form @xmath355 .",
    "we show in the induction step that it holds for any qbf @xmath356 of the form @xmath357 .",
    "let @xmath358 and @xmath359 be the communicating normal programs that correspond with @xmath356 and @xmath354 , respectively .",
    "note that the component programs @xmath360 are defined in exactly the same way as the component programs @xmath361 , the only difference being the name of the component programs .",
    "what is of importance in the case of @xmath362 is therefore only the additional rules in @xmath363 and the new component program @xmath168 .",
    "the additional rules in @xmath363 merely generate the corresponding interpretations , where we now need to consider the possible interpretations of the variables from @xmath364 as well .",
    "the rules in the new component program @xmath168 ensure that @xmath365 whenever @xmath366 and @xmath367 whenever @xmath368 for every @xmath193 an answer set of @xmath52 and @xmath369 . depending on @xmath136 being even or odd , we get two distinct cases :      if @xmath136 is even , then we have @xmath370 and we know that the qbf  @xmath362 has the form @xmath371 .",
    "let us consider what happens when we determine the @xmath372-focused answer sets of @xmath52 . due to the construction of @xmath168 , we know that @xmath373 can only hold for two answer sets @xmath194 and @xmath193 of @xmath52 if @xmath194 and @xmath193 correspond to identical interpretations of the variables in @xmath374 .",
    "furthermore , @xmath373 is only possible if @xmath375 while @xmath376 .",
    "now note that given an interpretation of the variables in @xmath374 , there is exactly one answer set for each choice of @xmath364 .",
    "when we have @xmath194 with @xmath376 this implies that there is an interpretation such that , for some choice of @xmath364 , this particular assignment of values of the qbf does not satisfy the qbf .",
    "similarly , if we have @xmath193 with @xmath375 then the qbf is satisfied for that particular choice of @xmath364 .",
    "determining @xmath372-focused answer sets of @xmath52 will eliminate @xmath193 since @xmath373 .",
    "in other words , for identical interpretations of the variables in @xmath374 , the answer set @xmath194 encodes a counterexample that shows that for these interpretations it does not hold that the qbf is satisfied for all choices of @xmath364 .",
    "focusing thus eliminates those answer sets that claim that the qbf is satisfiable for the variables in @xmath374 .",
    "when we can not find such @xmath373 this is either because none of the interpretations satisfy the qbf or all of the interpretations satisfy the qbf . in both cases , there is no need to eliminate any answer sets .",
    "we thus effectively mimic the requirement that the qbf @xmath362 should hold for @xmath377 . +    if @xmath136 is odd , then @xmath378 and we know that the qbf @xmath362 has the form @xmath379 . as before , we know that @xmath373 can only hold for two answer sets @xmath194 and @xmath193 of @xmath52 if @xmath194 and @xmath193 correspond to identical interpretations of the variables in @xmath374",
    ". however , this time @xmath373 is only possible if @xmath380 while @xmath381 .",
    "if we have @xmath193 with @xmath380 then the qbf is not satisfied for that particular choice of @xmath364 , whereas when @xmath194 with @xmath381 this implies that there is an interpretation such that , for some choice of @xmath364 , this particular assignment of the variables does satisfy the qbf .",
    "determining @xmath372-focused answer sets of @xmath52 will eliminate @xmath193 since @xmath373 .",
    "for identical interpretations of the variables in @xmath374 , the answer set @xmath194 encodes a counterexample that shows that for these interpretations there is some choice of @xmath364 such that the qbf is satisfied .",
    "focusing thus eliminates those answer sets that claim that the qbf is not satisfiable for the variables in @xmath374 .",
    "when we can not find such @xmath373 this is either because none of the interpretations satisfy the qbf or all of the interpretations satisfy the qbf . in both cases , there is no need to eliminate any answer sets .",
    "we effectively mimic the requirement that the qbf @xmath362 should hold for @xmath382 .    for a qbf of the form @xmath383 , with @xmath384",
    "if @xmath136 is even and @xmath385 otherwise , the proof is analogous . in the base case , we know that a qbf @xmath345 of the form @xmath386 is satisfiable only when for every @xmath349-focused answer set @xmath193 of @xmath347 we find that @xmath351 . otherwise , we know that there exists some @xmath349-focused answers sets @xmath193 of @xmath350 such that @xmath352 .",
    "hence the induction hypothesis is valid for @xmath353 .",
    "the induction step is then entirely analogous to what we have proven before , with the only difference being that the cases for @xmath136 being even or odd are swapped . finally ,",
    "since the first quantifier is @xmath387 , we need to verify that @xmath343 is true in every @xmath344-focused answer set of @xmath71 .",
    "focused - complete let @xmath52 be a communicating normal program with @xmath388 .",
    "the problem of deciding whether there exists a @xmath241-focused answer set @xmath193 of @xmath71 such that @xmath240 ( brave reasoning ) is in @xmath242 .",
    "we show the proof by induction on @xmath136 . in the case where @xmath353",
    ", we need to guess a @xmath372-focused answer set @xmath193 of @xmath71 which can clearly be done in polynomial time .",
    "we now need to verify that this is indeed a @xmath372-focused answer set which is a problem in @xmath123 . indeed , verifying that",
    "@xmath193 is not a @xmath372-focused answer set can be done using the following procedure in @xmath1 :            hence , to find a @xmath389-focused answer set , we guess an interpretation , verify that it is an answer set in polynomial time , and we subsequently use an @xmath1  oracle to decide whether this answer set is @xmath389-focused , _ i.e. _  the problem is in @xmath215 .",
    "assume that there exists an algorithm to compute the @xmath344-focused answer sets of @xmath52 that is in @xmath138 .",
    "in a similar fashion , we can guess a @xmath241-focused answer set and verify there is no @xmath241-focused answer set @xmath194 of @xmath71 such that @xmath390 using a @xmath125 oracle , _",
    "i.e. _  the algorithm is in @xmath391 .",
    "simple - complete let @xmath52 be a communicating simple program with @xmath388 .",
    "the problem of deciding whether there exists a @xmath241-focused answer set @xmath193 of @xmath71 such that @xmath240 ( brave reasoning ) is in @xmath242 .",
    "we know from  proposition  [ prop : partialanswerset ] that one normal program can be simulated by a communicating simple program with two component programs .",
    "since only the program @xmath363 in the simulation in  definition  [ def : simulation - qbf ] includes negation - as - failure , it suffices to add a single simple component program in order to simulate the negation - as - failure .",
    "since the number of component programs is of no importance in  proposition  [ prop : focused - complete ] , the result readily follows .",
    "disjunctive - complete let @xmath52 be a communicating disjunctive program with @xmath388 .",
    "the problem of deciding whether @xmath240 with @xmath193 a @xmath241-focused answer set of @xmath71 is in @xmath392 .",
    "this result can easily be verified by looking at the proof of proposition  [ prop : focused - complete ] and noticing that the only part of the algorithm that is affected by the use of communicating disjunctive programs @xmath52 is the base step . in this base step ,",
    "we use an oracle in @xmath143 to check whether our guess @xmath193 is indeed an answer set of @xmath71 . since @xmath193 is an answer set of @xmath71 iff @xmath393 and since @xmath153 is a disjunctive component program we know that we will instead need an oracle in @xmath144 to deal with communicative disjunctive programs .",
    "the remainder of the algorithm sketch remains unaffected .                                          ,",
    "ianni , g. , schindlauer , r. , and tompits , h. 2006 .",
    "dlvhex : a tool for semantic - web reasoning under the answer - set semantics . in _ proceedings of international workshop on proceedings of alpsws06_. 3339 .    ,",
    "guziolowski , c. , ivanchev , m. , schaub , t. , siegel , a. , thiele , s. , and veber , p. 2010 .",
    "repair and prediction ( under inconsistency ) in large biological networks with answer set programming . in _ proceedings of kr10_."
  ],
  "abstract_text": [
    "<S> answer set programming ( asp ) is a form of declarative programming that allows to succinctly formulate and efficiently solve complex problems . </S>",
    "<S> an intuitive extension of this formalism is communicating asp , in which multiple asp programs collaborate to solve the problem at hand . </S>",
    "<S> however , the expressiveness of communicating asp has not been thoroughly studied . in this paper </S>",
    "<S> , we present a systematic study of the additional expressiveness offered by allowing asp programs to communicate . </S>",
    "<S> first , we consider a simple form of communication where programs are only allowed to ask questions to each other . </S>",
    "<S> for the most part , we deliberately only consider simple programs , _ </S>",
    "<S> i.e. _  programs for which computing the answer sets is in  @xmath0 . </S>",
    "<S> we find that the problem of deciding whether a literal is in some answer set of a communicating asp program using simple communication is @xmath1-hard . </S>",
    "<S> in other words : we move up a step in the polynomial hierarchy due to the ability of these simple asp programs to communicate and collaborate . </S>",
    "<S> second , we modify the communication mechanism to also allow us to focus on a sequence of communicating programs , where each program in the sequence may successively remove some of the remaining models . </S>",
    "<S> this mimics a network of leaders , where the first leader has the first say and may remove models that he or she finds unsatisfactory . using this particular communication mechanism allows us to capture the entire polynomial hierarchy . </S>",
    "<S> this means , in particular , that communicating asp could be used to solve problems that are above the second level of the polynomial hierarchy , such as some forms of abductive reasoning as well as pspace - complete problems such as strips planning .    </S>",
    "<S> [ firstpage ]    logic programming , answer set programming , multi - agent reasoning </S>"
  ]
}