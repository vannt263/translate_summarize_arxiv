{
  "article_text": [
    "[ cols=\"<,<,<\",options=\"header \" , ]     open multiprocessing ( openmp or omp @xcite ) and message passing interface ( mpi ) are two strategies for using multiple processors for a single problem .",
    "the key difference between them is that in mpi , different nodes have their own memory and they communicate with each other when needed ; but with openmp , the memory is shared between threads .",
    "here is an example .",
    "suppose we have a two dimensional lattice with 4 sites in each direction , and we are using four nodes or threads , as shown below .",
    "+    1in@cc@cc 1&2&3&4 + 5&6&7&8 +   + 9&10&11&12 + 13&14&15&16",
    "+    suppose node / thread 1 corresponds to sites 1 , 2 , 5 and 6 .",
    "in mpi , node 1 has information only about sites on that node , namely 1 , 2 , 5 and 6 .",
    "if it needs information about other sites , for example about sites 3 or 7 which are nearest neighbors of sites 2 and 6 respectively , it has to use communication routines .",
    "contrast this with openmp , where all threads have access to data for all sites , but thread 1 does computations only for sites 1 , 2 , 5 and 6 .",
    "table 1 summarizes the differences between the two strategies . a trend towards shared memory parallel machines or clusters of symmetric multiprocessing ( smp ) nodes rather than the older paradigm of massively parallel processing ( mpp ) machines makes a study of openmp parallelism timely .",
    "openmp was designed to exploit certain characteristics of shared - memory architectures .",
    "the ability to directly access memory throughout the system ( with minimum latency and no explicit address mapping ) combined with very fast shared memory locks , makes shared - memory architectures best suited for supporting openmp .",
    "the advantage of openmp is that it is easier to program . unlike mpi",
    ", one does not have to worry about passing messages between nodes . in this paper , we study how openmp performs relative to mpi , and whether combining the two strategies gives better performance .",
    "in this section , we give some details about how a c code that works for a single processor is changed to work on multiple threads .",
    "the number of threads is determined by an environment variable , ` omp_num_threads ` .",
    "the code is executed serially , on a single thread , until a parallel construct is encountered , which is executed on multiple threads and then serial execution is resumed . to define a parallel construct ,",
    "lines beginning with ` # pragma omp ` are added to the code .",
    "such pragmas are ignored by the usual c compiler , so the code may also be run as an ordinary serial code .",
    "they are , however , interpreted by an openmp compiler to identify parallel regions .",
    "there are several constructs that can be made to execute in parallel ; here is an example for a `` ` for ` '' construct .",
    "+ ` # pragma omp parallel for for(i=0;i <",
    "n;i++ ) { my_job(i ) ; } `    this will run the function ` my_job ` in parallel on different threads .",
    "note that though the memory is shared , each thread must have a private copy of some variables , like ` i ` in the above example .",
    "loop variables are made private by default but other such variables have to be declared `` ` private ` '' .",
    "some variables may need to be summed over all the sites .",
    "this is accomplished with a ` reduction ` statement .",
    "the syntax is as follows : +   + ` j=0 ; ` + ` # pragma omp parallel for reduction(+:j ) ` + ` for(i=0;i <",
    "n;i++ ) { j+=my_function(i ) ; } `    this is equivalent to + @xmath0 .",
    "+   + note that the sum is performed over all threads though each thread works only on part of the total number of iterations .",
    "identifying ` private ` and ` reduction ` variables is necessary for getting correct results .",
    "the milc @xcite code is a set of publicly available codes developed by the mimd lattice computation ( milc ) collaboration for doing qcd simulations .",
    "this code has been run on a variety of parallel computers , using mpi , for many physics projects .",
    "the files are organized in different directories  the ` libraries ` directory contains low level routines like matrix multiplication , the ` generic ` directory contains oft - needed but somewhat higher level routines , including the updating and inversion routines .",
    "then there are various application directories .",
    "for this project , we only concentrated on the conjugate gradient inverter , file ` d_congrad5.c ` in ` generic_ks ` directory in version 6 of milc code .",
    "the code uses a macro ` forallsites ` defined as + ` # define forallsites(i , s)\\backslash for(i=0,s = lattice;i",
    "< sites_on_node;\\backslash i++,s++ ) ` + where ` lattice ` is an array of sites , ` site ` is a structure containing variables defined at each lattice point and ` sites_on_node ` is the number of lattice points on a given node .",
    "we needed to redefine the macro ` forallsites ` because the openmp compiler we used could not deal with two variables ( ` i ` and ` s ` ) in a parallel ` for ` statement .",
    "here is the macro redefinition .",
    "+ ` # define forallsites(i , s)\\backslash for(i=0;i < sites_on_node;i++){\\backslash s=&(lattice[i ] ) ; `    we used another macro ` end_loop ` , which is just defined to be a closing brace ` } ` to match the opening brace in the above macro .",
    "we used the kap / pro toolset @xcite for this project .",
    "it includes the following :    * ` guidec ` : openmp compiler for c. * ` guideview ` : openmp parallel performance visualization tool .",
    "it gives details of program execution , in particular , time spent in serial and parallel execution , imbalance in different regions of the code , etc .",
    "* ` assurec ` : compiler to be used with debugger which works by comparing single thread and multiple thread executions . * ` assureview ` : openmp programming correctness tool for viewing details of errors or conflicts which occur if different threads try to read / write the same variables at the same time .",
    "to add openmp parallelism to the milc code , the following steps were required .",
    "first , we had to redefine the macro as explained above .",
    "then we added the parallel for pragmas , specifying ` private ` and ` reduction ` variables .",
    "for example , in the ` forallsites ` loop , ` s ` was made ` private ` .",
    "we changed ` cc ` to ` guidec ` in our makefiles , and we had to modify those compiler options that ` guidec ` did not recognize . adding ` backend ` before a compiler option forces ` guidec ` to use ` cc ` compiler options .",
    "then , we ran ` assurec ` and ` assureview ` to locate and remove conflicts .",
    "finally , we ran the executable on different number of threads and verified that the output agreed with the mpi output .    even after one has a working openmp code , there are some issues to consider when comparing its performance with that of mpi .",
    "some performance problems are openmp issues , while others are not .",
    "if single thread openmp performance does not match that with a single node under mpi , that may indicate a culprit other than openmp .",
    "for example , thread safe compilation requires the ` -mt ` switch on sun .",
    "if using this switch on the original serial code decreases performance substantially , then the performance issue lies with the sun compiler and its runtime libraries , not with openmp . if the code uses many ` malloc / free ` pairs then thread - safe memory allocation is likely the culprit .",
    "again , this is not an openmp issue , but an issue with the quality of the vendor s thread - safe compiler / runtime implementation .",
    "we verified that the ` -mt ` option on the serial version on sun did not affect the performance significantly . except for the case where we combine openmp and mpi , no ` malloc / free ` statements are used in the region of the code where the performance is evaluated .",
    "thus , to the best of our knowledge , this is a fair comparison between openmp and mpi performance .",
    "we first ran the modified codes on a sun e10000 at indiana university .",
    "the details of architecture for this computer can be found online @xcite .",
    "benchmarks were done for various lattice sizes and numbers of threads .",
    "as the number of threads increased , the lattice dimensions were increased to keep the volume per thread constant at @xmath1 .",
    "the number of threads @xmath2 was increased from 1 to 16 by factors of 2 .",
    "for example , for a given @xmath3 , the lattice size for 2 threads is @xmath4 and for 16 threads it is @xmath5 .",
    "@xmath3 was increased from 4 to 14 in steps of 2 .",
    "reported in fig .",
    "1 is the performance on the kogut - susskind quark conjugate gradient routine in megaflop / s per cpu for both omp and mpi . for smaller number of threads / nodes , the omp rates are quite comparable to mpi .",
    "they lag behind for larger number of threads .",
    "there are two factors involved here : the overhead for setting up threads and the use of the cache . for small lattice sizes , since there is only a small number of computations to be performed , the former degrades the performance , but if significant portion of the problem can fit in the cache , the execution is speeded up . on the other hand , for larger lattices",
    "the thread initialization overhead is a much smaller fraction of the total computation time , but the problem size is too big to fit into the cache .",
    "we see that omp has a `` sweet spot '' at size 6 , much as the mpi performance peaks at size 8 .",
    "since we keep the load per thread constant , for the same lattice size the performance monotonically decreases in most cases as we increase the number of threads .",
    "= 7.0 cm = 6.0 cm    = 7.0 cm = 6.0 cm    next we benchmarked the code on blue horizon @xcite .",
    "this ibm sp machine at the san diego supercomputer center has 8-way smp nodes but with the current switch can support only 4 mpi processes per node .",
    "figure 2 contains the preliminary results from blue horizon .",
    "these results are qualitatively similar to the e10000 results .",
    "a hybrid approach combining openmp parallelism within mpi processes may offer better performance than either individual approach .",
    "we tried different combinations of threads and mpi processes on blue horizon .",
    "the hybrid approach fared better at times .",
    "figure  3 shows the results for a total of eight processors .",
    "it can be seen again that the mpi performance peaks at size 8 ( the left - most bars in fig .",
    "3 ) and the omp at size 6 ( the right - most bars ) . the combination of 2 threads and 4 nodes works best for smaller sizes .",
    "the processors on blue horizon were upgraded after these runs .",
    "we should repeat these calculations and extend the study to a larger number of cpus .",
    "= 7.0 cm = 6.0 cm",
    "on both computers studied , openmp performance was very similar to mpi performance for a small number of threads , but it deteriorated much faster as the number of threads increased , for smaller lattice sizes .",
    "thus , openmp may be a viable option for someone writing a code to be used with a modest number of processors on smp machines .",
    "the milc collaboration , however , already has a working mpi code that scales well on many machines . for almost all the combinations of problem sizes and number of cpus studied in this paper , mpi is at least as good as openmp , if not better .",
    "the only case where we get a considerable improvement over mpi is when we combine openmp and mpi on blue horizon for @xmath6 and 6 .",
    "not only does the hybrid approach give the best performance on a single smp node , it should allow us to run multi - node jobs using all eight processors on each node rather than the limit of four with the current switch .",
    "we have added openmp parallelism to the milc code only for the conjugate gradient inverter for this test project .",
    "it will require considerably more effort to modify the whole code to run on multiple openmp threads .",
    "it is our pleasure to thank bill magro and henry gabbs at kai for many useful discussions .",
    "we gratefully acknowledge the help provided by the staff at research and technical services at iu , especially david hart , mary papakhian and stephanie burks .",
    "this work was supported by the doe under grant de - f002 - 91er 40661 .",
    "we thank the san diego supercomputer center and npaci for use of blue horizon ."
  ],
  "abstract_text": [
    "<S> a trend in high performance computers that is becoming increasingly popular is the use of symmetric multiprocessing ( smp ) rather than the older paradigm of mpp . </S>",
    "<S> mpi codes that ran and scaled well on mpp machines can often be run on an smp machine using the vendor s version of mpi . </S>",
    "<S> however , this approach may not make optimal use of the ( expensive ) smp hardware . </S>",
    "<S> more significantly , there are machines like blue horizon , an ibm sp with 8-way smp nodes at the san diego supercomputer center that can only support 4 mpi processes per node ( with the current switch ) . on such a machine </S>",
    "<S> it is imperative to be able to use openmp parallelism on the node , and mpi between nodes . </S>",
    "<S> we describe the challenges of converting milc mpi code to using a second level of openmp parallelism , and benchmarks on ibm and sun computers . </S>"
  ]
}