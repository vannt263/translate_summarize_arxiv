{
  "article_text": [
    "recursion is one of the central ideas of computer science .",
    "most programming languages support recursion or at least a special form of recursion such as while - loop .",
    "recursion has also been considered since the very beginning of the studies of quantum programming ; for example , selinger @xcite introduced the notion of recursive procedure in his functional quantum programming language qpl and defined the denotational semantics of recursive procedures in terms of complete partial orders of super - operators .",
    "termination of quantum while - loops were analysed by ying and feng @xcite in the case of finite - dimensional state spaces .",
    "a quantum generalisation of etessami and yannakakis s recursive markov chains was proposed by feng et .",
    "al .  @xcite .",
    "but the control flows of all of the quantum recursions studied in the previous literatures are classical because branchings in them are determined by the outcomes of certain quantum measurements , which are classical information .",
    "so , they can be appropriately called _ classical recursion of quantum programs_.    quantum control flow was first introduced by altenkirch and grattage @xcite by defining a quantum case statement in their quantum programming language qml that implements a unitary transformation by decomposing it into two orthogonal branches along an orthonormal basis of a chosen qubit .",
    "motivated by the construction of quantum walks @xcite , @xcite , a different approach to quantum control flow was proposed by the author in @xcite , @xcite where a kind of quantum case statement was defined by employing an external quantum coin .",
    "furthermore , the notion of quantum choice was defined as the sequential composition of a coin tossing  program and a quantum case statement .",
    "the quantum control flow of programs is clearly manifested in these quantum case statement and quantum choice .",
    "this paper introduces a new notion of quantum recursion using quantum case statements and quantum choices .",
    "in contrast to the recursions in quantum programming considered before , the control flows of this kind of quantum recursions are quantum rather than classical .",
    "interestingly , this notion of quantum recursion enables us to construct a new class of quantum walks , called recursive quantum walks , whose behaviours seem very different from the quantum walks defined in the previous literatures .    in this paper , we define the operational and denotational semantics of quantum recursions . the equivalence between these two semantics of quantum recursions are established .",
    "obviously , how to define the semantics of quantum recursions is a question that can be asked within the basic framework of quantum mechanics .",
    "but surprisingly , answering it requires the mathematical tools from second quantisation @xcite because variable number of identical particles are employed to implement the quantum coins  involved in the computation of a quantum recursion .",
    "this paper is organised as follows . to make the paper self - contained , in section [ qcqc ] we recall the notions of quantum case statement and quantum choice from @xcite , @xcite .",
    "the syntax of quantum recursive programs is defined in section [ sec - syn ] . to give the reader a clearer picture",
    ", we choose not to include quantum measurements in the declarations of quantum recursions in this paper .",
    "it seems that quantum measurements can be added by combining the ideas used in this paper and those in @xcite , @xcite , but the presentation will be very complicated . in section [ rewk ] ,",
    "recursive quantum walks are considered as an example for further motivating the notion of quantum recursion . in particular , it is carefully explained that a formal description of the behaviour of recursive quantum walks requires the second quantisation method - a mathematical framework in which we are able to depict quantum systems with variable number of particles .",
    "for convenience of the reader , the basics of second quantisation is briefly reviewed in section [ sqq ] .",
    "we define the semantics of quantum recursions in two steps . the first step is carried out in section [ sema ] where we construct a domain of operators in the free fock space and prove continuity of semantic functionals of quantum programs with procedure identifiers .",
    "then recursive equations are solved in the free fock space by introducing the creation functional and by employing the standard fixed point theorem .",
    "the second step is completed in section [ recover ] where the solutions of recursive equations are symmetralised so that they can apply in the physically meaningful framework , namely the symmetric and antisymmetric fock spaces of bosons and fermions . a special class of quantum recursions , namely quantum while - loops with quantum control flow are examined in section [ qwlo ] .",
    "a short conclusion is drawn in section [ con1 ] with several problems for further studies .",
    "case statement in classical programming languages is a very useful program construct for case analysis , see @xcite for example .",
    "a quantum extension of case statement was defined in terms of measurements in various quantum programming languages , for example , sanders and zuliani s qgcl @xcite , @xcite and selinger s qpl @xcite .",
    "the author defined another quantum case statement using external quantum coin  and further introduced quantum choice as a variant of quantum case statement in @xcite , @xcite . in this section",
    ", we recall these two program constructs from @xcite .",
    "let us start from the simplest case - a quantum counterpart of if ... then ... else .",
    "assume that @xmath0 is a qubit of which the state hilbert space @xmath1 has @xmath2 , @xmath3 as an orthonormal basis .",
    "furthermore , assume that @xmath4 and @xmath5 are two unitary transformations acting on a quantum system @xmath6 of which the state hilbert space is @xmath7 .",
    "the system @xmath6 is called the principal quantum system .",
    "the action of @xmath4 on system @xmath6 can be thought of as a quantum program and is denoted @xmath8 $ ] .",
    "similarly , we write @xmath9 $ ] for the action of @xmath5 on @xmath6 . then a kind of quantum if ... then ... else  can be defined by employing qubit @xmath0 as a quantum coin , and it is written as : @xmath10\\ |0\\rangle\\rightarrow u_0[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\square\\ |1\\rangle\\rightarrow u_1[q]\\\\ & \\mathbf{fiq}\\end{split}\\ ] ] in a way similar to dijktra s guarded commands @xcite .",
    "the semantics of statement ( [ qc1 ] ) is an unitary operator @xmath11 on the tensor product @xmath12 ( i.e. the state hilbert space of the composed system of coin  @xmath0 and principal system @xmath6 ) defined by @xmath13 for any @xmath14 in @xmath7 .",
    "it can be represented by the following diagonal matrix @xmath15 we call @xmath16 the guarded composition of @xmath4 and @xmath5 along with basis @xmath17 .",
    "moreover , let @xmath18 be a unitary operator in the state hilbert space @xmath1 of the coin  @xmath0 .",
    "the action of @xmath18 on @xmath0 can also be thought of as a program and is denoted @xmath19 $ ] .",
    "then the quantum choice of @xmath8 $ ] and @xmath9 $ ] with coin - tossing  @xmath19 $ ] is defined to be @xmath20;\\ & \\mathbf{qif}\\ [ c]\\ |0\\rangle\\rightarrow u_0[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\square\\ |1\\rangle\\rightarrow u_1[q]\\\\ & \\mathbf{fiq}\\end{split}\\ ] ] here and in the sequel , @xmath21 denotes the sequential composition of programs @xmath22 and @xmath23 ; that is , program @xmath22 followed by program @xmath23 . using a notation similar to probabilistic choice in a probabilistic programming language like pgcl @xcite , program ( [ qc2 ] )",
    "can be written as @xmath24\\oplus_{v[c ] } u_1[q]\\ ] ] obviously , the semantics of quantum choice ( [ qc3 ] ) is the unitary matrix @xmath25 where @xmath26 is the identity operator in @xmath7 .",
    "the idea of defining quantum if ... then ... else  using quantum coin  was actually borrowed from quantum walks . here",
    ", let us consider the one - dimensional quantum walks @xcite as an example .",
    "[ ex1 ] the simplest random walk is the one - dimensional walk in which a particle moves on a lattice marked by integers @xmath27 , and at each step it moves one position left or right , depending on the flip of a fair coin .",
    "the hadamard walk is a quantum variant of the one - dimensional random walk .",
    "its state hilbert space is @xmath28 , where @xmath29 , @xmath30 are used to indicate the direction left and right , respectively , @xmath31 , and @xmath32 indicates the position marked by integer @xmath32 .",
    "one step of the hadamard walk is represented by the unitary operator @xmath33 , where the translation @xmath34 is a unitary operator in @xmath28 defined by @xmath35 for every @xmath36 , @xmath37 is the hadamard transform in the direction space @xmath38 , and @xmath39 is the identity operator in the position space @xmath40 .",
    "the hadamard walk is described by repeated applications of operator @xmath41 .",
    "now let us see how the idea of quantum case statement and quantum choice disguises in the construction of the hadamard walk .",
    "if we define the left and right translation operators @xmath42 and @xmath43 in the position space @xmath40 by @xmath44 for each @xmath36 , then the translation operator @xmath34 can be broken into a quantum case statement of @xmath42 and @xmath43 : @xmath45\\ |l\\rangle\\rightarrow t_l[p]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |r\\rangle\\rightarrow t_r[p]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\mathbf{fiq}\\end{split}\\ ] ] where @xmath46 is a direction coin , and @xmath47 is a variable used to denote the position .",
    "furthermore , the single - step walk operator @xmath41 can be seen as the quantum choice @xmath48\\oplus_{h[d]}t_r[p].\\ ] ]    recently , physicists have been very interested in implementing quantum control for unknown subroutines @xcite , @xcite , @xcite , which is essentially a quantum if ... then ... elseor a quantum choice .",
    "we now generalise the quantum case statement ( [ qc1 ] ) and quantum choice ( [ qc2 ] ) to the case with more than two branches .",
    "let @xmath49 and @xmath0 denote an @xmath50level quantum system with state hilbert space @xmath51 . for each @xmath52 ,",
    "let @xmath53 be a unitary operator or _ the zero operator _ in the state hilbert space @xmath7 of the principal system @xmath6 .",
    "using system @xmath0 as a quantum coin , we can define a quantum case statement : @xmath54\\ ( \\square i\\cdot |i\\rangle\\rightarrow u_i[q])\\ \\mathbf{qif } = \\mathbf{qif}\\ [ c]\\ |0\\rangle\\rightarrow u_0[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |1\\rangle\\rightarrow u_1[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ .......... \\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |n-1\\rangle\\rightarrow u_{n-1}[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\mathbf{fiq}\\end{split}\\ ] ] the reason for allowing some of @xmath53 s being the zero operator is that if @xmath55 $ ] is a program containing recursion then it may not terminate . in the case that @xmath53 is the zero operator , we usually drop of the @xmath56th branch of the statement ( [ qc4 ] ) .",
    "furthermore , let @xmath18 be a unitary operator in the coin  space @xmath1",
    ". then we can define a quantum choice : @xmath57\\ ( \\bigoplus_i |i\\rangle\\rightarrow u_i[q ] ) = v[c ] ; \\mathbf{qif}\\ [ c]\\ ( \\square i\\cdot |i\\rangle\\rightarrow u_i[q])\\ \\mathbf{qif}\\ ] ] the semantics of quantum case statement ( [ qc4 ] ) is the unitary operator @xmath58 in @xmath12 defined by @xmath59 for any @xmath52 and @xmath14 in @xmath7 .",
    "the operator @xmath16 is called the guarded composition of @xmath53 s along with basis @xmath60 .",
    "it is represented by the diagonal matrix @xmath61 the semantics of quantum choice ( [ qc5 ] ) is then the operator @xmath62 , where @xmath26 is the identity operator in @xmath7 .",
    "quantum walks on a graph @xcite can be conveniently expressed in terms of the above generalised quantum case statement and choice , as shown in the following :    [ ex2 ] a random walk on a directed graph @xmath63 is described by repeated applications of stochastic matrix @xmath64 , where @xmath65 where @xmath66 is the outgoing degree of @xmath67 , i.e. the number of edges outgoing from @xmath67 . in particular , if @xmath68 is @xmath69regular , i.e. all nodes have the same degree @xmath46 , then @xmath70 for all @xmath71 .",
    "a quantum walk on graph @xmath68 is a quantum counterpart of the random walk .",
    "let @xmath72 be the hilbert space spanned by states corresponding to the vertices in @xmath68 .",
    "we now assume that @xmath68 is @xmath69regular .",
    "then each edge in @xmath68 can be labelled by a number among @xmath73 so that for any @xmath74 , the edges labelled @xmath75 form a permutation . let @xmath76 be an auxiliary hilbert space of dimension @xmath46 , called the coin space .",
    "the shift operator @xmath77 is defined in @xmath78 by @xmath79 for @xmath74 and @xmath80 , where @xmath81 is the @xmath82th neighbour of @xmath83 , i.e. the vertex reached from @xmath83 through the outgoing edge labelled @xmath75 .",
    "furthermore , let @xmath84 be a unitary operator in @xmath85 , called the coin - tossing operator .",
    "then one step of the quantum walk is modelled by the operator @xmath86 , where @xmath39 is the identity operator in @xmath87 .",
    "the quantum walk is described by repeated applications of @xmath41 .",
    "if for each @xmath74 , we define the @xmath82th shift operator @xmath88 in @xmath87 by @xmath89 for any @xmath80 , then the shift operator @xmath77 can be seen as a quantum case statement : @xmath90\\ ( \\square a\\cdot |a\\rangle\\rightarrow s_a[q])\\ \\mathbf{qif}\\\\ = \\ & \\mathbf{qif}\\ [ c]\\ |1\\rangle\\rightarrow s_1[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\square\\ |2\\rangle\\rightarrow s_2[q]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ .......... \\\\ & \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |d\\rangle\\rightarrow s_{d}[q]\\\\ & \\mathbf{fiq}\\end{split}\\ ] ] where @xmath0 and @xmath6 are two variables denoting quantum systems with state spaces @xmath85 and @xmath87 , respectively .",
    "consequently , the single - step walk operator @xmath41 is the quantum choice : @xmath91 ( \\bigoplus_a |a\\rangle\\rightarrow s_a[q])\\ ] ]    the quantum case statement ( [ qc4 ] ) and quantum choice ( [ qc5 ] ) can be further generalised to the case where unitary transformations @xmath8 , u_1[q], ... ,u_{n-1}[q]$ ] are replaced by general quantum programs that may contain quantum measurements .",
    "it is quite involved to define the semantics of such general quantum case statement and choice ; for details we refer to @xcite , @xcite .",
    "a new notion of quantum recursion with quantum control flow can be defined based on quantum case statement and quantum choice discussed in the last section . in this short section ,",
    "we formally define the syntax of quantum recursive programs .",
    "we assume two sets of quantum variables : principal system variables , ranged over by @xmath92 , and coin  variables , ranged over by @xmath93 .",
    "these two sets are required to be disjoint .",
    "we also assume a set of procedure identifiers , ranged over by @xmath94",
    ". then program schemes are defined by the following syntax : @xmath95\\ |\\ \\mathbf{qif}\\ [ c ] ( \\square i\\cdot |i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}\\ ] ] where :    * @xmath96 is a procedure identifier ; programs @xmath97 and @xmath98 are the same as in a classical programming language ; @xmath99 is the sequential composition of @xmath100 and @xmath101 . * in unitary transformation @xmath102 $ ] , @xmath103 a sequence of coin  variables , @xmath104 is a sequence of principal system variables , and @xmath16 is a unitary operator in the state hilbert space of the system consisting of @xmath103 and @xmath104 .",
    "we will always put coin  variables before principal system variables .",
    "both of @xmath103 and @xmath104 are allowed to be empty .",
    "when @xmath103 is empty , we simply write @xmath105 $ ] for @xmath102 $ ] and it describes the evolution of the principal system @xmath104 ; when @xmath104 is empty , we simply @xmath106 $ ] for @xmath102 $ ] and it describes the evolution of the coins  @xmath103 . if both @xmath103 and @xmath104 are not empty , then @xmath102 $ ] describes the interaction between coins  @xmath103 the principal system @xmath104 . * in quantum case statement @xmath107 ( \\square i\\cdot |i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}$ ] , @xmath0 is a coin  variable , and @xmath60 is an orthonormal basis of the state hilbert space of @xmath0 .",
    "it is required not to occur in all the subprograms @xmath108 s because according to its physical interpretation , a coin  is always external to the principal system .",
    "this program construct is a generalisation of equation ( [ qc4 ] ) .    as a generalisation of equation ( [ qc5 ] ) ,",
    "the program construct of quantum choice can be defined in terms of quantum case statement and sequential composition .",
    "let @xmath22 be a program contains only coin  @xmath0 , let @xmath60 be an orthonormal basis of the state hilbert space of @xmath0 , and let @xmath108 be a program for each @xmath56 .",
    "then the quantum choice of @xmath108 s according to @xmath22 along the basis @xmath60 is defined as @xmath109\\bigoplus_{i}\\left(|i\\rangle \\rightarrow p_i\\right)\\stackrel{\\triangle}{=}p ; \\mathbf{qif}\\ [ c ] \\left(\\square i\\cdot |i\\rangle \\rightarrow p_i\\right)\\ \\mathbf{fiq}.\\ ] ] if the coin  is a qubit , then quantum choice ( [ quch ] ) can be abbreviated as @xmath110 intuitively , quantum choice ( [ quch ] ) runs a coin - tossing  subprogram @xmath22 followed by an alternation of a family of subprograms @xmath111 the coin - tossing  subprogram @xmath22 creates a superposition of the execution paths of @xmath112 and during the execution of the alternation , each @xmath108 is running along its own path , but the whole program is executed in a superposition of execution paths of @xmath111 this picture can be imaginatively termed as the _ superposition - of - programs _ paradigm .",
    "the semantics of quantum programs without procedure identifiers ( and thus without recursion ) can be easily defined .",
    "the principal system of a quantum program @xmath22 is the composition of the systems denoted by principal variables appearing in @xmath22 .",
    "we write @xmath113 for the state hilbert",
    "space of the principal system .",
    "[ seman - w]the semantics @xmath114 of a program @xmath22 without procedure identifiers is inductively defined as follows :",
    "1 .   if @xmath115 , then @xmath116 ( the zero operator in @xmath113 ) , and if @xmath117 , then @xmath118 ( the identity operator in @xmath113 ) ; 2 .",
    "if @xmath22 is an unitary transformation @xmath102 $ ] , then @xmath114 is the unitary operator @xmath16 ( in the state hilbert space of the system consisting of @xmath103 and @xmath104 ) ; 3 .",
    "if @xmath119 , then @xmath120 ; 4 .",
    "if @xmath121(\\square i\\cdot|i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}$ ] , then @xmath122 ( see equation ( [ qccq ] ) for the special case of unitary operators ) .    finally , we can define the syntax of quantum recursive programs .",
    "if a program scheme contains at most the procedure identifiers @xmath123 , then we write @xmath124.$ ]    [ recp - df ]    1 .",
    "let @xmath123 be different procedure identifiers .",
    "a declaration for @xmath123 is a system of equations : @xmath125 where for every @xmath126 , @xmath127 $ ] is a program scheme containing at most procedure identifiers @xmath123 .",
    "a recursive program consists of a program scheme @xmath124 $ ] , called the main statement , and a declaration @xmath128 for @xmath123 such that all coin  variables in @xmath22 do not appear in @xmath128 ; that is , they do not appear in the procedure bodies @xmath129 .",
    "the requirement in the above definition that the coins  in the main statement @xmath22 and those in the declaration @xmath128 are distinct is obviously necessary because a coin  used to define a quantum case statement is always considered to be external to its principal system .",
    "now the question is : how to define the semantics of quantum recursive programs ?",
    "as a motivating example of quantum recursive program , let us consider a variant of quantum walks , called recursive quantum walks . for simplicity , we focus on the recursive hadamard walk - a modification of example [ ex1 ] .",
    "recursive quantum walks on a graph can be defined by modifying example [ ex2 ] in a similar way .",
    "recall that the single - step operator @xmath41 of the hadamard walk is a quantum choice , which is the sequential composition of a coin - tossing  hadamard operator @xmath130 on the direction coin  @xmath46 and translation operator @xmath34 on the position variable @xmath47 .",
    "the translation @xmath131 $ ] is a quantum case statement that selects left or right translations according to the basis states @xmath132 of the coin  @xmath46 . if @xmath46 is in state @xmath133 then the walker moves one position left , and if @xmath46 is in state @xmath134 then it moves one position right .",
    "an essential difference between a random walk and a quantum walk is that the coin  of the latter can be in a superposition of the basis states @xmath132 , and thus a superposition of left and right translations @xmath135 $ ] and @xmath136 $ ] is created .",
    "the hadamard walk is then defined in a simple way of recursion with the single - step operator @xmath41 , namely repeated applications of @xmath41 .",
    "now we modify slightly the hadamard walk using a little bit more complicated recursion .",
    "[ ex3 ]    1 .",
    "the unidirectionally recursive hadamard walk first runs the coin - tossing  hadamard operator @xmath137 $ ] and then a quantum case statement : if the direction coin  @xmath46 is in state @xmath133 then the walker moves one position left , and if @xmath46 is in state @xmath134 then it moves one position right , followed by * a procedure behaving as the recursive walk itself*. in the terminology of programming languages , the recursive hadamard walk is defined to a program @xmath96 declared by the following recursive equation : @xmath138 \\oplus_{h[d ] } ( t_r[p];x)\\ ] ] where @xmath139 are the direction and position variables , respectively .",
    "the bidirectionally recursive hadamard walk first runs the coin - tossing  hadamard operator @xmath137 $ ] and then a quantum case statement : if the direction coin  @xmath46 is in state @xmath133 then the walker moves one position left , followed by * a procedure behaving as the recursive walk itself * , and if @xmath46 is in state @xmath134 then it moves one position right , also followed by * a procedure behaving as the recursive walk itself*. more precisely , the walk can be defined to be the program @xmath96 declared by the following two recursive equations : @xmath140;x)\\oplus_{h[d]}(t_r[p];x).\\ ] ] 3 .",
    "a variant of the bidirectionally recursive hadamard walk is the program @xmath96 ( or @xmath141 ) declared by the following system of recursive equations : @xmath142\\oplus_{h[d ] } ( t_r[p ] ; y),\\\\ y\\leftarrow ( t_l[p];x)\\oplus_{h[d ] } t_r[p].\\end{cases}\\ ] ] 4 .",
    "note that we used the same coin  @xmath46 in the two equations of ( [ ddrhw ] ) .",
    "if two different coins  @xmath46 and @xmath143 are used , then we have another variant of the bidirectionally recursive hadamard walk specified by @xmath144\\oplus_{h[d ] } ( t_r[p ] ; y),\\\\ y\\leftarrow ( t_l[p];x)\\oplus_{h[e ] } t_r[p].\\end{cases}\\ ] ] 5 .",
    "we can define a recursive quantum walk in another way if quantum case statement with three branches is employed : @xmath145;\\ & \\mathbf{qif}\\ [ d]\\ |l\\rangle\\rightarrow t_l[p]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\square\\ |r\\rangle\\rightarrow t_r[p]\\\\ & \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |i\\rangle\\rightarrow x\\\\ & \\mathbf{fiq}\\end{aligned}\\ ] ] where @xmath46 is not a qubit but a qutrit with state space @xmath146 , @xmath147 stand for the directions left and right , respectively , and @xmath39 for iteration , and @xmath16 is a @xmath148 unitary matrix , e.g. the @xmath149dimensional fourier transform : @xmath150    now let us have a glimpse of the behaviours of recursive quantum walks .",
    "we use @xmath151 to denote the empty program or termination .",
    "a configuration is defined to be a pair @xmath152 with @xmath22 being a program or the empty program @xmath151 , and @xmath14 a pure state of the quantum system .",
    "then the behaviour of a program can be visualised by a sequence of transitions between superpositions of configurations . here",
    ", we only consider the unidirectionally recursive quantum walk @xmath96 declared by equation ( [ rhw ] ) .",
    "assume that it is initialised in state @xmath153 ; that is , the coin  is in direction @xmath154 and the walker is at position @xmath155 .",
    "then we have : @xmath156 here , @xmath157 , and new quantum coins  @xmath158 that are identical to the original coin  @xmath46 are introduced in order to avoid the conflict of variables for coins .",
    "the above recursive quantum walks are good examples of quantum recursion , but their behaviours are not very interesting .",
    "it has been well - understood that the major difference between the behaviours of classical random walks and quantum walks is caused by quantum interference - two separate paths leading to the same point may be out of phase and cancel one another @xcite .",
    "it is clear from equation ( [ bdhw ] ) that quantum interference does not happen in the unidirectionally recursive quantum walk .",
    "similarly , no quantum interference occurs in the bidirectionally recursive quantum walks defined in the above example .",
    "the following is a much more interesting recursive quantum walk that shows a new phenomenon of quantum interference : the paths that are cancelled in a quantum walk are finite .",
    "however , it is possible that infinite paths are cancelled in a recursive quantum walk .",
    "let @xmath49 .",
    "a variant of unidirectionally recursive quantum walk can be defined as the program @xmath96 declared by the following recursive equation : @xmath159\\oplus_{h[d ] } t_r[p])^n ; ( ( t_l[p];x)\\oplus_{h[d ] } ( t_r[p];x))\\ ] ] here , we use @xmath160 to denote the sequential composition of @xmath32 @xmath22 s .",
    "now let us look at the behaviour of this walk .",
    "we assume that the walk is initialised in state @xmath153 .",
    "then the first three steps of the walk are given as follows : @xmath161\\\\   & \\rightarrow \\frac{1}{2}[(x_2,|l\\rangle_d|-2\\rangle_p)+(x_2,|r\\rangle_d|0\\rangle_p)+(x_2,|l\\rangle_d|0\\rangle_p)-(x_2,|r\\rangle_d|2\\rangle_p)]\\\\   & \\rightarrow \\frac{1}{2\\sqrt{2}}[(x_3,|l\\rangle_d|-3\\rangle_p)+(x_3,|r\\rangle_d|-1\\rangle_p)+(x_3,|l\\rangle_d|-1\\rangle_p)-(x_3,|r\\rangle_d|1\\rangle_p )   \\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ + ( x_3,|l\\rangle_d|-1\\rangle_p)+(x_3,|r\\rangle_d|1\\rangle_p)-(x_3,|l\\rangle_d|1\\rangle_p)+(x_3,|r\\rangle_d|3\\rangle_p)]\\\\   & = \\frac{1}{2\\sqrt{2}}[(x_3,|l\\rangle_d|-3\\rangle_p)+(x_3,|r\\rangle_d|-1\\rangle_p)+2(x_3,|l\\rangle_d|-1\\rangle_p)\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ -(x_3,|l\\rangle_d|1\\rangle_p)+(x_3,|r\\rangle_d|3\\rangle_p ) ]   \\end{split}\\ ] ] where @xmath162\\oplus_{h[d ] } t_r[p])^{n - i } ; ( ( t_l[p];x)\\oplus_{h[d ] } ( t_r[p];x))\\ ] ] for @xmath163 .",
    "we observe that in the last step of equation ( [ qintw-0 ] ) two configurations @xmath164 and @xmath165 cancel one another in the last part of the above equation .",
    "it is clear that both of them can generate infinite paths because they contain the recursive walk @xmath96 itself .",
    "the behaviour of the recursive program specified by the following equation : @xmath166\\oplus_{h[d ] } t_r[p])^n ; ( ( t_l[p];x)\\oplus_{h[d ] } ( t_r[p];x))\\ ] ] is even more puzzling .",
    "note that equation ( [ qintw-1 ] ) is obtained from equation ( [ qintw ] ) by changing the order of the two subprograms in its right - hand side .",
    "we have already seen the first steps of the recursive quantum walks . but a precise description of their behaviours amounts to solving recursive equations ( [ rhw ] ) , ( [ drhw ] ) , ( [ ddrhw ] ) and ( [ qintw ] ) . in mathematics , a standard method for finding the least solution to an equation @xmath167 with @xmath168 being a function from a lattice into itself is as follows : let @xmath169 be the least element of the lattice .",
    "we take the iterations of @xmath168 starting from @xmath169 : @xmath170 if @xmath168 is monotone and the lattice is complete , then the limit @xmath171 of iterations exists ; and furthermore if @xmath168 is continuous , then this limit is the least solution of the equation . in the theory of programming languages @xcite , a syntactic variant of this method",
    "is employed to define the semantics of a recursive program declared by , say , equation @xmath172 , where @xmath173 is presented in a syntactic rather than semantic way : let @xmath174\\ { \\rm for}\\ n\\geq 0.\\end{cases}\\ ] ] where @xmath175 $ ] is the result of substitution of @xmath96 in @xmath176 by @xmath177 .",
    "the program @xmath177 is called the @xmath32th syntactic approximation of @xmath96 . roughly speaking , the syntactic approximations @xmath177 @xmath178 describe the initial fragments of the behaviour of the recursive program @xmath96 .",
    "then the semantics @xmath179 of @xmath96 is defined to be the limit of the semantics @xmath180 of its syntactic approximations",
    "@xmath177 : @xmath181 now we apply this method to the unidirectionally recursive hadamard walk and construct its syntactic approximations as follows : @xmath182\\oplus_{h[d ] } ( t_r[p];\\mathbf{abort}),\\\\ & x^{(2)}=t_l[p]\\oplus_{h[d ] } ( t_r[p];t_l[p]\\oplus_{h[d_1 ] } ( t_r[p];\\mathbf{abort})),\\\\ & x^{(3)}=t_l[p]\\oplus_{h[d ] } ( t_r[p];t_l[p]\\oplus_{h[d_1 ] } ( t_r[p];t_l[p]\\oplus_{h[d_2 ] } ( t_r[p];\\mathbf{abort}))),\\\\ & ............ \\end{split}\\ ] ] however , a problem arises in constructing these approximations : we have to continuously introduce new coin  variables in order to avoid variable conflict ; that is , for every @xmath183 , we introduce a new coin  variable @xmath184 in the @xmath185th syntactic approximation .",
    "obviously , variables @xmath186 must denote identical particles .",
    "moreover , the number of the coin  particles that are needed in running the recursive hadamard walk is usually unknown beforehand because we do not know when the walk terminates .",
    "it is clear that this problem appears only in the quantum case but not in the theory of classical programming languages because it is caused by employing an external coin  system in defining a quantum case statement .",
    "therefore , a solution to this problem requires a mathematical framework in which we can deal with quantum systems where the number of particles of the same type - the coins  - may vary .",
    "fortunately , physicists had developed a formalism for describing quantum systems with variable particle number , namely second quantisation , more than eighty years ago . for convenience of the reader ,",
    "we recall basics of the second quantum method in this section .",
    "let @xmath113 be the state hilbert space of one particle .",
    "for any @xmath187 , we write @xmath188 for the @xmath50fold tensor product of @xmath113 .",
    "if we introduce the vacuum state @xmath189 , then the @xmath190fold tensor product of @xmath113 can be defined as the one - dimensional space @xmath191 .",
    "furthermore , the free fock space over @xmath113 is defined to be the direct sum @xcite : @xmath192    the principle of symmetrisation in quantum physics @xcite indicates that the states of @xmath32 identical particles are either completely symmetric or completely antisymmetric with respect to the permutations of the particles .",
    "these particles are called bosons in the symmetric case and fermions in the antisymmetric case . for each permutation @xmath193 of @xmath194",
    ", we define the permutation operator @xmath195 in @xmath188 by @xmath196 for all @xmath197 in @xmath113 .",
    "furthermore , we define the symmetrisation and antisymmetrisation operators in @xmath188 as follows : @xmath198 where @xmath193 ranges over all permutations of @xmath194 , and @xmath199 is the signature of the permutation @xmath193 . for @xmath200 and any @xmath197 in @xmath113 , we write @xmath201 then the state space of @xmath32 bosons and that of fermions are @xmath202 for @xmath203 respectively . if we set @xmath204 , then the space of the states of variable particle number is the symmetric or antisymmetric fock space : @xmath205 where @xmath206 for bosons and @xmath207 for fermions",
    ". the elements of the fock space @xmath208 ( resp . the free fock space @xmath209 )",
    "are of the form @xmath210 with @xmath211 ( resp .",
    "@xmath212 ) for @xmath213 and @xmath214 .      for each @xmath187 , let @xmath215 be an operator in @xmath188 .",
    "then operator @xmath216 is defined in the free fock space @xmath209 as follows : @xmath217 for any @xmath218 in @xmath209 , where @xmath219 ; that is , the vacuum state is considered to be an eigenvector of operator @xmath220 with eigenvalue @xmath155 .",
    "if for each @xmath221 and for each permutation @xmath193 of @xmath194 , @xmath195 and @xmath215 commute ; that is , @xmath222 then operator @xmath220 is said to be symmetric . a symmetric operator @xmath223 is an operator both in the symmetric fock space @xmath224 and in the antisymmetric fock space @xmath225 : @xmath226 for @xmath200 .",
    "we can introduce the symmetrisation functional @xmath227 that maps every operator @xmath223 to a symmetric operator : @xmath228 where for each @xmath221 , @xmath229 with @xmath193 traversing over all permutations of @xmath194 .",
    "if for each @xmath230 , the operator @xmath215 in equation ( [ fockop ] ) is an observable of @xmath32 particles , then @xmath220 is an extensive observable in the free fock space @xmath231 . in particular , let us consider one - body observables .",
    "assume that @xmath232 is a single - particle observable .",
    "then we can define one - body observable @xmath233 for the system of @xmath32 particles , where @xmath234 ( with @xmath39 being the identity operator in @xmath113 ) is the action of @xmath232 on the @xmath235th factor of the tensor product @xmath188 ; that is , @xmath236 for all @xmath237 in @xmath113 .",
    "it is easy to see that @xmath215 commutes with the permutations : @xmath238 therefore , @xmath239 is symmetric .",
    "it is called a one - body observable in the fock space @xmath208 for @xmath200 .",
    "similarly , we can define a @xmath240body observable with @xmath241 .",
    "let the ( discrete - time ) evolution of one particle is represented by unitary operator @xmath16 .",
    "then the evolution of @xmath32 particles without mutual interactions can be described by operator @xmath242 in @xmath188 : @xmath243 for all @xmath197 in @xmath113 .",
    "it is easy to verify that @xmath244 commutes with the permutations : @xmath245 so , the symmetric operator @xmath246 depicts the evolution of particles without mutual interactions in the fock space @xmath208 for @xmath200 .      the operator @xmath247 defined by equation ( [ fockop ] ) maps states of @xmath32 particles to states of particles of the same number .",
    "the transitions between states of different particle numbers are described by the creation and annihilation operators .",
    "to each one - particle state @xmath14 in @xmath113 , we associate the creation operator @xmath248 in @xmath208 defined by @xmath249 for any @xmath221 and all @xmath197 in @xmath113 . this operator adds a particle in the individual state @xmath14 to the system of @xmath32 particles without modifying their respective states .",
    "the annihilation operator @xmath250 is defined to be the hermitian conjugate of @xmath248 , and it is not difficult to show that @xmath251 intuitively , operator @xmath250 decreases the number of particles by one unit , while preserving the symmetry of the state .",
    "second quantisation provides us with the necessary tool for defining the semantics of quantum recursions .",
    "we first show how to solve recursive equations in the free fock spaces without considering symmetry or antisymmetry of the particles that are used to implement the quantum coins .",
    "let @xmath84 be a set of quantum coins . for each @xmath252 ,",
    "let @xmath1 be the state hilbert space of coin  @xmath0 and @xmath253 the free fock space over @xmath1 .",
    "we write @xmath254 we also assume that @xmath113 is the state hilbert space of the principal system .",
    "let @xmath255 be the set of nonnegative integers .",
    "then @xmath256 is the set of @xmath257indexed tuples of nonnegative integers : @xmath258 with @xmath259 for all @xmath252 , and we have : @xmath260 we write @xmath261 for the set of all operators of the form @xmath262 where @xmath263 is an operator in @xmath264 for each @xmath265 . recall that a binary relation @xmath266 on a nonempty set @xmath77 if it is reflexive , transitive and antisymmetric . in this case",
    ", we often call @xmath267 or even simply @xmath77 a partial order .",
    "we define a partial order @xmath268 on @xmath256 as follows : @xmath269 if and only if @xmath270 for all @xmath252 .",
    "a subset @xmath271 is said to be below - closed if @xmath272 and @xmath273 imply @xmath274 .",
    "we define the _ flat order _",
    "@xmath266 on @xmath275 as follows : for any @xmath276 and @xmath277 in @xmath275 ,    * @xmath278 if and only if there exists a below - closed subset @xmath271 such that @xmath279 for all @xmath272 and @xmath280 for all @xmath281 .",
    "let @xmath267 be a partial order .",
    "a nonempty subset @xmath282 is called a chain if for any @xmath283 , it holds that @xmath284 or @xmath285 .",
    "a partial order is said to be complete if it has the least element and every chain @xmath34 in it has the least upper bound @xmath286 .",
    "[ cpo - d ] @xmath287 is a complete partial order ( cpo ) .",
    "first , @xmath266 is reflexive because @xmath256 itself is below - closed . to show that @xmath266 is transitive , we assume that @xmath278 and @xmath288 . then there exist below - closed @xmath289 such that    1 .",
    "@xmath279 for all @xmath272 and @xmath280 for all @xmath281 ; 2 .",
    "@xmath290 for all @xmath291 and @xmath292 for all @xmath293 .",
    "clearly , @xmath294 is below - closed , and @xmath295 for all @xmath296 . on the other hand ,",
    "if @xmath297 $ ] , then either @xmath281 and it follows from clause 1 that @xmath280 , or @xmath298 and by combining clauses 1 and 2 we obtain @xmath299 . therefore , @xmath300 . similarly , we can prove that @xmath266 is antisymmetric .",
    "so , @xmath301 is a partial order .",
    "obviously , the operator @xmath302 with @xmath280 ( the zero operator in @xmath264 ) for all @xmath265 is the least element of @xmath287 .",
    "now it suffices to show that any chain @xmath303 in @xmath301 has the least upper bound . for each @xmath56",
    ", we put @xmath304 here @xmath305 is the below - completion of @xmath306 .",
    "furthermore , we define operator @xmath307 as follows:@xmath308    _ claim _ 1 : @xmath220 is well - defined ; that is , if @xmath309 and @xmath310 , then @xmath311 . in fact , since @xmath303 is a chain , we have @xmath312 or @xmath313 we only consider the case of @xmath312 ( the case of @xmath314 is proved by duality ) .",
    "then there exists below - closed @xmath271 such that @xmath311 for all @xmath272 and @xmath280 for all @xmath281 .",
    "it follows from @xmath309 that @xmath315 for some @xmath316 with @xmath317 . since @xmath318 , i.e. @xmath274 , we have @xmath272 because @xmath319 is below - closed .",
    "so , @xmath311 .",
    "_ claim _ 2 : @xmath320 .",
    "in fact , for each @xmath56 , @xmath305 is below - closed , and @xmath321 for all @xmath309 and @xmath322 for all @xmath323 .",
    "so , @xmath324 , and @xmath220 is an upper bound of @xmath303 .",
    "now assume that @xmath325 is an upper bound of @xmath303 : for all @xmath56 , @xmath326 ; that is , there exists below - closed @xmath327 such that @xmath328 for all @xmath329 and @xmath322 for all @xmath330 by the definition of @xmath306 and below - closeness of @xmath331 , we know that @xmath332 .",
    "we take @xmath333 .",
    "clearly , @xmath319 is below - closed , and if @xmath281 , then @xmath280 . on the other hand , if @xmath272 , then for some @xmath56 , we have @xmath309 , and it follows that @xmath329 and @xmath334",
    ". therefore , @xmath278 .",
    "@xmath335    for any operators @xmath302 and @xmath336 in @xmath275 ,",
    "their product is naturally defined as @xmath337 which is also in @xmath275 .",
    "we can define guarded composition of operators in fock spaces by extending equation ( [ qccq ] ) .",
    "let @xmath252 and @xmath60 be an orthonormal basis of @xmath1 , and let @xmath338 be an operator in @xmath275 for each @xmath56 .",
    "then the guarded composition of @xmath339 s along with the basis @xmath60 is @xmath340 note that for each @xmath265 , @xmath341 is an operator in @xmath342 and thus @xmath343 . recall that a mapping @xmath168 from a cpo @xmath344 into another cpo @xmath345 is said to be continuous if for any chain @xmath34 in @xmath346 , its image @xmath347 under @xmath168 has the least upper bound and @xmath348 .",
    "the following lemma shows that both product and guarded composition of operators in the free fock space are continuous .",
    "[ contin - lem ] let @xmath349 , @xmath350 and @xmath351 for each @xmath56 be chains in @xmath287",
    ". then    1 .",
    "@xmath352 2 .",
    "@xmath353    we only prove part 2 .",
    "the proof of part 1 is similar . for each @xmath56 , we assume that @xmath354 by the construction of least upper bound in @xmath287 given in the proof of lemma [ cpo - d ] , we can write @xmath355 for some @xmath356 with @xmath357 for every @xmath56 . by appending zero operators to the end of shorter summations , we may further ensure that @xmath358 s for all @xmath56 are the same , say @xmath359 .",
    "then by the defining equation ( [ ffgu ] ) we obtain : @xmath360      let @xmath124 $ ] be a program scheme .",
    "we write @xmath84 for the set of coins  occuring in @xmath22 . for each @xmath252 , let @xmath1 be the state hilbert space of quantum coin  @xmath0 . as said in section [ sec - syn ] , the principal system of @xmath22 is the composition of the systems denoted by principal variables appearing in @xmath22 . let @xmath113 be the state hilbert space of the principal system .",
    "[ sdf ] the semantic functional of program scheme @xmath22 is a mapping @xmath361 for any operators @xmath362 , @xmath363 is inductively defined as follows :    1 .   if @xmath364 then @xmath365 is the zero operator in @xmath302 with @xmath280 ( the zero operator in @xmath264 ) for all @xmath265 ; 2 .   if @xmath366 , then @xmath365 is the identity operator @xmath302 with @xmath367 ( the identity operator in @xmath264 ) for all @xmath265 with @xmath368 for every @xmath252 ; 3 .   if @xmath369 $ ] , then @xmath365 is the cylindrical extension of @xmath16 : @xmath302 with @xmath370 , where : 1 .",
    "@xmath371 is the identity operator in the state hilbert space of those coins  that are not in @xmath103 ; 2 .",
    "@xmath372 is the identity operator in @xmath373 ; and 3 .",
    "@xmath374 is the identity operator in the state hilbert space of those principal variables that are not in @xmath104 for all @xmath187 ; 4 .",
    "if @xmath375 @xmath376 , then @xmath377 ; 5 .",
    "if @xmath119 , then @xmath378 ( see the defining equation ( [ ffp ] ) of product of operators in the free fock space ) ; 6 .   if @xmath121(\\square i\\cdot |i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}$ ] , then @xmath379 ( see the defining equation ( [ ffgu ] ) of guarded composition of operators in the free fock space ) .    whenever @xmath380",
    "; that is , @xmath22 contains no procedure identifiers , then the above definition degenerates to definition [ seman - w ] .    the cartesian power @xmath381 is naturally equipped with the order @xmath266 defined componently from the order in @xmath261 : for any @xmath382 ,    * @xmath383 if and only if for every @xmath126 , @xmath384    then @xmath385 is a cpo too .",
    "furthermore , we have :    [ continuity-1 ] ( * continuity of semantic functionals * ) the semantic functional @xmath386 is continuous",
    ".    it can be easily proved by induction on the structure of @xmath22 using lemma [ contin - lem ] .",
    "@xmath335    for each coin  @xmath252 , we introduce the creation functional : @xmath387 defined as follows : for any @xmath388 , @xmath389 where @xmath390 is the identity operator in @xmath1 .",
    "we observe that @xmath263 is an operator in @xmath391 @xmath392 , whereas @xmath393 is an operator in @xmath394 . intuitively , the creation functional @xmath395 moves all copies of @xmath1 one position to the right so that @xmath56th copy becomes @xmath396th copy for all @xmath397 thus , a new position is created at the left end for a new copy of @xmath1 . for other coins",
    "@xmath46 , @xmath395 does not move any copy of @xmath38 .",
    "it is clear that for any two coins  @xmath398 , @xmath395 and @xmath399 commute ; that is , @xmath400 .",
    "note that the set @xmath84 of coins  in @xmath22 is finite .",
    "suppose that @xmath401 .",
    "then we can define the creation functional @xmath402 for the special case where the set @xmath84 of coins  is empty , @xmath403 is the identity functional ; that is , @xmath404 for all @xmath220 .",
    "[ continuity-2 ] for each @xmath252 , the creation functionals @xmath395 and @xmath405 @xmath406 are continuous .",
    "straightforward by definition .",
    "@xmath335    combining continuity of semantic functional and the creation functional ( theorem [ continuity-1 ] and lemma [ continuity-2 ] ) , we obtain :    [ corr1 ] let @xmath124 $ ] be a program scheme and @xmath84 the set of coins  occurring in @xmath22",
    ". then the functional : @xmath407 for any @xmath408 , is continuous .",
    "now we are ready to define the denotational semantics of recursive programs using the standard fixed point technique .",
    "let us consider a recursive program @xmath22 declared by the system of recursive equations:@xmath409 where @xmath127 $ ] is a program scheme containing at most procedure identifiers @xmath123 for every @xmath126 .",
    "the system @xmath128 of recursive equations naturally induces a semantic functional : @xmath410 for all @xmath408 , where @xmath84 is the set of coins  appearing in @xmath128 ; that is , in one of @xmath129 .",
    "it follows from theorem 4.20 in @xcite and corollary [ corr1 ] that @xmath411 is continuous .",
    "then the knaster - tarski fixed point theorem asserts that @xmath412 has the least fixed point @xmath413    [ def - fis]the fixed point ( denotational ) semantics of the recursive program @xmath22 declared by @xmath128 is @xmath414 that is , if @xmath415 , then @xmath416 ( see definition [ sdf ] ) .",
    "we now turn to consider the syntactic approximation technique for defining the semantics of recursive programs . as discussed at the end of section [ rewk ] and",
    "further clarified in example [ ex4 ] , a problem that was not present in the classical case is that we have to carefully avoid the conflict of quantum coin  variables when defining the notion of substitution .",
    "to overcome it , we assume that each coin  variable @xmath252 has infinitely many copies @xmath417 with @xmath418 . the variables @xmath419 are used to represent a sequence of particles that are all identical to the particle @xmath418 .",
    "then the notion of program scheme defined in section [ sec - syn ] will be used in a slightly broader way : a program scheme may contain not only a coin  @xmath0 but also some of its copies @xmath419 .",
    "if such a generalised program scheme contains no procedure identifiers , then it is called a generalised program . with these assumptions ,",
    "we can introduce the notion of substitution .",
    "[ stut ] let @xmath124 $ ] be a generalised program scheme that contains at most procedure identifiers @xmath420 @xmath421 , and let @xmath422 be generalised programs without any procedure identifier .",
    "then the simultaneous substitution @xmath423 @xmath424 $ ] of @xmath123 by @xmath422 in @xmath22 is inductively defined as follows :    1 .   if @xmath425 or an unitary transformation , then @xmath426=p$ ] ; 2 .",
    "if @xmath427 @xmath428 , then @xmath426=q_i$ ] ; 3 .   if @xmath119 , then @xmath429=p_1[q_1/x_1, ...",
    ",q_m / x_m];p_2[q_1/x_1, ... ,q_m / x_m].\\ ] ] 4 .",
    "if @xmath121(\\square i\\cdot |i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}$ ] , then @xmath429=\\mathbf{qif}\\ [ c](\\square i\\cdot |i\\rangle\\rightarrow p_i^\\prime)\\ \\mathbf{fiq}\\ ] ] where for every @xmath56 , @xmath430 is obtained through replacing the @xmath235th copy @xmath431 of @xmath0 in @xmath432 @xmath433 $ ] by the @xmath434th copy @xmath435 of @xmath0 for all @xmath235 .",
    "note that in clause 4 of the above definition , since @xmath22 is a generalised program scheme , the coin  @xmath0 may not be an original coin  but some copy @xmath436 of an original coin  @xmath437 . in this case , the @xmath235th copy of @xmath0 is actually the @xmath438th copy of @xmath46 : @xmath439 for @xmath440    the semantics of a generalised program @xmath22 can be given using definition [ seman - w ] in the way where a coin  @xmath0 and its copies @xmath419 are treated as distinct variables to each other . for each coin  @xmath0 ,",
    "let @xmath441 be the greatest index @xmath32 such that the copy @xmath442 appears in @xmath22 .",
    "then the semantics @xmath114 of @xmath22 is an operator in @xmath264 .",
    "furthermore , it can be identified with its cylindrical extension in @xmath261 : @xmath443 where for each @xmath444 , @xmath445 is the identity operator in @xmath446 .",
    "based on this observation , the semantics of substitution defined above is characterised by the following :    [ lem - stut ] for any ( generalised ) program scheme @xmath124 $ ] and ( generalised ) programs @xmath422 , we have : @xmath447\\rrbracket & = ( \\mathbb{k}_c^{m}\\circ \\llbracket p\\rrbracket ) ( \\llbracket q_1\\rrbracket, ... ,\\llbracket q_m\\rrbracket)\\\\ & = \\llbracket p\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket)),\\end{aligned}\\ ] ] where @xmath448 is the creation functional with @xmath84 being the set of coins  in @xmath22 .",
    "we prove the lemma by induction on the structure of @xmath22 .",
    "@xmath115 , @xmath98 or an unitary transformation .",
    "obvious .",
    ". then @xmath426=q_m$ ] . on the other hand ,",
    "since the set of coins  in @xmath22 is empty , @xmath449 for all @xmath450 thus , by clause 4 of definition [ sdf ] we obtain : @xmath451\\rrbracket =   \\llbracket q_m\\rrbracket\\\\ & = \\llbracket p\\rrbracket ( \\llbracket q_1\\rrbracket, ... ,\\llbracket",
    "q_m\\rrbracket)= \\llbracket p\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket)).\\end{aligned}\\ ] ]    case 3 .",
    "then by clause 3 of definition [ seman - w ] , clause 5 of definition [ sdf ] and the induction hypothesis , we have : @xmath452\\rrbracket = \\llbracket p_1[q_1/x_1, ...",
    ",q_m / x_m];p_2[q_1/x_1, ...",
    ",q_m / x_m]\\rrbracket\\\\    & = \\llbracket p_2[q_1/x_1, ... ,q_m / x_m]\\rrbracket\\cdot \\llbracket p_1[q_1/x_1, ...",
    ",q_m / x_m]\\rrbracket\\\\   & = \\llbracket p_2\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket))\\cdot \\llbracket p_1\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ...",
    ",\\mathbb{k}_c(\\llbracket q_m\\rrbracket))\\\\ & = \\llbracket p_1;p_2\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ...",
    ",\\mathbb{k}_c(\\llbracket q_m\\rrbracket))\\\\ & = \\llbracket p\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket ) ) .",
    "\\end{aligned}\\ ] ]    case 4 .",
    "@xmath121(\\square i\\cdot |i\\rangle\\rightarrow p_i)\\ \\mathbf{fiq}$ ] .",
    "then @xmath429=\\mathbf{qif}\\ [ c](\\square i\\cdot |i\\rangle\\rightarrow p^\\prime_i)\\ \\mathbf{fiq},\\ ] ] where @xmath430 is obtained according to clause 4 of definition [ stut ] . for each @xmath56 , by the induction hypothesis we obtain : @xmath453\\rrbracket = \\llbracket p_i\\rrbracket ( \\mathbb{k}_{c\\setminus\\{c\\}}(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_{c\\setminus\\{c\\}}(\\llbracket q_m\\rrbracket))\\ ] ] because the coin  @xmath0 does not appear in @xmath430 .",
    "furthermore , it follows that @xmath454\\rrbracket)\\\\ & = \\mathbb{k}_c(\\llbracket p_i\\rrbracket ( \\mathbb{k}_{c\\setminus\\{c\\}}(\\llbracket q_1\\rrbracket), ...",
    ",\\mathbb{k}_{c\\setminus\\{c\\}}(\\llbracket q_m\\rrbracket)))\\\\ & = \\llbracket p_i\\rrbracket ( ( \\mathbb{k}_c\\circ \\mathbb{k}_{c\\setminus\\{c\\}})(\\llbracket q_1\\rrbracket), ...",
    ",(\\mathbb{k}_c\\circ \\mathbb{k}_{c\\setminus\\{c\\}})(\\llbracket q_m\\rrbracket))\\\\ & = \\llbracket p_i\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket ) ) .",
    "\\end{aligned}\\ ] ] therefore , by clause 4 of definition [ seman - w ] , clause 6 of definition [ sdf ] and equation ( [ ffgu ] ) , we have : @xmath447\\rrbracket & = \\sum_i \\left(|i\\rangle\\langle i|\\otimes \\llbracket p^\\prime_i\\rrbracket\\right)\\\\ & = \\square ( c,|i\\rangle\\rightarrow   \\llbracket p_i\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ...",
    ",\\mathbb{k}_c(\\llbracket q_m\\rrbracket))\\\\   & = \\llbracket p\\rrbracket ( \\mathbb{k}_c(\\llbracket q_1\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket q_m\\rrbracket)).\\   \\blacksquare\\end{aligned}\\ ] ]    the notion of syntactic approximation can be defined based on definition [ stut ] .    [ synap ]    1 .",
    "let @xmath123 be procedure identifiers declared by the system @xmath128 of recursive equations ( [ decla ] ) .",
    "then for each @xmath455 , the @xmath32th syntactic approximation @xmath456 of @xmath457 is inductively defined as follows:@xmath458\\ { \\rm for}\\ n\\geq 0.\\end{cases}\\ ] ] 2 .",
    "let @xmath124 $ ] be a recursive program declared by the system @xmath128 of equations ( [ decla ] ) .",
    "then for each @xmath221 , its @xmath32th syntactic approximation @xmath459 is inductively defined as follows : @xmath460\\ { \\rm for}\\ n\\geq 0.\\end{cases}\\ ] ]    syntactic approximation actually gives an operational semantics of quantum recursive programs .",
    "as in the theory of classical programming , substitution represents an application of the so - called _ copy rule _ - at runtime a procedure call is treated like the procedure body inserted at the place of call ( see , for example , @xcite ) . of course , simplification may happen within @xmath456 by operations of linear operators ; for example , @xmath461;x[q_2];c[q_1,q_2]$ ] can be replaced by @xmath462 $ ] , where @xmath463 are principal system variables , @xmath84 is the cnot gate and @xmath96 is the not gate . to simplify the presentation , we choose not to explicitly describe simplification .",
    "the major difference between the classical case and the quantum case is that in the latter we need to continuously introduce new coin  variables to avoid variable conflict when we unfold a quantum recursive program using its syntactic approximations : for each @xmath221 , a new copy of each coin  in @xmath464 is created in the substitution @xmath465 $ ] ( see clause 4 of definition [ stut ] ) .",
    "thus , a quantum recursive program should be understood as a quantum system with variable particle number and described in the second quantisation formalism .",
    "note that for all @xmath455 and @xmath221 , the syntactic approximation @xmath456 is a generalised program containing no procedure identifiers .",
    "thus , its semantics @xmath466 can be given by a slightly extended version of definition [ seman - w ] : a coin@xmath0 and its copies @xmath419 are allowed to appear in the same ( generalised ) program and they are considered as distinct variables . as before , the principal system is the composite system of the subsystems denoted by principal variables appearing in @xmath129 and its state hilbert space is denoted by @xmath113 .",
    "assume that @xmath84 is the set of coin  variables appearing in @xmath129 .",
    "for each @xmath252 , we write @xmath1 for the state hilbert space of quantum coin  @xmath0 .",
    "then it is easy to see that @xmath466 is an operator in @xmath467 , where @xmath468 .",
    "so , we can imagine that @xmath469 .",
    "furthermore , we have :    for each @xmath455 , @xmath470 is an increasing chain and thus @xmath471 exists in @xmath287 .",
    "we show that @xmath472 by induction on @xmath32 .",
    "the case of @xmath473 is trivial because @xmath474 . in general , by the induction hypothesis on @xmath475 and corollary [ corr1 ] , we have : @xmath476 where @xmath84 is the set of coins  in @xmath128",
    ". then existence of the least upper bound ( [ infty - v ] ) follows immediately from lemma [ cpo - d ] .",
    "@xmath335    [ def - ops]let @xmath22 be a recursive program declared by the system @xmath128 of equations ( [ decla ] ) .",
    "then its operational semantics is @xmath477    the operational semantics of recursive program @xmath22 can be characterised by the limit of its syntactic approximations ( with respect to its declaration @xmath128 ) .",
    "[ prop - sapp]@xmath478    it follows from lemma [ lem - stut ] that @xmath479\\rrbracket\\\\   & = \\bigsqcup_{n=0}^\\infty\\llbracket p\\rrbracket ( \\mathbb{k}_c(\\llbracket x_1^{(n)}\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket x_m^{(n)}\\rrbracket))\\end{aligned}\\ ] ] where @xmath448 is the creation functional with respect to the coins  @xmath84 in @xmath22 .",
    "however , all the coins  @xmath84 in @xmath22 do not appear in @xmath480 ( see the condition in definition [ recp - df].2 ) .",
    "so , @xmath481 for every @xmath455 , and by theorem [ continuity-1 ] we obtain : @xmath482    the equivalence between denotational and operational semantics of recursive programs is established in the following :    [ ss - equv ] ( * equivalence of denotational semantics and operational semantics * ) for any recursive program @xmath22 , we have @xmath483    by definitions [ def - fis ] and [ def - ops ] , it suffices to show that @xmath484 is the least fixed point of semantic functional @xmath412 , where @xmath128 is the declaration of procedure identifiers in @xmath22 . with theorem [ continuity-1 ] and lemmas [ continuity-2 ] and [ lem - stut ] , we obtain:@xmath485\\rrbracket\\\\   & = \\bigsqcup_{n=0}^\\infty \\llbracket p_k\\rrbracket ( \\mathbb{k}_c(\\llbracket x_1^{(n)}\\rrbracket), ...",
    ",\\mathbb{k}_c(\\llbracket x_m^{(n)}\\rrbracket))\\\\   & = \\llbracket p_k\\rrbracket \\left(\\mathbb{k}_c\\left(\\bigsqcup_{n=0}^\\infty\\llbracket x_1^{(n)}\\rrbracket\\right), ... ,\\mathbb{k}_c\\left(\\bigsqcup_{n=0}^\\infty\\llbracket x_m^{(n)}\\rrbracket\\right)\\right)\\\\ & = \\llbracket p_k\\rrbracket ( \\mathbb{k}_c(\\llbracket x_1^{(\\infty)}\\rrbracket), ... ,\\mathbb{k}_c(\\llbracket x_m^{(\\infty)}\\rrbracket))\\end{split}\\ ] ] for every @xmath455 , where @xmath84 is the set of coins  in @xmath128 .",
    "so , @xmath484 is a fixed point of @xmath412 . on the other hand ,",
    "if @xmath486 is a fixed point of @xmath412 , then we can prove that for every @xmath221 , @xmath487 by induction on @xmath32 .",
    "indeed , the case of @xmath473 is obvious . in general , using the induction hypothesis on @xmath475 , corollary [ corr1 ] and lemma [ lem - stut ] we obtain : @xmath488 therefore , it holds that @xmath489 and @xmath484 is the least fixed point of @xmath412 .",
    "@xmath335    in light of this theorem , we will simply write @xmath114 for both the denotational ( fixed point ) and operational semantics of a recursive program @xmath22 .",
    "but we should carefully distinguish the semantics @xmath490 of a recursive program @xmath124 $ ] declared by a system of recursive equations about @xmath123 from the semantic functional @xmath491 of program scheme @xmath124 $ ] .",
    "usually , such a difference can be recognised from the context .",
    "now let us reconsider the recursive quantum walks defined in section [ rewk ] .",
    "[ ex4 ] ( unidirectionally recursive hadamard walk ) the semantics of the @xmath32th approximation of the unidirectionally recursive hadamard walk specified by equation ( [ rhw ] ) is @xmath492\\ ] ] where @xmath157 , @xmath493 is the operator in @xmath494 defined from the hadamard operator @xmath130 by equation ( [ evo1 ] ) .",
    "this can be easily shown by induction on @xmath32 , starting from the first three approximations displayed in equation ( [ sap ] ) .",
    "therefore , the semantics of the unidirectionally recursive hadamard walk is the operator : @xmath495\\\\ & = \\left[\\sum_{i=0}^{\\infty}\\left(\\bigotimes_{j=0}^{i-1 } |r\\rangle_{d_j}\\langle r|\\otimes |l\\rangle_{d_i}\\langle l|\\right)\\otimes t_lt_r^i\\right]\\left(\\mathbf{h}\\otimes i\\right ) \\end{split}\\ ] ] in @xmath496 , where @xmath497 , @xmath498 , @xmath39 is the identity operator in the position hilbert space @xmath40 , @xmath493 is as in equation ( [ sem1 ] ) , and @xmath499 is the extension of @xmath130 in the free fock space @xmath500 over the direction hilbert space @xmath38 .",
    "[ exam - t ] ( bidirectionally recursive hadamard walk ) let us consider the semantics of the bidirectionally recursive hadamard walk declared by equation ( [ ddrhw ] ) . for any string @xmath501 of @xmath154 and @xmath502 , its dual is defined to be @xmath503 , where @xmath504 and @xmath505 .",
    "moreover , we write @xmath506 , @xmath507 and @xmath508 then the semantics of procedures @xmath96 and @xmath141 are @xmath509\\left(\\mathbf{h}\\otimes i_p\\right),\\\\ \\llbracket y\\rrbracket & = \\left[\\sum_{n=0}^{\\infty}\\left(\\rho_{\\overline{\\sigma_n}}\\otimes t^\\prime_n\\right)\\right]\\left(\\mathbf{h}\\otimes i_p\\right ) , \\end{split}\\ ] ] where @xmath510 is as in example [ ex4 ] , and @xmath511 @xmath512    it is clear from equations ( [ unidw ] ) and ( [ bidw ] ) that the behaviours of unidirectionally and bidirectionally recursive hadamard walks are very different : the unidirectionally one can go to any one of the positions @xmath513 , but the bidirectionally walk @xmath96 can only go to the positions @xmath514 and @xmath515 , and @xmath141 can only go to the positions @xmath516 and @xmath517 .",
    "the solutions of recursive equations found in the free fock space using the techniques developed in the last section can not directly apply to the symmetric fock space for bosons or the antisymmetric fock space for fermions because they may not preserve symmetry . in this section ,",
    "we consider symmetrisation of these solutions of recursive equations .",
    "we first examine the domain of symmetric operators in the fock spaces used in defining semantics of recursive programs . as in subsection",
    "[ domain ] , let @xmath113 be the state hilbert space of the principal system and @xmath84 the set of coins , and @xmath518 where @xmath255 is the set of nonnegative integers , and for each @xmath252 , @xmath253 is the free fock space over the state hilbert space @xmath1 of coin  @xmath0 . for any operator @xmath519",
    ", we say that @xmath220 is symmetric if for each @xmath520 , for each @xmath252 and for each permutation @xmath193 of @xmath521 , @xmath195 and @xmath263 commute ; that is , @xmath522 ( note that in the above equation @xmath195 actually stands for its cylindrical extension @xmath523 in @xmath524 , where @xmath525 is the identity operator in @xmath38 for every @xmath526 , and @xmath39 is the identity operator in @xmath113 . )",
    "we write @xmath527 for the set of symmetric operators",
    "@xmath528 .    @xmath529 as a sub - partial order of @xmath287 is complete",
    ".    it suffices to observe that symmetry of operators is preserved by the least upper bound in @xmath287 ; that is , if @xmath339 is symmetric , so is @xmath530 , as constructed in the proof of lemma [ cpo - d ] .",
    "@xmath335    now we generalise the symmetrisation functional defined by equations ( [ symz1 ] ) and ( [ symz2 ] ) into the space @xmath531 . for each @xmath265 , the symmetrisation functional @xmath227 over operators in the space @xmath264",
    "is defined by @xmath532\\ ] ] for every operator @xmath220 in @xmath264 , where @xmath533 traverses over all @xmath257indexed families with @xmath534 being a permutation of @xmath521 for every @xmath252 .",
    "this symmetrisation functional can be extended to @xmath275 in a natural way : @xmath535 for any @xmath519 . obviously , @xmath536 .",
    "furthermore , we have :    [ symm - lem ] the symmetrisation functional @xmath537 is continuous .",
    "what we need to prove is that @xmath538 for any chain @xmath303 in @xmath287 .",
    "assume that @xmath320 . then by the proof of lemma [ cpo - d ] , we can write @xmath539 and @xmath540 for some @xmath331 with @xmath541",
    ". so , it holds that @xmath542      now we are ready to present the semantics of recursive programs in the symmetric or antisymmetric fock space .",
    "let @xmath124 $ ] be a recursive program declared by the system @xmath128 of recursive equations ( [ decla ] ) .",
    "then its symmetric semantics @xmath543 is the symmetrisation of its semantics @xmath114 in the free fock space : @xmath544 where @xmath545 ( see theorem [ ss - equv ] ) , @xmath84 is the set of coins  in @xmath128 , and @xmath113 is the state hilbert space of the principal system of @xmath128 .    as a symmetrisation of proposition [ prop - sapp ] , we have :    @xmath546 .",
    "it follows from proposition [ prop - sapp ] and lemma [ symm - lem ] ( continuity of the symmetrisation functional ) that @xmath547    again , let us consider the examples of recursive hadamard walks .",
    "( continuation of example [ ex4 ] ) for each @xmath548 , we have : @xmath549 ) is @xmath550    ( continuation of example [ exam - t ] ) the symmetric semantics of the bidirectionally recursive hadamard walk specified by equaltion ( [ ddrhw ] ) is : @xmath551\\left(\\mathbf{h}\\otimes i_p\\right),\\\\ \\llbracket y\\rrbracket & = \\left[\\sum_{n=0}^\\infty(\\delta_n\\otimes t_n)\\right]\\left(\\mathbf{h}\\otimes i_p\\right)\\end{aligned}\\ ] ] where : @xmath552 with @xmath553 ranging over all strings of @xmath554 @xmath154 s and @xmath555 @xmath502 s and @xmath556 ranging over all strings of @xmath555 @xmath154 s and @xmath554 @xmath502 s , and @xmath557 with @xmath553 ranging over all strings of @xmath555 @xmath154 s and @xmath558 @xmath502 s and @xmath556 ranging over all strings of @xmath558 @xmath154 s and @xmath555 @xmath502 s .",
    "let @xmath22 be a recursive program with @xmath113 being the state hilbert space of its principal variables and @xmath84 being the set of its coins .",
    "we consder the computation of @xmath22 with input @xmath559 .",
    "assume that the coins  are initialised in state @xmath560 , where for each @xmath252 , @xmath1 is the state hilbert space of coin  @xmath0 , @xmath561 is the symmetric or antisymmetric fock space over @xmath1 , and @xmath562 or @xmath563 if coin  @xmath0 is implemented by a boson or a fermion , respectively .",
    "then the computation of the program starts in state @xmath564 .",
    "what actually concerns us is the output in the principal system .",
    "this observation leads to the following :    [ principal ] given a state @xmath560 .",
    "the principal system semantics of program @xmath22 with respect to coin  initialisation @xmath565 is the mapping @xmath566 from pure states in @xmath113 to partial density operators @xcite , i.e. positive operators with trace @xmath567 , in @xmath113 : @xmath568 for each pure state @xmath14 in @xmath113 , where @xmath569 @xmath543 is the symmetric semantics of @xmath22 , and @xmath570 is the partial trace over @xmath571 ( see @xcite , section 2.4.3 ) .",
    "( continuation of example [ exam - t ] ) we consider the bidirectionally recursive hadamard walk declared by equation ( [ ddrhw ] ) once again and suppose that it starts from the position @xmath155 .    1 .   if the coins  are bosons initialised in state @xmath572 then we have @xmath573 where @xmath553 traverses over all strings of @xmath554 @xmath154 s and @xmath555 @xmath502 s , and @xmath556 traverses over all strings of @xmath555 @xmath154 s and @xmath558 @xmath502 s .",
    "therefore , the principal system semantics with the coin  initialisation @xmath565 is : @xmath574 2 .",
    "recall from @xcite that for each single - particle state @xmath14 in @xmath38 , the corresponding coherent state of bosons in the symmetric fock space @xmath575 over @xmath38 is defined as @xmath576^n}{n!}|\\mathbf{0}\\rangle\\ ] ] where @xmath189 is the vacuum state and @xmath577 the creation operator .",
    "if the coins  are initialised in the coherent state @xmath578 of bosons corresponding to @xmath133 , then we have : @xmath579 where @xmath580 ranges over all strings of @xmath554 @xmath154 s and @xmath555 @xmath502 s , and @xmath581 ranges over all strings of @xmath555 @xmath154 s and @xmath558 @xmath502 s .",
    "so , the principal system semantics with coin  initialisation @xmath582 is : @xmath583",
    "in this section , we consider a special class of quantum recursions . arguably , while - loop is the simplest and most popular form of recursion used in programming languages . in classical programming ,",
    "the while - loop @xmath584 can be seen as the program @xmath96 declared by the recursive equation:@xmath585 we can define a kind of quantum while - loop by using quantum case statement and quantum choice in the place of classical case statement @xmath586 in equation ( [ while1 ] ) .    [ awhile ]",
    "( quantum while - loop )    1 .   the first form of quantum while - loop : @xmath587=|1\\rangle\\ \\mathbf{do}\\ u[q]\\ \\mathbf{od}\\ ] ] is defined to be the recursive program @xmath96 declared by @xmath588\\ |0\\rangle \\rightarrow \\mathbf{skip}\\\\ & \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |1\\rangle \\rightarrow u[q];x\\\\ & \\mathbf{fiq } \\end{split}\\ ] ] where @xmath0 is a quantum coin  variable denoting a qubit , @xmath6 is a principal quantum variable , and @xmath16 is a unitary operator in the state hilbert space @xmath7 of system @xmath6 .",
    "2 .   the second form of quantum while - loop @xmath589=|1\\rangle\\",
    "\\mathbf{do}\\ u[q]\\ \\mathbf{od}\\ ] ] is defined to be the recursive program @xmath96 declared by @xmath590 } ( u[q];x)\\\\ & \\equiv v[c ] ; \\mathbf{qif}[c]\\ |0\\rangle \\rightarrow \\mathbf{skip}\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |1\\rangle \\rightarrow u[q];x\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\mathbf{fiq } \\end{split}\\ ] ] note that the recursive equation ( [ recq2 ] ) is obtained by replacing the quantum case statement @xmath591 in equation ( [ recq1 ] ) by the quantum choice @xmath592}$ ] .",
    "3 .   actually ,",
    "quantum loops ( [ while2 ] ) and ( [ while3 ] ) are not very interesting because there is not any interaction between the quantum coin  and the principal quantum system @xmath6 in them .",
    "this situation is corresponding to the trivial case of classical loop ( [ while1 ] ) where the loop guard @xmath593 is irrelevant to the loop body @xmath77 .",
    "the classical loop ( [ while1 ] ) becomes truly interesting only when the loop guard @xmath593 and the loop body @xmath77 share some program variables .",
    "likewise , a much more interesting form of quantum while - loop is @xmath594=|1\\rangle\\ \\mathbf{do}\\ u[q]\\ \\mathbf{od}\\ ] ] which is defined to be the program @xmath96 declared by the recursive equation @xmath595;\\ & \\mathbf{qif}[c]\\ |0\\rangle\\rightarrow\\mathbf{skip}\\\\ & \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |1\\rangle\\rightarrow u[q];x\\\\ & \\mathbf{fiq}\\end{split}\\ ] ] where @xmath41 is a unitary operator in the state hilbert space @xmath12 of the composed system of the quantum coin  @xmath0 and the principal system @xmath6 .",
    "the operator @xmath41 describes the interaction between the coin  @xmath0 and the principal system @xmath6 .",
    "it is obvious that the loop ( [ while4 ] ) degenerates to the loop ( [ while3 ] ) whenever @xmath596 , where @xmath39 is the identity operator in @xmath7 .",
    "the semantics of the loop ( [ while4 ] ) in the free fock space is the operator : @xmath597)\\\\ & \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ w[c_{k-1},q])w[c_{k-2},q] ... )w[c_1,q])w[c_0,q]\\\\ & = \\sum_{k=1}^\\infty\\left[\\left(\\bigotimes_{j=0}^{k-2 } |1\\rangle_{c_j}\\langle 1|\\otimes |0\\rangle_{c_{k-1}}\\langle 0|\\otimes u^{k-1}[q]\\right)\\prod_{j=0}^{k-1}w[c_j , q]\\right ] .",
    "\\end{split}\\ ] ] furthermore , the symmetric semantics of the loop is : @xmath598\\right)\\prod_{j=0}^{k-1}w[c_j , q]\\right],\\ ] ] where : @xmath599",
    "in this paper , we introduced the notion of quantum recursion based on quantum case statement and quantum choice defined in @xcite , @xcite .",
    "recursive quantum walks and quantum while - loops were presented as examples of quantum recursion .",
    "the denotational and operational semantics of quantum recursion were defined by using second quantisation , and they were proved to be equivalent .",
    "but we are still at the very beginning of the studies of quantum recursion , and a series of problems are left unsolved :    * first of all , it is not well understood what kind of computational problems can be solved more conveniently by using quantum recursion . *",
    "second , how to build a floyd - hoare logic for quantum while - loops defined in example [ awhile ] ?",
    "blute , panangaden and seely @xcite observed that fock space can serve as a model of linear logic with exponential types .",
    "perhaps , such a program logic can be established through combining linear logic with the techniques developed in @xcite . *",
    "another important open question is : what kind of physical systems can be used to implement quantum recursion where new coins  must be continuously created ? * finally , we even do not fully understand how does a quantum recursion use its coins  in its computational process . in the definition of the principal system semantics of a recursive program ( definition [ principal ] ) , a state @xmath565 in the fock space of coins  is given _",
    "a priori_. this means that the states of a coin  and its copies are given once for all .",
    "another possibility is that the states of the copies of a coin  are created step by step , as shown in the following : + consider the recursive program @xmath96 declared by @xmath600;\\ & \\mathbf{qif}\\ [ c]\\ |0\\rangle\\rightarrow \\mathbf{skip}\\\\ & \\ \\ \\ \\ \\ \\ \\",
    "\\square\\ |1\\rangle\\rightarrow t_r[p];x\\\\ & \\mathbf{fiq}\\end{aligned}\\ ] ] where @xmath0 is a coin  variable with state space @xmath601 , the variable @xmath47 and operator @xmath43 are as in the hadamard walk , @xmath602=\\sum_{n=0}^\\infty\\left[r_y\\left(\\frac{\\pi}{2^{n+1}}\\right)\\otimes |n\\rangle_p\\langle n|\\right]\\ ] ] and @xmath603 is the rotation of a qubit about the @xmath604axis in the bloch sphere .",
    "intuitively , @xmath605 $ ] is a controlled rotation where position of @xmath47 is used to determine the rotated angle .",
    "it is worth noting that this program @xmath96 is a quantum loop defined in equation ( [ while4 ] ) but modified by adding a creation operator at the beginning .",
    "its initial behaviour starting at position @xmath155 with the coin  @xmath0 being in the vacuum state @xmath189 is visualised by the following transitions : @xmath606.\\end{aligned}\\ ] ] the first configuration at the end of the above equation terminates , but the second continues the computation as follows : @xmath607}{\\longrightarrow}\\cdots.\\ ] ] + it is clear from the above example that the computation of a recursive program with the creation operator is very different from that without it .",
    "a careful study of quantum recursions that allows the creation operator appear in their syntax will be carried out in another paper .",
    "i m very grateful to professor prakash panangaden for teaching me the second quantisation method during his visit at the university of technology , sydney in 2013 .",
    "the first version of this paper is the text of the third part of my talk quantum programming : from superposition of data to superposition of programs  at the tsinghua software day , april 21 - 22 , 2014 ( see : http://sts.thss.tsinghua.edu.cn/tsd2014/home.html .",
    "the first part of the talk is based on @xcite , and the second part is based on @xcite ) .",
    "i m also grateful to professors jean - pierre jouannaud and ming gu for inviting me .",
    "r. f. blute , p. panangaden and r. a. g. seely , holomorphic models of exponential types in linear logic , in : _ proceedings of the 9th conference on mathematical foundations of programming semantics ( mfps ) _ , springer lncs 802 , 1994 , pp . 474 - 512",
    ".            y. feng , n. k. yu and m. s. ying , reachability analysis of recursive quantum markov chains , in : _ proceedings of the 38th international symposium on mathematical foundations of computer science ( mfcs ) _ , springer lncs 8087 , 2013 , pp .",
    "385 - 396 ."
  ],
  "abstract_text": [
    "<S> this paper introduces a new notion of quantum recursion of which the control flow of the computation is quantum rather than classical as in the notions of recursion considered in the previous studies of quantum programming . </S>",
    "<S> a typical example is recursive quantum walks , which are obtained by slightly modifying the construction of the ordinary quantum walks . </S>",
    "<S> the operational and denotational semantics of quantum recursions are defined by employing the second quantisation method , and they are proved to be equivalent </S>",
    "<S> .    case statement , quantum choice , quantum recursion , recursive quantum walks , second quantisation , fock space </S>"
  ]
}