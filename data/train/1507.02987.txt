{
  "article_text": [
    "one of the most important tasks at the bioinformatics is the search for similar genetic sequences in the data banks . with the new sequencing technologies , the size of these genetics data banks are growing exponentially  @xcite , and",
    "consequently the search time is growing too .    the alignment algorithms , _ needleman - wunsch _  @xcite and _ smith - waterman",
    "_  @xcite are algorithms of the dynamic programming class @xcite .",
    "they are very sensible alignments algorithms , but their computation and memory costs are quadratic @xmath1  ( where @xmath2 is the input sequence length and @xmath3 the data bank length ) .",
    "this computation and memory costs turn them impractical at large data banks sets . to address this problem , heuristics was developed to reduce the memory and processing consumption of the similar sequences searching processes . among the algorithms which use heuristics for similar sequences searching , the _ fasta _ @xcite and _ _ blast__@xcite algorithms are the more used and know algorithms . these algorithms search for areas which has similarities , called _ hsp",
    "_ ( high scoring pairs ) , and then , they make the alignment of the best _ hsp _ found using a dynamic programming algorithm .",
    "the _ fasta _ and _ blast _ algorithms also optimized the alignment cost , because the alignment is made between words which have a previously detected similarity only .",
    "nevertheless , the problem complexity continues being @xmath4 ( @xmath5 is the quantity of sequences in the data banks ) because it still necessary to read the data bank sequences entirely to find the _",
    "the searching process optimization can be made using inverted index to localize _",
    "inverted indexes are data structures which allow to find the localization of the indexed data at constant time ( @xmath6 ) .",
    "this type of indexes are utilized at information retrieval area , especially in web searching engine , as _ google _ , _ yahoo _ , and libraries for data indexing , as the _ apache lucene _ @xcite .    for the search for similar genetic sequences ,",
    "the sub - sequences of the data bank sequences are indexed , eliminating the necessity of finding the _ hsps _ thought a linear search .",
    "it is quite similar with the indexes found at the end of the books , where rather than to have the text entry , it have a sub - sequences entries informing where these sub - sequence can be found .",
    "the two most common data structures which are usually used to index the genetic sequences data bank are the suffixes trees and vectors .",
    "suffixes tress are used at the work of gusfield  @xcite , this data structure allows to access the sub - sequence position in linear time , but the real virtue is to find repeating sequences regions and to obtain the longest common ancestral .",
    "one example of suffixes tress application is presented by @xcite , where an algorithm for building tree to find near - exact sequences is utilized . at this example",
    ", the access time gain has a high memory consumption cost . at @xcite",
    "is said that the delcher  et  al .",
    "@xcite has a memory spent of @xmath7  bytes by base at her implementation when using suffixes trees . as comparison ,",
    "using the human genome with approximately three billions base pairs , are necessary more than @xmath8  gigabytes to store the suffix tree . at @xcite",
    "an optimization is shown in relation to previous work , where the algorithm is three times faster and it uses one third of the memory .",
    "even with this reduction , it is necessary more than @xmath9  gigabytes to store the suffix tree to index the human genome .",
    "vector is a data structure which is mainly an array of elements , where each position of this array represents an information and inside this position , have another array informing where this information can be found .",
    "some similar searching sequences techniques that uses vectors as inverted indexes are : _ _ ssaha__@xcite , _ _",
    "blat__@xcite , _ _ patternhunter__@xcite the _ _",
    "miblast__@xcite , _ _",
    "megablast__@xcite , _ _",
    "megablast__@xcite , and kalafus  @xcite which uses hash tables to align whole genomes . transforming based methods",
    "are considered out of the scope of this work , but jing  @xcite presents methods that use this technique .    another possible way to reduce the searching time is through parallel computing .",
    "the importance of the parallelization has grown along with the growing multiprocessing capabilities , like the number of the cores , in the modern processors .",
    "some tools for similar sequences searching have ways to use these multiprocessing technologies . as one example , it is possible to inform the _",
    "ncbi blast _ to divide the data bank and perform parallel searches at these data banks fragments .",
    "as the data bank is divided and the search parallelized , the computational complexity is @xmath10 ( @xmath11 is the quantity of fragments that the data bank will be divided ) , or it means , even with the search parallelization , it still have a linear computation complexity .    the computational complexity can be reduced using inverted index , but searching at the literature , it was not found any technique which uses indexing with parallel programming , and consequently they do not use the capacity of moderns the multi - core processors .",
    "thus , the objective of this work is to use the index techniques to optimize the searching process along with the use of the multi - core processor to reduce the searching time of the similar genetic sequences .",
    "the developed software , called _ genoogle _ uses indexing techniques with inverted index , index search parallelization , data bank division and parallelization , bit level sequences codification and alignment algorithms optimizations .",
    "this software was developed utilizing the java environment and it has a web page , web services and text mode interfaces .",
    "this work presents the _ genoogle _ , that is a similar sequence searching engine software which has as objective to execute fast and with good sensibility searches . to achieve these goals",
    ", it uses inverted index to find nimbly the _ hsps _ and it also uses parallelization techniques to use the multi - core processors capabilities .",
    "_ genoogle _ works similarly to the _ blast _ , where given an input sequence , a parameter set , and a data bank where the search will be made , the software returns the similar sequences from the given input and parameters .    defining a genetic sequence as a sequence where @xmath12  =  \\{@xmath13 , @xmath14 , @xmath15 , @xmath16 }  ( _ dna _ ) , @xmath12=\\{@xmath13 , @xmath14 , @xmath15 , @xmath17 }  ( _ rna _ ) and a sub - sequence is",
    "a sequence wich is contained partiality of fully into other sequence .",
    "the sequences at _ genoogle _ are divided into fixed length sub - sequences , where the length is defined by the user before the data bank formatting , and them , they are codified using @xmath18 bits for each sequence base .",
    "the sub - sequences are stored as a bit vector into @xmath19 bits integer and the length can vary from @xmath20 to @xmath21 bases . changing this value impacts at the search speed and sensibility , as big",
    "is the value , as fast will be the searching process , but the sensibility will be lower . to save memory , not overlapping windows",
    "are utilized to codify the data bank sequences , but for input sequences , to have more sensibility during the searching process , overlapped windows are utilized .",
    "these codified sequences , with other sequence information : name , identification code , and description are stored into a file disk , composing the data bank sequences .",
    "masks are used at the indexed sub - sequences to improve the searching sensibility of the inverted index .",
    "the masks are based on the _ patternhunter _",
    "@xcite work .",
    "the masks inform which sub - sequences bases should be maintained or removed and , consequently they increase the probability to find sub - sequences at the index .",
    "the masks provide two gains : the sensibility , which allows to search at the index with not - exact sequences , and it saves index space , because longer sub - sequences will be transformed into smaller , having less index entries and less sub - sequences at the data bank .",
    "_ genoogle _ has some run time parameters which can improve the sensibility or the search performance .",
    "the parameters for the sensibility are : the maximum distance between index entries for be considered for the same _ hsp _ , the minimum _ hsp _ size and the drop off for sequences extension .",
    "changing these parameters impact on the sensibility , allows to find more _",
    "hsp _ , but it is expected to have more false positives and to slow down the performance .",
    "_ genoogle _ use vectors as inverted indexes data structures .",
    "the size of the main vector is the quantity of possible sub - sequences : as the _ dna _ alphabet has @xmath22 letters , it is possible @xmath23 sub - sequences , being @xmath3 the defined sub - sequences length , having the inverted index @xmath23 entries .",
    "the size of each sub - sequence vector varies according the quantity of this sub - sequence into the data bank .",
    "each sub - sequence occurrence uses two integers of @xmath22 bytes to store the information : one integer is used to store the identifier of the sequence and the other integer is used to store the position at the sequence .",
    "the inverted index uses @xmath22 bytes to the sequences identifier and more @xmath22 to the position at this sequence , turning possible to index approximately @xmath24  billions  ( @xmath25 ) sequences and each one can have until this length , being the available memory the major limit to the quantity of sequences and their size .",
    "[ ht ]    the mask are applied at the data bank sequences during the indexing process .",
    "they are read and divided into sub - sequences , at each one the mask is applied on its sub - sequences and hence these masked sub - sequences are indexed . using masks allow having longer sub - sequences with smaller sensibility loose . for example , using the mask _ 111010010100110111 _ , where _ 1 _ means that the base in that location should be preserved and the _ 0 _ means that the base there should be removed , the sub - sequences read from the data bank will have @xmath26 bases , and after the mask be applied , will have @xmath27 bases . in this way , it is used a vector to index @xmath27 bases sub - sequences , but the sequences are divided into @xmath26 bases sub - sequences , saving inverted index structure memory .",
    "_ genoogle _ needs approximately @xmath28 bytes to store the inverted index .",
    "being @xmath29 the length of the data bank in bases , @xmath2 , the total mask length , and @xmath30 the sub - sequences length . for a data bank with @xmath22 billions bases and sub - sequences with @xmath27 bases , there will be @xmath31 of millions sub - sequences , requiring @xmath32  megabytes to store the inverted index . using masks with @xmath26 bases length",
    ", there will be @xmath33 millions sub - sequences and the inverted index will need @xmath34  megabytes , resulting on a gain of @xmath35 of the total memory required .",
    "to build the inverted indexes it is used the sort - based method  @xcite and the inverted index and the formatted data bank are stored at the disk . during the _ genoogle _ start time , the whole inverted index is read and loaded into the main memory , the data bank meta informations , like file offset , are also loaded into the main memory , but the data bank sequences are read from the disk when the sequences informations are necessary .",
    "after that the inverted index and the data bank meta informations are loaded into the main memory , _ genoogle _ is ready to run the searches .",
    "the searching process is divided into @xmath36 phases :    * input sequence processing ; * index searching for similar sub - sequences and construction of the _ hsps _ ; * _ hsps _ extension and merge ; * merging overlapped _",
    "* selection of the high scored _ hsps _ ; * local alignment of the selected _ hsps _ ; * selection and exhibition of the best alignments",
    ".    the input sequence processing firstly applies the mask at each overlapped sub - sequence of the input sequence and codify the resulting sub - sequence to the binary representation used by _ genoogle_. the input sequence processing is shown at fig .",
    "[ fig : input_sequence_processing ] . as the input sub - sequences are codified as binary data into an integer , it is possible to obtain the sub - sequence value directly from this data .",
    "because the determined sub - sequence position at the index is its own value it turns the index searching process simpler and direct .",
    "[ ht ]    at fig .",
    "[ fig : sub_obtain ] is shown the process to retrieve the informations from the inverted index .",
    "for each masked and encoded sub - sequence from the input sequence , using its encoded value , is retrieved from the inverted index all places which have this sub - sequence at the data bank sequences .",
    "the retrieved informations are stored into an array of arrays , where each position represents a data bank sequence .",
    "if two or more retrieved information are are closer than a specified parameter , they are merged into one retrieved information .",
    "these informations are filtered by their length and the remaining ones are them called high scoring pairs ( _ hsp _ ) .",
    "the _ hsp _ have five information : initial and final positions at the input sequence and at the data bank sequence , and the length of this area , where it gets the length of the _ hsp _ in relation of the data bank and of the input sequence and get the smaller value .",
    "[ ht ]    after the index searching phase , the located _ hsps _ are extended to the both directions to try to enlarge their length . during the extension phase , two or more _ hsps _ which were closed can be overlapped , generating duplicate results .",
    "hence , it is verified after the extension phase if the _ hsps _ have overlapped regions , and if they do , they are merged into one new _",
    "hsp_.    after the extension and merging phase , the _ hsps _ are sorted by their lengths in a decreasing way .",
    "it is possible to specify a parameter to inform the maximum quantity of alignments which should be returned .",
    "the objective of this parameter is to reduce the number of alignments built , saving processing and returning only the most significant alignments , it is also possible to set to return all _ hsps _ found .",
    "after the selection , it is made a local alignment for the selected _",
    "the local alignment is built by a modified version of the _ smith - waterman _ algorithm .",
    "the alignment algorithm is modified in order to limit the distance from the main diagonal which will be used to produce the alignment .",
    "rather than to use the whole matrix to build the alignment , it is used only the closest cells of the main diagonal .",
    "this limit is used because the two sub - sequences which will be aligned have a high similarity , turning unnecessary to calculate the whole alignment matrix . to reduce the memory use ,",
    "was also used a technique to divide the alignment matrix in smaller matrices .",
    "this technique divides the two sequences into segments , and each segment is aligned separately . after the segments alignment , the results are merged and considered the final result of whole sequences .",
    "after the _ hsps _ alignments , they are sorted by the alignment score , and the results are returned with other information , as the e - value , score , normalized score , and alignment position in the input and data bank sequence , to the user .",
    "to improve the searching time and to use the multi - processing capabilities , _ genoogle _ uses three parallelization techniques : inverted index access parallelization , extension and alignment parallelization , and data bank division parallelization .",
    "the data bank division parallelization is made dividing the data bank in fragments , similarly how _ ncbi blast _ does .",
    "the indexes searches and _ hsps _ construction are made independently into threads for each data bank fragment .",
    "after locating the _ hsps _ by the individual threads , they are extended , merged , sorted , filtered , aligned , sorted by their score , and returned to the user .",
    "this technique is interesting for large data banks , but this parallelization technique does not parallelize the whole searching process : the extension , sorting and alignment phases are not parallelized by this technique .    analyzing the searching data bank fragmentation process , it was verified that not every searching thread have the same execution time .",
    "it happens because some fragments have more similar sequences than others . analyzing the searching time",
    ", it was verified that the index searching time represents about @xmath37 of the whole searching time . about @xmath35 of the searching time",
    "is for the _ hsps _ alignments , because it , a component was developed to parallelize the sequences extension , sorting and alignment using all available computer processing core .    at this parallelization technique , the threads search the input sub - sequences at the data bank fragments index and then put the _ hsps _ into a collection shared by all index searching threads .",
    "after the index searching phase , the _ hsps _ collection is sorted by the _ hsp _ length and",
    "the longest are selected using a parameter that informs how many alignments should be returned .",
    "the remaining _ hsps _ are put into a _ fifo _",
    "queue , where it has extenders and aligners which will perform the extension and alignment .",
    "these extenders and aligners use independent threads , they read a _",
    "hsp _ from the queue , them perform the extension and alignment and put the result into another shared collection .",
    "these threads are managed by an executor , when a thread finish its job , the manager sends to it another _ hsp _ to extend and align until all _ hsps _ are extended and aligned .",
    "it is possible to configure the quantity of simultaneous threads .",
    "the memory required by the inverted index structure is the main problem of the data bank division .",
    "for example : using @xmath27 base pairs length sub - sequences , they are necessary @xmath19 megabytes to store only the inverted index structure .",
    "theoretically , to use the whole computational capacity of a computer with @xmath38 processing cores , it is necessary to divide the data bank in @xmath38 parts , becoming necessary to use up @xmath39 megabytes to store only the inverted index structure . because of the memory requirement for the data bank division , it is important to use a complementary approach . along with the data bank division ,",
    "the input sequences are also divided and performed the search parallel .",
    "thus it is possible to parallelize the searching process without overloading the memory with more data structures .",
    "this parallelization divides the input sequence in sub - inputs , and it searches each sub - input at the inverted index independently .",
    "it is also useful because it also parallelize the input query processing .",
    "after the index search , the _ hsps _ that are from the same data bank sequence and are closer , are merged into one _ hsp_. using the data bank division in two fragments and the input sequence in two sub - inputs , they are used @xmath22 threads to search at the inverted index , being the memory overload of only two inverted indexes structures . at the fig  [ fig : parallel_search ]",
    "is shown the complete parallelized _ genoogle _ search dividing the input query in two sub - inputs and the data bank in two fragments .",
    "[ fig : parallel_search ]",
    "_ genoogle _ is developed using the java environment version @xmath40 .",
    "the java environment was choose because it is multi - platform and it has a framework and primitives for parallel computing . the library _ biojava _  @xcite was used during the first part of the development , but now it was removed from the project . at the first implementations , _ biojava _ was used to reading , parsing , storing and genetic sequences alignment , but it was verified that the reading and parsing methods require too much memory , so , new and optimized classes was developed to perform these tasks .",
    "the main user interface is an text mode interface , where the user types the search command and the results are stored into a _",
    "file that is defined by the user .",
    "this interface has commands to perform the search , to list the available data banks , to obtain the parameters list , to run the garbage collection , to run the last command executed , and to run a batch file containing commands .",
    "the batch command is interesting because with it is possible to write a file with all commands that should be executed and to inform the _",
    "genoogle _ to execute them without any used intervention during the execution of these commands .",
    "_ genoogle _ has also an embedded simple web page interface , best suitable for testing , which contains only one input field , for the input sequence and a button to perform the search .",
    "the search results of the web page interface are a _ xml _",
    "document formatted and shown as a _ html _ web page by a _ xsl _ document .",
    "together with the web page , _ genoogle _ has a web - services interface , implemented using _ jax - ws_. using the web - services interface , it is possible to execute queries , to set parameters , retrieve the data bank available list , and others tasks inside of a programming script .",
    "the users can write scripts to access _ genoogle _ services automatically using their preferred programming language and perform their searches without manual intervention .",
    "for the experiments was utilized a data bank with sequences of the phase @xmath41 of the human genome project  @xcite along with refseq  @xcite data banks .",
    "the refseq data banks were used because they are verified and they have high quality .",
    "the human genome project data bank is the _",
    "hs_phase3 _ and has approximately @xmath42  @xmath43 .",
    "the refseq data bank are the _ cow _ with approximately @xmath44  @xmath45 , _ frog _ with @xmath0  @xmath45 , _ human _ with @xmath46  @xmath45 , _ mouse _ with @xmath47  @xmath45 , _ rat _ with @xmath48  @xmath45 , and _ zebrafish _ with @xmath49  @xmath45 , totalizing approximately @xmath50  @xmath45 . at the experiments",
    "was used the data banks from the refseq along with the _ hs_phase3 _ , totalizing @xmath51  @xmath43 and being necessary approximately @xmath18 gigabytes of memory to store it .    for the execution of the experiments",
    ", they were generated @xmath27 sets of input sequences .",
    "each set has @xmath27 sequences with approximately the same size , being @xmath20 sequence got from the data bank and @xmath52 are mutations of these sequences .",
    "the sets are with sequences with @xmath53 base pair ( bp ) , @xmath54 , @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 , @xmath60 , @xmath61 e @xmath62 .",
    "the searches were made using the data bank parallelism , dividing the input sequence parallelism and extending and aligning the sequences simultaneously .",
    "at the experiments it was used a computer with @xmath21 gigabytes of ram , linux version @xmath63 and java environment version @xmath40 with the _ jvm _  _ jrockit _  version @xmath64 .",
    "[ ht ]    for entries up to @xmath57 the gain using the parallelism is low , giving a gain of only @xmath18 times and the total time increases when the input sequence is divided into more than @xmath22 parts .",
    "it happens because the searching time for these small input sequences are too low , less than @xmath65 , and the synchronization overload impacts directly to the searching time . for input sequences with @xmath58",
    "it there is a gain of @xmath66 times with the utilization of the parallelization techniques . for inputs with @xmath59 and up , the speedup are @xmath38 , that is the aiming gain , and with @xmath61 and @xmath62 inputs the gains overcome this speedup .    the use of tools that use suffix trees was discarded for the time comparison because of the memory required by these tools . thought tests , it was verified that the _ blat _  software can not handle data banks bigger than @xmath22  @xmath43 .",
    "_ megablast _ was not verified because @xcite says that _ megablast _ was developed to be efficient on the searching time , but the results quality is worst than _ ncbi blast _ , it happens because the seeds minimum size is @xmath67 . because of the lower results quality , it was decided not to execute experiments with this tool .",
    "the _ indexed megablast _",
    "@xcite can not be executed because its memory requiring @xmath22 times the data bank , needing more than the @xmath21  @xmath43 available . and finally , it was not possible to obtain the _ patternhunter _ to execute the experiments .",
    "thus , it was decided to compare the performance only against the _ ncbi blast_.    comparing the sequential search times of _ genoogle _ and _ blast _ it is shown that genoogle is almost @xmath0 times faster and comparing the parallel times , genoogle is @xmath68 times faster .",
    "it is interesting to realize that for smaller input , until @xmath57 , the time gains in relation with _",
    "blast _ are not so good because the parallelization techniques does not use all their potential in these small inputs .",
    "the time difference at bigger inputs comes until @xmath69 times for @xmath60 input .",
    "it is important to realize that the sequential version of genoogle is faster than the parallel executions of the _",
    "blast_.    .time comparison between sequential ncbi blast and sequential genoogle .",
    "[ cols= \" > , > , > , > \" , ]      the results quality was analyzed comparing the genoogle results against the blast results and verifying which _ hsps _ were identified as similar and what is the percentage of _ hsps _ that were identified by _",
    "blast _ and not by the genoogle . for each input sequences ,",
    "a collection with the found alignments by blast was created and it is verified if these alignments were found by genoogle . it is accounted how many alignments were found and it is generated a percentage for each _ e - value _ range varying from @xmath70 a @xmath71 .    following is shown",
    "the graphic which shows the proportion of alignments found by genoogle in relation to the blast according the alignment _ e - value_. this graphic was generated from the data where it was verified which of the alignments found by the blast were found by the genoogle too . in this graphic",
    "it is possible to observe that until the _ e - value _",
    "@xmath72 more than @xmath73 of the alignments were found by the _ genoogle_. until the _ e - value _",
    "@xmath74 more than @xmath37 of the alignments were found and with the _ e - value _",
    "@xmath75 almost @xmath76 of the alignments were found . above this",
    "_ e - value _ the quantity of alignments found is bellow @xmath77 .",
    "[ ht ]    analyzing this graphic is realized that the genoogle is a good tool to find alignments with the _ e - value _ lower than @xmath78 .",
    "it happens because alignments with this _ e - value _ are usually long , with more than @xmath79 , and consequently are found easily . from the _ e - value _",
    "@xmath80 there is a drop in the results quality , where it is stabilized close to the _ e - value _ @xmath20 .",
    "alignments with the _ e - value _ highest than @xmath81 are alignments which can not be possible to infer a close homology  @xcite .",
    "this , it can be observed that genoogle has a very good search quality until the maximum @xmath82 _ e - value _ , but it has a quality drop until @xmath83 .",
    "the alignments should not to be considered to homology inference for values higher than @xmath84 .",
    "the experiments showed that the genoogle quality results is comparable to the blast when the alignment _ e - value _ is representative , demonstrating a possible homology between the two aligned sequences .",
    "more sensible search can be archived changing the searching parameters , as the maximum distance between the sub - sequences information got from the index , and the minimum hsp length . changing the minimum hsp length for alignments with _ e - value _ higher than @xmath85",
    ", the hsp found for this _ e - value _ grew to approximately @xmath86 and the search time was raised only @xmath87 .",
    "this work presented a genetic similarity sequences searching software which uses data bank sequences indexing along with parallel computing . to ensure the effectiveness and the search quality of to use index and parallel computing",
    "was developed and implemented the genoogle tool .",
    "this software was implemented using the java @xmath40 and it can be executed at windows , linux , and mac environment .",
    "experiments were executed to verify the results execution time and the results quality .",
    "the searching time was really good , with speedup of more than @xmath0 times in relation to parallelized blast .",
    "the results quality was good , finding relevant alignments , but it can be optimized by changing the searching parameters .",
    "thus , merging the indexing techniques with the three parallelization techniques and the option to optimize the search configurations , genoogle proved to be an effective tool and its results have good quality .",
    "as the main contributions of this work , it should be noted primarily as the first tool in the literature to do the genetic sequences search using indexing and parallel computing . considering that parallel computing importance",
    "has increased with increasing number of cores at the processors and also the importance of the data indexing to optimize the searching process in data banks wich has an exponential grow , this work has a relevance for addressing these two issues together ."
  ],
  "abstract_text": [
    "<S> the search for similar genetic sequences is one of the main bioinformatics tasks . </S>",
    "<S> the genetic sequences data banks are growing exponentially and the searching techniques that use linear time are not capable to do the search in the required time anymore . </S>",
    "<S> another problem is that the clock speed of the modern processors are not growing as it did before , instead , the processing capacity is growing with the addiction of more processing cores and the techniques which does not use parallel computing does not have benefits from these extra cores . </S>",
    "<S> this work aims to use data indexing techniques to reduce the searching process computation cost united with the parallelization of the searching techniques to use the computational capacity of the multi core processors . to verify the viability of using these two techniques simultaneously , a software which uses parallelization techniques with inverted indexes </S>",
    "<S> was developed .    </S>",
    "<S> experiments were executed to analyze the performance gain when parallelism is utilized , the search time gain , and also the quality of the results when it compared with others searching tools . </S>",
    "<S> the results of these experiments were promising , the parallelism gain overcame the expected speedup , the searching time was @xmath0 times faster than the parallelized _ ncbi blast _ , and the searching results showed a good quality when compared with this tool .    </S>",
    "<S> the software source code is available at https://github.com/felipealbrecht/genoogle . </S>"
  ]
}