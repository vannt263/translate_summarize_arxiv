{
  "article_text": [
    "constraint handling rules ( chr ) @xcite is a declarative general - purpose language .",
    "a chr program consists of a set of multi - headed guarded ( simplification , propagation and simpagation ) rules which allow one to rewrite constraints into simpler ones until a solved form is reached .",
    "the language is parametric w.r.t .",
    "an underlying constraint theory @xmath2 which defines basic built - in constraints . for a recent survey on the language see .    in the last few years",
    ", several papers have investigated the expressivity of chr , however very few decidability results for fragments of chr have been obtained .",
    "three main aspects affect the computational power of chr : the number of atoms allowed in the heads , the nature of the underlying signature on which programs are defined , and the constraint theory .",
    "the latter two aspects are often referred to as the `` host language '' since they identify the language on which a chr system is built .",
    "some results in @xcite indicate that restricting to single - headed rules decreases the computational power of chr .",
    "however , these results consider turing complete fragments of chr , hence they do not establish any decidability result . indeed , single - headed chr is turing - complete @xcite , provided that the host language allows functors and unification . on the other hand , when allowing multiple heads , even restricting to a host language which allows only constants does not allow to obtain any decidability property , since even with this limitation chr is turing complete @xcite .",
    "the only ( implicit ) decidability results concern propositional chr , where all constraints have arity 0 , and chr without functors and without unification , since these languages can be translated to ( colored ) petri nets @xcite  see also section [ sec : conclusions ] .",
    "given this situation , when looking for decidable properties it is natural to consider further restrictions of the above mentioned chr language which allows the only built - in @xmath1 ( interpreted in the usual way as equality on the herbrand universe ) and which , similarly to datalog , is defined over a signature which contains no function symbol of arity @xmath3 .",
    "we denote such a language by chr(@xmath4 ) .    in this paper",
    "we provide two decidability results for two fragments of chr(@xmath4 ) .",
    "the first fragment allows _ range - restricted _ rules only , that is , it does not allow the use of a variable in the body or in the guard if it does not appear in the head .",
    "we show , using the theory of well - structured transition systems @xcite , that in this case the existence of an infinite computation is decidable .",
    "the second fragment that we consider is single - headed chr(@xmath4 ) , denoted by chr@xmath5(@xmath4 ) .",
    "we prove that , for this language , the existence of a terminating computation is decidable . in this case",
    "we provide a direct proof , since no reduction to petri nets can be used ( the language introduces an infinite states system ) and well - structured transition system can not be used ( they do not allow to prove this kind of decidability properties ) .",
    "these results show that both chr fragments are strictly less expressive than turing machines .",
    "as previously mentioned , chr(@xmath4 ) is as expressive as turing machines .",
    "so these results obviously imply that both restrictions lower the expressive power of chr(@xmath4 ) .",
    "in this section we give an overview of chr syntax and its operational semantics following @xcite .",
    "a constraint @xmath6 is an atomic formula constructed on a given signature @xmath7 in the usual way .",
    "there are two types of constraints : built - in constraints ( predefined ) that are handled by an existing solver and chr constraints ( user - defined ) which are defined by a chr program .",
    "therefore we assume that the signature @xmath7 contains two disjoint sets of predicate symbols for built - in and chr constraints .",
    "for built - in constraints we assume that a first order decidable theory @xmath2 is given which describes their meaning .",
    "often the terminology `` host language '' is used to indicate the language consisting of the built - in predicates , because indeed often chr is implemented on top of such an existing host language .    to distinguish between different occurrences of syntactically equal constraints ,",
    "chr constraints are extended with a unique identifier .",
    "an identified chr constraint is denoted by @xmath8 with @xmath9 a chr constraint and @xmath10 the identifier .",
    "we write @xmath11 and @xmath12 , possibly extended to sets and sequences of identified chr constraints in the obvious way .",
    "[ subsection : chr_program ] a chr program is defined as a sequence of three kinds of rules : simplification , propagation and simpagation rules . intuitively , simplification rewrites constraints into simpler ones , propagation adds new constraints which are logically redundant but may trigger further simplifications , and simpagation combines in one rule the effects of both propagation and simplification rules",
    ". for simplicity we consider simplification and propagation rules as special cases of a simpagation rule",
    ". the general form of a simpagation rule is : @xmath13 where @xmath14 is a unique identifier of a rule , @xmath15 and @xmath16 ( the heads ) are multi - sets of chr constraints , @xmath17 ( the guard ) is a conjunction of built - in constraints and @xmath18 is a multi - set of ( built - in and user - defined ) constraints . if @xmath15 is empty then the rule is a simplification rule .",
    "if @xmath16 is empty then the rule is a propagation rule .",
    "at least one of @xmath15 and @xmath16 must be non - empty .",
    "when the guard @xmath17 is empty or @xmath19 we omit @xmath20 .",
    "the names of rules are omitted when not needed . for a simplification rule",
    "we omit @xmath21 while we write a propagation rule as @xmath22 .",
    "a chr _ goal _ is a multi - set of ( both user - defined and built - in ) constraints .",
    "we also use the following notation : @xmath23 , where @xmath24 is a set of variables , denotes the existential closure of a formula @xmath25 w.r.t . the variables in @xmath24 , while @xmath26 denotes the existential closure of a formula @xmath25 with the exception of the variables in @xmath24 which remain unquantified .",
    "@xmath27 denotes the free variables appearing in @xmath25 and @xmath28 the application of a substitution @xmath29 to a syntactic object @xmath30 .",
    "[ secdialectes ] as mentioned before , the computational power of chr depends on several aspects , including the number of atoms allowed in the heads , the underlying signature @xmath7 on which programs are defined , and the constraint theory @xmath2 , defining the built - ins .",
    "we use the notation chr(@xmath31 ) , where the parameter @xmath31 indicates the signature and the constraint theory ( in other words , the host language ) .",
    "more precisely , the language under consideration in this paper is chr(@xmath4 ) and has been defined in the introduction .",
    "we will also use the notation chr(@xmath32 ) to denote _ propositional _ chr , that is the language where all constraints have arity zero . this corresponds to consider a trivial host language without any data type .",
    "finally chr(@xmath33 ) indicates the ( usual ) chr language which allows functor symbols and the @xmath1 built - in .",
    "thus in this case the host language allows arbitrary herbrand terms and supports unification among them .",
    "the number of atoms in the heads also affects the expressive power of the language .",
    "we use the notation chr@xmath5 , possibly combined with the notation above , to denote _ single - headed _",
    "chr , where heads of rules contain one atom .",
    "[ subsection : traditional_operational_semantics ] we consider the theoretical operational semantics , denoted by @xmath34 and the abstract semantics , denoted by @xmath35 .",
    "the semantics @xmath34 is given by as a state transition system @xmath36 where configurations in @xmath37 are tuples of the form @xmath38 , where @xmath39 is the goal ( a multi - set of constraints that remain to be solved ) , @xmath40 is the chr store ( a set of identified chr constraints ) , @xmath18 is the built - in store ( a conjunction of built - in constraints ) , @xmath41 is the propagation history ( a sequence of identifiers used to store the rule instances fired ) and @xmath42 is the next free identifier ( it is used to identify new chr constraints ) .",
    "the transitions of @xmath34 are shown in table [ table : traditional_semantics ] .    given a program @xmath32 , the transition relation @xmath43 is the least relation satisfying the rules in table [ table : traditional_semantics ] .",
    "the * solve * transition allows to update the constraint store by taking into account a built - in constraint contained in the goal .",
    "the * introduce * transition is used to move a user - defined constraint from the goal to the chr constraint store , where it can be handled by applying chr rules . the * apply * transition allows to rewrite user - defined constraints ( which are in the chr constraint store ) using rules from the program .",
    "the * apply * transition is applicable when the current built - in store ( @xmath18 ) entails the guard of the rule ( @xmath17 ) .",
    "solve : :    @xmath44 where @xmath9 is a    built - in constraint introduce : :    @xmath45 where @xmath9    is a chr constraint apply : :    @xmath46    where @xmath32 contains a ( renamed apart ) rule    @xmath47    and there exists a matching substitution @xmath48 s.t .",
    "@xmath49 ,    @xmath50 ,    @xmath51 +    and    @xmath52 \\notin t$ ]    an _ initial configuration _ has the form @xmath53 while a _ final configuration _ has either the form @xmath54 when it is _ failed _ , or the form @xmath55 when it is successfully terminated because there are no applicable rules .",
    "a computation is called _ terminating _ if it ends in a final configuration , _ infinite _ otherwise .    [",
    "subsection : original_operational_semantics ]    the first chr operational semantics defined in @xcite differs from the traditional semantics @xmath34 .",
    "indeed this original , so called , abstract semantics denoted by @xmath35 , allows the firing of a propagation rule an infinite number of times . for this reason",
    "@xmath35 can be seen as the abstraction of the traditional semantics where the propagation history is not considered .",
    "it is identical to @xmath34 , except that configurations are of the form @xmath56 ( they do not contain a propagation history ) and the * apply * transition does not have the last condition that @xmath57 .",
    "in this section we consider the ( multi - headed ) range - restricted chr(@xmath4 ) language described in the introduction .",
    "we call a chr rule range - restricted if all the variables which appear in the body and in the guard appear also in the head of a rule .",
    "more formally , if @xmath58 denotes the variables used in @xmath31 , the rule @xmath59 is range - restricted if @xmath60 holds .",
    "a chr language is called range - restricted if it allows range - restricted rules only .",
    "we prove that in range - restricted chr(@xmath4 ) the existence of an infinite computation is a decidable property when considering the @xmath35 semantics .",
    "this shows that this language is less expressive than turing machines and than chr(@xmath4 ) .",
    "our result is based on the theory of well - structured transition systems ( wsts ) and we refer to @xcite for this theory . here",
    "we only provide the basic definitions on wsts , taken from @xcite .",
    "recall that a _ quasi - order _ ( or , equivalently , preorder ) is a reflexive and transitive relation .",
    "well - quasi - order _ ( wqo ) is defined as a quasi - order @xmath61 over a set @xmath31 such that , for any infinite sequence @xmath62 in @xmath31 , there exist indexes @xmath63 such that @xmath64 .",
    "a _ transition system _ is defined as usual , namely it is a structure @xmath65 , where @xmath40 is a set of _ states _ and @xmath66 is a set of",
    "_ transitions_. we define @xmath67 as the set @xmath68 of immediate successors of @xmath69 .",
    "we say that @xmath70 is _ finitely branching _ if , for each @xmath71 , @xmath67 is finite .",
    "hence we have the key definition .",
    "[ def : wsts ] a _ well - structured transition system with strong compatibility _ is a transition system @xmath65 , equipped with a quasi - order @xmath61 on @xmath40 , such that the two following conditions hold :    1 .",
    "@xmath61 is a well - quasi - order ; 2 .",
    "@xmath61 is strongly ( upward ) compatible with @xmath72 , that is , for all @xmath73 and all transitions @xmath74 , there exists a state @xmath75 such that @xmath76 and @xmath77 holds .",
    "the next theorem is a special case of a result in @xcite and will be used to obtain our decidability result .",
    "[ divdec ] let @xmath78 be a finitely branching , well - structured transition system with strong compatibility , decidable @xmath61 and computable @xmath67 for @xmath79 .",
    "then the existence of an infinite computation starting from a state @xmath79 is decidable .",
    "* decidability of divergence . *",
    "consider a given goal @xmath39 and a ( chr ) program @xmath32 and consider the transition system @xmath80 defined in section [ subsection : original_operational_semantics ] .",
    "obviously the number of constants and variables appearing in @xmath39 or in @xmath32 is finite .",
    "moreover , observe that since we consider range - restricted programs , the application of the transitions @xmath81 does not introduce new variables in the computations .",
    "in fact , even though rules are renamed ( in order to avoid clash of variables ) , the definition of the apply rule ( in particular the definition of @xmath48 ) implies that in a transition @xmath82 we have that @xmath83 holds .",
    "hence an obvious inductive argument implies that no new variables arise in computations .",
    "for this reason , given a goal @xmath39 and a program @xmath32 , we can assume that the set @xmath37 of all the configurations uses only a finite number of constants and variables .",
    "in the following we implicitly make this assumption .",
    "we define a quasi - order on configurations as follows .    given two configurations @xmath84 and @xmath85 we say that @xmath86 if    * for every constraint @xmath87 @xmath88 * for every constraint @xmath89 @xmath90 * @xmath91 is logically equivalent to @xmath92    the next lemma , with proof in @xcite , states the relevant property of @xmath61 .",
    "[ lemma : wqo ] @xmath61 is a well - quasi - order on @xmath37 .    next , in order to obtain our decidability results we have to show that the strong compatibility property holds .",
    "this is the content of the following lemma whose proof is in @xcite .",
    "[ lemma : wstssc ] given a chr(@xmath4 ) program @xmath32 , @xmath93 is a well - structured transition system with strong compatibility .",
    "finally we have the desired result .    [ theorem : decid1 ] given a range - restricted chr(@xmath4 ) program @xmath32 and a goal @xmath39 , the existence of an infinite computation for @xmath39 in @xmath32 is decidable .",
    "first observe that , due to our assumption on range - restricted programs , @xmath80 is finitely branching .",
    "in fact , as previously mentioned , the use of rule apply can not introduce new variables ( and hence new different states ) .",
    "the thesis follows immediately from lemma [ lemma : wstssc ] and theorem [ divdec ] .",
    "the previous theorem implies that range - restricted chr(@xmath4 ) is strictly less expressive than turing machines , in the sense that there can not exist a termination preserving encoding of turing machines into range - restricted chr(@xmath4 ) . to be more precise",
    ", we consider an encoding of a turing machine into a chr language as a function @xmath94 which , given a machine @xmath95 and an initial instantaneous description @xmath96 for @xmath95 , produces a chr program and a goal .",
    "this is denoted by @xmath97 .",
    "hence we have the following .",
    "an encoding @xmath94 of turing machines into a chr language is termination preserving is equivalent to the turing completeness of @xmath98 , however there is no general agreement on this , since for others a weak termination preserving encoding suffices . ]",
    "if the following holds : the machine @xmath95 starting with @xmath96 terminates iff the goal @xmath39 in the chr program @xmath32 has only terminating computations , where @xmath97 .",
    "the encoding is weak termination preserving if : the machine @xmath95 starting with @xmath96 terminates iff the goal @xmath39 in the chr program @xmath32 has at least one terminating computation .",
    "since termination is undecidable for turing machines , we have the following immediate corollary of theorem [ theorem : decid1 ] .    [",
    "theorem : decid2 ] there exists no termination preserving encoding of turing machines into range - restricted chr(@xmath4 ) .",
    "note that the previous result does not exclude the existence of weak encodings .",
    "for example , in @xcite it is showed that the existence an infinite computation is decidable in ccs ! , a variant of ccs , yet it is possible to provide a weak termination preserving encoding of turing machines in ccs ! ( essentially by adding spurious non - terminating computations ) .",
    "we conjecture that such an encoding is not possible for chr(@xmath4 ) .",
    "note also that previous results imply that range - restricted chr(@xmath4 ) is strictly less expressive than chr(@xmath4 ) : in fact there exists a termination preserving encoding of turing machines into chr(@xmath4 ) @xcite .",
    "as mentioned in the introduction , while chr(@xmath4 ) and chr@xmath5(@xmath33 ) are turing complete languages @xcite , the question of the expressive power of chr@xmath5(@xmath4 ) is open .",
    "here we answer to this question by proving that the existence of a terminating computation is decidable for this language , thus showing that chr@xmath5(@xmath4 ) is less expressive than turing machines . throughout this section",
    ", we assume that the abstract semantics @xmath35 is considered ( however see the discussion at the end for an extension to the case of @xmath34 ) .",
    "the proof we provide is a direct one , since neither well - structured transition systems nor reduction to petri nets can be used here ( see the introduction ) .",
    "we introduce here two more notions , namely the forest associated to a computation and the notion of reactive sequence , and some related results .",
    "we will need them for the main result of this section .",
    "first , we observe that it is possible to associate to the computation for an atomic goal @xmath39 in a program @xmath32 a tree where , intuitively , nodes are labeled by constraints ( recall that these are atomic formulae ) , the root is @xmath39 and every child node is obtained from the parent node by firing a rule in the program @xmath32 .",
    "this notion is defined precisely in the following , where we generalize it to the case of a generic ( non atomic ) goal , where for each chr constraint in the goal we have a tree .",
    "thus we obtain a _ forest _",
    "@xmath99 associated to a computation @xmath100 , where @xmath24 contains a node for each repetition of identified chr constraints in @xmath100 . before defining the forest we need the concept of _ repetition _ of an identified chr atom in a computation .",
    "let @xmath32 be a chr program and let @xmath100 be a computation in @xmath32 .",
    "we say that an occurrence of an identified chr constraint @xmath101 in @xmath100 is the @xmath10-th repetition of @xmath101 , denoted by @xmath102 , if it is preceded in @xmath100 by @xmath10 @xmath103 transitions of propagation rules whose heads match the atom @xmath101 .",
    "we also define @xmath104    [ def : forest ] let @xmath100 be a terminating computation for a goal in a chr@xmath5(@xmath4 ) program .",
    "the forest associated to @xmath100 , denoted by @xmath99 is defined as follows .",
    "@xmath24 contains nodes labeled either by repetitions of identified chr constraints in @xmath100 or by @xmath105 .",
    "@xmath106 is the set of edges .",
    "the labeling and the edges in @xmath106 are defined as follows :    \\(a ) for each chr constraint @xmath107 which occurs in the first configuration of @xmath100 there exists a tree in @xmath99 , whose root is labeled by a repetition @xmath108 , where @xmath109 is the identified chr constraint associated to @xmath107 in @xmath100 .",
    "\\(b ) if @xmath42 is a node in @xmath99 labeled by @xmath110 and the rule @xmath111 is used in @xmath100 to rewrite the repetition @xmath102 , where @xmath112 , the @xmath113 are chr constraints while @xmath114 contains built - ins , then we have two cases :    1",
    ".   if @xmath115 is @xmath116 then @xmath42 has @xmath117 sons , labeled by @xmath118 , for @xmath119 $ ] , and by @xmath120 , where the @xmath118 are the repetitions generated by the application of the rule @xmath121 to @xmath102 in @xmath100 .",
    "2 .   if @xmath115 is @xmath122 then : * if @xmath123 then @xmath42 has @xmath124 sons , labeled by @xmath118 , for @xmath119 $ ] , where @xmath118 are the repetitions generated by the application of the rule @xmath121 to @xmath102 in @xmath100 . * if @xmath125 then @xmath42 has @xmath126 son , labeled by @xmath105 .    note that , according to the previous definition , nodes which are not leaves are labeled by repetitions of identified constraints @xmath110 , where either @xmath127 or @xmath128 does not occur in the last configuration of @xmath100 . on the other hand ,",
    "the leaves of the trees in @xmath129 are labeled either by @xmath105 or by the repetitions which do not satisfy the condition above .",
    "an example can help to understand this crucial definition .",
    "[ label : example_forest ] let us consider the following program @xmath32 :    ....          r1 @ c(x , y ) < = > c(x , y),c(x , y )          r2 @ c(x , y ) < = > x = 0          r3 @ c(0,y ) = = > y = 0          r4 @ c(0,0 )",
    "< = > true ....    there exists a terminating computation @xmath100 for the goal @xmath130 in the program @xmath32 , which uses the clauses @xmath131 in that order and whose associated forest @xmath129 is the following tree :    note that the left branch corresponds to the termination obtained by using rule r2 , hence the superscript is not incremented . on the other hand , in the right branch",
    "the superscript @xmath132 at the second level becomes @xmath133 at the third level .",
    "this indicates that a propagation rule ( rule r3 ) has been applied .",
    "given a forest @xmath129 , we write @xmath134 to denote the subtree of @xmath129 rooted in the node @xmath42 . moreover , we identify a node with its label and we omit the specification of the repetition , when not needed .",
    "the following definition introduces some further terminology that we will need later .    *",
    "given a forest @xmath129 , a path from a root of a tree in the forest to a leaf is called a _ single constraint computation _ , or _",
    "sc - computation _ for short . * two repetitions @xmath102 and @xmath135 of identified chr constraints are called r - equal , indicated by @xmath136 , iff there exists a renaming @xmath137 such that @xmath138 * a sc - computation @xmath29 is @xmath139-repetitive if @xmath140 * the degree of a @xmath139-repetitive sc - computation @xmath29 , denoted by @xmath141 is the cardinality of the set @xmath142 which is defined as the maximal set having the following properties : * * contains a repetition @xmath102 in @xmath29 iff @xmath143 * * if @xmath102 is in @xmath142 then @xmath142 does not contain a repetition @xmath135 s.t . @xmath136 * a forest @xmath129 is @xmath144-repetitive if one of its sc - computation @xmath29 is @xmath144-repetitive and there is no @xmath145-repetitive sc - computation @xmath146 in @xmath129 with @xmath147 .",
    "* the degree @xmath148 of an @xmath144-repetitive forest @xmath129 is defined as @xmath149    after the forest , the second main notion that we need to introduce is that one of reactive sequence .    given a computation @xmath100 , we associate to each ( repetition of an ) occurrence of an identified chr atom @xmath109 in @xmath100 a , so called , reactive sequence of the form @xmath150 , where , for any @xmath151 $ ] , @xmath152 are built - in constraints .    intuitively each pair @xmath153 of built - in constraints represents all the @xmath103 transition steps , in the computation @xmath100 , which are used to rewrite the considered occurrence of the identified chr atom @xmath109 and the identified atoms derived from it .",
    "the constraint @xmath154 represents the input for this sequence of @xmath103 computation steps , while @xmath155 represents the output of such a sequence .",
    "hence one can also read such a pair as follows : the identified chr constraint @xmath109 , in @xmath100 , can transform the built - in store from @xmath154 to @xmath155 .",
    "different pairs @xmath153 and @xmath156 in the reactive sequence correspond to different sequences of @xmath103 transition steps .",
    "this intuitive notion is further clarified later ( definition [ def : seqrep ] ) , when we will consider a reactive sequence associated to a repetition of an identified chr atom .    since in chr computations",
    "the built - in store evolves monotonically , i.e. once a constraint is added it can not be retracted , it is natural to assume that reactive sequences are monotonically increasing .",
    "so in the following we will assume that , for each reactive sequence @xmath150 , the following condition holds : @xmath157 and @xmath158 for @xmath159 $ ] , @xmath160 $ ] .",
    "moreover , we denote the empty sequence by @xmath161 .",
    "next , we define the strictly increasing reactive sequences w.r.t . a set of variables @xmath31 .",
    "given a reactive sequence @xmath162 , with @xmath163 and a set of variables @xmath31 , we say that @xmath69 is strictly increasing with respect to @xmath31 if the following holds for any @xmath159 $ ] , @xmath160 $ ]    * @xmath164 , * @xmath165 and @xmath166 .",
    "given a generic reactive sequence @xmath162 and a set of variables @xmath31 , we can construct a new , strictly increasing sequence @xmath167 with respect to a set of variables @xmath31 as follows .",
    "first the operator @xmath168 restricts all the constraints in @xmath69 to the variables in @xmath31 ( by considering the existential closure with the exception of the variables in @xmath31 ) .",
    "then @xmath168 removes from the sequence all the stuttering steps ( namely the pairs of constraints @xmath169 , such that @xmath170 ) except the last . finally , in the sequence produced by the two previous steps , if there exists a pair of consecutive elements @xmath171 which are `` connected '' , in the sense that @xmath172 does not provide more information than @xmath173 , then such a pair is `` fused '' in ( i.e. , replaced by ) the unique element @xmath174 ( and this is repeated inductively for the new pairs )",
    "this is made precise by the following definition .",
    "[ def : eta ] let @xmath162 be a sequence of pairs of built - in stores and let @xmath31 be a set of variables .",
    "the sequence @xmath167 is the obtained as follows :    1 : :    first we define    @xmath175 ,    where for @xmath159 $ ]    @xmath176 and    @xmath177 .",
    "2 : :    then we define @xmath178 as the sequence obtained from    @xmath179 by removing each pair of the form    @xmath180 such that    @xmath170 , if such a pair is not    the last one of the sequence . 3 : :    finally we define @xmath181 , where    @xmath182 is the closure of @xmath178 w.r.t . the    following operation :",
    "if    @xmath171    is a pair of consecutive elements in the sequence and    @xmath183 holds then such a    pair is substituted by @xmath174 .",
    "the following lemma states a first useful property .",
    "the proof is in @xcite .",
    "[ lem : maxlungh ] let @xmath31 be a finite set of variables and let @xmath184 be a strictly increasing sequence with respect to @xmath31",
    ". then @xmath185 .",
    "next we note that , given a set of variables @xmath31 the possible strictly increasing sequences w.r.t .",
    "@xmath31 are finite ( up to logical equivalence on constraints ) , if the set of the constants is finite .",
    "this is the content of the following lemma , whose proof is in @xcite . here and in the following , with a slight abuse of notation , given two reactive sequences @xmath186 and @xmath187",
    ", we say that @xmath69 and @xmath179 are equal ( up to logical equivalence ) and we write @xmath188 , if for each @xmath189 $ ] @xmath190 and @xmath191 holds .",
    "[ theo : nummax ] let @xmath192 be a finite set of constants and let @xmath40 be a finite set of variables such that @xmath193 and @xmath194 .",
    "the set of sequences @xmath69 which are strictly increasing with respect to @xmath40 ( up to logical equivalence ) is finite and has cardinality at the most @xmath195    finally , we show how reactive sequences can be obtained from a forest associated to a computation .",
    "first we need to define the reactive sequence associated to a repetition of an identified chr atom in a computation . in this definition",
    "we use the operator @xmath168 introduced in definition [ def : eta ] .",
    "[ def : seqrep ] let @xmath100 be a computation for a chr@xmath5(@xmath4 ) program , @xmath196 be a repetition of an identified chr atom in @xmath100 and @xmath197 the sequence of the @xmath103 transition in @xmath100 that rewrite @xmath196 and all the repetitions derived from it .",
    "if @xmath198 let @xmath199 be the pair @xmath200 where @xmath91 and @xmath92 are all the built - ins in @xmath69 and @xmath179 . we will denote with @xmath201 the sequence @xmath202    finally we define the function @xmath203 which , given a node @xmath42 in a forest associated to a computation @xmath100 ( see definition [ def : forest ] ) , returns a reactive sequence .",
    "such a sequence intuitively represents the sequence of the @xmath103 transition steps which have been used in @xmath100 to rewrite the repetition labeling @xmath42 and the repetitions derived from it .",
    "let @xmath100 be a terminating computation and let @xmath99 be the forest associated to it . given a node @xmath42 in @xmath129",
    "we define :    * if the label of @xmath42 is @xmath102 , then @xmath204 ; * if the label of @xmath42 is @xmath105 then @xmath205 .",
    "let us consider for instance the forest shown in example [ label : example_forest ] .",
    "the sequences associated to the nodes of this forest are :    * @xmath206 * @xmath207 * @xmath208 * @xmath209      we are now ready to prove the main result of the paper .",
    "first we need the following lemma which has some similarities to the pumping lemma of regular and context free grammars .",
    "indeed , if the derivation is seen as a forest , this lemma allows us to compress a tree if in a path of the tree there are two r - equal constraints with an equal ( up to renaming ) sequence .",
    "the lemma is proved in @xcite .    here and in the following given a node @xmath42 in a forest @xmath210",
    "we denote by @xmath211 the label associated to @xmath42 .",
    "[ lem : substitute ] let @xmath100 be a terminating computation for the goal @xmath39 in the chr@xmath5(@xmath4 ) program @xmath32 .",
    "assume that @xmath129 is @xmath144-repetitive with @xmath212 and assume that there exists an @xmath144-repetitive sc - computation @xmath29 of @xmath129 and a repetition @xmath213 such that @xmath214 .",
    "+ moreover assume that there exist two distinct nodes @xmath42 and @xmath215 in @xmath29 such that @xmath215 is a node in @xmath134 , @xmath216 , @xmath217 and @xmath137 is a renaming such that @xmath218 and @xmath219 .",
    "then there exists a terminating computation @xmath220 for the goal @xmath39 in the program @xmath32 , such that either @xmath221 is @xmath145-repetitive with @xmath222 , or @xmath221 is @xmath144-repetitive and @xmath223 .",
    "finally we obtain the following result , which is the main result of this paper .",
    "[ theo : decidability_chr_1 ] let @xmath32 be a chr@xmath5(@xmath4 ) program an let @xmath39 be a goal .",
    "let @xmath224 be the number of distinct constants used in @xmath32 and in @xmath39 and let @xmath225 be the maximal arity of the chr constraints which occur in @xmath32 and in @xmath39 .",
    "@xmath39 has a terminating computation in @xmath32 if and only if there exists a terminating computation @xmath100 for @xmath39 in @xmath32 s.t .",
    "@xmath129 is @xmath124-repetitive and @xmath226    we prove only that if @xmath39 has a terminating computation in @xmath32 then there exists a terminating computation @xmath100 for @xmath39 in @xmath32 s.t .",
    "@xmath129 is @xmath124-repetitive and @xmath227 .",
    "the proof of the converse is straightforward and hence it is omitted .",
    "the proof is by contradiction .",
    "assume @xmath39 has a terminating computation @xmath100 in @xmath32 s.t .",
    "@xmath129 is @xmath124-repetitive , @xmath228 and there is no terminating computation @xmath220 for @xmath39 in @xmath32 such that @xmath221 is @xmath229-repetitive and @xmath230 .",
    "moreover , without loss of generality , we can assume that the degree of @xmath129 is minimal , namely there is no terminating computation @xmath220 for @xmath39 in @xmath32 such that @xmath221 is @xmath124-repetitive and @xmath231 .",
    "let @xmath29 be a @xmath124-repetitive sc - computation in @xmath232 .",
    "by definition , there exist @xmath124 repetitions of identified chr constraints @xmath233 in @xmath29 , which are @xmath121-equal .",
    "therefore there exist renamings @xmath234 such that @xmath235 for each @xmath236 $ ] .    by lemma [ theo : nummax ] for each chr constraint @xmath107 which occurs in @xmath32 or in @xmath39 , the set of sequences @xmath69 which are strictly increasing with respect to @xmath237 ( up to logical equivalence ) is finite and has cardinality at the most @xmath98 .",
    "then there are two distinct nodes @xmath42 and @xmath215 in @xmath29 and there exist @xmath236 $ ] such that @xmath238 and @xmath239 and @xmath240",
    ". then we have a contradiction , since by lemma [ lem : substitute ] this implies that there exists a terminating computation @xmath220 for @xmath39 in @xmath32 s.t .",
    "either @xmath221 is @xmath229-repetitive with @xmath230 or @xmath221 is @xmath124-repetitive and @xmath231 and then the thesis .    as an immediate corollary of the previous theorem",
    "we have that the existence of a terminating computation for a goal @xmath39 in a chr@xmath5(@xmath4 ) program @xmath32 is decidable .",
    "then we have also the following result , which is stronger than corollary [ theorem : decid2 ] since here weak encodings are considered .",
    "[ theorem : decid3 ] there is no weak termination preserving encoding of turing machines into chr@xmath5(@xmath4 ) .    as mentioned at the beginning of this section ,",
    "the previous result is obtained when considering the abstract semantics @xmath35 .",
    "however it holds also when considering the theoretical semantics @xmath34 .",
    "in fact lemma [ lem : substitute ] holds if we require that two r - equal constraints have the same sequence and have fired the same propagation rules .",
    "since the propagation rules are finite theorem [ theo : decidability_chr_1 ] is still valid if @xmath241 where @xmath121 is the number of propagation rules .",
    "we have shown two decidability results for two fragments of chr(@xmath4 ) , the chr language defined over a signature which does not allow function symbols .",
    "the first result , in section [ sec : rr ] , assumes the abstract operational semantics , while the second one , in section [ sec : sh ] , holds for both semantics ( abstract and theoretical ) .",
    "these results are not immediate .",
    "indeed , chr(@xmath4 ) , without further restrictions and with any of the two semantics , is a turing complete language @xcite .",
    "it remains quite expressive also with our restrictions : for example , chr@xmath5(@xmath4 ) , the second fragment that we have considered , allows an infinite number of different states , hence , for example , it can not be translated to petri nets .",
    "these results imply that range - restricted chr(@xmath4 ) and chr@xmath5(@xmath4 ) , the two considered fragments , are strictly less expressive than turing machines ( and therefore than chr(@xmath4 ) ) . also , it seems that range - restricted chr(@xmath4 ) is more expressive that chr@xmath5(@xmath4 ) , since the decidability result for the second language is stronger .",
    "however , a direct result in this sense is left for future work . also , we leave to future work to establish a decidability result for range - restricted chr(@xmath4 ) under an operational semantics which includes a propagation history .",
    "this is not easy , since in this case it appears difficult to apply the theory of well - structured transition systems ( the well - quasi - order we have defined does not work ) .",
    "several papers have considered the expressive power of chr in the last few years . in particular , showed that a further restriction of chr@xmath5(@xmath4 ) , which does not allow built - ins in the body of rules ( and which therefore does not allow unification of terms ) is not turing complete .",
    "this result is obtained by translating chr@xmath5(@xmath4 ) programs ( without unification ) into propositional chr and using the encoding of propositional chr intro petri nets provided in @xcite .",
    "the translation to propositional chr is not possible for the language ( with unification ) chr@xmath5(@xmath4 ) that we consider .",
    "also provides a translation of range - restricted chr(@xmath4 ) to petri nets .",
    "however in this translation , differently from our case , it is also assumed that no unification built - in can be used in the rules , and only ground goals are considered .",
    "related to this paper is also @xcite , where it is shown that chr(@xmath33 ) is turing complete and that restricting to single - headed rules decreases the computational power of chr .",
    "however , these results are based on the theory of language embedding , developed in the field of concurrency theory to compare turing complete languages , hence they do not establish any decidability result .",
    "another related study is @xcite , where the authors show that it is possible to implement any algorithm in chr in an efficient way , i.e. with the best known time and space complexity .",
    "earlier works by frhwirth @xcite studied the time complexity of simplification rules for naive implementations of chr . in this approach",
    "an upper bound on the derivation length , combined with a worst - case estimate of ( the number and cost of ) rule application attempts , allows to obtain an upper bound of the time complexity .",
    "the aim of all these works is clearly different from ours .",
    "p0.35|c|c|c _ host language @xmath31 _ & _ operational semantics _ & @xmath242 & @xmath243 + p ( propositional ) & abstract & no & no + & abstract & no & * no * + & & & + c ( constants ) , without = & any & no & yes + c ( constants ) ( cf .  section  [ sec : sh ] ) & any & * no * & yes + f ( functors ) & any & yes & yes +    a summary of the existing results concerning the computational power of several dialects of chr is shown in table [ tbl : overview ] . in this table , `` no '' and `` yes '' refer to the existence of a termination preserving encoding of turing machines into the considered language , while `` any '' means theoretical or abstract .",
    "the new results shown in this paper are indicated in a bold font .",
    "we would like to thank the reviewers for their precise and helpful comments .",
    "this research was partially supported by the miur prin 20089m932n project : `` innovative and multi - disciplinary approaches for constraint and preference reasoning '' .    , cerans , k. , jonsson , b. , and tsay , y .- k .",
    "general decidability theorems for infinite - state systems . in _ in proceedings , 11th annual ieee symposium on logic in computer science , lics96_. 313321 .      , gabbrielli , m. , and zavattaro , g. 2004 . comparing recursion , replication , and iteration in process calculi . in _",
    "icalp _ , j.  daz , j.  karhumki , a.  lepist , and d.  sannella , eds .",
    "lecture notes in computer science , vol . 3142 .",
    "springer , 307319 .",
    "on the asynchronous nature of communication in concurrent logic languages : a fully abstract model based on sequences . in _ concur _",
    ", j.  c.  m. baeten and j.  w. klop , eds .",
    "lecture notes in computer science , vol .",
    "springer , 99114 .      ,",
    "stuckey , p.  j. , , m. , and holzbaur , c. 2004 .",
    "the refined operational semantics of constraint handling rules . in _ iclp 04 _",
    ", b.  demoen and v.  lifschitz , eds .",
    "lncs , vol .",
    "springer , saint - malo , france , 90104 ."
  ],
  "abstract_text": [
    "<S> we study the decidability of termination for two chr dialects which , similarly to the datalog like languages , are defined by using a signature which does not allow function symbols ( of arity @xmath0 ) . </S>",
    "<S> both languages allow the use of the @xmath1 built - in in the body of rules , thus are built on a host language that supports unification . </S>",
    "<S> however each imposes one further restriction . </S>",
    "<S> the first chr dialect allows only _ range - restricted _ </S>",
    "<S> rules , that is , it does not allow the use of variables in the body or in the guard of a rule if they do not appear in the head . </S>",
    "<S> we show that the existence of an infinite computation is decidable for this dialect . </S>",
    "<S> the second dialect instead limits the number of atoms in the head of rules to one . </S>",
    "<S> we prove that in this case , the existence of a terminating computation is decidable . </S>",
    "<S> these results show that both dialects are strictly less expressive than turing machines . </S>",
    "<S> it is worth noting that the language ( without function symbols ) without these restrictions is as expressive as turing machines .    </S>",
    "<S> constraint programming , expressivity , well - structured transition systems . </S>"
  ]
}