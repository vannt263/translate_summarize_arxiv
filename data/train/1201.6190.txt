{
  "article_text": [
    "over the last years , voice over ip ( voip ) has gained momentum as the natural complementary to emails , although its adoption is still young .",
    "the technologies employed in voip are widely similar to those used for e - mails and a large portion is actually identical . as a result",
    ", one can easily produce hundreds concurrent calls per second from a single machine , replaying a pre - encoded message as soon as the callee accepts the call .",
    "this application of spam over internet telephony  also known as spit  is considered by many experts of voip as a severe potential threat to the usability of the technology @xcite .",
    "more concerning , many of the defensive measures that are effective against email spam do not directly translate in spit mitigation : unlike with spam in emails , where the content of a message is text and is available to be analyzed _ before _ the decision is made of whether to deliver it or flag it as spam , the content of a phone call is a voice stream and is only available when the call is actually answered .",
    "the simplest guard against spit would be to enforce strongly authenticated identities ( maintaining caller identities on a secure and central server ) together with personalized white lists ( allowing only friends to call ) and a consent framework ( having unknown users first ask for permission to get added to the list ) . however , this is not supported by the current communication protocols and also seems to be infeasible in practice .",
    "thus a number of different approaches have been previously suggested to address spit prevention , which mostly derive from experience in e - mail or web spam defense .",
    "they range from reputation - based @xcite and call - frequency based @xcite dynamic black - listing , fingerprinting @xcite , to challenging suspicious calls by captchas @xcite , or the use of more sophisticated machine learning .",
    "for example , @xcite suggests svm for anomaly detection in call histories , and @xcite proposes semi - supervised learning , a variant of k - means clustering with features optimized from partially labeled data , to cluster and discriminate spit from regular calls .",
    "these methods provide interesting building blocks , but , in our opinion , suffer from two main shortcomings .",
    "first , they do not provide performance guarantees in the sense that it is difficult to get an estimate of the number of spit calls that will go through and the number of regular calls they will erroneously stop .",
    "second , they require a lot of hand - tuning for working well , which can not be sustained in today s networks .    the initial motivation for this paper was to explore whether there would be ways to design spit filters that would not suffer from these two shortcomings . for this , we start by considering an abstracted scenario amenable to theoretical analysis where we make essentially two simplifying assumptions :    1 .",
    "we are dealing with _",
    "pure source _ spit detection in an _ outbound _ scenario , 2 .",
    "we can extract features from calls ( such as , for example , call duration ) whose distribution for spit and regular calls is _ known in advance_.    here , `` outbound scenario '' means that our spit detector will be located in , or at the egde of , the network where the source resides , and will check all outgoing calls originating from within the network . technically , this means that we are able to easily map calls to sources and that we can observe multiple calls from each source . by `` pure source '' we mean that a source either produces only spit or only non - spit calls for a certain observation horizon . under these assumptions ,",
    "we have been able to design a spit filter which requires no tuning and no user feedback and which is optimal in a sense that will be defined later in this paper .",
    "this paper reports on this spit filter and is organized in two parts : one theoretical in section  3 and one practical in section  4 . the theoretical part starts with section  [ seq : problem statement ] describing precisely and in mathematical terms the context in which we will design the spit filter .",
    "section  [ seq : algorithm ] shows how it is then possible to derive from a simple statistical test a spit filter with the desired properties and section  [ seq : expectedloss ] provides analytical expressions to compute its performance .",
    "monte carlo simulations in section  [ seq : example_exponential ] and [ seq : experiment1 ] then examine the theoretical performance of the spit filter .",
    "the practical part starts with section 4.1 describing how the spit filter could be integrated as one module into a larger hierarchical spit prevention framework .",
    "the primary purpose of this section is to demonstrate that the assumptions we make in section 3 are well justified and can be easily dealt with in a real world application .",
    "( note that a detailed description of the system architecture is not the goal of this paper . ) for example , section 4.2 describes how the assumption that the distributions for spit and non - spit must be known in advance can be dealt with using maximum likelihood estimation from labeled prior data ( which in addition allows us to elegantly address the problem of nonstationary attackers ) .",
    "then , using learned distributions , section 4.3 demonstrates for data extracted from a large database of real - world voice call data that the performance of our spit filter in the real world is also very good and is in accordance with the performance bounds derived analytically in section 3 .",
    "to systematically place our work in the context of related prior work , we will have to consider it along two axes . the first axis deals with ( low - level ) _ detection _ algorithms : here we have to deal with the question on what abstract object we want to work with ( e.g. , sip headers , stream data , call histories ) , how to represent this object such that computational algorithms can be applied ( e.g. , what features ) , and what precise algorithm is applied to arrive at a decision , which can be a binary classification ( non - spit / spit ) , a score ( interpreted as how likely it is to be non - spit / spit ) , or something else .",
    "the second axis deals with larger spit detection _ frameworks _ in which the ( low - level ) detection algorithm is only a small piece .",
    "the framework manages and controls the complete flow and encompasses detection , countermeasures , and self - healing .",
    "the formal framework for spit filtering we propose in this paper clearly belongs to the first category and only addresses low - level detection .",
    "the progressive multi gray - leveling ( pmgl ) proposed in @xcite is a low - level detector that monitors call patterns and assigns a gray level to each caller based on the number of calls placed on a short and long term . if the gray level is higher than a certain threshold , the call is deemed spit and the caller blocked .",
    "the pmgl is similar to what we are doing in that it attempts to identify sources that are compromised by bot nets in an outbound scenario .",
    "the major weakness of the pmgl is : ( 1 ) that it relies on a weak feature , as spitters can easily adapt and reduce their calling rate to remain below the detection threshold , and high calling rates can also have other valid causes such as a natural disaster ; ( 2 ) that it relies on `` carefully '' hand - tuned detection thresholds to work , which makes good performance in the real world questionable and  in our opinion  is not a very desirable property as it does not come with any worst - case bounds or performance guarantees .",
    "our approach is exactly the opposite as it starts from a mathematically justified scenario and explicitly provides performance guarantees and worst - case bounds .",
    "our approach is also more generic because it can work with _ any _ feature representation : while we suggest call duration is a better choice than call rate , our framework will work with whatever feature representation a network operator might think is a good choice ( given their data ) .    in @xcite a low - level detector based on semi - supervised",
    "clustering is proposed .",
    "they use a large number of call features , and because most of the features become available only after a call is accepted , is also primarily meant to classify pure sources ( as we do ) .",
    "the algorithm they propose is more complex and computationally more demanding than what we propose .",
    "in addition , their algorithm also relies on hand - tuned parameters and is hard to study analytically ; thus again it is impossible to have performance guarantees and derive worst - case bounds for it . performance - wise it is hard to precisely compare the results due to a different experimental setup , but our algorithm compares favorably and achieves a very high accuracy .",
    "the authors of @xcite propose to use support vector machines for identifying a varied set of voip misbehaviors , including spit .",
    "their approach works on a different representation of the problem ( call histories ) with a different goal in mind and thus is not directly comparable with what we do . while it also can not offer performance guarantees and worst - case bounds , in some respect it is more general than what we propose ; it also describes both detection and remediation mechanisms in a larger framework .    in seal @xcite ,",
    "the authors propose a complete framework for spit prevention which is organized in two stages ( passive and active ) .",
    "the passive stage performs low - level detection and consists of simple , unintrusive and computationally cheap tests , which , however , will only be successful in some cases and can be easily fooled otherwise .",
    "the purpose of the passive stage is to screen incoming calls and flag those that could be spit .",
    "the active stage then performs the more complex , intrusive and computationally expensive tests , which with very high probability can identify spit ( these tests more actively interact with the caller ) .",
    "seal is very similar to what we sketch in section  4 of this paper . on the other hand ,",
    "the low - level detection performed in seal is rather basic : while it is more widely applicable than what we do , it essentially consists only in comparing a weighted sum of features against a threshold . as with all the other related work ,",
    "weights and thresholds again need to be carefully determined by hand ; and again , since the problem is not modeled mathematically , performance guarantees and worst - case bounds are impossible to derive .    finally , it should be noted that , while the problem of spit detection can , in some sense , be related to the problem of anomaly detection and prevention of dos attacks in voip networks , for example see the work in @xcite , it is not the same . the reason why this is not",
    "the same is that these security threats are typically specific attacks aimed at disrupting the normal operation of the network .",
    "spit on the other hand operates on the social level and may consist of unwanted advertisements or phishing attempts  but not _ per se _ malicious code . as a consequence , techniques from anomaly detection and prevention of dos attacks can not be directly applied to spit detection .",
    "this section describes a formal framework for an outbound spit filter for which it is possible to prove optimality and provide performance guarantees .",
    "note that this section is stated from a theoretical point of view . in section  [ seq : real world ]",
    "we outline how one could implement it in a real world scenario .",
    "as shown in figure  [ fig:1 ] , we assume the following situation : the spit filter receives and monitors incoming calls from a number of different sources ( in real - world operation the spit filter will be placed in the outbound network , but implementation details such as this will be ignored in this theoretical section ) .",
    "the sources are independent from each other and will each place numerous calls over time .",
    "we assume that , over a given observation horizon , each source will either _ only produce regular calls _ or will _ only produce spit calls_. as the sources are independent , we can run a separate instance of the spit filter for each and thus in the following will only deal with the case of a single source .",
    "every time a call arrives at the filter , the filter can do one of two things : ( i ) accept the call and pass it on the recipient or ( ii ) block the call .",
    "each call will be associated with certain features and we assume that only if a call is accepted , we can observe the corresponding feature ( e.g. , call duration ) .",
    "the fundamental assumption we then make is that the distribution over these features will be different depending on whether a call is a spit call or a regular call , and that these distributions are known in advance .",
    "our goal is to decide , after observing a few calls , whether or not the source sends out spit .",
    "more precisely , we look for a decision policy that initially accepts all calls , thus refining the belief about whether or not the source is spit , and then at some point decides to either block or accept all future calls from the source . seen as a single - state decision problem over time , the spit filter has three possible actions : ( 1 ) accept the next call , which reveals its features and thus refines the belief about the type of the source , ( 2 ) block all future calls , and ( 3 ) accept all future calls .",
    "the last two actions immediately stop the decision - making process and , if the decision was wrong ( that is , deciding to accept when in truth the source is spit , or deciding to block when in truth the source is non - spit ) , will incur a terminal loss proportional to the number of remaining calls .",
    "in addition , we also have a per step cost during the initial exploration if the source is of type spit ( for erroneously accepting spit calls ) .    in doing so ,",
    "we arrive at a well defined concept of loss . within the framework outlined above",
    ", every conceivable spit filter algorithm will have a performance number : its expected loss .",
    "the particular spit filter that we are going to describe below will be one that minimizes this expected loss .",
    "note that the expected loss is an example for the typical exploration vs exploitation dilemma . on the one side ,",
    "since the decision to accept or block all future calls is terminal , we want to be very certain about its correctness to avoid making an expensive error . on the other side ,",
    "as long as we are observing we are automatically accepting all calls and thus will increase our loss if the source turns out to produce spit calls . to minimize our expected loss , we therefore also want to observe as few samples as possible .        to address the problem mathematically",
    ", we employ wald s sequential probability ratio test for simple hypotheses introduced in @xcite .",
    "the sequential probability ratio test ( sprt ) has the remarkable property that among all sequential tests procedures it minimizes the expected number of samples for a given level of certainty and regardless of which hypothesis is true ( the optimality of sprt was proved in @xcite ) .",
    "in addition , the sprt comes with bounds for the expected stopping time and thus allows us to derive concrete expressions for the expected loss as a function of the characteristics of the particular problem ( meaning we can express the loss as a function of the parameters of the distribution for spit or non - spit ) .",
    "finally , sprt requires only simple algebraic operations to carry out and thus is easy to implement and computationally cheap to run .",
    "the sprt is a test of one simple statistical hypothesis against another which operates in an online fashion and processes the data sequentially . at every time",
    "step a new observation is processed and one of the following three decisions is made : ( 1 ) the hypothesis being tested is accepted , ( 2 ) the hypothesis being tested is rejected and the alternative hypothesis is accepted , ( 3 ) the test statistic is not yet conclusive and further observations are necessary .",
    "if the first or the second decision is made , the test procedure is terminated .",
    "otherwise the process continues until at some later time the first or second decision is made .",
    "two kind of misclassification errors may arise : decide to accept calls when source is spit , or decide to block all future calls when source is non - spit .",
    "different costs may be assigned to each kind , upon which the performance optimization process described in section  [ seq : expectedloss ] is built .    to model the spit detection problem with the sprt",
    ", we now proceed as follows : assume we can make sequential observations from one source of _ a priori _ unknown type spit or non - spit .",
    "let @xmath2 denote the features of the @xmath3-th call we observe , modeled by random variable @xmath4 .",
    "the @xmath4 are i.i.d . with common distribution ( or density ) @xmath5 .",
    "the calls all originate from one source which can either be of type spit with distribution @xmath6 or of type non - spit with distribution @xmath7 .",
    "initially , the type of the source we are receiving calls from is not known ; in absence of other information we have to assume that both types are equally likely , thus the prior would be @xmath8 . in order to learn the type of the source , we observe calls @xmath9 and test the hypothesis @xmath10 (",
    "note again that in this formulation we assume that the densities @xmath11 and @xmath12 are both known so that we can readily evaluate the expression @xmath13 and @xmath14 for any given @xmath15 . )    at time @xmath3 we observe @xmath2 .",
    "let @xmath16 be the ratio of the likelihoods of each hypothesis after @xmath3 observations @xmath17 .",
    "since the @xmath18 are independent we can factor the joint distribution on the left side to obtain the right side . in practice",
    "it will be more convenient for numerical reasons to work with the log - likelihoods .",
    "doing this allows us to write a particular simple recursive update for the log - likelihood ratio @xmath19 , that is @xmath20 after each update we examine which of the following three cases applies and act accordingly : @xmath21 thresholds @xmath22 and @xmath23 with @xmath24 depend on the desired accuracy or error probabilities of the test : @xmath25 note that @xmath26 and @xmath27 need to be specified in advance such that certain accuracy requirements are met ( see next section where we consider the expected loss of the procedure ) .",
    "the threshold values @xmath22 and @xmath23 and error probabilities @xmath26 and @xmath27 are connected in the following way @xmath28 note that the inequalities arise because of the discrete nature of making observations ( i.e. , at @xmath29 ) which results in @xmath30 not being able to hit the boundaries exactly . in practice",
    "we will neglect this excess and treat the inequalities as equalities : @xmath31    let @xmath32 be the random time at which the sequence of the @xmath30 leaves the open interval @xmath33 and a decision is made that terminates the sampling process .",
    "( note that stopping time @xmath32 is a random quantity due to the randomness of the sample generation . )",
    "the sprt provides the following pair of inequalities ( equalities ) for the expected stopping time ( corresponding to each of the two possibilities ) @xmath34 & = \\frac{1}{\\kappa_0 } \\left ( \\alpha \\log \\frac{1-\\beta}{\\alpha }   + ( 1-\\alpha ) \\log \\frac{\\beta}{1-\\alpha } \\right ) \\label{eq : stopping_spit}\\\\ e_{x_i \\sim { p_{\\text{non - spit}}}}[t ] & = \\frac{1}{\\kappa_1 } \\left ( \\beta \\log \\frac{\\beta}{1-\\alpha }   + ( 1-\\beta ) \\log \\frac{1-\\beta}{\\alpha } \\right ) \\label{eq : stopping_nonspit}.\\end{aligned}\\ ] ] the constants @xmath35 with @xmath36 are the kullback - leibler information numbers defined by @xmath37 \\label{eq : k0 } \\\\",
    "\\kappa_1 & = e_{x\\sim { p_{\\text{non - spit } } } } \\left [ \\log \\frac{p(x|\\text{non - spit})}{p(x|\\text{spit } ) } \\right]\\label{eq : k1}. \\end{aligned}\\ ] ] the constants @xmath35 can be interpreted as a measure of how difficult it is to distinguish between @xmath11 and @xmath12 .",
    "the smaller they are the more difficult is the problem .",
    "we will now look at the performance of our spit filter and derive expressions for its expected loss .",
    "let us assume we are going to receive a finite number @xmath38 of calls and that @xmath38 is sufficiently large such that the test will always stop before the calls are exhausted ( the case where we observe fewer samples than what the test demands will be ignored for now , e.g. , see the truncated sprt @xcite ) .    how does the filter work ? at the beginning all calls are accepted ( observing samples @xmath39 ) until the test becomes sufficiently certain about its prediction .",
    "once the test becomes sufficiently certain , based on the outcome the filter implements the following simple policy : if the test returns that the source is spit then all future calls from it will be blocked .",
    "if the test says that the source is non - spit then all future calls from it will be accepted .",
    "since the decision could be wrong , we define the following cost matrix ( per call ) :    [ cols=\"<,^,^\",options=\"header \" , ]",
    "in this paper , we presented the first theoretical approach to spit filtering that is based on a rigorous mathematical formulation of the underlying problem and , in consequence , allows one to derive performance guarantees in terms of worst case cumulative misclassification cost ( the expected loss ) and thus , on the number of samples that are required to establish with the required level of confidence that a source is indeed a spitter .",
    "the method is optimal under the assumption of knowing the generating distributions , does not rely on manual tuning and tweaking of parameters , and is computationally simple and scalable .",
    "these are desirable features that make it a component of choice in a larger , autonomic framework .",
    "moreover , we have outlined the procedure that needs to be followed to apply this spit filter as an _ outbound _ filter in a realistic spit prevention system , including which potential call features to use and how the best feature could be found from the candidates via automated feature selection . in particular ,",
    "we have sketched how the generating distributions can be learned from data .",
    "the difficulty of the problem of successfully detecting spit is then only related to how similar / dissimilar the generating distributions are .",
    "this difficulty can be quantitatively expressed in terms of the kullback - leibler information numbers @xmath40which in turn can be calculated analytically or approximately from the learned distributions .",
    "taken together this means that the worst case performance of the spit filter can be computed in real - world operation ( and can thus be potentially used to tune the other hyperparameters of the whole system ) .    our experimental evaluation , both on data synthetically generated and on data extracted from real - world call data , verifies that our approach is feasible , efficient ( `` efficient '' meaning that only very few calls need to be observed from a source to identify spit ) , and able to produce highly accurate results even when the generating distribution is not _ a priori _ specified but inferred from data .",
    "damien ernst ( research associate ) and sylvain martin ( post - doctoral researcher ) acknowledge the financial support of the belgian fund of scientific research ( fnrs).this work is also partially funded by eu project resumenet , fp7224619 ."
  ],
  "abstract_text": [
    "<S> this paper presents a formal framework for identifying and filtering spit calls ( spam in internet telephony ) in an outbound scenario with provable optimal performance . in so doing , </S>",
    "<S> our work is largely different from related previous work : our goal is to rigorously formalize the problem in terms of mathematical decision theory , find the optimal solution to the problem , and derive concrete bounds for its expected loss ( number of mistakes the spit filter will make in the worst case ) . </S>",
    "<S> this goal is achieved by considering an abstracted scenario amenable to theoretical analysis , namely spit detection in an outbound scenario with pure sources . </S>",
    "<S> our methodology is to first define the cost of making an error ( false positive and false negative ) , apply wald s sequential probability ratio test to the individual sources , and then determine analytically error probabilities such that the resulting expected loss is minimized . </S>",
    "<S> the benefits of our approach are : ( 1 ) the method is optimal ( in a sense defined in the paper ) ; ( 2 ) the method does not rely on manual tuning and tweaking of parameters but is completely self - contained and mathematically justified ; ( 3 ) the method is computationally simple and scalable . </S>",
    "<S> these are desirable features that would make our method a component of choice in larger , autonomic frameworks .    * outbound spit filter with optimal performance guarantees *    @xmath0 + ( corresponding author ) + tjung@ulg.ac.be +    * sylvain martin*@xmath0 + sylvain.martin@ulg.ac.be +    * mohamed nassar@xmath1 + * mohamed.nassar@inria.fr +    * damien ernst*@xmath0 + dernst@ulg.ac.be +    * guy leduc*@xmath0 + guy.leduc@ulg.ac.be +    @xmath0montefiore institute ( department of eecs ) + university of lige + belgium    @xmath1 inria grand est - loria research center + france    * outbound spit filters with optimal performance guarantees * +    draft november 30 , 2011    * keywords : * security , internet telephony , spam , sequential probability ratio test    outbound spit filters with optimal performance guarantees </S>"
  ]
}