{
  "article_text": [
    "when querying a database , a user may not always obtain the expected results , and the system could provide some explanations",
    ". they could be useful to further understand the data or check if the query is the intended one .",
    "actually , the notion of explanation for a query result was introduced in @xcite , on the basis of the deeper concept of _ actual causation_.    a tuple @xmath0 is an _ actual cause _ for an answer @xmath1 to a conjunctive query @xmath2 from a relational database instance @xmath3 if there is a _ contingent _ set of tuples @xmath4 , such that , after removing @xmath4 from @xmath3 , @xmath1 is still an answer , but after further removing @xmath0 from @xmath5 , @xmath1 is not an answer anymore . here , @xmath4 is a set of tuples that has to accompany @xmath1 for it to be a cause .",
    "actual causes and contingent tuples are restricted to be among a pre - specified set of _ endogenous tuples _ , which are admissible , possible candidates for causes , as opposed to _ exogenous tuples _ , which may also be present in the database . in rest of this paper , whenever we simply say  cause \" , we mean  actual cause \" .    in applications involving large data sets , it is crucial to rank potential causes by their _ responsibilities _",
    "@xcite , which reflect the relative ( quantitative ) degrees of their causality for a query result . the responsibility measure for a cause",
    "is based on its _ contingency sets _ : the smallest ( one of ) its contingency sets , the strongest it is as a cause .",
    "actual causation , as used in @xcite , can be traced back to @xcite , which provides a model - based account of causation on the basis of _ counterfactual dependence_. _ causal responsibility _ was introduced in @xcite , to provide a graded , quantitative notion of causality when multiple causes may over - determine an outcome .",
    "apart from the explicit use of causality , research on explanations for query results has focused mainly , and rather implicitly , on provenance @xcite    .",
    "a close connection between causality and provenance has been established in @xcite . however , causality is a more refined notion that identifies causes for query results on the basis of user - defined criteria , and ranks causes according to their responsibilities @xcite .    _ consistency - based diagnosis _",
    "@xcite , a form of model - based diagnosis @xcite , is an area of knowledge representation .",
    "the problem here is , given the _ specification _ of a system in some logical formalism and a usually unexpected _ observation _ about the system , to obtain _ explanations _ for the observation , in the form of a diagnosis for the unintended behavior .    in a different direction , a database instance , @xmath3 , that is expected to satisfy certain integrity constraints may fail to do so . in this case",
    ", a _ repair _ of @xmath3 is a database @xmath6 that does satisfy the integrity constraints and _ minimally departs _ from @xmath3 .",
    "different forms of minimality can be applied and investigated .",
    "consistent answer _ to a query from @xmath3 and wrt .",
    "the integrity constraints is a query answer that is obtained from all possible repairs , i.e. is invariant or certain under the class of repairs .",
    "these notions were introduced in @xcite ( see @xcite for surveys ) .",
    "these three forms of reasoning , namely inferring causes from databases , consistency - based diagnosis , and consistent query answering ( and repairs ) are all _ non - monotonic _ @xcite .",
    "for example , a ( most responsible ) cause for a query result may not be such anymore after the database is updated .",
    "furthermore , they all reflect some sort of _ uncertainty _ about the information at hand . in this work",
    "we establish natural , precise , useful , and deeper connections between these three reasoning tasks .",
    "more precisely , we unveil a strong connection between computing causes and their responsibilities for conjunctive query answers , on one hand , and computing repairs in databases wrt .",
    "_ denial constraints _ , on the other .",
    "these computational problems can be reduced to each other . in order to obtain repairs wrt . _ a set _ of denial constraints from causes , we investigate causes for queries that are _ unions of conjunctive queries _ , and develop algorithms to compute causes and responsibilities .",
    "we show that inferring and computing actual causes and their responsibilities in a database setting become diagnosis reasoning problems and tasks .",
    "actually , a causality - based explanation for a conjunctive query answer can be viewed as a diagnosis , where in essence the first - order logical reconstruction of the relational database provides the system description @xcite , and the observation is the query answer .",
    "we also establish a bidirectional connection between diagnosis and repairs .",
    "being the causality problems the main focus of this work , we take advantage of algorithms and complexity results both for consistency - based diagnosis on one side ; and database repairs and consistent query answering @xcite , on another . in this way , we obtain new complexity results for the main problems of causality , namely computing actual causes , determining their responsibilities , and obtaining most responsible causes ; and also for their decision versions .",
    "in particular , we obtain fixed - parameter polynomial - time algorithms for some of them . more precisely , our main results are as follows :  ( the complexity results are all in data complexity )    \\1 .  for a boolean conjunctive query and its associated denial constraint ( the former being the violation view of the latter )",
    ", we establish a precise connection ( characterization and computational reductions ) between actual causes for the query ( being true ) and the subset- and cardinality - repairs of the instance wrt .  the denial constraint .",
    "we obtain causes from repairs .",
    "we obtain repairs from causes . for this",
    "we extend the treatment of causality to unions of conjunctive queries ( to represent multiple denial constraints ) .",
    "we characterize an actual cause s responsibility in terms of cardinality - repairs .",
    "we provide algorithms to compute causes and their ( minimal ) contingency sets for unions of conjunctive queries .",
    "the causes can be computed in ptime .",
    "we establish a precise connection between consistency - based diagnosis for a boolean conjunctive query being unexpectedly true according to a system description , and causes for the query being true .",
    "in particular , we show how to compute actual causes , their contingency sets , and responsibilities using the diagnosis characterization . hitting - set - based algorithmic approaches to diagnosis",
    "inspire our algorithmic / complexity approaches to causality .",
    "we reformulate the causality problems as hitting set problems and vertex cover problems on hypergraphs , which allows us to apply results and techniques for the latter to causality .",
    "( a ) checking minimal contingency sets can be done in ptime .",
    "( b ) the responsibility ( decision ) problem for conjunctive queries becomes _ np_-complete .",
    "( c ) however , it is fixed - parameter tractable when the parameter is the inverse of the responsibility bound .",
    "( d ) the functional problem of computing the causes responsibilities is @xmath7-complete , and deciding most responsible causes is @xmath8-complete .",
    "the structure of the resulting hitting - set problem allows us to obtain efficient parameterized algorithms and good approximation algorithms for computing causes and minimal contingency sets .",
    "\\7 .  on the basis of the causality / repair connection , and the dichotomy result for causality @xcite",
    ", we obtain a dichotomy result for the complexity of deciding the existence of repairs of a certain size wrt .",
    "single , self - join - free denial constraints .",
    "\\8 .  from the repair - diagnosis connection we also obtain some complexity results for consistency based - diagnosis .",
    "we define notions of preferred causes ; in particular one based on prioritized repairs @xcite .",
    "we also propose an approach to causality base on interventions that are repair actions that replace attribute values by null values .",
    "we discuss extensions and open issues that deserve investigation .",
    "the paper is structured as follows .",
    "section [ sec : prel ] introduces technical preliminaries for relational databases , causality in databases , database repairs and consistent query answering , consistency - based diagnosis , and relevant complexity classes .",
    "section [ sec : causfrepair ] characterizes actual causes and responsibilities in terms of database repairs .",
    "section [ sec : repairfcauses ] characterizes repairs and consistent query answering in terms of causes and contingency sets for queries that are unions of conjunctive queries ; and presents an algorithm for computing both of the latter .",
    "section [ sec : mbdtorep ] formulates causality problems as consistency - based diagnosis problems , and the latter as repair problems .",
    "section [ sec : mbdcomx ] shows complexity and algorithmic results ; in particular a fixed - parameter tractability result for causes responsibilities , and also about consistency based - diagnosis .",
    "section [ sec : pref - cause ] deals with preferred causes .",
    "section [ sec : disc ] discusses several relevant issues , connections and open problems around causality in databases .",
    "section [ sec : concl ] draws some final conclusions .",
    "we provide proofs for all the results except for those that are rather straightforward .",
    "this is an extended version of @xcite .",
    "it contains proofs , many improvements in the presentation , and also new developments and results , mainly in sections [ sec : complmbd ] and [ sec : pref - cause ] .",
    "we consider relational database schemas of the form @xmath9 , where @xmath10 is the possibly infinite database domain of _ constants _ and @xmath11 is a finite set of _ database predicates _ ) that we assume do not appear , unless explicitly stated otherwise .",
    "] of fixed arities .",
    "a database instance @xmath3 compatible with @xmath12 can be seen as a finite set of ground atomic formulas ( in databases aka .",
    "atoms or tuples ) , of the form @xmath13 , where @xmath14 has arity @xmath15 , and @xmath16 .    a _ conjunctive query _ ( cq )",
    "is a formula @xmath17 of the first - order ( fo ) logic language , @xmath18 , associated to @xmath19 of the form  @xmath20 , where the @xmath21 are atomic formulas , i.e. @xmath22 , and the @xmath23 are sequences of terms , i.e. variables or constants .",
    "the @xmath24 in @xmath17 shows all the free variables in the formula , i.e. those not appearing in @xmath25 .",
    "if @xmath24 is non - empty , the query is _",
    "open_. if @xmath24 is empty , the query is _ boolean _ ( a bcq ) , i.e. the query is a sentence , in which case , it is true or false in a database , denoted by @xmath26 and @xmath27 , respectively .",
    "a sequence @xmath28 of constants is an answer to an open query @xmath17 if @xmath29 $ ] , i.e. the query becomes true in @xmath3 when the variables are replaced by the corresponding constants in @xmath28 .",
    "an _ integrity constraint _ is a sentence of language @xmath18 , and then , may be true or false in an instance for schema @xmath19 .",
    "given a set @xmath30 of integrity constraints , a database instance @xmath3 is _ consistent _ if @xmath31 ; otherwise it is said to be _",
    "inconsistent_. in this work we assume that sets of integrity constraints are always finite and logically consistent .    a particular class of integrity constraints is formed by _ denial constraints _ ( dcs ) , which are sentences @xmath32 of the form : @xmath33 , where @xmath34 and each @xmath35 is a database atom , i.e. predicate @xmath36 .",
    "( the atoms may contain constants . )",
    "denial constraints are exactly the negations of bcqs .",
    "sometimes we use the common representation of dcs as  negative rules \" of the form :  @xmath37 .",
    "assume that the database instance is split in two , i.e. @xmath38 , where @xmath39 and @xmath40 denote the disjoint sets of _ endogenous _ and _ exogenous _ tuples , respectively .",
    "a tuple @xmath41 is called a _ counterfactual cause _ for a bcq @xmath2 , if @xmath42 and @xmath43 .",
    "a tuple @xmath41 is an _ actual cause _ for @xmath2 if there exists @xmath44 , called a _ contingency set _ , such that @xmath0 is a counterfactual cause for @xmath2 in @xmath5  @xcite .",
    "we will concentrate mostly on cqs without built - ins .",
    "however , the definitions of actual cause and contingency set can be applied without a change to _ monotone queries _ in general @xcite , in particular to _ unions of bcqs _ ( ubcqs ) , with or without built - ins .",
    "the _ responsibility _ of an actual cause @xmath0 for @xmath2 , denoted by @xmath45 , is the numerical value @xmath46 , where @xmath47 is the size of the smallest contingency set for @xmath0 .",
    "we can extend responsibility to all the other tuples in @xmath39 by setting their value to @xmath48 .",
    "those tuples are not actual causes for @xmath2 .",
    "[ ex : cfex1 ] consider @xmath49 @xmath50 @xmath51 , and the query @xmath52 .",
    "it holds : @xmath26 .",
    "tuple @xmath53 is a counterfactual cause for @xmath2 .",
    "if @xmath53 is removed from @xmath3 , @xmath2 is not true anymore .",
    "therefore , the responsibility of @xmath53 is 1 . besides , @xmath54 is an actual cause for @xmath2 with contingency set @xmath55 . if @xmath56 is removed from @xmath3 , @xmath2 is still true , but further removing @xmath54 makes @xmath2 false .",
    "the responsibility of @xmath54 is @xmath57 , because its smallest contingency sets have size @xmath58 .",
    "likewise , @xmath56 and @xmath59 are actual causes for @xmath2 with responsibility @xmath57 .",
    "for the same @xmath2 , but with @xmath60 , and the partition @xmath61 and @xmath62 , it turns out that both @xmath53 and @xmath59 are counterfactual causes for @xmath2.@xmath63    * _ notation : _ *  @xmath64 denotes the set of actual causes for bcq @xmath2 ( being true ) from instance @xmath38 .",
    "given a set @xmath30 of integrity constraints , a _ subset repair _",
    "( simply , s - repair ) of a possibly inconsistent instance @xmath3 for schema @xmath19 is an instance @xmath6 for @xmath19 that satisfies @xmath30 and makes @xmath65 minimal under set inclusion .",
    "@xmath66 denotes the set of s - repairs of @xmath3 wrt .",
    "@xmath30 @xcite .",
    "similarly , @xmath6 is a _ cardinality repair _ ( simply c - repair ) of @xmath3 if @xmath6 satisfies @xmath30 and minimizes @xmath67 .",
    "@xmath68 denotes the class of c - repairs of @xmath3 wrt .",
    "c - repairs are always s - repairs . for dcs",
    ", s - repairs and c - repairs are obtained from the original instance by deleting an s - minimal , resp .",
    "c - minimal , set of tuples .",
    "if it minimal under set inclusion in @xmath69 .",
    "similarly , a set is c - minimal if it is minimal in cardinality within @xmath69 . ]    more generally , different _ repair semantics _ may be considered to restore consistency wrt .",
    "general integrity constraints .",
    "they depend on the kind of allowed updates on the database ( i.e. tuple insertions / deletions , changes of attribute values ) , and the minimality conditions on repairs , e.g. subset - minimality , cardinality - minimality , etc .    given @xmath3 and @xmath30 , a _ repair semantics _ ,",
    "rsem , defines a class @xmath70 of rsem - repairs , which are the intended repairs @xcite .",
    "all the elements of @xmath70 are instances over the same schema of @xmath3 , and consistent wrt .",
    "if @xmath3 is already consistent , we expect @xmath70 to contain @xmath3 as its only member .    given a repair semantics , rsem ,",
    "@xmath28 is a rsem-_consistent answer _ to an open query @xmath17 if @xmath72 $ ] for every @xmath73 .",
    "a bcq is rsem-_consistently true _ if it is true in every @xmath73 . in particular , if @xmath28 is a consistent answer to @xmath17 wrt .",
    "s - repairs , we say it is an _",
    "s - consistent answer_. similarly for _ c - consistent answers_.    consistent query answering for dcs under s - repairs was investigated in detail @xcite .",
    "c - repairs and consistent query answering under them were investigated in detail in @xcite .",
    "@xcite for more references . )",
    "consistency - based diagnosis , a form of model - based diagnosis @xcite , considers problems @xmath74 @xmath75 , where @xmath76 is the description in logic of the intended properties of a system under the _ explicit _ assumption that all the _ components _ in @xmath77 , are working normally .",
    "@xmath78 is a fo sentence that represents the observations .",
    "if the system does not behave as expected ( as shown by the observations ) , then the logical theory obtained from @xmath79 plus the explicit assumption , say @xmath80 , that the components are indeed behaving normally , becomes inconsistent .",
    "@xmath81 is an _ abnormality _ predicate .",
    "expresses that component @xmath82 is ( behaving ) abnormal(ly ) . ]",
    "the inconsistency is captured via the _ minimal conflict sets _",
    ", i.e. those minimal subsets @xmath83 of @xmath77 , such that @xmath84 is inconsistent .",
    "as expected , different notions of minimality can be used at this point .",
    "a _ minimal diagnosis _ for @xmath85 is a minimal subset @xmath86 of @xmath77 , such that @xmath87 is consistent .",
    "that is , consistency is restored by flipping the normality assumption to abnormality for a minimal set of components , and those are the ones considered to be ( jointly ) faulty .",
    "the notion of minimality commonly used is s - minimality , i.e. a diagnosis that does not have a proper subset that is a diagnosis .",
    "we will use this kind of minimality in relation to diagnosis .",
    "diagnosis can be obtained from conflict sets @xcite .",
    "we recall some complexity classes @xcite used in this paper .",
    "@xmath88 is the class of functional problems associated to decision problem in the class _ ptime _ ,",
    "i.e. that are solvable in polynomial time .",
    "@xmath89 ( or @xmath90 ) is the class of decision problems solvable in polynomial time by a machine that makes calls to an @xmath91 oracle . for @xmath92",
    "the number of calls is logarithmic .",
    "it is not known if @xmath92 is strictly contained in @xmath93 .",
    "@xmath94 is similarly defined .",
    "let @xmath95 be an instance for schema @xmath12 , and @xmath96 a bcq .",
    "@xmath2 may be unexpectedly true , i.e. @xmath26 .",
    "now , @xmath97 is logically equivalent to the dc @xmath98 .",
    "the requirement that @xmath97 holds can be captured by imposing @xmath99 on @xmath3 . due to @xmath26",
    ", it holds @xmath100 .",
    "so , @xmath3 is inconsistent wrt .",
    "@xmath99 , and could be repaired .",
    "repairs for ( violations of ) dcs are obtained by tuple deletions . intuitively , a tuple that participates in a violation of @xmath99 in @xmath3 is an actual cause for @xmath2 .",
    "s - minimal sets of tuples like this are expected to correspond to s - repairs for @xmath3 wrt .",
    "@xmath99 .",
    "more precisely , given an instance @xmath101 , a bcq @xmath2 , and a tuple @xmath41 , we consider :    * the class containing the sets of differences between @xmath3 and those s - repairs that do not contain @xmath0 , and are obtained by removing a subset of @xmath39 : @xmath102 * the class containing the sets of differences between @xmath3 and those c - repairs that do not contain @xmath0 , and are obtained by removing a subset of @xmath39 : @xmath103    it holds @xmath104 .    now",
    ", any @xmath105 can be written as @xmath106 . from the s - minimality of s - repairs",
    ", it follows that @xmath107 , but @xmath108 .",
    "that is , @xmath109 , but @xmath110 . as a consequence",
    ", @xmath0 is an actual cause for @xmath2 with contingency set @xmath111 .",
    "we have obtained the following result . , we will usually denote its subsets with @xmath6 , @xmath112 , @xmath111 , @xmath86 , @xmath4 , etc . ]",
    "[ pro : c&r ] _ given @xmath113 , and a bcq @xmath2 , @xmath41 is an actual cause for @xmath2  iff @xmath114.@xmath63 _    [ pro : r&r ] _",
    "given @xmath113 , a bcq @xmath2 , and @xmath41 : _",
    "a.   if @xmath115 , then @xmath116 . b.   otherwise , @xmath117 , where @xmath105 and there is no @xmath118 such that @xmath119 .",
    "@xmath63    [ cor : card ] _ given @xmath113 and a bcq @xmath2 :   @xmath41 is a most responsible actual cause for @xmath2  iff @xmath120.@xmath63 _    [ ex : causasrepex1 ] ( ex .",
    "[ ex : cfex1 ] cont . )",
    "consider the same instance @xmath3 and query @xmath2 . in this case , the dc @xmath99 is , in datalog notation , a negative rule :  @xmath121 .    here , @xmath122",
    "@xmath123 @xmath124 @xmath125 @xmath126 and @xmath127 , with @xmath128 @xmath129 @xmath130 @xmath131 @xmath132 ,  @xmath133 @xmath134 @xmath50 @xmath51 ,  @xmath135 @xmath129 @xmath136 @xmath137 .    for tuple @xmath54 , @xmath138 @xmath139 @xmath140 , which , by propositions [ pro : c&r ] and [ pro : r&r ] , confirms that @xmath54 is an actual cause , with responsibility @xmath57 .    for tuple @xmath53 ,",
    "@xmath141 @xmath142 @xmath143 .",
    "so , @xmath53 is an actual cause with responsibility 1 .",
    "similarly , @xmath56 is an actual cause with responsibility @xmath57 , because @xmath144 @xmath145 @xmath146 @xmath147 @xmath148 @xmath149 @xmath150 @xmath151 .",
    "it holds @xmath152 , because all repairs contain @xmath153 , @xmath154 .",
    "this means they do not participate in the violation of @xmath99 or contribute to make @xmath2 true .",
    "so , they are not actual causes for @xmath2 , confirming the result in example [ ex : cfex1 ] .    @xmath155 . from corollary [ cor :",
    "card ] , @xmath53 is the most responsible cause .",
    "[ rem : ucq ] the results in this section can be easily extended to unions of bcqs .",
    "this can be done by associating a dc to each disjunct of the query , and considering the corresponding problems for database repairs wrt .",
    "several dcs ( cf",
    ". section [ sec : disjcauses ] ) .",
    "let us assume in the rest of this section that the database instance is @xmath101 .",
    "we now characterize repairs for inconsistent databases wrt .  _ a set of _ dcs in terms of actual causes , and reduce their computation to computation of causes .",
    "consider an instance @xmath3 for schema @xmath12 , and a set of dcs @xmath71 on @xmath19 .",
    "for each @xmath156 , say @xmath157 , consider its associated _ violation view _ defined by a bcq , namely @xmath158 .",
    "the answer _ yes _ to @xmath159 shows that @xmath32 is violated ( i.e. not satisfied ) by @xmath3 .",
    "next , consider the query that is the union of the individual violation views : @xmath160 , a _ union of _ bcqs ( ubcqs ) .",
    "clearly , @xmath3 violates ( is inconsistent wrt . )",
    "@xmath71 iff @xmath161 .",
    "it is easy to verify that @xmath3 , with @xmath162 , is consistent wrt .",
    "@xmath71  iff @xmath163 @xmath164 , i.e. there are no actual causes for @xmath165 to be true when all tuples are endogenous .",
    "now , let us collect all _ s - minimal contingency sets _ associated with an actual cause @xmath0 for @xmath165 :    [ def : cont ] for @xmath101 , and @xmath71 a set of dcs : @xmath166    notice that for @xmath167 , it holds @xmath168 .",
    "when @xmath162 , if @xmath169 and @xmath170 , from the definition of actual cause and the s - minimality of @xmath4 , it holds that @xmath171 is an s - minimal subset of @xmath3 with @xmath172 .",
    "so , @xmath173 is an s - repair for @xmath3 .",
    "then , the following holds .",
    "[ pro : sr&cp ] _ for an instance @xmath3 , with @xmath162 , and a set dcs @xmath71 : @xmath174 is an s - repair for @xmath3 wrt .",
    "@xmath71 iff , for every @xmath175 : @xmath176 and @xmath177 .",
    "@xmath63 _    to establish a connection between most responsible actual causes and c - repairs , assume that @xmath162 , and collect the _ most responsible actual causes _ for @xmath165 :    [ def : mrc ] for an instance @xmath3 with @xmath162 : @xmath178    [ pro : cr&mrp ] _ for instance @xmath3 , with @xmath162 , and set of dcs @xmath71 :  @xmath174 is a c - repair for @xmath3 wrt .",
    "@xmath71  iff , for every @xmath179 : @xmath180 and @xmath181 .",
    "@xmath63 _    actual causes for @xmath182 , with their contingency sets , account for the violation of some @xmath156 .",
    "removing those tuples from @xmath3 should remove the inconsistency . from propositions",
    "[ pro : sr&cp ] and [ pro : cr&mrp ] we obtain :    [ col : sr&cp ] _ given an instance @xmath3 and a set dcs @xmath71 , the instance obtained from @xmath3 by removing an actual cause , resp",
    ". a most responsible actual cause , for @xmath182 together with any of its s - minimal , resp .",
    "c - minimal , contingency sets forms an s - repair , resp . a c - repair , for @xmath3 wrt . @xmath71 . @xmath63 _    [ ex : rc2cp ] consider @xmath183 and @xmath184 , with @xmath185 and @xmath186 .",
    "the violation views are @xmath187 and @xmath188 . for @xmath189 , @xmath190 and @xmath3",
    "is inconsistent wrt .",
    "@xmath71 .",
    "now assume all tuples are endogenous .",
    "its holds @xmath191 @xmath192 , and its elements are associated with sets of s - minimal contingency sets , as follows : @xmath193 , @xmath194 @xmath195 ,  and @xmath196 .    from corollary [ col :",
    "sr&cp ] , and @xmath197 @xmath198 , @xmath199 is an s - repair .",
    "so is @xmath200 @xmath201 .",
    "these are the only s - repairs .",
    "furthermore , @xmath202 . from corollary [ col :",
    "sr&cp ] , @xmath203 is also a c - repair for @xmath3 .",
    "@xmath63    an actual cause @xmath0 with any of its s - minimal contingency sets determines a unique s - repair .",
    "the last example shows that , with different combinations of a cause and one of its contingency sets , we may obtain the same repair ( e.g. for the first two @xmath204 sets ) .",
    "so , we may have more minimal contingency sets than minimal repairs . however , we may still have exponentially many minimal contingency sets , so as we may have exponentially many minimal repairs of an instance wrt .",
    "dcs , as the following example shows .",
    "[ ex : repsvsconts ] consider @xmath205 and the dc @xmath206 .",
    "@xmath3 is inconsistent wrt .",
    "there are exponentially many s - repairs of @xmath3 : @xmath207 , @xmath208 , @xmath209 , ... ,",
    "the c - repairs are only @xmath6 and @xmath211 .",
    "for the bcq @xmath212 associated to @xmath32 , @xmath213 , and @xmath214 and @xmath215 are actual causes for @xmath212 ( courterfactual causes with responsibility @xmath58 ) .",
    "all tuples in @xmath216 are actual causes , each with exponentially many s - minimal contingency sets .",
    "for example , @xmath217 has the s - minimal contingency set @xmath218 , among exponentially many others ( any set built with just one element from each of the pairs @xmath219 , ... , @xmath220 is one ) .",
    "@xmath63      if we want to compute repairs wrt .",
    "sets of dcs from causes for ubcqs using , say corollary [ col : sr&cp ] , we first need an algorithm for computing the actual causes and their ( minimal ) contingency sets for ubcqs . these algorithms could be used as a first stage of the computation of s - repairs and c - repairs wrt .",
    "sets of dcs .",
    "however , these algorithms , which we develop in section [ sec : disjcausescont ] ) , are also interesting and useful _ per se_.    the ptime algorithm for computing actual causes in @xcite is for single conjunctive queries , but does not compute the actual causes contingency sets . actually , doing the latter increases the complexity , because _ deciding responsibility_. ] of actual causes is @xmath221-hard @xcite ( which would be tractable if we could efficiently compute all ( minimal ) contingency sets ) . in principle , an algorithm for responsibilities can be used to compute c - minimal contingency sets , by iterating over all candidates , but example [ ex : repsvsconts ] shows that there can be exponentially many of them .",
    "we first concentrate on the problem of computing actual causes for ubcqs , without their contingency sets , which requires some notation .",
    "[ def : hsstuff ] given @xmath222 , each @xmath223 a bcq , and an instance @xmath3 :    a.   @xmath224 is the collection of all s - minimal subsets of @xmath3 that satisfy a disjunct @xmath225 of @xmath2 .",
    "b.   @xmath226 consists of the s - minimal subsets @xmath112 of @xmath39 for which there exists a @xmath227 with @xmath228 and @xmath229 .",
    "@xmath63    @xmath226 contains all s - minimal sets of endogenous tuples that simultaneously ( and possibly accompanied by exogenous tuples ) make the query true .",
    "it is easy to see that @xmath224 and @xmath226 can be computed in polynomial time in the size of @xmath3 .",
    "now , generalizing a result for cqs in @xcite , actual causes for a ubcqs can be computed in ptime in the size of @xmath3 without computing contingency sets .",
    "we formulate this results in terms of the corresponding _ causality decision problem _ ( cdp ) .",
    "[ pro : ubcqcausesindirect ] _ given @xmath230 , @xmath231 , and a ubcq @xmath2 : _",
    "a.   @xmath0 is an actual cause for @xmath2 iff there is @xmath232 with @xmath233 .",
    "b.   the _ causality decision problem _ ( about membership of ) @xmath234 belongs to @xmath235 .",
    "[ ex : al2 ] ( ex .",
    "[ ex : rc2cp ] cont . )  consider the query @xmath236 , and assume that for @xmath3 ,  @xmath237 and @xmath238 .",
    "it holds @xmath239 @xmath240 . since @xmath241 @xmath201 ,  @xmath242",
    "so , @xmath243 is the only actual cause for @xmath244 . @xmath63      it is possible to develop a ( naive ) algorithm that accepts as input an instance @xmath38 , and a ubcq @xmath2 , and returns @xmath64 ; and also , for each @xmath245 ,  its ( set of ) s - minimal contingency sets @xmath246 .",
    "the basis for the algorithm is a correspondence between the actual causes for @xmath2 with their contingency sets and a _ hitting - set problem_. is a collection of non - empty subsets of a set @xmath247 , a subset @xmath248 is a _ hitting set _ for @xmath69 if , for every @xmath249 , @xmath250 .",
    "@xmath251 is an s - minimal hs if no proper subset of it is also an hs .",
    "@xmath247 is a minimum hs is it has minimum cardinality . ]",
    "more precisely , for a fixed ubcq @xmath2 , consider the _ hitting - set framework _",
    "@xmath252 with @xmath226 as in definition [ def : hsstuff ] .",
    "different computational and decision problems are based on @xmath253 , and we will confront some below . notice that hitting sets ( hss ) are all subsets of @xmath39 .",
    "the s - minimal hss for @xmath253 correspond to actual causes with their s - minimal contingencies for @xmath2 .",
    "most responsible causes for @xmath2 are in correspondence with hss for @xmath253 .",
    "this is formalized as follows :    [ pro : ubcqcauses ] _ for @xmath230 , @xmath231 , and a ubcq @xmath2 : _",
    "a.   @xmath0 is an actual cause for @xmath2 with s - minimal contingency set @xmath4 iff @xmath254 is an s - minimal hs for @xmath253 .",
    "b.   @xmath0 is a most responsible actual cause for @xmath2 with c - minimal contingency set @xmath4 iff @xmath254 is a minimum hs for @xmath253.@xmath63    the proof is similar to that of part ( a ) of proposition [ pro : ubcqcausesindirect ] .",
    "[ ex : al1 ] ( ex .",
    "[ ex : rc2cp ] and [ ex : al2 ] cont . )   @xmath3 and @xmath2 are as before , but now all tuples are endogenous . here , @xmath255 @xmath240 .",
    "@xmath253 has two s - minimal hss : @xmath256 and @xmath257 .",
    "each of them implicitly contains an actual cause ( any of its elements ) with an s - minimal contingency set ( what s left after removing the actual cause ) .",
    "@xmath258 is also the c - minimal hitting set , and contains the most responsible actual cause , @xmath243 .",
    "@xmath63    _ [ rem : hs]_for @xmath259 , @xmath226 can be computed in ptime , and its elements are bounded in size by @xmath260 , which is the maximum number of atoms in one of @xmath2 s disjuncts .",
    "this is a special kind of hitting - set problems .",
    "for example , deciding if there is a hitting set of size at most @xmath261 as been called the @xmath262-_hitting - set problem _",
    "@xcite , and @xmath262 is the bound on the size of the sets in the set class . in our case , @xmath262 would be @xmath260 .",
    "_      corollary [ col : sr&cp ] and proposition [ pro : ubcqcauses ] can be used to compute repairs .",
    "if the classes of s- and c - minimal hss for @xmath253 ( with @xmath263 ) are available , computing s- and c - repairs will be in ptime in the sizes of those classes .",
    "however , it is well known that computing minimal hss is a complex problem",
    ". actually , as example [ ex : repsvsconts ] implicitly shows , we can have exponentially many of them in @xmath264 ; so as exponentially many minimal repairs for @xmath3 wrt . a denial constraint .",
    "we can see that the complexity of contingency sets computation is in line with the complexities of computing hitting sets and repairs .    as corollary [ col : sr&cp ] and proposition [ pro : ubcqcauses ] show , the computation of causes , contingency sets , and most responsible causes via minimal / minimum hs computation can be used to compute repairs and decide about repair questions . since the hs problems in our case are of the @xmath262-hitting set kind , good algorithms and approximations for the latter ( cf .",
    "section [ sec : fpt ] ) could be used in the context of repairs .    in the rest of this section",
    "we consider an instance @xmath3 whose tuples are all endogenous , and a set @xmath71 of dcs .  for the disjunctive violation view @xmath165",
    ", the following result is obtained from propositions [ pro : sr&cp ] and [ pro : cr&mrp ] , and corollary [ col : sr&cp ] .",
    "[ col : consinf ] _ for an instance @xmath3 , with @xmath162 , and set dcs @xmath71 , it holds : _",
    "a.   for every @xmath169 , there is an s - repair that does not contain @xmath0 .",
    "b.   for every @xmath265 , there is a c - repair that does not contain @xmath0 . c.   for every @xmath266 and @xmath267",
    ", it holds @xmath268 and @xmath269 .",
    "@xmath63    for a projection - free , and a possibly non - boolean cq @xmath2 , we are interested in its consistent answers from @xmath3 wrt .",
    "@xmath71 . for example",
    ", for @xmath270 , the s - consistent ( c - consistent ) answers would be of the form @xmath271 , where @xmath272 and @xmath273 belong to all s - repairs ( c - repairs ) of @xmath3 .    from corollary [ col : consinf ]",
    ", @xmath274 is an s - consistent ( resp .",
    "c - consistent ) answer iff @xmath272 and @xmath273 belong to @xmath3 , but they are not actual causes ( resp .",
    "most responsible actual causes ) for @xmath182 .    the following simple result and its corollary will be useful in section [ sec : mbdcomx ] .    [",
    "pro : cqa ] _ for an instance @xmath3 , with @xmath162 , a set of dcs @xmath71 , and a projection - free cq  @xmath275 : _",
    "a.   @xmath28 is an s - consistent answer iff , for each @xmath276 , @xmath277 .",
    "b.   @xmath28 is a c - consistent answer iff , for each @xmath276 , @xmath278 .",
    "@xmath63    [ ex : cqa1 ] ( ex .",
    "[ ex : rc2cp ] cont . )",
    "consider @xmath279 .",
    "we had @xmath280 @xmath281 @xmath282 @xmath283 , @xmath202 .",
    "then , @xmath284 is both an s- and a c - consistent answer .",
    "@xmath63    notice that proposition [ pro : cqa ] can easily be extended to conjunctions of ground atomic queries .",
    "[ cor : cqa&cox ] _ given @xmath3 , a set of dcs @xmath71 , the ground atomic query @xmath285 is c - consistently true iff @xmath286 and it is not a most responsible cause for @xmath165.@xmath63 _    [ ex : cqa2 ] for @xmath287 and the dc @xmath288 , we obtain : @xmath163 @xmath289 .    from proposition [ pro : cqa ] ,",
    "the ground atomic query @xmath290 is both s- and c - consistently true in @xmath3 wrt .",
    "@xmath32 , because , @xmath291 @xmath292 .",
    "@xmath63    the cqs considered in proposition [ pro : cqa ] and its corollary [ cor : cqa&cox ] are not particularly interesting _ per se _ , but we will use those results to obtain new complexity results for causality later on , e.g. theorem [ the : cqa&ca&cox ] .",
    "let @xmath95 be an instance for schema @xmath12 , and @xmath96 , a bcq .",
    "assume @xmath2 is , possibly unexpectedly , true in @xmath3 .",
    "so , for the associated dc @xmath98 , @xmath100 .",
    "@xmath2 is our _ observation _ , for which we want to find explanations , using a consistency - based diagnosis approach .    for each predicate @xmath14",
    ", we introduce predicate @xmath293 , with the same arity as @xmath294 .",
    "intuitively , a tuple in its extension is _ abnormal _ for @xmath294 .",
    "the  system description \" , @xmath76 , includes , among other elements , the original database , expressed in logical terms , and the dc as true  under normal conditions \" .",
    "more precisely , we consider the following _ diagnosis problem _ , @xmath295 @xmath296 , associated to @xmath2 .",
    "the fo system description , @xmath76 , contains the following elements :    a.   @xmath297 , which is reiter s logical reconstruction of @xmath3 as a fo theory @xcite ( cf .",
    "example [ ex : mbdaex5 ] ) .",
    "b.   sentence @xmath298 , which is @xmath99 rewritten as follows : @xmath299 this formula can be refined by applying the abnormality predicate , @xmath81 , to endogenous tuples only .",
    "for this we need to use additional auxiliary predicates @xmath300 , with the same arity of @xmath301 , which contain the endogenous tuples in @xmath294 s extension ( see example [ ex : mbdaex5 ] ) . c.   the inclusion dependencies : @xmath302 ,  @xmath303 , and @xmath304 , for each @xmath14 .",
    "the last entry , @xmath2 , in @xmath305 is the  observation \" , which together with _ sd _ will produce and inconsistent theory , because we make the initial and explicit assumption that all the abnormality predicates are empty ( equivalently , that all tuples are normal ) , i.e. we consider , for each predicate @xmath294 , the sentence . ]",
    "@xmath306 where , * false * is a propositional atom that is always false .",
    "the second entry in @xmath85 is @xmath39 .",
    "this is the set of  components \" that we can use to try to restore consistency , in this case , by ( minimally ) changing the abnormality condition on tuples in @xmath39 . in other words ,",
    "the rules ( [ eq : default ] ) are subject to qualifications : some endogenous tuples may be abnormal .",
    "each diagnosis shows an s - minimal set of endogenous tuples that are abnormal .",
    "[ ex : mbdaex5 ] ( ex .",
    "[ ex : cfex1 ] cont . ) for the instance @xmath307",
    "@xmath308 @xmath309 , with @xmath39 @xmath123 @xmath310 @xmath51 , consider the diagnostic problem @xmath311 @xmath296 , with @xmath76 containing :    a.   predicate completion axioms plus _ unique names assumption _ : @xmath312 b.   the denial constraint qualified by non - abnormality , @xmath313 : @xmath314 in diagnosis formalizations this formula would be usually presented as : @xmath315 that is , under the normality assumption , the  system \" behaves as intended ; in this case , there are no ( endogenous ) violations of the denial constraint .",
    "this main formula in the diagnosis specification can also be written as a disjunctive positive rule : @xmath316 c.   abnormality / endogenousity predicates are in correspondence to the database schema , and only endogenous tuples can be abnormal : @xmath317    the assumption is that there are not abnormal tuples : @xmath318 the fo theory formed by ( [ eq : one ] ) - ( [ eq : last ] ) is inconsistent . @xmath63    now , in more general terms , the observation is @xmath2 ( being true ) , obtained by evaluating query @xmath2 on ( theory of ) @xmath3 . in this case ,",
    "since all the abnormality predicates are assumed to be empty , @xmath99 is equivalent to @xmath319 , which also becomes false wrt @xmath3 . as a consequence",
    ", @xmath320 is an inconsistent fo theory .",
    "a diagnosis is a set of endogenous tuples that , by becoming abnormal , restore consistency .",
    "[ def : diag ]    a.   a _ diagnosis _ for @xmath85 is a @xmath321 , such that @xmath322 + is consistent .",
    "b.   @xmath323 denotes the set of s - minimal diagnoses for @xmath85 that contain tuple @xmath41 . c.   @xmath324 denotes the set of c - minimal diagnoses in @xmath323 .",
    "+ @xmath63    [ ex : mbdaex5p5 ] ( ex .",
    "[ ex : mbdaex5 ] cont . )",
    "the theory can be made consistent by giving up ( [ eq : last ] ) , and making s - minimal sets of endogenous tuples abnormal .",
    "@xmath85 has two s - minimal diagnosis : @xmath325 and @xmath326 .",
    "the first one corresponds to replacing the second formula in ( [ eq : last ] ) by @xmath327 , obtaining now a consistent theory .    here , @xmath328 , and @xmath329 @xmath330 @xmath331 .",
    "@xmath63    by definition , @xmath332 .",
    "diagnoses for @xmath85 and actual causes for @xmath2 are related .",
    "[ pro : ac&diag ] _ consider @xmath113 , a bcq @xmath2 , and the diagnosis problem @xmath85 associated to @xmath2 .",
    "tuple @xmath41 is an actual cause for @xmath2 iff @xmath333 .",
    "@xmath63 _    the responsibility of an actual cause @xmath0 is determined by the cardinality of the diagnoses in @xmath324 .",
    "[ pro : r&diag ] _ for @xmath113 , a bcq @xmath2 , the associated diagnosis problem @xmath85 , and a tuple @xmath41 , it holds : _",
    "\\(a ) @xmath334 iff @xmath335 .",
    "\\(b ) otherwise , @xmath336 , where @xmath337 .",
    "@xmath63    for the proofs of propositions [ pro : ac&diag ] and [ pro : r&diag ] , it is easy to verify that the conflict sets of @xmath85 coincide with the sets in @xmath338 ( cf .",
    "definition [ def : hsstuff ] ) .",
    "the results are obtained from the characterization of minimal diagnosis as minimal hitting sets of sets of conflict sets ( cf .",
    "section [ sec : prel ] and @xcite ) and proposition [ pro : ubcqcauses ] .",
    "[ ex : mbdaex6 ] ( ex .",
    "[ ex : mbdaex5p5 ] cont . ) from propositions [ pro : ac&diag ] and [ pro : r&diag ] , @xmath53 and @xmath59 are actual cases , with responsibility @xmath58 .",
    "@xmath63    in consistency - based diagnosis , minimal diagnoses can be obtained as s - minimal hss of the collection of s - minimal _ conflict sets _",
    "section [ sec : prel ] ) @xcite . in our case ,",
    "conflict sets are s - minimal sets of endogenous tuples that , if not abnormal ( only endogenous ones can be abnormal ) , and together , and possibly in combination with exogenous tuples , make ( [ eq : ext ] ) false .",
    "it is easy to verify that the conflict sets of @xmath85 coincide with the sets in @xmath338 ( cf .",
    "definition [ def : hsstuff ] and remark [ rem : hs ] ) . as a consequence ,",
    "conflict sets for @xmath85 can be computed in ptime , the hss for @xmath85 contain actual causes for @xmath2 , and the hs problem for the diagnosis problems is of the @xmath262-hitting - set kind .",
    "the connection between consistency - based diagnosis and causality allows us , in principle , to apply techniques for the former , e.g. @xcite , to the latter .",
    "[ ex : mbdgrep ] ( ex .",
    "[ ex : mbdaex5 ] cont . )",
    "the diagnosis problem @xmath311 @xmath296 gives rise to the hs framework @xmath339 , with @xmath340 corresponding to the conflict set @xmath341 .",
    "@xmath253 has two minimum hss : @xmath342 and @xmath343 , which are the s - minimal diagnosis for @xmath305 .",
    "then , the two tuples are actual causes for @xmath2 ( cf . proposition   [ pro : ac&diag ] ) . from proposition",
    "[ pro : r&diag ] , @xmath344 .",
    "@xmath63    the solutions to the diagnosis problem can be used for computing repairs .",
    "[ pro : diag ] _ consider a database instance @xmath3 with only endogenous tuples , a set of dcs of the form @xmath345 , and their associated  abnormality - aware \" integrity constraints in ( [ eq : ext ] ) ( in this case we do not need @xmath346 atoms ) .",
    "_    each s - minimal diagnosis @xmath86 gives rise to an s - repair of @xmath3 , namely @xmath347 ; and every s - repair can be obtained in this way .",
    "similarly , for c - repairs using c - minimal diagnoses .",
    "[ ex : mbdaex6 + ] ( ex .",
    "[ ex : mbdaex6 ] cont . ) the instance @xmath307",
    "@xmath308 @xmath309 has three ( both s- and c- ) repairs wrt . the dc @xmath348 , namely @xmath349 , @xmath350 , and @xmath351 .",
    "they can be obtained as @xmath352 @xmath353 from the only ( s- and c- ) diagnoses , @xmath325 , @xmath326 , @xmath354 , resp .",
    "@xmath63    the kind of diagnosis problem we introduced above can be formulated as a _ preferred - repair problem _ @xcite . for this , it is good enough to materialize tables for the auxiliary predicates @xmath293 and @xmath346 , and consider the dcs of the form ( [ eq : ext ] ) ( with the @xmath346 atoms if not all tuples are endogenous ) , plus the dcs ( [ eq : default ] ) .",
    "the initial extensions for the @xmath293 predicates are empty .",
    "if @xmath3 is inconsistent wrt .",
    "this set of dcs , the s - repairs that are obtained by only _ inserting _ endogenous tuples into the extensions of the @xmath293 predicates correspond to s - minimal diagnosis , and each s - minimal diagnosis can be obtained in this way .",
    "in this section we assume @xmath101 , without any assumption on @xmath355 ( other than disjointness ) .",
    "there are three main computational problems in database causality . for a bcq @xmath2 and database @xmath3 :    * the _ causality problem _",
    "( cp ) is about computing the actual causes for @xmath2 . *",
    "the _ responsibility problem _ ( rp ) is about computing the responsibility @xmath45 of a given actual cause @xmath0 .",
    "+ since a tuple that is not an actual cause has responsibility @xmath48 , this problem subsumes ( a ) . * computing the _ most responsible actual causes _ ( mrc ) .",
    "these problems have corresponding _",
    "decision versions_. both cp and its decision version , cdp ( cf . proposition [ pro : ubcqcausesindirect ] ) , are solvable in polynomial time @xcite , which can be extended to ubcqs ( cf . proposition [ pro : ubcqcausesindirect ] ) .",
    "we consider the decision version of the second problem .",
    "[ def : resp ] for a bcq @xmath2 , the _ responsibility decision problem _ ( rdp ) is ( deciding about membership of ) :    @xmath356    @xmath357 , + that is , deciding if a tuple has a responsibility greater than a bound @xmath358 ( as a cause for @xmath2 ) .",
    "@xmath63    the complexity analysis of rdp in @xcite is restricted to conjunctive queries without self - joins , for which a dichotomy result holds :  depending on the syntactic structure of a query , rdp is either in ptime or is np - hard . here",
    ", we generalize the complexity analysis for rdp to general cqs",
    ".    we will also investigate the decision version of mrc ( cf .",
    "( [ eq : mrc ] ) ) : mrcdp , the _ most responsible cause decision problem_. this is a natural problem , because actual causes with the highest responsibility tend to provide most interesting explanations for query answers @xcite .",
    "[ def : mracp ] for a bcq @xmath2 , the _ most responsible cause decision problem _ is ( membership of ) :    @xmath359 @xmath360 .",
    "@xmath63    we start by analyzing a more basic decision problem .",
    "[ def : cusp ] for a bcq @xmath2 , the _ minimal contingency set decision problem _ ( mcsdp ) is about of checking if a set of tuples @xmath4 is an s - minimal contingency set associated to a cause @xmath0 ( cf .",
    "( [ eq : ct ] ) ) :    @xmath361 .",
    "@xmath63    due to the results in sections [ sec : causfrepair ] and [ sec : repairfcauses ] , it clear that there is a close connection between mcsdp and the _ s - repair checking _",
    "problem @xcite , about deciding if instance @xmath6 is an s - repair of instance @xmath3 wrt . a set of integrity constraints",
    "actually , the following result is obtained from the ptime solvability of the s - repair checking problem for dcs @xcite ( see also @xcite ) .",
    "[ pro : cspccpx ] _ for a bcq @xmath2 , @xmath362 .",
    "_    we could also consider the decision problem defined as in definition [ def : cusp ] , but with c - minimal @xmath4 .",
    "we will not use results about this problem in the following .",
    "furthermore , its connection with the c - repair checking problem is less direct . as one can see from section",
    "[ sec : causfrepair ] , c - minimal contingency sets correspond to a repair semantics somewhere between the s - minimal and c - minimal repair semantics ( a subclass of _ srep _ , but a superclass of _ crep _ ) :  it is about an s - minimal repair with minimum cardinality that does not contain a particular tuple .",
    "now we establish that rdp is _",
    "np_-complete for cqs in general .",
    "the _ np_-hardness is shown in @xcite .",
    "membership of _ np _ is obtained using proposition [ pro : cspccpx ] .    [ the : rp(d)cmx ] _",
    "( a ) for every bcq @xmath2 , @xmath363 .",
    "_    \\(b ) @xcite  there are cqs @xmath2 for which @xmath364 is _ np_-hard .    in order to better understand the complexity of rp , the responsibility computation problem , we will investigate the _ functional _ , non - decision version of rdp .    the main source of complexity when computing responsibilities is related to the hitting - set problem associated to @xmath365 in remark [ rem : hs ] ( cf .",
    "( [ eq : frame ] ) ) . in this case",
    ", it is about computing the cardinality of a minimum hitting set that contains a given vertex ( tuple ) @xmath0 . that this is a kind of _ @xmath262-hitting - set problem",
    "_ @xcite will be useful in section [ sec : fpt ] .",
    "our responsibility problem can also be seen as a _",
    "vertex cover problem _ on the _ hypergraph _ @xmath366 associated to @xmath365 .",
    "( that is , the hs framework can be seen as a hypergraph . ) in it , the hyperedges are the members of @xmath226 . determining the responsibility of a tuple @xmath0 becomes the problem on hypergraphs of determining the size of a minimum vertex cover ( vc ) that contains vertex @xmath0 ( among all vcs that contain the vertex ) .",
    "again , in this problem the hyperedges are bounded in size by @xmath260 .",
    "[ ex : hyperexm ] for @xmath367 , and @xmath368 @xmath369 @xmath370 ,  @xmath371 .",
    "@xmath3 is the set of vertices of hypergraph @xmath372 , whose hyperedges are @xmath373 @xmath374 and @xmath375 .",
    "its minimal vcs are : @xmath376 , @xmath377 @xmath370 , @xmath378 .",
    "then , @xmath379 is an actual cause with responsibility @xmath58 .",
    "the other tuples are actual causes with responsibility @xmath57 .",
    "@xmath63    to simplify the presentation , we will formulate and address our computational problems as problems for graphs ( instead of hypergraphs ) .",
    "however , our results still hold for hypergraphs @xcite . actually , the following _ representation lemma _ holds",
    ". @xmath63    [ lemma : resclx ] _ there is a fixed database schema @xmath12 and a bcq @xmath380 , without built - ins , such that , for every graph @xmath381 and @xmath382 , there is an instance @xmath3 for @xmath12 and a tuple @xmath231 , such that the size of a minimum vc of @xmath383 containing @xmath358 equals the responsibility of @xmath0 as an actual cause for @xmath2 . _",
    "having represented our responsibility problem as a graph - theoretic problem , we first consider a functional computational problems in graphs .",
    "the _ minimal vc membership problem _ ( mvcmp ) consists in , given a graph @xmath381 , an a vertex @xmath384 as inputs , compute the size of a minimum vertex cover of @xmath383 that contains @xmath358 . @xmath63",
    "[ lemma : mmvcand ] _ given a graph @xmath383 and a vertex @xmath358 in it , there is a graph @xmath385 extending @xmath383 that can be constructed in polynomial time in @xmath386 , such that the size of a minimum vc for @xmath383 that contains @xmath358 and the size of a minimum vc for @xmath385 coincide .",
    "_    from lemma [ lemma : mmvcand ] and the @xmath94-completeness of determining the size of a maximum clique in a graph @xcite , we obtain :    [ pro : mmvccml ] _ the mvcmp problem for graphs is @xmath94-complete . _    from lemma [ lemma : resclx ] and",
    "proposition [ pro : mmvccml ] we obtain the complexity result for rp .",
    "membership can also be obtained from theorem [ the : rp(d)cmx ] .",
    "[ the : r&diag ] _ _    a.   for every bcq without built - ins , @xmath2 ,",
    "computing the responsibility of a tuple as a cause for @xmath2 is in @xmath387 .",
    "b.   there is  a database schema and a bcq @xmath2 , without built - ins , such that computing the responsibility of a tuple as a cause for @xmath2 is @xmath94-complete .",
    "@xmath63    now we address the most responsible causes problem , mrcdp ( cf .",
    "definition [ def : mracp ] ) .",
    "we use the connection with consistent query answering of section [ sec : cqa ] , namely corollary [ cor : cqa&cox ] , and the @xmath388-completeness of consistent query answering under the c - repair semantics for queries that are conjunctions of ground atoms and a particular dc ( * ? ? ?",
    "4 ) .    [ the : cqa&ca&cox ] _ _    a.   for every bcq without built - ins , @xmath389 .",
    "b.   there is a database schema and a bcq @xmath2 , without built - ins , for which @xmath359 is @xmath8-complete .    from proposition [ pro : ubcqcauses ] and the @xmath390-completeness of determining the size of c - repairs for dcs ( * ?",
    "3 ) , we obtain the following for the computation of the highest responsibility value .    [",
    "pro : crepair&res&cox ] _ _    a.   for every bcq without built - ins , computing the responsibility of the most responsible causes is in @xmath390 .",
    "b.   there is a database schema and a bcq @xmath2 , without built - ins , for which computing the responsibility of the most responsible causes is @xmath390-complete .",
    "we need to cope with the intractability of computing most responsible causes . the area of _ fixed parameter tractability _ ( fpt ) @xcite provides tools to attack this problem . in this regard",
    ", we recall that a decision problem with inputs of the form @xmath391 , where @xmath392 is a distinguished parameter of the input , is fixed parameter tractable ( or belongs to the class fpt ) , if it can be solved in time @xmath393 , where @xmath82 and the hidden constant do not depend on @xmath394 or @xmath395 , and @xmath396 does not depend on @xmath395 .    in our case , the _ parameterized version of the decision problem _ @xmath364 ( cf .",
    "definition [ def : resp ] ) is denoted with @xmath397 , and the distinguished parameter is @xmath261 , such that @xmath398 .    that @xmath397 belongs to fpt can be obtained from its formulation as a @xmath262-hitting - set problem ( @xmath262 being the fixed upper bound on the size of the sets in the set class ) ; in this case about deciding if there is a hs that contains the given tuple @xmath0 that has cardinality smaller that @xmath261 .",
    "this problem belongs to fpt .",
    "[ the : fpt ] _ for every bcq @xmath2 , @xmath397 belongs to fpt , where the parameter is the inverse of the responsibility bound .",
    "_    this result and the corresponding algorithm sketched in its proof show that the higher the required responsibility degree , the lower the computational effort needed to compute the actual causes with at least that level of responsibility . in other terms , parameterized algorithms are effective for computing actual causes with high responsibility or most responsible causes . in general , parameterized algorithms are very effective when the parameter is relatively small @xcite .",
    "now , in order to compute most responsible causes , we could apply , for each actual cause @xmath0 , the just presented fpt algorithm on the hypergraph @xmath372 , starting with @xmath399 , i.e. asking if there is vc of size less than @xmath58 that contains @xmath0 .",
    "if the algorithm returns a positive result , then @xmath0 is a counterfactual cause , and has responsibility @xmath58 .",
    "otherwise , the algorithm will be launched with @xmath400 , until a positive result is returned .",
    "( the procedure can be improved through binary search on @xmath401 , with @xmath402 possibly much smaller than @xmath264 . )    the complexity results and algorithms provided in this section can be extend to ubcqs .",
    "this is due to remark [ rem : ucq ] and the construction of @xmath226 , which the results in this section build upon .",
    "for the @xmath262-hitting - set problem there are also efficient parameterized approximation algorithms @xcite .",
    "they could be used to approximate the responsibility problem .",
    "furthermore , approximation algorithms developed for the minimum vc problem on bounded hypergraphs @xcite should be applicable to approximate most responsible causes for query answers . via the causality / repair connection ( cf .",
    "section [ sec : cqa ] ) , it should be possible to develop approximation algorithms to compute s - repairs of particular sizes , c - repairs , and consistent query answers wrt .",
    "dcs .      in @xcite the class of _ linear _",
    "cqs is introduced . for them",
    ", computing tuple responsibilities is tractable . roughly speaking , a bcq is linear if its atoms can be ordered in a way that every variable appears in a continuous sequence of atoms , e.g. @xmath403 is linear , but not @xmath404 , for which rdp is _",
    "np_-hard @xcite .    the class of bcqs for which computing responsibility ( more precisely , our @xmath405 decision problem ) is tractable can be extended to _",
    "weakly linear_. now , the dichotomy result in @xcite says that for a bcq @xmath2 without self - joins , rdp is tractable when @xmath2 is weakly - linear , but _",
    "np_-hard , otherwise .    due to the causality",
    "/ repair connection of section [ sec : repairfcauses ] , we can obtain the following results for database repairs .",
    "( we assume all tuples are endogenous . )",
    "[ theo : dichotomy ] _ _    a.   for single weakly - linear dcs ,",
    "c - repair checking and deciding if the size of a c - repair is larger than a bound are both tractable .",
    "is weakly - linear if the corresponding bcq @xmath212 is weakly - linear . in this way",
    "any adjective that applies to bcqs can be applied to dcs . ]",
    "b.   for single , self - join free dcs @xmath32 , and the problem @xmath406 of deciding if there is a repair @xmath6 for a given input instance @xmath3 and a tuple @xmath407 with @xmath408 and @xmath409 , is a subset of @xmath3 that satisfies @xmath32 .",
    "here , @xmath410 . ]",
    "the following dichotomy holds : * if @xmath32 is weakly - linear , @xmath406 is tractable . * otherwise , it is _ np_-complete .",
    "this dichotomy result for repairs shows that interesting results in one of the areas ( causality , in this case ) have counterparts in some of the others .",
    "the form the reincarnation of the known result takes in the new area ( repairs , in this case ) is interesting _ per se_.    notice that both problems in ( a ) in theorem [ theo : dichotomy ] may be intractable even for single dcs @xcite .",
    "more specifically , c - repair checking can be _",
    "conp_-hard for single dcs @xcite .",
    "actually , the single dc used in ( * ? ? ?",
    "* lemma 4 ) is of the form @xmath411 , whose associated bcq is not weakly - linear . as a matter of fact ,",
    "this bcq is a _",
    "np_-hard for rdp @xcite .",
    "it is known that consistency - based diagnosis decision problems can be unsolvable @xcite",
    ". however , there are decidable classes of fo diagnosis specifications , and those classes are amenable to complexity analysis . however , there is little research on the complexity analysis of solvable classes of consistency - based diagnosis problems .",
    "the connection we established in the previous sections between causality , repairs and consistency - based diagnosis can be used to obtain new algorithmic and complexity results for the latter . without trying to be exhaustive about this , which is beyond the scope of this paper , we give an example of the kind of results that can be obtained .    considering the diagnosis problem we obtained in section [ sec : mbdtorep ] , we can define a class of diagnosis problems .",
    "cf . example [ ex : mbdaex5 ] , in particular ( [ eq : disj ] ) , for motivation .    a _ disjunctive positive _ ( dp ) diagnosis specification @xmath71 is a consistent fo logical theory , such that :    a.   @xmath71 has a signature ( schema ) consisting of a finite set of constants , a set of predicates @xmath19 , a set @xmath412 of predicates of the form @xmath413 , . ] with @xmath414 , and @xmath413 with the same arity of @xmath216 .",
    "@xmath19 and @xmath412 are mutually disjoint .",
    "b.   @xmath71 is inconsistent with @xmath415 .",
    "c.   consists of : * sentences of the form  @xmath416 , with @xmath417 , and @xmath418 a conjunction of atoms that does not include @xmath81-atoms of any kind .",
    "* sentences of the forms  @xmath419 , with @xmath420 . * a finite background universal theory @xmath421 expressed in terms of predicates in @xmath19 ( and constants ) that has a unique herbrand model . @xmath63    as above , a diagnosis is a set of @xmath413-atoms that , when assumed to be true , restores the consistency of the correspondingly modified @xmath422",
    ".    there are at least two important computational tasks that emerge , namely , given a _",
    "disjunctive positive _ ( dp ) diagnosis specification @xmath71 together with @xmath423 :    1 .   the _ minimum - cardinality diagnosis _ ( mcd ) problem , about computing minimum - cardinality diagnoses .",
    "the _ minimal membership diagnosis _ , ( mmd ) about computing minimum - cardinality diagnoses that contain a given _ ab_-atom .",
    "it is not difficult to see that these problems are computable ( or solvable in their decision versions ) .",
    "now we can obtain complexity lower bounds for them .",
    "actually , in section [ sec : mbdtorep ] , the _ responsibility _ and _ most responsible causes problem _ were reduced to diagnosis problems for specifications that turned out to be disjunctive positive ( see ( [ eq : disj ] ) ) .",
    "more specifically , proposition [ pro : r&diag ] reduces computing responsibility of a tuple to computing the size of a minimum - cardinality diagnosis that contains the tuple . furthermore , as a simple corollary of proposition [ pro : r&diag ]",
    ", we obtain the computation of minimum - cardinality diagnoses allows us to compute most responsible causes .",
    "now , combining all this with proposition [ pro : crepair&res&cox ] and theorem [ the : r&diag ] , we obtain the following lower bounds for our diagnosis problems .",
    "[ thm : diag ] _ for disjunctive positive diagnosis specifications , the mcd and mmd problems are @xmath94-hard in the size of their underlying herbrand structure . @xmath63 _",
    "in section [ sec : causfrepair ] we characterized causes and most responsible causes in terms of s - repairs and c - repairs , resp .",
    "we could generalize the notion of a cause and/or its responsibility by using , in principle , any _ repair semantics _ @xmath424 .",
    "the latter is represented by a class of repairs @xmath425 , of @xmath3 wrt .",
    "a set of denial constraints .",
    "this class contains consistent instances over the same schema as @xmath3 , and satisfy additional conditions .",
    "actually , a repair semantics is based on two elements that determine @xmath425 : ( a ) the class of admissible  repair actions \" ( updates to restore consistency ) , and ( b ) a form of minimality condition that forces ( minimal ) repairs to stay as close as possible to the original instance @xmath3 @xcite .",
    "when dealing with ( sets of ) denial constraints , the repair actions can only be of certain kinds .",
    "usually tuple deletions have been considered .",
    "this is the case of the s- and c - repairs we have considered in this work so far .",
    "we could go beyond and consider the notion of _ prioritized repair _ @xcite .",
    "also changes of attribute values can be the chosen repair actions , including the use of _ null values _ , to  destroy \" joins ( again , with different semantics , e.g. with nulls _  la _",
    "sql @xcite ) .    in this section",
    "we explore the possibility of introducing a notion of _ preferred cause _ that is based on a given repair semantics .",
    "this idea is inspired by ( and generalizes ) the characterization of causes in terms of repairs that we obtained before , namely ( [ eq : df ] ) , ( [ eq : dfc ] ) , proposition [ pro : c&r ] , and corollary [ cor : card ] .",
    "if we define causes and their ( minimal ) contingency sets on the basis of a given repair semantics , the minimality condition involved in the latter will have an impact on the notion of minimal ( or preferred ) contingency set , and indirectly , on the notions of responsibility and most responsible cause .",
    "in section [ sec : pref - rep ] we summarize prioritized repairs . in section [ sec : prefc - rep ] we impose preferences on causes on the basis of the prioritized repairs introduced in @xcite ( and further investigated in @xcite ) . in section [ sec : endo ] , we briefly investigate the possibility of capturing endogenous repairs , i.e. that do not change exogenous tuples , by means of a priority relation .",
    "finally , in section [ sec : null ] , we briefly consider the possibility of defining ( preferred ) causes via attribute - based repairs that use null values .",
    "the prioritized repairs in @xcite are based on a _",
    "priority relation _ , @xmath426 , on the set of database tuples . in the case of a pair of ( mutually ) _ conflicting tuples _ , i.e. that simultaneously violate a constraint in a given set set of dcs ( possibly in company of other tuples ) , the repair process reflects the user preference -as captured by the priority relation- on the tuples that are privileged to be kept in the database , i.e. in the intended repairs .",
    "given such a priority relation , in @xcite different classes of prioritized repairs are introduced , namely the class of _ globally optimal repairs _ , that of _ pareto - optimal repairs _ , and that of _ completion - optimal repairs_. intuitively , each class relies on a different _ optimality criterion _ that is used to extend the priority relation @xmath426 on pairs of conflicting facts to a priority relation on the set of s - repairs .",
    "as a consequence , each of these three classes is contained in that of the s - repairs . in particular , all these repairs are based on tuple deletions .",
    "let us denote with @xmath427 the class of all prioritized repairs based on @xmath426 and the optimality criterion @xmath428 .",
    "its elements are called _ @xmath429-prioritized repairs _ of @xmath3 wrt .",
    "a the set @xmath71 of denial constraints .",
    "it holds @xmath430 , and then , all the elements of @xmath427 are subsets of @xmath3 .    in order to show a concrete class @xmath427 , we first recall the definitions of priority relation and _ global - optimal repair _ from @xcite .",
    "[ def : pi ] given an instance @xmath3 and a set of denial constraints @xmath71 , a binary relation @xmath426 on @xmath3 is a _ priority relation _ wrt . @xmath71 if : ( a ) @xmath426 is acyclic , and ( b ) for every @xmath431 , if @xmath432 , then @xmath0 and @xmath433 are mutually conflicting .",
    "is a _ conflict _",
    ", i.e. the two tuples jointly participate in the violation of one of the dcs in @xmath71 . ]",
    "@xmath63    [ def : pr ]",
    "let @xmath3 be an instance , @xmath71 a set of dcs , and @xmath426 a corresponding priority relation .",
    "let @xmath6 and @xmath211 be two consistent sub - instances of @xmath3 .",
    "@xmath6 is a",
    "_ global improvement _ of @xmath211 if @xmath434 , and for every tuple @xmath435 , there exists a tuple @xmath436 such that @xmath437 .",
    "@xmath6 is a _ global - optimal repair _ of @xmath3 , if @xmath6 is an s - repair and does not have a global improvement .",
    "@xmath63    in this definition , the optimality criterion , a possible @xmath428 above , is that of global - optimal repair , or @xmath438-repair , which leads to a class @xmath439 .",
    "we consider this repair semantics just for illustration purposes .",
    "[ ex : pfcex1 ] consider the database schema @xmath440 , + @xmath441 @xmath442 , and the following instance @xmath3 :    l|c|c| author & _ name _ & _ journal _ +    & john & tkde + & tom & tkde + & john & tods +       l|c|c|c| journal & _ journal _ & _ topic _ & _ # paper _ + & tkde & xml & 30 + & tkde & cube & 31 + & tods & xml & 32 +     + consider the following denial constraint : @xmath443 capturing the condition that  john does not have a journal paper on xml \" .",
    "@xmath3 is inconsistent wrt .",
    "@xmath32 , and contains the following sets of conflicting tuples : @xmath444 @xmath3 has the following s - repairs , each obtained by deleting one tuple from each of @xmath445 and @xmath446 , to resolve the conflicts : @xmath447 ( a )  now , assume a user prefers to resolve a conflict by removing tuples from the _ author _ table rather than the _ journal _ table , maybe because he considers the latter more reliable than the former .",
    "this is expressed the following priority relationships on conflicting tuples : _",
    "journal(tkde , xml,30 ) _ @xmath426 _ author(john , tkde _ ) and _ journal(tods , xml,32 ) _ @xmath426 _ author(john , tods)_.    in this case only @xmath203 is a global - optimal repair . actually , @xmath203 is a global improvement over each of @xmath448 , @xmath449 and @xmath450 .",
    "for example , if we consider @xmath448 , then @xmath451_author(john , tods),journal(tkde , xml,30)_@xmath452 and @xmath453_author(john , tods),journal(tkde , xml,30)_@xmath452 .",
    "we can see that , for each tuple in @xmath454 , there is a tuple in @xmath455 that has a higher priority .",
    "therefore , @xmath203 is a global improvement on @xmath448 .",
    "so , in this case @xmath456    in this case , the uniqueness of the global - optimal repair is quite natural as the preference relation among conflicting tuples is a total relation .",
    "so , we know how to resolve every conflict according to the user preferences .",
    "\\(b )  for a more subtle situation , assume the user has the priorities as before , but in addition he tends to believe that john has a paper in tods .",
    "in this case we have only the relationship _",
    "journal(tkde , xml,30 ) _ @xmath457 _ author(john , tkde ) _ , and no preference for resolving the second conflict . now both @xmath448 and @xmath203 are global - optimal repairs .",
    "that is , now @xmath458 .",
    "@xmath63      according to the motivation provided at the beginning of this section , we now define _ preferred causes _ on the basis of a class of prioritized repairs .",
    "( compare ( [ eq : dif ] ) below with ( [ eq : df ] ) and ( [ eq : dfc ] ) . ) to keep things simple , we concentrate on single bcqs , @xmath2 , whose associated denial constraints are denoted by @xmath99 .    before providing technical details ,",
    "we motivate the notion of preference in the context of causality . in this direction , first notice that under actual causality , we already make a difference -and only this difference- between endogenous and exogenous tuples .",
    "we can think of extending this priority relation among tuples in such a way that , for example , we prioritize -as causes- tuples in a given relation @xmath216 , and we are not interested in tuples in another relation @xmath247 .",
    "so , the user can specify a priority relation between the two relations , or different _ scores _ for these relations @xcite .    in section [ sec :",
    "disjcausescont ] actual causes and their minimal contingency sets for a ubcq were characterized as the minimal hitting sets of the collection @xmath69 of minimal subsets of a database that entail the query .",
    "those minimal hitting sets are obtained by removing at least one tuple from each of the elements of @xmath69 ( cf .",
    "proposition [ pro : ubcqcauses ] ) . at this point , user preferences , or priorities , could be applied to tuples that belong to a same set @xmath69 .",
    "[ def : jc ] given an instance @xmath3 and a bcq @xmath2 , tuples @xmath0 and @xmath433 are _ jointly - contributing _",
    "if @xmath459 , and there exists an s - minimal @xmath460 such that @xmath461 and @xmath462 .",
    "@xmath63    now we define priority relations on jointly - contributing tuples .    [ def : pricause ] given an instance @xmath3 and a bcq @xmath2 , a binary relation @xmath463 on @xmath3 is a _ causal priority relation _ wrt .",
    "@xmath2 if : ( a ) @xmath463 is acyclic , and ( b ) for every @xmath431 , if @xmath464 , then @xmath0 and @xmath433 are jointly - contributing tuples.@xmath63    this definition introduces a natural notion of preference on causality .",
    "actually , this way of approaching priorities on causes is in ( inverse ) correspondence with preference on repairs as based on priority relations on conflicting tuples . to see this",
    ", first observe that for a given instance @xmath3 and bcq @xmath2 : @xmath0 and @xmath433 are jointly - contributing tuples for @xmath2  iff  @xmath0 and @xmath433 are mutually conflicting tuples for @xmath99 .    next , in the context of prioritized repairs , a priority relation reflects a user preference on tuples that are preferred to be kept in the database .",
    "this is the inverse of causality , where a causal priority relation , as we defined it , reflects the tuples that are preferred to be ( hypothetically or counterfactually ) removed from database , to make them preferred causes .    in the following assume",
    "@xmath465 is the inverse of a causal priority relation @xmath463 .",
    "that is , @xmath466  iff  @xmath467 .",
    "clearly , @xmath465 is acyclic , and can be imposed , with the expected result , on pairs of conflicting tuples . as a consequence , @xmath465 can be used to define prioritized repairs .",
    "[ def : prefcuases ] let @xmath3 be an instance , @xmath2 a bcq , @xmath0 a tuple in @xmath3 , @xmath463 a causal priority relation on @xmath3 s tuples .",
    "@xmath468  @xmath231 is a  @xmath469_-preferred cause _ for @xmath2   iff @xmath470 .",
    "@xmath63    notice that every @xmath469-preferred cause is also an actual cause .",
    "this follows from proposition [ pro : c&r ] and the fact that prioritized repairs are also s - repairs .",
    "similarly to proposition [ pro : r&r ] , for each @xmath471 , it holds that @xmath233 , @xmath0 is a @xmath469-preferred cause , and also an actual cause for @xmath2 with s - minimal contingency set @xmath472 . in particular , @xmath0 s responsibility can be defined and computed as before , but now restricting its contingency sets to those of the form @xmath472 , with @xmath473 .",
    "in this way , a causal priority relation may affect the responsibility of a cause ( wrt . the non - prioritized case ) .",
    "* _ notation : _ *  @xmath474 is the class of all s - minimal contingency sets for a @xmath469-preferred cause @xmath0 .",
    "[ ex : pfcex2 ]  ( example [ ex : pfcex1 ] cont . )",
    "the following bcq query @xmath2 is true in @xmath3 :    @xmath475 ;    and its associated dc @xmath99 is @xmath32 in ( [ eq : kappa ] ) .",
    "we want to obtain the preferred causes for @xmath2 being , possibly unexpectedly , true in @xmath3 , with the following preferences : ( a ) we prefer those among the _ author _ tuples .",
    "( b ) it is likely that john does have a paper in tods .",
    "so , we prefer _",
    "author(john , tods ) _ not to be the cause .",
    "these causal priorities are in inverse correspondence with those in the second case of example [ ex : pfcex1](b ) about priorities for repairs .",
    "that is , for our causal priority relation @xmath463 here , its inverse @xmath465 is @xmath457 in example [ ex : pfcex1](b ) .",
    "there we had @xmath476 , which we can use to apply definition [ def : prefcuases ] .",
    "we obtain as the globally - optimal causes , i.e. as @xmath477-causes : _",
    "author(john , tkde ) _ , _ author(tods , xml,32 ) _ and _ author(john , tods _ ) , all with the same responsibility , @xmath57 .",
    "@xmath63    notice that definition [ def : prefcuases ] can be easily extended to ubcqs .",
    "this is done , as earlier in this work , by considering the set @xmath71 of denial constraints associated to a ubcq . in the other direction",
    ", we recall that if we start with a set of dcs @xmath71 , the corresponding ubcq is denoted with @xmath165 .    as we did in the previous sections of this work",
    ", we could take advantage of algorithmic and complexity results about prioritized repairs @xcite , to obtain complexity results for preferred causes problems . as an example , we establish the complexity of the minimal contingency set decision problem for @xmath477_-preferred causes_.    more precisely , for an instance @xmath3 and a ubcq @xmath2 , the _ minimal preference - contingency set _ ( decision ) problem is about deciding if a set of tuples @xmath4 is an s - minimal contingency set associated to a @xmath478-preferred cause @xmath0 .",
    "[ def : pcusp ] for a ubcq @xmath2 , the _ minimal preference - contingency set _ decision problem is about membership of :    @xmath479.@xmath63    from definition [ def : prefcuases ] , there is a close connection between @xmath480 and the _ global - optimal repair checking problem _ , i.e. about deciding if an instance @xmath6 is a @xmath438-repair of @xmath3 wrt .",
    "a set of denial constraints .",
    "if we accept functional dependencies ( fds ) among our denial constraints ( and then , ubcqs that involve inequalities ) , the following result can be obtained from the _ np_-completeness of globally - optimal repair checking @xcite for fds .",
    "[ pro : pcspccpx ] _ for a ubcq @xmath2 with inequalities , @xmath481 is _ np_-hard . _",
    "it is worth contrasting this result with the tractability result in proposition [ pro : cspccpx ] for the _ minimal contingency set decision problem _ ( mcsdp ) for actual causes .",
    "notice that proposition [ pro : cspccpx ] still holds for ubcqs with inequality .",
    "notice that we could generalize the notion of preferred cause by appealing to any notion of repair .",
    "more precisely , if we have a _ repair semantics _ @xmath424 ( based on tuple deletions for dcs ) , we could replace @xmath482 in ( [ eq : dif ] ) by @xmath483 .",
    "however , to obtain the intended results for causes , we have to be careful , as above , about a possible inverse relationship between preference on repairs and preference on causes .",
    "the partition of a database into endogenous and exogenous tuples that is used in the causality setting may also be of interest in the context of repairs .",
    "considering that we should have more control on endogenous tuples than on exogenous ones , which may come from external sources , it makes sense to consider _ endogenous repairs _ , which would be obtained by updates ( of any kind ) on endogenous tuples only .",
    "( of course , a symmetric treatment of  exogenous \" repairs is also possible ; what is relevant here is the partition . )    for example , in the case of dcs , endogenous repairs would be obtained by deleting endogenous tuples only .",
    "more formally , given @xmath101 , possibly inconsistent with a set of dcs @xmath71 , an _ endogenous repair _",
    "@xmath6 of @xmath3 is a maximally consistent sub - instance of @xmath3 with @xmath484 , i.e. @xmath6 keeps all the exogenous tuples of @xmath3 .",
    "if endogenous repairs form the class @xmath485 , it holds @xmath486 .",
    "[ ex : endrep ]  consider @xmath113 , with @xmath487 @xmath488 and @xmath489 , and the dc @xmath490 .    here , @xmath122",
    "@xmath123 @xmath124 @xmath125",
    "@xmath126 , with @xmath491 @xmath492 , @xmath493 ,  and @xmath494 .  the only endogenous s - repair is @xmath448 .",
    "@xmath63    in this section , without trying to be exhaustive or detailed , we consider the possibility of defining endogenous repairs on the basis of a suitable priority relation @xmath426 on tuples , while at the same time taking advantage of the _ op _ optimality condition considered in section [ sec : pref - rep ] .    first , if we assume that relation @xmath457 , the extension of @xmath426 , is such , that @xmath495 when @xmath496 and @xmath497 ( @xmath457 is @xmath426 if the latter already has this property ) , then it is easy to verify that every endogenous s - repair globally improves any non - endogenous s - repair . as a consequence , if there is an endogenous s - repair , then all the @xmath498-repairs are endogenous .",
    "notice that the extension @xmath457 may destroy the acyclicity assumption on the priority relation , because we are starting from a given ( acyclic ) relation @xmath426 , which we are now extending",
    ".    it might be the case that there is no endogenous s - repair , in which case non - endogenous s - repairs would not the improved by an endogenous one .",
    "so , if we want only endogenous repairs , we can add an extra , dummy predicate @xmath499 to the schema , and the endogenous tuple @xmath500 to @xmath3 .",
    "we modify every dc , say  @xmath501 , by adding an extra , dummy condition :  @xmath502 . in this case",
    ", the s - repairs will be :  @xmath503 , which is endogenous , and also all those s - repairs of @xmath3 wrt .",
    "@xmath71 ( now each including @xmath500 ) .",
    "if we assume that @xmath504 , for every @xmath41 , then every non - endogenous s - repair will be improved by @xmath505 , and will be discarded .",
    "if we get rid of the original priority relationships @xmath437 , with @xmath506 , if any , then the @xmath498-repairs of @xmath507 wrt .",
    "@xmath508 will be all endogenous , namely @xmath505 plus the @xmath509 , where @xmath6 is an endogenous @xmath438- repair of @xmath3 wrt .",
    "in particular , if the only priority relationships are @xmath510 , with @xmath41 , then we obtain as repairs : @xmath505 plus all the endogenous s - repairs of @xmath3 wrt .",
    "@xmath71 ( each of them now including also the tuple @xmath500 ) .",
    "consider an instance @xmath511 that may be inconsistent wrt .",
    "a set of dcs .",
    "the allowed repair updates are changes of attribute values by the constant _",
    "null_. we assume that @xmath512 does not join with any other value , including _ null _  itself .    in order to keep track of changes",
    ", we may introduce numbers as first arguments in tuples , as global tuple identifiers ( ids ) .",
    "so , @xmath3 becomes @xmath513 .",
    "assume that @xmath514 returns the i d of the tuple @xmath231 .",
    "for example , @xmath515 .",
    "if , by updating @xmath3 into @xmath6 in this way , the value of the @xmath276th attribute in @xmath216 is changed to _ null _ , then the change is captured as the string @xmath516 $ ] .",
    "these strings are collected forming the set @xmath517 .",
    "for example , if @xmath518 is changed into @xmath519 @xmath520 , we have @xmath521 , s[2;1 ] , s[3;1 ] , s[3;2]\\}$ ] .",
    "null_-repair of @xmath3 wrt .",
    "a set of dcs @xmath71 is a consistent instance @xmath6 , such that @xmath517 is minimal under set inclusion .",
    "@xmath522 denotes the class of null - based repairs of @xmath3 wrt .",
    "@xmath71 .",
    "[ ex : nullreps ]  ( example [ ex : endrep ] cont . )",
    "consider the following inconsistent instance wrt .",
    "dc  @xmath523 :    @xmath524 @xmath525 .    for simplicity",
    ", we do not make any difference between endogenous and exogenous tuples . here",
    ", the class of _ null - based repairs _ , @xmath526 , is formed by :    @xmath527 ,    @xmath528 ,    @xmath529 ,    @xmath530 ,    @xmath531 ,    @xmath532 .    here ,",
    "@xmath533\\}$ ] , and @xmath534 , s[6;1]\\}$ ] .",
    "@xmath63    according to the motivation provided at the beginning of this section , we can now define causes appealing to the class of null - based repairs of @xmath3 . since repair actions in this case , are attribute - value changes , causes can be defined at both the tuple and attribute levels .",
    "the same applies to the definition of responsibility ( in this case generalizing proposition [ pro : r&r ] ) .",
    "[ def : attcuases ] for @xmath3 an instance and @xmath2 a bcq , and @xmath231 be a tuple of the form @xmath535 .    1 .   @xmath536 $ ] is a  _ null - based attribute - value cause _ for @xmath2   if there is @xmath537 @xmath538 with @xmath539 \\in { { \\it diff}}^{{{\\it null}}}(d , d')$ ] . + ( that is , the value @xmath540 for attribute @xmath541 in the tuple is a cause if it is changed into a null in some repair . ) 2 .",
    "@xmath0 is a  _ null - based tuple cause _ for @xmath2   if some @xmath536 $ ] is a _ null - based attribute - value cause _ for @xmath2 .",
    "+ ( that is , the whole tuple is a cause if at least one of its attribute values is changed into a null in some repair . ) 3 .",
    "the responsibility , @xmath542 , of @xmath0 , a  _ null - based tuple cause _ for @xmath2 , is the inverse of @xmath543 \\in   { { \\it diff}}^{{{\\it null}}}(d , d ' ) , \\mbox { for some } j , \\mbox { and}$ ] @xmath544 .",
    "the responsibility , @xmath545)$ ] , of @xmath536 $ ] , a  _ null - based attribute - value cause _ for @xmath2 , is the inverse of @xmath543 \\in   { { \\it diff}}^{{{\\it null}}}(d,$ ] @xmath546 @xmath547 .",
    "@xmath63    in cases ( c ) and ( d ) we minimize over the number of changes in a repair that are made together with that of the candidate tuple / attribute - value to be a cause . in the case of a tuple cause ,",
    "any change made in one of its attributes is considered in the minimization .",
    "for this reason , the minimum may be smaller than the one for a fixed attribute value change ; and so the responsibility at the tuple level may be greater than that at the tuple level . more precisely ,",
    "if @xmath548 , and @xmath536)$ ] is a _ null - based attribute - value cause _ , then it holds @xmath545 ) \\leq \\rho^{\\mbox{\\small \\it t - null}}(t)$ ] .",
    "[ ex : nullreps ] cont . )",
    "consider @xmath549 .",
    "its projection on its first ( non - id ) attribute , @xmath550 $ ] , is an attribute - level cause since @xmath551 \\in { { \\it diff}}^{{{\\it null}}}(d , d_2)$ ] .",
    "also @xmath551 \\in { { \\it diff}}^{{{\\it null}}}(d , d_3)$ ] .",
    "since @xmath552 , it holds @xmath553 ) = \\frac{1}{2}$ ] .    clearly @xmath554 is a _ null - based tuple cause _ for @xmath2 , with @xmath555 .",
    "@xmath63    notice that the definition of tuple - level responsibility , i.e. case ( c ) in definition [ def : attcuases ] , does not take into account that a same i d , @xmath276 , may appear several times in a @xmath517 .",
    "in order to do so , we could redefine the size of the latter by taking into account those multiplicities .",
    "for example , if we decrease the size of the _ diff _ by one with every repetition of the i d , the responsibility for a cause may ( only ) increase , which makes sense .",
    "our work opens interesting research directions , some of which are briefly discussed below .",
    "they are matter of ongoing and future research .      as discussed in section [ sec : pref - cause ] , the partition of a database into endogenous and exogenous tuples may also be of interest in the context of repairs .",
    "we may prefer endogenous repairs that change ( delete in this case ) only endogenous tuples .",
    "however , if there are no endogenous tuples , a preference condition could be imposed on repairs , keeping those that change exogenous tuples the least .",
    "this is something to explore .    as a further extension",
    ", it could be possible to assume that combinations of ( only ) exogenous tuples never violate the integrity constraints , which could be checked at upload time . in this sense",
    ", there would be a part of the database that is considered to be consistent , while the other is subject to possible repairs .",
    "for somehow related research , see @xcite .",
    "going a bit further , we could even consider the relations in the database with an extra , binary attribute , @xmath556 , that is used to annotate if a tuple is endogenous or exogenous ( it could be both ) , e.g. a tuple like @xmath557 .",
    "integrity constraints could be annotated too , e.g. the  exogenous \" version of dc @xmath32 , could be @xmath558 , and could be assumed to be satisfied",
    ".      causality as introduced by halpern and pearl in @xcite , aka .",
    "hp - causality , is the basis for the notion of causality in @xcite .",
    "hp - causality has been the object of some criticism @xcite , which is justified in some ( more complex , non - relational ) settings , specially due to the presence of different kinds of _ logical variables _ ( or lack thereof ) .",
    "in our context the objections do not apply : variables just say that a certain tuple belongs to the instance ( or not ) ; and for relational databases the closed - world assumption applies . in @xcite ,",
    "the definition of hp - causality is slightly modified . in our setting , this modified definition does not change actual causes or their properties .",
    "we have limited our discussion to boolean queries .",
    "it is possible to extend our work to consider conjunctive queries with free variables , e.g. @xmath559 . in this case",
    ", a query answer would be of the form @xmath284 , for @xmath560 a constant , and causes would be found for such an answer . in this case , the associated dc would be of the form @xmath561 , and the rest would be basically as above .",
    "s - repairs can be specified by means of _ answer set programs _ ( asps ) @xcite , and c - repairs too , with the use of weak program constraints @xcite .",
    "this should allow for the introduction of asps in the context of causality , for specification and reasoning .",
    "there are also asp - based specifications of diagnosis @xcite that could be brought into a more complete picture .",
    "functional dependencies are dcs with conjunctive violation views with inequality , and are still monotonic .",
    "there is much research on repairs and consistent query answering for functional dependencies , and more complex integrity constraints @xcite . in causality ,",
    "mostly cqs without built - ins have been considered .",
    "the repair connection could be exploited to obtain results for causality and cqs with inequality , and also other classes of queries .",
    "abduction @xcite is another form of model - based diagnosis , and is related to the subjects investigated in this work.the _ view update problem _ , about updating a database through views , is a classical problem in databases that has been treated through abduction @xcite .",
    "user knowledge imposed through view updates creates or reflects _ uncertainty _ about the base data , because alternative base instances may give an account of the intended view updates .",
    "the view update problem , specially in its particular form of of _ deletion propagation _ , has been recently related in @xcite to causality as introduced in @xcite .",
    "( notice only tuple deletions are used with violation views and repairs associated to dcs . )",
    "database repairs are also related to the view update problem .",
    "actually , _ answer set programs _",
    "( asp ) for database repairs @xcite implicity repair the database by updating intentional , annotated predicates ( cf .",
    "section [ sec : asps ] ) .",
    "even more , in @xcite , in order to protect sensitive information , databases are explicitly and virtually  repaired \" through secrecy views that specify the information that has to be kept secret .",
    "these are prioritized repairs that have been specified via asps .",
    "abduction has been explicitly applied to database repairs @xcite .",
    "the deep interrelations between causality , abductive reasoning , view updates and repairs are the objects of our ongoing research efforts @xcite .",
    "in this research we have unveiled and formalized some first interesting relationships between causality in databases , database repairs , and consistency - based diagnosis . these connections allow us to apply results and techniques developed for each of them to the others .",
    "this is particularly beneficial for causality in databases , where still a limited number of results and techniques have been obtained or developed .",
    "the connections we established here inspired complexity results for causality , e.g. theorems [ the : r&diag ] and [ the : cqa&ca&cox ] , and were used to prove them .",
    "we appealed to several non - trivial results ( and the proofs thereof ) about repairs / cqa obtained in @xcite .",
    "it is also the case that the well - established hitting - set approach to diagnosis inspired a similar approach to causal responsibility , which in its turn allowed us to obtain results about its fixed - parameter tractability .",
    "it is also the case that diagnostic reasoning , as a form of non - monotonic reasoning , can provide a solid foundation for causality in databases and query answer explanation , in general @xcite .    in ongoing research",
    "we have established connections between query answer causality , abductive diagnosis and database updates through views @xcite .",
    "it is interesting that several of these areas of data management and knowledge representation , including those considered in this work , fall under what has been called ",
    "reverse data management \" tasks @xcite .",
    "our work establishes formal connections between them and sets the ground for further investigation into their interrelationships .",
    "* acknowledgments : *  research funded by nserc discovery , and the nserc strategic network on business intelligence ( bin ) . conversations with alexandra meliou during leo bertossi s visit to u. of washington in 2011 are much appreciated .",
    "he is also grateful to dan suciu and wolfgang gatterbauer for their hospitality .",
    "l. bertossi is grateful to benny kimelfeld for stimulating conversations .",
    "part of the research was developed by l. bertossi during partial sabbatical stays at _ logicblox _ and _ the center for semantic web research _",
    "( chile ) . their support is much appreciated .",
    "barcelo ,  p. , bertossi ,  l. and bravo ,  l. characterizing and computing semantically correct answers from databases with annotated logic and answer sets . in _ semantics of databases",
    "_ , springer lncs 2582 , 2003 , pp . 1 - 27",
    ".          bertossi ,  l. and salimi ,  b. unifying causality , diagnosis , repairs and view - updates in databases .",
    "presented at the first international workshop on big uncertain data ( buda 2014 ) .",
    "posted at : arxiv:1405.4228 [ cs.db ] .",
    "bravo , l. and bertossi , l. semantically correct query answers in the presence of null values . proc .",
    "edbt ws on inconsistency and incompleteness in databases ( iidb 06 ) , j. chomicki and j. wijsen ( eds . ) , springer lncs 4254 , 2006 , pp .",
    "336 - 357 .",
    "lopatenko , a. and bertossi , l. complexity of consistent query answering in databases under cardinality - based and incremental repair semantics . , 2007 , springer lncs 4353 , pp .",
    "179 - 193 .",
    "extended version posted at : arxiv : cs/0604002 [ cs.db ] .",
    "salimi , b. and bertossi , l. causality in databases : the diagnosis and repair connections .",
    "presented at _ the 15th international workshop on non - monotonic reasoning ( nmr 2014)_. posted at : arxiv:1404.6857 [ cs.db ] ."
  ],
  "abstract_text": [
    "<S> in this work we establish and investigate connections between causes for query answers in databases , database repairs wrt . </S>",
    "<S> denial constraints , and consistency - based diagnosis . </S>",
    "<S> the first two are relatively new research areas in databases , and the third one is an established subject in knowledge representation . we show how to obtain database repairs from causes , and the other way around . </S>",
    "<S> causality problems are formulated as diagnosis problems , and the diagnoses provide causes and their responsibilities . </S>",
    "<S> the vast body of research on database repairs can be applied to the newer problems of computing actual causes for query answers and their responsibilities . </S>",
    "<S> these connections , which are interesting _ per se _ , allow us , after a transition -inspired by consistency - based diagnosis- to computational problems on hitting sets and vertex covers in hypergraphs , to obtain several new algorithmic and complexity results for database causality .    </S>",
    "<S> example.eps gsave newpath 20 20 moveto 20 220 lineto 220 220 lineto 220 20 lineto closepath 2 setlinewidth gsave .4 setgray fill grestore stroke grestore </S>"
  ]
}