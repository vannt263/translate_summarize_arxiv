{
  "article_text": [
    "recently _ quantum computing _ has attracted great attention by its potential abilities  @xcite . to realize a quantum algorithm , it is necessary to design the corresponding _ quantum circuit _ as small as possible .",
    "thus , it should be very important to study quantum circuit design methods even before quantum computing is physically realized .",
    "indeed , there has been a great deal of research  @xcite for quantum circuit design .",
    "typical quantum circuit design methods are based on _ matrix decomposition _",
    "@xcite since a quantum algorithm is expressed by a matrix .",
    "they can treat any kind of quantum circuits , but they can not treat large ( hence , practical ) size problems since they need to express matrices explicitly and thus they need exponential time and memory .",
    "( note that a matrix for an @xmath0-bit quantum circuit is @xmath1 , which will be explained later . )",
    "there is a different approach for quantum circuit design  @xcite .",
    "the approach is to focus on quantum circuits calculating only ( classical ) boolean functions by the following observation  @xcite : standard quantum algorithms usually consist of two parts , which we call _ common parts _ and _ unique parts _ below . _",
    "common parts _ do not differ for each problem instance . on the other hand ,",
    "_ unique parts _",
    "differ for each problem instance . for example , grover search algorithm  @xcite , one of the famous quantum algorithms , consists of so called an _ oracle _ part and the other part .",
    "an _ oracle _",
    "part calculates ( classical ) boolean functions depending on the specification of a given problem instance , while the other part consists of some quantum specific operations and does not change for all the problem instances .",
    "when we developed a new quantum algorithm , we should have designed the common part .",
    "therefore , we do not need to design the common part for individual problem instances . on the other hand ,",
    "since the unique part of a quantum algorithm differ for each problem instance , we need to have efficient design and verification methods for that part .",
    "since unique part calculates classical boolean functions , by focusing on only unique parts , we may have a design method to handle practical size problems based on ( classical ) logic synthesis techniques , especially reversible logic synthesis techniques .",
    "indeed there has been a great deal of research focusing on quantum circuits to calculate classical boolean functions in the conventional logic synthesis research community  @xcite .",
    "we also focus on this type of quantum circuits in this paper .",
    "it should be noted that there are many different points between our target quantum circuits and the conventional logic circuits ( as will be explained later ) although our target quantum circuits calculate only classical boolean functions .",
    "this is because we need to implement circuits with quantum specific operations ( as will be explained later ) .",
    "therefore , we definitely need quantum specific design and verification methods even for our target quantum circuits .",
    "recently a paper  @xcite discussed a problem of the equivalence check of _ general _ quantum circuits and quantum states considering the so - called _ phase equivalence _",
    "property of quantum states . even for quantum circuits calculating",
    "_ only _ boolean functions , it should be very important to verify and analyze the functionalities of designed circuits as in the case of classical logic synthesis .",
    "for example , we may consider the following situation : one of the possible realizations of quantum computation is considered to be so called a _ linear - nearest - neighbor ( lnn ) _ architecture in which the _ quantum bits ( qubits ) _ are arranged on a line , and only operations to neighboring qubits are allowed .",
    "thus , we need to modify a designed quantum circuit so that it uses only gates that operate to two adjacent qubits . in such a case",
    ", we may use some complicated transformations by hand , and thus it is very convenient if we have a verification tool to confirm that the original and the modified quantum circuits are functionally equivalent .    if we consider only the classical type gates , it is enough to use the conventional verification technique such as binary decision diagrams ( bdds )  @xcite for the verification . however , even if we consider quantum circuits calculating only boolean functions , it is known that non - classical ( quantum specific ) gates are useful to reduce the circuit size  @xcite .",
    "thus we need to verify quantum circuits with non - classical gates . in such cases , a classical technique is obviously not enough .",
    "as for simulating quantum circuits , efficient techniques using decision diagrams such as quantum information decision diagrams ( quidds )  @xcite and quantum multiple - valued decision diagrams ( qmdds )  @xcite have been proposed . by using these efficient diagrams , we can express the functionalities of two quantum circuits , and then verify the equivalence of the two circuits .",
    "however , they are originally proposed to simulate _",
    "general _ quantum circuits , and thus there may be a more efficient method that is suitable for verifying the functionalities of quantum circuits only for boolean functions .    * our contribution described in this paper . * considering the above discussion , we introduce a new quantum circuit class : _ semi - classical quantum circuits ( scqcs)_. although scqcs have a restriction , the class of scqcs covers all the quantum circuits ( for calculating a boolean function ) designed by the existing methods  @xcite . moreover , because of the restriction of scqcs , we can express the functionalities of scqcs very efficiently as in the case of conventional verifications by bdds .",
    "for that purpose , we introduce a new decision diagram structure called _ a decision diagram for a matrix function ( ddmf)_. then , we show that the verification method based on ddmfs are much more efficient than the above mentioned methods based on previously known techniques .",
    "we provide an analytical comparison between ddmfs and quidds , and reveal the essential difference : ( 1 ) we show that their ability to express the functionality of one quantum gate is essentially the same , but ( 2 ) we also show that our approach based on ddmfs is much more efficient for the verification of scqcs than a method based on quidds . (",
    "note that this does not mean that ddmfs are better than quidds : ddmfs are only for scqcs , whereas quidds can treat all kinds of quantum circuits . )",
    "moreover , we show by preliminary experiments that ddmfs can be used to verify scqcs of practical size ( 60 inputs and 400 gates ) . in order to introduce ddmfs",
    ", we also introduce new concepts , _ quantum functions _ and _ matrix functions _ , which may be interesting and useful on their own for designing quantum circuits with quantum specific gates .",
    "this section introduces new concepts : scqcs together with quantum functions , matrix functions and ddmfs .      before introducing our new concepts ,",
    "let us briefly explain the basics of quantum computation .    in quantum computation",
    ", it is assumed that we can use a _ qubit _ which is an abstract model of a _ quantum state . _",
    "a qubit can be described as @xmath2 , where @xmath3 and @xmath4 are two basic states , and @xmath5 and @xmath6 are complex numbers such that @xmath7 .",
    "it is convenient to use the following vectors to denote @xmath3 and @xmath4 , respectively : @xmath8 and , @xmath9 thus , @xmath2 can be described as a vector : @xmath10 then , any quantum operation on a qubit can be described as a 2@xmath112 matrix . by the laws of quantum mechanics ,",
    "the matrix must be _ unitary .",
    "_ we call such a quantum operation a _ quantum gate_. for example , the operation which transforms @xmath3 and @xmath4 to @xmath4 and @xmath3 , respectively , is called a @xmath12 gate whose matrix representation is as shown in fig .",
    "[ fig : matrix ] .",
    "in addition to the above @xmath12 gates , we can also use any quantum specific unitary matrix in quantum circuits .",
    "for example , _ rotation gates _ denoted by @xmath13 are often used in quantum computation .",
    "the matrix for the gates is as shown in fig .",
    "[ fig : matrix ] .",
    "although the functionality of rotation gates is not classical , they are useful to design quantum circuits even for ( classical ) boolean functions  @xcite .",
    "another quantum specific gate called @xmath14 gate is also utilized to design quantum circuits for boolean functions  @xcite .",
    "the matrix for the gate is as shown in fig .",
    "[ fig : matrix ] .",
    "this gate has the interesting property that @xmath15 .    in the following ,",
    "our primitive gates are ( generalized ) _ controlled - u gates _ which are defined as follows :    a controlled - u gate has ( possibly many ) positive and negative control bits , and one target bit .",
    "it applies a 2@xmath112 unitary matrix @xmath16 to the target qubit when the states of all the positive control bits are the states @xmath4 and the states of all the negative control bits are the state @xmath3 .",
    "a controlled - u gate may not have a control bit .",
    "in such a case , it always applies @xmath16 to the target qubit .",
    "see an example of a quantum circuit consisting of two controlled-@xmath12 gates in fig .",
    "[ fig : circuit1 ] .",
    "this circuit has three qubits , @xmath17 , @xmath18 and @xmath19 , each of which corresponds to one line . in quantum circuits ,",
    "each gate works one by one from the left to the right . for the first gate ,",
    "the target bit is @xmath20 and the symbol @xmath21 means the @xmath12 operation .",
    "the positive control bits are @xmath22 and @xmath23 denoted by black circles .",
    "this gate performs @xmath12 on @xmath19 only when both @xmath17 and @xmath18 are the state @xmath4 .",
    "consider the second gate in the same figure .",
    "the white circles denote negative controls , which means the gate performs @xmath12 only when both @xmath17 and @xmath18 are the states @xmath3 .",
    "in addition to controlled-@xmath12 gates which are essentially classical gates , we can consider any ( quantum specific ) unitary operation for controlled gates .",
    "for example , the functionalities of controlled gates in figs .",
    "[ fig : adder ] and  [ fig : non - scqc ] are various ( e.g. , not , @xmath14 , @xmath24 , @xmath25 and @xmath26 ) .",
    "consider fig .",
    "[ fig : circuit1 ] again .",
    "this circuit transforms the state of the third bit @xmath19 into @xmath27 , where @xmath28 .",
    "( throughout the paper , we use @xmath29 to mean the logical negation of @xmath30 . )",
    "thus , we can use this circuit ( as a part of a quantum algorithm ) to calculate the boolean function @xmath31 . as mentioned before , although our goal is to construct such a quantum circuit that calculates a boolean function , quantum specific gates ( such as @xmath13 and @xmath14 ) are useful  @xcite to make the circuit size smaller .",
    "for example , the circuit as shown in fig .",
    "[ fig : adder ] ( reported in  @xcite ) utilizes controlled-@xmath14 and controlled-@xmath24 gates to become much smaller than the best one with only classical type gates , i.e. , controlled-@xmath12 gates .",
    "( that was confirmed by an essentially exhaustive search  @xcite . )    in order to characterize such a quantum circuit that calculates a classical boolean function with non - classical gates , we introduce a _ semi - classical quantum circuit ( scqc ) _ whose definition is as follows .",
    "a semi - classical quantum circuit ( scqc ) is a quantum circuit consisting of controlled - u gates with the following restriction .    * restriction . *",
    "if all the initial input quantum states of the circuit are @xmath4 or @xmath3 ( i.e. , just classical values ) , the quantum states of the control qubits of all the gates in the circuit should be @xmath4 or @xmath3 at the time when the gate is being operated .",
    "the circuit in fig .",
    "[ fig : adder ] is an scqc .",
    "this is because the quantum states of the control qubits of all the gates are either @xmath4 or @xmath3 when the gate is being operated if the initial input states @xmath17 , @xmath18 and @xmath19 are either @xmath4 or @xmath3 .",
    "it is not trivial to see the condition for the quantum state of the control qubit of the last gate ( i.e. , @xmath19 ) in fig .",
    "[ fig : adder ] .",
    "however , by using our new concepts ( explained in the next section ) , it is easy to verify that the state is indeed the classical value if the input states of the circuit are classical values .",
    "on the contrary , the circuit as shown in fig .",
    "[ fig : non - scqc ] is not an scqc .",
    "again , by using our new concept it is easily verified that the condition is not satisfied for the quantum state of the control qubit of the last gate ( i.e. , @xmath19 ) in fig .",
    "[ fig : non - scqc ] .",
    "our motivation to introduce scqcs is based on the following observations .    *",
    "although scqcs are in a subset of all the possible quantum circuits , quantum circuits ( for calculating a boolean function ) designed by the existing methods are all scqcs to the best of our knowledge  @xcite .",
    "* even in the future , it is very unlikely that we come up with a _ tricky _ design method that produces a non - scqc to calculate ( classical ) boolean functions .",
    "the reason is as follows .",
    "if the circuit is not an scqc , there is a gate such that the quantum state of its control bit is not a simple classical value ( @xmath3 nor @xmath4 ) . in such a case ,",
    "the quantum states of the control bit and the target bit after the gate can not be considered separately : their states are not only non - classical values but also correlated with each other .",
    "such a situation is called quantum _ superposition _ and _ entanglement _  @xcite .",
    "since the whole circuit should calculate a classical boolean function , all of the final output quantum states should be again restored to simple classical values ( i.e. , @xmath3 or @xmath4 ) if all the initial input quantum states of the circuit are simple classical values .",
    "the reverse operations of creating quantum superposition and entanglement seems to be the only method to restore to a simple classical value .",
    "thus , it seems nonsense to consider non - scqc circuits when we consider practical design methods of quantum circuits to calculate boolean functions .",
    "* important note : * the restriction of scqcs means that we can not make _ entanglement _ if all the initial input quantum states of an scqc are just classical values .",
    "it is well - known that quantum computation without entanglement has no advantage over classical computation .",
    "however , this does not mean that scqcs are meaningless by the following reason : as mentioned , an scqc is used as a sub - circuit to calculate a boolean function for some quantum algorithms .",
    "thus , in the real situation where an scqc is used as a sub - circuit , the inputs to the scqc are not simple classical values , and so it indeed creates entanglement which should give us the advantage of quantum computation .",
    "in other words , the restriction of scqcs in the definition is considered when we suppose the inputs of scqcs are just classical values , which is not a real situation where scqcs are really used .",
    "therefore , scqcs should be enough if we consider designing a quantum circuit to calculate a boolean function from the practical point of view .",
    "moreover , the restriction of scqcs provides us an efficient method to analyze and verify quantum circuits as we will see in sec .",
    "[ sec : veri ] .",
    "that is our motivation to introduce the new concept in this paper .      before introducing our new representation of the functionalities of scqcs",
    ", we need the following definitions .    a quantum function with respect to @xmath0 boolean variables @xmath32 is a mapping from @xmath33 to qubit states .",
    "see the third bit after the first gate in the circuit in fig .",
    "[ fig : adder ] again .",
    "if the initial state of @xmath19 is @xmath3 , the resultant state of the third bit can be seen as a quantum function described as @xmath34 in the second column of table  [ tb ] .",
    "for example , the resultant quantum state becomes @xmath35 when @xmath36 .",
    "thus , @xmath37 is defined as @xmath35 as shown in the table .    note that a boolean function can be seen as a special case of quantum functions .",
    "for example , the third column ( @xmath38 ) of table  [ tb ] shows the quantum function of the resultant third qubit after the two gates of the circuit in fig .",
    "[ fig : circuit1 ] when the initial state of @xmath19 is @xmath3 .",
    "this can be considered as the output of a boolean function when @xmath3 and @xmath4 are considered as boolean values @xmath39 and @xmath40 , respectively .",
    "( as mentioned before , the circuit is considered to calculate the boolean function : @xmath41 , which we consider essentially the same as ( @xmath38 ) in table  [ tb ] . )",
    "the value of a quantum function @xmath42 can always be expressed as @xmath43 , where @xmath44 is a mapping from @xmath45 to 2@xmath112 unitary matrices .",
    "it is convenient to consider @xmath46 instead of @xmath42 itself , thus we introduce the following definition .",
    "a matrix function with respect to @xmath0 boolean variables @xmath32 is a mapping from @xmath33 to 2@xmath112 ( unitary ) matrices .",
    "the fourth and the fifth columns of table  [ tb ] show the matrix function @xmath47 and @xmath48 for the quantum function @xmath49 and @xmath38 , respectively , in the same table . in this paper , we treat a matrix function whose output values are only @xmath50 or @xmath12 as a classical boolean function by considering that @xmath12 and @xmath50 of the matrix function correspond to @xmath40 and @xmath39 , respectively , of the boolean function . in other words , we represent a boolean function by a matrix function as a special case .",
    "we define a special type of matrix function called _ constant matrix function _ as follows .",
    "a matrix function @xmath44 is called a constant matrix function if @xmath44 are the same for all the assignments to @xmath51 .",
    "@xmath52 denotes a constant matrix function that always equals to the matrix @xmath53 .",
    "the sixth and the seventh columns of table  [ tb ] show the truth tables for constant matrix functions , @xmath54 and @xmath55 , respectively .    by using the matrix function @xmath47 in the fourth column of table  [ tb ] , we can easily see how the first gate in fig .",
    "[ fig : adder ] transforms the third qubit @xmath56 : @xmath56 is transformed to @xmath57 .",
    "for example , when @xmath58 , @xmath56 is transformed to @xmath59 .",
    "we would like to stress again the following point : the above means that the representation ( and so the analysis ) by matrix functions works even when @xmath56 is any general quantum state .",
    "indeed , we can use an scqc even when the input states are not simple classical values , i.e. , the restriction of scqcs does not say that scqcs can not be used when the inputs are not classical .",
    "( if so , we may not be able to use an scqc for a part of a quantum algorithm . )    for matrix functions , we introduce two operators `` @xmath21 '' and ` @xmath60,' which are used to construct ddmfs for a quantum circuit in the following sections .",
    "[ def1 ] let @xmath47 , @xmath48 and @xmath61 be matrix functions with respect to @xmath22 to @xmath62 .",
    "then @xmath63 is defined as a matrix function @xmath64 such that @xmath65 where @xmath66 means normal matrix multiplication .",
    "let also @xmath67 be a boolean function with respect to @xmath22 to @xmath62 .",
    "then @xmath68 is a matrix function which equals to @xmath69 when @xmath70 , and equals to @xmath50 when @xmath71 .",
    "note that the operator @xmath60 is defined as asymmetric , i.e. , the first argument should be a boolean function whereas the second argument can be any matrix function .",
    "this is due to the restriction of scqcs such that the state of a control bit should be @xmath4 or @xmath3 ( i.e. , just classical value ) whereas the state of a target bit can be any quantum state .",
    "see examples in table  [ operators ] . note that if both of @xmath47 and @xmath48 are considered to be boolean functions like @xmath48 in table  [ tb ] , the operator @xmath21 corresponds to the exor of the two boolean functions .",
    "note also that if @xmath61 is essentially a boolean function like @xmath48 in table  [ tb ] , the operator @xmath60 corresponds to the and of the two boolean functions .",
    "a matrix function for a quantum function can be expressed efficiently by using an edge - valued binary decision diagram structure , which we call a ddmf whose definition is as follows :    a decision diagram for a matrix function ( ddmf ) is a directed acyclic graph with three types of nodes : ( 1 ) a single terminal node corresponding to the identity matrix @xmath50 , ( 2 ) a root node with an incoming edge having a weighted matrix @xmath53 , and ( 3 ) a set of non - terminal ( internal ) nodes .",
    "each internal and the root node are associated with a boolean variable @xmath72 , and have two outgoing edges which are called 1-edge ( solid line ) leading to another node ( the 1-child node ) and 0-edge ( dashed line ) leading to another node ( the 0-child node ) .",
    "every edge has an associated matrix .",
    "the matrix function represented by a node is defined recursively by the following three rules .",
    "\\(1 ) the matrix function represented by the terminal node is the constant matrix function @xmath54 .",
    "\\(2 ) the matrix function represented by an internal node ( or the root node ) whose associated variable is @xmath72 is defined as follows : @xmath73 , where @xmath47 and @xmath74 are the matrix functions represented by the 1-child node and the 0-child node , respectively , and @xmath75 and @xmath76 are the matrices of the 1-edge and the 0-edge , respectively .",
    "( see an illustration of this structure in fig .",
    "[ fig : ddmf1 ] . )",
    "\\(3 ) the root node has one incoming edge that has a matrix @xmath53 .",
    "then the matrix function represented by the whole ddmf is @xmath77 , where @xmath64 is a matrix function represented by the root node .    like conventional bdds",
    ", we achieve the canonical form for a ddmf if we impose the following restriction on the matrices on all the edges .",
    "a ( ddmf ) is canonical when ( 1 ) all the matrices on 0-edges are @xmath50 , ( 2 ) there are no redundant nodes : no node has 0-edge and 1-edge pointing to the same node with @xmath50 as the 1-edge matrix , and ( 3 ) common sub - graphs are shared : there are no two identical sub - graphs .",
    "any ddmf can be converted to its canonical form by using the following transformation from the terminal node to the root node : suppose the matrices on incoming edge , 0-edge and 1-edge of a node be @xmath53 , @xmath76 and @xmath75 , respectively .",
    "then , if @xmath76 is not @xmath50 , we modify these three matrixes as follows : ( 1 ) the matrix on the incoming edge is changed to be @xmath78 .",
    "( 2 ) the matrix on the 1-edge is changed to be @xmath79 .",
    "( 3 ) the matrix on the 0-edge is changed to be @xmath50 .",
    "it is easily verified that this transformation does not change the matrix function represented by the ddmf .",
    "see the example in fig .",
    "[ fig : canonicali ] where the matrix on 0-edge of the node @xmath23 is converted to @xmath50 . in the example , the matrices @xmath50 on edges are omitted .",
    "* note : * the concepts of _ quantum functions _ and _ matrix functions _ may be used implicitly in the design method of  @xcite , and the decision diagram structure is similar between ddmfs and the quantum decision diagrams used in  @xcite .",
    "however , the quantum decision diagrams in  @xcite are used to represent conventional boolean functions whereas ddmfs are used for representing matrix functions : the terminal node of a ddmf is a matrix @xmath50 .",
    "also a weight on an edge in ddmfs is generalized to any matrix .",
    "thus , ddmfs can be considered as a generalization of quantum decision diagrams to treat matrix functions rather than boolean functions .",
    "( as we have seen in table  [ tb ] , boolean functions can be seen as a special case of quantum functions . )",
    "we will use the same operators , @xmath21 and @xmath60 , for ddmfs as for matrix functions :    let @xmath80 , @xmath81 and @xmath82 be ddmfs that represent matrix functions @xmath47 , @xmath48 and @xmath61 , respectively .",
    "then @xmath83 is defined as a ddmf that represents a matrix function @xmath84 .",
    "let also @xmath85 be a ddmf that represents a boolean function @xmath67 .",
    "then @xmath86 is defined as a ddmf that represents a matrix function @xmath68",
    "see two scqcs in fig .  [",
    "fig : scqc1 ] and fig .",
    "[ fig : scqc2 ] .",
    "it is easy to see that their functionalities are the same .",
    "however , the problem is how to verify the equality for much larger circuits .",
    "thanks to the introduction of ddmfs , we propose a method to verify the equality of given two @xmath0-qubit scqcs in the following .",
    "* we construct a ddmf to represent the matrix function that expresses the functionality for each qubit state at the end of each circuit .    * step 2 .",
    "* we compare two ddmfs for the corresponding qubits of the two circuits .",
    "the comparison of two ddmfs can be done in @xmath87 time as in the case of bdds .",
    "1 is performed in a similar manner of constructing bdds to represent each boolean function in a logic circuit : ( 1 ) we first construct a ddmf for each primary input @xmath72 , and then ( 2 ) we pick a gate one by one from the primary inputs , and construct a ddmf for the output function of the gate from ddmfs for the input functions of the gate . the construction of a ddmf from two ddmfs can be done recursively as exactly the same as the construction of a bdd from two bdds  @xcite . in the below , we use a notation @xmath88 to express the ddmf for the @xmath89-th quantum qubit state right after the @xmath90-th gate .",
    "we also use a notation @xmath91 to denote the matrix function ( or the boolean function in a special case ) represented by a ddmf @xmath92 .",
    "* initialization .",
    "* for each input @xmath72 , we construct a @xmath93 as a ddmf for @xmath72 .",
    "this is the ddmf for the matrix function ( in fact , essentially a boolean function ) which is @xmath12 when @xmath94 .",
    "* construction of the ddmfs right after the @xmath90-th gate .",
    "* from the first gate to the last gate , we construct @xmath88 from @xmath95 as follows .",
    "if the @xmath89-th bit is not the target bit of the @xmath90-th gate , @xmath96 . if the @xmath89-th bit is the target bit of the @xmath90-th gate @xmath97 where @xmath98 is constructed by the following two steps .",
    "\\(1 ) for the @xmath90-th gate , let us suppose that the positive control bits be the @xmath99-th bits , and the negative control bits be the @xmath100-th bits .",
    "then , by the restriction of scqcs , all the matrix functions @xmath101 for @xmath102 are essentially classical boolean functions .",
    "( therefore , in the following expression , we treat @xmath101 as boolean functions , and perform logical operations on them . )",
    "thus we can calculate a logical and of them : @xmath103 .",
    "note that this boolean function can be obtained by ddmf operations since a ddmf represents a boolean function in a special case .",
    "\\(2 ) we construct @xmath104 for @xmath105 ) @xmath106 for @xmath107 , where @xmath16 is a unitary matrix associated with the @xmath90-th gate .",
    "note that all the ddmf operations in the above should be performed efficiently by using _",
    "apply _ operations and _ operation and node hash tables _ as the conventional bdd operations  @xcite .",
    "we show an example of ddmfs for the quantum circuit as shown in fig .",
    "[ fig : scqc1 ] . at the initialization step , we construct ddmfs for functions , @xmath108 and @xmath20 , which are @xmath109 , @xmath110 and @xmath111 , respectively , as shown in fig .  [",
    "fig : spte0 ] .",
    "then we construct the ddmfs for the quantum states right after the first gate . since the target bit is the second bit for the first gate , @xmath112 , and @xmath113 . to construct @xmath114",
    ", we first calculate a boolean function @xmath115 .",
    "this is because the first bit and the third bit are negative and positive controls , respectively .",
    "then we construct @xmath104 for @xmath105 ) @xmath106 for @xmath116 , whose matrix function is shown in table  [ ddmf - control ] .",
    "finally , we construct @xmath117 whose matrix function is as shown in table  [ ddmf-2 ] .",
    "the constructed ddmfs after the first gate are shown in fig .",
    "[ fig : spte1 ] .    .a truth table for @xmath118 [ cols=\"^,^\",options=\"header \" , ]",
    "in this paper , we introduced new concepts : scqcs together with ddmfs . as described , they should be useful for the analysis and the verification of quantum circuits with a practical restriction .",
    "it should be noted that ddmfs are provably useful even for quantum circuit design methods since ddmfs can be considered as a generalization of the data structure used in the design method in  @xcite .",
    "we also revealed the essential difference between ddmfs and quidds for representing the functionalities of scqcs . from our comparison",
    ", we can conclude that our approach is much more efficient for the verification of scqcs than a method based on known techniques .",
    "note that this does not mean that ddmfs are better than quidds : ddmfs are only for scqcs , whereas quidds can treat all kinds of quantum circuits .",
    "in other words , in some sense , our approach stands in the middle of classical boolean functions ( bdds ) and general quantum circuit specifications ( quidds or qmdds ) .",
    "as described , this standpoint can be considered as a good trade - off point if we consider designing and analyzing quantum circuits from the practical view point , i.e. , when we focus on sub - circuits to calculate boolean functions for quantum algorithms .",
    "lastly we would like to add one more issue : since ddmfs are edge - valued decision diagrams , it may be easier to verify _ quantum phase - equivalence checking _ of scqcs by ddmfs than the method based on quidds  @xcite .",
    "thus , we consider that it is an interesting future work to study how efficiently ddmfs work for _ quantum phase - equivalence checking _ of scqcs ."
  ],
  "abstract_text": [
    "<S> recently much attention has been paid to quantum circuit design to prepare for the future `` quantum computation era . '' like the conventional logic synthesis , it should be important to verify and analyze the functionalities of generated quantum circuits . for that purpose </S>",
    "<S> , we propose an efficient verification method for quantum circuits under a practical restriction . </S>",
    "<S> thanks to the restriction , we can introduce an efficient verification scheme based on decision diagrams called _ decision diagrams for matrix functions ( ddmfs)_. then , we show analytically the advantages of our approach based on ddmfs over the previous verification techniques . in order to introduce ddmfs </S>",
    "<S> , we also introduce new concepts , _ quantum functions _ and _ matrix functions _ , which may also be interesting and useful on their own for designing quantum circuits .    </S>",
    "<S> quantum circuit , verification , decision diagram </S>"
  ]
}