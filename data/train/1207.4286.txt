{
  "article_text": [
    "in model checking  @xcite the behaviour of a program is formally specified with a model . using the model , all paths through the program",
    "are then exhaustively checked against its requirements .",
    "the detailed nature of the requirements entails that the program is simulated in a fine - grained way , sometimes down to the level of individual bits . because of the complexity of this reasoning",
    "there has been much interest in abstracting away from the detailed nature of states .",
    "then , the program checker operates over classes of related states  collections of states that are equivalent in some sense  rather than individual states .",
    "abstract interpretation @xcite provides a systematic way to construct such program checkers .",
    "the key idea is to simulate the execution of each concrete operation @xmath0 in a program with an abstract analogue @xmath1 where @xmath2 and @xmath3 are domains of concrete values and descriptions , respectively .",
    "each abstract operation @xmath4 is designed to faithfully model its concrete counterpart @xmath5 in the sense that if @xmath6 describes a concrete value @xmath7 , sometimes written relationally as @xmath8  @xcite , then the result of applying @xmath5 to @xmath9 is described by the action of applying @xmath4 to @xmath10 , that is , @xmath11 . even for a fixed set of abstractions , there are typically many ways of designing the abstract operations",
    ". ideally the abstract operations should compute abstractions that are as descriptive , that is , as accurate as possible , though there is usually interplay with accuracy and complexity , which is one reason why the literature is so rich .",
    "normally the abstract operations are manually designed up front , prior to the analysis itself , but there are distinct advantages in synthesising the abstract operations from their concrete versions as part of the analysis itself , in a fully automatic way , which is one reason why the topic is attracting increasing attention  @xcite .",
    "one reason for automation stems from operations that arise in sequences that are known as blocks .",
    "suppose that such a sequence is formed of @xmath12 concrete operations @xmath13 , and each operation @xmath14 has its own abstract counterpart @xmath15 , henceforth referred to as its transfer function  @xcite .",
    "suppose too that the input to the sequence @xmath7 is described by an input abstraction @xmath6 , that is , @xmath8 .",
    "then the result of applying the @xmath12 concrete operations to the input ( one after another ) is described by applying the composition of the @xmath12 transfer functions to the abstract input , that is , @xmath16 . however , a more accurate result can be obtained by deriving a single transfer function @xmath4 for the block @xmath17 as a whole , designed so that @xmath18 .",
    "the value of this approach has been demonstrated for linear congruences @xcite in the context of verifying bit - twiddling code @xcite .    to illustrate this interplay between block - level abstraction and precision , consider a block consisting of three instructions that swaps the values of the variables @xmath19 and @xmath20 without using a third variable  ( * ? ? ? * chap .",
    "2.19 ) . to aid reasoning about the block as a whole ,",
    "fresh variables are introduced , static single assignment  @xcite style , so as to separate different assignments to the same variable .",
    "this gives where @xmath21 is an intermediate and @xmath19 and @xmath22 ( resp .",
    "@xmath20 and @xmath23 ) represent the values of the variable @xmath19 ( resp .",
    "@xmath20 ) on entry and exit from the block . since it follows that cumulatively the block can be described by a pair of two variable equalities @xmath24 which can be interpreted as transfer function for the block . from this transfer function",
    "it follows that if @xmath25 holds on entry to the block then @xmath26 holds on exit .",
    "note that equalities @xmath25 and @xmath26 are considered to be two - variable since they contain no more than two variables .",
    "now consider applying transfer functions for each of the three assignments in turn . again , suppose that @xmath25 holds prior to the assignment @xmath27 .",
    "since the ternary constraint @xmath28 can not be expressed within the two - variable equality domain then the best that can ever be inferred by any transfer function operating over this domain is @xmath25 for the post - state . likewise",
    "the best that can be inferred for a transfer function that simulates @xmath23 : = @xmath29 is @xmath25 for its post - state , and similarly for @xmath22 : = @xmath30 . thus by composing transfer functions over two - variable equalities one can not show that @xmath26 holds on exit from the block .",
    "therefore , the transfer function for a block can be strictly more precise than the composition of the transfer functions for the constituent instructions .",
    "since blocks are program - dependent , such an approach relies on automation rather than the manual provision of transfer functions for each instruction .",
    "another compelling reason for automation is the complexity of the concrete operations themselves ; a problem that is heightened by the finite nature of machine arithmetic .",
    "for instance , even a simple concrete operation , such as increment by one , is complicated by the finite nature of computer arithmetic : if increment is applied to the largest integer that can be stored in a word , then the result is the smallest integer that is representable .",
    "as the transfer function needs to faithfully simulate concrete increment , the corner case inevitably manifests itself ( if not in the transfer function itself then elsewhere @xcite ) .",
    "the problem of deriving transfer functions for machine instructions , such as those of the x86 , is particularly acute @xcite since these operations not only update registers and memory locations , but also side effect status flags  @xcite , of which there are many .",
    "when deriving a transfer functions for a sequence of machine instructions it is necessary to reason about how the status flags are used to pass state from one instruction to another . to illustrate the importance of status flags , consider double - length addition , where the operands are pairs of 32-bit words @xmath31 and @xmath32 , the result is denoted @xmath33 , and the @xmath34 subscript denotes the most significant half and @xmath35 the least significant .",
    "then the following block @xmath36 realises 64-bit addition , providing @xmath37 denotes an unsigned comparison  ( * ? ? ?",
    "* chap .  2.15 ) .",
    "without considering the carry flag @xmath9 , it is not clear how one can reconstruct that @xmath38 modulo @xmath39 which is the high - level abstraction of the semantics of the block without resorting to a reduced cardinal power construction ( * ? ? ?",
    "* theorem 10.2.0.1 ) .",
    "in such a construction , a domain that can express relations such as @xmath40 , henceforth called the base domain , is refined with respect to a domain which traces the value of @xmath9 , an adjunct that is sometimes called the exponent domain .",
    "this refinement enables @xmath9 to monitor whether @xmath40 holds or not .",
    "although a base domain can always been refined in this way , and the transfer functions enriched to support the extra expressiveness , an alternative approach is to derive a transfer function for a block of instructions which , in cases such as the above , better match against what can be expressed in the base domain .    as a final piece of motivation , it is worth noting that there are several ways of implementing double - length addition , and numerous ways of realising other commonly occurring operations @xcite , and therefore pattern matching can never yield a systematic nor a reliable way of computing transfer functions for basic blocks .",
    "monniaux @xcite recently addressed the vexing question of automatic abstraction by focussing on template domains @xcite which include , most notably , intervals @xcite and octagons @xcite .",
    "he showed that if the concrete operations are specified as piecewise linear functions , then it is possible to derive transfer functions for blocks using quantifier elimination . to illustrate the role of quantification ,",
    "suppose a piecewise linear function models a block that updates three registers whose values on entry and exit are represented by bit - vectors @xmath41 , @xmath42 and @xmath43 and @xmath44 , @xmath45 and @xmath46 respectively . to derive a transfer function for interval analysis ,",
    "it is necessary to ascertain how the maximal value of @xmath44 , denoted @xmath47 say , relates to the minimal and maximal values of @xmath41 , @xmath42 and @xmath43 , denoted @xmath48 and @xmath49 , @xmath50 and @xmath51 and @xmath52 and @xmath53 respectively .",
    "the value of @xmath47 can be specified in logic  @xcite by asserting that :    @xmath54    for all values of @xmath41 , @xmath42 and @xmath43 that fall within the intervals @xmath55 $ ] , @xmath56 $ ] and @xmath57 $ ] , the value of @xmath47 is greater or equal to @xmath44    for some combination of values of @xmath41 , @xmath42 and @xmath43 such that @xmath55 $ ] , @xmath56 $ ] and @xmath57 $ ] , the output @xmath44 takes the value of @xmath47 .    the `` for some '' can be expressed with existential quantification , and the `` for every '' with universal quantification . by applying quantifier elimination ,",
    "a direct relationship between @xmath48 , @xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath53 , and @xmath58 can be found , yielding a mechanism for computing @xmath58 in terms of @xmath48 , @xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath53 .",
    "this construction is ingenious but quantifier elimination is at least exponential for rational and real piecewise linear systems @xcite , and is doubly exponential when quantifiers alternate @xcite .",
    "hence , its application requires extreme care @xcite .    as an alternative to operating over piecewise linear systems  @xcite",
    ", one can instead express the semantics of a basic block with a boolean formula ; an idea that is familiar in model checking where it is colloquially referred to as bit - blasting  @xcite .",
    "first , bit - vector logic is used to represent the semantics of a block as a single cnf formula @xmath59 ( an excellent tutorial on flattening bit - vector logic into propositional logic is given in  ( * ? ? ?",
    "* chap . 6 ) ) .",
    "thus , each @xmath12-bit integer variable is represented as a separate vector of @xmath12 propositional variables .",
    "second , the above specification is applied to express the maximal value ( or conversely the minimal value ) of an output bit - vector in terms of the ranges on the input bit - vectors .",
    "this gives a propositional formula @xmath60 which is essentially @xmath59 augmented with universal quantifiers and existential quantifiers .",
    "third , the quantifiers are removed from @xmath60 to obtain @xmath61  a simplification of @xmath60 .",
    "of course , @xmath61 is just a boolean formula and does not prescribe how to compute a transfer function .",
    "however , a transfer function can be extracted from @xmath61 by abstracting @xmath61 with linear affine equations @xcite which directly relate the output ranges to the input ranges .",
    "this fourth step ( which is analogous to that proposed for abstracting formulae with congruences @xcite ) is the final step in the construction .",
    "this proposal for computing transfer functions @xcite may seem attractive since computing @xmath62 , where @xmath63 is a system of propositional constraints and @xmath42 is a vector of variables , is straightforward when the formula @xmath63 is in cnf .",
    "when @xmath63 is an arbitrary propositional system , a cnf formula @xmath64 that is equisatisfiable , denoted @xmath65 , to @xmath63 can be found  @xcite by introducing fresh variables @xmath43 to give @xmath66 . however",
    ", then the transfer function synthesis problem amounts to solving @xmath67 where @xmath64 is in cnf . to eliminate the existentially quantified variables @xmath43 , resolution  ( *",
    "9.2.3 ) can be applied , but the quadratic nature of each resolution step compromises tractability as the size of @xmath43 increases .",
    "the size of @xmath43 is proportional to the number of logical connectives in @xmath63 which , in turn , depends on the size of the bit - vectors and the complexity of the block under consideration .",
    "it is therefore no surprise that this approach has only been demonstrated for blocks of microcontroller code where the word - size is just 8 bits  @xcite .",
    "although no polynomial - time algorithms are known for existential quantifier elimination of cnf , new algorithms are emerging @xcite which will no doubt permit transfer functions to be derived for larger blocks .",
    "nevertheless , it would be preferable if quantifier elimination was avoided altogether .",
    "this paper develops the work reported in @xcite to contribute a method for deriving transfer functions which replaces quantifier elimination with successive calls to a sat solver , where the number of calls grows linearly with the word - size rather than the size of the formula that encodes the semantics of the block .    to illustrate , consider an octagon  @xcite which consists of a system of inequalities of the form @xmath68 .",
    "for each of these inequalities , our approach derives the least @xmath69 ( which is uniquely determined ) such that the inequality holds for all feasible values of @xmath19 and @xmath20 as defined by some propositional formula . as an example , consider the inequality @xmath70 .",
    "the constant @xmath10 is defined as @xmath71 where @xmath72 is a propositional formula constraining the bit - vectors @xmath41 and @xmath42 .",
    "furthermore , given a machine with word - length @xmath73 , the maximal value in an unsigned representation of @xmath19 and @xmath20 is @xmath74 , and thus we can derive an initial constraint @xmath75 for @xmath10 , which can be expressed disjunctively as @xmath76 where :    @xmath54    @xmath77    @xmath78    to determine which disjunct characterises @xmath10 , it is sufficient to test the propositional formula @xmath79 for _ satisfiability_. if satisfiable , then @xmath80 is entailed by the inequality @xmath70 , and @xmath81 otherwise .",
    "we proceed by decomposing the new characterisation into a disjunction  as in dichotomic or binary search  and repeating this step @xmath73 times to give @xmath10 exactly .",
    "likewise , constants @xmath10 can be found for all inequalities of the form @xmath68 , which provides a mechanism for computing an octagonal abstraction that describes a given propositional formula .",
    "the force of this abstraction technique is that it provides a way of deriving octagonal guards which must hold for a block to be executed in a particular mode .",
    "for example , a block might have three modes of operation , depending on whether an operation underflows , overflows , or does neither .",
    "which mode is applicable then depends on the values of variables on entry to the block , which motivates using guards to separate and describe the different modes of operation .",
    "knowing that a particular mode is applicable permits a specialised transfer function to be applied for inputs that conform to that mode .",
    "it is important to note that separating modes is a crucial step in the process of applying abstract domains that operate on unbounded integers , such as affine equalities , to describe finite bit - vector semantics . as an example , consider incrementing a variable @xmath19 by 1 .",
    "if @xmath19 and its representative @xmath22 on output are unbounded integers , the affine relation is merely @xmath82 .",
    "now suppose that @xmath19 and @xmath22 are 32-bit variables .",
    "then , if @xmath83 it follows @xmath82 , and @xmath84 otherwise . even though each of the two cases can be described in the affine domain , the join of these two affine relations conveys no useful information at all . separating modes",
    "ultimately leads to a transfer function being formulated as a system of guarded updates , where the updates stipulate how the entry values are mapped to exit updates , and the guards indicate which mode holds and therefore which type of update is applicable .",
    "this leaves the problem of how to compute the updates themselves ; the input - output transformers that constitute the heart of the transfer function .",
    "we show that updates can be also computed without resorting to quantifier elimination .",
    "we demonstrate this construction not only for intervals , but for transfer functions over octagons .",
    "the method is based on computing an affine abstraction of a boolean formula that is derived to describe the mode . for intervals , the update details how the bounds of an input interval are mapped to new bounds of an output interval .",
    "for octagons , the update maps the constants on the input octagonal inequalities to new constants on the output inequalities .",
    "overall , the approach to computing transfer functions that is presented in this paper confers the following advantages :    @xmath54    it is amenable to instructions whose semantics is presented as propositional formulae or satisfiability modulo theory ( smt ) @xcite formulae .",
    "the force of this is that such encodings are readily available for instructions , due to the rise in popularity of sat - based model checking ;    it avoids the computational problems associated with eliminating variables from piecewise linear systems and propositional formulae , particularly with regard to alternating quantifiers ;    it proposes the use of transfer functions that are action systems of guarded updates .",
    "these transfer functions are attractive both in terms of their expressiveness and the ease with which they can be evaluated ( only one expression need be evaluated for each inequality that describes the state on exit from the block ) ;    it shows how the modes of a block can be found and how , for a given mode , the guards can be computed using repeated sat solving .",
    "it is also shown how the updates for that mode can be deriving by interleaving sat solving with affine abstraction ;    it shows how update operations , which in the case of interval analysis , compute bounds on the output intervals from bounds on the input intervals , need not be linear functions .",
    "non - linear update operations can also be supported for transfer functions over octagons . in this context",
    ", the update operation computes the constants on the output octagonal inequalities from the constants on the input inequalities ( the coefficients are fixed in both the input and output octagons hence computing a transfer function amounts to adjusting constants ) ;    it explains how to handle operations that underflow , overflow , or do neither and even combinations of such behaviours , providing a way to seamlessly integrate template inequalities with finite precision arithmetic .",
    "overall the paper proposes a systematic technique for inferring transfer functions that are defined as systems of guarded updates .",
    "this section illustrates the syntactic form of transfer functions , so as to provide an outline of the approach and a roadmap for the whole paper .",
    "the roadmap explains which sections of the paper are concerned with deriving which components of the transfer function .",
    "transfer functions are inferred for blocks , such as the assembly code listing in fig .  [",
    "figure : example_program ] .",
    "( the approach is illustrated for blocks of 32-bit avr uc3 assembly code  @xcite , though the techniques are completely generic . )",
    "each instruction is modelled by at least one , and at most four , boolean functions according to whether it overflows or underflows , or is exact , that is , whether the instruction neither overflows nor underflows .",
    "this division into three cases reflects the ways the two s complement overflow ( v ) flag is set or clearer @xcite . in exceptional cases",
    "this flag is used in tandem with the negative ( n ) flag @xcite and thus it is natural to refine these three cases according to whether the negative flag is also set or clearer . however , if the instruction overflows then the result is necessarily negative whereas if it underflows then the result is non - negative , hence only the exact case needs to be further partitioned .",
    "this gives four cases in all , overflow , underflow , exact and negative , exact and non - negative , each of which can be precisely expressed with a boolean function that describes a so - called _",
    "mode_. the different instructions that make up the block may operate in different modes , though the mode of one instruction may preclude a mode of another being applicable .",
    "a mode combination is then chosen for each instruction , and a single boolean formula is constructed for the block by composing a formula for each instruction in the prescribed mode . if the composed formula is unsatisfiable , then the mode combination is inconsistent .",
    "otherwise , the mode combination is feasible and the formula describes one type of wrapping ( or non - wrapping ) behaviour that can be realised within the block .",
    "the composed formula is then used to distill a guard paired with an update ; one pair is computed for each feasible mode combination .",
    "for example , the block listed in fig .",
    "[ figure : example_program ] has nine feasible mode combinations in all , yielding nine guard and update pairs of the form : @xmath85 \\left . \\begin{array}{@{}rr } 2^{31 } + 1 \\leq { \\ensuremath{\\langle\\!\\langle \\vec{r0 } \\rangle\\!\\rangle } } + { \\ensuremath{\\langle\\!\\langle \\vec{r1 } \\rangle\\!\\rangle } } \\leq 2^{32 } - 2 & \\wedge \\\\ 0 \\leq { \\ensuremath{\\langle\\!\\langle \\vec{r0 } \\rangle\\!\\rangle } } \\leq 2^{31}-1 & \\wedge \\\\ 0 \\leq { \\ensuremath{\\langle\\!\\langle \\vec{r1 } \\rangle\\!\\rangle } } \\leq 2^{31}-1   \\end{array } \\right\\ } & \\rightarrow & \\left\\ { \\begin{array}{l@{\\;}l@{\\;}ll@ { } } ( { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymin } ' \\rangle\\!\\rangle } } & = & 2^{32 } - { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymax } \\rangle\\!\\rangle } } - { \\ensuremath{\\langle\\!\\langle \\vec{r1}_{\\mymax } \\rangle\\!\\rangle } } ) & \\wedge \\\\    ( { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymax } ' \\rangle\\!\\rangle } } & = & 2^{32 } - { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymin } \\rangle\\!\\rangle } } - { \\ensuremath{\\langle\\!\\langle \\vec{r1}_{\\mymin } \\rangle\\!\\rangle } } ) \\end{array}\\right . \\\\[3ex ] & \\vdots &   \\\\ \\left . \\begin{array}{@{}rr }   -2^{31 } + 1 \\leq { \\ensuremath{\\langle\\!\\langle \\vec{r0 } \\rangle\\!\\rangle } } + { \\ensuremath{\\langle\\!\\langle \\vec{r1 } \\rangle\\!\\rangle } } \\leq -1 & \\wedge \\\\ 0 \\leq { \\ensuremath{\\langle\\!\\langle \\vec{r1 } \\rangle\\!\\rangle } } \\leq 2^{31 } - 1 \\end{array } \\right\\ }   & \\rightarrow & \\left\\ { \\begin{array}{l@{\\;}l@{\\;}ll@ { } } ( { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymin } ' \\rangle\\!\\rangle } } & = & -{\\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymax } \\rangle\\!\\rangle } } - { \\ensuremath{\\langle\\!\\langle \\vec{r1}_{\\mymax } \\rangle\\!\\rangle } } ) & \\wedge \\\\    ( { \\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymax } ' \\rangle\\!\\rangle } } & = & -{\\ensuremath{\\langle\\!\\langle \\vec{r0}_{\\mymin } \\rangle\\!\\rangle } } - { \\ensuremath{\\langle\\!\\langle \\vec{r1}_{\\mymin } \\rangle\\!\\rangle } } ) \\end{array}\\right.\\\\[2ex ] \\end{array}\\ ] ]    each guard is a conjunction of linear template constraints over the inputs of the block , in this case @xmath86 and @xmath87 , which denote the ( signed ) values of the registers ` r0 ` and ` r1 ` on entry to the block .",
    "the guards express properties of ` r0 ` and ` r1 ` which must hold for the instructions to operate in the modes that make up the feasible mode combination .",
    "the update operations that augment the guards detail how the values of the registers are mutated for a given mode combination .",
    "for example , if the first guard is applicable , then the update asserts that the output value of ` r0 ` takes a value in the range @xmath88 $ ] ( which actually prescribes a single value ) ; the lower and upper bounds of ` r0 ` on exit are denoted @xmath89 and @xmath90 in the update .",
    "the second update illustrates how @xmath89 and @xmath90 can depend on the values of ` r0 ` and ` r1 ` on entry to the block , where the input lower and upper bounds for ` r0 ` are denoted @xmath91 and @xmath92 , and likewise for ` r1 ` .",
    "the guard is constructed one inequality at a time , by applying a form of dichotomic ( or binary ) search .",
    "this step amounts to a series of calls to a sat solver , as is explained in sect .",
    "[ section : guards ] .",
    "updates can be computed by inferring an affine relationship between the bound on an output symbolic constraint and the input symbolic bounds .",
    "such a relationship can again be derived by repeated sat solving , as detailed in sect .",
    "[ section : updates ] . replicating this construction for each of the symbolic output constants gives the update operation for a feasible mode combination .",
    "[ section : guards ] and sect .",
    "[ section : updates ] return to the example introduced given above , detailing the steps in the derivation of this transfer function . )",
    "yet , situations can arise for which the updates can not be expressed using affine relationships , motiving the study , in sect .",
    "[ section : template_octahedra ] , of complementary classes of update which can be formed from linear template inequality constraints  @xcite and non - linear template equality constraints  @xcite .",
    "updates that relate symbolic output constants to symbolic input constraints using equalities are complementary to those based on inequalities : both are useful when transfer functions are evaluated .",
    "[ section : evaluating ] focuses on this topic and explains how guards and updates are applied during fixed point computation .",
    "evidence is presented in sect .",
    "[ section : experiments ] which demonstrates that the techniques presented in the paper are capable of synthesising transfer functions for blocks , where previous approaches based on quantifier elimination were prohibitively expensive .",
    "finally , sect .",
    "[ section : related_work ] surveys the related work and sect .",
    "[ section : discussion ] concludes .",
    "we express the concrete semantics of a block with boolean formulae so as to ultimately infer a set of guards that distinguish that wrapping behaviour of a block .",
    "the construction given in  @xcite formulates this problem using quantification , so that quantifier elimination can be applied to solve it .",
    "however , whereas universal quantifier elimination is attractive computationally , this is not so for the elimination of existentially quantified variables .",
    "we overcome this problem by reformulating the construction given in  @xcite , and replace quantifier elimination by a series of calls to a sat solver .",
    "this section illustrates the power of this transposition by deriving guards for some illustrative blocks of microcontroller instructions .",
    "consider deriving a transfer function for the operation ` inc r0 ` , which increments the value of ` r0 ` by one and stores the result in ` r0 ` .",
    "for this example , we assume that the operands are unsigned .",
    "we represent the value of ` r0 ` by a bit - vector @xmath93 and let @xmath94 $ ] where @xmath95 $ ] denotes the @xmath96 element of @xmath93 .",
    "note that in the sequel the following notational distinction is maintained : ` r0 ` for a register , @xmath93 for a bit - vector representing ` r0 ` and @xmath97 and @xmath86 for , respectively , the unsigned and signed interpretation of the bit - vector @xmath93 .",
    "the instruction itself can operate in one of two modes : ( 1 ) it overflows ( iff @xmath98 ) or ( 2 ) it is exact ( otherwise ) . note that in the sequel the term exact is used to refer to a mode that is neither underflowing nor overflowing .",
    "the semantics of these two modes can be expressed as two formulae : @xmath99 ) \\\\ ( 2 ) & \\hspace{0.3em } & \\varphi_e(\\vec{x } ) & = & \\varphi(\\vec{x } ) \\wedge ( \\bigvee_{i=0}^{31 } \\neg \\vec{r0}[i ] ) \\end{array}\\ ] ] where @xmath100 encodes the increment over bit - vectors @xmath101 as follows : @xmath102 \\leftrightarrow \\vec{r0}[i ] \\oplus \\bigwedge_{j=0}^{i-1 } \\vec{r0}[j]\\right ) \\end{array}\\ ] ] both formulae can be converted into equisatisfiable formulae in cnf by introducing fresh variables @xmath43  @xcite .",
    "we therefore denote the resulting formulae by @xmath103 and @xmath104 .",
    "following our initial approach  @xcite , the transfer function for a multi - modal block ( where the internal instructions can wrap ) is described as a system of guarded updates . in the one - dimensional case ,",
    "octagonal guards coincide with intervals .",
    "each guard constitutes an upper - approximation of those inputs that are compatible with the specific mode . in case of the increment ,",
    "we derive guards @xmath105 and @xmath106 defined as : @xmath107 ( 2 ) & \\hspace{0.2em } & g_e & = & 0 & \\leq & { \\ensuremath{\\langle \\vec{r0 } \\rangle } } & \\leq & 2^{32}-2 \\end{array}\\ ] ] these guards partition the inputs into two disjoint spaces : ( 1 ) a single point for the overflow case and ( 2 ) exact operation . to obtain these guards",
    ", we provide an algorithm which solves a series of sat instances , rather than following a monolithic all - in - one approach based on quantifier elimination  @xcite . to illustrate our strategy , consider the computation of a least upper bound @xmath10 for @xmath97 for the formula @xmath103 . clearly , we have @xmath108 .",
    "we start by putting : @xmath109 recall that we use a binary encoding of integers in the boolean formulae .",
    "further , as @xmath110 is a power of two , we can finesse the need for a complicated boolean encoding of the predicate @xmath111 by using the equivalent formula : @xmath112 \\end{array}\\ ] ] which is simpler both to formulate and to solve .",
    "then , the satisfiability of @xmath113 shows that @xmath93 takes a value in the range @xmath114 .",
    "consequently , @xmath10 occurs in the same range .",
    "we can thus further refine this range by testing : @xmath115 for satisfiability , or equivalently : @xmath116 \\wedge \\vec{r0}[30 ] \\end{array}\\ ] ] as @xmath117 is satisfiable , we infer that @xmath10 satisfies @xmath118 .",
    "the method continues to refine the constraint on @xmath10 into two equally sized halves . only in the last iteration",
    "is the satisfiability check found to fail , from which we conclude that @xmath119 .",
    "overall , this deduction requires 32 sat instances , but the similarity of the instances suggests that the overhead can be mitigated somewhat by incremental sat .",
    "[ figure : example_program ] @xmath120    in a second example , we show how to extend the refinement technique from intervals to octagons . to illustrate the method , consider the program fragment in fig .",
    "[ figure : example_program ] .",
    "this program corresponds to an assignment for signed values .",
    "the function ` isign ` assigns ` abs(r0+r1 ) ` to ` r0 ` if ` r1 ` is positive , and ` -abs(r0+r1 ) ` otherwise . `",
    "r2 ` is used as a temporary register .",
    "the sum of ` r0 ` and ` r1 ` is computed by instruction @xmath121 , and instructions @xmath122 ",
    "@xmath123 implement ` isign ` .",
    "the semantics of even this simple block is not obvious due to the bounded nature of machine arithmetic .",
    "for instance , if ` abs ` is applied to the smallest representable integer @xmath124 then the result is @xmath110 subject to overflow , which gives @xmath124 . to derive octagons that describe such corner cases",
    ", we have to consider all combinations of over- and underflow modes of the instructions . in the above program , the instructions `",
    "add ` ( sum ) and ` lsl ` ( left - shift ) can wrap in different ways , and thus are multi - modal .",
    "neither ` eor ` nor ` mov ` can wrap ; they are both uni - modal .",
    "note that in general , the instruction ` sbc ` ( subtract - with - carry ) is multi - modal .",
    "however , in the case of two equal operands , the instruction can only result in @xmath35 or @xmath125 , depending on the carry - flag .",
    "we thus ignore the wrapping of ` sbc r2 r2 ` and consider it to be uni - modal for simplicity of presentation .",
    "note that only overflows occurred in the previous example since the single operand was unsigned .      in what follows ,",
    "let @xmath126 defined as @xmath127 \\leftrightarrow \\vec{r0}[i ] \\oplus    \\vec{r1}[i ] \\oplus \\vec{c}[i ] \\right ) \\wedge \\\\ & \\neg \\vec{c}[0 ] \\wedge \\left ( \\bigwedge_{i=0}^{30 } \\vec{c}[i+1 ] \\leftrightarrow ( \\vec{r0}[i ] \\wedge \\vec{r1}[i ] ) \\vee ( \\vec{r0}[i ] \\wedge \\vec{c}[i ] ) \\vee ( \\vec{r1}[i ] \\wedge \\vec{c}[i ] ) \\right ) \\end{array}\\ ] ] denote the boolean encoding of the instruction over bit - vectors @xmath128 obtained through static single assignment conversion .",
    "here , @xmath129 is a bit - vector of intermediate carry bits .",
    "the semantics of ` add r0 r1 ` is to compute the sum of ` r0 ` and ` r1 ` and store the result in ` r0 ` .",
    "since we are now working with signed objects , let @xmath130 ) - 2^{w-1 } \\cdot \\vec{x}[w-1 ] \\end{array}\\ ] ] denote the value of a bit - vector @xmath41 of length @xmath73 , where @xmath131 $ ] is interpreted as the sign - bit .",
    "then , ` add r0 r1 ` has four modes of operation : overflow , underflow , exact and non - negative , exact and negative .",
    "underflow occurs , for example , if the arithmetic sum of @xmath86 and @xmath87 is less than @xmath124 .",
    "the constraints for these modes , which are obtained directly from the instruction set specification  @xcite , can be expressed as four boolean formulae : @xmath132 \\wedge \\neg \\vec{r1}[31 ] \\wedge \\vec{r0}'[31 ] \\\\ \\mu_{u}(\\vec{x } ) & = & \\vec{r0}[31 ] \\wedge \\vec{r1}[31 ]",
    "\\wedge \\neg \\vec{r0}'[31 ] \\\\",
    "\\mu_{p}(\\vec{x } ) & = & ( \\vec{r0}[31 ] \\vee \\vec{r1}[31 ] \\vee \\neg \\vec{r0}'[31 ] ) \\wedge ( \\neg \\vec{r0}[31 ] \\vee \\neg \\vec{r1}[31 ] \\vee \\vec{r0}'[31 ] ) \\wedge \\neg \\vec{r0'}[31 ] \\\\ & = & ( \\neg \\vec{r0}[31 ] \\vee \\neg \\vec{r1}[31 ] \\vee \\vec{r0}'[31 ] ) \\wedge \\neg \\vec{r0'}[31 ] \\\\ & = & ( \\neg \\vec{r0}[31 ] \\vee \\neg \\vec{r1}[31 ] ) \\wedge \\neg \\vec{r0'}[31 ] \\\\ \\mu_{n}(\\vec{x } ) & = & ( \\vec{r0}[31 ] \\vee \\vec{r1}[31 ] \\vee \\neg \\vec{r0}'[31 ] ) \\wedge ( \\neg \\vec{r0}[31 ] \\vee \\neg \\vec{r1}[31 ] \\vee \\vec{r0}'[31 ] ) \\wedge \\vec{r0'}[31 ] \\\\ & = & ( \\vec{r0}[31 ] \\vee \\vec{r1}[31 ] \\vee \\neg \\vec{r0}'[31 ] ) \\wedge \\vec{r0'}[31 ] \\\\ & = & ( \\vec{r0}[31 ] \\vee \\vec{r1}[31 ] ) \\wedge \\vec{r0'}[31 ]",
    "\\\\ \\end{array}\\ ] ] for example , the formula @xmath133 describes the input - output relationships for in overflow mode .",
    "the instruction ` lsl r2 ` shifts register ` r2 ` to the left by one bit - position ; the most - significant bit of ` r2 ` is moved into the carry - flag .",
    "if the carry - flag is set , an overflow occurs ; there is no underflow for ` lsl ` .",
    "let @xmath134 and @xmath135 thus express the overflow and exact modes of ` lsl r2 ` . in an analogous way to the first `",
    "add ` instruction , let @xmath136 , @xmath137 , @xmath138 and @xmath139 express the semantics of the instruction . using these encodings that satisfy a single mode , we can compose a boolean formula for a fixed mode combination that expresses the possibility of one mode of one operation being consistent with another mode of another operation ; the unsatisfiability of this formula indicates that the chosen modes are inconsistent .",
    "for example , the combination of @xmath140 , @xmath141 and @xmath142 is infeasible .",
    "the above block thus constitutes @xmath143 combinations of modes , but only @xmath144 of which are satisfiable , which is depicted in tab .",
    "[ table : feasible_modes ] .",
    "it is thus necessary to derive guards only for the feasible combinations .",
    "@c@||@c@    .feasible and infeasible modes for the program in fig .",
    "[ figure : example_program ] [ cols=\"^,^,^,^\",options=\"header \" , ]      using quantifier elimination , all instances could be solved in a reasonable amount of time for 8-bit instructions .",
    "however , only the small instances could be solved for 32 bits ( and only then because the boolean encodings for the instructions were minimised prior to the synthesis of the transfer functions ) .",
    "it is also important to appreciate that none of the timeouts was caused by the sat solver ; it was resolution that failed to produce results in reasonable time . by way of comparison ,",
    "synthesising guards for different overflow modes requires most runtime in our new approach , caused by the fact that the number of sat instances to be solved grows linearly with the number of bits and quadratically with the number of variables ( the number of octagonal inequalities is quadratic in the number of variables ) .",
    "computing the affine updates consumes only a fraction of the overall time . in terms of precision ,",
    "the results coincide with those previously generated @xcite .",
    "the block for ` swap ` is interesting since it consists of three consecutive exclusive - or instructions , for which there is no coupling between different bits of the same register .",
    "the block is also unusual in that it is uni - modal with vacuous guards .",
    "these properties make it ideal for resolution . even in this situation ,",
    "the new technique scales better .",
    "in fact , the boolean formulae that we present to the solver are almost trivial by modern standards , the main overhead coming from repeated sat solving rather than solving a single large instance .",
    "sat4j does reuse clauses learnt in an earlier sat instances , though it does not permit clauses to be incrementally added and rescinded which is useful when solving maximisation problems  @xcite .",
    "thus the timings given above are very conservative ; indeed sat4j was chosen to maintain the portability of square rather than for raw performance .",
    "nevertheless , these timings very favourably compare with those required to compute transfer functions for intervals using bdds  @xcite , where in excess of 24 hours is required for single 8-bit instructions .",
    "our experiences  @xcite with native solvers such as minisat , however , indicate that a tenfold speed - up can be achieved by replacing sat4j .",
    "the process of deriving octagonal transfer functions by lifting ( sect .  [ section - medium ] ) requires an imperceivable overhead compared to computing affine relations themselves , indeed it is merely syntactic rewriting .",
    "the runtimes required for inferring affine updates by alternating range refinement and affine join ( sect .",
    "[ section - exact ] ) , however , is typically 3 or 4 times slower than those of computing the guards ; the number of symbolic constants on the output inequalities corresponds exactly to the number of input guards .",
    "since the octagon on input consists of 8 guards , and so does the octagon on output , the worst case requires @xmath145 iterations of affine abstraction and refinement ; a single iteration of refinement is no more expensive as in the cases given in tab .",
    "[ table : experimental_results ] , and the affine join has imperceivable impact . we have observed the full number of iterations is only needed for programs for which there is no affine relation between octagons on input and output .",
    "we refrain from giving exact times for the affine updates since they were computed with z3 @xcite rather than sat4j and thus are not directly comparable .      since transfer functions are program dependent , one could first use a simple form of range analysis  @xcite to over - approximate the ranges a register can assume .",
    "these ranges can be encoded in the formulae , thereby pruning out some mode - combinations .",
    "for example , it is rarely the case that the absolute value function is actually applied to the smallest representable integer .",
    "the problem of designing transfer functions for numeric domains is as old as the field of abstract interpretation itself  @xcite , and even the technique of using primed and unprimed variables to capture and abstract the semantics of instructions and functions dates back to the thesis work of halbwachs @xcite .",
    "however , even for a fixed abstract domain , there are typically many ways of designing and implementing transfer functions .",
    "cousot and halbwachs  ( * ? ? ?",
    "4.2.1 ) , for example , discussed several ways to realise a transfer function for assignments such as @xmath146 in the polyhedral domain while abstracting integer division @xmath147 is an interesting study within itself @xcite .",
    "the problem of handcrafting best transformers is particularly challenging and granger  @xcite lamented the difficulty of devising precise transfer functions for linear congruences .",
    "however , it took more than a decade after granger s work before it was observed that best transformers could automatically be constructed for domains of finite height  @xcite",
    ". nevertheless , automatic abstraction ( or the automatic synthesis of abstractions ) has only recently become a practical proposition , due to emergence of robust decision procedures  @xcite and efficient quantifier elimination techniques  @xcite .",
    "transfer functions can always be found for domains of finite height using the method of reps et al .",
    "@xcite , provided one is prepared to pay the cost of repeatedly calling a decision procedure or a theorem prover , possibly many times on each application of a transformer .",
    "this motivates applying a decision procedure in order to compute a best transformer offline , prior to the actual analysis  @xcite , so as to both simplify and speedup their application .",
    "our previous work  @xcite shows how bit - blasting and quantifier elimination can be applied to synthesise transformers for bit - vector programs .",
    "this work was inspired by that of monniaux  @xcite on synthesising transfer functions for piecewise linear programs .",
    "although his approach extends beyond octagons @xcite , it is unclear how to express some instructions ( such as bit - wise exclusive - or ) in terms of linear constraints .",
    "universal quantification , as used in both approaches , also appears in work on inferring linear template constraints  @xcite .",
    "there , gulwani and his co - authors apply farkas lemma in order to transform universal quantification into existential quantification , albeit at the cost of completeness since farkas lemma prevents integral reasoning .",
    "however , crucially , neither monniaux nor gulwani et al .  provide a way to model integer overflow and underflow .",
    "our work explains how to systematically handle wrap - around arithmetic in the transfer function itself ( without having to the revise the notion of abstraction @xcite ) whilst sidestepping quantifier elimination too .",
    "transfer functions for low - level code have been synthesised for intervals using bdds @xcite by applying interval subdivision where the extrema representing the interval are themselves represented as bit - vectors @xcite .",
    "if @xmath148 \\to [ 0 , 2 ^ 8 - 1]$ ] is a unary operation on an unsigned byte , then its abstract transformer @xmath1 on @xmath149 \\mid 0 \\leq \\ell \\leq u < 2 ^ 8 \\}$ ] can be defined recursively . if @xmath150 then @xmath151 ) = g(\\ell)$ ] whereas if @xmath152 then @xmath151 ) = f([\\ell , m - 1 ] ) \\sqcup f([m , u])$ ] where @xmath153 and @xmath154 .",
    "binary operations can likewise be decomposed by repeatedly dividing squares into their quadrants .",
    "the 8-bit inputs , @xmath155 and @xmath156 , can be represented as 8-bit vectors , as can the 8-bit outputs , so as to represent @xmath4 with a bdd .",
    "this permits caching to be applied when @xmath4 is computed , which reduces the time needed to compute a best transformer to approximately 24 hours for each 8-bit operation .",
    "it is difficult to see how this approach can be extended to blocks that involve many variables without a step - change in bdd performance .",
    "the question of how to construct a best abstract transformer has also been considered in the context of markov decision processes ( mdps ) for which the first abstract interpretation framework has recently been developed @xcite . the framework affords the calculation of both lower and upper bounds on reachability probabilities , which is novel .",
    "the work focuses on predicate abstraction  @xcite , that have had some success with large mdps , and seeks to answer the question of , for given set of predicates , what is the most precise abstract program that still is a correct abstraction .",
    "more generally , the work illustrates that the question of how to compute the best abstract transformer is pertinent even in a probabilistic setting .",
    "the classical approach to handling overflows is to follow the application of a transfer function with overflow and underflow checks ; program variables are considered to be unbounded for the purposes of applying the transfer function but then their sizes are considered and range tests and , if necessary , range adjustments are applied to model any wrapping .",
    "this approach has been implemented in the astree analyzer  @xcite . however , for convex polyhedra , it is also possible to revise the concretisation map to reflect truncation so as to remove the range tests from most abstract operations  @xcite .",
    "another choice is to deploy congruence relations  @xcite where the modulus is a power of two so as to reflect the wrapping in the abstract domain itself @xcite .",
    "this approach can be applied to find both relationships between different words @xcite and the bits that constitute words @xcite ( the relative precision of these two approaches has recently been compared @xcite ) .",
    "bit - level models have been combined with range inference @xcite , though neither of these works address relational abstraction nor transfer function synthesis .",
    "modular arithmetic can be modelled with case splitting by introducing a propositional variable that acts as a witness to an overflow . to illustrate , consider the 8-bit comparison @xmath157 ( * ?",
    "6.4 ) . to model overflow",
    "a witness @xmath158 is defined , which is used to control case selection .",
    "case selection is realised through two constraints defined by @xmath159 and @xmath160 .",
    "case - based axiomisations can even be used to model underflows and rounding - to - zero in ieee-745 floating - point arithmetic as shown in  ( * ? ? ?",
    "these ideas are similar in spirit to those given in this paper for decomposing a block into its modes which are selected by guards .",
    "the last decade has seen increasing interest in the derivation of polynomial invariants , with techniques broadly falling into two classes : methods that use algebraic techniques to operate directly over polynomials and methods that model polynomial invariants in a linear setting .",
    "the work of coln  @xcite is representative of the latter , for he shows how polynomial relations of bounded degree can be derived using program transformation . to illustrate , suppose a variable @xmath161 is updated using the assignment @xmath162 . a variable @xmath163 is introduced to represent the non - linear term @xmath164 and the program",
    "is extended by replacing the assignment @xmath165 with the parallel assignment @xmath166 so as to reflect the update on @xmath161 to @xmath163 .",
    "linear invariants between @xmath167 and the other variables in the transformed program then are reinterpreted as polynomial invariants .",
    "the idea of using nonlinear terms as additional independent variables also arises in the work of bagnara et al .",
    "@xcite who use convex polyhedra to represent polynomial cones of bounded degree and thereby derive polynomial inequalities .",
    "they reduce the loss of precision induced through linearisation by additional linear inequalities , which are included in the polyhedra to express redundant non - linear constraints .",
    "the idea of extending a vector of variables with non - linear terms also arises in the work of mller - olm and seidl  @xcite who consider the complexity of inferring polynomial equalities up to a fixed degree .",
    "they represent an affine relation with a set of vectors that generate the space through linear combination .",
    "extending this idea to variables that represent non - linear terms naturally leads to the notion of polynomial hull which is not dissimilar to the closure algorithm that is used in this paper for computing non - linear update functions .",
    "quantifier elimination has been proposed as a technique for inferring polynomial inequalities directly @xcite in which the invariants are templates of polynomial inequalities with undetermined coefficients .",
    "deriving coefficients for the templates amounts to applying quantifier elimination which can be computed using a parametric ( or comprehensive ) grbner basis construction  @xcite .",
    "this approach resonates with the technique proposed by monniaux for inferring loop invariants  @xcite .",
    "grbner bases also arise in techniques for calculating invariants that are based on fixed point calculation @xcite , the main advantage of this approach being that it does not assume any a priori bound on the degree of a polynomial as an invariant .",
    "polynomial analysis has also been applied in the field of sat - based termination analysis  @xcite using term rewriting  @xcite .",
    "their work provides techniques for encoding polynomial equality and inequality constraints in propositional boolean logic .      abstracting the effect of a procedure in a summary is a key problem in inter - procedural analysis @xcite since it enables the effect of a call on abstract state to be determined without repeatedly tracing the call .",
    "the challenge posed by summaries is how they can be densely represented whilst supporting the function composition and function application .",
    "gen / kill bit - vector problems @xcite are amenable to efficient representation , though for other problems , such as that of tracking two variable equalities @xcite , it is better not to tabular the effect of a call directly .",
    "this is because if a transformer is distributive , then the lower adjoint of a transformer uniquely determines the transformer and , perhaps surprisingly , the lower adjoint can sometimes be represented more succinctly than the transformer itself .",
    "acceleration @xcite is attracting increasing interest as an alternative way of computing a summary of a procedure , or more exactly the loops that it contains .",
    "the idea is to track how program state changes on each loop iteration",
    "so as to compute the trajectory of these changes ( in a computation is that akin to transitive closure ) and hence derive , in a single step , a loop invariant that holds on all iterations of the loop .",
    "symbolic bounds , which are key to our transfer functions , also arise in a form of symbolic bounds analysis @xcite that aspires to infer ranges on pointer and array index variables in terms of the parameters of a procedure .",
    "lower and upper bounds on each program variable at each program point are formulated as linear functions of the parameters of the function where the coefficients are themselves parametric .",
    "the problem then amounts to inferring values for these parametric coefficients . by assuming variables to be non - negative",
    ", inequalities between the symbolic bounds can be reduced to inequalities between the parametric coefficients , thereby reducing the problem to linear programming .",
    "this article discusses the problem of automatically computing transfer functions for programs whose semantics is defined over finite bit - vectors .",
    "the key aspect that distinguishes our work from existing techniques  @xcite is that it does not depend on quantifier elimination techniques at all .",
    "although boolean formulae presented in cnf initially appear attractive for this task because of the simplicity of universal quantifier elimination  ( * ? ?",
    "1.3 ) , their real strength is the fact that they are discrete .",
    "this permits linear equalities and inequalities to be inferred by repeated ( incremental ) satisfiability testing , avoiding the need for quantifier elimination in the abstraction process entirely .",
    "most notably , this technique sidesteps the complexity of binary resolution .",
    "the force of this observation is that it extends transfer function synthesis to architectures whose word size exceeds @xmath168 bits , thereby strengthening the case for low - level code verification  @xcite .",
    "the problem of synthesising transfer functions is not dissimilar to that of inferring ranking functions for bit - vector relations  @xcite . given a path @xmath169 with a transition relation @xmath170 , proving the existence of a ranking function amounts to solving the formula @xmath171 where @xmath172 is a polynomial over the bit - vector @xmath41 and @xmath129 is a bit - vector of coefficients  ( * ? ? ?",
    "* thm .  2 ) .",
    "however , if intermediate variables @xmath42 are needed to express @xmath170 , @xmath172 , @xmath173 or @xmath37 , then the formula actually takes the form @xmath174 where @xmath175 is equisatisfiable to @xmath176 .",
    "this formula is structurally similar to those solved in  @xcite by quantifier elimination , which begs the question of whether this problem  like that of transfer function synthesis  can be recast to avoid elimination altogether .",
    "we will also investigate whether transfer functions can be found , not only for sequences of instructions , but also for entire loops  @xcite .",
    "existing approaches for the specification of ( least inductive ) loop invariants rely on existential quantification  ( * ? ? ?",
    "3.4 ) , and the natural question is thus whether a variation of the techniques proposed in this paper can annul this complexity .    an interesting open question is whether the techniques discussed in this paper can be further generalised to linear template constraints with variable coefficients . as discussed in sect .",
    "[ section : guards - generalisation ] , the dichotomic search can be applied to any template constraint of the form @xmath177 , where @xmath178 are constants and @xmath179 are variables .",
    "however , some interesting abstract domains used in program analysis  such as two variables per inequality  @xcite  do not fall into this class . it is still unclear if and how such relations can be derived using binary search .",
    "it is also interesting to note that octagons derived using our approach are tightly closed  ( * ? ? ?",
    "intuitively , this means that all hyperplanes defined through inequalities actually touch the enclosed volume .",
    "however , the octagons may contain redundant inequalities , which may negatively affect performance  ( * ? ? ?",
    "it will therefore be interesting to evaluate if simplification is worthwhile  ( * ? ? ? * sect .",
    "6.1 ) and , if so , whether non - redundant octagons can be directly derived using sat .      this collaboration was supported by a royal society international joint project grant , reference gp101405 , and by a royal society travel grant , reference tg092357 .",
    "the first author was supported , in part , by the dfg research training group 1298 algorithmic synthesis of reactive and discrete - continuous systems and the by the dfg cluster of excellence on ultra - high speed information and communication , german research foundation grant dfg exc 89 .",
    "the second author was funded , in part , by a royal society industrial fellowship , reference if081178 .",
    "we gratefully acknowledge the comments provided by the reviewers of the esop paper  @xcite on which this work is largely based , as well as the feedback provided by the reviewers of the sas paper  @xcite , and its predecessor the vmcai paper  @xcite , since it was the reviewers critique that inspired this work .",
    "finally , we thank sebastian biallas , stefan kowalewski , david monniaux , axel simon and harald sndergaard for stimulating discussions .",
    "s.  bygde , b.  lisper , and n.  holsti .",
    "fully bounded polyhedral analysis of integers with wrapping . in _ third international workshop on numerical and symbolic abstract domains _ , 2011 . to appear in electronic notes in theoretical computer science .",
    "c.  fuhs , j.  giesl , a.  middeldorp , p.  schneider - kamp , r.  thiemann , and h.  zankl",
    ". olving for termination analysis with polynomial interpretations . in",
    "volume 4501 of _ lncs _ , pages 340354 .",
    "springer , 2007 .                                                                                                    g.  s. tseitin . on the complexity of derivation in the propositional calculus . in a.",
    "o. slisenko , editor , _ studies in constructive mathematics and mathematical logic _ , volume part ii , pages 115125 , 1968 ."
  ],
  "abstract_text": [
    "<S> traditionally , transfer functions have been designed manually for each operation in a program , instruction by instruction . in such a setting </S>",
    "<S> , a transfer function describes the semantics of a single instruction , detailing how a given abstract input state is mapped to an abstract output state . </S>",
    "<S> the net effect of a sequence of instructions , a basic block , can then be calculated by composing the transfer functions of the constituent instructions . </S>",
    "<S> however , precision can be improved by applying a single transfer function that captures the semantics of the block as a whole . </S>",
    "<S> since blocks are program - dependent , this approach necessitates automation . </S>",
    "<S> there has thus been growing interest in computing transfer functions automatically , most notably using techniques based on quantifier elimination . </S>",
    "<S> although conceptually elegant , quantifier elimination inevitably induces a computational bottleneck , which limits the applicability of these methods to small blocks . </S>",
    "<S> this paper contributes a method for calculating transfer functions that finesses quantifier elimination altogether , and can thus be seen as a response to this problem . </S>",
    "<S> the practicality of the method is demonstrated by generating transfer functions for input and output states that are described by linear template constraints , which include intervals and octagons . </S>"
  ]
}