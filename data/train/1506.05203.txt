{
  "article_text": [
    "given a text @xmath0 and a pattern @xmath1 , the order - preserving matching problem is to find all substrings in @xmath0 which have the same relative orders as @xmath1 .",
    "for example , given @xmath2 and @xmath3 , @xmath1 has the same relative orders as the substring @xmath4 of @xmath0 . in @xmath5 ( resp .",
    "@xmath1 ) , the first character @xmath6 ( resp .",
    "@xmath7 ) is the second smallest number , the second character @xmath8 ( resp .",
    "@xmath9 ) is the third smallest number , the third character @xmath10 ( resp .",
    "@xmath11 ) is the smallest number , and so on .",
    "see fig .",
    "[ fig : opmex ] .",
    "this problem is naturally generalized to the problem of finding multiple patterns .",
    "the order - preserving matching for a single pattern will be called the _ single order - preserving matching _ , and one for multiple patterns the _ multiple order - preserving matching_. in this paper we are concerned with the multiple order - preserving matching problem .",
    "order - preserving matching was introduced by kubica et al .",
    "@xcite and kim et al .",
    "@xcite , where kubica et al .",
    "@xcite defined order relations by order isomorphism of two strings , while kim et al .",
    "@xcite defined them explicitly by the sequence of rank values , which they called the _",
    "natural representation_. they both proposed @xmath12 time solutions for the single order - preserving matching based on the knuth - morris - pratt algorithm , where @xmath13 is the length of the text and @xmath14 is the length of the pattern .",
    "kim et al .",
    "@xcite also proposed an @xmath15 time algorithm for the multiple order - preserving matching based on the aho - corasick algorithm , where @xmath16 is the sum of lengths of all the patterns .",
    "henceforth , there has been considerable research on the single and multiple order - preserving matching problems . for the single order - preserving matching , cho et al .",
    "@xcite proposed a method to apply the boyer - moore bad character rule to order - preserving matching by using the notion of @xmath17-grams .",
    "chhabra and tarhio @xcite presented a more practical solution based on filtering .",
    "they first encoded input sequences into binary sequences and then applied standard string matching algorithms as a filtering method .",
    "faro and klekci  @xcite improved chhabra and tarhio s solution by using new encoding techniques which reduced the false positive rate of the filtering step . for the multiple order - preserving matching , belazzougui et al .",
    "@xcite theoretically improved the solution of kim et al .",
    "@xcite by replacing the underlying data structure by the van - emde - boas tree .",
    "they achieved randomized @xmath18 time for the search , where @xmath19 is the length of the longest pattern and @xmath20 is the number of patterns .",
    "order - preserving matching has been an active research area and many related problems have been studied such as order - preserving suffix trees @xcite and order - preserving matching with @xmath20 mismatches @xcite .",
    "kim et al .",
    "@xcite extended the representations of order relations from binary relations to ternary relations . with their representations",
    ", one can modify earlier order - preserving matching algorithms to accommodate strings with duplicate characters , i.e. , a number can appear more than once in a string .",
    "has the same relative orders as the substring @xmath4 of @xmath0 . ]    in this paper , we present two new algorithms for the multiple order - preserving matching problem which are more efficient on average than the previously proposed algorithms .",
    "the algorithms are based on modifications of some conventional pattern matching algorithms such as wu - manber @xcite and karp - rabin @xcite .",
    "the first algorithm , called algorithm slowromancap1@ , uses the ideas of the wu - manber algorithm , and the second algorithm , called algorithm slowromancap2@ , uses the ideas of the karp - rabin algorithm and the encoding techniques of chhabra and tarhio @xcite and faro and klekci @xcite for fingerprinting .",
    "algorithm slowromancap1@ runs in @xmath21 time on average , where @xmath13 is the length of the text , @xmath14 is the length of the shortest pattern , and @xmath16 is the sum of lengths of all the patterns .",
    "algorithm slowromancap2@ runs in @xmath22 time on average , assuming that @xmath16 is polynomial with respect to @xmath14 . in order to verify practical behaviors of our algorithms , we conducted experiments where the two algorithms were compared with the algorithms of kim et al .",
    "@xcite and belazzougui et al .",
    "experiments show that our algorithms run much faster in practice .",
    "let @xmath23 denote a set of numbers such that a comparison of two numbers can be done in constant time , and let @xmath24 denote the set of strings over the alphabet @xmath23 .",
    "for a string @xmath25 , let @xmath26 denote the length of @xmath27 .",
    "a string @xmath27 is described by a sequence of characters @xmath28 , x[2 ] , ... , x[|x|])$ ] .",
    "let a substring @xmath29 $ ] be @xmath30 , x[i+1 ] , ... , x[j])$ ] and a prefix @xmath31 be @xmath32 $ ] .",
    "for a character @xmath33 , let @xmath34 < c \\ ; \\text{for } \\ ; 1 \\leq i \\leq |x| \\}|$ ] .",
    "we use the _ natural representation _ defined by kim et al .",
    "@xcite to compare order relations of two strings .",
    "the natural representation is equivalent to _ order - isomorphism _ defined by kubica et al .",
    "@xcite , because the natural representation of two strings are identical if and only if they are order - isomorphic .    for a string @xmath27 of length @xmath13",
    ", the natural representation is defined as @xmath35 ) , rank_x(x[2 ] ) , ... , rank_x(x[n ] ) ) $ ] .",
    "for example , for @xmath36 , the natural representation is @xmath37 .",
    "we will simply say that @xmath27 matches @xmath38 if @xmath39 and @xmath40 .",
    "order - preserving matching can be defined in terms of the natural representation .",
    "[ def : sopm ] given a text @xmath41 \\in \\sigma^*$ ] and a pattern @xmath42 \\in \\sigma^*$ ] , @xmath1 matches @xmath0 at position @xmath43 if @xmath44)$ ] .",
    "the order - preserving matching is the problem of finding all the positions of @xmath0 matched with @xmath1 .",
    "definition  [ def : sopm ] is naturally generalized to the multiple order - preserving matching , formally defined in definition  [ def : mopm ] .",
    "[ def : mopm ] given a text @xmath41 \\in \\sigma^*$ ] and a set of patterns @xmath45 where @xmath46 for @xmath47 , the multiple order - preserving matching is the problem of finding all the positions of @xmath0 matched with any pattern in @xmath48 .",
    "there are two other representations in addition to the natural representation for comparing order relations of two strings : _ prefix representation _ and _ nearest neighbor representation_. the _ prefix representation _ can be defined as a sequence of rank values of characters in prefixes .    for a string @xmath27",
    ", the prefix representation is defined as @xmath49 ) , rank_{x_2}(x[2 ] ) , ... , rank_{x_{|x|}}(x[|x| ] ) ) $ ] . [",
    "appendix : definition : prefix_rep ]    for example , for @xmath36 , the prefix representation is @xmath50 .",
    "we can compute @xmath51 in time @xmath52 for general alphabet using the order - statistic tree  @xcite .",
    "the time complexity can be reduced to @xmath53 if the characters can be sorted in @xmath53 time .",
    "@xcite for two strings @xmath27 and @xmath38 where @xmath39 , if @xmath27 matches @xmath38 , then @xmath54 .",
    "[ lemma : if ]    the prefix representation has an ambiguity between different strings if they include duplicate characters .",
    "for example , when @xmath55 , and @xmath56 , the prefix representations of both @xmath27 and @xmath38 are @xmath57 , whereas their natural representations are different .",
    "kim et al . defined a new representation called the _ extended prefix representation _",
    "@xcite for strings with duplicate characters .",
    "we omit the details here .    for the _ nearest neighbor representation _",
    ", we define @xmath58 $ ] and @xmath59 $ ] as follows . @xmath60 = \\left\\ {    \\begin{array}{l l }      j & \\quad \\text{if $ x[j ] = \\max \\ { x[k ] : x[k ] \\leq x[i ] \\text { for } 1 \\leq k \\leq i-1 \\}$ } \\\\",
    "-\\infty & \\quad \\text{if no such $ j$ , }    \\end{array } \\right.\\ ] ] @xmath61 = \\left\\ {    \\begin{array}{l l }      j & \\quad \\text{if $ x[j ] = \\min \\ { x[k ] : x[k ] \\geq x[i ] \\text { for } 1 \\leq k \\leq i-1 \\}$ } \\\\",
    "\\infty & \\quad \\text{if no such $ j$ . }",
    "\\end{array } \\right.\\ ] ] if there are multiple @xmath62 s for @xmath58 $ ] or @xmath59 $ ] , we choose the rightmost one .    for a string @xmath27 , the nearest neighbor representation is defined as @xmath63 @xmath64 \\\\ lmin_{x}[1 ] \\end{pmatrix}$}}}$ ] @xmath65 \\\\ lmin_{x}[2 ] \\end{pmatrix}$}}}$ ] @xmath66 @xmath67 \\\\ lmin_{x}[|x| ] \\end{pmatrix}$}}}$ ] .",
    "for example , for @xmath68 , the nearest neighbor representation is as follows .",
    "@xmath69 for convenience , let @xmath70 = -\\infty$ ] , @xmath71 = \\infty$ ] , @xmath72 = 0 $ ] and @xmath73 = |x|+1 $ ] for any string @xmath27 .",
    "then , @xmath74 \\leq nat(x)[i ] \\leq nat(x)[lmin_x[i]]$ ] holds for @xmath75 .",
    "the time complexity for computing @xmath76 is @xmath52  @xcite . using this representation",
    ", we can check if two strings match in time linear to the size of the input , even when the strings have duplicate characters .",
    "@xcite given two strings @xmath27 and @xmath38 where @xmath39 , assume @xmath76 is computed",
    ". then we can determine whether @xmath27 matches @xmath38 in @xmath53 time .",
    "[ lemma : nn matching ]",
    "in this section , we present our first algorithm for the multiple order - preserving matching .",
    "algorithm slowromancap1@ is based on the wu - manber algorithm , which is widely used for multiple pattern matching .",
    "algorithm slowromancap1@ is divided into two steps : the preprocessing step and the searching step .",
    "let @xmath14 be the length of the shortest pattern , and @xmath16 be the sum of lengths of all the patterns .",
    "we consider only the first @xmath14 characters of each pattern .",
    "let @xmath77 where @xmath78 $ ] ( this notation is provided only for clarity of exposition ) . in the preprocessing step ,",
    "we build a shift table and a hash table based on @xmath79 , which are analogous to those of the wu - manber algorithm",
    ". however , since we are looking for strings matched with patterns in terms of order - preserving matching , we have to consider the order representations of strings rather than strings themselves for comparison .",
    "consider a block of length @xmath80 on the text , where @xmath81 .",
    "the shift table determines the shift value based on the prefix representation of the given block .",
    "given a block @xmath27 , we define @xmath82)=pre(x ) \\;\\text{for } \\ ; 1\\le i\\le k , b\\le j\\le m \\ } \\;.\\end{aligned}\\ ] ] that is , @xmath83 means the position of the rightmost block in any @xmath84 which is likely to match @xmath27 . here , the term `` is likely to '' is used because @xmath54 does not necessarily mean that @xmath27 matches @xmath38 . for convenience ,",
    "let @xmath85 if there is no such block .",
    "then , the shift table is defined as @xmath86=\\min(m - l_x , m - b+1)\\;,\\end{aligned}\\ ] ] where @xmath87 is a fingerprint mapping a block @xmath27 to an integer used as an index to the shift table . using the factorial number system @xcite",
    ", we define @xmath87 as @xmath88 - 1)\\cdot ( i-1)!\\;.\\end{aligned}\\ ] ] note that @xmath87 maps a block @xmath27 into a unique integer within the range @xmath89 $ ] according to its prefix representation .",
    "[ alg1_example]-(a ) shows the shift table when there are three patterns .",
    "assume that @xmath90 .",
    "consider the block @xmath91 $ ] .",
    "the rightmost block in @xmath79 whose prefix representation equals that of @xmath91 $ ] is @xmath92 $ ] .",
    "the fingerprint @xmath93)$ ] is @xmath94 .",
    "thus , @xmath95 $ ] is @xmath96 .",
    "note that in the figure , we can safely shift the patterns by @xmath97 .",
    "the fingerprint is also used to index the hash table . @xmath98",
    "$ ] contains a pointer to the list of the patterns whose last block in @xmath79 is mapped to the fingerprint @xmath43 .",
    "[ alg1_example]-(b ) shows the hash table with the same patterns .    to compute the values of the shift table",
    ", we consider each pattern @xmath99 separately .",
    "for each pattern @xmath99 , we compute the fingerprint of each block @xmath100 $ ] consecutively , and set the corresponding value of the shift table to the minimum between its current value ( initially set to @xmath101 ) and @xmath102 . in order to obtain the fingerprint of a block",
    ", we have to compute its prefix representation .",
    "once we compute the fingerprint of the first block @xmath103)$ ] using the order - statistic tree , the tree contains the first @xmath80 characters of @xmath99 . to compute the prefix representations of the subsequent blocks",
    ", we observe that we can compute @xmath104)$ ] by taking advantage of the order - statistic tree containing characters of the previous block @xmath105 $ ] .",
    "specifically , we erase @xmath106 $ ] from the tree and insert the new character @xmath107 $ ] into the tree . inserting and deleting an element into the order - statistic tree is accomplished in @xmath108 time since the tree contains @xmath109 elements .",
    "then we traverse the tree in @xmath109 time to retrieve the prefix representation of the new block .",
    "we repeat this until we reach the last block .",
    "when we reach the last block , we map into the hash table and add @xmath110 into the corresponding list .",
    "the whole process is performed for all the patterns .",
    "since there are @xmath111 blocks , it takes @xmath112 time to construct the shift and hash tables .",
    "we also precompute the nearest neighbor representations of all the patterns , namely , @xmath113 for @xmath114 .",
    "they are used in the searching step for verifying whether patterns actually match the text . using the order - statistic tree ,",
    "they are computed in @xmath115 time , where @xmath19 denotes the length of the longest pattern . as a result , the time complexity for the preprocessing step is @xmath116 .      in the searching step ,",
    "we find all the positions of @xmath0 matched with any pattern in @xmath48 .",
    "[ alg1 ] shows the pseudocode of algorithm slowromancap1@. for the search , we slide a position @xmath117 along the text , reading a block of length @xmath80 , @xmath118 $ ] , and computing the corresponding fingerprint @xmath43 .",
    "if @xmath119 , then we shift the search window to @xmath120 and continue the search .",
    "otherwise , @xmath121 and there may be a match .",
    "thus we select the list of patterns in @xmath98 $ ] , and compare each pattern in the list with the text via the nearest neighbor representation .",
    "we call this process the verification step .",
    "we repeat this until we reach the end of the text .    * algorithm slowromancap1@(@xmath122 , @xmath41 $ ] ) *    @xmath123 preprocess @xmath1 and compute shift , hash , nn @xmath124 @xmath125)$ ] verify each pattern in @xmath98 $ ] via nn @xmath126 @xmath127 $ ]      we present a simplified analysis of the average running time for the searching step . for the analysis",
    ", we assume that there are no duplicate characters in any @xmath80-length block in strings , i.e. , any consecutive @xmath80 characters in the text and patterns are distinct .",
    "although this assumption restricts the generality of our problem , it is insignificant because : ( 1 ) a fairly large alphabet makes the case against the assumption very unlikely to happen ; ( 2 ) even if it happens , the algorithm still works correctly without a significant impact on the performance in practice . we leave it as an open problem whether the average @xmath21 time can be derived when the strings are totally random , which is more complicated .",
    "now , we assume that each distinct block appears randomly at a given position ( i.e. , with the same probability ) .",
    "let us denote @xmath128 , then there are @xmath129 different possible blocks and the probability of a block to appear is @xmath130 .",
    "[ lemma1 ] for two random blocks @xmath27 and @xmath38 , where @xmath131 and each has no duplicate characters , the probability that @xmath54 is @xmath132 .",
    "recall that algorithm slowromancap1@ determines a shift value according to the prefix representation of a current block on the text .",
    "[ lemma : shift ] the probability that a random block @xmath27 leads to a shift value of @xmath62 , @xmath133 , is at most @xmath134 .",
    "[ lemma5 ] the expected value of a shift during the search is at least @xmath135 .",
    "we set @xmath136 .",
    "then , by stirling s approximation  @xcite , we can easily prove that @xmath137 , and thus the expected value of a shift is at least @xmath138 .",
    "consequently , the average number of iterations of the * while * loop during the search is bounded by @xmath139 . at each iteration , we compute a fingerprint and the computation takes @xmath140 time .",
    "lemma  [ avgcost ] shows that the verification step at each iteration is accomplished in constant time on average .",
    "[ avgcost ] the average cost of the verification step at each iteration is @xmath141 .",
    "hence , the average time complexity of the searching step is roughly @xmath142 .",
    "in this section , we present a simple algorithm that achieves average linear time for search .",
    "algorithm slowromancap2@ exploits the ideas of the karp - rabin algorithm and the encoding techniques of chhabra and tarhio  @xcite and faro and klekci  @xcite for fingerprinting .",
    "the karp - rabin algorithm is a practical string matching algorithm that makes use of fingerprints to find patterns , and it is important to choose a fingerprint function such that a fingerprint should be efficiently computed and efficiently compared with other fingerprints .",
    "furthermore , the fingerprint function should be suitable for identifying strings in terms of order - preserving matching .",
    "given an @xmath14-length pattern @xmath1 , chhabra and tarhio  @xcite encode the pattern into a binary sequence @xmath143 of length @xmath144 , where @xmath145 = \\left\\ {    \\begin{array}{l l }      1 & \\quad \\text{if $ p[i]<p[i+1 ] $ } \\\\",
    "0 & \\quad \\text{otherwise . }    \\end{array } \\right.\\ ] ] we consider the fingerprint @xmath143 as an @xmath146-bit binary number .",
    "we can compute @xmath143 in time @xmath147 .    as @xmath14 increases",
    ", the fingerprint @xmath143 may be too large to work with ; we need at least @xmath146 bits to represent a fingerprint . to address this issue",
    ", we compute the fingerprints as residues modulo a prime number @xmath148 . according to @xcite",
    ", we choose the prime @xmath148 pseudorandomly in the range @xmath149 $ ] . with this choice",
    ", it is proved that the probability of a single false positive due to the modulo operation while searching is bounded by @xmath150 , which is negligibly small for sufficiently large @xmath13  @xcite .",
    "faro and klekci  @xcite proposed more advanced encoding techniques such as @xmath17-nr and @xmath17-no . instead of comparing between only a pair of neighboring characters , they compared between a set of @xmath17 characters for computing the relative position of a character .",
    "we can compute fingerprints using those techniques similarly to above .",
    "we implemented algorithm slowromancap2@ using three encoding techniques , including chhabra and tarhio s binary encoding @xcite , @xmath17-nr , and @xmath17-no  @xcite , for fingerprinting . in the following sections",
    ", we will describe the algorithm assuming the binary encoding .",
    "again , let @xmath77 be the set of @xmath14-length prefixes of the patterns . in the preprocessing step , we first compute @xmath151 for @xmath114 and build a hash table . @xmath98",
    "$ ] contains a pointer to the list of the patterns whose fingerprints equal @xmath43 .",
    "we also compute @xmath113 for @xmath114 . in total",
    ", the preprocessing step takes @xmath115 time . fig .",
    "[ alg2_example]-(a ) shows the hash table when there are three patterns .",
    "we use a prime @xmath152 in the example .",
    "$ ] , the corresponding fingerprint is @xmath153 .",
    "we check @xmath154 $ ] , which has @xmath155 as elements , and thus verify them via nn . ]      in the searching step , we scan the text @xmath0 while iteratively computing fingerprints of the successive windows of size @xmath14 .",
    "[ alg2 ] shows the pseudocode of algorithm slowromancap2@. we slide a search window @xmath156 $ ] along the text , computing the corresponding fingerprint @xmath157 .",
    "if the list pointed by @xmath158 $ ] is not empty , we compare each pattern in the list with the text via its nearest neighbor representation .",
    "we call this process the verification step .",
    "we repeat this until we reach the end of the text . fig .  [",
    "alg2_example](b ) shows an example of the searching step .    * algorithm slowromancap2@(@xmath122 , @xmath41 $ ] ) *    @xmath123 preprocess @xmath1 and compute hash , nn @xmath124 @xmath159 ) \\ ; \\text{mod } \\ ; p$ ] verify each pattern in @xmath158 $ ] via nn      at each iteration of the * for * loop , we compute the fingerprint @xmath157 of the search window .",
    "let us denote @xmath160 ) \\ ; \\text{mod } \\ ; p$ ] , which is the fingerprint of the @xmath43-th search window .",
    "we can compute @xmath161 in time @xmath147 . to compute the fingerprints for the subsequent windows ,",
    "we observe that we can compute @xmath162 from @xmath163 using horner s rule  @xcite , since @xmath164)+\\beta(t)[i+m ] ) \\ ; \\text{mod } \\ ; p\\;,\\end{aligned}\\ ] ] where @xmath165 is a precomputed value .",
    "it is clear that this calculation is done in constant time .",
    "now , we analyze the time spent to perform the verification step .",
    "we assume that the numbers in the text and patterns are statistically independent and uniformly at random .",
    "the verification is performed when there is a match between encoded binary strings of the text and patterns .",
    "the probability that a 1 appears at a position of an encoded string is @xmath166 .",
    "so the probability of a character match  @xcite is @xmath167 since the odd positions of an encoded string are mutually independent , we can ( upper ) bound the probability of a match between two encoded strings by @xmath168 .",
    "note that @xmath169 for @xmath170 .",
    "[ lemma6 ] when @xmath16 is polynomial with respect to @xmath14 , the average cost of the verification step during the search is @xmath141 .",
    "hence , the average time complexity of the searching step is @xmath22 , when @xmath16 is polynomial with respect to @xmath14 .",
    "in order to verify the practical behaviors of our algorithms , we tested them against the previous algorithms based on the aho - corasick algorithm : kim et al.s @xcite , and belazzougui et al.s  @xcite .",
    "kim et al.s algorithm is denoted by _",
    "kef _ , belazzougui et al.s by _ bpr _ , and algorithm slowromancap1@ by _ alg1_. algorithm slowromancap2@ is denoted by _",
    "alg2 _ , followed by a notation of the encoding technique adopted for fingerprinting . specifically , _",
    "alg2_bin _ refers to algorithm slowromancap2@ with chhabra and tarhio s binary encoding @xcite , and _ alg2_nr2 _",
    "_ alg2_no2 _ ) refers to algorithm slowromancap2@ with the @xmath17-nr ( resp .",
    "@xmath17-no ) encoding of faro and klekci @xcite where we set @xmath171 .",
    "all algorithms were implemented in c++ and run on a debian linux 7(64bit ) with intel xeon x5672 processor and 32 gb ram . during the compilation",
    ", we used the o3 optimization option .",
    "we tested for a random text @xmath0 of length @xmath172 searched for @xmath173 random patterns of length @xmath174 , respectively .",
    "all the texts and patterns were selected randomly from an integer alphabet @xmath175 ( we tested for varying alphabet sizes , but we did nt observe sensible differences in the results ) . for each combination of @xmath20 and @xmath14 , we randomly selected a text and patterns , and then ran each algorithm .",
    "we performed this 10 times and measured the average time for the searching step .",
    "table  [ table1 ] shows the results .",
    "[ numberofpattern10 ] in appendix shows the average search times when @xmath176 .",
    "when @xmath14 is less than 50 , _",
    "alg2_bin _ is the best among the algorithms , achieving a speed up of about 6 times compared to _ kef _ , and about 14 times compared to _ bpr_. as @xmath14 increases , however , _",
    "alg1 _ becomes better , achieving a speed up of about 11 times compared to _",
    "kef _ , and about 24 times compared to",
    "_ bpr_. this is due to the increase of the average shift value during the search .",
    "the reason that the average shift value increases is that since we set @xmath136 , the block size increases as @xmath14 increases , and thus the probability that a block appears in the patterns decreases .",
    "[ numberofpattern50 ] and [ numberofpattern100 ] in appendix show the average search times when @xmath177 .",
    "they show similar trends with fig .",
    "[ numberofpattern10 ] .",
    "one thing to note is that as @xmath20 increases , the point of @xmath14 where _ alg1 _ becomes for the first time faster than the _",
    "alg2 _ family increases .",
    "we attribute this to the fact that as @xmath20 increases , a block appears more often in the patterns , which leads to lower shift values .",
    "[ 1 ] > + m#1     @xmath20 & @xmath14 & & _ kef _ & _ bpr _ & _ alg1 _ & _ alg2_bin _ & _ alg2_nr2 _ & _ alg2_no2 _ + & 5 & & 527.3 & 1215.1 & 274.8 & * 107.6 * & 164.8 & 186.5 + & 10 & & 544.3 & 1258.2 & 216.9 & * 91.5 * & 148.8 & 197.6 + & 20 & & 557.1 & 1254.8 & 286.5 & * 88.4 * & 155.4 & 194.8 + & 50 & & 556.2 & 1213 & * 51.1 * & 65.4 & 116.7 & 203 + & 100 & & 561.7 & 1244.8 & * 56.2 * & 70.4 & 123.9 & 206.9 +    & 5 & & 598 & 1227.2 & 647.8 & 234.1 & * 215.3 * & 310 + & 10 & & 573.8 & 1238.6 & 269.6 & * 100.5 * & 152.3 & 194.6 + & 20 & & 562.9 & 1244.2 & 308.6 & * 114.8 * & 187.1 & 216.4 + & 50 & & 570.7 & 1239.8 & 313.5 & * 113.8 * & 184.5 & 226.2 + & 100 & & 587.6 & 1271.8 & * 55.4 * & 86.1 & 150.6 & 227.6 +    & 5 & & 569 & 1291.1 & 674.4 & 395.6 & 386.3 & * 307.3 * + & 10 & & 629 & 1304.3 & 522.4 & * 81.9 * & 100.3 & 150.5 + & 20 & & 589 & 1250.2 & 498.4 & * 102.6 * & 164 & 205.1 + & 50 & & 605.3 & 1259.9 & 103.3 & * 86 * & 184.8 & 225.7 + & 100 & & 588.9 & 1247.2 & 73.2 & * 53.8 * & 182 & 227.5 +    [ table1 ]",
    "we proposed two efficient algorithms for the multiple order - preserving matching problem .",
    "algorithm slowromancap1@ is based on the wu - manber algorithm , and algorithm slowromancap2@ is based on the karp - rabin algorithm and exploits the encoding techniques of the previous works  @xcite .",
    "algorithm slowromancap1@ performs the multiple order - preserving matching in average @xmath142 time , and algorithm slowromancap2@ performs it in average @xmath22 time when @xmath16 is polynomial with respect to @xmath14 .",
    "the experimental results show that both of the algorithms are much faster than the existing algorithms . when the lengths of the patterns are relatively short , algorithm slowromancap2@ with the binary encoding performs the best due to its inherent simplicity .",
    "however , algorithm slowromancap1@ becomes more efficient as the lengths of the patterns grow .",
    "14    abramowitz , m. , stegun , i.a . : in : handbook of mathematical functions .",
    "dover new york ( 1972 ) belazzougui , d. , pierrot , a. , raffinot , m. , vialette , s. : single and multiple consecutive permutation motif search . in : cai , l. cheng , s .- w . , lam , t .- w .",
    "isaac 2013 .",
    "lncs , vol.8283 , pp .",
    "6677 , springer , heidelberg ( 2013 ) chhabra , t. , tarhio , j. : order - preserving matching with filtration . in : proc .",
    "sea14 , 13th international symposium on experimental algorithms , pp .",
    "307314 , springer ( 2014 ) cho , s. , na , j.c . , park , k. , sim , j.s .",
    ": a fast algorithm for order - preserving pattern matching .",
    "information processing letters 115(2 ) , 397402 ( 2015 ) cormen , t.h . ,",
    "leiserson , c.e . ,",
    "rivest , r.l . ,",
    "stein , c. : in : introduction to algorithms 2nd edn . mit press , cambridge ( 2001 ) crochemore , m. , iliopoulos , c.s . ,",
    "kociumaka , t. , kubica , m. , langiu , a. , pissis , s.p . , radoszewski , j. , rytter , w. , wale , t. : order - preserving incomplete suffix trees and order - preserving indexes . in : kurland , o. , lewenstein , m. , porat , e. ( eds . ) spire 2013 .",
    "lncs , vol . 8214 ,",
    "8495 , springer , heidelberg ( 2013 ) faro , s. , klekci , o. : efficient algorithms for the order preserving pattern matching problem .",
    "arxiv preprint arxiv:1501.04001 ( 2015 ) gawrychowski , p. , uznaski , p. : order - preserving pattern matching with k mismatches . in : combinatorial",
    "pattern matching , pp .",
    "130139 , springer ( 2014 ) karp , r.m .",
    ", rabin , m.o . : efficient randomized pattern - matching algorithms .",
    "ibm journal of research and development 31(2 ) , 249260 ( 1987 ) kim , j. , amir , a. , na , j.c . ,",
    "park , k. , sim , j.s .",
    ": on representations of ternary order relations in numeric strings . in : icabd , pp . 4652 ,",
    "springer ( 2014 ) kim , j. , eades , p. , fleischer , r. , hong , s. , iliopoulos , c.s . , park , k. , puglisi , s.j . ,",
    "tokuyama , t. : order - preserving matching .",
    "theoretical computer science 525 , 6879 ( 2014 ) knuth , d.e . : in : the art of computer programming vol .",
    "2 seminumerical algorithms .",
    "addison wesley ( 1998 ) kubica , m. , kulczyski , t. , radoszewski , j. , rytter , w. , wale , t. : a linear time algorithm for consecutive permutation pattern matching .",
    "information processing letters 113(12 ) , 430 - 433 ( 2013 ) wu , s. , manber , u. : a fast algorithm for multi - pattern searching . technical report .",
    "tr-94 - 17 , department of computer science , university of arizona ( 1994 )",
    "* proof of lemma [ lemma1 ] . *",
    "the probability is equivalent to the probability that when randomly choosing a block @xmath27 , its prefix representation is the same as that of ( already chosen ) @xmath38 .",
    "the sample space consists of all @xmath129 possible blocks .",
    "notice that once we choose @xmath80 distinct characters regardless of order , we can order them to fit in any one of the @xmath178 prefix representations .",
    "it means that there are @xmath179 blocks belonging to each prefix representation .",
    "therefore , the probability is @xmath180 .",
    "* proof of lemma [ lemma : shift ] . *",
    "the necessary condition for the case that @xmath27 leads to a shift value @xmath62 is that there exists a pattern @xmath99 whose block ending at the position @xmath102 belongs to the prefix representation of @xmath27 .",
    "since there are @xmath20 patterns , the probability of the necessary condition is @xmath134 .",
    "* proof of lemma [ avgcost ] .",
    "* at each iteration , the probability that a pattern @xmath110 leads to the verification step is @xmath132 and the cost for the verification for @xmath110 is @xmath182 by lemma  [ lemma : nn matching ] .",
    "since there are @xmath20 patterns , the expected cost of the verification step at each iteration is @xmath183 .",
    "* proof of lemma [ lemma6 ] .",
    "* at each iteration , the probability that a pattern @xmath110 leads to the verification is at most @xmath168 .",
    "thus , the expected cost of the verification step is at most @xmath184 , which is @xmath141 when @xmath16 is polynomial with respect to @xmath14 ."
  ],
  "abstract_text": [
    "<S> given a text @xmath0 and a pattern @xmath1 , the order - preserving matching problem is to find all substrings in @xmath0 which have the same relative orders as @xmath1 . </S>",
    "<S> order - preserving matching has been an active research area since it was introduced by kubica et al . </S>",
    "<S> @xcite and kim et al . @xcite . in this paper </S>",
    "<S> we present two algorithms for the multiple order - preserving matching problem , one of which runs in sublinear time on average and the other in linear time on average . </S>",
    "<S> both algorithms run much faster than the previous algorithms . </S>"
  ]
}