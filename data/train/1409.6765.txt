{
  "article_text": [
    "fair allocation of resources is one of the most critical issues for society .",
    "a basic , yet widely applicable , problem in computer science and economics is to allocate discrete objects to agents given the ordinal preferences of the agents over the objects .",
    "the setting is referred to as the _ assignment problem _ or the _ house allocation problem _  ( see , e.g. , * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "in this setting , there is a set of agents @xmath3 , a set of objects @xmath4 with each agent @xmath5 expressing ordinal preferences @xmath6 over @xmath7 .",
    "each object is assumed to be acceptable to the agents .",
    "the goal is to allocate the objects among the agents in a fair or optimal manner without allowing transfer of money .",
    "the model is applicable to many resource allocation or fair division settings where the objects may be public houses , school seats , course enrolments , kidneys for transplant , car park spaces , chores , joint assets of a divorcing couple , or time slots in schedules .",
    "for the assignment problem , the case of two agents is especially central .",
    "many disputes are between two parties and may require division of common resources .",
    "divorce proceedings is one of the settings in which common assets need to be divided among the two parties .",
    "other examples in history include partition of countries which results in the need to divide common assets .    when objects are allocated among agents , it is desirable that they are allocated in a fair and efficient manner . for fairness ,",
    "one of the most established concepts is envy - freeness .",
    "a formal study of envy - freeness in microeconomics can be traced back to the work of @xcite .",
    "envy - freeness requires that each agent should prefer its allocation over other agents allocations .",
    "envy - freeness can be trivially satisfied by not giving any objects to any agents",
    ". however , if we insist that the assignment should be _ complete _ , i.e. , it allocated all the objects to the agents , no assignment may be envy - free as is the case in which there is only one object and the agent who does not get any object is envious .",
    "the most established notion of efficiency is pareto optimality which requires that there should be no other allocation which each agent weakly prefers and at least one agent strictly prefers .",
    "pareto optimality has been termed the _",
    "`` single most important tool of normative economic analysis '' _",
    "an assignment which gives no objects to agents is clearly not pareto optimal .    in view of the importance of the two - agent setting , and the fundamental goals of envy - freeness and pareto optimality",
    ", @xcite presented an elegant algorithm called al for the case of two agents that computes a maximal assignment that is envy - free as well as _ locally pareto optimal _",
    "( pareto optimal for the set of allocated objects ) .",
    "since there may not exist a pareto optimal and envy - free assignment , @xcite relax the requirement of pareto optimality to local pareto optimality .",
    "the algorithm has received attention in the literature  ( see e.g. , * ? ? ? * ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "the desirable aspect of al is that is returns a locally pareto optimal and a maximal envy - free assignment . by maximal , we mean that unallocated objects can not be additionally given to the agents partial allocations without compromising envy - freeness .",
    "@xcite also claim that al returns a complete envy - free assignment if there exists a complete envy - free assignment .",
    "one possible limitation of the al method is that it assumes that agents have strict preferences over objects .",
    "we present a generalization of the al method in which agents may express indifferences among agents .",
    "indifferences in preferences are not only a natural relaxation but are also a practical reality in many cases .",
    "for example , if there are multiple copies of the same object with the same characteristics , then an agent is invariably indifferent among all such copies .",
    "indifferences can lead to various challenges .",
    "the complexity of solution concepts in the presence of indifferences can be considerably more than in the case of strict preferences .",
    "a famous example is that of roommate markets for which the problem of finding a stable matching is polynomial - time solvable for strict preferences but np - complete for weak orders  @xcite .",
    "similarly , a number of fairness concepts are harder to compute when weak orders are allowed  @xcite . in view of this",
    ", effort has been taken to generalize algorithms and rules for the case of indifferences in voting  ( see e.g. , * ? ? ?",
    "* ; * ? ? ?",
    "* ) , housing markets  ( see e.g. , * ? ? ?",
    "* ; * ? ? ?",
    "* ) , coalition formation  @xcite , and various matching market models  @xcite . the main contribution of this paper is a generalization of al which we refer to as gal for the case in which agents may express indifferences .",
    "the main result of the paper is as follows .    for two agents , gal returns in time @xmath8 a maximal envy - free and locally pareto optimal assignment even if agents express weak preferences .",
    "if a complete envy - free assignment exists , gal computes a complete envy - free assignment .",
    "moreover , there exists no other assignment that pareto dominates it and is still envy - free .",
    "previously ,  @xcite and @xcite presented @xmath9 time algorithms to check whether a _ complete _ envy - free assignment for two agents exists or not .",
    "the algorithms require solving network flow or maximum matching problems . as a corollary of gal",
    ", we obtain a simple @xmath8 algorithm to check whether there exists a complete assignment that is ef .",
    "the critical reader may ask whether gal can be generalized to handle an arbitrary number of agents . we show that unless complexity classes p and np coincide  @xcite , there exists _ no _ polynomial - time algorithm for an arbitrary number of agents that satisfies the same properties as gal .",
    "computation of fair discrete assignments has been intensely studied in the last decade . in many of the papers considered , agents express cardinal utilities for the objects and",
    "the goal is to compute fair assignments  ( see e.g. , * ? ? ?",
    "* ; * ? ? ?",
    "we consider the setting in which agents only express ordinal preferences over objects  @xcite which are less demanding to elicit .    when agents express preferences over objects and we need to reason about preferences over allocations , there are different ways one can define envy - freeness such as possible envy - freeness and weak sd envy - freeness  @xcite .",
    "in this paper we will use the strongest known reasonable notion of envy - freeness .",
    "the notion is equivalent to necessary envy - freeness in  @xcite , sd - envy - freeness in  @xcite , ef notion used in  @xcite and pair - wise envy - freeness in  @xcite .",
    "we will refer to the notion simply as ef just like @xcite do .",
    "@xcite and @xcite presented @xmath9 algorithms to check whether there exists an ef assignment .",
    "we show that there exists a simple @xmath8 algorithm for the problem even if agents express weak preferences .",
    "there are other papers  @xcite in fair division in which agents explicitly express ordinal preferences over sets of objects rather than simply expressing preferences over objects  @xcite .",
    "for these more expressive models , the computational complexity of computing fair assignments is either even higher  @xcite or representing preferences requires exponential space  @xcite . in this paper , we restrict agents to simply express ordinal preferences over objects .",
    "an assignment problem is a triple @xmath10 such that @xmath3 is a set of agents , @xmath11 is a set of objects , and the preference profile @xmath12 specifies for each agent @xmath13 its preference @xmath6 over @xmath7 .",
    "agents may be indifferent among objects .",
    "we will denote by @xmath14 the strict part and by @xmath15 the indifference part of the relation @xmath6 .",
    "we denote @xmath16 for each agent @xmath13 with equivalence classes in decreasing order of preferences .",
    "thus , each set @xmath17 is a maximal equivalence class of objects among which agent @xmath13 is indifferent , and @xmath18 is the number of equivalence classes of agent @xmath13 .",
    "if an equivalence class is a singleton @xmath19 , we list the object @xmath20 in the list without the curly brackets .",
    "a preference profile consists of _ dichotomous preferences _ each agent has at most two equivalence classes .",
    "a preference profile consists of _ strict preferences _ each agent has strict preferences over the objects .",
    "an assignment @xmath21 specifies the _ allocation _ of objects @xmath22 to each @xmath5 such that @xmath23 and @xmath24 for all @xmath25 .",
    "an assignment is _ complete _ if @xmath26 for all @xmath27 .",
    "we define the _ sd ( stochastic dominance ) _ relation .",
    "an agent _ sd - prefers _",
    "one allocation over another if for each object , the former allocation gives the agent as much probability of getting at least preferred an object as the latter allocation .",
    "given two assignments @xmath28 and @xmath29 , @xmath30 , i.e. , agent @xmath13 _ sd  prefers _",
    "allocation @xmath22 to allocation @xmath31 if for each @xmath27 , @xmath32 agent @xmath13 _ strictly sd prefers _",
    "@xmath22 to @xmath31 : @xmath33 if @xmath30 and @xmath34 $ ] .",
    "although each agent @xmath13 expresses ordinal preferences over objects , he could have a private cardinal utility @xmath35 consistent with @xmath6 : @xmath36    an assignment @xmath28 is _ sd - efficient _ if there exists no other assignment @xmath29 such that @xmath37 for all @xmath5 and @xmath38 for some @xmath5 .",
    "sd - efficiency is equivalent to pareto optimality for discrete assignments as defined by @xcite .",
    "hence we will refer to sd - efficiency as pareto optimality and sd - domination as pareto domination .",
    "an assignment @xmath28 is is _ lpo ( locally pareto optimal ) _ if there exists no other assignment @xmath29 such that @xmath39 and @xmath37 for all @xmath5 and @xmath38 for some @xmath5 .",
    "an assignment @xmath28 satisfies _ sd envy - freeness _ or is _ sd envy - free _ if each agent sd prefers its allocation to that of any other agent : @xmath40    from the definition it is easy to see that a necessary condition for sd envy - freeness is that each agent gets the same number of objects .",
    "@xcite defined ef as follows .    an allocation @xmath28 is _ ef ( envy - free ) _ if for all @xmath41 @xmath42 and there exists an injection @xmath43 and an injection @xmath44 such that for each object @xmath45 , @xmath13 ( weakly ) prefers @xmath20 to @xmath46 and for each object @xmath47 , @xmath48 ( weakly ) prefers @xmath20 to @xmath49 .    then , by using a similar argument as ( lemma 1 , * ? ? ?",
    "* ) , we can show that ef is equivalent to sd envy - freeness .",
    "we detail the argument for the sake of completeness and to formally extend lemma  1@xcite to the case of indifferences .",
    "ef is equivalent to sd envy - freeness .",
    "we first show that ef implies sd envy - freeness .",
    "suppose @xmath28 satisfies ef and take any object @xmath27 .",
    "suppose that there is an object @xmath50 such that @xmath51 . by the definition of @xmath52",
    ", we know that @xmath53 . since @xmath51 , we get that @xmath54 .",
    "hence ,    @xmath55    we now show that sd envy - freeness implies ef .",
    "suppose that assignment @xmath28 does not satisfy ef with the ef condition violated for agent @xmath13 . consider a bipartite graph @xmath56 where @xmath57 if @xmath58 , @xmath50 , and @xmath59 .",
    "since @xmath28 does not satisfy ef for @xmath13 , @xmath60 does not admit a perfect matching . by hall",
    "s theorem , there exists set @xmath61 such that @xmath62 where @xmath63 is the neighbourhood of @xmath64 in the graph @xmath60 .",
    "consider an object @xmath65 .",
    "since , @xmath62 , this it implies that @xmath66    but then @xmath28 does not satisfy sd envy - freeness .",
    "[ lemma : efcheck ] if the number agents is constant , it can be checked in @xmath1 time whether a given assignment is ef or not .",
    "we show that it can be checked in @xmath1 time whether a given assignment for a constant number agents is sd envy - free or not .",
    "we first show that an sd comparison between any two allocations can be made in @xmath1 time .",
    "let us say that we want to check whether @xmath67 where @xmath68 is some agent other than @xmath13 . without loss of generality , assume that @xmath13 s preferences are a coarsening of linear order @xmath69 .",
    "* we construct in @xmath1 a vector @xmath70 where @xmath71 if @xmath72 and @xmath73 otherwise . using @xmath74",
    "we construct in @xmath75 time a vector @xmath76 where @xmath77 .",
    "using @xmath78 we construct in @xmath75 time a vector @xmath79 where @xmath80 . * in a similar way , we construct in @xmath1 a vector @xmath81 where @xmath82 if @xmath83 and @xmath73 otherwise .",
    "using @xmath84 we construct in @xmath75 time a vector @xmath85 where @xmath86 . using @xmath87",
    "we construct in @xmath75 time a vector @xmath88 where @xmath89 .    now @xmath67 iff @xmath90 for all @xmath91 .",
    "this again takes time @xmath75 .",
    "hence an sd comparison between allocation takes time @xmath92 .    in order to test ef",
    ", we need to make @xmath93 comparisons which is constant if @xmath94 is constant . hence testing ef of an assignment for constant number of agent takes time @xmath1 .",
    "if the number of agents is not constant , then the time complexity is @xmath95 . in the paper",
    ", we will assume that @xmath96 i.e. , there are two agents .",
    "if we refer to some agent as @xmath97 , then we will refer to the other agent as @xmath68 . even for more than two agents",
    ", we may refer to @xmath68 as some agent other than @xmath5 .",
    "finally , define _ maximal envy - freeness_.    we say that a partial assignment @xmath28 is _ maximally envy - free _ if it is envy - free and there exists no assignment @xmath29 such that @xmath98 for all @xmath5 , @xmath99 for some @xmath5 , and @xmath29 is envy - free .",
    "before we delve into gal , we first informally describe a simplified version of al that still satisfies the properties of al as described in @xcite .",
    "agents have strict preferences and in each round they pick one object each .",
    "the algorithm repeats the following until all objects have been allocated to agent @xmath100 , @xmath101 , or contested pile @xmath102",
    ". we will refer to an object as _ unallocated _ if it has not been allocated to @xmath100 or @xmath101 or placed in @xmath102 .",
    "if the most preferred unallocated object of the agents is not the same , each agent picks its most preferred object .",
    "otherwise , if the most preferred unallocated object @xmath20 coincides , then we check whether we can give it to agent @xmath100 .",
    "if @xmath20 is given to agent @xmath100 and the next most preferred unallocated object is given to agent @xmath101 and the partial assignment satisfies ef , then we allow such an allocation in the round .",
    "if not , we check in the same way whether we can give it to agent @xmath101 . if @xmath20 can not be given to either of the two , we put it in @xmath102 .",
    "the general idea of gal is as follows . since the preferences of the two agents are weak orders , we first construct unique linear orders called _ priority orders _ based on the preferences .",
    "although , the comparisons to check the feasibility of ef assignments are still done with respect to the original preferences , the constructed linear orders help identify which unique object should each agent try to get first .",
    "the priority orders are refinements of the preferences where , if an agent is indifferent between two objects , it has higher priority for the object less preferred by the other agent .",
    "if both agents are indifferent among two objects , then agent 1 has higher priority for the object with the lower index and agent 2 has higher priority for the object with the higher index .",
    "after suitably constructing the linear orders , @xmath103 and @xmath104 , agents try to take the highest priority .",
    "if agents have a different highest priority object , they take their highest priority objects .",
    "otherwise there is a conflict so we must try to give one of the agents the highest priority object and give the other agent the second highest priority object according to the priority list if it does not violate ef .",
    "if this can not be done , we send the contested object to @xmath102 , the so called _ contested pile_. a key idea behind gal is that if an object @xmath105 is sent to the contested pile , then it can not be the case that @xmath105 along with some subsequent less preferred objects are allocated to agents and ef is not violated .",
    "the algorithm is formally defined as algorithm  [ algo : gal ] .",
    "note there is an asymmetry in the algorithm in that agent one is considered first to get object @xmath105 in step  [ step : agent1 ] .",
    "one can consider any of the two agents first or even toss a coin to select one agent .",
    "the properties of the algorithm are not affected .",
    "@xmath106 ef assignment @xmath28    construct a linear order @xmath103 for agent @xmath100 : for all @xmath107 , @xmath108 if @xmath109 ; @xmath110 if @xmath111 and @xmath112 ; @xmath108 if @xmath113 and @xmath112 and @xmath114 construct the linear order @xmath104 for agent @xmath101 : for all @xmath107 , @xmath115 if @xmath111 ; @xmath116 if @xmath109 and @xmath113 ; @xmath116 if @xmath113 and @xmath112 and @xmath114 .    @xmath117 @xmath118 ; @xmath119 @xmath120 round number @xmath121    @xmath122 [ step : o=1 ] [ stepb : o=1 ] @xmath123 @xmath124 @xmath125 @xmath126 @xmath127 ( or @xmath128 ) @xmath129 [ step : agent1 ] @xmath130 @xmath131 @xmath132 [ step : agent2 ] @xmath133",
    "@xmath134 @xmath135 @xmath136 @xmath137    first observe that for strict preferences , gal is equivalent to the simplified al method .",
    "the reason is that for strict preferences , there exists a unique priority order irrespective of any lexicographical tie - breaking order .",
    "we present a couple of examples to illustrate how gal works .",
    "the contested pile is empty in one example and non - empty in another .",
    "@xmath138    @xmath139    1 .",
    "round @xmath100 : @xmath140 , @xmath141 , @xmath142 ; 2 .",
    "round @xmath101 : @xmath143 , @xmath144 , @xmath142 ; 3 .",
    "round @xmath145 : @xmath146 , @xmath147 , @xmath142 .",
    "@xmath148    @xmath149    1 .",
    "round @xmath100 : @xmath150 , @xmath151 , @xmath152 ; 2 .",
    "round @xmath101 : @xmath153 , @xmath154 , @xmath152 ; 3 .",
    "round @xmath145 : @xmath155 , @xmath156 , @xmath152 ; 4 .",
    "round @xmath157 : @xmath158 , @xmath159 , @xmath152 .",
    "gal runs in @xmath8 time and is deterministic .    in each round , either one object each is allocated to the agents or one contested object is sent to @xmath102 .",
    "if each agent has a different highest priority unallocated object , then the allocation takes constant time .",
    "otherwise , the agents have the same highest priority contested object @xmath105 . in this case , we need to make at most two checks for whether there exists an ef partial assignment that allocated @xmath105 to one of the agents . in either of these checks ,",
    "we simply need to verify whether the given partial assignment is ef or not which takes time @xmath1 according to lemma  [ lemma : efcheck ] .",
    "thus , gal takes time @xmath8 .",
    "[ prop : maximal ] gal returns a maximal ef assignment .    the gal outcome is ef .",
    "this follows from the way the partial assignments are constructed so that ef is maintained . if @xmath160 , then the partial assignment is only modified after checking that the modification still satisfies ef . if @xmath161 , then each agent is given a most preferred unallocated object from @xmath64 .",
    "since the partial allocation @xmath28 is ef , and for each @xmath45 , @xmath162 , it follows that the allocation which gives @xmath163 to each @xmath97 is ef .",
    "we now show that the outcome is a maximal ef assignment .",
    "assume for contradiction that gal s outcome @xmath28 is not maximal ef .",
    "this means that for some object @xmath164 there exists an assignment @xmath29 that matches the objects matched by @xmath28 as well as @xmath20 and possible other objects .",
    "consider the object @xmath20 that is the first object to be placed in the contested pile @xmath102 and consider the stage in algorithm  [ algo : gal ] where @xmath20 was sent to @xmath102 .",
    "if @xmath20 was given to agent @xmath68 , then agent @xmath13 was given the next highest priority object @xmath165 according to @xmath166 which still leads to infeasibility of ef .",
    "clearly @xmath167 or else the partial assignment @xmath28 at the stage would nt fail ef .",
    "for every other unallocated object @xmath168 in @xmath64 ( that has not in the contested pile ) at that stage , it holds that @xmath169 .",
    "hence no object @xmath168 can be given to agent @xmath13 while @xmath20 is given to @xmath68 so that @xmath28 is still @xmath170 . by the same argument ,",
    "every subsequent object that is placed in @xmath102 can not be allocated to one of the agents without causing the other agent to be envious .",
    "next , we show that if there exists a complete ef assignment , then gal returns a complete ef assignment . for the proposition ,",
    "we require the following lemma which follows from ( theorem 4(i ) , * ? ? ?",
    "[ lemma : prop ] for the case of two agents , any partial assignment @xmath28 if ef iff for each @xmath171 , @xmath172    [ prop - complete ] if there exists a complete ef assignment , then gal returns a complete ef assignment .",
    "assume for contradiction that there exists a complete ef assignment but gal does not return a complete ef assignment .",
    "then there exists at least one object in the contested pile .",
    "let us consider the first object @xmath20 that is placed in the contested pile .",
    "when @xmath20 is placed in the contested pile , let the partial ef allocation be @xmath28 .",
    "let the next priority available unallocated objects of @xmath13 and @xmath68 be @xmath173 and @xmath174 respectively where it could be possible that @xmath175 .",
    "since @xmath20 is placed in the contested pile , this means that the assignment which gives @xmath176 to @xmath13 allocation and @xmath177 is not ef .",
    "similarly , the assignment which gives @xmath178 to @xmath13 allocation and @xmath179 is not ef .",
    "this implies that @xmath180 and @xmath181 .",
    "let the rank @xmath20 in agent @xmath13 s priority list be @xmath182 and the rank @xmath20 in agent @xmath13 s list be @xmath183 .",
    "now consider the objects in @xmath22 .",
    "all objects in @xmath22 are have a better rank than @xmath20 for agent @xmath13 .",
    "secondly , in agent @xmath13 s priority list , if an object is not allocated to @xmath13 , it is allocated to agent @xmath68 .",
    "now agent @xmath13 s allocation @xmath22 is such that if @xmath20 is given agent @xmath68 and @xmath184 to agent @xmath13 , the assignment is not ef . by lemma  [ lemma : prop ] , this means that @xmath185 .",
    "the assignment which allocates @xmath20 in addition one of the agents in addition to the partial assignment @xmath28 if not ef even if agent @xmath13 got his @xmath186 most preferred objects .",
    "this means that there does not exist a complete ef assignment .",
    "next we show that the gal outcome is lpo . unlike in @xcite , we can not use the characterization of @xcite that if agents have _ strict _ preferences , any assignment as a result of sequential allocation is pareto optimal .",
    "hence we need a lemma .",
    "let @xmath10 be an assignment problem and @xmath28 be a discrete assignment .",
    "we will create an auxiliary assignment problem and assignment where each agent is allocated exactly one object  ( see e.g. , * ? ? ?",
    "the _ clones _ of an agent @xmath5 are the agents in @xmath187 .",
    "the _ cloned assignment problem _ of @xmath10 is @xmath188 such that @xmath189 . and for each @xmath190 , @xmath191 .",
    "the _ cloned assignment _ of @xmath28 is the discrete assignment @xmath192 in which @xmath193 if @xmath45 and @xmath194 otherwise .",
    "a cloned assignment can easily be transformed back into the original assignment where each agent @xmath5 is allocated all the objects assigned by @xmath192 to the clones of @xmath13 .",
    "[ lemma : cycle2 ] an assignment for two agents is lpo iff there exist no objects @xmath195 such that @xmath20 is allocated to @xmath13 , @xmath165 is allocated to @xmath68 , @xmath196 and @xmath197 .    by ( lemma 2 , * ? ? ?",
    "* ) , an assignment is pareto optimal if and only if its cloned assignment is pareto optimal for the cloned assignment problem .",
    "hence , we can restrict our attention to the cloned assignment and the cloned assignment setting . if the cloned assignment is pareto optimal , the original assignment is pareto optimal .",
    "if the cloned assignment is _ not _ pareto optimal , then there exists a ` trading cycle ' in which each object points to its owner , each cloned agent in the cycle points to an object that is at least as preferred as its own object and at least one agent in the cycle points to a strictly more preferred object than the one it owns  @xcite .",
    "firstly , we claim that there exists no trading cycle consisting only of clones of one agent .",
    "assume for contradiction that there exist a trading cycle consisting of only of clones of the same agent .",
    "then there exists at least one object that is minimally preferred .",
    "the agent who points to this object also owns a minimally preferred object .",
    "hence each agent owns a minimally preferred object and thus the cycle is not pareto improving .",
    "we now show that , if there exists a trading cycle , then there exists one which alternates between clones of the two agents .",
    "consider any cycle which has the following path consisting of multiple clones of the same agent in succession : @xmath198 since clones of each agent @xmath13 have the identical preference , @xmath199 also points directly to @xmath200 .",
    "hence , we know that there is also a path @xmath201    we now show that if there exists a trading cycle which alternates between clones of the two agents , then there exists one with exactly one clone of each agent . by the definition of trading cycle ,",
    "at least one agent points to a strictly more preferred over the object he owns .",
    "assume that a clone of agent @xmath13 gets a strictly more preferred object in the trading cycle .",
    "let such a clone be @xmath202 that points to @xmath105 .",
    "consider the clone @xmath203 of agent @xmath13 who has the least preferred object among all clones of @xmath13 .",
    "we can assume without loss of generality that @xmath203 points to a strictly more preferred object that the one he owns .",
    "if this were not the case , then we know that @xmath202 has a trading path to @xmath203 and @xmath203 also strictly prefers @xmath105 over the object he owns .",
    "this means that there is trading cycle in which @xmath203 points to a strictly more preferred object owned by a clone of @xmath68 .",
    "hence , without loss of generality let the agents in the trading cycle have the following sequence where @xmath203 points to and strictly prefers the object of @xmath204 over his own object : @xmath205 if clone @xmath206 is indifferent between his object and the object owned by @xmath203 , then this means he strictly prefers @xmath204 s object over his own object .",
    "but this means that @xmath206 and @xmath204 weakly prefer each other s objects over their own object and @xmath206 strictly prefers @xmath204 s object which means we have already shown that there exist @xmath195 such that @xmath20 is allocated to @xmath13 , @xmath165 is allocated to @xmath68 , @xmath196 and @xmath197 .",
    "suppose for contradiction that @xmath206 has a strictly more preferred object than the object owned by @xmath203 .",
    "since @xmath203 has the least preferred object among all clones of @xmath13 , it points to any object that @xmath206 points to .",
    "since @xmath206 points to the object of @xmath207 , this means that @xmath203 strictly prefers the object of @xmath207 over his own object . by the same argument , @xmath203 strictly prefers each object owned by the clones of @xmath68 in the trading cycle .",
    "since at least one clone of @xmath68 points to the object of @xmath203 , we have shown that there exist @xmath195 such that @xmath20 is allocated to @xmath13 , @xmath165 is allocated to @xmath68 , @xmath196 and @xmath197 .",
    "we use lemma  [ lemma : cycle2 ] to obtain the following proposition .",
    "[ prop : lpo ] the gal outcome is lpo .    let us constrain ourselves to the set of objects @xmath208 that are allocated to agents @xmath100 and @xmath101 .",
    "now let @xmath209 be the cloned assignment problem .",
    "then assignment @xmath28 for objects in @xmath64 is po iff the corresponding assignment is po for @xmath209 .",
    "now assume that the gal outcome is not lpo .",
    "then the assignment with respect to @xmath64 is not po . by lemma  [ lemma : cycle2 ]",
    ", there exists @xmath97 such that @xmath13 gets @xmath20 in some round @xmath210 , @xmath196 where @xmath165 was allocated to @xmath68 and @xmath197 .",
    "this means that @xmath165 was allocated to @xmath13 in round @xmath211 .",
    "now if @xmath212 , then @xmath20 would be a higher priority object for @xmath68 so that it would not have gone for @xmath165 before @xmath20",
    ". then it must be that @xmath213 .",
    "but , if @xmath213 , then @xmath20 would again be a higher priority object for @xmath68 so that it would not have gone for @xmath165 before @xmath20 .",
    "hence a contradiction .",
    "in proposition  [ prop : lpo ] , we showed that there exists no other ( not necessarily ef ) assignment that uses the same objects as the gal outcome and is pareto improvement over the gal outcome .",
    "next we show that there exists no other ef assignment that may use any objects and is a pareto improvement over the gal outcome .",
    "[ prop : sd - dominate ] gal returns an assignment such that there exists no other assignment that pareto dominates it and is envy - free .",
    "assume for contradiction that gal s outcome @xmath28 is sd - dominated by another ef assignment @xmath29 such that @xmath37 for both @xmath13 and @xmath38 for at least one @xmath13 .",
    "we now proceed in rounds where in each round we check the highest priority allocated object of each of the two agents that have not been checked .",
    "we check the partial assignments @xmath214 and @xmath215 in each round @xmath210 to see whether @xmath216 .",
    "let us assume that @xmath216 and @xmath217 for the smallest possible @xmath210 .",
    "if both @xmath216 and @xmath218 , then it means that in @xmath29 both get higher priority objects than @xmath28 in that round . this is a contradiction as gal would allocated these higher priority objects to the agents .",
    "now assume that @xmath216 and @xmath219 .",
    "this means that agent @xmath68 gets an equally preferred object and the other agent @xmath13 gets a higher priority object .",
    "but this is again a contradiction , because gal would have allocated the more preferred object to @xmath13 in that round .",
    "note that for the case of two agents , @xcite presented a polynomial time algorithm to check whether a complete sd - envy - free assignment exists or not . in order to compute a maximal sd envy - free assignment",
    ", one can consider different subsets @xmath220 and check whether a complete sd - envy - free assignment exists or not for @xmath64 .",
    "however this approach would require checking exponential number of subsets .",
    "we have already shown that gal satisfies the desirable properties of al on a more general domain .",
    "next , we show that under strict preferences gal returns an assignment that is a possible outcome of al . in this sense , gal is a ` proper ' generalization of al .    for strict preferences ,",
    "gal returns an al outcome .    for strict preferences",
    ", there exists a unique priority order irrespective of any lexicographical tie - breaking order .",
    "we show that under strict preferences , gal and al handle all the cases in an equivalent manner .",
    "let us compare the formal definition of al ( page 133 - 134 * ? ? ?",
    "* ) with the pseudocode of gal . in al , in stage @xmath210 , the direction `` if one unallocated item remains , place it in cp and stop '' is equivalent to steps [ step : o=1 ] and [ stepb : o=1 ] of algorithm  [ algo : gal ] .    in al , in stage @xmath210 , the direction",
    "`` if no unallocated items remain , stop . ''",
    "is equivalent to the stopping condition in the while loop of algorithm  [ algo : gal ] .",
    "if both agents have different most preferred ( equivalent to highest priority since the preferences are strict ) unallocated objects , then both gal and al behave in the same manner and give the most preferred objects to the agents . for al this direction",
    "is specified in the last sentence of the stage @xmath221 .",
    "finally , both algorithms have a check for when both agents have the same most preferred objects with this check being in step @xmath222 in the specification of the al method . in al , the most preferred available contested object @xmath13",
    "is tentatively given to the one of the agents .",
    "in the specification of algorithm  [ algo : gal ] , the most preferred available object is also tentatively given to one of the agents .",
    "since , in algorithm  [ algo : gal ] , this object is referred to as @xmath105 so we will refer it as @xmath105 for both algorithms .",
    "let us say agent who gets it is agent @xmath68 .",
    "the other agent @xmath13 is tentatively given the next most preferred object that is not yet allocated . in the description of al , @xmath13 could be given an even less preferred unallocated object but in at least one instantiations of al , @xmath13 is tentatively given the next most preferred object that is still available . according to al ,",
    "such a tentative assignment is _ feasible _ as long as the number of objects assigned to @xmath68 including @xmath105 or put in the contested pile ( `` unassigned '' ) that @xmath13 prefers to the next most preferred unallocated object is at most @xmath210 .",
    "this means that for the tentative assignment @xmath28 , @xmath223 . since agent @xmath13 s allocation from the previous round consists of objects strictly preferred over @xmath105",
    ", this means that @xmath13 is not envious of @xmath68 in @xmath28 as long as @xmath13 was not envious of @xmath68 in the previous round .",
    "thus in both algorithms , the tentative assignment in which the contested object is given to agent @xmath68 and the next most preferred unallocated object is given to agent @xmath13 is made permanent if the modification does not cause envy .",
    "hence the feasibility check in the case of al is equivalent to checking whether the tentative new assignment is ef .",
    "if the tentative assignment is not ef for @xmath105 given to either of the two agents , then gal puts @xmath105 in the contested pile .",
    "similarly , al puts the object in the contested pile ( step @xmath224 ) .",
    "in this paper , we presented gal that is a generalization of the al method of @xcite for the fair allocation of indivisible objects among two agents . a crucial advantage of extending al to gal is for the case in which agents have identical preferences . if agents have strict and identical preferences , then al assigns all the objects to the contested pile . however",
    "if the preferences are really coarse , such as when all objects are equally preferred , then gal assigns @xmath225 to each agent .",
    "previous algorithms to solve this problem take time @xmath9 and require solving network flow or maximum matching problems  @xcite .",
    "gal is specifically designed for the case of two agents .",
    "this raises the question whether gal can be generalized to the case of arbitrary number of agents .",
    "assume there exists an algorithm @xmath226 that returns a maximal envy - free assignment that is complete if a complete envy - free assignment exists .",
    "then @xmath226 does not take polynomial time assuming @xmath227 .",
    "@xcite proved that checking whether there exists a complete ef assignment is np - complete for strict preferences .",
    "@xcite proved that checking whether there exists a complete ef assignment is np - complete for dichotomous preferences .",
    "if @xmath226 is polynomial - time , then it can be used to compute a maximal ef assignment .",
    "if the assignment is complete , we know that there exists a complete ef assignment . if the assignment is not complete , we know by proposition  [ prop - complete ] that there does not exist a complete ef assignment . hence a polynomial - time algorithm to compute a maximal ef assignment",
    "can solve an np - complete problem in polynomial time .",
    "gal can also be seen as a discrete version of the _ probabilistic serial ( ps ) algorithm _  @xcite that is used to compute a fractional assignment .",
    "ps is sd - efficient and sd - envy - free . in other words , ps returns a maximal fractional assignment that is both sd - efficient and sd - envy - free . in the randomized",
    "setting , there is always a complete assignment that satisfies both properties .",
    "similarly , a gal outcome is a maximal discrete assignment that is both sd - efficient and sd - envy - free .",
    "if we restrict ourselves to discrete assignments , then there may not exist a complete and envy - free assignment .    in this paper",
    ", we assumed that all objects are acceptable .",
    "the case where some objects may be unacceptable to an agent can be handled .",
    "if an object is unacceptable to both agents , it can be discarded from the outset .",
    "if an object is only acceptable to one agent , it will only be given to that agent .",
    "the author thanks steven brams for sharing the paper on the al method with him .",
    "he also appreciates sajid aziz , steven brams and christian klamler for their useful feedback .",
    "nicta is funded by the australian government through the department of communications and the australian research council through the ict centre of excellence program .",
    "d.  j. abraham , k.  cechlrov , d.  manlove , and k.  mehlhorn .",
    "pareto optimality in house allocation problems . in _ proceedings of the 16th international symposium on algorithms and computation ( isaac ) _ ,",
    "volume 3341 of _ lecture notes in computer science ( lncs ) _ , pages 11631175 , 2005 .",
    "h.  aziz , f.  brandt , and m.  brill . on the tradeoff between economic efficiency and strategyproofness in randomized social choice . in _ proceedings of the 12th international conference on autonomous agents and multi - agent systems ( aamas )",
    "_ , pages 455462 .",
    "ifaamas , 2013 .",
    "h.  aziz , s.  gaspers , s.  mackenzie , and t.  walsh .",
    "fair assignment of indivisible objects under ordinal preferences . in _ proceedings of the 13th international conference on autonomous agents and multi - agent systems ( aamas )",
    "_ , pages 13051312 , 2014 .",
    "s.  bouveret , u.  endriss , and j.  lang .",
    "fair division under ordinal preferences : computing envy - free allocations of indivisible goods . in _ proceedings of the 19th european conference on artificial intelligence ( ecai ) _ , pages 387392 , 2010 .",
    "s.  bouveret , y.  chevaleyre , and n.  maudet .",
    "fair allocation of indivisible goods . in f.",
    "brandt , v.  conitzer , u.  endriss , j.  lang , and a.  d. procaccia , editors , _ handbook of computational social choice _",
    ", chapter  12 .",
    "cambridge university press , 2015 .",
    "s.  j. brams and p.  c. fishburn .",
    "fair division of indivisible items between two people with identical preferences : envy - freeness , pareto - optimality , and equity .",
    "_ social choice and welfare _ , 17:0 247267 , 2000 .",
    "s.  j. brams and t.  r. kaplan . dividing the indivisible procedures for allocating cabinet ministries to political parties in a parliamentary system .",
    "_ journal of theoretical politics _ , 160 ( 2):0 143173 , 2004 .",
    "y.  chevaleyre , p.  e. dunne , u.  endriss , j.  lang , m.  lematre , n.  maudet , j.  padget , s.  phelps , j.  a. rodrguez - aguilar , and p.  sousa .",
    "issues in multiagent resource allocation .",
    "_ informatica _ , 30:0 331 , 2006 .      b.  de keijzer , s.  bouveret , t.  klos , and y.  zhang . on the complexity of efficiency and envy - freeness in fair division of indivisible goods with additive preferences . in",
    "_ proceedings of the 1st international conference on algorithmic decision theory _ , pages 98110 , 2009 .",
    "j.  p. dickerson , j.  goldman , j.  karp , a.  d. procaccia , and t.  sandholm .",
    "the computational rise and fall of fairness . in _ proceedings of the 28th aaai conference on artificial intelligence ( aaai ) _ , pages 14051411 .",
    "aaai press , 2014 .",
    "k.  iwama and s.  miyazaki .",
    "a survey of the stable marriage problem and its variants . in _ proceedings of the international conference on informatics education and research for knowledge - circulating society _ , pages 131136 .",
    "ieee computer society , 2008 .",
    "r.  j. lipton , e.  markakis , e.  mossel , and a.  saberi . on approximately fair allocations of indivisible goods . in _ proceedings of the 5th acm conference on electronic commerce ( acm - ec ) _",
    ", pages 125131 .",
    "acm press , 2004 .",
    "d.  saban and j.  sethuraman .",
    "house allocation with indifferences : a generalization and a unified view . in _ proceedings of the 14th acm conference on electronic commerce ( acm - ec ) _ , pages 803820 .",
    "acm press , 2013 ."
  ],
  "abstract_text": [
    "<S> we consider the assignment problem in which agents express ordinal preferences over @xmath0 objects and the objects are allocated to the agents based on the preferences . in a recent paper , </S>",
    "<S> brams , kilgour , and klamler ( 2014 ) presented the al method to compute an envy - free assignment for two agents . </S>",
    "<S> the al method crucially depends on the assumption that agents have strict preferences over objects . </S>",
    "<S> we generalize the al method to the case where agents may express indifferences and prove the axiomatic properties satisfied by the algorithm . as a result of the generalization </S>",
    "<S> , we also get a @xmath1 speedup on previous algorithms to check whether a complete envy - free assignment exists or not . finally , we show that unless p = np , there can be no polynomial - time extension of gal to the case of arbitrary number of agents .    </S>",
    "<S> * jel classification * : c70 @xmath2 d61 @xmath2 d71 </S>"
  ]
}