{
  "article_text": [
    "scheduling on unrelated machines to minimize the makespan is one of the classical problem in optimization ; here , we are given a set of @xmath2 jobs and @xmath3 machines , such that execution of a job @xmath4 on machine @xmath5 takes time @xmath6 .",
    "the objective is to find a schedule , i.e. an assignment @xmath7 of the jobs to the machines that minimizes the _ makespan _ @xmath8 .    despite its formal simplicity ,",
    "it is still not understood completely : no approximation result is known that is asymptotically better than the seminal @xmath9-approximation of lenstra , shmoys and tardos  @xcite , with asymptotical improvements made by vakhania and shechpin  @xcite ; however , the known lower bound on approximability is only @xmath0 , also due to lenstra , shmoys and tardos .",
    "a seemingly simpler problem is that of _ assignment restrictions _ : here , for every job @xmath4 we have a length @xmath10 and a set @xmath11 of _ feasible machines _ , i.e. we have @xmath12 for all @xmath13 and @xmath14 for all @xmath15 .    [ [ related - results ] ] related results + + + + + + + + + + + + + + +    as shown already by lenstra et al .",
    "@xcite , scheduling with arbitrary assignment restrictions is also impossible to approximate better than within a factor of @xmath0 , unless @xmath16 , and for the general case , no algorithm better than the @xmath9-approximation for the unrelated machine case is known .",
    "however , better results are known for special structures of the sets @xmath17 .",
    "if we have @xmath18 , we can think of jobs as edges in a graph whose vertices are the machines , and orienting the edge in one direction will increase the load of one of its endpoints . in this _",
    "graph balancing _ setting , ebenlendr et al .",
    "@xcite give a @xmath19-approximation .",
    "if the graph additionally a tree , lee et al .  @xcite give an fptas .",
    "another type of restriction studied is that of the relation between the @xmath17 sets : the most recent results being a ptas by muratore et al .",
    "@xcite for the case of nested restrictions , i.e. for each two @xmath20 , one of @xmath21 , @xmath22 or @xmath23 holds , and a @xmath1-approximation for tree - hierarchical assignment restrictions by huo and leung  @xcite . in this",
    "setting , again machines are considered vertices of a graph , a rooted tree in particular , and we impose that the sets @xmath17 must correspond to the machines on a path from a node to the root .",
    "for older results , we refer the reader to the survey  @xcite by leung and li .",
    "[ [ contribution - of - this - note . ] ] contribution of this note .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    we consider the tree - hierarchical assignment case by huo and leung and prove the following result :    scheduling with tree - hierarchical assignment restrictions admits a ptas , i.e. for every @xmath24 there is an @xmath25-approximation with running time polynomial in the input size ( but exponential in @xmath26 ) .",
    "our algorithm combines some of the usual techniques for ptas design such as partition into job sizes and geometric rounding with a hierarchical dynamic programming approach bottom - up through the tree . in this section",
    ", we describe the rounding and simplification steps we take to make the problem treatable by dynamic programming .    throughout the following ,",
    "let @xmath24 . to simplify the analysis ,",
    "our algorithm will create a solution of length at most @xmath27 times the optimal value @xmath28 .",
    "( for simplicity , we use @xmath28 to refer to both an optimal schedule and its makespan , since the distinction is clear from context . )",
    "note @xmath28 must be integral since all jobs lengths are , and it is bounded pseudopolynomially in the instance size , for example by @xmath29 . hence we may , in polynomial time , perform binary search over the range of feasible makespans and it is sufficient to give a relaxed decision procedure that for a guessed target makespan @xmath30 yields a schedule of length at most @xmath31 whenever a schedule of length at most @xmath30 exists .    in the following , we call a job _ small _ if @xmath32 , otherwise , we call it large",
    ". we will round up every large job to be of the form @xmath33 for integral @xmath34 .",
    "the number @xmath35 of values @xmath34 that can occur only depends on @xmath36 , i.e. it is a constant for purposes of running time .",
    "the following classical result holds for this rounding :    if there is a schedule of length @xmath30 of the original instance , there exists a schedule of the rounded instance with a constant number @xmath37 of large job sizes which has length at most @xmath38 .",
    "it is also clear that a feasible schedule of the rounded instance is feasible for the original instance by replacing rounded large jobs with their ( possibly slightly smaller ) unrounded counterparts .",
    "we now want to approximately describe every subset of the rounded instance by a @xmath39-element _ configuration tuple_. for large jobs , we simply count the number of jobs of each job size , which must be in @xmath40 . for small jobs , we count the total space taken up by them , in integral multiples of @xmath41 , rounding up . since every small job has size @xmath42 , the total size of all small jobs is at most @xmath43 , so this size indicator for small jobs is also from the set @xmath40 . in total , the number of configuration tuples is at most @xmath44 , in particular , it is polynomial in the input size .",
    "we can in this way associate with each node @xmath45 in the tree the configuration tuple @xmath46 of jobs",
    "@xmath4 whose set @xmath17 is the path starting in @xmath45 .",
    "if @xmath47 is the size multiplicity of the small jobs among them , i.e. their total size is in the interval @xmath48(s_v-1)\\cdot\\epsilon c ,    s_v\\cdot\\epsilon c]$ ] , we add up to one dummy job of size up to @xmath49 to make the total size exactly @xmath50 . by leaving that job on machine @xmath45 in the schedule , we obtain    if there is a schedule of length at most @xmath51 in the rounded instance , there is a schedule of length at most @xmath52 in the rounded and modified instance .",
    "let us now consider such a schedule @xmath53 of length at most @xmath54 . on every machine ( node ) @xmath45 , a certain subset @xmath55 of jobs is scheduled .",
    "hence , it has a corresponding configuration tuple associated with it , the total size of which is at most @xmath56 .",
    "the additional loss is again incurred because the small jobs in @xmath55 might not be an integral multiple of @xmath41 .",
    "it is these configurations that we will find by dynamic programming .",
    "in this section , we describe how to find a feasible assignment of configuration tuples to machines , if it exists , and how to convert this back into a schedule with a small increase in makespan .",
    "the core of our algorithm is a local procedure which works as follows for a node @xmath45 :    1 .   in the first step ,",
    "we accumulate the possible subsets of not - yet - scheduled jobs that @xmath45 may need to accept from its children .",
    "we maintain a set of possible subset configuration tuples @xmath57 , which initially contains only the all - zero tuple .",
    "then , for each child of @xmath45 in turn , we consider the set @xmath58 of tuples it pushes towards the root and set @xmath59 . since the size of @xmath57 and @xmath58 is always polynomial , this can be done in polynomial time for every child , and since there are at most @xmath2 children , finding the ultimate @xmath57 with all children taken into account also takes polynomial time",
    "then , we augment @xmath57 by adding to each tuple the tuple @xmath46 of jobs that are only available for scheduling on @xmath45 and its ancestors .",
    "the resulting set , which we still denote @xmath57 , still has polynomial size .",
    "3 .   for each @xmath60",
    ", we consider every possible subconfiguration @xmath61 that can be scheduled on @xmath45 , i.e. is of total size at most @xmath56 .",
    "then , the relative complement @xmath62 corresponds to jobs that would need to be pushed towards @xmath45 s parent node if we schedule according to @xmath63 on @xmath45 .",
    "again , since @xmath57 is polynomially bounded and the number of possible @xmath63 is as well , this can be done in polynomial time and yields a polynomially - sized set of configurations that are possibly pushed upwards .    our algorithm , for a given target makespan @xmath30 , will execute this procedure in any leaf - to - root order , i.e. it is always run on the children of a node before it is run on the node itself .",
    "we return that a feasible schedule exists if it is possible to push up the all - zero configuration tuple from the root .",
    "the configuration tuples themselves can be obtained by standard bookkeeping techniques , i.e. storing , for each sum - of - configurations configuration that occurs one ( and only one ) set of witness summands .",
    "clearly , if there is a feasible assignment of configurations to machines of length at most @xmath56 , the algorithm will find one , too , since all configuration tuples that can be pushed into a node are considered .    to complete the proof of",
    ", it remains to show how to assign the jobs .",
    "this is trivial for large jobs : we select feasible jobs of that size in an arbitrary fashion bottom - up , pushing the remainder upwards .",
    "since nothing is pushed beyond the root , all large jobs are assigned .",
    "the situation for small jobs is slightly more complicated , since we do not know the exact total size of the small jobs .",
    "however , we can simply fill the available space in a greedy manner until it is fully used ( or we run out of small jobs ) , i.e. the last small job may protude beyond the allotted size . since the last job s size is at most @xmath41 by definition , this will increase the makespan of the schedule we generate by another @xmath64 to at most @xmath31 , and it will at most decrease the total size of small jobs pushed towards the root , which clearly maintains feasibility of the remaining configurations .",
    "this note shows another case , tree - hierarchical structures , in which scheduling with assignment restrictions can be approximated within arbitrary accuracy .",
    "this mostly settles the complexity : an fptas can not exist since the setting generalizes the strongly @xmath65-hard problem @xmath66 , the existance of an eptas is still open .    for other important settings ,",
    "the question of inapproximability vs. ptas is still open : in particular , two natural cases would be _ cross - free families _",
    ", where for two sets @xmath20 , @xmath67 may also occur in addition to the three cases defining nested families as given in the introduction , and _ interval _ restrictions , where every @xmath17 is of the form @xmath68 for a fixed permutation of the machines ."
  ],
  "abstract_text": [
    "<S> scheduling with assignment restrictions is an important special case of scheduling unrelated machines which has attracted much attention in the recent past . </S>",
    "<S> while a lower bound on approximability of @xmath0 is known for its most general setting , subclasses of the problem admit polynomial - time approximation schemes . </S>",
    "<S> this note provides a ptas for tree - like hierarchical structures , improving on a recent @xmath1-approximation by huo and leung  @xcite .    </S>",
    "<S> = 1 </S>"
  ]
}