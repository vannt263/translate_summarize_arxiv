{
  "article_text": [
    "energy efficiency is always a primary concern for chip designers not only for the sake of prolonging the lifetime of batteries which are the major power supply of portable electronic devices but also for the environmental protection purpose when large facilities like data centers are involved .",
    "currently , processors capable of operating at a range of frequencies are already available , such as intel s speedstep technology and amd s powernow technology .",
    "the capability of the processor to change voltages is often referred to in the literature as dvs ( dynamic voltage scaling ) techniques . for dvs processors ,",
    "since energy consumption is at least a quadratic function of the supply voltage ( which is proportional to cpu speed ) , it saves energy to let the processor run at the lowest possible speed while still satisfying all the timing constraints , rather than running at full speed and then switching to idle .",
    "one of the earliest theoretical models for dvs was introduced by yao , demers and shenker @xcite in 1995 .",
    "they assumed that the processor can run at any speed and each job has an arrival time and a deadline .",
    "they gave a characterization of the minimum - energy schedule ( mes ) and an @xmath6 algorithm for computing it which is later improved to @xmath0 by @xcite .",
    "no special assumption was made on the power consumption function except convexity .",
    "several online heuristics were also considered including the average rate heuristic ( avr ) and optimal available heuristic ( opa ) . under the common assumption of power function @xmath7 , they showed that avr has a competitive ratio of @xmath8 for all job sets .",
    "thus its energy consumption is at most a constant times the minimum required .",
    "later on , under various related models and assumptions , more algorithms for energy - efficient scheduling have been proposed .",
    "bansal et al .",
    "@xcite further investigated the online heuristics for the model proposed by @xcite and proved that the heuristic opa has a tight competitive ratio of @xmath9 for all job sets .",
    "for the temperature model where the temperature of the processor is not allowed to exceed a certain thermal threshold , they showed how to solve it within any error bound in polynomial time .",
    "recently , bansal et al .",
    "@xcite showed that the competitive analysis of avr heuristic given in @xcite is essentially tight .",
    "quan and hu @xcite considered scheduling jobs with fixed priorities and characterized the optimal schedule through transformations to mes @xcite .",
    "yun and kim @xcite later on showed the np - hardness to compute the optimal schedule .",
    "pruhs et al .",
    "@xcite studied the problem of minimizing the average flow time of a sequence of jobs when a fixed amount of energy is available and gave a polynomial time offline algorithm for unit - size jobs .",
    "bunde @xcite extended this problem to the multiprocessor scenario and gave some nice results for unit - size jobs .",
    "chan et al .",
    "@xcite investigated a slightly more realistic model where the maximum speed is bounded .",
    "they proposed an online algorithm which is @xmath10-competitive in both energy consumption and throughput .",
    "more work on the speed bounded model can be found in @xcite@xcite@xcite .",
    "ishihara and yasuura @xcite initiated the research on discrete dvs problem where a cpu can only run at a set of given speeds .",
    "they solved the case when the processor is only allowed to run at two different speeds .",
    "kwon and kim @xcite extended it to the general discrete dvs model where the processor is allowed to run at speeds chosen from a finite speed set .",
    "they gave an @xmath6 algorithm for this problem based on the mes algorithm in @xcite , which is later improved in @xcite to @xmath11 where @xmath5 is the allowed number of speeds .",
    "when the cpu can only change speed gradually instead of instantly , @xcite discussed about some special cases that can be solved optimally in polynomial time .",
    "later , wu et al .",
    "@xcite extended the polynomial solvability to jobs with agreeable deadlines .",
    "irani et al . @xcite investigated an extended scenario where the processor can be put into a low - power sleep state when idle .",
    "a certain amount of energy is needed when the processor changes from the sleep state to the active state .",
    "the technique of switching processors from idle to sleep and back to idle is called dynamic power management ( dpm ) which is the other major technique for energy efficiency .",
    "they gave an offline algorithm that achieves 2-approximation and online algorithms with constant competitive ratios .",
    "recently , albers and antoniadis @xcite proved the np - hardness of the above problem and also showed some lower bounds of the approximation ratio .",
    "pruhs et al .",
    "@xcite introduced profit into dvs scheduling .",
    "they assume that the profit obtained from a job is a function on its finishing time and on the other hand money needs to be paid to buy energy to execute jobs .",
    "they give a lower bound on how good an online algorithm can be and also give a constant competitive ratio online algorithm in the resource augmentation setting . a survey on algorithmic problems in power management for dvs by irani and pruhs",
    "can be found in @xcite .",
    "most recent surveys by albers can be found in @xcite@xcite .    in @xcite",
    ", the authors showed that the optimal schedule for tree structured jobs can be computed in @xmath2 time . in this paper , we prove that the optimal schedule for general jobs can also be computed in @xmath2 time , improving upon the previously best known @xmath0 result @xcite .",
    "the remaining paper is organized as follows .",
    "section 2 will give the problem formulation . section 3",
    "will discuss the linear implementation of an important tool  the s - schedule used in the algorithm in @xcite .",
    "then we use the linear implementation to improve the calculation of the optimal schedule in section 4 . in section 5 , we give improvements in the computation complexity of the optimal schedule for the discrete model . finally , we conclude the paper in section 6 .",
    "we consider the single processor setting .",
    "a job set @xmath12 over @xmath13 $ ] is given where each job @xmath14 is characterized by three parameters : arrival time @xmath15 , deadline @xmath16 , and workload @xmath17 . here",
    "workload means the required number of cpu cycles .",
    "we also refer to @xmath18\\subseteq [ 0,1]$ ] as the interval of @xmath14 .",
    "a _ schedule _",
    "@xmath19 for @xmath20 is a pair of functions @xmath21 which defines the processor speed and the job being executed at time @xmath22 respectively .",
    "both functions are assumed to be piecewise continuous with finitely many discontinuities .",
    "a _ feasible _",
    "schedule must give each job its required workload between its arrival time and deadline with perhaps intermittent execution .",
    "we assume that the power @xmath23 , or energy consumed per unit time , is @xmath7 ( @xmath24 ) where @xmath25 is the processor speed . the total energy consumed by a schedule",
    "@xmath19 is @xmath26 .",
    "the goal of the min - energy feasibility scheduling problem is to find a feasible schedule that minimizes @xmath27 for any given job set @xmath20 .",
    "we refer to this problem as the continuous _ dvs _ scheduling problem .    for the continuous dvs scheduling problem ,",
    "the optimal schedule @xmath28 is characterized by using the notion of a _",
    "critical interval _ for @xmath20 , which is an interval @xmath29 in which a group of jobs must be scheduled at maximum constant speed @xmath30 in any optimal schedule for @xmath20 .",
    "the algorithm mes in @xcite proceeds by identifying such a critical interval @xmath29 , scheduling those critical jobs at speed @xmath30 over @xmath29 , then constructing a subproblem for the remaining jobs and solving it recursively .",
    "the details are given below .",
    "for any interval @xmath31 $ ] , we use @xmath32 to denote the subset of jobs in @xmath20 whose intervals are completely contained in @xmath29 .",
    "the intensity of an interval @xmath29 is defined to be @xmath33 .",
    "an interval @xmath34 achieving maximum @xmath30 over all possible intervals @xmath29 defines a critical interval for the current job set .",
    "it is known that the subset of jobs @xmath35 can be feasibly scheduled at speed @xmath36 over @xmath34 by the earliest deadline first ( edf ) principle .",
    "that is , at any time @xmath22 , a job which is waiting to be executed and having earliest deadline will be executed during @xmath37 $ ] .",
    "the interval @xmath34 is then removed from @xmath13 $ ] ; all the remaining job intervals @xmath18 $ ] are updated to reflect the removal , and the algorithm recurses .",
    "we denote the optimal schedule which guarantees feasibility and consumes minimum energy in the continuous dvs model as _ opt_.    the authors in @xcite later observed that in fact the critical intervals do not need to be located one after another .",
    "instead , one can use a concept called @xmath25-schedule defined below to do bipartition on jobs which gradually approaches the optimal speed curve .    for any constant @xmath25 ,",
    "the @xmath25-schedule for @xmath20 is an edf schedule which uses a constant speed @xmath25 in executing any jobs of @xmath20",
    ". it will give up a job when the deadline of the job has passed . in general , @xmath25-schedules may have idle periods or unfinished jobs .    in a schedule @xmath19 , a maximal subinterval of @xmath13 $ ] devoted to executing the same job @xmath14",
    "is called an execution interval for @xmath14 ( with respect to @xmath19 ) .",
    "denote by @xmath38 the union of all execution intervals for @xmath14 with respect to @xmath19 .",
    "execution intervals with respect to the @xmath25-schedule will be called @xmath25-execution intervals .",
    "it is easy to see that the @xmath25-schedule for @xmath1 jobs contains at most @xmath39 @xmath25-execution intervals , since the end of each execution interval ( including an idle interval ) corresponds to the moment when either a job is finished or a new job arrives .",
    "also , the @xmath25-schedule can be computed in @xmath40 time by using a priority queue to keep all jobs currently available , prioritized by their deadlines . in the next section",
    ", we will show that the @xmath25-schedule can be computed in linear time .",
    "in this work , we assume that the underlying computational model is the unit - cost ram model with word size @xmath41 . this model is assumed only for the purpose of using a special union - find algorithm by gabow and tarjan @xcite .",
    "[ lemma : s - schedule ] if for each @xmath42 , the rank of @xmath15 in @xmath43 and the rank of @xmath16 in @xmath44 are pre - computed , then the @xmath25-schedule can be computed in linear time in the unit - cost ram model .",
    "we make the following two assumptions :    * the jobs are already sorted according to their deadlines ; * for each job @xmath14 , we know the rank of @xmath15 in the arrival time set @xmath45 .    because of the first assumption and without loss of generality , we assume that @xmath46 . algorithm [ algo : naive ] schedules the jobs in the order of their deadlines .",
    "when scheduling job @xmath42 , the algorithm tries to search for an earliest available time interval and schedule the job in it , and then repeat the process until all the workload of the job is scheduled or unable to find such a time interval before the deadline .",
    "a more detailed discussion of the algorithm is given below .",
    "initialize @xmath47 for @xmath48 .",
    "let @xmath49 be @xmath50 .",
    "note that the times `` @xmath51 '' and `` @xmath52 '' ( where @xmath53 is any fixed positive constant ) are included in @xmath49 for simplifying the presentation of the algorithm .",
    "denote the size of @xmath49 by @xmath54 .",
    "denote @xmath55 to be the @xmath56-th smallest element in @xmath49 .",
    "note that the rank of any @xmath15 in @xmath49 is known . during the running of the algorithm",
    ", we will maintain the following data structure :    for each @xmath57 , the algorithm maintains a value @xmath58 , whose value is in the range @xmath59 $ ] .",
    "the meaning of @xmath58 is that : the time interval @xmath60 is fully occupied by some jobs , and the time interval @xmath61 is idle .",
    "if @xmath62 is fully occupied , then @xmath58 is @xmath63 .",
    "note that such a time @xmath58 always exists during the running of the algorithm , which will be shown later when we discuss how to maintain @xmath58 . at the beginning of the algorithm",
    ", we assume that the processor is idle for the whole time period .",
    "that means @xmath64 for @xmath48 ( see line [ line : inite ] of algorithm [ algo : naive ] ) .",
    "an example for demonstrating the usage of the @xmath58 data structure is given below : assume that @xmath65 . at some point during the execution of the algorithm ,",
    "if some jobs have been scheduled to run at time intervals @xmath66 , then we will have @xmath67 , @xmath68 , @xmath69 , @xmath70 , @xmath71 , @xmath72 , @xmath73 , @xmath74 , @xmath75 , and @xmath76 .",
    "before we analyze the algorithm , we need to define an important concept called .    during the running of the algorithm ,",
    "a canonical time interval is a time interval of the form @xmath77 , where @xmath78 .",
    "when @xmath79 , we call it an empty canonical time interval .    note that a non - empty canonical time interval is always idle based on the definition of @xmath80 . any arrival time @xmath15 will not lie inside any canonical time interval but it is possible that @xmath15 will touch any of the two ending points , i.e. , for any @xmath81 , we have either @xmath82 or @xmath83 . therefore ,",
    "if we want to search for a time interval to run a job at or after time @xmath15 , then we should always look for the earliest non - empty canonical time interval @xmath84 where @xmath85 .    in algorithm [ algo : naive ] , a variable @xmath86 is used to track the workload to be scheduled .",
    "lines [ line : beginwhile]-[line : endwhile ] try to schedule @xmath14 as early as possible if @xmath87 .",
    "line [ line : findearliest ] tries to search for an earliest canonical time interval @xmath77 no earlier than the arrival time of @xmath14 ( i.e. , @xmath85 ) .",
    "such a @xmath88 always exists because there is always a non - empty canonical time interval @xmath89 .",
    "line [ line : deadlinecheck : begin]-[line : deadlinecheck : end ] means that , if @xmath80 is not earlier than the deadline of @xmath14 , then the job can not be finished .",
    "line [ line : setu ] sets a value of @xmath90 , whose meaning is that @xmath91 can be used to schedule the job .",
    "the value of @xmath90 is no later than the deadline of @xmath14 .",
    "lines [ line : schedule1]-[line : updater1 ] process the case when the remaining workload of @xmath14 can not be finished in the time interval @xmath92 . lines [ line : schedule2]-[line : updater2 ] process the case when the remaining workload of @xmath14 can be finished in the time interval @xmath91 . in the first case ,",
    "line [ line : updatee1 ] updates @xmath93 to @xmath90 because the time interval @xmath94 is occupied and @xmath95 is idle . in the second case , a time of @xmath96 is occupied by @xmath14 after the time @xmath93 , so @xmath93 is increased by @xmath96 .",
    "following the example provided in the previous example , assume that the speed is @xmath97 , if we are to schedule a job @xmath14 , where @xmath98 , the algorithm will proceed as follows : at the beginning , @xmath86 will be initialized to @xmath99 , and @xmath100 ( because @xmath101 ; see line [ line : set_i ] ) .",
    "line [ line : findearliest ] will then get the interval @xmath102 as an earliest non - empty canonical time interval , and a workload of @xmath103 is scheduled at that time interval .",
    "the values of @xmath104 will be updated to @xmath105 accordingly .",
    "now , @xmath86 becomes @xmath106 , and line [ line : findearliest ] will get the time interval @xmath107 to schedule the job . after that @xmath86 becomes @xmath108 , and @xmath109 .",
    "line [ line : findearliest ] then gets the time interval @xmath110 to schedule the job , and @xmath86 will be further reduced to @xmath111 .",
    "the values of @xmath112 will be updated to @xmath113 .",
    "the next time interval found will be @xmath114 , and @xmath86 will become @xmath115 .",
    "the values of @xmath116 will be updated to @xmath117 .",
    "the remaining earliest non - empty canonical time interval is @xmath118 , but the deadline of the job is @xmath119 , so only @xmath120 will be used to schedule the job , and @xmath86 will be @xmath121 .",
    "the value of @xmath122 is then updated to @xmath119 .",
    "finally , @xmath123 is the remaining earliest non - empty canonical time interval , but @xmath124 , so line [ line : deadlinecheck : begin]-[line : deadlinecheck : end ] will break the loop , and @xmath14 will be an unfinished job .",
    "a graphical illustration is provided in figure [ figure1 ] .",
    "the solid rectangles represent the time intervals occupied by some jobs before scheduling @xmath14 .",
    "the cross - hatched rectangles represent the time intervals that are used to schedule @xmath14 .",
    "the @xmath125-th cross - hatched rectangle ( where @xmath126 ) is the @xmath125-th time interval scheduled according to this example . note that all the cross - hatched rectangles except the @xmath127-th one are canonical time intervals right before scheduling @xmath14 .",
    "the most critical part of the algorithm is line [ line : findearliest ] , which can be implemented efficiently by the following folklore method using a special union - find algorithm developed by gabow and tarjan @xcite ( see also the discussion of the decremental marked ancestor problem @xcite ) . at the beginning , there is a set @xmath128 for each @xmath48 .",
    "the name of a set is the largest element of the set .",
    "whenever @xmath80 is updated to @xmath129 ( i.e. , there is not any idle time in the interval @xmath130 ) , we make a union of the set containing @xmath88 and the set containing @xmath131 , and set the name of this set to be the name of the set containing @xmath131 . after the union",
    ", the two old sets are destroyed . in this way ,",
    "a set is always an interval of integers . for a set whose elements are @xmath132",
    ", the semantic meaning is that , @xmath133 is fully scheduled but @xmath84 is idle .",
    "therefore , to search for an earliest non - empty canonical time interval beginning at or after time @xmath55 , we can find the set containing @xmath56 , and let @xmath88 be the name of the set , then @xmath84 is the required time interval .",
    "an example of the above union - find process for scheduling @xmath14 in the previous example is given below : before scheduling @xmath14 , we have the sets @xmath134 , @xmath135 , @xmath136 , @xmath137 , @xmath138 , @xmath139 , @xmath140 .",
    "the execution of line [ line : findearliest ] will always try to search for a set that contains the element @xmath100 .",
    "therefore , the first execution will find the set @xmath135 , so @xmath88 will be @xmath141 .",
    "after that , @xmath104 becomes @xmath142 , so the algorithm needs to make a union of the sets @xmath135 and @xmath136 to get @xmath143 .",
    "similarly , the next execution will find the set @xmath143 , so @xmath144 .",
    "the algorithm will then make a union of @xmath143 and @xmath137 to get @xmath145 .",
    "for the next execution , the set @xmath145 will be found , and it will be merged with @xmath138 to get @xmath146 . in this case ,",
    "@xmath147 , and the earliest non - empty canonical time interval is @xmath148 .",
    "after @xmath116 is updated to @xmath149 , the algorithm will merge @xmath146 with @xmath139 and obtain @xmath150 .",
    "therefore , the next execution of line [ line : findearliest ] will get @xmath151 . after the time interval @xmath120",
    "is scheduled and @xmath122 is updated to @xmath119 , so the algorithm will not do any union .",
    "the last execution finds @xmath151 again , and a loop break is performed .",
    "now , we we analyze the time complexity of the algorithm .",
    "each set always contains continuous integers .",
    "it can be proved by induction . at the beginning , each skeleton set is a continuous integer set . during the running of the algorithm ,",
    "the union operation always merges two nearby continuous integer sets to form a larger continuous integer set .",
    "there are at most @xmath152 unions .",
    "it is because there are only @xmath153 sets .",
    "there are at most @xmath154 finds .",
    "some @xmath152 finds are from finding the set containing @xmath131 during each union .",
    "note that there is no need to perform a find operation to find the set containing @xmath88 for union , because @xmath88 is just the name of such a set , where the set contains continuous integers with @xmath88 as the largest element .",
    "the other @xmath155 finds are from searching for earliest canonical time intervals beginning at or after time @xmath55 .",
    "this can be analyzed in the following way : let @xmath156 be the number of times to search for an earliest canonical time interval when processing job @xmath14 .",
    "let @xmath157 be the number of unions that are performed when processing job @xmath14 .",
    "we have @xmath158 , because each of the first @xmath159 finds must accompany a union .",
    "therefore , @xmath160    since these unions and finds are operated on the sets of integer intervals , such an interval union - find problem can be solved in @xmath161 time in the unit - cost ram model using gabow and tarjan s algorithm @xcite .",
    "note that @xmath162 , so the total time complexity is @xmath163 .",
    "theorem [ lemma : s - schedule ] holds .",
    "if the union - find algorithm is implemented in the pointer machine model @xcite using the classical algorithm of tarjan @xcite , the complexity of our @xmath25-schedule algorithm will become @xmath164 where @xmath165 is the one - parameter inverse ackermann function .",
    "note that , the number of finds can be further reduced with a more careful implementation of the algorithm as follows ( but the asymptotic complexity will not change ) :    * whenever the algorithm schedules a job @xmath14 to run at a time interval @xmath166 , the algorithm no longer needs to proceed to line [ line : findearliest ] for the same job , because there will not be any idle time interval available before the deadline .",
    "* for each job @xmath14 , the first time to find a non - empty canonical time interval requires one find operation .",
    "in any of the later times to search for earliest non - empty canonical time intervals for the same job , there must be a union operation just performed . the @xmath88 that determines the earliest non - empty canonical time interval @xmath167 is just the name of that new set after that union , so",
    "a find operation is not necessary in this case .",
    "note that the find operations that accompany the unions are still required .    using the above implementation",
    ", the number of finds to search for earliest non - empty canonical time intervals can be reduced to @xmath1 . along with",
    "the @xmath152 finds for unions , the total number of finds of this improved implementation is at most @xmath155 .",
    "we will first take a brief look at the previous best known dvs algorithm of li , yao and yao @xcite . as in @xcite , define the `` support '' @xmath168 of @xmath20 to be the union of all job intervals in @xmath20 .",
    "define @xmath169 , the `` average rate '' of @xmath20 to be the total workload of @xmath20 divided by @xmath170 . according to lemma 9 in @xcite , using @xmath171 to do",
    "an @xmath25-schedule will generate two nonempty subsets of jobs requiring speed at least @xmath25 or less than @xmath25 respectively in the optimal schedule unless the optimal speed for @xmath20 is a constant @xmath25 .",
    "the algorithm will recursively do the scheduling based on the two subsets of jobs .",
    "therefore , at most @xmath1 calls of @xmath25-schedules on a job set with at most @xmath1 jobs are needed before we obtain the optimal schedule for the whole job set .",
    "the most time - consuming part of their algorithm is the @xmath25-schedules .    to apply our improved @xmath25-schedule algorithm for solving the continuous dvs scheduling problem",
    ", we need to make sure that the ranks of the deadlines and arrival times are known before each @xmath25-schedule call .",
    "it can be done in the following way : before the first call , sort the deadlines and arrival times and obtain the ranks . in each of the subsequent calls , in order to get the new ranks within the two subsets of jobs , a counting sort algorithm can be used to sort the old ranks in linear time . therefore , the time to obtain the ranks is at most @xmath2 for the whole algorithm .",
    "based on the improved computation of @xmath25-schedules , the total time complexity of the dvs problem is now @xmath2 , improving the previous @xmath172 algorithm of @xcite by a factor of @xmath173 .",
    "we have the following theorem .",
    "the continuous dvs scheduling problem can be solved in @xmath2 time for @xmath1 jobs in the unit - cost ram model .",
    "for the discrete dvs scheduling problem , we have an @xmath40 algorithm to calculate the optimal schedule by doing binary testing on the given @xmath5 speed levels , improving upon the previously best known @xmath3 @xcite .",
    "to be specific , given the input job set with size @xmath1 and a set of speeds @xmath174 , we first choose the speed @xmath175 to bi - partition the job set into two subsets . then within each subset",
    ", we again choose the middle speed level to do the bi - partition .",
    "we recursively do the bi - partition until all the speed levels are handled . in the recursion tree",
    "thus built , we claim that the re - sorting for subproblems on the same level can be done in @xmath163 time which implies that the total time needed is @xmath176 .",
    "the claim can be shown in the following way .",
    "based on the initial sorting , we can assign a new label to each job specifying which subgroup it belongs to when doing bi - partitioning .",
    "then a linear scan can produce the sorted list for each subgroup .",
    "in this paper , we improve the time for computing the optimal continuous dvs schedule from @xmath0 to @xmath2 .",
    "the major improvement happens in the computation of s - schedules .",
    "originally , the s - schedule computation is done in an online fashion where the execution time is allocated from the beginning to the end sequentially and the time assigned to a certain job can be gradually decided .",
    "while in this work , we allocate execution time to jobs in an offline fashion .",
    "when jobs are sorted by deadlines , job @xmath177 s execution time is totally decided before we go on to consider @xmath178 . then by using a suitable data structure and conducting a careful analysis ,",
    "the computation time for s - schedules improves from @xmath40 to @xmath163 .",
    "we also design an algorithm to improve the computation of the optimal schedule for the discrete model from @xmath3 to @xmath4 .",
    "a. m. ben - amram . what is a `` pointer machine '' ?",
    "sigact news 26 , 2 ( june 1995 ) , 88 - 95 .",
    "d. p. bunde .",
    "power - aware scheduling for makespan and flow . _ in proceedings of the 18th annual acm symposium on parallelism in algorithms and architectures _ , 2006 , pp .",
    "190 - 196 .",
    "h. l. chan , w. t. chan , t. w. lam , l. k. lee , k. s. mak , and p. w. h. wong . energy efficient online deadline scheduling .",
    "_ in proceedings of the 18th annual acm - siam symposium on discrete algorithms",
    "_ , 2007 , pp .",
    "795 - 804 .",
    "w. t. chan , t. w. lam , k. s. mak , and p. w. h. wong .",
    "online deadline scheduling with bounded energy efficiency . _ in proceedings of the 4th annual conference on theory and applications of models of computation",
    "_ , 2007 , pp .",
    "416 - 427 .",
    "h. n. gabow and r. e. tarjan .",
    "a linear - time algorithm for a special case of disjoint set union . in _",
    "stoc 83 : proceedings of the fifteenth annual acm symposium on theory of computing _ , pages 246251 , new york , ny , usa , 1983 .",
    "i. hong , g. qu , m. potkonjak and m. b. srivastavas .",
    "synthesis techniques for low - power hard real - time systems on variable voltage processors . _ in proceedings of the ieee real - time systems symposium _ , 1998 , pp .",
    "178 - 187 .",
    "t. w. lam , l. k. lee , i. k. k. to , and p. w. h. wong .",
    "energy efficient deadline scheduling in two processor systems .",
    "_ in proceedings of the 18th international symposium on algorithm and computation",
    "_ , 2007 , pp .",
    "476 - 487 .",
    "k. pruhs and c. stein . how to schedule when you have to buy your energy .",
    "_ in the proceedings of the 13th international workshop on approximation , randomization , and combinatorial optimization .",
    "algorithms and techniques _ , 2010 , pp .",
    "352 - 365 ."
  ],
  "abstract_text": [
    "<S> dynamic voltage scaling techniques allow the processor to set its speed dynamically in order to reduce energy consumption . in the continuous model </S>",
    "<S> , the processor can run at any speed , while in the discrete model , the processor can only run at finite number of speeds given as input . the current best algorithm for computing the optimal schedules for the continuous model runs at @xmath0 time for scheduling @xmath1 jobs . in this paper </S>",
    "<S> , we improve the running time to @xmath2 by speeding up the calculation of s - schedules using a more refined data structure . </S>",
    "<S> for the discrete model , we improve the computation of the optimal schedule from the current best @xmath3 to @xmath4 where @xmath5 is the number of allowed speeds . </S>"
  ]
}