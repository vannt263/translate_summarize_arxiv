{
  "article_text": [
    "the combination of deterministic and uncertain reasoning has led to many mixtures of logic and probability @xcite . in particular , combinations of logic programming constructs and probabilistic assessments have been pursued in several guises @xcite , and the topic has generated significant literature @xcite .    among probabilistic logic programming languages ,",
    "the approach started by poole s probabilistic horn abduction @xcite and sato s distribution semantics  @xcite has been very popular . basically , there a logic program is enlarged with independent probabilistic facts .",
    "for instance , consider a rule @xmath0 and probabilistic fact @xmath1 depending on @xmath2 , @xmath3 may succeed or not in leading to @xmath4 .",
    "sato s distribution semantics at first focused on _ definite _ programs , and was announced `` roughly , as distributions over least models ''  @xcite . poole and sato originally emphasized _ acyclic _ logic programs @xcite , even though sato did handle cyclic ones .",
    "since then , there has been significant work on non - definite and on cyclic probabilistic logic programs under variants of the distribution semantics @xcite .    in this paper",
    "we examine the meaning and the computational complexity of probabilistic logic programs that extend sato s distribution semantics .",
    "we look at standard function - free normal programs containing negation as failure and probabilistic facts . the goal is to compute an _ inference _ ; that is , to compute the probability @xmath5 , where both @xmath6 and @xmath7 are sets of facts .",
    "the pair @xmath8 is referred to as the _ query_. we distinguish between the complexity of inference when a probabilistic program and a query are given ( the _ inferential _ complexity ) , and the complexity of inference when the probabilistic program is fixed and the query is given ( the _ query _ complexity ) .",
    "query complexity is similar to _ data _ complexity as used in database theory , as we discuss later .",
    "we first examine acyclic programs ; for those programs all existing semantics coincide .",
    "given the well - known relationship between acyclic probabilistic logic programs and bayesian networks , it is not surprising that inference for propositional acyclic programs is @xmath9-complete .",
    "however , it _ is _ surprising that , as we show , inference with _ bounded arity _ acyclic programs _ without negation _ is @xmath10-equivalent , thus going up the counting hierarchy .",
    "and we show that acyclic programs without a bound on predicate arity take us to @xmath11-completeness .",
    "many useful logic programs are cyclic ; indeed , the use of recursion is at the heart of logic programs and its various semantics @xcite .",
    "many applications , such as non - recursive structural equation models  @xcite and models with `` feedback ''  @xcite , defy the acyclic character of bayesian networks .",
    "we study cyclic normal logic programs in a few steps .",
    "first we look at the inferential and query complexity of locally stratified programs . for these programs",
    ", again we see that most existing semantics coincide ; in particular semantics based on stable and well - founded models are identical .",
    "to summarize , we show that the complexity of stratified programs is the same as the complexity of acyclic programs .",
    "we then move to general , possibly cyclic , programs .",
    "there are various semantics for such programs , and relatively little discussion about them in the literature .",
    "for instance , take a program consisting of two rules , @xmath12 and a fact associated with a probabilistic assessment : @xmath13 with probability @xmath14 , we have that @xmath15 is @xmath16 , and then @xmath17 is @xmath18 and @xmath19 is @xmath16 .",
    "this is simple enough .",
    "but with probability @xmath20 , we have that @xmath15 is @xmath18 , and then the remaining two rules create a cycle : @xmath17 depends on @xmath19 and vice - versa .",
    "the question is how to define a semantics when a cycle appears .",
    "we focus on two semantics for such programs , even though we mention a few others .",
    "first , we look at a semantics for probabilistic logic programs that can be extracted from the work of lukasiewicz on probabilistic description logics  @xcite .",
    "his proposal is that a probabilistic logic program defines a set of probability measures , induced by the various stable models of the underlying normal logic program .",
    "the second semantics we examine is based on the well - founded semantics of normal logic programs : in this case there is always a single distribution induced by a probabilistic logic program @xcite .",
    "we first study lukasiewicz s semantics , referred to as the `` credal semantics '' .",
    "we show that credal semantics produces sets of probability models that dominate infinitely monotone choquet capacities ; the latter objects are relatively simple extensions of probability distributions and have been often used in the literature , from random set theory to dempster - shafer theory .",
    "we then derive results concerning inferential and query complexity .",
    "we show that the complexity of general probabilistic logic programs goes up the counting hierarchy , up to @xmath21 levels ; overall the complexity of the well - founded semantics is in lower classes than the complexity of the stable model semantics .",
    "the paper begins in section [ section : basics ] with a review of logic programming and complexity theory .",
    "section [ section : plps ] presents basic notions concerning probabilistic logic programs and their semantics . in section [ section : semantics ]",
    "we contribute with a comparison between the _ credal _ and the _ well - founded _ semantics .",
    "our main results appear in sections [ section : structure ] , [ section : complexityacyclicstratified ] , [ section : complexitycredal ] and [ section : complexitywellfounded ] . in section [ section : structure ]",
    "we show that the credal semantics of a probabilistic logic program is a set of probability measures induced by a 2-monotone choquet capacities .",
    "sections [ section : complexityacyclicstratified ] , [ section : complexitycredal ] and [ section : complexitywellfounded ] analyze the complexity of inferences under the credal and the well - founded semantics .",
    "the paper concludes , in section [ section : conclusion ] , with a summary of our contributions and a discussion of future work .",
    "we briefly collect here some well known terminology and notation regarding logic programming and complexity theory . before we plunge into those topics , we briefly fix notation on bayesian networks as we will need them later .",
    "bayesian network _ is a pair consisting of a directed acyclic graph @xmath22 whose nodes are random variables , and a joint probability distribution @xmath23 over all variables in the graph , such that @xmath22 and @xmath23 satisfy the `` markov condition '' ( that is , a random variable is independent of its parents given its nondescendants )  @xcite .",
    "if all random variables are discrete , then one can specify `` local '' conditional probabilities @xmath24 , and the joint probability distribution is necessarily the product of these local probabilities : @xmath25 where @xmath26 is the projection of @xmath27 on the set of random variables @xmath28 ; whenever @xmath29 has no parents , @xmath24 stands for @xmath30 .",
    "take a vocabulary consisting of set of logical variable symbols @xmath31 , a set of predicate symbols @xmath32 , and a set of constants @xmath33 . a _ term _ is a constant or a logical variable ; an _ atom _ is written as @xmath34 , where @xmath35 is a predicate of arity @xmath36 and each @xmath37 is a term .",
    "a zero - arity atom is written simply as @xmath35 .",
    "an atom is _ ground _ if it does not contain logical variables .",
    "a _ normal logic program _ consists of rules written as @xcite @xmath38 where the @xmath39 are atoms and @xmath40 is interpreted according to some selected semantics , as discussed later .",
    "head _ of this rule is @xmath41 ; the remainder of the rule is its _",
    "body_. a rule without a body , written simply as @xmath42 , is a _",
    "fact_. a _ subgoal _ in the body is either an atom @xmath43 ( a _ positive _ subgoal ) or @xmath44 ( a _ negative _ subgoal ) .",
    "a program without negation is _ definite _ , and a program without variables is _ propositional_.    [ example : logicsmokers ] here is a program describing the relation between smoking , stress , and social influence @xcite : @xmath45 this program is definite , but not propositional . @xmath46",
    "the _ herbrand base _ of a program is the set of all ground atoms built from constants and predicates in the program .",
    "we do not consider functions in this paper , to stay with finite herbrand bases .",
    "a _ substitution _ is a ( partial ) function that maps logical variables into terms .",
    "grounding _ is a substitution mapping into constants .",
    "the grounding of a rule is a ground rule obtained by applying the same grounding to each atom .",
    "the grounding of a program is the propositional program obtained by applying every possible grounding all rules , using only the constants in the program ( i.e. , using only ground atoms in the herbrand base ) .",
    "an atom @xmath43 _ unifies _ with an atom @xmath47 if there is a substitution that makes both ( syntactically ) equal .",
    "a _ literal _",
    "@xmath48 is either an atom @xmath43 or a negated atom @xmath49 .",
    "a set of literals is _ inconsistent _ if @xmath43 and @xmath49 belong to it . given a normal logic program @xmath50 , a _",
    "partial interpretation _ is a consistent set of literals whose atoms belong to the herbrand base of @xmath50 .",
    "an _ interpretation _ is a consistent set of literals such that every atom in the herbrand base appears in a literal .",
    "an atom is @xmath16 ( resp . , @xmath18 ) in a ( partial ) interpretation if it appears in a non - negated ( resp . ,",
    "negated ) literal .",
    "a subgoal is @xmath16 in an interpretation if it is an atom @xmath43 and @xmath43 belongs to the interpretation , or the subgoal is @xmath44 and @xmath49 belongs to the interpretation .",
    "a grounded rule is _ satisfied _ in a partial interpretation if its head is @xmath16 in the interpretation , or any of its subgoals is @xmath18 in the interpretation .",
    "a _ model _ of @xmath50 is an interpretation such that every grounding of a rule in @xmath50 is satisfied .",
    "a _ minimal model _ of @xmath50 is a model with minimum number of non - negated literals .",
    "( iba ) at ( 0,1 ) @xmath51 ; ( iab ) at ( 3,1 ) @xmath52 ; ( ta ) at ( -2.5,1 ) @xmath53 ; ( tb ) at ( 5.5,1 ) @xmath54 ; ( sa ) at ( 0,0 ) @xmath55 ; ( sb ) at ( 3,0 ) @xmath56 ; ( iaa ) at ( 0,-1 ) @xmath57 ; ( ibb ) at ( 3,-1 ) @xmath58 ;    ( iba ) to ( sa ) ; ( iab ) to ( sb ) ; ( tb ) to ( sb ) ; ( sa ) [ out=-10 , in=-170 ] to ( sb ) ; ( sb ) [ out=170 , in=10 ] to ( sa ) ;    ( iaa ) to ( sa ) ; ( ibb ) to ( sb ) ; ( ta ) to ( sa ) ;    ( sa ) edge [ loop left ] ( sa ) ; ( sb ) edge [ loop right ] ( sb ) ;    the _ dependency graph _ of a program is a directed graph where each predicate is a node , and where there is an edge from a node @xmath47 to a node @xmath43 if there is a rule where @xmath43 appears in the head and @xmath47 appears in the body ; if @xmath47 appears right after @xmath40 , the edge is _ negative _ ; otherwise , it is _",
    "positive_. the _ grounded _ dependency graph is the dependency graph of the propositional program obtained by grounding .",
    "for instance , the grounded dependency graph of the program in example [ example : logicsmokers ] is depicted in figure [ fig : depsmokers ] .",
    "a program is _ acyclic _ when its grounded dependency graph is acyclic .    concerning the semantics of normal logic programs , there are , broadly speaking , two strategies to follow .",
    "one strategy is to translate programs into a first - order theory that is called a _",
    "completion _ of the program .",
    "then the semantics of the program is the set of first - order models of its completion .",
    "the most famous completion is clark s @xcite , roughly defined as follows .",
    "first , rewrite each body by replacing commas by @xmath59 and @xmath40 by @xmath60 .",
    "second , remove constants from heads : to do so , consider a rule @xmath61 , where @xmath62 is a constant and @xmath63 is the body ; then this rule is replaced by @xmath64 .",
    "then , for each set of rules that share the same head @xmath41 , write @xmath65 , where each @xmath63 is the body of one of the rules .",
    "the second strategy that is often used to define the semantics of normal logic programs is to select some models of the program to be its semantics .",
    "there are many proposals in the literature as to which models should be selected ; however , currently there are two selections that have received most attention : the _ stable model _ @xcite and the _ well - founded _ @xcite semantics .",
    "we now describe these semantics ; alas , their definitions are not simple .",
    "consider first the stable model semantics .",
    "suppose we have a normal logic program @xmath50 and an interpretation @xmath66 .",
    "define the _ reduct _ @xmath67 to be a definite program that contains rule @xmath68 iff one of the grounded rules from @xmath50 is @xmath69 where each @xmath70 is @xmath18 in @xmath66 .",
    "that is , the reduct is obtained by ( i ) grounding @xmath50 , ( ii ) removing all rules that contain a subgoal @xmath71 in their body such that @xmath43 is an atom that is @xmath16 in @xmath66 , ( iii ) removing all remaining literals of the form @xmath71 from the remaining rules .",
    "an interpretation @xmath66 is a",
    "_ stable model _ if @xmath66 is a minimal model of @xmath67 .",
    "note that a normal program may fail to have a stable model , or may have several stable models .",
    "there are two types of logical reasoning under the stable mode semantics  @xcite .",
    "_ brave reasoning _ asks whether there is a stable model containing a specific atom ( and possibly returns it if it exists ) .",
    "_ cautious reasoning _ asks whether a specific atom appears in all stable models ( and possibly lists all such models ) .",
    "consider now the well - founded semantics .",
    "given a subset @xmath72 of the herbrand base of a program , and a partial interpretation @xmath66 , say that an atom @xmath43 is _ unfounded _ with respect to @xmath72 and @xmath66 iff for each grounded rule whose head is @xmath43 , we have that ( i ) some subgoal @xmath39 or @xmath73 is @xmath18 in @xmath66 , or ( ii ) some subgoal that is an atom @xmath39 is in @xmath72",
    ". now say that a subset @xmath72 of the herbrand base is an _ unfounded set _ with respect to interpretation @xmath66 if each atom in @xmath72 is unfounded with respect to @xmath72 and @xmath66 .",
    "this is a complex definition : roughly , it means that , for each possible rule that we might apply to obtain @xmath43 , either the rule can not be used ( given @xmath66 ) , or there is an atom in @xmath72 that must be first shown to be @xmath16 .",
    "now , given normal logic program @xmath50 , define @xmath74 to be a transformation that takes interpretation @xmath66 and returns another interpretation : @xmath75 iff there is some grounded rule with head @xmath43 such that every subgoal in the body is @xmath16 in @xmath66 . also define @xmath76 to be the greatest unfounded set with respect to @xmath66 ( there is always such a greatest set ) .",
    "define @xmath77 , where the notation @xmath78 means that we take each literal in @xmath76 and negate it ( that is , @xmath43 becomes @xmath49 ; @xmath49 becomes @xmath43 ) . intuitively , @xmath79 is what we can `` easily prove to be positive '' and @xmath80 is what we can `` easily prove to be negative ''",
    ".    finally : the well - founded semantics of @xmath50 is the least fixed point of @xmath81 ; this fixed point always exists .",
    "that is , apply @xmath82 , starting from @xmath83 , until it stabilizes ; the resulting interpretation is the well - founded model .",
    "the iteration stops in finitely many steps given that we have finite herbrand bases .",
    "the well - founded semantics determines the truth assignment for a subset of the atoms in the herbrand base ; for the remaining atoms , their `` truth values are not determined by the program '' ( * ? ? ?",
    "* section 1.3 ) .",
    "a very common interpretation of this situation is that the well - founded semantics uses three - valued logic with values @xmath16 , @xmath18 , and @xmath84 .",
    "it so happens that any well - founded model is a subset of every stable model of a normal logic program ( * ? ? ?",
    "* corollary 5.7 ) ; hence , if a program has a well - founded model that is an interpretation for all atoms , then this well - founded model is the unique stable model ( the converse is not true ) .",
    "there are other ways to define the well - founded semantics that are explicitly constructive @xcite .",
    "one is this , where the connection with the stable model semantics is emphasized @xcite : write @xmath85 to mean the least fixpoint of @xmath86 ; then the well - founded semantics of @xmath50 consists of those atoms @xmath43 that are in the least fixpoint of @xmath87 plus the literals @xmath49 for those atoms @xmath43 that are _ not _ in the greatest fixpoint of @xmath87 .",
    "note that @xmath87 is a monotone operator .",
    "it is instructive to look at some examples .",
    "[ example : basic ] first , take a program @xmath50 with two rules : @xmath88 and @xmath89 ( identical to rules in expression ( [ equation : basiccyclicprogram ] ) ) .",
    "this program has two stable models : both assign @xmath18 to @xmath35 ; one assigns @xmath16 to @xmath90 and @xmath18 to @xmath91 , while the other assigns @xmath16 to @xmath91 and @xmath18 to @xmath90 ( note @xmath92 and @xmath93 ) .",
    "the well - founded semantics assigns @xmath18 to @xmath35 and leaves @xmath90 and @xmath91 as @xmath84 .",
    "@xmath94    [ example : game ] consider a game where a player wins if there is another player with no more moves @xcite , as expressed by the cyclic rule : @xmath95 suppose the available moves are given as the following facts : @xmath96 there are two stable models : both assign @xmath16 to @xmath97 and @xmath18 to @xmath98 ; one assigns @xmath16 to @xmath99 and @xmath18 to @xmath100 , while the other assigns @xmath16 to @xmath100 and @xmath18 to @xmath99 .",
    "the well - founded semantics leads to partial interpretation @xmath101 , leaving @xmath99 and @xmath100 as @xmath84 .",
    "if @xmath102 is not given as a fact , it is assigned @xmath18 , and the well - founded semantics leads to @xmath103 .",
    "@xmath94    [ example : barber ] the barber paradox : if the barber shaves all , and only , those villagers who do not shave themselves , does the barber shave himself ?",
    "consider : @xmath104 there is no stable model for this normal logic program : the facts and the rule lead to the pattern @xmath105 , thus eliminating any possible stable model .",
    "the well - founded semantics assigns @xmath18 to @xmath106 , to @xmath107 and to @xmath108 .",
    "also , @xmath109 is assigned @xmath16 , and @xmath110 is left @xmath84 .",
    "that is , even though the semantics leaves the status of the barber as @xmath84 , it does produce meaningful answers for other villagers . @xmath94      we adopt basic terminology and notation from computational complexity  @xcite .",
    "a _ language _ is a set of strings .",
    "a language defines a _ decision problem _ ; that is , the problem of deciding whether an input string is in the language . a _ complexity class _ is a set of languages ; we use well - known complexity classes such as @xmath111 , @xmath112 , @xmath113 , @xmath114 .",
    "the complexity class @xmath9 consists of those languages @xmath115 that satisfy the following property : there is a polynomial time nondeterministic turing machine @xmath116 such that @xmath117 iff more than half of the computations of @xmath116 on input @xmath118 end up accepting .",
    "analogously , we have @xmath11 , consisting of those languages @xmath115 with the following property : there is an exponential time nondeterministic turing machine @xmath116 such that @xmath117 iff half of the computations of @xmath116 on input @xmath118 end up accepting  @xcite .",
    "an oracle turing machine @xmath119 , where @xmath115 is a language , is a turing machine that can write a string @xmath118 to an `` oracle '' tape and obtain from the oracle , in unit time , the decision as to whether @xmath117 or not .",
    "similarly , for a function @xmath120 , an oracle turing machine @xmath121 can be defined .",
    "if a class of languages / functions @xmath122 is defined by a set of turing machines @xmath123 ( that is , the languages / functions are decided / computed by these machines ) , then @xmath124 is the set of languages / functions that are decided / computed by @xmath125 .",
    "similarly , for any class @xmath122 we have @xmath126 . if @xmath122 and @xmath127 are classes of languages / functions , @xmath128 .",
    "the _ polynomial hierarchy _ consists of classes @xmath129 and @xmath130 , with @xmath131 .",
    "later we also use classes @xmath132 and @xmath133 .",
    "wagner s _ polynomial counting hierarchy _ is the smallest set of classes containing @xmath111 and , recursively , for any class @xmath134 in the polynomial counting hierarchy , the classes @xmath135 , @xmath136 , and @xmath137 ( * ? ? ?",
    "* theorem 4 ) ( * ? ? ? * theorem 4.1 ) .",
    "the polynomial hierarchy is included in wagner s counting polynomial hierarchy .",
    "a _ many - one reduction _ from @xmath115 to @xmath138 is a polynomial time algorithm that takes the input to decision problem @xmath115 and transforms it into the input to decision problem @xmath138 such that @xmath138 has the same output as @xmath115 . for a complexity class @xmath134 ,",
    "a decision problem @xmath115 is @xmath134-hard with respect to many - one reductions if each decision problem in @xmath134 can be reduced to @xmath115 with many - one reductions .",
    "a decision problem is then @xmath134-complete with respect to many - one reductions if it is in @xmath134 and it is @xmath134-hard with respect to many - one reductions . in proofs we will often use propositional formulas ; such a formula is in conjunctive normal form ( cnf ) when it is a conjunction of clauses ( where a clause is a disjunction of literals ) .",
    "a @xmath139cnf is a cnf in which each clause has @xmath139 literals .",
    "we use the following @xmath140-complete problem ( * ? ? ?",
    "* theorem 7 ) , that we refer to as @xmath141 :    input : : :    a pair @xmath142 , where    @xmath143 is a    propositional formula in 3cnf and each @xmath144 is a    tuple of logical variables , and @xmath116 is an integer .",
    "output : : :    whether or not the number of truth assignments for    @xmath145 in the formula    @xmath146    is strictly larger than @xmath116 , where the quantifiers    alternate and each logical variable not in @xmath145    is bound to a quantifier .    another @xmath140-complete problem , referred to as @xmath147 is :    input : : :    a pair @xmath142 , where    @xmath143 is a    propositional formula in dnf and each @xmath144 is a    tuple of logical variables , and @xmath116 is an integer .",
    "output : : :    whether or not the number of truth assignments for    @xmath145 in the formula    @xmath148    is strictly larger than @xmath116 , where the quantifiers    alternate and each logical variable not in @xmath145    is bound to a quantifier .    a detail is that wagner defines a @xmath140-complete problem using `` @xmath149 '' instead of `` @xmath150 '' , but the former is equivalent to `` @xmath151 '' , so both inequalities can be used .",
    "in this paper we focus on a particularly simple combination of logic programming and probabilities @xcite .",
    "a _ probabilistic logic program _ , abbreviated plp , is a pair @xmath152 consisting of a normal logic program @xmath50 and a set of _ probabilistic facts _ @xmath153 .",
    "a probabilistic fact is a pair consisting of an atom @xmath43 and a probability value @xmath154 ; we use the notation @xmath155 borrowed from the problog package @xcite .",
    "we assume that every probability value is a rational number .",
    "[ example : alarm ] here is a syntactically correct problog program : @xmath156 there are four rules , two facts , and five probabilistic facts .",
    "@xmath94    a probabilistic fact may contain logical variables ; for instance , we may write @xmath157 .",
    "we interpret such a parameterized probabilistic fact as the set of all grounded probabilistic facts obtained by substituting variables with constants in the herbrand base .    given a plp @xmath152 where @xmath50 is acyclic , we say the plp is acyclic . likewise , if @xmath50 is definite , stratified , cyclic , etc , we use the same adjective for the whole plp .",
    "the interpretation of probabilistic facts requires some pause .",
    "suppose we have a plp @xmath152 with @xmath36 probabilistic facts ( which may be groundings of probabilistic facts containing logical variables ) .",
    "from @xmath152 we can generate @xmath158 normal logic programs : for each probabilistic fact @xmath155 , we can either choose to keep fact @xmath159 , or choose to erase fact @xmath159 altogether .",
    "these choices are assumed independent : this is sato s _ independence assumption_.    for instance , consider the plp : @xmath160 we have four ways to write a normal logic program out of this plp ; that is , @xmath35 can be kept or removed , and likewise for @xmath161 .",
    "all these normal logic programs are obtained with the same probability @xmath162 , and in one of them @xmath163 is @xmath16 ; consequently , the probability @xmath164 .    a _ total choice _ @xmath165 for the plp is a subset of the set of grounded probabilistic facts .",
    "we interpret @xmath165 as a set of ground facts that are probabilistic selected to be included in @xmath50 ; all other ground facts obtained from probabilistic facts are to be discarded . the probability of a total choice is easily computed : it is a product over the grounded probabilistic facts , where probabilistic fact @xmath155 contributes with factor @xmath154 if @xmath159 is kept , or factor @xmath166 if @xmath159 is removed . now for each total choice @xmath165",
    "we obtain a normal logic program , that we denote by @xmath167 .",
    "for instance , the plp in expression ( [ equation : independenceassumption ] ) has two probabilistic facts , leading to four total choices , each with probability @xmath162 .",
    "now consider a more complicated plp : @xmath168 there are five ground probabilistic facts ( after grounding @xmath169 appropriately ) ; hence there are @xmath170 total choices .",
    "suppose we choose to keep the fact in the first probabilistic fact , and discard all the others ( with probability @xmath171 ) ; then we obtain @xmath172 a program with a single stable model where @xmath35 is the only @xmath16 atom . by going through all possible total choices",
    ", we have that @xmath173 ( as @xmath174 is kept in the program by a first choice with probability @xmath175 or by a second choice with probability @xmath176 , hence @xmath177 ) . similarly , @xmath178 ; note however that @xmath179 . and",
    "finally , @xmath180 .",
    "sato assumes that no probabilistic fact unifies with the head of a non - fact rule ( that is , a rule with a nonempty body ) ; this is called the _ disjointness condition _  @xcite . from a modeling perspective",
    "this is a convenient assumption even though we do not need it in our complexity results .",
    "in fact from a modeling perspective an even stronger disjointness condition makes sense : no probabilistic fact should unify with the head of any rule ( with a body or not ) , nor with any other probabilistic fact . under this assumption",
    ", the probabilistic fact @xmath155 can be directly interpreted as a probabilistic assessment @xmath181 .",
    "again , we do not need such an assumption for our results , but our examples will always satisfy it , and it makes sense to assume that it will always be adopted in practice .",
    "we can now discuss the semantics of a plp @xmath152 .",
    "first , take the grounding of this plp . now for each total choice @xmath165 we obtain the normal logic program @xmath167 .",
    "hence the distribution over total choices induces a distribution over normal logic programs .",
    "a common assumption is that , for each total choice @xmath165 , the resulting normal logic program @xmath167 yields a single model @xcite .",
    "for instance , if @xmath50 is definite , then @xmath167 is definite for any @xmath165 , and @xmath167 has a unique stable model that is also its unique well - founded model .",
    "thus the unique distribution over total choices becomes a unique distribution over stable / well - founded models .",
    "this distribution is exactly sato s _ distribution semantics _  @xcite .",
    "similarly , suppose that @xmath50 is acyclic ; then @xmath167 is acyclic for any @xmath165 , and @xmath167 has a unique stable model that is also its unique well - founded model  @xcite .",
    "poole s and sato s original work focused respectively on acyclic and definite programs ; in both cases the semantics of resulting normal logic programs is uncontroversial .",
    "the same can be said of the larger class of _ stratified _ programs ; a normal logic program is stratified when cycles in the grounded dependency graph contain no negative edge ( this is often referred to as _ locally stratified _ in the literature ) @xcite .",
    "both the stable and the well - founded semantics are identical for stratified programs , and both generate a unique interpretation for all atoms . as a consequence , a plp @xmath152 has a unique distribution semantics whenever @xmath50 is stratified .",
    "note that both acyclic and definite programs are stratified .",
    "the plp in example [ example : alarm ] is acyclic , and thus stratified , but not definite .",
    "the grounded dependency graph of this program is depicted in figure  [ figure : alarmgraph ] .",
    "this graph can be interpreted as a bayesian network , as we discuss later @xcite .",
    "there are @xmath182 total choices , and the probability of @xmath183 is @xmath184 .",
    "\\(b ) at ( 1,0.6 ) @xmath185 ; ( e ) at ( 1,-0.1 ) @xmath186 ; ( a ) at ( 3.5,0.6 ) @xmath187 ; ( cm ) at ( 6,0.62 ) @xmath188 ; ( cj ) at ( 6,-0.1 ) @xmath189 ; ( nm ) at ( 8,0.62 ) @xmath190 ; ( nj ) at ( 8,-0.1 ) @xmath191 ; ( a1 ) at ( 2.5,-0.1 ) @xmath192 ; ( a2 ) at ( 3.5,-0.1 ) @xmath193 ; ( a3 ) at ( 4.5,-0.1 ) @xmath194 ; ( b)(a ) ; ( e)(a ) ; ( a)(cm ) ; ( a)(cj ) ; ( a1)(a ) ; ( a2)(a ) ; ( a3)(a ) ; ( nm)(cm ) ; ( nj)(cj ) ;    [ example : smokers ] consider a probabilistic version of the `` smokers '' program in example [ example : logicsmokers ] @xcite : @xmath195 the grounded dependency graph of this program is identical to the one shown in figure [ fig : depsmokers ] .",
    "it is tempting to interpret this graph as a bayesian network , but of course this is not quite right as the graph is cyclic .",
    "indeed the program is not acyclic , but it is definite and therefore stratified , hence a unique distribution is defined over ground atoms . for instance , we have @xmath196 and @xmath197 .",
    "the program would still be stratified if the first rule were replaced by @xmath198 in this case there would still be a cycle , but the negative edge in the dependency graph would not belong to the cycle . @xmath94    often a stratified program is used to implement recursion , as illustrated by the next example :    consider the following plp , based on an example in the problog distribution : @xmath199 that is , we have a random graph with nodes @xmath200 , and probabilities attached to edges .",
    "the query @xmath201 yields the probability that there is a path between nodes @xmath202 and @xmath203 . using problog",
    "one obtains @xmath204 .",
    "@xmath94      if a normal logic program is non - stratified , then its well - founded semantics may be a partial interpretation , and some atoms may be left as @xmath84 ; it may have several stable models , or no stable model at all .",
    "thus we must accommodate these cases when we contemplate non - stratified plps .",
    "a first possible semantics for general probabilistic logic programs can be extracted from work by on probabilistic description logic programs . to describe that proposal ,",
    "a few definitions are needed .",
    "a plp @xmath205 is _ consistent _ if there is at least one stable model for each total choice of @xmath153 .",
    "a _ probability model _ for a consistent plp @xmath205 is a probability measure @xmath23 over interpretations of @xmath50 , such that : + ( i ) every interpretation @xmath66 with @xmath206 is a stable model of @xmath207 for the total choice @xmath165 that agrees with @xmath66 on the probabilistic facts ( that is , @xmath165 induces the same truth values as @xmath66 for the grounded probabilistic facts ) ; and + ( ii ) the probability of each total choice @xmath165 is the product of the probabilities for all individual choices in @xmath165 .",
    "+ the set of all probability models for a plp is the semantics of the program .",
    "later examples will clarify this construction .",
    "lukasiewicz calls his proposed semantics the _ answer set semantics _ for probabilistic description logic programs ; however , note that this name is both too restrictive ( the semantics can be used for programs with functions , for instance ) and a bit opaque ( it does not emphasize the fact that it deals with uncertainty ) .",
    "we prefer the term _ credal semantics _ , which we adopt from now on .",
    "the reason for this latter name is that a set of probability measures is often called a _",
    "credal set _ @xcite .",
    "now given a consistent plp , we may be interested in the smallest possible value of @xmath208 for a set @xmath6 of truth assignments , with respect to the set @xmath209 of all probability models of the plp .",
    "this is conveyed by the _ lower probability _ of @xmath6 , @xmath210 .",
    "similarly , we have the _ upper probability _ of @xmath6 , @xmath211 .",
    "suppose that we also have a set of @xmath7 of truth assignments for ground atoms ; then we may be interested in the conditional lower and upper probabilities , respectively @xmath212 and @xmath213 .",
    "we leave conditional lower / upper probabilities undefined when @xmath214 ( that is , when @xmath215 for every probability model ) .",
    "this is not the only possible convention : adopts @xmath216 and @xmath217 in this case , while walley s style of conditioning prescribes @xmath218 and @xmath219 whenever @xmath214 @xcite .",
    "the approach by is to allow probabilities directly over well - founded models , thus allowing probabilities over atoms that are @xmath84 .",
    "that is , given a plp @xmath205 , associate to each total choice @xmath165 the unique well - founded model of @xmath167 to @xmath165 ; the unique distribution over total choices induces a unique distribution over well - founded models .",
    "note that probabilities may be assigned to @xmath84 values in this sort of semantics . as we discuss in section [ section : semantics",
    "] , this is a bold proposal whose interpretation is far from simple .",
    "regardless of its meaning , the approach deserves attention as it is the only one in the literature that genuinely combines well - founded semantics with probabilities .",
    "accordingly , we refer to it as the _ well - founded semantics _ of probabilistic logic programs ( the combination of language and semantics is named wf - prism by hadjichristodoulou and warren ) .",
    "sato et al .",
    "propose a semantics where distributions are defined over models produced by fitting s three - valued semantics @xcite .",
    "we note that fitting s semantics is weaker than the well - founded semantics , and the literature on logic programming has consistently preferred the latter , as we do in this paper .",
    "another three - valued approach , proposed by , leaves the probability of any formula as @xmath84 whenever the formula is @xmath84 for any total choice ( to determine whether a formula is @xmath84 or not in a particular partial interpretation , three - valued logic is used ) .",
    "hence , when a formula gets a ( non-@xmath84 ) numeric probability value , its truth value is the same for all stable models ; thus any numeric probability calculations that are produced with this semantics agree with the semantics based on stable models .",
    "that is , lukasiewicz proposal is more akin to the credal semantics than to the well - founded semantics .",
    "a different semantics for non - stratified plps is adopted by the p - log language @xcite .",
    "p - log allows for disjunction in heads and other features , but when restricted to normal logic programs it is syntactically similar to problog .",
    "the semantics of a p - log program is given by a single probability distribution over possibly many stable models ; whenever necessary default assumptions are called to distribute probability evenly , or to avoid inconsistent realizations ( by re - normalization ) .",
    "we leave an analysis of this sort of semantics to the future ; here we prefer to focus on semantics that do not make default assumptions concerning probabilities .",
    "it is also important to mention the constraint logic programming language of , a significant contribution that is also based on credal sets .",
    "however , they use a syntax and semantics that is markedly different from lukasiewicz s approach , as they allow continuous variables but do not let a program have multiple stable models per total choice .",
    "they also present expressions for ( conditional ) lower and upper probabilities , by direct optimization ; in section [ section : structure ] we show that such expressions can be derived from properties of infinitely monotone choquet capacities .",
    "finally , have introduced a semantics that allows for inconsistent plps to have meaning without getting into three - valued logic .",
    "they adopt a much more sophisticated family of logic programs ( within the datalog@xmath220 language ) , and they provide a thorough analysis of complexity that we discuss later .",
    "this is also a proposal that deserves future study .    in this paper",
    "we focus on the _ credal _ and the _ well - founded _ semantics in the remainder of this paper , whenever non - stratified plps are discussed , but certainly there are other avenues to explore .",
    "it does not seem that any comparison is available in the literature between the credal and the well - founded semantics for non - stratified plps . indeed , the credal semantics has not been adopted since its appearance , a turn of events we find unfortunate as it is quite a sensible semantics for general plps . in this section we present some examples that emphasize differences between these semantics , and we examine their interpretation .",
    "[ example : probabilisticbasic ] consider a probabilistic version of example [ example : basic ] : @xmath221 this is in essence identical to the plp in expression  ( [ equation : basiccyclicprogram ] ) . to interpret the plp , note that with probability @xmath154 we obtain the normal logic program @xmath222 the unique stable / well - founded model of this program assigns @xmath16 to @xmath35 and @xmath91 , and @xmath18 to @xmath90 .",
    "that is , we have the stable model @xmath223 . on the other hand , with probability",
    "@xmath224 we obtain a program with different behavior , namely : @xmath225 this program has two stable models : @xmath226 and @xmath227 . but this program has a single well - founded model , where @xmath35 is @xmath18 and both @xmath90 and @xmath91 are @xmath84 .    consider the credal semantics .",
    "there is a probabilty model such that @xmath228 and @xmath229 , and another probability model such that @xmath230 and @xmath231 . indeed any probability measure such that @xmath232 and @xmath233 , @xmath234 , for @xmath235 $ ] , is also a probability model for this plp .",
    "the well - founded semantics is instead a single distribution that assigns @xmath236 , and assigns probability mass @xmath154 to the partial interpretation @xmath237 .",
    "now consider an inference ; say for instance one wants @xmath238 .",
    "clearly @xmath239 , regardless of the semantics .",
    "but consider @xmath90 .",
    "with respect to the credal semantics , the relevant quantities are @xmath240 and @xmath241 . and with respect to the well - founded semantics we have instead @xmath242 and @xmath243 , while @xmath244 .    to elaborate on this sort of programming pattern , consider the following non - propositional example , adapted from : @xmath245 when @xmath246 is discarded , the resulting normal logic program has a single stable model @xmath247 .",
    "when @xmath246 is a fact , the resulting program two stable models : @xmath248 the well - founded semantics instead leads to @xmath84 values both for @xmath249 and @xmath250 . note that any probability measure such that @xmath251 , @xmath252 , and @xmath253 , for @xmath254 $ ] , is a probability model .",
    "hence we have @xmath255 and @xmath256 with respect to the credal semantics , while we have @xmath257 , @xmath258 , and finally we have @xmath259 with respect to the well - founded semantics .",
    "[ example : cyclicprogram ] now take a plp adapted from an example by , where the same pattern of cyclic negation observed in the previous example seems to appear : @xmath260 there are four total choices , each inducing a normal logic program . in one case ,",
    "namely @xmath261 , the resulting normal logic program has no stable model .",
    "hence , this plp has no credal semantics .",
    "however , it does have a well - founded semantics .",
    "table [ table : cyclicprogram ] shows the assignments for @xmath262 and @xmath263 induced by the various total choices ; we obtain @xmath264 by collecting probabilities from table [ table : cyclicprogram ] .",
    "@xmath46    .total choices , the induced assignments , and their probabilities , for example [ example : cyclicprogram ] . [ cols=\"^,^,^,^,^\",options=\"header \" , ]     concerning complexity , acyclic and stratified plps have identical credal and well - founded semantics , while general plps may have different credal and well - founded semantics . for normal logic programs ( not probabilistic ones ) , the well - founded semantics is known to stay within lower complexity classes than the credal semantics @xcite ; the same phenomenon persists in the probabilistic case .",
    "indeed , the well - founded semantics for general plps reaches the same complexity classes as for acyclic plps .",
    "one might take this as an argument for the well - founded semantics , on top of the fact that the well - founded semantics is defined for _ any _ plp",
    ". on the other hand , our analysis in section [ section : semantics ] favors , at least conceptually , the credal semantics , despite the fact that it may not be defined for some plps ( in fact one might argue that no semantics should be defined for such plps ) .",
    "it is much easier to understand the meaning of plps using the credal semantics than the well - founded semantics , as the latter mixes three - valued logic and probabilities in a non - trivial way .",
    "we suggest that more study is needed to isolate those programs where @xmath84 values are justified and can be properly mixed with probabilities .",
    "also , the well - founded semantics may be taken as an approximation of the set of possible probability models . in any case , we find that lukasiewicz s credal semantics is quite attractive and not as well known as it deserves to be",
    ".    we could include in the analysis of plps a number of useful constructs that have been adopted in answer set programming @xcite .",
    "there , _ classic negation _ , such as @xmath265 , is allowed on top of @xmath40 .",
    "also , constraints , such as @xmath266 , are allowed to mean that @xmath267 is @xmath18 .",
    "more substantial is the presence , in answer set programming , of _ disjunctive heads_. with such a machinery , we can for instance rewrite the rules in example  [ example : probabilisticbasic ] as a single rule @xmath268 , and the rules in example  [ example : graphcoloring ] as the pair : @xmath269    now the point to be made is this .",
    "suppose we have a probabilistic logic program @xmath152 , where as before we have independent probabilistic facts , but where @xmath50 is now a logic program with classic negation , constraints , disjuctive heads , and @xmath50 is consistent in that it has stable models for every total choice of probabilistic facts .",
    "the proof of theorem [ theorem : capacity ] can be reproduced in this setting , and hence _ the credal semantics ( the set of measures over stable models ) of these probabilistic answer set programs is again an infinite monotone credal set . _",
    "the complexity of inference with these constructs is left for future investigation .",
    "much more is yet to be explored concerning the complexity of plps .",
    "several classes of plps deserve attention , such as definite , tight , strict , order - consistent programs , and programs with aggregates and other constructs .",
    "the inclusion of functions ( with appropriate restrictions to ensure decidability ) is another challenge .",
    "concerning complexity theory itself , it seems that approximability should be investigated , as well as questions surrounding learnability and expressivity of plps .",
    "the first author is partially supported by cnpq , grant 308433/2014 - 9 .",
    "the second author received financial support from the so paulo research foundation ( fapesp ) , grant 2016/01055 - 1 .",
    "cal , a. , lukasiewicz , t. , predoiu , l. ,  stuckenschmidt , h. 2009 .",
    "tightly coupled probabilistic description logic programs for the semantic webin journal on data semantics xii ,  95130 .",
    "springer berlin heidelberg , berlin , heidelberg .",
    "cozman , f.  g.   mau , d.  d. 2016 .",
    "probabilistic graphical models specified by probabilistic logic programs : semantics and complexityin conference on probabilistic graphical models  jmlr workshop and conference proceedings ,  52 ,  110121 .",
    "fagin , r.   halpern , j.  y. 1991 . a new approach to updating beliefin bonissone , p.  p. , henrion , m. , kanal , l.  n. ,  lemmer , j.  f. , uncertainty in artificial intelligence 6 ,  347374 .",
    "elsevier science publishers , north - holland .",
    "fierens , d. , van den broeck , g. , renkens , j. , shrerionov , d. , gutmann , b. , janssens , g. ,  de  raedt , l. 2014 . inference and learning in probabilistic logic programs using weighted boolean formulas , 15(3 ) , 358401 .",
    "lukasiewicz , t. 2005 .",
    "probabilistic description logic programsin proceedings of the 8th european conference on symbolic and quantitative approaches to reasoning with uncertainty ( ecsqaru 2005 ) , 737749 , barcelona , spain .",
    "springer .",
    "poole , d. 2008 . the independent choice logic and beyondin raedt , l.  d. , frasconi , p. , kersting , k. ,  muggleton , s. , probabilistic inductive logic programming , 4911 of lecture notes in computer science ,  222243 .",
    "springer .",
    "poole , d.   crowley , m. 2013 .",
    "cyclic causal models with discrete variables : markov chain equilibrium semantics and sample orderingin international joint conference on artificial intelligence ( ijcai ) ,  10601068 .",
    "riguzzi , f. 2015 .",
    "the distribution semantics is well - defined for all normal programsin riguzzi , f.   vennekens , j. , international workshop on probabilistic logic programming ,  1413 of ceur workshop proceedings ,  6984 ."
  ],
  "abstract_text": [
    "<S> we examine the meaning and the complexity of probabilistic logic programs that consist of a set of rules and a set of independent probabilistic facts ( that is , programs based on sato s distribution semantics ) . </S>",
    "<S> we focus on two semantics , respectively based on stable and on well - founded models . </S>",
    "<S> we show that the semantics based on stable models ( referred to as the `` credal semantics '' ) produces sets of probability models that dominate infinitely monotone choquet capacities ; we describe several useful consequences of this result . </S>",
    "<S> we then examine the complexity of inference with probabilistic logic programs . </S>",
    "<S> we distinguish between the complexity of inference when a probabilistic program and a query are given ( the _ inferential _ complexity ) , and the complexity of inference when the probabilistic program is fixed and the query is given ( the _ query _ complexity , akin to _ data _ complexity as used in database theory ) . </S>",
    "<S> we obtain results on the inferential and query complexity for acyclic , stratified , and cyclic propositional and relational programs ; complexity reaches various levels of the counting hierarchy and even exponential levels . </S>"
  ]
}