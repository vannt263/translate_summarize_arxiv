{
  "article_text": [
    "the work of shannon @xcite , information theory has sought to determine how much information can be communicated over a noisy channel ; modern coding theory has sought ways to achieve this capacity using error control codes . a standard channel model is the additive white gaussian noise ( awgn ) channel , for which the maximum rate of information that can be reliably communicated ( known as the capacity ) is known and depends on the transmission power .",
    "this model does not , however , consider the energy it takes to encode and decode ; a full understanding of energy use in a communication system requires taking into account these encoding and decoding energies , along with the transmission energy .",
    "currently there has been very little work done in seeking a fundamental understanding of the energy required to execute an error control coding algorithm .",
    "early work in relating the area of circuits and number of clock cycles in circuits that perform decoding algorithms was presented by el gamal _ et al .",
    "_ in @xcite .",
    "more recent work in trying to find fundamental limits on the energy of decoding can be attributed to grover _ et al . _ in @xcite . in this work",
    ", the authors consider decoding schemes that are implemented using a vlsi model attributed to thompson @xcite ( which we will describe later ) , and they are able to show that for any code , using any decoding algorithm , as the required block error probability approaches @xmath6 , the sum of the transmission , encoding , and decoding energy , per bit , must approach infinity at a rate of @xmath7{\\frac{1}{\\log p_{e}^{\\text{blk}}}}\\right)$ ] , where @xmath8 is the block error probability of the code .",
    "this result is useful to the extent that it suggests how to judge the energy complexity of low error probability codes ; however , it does not suggest how the energy complexity of decoding scales as capacity is approached .",
    "the result of this paper uses a similar approach to grover _ et al .",
    "_ , but we generalize the computation model to both parallel and serial computation , and show how the energy of low block error rate decoders must scale with block length @xmath9 .",
    "we believe that this approach can guide the development of codes and decoding circuits that are optimal from an energy standpoint .    in this paper , in section",
    "[ sec : vlsi - model ] we will describe the vlsi model that will be used to derive our bounds on decoding energy .",
    "our results apply to a decoder for a standard binary erasure channel , which will be formally defined in section [ sec : channel - model ] . in section [ sec : existing - results ] we will describe some terminology and some key lemmas used in our paper .",
    "the main contribution of this paper will be given in section [ sec : key - result - of ] where we describe a scaling rule for codes with long block length that have asymptotic error probability less than @xmath0 .",
    "the approach used in this section is extended in section [ sec : serialcomp ] to find a scaling rule for serial computation .",
    "then , in section [ generalcase ] we extend the approaches of the previous sections to derive a non - trivial super - linear lower bound on circuit energy complexity for a series of decoders in which the number of output pins can vary with increasing block length .",
    "these results are applied to find a scaling rule for the energy of capacity approaching decoders as a function of fraction of capacity in section [ sec : consequences ] .",
    "we then give a simple example in section [ sec : upperbound ] showing how an ldpc decoder can be implemented with at most @xmath10 energy , providing an upper bound to complement our fundamental lower bound .",
    "_ notation : _ to aid our discussion of scaling laws , we use standard big - oh and big - omega asymptotic notation , which is well discussed in @xcite .",
    "we say that a function @xmath11 if and only if there is some @xmath12 and some @xmath13 such that for all @xmath14 , @xmath15 .",
    "similarly , we say that @xmath16 if and only if @xmath17 .",
    "intuitively , this means that the function @xmath18 grows at least as fast ( in an order sense ) as @xmath19 and hence we use it with lower bounds . in the following , a sequence of values @xmath20",
    "is denoted @xmath21 .",
    "random variables are denoted with upper case letters ; values in their sample spaces are denoted with lower - case letters .",
    "the vlsi model that we will use is based on the work of thompson  @xcite , and was used by el gamal in @xcite and grover _ et al . _ in @xcite .",
    "the model consists of a basic set of axioms that describe what is meant by a vlsi circuit and a computation .",
    "the model then relates two parameters of the circuit and computation , namely the number of clock cycles used for the computation and the area of the circuit , to the energy used in the computation .",
    "thompson used this model to compute fundamental bounds on the energy required to compute the discrete fourier transform , as well as other standard computational problems , including sorting .",
    "the results in this paper apply to any circuit implemented in a way that is consistent with these axioms , listed as follows :        * a circuit consists of two types of components : wires and nodes .",
    "in such a circuit , wires carry binary messages and nodes can perform simple computations ( _ e.g. _ , and , xor ) , all laid out on a grid of squares .",
    "wires carry information from one node to another node .",
    "wires are assumed to be bi - directional ( at least for the purpose of lower bounds ) . in each clock cycle",
    ", each node sends one bit to each of the nodes it is connected to over the wire .",
    "we in general allow a node to perform a random function on its inputs . in a deterministic function ,",
    "the output of the function is determined fully by its inputs . by a random function",
    "we mean that the outputs of a particular node , conditioned on the inputs being some element from the set of possible inputs , is a distribution @xmath22 where @xmath23 is a random variable representing the possible outputs of the node and @xmath24 a random variable representing the inputs of a node . in the particular case of a node with @xmath25 input wires ( and thus @xmath25 output wires because of our bidirectional assumption on the wires ) the random variables @xmath24 and @xmath23 can take on values from @xmath26 . *",
    "a vlsi circuit is a set of computational nodes connected to each other using finite - width bi - directional wires . at each clock cycle , nodes communicate with the other nodes to which they are connected .",
    "computation terminates at a pre - determined number , @xmath27 , of clock cycles .",
    "* wires run along edges and cross at grid points .",
    "there is only one wire per edge .",
    "each grid point contains a logic element , a wire crossing , a wire connection , or an input / output pin .",
    "grid points can be empty .",
    "a computational node is a grid point that is either a logic element , a wire - connection , or an input / output pin .",
    "* the circuit is planar , and each node has at most @xmath25 wires leading from it .",
    "* inputs of computation are stored in source nodes and outputs are stored in output nodes .",
    "the same node can be a source node and an output node .",
    "each input can enter the circuit only at the corresponding source node . * each wire has width @xmath28 .",
    "any two wires are separated by at least the wire - width .",
    "any grid points are separated by distance at least @xmath28 .",
    "each node is assumed to require at least @xmath29 wire area ( length and width at least @xmath28 ) .",
    "* processing is done in `` batches , '' in which a set of inputs is processed and outputs released before the next set of inputs arrive . *",
    "energy consumed in a computation is proportional to @xmath30 where @xmath31 is the area occupied by the wires and nodes of the circuit and @xmath27 is the number of clock cycles required to execute the computation .",
    "precisely , the energy is assumed to be @xmath32 where @xmath33 , where @xmath34 is the capacitance per unit wired area of the circuit , and @xmath35 is the voltage used to drive the circuit .",
    "the quantity @xmath36 is denoted by @xmath37 , which is the `` energy parameter '' of the circuit .",
    "processing energy for computation , @xmath38 , is thus given by @xmath39 .",
    "since energy of a computation in our model and the area time complexity are essentially the same , in this paper we use the terms `` energy complexity '' and `` area - time '' complexity interchangeably .",
    "the circuit model described above allows us to consider a circuit as a graph in which the computational nodes correspond to the nodes of a graph and the wires correspond to edges .",
    "the last assumption of our model , which relates the area and number of clock cycles to energy consumed in a circuit , assumes that a vlsi circuit is fully charged and then discharged to ground during each clock cycle . since the wires in a circuit",
    "are made of conducting material and are laid out essentially flat , the circuit will have a capacitance proportional to the area of the wires .",
    "assuming that all the wires will need to be charged at each clock cycle , there must be @xmath40 energy supplied to the circuit .",
    "for now , we do not consider what will happen if at each clock cycle the state of some of the wires does not change . in the literature ( see @xcite and @xcite ) this model is often used to understand power consumption in a digital circuit so we do not attempt to alter these assumptions for the purposes of this paper . sometimes leakage current of the circuit",
    "is factored into such models ; we also neglect this as we assume the frequency of computation is high enough so that the power used in computation dominates .",
    "there has been some work to understand the tradeoff between computational complexity and code performance .",
    "one such example is @xcite , in which the complexity of a gallager decoding algorithm b was optimized subject to some coding parameters .",
    "this however does not correspond to the energy of such algorithms .",
    "in @xcite it was proven that the area - time complexity of any circuit implemented according to this vlsi model that computes a discrete fourier transform must scale as @xmath41 .",
    "however , there exist algorithms that compute in @xmath42 operations ( for example , see @xcite ) ; thompson s results thus imply that , for at least some algorithms , energy consumption is _ not _ merely proportional to the computational complexity of an algorithm .    in the field of coding theory , grover _",
    "_ in @xcite provided an example of two algorithms with the same computational complexity but different computational energies .",
    "the authors looked at the girth of the tanner graph of an ldpc code .",
    "the girth is defined as the minimum length cycle in the tanner graph that represents the code .",
    "they showed , using a concrete example , that for ( 3 , 4)-regular ldpc codes of girth 6 and 8 decoded using the gallager - a decoding algorithm , the decoders for girth 8 codes can consume up to 36% more energy than those for girth 6 codes .",
    "the girth of a code does not necessarily make the decoding algorithm require more computations ( _ i.e. _ , it does not increase computational complexity ) , but , for this example , it _ does _ increase the energy complexity .",
    "this is because codes with greater girth require the interconnection between nodes to be more complex , even though the same number of computational nodes and clock cycles may be required .",
    "this drives up the area required to make these interconnections , and thus drives up the energy requirements .",
    "also in the field of coding theory , the work of thorpe @xcite has shown that a measure of wiring complexity of an ldpc decoder can be traded off with decoding performance .",
    "thus , current research suggests that in decoding algorithms there appears to be a fundamental trade - off between code performance and interconnect complexity .",
    "this paper attempts to find an analytical characterization of this trade - off .",
    "our paper considers a generic model of computation , but of course it does not completely reflect all methods of implementing a circuit .",
    "we discuss some circuit design techniques that our model does not directly consider below .",
    "modern vlsi circuits differ from the thompson model in that the number of vlsi layers is not one ( or two if one counts a wire crossing as another layer ) .",
    "modern vlsi circuits allow multiple layers . fortunately",
    ", it is known that if @xmath43 layers are allowed , then this can decrease the total area by at most a factor of @xmath44 ( see , for example , @xcite or @xcite ) . for the purposes of our lower bounds , if the number of layers remains constant as @xmath9 increases , we can modify our energy lower bound results by dividing the lower bounds by @xmath44 .",
    "if , however , the number of layers can grow with @xmath9 our results may no longer hold .",
    "note also that this only holds for the purpose of lower bound .",
    "it may not be possible to implement a circuit with an area that decreases by a factor of @xmath44 , and so the upper bounds of section [ sec : upperbound ] can not be similarly modified .",
    "the model used in this paper assumes that after every clock cycle the circuit is entirely discharged and the energy used to charge the circuit is lost .",
    "there exists extensive research into circuit designs in which this is not the case ( for an overview of this type of computing , called adiabatic computing , see @xcite ) .",
    "our results do not apply to such circuit designs .",
    "the thompson model does not allow for the use of special memory nodes in computation that can hold information and compute the special function of loading and unloading from memory .",
    "such a circuit can be created using the thompson model , but it may be that a strategic use of a lower energy memory element can decrease the total energy of a computation . intuitively , however , the use of a memory element to communicate information within a circuit should still be proportional to the distance that information is communicated .",
    "grover in @xcite proposed a `` bit - meters '' model of energy computation and derives scaling rules similar to our results , suggesting that , at least in an order sense , the circuit model we use is general enough to understand the scaling of high block length codes even if lower energy memory is used . understanding precisely what kind of gain the use of a memory element can provide in energy complexity is beyond the scope of this paper .",
    "we will consider a noisy channel model that is similar to the model used by grover _",
    "et al . _ in @xcite .",
    "an information sequence of @xmath45 independent fair coin flips @xmath46 is encoded into @xmath47 binary - alphabet codewords @xmath48 ; and thus this code has rate @xmath49 bits / channel use .",
    "the sequence @xmath50 is passed through a binary erasure channel with erasure probability @xmath51 , resulting in a received vector @xmath52 , where the @xmath53 symbol corresponds to the erasure event .",
    "the decoder estimates the input sequence @xmath54 by computing a function of the received vector @xmath55 .",
    "the outputs of the noisy channel thus become inputs into the decoder circuit . in our most general model of computation , it is required that these channel outputs are eventually input into an input node of the circuit . in a parallel implementation model used for theorem [ maintheorem ] , each of these @xmath9 decoder input symbols are input , at the beginning of the computation , into the @xmath9 input nodes of the decoder . in a more general computational model used in theorems [ serialtheorem ] and [ generaltheorem ]",
    ", it is assumed that each of these symbols are input into the input nodes of the decoder during some clock cycle in the computation .",
    "note that we allow each of the @xmath9 symbols to be inserted into the circuit at any input node location during any clock cycle , but we also require , according to our model , that each input is injected only once into the circuit . thus , our model does not subsume circuit implementations that , at no cost , allow the same input symbol to be inserted into the circuit in multiple places .    the probability of block error is defined as @xmath56 the lower bounds used in our result are valid for a binary erasure channel , but also for any channel that can result from a degraded version of a binary erasure channel . hence ,",
    "if we let @xmath57 then our results apply to lower bounds on decoders for binary symmetric channels with crossover probability @xmath58 .",
    "the main theorems in this paper rely on the evaluation of a particular limit , which we present as a lemma below .",
    "[ limitlemma ] for any constant @xmath59 , @xmath60 , and any constant @xmath61 : @xmath62    this result follows simply from taking the logarithm of the expression in ( [ eq : keylimitused ] ) and using lhpital s rule to show that the logarithm approaches @xmath63 .",
    "grover _ et al .",
    "_ in @xcite used a nested bisection technique , involving subdividing circuits , to derive the two key lemmas used in this paper .",
    "a circuit created according to the thompson model can be considered a graph in which the computational nodes correspond to graph vertices and the wires are graph edges . to understand these lemmas we must first understand what is meant by ( a ) a minimum bisection of a circuit and ( b ) a nested bisection of a circuit .",
    "informally , a bisection of a graph is a set of edges whose removal results in at least two graphs of essentially the same size that are unconnected to each other .",
    "a bisection can also be defined in terms of separating a particular subset of vertices .",
    "a formal definition is given below .",
    "let @xmath64 be a graph .",
    "let @xmath65 be a subset of the vertices , and @xmath66 be a subset of the edges .",
    "then @xmath67 _ bisects _ @xmath68 in @xmath69 if deletion of the edges in @xmath67 from the graph cuts @xmath70 into disconnected sets @xmath71 and @xmath72 , with @xmath73 , and @xmath68 into sets @xmath74 and @xmath75 such that @xmath76 .",
    "a bisection of @xmath70 in @xmath69 is called a bisection of @xmath69 .",
    "a minimal bisection is a bisection of a graph whose size is minimal over all bisections .",
    "the _ minimum bisection width _ is the size of a minimal bisection .",
    "for a general graph , finding a minimum bisection is a difficult problem ( in fact , it is np - complete @xcite ) , but all that is required for the results we will use is that a minimum bisection exists for every graph .",
    "[ minimumbisectionwidth ] shows minimal bisections of a few simple graphs .",
    "note that the definition of a minimum bisection also applies to subsets of the vertices of a graph .",
    "a circuit has both input nodes and output nodes .",
    "the input ( resp . output ) nodes of the graph corresponding to a circuit are those nodes of the graph that correspond to the input ( resp .",
    "output ) nodes of the circuit .",
    "for the purposes of the results in this paper , we will consider bisections of the graph that bisect the output nodes .",
    "we will also be using some other terms throughout the paper which we define below .    if one performs a minimum bisection on the output nodes of the graph corresponding to the interconnection graph of a circuit , this results in @xmath77 disconnected subcircuits .",
    "the output nodes of these two ( now disconnected ) subcircuits can thus each be minimally - bisected again , resulting in @xmath25 subcircuits .",
    "this process , when repeated @xmath78 times , is said to perform an _",
    "@xmath78-stage nested minimum bisection_. note that this divides the graph into @xmath79 disconnected components , which we will refer to as _",
    "when a circuit is viewed as a graph , a subcircuit can be viewed as a subgraph induced by a nested minimum bisection . when viewed as a circuit according to the thompson model",
    ", it is a collection of computational nodes joined by wires laid out on a grid pattern .",
    "an example of a mesh - like circuit with 16 nodes undergoing two stages of nested minimum bisections is shown in fig .",
    "[ nestedbisectionexamples ] .",
    "after a circuit undergoes @xmath78-stages of nested minimum bisections , label each of the @xmath79 subcircuits with a unique integer @xmath80 in which @xmath81 . consider a particular subcircuit @xmath80 . during the @xmath78-stages of",
    "nested minimum bisections , a number of edges @xmath82 are removed that are incident on the graph corresponding to subcircuit @xmath80 ( we can think of this as the `` fan - out '' of this subcircuit ) .",
    "[ def : bidefn ] during the course of the computation , the number of bits communicated to subcircuit @xmath80 is @xmath83 , where @xmath27 is the number of clock cycles , and we refer to @xmath84 as the _ bits communicated to subcircuit @xmath80 during a computation_.    the quantity @xmath84 is associated with a particular subcircuit induced by a particular @xmath78-stage nested minimum bisection . when discussed , this quantity s association with a particular @xmath78-stage nested minimum bisection is implicit .",
    "[ defn : br ] the quantity @xmath85 denotes the _ number of bits communicated across all edges deleted in an @xmath78-stage nested minimum bisection . _ note that this is a quantity associated with a particular @xmath78-stage nested minimum bisection .",
    "the quantity @xmath86 will be important in the proofs of the theorems in the paper .",
    "specifically , it can be shown that if a decoding circuit ( which we will define below ) has a large @xmath86 for a particular @xmath78-stage nested minimum bisection , then the energy expended during a computation by this circuit must be high .",
    "as well , it can be shown that if this quantity is low , then the probability that the circuit makes an error is high .",
    "the above definitions are general and can apply to the computation of any function .",
    "however , for our bounds we will be finding lower bounds on the energy complexity of decoding circuits .",
    "an @xmath87 _ parallel decoding circuit _ is a circuit that has @xmath9 input nodes ( accepting symbols in @xmath88 ) and @xmath45 output nodes ( producing symbols in @xmath89 ) .",
    "the @xmath9 input nodes are to receive the outputs of a noisy channel ( which for the purposes of lower bound we assume to be a binary erasure channel with erasure probability @xmath51 ) . at the end of the computation the decoder is to output the estimate of the original codeword .",
    "note that this circuit decodes a rate @xmath49 code .",
    "note that in the thompson model it is assumed that all inputs are binary .",
    "for the purposes of lower bound , we allow for the inputs into the computation to be either @xmath6 , @xmath90 or @xmath53 , where @xmath53 is the erasure symbol . at every clock cycle , we allow input nodes to perform a function on their input symbol , as well as the bits input into the node at the clock cycle . these nodes",
    "may then output any function of these inputs along the wires leading from the node .",
    "this definition will be generalized to serial computation models in the discussions preceding theorem  [ serialtheorem ] .",
    "note also that our model of a decoding circuit allows for an input to be an erasure symbol , which is a slight relaxation of the thompson circuit model .",
    "however , in our theorems , the key point will be that , if in a particular subcircuit all the @xmath91 input nodes of that subcircuit are erased , then , _ conditioned on this event _ , the distribution of the possible original inputs to the channel of the @xmath92 bits that a subcircuit @xmath80 is to estimate remains uniform .",
    "this is a result of the symmetric nature of a binary erasure channel , and this will allow us to directly apply lemma  [ pidgeonholelemma ] to form lower bounds on probability of error .",
    "after a decoding circuit undergoes @xmath78-stages of nested minimum bisections , each subcircuit will have roughly an equal number of output nodes , but the number of input nodes may vary ( the actual number of input nodes in each subcircuit in general will be a function of the particular graph structure of the circuit , and the particular @xmath78-level nested minimum bisection performed ) .    [",
    "def : nidefn ] we refer to this quantity as the _ number of input nodes in subcircuit @xmath80 _ and denote it @xmath93 .    note that this quantity is determined by the particular @xmath78-stage nested minimum bisection , but for notational convenience we will consider the relation of this quantity to the particular structure of the @xmath78-stage nested minimum bisection to be implicit .    a particular @xmath80th subcircuit formed by an @xmath78-stage nested minimum",
    "bisection will have a certain number of output nodes , which we denote @xmath92 .",
    "this quantity is referred to as the _ number of output nodes in subcircuit @xmath80_.    in a fully parallel computation model ( which we will employ in theorem  [ maintheorem ] ) , at the end of the computation , these output nodes are to hold a vector @xmath94 , where the vector to be estimated is a vector @xmath95 which is produced by a series of fair coin flips as described in section  [ sec : channel - model ] . since at the end of the computation these output nodes are to hold an estimate of a vector of length @xmath92 it is said that in this case @xmath92 is the _ number of bits responsible for decoding by subcircuit @xmath80_. the probability of error for a subcircuit is precisely the probability that , after the end of the computation , @xmath96 .    [",
    "pidgeonholelemma ] suppose that @xmath24 , @xmath23 , and @xmath97 are random variables that form a markov chain @xmath98 .",
    "suppose furthermore that @xmath24 takes on values from a finite alphabet @xmath99 with a uniform distribution ( i.e. , @xmath100 for any @xmath101 ) and @xmath23 takes on values from an alphabet @xmath102 .",
    "suppose furthermore that @xmath97 takes on values from a set @xmath103 such that @xmath104 .",
    "then , @xmath105    this general lemma is meant to make rigorous a fundamental notion that will be used in this paper . as applied to our decoding problem , the random variable @xmath24 can be thought of as the input to a binary erasure channel , and @xmath23 can be any inputs into a subcircuit of a computation , and @xmath97 can be thought of as a subcircuit s estimate of @xmath24 .",
    "this lemma makes rigorous the notion that if a subcircuit has fewer bits input into it than it is responsible for decoding , then the decoder must guess at least @xmath90 bit , and makes an error with probability at least @xmath0 .",
    "this scenario is actually a special case of this lemma in which @xmath106 and @xmath107 for integers @xmath45 and @xmath108 , where @xmath109 .    clearly , by the law of total probability ,    @xmath110    where we simply expand the term in the summation according to the definition of a markov chain . using @xmath111",
    "we get : @xmath112 and using @xmath113 because it is a probability , and changing the order of summation gives us : @xmath114 since @xmath115 ( as we are summing over a subset of values that @xmath97 can take on ) , we get : @xmath116    in the proofs of the theorems in this paper , we will be dividing a circuit up into pieces and then we will let @xmath9 grow larger . technically , a circuit can only be divided into an integer fraction of pieces . however , in most cases this does not matter . to make this notion rigorous , we will need to use the following lemma :    [ roundingerrorlemma ] let @xmath117 be a function such that @xmath118 for sufficiently large @xmath119 and some positive constant @xmath120 .",
    "if there are functions @xmath121 , and @xmath122 is continuous for sufficiently large @xmath119 , and if @xmath123 for some constant @xmath124 , and if @xmath125 then @xmath126 .",
    "suppose @xmath127    to show that @xmath126 we need to construct , given some @xmath51 , a particular @xmath13 such that for all @xmath128 @xmath129 .",
    "since @xmath122 grows unbounded , and is continuous for sufficiently large @xmath119 , then there must be a particular value of @xmath119 ( call it @xmath130 ) such that @xmath19 takes on all values greater than @xmath131 for some @xmath132 .",
    "as well , for any @xmath133 there exists some @xmath134 such that for all @xmath135 , @xmath136 .",
    "in particular this is true for some @xmath137 .",
    "thus , choose @xmath13 to be the least number",
    "greater than @xmath134 in which @xmath138 ( this must exist because @xmath122 takes on all values greater than @xmath139 ) .",
    "thus , for @xmath140 @xmath141 only takes on values greater than @xmath139 ( because @xmath118 ) . since @xmath136 for all @xmath135 , thus @xmath129 for all @xmath140 , since @xmath141 can only take on values that @xmath19 takes on for @xmath135 .",
    "this result applies when @xmath142 is the floor function , denoted@xmath143 , since @xmath144 .",
    "we will need to make one observation that will be used in the three main theorems of this paper , which we present in the lemma below .",
    "[ convexoptimizationlemma ] if @xmath133 and @xmath145 are positive integers subject to the restriction that @xmath146 then : @xmath147    the proof follows from a simple convex optimization argument .",
    "-stages of nested minimum bisections . in these two stages of nested minimum bisections , we see that @xmath148 wires are cut . because we assume wires are bidirectional , and thus two bits are communicated across these wires every clock cycle , in the case of this circuit we have @xmath149 , where @xmath27 is the number of clock cycles",
    ". it will not be important how to actually do these nested bisections , rather it is important only to know that any circuit can undergo these nested bisections . ]",
    "grover _ et al . _ in @xcite uses a nested bisection technique to prove a relation between energy consumed in a circuit computation and bits communicated across the @xmath78-stages of nested bisections which we present as a series of two lemmas , the second which we will use directly in our results .",
    "[ atausquaredlemma ] for a circuit undergoing @xmath78-stages of nested bisections , in which the total number of bits communicated across all @xmath78-stages of nested bisections is @xmath86 , then @xmath150 where @xmath151 is the area of the circuit and @xmath27 is the number of clock cycles during the computation .",
    "see @xcite for a detailed proof . here",
    "we provide a sketch . to accomplish this proof , @xmath78-stages of nested minimum bisections on a circuit",
    "are performed and then a principle due to thompson @xcite is applied that states that the area of a circuit is at least proportional to the square of the minimum bisection width of the circuit .",
    "also , the number of bits communicated to a subcircuit can not exceed the number of wires entering that subcircuit multiplied by the number of clock cycles .",
    "the area of the circuit ( related to the size of the minimum bisections performed ) and the number of clock cycles ( more clock cycles allow more bits communicated across cuts ) are then related to the number of bits communicated across all the edges deleted during the @xmath78-stages of nested bisections .",
    "[ lem : edeclemma ] if a circuit as described in lemma  [ atausquaredlemma ] in addition has at least @xmath152 nodes , then the @xmath153 complexity of such a computation is lower bounded by : @xmath154    following the same arguments of grover _ et al . _ in @xcite ( which we reproduce to get the more general result we will need ) , note that if there are at least @xmath152 computational nodes , then @xmath155 which , when combined with lemma  [ atausquaredlemma ] results in : @xmath156 which yields the statement of the lemma upon taking the square root .    in terms of our energy notation , the result of lemma  [ lem : edeclemma ] implies that for such a circuit with at least @xmath152 computational nodes , the energy complexity is lower bounded by : @xmath157 where @xmath158.[bondforatau ]      the key lemma that will be used in the first theorem of this paper is due to grover _ et al .",
    "we modify the lemma slightly .",
    "[ lem : peblocklemma ] for any code implemented using the vlsi model for an erasure channel with erasure probability @xmath51 , for any @xmath159 , @xmath160    the proof uses the same approach as grover _",
    "_ in @xcite but we modify it slightly to ease the use of our lemma for our theorem and to conveniently deal with the possibility that a decoder can guess an output of a computation .",
    "let @xmath161 be the number of input bits erased in the @xmath80th subcircuit after @xmath78-stages of nested bisections .",
    "furthermore , recall from definition [ def : bidefn ] that @xmath162 is the number of bits injected into the @xmath80th subcircuit during the computation . also , recall from definition [ def : nidefn ] that @xmath91 is the number of input nodes located within the @xmath80th subcircuit .",
    "we use the principle that if @xmath163 for any subcircuit then the probability of block error is at least @xmath0 .",
    "this is a very intuitive idea ; if the number of bits that are not erased , plus the number of bits injected into a circuit is less than the number of bits the circuit is responsible for decoding , the circuit must at least guess @xmath90 bit .",
    "this argument will be made formal in the proof that follows .",
    "( of lemma [ lem : peblocklemma ] ) suppose that all the @xmath91 input bits injected into the @xmath80th subcircuit are the erasure symbol .",
    "then , conditioned on this event , the distribution of the @xmath92 bits that this subcircuit is to estimate is uniform ( owing to the symmetric nature of the binary erasure channel ) . furthermore",
    ", if @xmath164 then the number of bits injected into the subcircuit is less than the number of bits the subcircuit is responsible for decoding . combining these two facts allows us to apply lemma  [ pidgeonholelemma ] directly to conclude that , in the event all the inputs bits of a subcircuit are erased , and the number of bits injected into the subcircuit is less than @xmath165 , then the subcircuit makes an error with probability at least @xmath0 .",
    "denote the event that all inputs bits in subcircuit @xmath80 are erased as @xmath166 .",
    "the probability of this event is given by @xmath167    suppose that @xmath168 ( where we recall from definition [ defn : br ] that @xmath86 is the total number of bits communicated across all edges cut in @xmath78-stages of nested minimum bisections ) .",
    "let @xmath169 be the set of indices @xmath80 in which @xmath162 ( the bits communicated to the @xmath80th subcircuit ) is smaller than @xmath165 . we first claim that @xmath170 .",
    "to prove this claim , let @xmath171 and note that @xmath172 , from which it follows that @xmath173 . since @xmath174 , the claim follows .    hence , in the case that @xmath175 , because of the law of total probability : @xmath176 where the event @xmath177 is the event that each of the subcircuits indexed in @xmath68 , after @xmath78-stages of nested bisections , do not have all their @xmath93 input bits erased .",
    "we then note that , in this case , the probability of the circuit being decoded correctly is at most @xmath90 . for the second term",
    ", we note that conditioned on the event that at least one of the subcircuits indexed in @xmath68 has all their input bits erased , since the circuit must at least guess @xmath90 bit , the probability of the circuit decoding successfully is at most @xmath0 , by lemma [ pidgeonholelemma ] .    since @xmath178 ,",
    "subject to this restriction , lemma [ convexoptimizationlemma ] shows the expression in ( [ eq : usinglawoftotal ] ) is maximized when @xmath179 for each subcircuit in @xmath68 .",
    "hence , @xmath180 thus , either @xmath181 or @xmath182 which implies @xmath183 and so @xmath184",
    "we define a coding scheme as a sequence of codes of fixed rate together with decoding circuits , in which the block length of each successive code increases .",
    "we define @xmath185 as the block error probability for the decoder of block length @xmath9 in this scheme .",
    "an example of a coding scheme would be a series of regular ldpc codes together with ldpc decoding circuits in which the block length @xmath9 doubles for each decoder in the sequence .",
    "our results are general and would apply to any particular coding scheme using any circuit implementation and any decoding algorithm .",
    "the key result of this paper is given in the following theorem :    [ maintheorem ] for every coding scheme in which @xmath186 , there exists some @xmath187 such that for all @xmath188 , for any circuit implemented according to the vlsi model with parameters @xmath37 and @xmath28 , @xmath189 where @xmath190 is the energy used in the decoding and @xmath191 is a constant that depends on circuit technology parameters that we defined before .",
    "the requirement that @xmath186 for our bound in ( [ eq : theoremtoprove ] ) though reasonable , is not necessary for a good design .",
    "typical block error probability requirements may be on the order of @xmath192 or @xmath193 , although if the block error probabilities are lower bounded by @xmath0 for a series of decoding schemes , this is not necessarily a bad design .",
    "the individual bit error probabilities ( the probability that a randomly selected output bit of the decoder is decoded correctly ) may indeed be acceptably low",
    ". however , our results do not consider such schemes .",
    "it is also not necessary for a decoding scheme to have a block length that gets arbitrarily large .",
    "however , a capacity - approaching code must have block length that approaches infinity and our result can be used to understand how the energy complexity of such decoding algorithms approach infinity .",
    "the theorem follows from an appropriate choice for @xmath78 , the number of nested bisections we perform",
    ". we can choose any nonnegative integer @xmath78 so that @xmath159 .",
    "note that @xmath194 is the number of bits the decoder is responsible for decoding . as @xmath45 gets large",
    ", we can thus choose any @xmath78 so that @xmath195 .",
    "thus , we choose an @xmath78 so that , approximately , @xmath196 , for a value of @xmath197 which we will choose later . in particular , we will choose @xmath198 .",
    "this is valid so long as @xmath9 is sufficiently large , for some @xmath199 .",
    "note that @xmath200 since @xmath201 .",
    "since @xmath202 , this is a valid choice for @xmath78 so long as @xmath203 which must occur as the left side of the inequality approaches @xmath6 as @xmath9 gets large .",
    "we can plug this value for @xmath78 into lemma  [ lem : peblocklemma ] , but we will simplify the expression by neglecting the floor function , as application of lemma  [ pidgeonholelemma ] will show that this does not alter the evaluation of the limit that we will compute , as we can see our choice for @xmath78 grows unbounded with @xmath9 . thus , either @xmath204 or , applying lemma  [ lem : edeclemma ] by recognizing that there are at least @xmath205 nodes , @xmath206 by a direct application of lemma  [ limitlemma ] , so long as @xmath207 , the bound in ( [ eq : boundtofindlimitof ] ) approaches @xmath0 which we can see as follows : @xmath208 this implies that , in the limit of large block sizes , the probability of block error must be lower bounded by @xmath0 , unless @xmath209 .",
    "but then by ( [ iflimitisnotoverhalf ] ) , it must be that @xmath210 which is the result we are seeking to prove .",
    "the following corollary is immediate .",
    "if a sequence of decoding schemes in which in the limit of large @xmath9 @xmath211 , the average decoding energy , per decoded bit ( which we denote @xmath212 ) is bounded as : @xmath213    the proof follows simply by dividing ( [ eq : whattodivivebynr ] ) by @xmath214 , the number of bits such a code is responsible for decoding .",
    "our result in section  [ sec : key - result - of ] applies to decoders implemented entirely in parallel ; however , this does not necessarily reflect the state of modern decoder implementations .",
    "below we provide a modified version of the thompson vlsi model that allows for the source of the computation to be input serially and the outputs to be computed serially .    in this modified model , we assume that the circuit computes a function of @xmath9 inputs and @xmath45 outputs",
    ". however , instead of having @xmath9 input nodes and @xmath45 output nodes , the circuit has @xmath215 input nodes and @xmath216 output nodes .",
    "the computation terminates after a set @xmath27 number of clock cycles , and during the @xmath27 clock cycles , the inputs to the computation may be input into the @xmath215 input nodes ( where @xmath215 bits at most can be input during a single clock cycle ) , and the outputs of the computation must appear in the output nodes during specified clock cycles of the computation .",
    "[ simpleboundfortau ] the number of clock cycles @xmath27 must at least be enough to output all the bits .",
    "if there are @xmath216 output nodes and @xmath45 outputs to the function being computed , then there must be at least @xmath217 clock cycles .",
    "if all the inputs into the computation are being used , then there must also be at least @xmath218 clock cycles , though it is technically possible for some functions to have inputs that `` do nt matter '' so this is not a strict bound for all functions .    hence , a lower bound on the energy complexity for this computation is : @xmath219 where @xmath31 is the area of the circuit .",
    "[ serialtheorem]suppose there is a sequence codes together with decoding schemes with rate @xmath220 and block length @xmath9 approaching infinity .",
    "we label the block error probability of the length @xmath9 decoder as @xmath221 .",
    "also suppose that the number of output pins remains a constant @xmath216 . then either ( a ) @xmath222 or ( b ) there exists some @xmath223 such that for all @xmath9 greater than @xmath223 @xmath224    to prove this theorem , instead of dividing the circuit into subcircuits , we will divide the computation conceptually in time , by dividing the computation into epochs .",
    "more precisely , consider dividing the computation outputs into chunks of size @xmath108 ( with the exception of possibly one chunk if @xmath108 does not evenly divide @xmath45 ) , meaning that there are @xmath225 such chunks .",
    "hence , the outputs , which can be labeled @xmath226 can be divided into groups , or a collection of subvectors @xmath227 in which @xmath228 , @xmath229 and so on , until @xmath230 .",
    "the set of clock cycles in the computation in which the bits in @xmath231 are output is considered to be the _",
    "@xmath80th epoch_.    in our analysis , we are interested in analyzing the decoding problem for chunks of the output as defined above for an @xmath108 that we will choose later for the convenience of our theorem .",
    "we are also interested in another set of quantities : the input bits injected into the circuit between the time when the last of the bits in @xmath232 are output and the first of the bits in @xmath233 bits are output .",
    "label the collection of these bits as @xmath234 .",
    "label the size of each of these of these subvectors as @xmath235 , so that the number of bits injected before all of the bits in @xmath236 are computed is @xmath237 , and the number of those injected after the first @xmath237 bits are injected and until the clock cycle when the last of the bits in @xmath238 are output is @xmath239 , and so on .",
    "let @xmath240 be the number of erasures that are injected into the circuit during the @xmath80th epoch .",
    "note that by lemma  [ pidgeonholelemma ] an error occurs when @xmath241 where @xmath242 is the maximum number of bits that can be stored in the circuit , remembering that according to the computation model the maximum number of bits that can be stored in a circuit must be proportional to the area of the circuit , as each wire in the circuit at any given time in the computation can hold only the value @xmath90 or @xmath6 .",
    "( of theorem [ serialtheorem ] ) suppose we divide the circuit into chunks each of size @xmath243 , @xmath216 more than the normalized circuit area .",
    "then , if all the bits @xmath93 are erased , the probability that at least one of the bits of @xmath232 is not decoded must at least be @xmath0 , because there are simply not enough non - erased inputs for the circuit to infer the @xmath108 bits it is responsible for decoding in that window of time . note that we choose @xmath244 so that an error event occurs with probability at least @xmath0 when all the @xmath93 bits are erased , because it is technically possible that in a clock cycle that outputs the last of the bits of @xmath232 , @xmath245 bits of @xmath233 are output .",
    "then , the number of bits required to be computed for the next chunk of outputs is at least @xmath246 .",
    "let the size of each @xmath232 ( except possibly @xmath247 ) be @xmath243 .",
    "similar to what we did for in section  [ sub : bound - on - block ] , denote the event that all input bits in @xmath248 are erased as @xmath249 .",
    "thus :    @xmath250    the first term is simplified by recognizing the independence of erasure events in the channel and the second term is simplified by the fact that , conditioned on the event that at least one subcircuit has input nodes being all erasure symbols , lemma [ pidgeonholelemma ] applies and at least one subcircuit must make an error with probability at least @xmath0 .",
    "thus : @xmath251 it must be that @xmath252 , and thus @xmath253 , where again @xmath9 is the total number of inputs .",
    "we can apply lemma  [ convexoptimizationlemma ] to show that the product term in ( [ eq : lowerboundequation ] ) is maximized when each @xmath93 is equal to @xmath254 .",
    "thus , we show that : @xmath255 for the sake of the convenience of calculation , we replace @xmath256 with @xmath257 , which will not alter the evaluation of the limit by lemma  [ roundingerrorlemma ] , giving us : @xmath258 since we have assumed @xmath244 , suppose that @xmath259 , and recognizing that @xmath260 , and that @xmath244 , substituting into ( [ linetosub ] ) and simplifying gives us : @xmath261 thus , if @xmath262 and applying lemma  [ limitlemma ] : @xmath263 hence , either in the limit block error probability is at least @xmath0 , or @xmath264 and thus @xmath265 where we have used the fact that the number of clock cycles is at least @xmath217 as well as our bound on @xmath266 .",
    "the results in sections [ sec : key - result - of ] and [ sec : serialcomp ] show that in the case of fully parallel implementations , the area - time complexity of decoders that asymptotically have a low block error probability must asymptotically have a super - linear lower bound .",
    "technically , however , it may be possible to make a series of circuits with increasing block length , and have the number of output pins increase with increasing block length .",
    "we can show that , in this case , a super - linear lower bound exists as well where we require only weak assumptions on the circuit layout .",
    "this proof applies the main principle of this paper : namely that if a subcircuit has all its inputs erased , then that subcircuit must somehow have communicated to it other bits from outside this circuit , or it must , with high probability , make an error . in theorem [ maintheorem ] , we recognize that in a fully parallel computation these bits must be injected to it from another part of the circuit , resulting in some energy cost . in theorem",
    "[ serialtheorem ] , we divide the circuit into epochs , and recognize that if all the input bits injected into the circuit during that epoch are erased then the circuit must have bits injected to it from before that epoch .",
    "but the number of bits that can be carried forward after each epoch is limited by the area of the circuit . in the general case in which the number of output pins can vary with block length , we divide the circuit into subcircuits and epochs ( in essence , dividing the circuit in both time and space ) and apply these two fundamental ideas .    to accomplish this lower bound , we will need this simplifying assumption : for any decoder with @xmath216 output pins , each output pin is responsible for , before the end of the computation , outputting between @xmath267 and @xmath268 bits .",
    "furthermore , we assume that each output bit produces an output at the same time .",
    "we call this assumption an _ output regularity assumption_. this assumption allows us to divide the circuit into subcircuits and then epochs , and thus with this assumption each subcircuit can be divided into _ subcircuit epochs_. the main structure of the proof will be this : if the energy of a computation is not high , then there will be many subcircuit epochs that do not have enough bits injected into them to overcome the case of one of them having all of their input bits erased .",
    "the task is thus to choose a correct number of divisions of the circuit into subcircuits and epochs , so that the probability of this event ( that a subcircuit epoch makes an error ) is high unless the area - time complexity of the computation is high .",
    "[ generaltheorem ] for a sequence of codes and circuit implementations of decoding algorithms in which block length @xmath9 gets large , and where the number of output pins @xmath216 can vary with block length @xmath9 , and the computation performed by the decoders is consistent with the output regularity assumption , then , in the limit as @xmath9 approaches infinity , either ( a ) @xmath269 or ( b ) for a sufficiently large @xmath9 , @xmath270 .    the proof is given in appendix  [ appendixgeneralproof ]",
    "a direct consequence of our work is that as code rates approach capacity , the average energy of decoding , per bit , must approach infinity .",
    "it is well known from @xcite and @xcite and further studied in @xcite that as a function of fraction of capacity @xmath271 , the minimum block length scales approximately as @xmath272 for a constant @xmath59 that depends on the channel and target probabilities of error .",
    "we are not concerned about the value of this constant , but rather the dependence of this approximation on @xmath273 . plugging this result into ( [ corollaryone ] ) implies : @xmath274 this result implies that not only must the total energy of a decoding algorithm approach infinity as capacity is approached ( this is a trivial consequence of the fact that block length must approach infinity as capacity is approached ) , but also the energy",
    "_ per bit _ must approach infinity as capacity is approached .",
    "thus , if the total energy per bit is to be optimized , a rate strictly less than capacity must be used .",
    "we can not get arbitrarily close to optimal energy per bit by getting arbitrarily close to capacity , which would be the case if there were linear energy complexity algorithms with block error probability that stay less than @xmath0 .",
    "the result of theorem  [ serialtheorem ] can also be extended to find a fundamental lower bound on the average energy per bit of serially decoded , capacity - approaching codes .",
    "for the same reason as in the fully parallel case , we can see that as a function of gap to capacity , the average energy per bit for a decoder must scale as @xmath275 finally , it can be shown from theorem  [ generaltheorem ] that in circuits in which the output pins can grown arbitrarily , and the regular output rate condition is satisfied , the average energy per bit as a function of gap to capacity must scale as @xmath276",
    "we have shown that for any code and decoding circuit with block error probability that is below @xmath0 , the area - time complexity must scale at least as fast as @xmath1 .",
    "we provide here an example of a particular circuit layout that achieves @xmath277 complexity",
    ". low density parity check ( ldpc ) codes are standard codes first described by gallager in @xcite .",
    "there have been a number of papers that have sought to find very energy - efficient implementations of ldpc decoders ; for example @xcite . the reference @xcite gives an overview of various techniques used to create actual vlsi implementations of ldpc decoders .",
    "however , these papers have not sought to view how the energy per bit of these decoders scales with block length ; they show a method to optimize an ldpc decoder of a particular block length and show that their implementation method improves over a previous implementation .",
    "our goal is to provide an understanding of how a particular implementation of ldpc codes should scale with block length @xmath9 .",
    "we provide a simple circuit placement algorithm that results in a circuit whose area scales no faster than @xmath278 where @xmath279 is the number of edges in the circuit . for a regular ldpc code with constant node degrees , this implies that the area scales as @xmath277 .",
    "the placement algorithm proposed involves actually instantiating the tanner graph of the ldpc code with wires , where each edge of the tanner graph corresponds to a wire connected to @xmath9 subcircuits that perform variable node computations and the @xmath280 subcircuits that perform check node computations .",
    "our concern is not about the implementation of the variable and check nodes in this circuit . in the diagram , we treat these as merely a `` black box '' whose area is no greater than proportional to the square of the degree of the node . of course , the actual area of these nodes is implementation specific , but the important point is that the area of each node should only depend on the particular node degree and not on the block length of the entire code . our concern is actually regarding how the area of the interconnecting wires scales .",
    "the wires leading out of each of these check and variable node subcircuits correspond to edges that leave the corresponding check or variable node of the tanner graph .",
    "the challenge is then to connect the variable nodes with the check nodes with wires as they are connected in the tanner graph in a way consistent with our circuit axioms .",
    "we lay out all the variable nodes on the left side of the circuit , and all the subcircuits corresponding to a check node on the right side of the circuit , and place the outputs of each of these subcircuits in a unique row of the circuit grid ( see fig .",
    "[ ldpcnsquaresexample ] ) .",
    "note that the number of outputs for each variable and check node subcircuit will be equal to the degree of that corresponding node in the tanner graph of the code .",
    "the height of this alignment of nodes will be @xmath281 , twice the number of edges in the corresponding tanner graph ( as there must be a unique row for each of the @xmath279 edges of the variable nodes and also for the @xmath279 edges leading from the check nodes .",
    "the distance between these columns of check and variable nodes is @xmath279 .",
    "each output of the variable nodes is assigned a unique grid column that will not be occupied by any other wire ( except in the case of a crossing , which according to our model is allowed ) .",
    "a horizontal wire is drawn until this column is reached , and then the wire is drawn up or down along this column until it reaches the row corresponding to the variable node to which it is to be attached .",
    "a diagram of the procedure to draw such a circuit for a case of @xmath282 edges is shown in fig .  [ ldpcnsquaresexample ] . since each output of the variable and",
    "check node `` black boxes '' takes up a unique row , and each wire has a unique column , no two wires in drawing this circuit can ever run along the same edge ; they can only cross , which is permitted in our model .",
    "the total area of this circuit is thus bounded by : @xmath283 , where @xmath284 is the area of the nodes and @xmath285 is the area of the wires .",
    "now it is sufficient that there is a grid row for each output of the variable nodes and the check nodes , and that there is a column for each edge .",
    "hence @xmath286    we assume that the area of the subcircuits that perform the computational node operations can complete their operation in one clock cycle and take up area proportional to the square of their degree .",
    "hence we suppose that @xmath287 , where @xmath288 is the degree of the variable nodes and @xmath289 the degree of the check nodes .",
    "we then conclude that : @xmath290    the total energy for the computation will depend on the number of iterations performed .",
    "since each iteration requires sending information for the variables nodes to the check nodes and back again , this can be performed in @xmath77 clock cycles .",
    "hence , @xmath291 , where @xmath292 is the number of iterations performed , and of course @xmath27 is the number of clock cycles in the computation .",
    "thus , the total energy of this implementation of an ldpc code is upper bounded by @xmath293    the work of lentmaier _ et al . _",
    "@xcite has shown that for an ldpc decoder , for asymptotically low block error probability , @xmath294 iterations are sufficient if the node degrees are high enough .",
    "this then results in an upper bound on the energy of @xmath295     edges that correspond to interconnections that must be made . going left to right , starting at the top left circuit ,",
    "the six parts of this diagram show the progressive addition of each additional `` edge '' in the circuit implementation of the tanner graph .",
    "each wire has a unique column that it is allowed to run along , and each output has a unique row , ensuring that no two wires ever need to run along the same section .",
    "the only time when the wires need to intersect is during a wire crossing , which is explicitly allowed by our circuit axioms .",
    "this method can be used to draw any arbitrary bipartite graph with @xmath279 edges . ]",
    "this work expands on previous work in @xcite by providing a standard to which decoding algorithms together with circuit implementations can be compared .",
    "earlier work on the energy used in decoding ( for example , @xcite ) have involved trying to optimize a circuit that implements a particular code ; they have not sought to understand how the energy scales with the length of the code .",
    "some work has provided an analysis of the energy requirements for specific types of codes .",
    "the work in @xcite has provided a way to analyze the energy requirements for an ldpc decoder .",
    "the result of our paper is more general : it applies to any decoding algorithm .",
    "further investigations should compare the results in this paper to existing results relating energy per bit with parameters like block error probability .",
    "finally , this paper should also be used to guide the development of new codes that attempt to approach this fundamental lower bound .",
    "there may be some modifications of some types of codes , for example ldpc codes , whose area - time complexity is chosen to be @xmath296 ( for example , by choosing the neighbors of the nodes in the tanner graph representation of such a code to limit the area of the code , or by limiting the number of iterations ) .",
    "most analyses of ldpc codes assume a random tanner graph .",
    "if the interconnections of the ldpc code are restricted to limit the area of the implementation ( and thus violating the assumptions of most ldpc code analyses ) will the decoder still have a good performance ?",
    "the work of @xcite suggests there is some kind of trade - off .      to accomplish this super - linear lower bound , we divide how the number of output pins @xmath216 scales with @xmath9 , the block length , into cases .",
    "we suppose that @xmath297 . if not , using our result from theorem  [ serialtheorem ] , for codes with asymptotic block error probability less than @xmath0 , @xmath298",
    "if @xmath299 then we can show that @xmath300 and we are done .",
    "[ divideintoseparatesubsequencesremark ] technically , the statement that either @xmath297 or @xmath299 does not fully specify all possible sequences of output pins .",
    "however , for any sequence , we can divide the sequences into separate subsequences , specifically the sequences of codes in which @xmath297 and in which @xmath299 . for each of those subsequences",
    "we can prove our lower bound .",
    "note again that , just as in remark [ divideintoseparatesubsequencesremark ] , if the area alternates between @xmath305 with increasing block length , we can simply divide the sequence of decoders into two subsequences and prove that the necessary scaling law holds for each subsequence .",
    "hence , we consider the case that we have a sequence of serial decoding algorithms in which the area of the circuit grows with the block length @xmath9 and the number of output nodes on the circuit grows with @xmath9 .",
    "we consider the case in which @xmath306 and @xmath307      for each of the @xmath12 epochs we want the number of bits responsible on average for each decoder to decode to be four times the area .",
    "this will mean that , even if we optimistically assume that before the beginning of each epoch a circuit had already computed the future outputs , a typical subcircuit can only store a fraction of the bits it is responsible for decoding in the next epoch .",
    "note that the number of bits that a subcircuit is responsible for in total over the entire computation must be @xmath308 and hence , if the computation is to be divided into @xmath12 epochs , during each epoch , an average subcircuit must be responsible for decoding @xmath309 bits .",
    "we seek to choose an @xmath12 such that @xmath310 where @xmath311 is the average normalized area of a subcircuit . this will be true if @xmath312 or equivalently if @xmath313 so we choose @xmath314 we also want @xmath315 for a constant @xmath59 which we will choose later , so we choose @xmath316    we need to show that this is a valid choice for @xmath292 .",
    "the restriction on the choice of @xmath292 is that @xmath317 ( we ca nt subdivide the circuit into more subcircuits than there are output pins ) . by applying the assumption on the scaling of the area of the circuit in ( [ areascalingassumption ] ) we can see that @xmath318 is asymptotically less than @xmath216 , and",
    "hence this choice of @xmath292 is valid .",
    "our choice of @xmath12 is @xmath319 .",
    "the restriction on the choice of @xmath12 is that @xmath320 ( there must be at least one output per pin per epoch ) .",
    "thus @xmath321 , which will be true when @xmath322 .",
    "but since the @xmath216 output pins form part of the area of the circuit , this must always be satisfied .    on a minor technical note",
    ", we can only choose integer values of @xmath12 .",
    "hence , we can decide to choose the floor of @xmath12 .",
    "but , as argued in lemma  [ roundingerrorlemma ] if the function for choosing @xmath12 grows with @xmath9 then the evaluation of a limit where we neglect this floor function is the same .",
    "so , our other requirement , that @xmath323 means that our choice for @xmath12 grows as @xmath9 increases .",
    "we consider the case when area of the computation remains proportional to @xmath9 at the end of this section .",
    "let the number of bits injected into the @xmath80th subcircuit during the @xmath324th epoch from other parts of the circuit be @xmath325 .",
    "now , the average subcircuit has area @xmath326 , so we consider the set of subcircuits that have area less than @xmath327 .",
    "this number must be at least @xmath0 the subcircuits , otherwise the total area of all these subcircuits would exceed the total circuit area .",
    "denote the set of indices of subcircuits with area less than @xmath327 as @xmath328 .",
    "note that @xmath329 .    consider a specific @xmath324th epoch .",
    "suppose that the total number of bits injected into the subcircuits indexed by @xmath328 after @xmath78-stages of nested bisections during this epoch is less than @xmath330 .",
    "if this is true , then there must be at least half of the subcircuits in @xmath328 that have fewer than @xmath331 bits injected into them . otherwise , the total number of bits injected into these subcircuits is at least @xmath332 , which we assumed is not the case .",
    "thus , with our assumptions , at the @xmath324th epoch , either the total number of bits injected across @xmath78-stages of nested minimum bisections is at least @xmath330 , or there are at least @xmath333 subcircuits with area less than @xmath334 that have less than @xmath335 bits injected into them .",
    "denote the set of indices of these low area subcircuits with a low number of bits injected into them during the @xmath324th epoch as @xmath336 .",
    "the size of @xmath336 we have assumed to be at least @xmath333 , so for the sake of simplicity define @xmath337 as a subset of @xmath336 with size exactly @xmath333 .",
    "now , consider the number of epochs during which there are less than @xmath330 bits injected across all the bisections .",
    "either this number is less than @xmath338 or greater than or equal to @xmath338 .",
    "suppose that it is greater than or equal to @xmath338 .",
    "denote the set of indices denoting the epochs in which the number of bits injected across all the bisections during that epoch is less than @xmath330 as @xmath339 , and a particular set of size exactly @xmath338 as @xmath340 ( chosen for simplicity of computation ) .",
    "we now apply the key principle used for all the theorems in this paper .",
    "consider a particular @xmath324th epoch where @xmath341 , an epoch with less than @xmath330 bits communicated across all the bisections . during this epoch",
    "the subcircuits in @xmath336 are those with less than @xmath331 bits injected into them , and they have area at most @xmath342 , and are responsible for decoding @xmath343 bits .",
    "let the number of input bits injected into the circuit for such a particular subcircuit be @xmath344 .",
    "if all of these inputs are erased , then , by applying lemma  [ pidgeonholelemma ] the circuit must guess at least @xmath90 output , and the probability of error is at least @xmath0 , because in this case they only have @xmath345 bits to use .",
    "using the same argument as in theorems  [ serialtheorem ] and [ maintheorem ] , we can show that if , for all the subcircuits in @xmath337 , where @xmath341 , in the event that for any of these subcircuits all of their @xmath344 input bits are erased , then an error occurs with probability @xmath0 .",
    "applying this principle gives us :        subject to those restrictions , lemma  [ convexoptimizationlemma ] implies that the expression in ( [ eq : equationtoconvexoptimize ] ) is minimized when each of the @xmath344 are equal to @xmath348 .",
    "hence @xmath349 which , by applying lemma  [ limitlemma ] , can easily be shown to approach @xmath0 when @xmath9 gets larger , if @xmath59 is chosen to be @xmath350 . hence , either in the limit block error probability approaches @xmath0 or the size of @xmath339 is greater than @xmath338 , and there are many bits communicated in the circuit for many epochs .    from lemma  [ lem : edeclemma ] , by recognizing that for the circuit under consideration there are at least @xmath216 nodes , if there are @xmath351 bits injected across all the @xmath78-stages of nested minimum bisections , then @xmath352 where @xmath353 and @xmath354 , the number of subcircuits into which the circuit was divided .",
    "thus , combining this bound with our choice for @xmath292 and the assumption that there are at least @xmath330 bits injected across all the bisections for epochs in @xmath340 , we get that either @xmath355 for at least @xmath338 epochs , or @xmath356 .",
    "hence , in total ,        finally , we must consider a case when the area of the circuit scales with @xmath9 .",
    "this must be treated separately because in this case our choice for @xmath12 in the above argument does not necessarily grow with @xmath9 and so we ca nt assume that our rounding approximation is valid .",
    "thus , suppose that @xmath360 .",
    "suppose also that @xmath361 .",
    "then @xmath362 from remark  [ simpleboundfortau ] , and therefore the total area - time complexity of such a sequence of decoders scales as @xmath363    in the other case , when @xmath364 then we can subdivide the circuit into @xmath365 pieces , and make the same argument that has been made in theorem  [ maintheorem ] that the number of bits communicated across all cuts during the course of the computation must be proportional to @xmath366 . recognizing that we have assumed there are at least @xmath367 nodes in the circuit and applying lemma  [ lem : edeclemma ] , and also substituting @xmath368 we get : @xmath369 which of course is asymptotically faster than @xmath4 .                      w.  yu , m.  ardakani , b.  smith , and f.  r. kschischang , `` complexity - optimized low - density parity - check codes for gallager decoding algorithm b , '' in _ proc .",
    "2005 ieee int . symp . on info .",
    "theory _ , 2005 , pp .",
    "14881492 .",
    "m.  garey , d.  johnson , and l.  stockmeyer , `` some simplified np - complete graph problems , '' _ theoretical computer science _",
    ", vol .  1",
    ", no .  3 , pp .",
    "237  267 , 1976 .",
    "[ online ] .",
    "available : http://www.sciencedirect.com/science/article/pii/0304397576900591    v.  strassen , `` asymptotische abschtzungen in shannon s informationstheorie , '' in _ in transactions of the 3rd prague conference on information theory , statistical decision functions , random processes_.1em plus 0.5em minus 0.4emprague : pub .",
    "house of the czechoslovak academy of sciences , 1962 , pp .",
    "689723 .            c.  roth , a.  cevrero , c.  studer , y.  leblebici , and a.  burg , `` area , throughput , and energy - efficiency trade - offs in the vlsi implementation of ldpc decoders , '' in _ 2011 ieee international symposium on circuits and systems ( iscas ) _ , may 2011 , pp .",
    "17721775 .",
    "m.  lentmaier , d.  truhachev , k.  zigangirov , and d.  costello , `` an analysis of the block error probability performance of iterative decoding , '' _ ieee transactions on information theory _",
    "51 , no .",
    "38343855 , nov 2005 ."
  ],
  "abstract_text": [
    "<S> thompson s model of vlsi computation relates the energy of a computation to the product of the circuit area and the number of clock cycles needed to carry out the computation . </S>",
    "<S> it is shown that for any family of circuits implemented according to this model , using any algorithm that performs decoding of a codeword passed through a binary erasure channel , as the block length approaches infinity either ( a ) the probability of block error is asymptotically lower bounded by @xmath0 or ( b ) the energy of the computation scales at least as @xmath1 , and so the energy of successful decoding , per decoded bit , must scale at least as @xmath2 . </S>",
    "<S> this implies that the average energy per decoded bit must approach infinity for any sequence of codes that approaches capacity . </S>",
    "<S> the analysis techniques used are then extended to the case of serial computation , showing that if a circuit is restricted to serial computation , then as block length approaches infinity , either the block error probability is lower bounded by @xmath0 or the energy scales at least as fast as @xmath3 . in a very general case that allows for the number of output pins to vary with block length </S>",
    "<S> , it is shown that the average energy per decoded bit must scale as @xmath4 . </S>",
    "<S> a simple example is provided of a class of circuits performing low - density parity - check decoding whose energy complexity scales as @xmath5 . </S>"
  ]
}