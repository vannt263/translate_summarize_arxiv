{
  "article_text": [
    "treewidth , tree decomposition and related graph decomposition concepts have been studied extensively as a means for finding theoretically efficient algorithms for optimization problems in graphs . for graphs of bounded treewidth",
    ", polynomial time algorithms can be found for a large number of graph optimization problems .",
    "however , due to large constants hidden in the time complexity as well as ( super)exponential dependency on the treewidth , in practice these algorithms are often too slow to solve optimization problems . though heuristic methods for finding tree decompositions of small width have been developed , most applications of tree decompositions are in speeding up exact algorithms .",
    "little work has been done in using tree decompositions as a tool for high performance heuristic optimization algorithms .    to the best of our knowledge the only work in combinatorial optimization exploring this avenue is the tour merging algorithm for the traveling salesman problem ( tsp ) by cook and seymour @xcite , using the related concept of branch decomposition . in their paper",
    "they describe an algorithm that first generates a pool of high quality solutions to the tsp using a local search heuristic with different starting points . in the merging phase , the graph union of these solutions",
    "is then taken to produce a sparse subgraph of the original graph .",
    "this makes the computation of a low width branch decomposition feasible , which they then use to quickly find the optimal solution to the tsp instance induced by this sparse subgraph .",
    "experimental results showed a fair improvement over the best solution found , in a small amount of additional time .    in this paper",
    "we report experimental results applying the same paradigm described in @xcite on the steiner tree problem in graphs ( stp ) .",
    "a set of locally optimal solutions is generated to create a sparse subgraph , and subsequently tree decomposition is used to quickly solve the restricted instance to optimality .",
    "the main difference with the technique by cook and seymour is that we allow the algorithm to discard some of the generated solutions , if it helps finding a tree decomposition of sufficiently small width on the graph union of the remaining solutions . though this hurts solution quality in some cases , the improvement in running time warrants this trade off .    for generating solutions we use a multistart heuristic by ribeiro et al .",
    "@xcite available under the name _ bossa_. the instances induced by the generated solutions are solved using dynamic programming ( dp ) , for which we use a fairly recent tree decomposition based implementation by fafianie et al .",
    "we compare the performance of our algorithm to the _ path relinking _ solution merging strategy proposed in @xcite which is part of the bossa implementation .",
    "experimental results show that our method is very promising .",
    "test runs on sparse benchmark sets showed up to an average 6-fold improvement of the optimality gap provided by the best generated solution , within only one or two percent of the running time of the solution generating phase . on the other hand for dense graphs it often was nt possible to find a combination of local solutions within our predefined treewidth limit . by using a fast greedy heuristic for finding tree decompositions however",
    ", it takes little time to identify this , and therefore the overhead of running the merging algorithm is negligible in such situations .",
    "it should be noted that bossa is no longer competitive in terms of performance . as pointed out by an anonymous reviewer , a heuristic by polzin and daneshmand ( * ? ? ?",
    "* chapter  4 ) was shown to give similar or better solutions compared to bossa in a fraction of the time on established benchmarks .    however , a very recent advancement by pajor et al .",
    "@xcite indicates that our results are still highly relevant .",
    "they present an improved multistart heuristic and experimental results indicate that this implementation outperforms the heuristic by polzin and daneshmand again .",
    "the proposed heuristic has a strong similarity to bossa .",
    "though some structural changes yield better quality solution pools in the same number of iterations , most of the performance gain is actually achieved by faster implementations of the same local search techniques . since the improved implementation",
    "could be directly plugged in as a solution generator for our method , we expect the positive results to carry over when replacing the multistart heuristic with the improved version of pajor et al .",
    ", though further experiments are need to confirm this .    the rest of this article is organized as follows . in section [ sec : preliminaries ] basic notation is introduced , we give a formal definition of treewidth and we discuss a greedy algorithm for treewidth that plays an important part in the performance of our algorithm . in section",
    "[ sec : algorithm ] we describe the heuristic for selecting solutions for merging and briefly discuss the algorithms used for generating solutions and solving the instance induced by those solutions . in section [ sec : results ] we report experimental results on a variety of benchmark instances .",
    "we denote an undirected graph @xmath0 with vertex set @xmath1 and edge set @xmath2 , or @xmath3 and @xmath4 when no confusion is possible . together with a weight function",
    "@xmath5 we have a weighted graph . in this paper",
    "we assume graphs to be simple : no loops or parallel edges are allowed .",
    "a graph union @xmath6 is equal to the graph found by taking the union of both the vertex and the edge sets of the operands .",
    "the neighbours of @xmath7 in @xmath0 are denoted @xmath8 .",
    "the subject of this paper is the classical steiner tree problem .",
    "this famous np - complete graph optimization problem should need no introduction to the reader but we include a formal definition for completeness :     + given a connected weighted graph @xmath9 with non - negative weights and a set of terminal vertices @xmath10 , find a minimum weight subgraph @xmath11 of @xmath0 such that all terminal vertices are pairwise connected .",
    "the concept of treewidth is a graph invariant that indicates how _ tree - like _ a graph is .",
    "it is derived from the tree decomposition , a transformation that projects a general graph onto a tree .",
    "the formal definition is as follows :    a tree decomposition of a graph @xmath12 is a tree @xmath13 , where each node @xmath14 is labelled with a vertex set @xmath15 , called a bag , satisfying the following conditions :    1 .",
    "@xmath16 2 .   for all @xmath17",
    "there is an @xmath18 such that @xmath19 3 .   if @xmath20 and @xmath21 then @xmath22 for all @xmath23 on the path between @xmath24 and @xmath25 in the tree @xmath26    the width @xmath27 of a tree decomposition is equal to the size of the largest bag minus one .",
    "the treewidth of a graph @xmath28 is the smallest width over all possible tree decompositions of @xmath0 . as finding",
    "the treewidth of a graph is np - complete no polynomial time exact algorithms exists unless @xmath29 @xcite .",
    "heuristic approaches come in many shapes , including local search techniques and heuristics derived from exact algorithms , see bodlaender and koster @xcite .",
    "we will use a simple but very effective greedy heuristic described in @xcite .",
    "@xmath30 a minimum degree vertex in @xmath0 @xmath31 add edges to @xmath0 such that @xmath32 is a clique remove @xmath7 from @xmath0 @xmath33    algorithm [ algo : greedydegree ] , greedydegree , constructs an _ elimination order _ , which is a permutation of vertices of the graph .",
    "it does so by iteratively choosing the minimum degree vertex , adding edges between all its neighbours , and then removing it from the graph . these last two steps are called _",
    "vertex elimination_.    any elimination order can be used to construct a ( unique ) tree decomposition in linear time ( see ( * ? ? ?",
    "5 ) ) . for convenience",
    "we will directly treat the output of algorithm [ algo : greedydegree ] as a tree decomposition .",
    "the width of the tree decomposition produced by algorithm [ algo : greedydegree ] is equal to the highest degree of any vertex at the moment it is eliminated from the graph @xcite .    in this paper",
    "we often abuse language by referring to the width found by greedydegree@xmath34 as the treewidth of @xmath0 , especially when @xmath0 is a graph induced by a set of solutions .",
    "of course this is just an upper bound , but since we never solve for exact treewidth in our algorithm , it is not necessary to make the distinction when from context it is clear that we mean the width of the tree decomposition found .",
    "the basic outline of our approach consists of three steps .",
    "let an instance of the stp be denoted by stp@xmath35 .    1 .",
    "generate as set @xmath36 of locally optimal solutions for stp@xmath37 .",
    "2 .   pick a subset @xmath38 such that @xmath26 = greedydegree@xmath39 has width@xmath40 , where @xmath41 .",
    "3 .   solve stp@xmath42 using dp guided by the decomposition @xmath26 found in 2 .",
    "the dp implementation we used for the last step , more on that in section [ subsec : dp ] , has running time linear in @xmath43 , but exponential in the treewidth .",
    "the multistart heuristic used to generate locally optimal solution is an implementation of a hybrid greedy randomized adaptive search procedure ( grasp ) for the stp ( see section [ subsec : grasp ] ) .",
    "as the first and last steps are basically black box routines with respect to the solution merging heuristic , we will first explain how we construct a suitable subset of solutions .      in the implementation of tour merging for the tsp in @xcite a fixed number of solutions",
    "is generated , and quite some time is spent on finding a good branch decomposition . if the algorithm can not find a decomposition of sufficiently small width , the merging heuristic is deemed intractable and returns no solution .",
    "our method is a little different .",
    "we also generate a fixed number of heuristic solutions , and limit the width of the tree decomposition deemed acceptable to proceed with the dp step .",
    "however we allow more flexibility by accepting a subset of solutions such that greedydegree finds a decomposition of width at most @xmath44 on their graph union .",
    "an initial approach to finding a good subset of solutions is motivated by the idea that if we can not use all solutions , we give priority to those with the highest quality .",
    "let @xmath36 be the set of solutions generated in step 1 and @xmath45 their weights .",
    "initially we sort the solutions in ascending order of @xmath46 and apply algorithm [ algo : greedysteinerunion ] .",
    "this keeps iteratively adding solutions to the graph union as long as the limit @xmath44 is not violated by the decomposition found by greedydegree . in a sense the algorithm finds a _ maximal _ subset of solutions , that is , no solution can be added without breaching the width limit .",
    "+ @xmath36 : list of solutions , ordered + @xmath44 : maximum treewidth + @xmath47 : list of solutions , such that @xmath48 @xmath49 @xmath50 @xmath51 @xmath52 @xmath47 @xmath53 @xmath30 a minimum degree vertex in @xmath0 @xmath54 add edges to @xmath0 such that @xmath32 is a clique remove @xmath7 from @xmath0 @xmath55    this procedure usually gives reasonably good improvements in the dp step if the number of solutions rejected by algorithm [ algo : greedysteinerunion ] is low .",
    "however , if only small sets of solutions stay within width limit @xmath44 , and there are consequently many possible maximal solution sets , the chance of the greedy procedure finding a good set from the possible alternatives is small .",
    "specifically , experiments showed that increasing the width limit @xmath44 may often result in a decrease in the eventual solution quality , a highly undesirable result .    to improve the robustness of the solution picking step",
    "we introduce the randomized _ ranking _ procedure described in algorithm [ algo : rankingprocedure ] .",
    "this procedure is akin to a simulation of step 2 and step 3 of the solution merging algorithm with a lower width limit @xmath23 , where we shuffle the solutions instead of sorting them by @xmath46 .",
    "we use the value of the solution found in each iteration to adjust the rank of all solutions that were picked by algorithm [ algo : greedysteinerunion ] in that iteration .",
    "+ @xmath36 : list of solutions + @xmath46 : map giving the weigth of every steiner tree @xmath11 in @xmath36 + @xmath23 : maximum treewidth + @xmath56 : number of random ranking iterations + @xmath57 : map assigning an adjusted value to every solution in @xmath36 @xmath58 shuffle the order of @xmath36 at random @xmath59 @xmath60 weight of steiner tree @xmath11 found by dp on the graph @xmath61 add @xmath62 to all sets @xmath63 for which @xmath64 @xmath65    the adjusted values @xmath57 can be interpreted as a metric for how promising the inclusion of a solution @xmath11 is in terms of the improvement found in step 3 .",
    "these values are then used to sort the solutions before a final run of algorithm [ algo : greedysteinerunion ] with maximum width @xmath44 .",
    "this yields a much more robust algorithm as in experiments we never observed an increase in @xmath44 resulting in a decrease in solution quality .",
    "experimental results indicate that the execution time of the dp grows roughly with @xmath66 where @xmath44 is the width of the tree decomposition",
    ". therefore if we run algorithm [ algo : rankingprocedure ] , for example , with @xmath67 for 10 iterations , its execution time is still expected to be an order of magnitude smaller than directly running the dp once on a graph with decomposition of width @xmath44 .",
    "a byproduct is that we can check more combinations of solutions for improvement .",
    "in fact , sometimes the best solution found during the execution of algorithm [ algo : rankingprocedure ] is better than the final solution found on the graph union with maximum width @xmath44 , even after ranking according to the adjusted values .",
    "however , this does not happen too often and in general it pays off to execute a last iteration with the higher limit @xmath44 .    taking it all together the steps for picking the set of solutions",
    "are :    * find @xmath68 * sort the solutions @xmath69 ascending according to @xmath57 * find @xmath70    the graph union of @xmath47 and its tree decomposition are then used as input for the final dp run in step 3 .",
    "a recent implementation of dynamic programming for the stp was introduced in @xcite .",
    "it uses the greedydegree algorithm to find a decent tree decomposition of the input graph , and then proceeds with a novel dynamic programming algorithm that reduces the search space in every stage by removing entries that can not affect optimality .",
    "we will not reproduce the formal dynamic program here , for which we refer to the paper .    however , the idea is that the dp is guided by a tree decomposition , such that the size of the state space is governed by the number of partitions of the vertex sets in each bag . in the paper multiple methods for reducing the size of the search space",
    "are proposed and implemented in the corresponding software .",
    "we use the default _ classic _ dp however , as the relative speed ups are not large enough to make a significant contribution in our implementation .",
    "a hybrid for the stp was introduced in @xcite for which the code is publicly available under the name bossa @xcite .",
    "using a simple multistart approach , in which a construction heuristic is started from different nodes to produce a solutions that is then improved to a local optimum , does not work particularly well for the stp . for reasons that seem to be inherent to the problem",
    "most construction heuristics usually produce the same or a few different solutions even for widely different starting points .    to still be able to improve on deterministic heuristics ,",
    "the hybrid grasp algorithm in bossa employs a variety of techniques to force the algorithm to explore different areas of the search space .",
    "these include multiple different construction heuristics , randomization in the local search procedure and weight perturbations .",
    "this makes the hybrid grasp particularly useful for our algorithm , as it can generate a set of good but disjoint solutions . for a full explanation of these techniques",
    "please see the paper .",
    "the bossa code also includes a solution merging heuristic called path relinking , which can be used in combination with grasp .",
    "we use it to compare the performance of our algorithm .",
    "the algorithm was implemented in java integrating the existing java code from @xcite for the merging part and using system calls and text files to interface with the binary executable of bossa , to generate the solutions pool .",
    "though working with text files gave some overhead , this effect was insignificant as the time spent on read / write operations was usually small compared to the computation time .",
    "all experiments were run in a single thread on 16 core intel xeon e5 - 2650 v2 @ 2.6 ghz and 64 gb of ram . at any time no more than 15 processes were running to make sure one core was free for background processes .",
    "the maximum heap space for the java virtual machine was set to 1 gb for all instances .",
    "for all experiments , in the solution generation phase 16 solutions were generated with grasp , where each run of the grasp was set to 8 iterations and with a different random seed .",
    "we set the maximum treewidth for the final dp to @xmath71 and the maximum treewidth for the ranking procedure to @xmath72 , with @xmath73 iterations of random shuffling . in all experiments where grasp alone solved an instance to optimality",
    ", the instance was dropped from the test set .",
    "r0.6    [ cols=\"^,<,<,^,^,^,^,^,^,^ \" , ]     an initial test was run on the last 50 instances of the classic i640 benchmark set available through the steinlib @xcite repository .",
    "all instances are randomly generated .",
    "this benchmark is a little outdated in that nowadays most instances can quickly be solved to optimality , but the clear distinction in parameters with which the instances were generated facilitates an easy analysis of the results .",
    "all instances in the benchmark set have 640 vertices , but differ in edge densities and number of terminals . for most instances",
    "the optimal value is known , in the other cases we used the best known upper bound as an approximation to find the optimality gap .",
    "this is only the case for instances i640 - 311@xmath74i640 - 315 .",
    "the results are in table [ tab : i640results ] .",
    "next to the instance name the number of terminals and edges is shown .",
    "the optimality gaps of grasp and our solution merging heuristic ( smh ) are given as a percentage of the optimal value .",
    "the column impr.% gives the percentage improvement of the optimality gap by smh compared to grasp .",
    "the running time for smh does not include grasp .",
    "the column rel . gives the time spent on smh relative to the time spent on grasp .",
    "the last column , # trees is the number of local solutions that were eventually accepted after the sorting procedure(see algorithm [ algo : rankingprocedure ] ) in the solution union for the smh .",
    "the table clearly reveals the difference in performance between sparse and denser graphs . for instances with",
    "less than 1280 edges smh usually gives a good improvement , even solving the instances to optimality in three instances , yet for none of the most dense instances an improvement was found .",
    "this is also reflected in the number of solutions that were used by the algorithm in the final run of the merging phase .",
    "there is a clear inverse relation between the density and the number of solutions the algorithm can merge while keeping treewidth within limits . as results e.g. instance 201 and 205 show , a high number of solutions merged does not guarantee improvement , although apparently it is a good indicator .",
    "also the running time of the smh relative to grasp is usually lower when no improvement can be found .    as stated before most of the instances in the i640 are not particularly hard to solve with todays hardware . to get a better view of the power of the smh algorithm we wanted to apply it to some bigger instances .",
    "the most notouriously hard test set in steinlib is the puc testset , of which most instances have no known optimal solution after more than 13 years in the field .",
    "no results are plotted but for completeness that smh gave poor results on these instances : for all but the smallest instances we were not able to find any combination of solutions within width limit .",
    "we do nt know if this is because our greedy tree decomposition works particularly bad for these graphs , or because high treewidth is an inherent property of the graph . in any case",
    "most instances from puc are denser than the second highest density instances from i640 , for which smh was already hardly able to show improvement .",
    "fortunately there are some other test sets in the steinlib repository that are big enough to justify the use of our merging heuristic but not so dense as to make it run into trouble because of the treewidth limit .",
    "results on these test sets are discussed in the rest of this section .    to compare performance",
    "we also ran the path relinking algorithm ( pr ) from bossa .",
    "the path relinking algorithm is itself a solution merging heuristic which comes in two flavours . on standard settings it first tries these different flavours and then picks the one that seems to perform best . for our experiments we forced it to use the random relink heuristic , as this turned out to perform best on all tested instances , and the initial run that determines the best settings takes a considerable amount of time .",
    "this makes for a more fair comparison . for more information",
    "see @xcite .",
    "the es1000fst test set contains 15 instances of randomly generated points on a grid , with l1 distances as edge weights .",
    "each instance has 1000 terminal vertices and between 2500 and 2900 vertices in total .",
    "due to preprocessing techniques applied to the graphs these instances only have between 3600 and 4500 edges , making them very sparse .",
    "the results for grasp , grasp+smh and grasp+pr are shown in table [ tab : resultses1000fst ] . again , for smh and pr the time does not include the initial grasp iterations .",
    "results are averaged over all instances . the number of instances for which the algorithms produced the best solution among all produced solutions for that instance is given by the row # best .",
    "l |*4l & & grasp & smh & pr + opt gap % & & 0.392&0.061&0.109 + time ( s)&&402&6&493 + # best&&0&14&1 +    l |*3l & & grasp & smh + opt gap % & & 0.441&0.189 + total cpu time(s ) & & 194485&310 + wall clock time(s ) & & 12155 & 310 +    overall the smh seems to perform better on these instances .",
    "its also nice to note that on average 15.4 solutions were used in the final dp run of the merging phase .",
    "this is probably caused by the inherently low treewidth of the instances .",
    "however , the treewidth of these instances is not so low that direct use of dp would be feasible .",
    "as the treewidth found by greedydegree for the es1000fst instances had a minimum of 14 and an average of 22 , running the tree decomposition based dp on the original instances would take ages .",
    "we also tested on the single instance in the es10000fst set .",
    "this graph is created in a similar way but with a factor 10 more terminals and vertices .",
    "because this instance is so large that only running the 128 grasp iterations needed for the smh takes more than two cpu days , we did not compare it with path relinking in a sequential run .",
    "instead grasp was run on 16 cores in parallel and the solution merging heuristic was run on a single core thereafter .",
    "results are in table [ tab : resultses10kfst ] .",
    "both the wallclock time ( time untill all threads where finished ) and the total computation time summed over all threads are shown .",
    "though not the most spectacular improvement in optimality gap it shows the good scaling properties of smh .",
    "the relative time spent on smh compared to grasp has about the same ratio as seen in the es1000fst instances when we compare wallclock time , yet it is an order of magnitude smaller when we compare the total cpu time . we need to notice however that for this instance smh was only able to use 3 solutions , as the treewidth of the entire solution pool combined was rather high at 22 .",
    "the lin test set from steinlib has very similar properties as the es1000fst set .",
    "these instances are generated from placing rectangles of different sizes in a plane , such that their corners become vertices and there edges graph edges .",
    "though no preprocessing is done on these instances , it still makes for a very sparse graph , with no vertex having a degree more than 4 . after dropping instances that were solved to optimality by grasp",
    ", only the last 13 instances remained .",
    "the number of vertices of these instances are in the range 3700 - 39000 .",
    "l |*4l & & grasp & smh & pr + opt gap % & & 0.33&0.09&0.13 + time(s)&&336&2&157 + # best&&1&10&6 +",
    "l |*4l & & grasp & smh & pr + opt gap % & & 0.27&0.07&0.11 + time(s)&&1386&7&1057 + # best&&1&8&4 +    results are in table [ tab : resultslin ] .",
    "again the smh performs very good compared to pr , in smaller amount of time . in all cases",
    "the merging phase could use all 16 solutions , often producing a union well below the treewidth limit .",
    "the last test sets we ran experiments on are the alut and alue sets from steinlib , which we combined because of their strong similarities .",
    "the structural properties of these instances are very much like the lin test set . however , these come from very - large - scale - circuit ( vlsi ) applications .",
    "the results is a grid graph with rectangular holes in it .",
    "this graph again has a maximum degree of 4 . after dropping instances",
    "which grasp solved to optimality , 10 instances remained ranging in number of vertices between 3500 and 37000 and a number of terminals between 68 and 2344 . because of the fairly large size of some of these instances , we put a maximum on the running time for the combination of grasp and merging heuristic of 3.5 hours .",
    "this gave a timeout for pr on the largest instance , so we took the best found solution up to that point .",
    "to compare , smh only took 40 seconds to run for this instance , while grasp took about 2 hours .",
    "one of the nice properties of using the tree decomposition based approach is that for graphs with a regular structure such as with the last two sets we tested on , the size of the graph does not seem to matter much for the treewidth of the union of solutions , while the dp runs linear in the number of vertices . in the experiment",
    "run on the alut / alue sets , for all but two of the remaining instances the merging phase was able to use all 16 generated solutions .",
    "the two exceptions , where only 15 solutions were used , were the largest instance , and surprisingly , the smallest instance .",
    "this illustrates that observation quite well .",
    "experimental results showed that a tree decomposition based exact algorithm can be employed as an efficient means to merge local heuristic solutions to the stp on sufficiently sparse graphs .",
    "as we have seen in results on the alut / alue test set , the sparse structure natural to vlsi derived graphs is exactly that at which our heuristic performs well .",
    "as vlsi is one of the major applications of the stp , this makes the heuristic practically relevant .",
    "as mentioned in the introduction the algorithm we used to generate solutions is no longer state of the art . in theory",
    "any algorithm capable of generating distinct locally optimal solutions could be employed with our algorithm .",
    "we plan to investigate the competitiveness of our solution merging heuristic when combined with a faster implementation such as @xcite for generating solutions in preparation of a journal version of this paper .",
    "that fixed parameter tractable algorithms can be used as a heuristic solution merging technique for the tsp had been shown in @xcite , while we established results for the stp .",
    "it seems likely that there are more optimization problems where this technique can be used .",
    "a minimal requirement seems to be that any feasible solution has low value for the chosen parameter . however , whether a low width decomposition can be found on a combination of local solutions",
    "depends on the instance , and in the case of the stp the density of the input graph seems a good indicator for that .",
    "it would be interesting to see if such a characterization is possible for other optimization problems that have low width solutions .    as a final remark , in our algorithm we managed the treewidth of the solution union by discarding solutions",
    ". a simple extension would be to use an iterative scheme to reduce treewidth of the solution pool : first run the solution merging heuristic on ( small ) subsets of the generated solutions to generate a new solution pool with less solutions , and repeat until all solutions are within the treewidth limit .",
    "it seems likely this could further improve the performance .",
    "bodlaender , h.l . ,",
    "koster , a.m.c.a .",
    ": treewidth computations i. upper bounds , information and computation 208 , 259 - 275 ( 2010 ) bodlaender , h. l. , fomin , f. v. , kratsch , d. , koster , a. m. c. a. , and thilikos , d. m : on exact algorithms for treewidth .",
    "acm trans . algor . 9 , 1 , article 12 ( 2012 ) cook , w. , seymour , p. tour merging via branch - decomposition . informs journal on computing , 15(3 ) , 233 - 248 ( 2003 ) fafianie , s. , bodlaender , h. l. , nederlof , j. : speeding up dynamic programming with representative sets . in : g. gutin and s. szeider ( eds . ) : ipec 2013 , lncs 8246 , pp .",
    "321334 , ( 2013 ) koch , t. , martin , a. , vo , s. : steinlib , an updated library on steiner tree problems in graphs .",
    "technical report zib - report 00 - 37 , konrad - zuse zentrum fur informationstechnik berlin ( 2000 ) , http://steinlib.zib.de/ ribeiro , c. c. , uchoa , e.,werneck , r. f. a hybrid grasp with perturbations for the steiner problem in graphs .",
    "informs journal on computing , 14(3 ) , 228 - 246 .",
    "( 2002 ) uchoa , e. , poggi de aragao , m. , werneck , r. , ribeiro , c.c . : bossa .",
    "( 2002 ) , http://www.cs.princeton.edu/~rwerneck/bossa/ polzin , t. : algorithms for the steiner problem in networks .",
    "phd thesis , universit'at des saarlandes ( 2003 ) pajor , t. , uchoa , e. , werneck , r.f . : a robust and scalable algorithm for the steiner problem in graphs arxiv preprint arxiv:1412.2787 ( 2014 )"
  ],
  "abstract_text": [
    "<S> fixed parameter tractable algorithms for bounded treewidth are known to exist for a wide class of graph optimization problems . while most research in this area has been focused on exact algorithms , </S>",
    "<S> it is hard to find decompositions of treewidth sufficiently small to make these algorithms fast enough for practical use . </S>",
    "<S> consequently , tree decomposition based algorithms have limited applicability to large scale optimization . </S>",
    "<S> however , by first reducing the input graph so that a small width tree decomposition can be found , we can harness the power of tree decomposition based techniques in a heuristic algorithm , usable on graphs of much larger treewidth than would be tractable to solve exactly . </S>",
    "<S> we propose a solution merging heuristic to the steiner tree problem that applies this idea . </S>",
    "<S> standard local search heuristics provide a natural way to generate subgraphs with lower treewidth than the original instance , and subsequently we extract an improved solution by solving the instance induced by this subgraph . </S>",
    "<S> as such the fixed parameter tractable algorithm becomes an efficient tool for our solution merging heuristic . for a large class of sparse benchmark instances </S>",
    "<S> the algorithm is able to find small width tree decompositions on the union of generated solutions . </S>",
    "<S> subsequently it can often improve on the generated solutions fast . </S>"
  ]
}