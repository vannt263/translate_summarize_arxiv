{
  "article_text": [
    "a @xmath1-bits dyck word is a string containing exactly @xmath2 ones and @xmath2 zeros and such that each of its prefix substrings contains no more zeros than ones .",
    "dyck words appear in a vast number of problems @xcite .",
    "consequently , generating them has many applications .",
    "for instance , if ones and zeros are replaced with openning and closing parentheses , then a dyck word is a combination of @xmath2 properly balanced pairs of parentheses .",
    "when one denotes a move rightwards and zero denotes a move upwards , a dyck word represents a monotonic path along the edges of an @xmath3 grid that starts at the lower left corner , finishes at the upper right corner and stays below diagonal .",
    "figure [ fig : paths-4x4 ] shows all @xmath4 such paths on a @xmath5 grid .    for the sake of clarity ,",
    "another implementation of essentially the same algorithm is presented .",
    "this one works on strings of two different arbitrarily chosen symbols ( e.g. , opening and closing parentheses ) .",
    "contrarily to the implementation in the abstract , the second one has explicit loops and branches and has @xmath6 time complexity .",
    "the apparent contradiction between being two implementations of `` essentially the same '' algorithm but one being loopless , brancheless and @xmath7 and the other having loops , branches and being @xmath6 can be explanained as follows .    to perform bitwise and arithmetic operations the hardware somehow",
    " runs \" loops on its transistors but , as far as i understand , for the sake of software complexity , these operations are considered as being loopless , branchless and @xmath7 . in that sense",
    "we can categorize the algorithm above as loopless , branchless and @xmath7 . the second implementation ( through software code ) simply makes explicit some loops and branches  ran \" by the hardware when the first implementation is executed .",
    "both implementations are @xmath7 in space .",
    "* disclaimer * : i am not a computer scientist and i am not aware of the state of the art .",
    "i do not claim the algorithm above has not been discovered / invented before but i believe there is a strict positive probability that it has not .",
    "i have performed a not very thorought search on the net and i have failed to find anything similar .",
    "the closest i know is the gosper s hack @xcite which , i must say , served as inspiration for the design of the algorithm above .",
    "furthermore , the algorithm above borrows its first two lines from gosper s hack .",
    "let @xmath8 and @xmath9 . a @xmath1-bits * word * is an element @xmath10 of @xmath11 . throughout @xmath2 is fixed and , unless necessary , we omit the @xmath1 from notation . also , we most often drop parentheses and commas as well .",
    "( for instance , @xmath12 becomes @xmath13 . ) finally , by abuse of notation , we identify @xmath10 with the number whose binary expansion is @xmath14 .",
    "more precisely , with @xmath15 thanks to this identification we can order words , talk about minimum , maximum , etc .    for @xmath16 and @xmath17 we define @xmath18 in plain english , @xmath19 is the number of ones in @xmath14 appearing before or at @xmath20-th position .",
    "similarly , @xmath21 counts the number of zeros before or at position @xmath20 .",
    "we say that @xmath16 is a * dyck word * if @xmath22 with equality holding for @xmath23 , that is , @xmath24 in plain english , before or at the @xmath20-th position , the number of ones must be no lesser than the number of zeros . in adition the total numbers of ones and zeros match .    for the mathematically trained eye , property becomes easier to spot or not so small if you are a lisp programmer .",
    "] when ones and zeros are replaced , respectively , with openning and closing parentheses . in this case , the dyck word contains @xmath2 pairs of correctly matched open and close parentheses .",
    "for instance , @xmath13 becomes ( ) ( ) ( ) ( ) and @xmath25 becomes ( ) ( ( ( ) ) ) .",
    "the algorithm in the abstract generates the succesor of the given dyck word .",
    "therefore , to kick off and stop the generation of all words , we need to know the minimum and maximum dyck word .",
    "( recall that word size is fixed and `` minimum '' and `` maximum '' refer to the order of integer numbers . )",
    "we claim that the minimum dyck word is @xmath26 ( or @xmath27 in the parenthetical representation ) .",
    "more precisely , @xmath28 is given by @xmath29 , if @xmath20 is odd , and @xmath30 , if @xmath20 is even .    before proving our claim ,",
    "we compute @xmath31 : @xmath32 calculating this number on real computers needs care to avoid overflow . for instance , if @xmath33 then @xmath34 which is one more than the maximum natural number representable by a @xmath0-bits unsigned integer type . in practice",
    ", however , this is a `` minor '' issue because generating all @xmath0-bits dyck words would take `` forever '' given that the number of @xmath1-bits dyck words grows factorially @xcite with @xmath2 .",
    "we shall now prove that @xmath31 is the minimum dyck word .",
    "suppose by contradiction that there s a dyck word @xmath10 such that @xmath35 .",
    "in particular , @xmath36 and let @xmath20 be the minimum index such that @xmath37 . since @xmath35 , we have @xmath38 and @xmath29 .",
    "it follows that @xmath20 is odd . by construction of @xmath31 ,",
    "@xmath39 because @xmath40 is even .",
    "the same holds for @xmath14 because it shares the first @xmath40 bits with @xmath31 .",
    "now , @xmath38 and thus @xmath41 and @xmath42 which yields @xmath43 , contradicting .",
    "its much easier to see that the maximum dyck word is @xmath44 which values @xmath45 .",
    "let @xmath10 be a dyck word . in this section",
    "we characterize the dyck word that succeeds @xmath14 , that is , the smallest dyck word which is greater than @xmath14 .    assuming that @xmath46 , _",
    "i.e. _ , @xmath14 is not the maximum dyck word , there exists at least one index @xmath47 such that @xmath38 and @xmath48 . let @xmath49 be the maximum of such indices . since a dyck word can not start with a zero or finish with a one , we have @xmath50 . then , after position @xmath49 there is no bit zero followed by a bit one",
    ". more precisely , there s a ( possiblye empty ) sequence of ones followed by a sequence of zeros up to the end .",
    "hence , @xmath14 has this form : @xmath51 with @xmath52 and @xmath53 .",
    "we shall prove that the successor @xmath54 of @xmath14 has this form : @xmath55    notice that the prefixes of @xmath14 and @xmath54 are the same .",
    "first we shal show that @xmath54 is well defined , that is , @xmath56 ; the size of @xmath54 is @xmath1 ; and @xmath54 verifies the properties and .",
    "the total number of ones in @xmath14 is @xmath57 and the total number of zeros is @xmath58 .",
    "since @xmath14 is a dyck word , these numbers match and we obtain @xmath59 . hence , @xmath60 again , because @xmath14 is a dyck word , @xmath61 is positive and so is @xmath62 .",
    "the last two segments of @xmath14 have total size @xmath63 and the last two segments of @xmath54 have total size @xmath64 .",
    "hence @xmath54 is also @xmath1-bits long and @xmath65 .    because of the common prefix with @xmath14 , @xmath54 verifies property for any @xmath66 .",
    "obviously , it also verifies for @xmath67 ( @xmath54 gets an extra @xmath68 ) .",
    "notice that for any @xmath69 , @xmath70 .",
    "hence , if @xmath54 fails to verify for any @xmath20 in this set of indices , then it fails to verify for @xmath71 .",
    "however , @xmath72 and @xmath73 and from we obtain that these numbers are equal .",
    "this proves that holds for @xmath74 .",
    "furthermore , we have proven that @xmath75 .    from the @xmath76-th bit onwards , the sequence is alternating and it follows that @xmath77    to prove that @xmath54 is the smallest dyck word which is greater than @xmath14 , assume there s another dyck word @xmath78 such that @xmath79",
    "well , obviously , @xmath80 must have the same prefix as @xmath14 and @xmath54 .",
    "what about @xmath81 ?",
    "it s either zero or one and we slipt in two cases .    if @xmath82 then , because @xmath83 and @xmath84 for all @xmath85 , the common part between @xmath80 and @xmath14 must span up to index @xmath86 . for @xmath87 , @xmath38 and for @xmath83 to hold , at least one of the last @xmath88 bits of @xmath80 must be one . then the number of ones in @xmath80 is greater than the number of ones in @xmath14 which violates the fact that any dyck word has exactly @xmath2 ones .    similarly , if @xmath89 , then because @xmath90 and @xmath70 for @xmath69 the common part between @xmath80 and @xmath54 must span up to index @xmath76 .",
    "but , since @xmath91 , there exists @xmath92 such that @xmath93 .",
    "let @xmath20 be the minimum of such indices .",
    "for @xmath90 to hold , it is necessary that @xmath94 and @xmath95 . from",
    "it follows that @xmath20 is odd and @xmath96 is even . again from we obtain @xmath97 and the same holds for @xmath80 thanks to its common part with @xmath54 . but @xmath94 and thus @xmath98 and @xmath99 which violates .",
    "the following c++ function implements the algorithm presented in the previous section . it does not allocate memory for the output and , instead , performs the manipulations in - place .",
    "it makes no use of helper containers and , therefore , it s @xmath7 on space .",
    "the algorithm scans the word backwards up to a certain point .",
    "then it advances forward changing the bits up to the rightmost . hence , in the worse case , the program scans the whole word twice implying complexity @xmath6 on time .",
    "the function takes a dyck word ` w ` made of ` one`s and ` zero`s ( provided as arguments ) and transforms it into the next dyck word , if it exists , otherwise , it clears the word .",
    "the behaviour is undefined if ` w ` is not a dyck word of ` one`s and ` zero`s .",
    ".... void next_dyck_word(std::string & w , char const one , char const zero ) {       unsigned const m = w.size ( ) - 1 ;    unsigned        y = 0 ;    unsigned        x = 0 ;      for ( unsigned i = m ; i > 0 ; --i ) {        if ( w[i ] = = zero )        + + y ; // counter for trailing zeros .",
    "else if ( w[i - 1 ] = = zero ) {               // found greatest i such that w[i ] = zero and w[i + 1 ] = one .               //",
    "change these two chars .",
    "w[i - 1 ] = one ;        w [   i   ] = zero ;               // overwrite the following next y - x chars to zero .        for ( y = y - x ; y !",
    "= 0 ; --y )          w[++i ] = zero ;               // overwrite the remaining chars with alternating ones and zeros .        while ( i < m ) {          w[++i ] = one ;          w[++i ] = zero ;        }        return ;      }        else        + + x ; // counter for ones that precede the trailing zeros .    }    w.clear ( ) ; // failed to produce a dyck word , then clear w. } ....",
    "we shall consider now the short implementation shown in the abstract .",
    "similarly to the longer implementation , the short one assumes that the input is a dyck word . if it is not , then this is a pre - condition violation which yields undefined behaviour .",
    "in addition ( and opposite to the implementation above ) , another pre - condition is that the input is not the maximum dyck word of its size .",
    "failing to verify this condition , again , produces undefined behaviour .    for easy of reference",
    "( and because it is very short ) we trascript the algorithm here .",
    ".... integer next_dyck_word(integer w ) {    integer const a = w & -w ;    integer const b = w + a ;    integer        c = w ^ b ;                  c = ( c / a > > 2 ) + 1 ;                  c = ( ( c * c - 1 ) & 0xaaaaaaaaaaaaaaaa ) | b ;    return c ; } ....    the abstract says that ` integer ` is a c / c++ _ unsigned _ integer type and the first line in the function s body takes the opposite of ` w ` ! this is intended and works as expected on c and c++ conforming implementations because on these systems unsigned integer types have @xmath100-modular arithmetics , where @xmath101 is the size in bits of the integer type .",
    "other programming languages might have different integer types and , at this point , it is useful to list the properties the type must verify for the algorithm to work .    the first rule is obvious but worth saying : the type must implement the usual binary representation of integer numbers .",
    "in particular , all values in the range @xmath102 are representable .",
    "@xmath100-modular arithmetics is sufficient but not necessary and only the opposite of ` w ` must be as per @xmath100-modular arithmetics ( simply put the opposite of @xmath14 is @xmath103 ) . for the other operations ,",
    "usual arithmetic rules are enough because the ( mathematical ) results of additions , subtractions , multiplications and divisions stay in the @xmath102 range . moreover , ` a ` is a divisor of ` c ` ( see below ) and , therefore , no truncation or division by zero occurs .",
    "we assume usual semantics also for the bitwise operators ` & ` , ` ^ ` , and ` | ` .",
    "finally , the right shift rotation inserts zeros in the gaps on the left but if , this is not the case , we can replace the right shift of two bits by a division by four , provided that the division truncates the result .",
    "the pleasure of verifying the details that the arithmetic and bitwise operations above reproduce the construction explained in previous section is left to the reader .",
    "i shall provide an overall picture though .",
    "let @xmath104 , @xmath105 , @xmath88 and @xmath54 be as in the previous section .",
    "the expression ` w & -w ` , assigned to ` a ` , yields a number whose bits are all zero but the one located at position @xmath86 .",
    "the result of ` w + a ` , assigned to ` b ` , is a number that matches @xmath54 up to position @xmath65 and have only zeros afterwards .",
    "hence , the first two lines do almost everything .",
    "the following three fill up the last @xmath106 positions with the sequence of ones and zeros .    the first value assigned to `",
    "c ` is a number with all bits zero but @xmath107 of them which form a contiguous sequence finishing at position @xmath86 . recall that at this position lies the only non null bit of ` a `",
    "hence , ` c / a ` has the effect of moving the sequence of @xmath107 ones in ` c ` all the way up to the right .",
    "shifting @xmath108 extra bits produces a number with all its @xmath105 least significant bits set to one , that is , @xmath109 . after the addition to @xmath68 , ` c ` gets the value @xmath110 .",
    "squaring produces @xmath111 and decrementing yields @xmath112 which is a mask for the @xmath106 rightmost bits .",
    "now the magic number comes in ( at this point , you have probably guessed what this is ) .",
    "it s the @xmath0-bits number whose binary expansion is an alternating sequence of ones and zeros or , in other terms , it s the minimum @xmath0-bits dyck word .",
    "applying operator ` & ` to the mask and the magic number produces the @xmath106-long sequence of ones and zeros needed to fill the gap in ` b ` .",
    "the operator ` | ` completes the task .",
    "i thank my friend prof .",
    "lorenz schneider who introduced me to the gosper s hack about three years ago .",
    "i am also grateful towards _ mosh111 _ , whoever he / she is , who introduced me to the problem of dyck word generation through his / her post in @xcite 3 days ago ."
  ],
  "abstract_text": [
    "<S> let ` integer ` be any c / c++ unsigned integer type up to @xmath0-bits long . given a dyck word the following code returns the next dyck word of the same size , provided it exists .    </S>",
    "<S> .... integer next_dyck_word(integer w ) {    integer const a = w & -w ;    integer const b = w + a ;    integer        c = w ^ b ;                  c = ( c / a > > 2 ) + 1 ;                  c = ( ( c * c - 1 ) & 0xaaaaaaaaaaaaaaaa ) | b ;    return c ; } .... </S>"
  ]
}