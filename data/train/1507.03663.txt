{
  "article_text": [
    "o. gasquet and f. maris teach at university paul sabatier in toulouse , france .",
    "they teach logic at different levels starting from introductory courses of propositional logic up to advanced topics for graduate students , like modal logic or logic - based planning .",
    "s. ben slimane , a. comte , a. heba , o. lezaud and m. valais are graduate students of the same university . they have been implementing ` touist `  during three months of their msc .      at the beginning of undergraduate studies , we ( teachers ) found that students motivation may be increased by showing them that logic is useful and powerful for computer scientists and that computer science does not only consist in hacking c - code or java .",
    "classically , logic is motivated by abstract examples or , at the best , by toy examples . at some time",
    ", we thought that it would be preferable to show and not only tell them that with little knowledge , logic can be used to solve difficult problems whose size prevents humans from solving them by hand easily or would require rather complex programming in c or any other programming language . +      in icttl2011 , we presented ` satoulouse `  @xcite , devoted to propositional logic whose main features were 1 ) to offer a high - level logic language for expressing succinctly complex formulas and 2 ) to find models of these formulas by using a powerful sat prover .",
    "but ` satoulouse `  had several drawbacks to be corrected .",
    "+ of course , there are loads of logic tools like provers , proof assistants , truth table editors,  on the internet , even prolog could have been used , but none fits our requirements which are :    * the tool must be very easy to install and to use , with no complex syntax ; * the prover can be used as a black box without knowing how it works ; * no normal forming , ordering on clauses , or prolog cut must be needed ; * only little knowledge in logic should be necessary .    as we could not find an existing tool fulfilling these requirements , in 2010 we started to implement ours , and we came to the idea of just developing an interface that allows to very comfortably use a powerful sat - prover ( namely sat4j @xcite ) : this tool had been called ` satoulouse `  and is described in @xcite . with this tool , students could experiment by themselves that a logical language is not only descriptive but may lead to computations that solve real - life problems .",
    "in particular , with ` satoulouse ` , they could solve sudokus quite easily , as well as many other combinatorial problems such as time - table , map coloring , electronic circuits design,  .",
    "here are the main facilities that ` satoulouse `  offered :    * input formulas need not to be in clausal form and arbitrary connectives may be used , normal forming is done dynamically during keyboarding of the user ; * big conjunctions and disjunctions facilities are offered like in : @xmath0 * running the solver only consists in clicking a button ; * the tool displays a model in the syntax of the input formula .",
    "then it is possible to show the power of propositional logic to students that have been trained a bunch of hours to formalize sentences in logic and have acquired basic notions of validity and satisfiability to automatically solve some sudokus .",
    "but this is not the whole story , since the same sat - solver may be used for solving many other combinatorial problems as easily as they just did for sudokus : they just have to formalize the constraints .",
    "our students are asked to do so for : time - table , map coloring,  `satoulouse ` has been used during three years now by about 400 students with great satisfaction .",
    "particularly , students used it to perform long - term homeworks in the spirit of programming projects : we give them a logical problem to solve ( too big to be solved by hand ) , they must formalize it and then use this formalization to solve the problem .",
    "for example , a problem of storage of chemicals that must be stored in same / contiguous / non - contiguous rooms according to their degree of compatibility .",
    "students must solve a case involving a lot of chemicals .",
    "but during these years , we noticed some painful limitations of ` satoulouse ` : many bugs , flaws in the interface , lack of modularity ( if one wishes to change the sat prover used ) , ambiguity and limitations of its language , etc .    for example , problems involving pigeon - holes principle like the rules of the takuzu game which requires to count 0 s and 1 s could not be easily formalized : facilities to express something like `` exactly 5 among 10 propositions are true '' were missing .    `",
    "satoulouse `  do not offer the possibility to browse all the models provided by the prover , it only returns one .",
    "lessons learned from two years using ` satoulouse `  are that many of our cs students clearly become aware that logic has real applications w.r.t .  problem solving , and many of them gained ability in formalizing problems .",
    "but remaining flaws of ` satoulouse `  made debugging really hard because only one model is displayed and because of the raw way the models is displayed , together with the poor editing capabilities it has .",
    "moreover only pure combinatorial problems could be handled which heavily limitates the wide range pretention of ` satoulouse `  w.r.t .",
    "real world problems .",
    "another drawback of ` satoulouse ` not specifically linked to logic teaching , was its inability to be used from the command line : researchers or engineers who wish to use it intensively would find it tedious to type input problems .",
    "last , extension to richer theories is also something that may interest researchers , engineers or graduate students , since ` satoulouse `  is definitely not suited for satisfiability modulo theories or for solving planification problems though the same architecture of the software could be used by just changing the solver used .",
    "a few months ago , we started to go for a whole new software which would fulfill all these demands .",
    "it would be called ` touist `  which stands for toulouse integrated satisfiability tool and should be pronounced `` twist '' .    ` touist `  is of course publicly available for download from the following site    https://github.com/olzd/touist/releases    to sum it up , here are the features ` touist `  offers that ` satoulouse `  does not :    * definition of domain sets : @xmath1 vs. @xmath2 * multiple binding of indexes : @xmath3 vs. @xmath4 * rich computations on indexes as well as on domain sets @xmath5 * built - in pigeon - holes primitives : `` atleast '' ( resp .",
    "`` atmost '' , `` exact '' ) _ so many _ values are true among _ these values _ * predicates also may be variables ranging over domain sets : @xmath6 vs. @xmath7 * specialized literals targeting constraints between integer or real numbers * easy browsing of models successively computed by the solvers * regular expressions allowing filtration of literals under interest * possibility to use the software on command line and/or batch * many editing facilities and improvements",
    "` touist `  is made of three modules , but the standard user will only see one of them : the interface . in the sequel we mainly insist on the latter rather than on the translator and the solver .",
    "the global architecture looks as pictured in figure [ fig : architecturetouist ] :        with ` touist `  one accesses a powerful and friendly editor for editing complex logical formulas and various constraints like :    @xmath8    which comfortably abbreviates @xmath9 .",
    "once it has been given to the interface , a set of formulas may be checked for satisfiability : the interface would send it to the provers which would send back a satisfying model , displayed as shows figure [ fig : exampleofamodel ] if such models exist .",
    "then through the interface , the user can for example ask for other models ( button `` next '' of the interface ) .",
    "models returned by the prover are `` total '' ones : each variable appearing in the formulas sent to the prover is assigned a value .",
    "the user may select only true propositions or only false ones .",
    "she can also select subsets of the variables under interest by typing a regular expression filtering them .",
    "with time , we noticed that we often need to write things like @xmath10 if one read @xmath11 as `` there is a letter @xmath12 in cell @xmath13 '' of some @xmath14 grid , the above formula expresses that there is _ at most _ one letter among ` a ' ... ` i ' in each cell .",
    "these sets @xmath15 and @xmath16 are _ domain sets _ , with ` touist `  the user may define as many domain sets she wants , e.g. :    ....   n=(1 .. 9 )    l=(a , b , c , d , e , f , g , h , i ) ....    and then write the above formula as @xmath17 + moreover , usual operations on sets ( @xmath18 , @xmath19 , @xmath20 ,  ) can be used to define other sets .      the formulae of ` touist ` are based on propositional variables ( that can have indices ) and usual logical operators ( @xmath21 , @xmath22 , @xmath23 , @xmath24 , @xmath25 )",
    ". thus one can type usual simple formulas like @xmath26 .",
    "but in addition , we provide high - level logical operators that allow to express complex statements in a very compact form .",
    "they allow to express conjunctions and disjunctions over formulas containing parameters that vary , e.g.    * @xmath27 , where @xmath28 is the domain set defined above .",
    "it represents @xmath29 .",
    "* @xmath30 .",
    "of course , these operators may be nested , as in @xmath31 stating that in each cell there is at least one letter .",
    "they were one of the `` left - to - the - future '' topic of @xcite .",
    "these less classical logical operators are available in ` touist ` : they allow to drastically lower the size of some formulas , they are : @xmath32 , @xmath33 and @xmath34 . + the following examples will describe their meanings :    * @xmath35 represents  for at most two values of @xmath36 @xmath37 is true ; * @xmath38 represents  for at least two values of @xmath36 @xmath37 is true ; * @xmath39 represents  for exactly two values of @xmath36 @xmath37 is true ;    generalized disjunction is in fact a special case of those : at least one is true , conjuction too : at most 0 are false , and exclusive or may be viewed as : exactly one among two is true .",
    "let us recall that with basic logical operators and with @xmath28 containing 9 elements , @xmath40 would necessitate a formula containing 84 propositions @xmath41 since it amounts to choosing 3 among 9 which yields @xmath42 possibilities , and neither @xmath43 and @xmath44 would help a lot .      often we need to add constraints on indexes , for example : @xmath45 which means that @xmath46 is true whenever @xmath47 .",
    "this was the only constraint available in ` satoulouse ` , now in ` touist `  the range of possibility has been widely enriched .",
    "constraints may include usual comparaison operators like @xmath48 , @xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath53 and these comparisons may not only apply to indices but to any arithmetic expressions involving indexes and @xmath54 , @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 . expressing a sentence like `` each cell @xmath13 contains a number which is not equal to @xmath60",
    "'' will give : @xmath61 of course , _ all these sentences _ may be expressed with usual plain logical operators , but this would be an aweful work to do .",
    "nevertheless , students must know what is behind the scene , and that such a compact formula abbreviates something long and dull like : @xmath62        formulas as seen above are written in the _ display _ language ( latex - style ) , but all those symbols are not available on keyboards , thus for writing formula and domain sets , the user will use the input language .",
    "for example , the above formula together with the associated set @xmath28 will be typed as ( variables are prefixed with $ ):    .... bigand $ i in $ n , $ j in $ n     bigor $ k in $ n when $ k < $ i+$j :      p($i,$j,$k ) )    end end ....    but ` touist `   displays it in latex - style as seen in the right panel shown in figure [ fig : latexdisplay ] .",
    "the definition of the set @xmath28 is done in the sets tab .",
    "also , formulas may either be hand - typed in the editor window , or introduced in a sort of syntax - directed editor , by progressively refining the syntax tree , or else they can be imported from some external file .",
    "in what follows , we very briefly present some advanced features of ` touist ` . they may rather interest researchers , engineers , graduate students and their teachers .",
    "they concern smt ( sat modulo theories ) , planning as sat and their combination planning as smt .",
    "some combinatorial problems require nevertheless to deal with some calculus over natural or real numbers .",
    "this can be done using only propositional logic ( e.g.  @xmath63 may be encoded by @xmath64 ) , but it is very uncomfortable as soon as there are more than a few additions to be made .",
    "do not even mention products or more complex operations .",
    "the idea behind smt genesis has been to combine sat solvers with arithmetic solver in order to improve the treatment made to the arithmetic part of reasoning . in many cases",
    ", it will not only improve the efficiency of the prover , but will also allow to express arithmetic constraints of problems in a drastically more compact way .",
    "think of the kamaji game where the player must group adjacent numbers in a grid so that their sum is equal to some fixed number . solving the game",
    "essentially requires logical reasoning but still needs a few arithmetic ( addition )",
    ".    then if @xmath65 for each cell @xmath13 is an integer and @xmath66 represents the fact that cells @xmath13 to @xmath67 of line @xmath68 form a group , the sum constraint may be expressed as : @xmath69 where @xmath28 is the fixed number and @xmath70 is @xmath71 .",
    "pure propositional logic is definitely unsuited for such sentences !      in artificial intelligence , _ planning _ is a cognitive process to automatically generate , through a formal procedure , an articulated result in the form of an integrated decision - making system called _ plan_. the plan is generally in the form of an organized collection of _ actions _ and it must allow the universe to evolve from the _ initial state _ to a satisfactory state , the _ goal_. propositional planning as sat has been introduced by kautz and selman in @xcite .",
    "one important difference of ` touist ` compared with ` satoulouse ` is its ability to take into account both logic formulas and domain sets .",
    "for example , if one wants to solve a particular planning problem , ` satoulouse `  is easy to use for describing the problem and solving it via a sat solver .",
    "but in order to solve several generic planning problems , we can take advantage from the flexibility of ` touist `  which will allow the user to describe a generic solving method with rules encoded as formulas and to use domains sets to describe each particular planning problem .",
    "numerous encoding rules for planning problem resolution have already been proposed @xcite . as an example of such a rule we give below an encoding of frame - axioms . if a fact is false at step i-1 of a solution plan and becomes true at step i , then the disjunction of actions that can establish the fact at step i of the plan is true .",
    "that is , at least one of the actions that can establishes the fact should have been applied .",
    "@xmath72      moreover , in addition to sat , our new platform ` touist `  is able to handle theories like difference logic or linear arithmetic on integer or real numbers , and call a smt solver to find a solution . to be solved , real world",
    "temporal planning problems require to represent continuous time , and so , the use of real numbers in logic encodings . ` touist `  can also be used to solve such problems involving durative actions , exogenous events and temporally extended goals , for example with encoding rules proposed in @xcite .",
    "we give below an encoding of temporal mutual exclusion of actions .",
    "if two actions respectively producing a proposition @xmath73 and its negation are active in the plan , then the time interval @xmath74 $ ] corresponding to the activation of @xmath73 , and the time interval @xmath75 $ ] corresponding to the activation of @xmath76 are disjoint .",
    "@xmath77 @xmath78\\right]\\ ] ]",
    "as far as we are aware , there is no other tool targeted at the same large audience , neither at the same wide class of problems , neither with the same comfort .",
    "most existing pedagogical tools ( either implementation of truth - tables or semantic tableaux ) that could do the job of searching a model can not efficiently handle big problems , and real tools able to deal with them are definitely not designed to be used by beginners in logic , and not even by most graduate students .",
    "advanced tools designed for graduate topics , like mozart @xcite or alloy @xcite have a steep learning curve that may dissuade beginners and non - specialist users .",
    "olivier gasquet , franois schwarzentruber , and martin strecker .",
    "satoulouse : the computational power of propositional logic shown to beginners . in p.",
    "blackburn , h.  van ditmarsch , m.  manzano , and f.  soler - tosca , editors , _ third international congress on tools for teaching logic ( icttl2011 ) _ , volume 6680 of _ lecture notes in computer science _ , pages 7784 .",
    "springer , 2011 .",
    "amol  dattatraya mali and subbarao kambhampati . on the utility of plan - space ( causal ) encodings .",
    "in _ proceedings of the sixteenth national conference on artificial intelligence and eleventh conference on innovative applications of artificial intelligence , 1999 _ , pages 557563 , 1999 .",
    "frdric maris and pierre rgnier .",
    "tlp - gp : new results on temporally - expressive planning benchmarks . in _ international conference on tools with artificial intelligence ( ictai ) _ , volume  1 , pages 507514 .",
    "ieee computer society , 2008 ."
  ],
  "abstract_text": [
    "<S> sat provers are powerful tools for solving real - sized logic problems , but using them requires solid programming knowledge and may be seen w.r.t .  </S>",
    "<S> logic like assembly language w.r.t </S>",
    "<S> .  programming . </S>",
    "<S> something like a high level language was missing to ease various users to take benefit of these tools . ` </S>",
    "<S> touist `  aims at filling this gap . </S>",
    "<S> it is devoted to propositional logic and its main features are 1 ) to offer a high - level logic langage for expressing succintly complex formulas ( e.g.  formulas describing sudoku rules , planification problems ,  ) and 2 ) to find models to these formulas by using the adequate powerful prover , which the user has no need to know about . </S>",
    "<S> it consists in a friendly interface that offers several syntactic facilities and which is connected with some sufficiently powerful provers allowing to automatically solve big instances of difficult problems ( such as time - tables or sudokus ) . </S>",
    "<S> it can interact with various provers : pure sat solver but also smt provers ( sat modulo theories - like linear theory of reals , etc ) and thus may also be used by beginners for experiencing with pure propositional problems up to graduate students or even researchers for solving planification problems involving big sets of fluents and numerical constraints on them . </S>"
  ]
}