{
  "article_text": [
    "our group has designed and implemented a unified accelerator application programming interface ( api ) called xal@xcite .",
    "xal is designed to aid in the development of science control applications for beam physics .",
    "accordingly , the xal api is a _ physics - centric software programming interface .",
    "the physics applications interact with a model of an accelerator that resides in computer memory .",
    "xal also contains the software infrastructure that creates the accelerator model .",
    "xal loads a text - based ( xml ) description of an accelerator and assembles software objects such that an accurate model of the accelerator exists in computer memory .",
    "xal is based on ual @xcite , the unified accelerator library .",
    "_    the original motivation for xal was to provide an accelerator independent interface for applications to interact with i / o from a live accelerator .",
    "this allows physicists to write beam physics control applications ( orbit correctors , beam profile monitors , rf tuners , etc . ) to the xal api so that they can run on any accelerator .",
    "some pseudo - code illustrating the principles of an xal - based orbit correction application may illustrate the essence of the concept .",
    ".... accelerator   theaccel = xalfactory.newaccel(``sns.xml '' ) bpm [ ]         thebpms        = theaccel.getnodesoftype(bpm ) horzdipole [ ] thecorrectors = theaccel.getnodesoftype(dch ) for each bpm in thebpms        read bpm.avgpos ( ) and set a corrector magnet accordingly ....    to aid in writing applications that take into account design values , the accelerator description file contains all design information for the accelerator .",
    "this condition allows , for example , a physics application to compare the design field of a quadrupole with its read - back ( runtime ) field .    with all design information incorporated into a software model of an accelerator",
    ", we have discovered an excellent simulation engine .",
    "as long as the software accelerator has a convenient means for traversing beam - line devices in a spatially sequential manner , we can use design values along the way to simulate beam - dynamics .",
    "this scenario allows for a drastic departure from traditional accelerator simulation codes .",
    "traditionally simulators have been isolated software products .",
    "they load some type of lattice description of an accelerator and apply predefined beam - dynamics to an initial beam .",
    "ultimately this design has led to huge codes ( to account for various beam - line element types ) .",
    "further , these codes typically operate with only one type of simulation ( multi - particle or rms envelope , but not both ) .",
    "the architecture presented here contains a novel approach to the simulation domain .",
    "it is our conjecture that the method presented here better captures reality in that there is some sort of _ software beam actually traversing a software model of a real accelerator . _",
    "our approach is based upon the element - algorithm - probe design pattern @xcite .",
    "the core concept of this design pattern is the separation of beam - dynamics code from the actual beam - line elements .",
    "it is desirable to keep the code that corresponds to beam - line elements as simple as possible so that the application writer has a clean interface to a beam - line element .",
    "the element - algorithm - probe pattern enforces this concept by requiring beam - dynamics code to exist in a separate entity , called an ialgorithm .",
    "deferred until runtime is the binding of beam - dynamics to actual beam - line elements .",
    "this deployment strategy allows for conceptually correct simulations .",
    "first it is truly modular .",
    "the three concepts , beam - line elements , beam - dynamics , and the beam are compartmentalized into separate code .",
    "second it is truly maintainable . to support a new beam type or new beam - line element type",
    "does not cause code bloat .",
    "finally it is truly extensible . via the mechanism of a java interface",
    ", various beam - dynamics algorithms can be written for the same type of beam - line element and switched at will at runtime .",
    "modularity , maintainability , and extensibility provide true power and flexibility to our architecture .",
    "it may help to understand the facets of java that we exploit in order to implement the element - algorithm - probe design pattern .    at the center of the element - algorithm - probe pattern",
    "is the concept of a java _ interface . essentially , an interface is a contract between a user and an implementor .",
    "the contract says that the implementor of an interface is required to provide an implementation of the methods defined in the interface .",
    "_    for example , consider the interface    .... public interface thermometer {        public double gettemperature ( ) ; } ....    using this interface , a programmer can assume being able to perform operations on a thermometer no matter how the thermometer actually obtains the temperature .",
    "this is desirable because a thermometer implementor can change how the temperature is actually obtained ( if , say , a new sensor system was installed ) without requiring all thermometer users to recompile their code .",
    "we use the same idea with beam - dynamics code .",
    "beam - dynamics reside in files that _ implement ( the computer science term for acknowledging involvement in the contract from the implementors point of view ) the ialgorithm interface . since the simulation engine knows how to do beam - dynamics calculations solely by interacting with ialgorithms , it is trivial to swap beam - dynamics algorithms at will . _    the ialgorithm interface looks like this .    ....",
    "public interface ialgorithm {     public void propagate(ielement , iprobe ) ;     public class legalelementtype ( ) ;     public class legalprobetype ( ) ; }   ....    conceptually , an ialgorithm implementor is required provide an implementation of the method propagate ( ) to modify the the beam ( iprobe ) according to the beam dynamics of the the beam - line element ( ielement ) .    in essence ,",
    "all that the simulation engine knows about are the three data types ( all defined in interfaces ) ialgorithm , iprobe , and ielement .",
    "the beauty of this design is that there are separate code locations for beam - line elements , beam - dynamics , and the beam itself .",
    "the iprobe interface should ideally contain the bare minimum information to fully represent a beam .",
    "such beam information consists of beam current , beam charge , particle charge , particle rest energy , particle kinetic energy , etc .",
    "further , since a probe represents the state of the beam at a position in the beam - line , a probe also contains a beam - line - position attribute .",
    "the current iprobe specification serves the purpose of representing a beam for a single particle , particle ensemble , and envelope simulations ( in both two and three dimensions ) .",
    "figure 1 represents a suitable inheritance hierarchy of probe types to handle the aforementioned simulation types .",
    "it is important to note that there are various approaches toward simulating beam - dynamics .",
    "for example , accurate approaches may involve slicing nodes up into small pieces .",
    "an aggregate of approximations done on sufficiently small elements is typically more accurate than one overall approximation .",
    "however , normally this is only practical in elements that have special behavior .",
    "so the question arises : _ how are probes propagated through elements ? _    it is the responsibility of the ialgorithm implementor to handle all beam - dynamics , including the propagation mechanism .",
    "sample propagation mechanisms will be presented later in this paper .",
    "however , keep in mind the most appropriate propagation mechanism when implementing algorithms for the particular problem at hand .",
    "we have already introduced the concept of the ialgorithm interface .",
    "now let us pursue a few more details regarding its implementation .",
    "the ialgorithm interface provides a generic way of assembling algorithms in a simulation engine . in practice",
    "any particular ialgorithm implementation only makes sense in the context of a particular beam - line element type and probe type .",
    "for example , a hypothetical ialgorithm called quadparticlemapper would expect a quadrupole as its ielement and a particle as its iprobe .",
    "providing such specificity is the job of the legalelementtype ( ) and legalprobetype ( ) methods .",
    "an implementation of the quadparticlemapper could look like this .    ....     public class quadparticlemapper(ielement p_elem ,                                   iprobe p_probe ) {    public class legalelementtype(){return quadrupole.class ; }       public class legalprobetype(){return particle.class ; }    public void propagate(){quadrupole / particle beam dynamics } } ....    by providing these methods , the simulation engine can do type checking upon algorithm binding . it would not make sense to bind this algorithm to a wirescanner .",
    "providing these methods helps to avoid that condition .",
    "designing an actual simulation merely involves putting together elements , algorithms , and probes in a semantically meaningful way .",
    "it turns out that , to the first order , the beam dynamics through a particular node type can be captured by a transfer matrix .",
    "this property allows for a straight - forward means of simulating a particle traveling down a beam - line .",
    "an object - oriented approach would be to create a particlemapper class that transforms the particle probe by the simple vector - matrix multiplication @xmath0 where @xmath1 is the coordinate vector of the particle @xmath2 at the start of the node , and @xmath3 is the transfer matrix of the node .",
    "further , @xmath3 can be obtained by the particlemapper via the use of an abstract method that is implemented by beam - dynamics algorithms for individual nodes ( quadrupoleparticlemapper , rfcavityparticlemapper , etc . ) .",
    "a suitable class design can be seen in figure 2 .    to further illustrate some of these concepts , the basic layout of the particlemapper class looks like this .",
    ".... abstract public matrix computetransfermatrix ( ) ;    public void propagate(ielement pelem , iprobe pprobe ) {          //type - cast the probe and element to what we expect          particle theprobe = ( ( particle)pprobe ) ;           acceleratornode thenode = ( ( acceleratornode)pelem ) ;             //do the vector - matrix multiplication          theprobe.setcoords(computetransfermatrix                               .times(theprobe.getcoords ( ) ) ) ;            //advance the probe the length of the node          theprobe.advanceposition(thenode.getlength ( ) ) ;          return ; } ....    once the computetransfermatrix ( ) operations are implemented for the node - specific dynamics , all that remains is writing a driver program .",
    "a driver program binds algorithms to nodes and injects the probe .",
    "here is a pseudo - code driver .    ....    //instantiate the xal accelerator model accelerator   theaccel = xalfactory.newaccel(``sns.xml '' )    //bind the algorithms quadrupole [ ] thequads       = theaccel.getnodesoftype(quad ) rfcavity [ ]    thecavities    = theaccel.getnodesoftype(rfc ) for each quad in thequads        bind a quadparticlemapper instance to quad for each rfcav in thecavities        bind a rfcavityparticlemapper instance to rfcav    //instantiate a probe particle p1 = new particle(initial conditions ... )     //run the probe down the beam - line acceleratornode [ ] thenodes = theaccel.getallnodes ( ) ; for each node in thenodes        node.propagate(p1 ) ....    and that is it !",
    "the particle probe will be transformed by each beam - line element according the the bound algorithm .",
    "note that the pseudo - code is a basic proof of concept and does not contain the code necessary to broadcast probe increment intermediate data to produce , for example , a plot .    the single particle simulation can be applied to a two - dimensional case by only considering the first four elements of @xmath4 .",
    "further , the single particle simulation can be extended to a multi - particle simulation ( in two and three dimensions ) by constructing a container of particle probes and writing beam - dynamics algorithms that properly transform the collection .",
    "the only matter that complicates ( and complicate it does ! ) a multi - particle simulation is the concept of space - charge . before biting off this task ,",
    "however , a presentation of another type of simulation that accounts for space - charge is warranted .",
    "the rms qualities of a beam can be represented by the 6x6 symmetric matrix @xmath5 that statistically expresses the boundaries of a beam in transverse , longitudinal , and phase space by using moments of the beam distribution .",
    "rms envelopes are convenient because applying beam - dynamics involves a simple matrix operation .",
    "namely , the same transfer matrix @xmath6 used in single particle simulations can propagate rms envelopes according to the conjugation    @xmath7    the other important concept in this simulation is space charge .",
    "a @xmath5 matrix is a statistical representation of a beam , which is a multi - particle entity .",
    "therefore , each particle in the beam is aware ( electromagnetically ) of all other particles in the beam .",
    "it turns out that to the first order the effects of space charge can be captured in a @xmath6 matrix .",
    "while it may not be mathematically trivial to calculate the matrix , having the calculation in such a form makes the integration into our simulation engine simple .",
    "however it should not be overlooked that this quantity is very important to the correctness of simulation .",
    "the envelope simulation is more complex than a single - particle simulation in that we will propagate envelopes through elements using more than one propagation mechanism .",
    "specifically , we may be able to compute a better approximation of behavior through quadrupoles than rf cavities .",
    "this condition is due to the fact that the @xmath6 matrix for a quadrupole adheres to the semi - group property .",
    "@xmath8    or    @xmath9 where @xmath10 is the length of the quadrupole being considered .",
    "to more accurately consider space charge , we take advantage of the semi - group property of the transfer matrices . in the propagate ( )",
    "method of the semigroupenvelopemapper ( see figure 3 ) we subsection the node ( e.g. , a quadrupole ) into @xmath11 slices of length @xmath12 where @xmath13 is the length of the quadrupole .",
    "then we run the probe through these @xmath11 slices , applying space charge kicks after every subsection ( see figure 4 ) .",
    "since rf cavity transfer ( @xmath6 ) matrices do not in general adhere to a semi - group property , we are forced to take a more simplistic approach toward transforming the envelope .",
    "we will slice the node in two , treating each half as a drift - space ( to account for space charge ) and hit the envelope in the middle of the node with the numerically approximated @xmath6 matrix ( see figure 5 ) .",
    "as a final exercise it will be useful to consider the design of a multi - particle simulation .",
    "the true complication of designing a multiple - particle ( ensemble ) simulation is the computation of space - charge effects .",
    "unfortunately , to model multiple particles , space - charge effects can not be accurately captured by a transfer matrix . on the other hand ,",
    "the architecture outlined in this paper keeps the details of the space - charge calculations from interfering with code cleanliness .    .... ....    the two core concepts of a multi - particle ( ensemble ) simulation are    * calculation of the electric self - fields of the ensemble * using the calculated fields to update the particle coordinates .",
    "there are various approaches that can be taken for both tasks .",
    "all that we attempt to show here is that by correctly isolating these concepts , a clean software architecture can be maintained .",
    "namely , an ensemble probe should encapsulate the logic necessary to obtain the electric self fields of the ensemble .",
    "that being the case , various ensemble probe implementations could be swapped at will to employ different field calculation techniques .",
    "for example , many electric field calculation techniques involve solving poisson s equation to obtain the electric potential of the ensemble . by hiding this code from the simulation engine (",
    "it is contained within the ensemble probe implementation ) , the implementor could exploit parallel processing facilities ( see figure 6 ) .    by moving the calculation of electric fields out of the beam - dynamics code ,",
    "the beam - dynamics algorithm developer is free to choose space - charge consideration techniques with minimal impact to code clarity .",
    "one may decide to take the `` thin lens kick '' approach that has been used previously in this paper .",
    "one may alternatively decide to apply a `` trajectory integration '' based approach .",
    "the key point here is that by separating codes into their logical components allows for a high degree of flexibility in simulation technique .",
    "we are enthusiastic to report that the results obtained in the rms envelope simulation have been validated against trace3d @xcite figure 7 shows agreement between simulation results of the sns medium energy beam transport ( mebt ) using both trace3d and the xal simulation engine .",
    "it is encouraging that a problem domain with so many interdependencies(particle physics ) can be simulated with a clean architecture .",
    "as we move toward the future , we are anticipating the ability to implement model reference control techniques .",
    "that is , within the xal model there is access to a live accelerator and a simulated accelerator .",
    "having both at hand allows the comparison of live behavior with simulated behavior to develop control strategies .",
    "the key to effectively implementing an environment conducive to model reference control is architectural discipline when designing both the i / o and simulation aspects of xal . as long as the interface to the two are respectively clean , hybridization of the two will be a straightforward extension .    2 j. galambos , c.m .",
    "chu , t.a .",
    "pelaia , a. shishlo , c.k .",
    "allen , n. pattengale .",
    "`` sns application programming environment '' , epac 2002 n. malitsky and r. talman .",
    "`` unified accelerator libraries '' , aip 391(1996 ) n. malitsky and r. talman . `` the framework of unified accelerator libraries '' , icap 1998 c. k. allen and n. d. pattengale .",
    "`` simulation of bunched beams with ellipsoidal symmetry and linear space charge effects '' , lanl technical report 2002 k. crandall , d. p. rusthoi , `` trace 3-d documentation , '' los alamos national laboratory report la - ur-97 - 886 , may 1997 ."
  ],
  "abstract_text": [
    "<S> a modular , maintainable and extensible particle beam simulation architecture is presented . </S>",
    "<S> design considerations for single particle , multi particle , and rms envelope simulations ( in two and three dimensions ) are outlined . </S>",
    "<S> envelope simulation results have been validated against trace3d . </S>",
    "<S> hybridization with a _ physics - centric contol - system abstraction provides a convenient environment for rapid deployment of applications employing model - reference control strategies . _ </S>"
  ]
}