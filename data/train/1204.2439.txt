{
  "article_text": [
    "the stabilizer formalism @xcite for quantum error correction reveals many similarities between classical and quantum codes .",
    "in particular , it shows that quantum codes can be obtained from classical self - dual codes over @xmath0 @xcite , and inherit many of their properties . despite this connection ,",
    "there exists fundamental distinctions between classical and quantum codes , among which degeneracy stands out @xcite . whereas two distinct bit - flip patterns @xmath1 and @xmath2 applied to a given bit string @xmath3 always produces two distinct strings @xmath4 and @xmath5 , it is possible in quantum mechanics to find two distinct errors @xmath6 and @xmath7 that have exactly the same effect on every code state , i.e. @xmath8 for every state @xmath9 in the code space @xmath10 .",
    "we say that errors @xmath6 and @xmath7 are degenerate for the code @xmath10 .",
    "in fact , every quantum code has degenerate errors , but we say that a code is degenerate when it has degenerate errors that are typical .",
    "degeneracy is a purely quantum mechanical effect with no classical counterpart , and leads to important distinctions between classical and quantum information theory . in particular ,",
    "shannon s bound to the capacity of a memoryless channel @xmath11 @xmath12 is established by counting the number channel outputs that are produced by applying typical errors on all possible input codewords , and demanding that it does not exceed the total number of strings .",
    "if we apply the same counting argument to a degenerate quantum code , because some errors have the same effect on all codewords , we overestimate the number of distinct channel outputs and hence underestimate the channel capacity . indeed , the quantum analog of the mutual information @xmath13 for an input distribution @xmath14 and channel @xmath11 is the coherent information @xmath15 for a purification @xmath16 of an input distribution @xmath17 and a quantum channel @xmath11 .",
    "based on this analogy , one would expect that the quantity @xmath18 upper bounds the quantum channel capacity .",
    "but due to the existence of degenerate errors , the true quantum capacity is instead given by regularized quantity @xcite @xmath19 the quantity @xmath20 can be achieved by non - degenerate codes  for pauli noise defined below it is achieved by random stabilizer codes similar to those used in shannon s original construction in the classical setting .",
    "however , @xmath21 requires the use of degenerate codes .",
    "because @xmath21 involves an optimization over an input distribution correlated across many channel uses , it can not be computed in general",
    ". however , degenerate codes of finite rate have been tailored for channels with @xmath22 @xcite , a striking demonstration that @xmath21 can be greater than @xmath20 .    to benefit from the degeneracy of a quantum code , it is necessary to take it into consideration in the decoding process .",
    "maximum a posteriori ( map ) decoding usually consists in identifying the error with largest probability conditioned on a given error syndrome .",
    "but since degenerate errors have the same effect on all code states , they can all be corrected the same way .",
    "hence , for a degenerate quantum code , map decoding should instead consist of identifying the class of degenerate errors with the largest probability conditioned on a given error syndrome , the probability of a class of errors being the sum of the probabilities of its elements .",
    "this can be substantially more complicated than standard map decoding .",
    "topological codes @xcite are a good example of codes for which a standard map decoder exists @xcite but no degenerate map decoder is known , and where we know that degeneracy can provide an advantage @xcite .",
    "thus , the design of degenerate map decoding algorithms is an important problem for quantum information theory .    in this article",
    ", we study this problem for quantum convolutional codes .",
    "map decoding of classical convolutional codes can be formally classified as a max - prod problem , and is solved using viterbi s algorithm @xcite .",
    "the max is to optimize the conditional probability over all errors , while the prod reflects the fact that the probability of a given error on a memoryless channel is the product of the probability of each of its components .",
    "viterbi s algorithm makes use of the distributive law @xmath23 to solve the map decoding problem @xcite in a time that scales linearly with the length of the code . using the stabilizer formalism",
    ", all this machinery can be imported to the quantum realm and yields a map decoder for quantum convolutional codes @xcite .",
    "a degenerate map decoder has a different formal structure however ; the need to add - up the probabilities of all degenerate errors entails a max - sum - prod problem . by making use of the distributive law of the product over the sum and of the max over the product , together with the particular factorized structure of the problem",
    ", we conceive a generalization of viterbi s algorithm that exactly achieves degenerate map decoding of quantum convolutional code in linear time . using monte carlo simulations",
    ", we find that the degenerate decoder suppresses more errors than the standard non - degenerate decoder ; the improvement becoming more important at low error rates .",
    "thus , convolutional codes provide an example where degenerate map decoding can be performed efficiently and yield a significant performance gain .",
    "the rest of this article is organized as follows .",
    "the next section introduces basic concepts . in sec .",
    "[ sec : decoding ] , we define the decoding problem for quantum codes , emphasizing on the role of degenerate errors . section [ sec : viterbi ] summarizes viterbi s algorithm for quantum convolutional codes , and explains how it can be modified to take degeneracy into consideration .",
    "lastly , we present numerical result in sec . [",
    "sec : results ] .",
    "our presentation of quantum convolutional codes and their decoding algorithms follows @xcite , we refer the reader to this article for more technical details on these basic concepts .",
    "a quantum state of @xmath24 qubits is specified by a vector @xmath25 in a @xmath26-dimensional vector space @xmath27 .",
    "a quantum code @xmath10 encoding @xmath28 qubits into @xmath24 qubits is a @xmath29-dimensional subspace of @xmath27 .",
    "the stabilizer formalism offers a compact description of such a subspace , making use of the pauli group .",
    "the pauli matrices are defined as follows @xmath30 together with the @xmath31 identity matrix @xmath32 and the imaginary unit @xmath33 , they form a group under multiplication , the pauli group @xmath34 .",
    "the @xmath24-qubit pauli group is the @xmath24-fold tensor product of the single - qubit pauli group @xmath35 .",
    "an important fact about @xmath36 is that all of its elements either commute or anti - commute , i.e. for all @xmath37 , @xmath38 .",
    "using the fact that @xmath39 , we find that @xmath40 is a generating set of @xmath36 , where @xmath41 ( @xmath42 ) stands for the pauli operator @xmath43 ( @xmath14 ) acting on qubit @xmath44 , and is the identity elsewhere , i.e. @xmath45    a stabilizer group @xmath46 is an abelian subgroup of @xmath36 that does not contain the element @xmath47 .",
    "it can be specified by @xmath48 independent stabilizer generators @xmath49 .",
    "the quantum code @xmath10 associated to the stabilizer group @xmath46 is defined by a set of eigenvalue equations @xmath50 note that the condition @xmath51 for all generators @xmath52 of @xmath46 is enough to ensure .",
    "the dimension of the code @xmath10 is @xmath29 with @xmath53 , so we say that the code encodes @xmath28 logical qubits into @xmath24 physical qubits , so has rate @xmath54 . clearly , the stabilizer generators @xmath52 play a role analogous to the linearly independent rows of the parity check matrix of a classical linear code .    the centralizer @xmath55 of @xmath46i.e .",
    "elements of @xmath36 that commute with all elements of @xmath46are called pauli codewords . multiplying a code state @xmath56 by a pauli codeword @xmath57 produces another code state .",
    "this can be verified directly since @xmath58 which shows that @xmath59 is an eigenstate of eigenvalue @xmath60 of all stabilizers @xmath61 , where we have used the commutativity of @xmath62 and @xmath61 .",
    "more generally , all code states can be generated starting from an arbitrary fiducial code state @xmath63 and multiplying it by a logical operator @xmath64 in the algebra generated by the pauli codewords .",
    "the encoding circuit is another method to specify a stabilizer code .",
    "the main advantages of this circuit - based definition is that all commutation constraints discussed above are automatically satisfied , and it is more suited for the definition of quantum convolutional codes .",
    "the clifford group on @xmath24 qubits is the normalizer of the pauli group in @xmath65 . in other words ,",
    "clifford transformations consist of unitary transformation @xmath66 on @xmath24 qubits for which @xmath67 is a pauli operator , for all pauli operators @xmath68 .",
    "any clifford transformation on @xmath24 qubits can be decomposed into a quantum circuit composed of controlled - not gates , hadamard gates @xmath69 , and phase gates @xmath70 .",
    "given an @xmath24-qubit clifford transformation @xmath66 , we can construct a stabilizer code with stabilizer generators @xmath71 and pauli codewords @xmath72 for later use , it is also convenient to define operators that we call pure errors as @xmath73    since conjugation by a unitary matrix preserves the commutation relations , the following commutation relations are a straightforward consequence of definitions eqs .  [ eq",
    ": stab]-[eq : pureerror ] : @xmath74 & = 0 \\label{eq : stab_comm } \\\\   [ s_a,\\overline z_b ] & =   [ s_a,\\overline x_b ] = 0 \\label{eq : log_comm } \\\\   s_at_b & = ( -1)^{\\delta_{ab } } t_bs_a \\label{eq : err_comm}\\end{aligned}\\ ] ] where expresses the fact that @xmath46 is abelian , shows that pauli codewords are in the center of @xmath46 , and will be helpful in formulating the decoding problem . also ,",
    "because the operators @xmath75 generate @xmath36 and because completeness is not affected by a unitary transformation , it follows that @xmath76 generate @xmath36 .",
    "lastly , @xmath66 is called the encoding circuit because any state obtained from the following circuit        where @xmath25 can be an arbitrary @xmath28-qubit state , is a code state , i.e. @xmath77 . in this circuit",
    ", we call the @xmath3 top input qubits the ancillary qubits , while the bottom @xmath28 input qubits are called the data qubits as they carry the information prior to encoding into @xmath10 .      the natural noise models to study using stabilizer codes are pauli noise models . in these models",
    ", the noise alters an encoded state @xmath9 by multiplying it by an element of the pauli group @xmath78 , i.e. @xmath79 . the errors @xmath6 are chosen at random according to some probability @xmath80 that specifies the noise model .",
    "a common assumption is that of an i.i.d .",
    "noise model where @xmath80 is the @xmath24-fold tensor product of a distribution @xmath81 over the single qubit pauli group . , or @xmath82 , or @xmath83x was applied ",
    "has no observable effect , so our description of errors is over equivalent classes of pauli operators defined modulo a phase . ]",
    "the symmetric choice @xmath84 is called the depolarization channel of rate @xmath85 .",
    "quantum convolutional codes were introduced in @xcite , but here we follow essentially the definitions of @xcite , and refer the reader to this article for more technical definitions . an @xmath86-quantum convolutional code is a stabilizer code with stabilizer generators of the form @xmath87 where @xmath88 and @xmath89 is called the constraint length of the code . in other words , there are @xmath3 distinct @xmath90-qubit pauli operators @xmath52 that are translated by integer multiples of @xmath24 to generate the entire set of generators . note that the total number of qubits used in the code is left unspecified in this definition ; the maximum value @xmath91 of @xmath92 determines the length of the convolutional code .",
    "thus , it is implicitly assumed in that the operators are padded to the right with identity matrices so that they all act on @xmath93 qubits .",
    "of course , the @xmath52 should all commute with one another to ensure @xmath94=0 $ ] , and also with their translations by integer multiples of @xmath24 to ensure @xmath95=0 $ ] . for codes with large constraint length @xmath89 , this last commutation condition can lead to a large number of constraints on the @xmath52 that are difficult to fulfill .",
    "but as for stabilizer codes discussed above , there exists an equivalent circuit - based definition of quantum convolutional codes that circumvents this difficulty .    in this circuit - based definition ,",
    "a @xmath96-quantum convolutional code is a stabilizer code whose encoding circuit takes the particular form        which illustrates the case @xmath97 , @xmath98 and @xmath99 .",
    "the encoding circuit is composed of a seed transformation @xmath100 , element of the clifford group , that is applied periodically to non - disjoint sets of qubits .",
    "we refer to a given period of this circuit as a time frame of the code .",
    "the qubits that overlap two consecutive applications of the seed transformation are referred to as memory qubits , and there are in general @xmath101 of them in every frame . in each frame",
    "( except the very first one ) , there are a total of @xmath24 input qubits , @xmath28 of which carry quantum information ( marked  data \" in the circuit ) and @xmath102 are ancillary qubits in the sate @xmath103 .",
    "the rate of the code is therefore @xmath54 .",
    "a quantum convolutional code can contain an arbitrary number @xmath91 of frames . for a given value of @xmath91",
    ", we obtain a code block containing a total of @xmath104 physical qubits and encoding @xmath105 logical qubits . , see @xcite .",
    "]    a generating set for the stabilizer is given by @xmath106 where @xmath66 is the @xmath107-qubit clifford transformation resulting from the entire sequence of seed transformation @xmath100 , and the qubit index @xmath44 varies over all ancillary qubit index , i.e. locations on the encoding circuit marked with qubits in a @xmath103 input state .",
    "the notation used in the definition based on and the definition based on the encoding circuit differ slightly because there is no direct relation between the constraint length @xmath89 and the number of memory qubits @xmath101 .",
    "however , one can easily show that a convolutional code defined by a circuit with @xmath101 memory qubits admits a set of generators of constraint length @xmath108 .",
    "as in the classical setting , the first step in the decoding process is the error syndrome extraction . in quantum mechanics , this is done by measuring the stabilizer generators .",
    "remember that in quantum mechanics , the measurement of an observable  i.e .",
    "an hermitian matrix  gives an outcome equal to the eigenvalue of the operator corresponding to the state of the system . by definition",
    ", all code states have @xmath60 eigenvalues for all stabilizer generators , i.e. @xmath51 . if an error @xmath6 corrupts the state to @xmath109 , the eigenvalue of @xmath52 will remain the same when @xmath6 and @xmath52 commute , and will be changed to @xmath110 when @xmath6 and @xmath52 anti commute . to see this , note that @xmath111 the @xmath112 measurement outcome of @xmath52 gives the @xmath44th syndrome bit @xmath113 , and we denote the collection of @xmath3 syndrome bits @xmath114 .    the goal of the non - degenerate ( nd ) decoder can be stated quite simply : find the most probable error conditioned on the measured syndrome .",
    "if we denote @xmath115 the syndrome that error @xmath6 would produce , non - degenerate map decoding consists of the optimization problem @xmath116 where @xmath80 is given by the noise model , and argmax denotes the argument that achieves the maximum .    to explain the degenerate decoding problem , it is convenient to express pauli errors in a basis tailored to the stabilizer code . as explained in sec .",
    "[ sec : stab ] , the set @xmath117 forms a basis for @xmath36 .",
    "thus , an error @xmath6 has a unique decomposition into a product of logical operators , elements of the stabilizer group , pure errors , and an irrelevant phase factor that we will henceforth ignore .",
    "in other words , we can uniquely decompose any error as @xmath118 where @xmath119 , @xmath120 , and @xmath121 .",
    "we can therefore interpret the noise model @xmath80 as a probability distribution over @xmath62 , @xmath61 , and @xmath122 , simply setting @xmath123    observe that the syndrome @xmath124 is in one - to - one correspondence with the pure error component @xmath122 , namely , an error with syndrome @xmath124 has the pure error component @xmath125 where @xmath126 and @xmath127 .",
    "this can be seen from the commutation relation , which shows that @xmath52 anti - commutes with @xmath6 if and only if @xmath6 contains @xmath128 when decomposed in the basis @xmath129 .",
    "in addition , eqs .",
    "[ eq : stab_comm]-[eq : log_comm ] show that the @xmath61 and @xmath62 components of an error @xmath6 have no effect on its syndrome .",
    "thus , knowledge of the error syndrome is equivalent to knowledge of @xmath122 , so the error probability conditioned on the error syndrome is obtained by bayes rule @xmath130 where the marginal probability is defined as usual @xmath131 .",
    "degenerate errors are those that differ only by their @xmath61 component .",
    "indeed , the errors @xmath6 and @xmath132 for @xmath120 have exactly the same effect on all code states by definition .",
    "thus , only the logical component @xmath133 needs to be identified to correct the error ; the @xmath122 component is known given the syndrome and the @xmath61 component has no effect on the encoded information .",
    "the degenerate map decoding therefore consists of the optimization problem @xmath134 where @xmath135 is the marginal conditional distribution obtained from .",
    "an equivalent way to explain the degenerate decoding problem is to imagine un - encoding the corrupted encoded state @xmath136 .",
    "this produces the state @xmath137 where @xmath138 is the un - encoded version of the logical component @xmath133 of @xmath6 and @xmath139 is the un - encoded version of the stabilizer @xmath61 and pure error @xmath122 components of @xmath6 .",
    "note that the un - encoded version of @xmath61 contains only @xmath43 operators on the ancillary qubits by definition , c.f . .",
    "since @xmath140 , we conclude that the @xmath61 component has no effect on the un - encoded corrupted state , a direct manifestation of degeneracy",
    ". the @xmath122 component on the other hand map to @xmath14 operators under @xmath141 , c.f . .",
    "we conclude that the final state is @xmath142 where @xmath143 is a shorthand for a @xmath3-qubit state with qubit @xmath44 in a state @xmath144 .",
    "the error syndrome can be directly obtained by measuring the ancillary qubits , and the degenerate decoding problem consists in identifying the most likely @xmath62 given @xmath124 .",
    "with convolutional code , it is natural to use a notation that reflects the periodic structure of the encoding circuit .",
    "we use a two - index notation to identify qubits : qubit @xmath145 corresponds to the @xmath44th qubit of the @xmath92th time frame , in other words the @xmath146$]th qubit altogether since there are @xmath24 qubit per time frame .",
    "similarly , the error syndrome @xmath124 naturally breaks into @xmath91 distinct @xmath3-bit syndromes @xmath147 with @xmath148 . following the last paragraph of the previous section , syndrome bit @xmath149",
    "is obtained by measuring the ancillary qubit @xmath145 after having un - encoded the corrupted state , see figure [ fig : conve ] .",
    "similarly , it is natural to also break @xmath62 and @xmath6 into a product of operators on each frame @xmath150 and @xmath151 , see figure [ fig : conve ] . since we assume that the quantum channel is memoryless , the error probability factors as @xmath152 .     into a tensor product of errors",
    "@xmath151 in each @xmath24-qubit frame .",
    "the error produces a syndrome @xmath124 and an un - encoded logical component @xmath62 , that are also broken - up into components on each frame @xmath153 and @xmath150 . ]    the standard , non - degenerate , decoding of quantum convolutional code uses a trellis .",
    "trellis - based decoding of quantum convolutional codes was introduced in @xcite , but here we follow the presentation of @xcite , and refer the reader to this article for more details of the construction . the trellis for an @xmath96-quantum convolutional code of length @xmath91 is a directed multigraph whose vertices can be grouped into @xmath91 sets @xmath154 .",
    "each element of @xmath154 is labeled by a distinct element @xmath155 , so @xmath156 .",
    "given an error syndrome @xmath124 , there is an edge between @xmath157 and @xmath158 if and only if there exists an @xmath159 , @xmath160 , and @xmath161 such that @xmath162 where @xmath163 .",
    "there can in general be different choices of @xmath151 that fulfill this condition , and we label the multiple edges by the associate @xmath151 .",
    "this condition is illustrated by the circuit        which can be understood , reading from right to left , as one segment of the un - encoding circuit which proceeds recursively starting at @xmath164 and making its way to @xmath165 .",
    "the interpretation is a situation where errors in the previous un - encoding steps have resulted in a memory state @xmath166 which , combined with the error segment @xmath167 , produces the right syndrome bits @xmath153 for the time frame @xmath92 , modifies the logical state by the application of @xmath150 in this frame , and sets the memory in a new state @xmath168 .    with this interpretation",
    "we see that paths in the trellis correspond to all the distinct errors @xmath6 with syndrome @xmath124 .",
    "to find the most likely error ( or path ) among them , we associate a probability ( or weight ) to each edge .",
    "the probability associated to the edge linking @xmath168 to @xmath166 labeled @xmath151 is @xmath169 , the probability of the corresponding error , specified by the error model .",
    "the non - degenerate map decoding then consists in finding the path in the trellis with the largest probability , where the probability of a path is equal to the product of the probability of each of its segments .",
    "it is convenient to speak instead of the length of a path , which is equal to the sum of the weight of its segments , the weight of segment @xmath170 labeled @xmath151 being @xmath171 , and we set @xmath172 if there is no edge labeled @xmath151 between @xmath168 and @xmath173 .",
    "then , the decoding problem becomes that of finding the shortest path in the trellis .",
    "viterbi s algorithm solves this problem recursively , starting at @xmath164 and decreasing the value of @xmath92 by 1 at each iteration , by associating a cumulative distance to the vertices of the graph .",
    "the cumulative distance of vertex @xmath173 , @xmath174 , is equal to the length of the shortest path starting at @xmath164 and leading to @xmath173 .",
    "it obeys the recursive equation @xmath175,\\ ] ] so the algorithm keeps only the edges that realize the maximum for each @xmath168 , the other edges are erased .",
    "the initialization of the algorithm is given by @xmath176 where @xmath177 is the error model on the last @xmath101 bits of the circuit .",
    "to explain the termination of the algorithm , we must specified that the first @xmath101 qubits of the quantum circuit ( the memory qubits of frame 0 ) are used as additional ancillary qubits .",
    "thus , they are initialized in state @xmath178 prior to encoding and measured in the @xmath43 basis after the un - encoding , see @xcite for more details .",
    "the output of this measurement reveals the @xmath14 component of @xmath179 , and only the values of @xmath179 with the correct component are kept .",
    "the shortest path is the one connecting to the @xmath179 with the shortest cummulative distance @xmath180 .",
    "the reason why the previous algorithm does not take degeneracy into account is that each path is associate to a distinct physical error . for degenerate decoding ,",
    "errors need to be associated to equivalent classes of states instead , where errors that differ by an element of @xmath46 are joined in the same class . one way to keep track of such classes is to label them by their logical un - encoded component @xmath181 . the degenerate viterbi algorithm will thus use the same trellis structure as above , but instead of labeling an edge that fulfills by the corresponding @xmath151 , it will be labeled by the corresponding un - encoded logical operator segments @xmath159 . as before , the probability associated to an edge will be equal to @xmath169 for the @xmath151 fulfilling the condition .",
    "thus , at this point , the construction of the trellis follows exactly the original prescription of @xcite , but its edges are labeled differently .    for a given syndrome segment @xmath153 , un - encoded logical",
    "segment @xmath150 , and memory states @xmath168 and @xmath173 , there can be multiple distinct @xmath151 that fulfills the condition . call this set of solutions @xmath182 .",
    "thus , the trellis contains multiple edges between some memory states @xmath168 and @xmath173 with the same label @xmath150 .",
    "these multiple edges @xmath182 correspond to degenerate paths , i.e. paths that differ only by an element of the stabilizer group .",
    "therefore , they should be viewed as equivalent paths so we merge them into a single super edge as illustrated in fig .",
    "[ fig : merge ] .",
    "the probability of a super edge is equal to the sum of the probabilities of the merged edges , or in terms of weight : @xmath183 in terms of these weights , the degenerate decoding problem becomes the problem of finding the shortest path in the trellis , for which viterbi s algorithm can be used .    in summary ,",
    "our modification to viterbi s decoding algorithm consists in a pre - processing phase that modifies the trellis my merging edges that correspond to degenerate errors and computing the associated weights .",
    "given this modified trellis , the degenerate decoding problem becomes identical to the non - degenerate decoding problem , and can be solved with viterbi s original algorithm .",
    "to @xmath173 are merged into a unique super edge with the corresponding label .",
    "the probability of a super edge is equal to the sum of the probabilities of the merged edges . ]",
    "we have benchmarked our degenerate viterbi decoder using monte carlo simulations on quantum convolution codes of finite block length @xmath184 with various code parameters @xmath96 , results are presented in fig .",
    "[ fig : results ] .",
    "the codes were generated by choosing the seed transformation @xmath100 at random in the clifford group .",
    "for each set of parameters @xmath96 , we have simulated a few dozens of such randomly generated codes and kept the most interesting results , although our conclusions extend qualitatively to all codes we have simulated .",
    "the codes are terminated by padding , as explained in @xcite .",
    "the monte carlo simulations were realized as follows .",
    "an @xmath107 qubit error @xmath6 is generated randomly according the depolarizing error probability of rate @xmath85 ( c.f .",
    "[ sec : noise ] ) and the corresponding error syndrome @xmath124 is calculated .",
    "the syndrome is fed as input to two distinct algorithms : a degenerate and a non - degenerate decoding algorithm .",
    "the degenerate decoder outputs the most likely logical error component @xmath185 given by . it is declared successful if the output @xmath185 belongs to the equivalence class of the randomly generated error @xmath6 , and failed otherwise .",
    "the procedure is repeated @xmath186 times to accumulate statistics , and the block error rate equals the frequency of its failures .",
    "the number of samples @xmath186 is adjusted such that at least 30 significant events are observed , resulting in a relative error at most @xmath187 on the reported data .",
    "figure [ fig : results ] reports the block error rate of the degenerate decoder as a function of the channel error rate for different convolutional codes .",
    "for different @xmath96-quantum convolutional codes : circles @xmath188 ; squares @xmath189 ; triangles @xmath190 .",
    "since all codes have @xmath191 and the length of the code is @xmath192 , all codes encode 600 logical qubits .",
    "the triangles represent a code of lower rate , so as expected it shows overall better performances .",
    "inset : the ratio of block error rates obtained with the non - degenerate viterbi decoder and the degenerate viterbi decoder .",
    "the degenerate viterbi decoder always yields a lower block error rate , and this advantage increases as the channel error rate decreases.,width=340 ]    a similar procedure is performed in parallel with the non - degenerate viterbi decoder during our monte carlo simulations . given the input syndrome @xmath124 , the non - degenerate decoder outputs the most likely error @xmath193 given by .",
    "it is declared successful if the output @xmath193 belongs to the equivalence class of the randomly generated error @xmath6 , and failed otherwise .",
    "note that the non - degenerate decoder therefore benefit from the existence of degeneracy because its output @xmath193 is not required to exactly match the randomly generated error @xmath6 to be accepted as a successful decoding , as long as they belong to the same equivalence class .",
    "the distinction is that degeneracy is not explicitly taken into account to estimate the error .",
    "to evaluate the impact of degeneracy on the decoder s performance , we compare its block error rate with the one obtained with the non - degenerate viterbi decoder . in the inset of fig .",
    "[ fig : results ] , we show the ratio between the non - degenerate decoder s block error rate to the one of the degenerate decoder .",
    "the fact that all data points are above 1 indicates that the non - degenerate decoder always yields a lower block error rate than the non - degenerate decoder .",
    "we also observe in the inset of fig .",
    "[ fig : results ] that the benefit becomes more prominent at low depolarizing rates .",
    "this effect appears to be independent of the code parameters : the block error rate ratios of all the codes we have simulated show a clear monotonic increase as @xmath85 decreases .",
    "we have observed gains as large as 4.4 db .",
    "degeneracy is a key feature of quantum codes that is at the origin of important distinctions between classical and quantum information theory . to gain from the existence of degeneracy",
    ", it must be taken into account during the decoding process of a code . here",
    ", we have developed a decoding algorithm for quantum convolutional codes that exactly solves the maximum a posteriori decoding problem over equivalent classes of degenerate errors .",
    "the main modification to the standard viterbi algorithm is a pre - processing phase that modifies the trellis .",
    "our monte carlo simulations show that degenerate decoding improves the error suppression of the code , and that this effect becomes more prominent at low error rates .    because convolutional codes are the main ingredient of quantum turbo codes , a natural next step would be to use our degenerate decoder in a concatenated scheme , where its benefit could be further amplified .",
    "the development of a fault - tolerant computing scheme based on these codes is also desirable .",
    "the importance of our decoder may be particularly important in this setting since fault - tolerant quantum computers operate at low error rates , where the effect of degenerate decoding are most prominent .      _",
    "disclaimer _ the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements , either expressed or implied , of iarpa , doi / nbc , or the u.s . government ."
  ],
  "abstract_text": [
    "<S> we present a decoding algorithm for quantum convolutional codes that finds the class of degenerate errors with the largest probability conditioned on a given error syndrome . </S>",
    "<S> the algorithm runs in time linear with the number of qubits . </S>",
    "<S> previous decoding algorithms for quantum convolutional codes optimized the probability over individual errors instead of classes of degenerate errors . </S>",
    "<S> using monte carlo simulations , we show that this modification to the decoding algorithm results in a significantly lower block error rate .    </S>",
    "<S> convolutional - codes , quantum error correction , viterbi algorithm </S>"
  ]
}