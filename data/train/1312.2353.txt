{
  "article_text": [
    "integrity checking has been a perennial topic in almost all database conferences , journals and research labs .",
    "very large quantities of research activities and publications testify to the importance of the issue .",
    "the motivation which has stimulated these investigations is that integrity checking is practically unfeasible for significant amounts of stored data without a dedicated approach to optimize the process .",
    "progress has been made with extensions of basic approaches to deductive , object - relational , xml - based , distributed and other kinds of advanced database technology , as surveyed in @xcite .",
    "however , what has not changed much are the fundamental ideas that are already present in the seminal paper @xcite .",
    "the basic idea is that , in most cases , a simplified form of the set of integrity constraints imposed on the database can be obtained from a given update ( or just an update schema ) and the current state of the database ( or just the database schema ) .",
    "thus , integrity , which is supposed to be an invariant of all possible database states , is checked upon each update request , which in turn becomes effective if the check yields that integrity is not violated . here ,",
    "`` simplified '' essentially means more efficiently evaluated at update time .",
    "of course , efficiency is not unequivocally measurable .",
    "however , the number of stored facts to be retrieved for constraint evaluation is a good rule of thumb .",
    "another such rule is the number of literals in the simplified form . also , the minimization ( reduction or avoidance ) of repair costs after having detected integrity violation is a factor to be considered when assessing the efficiency of integrity checking . to establish the new state",
    "is usually considered less costly than to undo it , but for concurrent transactions , more so in distributed and even more so in replicated databases , establishing the new state is a sizable and non - negligible cost factor ( think of the concurrency control , management and communication rounds needed for distribution and different replication strategies ) , while roll - backs are less of a problem since they can be taken care of and optimized by the dbms , making use of its transaction logs .",
    "integrity checking methods may differ in some of the assumptions .",
    "for instance , in @xcite and in most of the publications on the same subject that came after it , a categorical premise for the correctness of the simplification approach has been that the constraints to be checked for a given update @xmath0 are supposed to be satisfied in the  old \" state , i.e. , the database state given when @xmath0 is requested .",
    "this assumption has been relaxed in  @xcite , thereby introducing the notion of inconsistency - tolerant integrity checking .",
    "other different assumptions may regard the class of integrity constraints and updates that are supported by the methods , as surveyed in  @xcite .    unlike previous surveys , in this paper we study the main differences between approaches that require to check integrity after all updates have been applied and those that check integrity before the updates .",
    "we shall see that these checks are generally non - interchangeable , unless the updates are of a specific kind .",
    "in this section , we recapitulate , classify and discuss the main characteristics of the simplification approach to integrity checking .",
    "we fix basic definitions and terminology , and thus the framework into which our formalizations in the remainder are cast . in section [ subsec : simplifications ] we introduce abstract notions of various classes of simplifications and discuss them in section [ subsec : pre - tests - vs - post - tests ] .    throughout , we refer to the relational framework of deductive databases , i.e. , relational databases with possibly recursive view definitions described in clause form @xcite .",
    "thus , a _ database _ consists of a set of _ facts _ and a set of _ rules _ ,",
    "i.e. , _ tuples _ and _ views _ , in the terminology of the relational model .    an _ integrity constraint _ expresses a semantic invariant , i.e. , a condition supposed to hold in each state of the database . in general , it can be expressed by any closed first - order logic formula in the language of the database on which it is imposed .",
    "two kinds of normal form representations of integrity constraints which both incur no loss of generality are prominent in the literature : prenex normal form and denial form .",
    "the former , as defined and used , e.g. , in @xcite , has all quantifiers moved leftmost and all negation symbols moved innermost , by equivalent rewritings of the original formula .",
    "the latter , as defined and used , e.g. , in @xcite , has the form of datalog clauses with empty head , expressing that , if their condition is satisfied , then integrity is violated , and may need dedicated view definitions to define these conditions by recurring on database facts .",
    "an _ integrity theory _ is a finite set of integrity constraints , to be thought of as being imposed on some database .    for simplicity ,",
    "we limit ourselves to databases that have a unique standard model and no  unknown \" facts ( i.e. , each fact is either true or false in the model ) , e.g. , stratified databases , and assume that database semantics is defined by this model .    for a closed formula @xmath1",
    ", we write @xmath2 ( resp . , @xmath3 ) to indicate that @xmath1 evaluates to @xmath4 ( resp . , @xmath5 ) in @xmath6 s standard model . for a set of formulas",
    "@xmath7 , we write @xmath8 ( resp . , @xmath9 ) to indicate that for every ( resp . , some ) formula @xmath10 we have @xmath2 ( resp . , @xmath3 ) . if @xmath1 is an integrity constraint and @xmath7 an integrity theory , it is usual to also say that @xmath6 _ satisfies _ ( resp .",
    ", _ violates _ ) @xmath1 and @xmath7 , respectively .",
    "an equivalent terminology is defined as follows .",
    "a database @xmath6 is _ consistent _ with an integrity theory @xmath7 iff @xmath11 .",
    "informally , we have already spoken of database states .",
    "more formally , database states are determined by atomically executed updates .",
    "an _ update _",
    "@xmath0 is a mapping @xmath12 , where @xmath13 is the space of databases as determined by a fixed , sufficiently rich language which need not be extended by any update . for simplicity",
    ", we only consider updates that may involve facts and rules in this paper , but no integrity constraints , which are thought of as immutable . for convenience , for any database @xmath6 ,",
    "let @xmath14 denote the new database obtained by applying update @xmath0 on @xmath6 .",
    "traditionally , the integrity checking problem asks , given a set of integrity constraints @xmath7 , a database @xmath6 consistent with @xmath7 , and an update @xmath0 , whether @xmath15 holds , i.e. , whether the new database is consistent with ( i.e. , satisfies ) the integrity constraints .",
    "however , evaluating @xmath7 in @xmath14 may be prohibitively expensive .",
    "so , a reformulation of the problem is called for , trying to take advantage of the incrementality of updates .",
    "traditionally , all such reformulations have been made under the assumption that the old state is consistent .",
    "we will discuss two kinds of such reformulations that have commonly been dealt with in the literature .",
    "both determine an alternative integrity theory @xmath16 ( which by itself is later called a simplification ) , the evaluation of which is supposed to be simpler than to evaluate @xmath7 , while yielding equivalent results .",
    "the first kind of such @xmath16 is determined to be evaluated in the new state .",
    "[ def : post - test ] let @xmath7 be an integrity theory and @xmath0 an update .",
    "an integrity theory @xmath16 is a _",
    "post - test _ of @xmath7 for @xmath0 whenever @xmath17 for every database @xmath6 consistent with @xmath7 .    clearly , @xmath7 itself is a post - test of @xmath7 for any update .",
    "as indicated , one is interested in producing a post - test that is actually `` simpler '' to evaluate than the original integrity constraints .",
    "this is traditionally achieved by exploiting the fact that the old state @xmath6 is consistent with @xmath7 , thus avoiding redundant checks of cases that are already known to satisfy integrity .",
    "note that the process of integrity checking involving a post - test consists in : executing the update , checking the post - test and , if it fails to hold , correcting the database by performing a repair action , i.e. , a rollback and optionally a modification of the update which wo nt violate integrity . well - known post - test - based approaches are described in @xcite .",
    "the second kind of approach to deal with integrity checking incrementally is to determine an integrity theory @xmath18 to be evaluated in the old state , i.e. , to predict without actually executing the update whether the new , updated state will be consistent with the integrity constraints .",
    "[ def : pre - test ] let @xmath7 be an integrity theory and @xmath0 an update .",
    "an integrity theory @xmath18 is a _ pre - test _ of @xmath7 for @xmath0 whenever @xmath19 for every database @xmath6 consistent with @xmath7 .    here ,",
    "not only the consistency of the old state @xmath6 with @xmath7 is exploited , but also that inconsistent states can be prevented without executing the update , and , thus , without ever having to undo a violated new state .",
    "the integrity checking process involving a pre - test is therefore : check whether the pre - test holds and , if it does , execute the update .",
    "examples of pre - test - based approaches are @xcite .",
    "note that , depending on the requirements of availability and consistency of a given application , integrity checking with pre - tests is possibly better suited for concurrent transaction processing , particularly in distributed databases .    in the remainder",
    ", we refer to both post- and pre - tests as _ simplifications _ of the original integrity theory .",
    "it is tacitly assumed that given simplifications are , at least in significant classes of cases , indeed simpler to evaluate than the original constraints .",
    "a characterization of simplicity beyond what is mentioned in the introduction , e.g. , by formal cost models , is out of the scope of this paper ; cf .",
    "@xcite for a discussion .",
    "now , whatever the definition of simplicity , we can not directly compare the evaluation cost of a post - test with that of a pre - test since they refer to two different ( viz .",
    "old and new ) states .",
    "therefore , it is desirable to have kindred reference pre- and post - tests for benchmarking given simplifications .",
    "plain tests , as defined below , i.e. , simplifications that do not exploit the fact that the old state satisfies integrity , may serve as such reference tests .",
    "[ def : plain - test ] let @xmath7 be an integrity theory and @xmath0 an update .",
    "\\a ) an integrity theory @xmath20 is a _",
    "plain pre - test _ of @xmath7 for @xmath0 , denoted by @xmath21 , if the following holds : @xmath22 for every database @xmath6 .",
    "\\b ) an integrity theory @xmath23 is a _ plain post - test _ of @xmath7 for @xmath0 , denoted by @xmath24 , if the following holds : @xmath25 for every database @xmath6 .",
    "clearly , @xmath7 is a plain post - test of itself for any update .",
    "note that each plain test is also a simplification . for any pre - test ( resp .",
    ", post - test ) , it is therefore desirable that it be at least as simple to evaluate as the corresponding plain test .",
    "it is straightforward to see that , for fixed @xmath7 and @xmath0 , all plain pre - tests of @xmath7 for @xmath0 are logically equivalent .",
    "[ pro : all - plain - pre - tests - equivalent ] let @xmath7 be an integrity theory and @xmath0 an update .",
    "then , for any two plain pre - tests @xmath26 and @xmath27 of @xmath7 for @xmath0 , we have @xmath28 .    by applying definition [ def : plain - test ] to @xmath26 and @xmath27 ,",
    "one gets by transitivity that @xmath29 for every @xmath6 , i.e. , @xmath28 .",
    "conversely , not all plain post - tests are logically equivalent . as a counterexample ,",
    "take , e.g. , @xmath30 and let @xmath0 be the insertion of @xmath31 . then @xmath32 is a post - test of @xmath7 for @xmath0 but @xmath33 .",
    "we conclude this section with an example of simplification of integrity constraints .",
    "[ ex : conflict - of - interests ] consider a database with the relations @xmath34 ( submission @xmath35 assigned to reviewer @xmath36 ) , @xmath37 ( submission @xmath35 authored by @xmath38 ) and @xmath39 ( publication @xmath40 authored by @xmath38 ) .",
    "assume a policy establishing that no one can review a paper of his / her ( former ) coauthors .",
    "this is expressed by : @xmath41 let @xmath0 be the an update that inserts the facts @xmath42 and @xmath43 into the database , where @xmath44 , @xmath45 , @xmath46 are some constants .",
    "a simplification of @xmath7 for @xmath0 ( equivalent to what nicolas method would output ) is as follows : @xmath47 the simplified conditions given by @xmath18 can be read as follows :    * @xmath45 did not submit @xmath46 * @xmath44 does not review @xmath46 * @xmath45 is not coauthor of @xmath44 * @xmath45 is not coauthor of an author of @xmath46 * @xmath46 is not reviewed by a coauthor of @xmath44    these checks are much easier to execute than @xmath7 , as they greatly reduce the space of tuples to be considered by virtue of the instantiation of variables with constants .",
    "in this section we compare pre - tests and post - tests and discuss their interchangeability . note that we do this without referring to any specific simplification method or update language .",
    "first , we show that , in general , a pre - test can not be used as a post - test , nor vice versa .",
    "[ ex : pre - and - post - test - differ - in - general ] consider the integrity theory @xmath48 and an update @xmath0 that exchanges the contents of @xmath49 and @xmath50 . then @xmath51 is a pre - test but clearly not a correct post - test .",
    "consider , e.g. , a database @xmath52 ; we have @xmath53 , i.e. , it does not hold that @xmath54 , although @xmath6 is consistent with @xmath7 .",
    "similarly , @xmath55 is a post - test , but not a pre - test , of @xmath7 for @xmath0 .",
    "this result is not surprising , since we allow for updates representing any kind of transformation of the database , such as swapping the contents of two relations .",
    "we now introduce a class of updates that excludes an update such as @xmath0 of example [ ex : pre - and - post - test - differ - in - general ] .",
    "[ def : idempotent - update ] an update @xmath0 is _ idempotent _ if @xmath14 = @xmath56 for any database @xmath6 .",
    "idempotent updates capture additions , deletions and changes of specific tuples , which are certainly among the most frequent kinds of updates . for idempotent updates",
    ", we can prove that a plain pre - test is also always a valid plain post - test .",
    "[ pro : plain - pre - test = post - test - idempotent ] let @xmath7 be an integrity theory and @xmath0 an idempotent update",
    ". then @xmath57 for any database @xmath6 , i.e. , @xmath58 is a plain post - test of @xmath7 for @xmath0 .    since @xmath0 is idempotent , i.e. , @xmath59 for any @xmath6 , we have    * @xmath60 for any @xmath6 .    since @xmath21 is a plain pre - test of @xmath7 wrt .",
    "@xmath0 , we have    * @xmath61 for any @xmath14 ( and thus for any @xmath6 ) .    by transitivity between ( 1 ) and ( 2 )",
    "we obtain the thesis .    more surprisingly , however , the converse does not hold , i.e. , there are plain post - tests that are not plain pre - tests . in general , even for idempotent updates , there are pre - tests that are not post - tests and post - tests that are not pre - tests .",
    "[ pro : pre - differ - post - for - idempotent ] let @xmath7 be an integrity theory and @xmath0 an idempotent update",
    ". then    1 .",
    "there is a pre - test @xmath18 of @xmath7 for @xmath0 such that it does not hold that @xmath62 for any database @xmath6 consistent with @xmath7 , i.e. , @xmath18 is not a post - test of @xmath7 for @xmath0 .",
    "2 .   there is a plain post - test @xmath16 of @xmath7 for @xmath0 such that it does not hold that @xmath63 for any database @xmath6 consistent with @xmath7 , i.e. , @xmath16 is not a pre - test of @xmath7 for @xmath0 .",
    "\\(1 ) let @xmath6 be a state consistent with @xmath7 .",
    "we have : @xmath64 so , the only possibility is a situation where @xmath65 , @xmath66 , and @xmath67 , which happens , e.g. , with @xmath68 , @xmath69@xmath70 , @xmath71 and @xmath0 an update such that @xmath72 . to conclude the proof ,",
    "we show that the chosen @xmath18 is a pre - test . indeed , for any @xmath6 such that @xmath11 , then @xmath65 , and @xmath67 .",
    "\\(2 ) the same @xmath6 , @xmath0 and @xmath7 as in the previous point can also be used for the second case by considering the plain post - test @xmath73 .",
    "we have @xmath11 , @xmath67 , @xmath74 and @xmath75 .",
    "another interesting aspect regarding pre - tests and post - tests is whether their evaluation is at all affected by the update .",
    "proposition [ pro : plain - pre - test = post - test - idempotent ] immediately implies that the evaluation of a plain pre - test is not affected by the update , as stated in the following corollary .",
    "[ cor : plain - pre - test - resource - set - update - disjoint ] let @xmath7 be an integrity theory and @xmath0 an idempotent update .",
    "then @xmath76 for any @xmath6 .",
    "by definition of @xmath21 , we have    * @xmath77 for any @xmath6 ,    and , by transitivity with the claim of proposition [ pro : plain - pre - test = post - test - idempotent ] , we have the thesis",
    ".    however , this does not hold in general for pre - tests or ( plain ) post - tests , as demonstrated in the example of the proof of proposition [ pro : pre - differ - post - for - idempotent ] .",
    "the following table summarizes the results presented in this section .",
    "we indicate with pre@xmath78 ( resp . , post@xmath78 ) the set of all pre - tests ( resp . , post - tests ) of integrity theory @xmath7 for @xmath0 , and use a @xmath79 subscript to indicate the set of all plain pre - tests ( resp .",
    ", post - tests ) of @xmath7 for @xmath0 .    [ cols=\"<,^,^\",options=\"header \" , ]",
    "simplification of integrity constraints has been recognized by a large body of research as a powerful technique for optimization of integrity checking . several approaches to simplification",
    "require the update transaction to be performed _ before _",
    "the resulting state is checked for consistency with a post - test  @xcite . as opposed to that , to pre - test the feasibility of an update with respect to an integrity theory",
    "allows for avoiding both the execution of the update and , particularly , the restoration of the database state before the update , which may be very costly .",
    "pre - test - based methods are , e.g. , @xcite , including a few industrial attempts , e.g. , @xcite .",
    "other methods provide simplifications that may require the availability of both the old and the new state , assuming that the database keeps track of the old state before committing an update , @xcite .    in @xcite , an adaptation of subsumption checking ( called _ partial subsumption _ ) is used to generate simplification as the `` difference '' ( called _ residual _ ) between an integrity constraint and a clause representing an update .",
    "qian s method  @xcite generates pre - tests for integrity checking based on the observation that a simplified integrity constraint can be regarded as a weakest precondition for having a consistent updated state , in the same sense as in hoare s logic  @xcite for imperative languages , and by assuming consistency of the database before the update .",
    "simplification of integrity constraints for update patterns resembles the notion of program _ specialization _ used in partial evaluation , which is the process of creating a specialized version of a given program ( in this case , a general integrity checker ) with respect to known input data ( here , the update ) , as investigated in @xcite .",
    "more generally , integrity checking can be seen as a special case of materialized view maintenance : integrity constraints are defined as views that must always remain empty for the database to be consistent  @xcite .",
    "simplification can also be obtained by resorting to decision procedures for query containment  @xcite , as shown in @xcite .",
    "we intentionally did not do so before , but at this point is seems worth mentioning that several simplification methods accept instantiable or parameterizable _ patterns _ of updates instead of specific updates , e.g.  @xcite .",
    "thus , given such a pattern at schema specification time , it is possible to compile a simplification of the integrity theory for all updates matching that pattern .",
    "for instance , if constants @xmath44 , @xmath45 and @xmath46 in the update of example [ ex : conflict - of - interests ] were specified as simple placeholders for constants ( called _ dummy constants _ in @xcite and _ parameters _ in @xcite ) , and thus not assumed to be necessarily different , a pre - test - based simplification would also include an integrity constraint that checks that @xmath80 .    logic programming - based approaches such as @xcite do not take into account irrelevant clauses for refuting denial constraints , even if they would take part in an unnoticed case of inconsistency that has not been caused by the checked update but by some earlier event .",
    "moreover , such approaches do not exhibit any explosive behavior as predicted classical logic in the presence of inconsistency .",
    "in other words , query evaluation procedures based on sl - resolution can fairly well be called inconsistency - tolerant or  paraconsistent \" in a procedural sense , as done , e.g. , in @xcite . the declarative inconsistency tolerance of simplifications for improving integrity checking has been studied in several works  @xcite .",
    "the related problem of restoring integrity of a database once inconsistencies are discovered is tackled by calculating a _ repair _ , i.e. , a consistent database that is as close as possible to the original , inconsistent database . since the seminal contribution @xcite",
    ", many authors have studied the problem of providing consistent answers to queries posed to an inconsistent database .",
    "these techniques certainly add to inconsistency tolerance in databases , but can not be directly used to detect inconsistencies for integrity checking purposes ( i.e. , by posing integrity constraints as queries ) . along the same lines ,",
    "active rules have been considered as a means to restore a consistent database @xcite .",
    "last , we mention work on incomplete databases which also considers integrity constraints that are not satisfied in a given database state as something to be dealt with constructively , instead of banning it from consideration , as most integrity checking methods do @xcite .",
    "however , that work is not interested in integrity checking simplifications that could be used in such databases .",
    "rather , it is dealing with the issue of satisfiability and its computational complexity , as related to an open world assumption by which the space of possible  closed worlds \" ( i.e. database states without missing information ) that would satisfy integrity are studied .",
    "the theme of this paper is to simplify the checking of integrity satisfaction in the presence of inconsistency , not to ask for the satisfiability of integrity constraints in the absence of complete information .",
    "( basic similarities and differences of satisfaction and satisfiability of integrity are addressed in @xcite . )",
    "relevant new directions of research regard all those areas where integrity constraints are used to characterize useful scenarios in which query answering plays an important role . among these , we mention _ i ) _ _ access patterns _ , which are constraints indicating which attributes of a relation schema are used as input and which ones are used as output  @xcite , _ ii ) _",
    "top-@xmath81 queries , where the constraints specify a limit on the number of results that the query should return , including constraints on proximity or diversity  @xcite , _ iii ) _ _ taxonomies _ and context information , which may be used to pose constraint on the granularity of the data and to reason about it  @xcite .",
    "we have discussed and compared the two main abstract families of methods that can be used to incrementally check integrity constraints : pre - tests and post - tests .",
    "these are simplifications to be checked before or , respectively , after the update is executed ( while update commitment is supposed to occur only after a successful check ) . in order to not only talk about some",
    "selected , specific methods , albeit well - known ones , we have characterized declarative and procedural aspects of simplification - based integrity checking in a manner which is largely independent of concrete methods .",
    "unsurprisingly , pre - tests and post - tests are not interchangeable , not only in terms of the convenience of executing the ones or the others in practical situations ( pre - tests may actually be preferred in case of updates to be rejected ) , but also of their semantic properties .",
    "somewhat surprisingly , however , their applicability is mostly asymmetric , even for the simple case of idempotent updates ."
  ],
  "abstract_text": [
    "<S> integrity checking is a crucial issue , as databases change their instance all the time and therefore need to be checked continuously and rapidly . </S>",
    "<S> decades of research have produced a plethora of methods for checking integrity constraints of a database in an incremental manner . </S>",
    "<S> however , not much has been said about _ when _ to check integrity . in this paper , we study the differences and similarities between checking integrity before an update ( a.k.a . </S>",
    "<S> pre - test ) or after ( a.k.a . </S>",
    "<S> post - test ) in order to assess the respective convenience and properties . </S>"
  ]
}