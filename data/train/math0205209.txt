{
  "article_text": [
    "in 1998 a proof of the kepler conjecture was completed @xcite . by any account , that solution is complex ( 300 pages of text , 3 gb stored data on the computer , computer calculations taking months , 40k lines of computer code , and so forth ) .",
    "the thesis underlying this article is that the 1998 proof is complex because it is highly under - automated . throughout that proof ,",
    "manual procedures are used where automated ones would have been better suited .",
    "ultimately , a properly automated proof of the kepler conjecture might be short and elegant .",
    "the hope is that the kepler conjecture might eventually become an instance of a general family of optimization problems for which general optimization techniques exist . just as today",
    "linear programming problems of a moderate size can be solved without fanfare , we might hope that problems of a moderate size in this family might be routinely solved by general algorithms .",
    "the proof of the kepler conjecture would then consist of demonstrating that the kepler conjecture can be structured as a problem in this family , and then invoking the general algorithm to solve the problem .    as a step toward that objective",
    ", this article frames the primary algorithms of that proof in sufficient generality that they may be applied to much larger families of problems .",
    "the algorithms are arranged into four sections : _ quantifier elimination , linear assembly problems , automated inequality proving , plane graph generation_.    we do not claim any originality in the algorithms .",
    "in fact , the purpose is just the contrary : to exhibit the proof of the kepler conjecture insofar as possible as an instance of standard optimization techniques . to keep things as general as possible",
    ", the algorithms we present here will make no mention of the particulars of the kepler conjecture .",
    "a final section lists parts of the 1998 proof that can be structured according to these general algorithms .",
    "we might try to structure the kepler conjecture as a statement in the elementary theory of the real numbers .",
    "tarski proved the decidability of this theory , through quantifier elimination .",
    "g. collins and others have developed and implemented concrete algorithms to perform quantifier elimination @xcite .",
    "the kepler conjecture , as formulated in @xcite , is not a statement in this theory , because the transcendental arctangent function enters into the statement .",
    "however , it seems that the arctangent is not essential to the formulation of the kepler conjecture , and that it enters only because no attempt was made to do without it .",
    "for example , it is plausible that it can be replaced with a close rational approximation , without doing violence to the proof .",
    "in fact , the computer calculations in that proof are already based on rational approximations with explicit error bounds , and on its rational derivative @xmath0 .    assuming this can be done",
    ", quantifier elimination gives a procedure to solve the kepler conjecture .",
    "unfortunately , these algorithms are prohibitively slow ( exponential , or doubly exponential in the number of variables ) .",
    "section  [ linear ] of this article proposes a different family of optimization problems for which algorithmic performance is satisfactory .",
    "these are called linear assembly problems .",
    "although quantifier elimination is too slow to be of practical value as a 1-step solution to the kepler conjecture , it can be of great value in proving intermediate results .",
    "recent algorithms are able to solve problems nearly at the level of difficulty of intermediate results in the kepler conjecture @xcite , @xcite .    instances of the following families of problems arise as intermediate steps in the kepler conjecture .",
    "each instance of the following families must provide an explicit set of parameters @xmath1 ( or @xmath2 , @xmath3 ) , and the problem becomes to show that configurations of points in @xmath4 with the given parameters do not exist . in theory ,",
    "the problems are all amenable to solution by quantifier elimination .    [ first ]",
    "let @xmath5 be a simplex whose edges all have length at most given parameter values @xmath6 .",
    "show that there is no point in the interior of the simplex with distance at least @xmath7 from every vertex .",
    "show that there does not exist a triangle of circumradius at most @xmath8 , and a segment of length at most @xmath9 such that the segment passes through the interior of the triangle and such that each endpoint of the segment has distance at least @xmath10 from each vertex of the triangle .",
    "[ pr : third ] show that there does not exist a configuration of @xmath11 points @xmath12 with given minimum @xmath13 and maximum @xmath14 distances between each pair @xmath15 of points .",
    "the line through @xmath16 must link the triangle with vertices @xmath17 .",
    "[ six ] show that there does not exist a configuration of @xmath18 points @xmath19 , @xmath20 , @xmath21 , with given minimum and maximum distances between each pair @xmath15 of points .",
    "the line @xmath16 must link the skew quadrilateral with vertices @xmath22 ( ordered according to subscripts ) .    [",
    "seven ] show that there does not exist a configuration of @xmath23 points @xmath19 , @xmath20 , @xmath24 , @xmath25 with given minimum @xmath13 and maximum @xmath14 distances between each pair @xmath15 of points . for @xmath26",
    ", the line @xmath27 must link the skew quadrilateral with vertices @xmath22 ( ordered according to subscripts ) .",
    "although we hope that one day these problems will all be amenable to direct solution by quantifier elimination , in practice , we did not try to apply quantifier elimination directly without preprocessing them .",
    "the idea of preprocessing is that if a configuration exists , then the points can be moved in such a way to make various upper and lower bound constraints on distances bind . with a large number of binding constraints ,",
    "the dimension of the configuration space becomes smaller and the problem easier to solve . in some cases ,",
    "preprocessing reduces the configuration space to a single configuration , so that the existence of the configuration can be tested by choosing coordinates and calculating whether all the metric constraints are satisfied .",
    "these five families of quantifier elimination problems have a similar feel to them .",
    "let us give a preprocessing algorithm in general enough terms that it applies uniformly to all five problem families .",
    "the primary preprocessing of the configurations is a deformation that we call _",
    "pivoting_. fix any three of the points @xmath28 , @xmath29 , and @xmath21 of the configuration .",
    "we call a _ pivot through axis _ @xmath30 the continuous motion of @xmath21 in the perpendicular bisecting plane @xmath31 of @xmath30 at constant distance from @xmath28 and @xmath29 .",
    "thus , the pivot moves @xmath21 in a circular path in the plane @xmath31 .",
    "usually , the plane @xmath32 through the three points is chosen to have the property that the entire configuration lies in a half - space through @xmath33 . if @xmath21 moves away from the half - space containing @xmath33 , the distances from @xmath21 to the other points of the configuration increase or remain the same . if @xmath21 moves into the half - space , the distances decrease or remain the same .",
    "more generally , we allow the plane @xmath33 to separate the points of the configuration into two groups , such that the lower distance bounds from @xmath21 to the first group do not bind , and such that the upper distance bounds from @xmath21 to the second group do not bind .    to apply pivots , we must prescribe their directions , whether into the half - space or away from it . to do this",
    ", we give a _ model _",
    ", which is a configuration that exists , of the form indicated in the problem family , but which is not required to satisfy the various constraints .",
    "various edges in the model are marked with a strut ( indicating a lower bound ) or a cable ( indicating an upper bound ) .",
    "if the model has a cable , then preprocessing pivots are applied to increase the corresponding distance in the configuration space , until the given upper bound is reached . where the model has a strut , pivots are applied so as to decrease distances to the lower bound .",
    "( bob connelly has pointed out that some of these problems can be viewed as tensegrity problems , but we do not see how to treat them all as tensegrities , so we do not pursue this point of view here .",
    "globally rigid tensegrities are analogous to our models .",
    "however , our models are not claimed to be rigid . )",
    "[ example : simplex ] in problem  [ first ] , let the upper bounds on the edges of the simplex be @xmath34 , and let @xmath35 .",
    "we take the model to be a regular tetrahedron with edges marked as cables .",
    "mark the edges from the circumcenter to the vertices as struts .",
    "we apply pivots to the simplex to increase its edges to @xmath34 .",
    "move the interior point by a sequence of pivots so that it has distance exactly @xmath36 to three of the four vertices of the simplex .",
    "after these pivots are completed , the configuration is uniquely determined , and a calculation with explicit coordinates shows that the configuration does not exist , because the distance from the interior point to the fourth vertex of the simplex is too small .    in these problems , when we pivot in the correct direction , the distance constraints between points take care of themselves .",
    "however , some of the problems impose additional constraints . in problem",
    "[ first ] , the point is constrained to lie in the simplex . in the other problems ,",
    "lines are required to be linked with various space polygons .",
    "a separate verification is required to see that pivots do not violate these additional constraints . _ these separate verifications are again quantifier elimination problems , of a smaller magnitude than the original problem . _    for example , in problem  [ first ] , we verify that the point can not be an interior point of a face of the simplex .",
    "this insures that the point does not escape from the interior of the simplex during the sequence of pivots .",
    "the argument that there does not exist a point in a face , under the given metric constraints , is similar to example  [ example : simplex ] , but all the arguments are reduced to two dimensions , instead of three .",
    "the preprocessing in most other cases is similar to example  [ example : simplex ] , and can be reconstructed without difficulty from the models .",
    "the two exceptions are problem  [ six ] and problem  [ seven ] , which require substantial preprocessing and a lemma to insure that the pivots can be carried out .",
    "( i would much prefer to have arguments based on a pure quantifier elimination algorithm and bypass this lemma entirely , but the current quantifier elimination algorithms do not seem up to the task . )",
    "fix constants @xmath37 , @xmath38 , @xmath39 , @xmath40 , and @xmath41 subject to the constraints @xmath42 ,              \\quad \\epsilon\\ge2 ,              \\quad h_i\\in[2,\\sqrt8 ] ,              \\quad\\ell\\in[2,\\sqrt8].\\ ] ] pick the following parameters in example  [ seven ] @xmath43 and let the other values of @xmath3 be @xmath44 .",
    "if a configuration of @xmath23 points exists with these parameters , then a configuration also exists with these parameters and the additional constraints that @xmath45 furthermore , the same lemma and conclusion holds in the context of the 6-point configuration of example  [ six ] , if we take @xmath46 and @xmath47 .",
    "this is lemma 4.3 of @xcite .",
    "some of the constants have been relaxed in a way that affects the proof in a very minor way .",
    "( two modifications must be made to the proof .",
    "the assertion that the circumradius of a triangle of sides @xmath48 is less than @xmath49 of the original must be replaced with the assertion that there exists an @xmath50 such that the circumradius of the triangle of sides @xmath51 is less than @xmath49 . also , an instance of problem  [ first ] is needed , with @xmath35 and the length - bounds of the sides of the simplex @xmath52 , @xmath52 , @xmath34 at one vertex , and lengths at most @xmath34 at the edges opposite the edges of length at most @xmath52 . )",
    "in this section we define a class of nonlinear optimization problems that we call _ linear assembly problems_.    assume given a topological space @xmath53 , and a finite collection of topological spaces , called _ local domains_. for each local domain @xmath54 there is a map @xmath55",
    ". there are functions @xmath56 , @xmath57 ,",
    "each defined on some local domain @xmath58 , and we let @xmath59 denote the composite @xmath60 .    on each local domain @xmath54 , the functions @xmath56 are related by a finite set of nonlinear relations @xmath61    we use vector notation @xmath62 , with constant vectors @xmath63 , @xmath64 , and matrix @xmath65 given .    the problem is to maximize @xmath66 subject to the constraints @xmath67 and to the nonlinear relations  [ phi ] . a problem of this form",
    "is called a linear assembly problem .",
    "( intuitively , there are a number of nonlinear objects @xmath54 , that form the pieces of a jigsaw puzzle that fit together according to the linear conditions  [ ax ] . )    assume a single local domain @xmath54 , and let @xmath68 be the identity map .",
    "the function @xmath69 is nonlinear .",
    "the problem is to maximize @xmath70 over @xmath54 subject to the nonlinear relations @xmath71 .",
    "this is a general constrained nonlinear optimization problem .",
    "assume that each @xmath56 has a distinct local domain @xmath72 .",
    "let @xmath73 , let @xmath74 be the projection onto the @xmath75th coordinate , and let @xmath59 be the @xmath75th coordinate function on @xmath76 .",
    "assume that @xmath71 is empty for each @xmath54 .",
    "the problem becomes the general linear programming problem @xmath77 such that @xmath78 .",
    "these two examples give the nonlinear and linear extremes in linear assembly problems .",
    "the more interesting cases are the mixed cases which combine nonlinear and linear programming .",
    "example  [ pr : third ] gives one such case .",
    "( 2d voronoi cell minimization ) .",
    "take a packing of disks of radius @xmath79 in the plane .",
    "let @xmath80 be the set of centers of the disks .",
    "assume that the origin @xmath81 is one of the centers .",
    "the truncated voronoi cell at @xmath19 is the set of all @xmath82 such that @xmath83 , and @xmath84 is closer to the origin than to any other center in @xmath80 .",
    "we assume @xmath85 .    only the centers of distance at most @xmath86 affect the shape and area of the truncated voronoi cell . for each @xmath87 , we have a topological space of all truncated voronoi cells with @xmath88 nonzero disk centers @xmath89 at distance at most @xmath86 .",
    "fix @xmath88 , and let @xmath53 be the topological space .",
    "let @xmath90 , @xmath91 , be the sectors lying between consecutive segments @xmath92 .",
    "each sector is characterized by its angle @xmath93 and the lengths @xmath94 and @xmath95 of the two segments @xmath92 , @xmath96 between which the sector lies .",
    "the part @xmath65 in @xmath54 of the area of the truncated voronoi cell is a function of the variables @xmath93 , @xmath94 , @xmath95 .",
    "a nonlinear implicit equation @xmath97 relates @xmath65 , @xmath93 , @xmath94 , and @xmath95 on @xmath54 .",
    "the variables @xmath56 of the linear assembly problem for the local domain @xmath54 are @xmath65 , @xmath94 , @xmath95 , @xmath93 .",
    "we have a linear assembly problem .",
    "the function @xmath66 is the area of the truncated voronoi cell , viewed as a sum of variables @xmath65 , for each sector @xmath54 ( or rather , their pullbacks to @xmath53 under the natural projections @xmath98 ) .",
    "the assembly constraints are all linear .",
    "one linear relation imposes that the angles of the @xmath88 different sectors must sum to @xmath99 .",
    "other linear relations impose that the variable @xmath94 on @xmath54 equals the variable @xmath95 on @xmath100 if the two variables represent the length of the same segment @xmath92 in @xmath53 .      in this section",
    "we describe how various linear assembly problems are solved in the proof of the kepler conjecture in terms sufficiently general to apply to other linear assembly problems as well .",
    "let us introduce some general notation .",
    "let @xmath101 be the vector of variables with local domain @xmath54 .",
    "write @xmath66 in the form @xmath102 and the assembly conditions as @xmath103 according to the local domain of the variable .",
    "the first general technique is _",
    "linear relaxation_. we replace the nonlinear relations @xmath104 with a collection of linear inequalities that are true whenever the constraints @xmath71 are satisfied : @xmath105 .",
    "a linear program is obtained by replacing the nonlinear constraints @xmath71 with the linear constraints .",
    "its solution dominates the nonlinear optimization problem . in this way",
    ", the nonlinear maximization problem can be bounded from above .",
    "let us review some constructions that insure rigor in linear programming solutions .",
    "we assume general familiarity with the basic theory and terminology of linear programming .",
    "it is well - known that the primal has a feasible solution iff the dual is bounded .",
    "we will formulate our linear programs in such a way that both the primal and the dual problems are feasible and bounded .",
    "we use vector notation to formulate a primal problem as @xmath106 such that @xmath107 , where @xmath84 is a column vector of free variables ( no positivity constraints ) , @xmath65 is a matrix , @xmath63 is a row vector , and @xmath64 is a column vector .",
    "we can insure that this primal problem is bounded by bounding each of the variables @xmath59 .",
    "( this is easily achieved considering the geometric origins of our problem , which provides interpretations of variables as particular dihedral angles , edge lengths , and volumes . )",
    "we assume that these bounds form part of the constraints @xmath78 .",
    "the linear programs we consider have the property that if the maximum is less than a constant @xmath108 , the solution does not interest us .",
    "( for instance , in the dodecahedral conjecture , voronoi cell volumes are of interest only if the volume is less than the volume of the regular dodecahedron . )",
    "this observation allows us to replace the primal problem with one having an additional variable @xmath109 : @xmath110 such that @xmath111 , and @xmath112 .",
    "this modified primal is bounded for the same reasons that the original primal is .",
    "it has the feasible solution @xmath113 and @xmath114 .",
    "if the maximum @xmath115 of the original primal is greater than @xmath108 , then the optimal solution of the modified primal has @xmath116 , and hence its maximum is also @xmath115 .",
    "assume that @xmath117 gives an optimal solution to the modified problem for some @xmath118 , with @xmath119 .",
    "then @xmath120 is also a feasible solution and it beats the optimal solution @xmath121 this contradiction proves @xmath122 .",
    "the output from linear program that is solved by numerical methods can be transformed into a rigorous bound as follows . based on the preceding remarks , we assume that these linear programs are feasible and bounded .",
    "the dual is then also feasible and bounded .",
    "we assume that the numerical solutions are carried out with sufficient accuracy to insure bounded feasible approximations to the true optima .    to explain the rigorous verification , we separate the equality constraints from the inequality constraints , and rewrite the problem as @xmath123 such that @xmath124 , @xmath107 , with @xmath84 free .",
    "the dual problem yields a solution to @xmath125 such that @xmath126 , with @xmath127 and @xmath128 free .",
    "let @xmath129 be a numerically obtained approximation to the dual solution .",
    "the vector @xmath130 will be approximately positive , and by replacing negative coefficients by @xmath19 , we may assume @xmath131 .",
    "let @xmath132 be the error row vector resulting from numerical approximations .",
    "then for any feasible solution @xmath84 of the primal , we have @xmath133 using the bounds of the variables @xmath59 , we bound @xmath134 , and thus obtain the rigorous upper bound @xmath135 on the primal .",
    "the linear programs are solved numerically using a commercial package ( cplex ) . the input and output to these numerical programs",
    "are processed by a custom java program , which is linked to cplex with a java api provided by the software manufacturer .",
    "each bound is calculated with interval arithmetic to insure that it is reliable .",
    "( we use a simple implementation of interval arithmetic in java based on the math.bigdecimal implementation of arbitrary precision arithmetic . )",
    "the second general technique is nonlinear duality .",
    "suppose that we wish to show that the maximum of the primal problem  [ cx ] is at most @xmath115 .",
    "let @xmath136 be a guess of the solution to the problem , obtained for example , by numerical nonlinear optimization .",
    "we relax the nonlinear optimization by dropping from the matrix @xmath65 and the vector @xmath64 those inequalities that are not binding at @xmath137 . with this modification",
    ", we may assume that @xmath138 .",
    "let @xmath139 be the size of the vector @xmath64 , that is , the number of binding linear conditions .",
    "let @xmath140 be the number of local domains @xmath54 .",
    "we introduce a linear dual problem with real variables @xmath109 , @xmath141 , and @xmath142 . the variables @xmath143 and @xmath144 are constrained to be non - negative .    we consider the linear problem of maximizing @xmath109 such that @xmath145 and such that for each @xmath146 in each @xmath54 the linear inequality @xmath147 is satisfied .",
    "there is no guarantee that a feasible solution exists to this system of inequalities .",
    "however , any feasible solution gives an upper bound @xmath115 .",
    "indeed , let @xmath148 be any feasible argument to the primal , and let @xmath149 be a feasible solution to the dual .",
    "taking the sum of the linear inequalities  [ xd ] , over @xmath54 at @xmath84 , we have ( recall @xmath150 and @xmath78 ) : @xmath151    since the dual problem has infinitely many constraints ( because of constraints for each @xmath152 ) , we solve the dual problem in two stages .",
    "first , we approximate each @xmath54 by a finite set of test points , and solve the finitely constrained linear programming problem for @xmath153 , and @xmath144 .    we replace @xmath109 with @xmath154 ( to make the constraint [ mx ] bind ) .",
    "it follows from the feasibility of @xmath109 that @xmath155 , and that @xmath156 is also feasible on the finitely constrained problem . to show that @xmath156 satisfies all the inequalities  [ xd ] ( under the substitution @xmath157 ) , we use interval arithmetic to show that each of these inequalities hold .",
    "( to make these interval arithmetic verifications as easy as possible , we have chosen the solution @xmath158 to make the closest inequality hold by as large a margin @xmath159 as possible .",
    "this is the meaning of the maximization over @xmath109 in the dual problem . )",
    "the next section will give further details about interval arithmetic verifications .",
    "the third technique is branch and bound .",
    "when no feasible solution is found in step ( 2 ) , it may still be possible to partition @xmath53 into finitely many sets @xmath160 , on which feasible solutions to the dual may be found .",
    "although this is an essential part of the solution , the rules for branching in the kepler conjecture follow the structure of that problem , and we do not give a general branching algorithm .",
    "what we would like is a general , efficient algorithm for proving inequalities of several real variables .",
    "each inequality @xmath161 of a continuous function on a compact domain can be expressed as a maximization problem : @xmath162 generally efficient algorithms are not possible because np hard problems can be encoded as optimization problems of quadratic functions @xcite .",
    "this section describes an inequality proving procedure that has worked well in practice , and which could be automated to provide a method of general interest .",
    "this section assumes some general familiarity with issues of floating - point and interval arithmetic , such as can be found in @xcite , @xcite .",
    "our methods are similar to those in @xcite .    to prove @xmath163 , it is enough to show that the maximum of @xmath70 is less than @xmath19 .",
    "for this reason , we use interval arithmetic to bound the maximum of functions . through interval arithmetic ,",
    "an interval @xmath164 $ ] containing the range of @xmath70 can be obtained . by verifying that @xmath165 , it follows that the range of @xmath70 is negative , and hence that @xmath163 .",
    "all our functions can be built from arithmetic operations .",
    "( transcendental functions are replaced with explicit rational approximations with known error bounds . )    often , the functions @xmath70 are twice continuously differentiable . to obtain additional speed and accuracy",
    ", we use interval arithmetic to obtain rigorous bounds on the second partial derivatives of @xmath70 .",
    "( we obtain formulas for the second partials through symbolic and automatic differentiation of the function @xmath70 ) . with bounds on the second partials ,",
    "we obtain rigorous bounds on @xmath70 through its taylor approximation .",
    "the accuracy of the taylor approximation improves as the domain shrinks in size .",
    "we chop the domain into a collection of small rectangles and check on each rectangle whether the taylor bound implies @xmath163 .",
    "if taylor bound is too crude to give @xmath163 , we divide it into smaller rectangles and recompute the taylor bounds . by a process of adaptive subdivision of rectangles , the inequality @xmath163 is eventually established .",
    "derivative information can be used to speed up the algorithm .",
    "taylor bounds can also be applied to the first partial derivatives of @xmath70 .",
    "if a partial derivative of a variable @xmath84 is of fixed sign on a rectangle , then the function is maximized along an edge @xmath166 of the rectangle .",
    "if this edge is shared with an adjacent rectangle , the maximization of @xmath70 is pushed to an adjacent rectangle .",
    "if this edge lies on the boundary of the domain , the dimension of the optimization problem is reduced by one .    the method outline above works extremely well for simple functions in a small number of variables .",
    "the complexity grows rapidly with the number of variables .",
    "we are able to obtain satisfactory results for many inequalities that depend on a single simplex @xmath5 , that is , functions of six variables parameterized by the edge lengths of a simplex .",
    "most of the computer code for the proof of the kepler conjecture implements the taylor approximations of the nonlinear functions .",
    "the computer code for proving @xmath163 is obtained as follows .",
    "first , an expression for @xmath70 is derived .",
    "the formulas for the first and second partial derivatives of the function are obtained ( say by a symbolic algebra system ) from the expressions for @xmath70 .",
    "these symbolic expressions are then converted to an interval arithmetic format . in a language such as c++ with operator overloading ,",
    "this can be achieved by defining a class for intervals and overloading arithmetic operations so that they may be applied to instances of the class . in languages without operator overloading , the conversion from the symbolic expression to computer source code is more involved .",
    "there are other considerations to bear in mind in producing the interval code . in practice",
    ", there is a substantial degradation of performance when the rounding mode on the computer is frequently switched , and often it is necessary to rearrange the code substantially to reduce the number of changes in rounding mode .",
    "also , floating point arithmetic is not associative , so that in order to obtain rigorous results based on interval arithmetic , great care must be paid to the placement of parentheses .",
    "another issue is the input of floating point constants . in c++",
    ", the line of code in  [ x=1 ] sets @xmath167 , no matter the rounding flags .",
    "( the constant is parsed at compile time and truncated to 16 digits , and there is no control over rounding modes until later , when the program executes . )",
    "the code must insure that no errors are introduced through compiler constant truncation .",
    "there are many such perils in the production of reliable interval arithmetic code .",
    "overall , a great deal of effort must be expended to produce the computer code for rather simple inequalities .",
    "this effort must be expended every time a new function is introduced into an inequality .",
    "this simple fact has kept the inequality - proving software developed for the proof of the kepler conjecture from having more widespread applicability to more general inequality proving .",
    "figure  [ c++ ] shows a snippet of c++ code that computes the arctangent of a linear germ of a function .    ` / * * ` + ` * a lineinterval is an interval version of a linear approximation to a ` + ` * function in 6 variables . ` + ` * the linear approximation is + f + df[0 ] x0 + df[1 ] x1 + df[2 ] x2 + ... + df[5 ] x5 . `",
    "+ ` * / ` + ` class lineinterval { ` + `    public : ` + `       interval f , df[6 ] ; ` + `       //",
    "rest of class omitted   ` + ` } ; ` + ` ` + ` / * * ` + ` * sample implementation of the arctangent function . `",
    "+ ` * this computes the linear approximation only .",
    "the second derivatives ` + ` * are much more involved . `",
    "+ ` * / ` + ` static lineinterval atan(lineinterval a , lineinterval b ) //",
    "atan(a / b ) ; ` + ` { ` + `    static const interval one(\"1 \" ) ; ` + `    lineinterval temp ; ` + `    temp.f = intermath::atan(a.f / b.f ) ; // computes interval - valued arctangent ` + `    interval rden = one/(a.f*a.f+b.f*b.f ) ; ` + `    for ( int i=0;i<6;i++ ) temp.df[i]= rden*(a.df[i]*b.f - b.df[i]*a.f ) ; ` + `    return temp ; ` + ` } ` + `   ` +    if the kepler conjecture is eventually to be proved by generic tools , we must find a less cumbersome way to produce the computer code . indeed , a fundamental principle of software design is that there should be no manual procedures ( pragmatic programmer , tip 61 ) @xcite .",
    "generative programming gives methods to automate the production of computer code @xcite .",
    "there is nothing about the interval arithmetic computer code for a new function that requires human thought or effort in an essential way .",
    "for example , an examination of the code for the arctangent in figure  [ c++ ] reveals that it is a shallow reformatting of the formula for the derivative of the arctangent , combined with the quotient rule in calculus . why should the code be produced by hand , if it the process is entirely mechanical ?    a generative program could be written that takes as its input a function and produces as output the interval arithmetic computer code for the taylor series bounds of that function .",
    "the program would parse the definition of the function , generate symbolic derivatives of the function , convert the derivative information to computer code for calculating the derivatives , and so forth .",
    "what advantages would this bring ?",
    "first of all , it would no longer be necessary to read 40k lines of check to check the correctness of the proof of the kepler conjecture",
    ". it would be enough to check the code on the much smaller generator .",
    "also , the same generator could be used to prove many other inequalities .      the generative program has not been written .",
    "some feasibility tests have been made with javacc for parsing and xslt for abstract syntax tree transformations .",
    "a sphere graph is a graph together with an embedding of it into the unit sphere .",
    "we discuss a simple sphere graph generating algorithm in this section .",
    "figure  [ graph - seq ] shows a sequence of sphere graphs , giving a sequence of faces that are added to a square to produce the graph dual to the edge graph of the rhombic dodecahedron .",
    "we can represent the sequence abstractly as a directed graph with vertices @xmath169 with edges from @xmath89 to @xmath170 .",
    "figure  [ graph2-seq ] shows that the sequence of faces can be generated in different orders , and that all different sequences can be represented as a directed graph whose root is the square @xmath171 .",
    "call this the derivation graph .",
    "the terminal vertices of the directed graph represent sphere graphs isomorphic to @xmath172 .        in going from a parent to a child",
    ", we always add one face .",
    "each sphere graph in the derivation graph has two types of faces  those such as the pentagon in @xmath173 that does not survive unmodified in the terminal nodes , and those such as the triangle in @xmath173 that do .",
    "call these two types of faces _ modifiable _ and _ unmodifiable _ respectively .",
    "let us generalize this construction to generate all the sphere graphs that are needed for the proof of the kepler conjecture .",
    "fix a natural number @xmath174 .",
    "consider the set @xmath175 of nonempty sphere graphs with at most @xmath174 vertices , and no loops or multiple joins .",
    "all faces of the sphere graph are assumed to be polygons , and all polygons are assumed to be simple .",
    "we give each face one of the two attributes _ modifiable _ or _ unmodifiable _ and call a graph with these attributes a _ decorated _ graph .",
    "let @xmath176 be the set of all decorated graphs of @xmath175 .",
    "let @xmath33 be a polygon .",
    "we say that a simple polygon @xmath177 is an _ admissible refinement _ of @xmath33 if every vertex of @xmath177 is either a vertex of @xmath33 or an interior point of @xmath33 and if @xmath177 shares at least one edge with @xmath33 .",
    "an admissible refinement of @xmath33 partitions the region @xmath33 into the region @xmath177 and finitely many other polygons .",
    "let @xmath178 be a decorated sphere graph in @xmath176 .",
    "we say that @xmath179 is an _ admissible refinement _ of @xmath178 if there is a modifiable face @xmath33 of @xmath179 and an admissible refinement @xmath177 of @xmath33 such that the graph obtained by adding @xmath177 is @xmath179 that is compatibly decorated .",
    "we say that @xmath179 is compatibly decorated if the unmodifiable faces of @xmath179 are @xmath177 together with the unmodifiable faces of @xmath178 .",
    "a special case occurs , when @xmath180 , and in this case , we simply change the attribute of @xmath33 to unmodifiable .",
    "the set @xmath176 becomes a directed graph @xmath181 with an edge from each @xmath178 to all of the admissible refinements of @xmath178 .",
    "the root of the directed graph is an empty node .",
    "the children of the root are graphs consisting of a single polygon dividing the sphere into an interior and exterior , one side modifiable and the other not .",
    "the terminal vertices in this directed graph are decorated graphs , with no modifiable faces .",
    "thus , terminal vertices are in natural bijection with @xmath175 .",
    "if we take any graph in @xmath175 , it can be reached from the root as follows .",
    "pick a face of @xmath175 and draw its edges as the initial polygon .",
    "make the interior of the polygon modifiable . then continue to pick faces that have at least one edge already drawn , and draw all remaining edges of that face , marking the completed face as unmodifiable",
    "this corresponds to following a edge in the directed graph @xmath181 .",
    "this gives us an algorithm to generate all sphere graphs in @xmath175 : begin with the children of the root vertex ( polygons with at most @xmath174 vertices ) and generate all admissible refinements ( that is , follow all possible directed edges ) until terminal vertices are reached .",
    "we can improve on this algorithm by fixing for each @xmath182 a modifiable face @xmath33 and an edge on that face , and then taking only admissible refinements @xmath177 of @xmath33 that share the given edge .",
    "each sphere graph in @xmath175 is still generated under this restriction .",
    "we can also assume without loss of generality that the initial polygon is chosen to be one with the most edges .",
    "there is an enormous combinatorial explosion as all admissible refinements are generated . as fortune",
    "has it , we are not interested in all sphere graphs @xmath175 , but rather only those that arise as a potential counterexample to the kepler conjecture .",
    "let @xmath183 denote this smaller set of relevant graphs .",
    "this allows us to combine the general graph - generating algorithm with pruning operations that keep the combinatorics from getting out of hand .",
    "what is needed are criteria on @xmath182 that allows us to conclude that @xmath178 has no no admissibly refined descendents in @xmath184 , that is , to conclude there is no directed path from @xmath178 to @xmath185 .",
    "the proof of the kepler conjecture gives a long list of properties of graphs in @xmath184 and this avoids the combinatorial explosion .",
    "the implementation of the graph generator includes many other minor tricks to keep the execution time manageable . pruning and the other tricks are rather mundane , and we refer the reader to the source code for details .",
    "we will not try to list all of the places where the algorithms of this article would bring a simplification of the 1998 proof of the kepler conjecture .",
    "the list would be extensive . to give a rough indication , we list a few places these algorithms are relevant to the two shortest articles of the proof @xcite and @xcite .    in the article",
    "@xcite alone , low - dimensional quantifier elimination problems are the subject of lemma 1.2 , lemma 1.3 , lemma 1.4 , lemma 1.5 , lemma 1.6 , lemma 1.7 , lemma 1.8 , lemma 1.9 , lemma 1.11 , lemma 2.1 , and lemma 2.2 . in  @xcite , an additional low - dimensional quantifier elimination problem appears in lemma 2.2 . in general , the parts of the 1998 proof that rely on what that proof calls _ geometric considerations _ are amenable to preprocessed quantifier elimination .",
    "linear assembly algorithms generalize the algorithm presented in  @xcite , appendix 2 .",
    "some examples where linear assembly would simplify the 1998 proof are  @xcite section 4 , and  @xcite proposition 4.1 , proposition 4.2 , proposition 5.2 , proposition 5.3 , appendix 1 ( a.5 and a.7 ) .",
    "interval arithmetic inequalities are used throughout the 1998 proof , in sections such as @xcite appendix 3.13.14.7.5 and @xcite section 10 , appendix 1 . in the early articles in the series ,",
    "interval arithmetic taylor approximations are not used @xcite . as a result",
    ", these early papers only prove very limited types of inequalities .",
    "the entire strategy of the proof of the kepler conjecture in @xcite is shaped by these algorithmic limitations .",
    "this profoundly affects the structure of the optimization problem in @xcite , because a scoring function within the reach of the early primitive algorithms was chosen , although such a function was highly suboptimal . with improved automated inequality proving algorithms",
    ", it should be possible to make a fresh start and devise a much more efficient scoring function .",
    "graph generation is carried out in @xcite section 8 .",
    "we have not yet reached the fundamental objective of avoiding all manual procedures ; some parts of the proof remain hand - made ( even after taking account of the algorithms of this article ) .",
    "a fully automated proof would have to develop additional algorithms to prove these estimates .",
    "nevertheless , this article brings us one step closer to that objective .",
    "anonymous , what every computer scientist should know about floating - point arithmetic , http://docs.sun.com/htmlcoll/coll.648.2/iso-8859-1/numcompgd/ncg_goldberg.html    s. basu , r. pollack , and m .- f .",
    "roy , on the combinatorial and algebraic complexity of quantifier elimination , in procedings of the foundations of computer science , pp .",
    "632641 , 1994 .",
    "goetz alefeld and juergen herzberger , introduction to interval computations , academic press , n.y . , 1983 .",
    "krzysztof czarnecki and ulrich eisenecker , generative programming : methods , tools , and applications , addison - wesley , 2000 .",
    "bob f. caviness ( editor ) , j. r. johnson ( editor ) , quantifier elimination and cylindrical algebraic decomposition ( texts and monographs in symbolic computation ) , springer - verlag , 1998 .",
    "s. ferguson and t. hales , a formulation of the kepler conjecture , preprint , 1998 .",
    "t. hales , sphere packings i , disc . comp .",
    "geom , 1997 , 17:1 - 51 .",
    "t. hales , an overview of the kepler conjecture , preprint , 1998 .",
    "t. hales , sphere packings iii , preprint , 1998 .",
    "reiner horst , p. m. pardalos , and nguyen v. thoai , introduction to global optimization - second edition ( nonconvex optimization and its applications , volume 48 ) , kluwer , 2000 .",
    "andrew hunt , david thomas , and ward cunningham pragmatic programmer : from journeyman to master , addison - wesley , 1999 .",
    "r. baker kearfott : rigorous global search : continuous problems kluwer academic publishers , dordrecht , netherlands , 1996 .",
    "bhubaneswar mishra , computational real algebraic geometry , handbook of discrete and computational geometry , crc press , 1997 .",
    "thomas c. hales is at the department of mathematics , university of pittsburgh .",
    "the interval - arithmetic algorithms were developed in collaboration with s. ferguson ."
  ],
  "abstract_text": [
    "<S> by any account , the 1998 proof of the kepler conjecture is complex . the thesis underlying </S>",
    "<S> this article is that the proof is complex because it is highly under - automated . throughout that proof , </S>",
    "<S> manual procedures are used where automated ones would have been better suited . </S>",
    "<S> this paper gives a series of nonlinear optimization algorithms and shows how a systematic application of these algorithms would bring substantial simplifications to the original proof . </S>"
  ]
}