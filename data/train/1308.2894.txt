{
  "article_text": [
    "s a major breakthrough in coding theory , polar codes , introduced by arikan in @xcite , can asymptotically achieve the channel capacity of binary symmetric channels using a successive cancellation ( sc ) decoder with a complexity of @xmath1 , where @xmath2 , is the code block length .",
    "later , some improved algorithms of sc are described in @xcite @xcite @xcite . yet still",
    "the performance of these decoders is inferior to that of the maximum likelihood ( ml ) decoder , or at least can not be proven to achieve the ml performance .",
    "an ml decoder of polar codes is implemented by viterbi algorithm in @xcite ; but the decoding complexity grows exponentially with the code length .    inspired by the sphere decoding ( sd ) for space - time block codes @xcite @xcite , an sd algorithm of polar codes is proposed in @xcite to perform ml decoding with a cubic complexity .",
    "the sphere decoder configures an initial target radius , and the candidates in the sphere are enumerated .",
    "whenever an @xmath3-length path corresponding to a smaller radius is found , this path is buffered as a candidate codeword , and based on which , the target radius is updated .",
    "after that , the search is restarted in the new sphere with a smaller radius . until no paths can be found in the sphere with a smaller radius than the target",
    ", the decoder outputs the buffered path as the decoding codeword .",
    "the drawback of this naive decoding is that some paths which have already been spanned in the previous sphere may be respanned .",
    "furthermore , when searching in the sphere , the decoder enumerates and expands the candidate path only based on the path length , namely , if one path has a longer length , it will be expanded with a higher priority .",
    "this length - first search is not a good strategy , because the search rule only involves a simple information of the path length and neglects the information provided by the received sequence .",
    "stack sequential algorithm , as stated in @xcite , is functionally equivalent to the sphere decoding . in this paper ,",
    "a stack sd ( ssd ) algorithm of polar codes is applied , where the paths are stored in a stack with a descending order of the path metrics . in ssd , each possible path is visited at most once .",
    "inspired by massey s work about the optimum frame synchronization @xcite , we derive an optimum path metric based on the ml rule .",
    "further , a much simpler metric is also provided as an approximation of the proposed metric in the high signal - to - noise ratio ( snr ) regimes . with the help of the proposed path metrics , the ssd can efficiently enumerate the candidate paths and narrow the search range so as to remarkably reduce the computational complexity yet still achieve the ml performance .",
    "the remainder of this paper is organized as follows .",
    "describes the process of the polar coding and the signal model over the additive white gaussian noise ( awgn ) channel . derives the optimum and suboptimum path metric based on the ml rule and presents the details of ssd algorithm .",
    "gives the performance and complexity analysis of the proposed ssd algorithm based on the simulation results . finally , concludes the paper .",
    "given an @xmath4 polar code , the @xmath3-length code block ( codeword ) @xmath5 can be generated by @xmath6 where @xmath7 is a source - scrambling vector generated by the @xmath8 bit - reversal permutation matrix @xmath9 defined in @xcite , and the vector @xmath10 is the source block . as the @xmath11-th kronecker power of @xmath12 $ ]",
    ", the matrix @xmath13 has a lower triangular structure , where the @xmath14-th element @xmath15 is taken the value in @xmath16 .",
    "hence , the components @xmath17 can be written as @xmath18 the @xmath3 polarized subchannels are corresponding to the rows of the matrix @xmath13 , and the reliabilities of which are calculated using bhattacharyya parameters @xcite .",
    "the entries in the source - scrambling vector @xmath19 with indices corresponding to the more reliable @xmath20 rows of the matrix @xmath21 are assigned information bits ; the other @xmath22 entries are related to the frozen bits which can be set to zeros when the channels are symmetric .    the received sequence @xmath23 can be written as @xmath24 where @xmath25 is the energy of the transmitted signal , and @xmath26 is the transmitted signal vector , and @xmath27 is an @xmath3-length vector of i.i.d . awgns .",
    "the components @xmath28 are statistically independent gaussian random variables with @xmath29 mean and variance @xmath30 where @xmath31 is the one - sided noise spectral density . and the elements @xmath32 are the bpsk modulated signals . the ml estimation of the transmitted bits can be obtained by minimizing the square euclidean distance ( sed ) towards the received sequence , that is , @xmath33 where @xmath34 is an all - one vector of length @xmath3 . after performing a bit - reversal permutation on @xmath35 , an estimation of the source block",
    "is obtained , i.e. , @xmath36 where @xmath37 denotes the matrix inverse .",
    "in fact , @xmath38 .",
    "in this section , we first give a brief description of the code tree and provide an ssd with conventional enumeration strategy .",
    "then , the optimum path metric is derived based on the ml rule and its approximations in high / low snr regimes are also provided .",
    "finally , the proposed ssd algorithm with an efficient enumeration is described in detail .      for the sd algorithm ,",
    "the ml estimation @xmath35 can be obtained by enumerating all the transmitted signal vectors @xmath39 within a sphere of radius @xmath40 that is centered at @xmath41 . in @xcite ,",
    "the sd algorithm is described as a series of depth - first searches on the code tree , and a strategy using parallel subtree searches is suggested to reduce the complexity .",
    "but for each iteration of both methods , after updating the radius of sphere , the search process should be restarted from the preceding node .",
    "thus , for a direct implementation of sd , a certain path in the code tree may be revisited many times . to avoid these revisitings , a stack implementation of sd",
    "is applied in this paper .    for finite bpsk signals ,",
    "the sphere decoder can be regarded as a bounded search in a code tree . due to the lower triangular form of @xmath42",
    ", the source - scrambling vector @xmath19 can be represented as a path in a tree of depth @xmath3 , where the values of bit @xmath43 at level @xmath44 correspond to branches at depth @xmath45 .",
    "for example , fig.[fig_example ] gives a code tree with four levels .",
    "inspired by @xcite , a stack is used in ssd to store the candidate paths .",
    "the paths with solid branches are the candidates in the stack and sorted by path metric in descending order , on the other hand , those dash branches are visited and discarded ( since their euclidean distances to the sphere center are larger than the target ) . under the ssd algorithm ,",
    "a possible candidate path is visited at most once .",
    "let @xmath46 denote the binary labeling of an @xmath47-length path from the root to a certain branch at the @xmath44-th level , and we use @xmath48 to denote the corresponding transmitted signal vector .",
    "given the received sequence @xmath41 , the corresponding sed between the path @xmath49 and the related segment of received sequence @xmath50 can be expressed as that in @xcite , @xmath51 if the branch @xmath43 is corresponding to a frozen bit and takes an incorrect value , the associated sed is @xmath52 .",
    "the sphere decoder utilizes this sed as a measurement to judge whether the vector @xmath53 is inside the sphere . particularly , when @xmath54 , it is also used to update the radius of sphere .",
    "for the conventional enumeration , since the sd is described as a series of depth - first searches , the length of the candidate path is taken for path sorting in ssd , @xmath55 initially , a null path @xmath56 which is corresponding to the root node is loaded in the stack and its metric is @xmath57 .",
    "the search goes along the longest path in the stack .",
    "whenever a candidate path @xmath49 is found to have a measurement @xmath58 that is larger than the target radius @xmath40 , it will be dropped directly .",
    "when the path on the top of the stack achieves length @xmath3 , i.e. , @xmath54 , the @xmath3-length bit sequence corresponding to this path is buffered as a candidate vector , and the target radius is updated as @xmath59 .",
    "this procedure goes on until the stack becomes empty , the buffered vector is then output as the decoding result .",
    "in fact , this conventional enumeration is to select the candidate path in the stack one - by - one and check that whether the candidate is inside the sphere .",
    "since the paths in the stack are sorted by the simple path metric @xmath60 , the sphere decoder lacks the valuable information to direct the search procedure .",
    "given a path @xmath49 and its corresponding vector @xmath61 , the complement vector @xmath62 can take a possible value from a random vector @xmath63 , where each @xmath64 is either @xmath65 or @xmath66 with an equal probability of @xmath67 .",
    "the optimum path metric for the enumeration is to maximize the likelihood probability @xmath68 since @xmath69 for all @xmath70 , it is equivalent to maximize @xmath71 since @xmath27 is a vector of i.i.d .",
    "awgns , we have @xmath72 @xmath73 substituting this formula into ( [ metric_l2 ] ) and neglecting all the items independent of @xmath61 or @xmath74 , it is equivalent to maximize @xmath75 remember @xmath76 takes value in @xmath77 , the above summation can be expressed as @xmath78 the logarithmic form of ( [ metric_l3e ] ) is @xmath79 given a received sequence @xmath41 , the following summation @xmath80 is a constant . after subtracting ( [ const ] ) from @xmath81",
    ", we obtain a path metric that is equivalent to the optimal one in ( [ metric_l1 ] ) , i.e. , @xmath82 where @xmath83    this ml path metric includes two terms : the first summation involves the correlation between the vector @xmath61 and the received sequence @xmath50 ; the second term , @xmath84 , is a correction term which further consists of two parts : the summation represents a kind of energy correction related to the received sequence @xmath50 ; the second part is corresponding to the depth of the path @xmath49 . compared with massey s metric @xcite , this metric has the same item for the first summation , but the correction term of which includes an additional part to manifest the length of the path .",
    "similar to the works in @xcite , two approximations of the optimum path metric can also be derived in the cases of very high and very low snr .",
    "when @xmath85 , the argument of the @xmath86 in ( [ m1_metric ] ) is much greater than @xmath87 so that the function @xmath88 can be approximated as @xmath89",
    ". therefore , after dropping the constant @xmath90 , the high snr approximation of the optimum path metric in ( [ m1_metric ] ) can be expressed as @xmath91 which is much simpler than the metric @xmath92 .    for practical implementation , after receiving @xmath41 , the values of @xmath93 for all @xmath94 can be pre - calculated and stored in a @xmath95-sized table .",
    "thus , for each node visiting during the rest decoding procedure , no extra calculation is needed compared with the ssd using the conventional metric @xmath60 .",
    "the similar method can also be applied for the calculation of metric @xmath92 .",
    "when @xmath96 , the function @xmath97 can be approximated by @xmath98 . using this approximation in ( [ m1_metric ] ) , we have @xmath99 but according to our simulation results ( which are not provided in this paper ) , this metric is not efficient in reducing the complexity .",
    "so we will not discuss it below .      the ssd algorithm based on the proposed path metric @xmath92 or @xmath100",
    "can be summarized as follows :    * step 1*. initialization : 1 ) set the target radius as @xmath101 ; 2 ) a null path @xmath102 with @xmath103 is pushed into the stack .    * step 2*. popping : a path @xmath49 is popped from the top of the stack , if the path reaches the depth @xmath3 , i.e. , @xmath54 , record the estimation vector @xmath104 and update the search radius @xmath105 , then go to * step 4*.    * step 3*. expanding : the current path @xmath49 is extended to two new paths , i.e. , @xmath106 and @xmath107 . for each path , calculate the sed @xmath108 by ( [ msed_metric ] ) .",
    "if the optimum path metric is used , calculate the path metric @xmath109 by ( [ m1_metric ] ) .",
    "otherwise , if the high snr approximation is used , calculated the path metric @xmath110 by ( [ m2_metric ] ) .    * step 4*. pushing : the paths with @xmath111 are pushed back into the stack , the others are simply dropped .",
    "* step 5*. sorting : the paths in the stack are re - sorted from top to bottom in descending order according to the value of @xmath92 or @xmath100 .    * step 6*. stopping : if the stack is empty , then stop the decoding process and output @xmath112 ; otherwise , go to .    to efficiently implement an ssd decoder , the same technique in @xcite can be utilized to avoid the redundant copy operations and memory occupation .",
    "compared with the conventional sd , the main difference of ssd algorithm is the sorting operations in * step 5*. the candidate path is enumerated from the most probable one by applying the proposed path metric @xmath92 or its approximation @xmath100 , therefore the complexity of ssd algorithm can be efficiently reduced .",
    "in this section , the ssd is applied to polar codes and reed - muller ( rm ) codes with short code blocks . the performance and complexity of the ssd with the conventional metric and the proposed metrics are evaluated via simulations with bpsk modulation over awgn channels .",
    "fig.[fig_perform ] presents the block - error - rate ( bler ) performances of ( 64 , 57 ) polar and rm codes under ssd with different path metrics .",
    "we can see that the ssd algorithms with all the three metrics , the conventional metric ( @xmath60 in ( [ m0_metric ] ) ) , the ml rule ( @xmath92 in ( [ m1_metric ] ) ) or its high snr approximation ( @xmath100 in ( [ m2_metric ] ) ) , can achieve the same performance .",
    "further , rm codes are shown to have better performances than polar codes under the ml decoding .",
    "the computational complexities are shown in fig.[fig_complexity ] .",
    "the average complexities are evaluated by counting the node visitings in the code tree .",
    "compared with the ssd using the conventional metric @xmath60 , significant complexity reductions can be obtained by using the proposed path metrics : about @xmath0 times in the entire simulated snr regime . although the metric @xmath100 is an approximation of the metric @xmath92 in the case of high snr , the ssd algorithm with this metric can achieve almost the same complexity reduction in the medium to high bit snr regime , that is , @xmath113 .",
    "interestingly , even in the low snr regime , only a slight increasing of complexity under the ssd algorithm with the metric @xmath100 is observed .",
    "a stack - based sphere decoding algorithm with efficient enumeration is proposed to achieve the performance of ml decoding for the polar codes . by introducing the optimum path metric in the sorting operations ,",
    "remarkable complexity reduction can be obtained under the ssd algorithm . moreover ,",
    "a high snr approximation of the optimum metric is provided , which has a very simple form and is more suitable for practical applications ."
  ],
  "abstract_text": [
    "<S> sphere decoding ( sd ) of polar codes is an efficient method to achieve the error performance of maximum likelihood ( ml ) decoding . </S>",
    "<S> but the complexity of the conventional sphere decoder is still high , where the candidates in a target sphere are enumerated and the radius is decreased gradually until no available candidate is in the sphere . in order to reduce the complexity of sd , a stack sd ( ssd ) algorithm with an efficient enumeration is proposed in this paper . </S>",
    "<S> based on a novel path metric , ssd can effectively narrow the search range when enumerating the candidates within a sphere . </S>",
    "<S> the proposed metric follows an exact ml rule and takes the full usage of the whole received sequence . </S>",
    "<S> furthermore , another very simple metric is provided as an approximation of the ml metric in the high signal - to - noise ratio regime . for short polar codes , </S>",
    "<S> simulation results over the additive white gaussian noise channels show that the complexity of ssd based on the proposed metrics is up to @xmath0 times lower than that of the conventional sd .    </S>",
    "<S> polar codes , successive cancellation decoding , sphere decoding , maximum likelihood rule . </S>"
  ]
}