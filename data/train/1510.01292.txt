{
  "article_text": [
    "cloud storage is an on - demand network data storage and access paradigm . to ensure accessibility of remotely stored data at any time , a typical solution is to store data across multiple servers or clouds , often in a replicated fashion .",
    "data replication not only lacks flexibility in data recovery , but also requires secure data management and protection .",
    "it is well known that secure data management is generally very costly and may be vulnerable to data compromising attacks .",
    "distributed data storage provides an elegant tradeoff between the costly secure data management task and the cheap storage media .",
    "the main idea for distributed storage is that instead of storing the entire data in one server , we can split the data into @xmath0 data components and store the components across multiple servers .",
    "the original data can be recovered only when the required ( threshold ) number of components , say @xmath1 , are collected .",
    "in fact , the original data is information theoretically secure for anyone who has access up to @xmath2 data components . in this case ,",
    "when the individual components are stored distributively across multiple cloud storage servers , each cloud storage server only needs to ensure data integrity and data availability .",
    "the costly data encryption and secure key management may no longer be needed any more .",
    "the distributed cloud storage can also increase data availability while reducing network congestion that leads to increased resiliency .",
    "a popular approach is to employ an @xmath3 maximum distance separable ( mds ) code such as an reed - solomon ( rs ) code @xcite . for rs code ,",
    "the data is stored in @xmath0 storage nodes in the network .",
    "the data collector  ( dc ) can reconstruct the data by connecting to any @xmath1 healthy nodes .",
    "while rs code works perfect in reconstructing the data , it lacks scalability in repairing or regenerating a failed node .",
    "to deal with this issue , the concept of regenerating code was introduced in @xcite .",
    "the main idea of the regenerating code is to allow a replacement node to connect to some individual nodes directly and regenerate a substitute of the failed node , instead of first recovering the original data then regenerating the failed component .",
    "compared to the rs code , regenerating code achieves an optimal tradeoff between bandwidth and storage within the minimum storage regeneration ( msr ) and the minimum bandwidth regeneration ( mbr ) points .",
    "rs code based msr ( rs - msr ) code and mbr ( rs - mbr ) code have been explicitly constructed in @xcite . however , the existing research either has no error detection capability , or has the error correction capability limited by the rs code .",
    "moreover , the schemes with error correction capability are unable to determine whether the error correction is successful .    in this paper , we construct the regenerating codes by combining the hermitian code and regenerating code at the msr point ( h - msr code ) and the mbr point ( h - mbr code ) .",
    "we prove that these codes can achieve the theoretical msr bound and mbr bound respectively .",
    "we also propose data regeneration and reconstruction algorithms for the h - msr code and the h - mbr code in both error - free network and hostile network .",
    "our proposed algorithms can detect the errors in the network while achieving the error correction capability _ beyond the rs code_. moreover , our proposed algorithms can determine whether the error correction is successful .",
    "the rest of this paper is organized as follows : in section [ sec : relatedwork ] , related work is reviewed .",
    "the preliminary of this paper is presented in section [ sec : preliminary ] . in section [ sec : h - msr ] , our proposed encoding of h - msr code is described . in section [ sec : h - msr - regeneration ] , regeneration of the h - msr code is discussed .",
    "reconstruction of the h - msr code is analyzed in section [ sec : h - msr - reconstruct ] . in section [ sec : h - mbr ] , our proposed encoding of h - mbr code is described . in section [ sec",
    ": h - mbr - regeneration ] , regeneration of the h - mbr code is discussed .",
    "reconstruction of the h - mbr code is analyzed in section [ sec : h - mbr - reconstruct ] .",
    "we conduct performance analysis in section [ sec : performance ] .",
    "the paper is concluded in section [ sec : conclusion ] .",
    "when a storage node in the distributed storage network that employing the conventional @xmath3 rs code ( such as oceanstore  @xcite and total recall  @xcite ) fails , the replacement node connects to @xmath1 nodes and downloads the whole file to recover the symbols stored in the failed node .",
    "this approach is a waste of bandwidth because the whole file has to be downloaded to recover a fraction of it . to overcome this drawback , dimakis _ et al . _",
    "@xcite introduced the concept of @xmath4 regenerating code . in the context of regenerating code",
    ", the replacement node can regenerate the contents stored in a failed node by downloading @xmath5 help symbols from @xmath6 helper nodes .",
    "the bandwidth consumption to regenerate a failed node could be far less than the whole file .",
    "a data collector  ( dc ) can reconstruct the original file stored in the network by downloading @xmath7 symbols from each of the @xmath1 storage nodes . in  @xcite",
    ", the authors proved that there is a tradeoff between bandwidth @xmath5 and per node storage @xmath7 .",
    "they find two optimal points : minimum storage regeneration ( msr ) and minimum bandwidth regeneration ( mbr ) points .",
    "the regenerating code can be divided into functional regeneration and exact regeneration . in the functional regeneration ,",
    "the replacement node regenerates a new component that can functionally replace the failed component instead of being the same as the original stored component .",
    "@xcite formulated the data regeneration as a multicast network coding problem and constructed functional regenerating codes .",
    "@xcite implemented a random linear regenerating codes for distributed storage systems .",
    "@xcite proved that by allowing data exchange among the replacement nodes , a better tradeoff between repair bandwidth @xmath5 and per node storage @xmath7 can be achieved . in the exact regeneration",
    ", the replacement node regenerates the exact symbols of a failed node .",
    "@xcite proposed to reduce the regeneration bandwidth through algebraic alignment .",
    "@xcite provided a code structure for exact regeneration using interference alignment technique .",
    "@xcite presented optimal exact constructions of mbr codes and msr codes under product - matrix framework .",
    "this is the first work that allows independent selection of the nodes number @xmath0 in the network .",
    "however , none of the existing work above considered code regeneration under node corruption or adversarial manipulation attacks .",
    "in fact , all these schemes will fail in both regeneration and reconstruction in these scenarios .",
    "in  @xcite , the authors discussed the amount of information that can be safely stored against passive eavesdropping and active adversarial attacks based on the regeneration structure . in  @xcite , the authors proposed to add crc codes in the regenerating code to check the integrity of the data in hostile network .",
    "unfortunately , the crc checks can also be manipulated by the malicious nodes , resulting in the failure of the regeneration and reconstruction . in @xcite",
    ", the authors analyzed the error resilience of the rs code based regenerating code in the network with errors and erasures .",
    "they provided the theoretical error correction capability .",
    "their result is an extension of the mds code to the regenerating code and their scheme is unable to determine whether the errors in the network are successfully corrected .    in this paper",
    ", we propose a hermitian code based minimum storage regeneration ( h - msr ) code and a hermitian code based minimum bandwidth regeneration ( h - mbr ) code .",
    "the proposed h - msr / h - mbr codes can correct more errors than the rs - msr / rs - mbr codes and can always determine whether the error correction is successful . our design is based on the structural analysis of the hermitian code and the efficient decoding algorithm proposed in  @xcite .",
    "it is worthwhile to point out that although there are strong connections between regenerating code in distributed storage and general network communication of which security problems have been well studied , our proposed h - msr / h - mbr codes are fundamentally different from these security studies of network communication e.g.  @xcite , for two main reasons .",
    "first , the significant error correction capability of the proposed h - msr / h - mbr codes is due to the underlying hermitian code  @xcite , instead of relying on an error - detection layer , and/or shared secret keys between the sender and the receiver for error detection  ( * ? ? ?",
    "* section 8.6.1 ) .",
    "second , the regenerating codes studied in this paper and the general network communication are different in that besides the overall data reconstruction , the regenerating codes also emphasize repairing of the corrupted code components ( regeneration ) , while general network communication only focuses on data reproducing ( reconstruction ) . therefore ,",
    "both the principle and the scope of this paper are different from the researches of security in general network communication .",
    "regenerating code introduced in  @xcite is a linear code over the finite field @xmath8 with a set of parameters @xmath4 .",
    "a file of size @xmath9 is stored in @xmath0 storage nodes , each of which stores @xmath7 symbols .",
    "a replacement node can regenerate the contents of a failed node by downloading @xmath10 symbols from each of @xmath6 randomly selected storage nodes .",
    "so the total bandwidth needed to regenerate a failed node is @xmath11 .",
    "the data collector ( dc ) can reconstruct the whole file by downloading @xmath7 symbols from each of @xmath12 randomly selected storage nodes . in  @xcite ,",
    "the following theoretical bound was derived : @xmath13 from equation  ( [ eq : min_cut ] ) , a tradeoff between the regeneration bandwidth @xmath5 and the storage requirement @xmath7 was derived .",
    "there are two special cases : minimum storage regeneration ( msr ) point in which the storage parameter @xmath7 is minimized ; @xmath14 and minimum bandwidth regeneration ( mbr ) point in which the bandwidth @xmath5 is minimized : @xmath15    in this paper , we assume that dc keeps the encoding matrix secret and each storage node only knows its own encoding vector .",
    "a hermitian curve @xmath16 over @xmath17 in affine coordinates is defined by : @xmath18 the genus of @xmath16 is @xmath19 and there are @xmath20 points that satisfy equation  ( [ eq : hermitian_curve ] ) , denoted as @xmath21 , @xmath22 ( see table  [ tb : points ] ) , where @xmath23 are the @xmath24 solutions to @xmath25 and @xmath26 is a primitive element in @xmath17 .",
    "@xmath27 is defined as : @xmath28 where @xmath29 for @xmath30 .",
    "a codeword of the hermitian code @xcite @xmath31 is defined as @xmath32 where @xmath33 .",
    "the dimension of the message before encoding can be calculated as @xmath34 .    [ cols=\"^,^,^,^ \" , ]      in this paper , we assume some network nodes may be corrupted due to hardware failure or communication errors , and/or be compromised by malicious users . as a result , upon request",
    ", these nodes may send out incorrect responses to disrupt the data regeneration and reconstruction .",
    "the adversary model is the same as  @xcite , we assume that the malicious users can take full control of @xmath35 ( @xmath36 and corresponds to @xmath37 in  @xcite ) storage nodes and collude to perform attacks",
    ".    we will refer these symbols as _ bogus _ symbols without making distinction between the corrupted symbols and compromised symbols .",
    "we will also use corrupted nodes , malicious nodes and compromised nodes interchangeably without making any distinction .",
    "in this section , we will analyze the h - msr code based on the msr point with @xmath38 .",
    "the code based on the msr point with @xmath39 can be derived the same way through truncating operations .",
    "let @xmath40 be a strictly decreasing integer sequence satisfying @xmath41 , where @xmath42 is the parameter @xmath7 for the underlying regenerating code .",
    "the least common multiple of @xmath43 is @xmath44 .",
    "suppose the data contains @xmath45 message symbols from the finite field @xmath17 .",
    "in practice , if the size of the actual data is larger than @xmath9 symbols , we can fragment it into blocks of size @xmath9 and process each block individually .",
    "we arrange the @xmath9 symbols into two matrices @xmath46 as below : @xmath47 where @xmath48 , \\nonumber \\\\ t_i & = & [ t_{i,1 } , t_{i,2 } , \\cdots , t_{i , a/\\alpha_i}].\\end{aligned}\\ ] ] @xmath49 , is a symmetric matrix of size @xmath50 with the upper - triangular entries filled by data symbols .",
    "thus @xmath51 contains @xmath52 symbols .",
    "the number of columns of each submatrix @xmath53 , is the same : @xmath54 .",
    "the size of matrix @xmath55 is @xmath56 .",
    "so it contains @xmath57 data symbols .",
    "@xmath58 , is constructed the same as @xmath51 .",
    "so @xmath59 contains the other @xmath60 data symbols .    for a hermitian code @xmath31 over @xmath17",
    ", we encode matrix @xmath61 $ ] by encoding each column @xmath62 , individually using @xmath31 .",
    "the codeword matrix is defined as @xmath63,\\ ] ] where @xmath64 has the following form ( @xmath33 ) : @xmath65^t,\\ ] ] and the elements of @xmath66 are viewed as the coefficients of the polynomials @xmath67 in @xmath68 when @xmath66 is encoded .",
    "let @xmath69 be a vandermonde matrix , where @xmath26 is the primitive element in @xmath17 mentioned in section  [ sec : hermitian_code ] and @xmath70 .",
    "define @xmath71 to be a diagonal matrix comprised of @xmath72 elements , where @xmath73 , is chosen using the following two criteria : ( i ) @xmath74 .",
    "( ii ) any @xmath75 rows of the matrix @xmath76 $ ] , @xmath70 , are linearly independent .",
    "we also define @xmath77 to be a @xmath78 diagonal matrix for @xmath79 , where i is the @xmath78 identical matrix . and @xmath80 is a @xmath81 diagonal matrix formed by @xmath72 diagonal submatrices @xmath82 .    for distributed storage",
    ", we encode each pair of matrices @xmath83 using algorithm  [ alg : enc ] .",
    "we will name this encoding scheme as _ hermitian - msr code encoding _ , or _",
    "h - msr code encoding_.    encoding h - msr code [ alg : enc ]    * step n : *    encode the data matrices @xmath46 defined in equation ( [ eqn : matrices_s_t ] ) using a hermitian code @xmath31 over @xmath17 with parameters @xmath84 and @xmath85 .",
    "denote the generated @xmath86 codeword matrices as @xmath87 and @xmath88 .",
    "compute the @xmath86 codeword matrix @xmath89 .",
    "divide @xmath90 into @xmath72 submatrices @xmath91 of size @xmath92 and store each submatrix in a storage node as shown in fig .",
    "[ fig : store_codeword ] .        for h - msr coding encoding , we have the following theorem .",
    "[ th : msr ] the h - msr code encoding described in algorithm  [ alg : enc ] can achieve the msr point in distributed storage .",
    "we first study the structure of the codeword matrix @xmath87 . since every column of the matrix is an independent hermitian codeword",
    ", we can decode the first column @xmath93 @xmath94^t$ ] as an example without loss of generality .",
    "we arrange the @xmath20 rational points of the hermitian curve following the order in table  [ tb : points ] . in the table , we can find that for each @xmath95 , the rational points @xmath96 all have the same first coordinate .",
    "suppose @xmath33 : @xmath97 , @xmath98 for @xmath99 .",
    "since @xmath100 all have the same first coordinate and @xmath101 is only applied to the first coordinate of @xmath102 , we have @xmath103 , which does not depend on @xmath104",
    ". therefore , we can derive @xmath72 sets of equations for @xmath105 : @xmath106if we store the codeword matrix in storage nodes according to fig .",
    "[ fig : store_codeword ] , each set of the equations corresponds to a storage node . as we mentioned above , the set of equations in equation  ( [ equ_derive_f ] ) can be derived in storage node @xmath107 .    since the coefficient matrix @xmath108 is a vandermonde matrix : @xmath109 we can solve @xmath110^t$ ] from @xmath111 where @xmath112^t$ ] .    from all the @xmath72 storage nodes",
    ", we can get vectors @xmath113^t,$ ] @xmath114 , which can be viewed as extended reed - solomon codes .",
    "now consider all the columns of @xmath87 , we can get the following equation : @xmath115 where @xmath116 $ ] , @xmath70 , @xmath117 , and @xmath118 corresponds to the @xmath119 column of the submatrix @xmath51 .",
    "next we will consider the structure of the codeword matrix @xmath88 .",
    "because the encoding process for @xmath88 is the same as that of @xmath87 , for @xmath120 , we can derive @xmath121 where @xmath122^t$ ] , @xmath123 $ ] , @xmath70 , @xmath117 , and @xmath124 corresponds to the @xmath119 column of the submatrix @xmath125 .",
    "thirdly , we will study the optimality of the code in the sense of the msr point . for @xmath126 , since @xmath127 are symmetric and satisfy the requirements for msr point according to  @xcite with parameters @xmath128 . by encoding @xmath46 using @xmath129 and distributing @xmath91 into @xmath72 storage nodes , each row of the matrix @xmath130 , can be derived in a corresponding storage node . because @xmath131 achieves the msr point ,",
    "data related to matrices @xmath132 , can be regenerated at the msr point .",
    "therefore , algorithm  [ alg : enc ] can achieve the msr point .",
    "in this section , we will first discuss regeneration of the h - msr code in error - free network . then we will discuss regeneration in hostile network .",
    "let @xmath133^t$ ] , then @xmath134^t,\\end{aligned}\\ ] ] for every column @xmath135 of @xmath136 .",
    "the main idea of the regeneration algorithms is to regenerate @xmath137 , @xmath138 , by downloading help symbols from @xmath139 nodes , where @xmath140 represents the regeneration parameter @xmath6 for @xmath137 in the h - msr code regeneration .",
    "suppose node @xmath141 fails , we devise algorithm  [ alg : reg_err_free ] in the network to regenerate the exact h - msr code symbols of node @xmath141 in a replacement node @xmath142 . for convenience ,",
    "we suppose @xmath143 and define @xmath144 where @xmath145 , is the @xmath146 row of @xmath147 $ ] .",
    "each node @xmath107 , @xmath105 , only stores its own encoding vector @xmath148 , @xmath138 .",
    "first , replacement node @xmath142 will send requests to helper nodes for regeneration : @xmath142 sends the integer @xmath149 to @xmath150 helper nodes , to which @xmath142 has not sent requests before , for every @xmath149 from @xmath151 to @xmath152 in descending order . upon receiving the request integer @xmath149 ,",
    "helper node @xmath107 will calculate and send the help symbols as follows : node @xmath107 will first calculate @xmath153 to remove the coefficient matrix @xmath108 from the codeword matrix .",
    "since the @xmath154 row of @xmath155 corresponds to the symbols related to @xmath137 , for @xmath156 , node @xmath107 will divide the @xmath154 row of @xmath155 into @xmath157 row vectors of the size @xmath158 : @xmath159 $ ] . then for every @xmath156 and @xmath160 , node @xmath107 will calculate the help symbol @xmath161 , where @xmath162 is the @xmath163 row of the encoding matrix @xmath164 defined in equation  ( [ eq : phi ] ) . at last , node @xmath107 will send out all the calculated symbols @xmath165 . here",
    "@xmath149 indicates that @xmath142 is requesting symbols @xmath165 , @xmath156 and @xmath160 , calculated by @xmath166^t$ ]    since @xmath167 for @xmath168 , for efficiency consideration , only @xmath169 helper nodes need to send out symbols @xmath165 , @xmath138 and @xmath160 , calculated by @xmath170^t$ ] .",
    "then @xmath171 nodes only need to send out symbols @xmath165 , @xmath156 and @xmath160 , calculated by @xmath172^t$ ] for @xmath173 . in this way , the total number of helper nodes that send out symbols @xmath165 , @xmath160 , calculated by @xmath137 is @xmath174 .",
    "when the replacement node @xmath142 receives all the requested symbols , it can regenerate the symbols stored in the failed node @xmath141 using the following algorithm :    @xmath142 regenerates symbols of the failed node @xmath141 [ alg : reg_err_free ]    * step n : *    for every @xmath138 and @xmath160 , calculate the regenerated symbols related to the help symbols @xmath165 from @xmath140 helper nodes . without loss of generality ,",
    "we assume @xmath175 :    * step 1.1 : * let @xmath176^t$ ] , solve the equation : @xmath177 .",
    "* step 1.2 : * since @xmath178 and @xmath179 are symmetric , we can calculate @xmath180 $ ] .",
    "* step 1.3 : * compute @xmath181 .",
    "let @xmath182 be a @xmath183 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath185 .    from algorithm  [ alg : reg_err_free ]",
    ", we can derive the equivalent storage parameters for each symbol block of size @xmath186 : @xmath187 , @xmath188 , @xmath189 , @xmath190 and equation  ( [ eq : msr_tradeoff ] ) of the msr point holds for these parameters .",
    "theorem [ th : msr ] guarantees that algorithm  [ alg : reg_err_free ] can achieve the msr point for data regeneration of the h - msr code .      in hostile network , algorithm [ alg : reg_err_free ]",
    "may not be able to regenerate the failed node due to possible bogus symbols received from the responses .",
    "in fact , even if the replacement node @xmath142 can derive the symbol matrix @xmath191 using algorithm  [ alg : reg_err_free ] , it can not verify the correctness of the result .",
    "there are two modes for the helper nodes to regenerate the contents of a failed storage node in hostile network .",
    "one mode is the detection mode , in which no error has been found in the symbols received from the helper nodes .",
    "once errors are detected , the recovery mode will be used to correct the errors and locate the malicious nodes .      in the detection mode , the replacement node @xmath142 will send requests in the way similar to that of the error - free network in section  [ sec : h - msr - regeneration - error - free ] .",
    "the only difference is that when @xmath192 , @xmath142 sends requests to @xmath193 nodes instead of @xmath194 nodes .",
    "helper nodes will still use the way similar to that of the error - free network in section  [ sec : h - msr - regeneration - error - free ] to send the help symbols .",
    "the regeneration algorithm is described in algorithm  [ alg : reg_with_err_normal ] with the detection probability characterized in theorem  [ th : reg_with_err_normal ] .",
    "@xmath142 regenerates symbols of the failed node @xmath141 in hostile network [ alg : reg_with_err_normal ]    * step n : *    for every @xmath138 and @xmath160 , we can calculate the regenerated symbols which are related to the help symbols @xmath195 from @xmath140 helper nodes .",
    "@xmath196 is the response from the @xmath197 helper node .",
    "if @xmath165 has been modified by the malicious node @xmath107 , we have @xmath198 .",
    "otherwise we have @xmath199 . to detect",
    "whether there are errors , we will calculate symbols from two sets of helper nodes then compare the results .",
    "( without loss of generality , we assume @xmath200 . )    * step 1.1 : * let @xmath201^t$ ] , where the symbols are collected from node @xmath152 to node @xmath202 , solve the equation @xmath203 .",
    "* step 1.2 : * let @xmath204^t$ ] , where the symbols are collected from node @xmath205 to node @xmath140 , solve the equation @xmath206 .",
    "* step 1.3 : * compare @xmath207 with @xmath208 .",
    "if they are the same , compute @xmath209 as described in algorithm  [ alg : reg_err_free ] .",
    "otherwise , errors are detected in the help symbols .",
    "exit the algorithm and switch to recovery regeneration mode .",
    "no error has been detected for the calculating of the regeneration so far .",
    "let @xmath182 be a @xmath92 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath185 .",
    "[ lm : reg_with_err_normal ] suppose @xmath210 are the @xmath211 errors @xmath212 in algorithm  [ alg : reg_with_err_normal ] , @xmath213^t$ ] and @xmath214^t$ ] . when the number of malicious nodes in the @xmath211 helper nodes is less than @xmath211 , the probability that @xmath215 is at most @xmath216 .",
    "since @xmath217 and @xmath218 are full rank matrices , we can get their corresponding inverse matrices .",
    "@xmath219 is equivalent to @xmath220 .",
    "first , we have @xmath221^t.\\ ] ] suppose @xmath222 $ ] , then we have : @xmath223 @xmath224^t   \\nonumber\\\\ & = & \\mathbf{v}_{0,d_l-1,l } \\cdot [ \\eta_0 , \\eta_1 , \\cdots , \\eta_{d_l-1 } ] \\cdot [ e_1 , e_2 , \\cdots , e_{d_l } ] ^t\\\\ & = & [ x_{2,0 } , e_1,\\cdots , e_{d_l-1}]^t.\\nonumber\\end{aligned}\\ ] ]    to calculate @xmath225 , we first derive the expression of @xmath226 .",
    "because @xmath227 are linearly independent , they can be viewed as a set of bases of the @xmath140 dimensional linear space .",
    "so we have @xmath228 where @xmath229 , because any @xmath140 vectors out of @xmath230 are linearly independent . then @xmath231 [ e_1 , e_2 , \\cdots , e_{d_l } ] ^t\\nonumber \\\\ & = & \\sum_{r=1}^{r = d_l } \\zeta_r \\cdot e_r.\\end{aligned}\\ ] ]    if @xmath232 then @xmath233 and @xmath234 .",
    "the number of errors corresponds to the number of malicious nodes .",
    "when only one element of @xmath235 is nonzero , since @xmath236 are all nonzero , equation  ( [ eq : msr_reg_detect ] ) will never hold . in this case , the probability is @xmath152 .",
    "when there are more than one nonzero elements , it means there are more than one malicious nodes . if the number of malicious nodes is less than @xmath211 , they will not be able to collude to solve the coefficients @xmath237 in  ( [ eqn : mali_solve_coe ] ) .",
    "the probability that equation  ( [ eq : msr_reg_detect ] ) holds will be @xmath216 .",
    "[ th : reg_with_err_normal ] when the number of malicious nodes in the @xmath211 helper nodes of algorithm  [ alg : reg_with_err_normal ] is less than @xmath211 , the probability for the bogus symbols sent from the malicious nodes to be detected is at least @xmath238 .",
    "since @xmath217 and @xmath218 are full rank matrices , @xmath239 can be calculated by ( for convenience , use @xmath240 to represent @xmath241 ) : @xmath242^t \\nonumber \\\\ & = & \\mathbf{x } +   \\hat{\\mathbf{x}}_1.\\end{aligned}\\ ] ]    @xmath243 can be calculated the same way : @xmath244^t    = \\mathbf{x } +   \\hat{\\mathbf{x}}_2.\\end{aligned}\\ ] ] if @xmath219 , algorithm  [ alg : reg_with_err_normal ] will fail to detect the errors .",
    "so we will focus on the relationship between @xmath245 and @xmath246 .",
    "according to lemma  [ lm : reg_with_err_normal ] , when the number of malicious nodes in the @xmath211 helper nodes is less than @xmath211 , the probability that @xmath219 is at most @xmath216 .",
    "so the probability that @xmath247 , equivalently the detection probability , is at least @xmath248 .",
    "once the replacement node @xmath142 detects errors using algorithm  [ alg : reg_with_err_normal ] , it will send integer @xmath249 to all the other @xmath250 nodes in the network requesting help symbols .",
    "helper node @xmath107 will send help symbols similar to section  [ sec : h - msr - regeneration - error - free ] .",
    "@xmath142 can regenerate symbols using algorithm  [ alg : reg_with_err_recovery ] .",
    "@xmath142 regenerates symbols of the failed node @xmath141 in hostile network [ alg : reg_with_err_recovery ]    * step n : *    for every @xmath251 in descending order and @xmath160 in ascending order , we can regenerate the symbols when the errors in the received help symbols @xmath195 from @xmath250 helper nodes can be corrected . without loss of generality , we assume @xmath252 .",
    "* step 1.1 : * let @xmath253^t$ ] . since @xmath254",
    ", @xmath255 can be viewed as an mds code with parameters @xmath256 .    * step 1.2 : * substitute @xmath195 in @xmath257 with the symbol @xmath258 representing an erasure if node @xmath107 has been detected to be corrupted in the previous loops ( previous values of @xmath259 ) .",
    "* step 1.3 : * if the number of erasures in @xmath257 is larger than @xmath260 , then the number of errors have exceeded the error correction capability .",
    "so here we will flag the decoding failure and exit the algorithm .",
    "* step 1.4 : * since the number of errors is within the error correction capability of the mds code , decode @xmath257 to @xmath261 and solve @xmath262 .",
    "* step 1.5 : * if the @xmath197 position symbols of @xmath263 and @xmath257 are different , mark node @xmath107 as corrupted .",
    "* step 1.6 : * compute @xmath264 as described in algorithm [ alg : reg_err_free ] .",
    "let @xmath182 be a @xmath92 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath185 .    for data regeneration described in algorithm  [ alg : reg_with_err_recovery ]",
    ", we have the following theorem :    [ thm : reg_with_err_recovery ] for data regeneration , the number of errors that the h - msr code can correct is @xmath265    h - msr code can be viewed as @xmath24 mds codes with parameters ( @xmath266 ) , @xmath267 .",
    "since @xmath268 and @xmath269 is strictly decreasing , we can choose the sequence @xmath270 to be strictly decreasing .",
    "so @xmath140 is also strictly decreasing . for the @xmath24 mds codes ,",
    "the minimum distance of the ( @xmath271 ) code is the largest . in algorithm  [ alg :",
    "reg_with_err_recovery ] , this code is decoded first and it can correct up to @xmath272 errors , where @xmath273 is the floor function of @xmath274 .",
    "then the code @xmath275 , will be decoded sequentially .",
    "the ( @xmath266 ) code can correct at most @xmath276 errors when @xmath277 . thus , the total numbers errors that the h - msr code can correct is @xmath278 .",
    "in this section , we will first discuss reconstruction of the h - msr code in error - free network .",
    "then we will discuss reconstruction of the h - msr code when there are corrupted nodes in the network .",
    "the main idea of the reconstruction algorithms is to reconstruct @xmath137 , @xmath138 , by downloading help symbols from @xmath279 nodes , where @xmath280 is used to represent the reconstruction parameter @xmath1 for @xmath137 in the h - msr code reconstruction .",
    "we devise algorithm  [ alg : recon_err_free ] in the network for the data collector dc to reconstruct the original file . for convenience ,",
    "we suppose @xmath281 .",
    "first , dc will send requests to the storage nodes for reconstruction : dc sends integer @xmath149 to @xmath282 helper nodes , to which dc has not sent requests before , for every @xmath149 from @xmath151 to @xmath152 in descending order . upon receiving the request integer @xmath149 ,",
    "node @xmath107 will calculate and send symbols as follows : first node @xmath107 will calculate @xmath283 to remove the coefficient matrix @xmath108 from the codeword matrix .",
    "since the @xmath154 row of @xmath284 corresponds to the symbols related to @xmath137 , for @xmath156 , node @xmath107 will send out the @xmath154 row of @xmath284 : @xmath285 . here",
    "@xmath149 indicates that dc is requesting symbols of @xmath285 , @xmath156 , calculated by @xmath286^t$ ] .    since @xmath287 for @xmath168 , for efficiency consideration",
    ", only @xmath288 helper nodes need to send out symbols of @xmath285 , @xmath138 , calculated by @xmath170^t$ ] .",
    "then @xmath282 nodes only need to send out symbols of @xmath285 , @xmath156 , calculated by @xmath172^t$ ] for @xmath173 . in this way ,",
    "the total number of helper nodes that send out symbols of @xmath285 calculated by @xmath137 is @xmath289 .",
    "when dc receives all the requested symbols , it can reconstruct the original file using the following algorithm :    dc reconstructs the original file [ alg : recon_err_free ]    * step n : *    for every @xmath138 , divide the response symbol vector @xmath285 from the @xmath197 node into @xmath157 equal row vectors : @xmath290 $ ] , @xmath291 .    for every @xmath138 and @xmath160",
    ", dc reconstructs the matrices related to the original file :    * step 2.1 : * let @xmath292^t$ ] , we have the equation : @xmath293 according to the encoding algorithm .",
    "* step 2.2 : * dc reconstructs @xmath179 using techniques similar to @xcite .",
    "dc reconstructs the original file from all the matrices @xmath179 , @xmath138 and @xmath160 .",
    "similar to the regeneration algorithms , the reconstruction algorithms in error - free network do not work in hostile network .",
    "even if the data collecter can calculate the symbol matrices @xmath46 using algorithm  [ alg : recon_err_free ] , it can not verify whether the result is correct or not .",
    "there are two modes for the original file to be reconstructed in hostile network .",
    "one mode is the detection mode , in which no error has been found in the symbols received from the storage nodes .",
    "once errors are detected in the detection mode , the recovery mode will be used to correct the errors and locate the malicious nodes .      in the detection mode",
    ", dc will send requests in the way similar to that for the error - free network in section  [ sec : h - msr - reconstruct - error - free ] .",
    "the only difference is that when @xmath192 , dc will send requests to @xmath294 nodes instead of @xmath295 nodes .",
    "storage nodes will still use the way similar to that for the error - free network in section  [ sec : h - msr - reconstruct - error - free ] to send symbols .",
    "the reconstruction algorithm is described in algorithm  [ alg : recon_with_err_normal ] with the detection probability described in theorem  [ th : recon_with_err_normal ] .",
    "dc reconstructs the original file in hostile network [ alg : recon_with_err_normal ]    * step n : *    for every @xmath138 , we can divide the symbol vector @xmath296 into @xmath157 equal row vectors : @xmath297 $ ] .",
    "@xmath298 is the response from the @xmath197 storage node .",
    "if @xmath285 has been modified by the malicious node @xmath107 , we have @xmath299 . to detect whether there are errors",
    ", we will reconstruct the original file from two sets of storage nodes then compare the results .",
    "( without loss of generality , we assume @xmath300 . )    for every @xmath138 and @xmath160 , dc can reconstruct the matrices related to the original file :    * step 2.1 : * let @xmath301^t$ ] .",
    "* step 2.2 : * let @xmath302^t$ ] , which are the symbols collected from node @xmath152 to node @xmath303 , then we have @xmath304",
    ". solve @xmath305 using the method same to algorithm  [ alg : recon_err_free ] .",
    "* step 2.3 : * let @xmath306^t$ ] , which are the symbols collected from node @xmath152 to node @xmath307 except node @xmath270 , and @xmath308 , then we have @xmath309",
    ". solve @xmath310 using the method same to algorithm  [ alg : recon_err_free ] .",
    "* step 2.4 : * compare @xmath311 $ ] with @xmath312 $ ] .",
    "if they are the same , let @xmath313 = [ s_1,t_1]$ ] .",
    "otherwise , errors are detected in the received symbols .",
    "exit the algorithm and switch to recovery reconstruction mode .",
    "no error has been detected for the calculating of the reconstruction so far .",
    "so dc can reconstruct the original file from all the matrices @xmath179 , @xmath138 and @xmath160 .",
    "[ th : recon_with_err_normal ] when the number of malicious nodes in the @xmath314 nodes of algorithm  [ alg : recon_with_err_normal ] is less than @xmath314 , the probability for the bogus symbols sent from the malicious nodes to be detected is at least @xmath315 .",
    "we arrange this proof as follows .",
    "we will first study the requirements for @xmath316 in algorithm  [ alg : recon_with_err_normal ] which will lead to the failure of the algorithm when there are bogus symbols .",
    "then we will study the corresponding failure probabilities depending on different values of @xmath317 of the matrix @xmath318 defined in section  [ sec : h - msr ] .",
    "for convenience we write @xmath319 as @xmath320 in the proof .",
    "@xmath321^{\\alpha_l}}$ ] for @xmath322 .",
    "we also write @xmath323 $ ] , where @xmath324 and @xmath325 represents @xmath326 which is the @xmath197 row of the encoding matrix @xmath164 defined in section  [ sec : h - msr].@xmath327    [ [ step-1.-derive - the - requirements ] ] step 1 .",
    "derive the requirements + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for @xmath328 in algorithm  [ alg : recon_with_err_normal ] , we have : @xmath329 where @xmath330 , @xmath331 .",
    "suppose @xmath332 , we can write equation  ( [ eq : recon_raw ] ) as : @xmath333 it is easy to see that @xmath334 and @xmath335 are symmetric , so we have @xmath336 where @xmath337 are the elements in the @xmath197 row , @xmath338 column of @xmath339 respectively .",
    "solve equation  ( [ eq : recon ] ) for all the @xmath340 ( @xmath341 ) , we can get the corresponding @xmath342 . because the structure of @xmath334 and @xmath335 are the same",
    ", we will only focus on @xmath334 ( corresponding to @xmath343 ) in the proof .",
    "the calculation for @xmath335 ( corresponding to @xmath344 ) is the same .",
    "@xmath345 = c_1.\\ ] ] so the elements of the @xmath197 row of @xmath334 ( except the element in the diagonal position ) can be written as : @xmath346 = [ c_{1,i,0 } , \\cdots , c_{1,i , i-1 } , c_{1,i , i+1 } , \\cdots , c_{1,i,\\alpha_l } ] .",
    "\\end{matrix}\\ ] ]    let @xmath347 , then @xmath348 is an @xmath349 full rank matrix , and we can derive @xmath343 from @xmath350[\\mu_1^t , \\mu_2^t,\\cdots , \\mu_{\\alpha_l}^t]^{-1}\\\\ [ c_{1,1,0 } , c_{1,1,2},\\cdots , c_{1,1,\\alpha_l}][\\mu_0^t , \\mu_2^t,\\cdots , \\mu_{\\alpha_l}^t]^{-1}\\\\ \\cdots \\\\ [ c_{1,\\alpha_l-1,0 } , c_{1,\\alpha_l-1,1},\\cdots , c_{1,\\alpha_l-1,\\alpha_l}][\\mu_0^t , \\mu_1^t,\\cdots , \\mu_{\\alpha_l}^t]^{-1}\\\\ \\end{bmatrix}.\\ ] ]    for @xmath351 in algorithm  [ alg : recon_with_err_normal ] , we can get @xmath352 the same way . if @xmath353 , algorithm  [ alg : recon_with_err_normal ] will fail to detect the errors .",
    "this will happen if all the rows of @xmath354 and @xmath355 are the same .",
    "so we will focus on the @xmath197 row of @xmath354 and @xmath355 .",
    "[ [ step-2.-calculate - the - failure - probabilities ] ] step 2 .",
    "calculate the failure probabilities + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    depending on the values of @xmath317 , we discuss two cases :    \\(a ) if none of the @xmath317 ( @xmath356 ) equals to 0 , we can solve @xmath357 in equation  ( [ eq : recon ] ) :    @xmath358    in equation  ( [ eq : solve_c ] ) , @xmath359 represents the original solution without errors , while @xmath360 represents the impact of the errors .",
    "so the @xmath197 row of @xmath354 can be written as : @xmath361\\cdot\\pi_{1,i}^{-1 } \\nonumber \\\\ & = & [ n_{1,i,0},\\cdots , n_{1,i , i-1},n_{1,i , i+1},\\cdots , n_{1,i,\\alpha_l}]\\cdot\\pi_{1,i}^{-1 } \\nonumber \\\\ & & + [ q_{1,i,0},\\cdots , q_{1,i , i-1},q_{1,i , i+1},\\cdots , q_{1,i,\\alpha_l}]\\cdot\\pi_{1,i}^{-1 }   \\label{eq : solve_c_nom_plus_err } \\\\ & = & \\xi_i + \\delta_{1,i},\\nonumber\\end{aligned}\\ ] ] where @xmath362 $ ] .",
    "@xmath363 corresponds to the part independent of the errors .",
    "@xmath364 is the error part and can be further expanded as : @xmath365 \\cdot \\pi_{1,i}^{-1 } \\nonumber\\\\ & & - \\left[\\frac{\\mathbf { e}_0 \\cdot \\mu_i^t}{\\lambda_0},\\cdots , \\frac{\\mathbf { e}_{i-1 } \\cdot \\mu_i^t}{\\lambda_{i-1}},\\frac{\\mathbf { e}_{i+1 } \\cdot \\mu_i^t}{\\lambda_{i+1}},\\cdots , \\frac{\\mathbf { e}_{\\alpha_l } \\cdot \\mu_i^t}{\\lambda_{\\alpha_l}}\\right ] \\cdot \\pi_{1,i}^{-1}. \\label{eq : solve_c_err}\\end{aligned}\\ ] ] the first part of equation  ( [ eq : solve_c_err ] ) can be reduced as follows : @xmath366 \\cdot \\pi_{1,i}^{-1 } \\nonumber\\\\ & = & \\frac{\\mathbf { e}_i}{\\lambda_i } \\cdot \\left[\\mu_0^t,\\cdots,\\mu_{i-1}^t , \\mu_{i+1}^t,\\cdots , \\mu_{\\alpha_l}^t\\right ] \\cdot \\pi_{1,i}^{-1 } \\label{eq : solve_c_err_1st_part}\\\\ & = & \\frac{\\mathbf { e}_i}{\\lambda_i}. \\nonumber\\end{aligned}\\ ] ] so we have : @xmath367 \\cdot \\pi_{1,i}^{-1 } \\nonumber \\\\ & = & \\frac{\\mathbf { e}_i}{\\lambda_i } - \\rho_{1,i}.\\end{aligned}\\ ] ]    for @xmath351 in algorithm  [ alg : recon_with_err_normal ] where @xmath368 , we can derive @xmath369 , then @xmath355 the same way .",
    "the @xmath197 row of @xmath355 can be written as : @xmath370 where @xmath371\\cdot\\pi_{2,i}^{-1}$ ] , @xmath372 , @xmath373 $ ] .    because @xmath374 is a full rank matrix , @xmath375 is equivalent to @xmath376 .",
    "similar to the proof of lemma  [ lm : reg_with_err_normal ] , suppose @xmath377 , we have @xmath378 .",
    "so @xmath379,\\\\ \\rho_{2,i }   \\cdot   \\pi_{1,i }   & = & \\left[\\cdots , \\frac{\\mathbf { e}_{i-1 } \\cdot   \\mu_i^t}{\\lambda_{i-1}},\\frac{\\mathbf { e}_{i+1 }   \\cdot \\mu_i^t}{\\lambda_{i+1}},\\cdots , \\frac{\\mathbf { e}_{\\alpha_l-1 }   \\cdot   \\mu_i^t}{\\lambda_{\\alpha_l-1 } } , x_{2,\\alpha_l}\\right].\\end{aligned}\\ ] ]    because @xmath380 are linearly independent , they can be viewed as a set of bases of the @xmath270 dimensional linear space .",
    "so we have @xmath381 thus @xmath382 \\cdot \\pi_{2,i}^{-1 }   \\cdot   \\left(\\sum_{r=0,r \\neq i,\\alpha_l}^{r=\\alpha_l + 1 } \\zeta_r   \\cdot   \\mu_r^t\\right ) \\nonumber \\\\ & = & \\left(\\sum_{r=0,r \\neq i,\\alpha_l}^{r=\\alpha_l + 1 } \\zeta_r   \\cdot \\frac{\\mathbf{e}_r   \\cdot   \\mu_i^t}{\\lambda_r}\\right).\\end{aligned}\\ ] ] if @xmath383 @xmath384 and @xmath385 will be equal , so are @xmath354 and @xmath355 .",
    "therefore , algorithm  [ alg : recon_with_err_normal ] will fail .    for the error @xmath386 , the following equation holds : @xmath387 = [ \\hat{e}_{i,0 } , \\hat{e}_{i,1 } , \\cdots , \\hat{e}_{i,\\alpha_l - 1 } ]",
    "= \\hat{\\mathbf{e}}_i.\\ ] ] because @xmath388 $ ] is a full rank matrix , there is a one - to - one mapping between @xmath389 and @xmath390 .",
    "equation  ( [ eq : msr_recon_detect ] ) can be written as : @xmath391 when the number of malicious nodes in the @xmath392 nodes is less than @xmath392 , the malicious nodes can collude to satisfy equation  ( [ eq : msr_recon_detect_number ] ) for at most one particular @xmath107 .",
    "so the probability that equation  ( [ eq : msr_recon_detect_number ] ) holds is @xmath216 for at least @xmath393 out of @xmath270 @xmath394 between @xmath152 and @xmath393 .",
    "if we consider equation  ( [ eq : msr_recon_detect_number ] ) for all the @xmath394 simultaneously , the probability will be at most @xmath395 . as discussed before , the probability for @xmath396 will be at most @xmath395 . in this case",
    ", the detection probability is at least @xmath397 .",
    "\\(b ) if one of the @xmath317 ( @xmath356 ) equals to @xmath152 , we can assume @xmath398 without loss of generality .",
    "when @xmath399 , the solution for equation  ( [ eq : recon ] ) is : @xmath400 similar to equations  ( [ eq : solve_c_nom_plus_err ] ) , ( [ eq : solve_c_err ] ) and ( [ eq : solve_c_err_1st_part ] ) , we have @xmath401 . for @xmath351 , it is easy to see that @xmath402 .",
    "so the first rows of @xmath354 and @xmath355 are the same no matter what the error vector @xmath403 is .",
    "when @xmath404 , the solution for equation  ( [ eq : recon ] ) is : @xmath405 where @xmath406 is a zero row vector .",
    "when @xmath407 , the solution has the same expression as equation  ( [ eq : solve_c ] ) . in this case , for the @xmath408 row of @xmath354 , equation  ( [ eq : solve_c_err ] ) can be written as : @xmath409 \\cdot \\pi_{1,i}^{-1 } \\nonumber\\\\ & & -\\left[-\\mathbf{e}_0 \\cdot \\mu_i^t,\\cdots , \\frac{\\mathbf { e}_{i-1 } \\cdot \\mu_i^t}{\\lambda_{i-1}},\\frac{\\mathbf { e}_{i+1 } \\cdot \\mu_i^t}{\\lambda_{i+1}},\\cdots , \\frac{\\mathbf { e}_{\\alpha_l } \\cdot \\mu_i^t}{\\lambda_{\\alpha_l}}\\right ] \\cdot \\pi_{1,i}^{-1}. \\label{eq : solve_c_err_case_b}\\end{aligned}\\ ] ] the first part of equation  ( [ eq : solve_c_err_case_b ] ) can be divided into two parts : @xmath410 \\cdot \\pi_{1,i}^{-1 } -   \\left[\\frac{\\mathbf{e}_i \\cdot \\mu_0^t}{\\lambda_i},\\mathbf{0},\\cdots,\\mathbf{0 } \\right ]   \\cdot   \\pi_{1,i}^{-1}\\nonumber \\\\ & = & \\frac{\\mathbf { e}_i}{\\lambda_i }   -   \\frac{\\mathbf { e}_i}{\\lambda_i } \\cdot   [ \\mu_0^t , \\mathbf { 0},\\cdots,\\mathbf { 0}]\\cdot \\pi_{1,i}^{-1}.\\end{aligned}\\ ] ] so equation  ( [ eq : solve_c_err_case_b ] ) can be further written as : @xmath411 \\cdot \\pi_{1,i}^{-1 } \\nonumber \\\\ & = & \\frac{\\mathbf { e}_i}{\\lambda_i } - \\rho_{1,i}.\\end{aligned}\\ ] ]    by employing the same derivation in case  ( a ) , for @xmath412 , @xmath384 and @xmath385 will be equal if @xmath413 when the number of malicious nodes in the @xmath314 nodes is less than @xmath314 , similar to case  ( a ) , the probability that equation  ( [ eq : msr_recon_detect_number_case_b ] ) holds is @xmath216 for at least @xmath414 out of @xmath393 @xmath394 between @xmath205 and @xmath393 .",
    "if we consider equation  ( [ eq : msr_recon_detect_number_case_b ] ) for all the @xmath394 simultaneously , the probability will be at most @xmath415 . here",
    "the probability for @xmath396 will be at most @xmath416 . in this case",
    ", the detection probability is @xmath315 .    combining both cases ,",
    "the detection probability is at least @xmath315 .",
    "once dc detects errors using algorithm  [ alg : recon_with_err_normal ] , it will send integer @xmath249 to all the @xmath72 nodes in the network requesting symbols .",
    "storage nodes will still use the way similar to that of the error - free network in section  [ sec : h - msr - reconstruct - error - free ] to send symbols .",
    "the reconstruct procedures are described in algorithm  [ alg : recon_with_err_recovery ] .",
    "dc reconstructs the original file in hostile network [ alg : recon_with_err_recovery ]    * step n : *    for every @xmath138 , we divide the symbol vector @xmath296 into @xmath157 equal row vectors : @xmath297 $ ] .",
    "( without loss of generality , we assume @xmath79 . )    for every @xmath251 in descending order and @xmath160 in ascending order , dc can reconstruct the matrices related to the original file when the errors in the received symbol vectors @xmath417 from @xmath72 storage nodes can be corrected :    * step 2.1 : * let @xmath418^t$ ] .",
    "* step 2.2 : * if the number of corrupted nodes detected is larger than @xmath419 , then the number of errors have exceeded the error correction capability .",
    "we will flag the decoding failure and exit the algorithm .",
    "* step 2.3 : * since the number of errors is within the error correction capability of the h - msr code , substitute @xmath417 in @xmath420 with the symbol @xmath258 representing an erasure vector if node @xmath107 has been detected to be corrupted in the previous loops ( previous values of @xmath259 ) .",
    "* step 2.4 : * solve @xmath179 using the method described in section [ sec : rec - st ] . if symbols from node @xmath107 are detected to be erroneous during the calculation , mark node @xmath107 as corrupted .",
    "dc reconstructs the original file from all the matrices @xmath179 , @xmath138 and @xmath160 .    for data reconstruction described in algorithm  [ alg : recon_with_err_recovery ]",
    ", we have the following theorem :    [ thm : recon_with_err_recovery ] for data reconstruction , the number of errors that the h - msr code can correct is @xmath421    similar to the proof of theorem  [ thm : reg_with_err_recovery ] in data regeneration , for data reconstruction algorithm  [ alg : recon_with_err_recovery ] , h - msr code can be viewed as @xmath24 mds codes with parameters @xmath422 . the decoding for the reconstruction",
    "is performed from the code with the largest minimum distance to the code with the smallest minimum distance as in the data regeneration case .",
    "so here we have similar result as in equation  ( [ eq : num_of_errs_msr_recovery ] ) .",
    "when there are bogus symbols @xmath195 sent by the corrupted nodes for certain @xmath259 , we can recover the matrices @xmath423 as follows :    for @xmath420 in algorithm  [ alg : recon_with_err_recovery ] , we have @xmath424 , and @xmath425 where @xmath323 $ ] , @xmath426 and @xmath325 represents @xmath326 which is the @xmath197 row of the encoding matrix @xmath164 in the proof of theorem  [ th : msr ] .",
    "let @xmath427 , @xmath428 , and @xmath429 , then @xmath430 since @xmath431 are both symmetric , we can solve the non - diagonal elements of them as follows : @xmath432 because matrices @xmath433 and @xmath434 have the same structure , here we only focus on @xmath433 ( corresponding to @xmath435 ) .",
    "it is straightforward to see that if node @xmath107 is malicious and there are errors in the @xmath197 row of @xmath420 , there will be errors in the @xmath197 row of @xmath436 .",
    "furthermore , there will be errors in the @xmath197 row and @xmath197 column of @xmath433 .",
    "define @xmath437 , we have @xmath438 here we can view each column of @xmath433 as a @xmath439 mds code because @xmath440 is a vandermonde matrix .",
    "the length of the code is @xmath250 since the diagonal elements of @xmath433 is unknown .",
    "suppose node @xmath149 is uncorrupted .",
    "if the number of erasures @xmath441 ( corresponding to the previously detected corrupted nodes ) and the number of the corrupted nodes @xmath35 that have not been detected satisfy : @xmath442 then the @xmath338 column of @xmath433 can be recovered and the error locations ( corresponding to the corrupted nodes ) can be pinpointed .",
    "the non - diagonal elements of @xmath433 can be recovered .",
    "so dc can reconstruct @xmath443 using the method similar to @xcite .",
    "for @xmath444 , the recovering process is similar .",
    "in this section , we will analyze the h - mbr code based on the mbr point with @xmath445 . according to equation  ( [ eq : mbr_tradeoff ] ) , we have @xmath446 .",
    "let @xmath447 be a strictly decreasing integer sequence satisfying @xmath448 .",
    "the least common multiple of @xmath447 is @xmath44 .",
    "let @xmath449 be a integer sequence satisfying @xmath450 .",
    "suppose the data contains @xmath451 message symbols from the finite field @xmath17 .",
    "in practice , if the size of the actual data is larger than @xmath9 symbols , we can fragment it into blocks of size @xmath9 and process each block individually .",
    "we arrange the @xmath9 symbols into matrix @xmath452 as below : @xmath453 where @xmath454\\ ] ] and @xmath455 @xmath456 is a symmetric matrix of size @xmath457 with the upper - triangular entries filled by data symbols .",
    "@xmath125 is a @xmath458 matrix .",
    "thus @xmath459 contains @xmath460 symbols , @xmath66 contains @xmath461 symbols and @xmath452 contains @xmath9 symbols .    for distributed storage ,",
    "we encode @xmath452 using algorithm  [ alg : enc_mbr ] :    encoding h - mbr code [ alg : enc_mbr ]    * step n : *    first we encode the data matrices @xmath452 defined above using a hermitian code @xmath31 over @xmath17 with parameters @xmath84 and @xmath85 .",
    "the @xmath86 codeword matrix can be written as @xmath462 .",
    "then we divide the codeword matrix @xmath90 into @xmath72 submatrices @xmath91 of the size @xmath183 and store one submatrix in each of the @xmath72 storage nodes as shown in fig .",
    "[ fig : store_codeword ] .",
    "then we have the following theorem :    [ th : mbr ] by processing the data symbols using algorithm  [ alg : enc_mbr ] , we can achieve the mbr point in distributed storage .",
    "similar to the proof of theorem  [ alg : enc ] , we can get the following equation considering all the columns of @xmath463 : @xmath464 where @xmath465 $ ] , @xmath70 , @xmath117 .",
    "@xmath466 corresponds to the @xmath119 column of the submatrix @xmath459 and each element of @xmath467^t$ ] can be derived from a distinct storage node .",
    "@xmath468 is defined in equation  ( [ eq : phi ] ) .",
    "next we will study the optimality of the code in the sense of the mbr point .",
    "for @xmath469 , @xmath459 is symmetric and satisfies the requirements for mbr point according to  @xcite with parameters @xmath470 . by encoding @xmath452 using @xmath463 and distributing @xmath91 into @xmath72 storage nodes , each row of the matrix @xmath471 , can be derived in a corresponding storage node . because @xmath472 achieves the mbr point ,",
    "data related to matrices @xmath473 , can be regenerated at the mbr point .",
    "therefore , algorithm  [ alg : enc_mbr ] can achieve the mbr point .",
    "in this section , we will first discuss regeneration of the h - mbr code in error - free network . then we will discuss regeneration in hostile network .",
    "let @xmath474^t$ ] , then @xmath475^t,$ ] for every column @xmath135 of @xmath136 .",
    "the main idea of the regeneration algorithms is similar to that of the h - msr code : regenerate @xmath476 , by downloading help symbols from @xmath477 nodes , where @xmath140 is the regeneration parameter @xmath6 for @xmath478 in the h - mbr code regeneration .",
    "suppose node @xmath141 fails , we use algorithm  [ alg : reg_err_free_mbr ] to regenerate the exact h - mbr code symbols of node @xmath141 . for convenience ,",
    "we suppose @xmath479 and define @xmath480 where @xmath481 , is the @xmath146 row of @xmath164 .",
    "similar to the h - msr code , replacement node @xmath142 will send requests to helper nodes in the way same to that in section  [ sec : h - msr - regeneration - error - free ] . upon receiving the request integer @xmath149 ,",
    "helper node @xmath107 will calculate and send the help symbols similar to that of section  [ sec : h - msr - regeneration - error - free ] .",
    "when the replacement node @xmath142 receives all the requested symbols , it can regenerate the symbols stored in the failed node @xmath141 using the following algorithm :    @xmath142 regenerates symbols of the failed node @xmath141 [ alg : reg_err_free_mbr ]    * step n : *    for every @xmath138 and @xmath160 , we can calculate the regenerated symbols which are related to the help symbols @xmath165 from @xmath140 helper nodes : ( without loss of generality , we assume @xmath175 . )    * step 1.1 : * let @xmath176^t$ ] , solve the equation : @xmath482 .",
    "* step 1.2 : * since @xmath483 and @xmath484 is symmetric , we can calculate @xmath485 .",
    "let @xmath182 be a @xmath92 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath486 .    for algorithm  [ alg : reg_err_free_mbr ]",
    "we can derive the equivalent storage parameters for each symbol block of size @xmath487 and equation  ( [ eq : mbr_tradeoff ] ) of the mbr point holds for these parameters .",
    "theorem [ th : mbr ] guarantees that algorithm  [ alg : reg_err_free_mbr ] can achieve the mbr point for data regeneration of the h - mbr code",
    ".      in hostile network , algorithm [ alg : reg_err_free_mbr ] may be unable to regenerate the failed node due to the possible bogus symbols received from the responses .",
    "in fact , even if the replacement node @xmath142 can derive the symbol matrix @xmath191 using algorithm  [ alg : reg_err_free_mbr ] , it can not verify the correctness of the result .",
    "similar to the h - msr code , there are two modes for the helper nodes to regenerate the h - mbr code of a failed storage node in hostile network .",
    "one mode is the detection mode , in which no error has been found in the symbols received from the helper nodes .",
    "once errors are detected , the recovery mode will be used to correct the errors and locate the malicious nodes .      in the detection mode ,",
    "the replacement node @xmath142 will send requests in the way similar to that of the error - free network in section  [ sec : h - mbr - regeneration - error - free ] .",
    "the only difference is that when @xmath192 , @xmath142 sends requests to @xmath193 nodes instead of @xmath194 nodes .",
    "helper nodes will still use the way similar to that of the error - free network in section  [ sec : h - mbr - regeneration - error - free ] to send the help symbols .",
    "the regeneration algorithm is described in algorithm  [ alg : reg_with_err_normal_mbr ] with the detection probability characterized in theorem  [ th : reg_with_err_normal_mbr ] .",
    "@xmath142 regenerates symbols of the failed node @xmath141 in hostile network [ alg : reg_with_err_normal_mbr ]    * step n : *    for every @xmath138 and @xmath160 , we can calculate the regenerated symbols which are related to the help symbols @xmath195 from @xmath140 helper nodes .",
    "@xmath196 is the response from the @xmath197 helper node .",
    "if @xmath165 has been modified by the malicious node @xmath107 , we have @xmath198 . to detect",
    "whether there are errors , we will calculate symbols from two sets of helper nodes then compare the results .",
    "( without loss of generality , we assume @xmath200 . )    * step 1.1 : * let @xmath201^t$ ] , where the symbols are collected from node @xmath152 to node @xmath202 , solve the equation @xmath488 .",
    "* step 1.2 : * let @xmath204^t$ ] , where the symbols are collected from node @xmath205 to node @xmath140 , solve the equation @xmath489 .    *",
    "step 1.3 : * if @xmath490 , compute @xmath491 as described in algorithm [ alg : reg_err_free_mbr ] .",
    "otherwise , errors are detected in the help symbols .",
    "exit the algorithm and switch to recovery regeneration mode .",
    "no error has been detected for the calculating of the regeneration so far .",
    "let @xmath182 be a @xmath92 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath486 .",
    "[ th : reg_with_err_normal_mbr ] when the number of malicious nodes in the @xmath211 helper nodes of algorithm  [ alg : reg_with_err_normal_mbr ] is less than @xmath211 , the probability for the bogus symbols sent from the malicious nodes to be detected is at least @xmath238 .",
    "similar to the proof of theorem  [ th : reg_with_err_normal ] , we can write @xmath492^t    = \\mathbf{x } +   \\hat{\\mathbf{x}}_1 , \\\\",
    "\\mathbf{x}_2   & = & \\mathbf{x } + \\mathbf{w}_{1,d_l , l}^{-1 }   \\cdot [ e_1 , \\cdots , e_{d_l } ] ^t    = \\mathbf{x } +   \\hat{\\mathbf{x}}_2.\\end{aligned}\\ ] ]    since @xmath493 are full rank matrices like the matrices @xmath494 in the proof of lemma  [ lm : reg_with_err_normal ] and any @xmath140 vectors out of @xmath495 are linearly independent , the rest of this proof is similar to that of lemma  [ lm : reg_with_err_normal ] . when the number of malicious nodes in the @xmath211 helper nodes is less than @xmath211 , the probability for @xmath219 is at most @xmath216 . therefore , the detection probability is at least @xmath238 .",
    "once the replacement node @xmath142 detects errors using algorithm  [ alg : reg_with_err_normal_mbr ] , it will send integer @xmath249 to all the other @xmath250 nodes in the network requesting help symbols .",
    "helper nodes will still use the way similar to that of the error - free network in section  [ sec : h - mbr - regeneration - error - free ] to send the help symbols .",
    "@xmath142 can regenerate symbols using algorithm  [ alg : reg_with_err_recovery_mbr ] .",
    "@xmath142 regenerates symbols of the failed node @xmath141 in hostile network [ alg : reg_with_err_recovery_mbr ]    * step n : *    for every @xmath251 in descending order and @xmath160 in ascending order , we can regenerate the symbols when the errors in the received help symbols @xmath195 from @xmath250 helper nodes can be corrected . without loss of generality , we assume @xmath252 .",
    "* step 1.1 : * let @xmath253^t$ ] .",
    "since @xmath496 , @xmath255 can be viewed as an mds code with parameters @xmath256 .    * step 1.2 : * substitute @xmath195 in @xmath257 with the symbol @xmath258 representing an erasure if node @xmath107 has been detected to be corrupted in the previous loops ( previous values of @xmath259 ) .",
    "* step 1.3 : * if the number of erasures in @xmath257 is larger than @xmath260 , then the number of errors have exceeded the error correction capability .",
    "we will flag the decoding failure and exit the algorithm .",
    "* step 1.4 : * since the number of errors is within the error correction capability of the mds code , decode @xmath257 to @xmath261 and solve @xmath262 .",
    "* step 1.5 : * if the @xmath197 position symbols of @xmath263 and @xmath257 are different , mark node @xmath107 as corrupted .    *",
    "step 1.6 : * compute @xmath491 as described in algorithm [ alg : reg_err_free_mbr ] .",
    "let @xmath182 be a @xmath92 matrix with the @xmath119 row defined as @xmath184 , 0 \\leq l \\leq q-1 $ ] .",
    "calculate the regenerated symbols of the failed node @xmath141 : @xmath486 .    for data regeneration described in algorithm  [ alg : reg_with_err_recovery_mbr ] , since the structures of the underlying hermitian codes of h - msr code and h - mbr code with the same code rates are the same , we have similar result as that in theorem  [ thm : reg_with_err_recovery ] .",
    "[ thm : reg_with_err_recovery_mbr ] for data regeneration , the number of errors that the h - mbr code can correct is @xmath497",
    "in this section , we will first discuss reconstruction of the h - mbr code in error - free network .",
    "then we will discuss reconstruction when there are corrupted nodes in the network .",
    "the main idea of the reconstruction algorithms is similar to that of the h - msr code : reconstruct @xmath476 , by downloading help symbols from @xmath280 nodes , where @xmath280 represents the reconstruction parameter @xmath1 for @xmath478 in the h - mbr code .",
    "we use algorithm  [ alg : recon_err_free_mbr ] in the network for the data collector dc to reconstruct the original file . for convenience ,",
    "we suppose @xmath498 .",
    "similar to the h - msr code described in section  [ sec : h - msr - reconstruct - error - free ] , dc will send requests to storage nodes . upon receiving the request integer @xmath149 ,",
    "node @xmath107 will calculate and send symbols .",
    "when dc receives all the requested symbols , it can reconstruct the original file using the following algorithm :    dc reconstructs the original file [ alg : recon_err_free_mbr ]    * step n : *    for every @xmath138 , divide the symbol vector @xmath285 into @xmath157 equal row vectors : @xmath499 , @xmath500 $ ] .",
    "( @xmath285 is the response from the @xmath197 node and we assume @xmath291 without loss of generality . )    for every @xmath138 and @xmath160 , dc reconstructs the matrices related to the original file :    * step 2.1 : * let @xmath292^t$ ] , we have the equation : @xmath501 according to the encoding algorithm .    * step 2.2 : * dc reconstructs @xmath484 using techniques similar to that of  @xcite .",
    "dc reconstructs the original file from all the matrices @xmath484 , @xmath138 and @xmath160 .",
    "similar to the h - msr code , the reconstruction algorithms for h - mbr code in error - free network do not work in hostile network .",
    "even if the data collecter can calculate the symbol matrices @xmath452 using algorithm  [ alg : recon_err_free_mbr ] , it can not verify whether the result is correct or not .",
    "there are two modes for the original file to be reconstructed in hostile network .",
    "one mode is the detection mode , in which no error has been found in the symbols received from the storage nodes .",
    "once errors are detected in the detection mode , the recovery mode will be used to correct the errors and locate the malicious nodes .      in the detection mode",
    ", dc will send requests in the way similar to that of the error - free network in section  [ sec : h - mbr - reconstruct - error - free ] .",
    "the only difference is that when @xmath192 , dc will send requests to @xmath294 nodes instead of @xmath295 nodes .",
    "storage nodes will send symbols similar to that of the error - free network in section  [ sec : h - mbr - reconstruct - error - free ] .",
    "the reconstruction algorithm is described in algorithm  [ alg : recon_with_err_normal_mbr ] with the detection probability described in theorem  [ th : recon_with_err_normal_mbr ] .",
    "dc reconstructs the original file in hostile network [ alg : recon_with_err_normal_mbr ]    * step n : *    for every @xmath138 , we can divide the symbol vector @xmath296 into @xmath157 equal row vectors : @xmath297 $ ] .",
    "@xmath298 is the response from the @xmath197 storage node .",
    "if @xmath285 has been modified by the malicious node @xmath107 , we have @xmath299 . to detect whether there are errors",
    ", we will reconstruct the original file from two sets of storage nodes then compare the results .",
    "( without loss of generality , we assume @xmath300 . )    for every @xmath138 and @xmath160 , dc can reconstruct the matrices related to the original file :    * step 2.1 : * let @xmath301^t$ ] .",
    "* step 2.2 : * let @xmath502^t$ ] , which are the symbols collected from node @xmath152 to node @xmath503 , then we have @xmath504 .",
    "solve @xmath505 using the method same to algorithm  [ alg : recon_err_free_mbr ] .",
    "* step 2.3 : * let @xmath506^t$ ] , which are the symbols collected from node @xmath205 to node @xmath280 , then we have @xmath507",
    ". solve @xmath508 using the method same to algorithm  [ alg : recon_err_free_mbr ] .",
    "* step 2.4 : * compare @xmath505 with @xmath508 .",
    "if they are the same , let @xmath509 .",
    "otherwise , errors are detected in the received symbols .",
    "exit the algorithm and switch to recovery reconstruction mode .",
    "no error has been detected for the calculating of the reconstruction so far .",
    "so dc can reconstruct the original file from all the matrices @xmath484 , @xmath138 and @xmath160 .",
    "[ th : recon_with_err_normal_mbr ] when the number of malicious nodes in the @xmath314 nodes of algorithm  [ alg : recon_with_err_normal_mbr ] is less than @xmath314 , the probability for the bogus symbols sent from the malicious nodes to be detected is at least @xmath510 .    for convenience ,",
    "we write @xmath511 as @xmath389 in the proof .",
    "@xmath512^{\\alpha_l}}$ ] for @xmath300 . in algorithm",
    "[ alg : recon_with_err_normal_mbr ] , @xmath513 where @xmath514 .",
    "let @xmath515 $ ] , @xmath516 $ ] and @xmath517 $ ] , where @xmath518 , @xmath519 , @xmath520 are @xmath521 submatrices and @xmath522 , @xmath523 , @xmath524 are @xmath525 submatrices .    according to equation  ( [ eq : mbr_m_matrix ] ) , we have @xmath526 \\nonumber \\\\",
    "& = & [ r_{1,1 } + q_{1,1 } , r_{1,2 } + q_{1,2}].\\end{aligned}\\ ] ] since @xmath518 is a submatrix of a vandermonde matrix , it is a full rank matrix .",
    "so we have @xmath527    for @xmath528 in algorithm  [ alg : recon_with_err_normal_mbr ] , let @xmath529 $ ] , @xmath530 $ ] and @xmath531 $ ] , where @xmath532 , @xmath533 , @xmath534 are @xmath521 submatrices and @xmath535 , @xmath536 , @xmath537 are @xmath538 submatrices .",
    "similarly , we have @xmath539 if @xmath540 and @xmath541 , algorithm  [ alg : recon_with_err_normal_mbr ] will fail to detect the bogus symbols .",
    "so we will focus on @xmath542 and @xmath543 .",
    "suppose @xmath544^t,\\pi_{2,j}=[e_1,\\cdots , e_{k_l}]^t$ ] are the @xmath545 columns of @xmath524 and @xmath536 respectively , where @xmath546 .",
    "since @xmath518 and @xmath534 are vandermonde matrices and have the same relationship as that of between @xmath217 and @xmath218 , similar as the proof of lemma  [ lm : reg_with_err_normal ] , we can prove that when the number of malicious nodes in the @xmath314 nodes is less than @xmath314 , the probability of @xmath547 is at most @xmath216 .",
    "thus the probability for @xmath540 is at most @xmath548 . through the same procedure",
    ", we can derive that the probability of @xmath541 is at most @xmath549 .",
    "the probability for both @xmath541 and @xmath540 is at most @xmath550 .",
    "so the detection probability is at least @xmath551 .",
    "once dc detects errors using algorithm  [ alg : recon_with_err_normal_mbr ] , it will send integer @xmath249 to all the @xmath72 nodes in the network requesting symbols .",
    "storage node @xmath107 will use the way similar to that of the error - free network in section  [ sec : h - mbr - reconstruct - error - free ] to send symbols .",
    "the reconstruct procedures are described in algorithm  [ alg : recon_with_err_recovery_mbr ] .",
    "dc reconstructs the original file in hostile network [ alg : recon_with_err_recovery_mbr ]    * step n : *    for every @xmath138 , divide the symbol vector @xmath296 into @xmath157 equal row vectors : @xmath552 @xmath553 $ ] .",
    "( without loss of generality , we assume @xmath79 . )    for every @xmath251 in descending order and @xmath160 in ascending order , dc reconstructs the matrices related to the original file when the errors in the received symbol vectors @xmath417 from @xmath72 storage nodes can be corrected :    * step 2.1 : * let @xmath418^t$ ] .",
    "* step 2.2 : * if the number of corrupted nodes detected is larger than @xmath419 , then the number of errors have exceeded the error correction capability .",
    "so here we will flag the decoding failure and exit the algorithm .",
    "* step 2.3 : * since the number of errors is within the error correction capability of the h - mbr code , substitute @xmath417 in @xmath420 with the symbol @xmath258 representing an erasure vector if node @xmath107 has been detected to be corrupted in the previous loops ( previous values of @xmath259 ) .",
    "* step 2.4 : * solve @xmath484 using the method in section [ sec : rec - m ] . if symbols from node @xmath107 are detected to be erroneous during the calculation , mark node @xmath107 as corrupted .",
    "dc reconstructs the original file from all the matrices @xmath484 , @xmath138 and @xmath160 .    for data reconstruction described in algorithm  [ alg : recon_with_err_recovery_mbr ]",
    ", since the structures of the underlying hermitian codes of h - msr code and h - mbr code with the same code rates are the same , we have similar result as that in theorem  [ thm : recon_with_err_recovery ] .",
    "[ thm : recon_with_err_recovery_mbr ] for data reconstruction , the number of errors that the h - mbr code can correct is @xmath554      when there are bogus symbols @xmath195 sent by the corrupted nodes for certain @xmath259 , we can recover the matrices @xmath555 as follows :    for @xmath420 in algorithm  [ alg : recon_with_err_recovery_mbr ] , we have @xmath556 , where @xmath557 $ ] , @xmath558 $ ] .",
    "@xmath559 , @xmath560 are @xmath561 submatrices and @xmath562 , @xmath563 are @xmath564 submatrices .    according to equation  ( [ eq : mbr_m_matrix ] ) , we have @xmath565 = [ r_1 ' , r_2'].\\ ] ]    for @xmath566 , we can view each column of @xmath563 as a @xmath567 mds code because @xmath440 is a vandermonde matrix .",
    "if the number of erasures @xmath441 ( corresponding to the previously detected corrupted nodes ) and the number of corrupted nodes @xmath35 that have not been detected satisfy : @xmath568 then all the columns of @xmath569 can be recovered and the error locations ( corresponding to the corrupted nodes ) can be pinpointed .",
    "after @xmath569 has been recovered , we can recover @xmath570 following the same process because @xmath571 .",
    "so dc can reconstruct @xmath555 .",
    "in this section , we analyze the performance of the h - msr code and compare it with the performance of the rs - msr code .",
    "we will first analyze their error correction capability then their complexity .",
    "the comparison results between the h - mbr code and the rs - mbr code are the same since the error correction capability and the complexity of the h - msr code and the h - mbr code are similar while these performance parameters of the rs - msr code and the rs - mbr code are similar .",
    "the rs - msr code in  @xcite can correct up to @xmath35 errors by downloading symbols from @xmath572 nodes .",
    "however , the number of errors may vary in the symbols sent by helper nodes .",
    "when there is no error or the number of errors is far less than @xmath35 , downloading symbols from extra nodes will be a waste of bandwidth .",
    "when the number of errors is larger than @xmath35 , the decoding process will fail without being detected . in this case , the symbols stored in the replacement node will be erroneous .",
    "if this erroneous node becomes a helper node later , the errors will propagate to other nodes .",
    "the h - msr code can detect the erroneous decodings using algorithm  [ alg : reg_with_err_normal ] .",
    "if no error is detected , regeneration of h - msr only needs to download symbols from one more node than the regeneration in error - free network , while the extra cost for the rs - msr code is @xmath573 . if errors are detected in the symbols received from the helper nodes , the h - msr code can correct the errors using algorithm  [ alg : reg_with_err_recovery ] .",
    "moreover , the algorithm can determine whether the decoding is successful , while the rs - msr code is unable to provide such information .",
    "the evaluation result is similar to the data regeneration .",
    "the rs - msr code can correct up to @xmath35 errors with support from @xmath573 additional helper nodes .",
    "the h - msr code is more flexible . for error detection",
    ", it only requires symbols from one additional node using algorithm  [ alg : recon_with_err_normal ] .",
    "the errors can then be corrected using algorithm  [ alg : recon_with_err_recovery ] .",
    "the algorithm can also determine whether the decoding is successful .      for data regeneration described in algorithm  [ alg : reg_with_err_recovery ]",
    ", according to theorem  [ thm : reg_with_err_recovery ] and equation  ( [ eq : num_of_errs_msr_recovery ] ) , the h - msr code can correct @xmath574 errors , while the @xmath575 rs - msr code with the same rate can correct @xmath576 errors .",
    "therefore , we have the following theorem .    for data regeneration , the number of errors that the h - msr code and the rs - msr code can correct satisfy @xmath577 when @xmath578 .    for @xmath579 , we have @xmath580    for @xmath581 , we have @xmath582    when @xmath583 , it is easy to verify that @xmath584 .    when @xmath585 , we can rewrite equation  ( [ eq : min_dist_h ] ) as @xmath586 the gap between @xmath581 and @xmath579 is at least @xmath587",
    "so we have @xmath584 .",
    "suppose @xmath588 and @xmath589 , the hermitian curve is defined by @xmath590 over @xmath591 .",
    "from the previous discussion , we have @xmath592 .",
    "choose @xmath593 .",
    "so @xmath594 .",
    "according to the analysis above , we have @xmath595 , which is larger than @xmath596 .",
    "we also show that the maximum number of malicious nodes from which the errors can be corrected by the h - msr code in fig .",
    "[ fig : comparison ] . here the parameter @xmath24 of the hermitian code increases from 4 to 16 with a step of 2 . in the figure ,",
    "the code rates for the rs - msr code and the h - msr code are the same .",
    "the figure demonstrates that for data regeneration , the h - msr code has better error correction capability than the rs - msr code .        for data reconstruction described in algorithm  [ alg : recon_with_err_recovery ] , according to theorem  [ thm : recon_with_err_recovery ] and equation  ( [ eq : num_of_errs_msr_recovery_recon ] ) , the number of errors that h - msr code can correct is @xmath597 .",
    "similarly , we can conclude that for data reconstruction the h - msr code has better error correction capability than the rs - msr code under the same code rate .      for the complexity of the h - msr code ,",
    "we consider two scenarios .      for the h - msr regeneration , compared with rs - msr code , the h - msr code will slightly increase the complexity of the helper nodes .",
    "for each helper node , the extra operation is a matrix multiplication between @xmath598 and @xmath136 .",
    "the complexity is @xmath599 .",
    "similar to @xcite , for a replacement node , from algorithm  [ alg : reg_err_free ] and algorithm  [ alg : reg_with_err_normal ] , we can derive that the complexity to regenerate symbols for rs - msr is @xmath600 , while the complexity for h - msr is only @xmath601 .",
    "likewise , for algorithm [ alg : reg_with_err_recovery ] , the complexity to recover the h - msr code is @xmath601 , and @xmath600 for rs - msr code .      for the reconstruction , compared with rs - msr code , the additional complexity of the h - msr code for each storage node is @xmath602 , which is @xmath603 .",
    "the computational complexity for dc to reconstruct the data is @xmath601 for the h - msr code and @xmath600 for the rs - msr code .",
    "in this paper , we developed a hermitian code based minimum storage regeneration ( h - msr ) code and a hermitian code based minimum bandwidth regeneration ( h - mbr ) code for distributed storage .",
    "due to the structure of hermitian code , our proposed codes can significantly improve the performance of the regenerating code under malicious attacks .",
    "in particular , these codes can deal with errors beyond the maximum distance separable ( mds ) code .",
    "our theoretical analyses demonstrate that the h - msr / h - mbr codes have lower complexity than the reed - solomon based minimum storage regeneration ( rs - msr ) code and the reed - solomon based minimum bandwidth regeneration ( rs - mbr ) code in both regeneration and reconstruction . as a future research task",
    ", we will further analyze the optimal design of regenerating code based on the hermitian - like codes .",
    "r.  bhagwan , k.  tati , y .- c .",
    "cheng , s.  savage , and g.  m. voelker , `` total recall : system support for automated availability management , '' in _ roc .",
    "design implementation _ , pp .  337350 , 2004 .",
    "k.  rashmi , n.  shah , and p.  kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee transactions on information theory _ , vol .  57 , pp .  52275239 , 2011 .",
    "a.  duminuco and e.  biersack , `` a practical study of regenerating codes for peer - to - peer backup systems , '' in _ distributed computing systems , 2009 .",
    "icdcs 09 .",
    "29th ieee international conference on _ , pp .  376  384 , june 2009 .      y.  wu and a.  g. dimakis , `` reducing repair traffic for erasure coding - based storage via interference alignment , '' in _ ieee international symposium on information theory , 2009 .",
    "isit 2009 .",
    "_ , pp .  22762280 , 2009 .",
    "n.  shah , k.  rashmi , p.  kumar , and k.  ramchandran , `` interference alignment in regenerating codes for distributed storage : necessity and code constructions , '' _ ieee transactions on information theory _",
    "58 , pp .",
    "2134  2158 , 2012 .",
    "s.  pawar , s.  el  rouayheb , and k.  ramchandran , `` securing dynamic distributed storage systems against eavesdropping and adversarial attacks , '' _ ieee transactions on information theory _ , vol .",
    "57 , pp .",
    "6734  6753 , 2011 .",
    "k.  rashmi , n.  shah , k.  ramchandran , and p.  kumar , `` regenerating codes for errors and erasures in distributed storage , '' in _ international symposium on information theory ( isit ) 2012 _ , pp .  12021206 , 2012 ."
  ],
  "abstract_text": [
    "<S> distributed storage plays a crucial role in the current cloud computing framework . after the theoretical bound for distributed storage </S>",
    "<S> was derived by the pioneer work of the regenerating code , reed - solomon code based regenerating codes were developed . </S>",
    "<S> the rs code based minimum storage regeneration code ( rs - msr ) and the minimum bandwidth regeneration code ( rs - mbr ) can achieve theoretical bounds on the msr point and the mbr point respectively in code regeneration . </S>",
    "<S> they can also maintain the mds property in code reconstruction . </S>",
    "<S> however , in the hostile network where the storage nodes can be compromised and the packets can be tampered with , the storage capacity of the network can be significantly affected . in this paper </S>",
    "<S> , we propose a hermitian code based minimum storage regenerating  ( h - msr ) code and a minimum bandwidth regenerating  ( h - mbr ) code . </S>",
    "<S> we first prove that our proposed hermitian code based regenerating codes can achieve the theoretical bounds for msr point and mbr point respectively . </S>",
    "<S> we then propose data regeneration and reconstruction algorithms for the h - msr code and the h - mbr code in both error - free network and hostile network . </S>",
    "<S> theoretical evaluation shows that our proposed schemes can detect the erroneous decodings and correct more errors in hostile network than the rs - msr code and the rs - mbr code with the same code rate . </S>",
    "<S> our analysis also demonstrates that the proposed h - msr and h - mbr codes have lower computational complexity than the rs - msr / rs - mbr codes in both code regeneration and code reconstruction .    </S>",
    "<S> regenerating code , reed - solomon code , error - correction , hermitian code . </S>"
  ]
}