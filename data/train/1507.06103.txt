{
  "article_text": [
    "integrity constraints provide means for ensuring that database evolution does not result in a loss of consistency or in a discrepancy with the intended model of the application domain  @xcite .",
    "a relational database that do not satisfy some of these constraints is said to be inconsistent . in practice",
    "it is not unusual that one has to deal with inconsistent data  @xcite , and when a conjunctive query ( cq ) is posed to an inconsistent database , a natural problem arises that can be formulated as : _ how to deal with inconsistencies to answer the input query in a consistent way ? _",
    "this is a classical problem in database research and different approaches have been proposed in the literature .",
    "one possibility is to clean the database  @xcite and work on one of the possible coherent states ; another possibility is to be tolerant of inconsistencies by leaving intact the database and computing answers that are `` consistent with the integrity constraints ''  @xcite . in this paper",
    ", we adopt the second approach  which has been proposed by under the name of _ consistent query answering _",
    "( cqa )  and focus on the relevant class of _ primary key _ constraints . formally , in our setting : @xmath0 a database @xmath1 is _ inconsistent _ if there are at least two tuples of the same relation that agree on their primary key ; @xmath2 a _ repair _ of @xmath1 is any maximal consistent subset of @xmath1 ; and @xmath3 a tuple @xmath4 of constants is in the _ consistent answer _ to a cq @xmath5 over @xmath1 if and only if , for each repair @xmath6 of @xmath1 , tuple @xmath4 is in the ( classical ) answer to @xmath5 over @xmath6 .",
    "intuitively , the original database is ( virtually ) repaired by applying a minimal number of corrections ( deletion of tuples with the same primary key ) , while the consistent answer collects the tuples that can be retrieved in every repaired instance .",
    "cqa under primary keys is conp - complete in data complexity @xcite , when both the relational schema and the query are considered fixed . due to its complex nature ,",
    "traditional rdbms are inadequate to solve the problem alone via sql without focusing on restricted classes of cqs @xcite . actually ,",
    "in the unrestricted case , cqa has been traditionally dealt with logic programming  @xcite .",
    "however , it has been argued  @xcite that the practical applicability of logic - based approaches is restricted to data sets of moderate size .",
    "only recently , an approach based on binary integer programming  @xcite has revealed good performances on large databases ( featuring up to one million tuples per relation ) with primary key violations .    in this paper",
    ", we demonstrate that logic programming can still be effectively used for computing consistent answers over large relational databases .",
    "we design a novel decomposition strategy that reduces ( in polynomial time ) the computation of the consistent answer to a cq over a database subject to primary key constraints into a collection of smaller problems of the same sort . at the core of the strategy",
    "is a cascade pruning mechanism that dramatically reduces the number of key violations that have to be handled to answer the query .",
    "moreover , we implement the new strategy using answer set programming ( asp ) @xcite , and we prove empirically the effectiveness of our asp - based approach on existing benchmarks from the database world .",
    "in particular , we compare our approach with some classical @xcite and optimized @xcite encodings of cqa in asp that were presented in the literature .",
    "the experiment empirically demonstrate that our logic - based approach implements cqa efficiently on large data sets , and can even perform better than state - of - the - art methods .",
    "we are given two disjoint countably infinite sets of _ terms _ denoted by @xmath7 and @xmath8 and called _ constants _ and _ variables _ , respectively .",
    "we denote by @xmath9 sequences ( or sets , with a slight abuse of notation ) of variables @xmath10 , and by @xmath11 sequences of terms @xmath12 .",
    "we also denote by @xmath13 $ ] the set @xmath14 , for any @xmath15 . given a sequence @xmath16 of terms and a set @xmath17 $ ]",
    ", @xmath18 is the subsequence @xmath19 .",
    "for example , if @xmath20 and @xmath21 , then @xmath22 .",
    "a ( _ relational _ ) _ schema _ is a triple @xmath23 where @xmath24 is a finite set of _ relation symbols _ ( or _ predicates _ ) , @xmath25 is a function associating an _",
    "arity _ to each predicate , and @xmath26 is a function that associates , to each @xmath27 , a nonempty set of positions from @xmath28 $ ] , which represents the _ primary key _ of @xmath29 .",
    "moreover , for each relation symbol @xmath27 and for each position @xmath30 $ ] , @xmath31 $ ] denotes the @xmath32-th _ attribute _ of @xmath29 . throughout ,",
    "let @xmath33 denote a relational schema .",
    "an _ atom _ ( over @xmath34 ) is an expression of the form @xmath35 , where @xmath27 , and @xmath36 .",
    "an atom is called a _ fact _ if all of its terms are constants of @xmath7 .",
    "conjunctions of atoms are often identified with the sets of their atoms . for a set @xmath37 of atoms ,",
    "the variables occurring in @xmath37 are denoted by @xmath38 .",
    "a _ database _ @xmath1 ( over @xmath34 ) is a finite set of facts over @xmath39 .",
    "given an atom @xmath40 , we denote by @xmath41 the sequence @xmath42 .",
    "we say that @xmath1 is _ inconsistent _ ( w.r.t .",
    "@xmath34 ) if it contains two different atoms of the form @xmath43 and @xmath44 such that @xmath45 .",
    "otherwise , it is _ consistent_. a _ repair _ @xmath6 of @xmath1 ( w.r.t .",
    "@xmath34 ) is any maximal consistent subset of @xmath1 .",
    "the set of all the repairs of @xmath1 is denoted by @xmath46 .",
    "a _ substitution _ is a mapping @xmath47 which is the identity on @xmath7 .",
    "given a set @xmath37 of atoms , .",
    "the restriction of @xmath48 to a set @xmath49 , is denoted by @xmath50 . a _ conjunctive query _ ( cq ) @xmath5 ( over @xmath34 ) is an expression of the form @xmath51 , where @xmath52 are variables of @xmath8 , and @xmath53 is a conjunction of atoms ( possibly with constants ) over @xmath34 . to highlight the free variables of @xmath5 ,",
    "we often write @xmath54 instead of @xmath5 .",
    "if @xmath9 is empty , then @xmath5 is called a _ boolean conjunctive query _ ( bcq ) . assuming that @xmath9 is the sequence @xmath10 , the _ answer _ to @xmath5 over a database @xmath1 , denoted @xmath55 , is the set of all @xmath56-tuples @xmath57 for which there exists a substitution @xmath48 such that @xmath58 and @xmath59 , for each @xmath60 $ ] .",
    "a bcq is _ true _ in @xmath1 , denoted @xmath61 , if @xmath62 .",
    "consistent answer _ to a cq @xmath54 over a database @xmath1 ( w.r.t .",
    "@xmath34 ) , denoted @xmath63 , is the set of tuples @xmath64 .",
    "clearly , @xmath65 holds .",
    "a bcq @xmath5 is _ consistently true _ in a database @xmath1 ( w.r.t .",
    "@xmath34 ) , denoted @xmath66 , if @xmath67 .",
    "to deal with large inconsistent data , we design a strategy that reduces in polynomial time the problem of computing the consistent answer to a cq over a database subject to primary key constraints to a collection of smaller problems of the same sort . to this end , we exploit the fact that the former problem is logspace turing reducible to the one of deciding whether a bcq is consistently true ( recall that the consistent answer to a cq is a subset of its answer ) . hence , given a database @xmath1 over a schema @xmath34 , and a bcq @xmath5 , we would like to identify a set @xmath68 of pairwise disjoint subsets of @xmath1 , called fragments , such that : _",
    "@xmath69 iff there is @xmath70 $ ] such that @xmath71_. at the core of our strategy we have : @xmath0 a cascade pruning mechanism to reduce the number of `` crucial '' inconsistencies , and @xmath2 a technique to identify a suitable set of fragments from any ( possibly unpruned ) database . for the sake of presentation",
    ", we start with principle @xmath2 . in the last two subsections , we provide complementary techniques to further reduce the number of inconsistencies to be handled for answering the original cq .",
    "the proofs of this section are given in  [ sec : app - proofs ] .",
    "given a database @xmath1 , a _",
    "key component _",
    "@xmath72 of @xmath1 is any maximal subset of @xmath1 such that if @xmath73 and @xmath74 are in @xmath72 , then both @xmath75 and @xmath45 hold .",
    "namely , @xmath72 collects only atoms that agree on their primary key .",
    "hence , the set of all key components of @xmath1 , denoted by @xmath76 , forms a partition of @xmath1 .",
    "if a key component is a singleton , then it is called _ safe _ ; otherwise it is _",
    "conflicting_. let @xmath77 .",
    "it can be verified that @xmath78 .",
    "let us now fix throughout this section a bcq @xmath5 over @xmath34 .",
    "for a repair @xmath79 , if @xmath5 is true in @xmath6 , then there is a substitution @xmath48 such that @xmath80 .",
    "but since @xmath81 , it also holds that @xmath82 .",
    "hence , is an overestimation of the substitutions that map @xmath5 to the repairs of @xmath1 .        inspired by the notions of conflict - hypergraph @xcite and conflict - join graph @xcite",
    ", we now introduce the notion of conflict - join hypergraph . given a database @xmath1 , the _ conflict - join hypergraph _ of @xmath1 ( w.r.t .",
    "@xmath5 and @xmath34 ) is denoted by @xmath83 , where @xmath1 are the vertices , and @xmath84 are the hyperedges partitioned in @xmath85 and @xmath86 .",
    "@xmath87 of vertices of @xmath88 is any minimal nonempty subset of @xmath1 such that , for each @xmath89 , either @xmath90 or @xmath91 holds .",
    "intuitively , every edge of @xmath88 collects the atoms in a key component of @xmath1 or the atoms in @xmath92 , for some @xmath93 .",
    "moreover , each bunch collects the vertices of some connected component of @xmath88 . before we proceed further ,",
    "let us fix these preliminary notions with the aid of the following example .",
    "[ ex : hypergraph ] consider the schema @xmath33 , where @xmath94 , @xmath95 , and @xmath96 .",
    "consider also the database @xmath97 @xmath98 @xmath99 @xmath100 , @xmath101 , and the bcq @xmath102 .",
    "the conflicting components of @xmath1 are @xmath103 @xmath104 and @xmath105 , @xmath101 , while its safe component is @xmath106 .",
    "the repairs of @xmath1 are @xmath107 @xmath99 @xmath108 , @xmath109 @xmath99 @xmath101 ,",
    "@xmath110 @xmath99 @xmath108 , and @xmath111 @xmath99 @xmath101 .",
    "moreover , @xmath112 contains the substitutions : @xmath113 , @xmath114 , @xmath115 , and @xmath116 .",
    "the conflict - join hypergraph @xmath83 is depicted in figure [ fig : repairs ] .",
    "solid ( resp .",
    ", dashed ) edges form the set @xmath117 ( resp . , @xmath118 ) .",
    "since @xmath119 maps @xmath5 to @xmath120 and @xmath121 , and @xmath122 maps @xmath5 to @xmath123 and @xmath124 , we conclude that @xmath69 .",
    "finally , @xmath1 is the only bunch of @xmath88 .",
    "@xmath125    in example [ ex : hypergraph ] we observe that @xmath126 can be safely ignored in the evaluation of @xmath5 .",
    "in fact , even if both @xmath127 and @xmath128 contain an atom of @xmath126 , @xmath119 and @xmath122 are sufficient to prove that @xmath5 is consistently true .",
    "this might suggest to focus only on the set @xmath129 , and on its repairs @xmath130 @xmath131 and @xmath132 @xmath131 .",
    "also , since @xmath133 , @xmath134 represents the `` small '' fragment of @xmath1 that we need to evaluate @xmath5",
    ". the practical advantage of considering @xmath134 instead of @xmath1 should be already clear : @xmath0 the repairs of @xmath134 are smaller than the repairs of @xmath1 ; and @xmath2 @xmath134 has less repairs than @xmath1 .",
    "we are now ready to introduce the the formal notion of fragment .",
    "[ def : fragment ] consider a database @xmath1 .",
    "for any set @xmath135 of key components of @xmath1 , we say that the set @xmath136 is a ( _ well - defined _ ) _ fragment _ of @xmath1 .",
    "@xmath125    according to definition [ def : fragment ] , the set @xmath129 in example [ ex : hypergraph ] is a fragment of @xmath1 .",
    "the following proposition , states a useful property that holds for any fragment .",
    "[ prop : fragment ] consider a database @xmath1 , and two fragments @xmath137 of @xmath1 .",
    "if @xmath138 , then @xmath139 .    by definition [ def :",
    "fragment ] , @xmath1 is indeed a fragment of itself .",
    "hence , if @xmath5 is consistently true , then there is always the fragment @xmath140 such that @xmath133 .",
    "but now the question is : _ how can we identify a convenient set of fragments of @xmath1 _ ?",
    "the naive way would be to use as fragments the bunches of @xmath88 .",
    "soundness is guaranteed by proposition [ prop : fragment ] . regarding completeness",
    ", we rely on the following result .",
    "[ thm : bunches ] consider a database @xmath1 .",
    "if @xmath69 , then there is a bunch @xmath87 of @xmath88 s.t . @xmath141 .    by combining proposition [ prop : fragment ] with theorem [ thm : bunches ]",
    "we are able to reduce , in polynomial time , the original problem into a collection of smaller ones of the same sort .",
    "the technique proposed in the previous section alone is not sufficient to deal with large data sets .",
    "in fact , since it considers all the bunches of the conflict - join hypergraph , it unavoidably involves the entire database . to strengthen its effectiveness ,",
    "we need an algorithm that realizes , for instance , that @xmath126 is `` redundant '' in example [ ex : hypergraph ] . but",
    "before that , let us define formally what we mean by the term redundant .",
    "[ def : redundant ] a key component @xmath72 of a database @xmath1 is called _ redundant _ ( w.r.t .",
    "@xmath5 ) if the following condition is satisfied : for each fragment @xmath134 of @xmath1 , @xmath133 implies @xmath142 .",
    "@xmath125    the above definition states that a key component is redundant independently from the fact that some other key component is redundant or not .",
    "therefore :    [ prop : redundancyclosure ] consider a database @xmath1 and a set @xmath143 of redundant components of @xmath1 .",
    "it holds that @xmath69 iff @xmath144 .    in light of proposition",
    "[ prop : redundancyclosure ] , if we can identify all the redundant components of @xmath1 , then after removing from @xmath1 all these components , what remains is either : @xmath0 a nonempty set of ( minimal ) bunches , each of which entails consistently @xmath5 whenever @xmath69 ; or @xmath2 the empty set , whenever @xmath145 . more formally :    [ prop : truequeryhasnonredundantcomponent ] given a database @xmath1 , each key component of @xmath1 is redundant iff @xmath145 .    however , assuming that @xmath146 , any algorithm for the identification of all the redundant components of @xmath1 can not be polynomial because , otherwise , we would have a polynomial procedure for solving the original problem .",
    "our goal is therefore to identify sufficient conditions to design a pruning mechanism that detects in polynomial time as many redundant conflicting components as possible . to give an intuition of our pruning mechanism",
    ", we look again at example [ ex : hypergraph ] .",
    "actually , @xmath126 is redundant because it contains an atom , namely @xmath147 , that is not involved in any substitution ( see figure [ fig : repairs ] ) .",
    "assume now that this is the criterion that we use to identify redundant components . since , by definition [ def : redundant ] , we know that @xmath69 iff @xmath148 , this means that we can now forget about @xmath1 and consider only @xmath149 .",
    "but once we focus on @xmath150 , we realize that it contains only @xmath119 and @xmath122 .",
    "then , a smaller number of substitutions in @xmath150 w.r.t . those in @xmath112 motivates us to reapply our criterion .",
    "indeed , there could also be some atom in @xmath151 not involved in any of the substitutions of @xmath150 .",
    "this is not the case in our example since the atoms in @xmath151 are covered by @xmath152 or @xmath153 .",
    "however , in general , in one or more steps , we can identify more and more redundant components .",
    "we can now state the main result of this section .",
    "[ thm : pruning ] consider a database @xmath1 , and a key component @xmath72 of @xmath1 .",
    "let @xmath83 be the conflict - join hypergraph of @xmath1 .",
    "if @xmath154 , then @xmath72 is redundant .    in what follows , a redundant component that can be identified via theorem  [ thm : pruning ]",
    "is called _",
    "strongly redundant_. as discussed just before theorem  [ thm : pruning ] , an indirect effect of removing a redundant component @xmath72 from @xmath1 is that all the substitutions in the set can be in a sense ignored .",
    "in fact , @xmath155 . whenever a substitution can be safely ignored , we say that it is unfounded .",
    "let us formalize this new notion in the following definition .",
    "[ def : unfoundedsub ] consider a database @xmath1 .",
    "a substitution @xmath48 of @xmath112 is _ unfounded _ if : for each fragment @xmath134 of @xmath1 , @xmath133 implies that , for each repair @xmath156 , there exists a substitution @xmath157 different from @xmath48 such that @xmath158 .",
    "@xmath125    we now show how to detect as many unfounded substitutions as possible .",
    "[ thm : suffunfoundedsub ] consider a database @xmath1 , and a substitution @xmath93 .",
    "if there exists a redundant component @xmath72 of @xmath1 such that @xmath159 , then @xmath48 is unfounded .    clearly , theorem  [ thm : suffunfoundedsub ] alone is not helpful since it relies on the identification of redundant components .",
    "however , if combined with theorem  [ thm : pruning ] , it forms the desired cascade pruning mechanism . to this end , we call _ strongly unfounded _ an unfounded substitution that can be identified by applying theorem  [ thm : suffunfoundedsub ] by only considering strongly redundant components .",
    "hereafter , let us denote by @xmath160 the subset of @xmath112 containing only strongly unfounded substitutions .",
    "hence , both substitutions @xmath161 and @xmath162 in example [ ex : hypergraph ] are strongly unfounded , since @xmath126 is strongly redundant . moreover , we reformulate the statement of theorem [ thm : pruning ] by exploiting the notion of strongly unfounded substitution , and the fact that the set @xmath163 is nonempty if and only if there exists an atom @xmath164 such that the set @xmath165  or equivalently the set @xmath166  is empty . for example , according to figure  [ fig : repairs ] , the set @xmath167 is nonempty since it contains the atom @xmath147 .",
    "but this atoms makes the set @xmath168 empty since no substitution of @xmath112 ( or no hyperedge of @xmath118 ) involves @xmath147 .",
    "[ prop : stronglyredundant ] a key component @xmath72 of @xmath1 is strongly redundant if there is an atom @xmath164 such that one of the two following conditions is satisfied : ( 1 ) @xmath169 , or ( 2 ) @xmath170 .    by combining theorem  [ thm : suffunfoundedsub ] and proposition  [ prop : stronglyredundant ] , we have a declarative ( yet inductive ) specification of all the strongly redundant components of @xmath1 .",
    "importantly , the process of identifying strongly redundant components and strongly unfounded substitutions by exhaustively applying theorem  [ thm : suffunfoundedsub ] and proposition  [ prop : stronglyredundant ] is monotone and reaches a fixed - point ( after no more than @xmath171 steps ) when no more key component can be marked as strongly redundant .",
    "previously , we have described a technique to reduce inconsistencies by progressively eliminating key components that are involved in query substitutions but are redundant . in the following ,",
    "we show how to reduce inconsistencies by reducing the cardinality of conflicting components , which in some cases can be even treated as safe components .",
    "the act of _ removing _ an attribute @xmath31 $ ] from a triple @xmath172 consists of reducing the arity of @xmath29 by one , cutting down the @xmath32-th term of each @xmath29-atom of @xmath1 and @xmath5 , and adapting the positions of the primary key of @xmath29 accordingly .",
    "moreover , let @xmath173~|~r \\in { \\mathcal{r}}~\\textrm { and } ~i \\in [ \\alpha(r)]\\}$ ] , let @xmath174 , and let @xmath175 .",
    "the _ projection _ of @xmath172 on @xmath37 , denoted by @xmath176 , is the triple that is obtained from @xmath172 by removing all the attributes of @xmath87 . consider a cq @xmath5 and a predicate @xmath27 .",
    "the attribute @xmath31 $ ] is _ relevant _ ( w.r.t .",
    "@xmath5 ) if @xmath5 contains an atom of the form @xmath177 such that at least one of the following conditions is satisfied : @xmath0 @xmath178 ; or @xmath2 @xmath179 is a constant ; or @xmath3 @xmath179 is a variable that occurs more than once in @xmath5 ; or @xmath180 @xmath179 is a free variable of @xmath5 .",
    "an attribute which is not relevant is _ idle _",
    "@xmath5 ) .",
    "an example is reported in [ sec : exampleidle ] .",
    "the following theorem states that the consistent answer to a cq does not change after removing the idle attributes .",
    "[ thm : idle ] consider a cq @xmath5 , the set @xmath181\\in \\mathit{attrs}({\\sigma})~|~r[i]~\\textrm { is relevant w.r.t . }",
    "q\\}$ ] , and a database @xmath1 .",
    "it holds that @xmath182 .",
    "let @xmath39 be a relational schema , @xmath1 be a database , and @xmath183 be a cq , where we assume that @xmath184 contains only relevant attributes w.r.t .",
    "@xmath5 ( idle attributes , if any , have been already removed ) . since @xmath65 , for each candidate answer @xmath185 , one should evaluate whether the bcq @xmath186 is ( or is not ) consistently true in @xmath1 . before constructing the conflict - join hypergraph of @xmath1 ( w.r.t .",
    "@xmath187 and @xmath34 ) , however , one could check whether there is a substitution @xmath48 that maps @xmath187 to @xmath1 with the following property : for each @xmath188 , the singleton @xmath189 is a safe component of @xmath1 . and",
    ", if so , it is possible to conclude immediately that @xmath190 .",
    "intuitively , whenever the above property is satisfied , we say that @xmath191 is a",
    "_ safe answer _ to @xmath5 because , for each @xmath192 , it is guaranteed that @xmath193 .",
    "the next result follows .",
    "consider a cq @xmath183 , and a tuple @xmath191 of @xmath55 . if there is a substitution @xmath48 s.t .",
    "each atom of @xmath194 forms a safe component of @xmath1 , then @xmath190 .",
    "in this section , we propose an asp - based encoding to cqa that implements the techniques described in section [ sec : pruning ] , and that is able to deal directly with cqs , instead of evaluating separately the associated bcqs .",
    "hereafter , we assume the reader is familiar with answer set programming  @xcite and with the standard syntax of asp competitions  @xcite . a nice introduction to asp",
    "can be found in @xcite , and in the asp core 2.0 specification in @xcite . given a relational schema @xmath195 , a database @xmath1 , and a cq @xmath183",
    ", we construct a program @xmath196 s.t .",
    "a tuple @xmath197 belongs to @xmath63 iff each answer set of @xmath198 contains an atom of the form @xmath199 , for some constant @xmath200 .",
    "importantly , a large part of @xmath196 does not depend on @xmath5 or @xmath39 . to lighten the presentation",
    ", we provide a simplified version of the encoding that has been used in our experiments .",
    "in fact , for efficiency reasons , idle attributes should be `` ignored on - the - fly '' without materializing the projection of @xmath201 on the relevant attributes ; but this makes the encoding a little more heavy .",
    "hence , we first provide a naive way to consider only the relevant attributes , and them we will assume that @xmath184 contains no idle attribute . let @xmath6 collect all the attributes of @xmath39 that are relevant w.r.t .",
    "@xmath5 . for each @xmath27 that occurs in @xmath5 ,",
    "let @xmath202 be a sequence of @xmath203 different variables and @xmath204\\in r\\}$ ] , the terms of the @xmath29-atoms of @xmath1 that are associated to idle attributes can be removed via the rule @xmath205 .",
    "hereafter , let us assume that @xmath184 contains no idle attribute , and @xmath206 .",
    "program @xmath196 is depicted in figure  [ fig : encoding ] .    ' '' ''    =  =  = + % +    @xmath207 .",
    "+    @xmath208 . `",
    "@xmath209 +    @xmath210 .",
    "+    @xmath211 . +",
    "[ 2 mm ] % +    @xmath212 .",
    "+    @xmath213 . `",
    "@xmath209 +    @xmath214 . `",
    "@xmath209 +    @xmath215 . `",
    "@xmath209 + [ 2 mm ] % +    @xmath216 + @xmath217 .",
    "+    @xmath218 .",
    "+    @xmath219 , + @xmath220 . +    @xmath221 . +",
    "[ 2 mm ] % +    @xmath222 + @xmath223 .",
    "+    @xmath224",
    ". +    @xmath225",
    ". +    @xmath226",
    ". +    @xmath227",
    ". +    @xmath228",
    ". +    @xmath229 + @xmath230",
    ". +    @xmath231 . +",
    "[ 2 mm ] % +    @xmath232 .",
    "+    @xmath233",
    ". +    @xmath234 .",
    "+ [ 2 mm ] % +    @xmath235",
    ". +    @xmath236 .",
    "+    @xmath237 + @xmath238 .",
    "+    ' '' ''    _ computation of the safe answer .",
    "_ via rule @xmath239 , we identify the set @xmath240 is a substitution and @xmath241 .",
    "it is now possible ( rule @xmath242 ) to identify the atoms of @xmath1 that are involved in some substitution . here",
    ", for each atom @xmath243 , we recall that @xmath244 is the subsequence of @xmath4 containing the terms in the positions of the primary key of @xmath29 , and we assume that @xmath245 are the terms of @xmath4 in the remaining positions . in particular , we use two function symbols , @xmath246 and @xmath247 , to group the terms in the key of @xmath29 and the remaining ones , respectively .",
    "it is now easy ( rule @xmath248 ) to identify the conflicting components involved in some substitution .",
    "let @xmath249 .",
    "we now compute ( rule @xmath250 ) the safe answers",
    ".    _ hypergraph construction .",
    "_ for each candidate answer @xmath185 that has not been already recognized as safe , we construct the hypergraph @xmath251 associated to the bcq @xmath252 , where @xmath253 , as usual .",
    "hypergraph @xmath254 is identified by the functional term @xmath255 , the substitutions of @xmath118 ( collected via rule @xmath256 ) are identified by the set @xmath257 and @xmath258 of functional terms , while the key components of @xmath117 ( collected via rule @xmath259 ) are identified by the set @xmath260 and @xmath261 and @xmath262 of functional terms . to complete the construction of the various hypergraphs",
    ", we need to specify ( rules @xmath263 and @xmath264 ) which are the atoms in each hyperedge .",
    "_ pruning .",
    "_ we are now ready to identify ( rules @xmath265 ) the strongly redundant components and the strongly unfounded substitutions ( as described in section [ sec : pruning ] ) to implement our cascade pruning mechanism .",
    "hence , it is not difficult to collect ( rule @xmath266 ) the substitutions that are not unfounded , that we call _",
    "residual_.    _ fragments identification .",
    "_ key components involving at least a residual substitution ( i.e. , not redundant ones ) , can be aggregated in fragments ( rules @xmath267 ) by using the notion of bunch introduced in section [ sec : fragments ] . in particular ,",
    "any given fragment @xmath134  associated to a candidate answer @xmath185 , and collecting the key components @xmath268  is identified by the functional term @xmath269 where , for each @xmath270 , the functional term associated to @xmath271 lexicographically precedes the functional term associated to @xmath272 . _ repair construction .",
    "_ rules @xmath273 can be evaluated in polynomial time and have only one answer set , while the remaining part of the program can not in general .",
    "in particular , rules @xmath274 generate the search space .",
    "actually , each answer set @xmath275 of @xmath196 is associated ( rule @xmath276 ) with only one fragment , say @xmath134 , that we call _ active _ in @xmath275 .",
    "moreover , for each key component @xmath72 of @xmath134 , answer set @xmath275 is also associated ( rule @xmath277 ) with only one atom of @xmath72 , that we also call _ active _ in @xmath275 .",
    "consequently , each substitution which involves atoms of @xmath134 but also at least one atom which is not active , must be ignored in @xmath275 ( rule @xmath278 ) .    _",
    "new query .",
    "_ finally , we compute the atoms of the form @xmath199 via rules @xmath279 .",
    "the experiment for assessing the effectiveness of our approach is described in the following .",
    "we first describe the benchmark setup and , then , we analyze the results .",
    "_ benchmark setup .",
    "_ the assessment of our approach was done using a benchmark employed in the literature for testing cqa systems on large inconsistent databases  @xcite .",
    "it comprises 40 instances of a database schema with 10 tables , organized in four families of 10 instances each of which contains tables of size varying from 100k to 1 m tuples ; also it includes 21 queries of different structural features split into three groups depending on whether cqa complexity is conp - complete ( queries @xmath280 ) , ptime but not fo - rewritable  @xcite ( queries @xmath281 ) , and fo - rewritable ( queries @xmath282 ) .",
    "( see [ app : bench ] ) .",
    "we compare our approach , named _ pruning _ , with two alternative asp - based approaches . in particular ,",
    "we considered one of the first encoding of cqa in asp that was introduced in  @xcite , and an optimized technique that was introduced more recently in @xcite ; these are named _ bb_and _ mrt _",
    ", respectively .",
    "_ bb_and _ mrt_can handle a larger class of integrity constrains than _ pruning _ , and only _",
    "mrt_features specific optimization that apply also to primary key violations handling .",
    "we constructed the three alternative encodings for all 21 queries of the benchmark , and we run them on the asp solver wasp 2.0  @xcite , configured with the iterative coherence testing algorithm  @xcite , coupled with the grounder gringo ver .",
    "4.4.0 @xcite.for completeness we have also run claspver .",
    "3.1.1  @xcite obtaining similar results",
    ". waspperformed better in terms of number of solved instances on _ mrt_and _ bb_.",
    "the experiment was run on a debian server equipped with xeon e5 - 4610 cpus and 128 gb of ram . in each execution ,",
    "resource usage was limited to 600 seconds and 16 gb of ram .",
    "execution times include the entire computation , i.e. , both grounding and solving .",
    "all the material for reproducing the experiment ( asp programs , and solver binaries ) can be downloaded from www.mat.unical.it/ricca/downloads/mrticlp2015.zip .",
    "_ analysis of the results .",
    "_ concerning the capability of providing an answer to a query within the time limit , we report that _",
    "pruning_was able to answer the queries in all the 840 runs in the benchmark with an average time of 14.6s . _ mrt _ , and _ bb_solved only 778 , and 768 instances within 600 seconds , with an average of 80.5s and 52.3s , respectively .",
    "the cactus plot in figure  [ fig : comp : cac ] provides an aggregate view of the performance of the compared methods .",
    "recall that a cactus plot reports for each method the number of answered queries ( solved instances ) in a given time .",
    "we observe that the line corresponding to _ pruning_in figure  [ fig : comp : cac ] is always below the ones of _ mrt_and _ bb_. in more detail , _",
    "pruning_execution times grow almost linearly with the number of answered queries , whereas _ mrt_and _",
    "bb_show an exponential behavior .",
    "we also note that _",
    "mrt_behaves better than _ bb _ , and this is due to the optimizations done in _",
    "mrt_that reduce the search space .    the performance of the approaches w.r.t .",
    "the size of the database is studied in figure  [ fig : comp : avgsol ] . the x - axis reports the number of tuples per relation in tenth of thousands , in the upper plot",
    "is reported the number of queries answered in 600s , and in the lower plot is reported the corresponding the average running time .",
    "we observe that all the approaches can answer all 84 queries ( 21 queries per 4 databases ) up to the size of 300k tuples , then the number of answered queries by both _ bb_and _",
    "mrt_starts decreasing .",
    "indeed , they can answer respectively 74 and 75 queries of size 600k tuples , and only 67 and 71 queries on the largest databases ( 1 m tuples ) . instead , _",
    "pruning_is able to solve all the queries in the data set . the average time elapsed by running _",
    "pruning_grows linearly from 2.4s up to 27.4s .",
    "_ mrt_and _ bb_average times show a non - linear growth and peak at 128.9s and 85.2s , respectively .",
    "( average is computed on queries answered in 600s , this explains why it apparently decreases when a method can not answer some instance within 600s . )    the scalability of _",
    "pruning_is studied in detail for each query in figures  [ fig : ratioscalability](d - f ) , each plotting the average execution times per group of queries of the same theoretical complexity .",
    "it is worth noting that _ pruning_scales almost linearly in all queries , and independently from the complexity class of the query .",
    "this is because _",
    "pruning_is able to identify and deal efficiently with the conflicting fragments .",
    "we now analyze the performance of _ pruning_from the perspective of a measure called _ overhead _ , which was employed in  @xcite for measuring the performance of cqa systems . given a query q the overhead is given by @xmath283 , where @xmath284 is time needed for computing the consistent answer of q , and @xmath285 is the time needed for a plain execution of q where the violation of integrity constraints are ignored .",
    "note that the overhead measure is independent of the hardware and the software employed , since it relates the computation of cqa to the execution of a plain query on the same system .",
    "thus it allows for a direct comparison of _",
    "pruning_with other methods having known overheads . following what was done in  @xcite , we computed the average overhead measured varying the database size for each query , and we report the results by grouping queries per complexity class in figures  [ fig : ratioscalability](a - c ) .",
    "the overheads of _",
    "pruning_is always below 2.1 , and the majority of queries has overheads of around 1.5 .",
    "the behavior is basically ideal for query q5 and q4 ( overhead is about 1 ) .",
    "the state of the art approach described in  @xcite has overheads that range between 5 and 2.8 on the very same dataset ( more details on [ app : bench ] ) .",
    "thus , our approach allows to obtain a very effective implementation of cqa in asp with an overhead that is often more than two times smaller than the one of state - of - the - art approaches .",
    "we complemented this analysis by measuring also the overhead of _ pruning_w.r.t .",
    "the computation of safe answers , which provide an underestimate of consistent answers that can be computed efficiently ( in polynomial time ) by means of stratified asp programs .",
    "we report that the computation of the consistent answer with _",
    "pruning_requires only at most 1.5 times more in average than computing the safe answer ( detailed plots in [ app : bench ] ) .",
    "this further outlines that _",
    "pruning_is able to maintain reasonable the impact of the hard - to - evaluate component of cqa .",
    "finally , we have analyzed the impact of our technique in the various solving steps of the evaluation .",
    "the first three histograms in figure  [ fig : grounding ] report the average running time spent for answering queries in databases of growing size for _ pruning_(fig .",
    "[ fig : hpr ] ) , _ bb_(fig .",
    "[ fig : hbb ] ) , and _ mrt_(fig .",
    "[ fig : hmrt ] ) . in each bar",
    "different colors distinguish the average time spent for grounding and solving .",
    "in particular , the average solving time over queries _ answered within the timeout _ is labeled solving - sol , and each bar extends up to the average cumulative execution time computed over all instances , where each timed out execution counts 600s .",
    "recall that , roughly speaking , the grounder solves stratified normal programs , and the hard part of the computation is performed by the solver on the residual non - stratified program ; thus , we additionally report in figure  [ fig : grperc ] the average number of facts ( knowledge inferred by grounding ) and of non - factual rules ( to be evaluated by the solver ) in percentage of the total for the three compared approaches .",
    "the data in figure  [ fig : grounding ] confirm that most of the computation is done with _",
    "pruning_during the grounding , whereas this is not the case for _ mrt_and _ bb_. figure  [ fig : grperc ] shows that for _ pruning_the grounder produces a few non - factual rules ( below 1% in average ) , whereas _ mrt_and _",
    "bb_produce 5% and 63% of non - factual rules , respectively .",
    "roughly , this corresponds to about 23k non - factual rules ( resp .",
    ", 375k non - factual rules ) every 100k tuples per relation for _ mrt_(resp .",
    ", _ bb _ ) , whereas our approach produces no more than 650 non - factual rules every 100k tuples per relation .",
    "logic programming approaches to cqa were recently considered not competitive  @xcite on large databases affected by primary key violations . in this paper , we proposed a new strategy based on a cascade pruning mechanism that dramatically reduces the number of primary key violations to be handled to answer the query .",
    "the strategy is encoded naturally in asp , and an experiment on benchmarks already employed in the literature demonstrates that our asp - based approach is efficient on large datasets , and performs better than state - of - the - art methods in terms of overhead . as far as future work",
    "is concerned , we plan to extend the _",
    "pruning_method for handling inclusion dependencies , and other tractable classes of tuple - generating dependencies .    ,",
    "hull , r. , and vianu , v. 1995 . .",
    "addison - wesley .    , dodaro , c. , and ricca , f. 2014a .",
    "anytime computation of cautious consequences in answer set programming .  _",
    "14 , _  4 - 5 , 755770 .    ,",
    "dodaro , c. , and ricca , f. 2014b .",
    "preliminary report on wasp 2.0 .  _",
    "abs/1404.6999_.    , bertossi , l.  e. , and chomicki , j. 1999 .",
    "consistent query answers in inconsistent databases . in _ proceedings of pods",
    "99_. 6879 .    ,",
    "bertossi , l.  e. , and chomicki , j. 2003 . answer sets for consistent query answering in inconsistent databases .",
    "_ 3 , _  4 - 5 , 393424",
    ".    \\2003 . .",
    "cambridge university press .",
    "logic programs for querying inconsistent databases . in _ proceedings of padl03_. lncs , vol",
    "springer , 208222 .",
    "synthesis lectures on data management .",
    "morgan & claypool publishers .    , hunter , a. , and schaub , t. , eds .",
    "lncs , vol .",
    "springer , berlin / heidelberg .    ,",
    "eiter , t. , and truszczynski , m. 2011 .",
    "answer set programming at a glance .",
    "_ 54 , _  12 , 92103 .    ,",
    "faber , w. , gebser , m. , ianni , g. , kaminski , r. , krennwallner , t. , leone , n. , ricca , f. , and schaub , t. 2013 .",
    "asp - core-2 input language format .",
    "available at https://www.mat.unical.it/aspcomp2013/files/asp-core-2.03b.pdf .    ,",
    "ianni , g. , and ricca , f. 2014 . the third open answer set programming competition .  _ 14 , _  1 , 117135 .",
    "minimal - change integrity maintenance using tuple deletions .",
    "_ 197 , _  1 - 2 , 90121 .    ,",
    "fink , m. , greco , g. , and lembo , d. 2003 .",
    "efficient evaluation of logic programs for querying data integration systems . in _ proceedings of iclp03_. lncs , vol .",
    "springer , 163177 .    , ipeirotis , p.  g. , and verykios , v.  s. 2007 .",
    "duplicate record detection : a survey .",
    "_ 19 , _  1 , 116 .    ,",
    "fazli , e. , and miller , r.  j. 2005 .",
    "conquer : efficient management of inconsistent databases . in _ proceedings of sigmod05_. acm , 155166 .",
    "first - order query rewriting for inconsistent databases .",
    "_ 73 , _  4 , 610635 .    , kaminski , r. , knig , a. , and schaub , t. 2011 .",
    "advances in _ gringo _ series 3 . in _ logic programming and nonmonotonic reasoning - 11th international conference , lpnmr 2011 , vancouver , canada , may 16 - 19 , 2011 . proceedings _ , j.  p. delgrande and w.  faber , eds .",
    "lecture notes in computer science , vol . 6645 .",
    "springer , 345351 .    ,",
    "kaufmann , b. , and schaub , t. 2013 .",
    "advanced conflict - driven disjunctive answer set solving . in _",
    "ijcai 2013 , proceedings of the 23rd international joint conference on artificial intelligence , beijing , china , august 3 - 9 , 2013 _ , f.  rossi , ed .",
    "ijcai / aaai .",
    "classical negation in logic programs and disjunctive databases .",
    "_ 9 , _  3/4 , 365386 .    ,",
    "greco , s. , and zumpano , e. 2001 . a logic programming approach to the integration , repairing and querying of inconsistent databases . in _ proceedings of iclp01_. lncs , vol .",
    "springer , 348364 .    , greco , s. , and zumpano , e. 2003 . a logical framework for querying and repairing inconsistent databases .",
    "_ 15 , _  6 , 13891408",
    ".    \\2012 .",
    "a dichotomy in the complexity of consistent query answering for queries with two atoms .",
    "_ 112 , _  3 , 7785 .    ,",
    "pema , e. , and tan , w .- c .",
    "efficient querying of inconsistent databases with binary integer programming .",
    "_ 6 , _  6 , 397408 .    ,",
    "ricca , f. , and terracina , g. 2013 .",
    "consistent query answering via asp from different perspectives : theory and practice .",
    "_ 13 , _  2 , 227252 .",
    "\\2009 . on the consistent rewriting of conjunctive queries under primary key constraints .",
    "_ 34 , _  7 , 578601 .",
    "certain conjunctive query answering in first - order logic .",
    "_ 37 , _  2 , 9 .",
    "[ sec : appendix ]",
    "here we report the proofs of theorems and propositions reported in section  [ sec : pruning ] .",
    "let us assume that @xmath138 .",
    "this means that @xmath5 is true in every repair of @xmath286 .",
    "since , by definition , for each repair @xmath121 of @xmath287 , there exists a repair @xmath120 of @xmath286 such that @xmath288 , we conclude that @xmath5 must be true also in every repair of @xmath287 .",
    "we we will prove the contrapositive . to this end , let @xmath289 be the bunches of @xmath88 . assume that , for each @xmath290 $ ] , @xmath291 .",
    "this means that , for each @xmath70 $ ] , there exists a repair @xmath292 such that @xmath293 .",
    "consider now the instance @xmath294 } r_i$ ] .",
    "since @xmath289 always form a partition of @xmath1 , since for each @xmath93 , @xmath92 is entirely contained in exactly one bunch , and since each key component of @xmath1 is entirely contained in exactly one bunch , we conclude that @xmath6 is a repair of @xmath1 and @xmath295 .",
    "hence @xmath296 .",
    "@xmath297 if @xmath145 , then by proposition [ prop : fragment ] we have that , for each fragment @xmath134 of @xmath1 , @xmath298 .",
    "moreover , by rephrasing definition  [ def : redundant ] , we have that any key component @xmath72 of @xmath1 is redundant if the following condition is satisfied : for each fragment @xmath134 of @xmath1 , @xmath299 .",
    "hence , by combining the two , we conclude that each key component of @xmath1 is redundant .",
    "@xmath300 if each key component @xmath72 of @xmath1 is redundant , by proposition  [ prop : redundancyclosure ] , we can conclude that @xmath145 , since the empty database can not entail @xmath5 .",
    "let @xmath134 be a fragment of @xmath1 such that @xmath133 .",
    "by considering @xmath134 as a database and by theorem [ thm : bunches ] , we have that there exists at least a bunch @xmath87 of the conflict - join hypergraph @xmath301 of @xmath134 such that @xmath141 . if @xmath302 , then @xmath303 , and therefore , by proposition [ prop : fragment ] , since @xmath87 is a fragment of @xmath304 , we have that @xmath142 .",
    "if @xmath305 , then let us consider one of the atoms @xmath164 that is not involved in any substitution .",
    "but since @xmath5 is true in every repair of @xmath87 containing @xmath306 , this means that @xmath5 is true also in every repair of @xmath307 . and",
    "since @xmath307 is a fragment of @xmath308 , also in this case we can conclude that @xmath142 .",
    "let @xmath72 be a redundant component of @xmath1 , and @xmath48 be a substitution of @xmath112 such that @xmath159 .",
    "moreover , let @xmath134 be a fragment of @xmath1 such that @xmath133 . since @xmath72 is redundant , by definition  [ def : redundant ]",
    ", we have that @xmath142 .",
    "but since @xmath92 necessarily contains an atom of @xmath72 , this means that for each repair @xmath309 , there exists a substitution @xmath157 different from @xmath48 such that @xmath158 .",
    "but since the union of all these substitutions different from @xmath48 can be also used to entail @xmath5 in every repair of @xmath134 , by definition  [ def : unfoundedsub ] , we can conclude that @xmath48 is unfounded .",
    "consider , for example , the schema @xmath33 , where @xmath94 , @xmath310 , @xmath311 , and @xmath96 .",
    "consider also the database @xmath312 @xmath313 @xmath314 , and the bcq @xmath315 .",
    "the key components of @xmath1 are @xmath316 @xmath317 and @xmath318 , while the repairs of @xmath1 and @xmath34 are @xmath319 @xmath314 and @xmath320 @xmath314 . moreover , the set @xmath112 contains substitutions @xmath321 and @xmath322 . finally , since @xmath119 maps @xmath5 to @xmath120 , and @xmath122 maps @xmath5 to @xmath121",
    ", we can conclude that @xmath69 .",
    "however , one can observe that @xmath323 could be considered as a safe component with respect to @xmath5 .",
    "in fact , variable @xmath324 of @xmath5  being in a position that does not belong to @xmath325  occurs only once in @xmath5 . and",
    "this intuitively means that whenever there exists a substitution that maps @xmath5 in a repair containing @xmath326 , there must exist also a substitution that maps @xmath5 in a repair containing @xmath327 .",
    "therefore , to avoid that @xmath323 produces two repairs , one can consider only the first two attributes of @xmath328 and modify @xmath5 accordingly .",
    "hence , we can consider @xmath329 , where @xmath330 , @xmath331 and @xmath332 , the database @xmath333 @xmath314 , and the bcq @xmath334 .",
    "clearly , @xmath151 is now consistent and entails @xmath335 .",
    "the benchmark considered in the paper was firstly used in @xcite .",
    "it comprises several instances of varying size of a synthetic database specifically conceived to simulate reasonably high selectivities of the joins and a large number of potential answers .",
    "moreover it includes a set of queries of varying complexity and 40 instances of a randomly generated database . in the following we report the main characteristics of the data set and a link to an archive where the encoding and the binaries of the asp system employed in the experiment can be also obtained .",
    "it contains the following queries organized in groups depending on the respective complexity of cqa ( existential quantifiers are omitted for simplicity ) :    * * co - np , not first - order rewritable * * @xmath336 * @xmath337 * @xmath338 * @xmath339 * @xmath340 * @xmath341 * @xmath342 * * ptime , not first order rewritable * * @xmath343 * @xmath344 * @xmath345 * @xmath346 * @xmath347 * @xmath348 * @xmath349 * * first order rewritable * * @xmath350 * @xmath351 * @xmath352 * @xmath353 * @xmath354 * @xmath355 * @xmath356      we used exactly the same datasets employed in @xcite .",
    "it comprises 40 samples of the same database , organized in four families of 10 instances each of which contains 10 tables of size varying from 100000 to 100000 tuples with increments 100000 . quoting @xcite ,",
    "the generation of databases has been done according with the following criterion :  for every two atoms @xmath357 , @xmath358 that share variables in any of the queries , approximately 25 of the facts in @xmath357 join with some fact in @xmath358 , and vice - versa .",
    "the third attribute in all of the ternary relations , which is sometimes projected out and never used as a join attribute in table 1 , takes values from a uniform distribution in the range @xmath359 $ ] .",
    "hence , in each relation , there are approximately @xmath360 distinct values in the third attribute , each value appearing approximately 10 times . ",
    "we refrain from reporting here all the asp encodings employed in the experiment since they are very lengthy .",
    "instead we report as an example the asp program used for answering query q7 , and provide all the material in an archive that can be downloaded from www.mat.unical.it/ricca/downloads/mrticlp2015.zip .",
    "the zip package also contains the binaries of the asp system employed in the experiment .",
    "let us classify the variables of @xmath361 :    * all the variables are : @xmath362 ; * the free variables are : @xmath363 ; * the variables involved in some join are : @xmath364 ; * the variables in primary - key positions are : @xmath365 ; * the variable in idle positions are : @xmath366 * the variable occurring in relevant positions are : @xmath367    [ [ computation - of - the - safe - answer . ] ] computation of the safe answer .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +     + `  sub(x , y , z , x1,w , d )  ` + ` : -  ` + ` r5(x , y , z ) ,  r6(x1,y , w ) ,  r7(y , u , d ) . `     + `  involvedatom(k - r5(x ) ,  nk - r5(v2,v3 ) )  : -  sub(x , y , z , x1,w , d ) ,  r5(x , v2,v3 ) . `",
    "+ `  involvedatom(k - r6(x1 ) ,  nk - r6(v2,v3 ) )  : -  sub(x , y , z , x1,w , d ) ,  r6(x1,v2,v3 ) . `",
    "+ `  involvedatom(k - r7(y ) ,  nk - r7(v3 ) )  : -  sub(x , y , z , x1,w , d ) ,  r7(y , v2,v3 ) . `",
    "+ `  confcomp(k )  : -  involvedatom(k , nk1 ) ,  involvedatom(k , nk2 ) ,",
    "nk1  >  nk2 .",
    "`     + `  safeans(z , w , d )  : -  sub(x , y , z , x1,w , d ) ,  not  confcomp(k - r5(x ) ) , ` + `  not  confcomp(k - r6(x1 ) ) ,  not  confcomp(k - r7(y ) ) . `",
    "[ [ hypergraph - construction . ] ] hypergraph construction .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +     + `  subeq(sid(x , y , z , x1,w ,",
    "d ) ,  ans(z , w , d ) )  : -  sub(x , y , z , x1,w , d ) ,  not  safeans(z , w , d ) . ` +   + `  compek(k - r5(x ) ,  ans )  : -  subeq(sid(x , y , z , x1,w , d ) ,  ans ) . `",
    "+ `  compek(k - r6(x1 ) ,  ans )  : -  subeq(sid(x , y , z , x1,w , d ) ,  ans ) . `",
    "+ `  compek(k - r7(y ) ,  ans )  : -  subeq(sid(x , y , z , x1,w , d ) ,  ans ) . `",
    "+ `  insubeq(atom - r5(x , y , z ) ,  sid(x , y , z , x1,w , d ) )  : -  subeq(sid(x , y , z , x1,w , d ) ,  _ ) . `",
    "+ `  insubeq(atom - r6(x1,y , w ) ,  sid(x , y , z , x1,w , d ) )  : -  subeq(sid(x , y , z , x1,w , d ) ,  _ ) . ` + `  insubeq(atom - r7(y , d ) ,  sid(x , y , z , x1,w , d ) )  : -  subeq(sid(x , y , z , x1,w , d ) ,  _ ) . ` +   + `  incompek(atom - r5(x , v2,v3 ) ,  k - r5(x ) )  : -  compek(k - r5(x ) ,  ans ) , ` + `  involvedatom(k - r5(x ) ,  nk - r5(v2,v3 ) ) . `",
    "+ `  incompek(atom - r6(x1,v2,v3 ) ,  k - r6(x1 ) )  : -  compek(k - r6(x1 ) ,  ans ) , ` + `  involvedatom(k - r6(x1 ) ,  nk - r6(v2,v3 ) ) . ` + `  incompek(atom - r7(y , v3 ) ,  k - r7(y ) )  : -  compek(k - r7(y ) ,  ans ) , ` + `  involvedatom(k - r7(y ) ,  nk - r7(v3 ) ) . `",
    "[ [ pruning . ] ] pruning .",
    "+ + + + + + + +     + `  redcomp(k , ans )  : -  compek(k , ans ) ,  incompek(a , k ) , ` + `  # count{s :  insubeq(a , s ) ,  subeq(s , ans ) }  =  0 . `",
    "+   + `  unfsub(s , ans )  : -  subeq(s , ans ) ,  insubeq(a , s ) ,  incompek(a , k ) ,  redcomp(k , ans ) . ` +   + `  redcomp(k , ans )  : -  compek(k , ans ) ,  incompek(a ,",
    "k ) , ` + `  x  =  # count{s :  insubeq(a , s ) ,  subeq(s , ans ) } ` + `  # count{s :  insubeq(a , s ) ,  unfsub(s , ans ) }  > =  x. ` +   + `  residualsub(s , ans )  : -  subeq(s , ans ) ,  not  unfsub(s , ans ) . `    [ [ fragments - identification . ] ] fragments identification .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +     + `  sharesub(k1,k2,ans )  : -  residualsub(s , ans ) ,  insubeq(a1,s ) ,  insubeq(a2,s ) , ` + `  a1  < >  a2 ,  incompek(a1,k1 ) ,  incompek(a2,k2 ) ,  k1  < >  k2 . ` +   + `  ancestorof(k1,k2,ans )  : -  sharesub(k1,k2,ans ) ,  k1  <  k2 . `",
    "+ `  ancestorof(k1,k3,ans )  : -  ancestorof(k1,k2,ans ) ,  sharesub(k2,k3,ans ) ,  k1  <  k3 . `",
    "+   + `  child(k , ans )  : -  ancestorof(_,k , ans ) . `",
    "+   + `  keycompinfrag(k1 ,  fid(k1,ans ) )  : -  ancestorof(k1,_,ans ) ,  not  child(k1,ans ) . `",
    "+ `  keycompinfrag(k2 ,  fid(k1,ans ) )  : -  ancestorof(k1,k2,ans ) ,  not  child(k1,ans ) . `",
    "+   + `  subinfrag(s , fid(kf , ans ) )  : -  residualsub(s , ans ) ,  insubeq(a , s ) , ` + `  incompek(a , k ) ,  keycompinfrag(k , fid(kf , ans ) ) . `",
    "+   + `  frag(fid(k , ans),ans )  : -  keycompinfrag(_,fid(k , ans ) ) . `    [ [ repairs - construction . ] ] repairs construction .",
    "+ + + + + + + + + + + + + + + + + + + + +     + `  1  < =  { activefrag(f):frag(f , ans ) }  < =  1  : -  frag ( _ , _ ) . `",
    "+   + `  1",
    "< =  { activeatom(a):incompek(a , k ) }  < =  1  : -  activefrag(f ) ,  keycompinfrag(k , f ) . ` +   + `  ignoredsub(s )  : -  activefrag(f ) ,  subinfrag(s , f ) ,  insubeq(a , s ) ,  not  activeatom(a ) . `    [ [ new - query . ] ] new query .",
    "+ + + + + + + + + +     + `  q`@xmath368`(s , z , w , d )  : -  safeans(z , w , d ) . ` + `  q`@xmath368`(f , z , w , d )  : -  frag(f , ans(z , w , d ) ) ,  not  activefrag(f ) . `",
    "+ `  q`@xmath368`(f , z , w , d )  : -  activefrag(f ) ,  subinfrag(s , f ) ,  not  ignoredsub(s ) ,  frag(f , ans(z , w , d ) ) . `",
    "we report in this appendix some additional plots . in particular , we provide @xmath369 detailed plots for the overhead of _ pruning_w.r.t . safe answer computation ; @xmath370 scatter plots comparing , execution by execution , _",
    "pruning_with _ bb_and _ mrt _ ; and , @xmath371 an extract of @xcite concerning the overhead measured for the mip - based approach for easing direct comparison with our results .",
    "we report in the following the detailed plots concerning the overhead of _ pruning_w.r.t . the computation of safe answers .",
    "the results are reported in three plots grouping queries per complexity class in figures  [ fig : ratiosafe ] .",
    "one might wonder what is the picture if the asp - based approaches are compared instance - wise .",
    "an instance by instance comparison of _ pruning_with _ bb_and _ mrt _ , is reported in the scatter plots in figure  [ fig : scatter ] . in these plots a point @xmath372 is reported for each query , where @xmath373 is the running time of _ pruning _ , and @xmath374 is the running time of _ bb_and _ mrt _ , respectively in figure  [ fig : scatter : abc ] and figure  [ fig : scatter : mrt ] .",
    "the plots also report a dotted line representing the secant ( @xmath375 ) , points along this line indicates identical performance , points above the line represent the queries where the method on the @xmath373-axis performs better that the one in the @xmath374-axis and vice versa .",
    "figure  [ fig : comp ] clearly indicates that _ pruning_is also instance - wise superior to alternative methods ."
  ],
  "abstract_text": [
    "<S> consistent query answering over a database that violates primary key constraints is a classical hard problem in database research that has been traditionally dealt with logic programming . </S>",
    "<S> however , the applicability of existing logic - based solutions is restricted to data sets of moderate size . </S>",
    "<S> this paper presents a novel decomposition and pruning strategy that reduces , in polynomial time , the problem of computing the consistent answer to a conjunctive query over a database subject to primary key constraints to a collection of smaller problems of the same sort that can be solved independently . </S>",
    "<S> the new strategy is naturally modeled and implemented using answer set programming ( asp ) . </S>",
    "<S> an experiment run on benchmarks from the database world prove the effectiveness and efficiency of our asp - based approach also on large data sets . to appear in theory and practice of logic programming ( tplp ) , proceedings of iclp 2015 .    </S>",
    "<S> inconsistent databases , primary key constraints , consistent query answering , asp </S>"
  ]
}