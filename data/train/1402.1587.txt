{
  "article_text": [
    "reconfiguration problems have been studied often in recent years .",
    "these arise in settings where the goal is to transform feasible solutions to a problem in a step - by - step manner , while maintaining a feasible solution throughout .",
    "a _ reconfiguration problem _ is obtained by defining _ feasible solutions _ ( or configurations ) for _ instances _ of the problem , and a ( symmetric ) _ adjacency relation _ between solutions .",
    "this defines a _ solution graph _ for every instance , which is usually exponentially large in the input size .",
    "usually , it is assumed that _",
    "adjacency _ and _ being a feasible solution _ can be tested in polynomial time .",
    "typical questions that are studied are deciding the existence of a path between two given solutions _ ( reachability ) _ , finding shortest paths between solutions , deciding whether the solution graph is connected or giving sufficient conditions for this , and giving bounds on its diameter .",
    "for example , the literature contains such results on the reconfiguration of vertex colorings  @xcite , boolean assignments that satisfy a given formula  @xcite , independent sets  @xcite , matchings  @xcite , shortest paths  @xcite , subsets of a ( multi-)set of integers  @xcite , etc .",
    "techniques for many different reconfiguration problems are discussed in  @xcite .",
    "see the recent survey by van den heuvel  @xcite for an overview of and introduction to reconfiguration problems , and a discussion of their various applications .",
    "one of the most well - studied problems of this kind is the reconfiguration of _ independent sets_. for a graph @xmath2 and integer @xmath3 , the independent sets of size at least / exactly @xmath3 of @xmath2 form the feasible solutions .",
    "independent sets are also called _ token configurations _ , where the independent set vertices are viewed as _ tokens .",
    "_ three types of adjacency relations have been studied in the literature : in the _ token jumping ( tj ) _ model  @xcite , a token can be moved from any vertex to any other vertex . in",
    "the _ token sliding ( ts ) _ model , tokens can be moved along edges of the graph  @xcite . in the _",
    "token addition and removel ( tar ) _ model  @xcite , tokens can be removed and added in arbitrary order , though at least @xmath3 tokens should remain at any time ( @xmath3 is the _ token lower bound _ ) . of course ,",
    "in all of these cases , an independent set should be maintained , so tokens can only be moved / added to vertices that are not dominated by the current token configuration .",
    "the _ reachability problem _ has received the most attention in this context : given two independent sets @xmath0 and @xmath1 of a graph @xmath2 , and possibly a token lower bound @xmath9 , is there a path ( or _ reconfiguration sequence _ ) from @xmath0 to @xmath1 in the solution graph ?",
    "we call this problem _ tj - reachability , ts - reachability _ or _ tar - reachability _ , depending on the adjacency relation that is used .",
    "kamiski et al  @xcite showed that the tar - reachability problem generalizes the tj - reachability problem ( see section  [ sec : prelim ] for details ) .",
    "for all three adjacency relations , this problem is pspace - hard , even in perfect graphs  @xcite , and even in planar graphs of maximum degree 3  @xcite .",
    "( the latter result is not explicitly stated in  @xcite , but can easily be deduced from the given reduction .",
    "see  @xcite for more information . )",
    "see also  @xcite for an alternative , simple pspace - hardness proof .",
    "in addition , in  @xcite , the problem of deciding whether there exists a path of length at most @xmath10 between two solutions is shown to be strongly np - hard , for all three adjacency models .    on the positive side",
    ", these problems can be solved in polynomial time for various restricted graph classes .",
    "the result on matching reconfiguration by ito et al  @xcite implies that for line graphs , tj - reachability and tar - reachability can be solved efficiently . in  @xcite , an efficient algorithm is given for ts - reachability in cographs , and it is shown that for tj - reachability in even - hole - free graphs , a reconfiguration sequence exists between any pair of independent sets @xmath0 and @xmath1 , and that the shortest reconfiguration sequence always has length @xmath11 .    [",
    "[ new - results - and - techniques ] ] new results and techniques + + + + + + + + + + + + + + + + + + + + + + + + + +    in this paper , we show that tar - reachability and tj - reachability can be solved in time @xmath6 for cographs , where @xmath5 is the number of vertices of the input graph .",
    "this answers an open question from  @xcite .",
    "in addition , we show that for cographs , components of the solution graph have diameter at most @xmath7 and @xmath12 , under the tar - model and tj - model , respectively .",
    "recall that a graph is a _",
    "iff it has no induced path on four vertices .",
    "alternatively , cographs can be defined as graphs that can be obtained from a collection of trivial ( one vertex ) graphs by repeatedly applying _ ( disjoint ) union _ and _ ( complete ) join _ operations .",
    "the order of these operations can be described using a rooted _",
    "cotree_. this characterization allows efficient dynamic programming ( dp ) algorithms for various np - hard problems . our algorithm is also a dp algorithm over the cotree , albeit more complex than many known dp algorithms on cographs . for both solutions @xmath13 and @xmath14 , certain values are computed , using first a _ bottom up _ dp phase , and next a _",
    "dp phase over the cotree .",
    "using these values , we can conclude whether @xmath14 is reachable from @xmath13 .",
    "because of this method , we in fact obtain a stronger result : tj- and tar - reachability can be decided efficiently for any graph that can be obtained using join and union operations , when starting with a collection of base graphs from a graph class @xmath8 that satisfies the following properties :    * for any graph in @xmath8 , the tar - reachability problem can be decided efficiently , and * for any graph in @xmath8 and independent set  @xmath0 , the size of a maximum independent set that is tar - reachable from @xmath0 can be computed efficiently , for all token lower bounds @xmath15 .    in this paper , we show that an example of such a graph class is the class of _ chordal graphs_. in another paper , we show that the class of _ claw - free graphs _ also satisfies these properties  @xcite . combining these results yields quite a rich graph class for which this pspace - hard problem can be solved in polynomial time .",
    "another motivation for this research is that cographs form the base class for various graph width measures : cographs are exactly the graphs of cliquewidth at most two , and exactly the graphs of modular - width two  @xcite .",
    "the corresponding graph decompositions ( @xmath3-expressions and modular decompositions ) have been well - studied in algorithmic graph theory , because of the fact that many np - hard problems can be solved efficiently on graphs where the width of these decompositions is low , using dp algorithms  @xcite .",
    "another similar , successful and widely used notion is that of a tree decomposition / the treewidth of a graph  @xcite .",
    "the success of such approaches for np - complete problems and np - optimization problems is unmistakable in the area of algorithmic graph theory .",
    "however , surprisingly , no nontrivial results of this kind are known for reconfiguration problems , to our knowledge . more precisely : we are not aware of any reconfiguration problems that are pspace - hard in general , but that can be solved efficiently on graphs of treewidth or cliquewidth at most @xmath3 , for every constant @xmath3 . on the other hand ,",
    "none of the studied reconfiguration problems have been shown to be pspace - hard on graphs of bounded treewidth / cliquewidth .",
    "we expect that positive results of this kind are certainly possible , but have not yet been obtained due to the lack of dp techniques for reconfiguration problems .",
    "this paper gives a first example of how dynamic programming over graph decompositions can be used successfully for pspace - hard reconfiguration problems .",
    "this is a first step towards solving various reconfiguration problems for graphs of bounded ( modular- , clique- , tree- ) width ; we expect that similar algorithmic techniques can be used and are necessary to show that indeed , various reconfiguration problems can be solved efficiently using dp over graph decompositions .",
    "we remark that a dp approach has also been used to show that the pspace - hard shortest path reconfiguration problem can be solved in polynomial time on planar graphs  @xcite , although a problem - specific layer decomposition of the graph was used .",
    "our dp algorithm for the tar - reachability problem is presented in sections  [ sec : modulelemmas][sec : summary ] .",
    "first , in section  [ sec : outline ] , an example is given , the proof of this statement is outlined , and a detailed overview of sections  [ sec : modulelemmas][sec : summary ] is given . in section",
    "[ sec : graphclasses ] , examples of graph classes are given for which this algorithm works ; in particular graphs obtained from chordal graphs using union and join operations ( which includes cographs ) . the bound on the diameter of the solution graph is given in section  [ sec : diameter ] .",
    "we start in section  [ sec : prelim ] with precise definitions , and end in section  [ sec : discussion ] with a discussion .",
    "[ [ token - addition - and - removal ] ] token addition and removal + + + + + + + + + + + + + + + + + + + + + + + + + +    by @xmath16 we denote the maximum size of an independent set in @xmath2 . in this paper",
    ", we use the _",
    "token addition and removal ( tar ) _ model for independent set reconfiguration . for a graph @xmath2 and integer @xmath3 , the vertex set of the graph",
    "@xmath17 is the set of all independent sets of size at least @xmath3 in @xmath2 .",
    "two distinct independent sets @xmath0 and @xmath1 are adjacent in @xmath17 if there exists a vertex @xmath18 such that @xmath19 or @xmath20 .",
    "vertices from independent sets will also be called _",
    "tokens _ , and we will also say that @xmath1 is obtained from @xmath0 by _ adding one token on @xmath21 _ resp .  _ removing one token from @xmath21 _ , or that _ @xmath1 is obtained from @xmath0 using one -step . _    for an integer @xmath3 and two independent sets @xmath0 and @xmath1 of @xmath2 with @xmath22 and @xmath23 , we write @xmath24 if @xmath17 contains a path from @xmath0 to @xmath1 .",
    "observe that @xmath25 always holds , and that the relation @xmath26 is an equivalence relation , for all @xmath2 and @xmath3 .",
    "the superscript @xmath2 is omitted if the graph in question is clear .",
    "if @xmath2 and @xmath3 are clear from the context , we will also simply say that _",
    "@xmath1 is reachable from @xmath0_. a sequence @xmath27 is called a _",
    "@xmath3-tar - sequence _  for @xmath2 from @xmath28 to @xmath29",
    "if    * for every @xmath30 , @xmath31 is an independent set of @xmath2 , * for every @xmath30 , @xmath32 , and * for every @xmath30 , @xmath33 can be obtained from @xmath31 using at most one -step .",
    "observe that @xmath24 if and only if there exists a @xmath3-tar - sequence  in @xmath2 from @xmath0 to @xmath1 .",
    "note that we allow that @xmath34 , in order to avoid discussing trivial cases in our proofs .",
    "our results also apply to the _ token jumping ( tj ) _ model : for a graph @xmath2 and integer @xmath3 , the vertex set of the graph @xmath35 is the set of all independent sets of size _ exactly _ @xmath3 in @xmath2 .",
    "two distinct independent sets @xmath0 and @xmath1 are adjacent in @xmath35 if there exist vertices @xmath36 and @xmath37 such that @xmath38 .",
    "we say that @xmath1 is obtained from @xmath0 by _ jumping a token from @xmath39 to @xmath21 .",
    "_ analogously to before , this defines tj - sequences from @xmath0 to @xmath1 , and we write @xmath40 if a tj - sequence  from @xmath0 to @xmath1 exists .",
    "kamiski et al showed that the tar - model generalizes the tj - model , in the following way :    [ lem : tjistar ] let @xmath13 and @xmath14 be two independent sets of a graph @xmath2 , with @xmath41 .",
    "then for any @xmath42 , there exists an @xmath43-tar - sequence  from @xmath13 to @xmath14 of length at most @xmath44 if and only if there exists a tj - sequence  from @xmath13 to @xmath14 of length at most @xmath3 .",
    "we remark that the tar - model as defined in  @xcite is a little more restricted : for our algorithms , it is essential to consider the case where the token lower bound @xmath3 is equal to the size of the initial independent sets @xmath13 and @xmath14 , whereas in  @xcite , only the case where @xmath45 is considered .",
    "[ [ cographs - and - cotree - decompositions ] ] cographs and cotree decompositions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for an illustration of the following definitions , see figure  [ fig : cotree ] .",
    "generalized cotree _ is a binary tree @xmath46 with root @xmath47 , together with    * a partition of the nonleaf vertices into _ union nodes _ and _ join nodes _ , and * a graph @xmath48 for every leaf @xmath39 of @xmath46 , such that for any two leaves @xmath39 and @xmath21 , the graphs @xmath48 and @xmath49 are vertex and edge disjoint",
    ".    vertices of @xmath46 are called _",
    "nodes_. for every nonleaf node @xmath39 , the two children are ordered ; they are called the _ left child _ and _ right child _ of @xmath39 . with every node",
    "@xmath50 we associate a graph @xmath48 in the following way : for leaves @xmath39 , @xmath48 is as given .",
    "otherwise , @xmath39 has two child nodes ; denote these by @xmath21 and @xmath51 . if @xmath39 is a union node , then @xmath48 is the _ disjoint union _ of @xmath49 and @xmath52 .",
    "if @xmath39 is a join node , then @xmath48 is obtained by taking the _ complete join _ of @xmath49 and @xmath52 .",
    "this operation is defined as follows : start with the disjoint union of @xmath49 and @xmath52 , and add edges @xmath53 for every combination of @xmath54 and @xmath55 . for a node @xmath50 , we denote @xmath56 .",
    "a generalized cotree @xmath46 is called a _ cotree _ if for every leaf @xmath57 , the graph @xmath49 consists of a single vertex .",
    "such a leaf is called a _",
    "trivial leaf_.    let @xmath46 be a ( generalized ) cotree , with root @xmath47 . for a graph @xmath2 ,",
    "we say that @xmath46 is a _ ( generalized ) cotree for @xmath2 _ if @xmath58 .",
    "a graph @xmath2 is called a _ cograph _ if there exists a cotree for @xmath2 .",
    "let @xmath8 be a graph class .",
    "we say that a generalized cotree @xmath46 for a graph @xmath2 is a _ cotree decomposition of @xmath2 into @xmath8-graphs _ if for every leaf @xmath57 , the graph @xmath59 .",
    "for instance , we will consider cotree decompositions into chordal graphs .",
    "in this section , we will give an example , and use it to introduce the techniques and notions that will be used in the proofs .",
    "we will end with an outline of the algorithm , and overview of the paper .",
    "[ [ example ] ] example + + + + + + +    in figure  [ fig : cotree ] , a cograph @xmath2 together with a cotree @xmath46 of @xmath2 is shown .",
    "the root of @xmath46 is @xmath47 , and @xmath60 .",
    "the graph @xmath2 has three components , which are @xmath49 , @xmath52 and @xmath61 .    in figure",
    "[ fig : longtarseq ] , three independent sets @xmath13 , @xmath14 and @xmath62 are shown for the cograph @xmath2 from figure  [ fig : cotree ] . in order to go from @xmath13 to @xmath14 in @xmath63 , an independent set  must be visited which has no tokens on the component @xmath61 , and therefore at least five tokens on the other two components .",
    "the only such independent set  of @xmath2 is @xmath62 . using similar observations",
    ", it can be seen that there the _ shortest _ @xmath64-tar - sequence  from @xmath13 ( or @xmath14 ) to @xmath62 is unique up to symmetries , and has length twelve ( six additions and six deletions ) .",
    "hence the shortest @xmath64-tar - sequence  from @xmath13 to @xmath14 has length 24 .",
    "[ [ proof - outline - and - definitions ] ] proof outline and definitions + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for two independent sets @xmath13 and @xmath14 of a graph @xmath2 , both with size at least @xmath3 , we will characterize whether @xmath65 , using a ( generalized ) cotree for @xmath2 .",
    "this requires the following notion .",
    "[ def : freedom ] let @xmath46 be a generalized cotree for a graph @xmath2 , @xmath0 be an independent set of @xmath2 , and @xmath15 .",
    "for @xmath57 , define @xmath66 over all independent sets @xmath1 of @xmath2 with @xmath24 .",
    "for instance , in the example from figure  [ fig : longtarseq ] , @xmath67 , and this fact is essential for concluding that @xmath68 in this case . in general , the following theorem characterizes whether @xmath14 is reachable from @xmath13 , using the values from definition  [ def : freedom ] .",
    "[ thm : new_main_combin ] let @xmath46 be a generalized cotree for a graph @xmath2 .",
    "let @xmath13 and @xmath14 be two independent sets of @xmath2 of size at least @xmath3 . then @xmath65 if and only if    1 .",
    "[ it : one ] for all nodes @xmath50 , @xmath69 , and 2 .",
    "[ it : two ] for all leaves @xmath50 , @xmath70 , where @xmath71 .",
    "the forward direction of the statement is straightforward : if @xmath65 , then since @xmath26 is an equivalence relation , any independent set  @xmath1 is reachable from @xmath13 if and only if it is reachable from @xmath14 .",
    "it follows that @xmath72 for all @xmath57 .",
    "the second property follows by restricting all independent sets in a @xmath3-tar - sequence  from @xmath13 to @xmath14 to the subgraph @xmath49 for any leaf @xmath57 . by definition , these all have size at least @xmath73 , so this yields an @xmath74-tar - sequence  from @xmath75 to @xmath76 for @xmath49 . for more details , see section  [ sec : summary ] , where theorem  [ thm : new_main_combin ] is proved .    in order to efficiently decide whether @xmath65 , it remains to compute the values @xmath77 for all @xmath57 and @xmath78 .",
    "how this can be done is shown in section  [ sec : topdown ] .    in the example from figure",
    "[ fig : longtarseq ] , it holds that @xmath79 .",
    "this is because on the subgraph @xmath48 , which is the disjoint union of components @xmath49 and @xmath52 , it is possible to reconfigure from the initial independent set  @xmath13 to an independent set  with at least five tokens on @xmath48 , while keeping at least two tokens on @xmath48 throughout .",
    "this indicates that in order to compute the values @xmath77 , the following values must be computed , for different values of @xmath80 .",
    "[ def : ris ] let @xmath46 be a cotree for @xmath2 , and @xmath0 be an independent set of @xmath2 . for @xmath57 and @xmath81 , denote by @xmath82 the maximum of @xmath83 over all independent sets @xmath1 of @xmath49 with @xmath84 .",
    "note that the value @xmath82 depends only on the situation in the subgraph @xmath49 ; not on the entire graph .",
    "this is in contrast to the values @xmath85 .",
    "observe also that @xmath86 ( regardless of the choice of @xmath0 ) .",
    "it is not obvious how to compute the values @xmath87 .",
    "for the example from figure  [ fig : longtarseq ] , concluding that @xmath88 requires studying the following 2-tar - sequence  for @xmath48 .",
    "we start with one token on both @xmath49 and @xmath52 .",
    "one token can be added on @xmath49 .",
    "this allows removing the token from @xmath52 , and subsequently moving to a better configuration , with two tokens on @xmath52 .",
    "this in turn allows removing all tokens from @xmath49 , and subsequently moving to a better configuration , with three tokens on @xmath49 . a sequence of this type",
    "is called a _ cascading sequence_. informally , in such a sequence , we have a join node @xmath39 with children @xmath21 and @xmath51 , and alternatingly move between on one hand a large independent set  on @xmath21 and a small independent set  on @xmath51 and on the other hand a large independent set  on @xmath51 and small independent set  on @xmath21 .",
    "the goal is to obtain ever larger independent sets until no more improvements can be made . in section  [ ssec : risrules ]",
    ", we will show how to compute the values @xmath89 .",
    "this is done by characterizing the outcome of such cascading sequences , using _",
    "maximum @xmath74-stable tuples_.    the values @xmath87 for a node @xmath39 with children @xmath21 and @xmath51 can be computed using only the values @xmath90 and @xmath91 for different choices of @xmath92 .",
    "hence these values can be computed using a _ bottom up _",
    "dynamic programming algorithm , which starts at the leaves of the cotree .",
    "next , the rules from section  [ sec : topdown ] for computing the values @xmath93 can be used .",
    "as indicated by their definitions , computing these values requires considering the entire graph .",
    "therefore this must be done using a _ top down",
    "_ dynamic programming algorithm , which starts at the root node of @xmath46 .",
    "together with theorem  [ thm : new_main_combin ] , this yields our algorithm for deciding whether @xmath65 .",
    "our main algorithmic result is summarized in the next theorem , which is proved in section  [ sec : summary ] .",
    "[ thm : main_alg ] let @xmath46 be a generalized cotree for a graph @xmath2 on @xmath5 vertices , let @xmath42 and let @xmath13 and @xmath14 be independent sets of @xmath2 .",
    "if for every nontrivial leaf @xmath57 and relevant integer @xmath74 ,    * the values @xmath94 and @xmath95 are known , and * it is known whether @xmath96 ,    then in time @xmath6 it can be decided whether @xmath65 .",
    "in particular , theorem  [ thm : main_alg ] implies that for any two independent sets @xmath13 and @xmath14 for a _ cograph _ @xmath2 , it can be decided in time @xmath6 whether @xmath65 .    in section  [ sec : diameter ]",
    ", we will give an upper bound for the length of a shortest @xmath3-tar - sequence  between two independent sets @xmath13 and @xmath14 .",
    "the above example shows that to go from @xmath13 to @xmath14 , it may be necessary to put tokens on vertices that are neither in @xmath13 nor in @xmath14 .",
    "nevertheless , we can show that for a commonly reachable independent set",
    "@xmath62 , there exists a @xmath3-tar - sequence  from @xmath13 ( resp .",
    "@xmath14 ) to @xmath62 that for every vertex @xmath18 , adds a token on @xmath21 at most once .",
    "this shows that there exists a @xmath3-tar - sequence  from @xmath13 to @xmath14 of length at most @xmath97 .    for all of our proofs",
    ", an essential fact is that for every node @xmath39 , the vertex set @xmath98 is a module of @xmath2",
    ". we will first give lemmas related to independent set  reconfiguration and modules in section  [ sec : modulelemmas ] .",
    "a _ module _ of a graph @xmath2 is a set @xmath99 such that for every @xmath100 , either @xmath101 or @xmath102 . in other words : for every pair @xmath103 , @xmath104 .",
    "note that we will also consider @xmath105 to be a ( trivial ) module of @xmath2 .",
    "we will often use the following simple property of cographs .",
    "[ propo : module ] let @xmath46 be a cotree of @xmath2 .",
    "then for any @xmath57 , @xmath106 is a module of @xmath2 .",
    "modules are very useful for independent set reconfiguration , since to some extent , we can reconfigure within the module and outside of the module independently .",
    "the following two lemmas make this more precise , and present two useful properties for the proofs below .",
    "these two lemma proofs also introduce proof techniques related to tar - sequences that will be used often below .",
    "later , we will however not apply them in the same level of detail again .",
    "[ lem : modulea ] let @xmath107 be a module of a graph @xmath2 , let @xmath3 and @xmath108 be integers , and let @xmath13 be an independent set  of @xmath2 , with @xmath109 and @xmath110",
    ". denote @xmath111 $ ] .",
    "if there exists an independent set  @xmath14 of @xmath2 with @xmath112 and @xmath113 , and if there exists an independent set  @xmath62 of @xmath114 with @xmath115 , then there exists an independent set  @xmath116 of @xmath2 with @xmath117 and @xmath118 .",
    "denote @xmath119 , and @xmath120 .",
    "first consider the case that @xmath121 .",
    "informally , we can then simply apply the same vertex additions and removals from the @xmath108-tar - sequence  from @xmath122 to @xmath62 to the entire independent set  @xmath13 , and this way maintain an independent set throughout .",
    "formally , let @xmath123 be an @xmath108-tar - sequence  for @xmath114 from @xmath122 to @xmath62 .",
    "define @xmath124 for all @xmath30 .",
    "then @xmath125 is the desired @xmath3-tar - sequence  from @xmath13 to an independent set  @xmath116 of @xmath2 with @xmath118 .",
    "indeed ,    * for every @xmath30 , both @xmath31 and @xmath126 are independent sets .",
    "since @xmath107 is a module and @xmath127 , @xmath126 contains no vertices that are adjacent to any vertex in @xmath107 , so @xmath128 is again an independent set of @xmath2 . * since @xmath121 , we have @xmath129 . by definition , for every @xmath30 it holds that @xmath130 , and thus @xmath131 . * clearly , every @xmath132 can be obtained from @xmath128 using at most one -step .    in the remaining case",
    ", we may assume that @xmath133 .",
    "consider a _",
    "shortest _ @xmath3 - -seq  @xmath134 from @xmath13 to _ any _ independent set  @xmath14 of @xmath2 with @xmath113 .",
    "so for every @xmath30 with @xmath135 , @xmath136 , and @xmath137 is obtained from @xmath138 by removing a vertex from @xmath107 .",
    "since @xmath107 is a module and @xmath138 is an independent set , this implies that no vertex in @xmath139 is adjacent to any vertex in @xmath107 .",
    "denote @xmath140 .",
    "informally , we can now reverse the tar - sequence  @xmath141 , but ignore every token addition or removal on @xmath142 .",
    "this yields a @xmath3-tar - sequence  for @xmath2 , from @xmath14 to @xmath143 . since @xmath144",
    ", we can now apply the token additions and removals from the tar - sequence  from @xmath122 to @xmath62 to this independent set , similar to above , and obtain the desired independent set  @xmath145 . combining these three @xmath3-tar - sequences",
    "shows that there is a @xmath3-tar - sequence  from @xmath13 to @xmath116 .",
    "we now define this more precisely , and verify that these are indeed tar - sequences .    for every @xmath30 , denote @xmath146 . consider the sequence @xmath147 .",
    "the argue that this is a @xmath3-tar - sequence  from @xmath14 to @xmath143 :    * as observed above , no vertex in @xmath148 is adjacent to any vertex in @xmath107 .",
    "hence for every @xmath30 , @xmath149 is an independent set . *",
    "recall that for every @xmath30 , @xmath150 , and @xmath144 , so @xmath151 .",
    "* clearly , consecutive sets in the sequence can be obtained from each other by at most one -step .",
    "analog to the first part of the proof , one can show that there exists a @xmath3-tar - sequence  @xmath152 for @xmath2 from @xmath143 to @xmath153 . combining the sequences @xmath141 , @xmath154 and @xmath152 shows that @xmath155 , which proves the statement .    using similar techniques",
    ", we can prove the next lemma .",
    "this applies to the case where one module @xmath107 can be partitioned into two sets @xmath156 and @xmath157 , with no edges between them , which therefore are also modules .",
    "[ lem : moduleb ] let @xmath107 be a module of a graph @xmath2 , such that @xmath107 can be partitioned into two sets @xmath156 and @xmath157 with no edges between @xmath156 and @xmath157 .",
    "let @xmath13 be an independent set  of @xmath2 , let @xmath158 be an independent set  of @xmath2 with @xmath159 , that maximizes @xmath160 among all such sets , and let @xmath161 be an independent set  of @xmath2 with @xmath162 .",
    "then there exists an independent set  @xmath62 of @xmath2 with @xmath163 and @xmath164 , for @xmath165 .",
    "if @xmath166 , then by definition of @xmath158 , it also holds that @xmath167 , and therefore chosing @xmath168 proves the statement .",
    "so now suppose that @xmath169 .",
    "since the relation @xmath170 is an equivalence relation , we conclude that there exists a @xmath3-tar - sequence  @xmath171 from @xmath158 to @xmath161 . we will use @xmath141 to show that there exists an independent set  @xmath62 of @xmath2 with @xmath172 and @xmath164 , for @xmath165 . combining this with @xmath159 shows that also @xmath163 , which proves the statement .",
    "first suppose that @xmath141 contains an independent set  that contains no vertices of @xmath107 .",
    "then let @xmath31 be the first such independent set , so @xmath173 and @xmath31 is obtained from @xmath174 by removing a token from @xmath107 .",
    "since @xmath107 is a module and @xmath174 is an independent set , @xmath31 therefore contains no vertex that is adjacent to any vertex in @xmath107 .",
    "we can then simply add the vertices in @xmath175 and @xmath176 to @xmath31 in any order , to obtain the desired independent set  @xmath62 ( recall that there are no edges between @xmath156 and @xmath157 ) . combining the tar - sequences from @xmath13 to @xmath158 , from @xmath158 to @xmath31 , and from @xmath31 to @xmath62 shows that @xmath163 .",
    "so now we may assume that every independent set  @xmath31 in the sequence @xmath141 contains at least one vertex of @xmath107 .",
    "then we modify @xmath141 as follows : we ignore all token additions and removals on @xmath156 .",
    "we argue that this is a @xmath3-tar - sequence  from @xmath158 to @xmath177 .",
    "more precisely , for every @xmath30 define @xmath178 , and consider the sequence @xmath179 .",
    "we argue that @xmath154 is a @xmath3-tar - sequence  for @xmath2 :    * suppose to the contrary that there exists an @xmath30 such that @xmath128 is not an independent set .",
    "let @xmath30 be the minimum index with this property",
    ". then @xmath31 is obtained from @xmath174 by adding a vertex @xmath108 that is adjacent to some vertex in @xmath158 . because vertices in @xmath157 are not adjacent to vertices in @xmath156",
    ", it follows that @xmath180 . since @xmath107 is a module",
    ", @xmath108 is adjacent to every vertex in @xmath107 . but @xmath31 contains at least one vertex of @xmath107 , contradicting that it is an independent set .",
    "we conclude that every @xmath128 is an independent set .",
    "* let @xmath181 .",
    "since every independent set  @xmath31 is also reachable from @xmath13 , from the definition of @xmath158 it follows that @xmath182 .",
    "therefore , @xmath183 .",
    "it follows that for every @xmath30 , @xmath184 . * clearly ,",
    "consecutive sets in the sequence @xmath154 can be obtained from each other using at most one -step .",
    "we conclude that @xmath172 .",
    "combined with @xmath159 , it follows that @xmath163 .",
    "in section  [ ssec : risrules ] below we will give dynamic programming rules for computing the values @xmath185 for all nodes @xmath50 .",
    "recall that @xmath186 where the maximum is taken over all independent sets @xmath1 of @xmath48 with @xmath187 . for trivial leaves and",
    "join nodes , the rules are straightforward . as discussed in section  [ sec : outline ] , the computation for union nodes is more complicated , and requires studying the outcome of certain @xmath74-tar - sequences in @xmath48 , which we will informally call _ cascading sequences_.    we first introduce these informally , using the example shown in figure  [ fig : cascading ] .",
    "this figure depicts a cograph @xmath48 which is obtained by taking the disjoint union of two cographs @xmath49 and @xmath52 . in this figure , a bold line between two encircled sets @xmath188 and @xmath189 of vertices means that edges @xmath190 are present between every @xmath191 and @xmath192",
    "this corresponds to a complete join of @xmath193 $ ] and @xmath194 $ ] .",
    "let @xmath0 be the independent set  of @xmath48 consisting of the white vertices .",
    "in table  [ tab : risexample ] , the values @xmath89 and @xmath195 are given for every @xmath196 .",
    "( these values can easily be verified .",
    "see also figure  [ fig : suseqs ] for examples of maximum independent sets that are reachable from @xmath197 in @xmath198 for various values of @xmath74 , and @xmath199 . )",
    "let the _ type _ of an independent set @xmath1 of @xmath48 be @xmath200 .",
    "if it is required to keep at least @xmath201 tokens on @xmath48 throughout , then from the initial independent set  @xmath0 , which is of type @xmath202 , we can go to an independent set  of type @xmath203 .",
    "this holds by definition of @xmath204 and @xmath205 , and because we can reconfigure in both components independently , as long as at least three tokens remain on both sides . from this",
    ", we could go to a independent set  of type @xmath206 , but this does not enable further improvements .",
    "so we conclude that @xmath207 .",
    "if @xmath208 , then observe that we can go from the initial independent set  of type @xmath202 to one of type @xmath209 , and subsequently to one of type @xmath210 .",
    "next , we can visit independent sets of types @xmath211 and @xmath212 .",
    "we could then go to one of type @xmath213 , but since @xmath214 , this yields no improvement .",
    "we conclude that @xmath215 . finally ,",
    "if @xmath216 , then we can visit independent sets of types @xmath202 , @xmath217 , @xmath218 , @xmath219 , @xmath220 , @xmath221 , in this order , using similar arguments . since @xmath222 ,",
    "no further improvements are possible , so @xmath223 for all @xmath216 .",
    "this yields the values @xmath224 shown in table  [ tab : risexample ] .",
    "note that we can deduce these values using only the previous two columns of the table ; without considering other details about the graph .",
    "@xmath225    below we will prove that the values computed this way are correct .",
    "however , we will not formalize cascading sequences , but instead characterize their outcome",
    ". we will define _ maximum @xmath74-stable tuples @xmath226 _ for each @xmath227 , and show that @xmath228 and @xmath229 , where in both cases the minimum is taken over all independent sets @xmath1 of @xmath48 with @xmath187 .",
    "so for the example above and @xmath230 , these tuples can be verified to be @xmath231 , @xmath232 and @xmath233 respectively .",
    "( as indicated by the above cascading sequences . )",
    "next , we will show that @xmath234 , where @xmath226 is the maximum @xmath74-stable tuple .",
    "the maximum @xmath74-stable tuple can easily be computed from its definition , given below .      throughout this section",
    ", @xmath46 denotes a generalized cotree of @xmath2 and @xmath0 denotes an independent set  of @xmath2 .",
    "the following property follows easily from the definition of @xmath185 , and will often be used in this section .",
    "[ propo : rismonotone ] let @xmath50 .",
    "for any two integers @xmath235 with @xmath236 , it holds that @xmath237 .    for trivial leaf nodes ,",
    "the computation of these values is easy :    [ propo : risleaf ] let @xmath50 be a trivial leaf node",
    ". then @xmath238 for all @xmath74 .    for join nodes ,",
    "the computation of @xmath185 is still relatively straightforward .",
    "note that for any join node @xmath39 and independent set  @xmath0 , @xmath39 has a child @xmath51 with @xmath239 .",
    "[ propo : risjoin ] let @xmath50 be a join node .",
    "let @xmath51 be a child of @xmath39 with @xmath240 , and let @xmath21 be the other child of @xmath39 .",
    "* @xmath241 for all @xmath242 , and * @xmath243 .    because all edges are present between @xmath49 and @xmath52 , a maximum independent set of @xmath48 is either a maximum independent set  of @xmath49 or of @xmath52 , so @xmath244 .",
    "now consider the case @xmath242 , and thus @xmath245 .",
    "then initially all tokens of @xmath0 are on the child @xmath49 .",
    "as long as there is at least one token on @xmath49 , no tokens can be added to @xmath52 .",
    "so essentially , @xmath52 can be ignored , and thus @xmath241 .    for union nodes @xmath39",
    ", we will show that the value of @xmath185 can be characterized using _ maximum stable tuples _",
    ", which are defined as follows .    for a union node @xmath39 with left child @xmath21 and right child",
    "@xmath51 , independent set @xmath246 and integer @xmath247 , call a tuple @xmath226 of integers with @xmath248 and @xmath249 _ @xmath74-stable _ if @xmath250 call an @xmath74-stable tuple @xmath226 _ maximum _ if there is no @xmath74-stable tuple @xmath251 with @xmath252 , @xmath253 and @xmath254 .    in the remainder of this section , we will first prove that for every @xmath74 , there exists a unique maximum @xmath74-stable tuple @xmath226 , and characterize this tuple ( lemma  [ lem : uniquestablecharacterization ] below ) . using this characterization",
    ", we can show that for a union node @xmath39 with children @xmath21 and @xmath51 and any @xmath74 , @xmath255 , where @xmath226 is the unique maximum @xmath74-stable tuple ( lemma  [ lem : risunion ] below ) .",
    "[ lem : uniquestablecharacterization ] let @xmath50 be a union node , with left child @xmath21 and right child @xmath51 . for @xmath227 , let @xmath228 and @xmath229 , where in both cases the minimum is taken over all independent sets @xmath1 of @xmath48 with @xmath256 .",
    "then @xmath226 is the unique maximum @xmath74-stable tuple for @xmath0 and @xmath39 .",
    "before we can prove lemma  [ lem : uniquestablecharacterization ] , we first need to prove a number of other statements .",
    "these statements will refer to notations @xmath0 , @xmath39 , @xmath21 , @xmath51 , @xmath257 , @xmath108 , @xmath74 as defined in lemma  [ lem : uniquestablecharacterization ] .",
    "in addition , we will denote @xmath258 .",
    "[ propo : claima ] consider a tar - sequence  @xmath259 in @xmath260 with @xmath261 .",
    "let @xmath262 and @xmath263 .",
    "then @xmath264 and @xmath265 .",
    "consider the sequence @xmath266 with @xmath267 for all @xmath30 .",
    "this is a @xmath268-tar - sequence  for @xmath52 that ends with @xmath269 .",
    "so by definition , @xmath270 .",
    "the proof of the other statement is analog .    since @xmath257 and @xmath108 ( as defined in lemma  [ lem : uniquestablecharacterization ] )",
    "provide lower bounds for @xmath271 and @xmath268 respectively ( as defined in proposition  [ propo : claima ] ) , we conclude :    [ cor : risisub ] for every @xmath1 with @xmath272 , it holds that @xmath273 and @xmath274 .",
    "using proposition  [ propo : claima ] , we can draw the following two conclusions .",
    "[ propo : eqone ] @xmath275 and @xmath276 .",
    "consider an @xmath74-tar - sequence  @xmath277 for @xmath48 from @xmath278 to an independent set  @xmath279 with @xmath280.let @xmath263 , so @xmath281 . by proposition  [ propo : claima ] , @xmath282 .",
    "using proposition  [ propo : rismonotone ] and @xmath281 , it follows that @xmath283 holds as well .",
    "the other inequality is proved analogously .",
    "[ lem : eqtwo ] for any @xmath74-stable tuple @xmath251 , it holds that @xmath284 and @xmath285 .",
    "suppose to the contrary that there exists an @xmath74-tar - sequence  for @xmath48 from @xmath278 to some independent set  @xmath1 with @xmath286 or @xmath287 .",
    "consider a _",
    "shortest _ @xmath74-tar - sequence  @xmath259 of this kind , and assume w.l.o.g .",
    "this ends with @xmath279 with @xmath288 .",
    "this implies that @xmath289 , and therefore @xmath290 ( since @xmath251 is stable ) .",
    "it follows that @xmath291 , so @xmath292 we obtain @xmath293 let @xmath263 , and choose @xmath30 accordingly such that @xmath294 . combining proposition  [ propo : claima ] with  ( [ eq : x ] ) yields @xmath295 it follows that @xmath296 ( proposition  [ propo : rismonotone ] ) .",
    "so @xmath297 , and thus @xmath298 .",
    "but then the subsequence of @xmath141 that ends with @xmath299 satisfies @xmath300 , and this is a strictly shorter sequence than @xmath141 , a contradiction with the choice of @xmath141 .",
    "[ propo : eqthree ] there exists an independent set  @xmath301 of @xmath48 with @xmath302 and @xmath303 , and there exists an independent set  @xmath304 of @xmath48 with @xmath305 and @xmath306 .",
    "we prove the second statement .",
    "the proof of the first statement is analog . if @xmath307 , then we can simply add vertices from a maximum independent set  @xmath62 of @xmath52 to @xmath278 , one by one .",
    "recall that @xmath308 . since @xmath48 is the disjoint union of @xmath49 and @xmath52 , this yields a tar - sequence  in @xmath48 , from @xmath278 to a independent set  @xmath304 with @xmath309 .",
    "so we may now assume that @xmath310 , and we can apply ( module ) lemma  [ lem : modulea ] , with @xmath278 in the role of @xmath13 , @xmath311 in the role of the module @xmath107 and @xmath48 in the role of the entire graph @xmath2 .",
    "by definition of @xmath108 , there exists an independent set  @xmath14 of @xmath48 with @xmath312 and @xmath313 . by definition of @xmath314",
    ", there exists an independent set  @xmath62 of @xmath52 with @xmath315 and @xmath316 .",
    "now lemma  [ lem : modulea ] shows that there exists an independent set  @xmath304 of @xmath48 with @xmath317 and @xmath318 .",
    "now we are ready to prove lemma  [ lem : uniquestablecharacterization ] .",
    "_ proof of lemma  [ lem : uniquestablecharacterization ] : _ consider @xmath304 as in  proposition  [ propo : eqthree ] .",
    "we can remove all but @xmath319 tokens from @xmath49 , and still have at least @xmath74 tokens in total on @xmath48 .",
    "this shows that @xmath320 .",
    "analogously , @xmath321 follows . combining these inequalities with proposition  [ propo : eqone ] and the obvious inequalities @xmath322",
    ", @xmath323 shows that @xmath324 and @xmath325 , hence the tuple @xmath226 is @xmath74-stable .",
    "furthermore , lemma  [ lem : eqtwo ] shows that @xmath226 is a _ maximum _",
    "@xmath74-stable tuple , and in fact the _ only _ maximum @xmath74-stable tuple .",
    "lemma  [ lem : uniquestablecharacterization ] implies in particular that there exists a unique maximum @xmath74-stable tuple for any choice of @xmath74 . from now on we will now use this fact implicitly , for instance in the following lemma statement .",
    "now we are ready to state and prove lemma  [ lem : risunion ] , which shows how the values @xmath87 can be computed for a join node @xmath39 .",
    "[ lem : risunion ] let @xmath50 be a union node , with left child @xmath21 and right child @xmath51 .",
    "for @xmath227 , let @xmath226 be the unique maximum @xmath74-stable tuple for @xmath0 and @xmath39",
    ". then @xmath326 .",
    "lemma  [ lem : uniquestablecharacterization ] shows that @xmath228 and @xmath229 , where in both cases the minimum is taken over all independent sets @xmath1 of @xmath48 with @xmath256 , so we may apply the above statements that were proved for this choice of @xmath257 and @xmath108 .",
    "for any independent set  @xmath327 of @xmath48 with @xmath328 , corollary  [ cor : risisub ] shows that @xmath329 , so @xmath330 now it suffices to prove that @xmath331 to this end , we will show that ( module ) lemma  [ lem : moduleb ] can be applied , with @xmath48 in the role of the entire graph @xmath2 , @xmath98 in the role of the module @xmath107 , and @xmath106 and @xmath311 in the roles of the modules @xmath156 and @xmath157 , respectively ( recall that @xmath332 should be a partition of @xmath107 with no edges between @xmath156 and @xmath157 ) .",
    "we choose @xmath278 in the role of @xmath13 .",
    "by proposition  [ propo : eqthree ] , there exists an independent set  @xmath301 of @xmath48 with @xmath333 and @xmath303 .",
    "corollary  [ cor : risisub ] shows that @xmath301 maximizes the number of vertices on @xmath106 among all reachable sets .",
    "analogously , these two propositions show that there exists an independent set  @xmath304 of @xmath48 with @xmath334 and @xmath306 , that maximizes the number of vertices on @xmath311 among all reachable independent sets .",
    "when using @xmath301 and @xmath304 in the roles of @xmath158 and @xmath161 , lemma  [ lem : moduleb ] shows that there exists an independent set  @xmath62 of @xmath2 with @xmath335 , @xmath336 and @xmath337 .",
    "inequality  ( [ eq : seven ] ) follows since @xmath338 and @xmath339 .",
    "let @xmath39 be a union node with children @xmath21 and @xmath51 such that for every relevant integer @xmath74 , the values @xmath89 and @xmath340 are known .",
    "then lemma  [ lem : risunion ] shows that for every relevant value @xmath74 , the value @xmath87 can be computed in polynomial time : try all relevant combinations @xmath226 , verify whether they are stable , and subsequently identify the unique maximum stable tuple .",
    "however , this is not very efficient . in this section",
    "we present a more efficient method for computing the values @xmath185 for union nodes @xmath39 .",
    "the method is shown in algorithm  [ alg : fastriscomput ] .",
    "input : for a union node @xmath39 with children @xmath21 and @xmath51 : the values @xmath341 and @xmath342 for @xmath343 and @xmath344 .",
    "+ output : values @xmath345 for all @xmath227 .",
    "= = @xmath346[la:1 ] + @xmath347[la:2 ] + @xmath348[la:3 ] + * while * @xmath349 * do*[la:4 ] + [ la:5 ] + @xmath350[la:6 ] + @xmath351[la:7 ] + @xmath352[la : assign1 ] + @xmath353[la : assign2 ] + @xmath354 and @xmath355[la:10 ] + @xmath356[la : assignris ] + @xmath357[la : decell ] + * endwhile*[la:13 ]    to prove that algorithm  [ alg : fastriscomput ] is correct , we need the following invariant .    [ propo : abovestable ] at any time during the computation of algorithm  [ alg : fastriscomput ] , for the variables @xmath358 , @xmath359 and @xmath74 the following property holds : for any @xmath360 and @xmath92-stable tuple @xmath226 : @xmath361 and @xmath362 .",
    "consider the initial choices @xmath363 , @xmath364 and @xmath365 , and any @xmath92-stable tuple @xmath226 for @xmath366 .",
    "if @xmath367 , then obviously @xmath361 .",
    "otherwise , @xmath368 .",
    "analogously , @xmath362 follows .",
    "now suppose that the claim holds for @xmath369 , and that @xmath370 is obtained from this tuple as shown in the algorithm .",
    "more precisely , @xmath226 is an @xmath92-stable tuple for @xmath366 , and we have @xmath371 , @xmath372 , @xmath373 and @xmath374 . we prove that @xmath362 .",
    "the case @xmath375 is trivial , so now assume @xmath376 , and therefore by @xmath92-stability of @xmath226 , @xmath377 . since @xmath371 , proposition  [ propo : rismonotone ] yields @xmath378 .",
    "we conclude that @xmath379 .",
    "the inequality @xmath361 follows analogously .",
    "it follows that the assignments in lines  [ la : assign1 ] and  [ la : assign2 ] maintain the invariant . finally , decreasing @xmath74 by one ( line  [ la : decell ] )",
    "also obviously maintains the invariant .",
    "[ lem : riscomputcorrect ] algorithm  [ alg : fastriscomput ] correctly computes the values @xmath185 for all @xmath227 .    the repeat - until loop terminates when @xmath380 and @xmath381 , so when @xmath370 is @xmath74-stable for @xmath0 and @xmath39 . by proposition",
    "[ propo : abovestable ] , for any @xmath74-stable tuple @xmath226 it holds that @xmath361 and @xmath362 , so @xmath370 is a maximum @xmath74-stable tuple",
    ". then lemma  [",
    "lem : risunion ] shows that the assignment @xmath382 is correct .    to bound the complexity of algorithm  [ alg : fastriscomput ] , we need the following invariant .",
    "[ propo : prestable ] at any time during the computation of algorithm  [ alg : fastriscomput ] , for the variables @xmath358 , @xmath359 and @xmath74 the following property holds : @xmath383 and @xmath384 .    for the initial choices of @xmath358 , @xmath359 and @xmath74 , the claim holds , since @xmath365 , @xmath385 and @xmath386 .",
    "now suppose that the claim holds for @xmath369 , and that @xmath370 is obtained from this tuple as shown in the algorithm .",
    "more precisely , we have @xmath387 , @xmath388 , @xmath373 and @xmath374 .",
    "we first argue that @xmath389 . if @xmath390",
    ", the statement is clear ( using the obvious invariant that these values remain nonnegative ) . otherwise , we can write @xmath391 . by proposition  [ propo : rismonotone ]",
    ", it follows that @xmath392 , and therefore @xmath393 .",
    "analogously , @xmath383 follows .",
    "this shows that the assignments in lines  [ la : assign1 ] and  [ la : assign2 ] maintain the invariant .",
    "clearly , decreasing @xmath74 by one ( line  [ la : decell ] ) maintains the invariant as well .",
    "[ lem : riscomputcomplexity ] algorithm  [ alg : fastriscomput ] terminates in time @xmath394 .",
    "denote @xmath395 .",
    "all lines take constant time ( we may assume that the quantities @xmath396 and @xmath397 are known ) .",
    "therefore it suffices to show that in total , the variables @xmath358 and @xmath359 are reassigned at most @xmath398 times ( in lines  [ la : assign1 ] and  [ la : assign2 ] ) .",
    "proposition  [ propo : prestable ] shows that whenever a new tuple @xmath370 is obtained from a previous tuple @xmath369 , that @xmath399 and @xmath400 .",
    "( if @xmath390 , the statement is clear , and otherwise @xmath391 holds .",
    "@xmath401 follows similarly . ) if @xmath402 and @xmath403 , then @xmath74 is subsequently decreased ( line  [ la : decell ] ) , which is done @xmath5 times in total .",
    "otherwise , @xmath404 , and since both values remain nonnegative throughout , this can occur at most @xmath5 times as well .",
    "hence no line of the algorithm is visited more than @xmath398 times .",
    "[ thm : fastriscomputation ] let @xmath46 be a generalized cotree of a graph @xmath2 on @xmath5 vertices , and let @xmath0 be an independent set  of @xmath2 . if the values @xmath405 are known for all nontrivial leaves @xmath57 and all relevant integers @xmath74 , then there is an algorithm that computes    * the values @xmath185 for all @xmath50 and @xmath227 , and * the maximum @xmath74-stable tuples for all union nodes @xmath50 and @xmath227 ,    with time complexity @xmath406 , where @xmath407 .",
    "the lemmas  [ lem : riscomputcorrect ] and  [ lem : riscomputcomplexity ] show that for a union node @xmath39 , algorithm  [ alg : fastriscomput ] computes the values @xmath185 for all @xmath227 in time @xmath394 , given that the corresponding values for all child nodes are known . for the case",
    "that @xmath39 is a trivial leaf or join node , the same claim follows easily from propositions  [ propo : risleaf ] and  [ propo : risjoin ] .",
    "so , using a straightforward bottom up computation , all values @xmath185 can be computed correctly in time @xmath408 .",
    "that is , in constant time on average per entry .",
    "it remains to bound @xmath107 in terms of @xmath5 .    for a node @xmath50 ,",
    "define @xmath409 , where the sum is over all descendants @xmath21 of @xmath39 in @xmath46 , including @xmath39 itself . by induction over @xmath46 , we show that @xmath410 .",
    "the induction base is trivial . for the induction step ,",
    "consider a node @xmath39 with children @xmath21 and @xmath51 , and write @xmath411 and @xmath412 .",
    "then using the induction hypothesis , we can write @xmath413 ( we used @xmath414 and @xmath415 . ) let @xmath47 be the root of @xmath46 . using @xmath416 the statement follows .      throughout this section ,",
    "@xmath46 denotes again a generalized cotree of @xmath2 and @xmath0 denotes an independent set  of @xmath2 . in this section",
    ", we will show how the values @xmath85 can be computed for all nodes @xmath57 .",
    "for the case that @xmath21 is a union node , this requires knowledge of a maximum @xmath74-stable tuple ( characterized in lemma  [ lem : uniquestablecharacterization ] ) . for the root node of @xmath46 ,",
    "the value is trivial .",
    "[ propo : tddp_freedom_root ] let @xmath47 be the root node of the cotree @xmath46",
    ". then @xmath417 .",
    "[ propo : tddp_freedom_join ] let @xmath50 be a join node , with children @xmath21 and @xmath51 such that @xmath418 . then @xmath419 and @xmath420 .    considering @xmath0 itself , @xmath420 follows immediately .",
    "the inequality @xmath421 follows since @xmath422 .",
    "it remains to prove that @xmath423 .",
    "consider a _",
    "shortest _ @xmath3-tar - sequence  @xmath123 in @xmath2 from @xmath0 to any independent set  @xmath424 with @xmath425 .",
    "if @xmath426 , then @xmath427 , so now assume @xmath428",
    ". then @xmath424 is obtained from @xmath429 by removing a vertex from @xmath106 .",
    "since @xmath48 is the complete join of @xmath49 and @xmath52 and @xmath429 is an independent set , @xmath430 .",
    "so @xmath431 .",
    "[ lem : tddp_freedom_union ] let @xmath50 be a union node , with left child @xmath21 and right child @xmath51 .",
    "let @xmath432 , and let @xmath226 be the maximum @xmath74-stable tuple for @xmath0 and @xmath39",
    ". then @xmath433 and @xmath434 .    denote again @xmath435 . by lemma  [ lem : uniquestablecharacterization ] , for the maximum @xmath74-stable tuple @xmath226 for @xmath0 and @xmath39",
    "it holds that @xmath436 where in both cases the minimum is taken over all independent sets @xmath1 of @xmath48 with @xmath272 .",
    "we first use this to show that @xmath437 and @xmath438 . consider a @xmath3-tar - sequence  @xmath123 for @xmath2 with @xmath439 and @xmath425 . for every @xmath30 ,",
    "denote @xmath440 , and consider the sequence @xmath125 . by definition of @xmath432 , for every @xmath30 it holds that @xmath441 , so",
    "this is an @xmath74-tar - sequence  for @xmath48 , and thus @xmath442 . using  ( [ eq : key ] )",
    "it then follows that @xmath443 .",
    "analogously , @xmath438 follows .",
    "we will now prove that @xmath444 and @xmath445 . by  ( [ eq : key ] ) , there exist independent sets @xmath301 and @xmath304 of @xmath48 with @xmath303 , @xmath306 , @xmath446 and @xmath447 . by the definition of @xmath432",
    ", there exists an independent set  @xmath14 of @xmath2 with @xmath448 and @xmath449",
    ". we can now apply ( module ) lemma  [ lem : modulea ] twice , with @xmath98 in the role of module @xmath107 , @xmath278 in the role of @xmath13 , and @xmath301 or @xmath304 respectively in the role of @xmath62 to conclude that there exist independent sets @xmath450 and @xmath451 of @xmath2 with @xmath452 , @xmath453 , @xmath454 and @xmath455 .",
    "thus @xmath444 and @xmath445 .",
    "in this section , we prove the two main theorems , and summarize how the previous facts and dynamic programming rules can be used to decide efficiently whether @xmath65 for any two given independent sets @xmath13 and @xmath14 of a @xmath2 , for any graph that satisfies the properties stated in theorem  [ thm : main_alg ] .",
    "first , we prove the theorem that characterizes whether @xmath65 , using the previously defined values .",
    "let @xmath46 be a generalized cotree for a graph @xmath2 .",
    "let @xmath13 and @xmath14 be two independent sets of @xmath2 of size at least @xmath3",
    ". then @xmath65 if and only if    1 .   for all nodes @xmath50 , @xmath69 , and 2 .   for all leaves @xmath50 , @xmath70 , where @xmath71 .",
    "we first prove the forward direction .",
    "suppose that @xmath65 . then clearly , for any independent set  @xmath1 of @xmath2 , @xmath456 holds if and only if @xmath457 .",
    "so @xmath458 holds for every node @xmath50 ( definition  [ def : freedom ] ) , which proves the first property .    for any @xmath50",
    ", we may now denote @xmath459 .",
    "consider a @xmath3-tar - sequence  @xmath123 for @xmath2 from @xmath13 to @xmath14 .",
    "for any node @xmath50 and any @xmath460 , it holds that @xmath461 ( definition  [ def : freedom ] ) .",
    "so @xmath125 with @xmath440 for all @xmath30 is a @xmath462-tar - sequence  for @xmath48 .",
    "this shows that @xmath463 , and thus proves the second property .",
    "now we prove the other direction .",
    "assume that the two properties hold .",
    "so we may denote @xmath459 for all nodes @xmath39 .",
    "we prove the following claim by induction over @xmath46 :    _ claim  a : _ for all nodes @xmath50 : @xmath464 .",
    "_ induction base : _ for leaf nodes @xmath50 , the statement follows immediately from the second property .",
    "_ induction step : _ first consider a join node @xmath50 with children @xmath21 and @xmath51 .",
    "suppose that @xmath465 .",
    "this implies @xmath466 and @xmath467 .",
    "therefore , since @xmath39 is a join node , @xmath468 and @xmath469 .",
    "in addition , @xmath470 ( proposition  [ propo : tddp_freedom_join ] ) . from these facts , and the induction assumption @xmath471 , we conclude that @xmath464 .",
    "the case @xmath472 is analog .",
    "now suppose that @xmath473 .",
    "then @xmath474 ( proposition  [ propo : tddp_freedom_join ] ) .",
    "the desired claim follows since @xmath475 trivially holds .    next , consider the case that @xmath50 is a union node with left child @xmath21 and right child @xmath51 .",
    "denote @xmath476 , @xmath477 and @xmath478 . by lemma  [ lem : tddp_freedom_union ] , @xmath226 is the maximum @xmath74-stable tuple for @xmath39 , for both @xmath13 and @xmath14 .",
    "we define @xmath479 to be an independent set  of @xmath49 with @xmath480 , with maximum size among all such sets , and define @xmath481 to be an independent set  of @xmath52 with @xmath482 , with maximum size among all such sets . by induction ,",
    "@xmath483 , so it also holds that @xmath484 , and that @xmath479 has maximum size among all such reachable sets .",
    "analogously , @xmath485 , and @xmath481 has maximum size among all such reachable sets .",
    "define @xmath486 .",
    "we will now show that @xmath487 is reachable from both @xmath488 and @xmath489 , which proves claim  a for node @xmath39 .",
    "lemma  [ lem : uniquestablecharacterization ] shows that there exists an independent set  @xmath1 of @xmath48 with @xmath490 and @xmath491 . using this",
    ", we argue that there exists an independent set  @xmath301 of @xmath48 with @xmath492 and @xmath493 .",
    "if @xmath494 , then this claim is trivial .",
    "otherwise , we can apply ( module ) lemma  [ lem : modulea ] to draw this conclusion ( using @xmath106 , @xmath48 , @xmath1 and @xmath479 in the roles of the module @xmath107 , entire graph @xmath2 , and independent sets @xmath14 and @xmath62 , respectively ) .",
    "analogously , we may conclude that there exists an independent set  @xmath304 of @xmath48 with @xmath495 and @xmath496 .",
    "since @xmath486 , we can now apply ( module ) lemma  [ lem : moduleb ] ( with @xmath48 in the role of the entire graph , @xmath106 and @xmath311 in the roles of disjoint modules @xmath156 and @xmath157 , and @xmath301 and @xmath304 in the roles of @xmath158 and @xmath161 ) , to conclude that @xmath497 . for this , we require the fact that @xmath479 has maximum size among all independent sets of @xmath49 that are reachable from @xmath75 .    the argument from the previous paragraph also holds when replacing @xmath13 by @xmath14 , since @xmath479 and @xmath481 are also maximum reachable independent sets from @xmath76 and @xmath498 .",
    "thus we may also conclude that @xmath499 .",
    "using the fact that @xmath500 is an equivalence relation , we conclude that @xmath501 , which proves the desired claim for @xmath39 .",
    "this concludes the induction proof of claim  a. applying claim  a to the root node @xmath47 of @xmath46 shows that @xmath65 , since @xmath502 ( proposition  [ propo : tddp_freedom_root ] ) , and @xmath503 , and therefore concludes the proof of the theorem .",
    "next , we prove our main algorithmic result . in the next section ,",
    "we give examples of graph classes for which this theorem yields efficient algorithms .",
    "let @xmath46 be a generalized cotree for a graph @xmath2 on @xmath5 vertices , let @xmath42 and let @xmath13 and @xmath14 be independent sets of @xmath2 .",
    "if for every nontrivial leaf @xmath57 and relevant integer @xmath74 ,    * the values @xmath94 and @xmath95 are known , and * it is known whether @xmath96 ,    then in time @xmath6 it can be decided whether @xmath65 .",
    "we may assume that @xmath110 and @xmath504 , otherwise we can immediately answer no .",
    "first we use a _ bottom up _ dynamic programming algorithm , to compute the values @xmath505 and @xmath506 for every node @xmath39 and relevant integer @xmath74 .",
    "theorem  [ thm : fastriscomputation ] shows that this can be done in time @xmath6 , and that at the same time the maximum @xmath74-stable tuples can be computed for @xmath13 , @xmath14 , all union nodes @xmath39 and relevant integers @xmath74 .",
    "( recall that this uses the dynamic programming rules for trivial leaves , join nodes and union nodes given in proposition  [ propo : risleaf ] , proposition  [ propo : risjoin ] and lemma  [ lem : risunion ] , respectively , and the fast computation of maximum @xmath74-stable tuples given in section  [ ssec : fastriscomput ] . )",
    "next , we start the _ top down _ phase of the dynamic programming algorithm , where we compute the values @xmath507 and @xmath508 for every node @xmath39 . for the root node @xmath47 of @xmath46",
    ", we can initialize these values to @xmath3 ( proposition  [ propo : tddp_freedom_root ] ) . next , for every node @xmath39 for which these two values are known",
    ", we can compute these two values for the two children @xmath21 and @xmath51 , by applying proposition  [ propo : tddp_freedom_join ] for join nodes and lemma  [ lem : tddp_freedom_union ] for union nodes .",
    "note that applying lemma  [ lem : tddp_freedom_union ] to a union node @xmath39 requires the previously computed maximum @xmath74-stable tuple @xmath226 for @xmath78 , with @xmath509 .",
    "this is why the bottom up phase is required .",
    "finally , we return yes if    * for all nodes @xmath57 , @xmath510 , and * for all leaves @xmath57 , @xmath511 , where @xmath73 .",
    "this is correct by theorem  [ thm : new_main_combin ] .",
    "( note that for trivial leaves @xmath57 , @xmath511 always holds , and for nontrivial leaves , we assume that this information is given . ) considering the dynamic programming rules , every value that is assigned in the top down phase can be computed in constant time per value .",
    "hence the top down phase takes time @xmath512 , and the total complexity of the algorithm becomes @xmath6 ( which is dominated by the bottom up phase ) .",
    "in this section , we discuss graph classes to which theorem  [ thm : main_alg ] applies .",
    "firstly , theorem  [ thm : main_alg ] easily implies that the tar - reachability problem can be decided efficiently on cographs .",
    "[ thm : cograph ] let @xmath2 be a cograph on @xmath5 vertices , let @xmath42 and let @xmath13 and @xmath14 be independent sets of @xmath2 . in time",
    "@xmath6 it can be decided whether @xmath65 .",
    "a cotree @xmath46 for @xmath2 can be constructed in linear time  @xcite .",
    "we can easily guarantee that this is a binary tree . since a cotree only has trivial leaves ,",
    "theorem  [ thm : main_alg ] can now be applied .",
    "indeed , for a trivial leaf @xmath39 : proposition  [ propo : risleaf ] shows that @xmath238 holds for all relevant @xmath513 .",
    "secondly , it can be seen that @xmath96 always holds for all relevant @xmath513 .",
    "so the conditions of theorem  [ thm : main_alg ] are satisfied .",
    "combining this theorem with lemma  [ lem : tjistar ] shows that we can efficiently decide whether @xmath514 in the case that @xmath2 is a cograph , which answers an open question from  @xcite :    let @xmath2 be a cograph on @xmath5 vertices , and let @xmath13 and @xmath14 be independent sets of @xmath2 . in time",
    "@xmath6 it can be decided whether @xmath514 .",
    "theorem  [ thm : main_alg ] is however much stronger , and implies that tar - reachability can be decided efficiently for much richer graph classes",
    ". we will now give an example of such a graph class , namely the class of _ all graphs that admit a cotree decomposition into chordal graphs .",
    "_ along the way , we will introduce some tools that allow proving the same for other graph classes that can be obtained by taking unions and joins of graphs from a graph class @xmath8 , for which the values / properties from theorem  [ thm : main_alg ] can efficiently be computed / decided .",
    "a graph @xmath2 is _ chordal _ if it contains no cycles of length four or more as induced subgraphs ( in other words : if every cycle of length at least four contains a _ chord _ ) .",
    "the only two properties of chordal graphs that we will use are the following .",
    "firstly :    [ thm : chordalmaxindset ] let @xmath2 be a chordal graph .",
    "then @xmath16 can be computed in polynomial time .",
    "this statement is well - known , and relatively easy to prove using the concept of simplicial vertices . for the more general class of _ perfect graphs _",
    ", @xmath16 can in fact also be computed in polynomial time .",
    "see  ( * ? ? ?",
    "* section  66.3 ) for more background .",
    "secondly , we use the fact that chordal graphs are obviously even - hole - free . a graph",
    "@xmath2 is _ even - hole - free _ if it contains no even cycles as induced subgraphs . to our knowledge ,",
    "no polynomial time algorithm for computing @xmath16 for even - hole - free graphs is known ; otherwise , the result from this section could be generalized to even - hole - free graphs .",
    "see also  @xcite .",
    "we will also apply the following result , which was proved in  @xcite .",
    "[ thm : evenholefreetj ] let @xmath13 and @xmath14 be two independent sets of an even - hole - free graph @xmath2 with @xmath515",
    ". then @xmath514 .    using lemma  [ lem : tjistar ] , this theorem can be applied to the tar model to conclude :    [ lem : evenholefreetar ] let @xmath13 and @xmath14 be two distinct independent sets of an even - hole - free graph @xmath2",
    ". then @xmath65 if and only if neither @xmath13 nor @xmath14 is a dominating set of size @xmath3 .",
    "if @xmath13 is a dominating set of size @xmath3 , then no token can be added to @xmath13 , and no token can be removed from @xmath13 .",
    "so @xmath13 has no neighbors in @xmath17 .",
    "since @xmath13 and @xmath14 are distinct , it follows that @xmath516 .",
    "this follows similarly if @xmath14 is a dominating set of size @xmath3 .",
    "now suppose that neither @xmath13 nor @xmath14 is a dominating set of size @xmath3 .",
    "then we show that @xmath65 .",
    "we can easily construct an independent set  @xmath517 with @xmath518 and @xmath519 :    * if @xmath520 then add an arbitrary vertex @xmath21 which has no neighbors in @xmath13 ( which exists since @xmath13 is not dominating ) .",
    "* if @xmath521 then remove arbitrary vertices from @xmath13 until an independent set  of size @xmath522 is obtained .    similarly , we can easily construct an independent set  @xmath523 with @xmath524 and @xmath525 .",
    "by theorem  [ thm : evenholefreetj ] , @xmath526 .",
    "next , lemma  [ lem : tjistar ] shows that @xmath527 .",
    "combining this with @xmath518 and @xmath524 shows that @xmath65 .",
    "the above lemma easily yields the following statement .",
    "[ cor : evenholefreepreris ] let @xmath0 be an independent set  of an even - hole - free graph @xmath2 , and let @xmath1 be an independent set  of @xmath2 with @xmath528 that maximizes @xmath83 among all such sets",
    ". then    * @xmath529 if @xmath0 is a dominating set of size @xmath3 , and * @xmath530 otherwise .",
    "this in turn gives us immediately an easy way to compute the values @xmath345 for the case that @xmath48 is even - hole - free :    [ cor : evenholefreeris ] let @xmath46 be a cotree decomposition of a graph @xmath2 into even - hole - free graphs , and let @xmath0 be an independent set  of @xmath2 .",
    "then for every leaf @xmath50 , and every relevant value @xmath74 :    * @xmath531 if @xmath532 is a dominating set of @xmath48 of size @xmath74 , and * @xmath533 otherwise .",
    "combining theorem  [ thm : chordalmaxindset ] , lemma  [ lem : evenholefreetar ] and corollary  [ cor : evenholefreeris ] shows that if we have a cotree decomposition of a graph @xmath2 into chordal graphs , then the conditions of theorem  [ thm : main_alg ] are satisfied , so we can compute in polynomial time whether @xmath534 .",
    "however , it remains to discuss how in general , a cotree decomposition into chordal graphs can be found .",
    "recall that for a graph @xmath2 , by @xmath535 the _ complement _ of @xmath2 is denoted , which is the graph @xmath536 .",
    "[ def : indecomp ] a graph @xmath114 is _ indecomposable _ if both @xmath114 and @xmath537 are connected .",
    "a _ maximal cotree decomposition _ of a graph @xmath2 is a generalized cotree decomposition @xmath46 such that for every leaf @xmath50 , @xmath48 is indecomposable .",
    "[ propo : maximalcotreedecomppolytime ] for any graph @xmath2 , a maximal cotree decomposition of @xmath2 can be computed in polynomial time .",
    "a polynomial time algorithm for testing whether a given graph is indecomposable follows immediately from the definition ( quadratic time in fact ) .",
    "now consider the following algorithm for constructing a maximal cotree decomposition of @xmath2 : start with a trivial generalized cotree decomposition @xmath46 , consisting of one ( root ) node @xmath47 with @xmath58 .",
    "as long as the current generalized cotree decomposition @xmath46 contains a leaf @xmath50 such that @xmath48 is decomposable , partition the vertices of @xmath48 into new sets @xmath106 and @xmath311 such that @xmath48 is the disjoint union or complete join of @xmath538 $ ] and @xmath539 $ ] ( this can be trivially done in the case where @xmath48 is disconnected , respectively in the case where @xmath540 is disconnected ) . now add corresponding new leaf nodes @xmath21 and @xmath51 as children of @xmath39 , and make @xmath39 into a union or join node , respectively .",
    "this way , a generalized cotree decomposition of @xmath2 is maintained .",
    "the algorithm terminates after at most @xmath541 steps ( which all take polynomial time ) , since in every step , the number of leaves of @xmath46 increases by one , and a generalized cotree decomposition has at most @xmath541 leaves .",
    "when the algorithm terminates , the resulting generalized cotree decomposition is clearly maximal .",
    "a graph class @xmath8 is called _ hereditary _ if for every @xmath542 and every induced subgraph @xmath114 of @xmath2 , @xmath543 holds . clearly , chordal graphs are hereditary .    [",
    "lem : anymaximaldecompsuffices ] let @xmath8 be a hereditary graph class , and let @xmath2 be a graph that admits a cotree decomposition into @xmath8-graphs . then every maximal cotree decomposition of @xmath2 is a cotree decomposition into @xmath8-graphs .",
    "let @xmath544 be a maximal cotree decomposition of @xmath2 , and let @xmath545 be a cotree decomposition of @xmath2 into @xmath8-graphs . denote by @xmath546 and @xmath547 the subgraphs of @xmath2 that correspond to nodes @xmath548 and @xmath549 , respectively",
    ". similarly , denote their vertex sets by @xmath550 and @xmath551 .    consider a leaf @xmath548 .",
    "we will prove that @xmath552 is also part of the graph class @xmath8 . if there is a leaf node @xmath553 such that @xmath554",
    ", then @xmath546 is an induced subgraph of @xmath555 , so since @xmath8 is hereditary , @xmath556 holds .",
    "now assume that there is no such leaf node in @xmath545",
    ". then observe that we may consider a node @xmath557 with @xmath558 , which has no child nodes that satisfy this property .",
    "( in other words : @xmath51 is a lowest common ancestor of all nodes @xmath257 with @xmath559 . ) let @xmath257 and @xmath108 be the two child nodes of @xmath51 .",
    "so by choice of @xmath51 , @xmath550 can be partitioned into two nonempty sets @xmath560 and @xmath561 .",
    "if @xmath51 is a join node , then @xmath546 can be written as the complete join of @xmath562 $ ] and @xmath563 $ ] , so @xmath564 is disconnected , contradicting the fact that it is indecomposable .",
    "similarly , if @xmath51 is a union node , then @xmath546 can be written as the disjoin union of @xmath562 $ ] and @xmath563 $ ] , so it is disconnected , contradicting the fact that it is indecomposable .",
    "this concludes the proof that for every @xmath548 , @xmath565 holds .",
    "we now summarize how the previous statements yield a polynomial time algorithm for testing @xmath65 , whenever @xmath2 is a graph that admits a cotree decomposition into chordal graphs .",
    "[ thm : tar_cotreeintochordal ] let @xmath2 be a graph that admits a cotree decomposition into chordal graphs , and let @xmath13 and @xmath14 be independent sets of @xmath2 , both of size at least @xmath3 . then in polynomial time",
    ", we can decide whether @xmath65 .",
    "we first construct a maximal cotree decomposition @xmath46 of @xmath2 in polynomial time ( proposition  [ propo : maximalcotreedecomppolytime ] ) . by lemma  [ lem : anymaximaldecompsuffices ] , @xmath46 is then a cotree decomposition into chordal graphs ( since chordal graphs are hereditary ) .",
    "so by theorem  [ thm : chordalmaxindset ] , we can compute @xmath566 for every leaf @xmath50 . combining this with corollary  [ cor : evenholefreeris ] , and",
    "the fact that chordal graphs are even - hole - free , shows that we can compute the values @xmath567 and @xmath568 for every leaf @xmath50 and relevant @xmath74 .",
    "finally , lemma  [ lem : evenholefreetar ] gives an easy way to decide in polynomial time whether @xmath501 for any leaf @xmath50 and relevant value @xmath74 .",
    "so the conditions of theorem  [ thm : main_alg ] are satisfied for the generalized cotree decomposition @xmath46 of @xmath2 , and thus we can compute in polynomial time whether @xmath65 .",
    "using the previous lemmas , we can efficiently decide whether there exists a @xmath3-tar - sequence  from @xmath13 to @xmath14 in a cograph @xmath2 . however ,",
    "from these lemmas , one can not easily deduce a polynomial upper bound for the length of such a sequence .",
    "this requires studying the aforementioned cascading sequences in more detail , which is what we will do in this section .",
    "we will show that if @xmath65 , then there exists a @xmath3-tar - sequence  from @xmath13 to @xmath14 of length at most @xmath97 , where @xmath569 .",
    "the main idea is as follows .",
    "given independent sets @xmath13 and @xmath14 of @xmath2 with @xmath65 , we choose an appropriate subgraph @xmath570 of @xmath2 such that there exist maximum independent sets @xmath517 and @xmath523 of @xmath2 and short @xmath3-tar - sequences from @xmath13 to @xmath517 and from @xmath14 to @xmath523 .",
    "these sequences are short in the sense that for every vertex @xmath18 , no token is added on @xmath21 after the first token is removed from @xmath21 .",
    "so in total , there are at most @xmath571 token additions / removals used in the sequence from @xmath13 to @xmath517 , and a similar statement holds for @xmath14 and @xmath523 . finally , we show that @xmath3-tar - sequence  from @xmath517 to @xmath523 exists , of length at most @xmath572 .",
    "( recall that @xmath573 denotes the _ symmetric difference _ of @xmath13 and @xmath14 . ) combining these three @xmath3-tar - sequences yields a @xmath3-tar - sequence  from @xmath13 to @xmath14 of length at most @xmath97 in the subgraph @xmath570 , and therefore also in @xmath2 .",
    "we now define the type of tar - sequences that we will consider . for a node @xmath50 and _ every _ value of @xmath227 , a _ subsequence _ of the next sequence outlines an @xmath74-tar - sequence  for @xmath48 from @xmath532 to an independent set  @xmath1 with @xmath574 ( properties  [ it : begin ] and  [ it : shortseq ] ) .",
    "in addition it is _ short _ in the sense that every vertex of @xmath48 is used for at most one token addition ( property  [ it : newverts ] ) .",
    "this motivates the name _ short universal sequence_. examples of these sequences are given in figure  [ fig : suseqs ] for the graphs @xmath49 and @xmath52 from figure  [ fig : cascading ] .",
    "[ def : suseq ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2",
    ". a _ short universal sequence _ or _ su - sequence _ for a node @xmath50 , based on @xmath0 , is a sequence @xmath575 of independent sets of @xmath48 that satisfy the following properties :    1 .",
    "[ it : begin ] @xmath576 .",
    "[ it : increase ] for all @xmath577 : @xmath578 .",
    "[ it : newverts ] for all @xmath579 with @xmath580 : @xmath581 .",
    "[ it : shortseq ] for all @xmath227 and @xmath460 : if @xmath582 then @xmath298 and there exists an @xmath74-tar - sequence  in @xmath48 from @xmath583 to @xmath584 that only adds tokens on @xmath585    below we will show by induction over @xmath46 that for every node @xmath50 , an su - sequence exists . but",
    "first , we will prove two properties that indicate why these sequences are useful for finding short @xmath74-tar - sequences from @xmath532 to an independent set  @xmath1 with @xmath586 , for any value of @xmath74 .",
    "[ propo : su_ends_with_maxindset ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 .",
    "let @xmath575 be an su - sequence for a node @xmath50 , based on @xmath0 .",
    "then @xmath587 .    for all @xmath460 , since @xmath583 is an independent set  of @xmath48 , @xmath588 . if the inequality is strict , then @xmath589 , so property  [ it : shortseq ] of definition  [ def : suseq ] shows that @xmath298 .",
    "[ lem : suseq_usage ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 .",
    "let @xmath575 be an su - sequence for a node @xmath50 , based on @xmath0 .",
    "for any @xmath227 and @xmath590 with @xmath582 , there exists an @xmath74-tar - sequence  from @xmath532 to @xmath584 in @xmath48 of length @xmath591 .",
    "therefore , @xmath592 .    for any @xmath74",
    ", we prove the statement by induction over @xmath30 .",
    "we will assume that @xmath582 , otherwise there is nothing to prove .",
    "for @xmath593 , property  [ it : shortseq ] shows that there is an @xmath74-tar - sequence  in @xmath48 from @xmath594 to @xmath595 that only adds tokens on @xmath596 .",
    "it follows that this tar - sequence  uses exactly @xmath597 token additions , and @xmath598 token removals . we can write @xmath599 which proves the statement",
    ".    now suppose @xmath173 .",
    "since @xmath582 , property  [ it : increase ] shows that @xmath600 holds as well .",
    "so by induction , there exists an @xmath74-tar - sequence  in @xmath48 from @xmath594 to @xmath583 of length @xmath601 . by property",
    "[ it : shortseq ] , there also exists an @xmath74-tar - sequence  in @xmath48 from @xmath583 to @xmath584 , of length @xmath602 ( using an argument similar to above ) .",
    "these can be combined into an @xmath74-tar - sequence  in @xmath48 from @xmath594 to @xmath584 .",
    "the total length of this sequence is therefore : @xmath603 @xmath604 @xmath605 @xmath606 @xmath607    this concludes the induction proof , so we conclude that for any @xmath30 with @xmath582 , there exists an @xmath74-tar - sequence  from @xmath532 to @xmath584 in @xmath48 of length @xmath591 . from this , it follows immediately that @xmath592 .",
    "we will now prove that su - sequences exist for every @xmath50 .",
    "[ propo : suseq_leaf ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 . for every leaf node @xmath50",
    ", there exists an su - sequence based on @xmath0 .",
    "we define @xmath576 and @xmath608 .",
    "choose @xmath426 if these two sets are the same , and @xmath609 otherwise .",
    "one can easily verify that the four properties from definition  [ def : suseq ] hold for this sequence .",
    "( recall that by proposition  [ propo : risleaf ] , @xmath610 for all @xmath74 . )",
    "[ lem : suseq_join ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 .",
    "let @xmath50 be a join node with children @xmath21 and @xmath51 .",
    "if there exist su - sequences for @xmath21 and @xmath51 , then there exists an su - sequence for @xmath39 ( all based on @xmath0 ) .",
    "suppose @xmath39 is a join node , with children @xmath21 and @xmath51 .",
    "we will construct an su - sequence @xmath611 for @xmath39 .",
    "if @xmath612 , then we choose @xmath613 , @xmath614 and @xmath615 to be a maximum independent set  of @xmath48 . this choice satisfies the four properties of definition  [ def : suseq ] .",
    "so now we may assume w.l.o.g . that @xmath616 and @xmath418 .",
    "by induction , for @xmath21 there exists an su - sequence @xmath617 based on @xmath0 . for all @xmath618 ,",
    "we choose @xmath619 .",
    "if @xmath620 is also a maximum independent set  of @xmath48 then this is the entire sequence for @xmath39 ( so we choose @xmath621 ) , and it satisfies the four properties again ( recall that in this case , @xmath622 for all @xmath74 , by proposition  [ propo : risjoin ] ) . otherwise , since @xmath39 is a join node , any set @xmath623 is a maximum independent set  for @xmath48 if and only if it is a maximum independent set  for @xmath49",
    ". therefore we can choose @xmath624 , and choose @xmath625 to be any maximum independent set of @xmath49 .",
    "clearly , there exists a @xmath626-tar - sequence  from @xmath627 to @xmath625 that only adds tokens on @xmath628 . since @xmath629 and @xmath622 for all @xmath242 ( proposition  [ propo : risjoin ] ) , this shows that property  [ it : shortseq ] again holds for the new sequence . for all @xmath630 , @xmath631 , so @xmath632 , and thus property  [ it : newverts ] is again satisfied for this new sequence .",
    "property  [ it : begin ] holds since @xmath633 ( using induction , and that @xmath39 is a join node with @xmath616 , respectively ) .    the proof of the following lemma is also illustrated in figure  [ fig : suseqs ] . given su - sequences for children @xmath21 and @xmath51 of a union node @xmath39 , we obtain an su - sequence for @xmath39 by letting every set in the new sequence be the union of one set from the su - sequence for @xmath21 and one set from the su - sequence for @xmath51 .",
    "[ lem : suseq_union ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 .",
    "let @xmath50 be a union node with children @xmath21 and @xmath51 .",
    "if there exist su - sequences for @xmath21 and @xmath51 , then there exists an su - sequence for @xmath39 ( all based on @xmath0 ) .",
    "let @xmath617 and @xmath634 be su - sequences based on @xmath0 for @xmath21 and @xmath51 , respectively .",
    "we will construct a su - sequence @xmath611 for @xmath39 from these .",
    "these sets will be constructed such that for every index @xmath358 , there exist indices @xmath359 and @xmath635 with @xmath636 first we choose @xmath637 , which guarantees that @xmath638 , so property  [ it : begin ] is satisfied .",
    "next , for every choice of indices @xmath639 such that we assigned @xmath640 , continue the construction of the sequence according to the following method . for notational convenience , we define @xmath641 and @xmath642 for all @xmath643 .",
    "a.   denote @xmath644 and @xmath645 .",
    "b.   [ it : seqend ] if @xmath646 and @xmath647 then assign @xmath648 ( so the su - sequence for @xmath39 ends here ) .",
    "otherwise , choose @xmath649 as follows : c.   [ it : ellchoice ] choose @xmath74 to be the maximum value in @xmath650 such that @xmath651 or @xmath652 .",
    "d.   if @xmath651 then choose @xmath653 , and otherwise ( when @xmath652 ) choose @xmath654 .",
    "we first argue that a value @xmath74 can always be chosen as in  ( [ it : ellchoice ] ) : if @xmath655 , then by property  [ it : shortseq ] , @xmath656 .",
    "so choosing any @xmath657 with @xmath658 suffices .",
    "otherwise , by  ( [ it : seqend ] ) , @xmath659 , and any @xmath74 with @xmath660 suffices by an analog argument .",
    "the above construction defines the sequence @xmath611",
    ". we will now prove that it is an su - sequence .    as observed above , @xmath661 , so property  [ it : begin ] is satisfied .",
    "since @xmath662 and @xmath663 holds for any @xmath359 and @xmath635 ( property  [ it : increase ] ) , it follows that @xmath664 holds for any @xmath665 , which proves property  [ it : increase ] for the new sequence .",
    "now we prove property  [ it : newverts ] .",
    "consider @xmath666 with @xmath640 and @xmath667 .",
    "so @xmath668 and @xmath669 .",
    "assume w.l.o.g .",
    ". then we can write @xmath671 for the last equality , we used    * property  [ it : newverts ] for @xmath21 to conclude that @xmath672 , and * the observations that @xmath673 , @xmath674 , and @xmath675 to conclude that @xmath676 .",
    "it remains to prove property  [ it : shortseq ] for the new sequence .",
    "first note that @xmath677 , so we may end the sequence when @xmath646 and @xmath647 . now consider any index @xmath665 , such that we constructed @xmath649 from @xmath640 using the above method .",
    "we will prove for all @xmath678 with @xmath679 that there exists an @xmath92-tar - sequence  in @xmath48 from @xmath680 to @xmath681 that only adds tokens on @xmath682 .",
    "first , we show that @xmath683 implies that @xmath684 or @xmath685 .",
    "consider an @xmath92-tar - sequence  @xmath686 from @xmath532 to an independent set  @xmath1 of @xmath48 with @xmath687 .",
    "let @xmath688 be the first index such that @xmath689 or @xmath690",
    ". clearly , such an index @xmath688 exists , and @xmath691 holds since @xmath692 by property  [ it : increase ] .",
    "assume that @xmath689 .",
    "then define @xmath693 for all @xmath694 . by choice of @xmath30",
    ", for all @xmath694 it holds that @xmath695 , and therefore @xmath696 .",
    "so the sequence @xmath697 is an @xmath698-tar - sequence  for @xmath49 from @xmath699 to an independent set  @xmath700 with @xmath701 , and thus @xmath702 .",
    "from this fact we conclude that for any @xmath678 with @xmath679 , it holds that @xmath366 , where @xmath74 is the value chosen in  ( [ it : ellchoice ] ) .",
    "we conclude the proof of property  [ it : shortseq ] by showing that there exists an @xmath74-tar - sequence  in @xmath48 from @xmath703 to @xmath649 that only adds tokens on @xmath704 ( which is then obviously also an @xmath92-tar - sequence ) .",
    "consider the case that we have chosen @xmath670 .",
    "then @xmath705 , so by using property  [ it : shortseq ] for the su - sequence for @xmath21 , there exists an @xmath706-tar - sequence  in @xmath49 from @xmath707 to @xmath708 that only adds tokens on @xmath709 .",
    "if we apply the same token additions to @xmath640 , then this yields the desired @xmath74-tar - sequence  from @xmath703 to @xmath649 , since any independent set  in this sequence contains @xmath47 vertices of @xmath311 . if @xmath710 , then @xmath711 , and the proof is analog .    summarizing",
    ", we have now shown that for the constructed sequence @xmath611 , all properties from definition  [ def : suseq ] hold , and therefore it is an su - sequence for @xmath39 , based on @xmath0 , which concludes the proof of the lemma .",
    "a straightforward induction proof based on proposition  [ propo : suseq_leaf ] , lemma  [ lem : suseq_join ] and lemma  [ lem : suseq_union ] now yields the following statement .",
    "[ thm : suseqsexist ] let @xmath46 be a cotree of a graph @xmath2 , and let @xmath0 be an independent set  of @xmath2 . for every node @xmath50",
    ", there exists an su - sequence based on @xmath0 .",
    "combined with proposition  [ propo : su_ends_with_maxindset ] and lemma  [ lem : suseq_usage ] , this shows that for any value of @xmath3 such that there exists a @xmath3-tar - sequence  in @xmath2 from @xmath0 to some maximum independent set  of @xmath2 , then there exists a short @xmath3-tar - sequence  of this type .",
    "[ thm : shorttarseqtomax ] let @xmath2 be a graph on @xmath5 vertices , let @xmath46 be a cotree of @xmath2 with root @xmath47 , let @xmath0 be an independent set  of @xmath2 , and let @xmath3 be an integer such that @xmath712 .",
    "then there exists a @xmath3-tar - sequence  from @xmath0 to some maximum independent set @xmath1 of @xmath2 with length at most @xmath713 .    by theorem  [ thm : suseqsexist ]",
    ", there exists an su - sequence @xmath714 for the root node @xmath47 . since @xmath715 ( proposition  [ propo : su_ends_with_maxindset ] )",
    ", lemma  [ lem : suseq_usage ] shows that there exists a @xmath3-tar - sequence  from @xmath0 to @xmath716 of length @xmath717 .",
    "theorem  [ thm : shorttarseqtomax ] can be used to prove the existence of a linear length tar - sequence  between any two independent sets @xmath13 and @xmath14 with @xmath65 , by reconfiguring both to a common reachable maximum independent set .",
    "there are however two problems with this approach : first , even though @xmath65 holds , it may be that @xmath13 and @xmath14 can not reach any maximum independent set  of @xmath2 .",
    "this is remedied by considering an appropriate subgraph @xmath570 of @xmath2 , such that @xmath718 holds , and both @xmath13 and @xmath14 can reach a maximum independent set  of @xmath570 .",
    "lemma  [ lem : reachablesubgraph ] below indicates how this graph @xmath570 can be chosen ",
    "it suffices to simply omit all vertices that are not in any independent set  that can be reached from @xmath13 or @xmath14 .",
    "secondly , even if both @xmath13 and @xmath14 can both reach a maximum independent set  of a graph @xmath2 ( i.e. @xmath719 ) , it may be that @xmath2 has multiple maximum independent sets , and theorem  [ thm : shorttarseqtomax ] does not specify which one is reachable .",
    "in fact , from the construction of the su - sequences it can be seen that different choices of @xmath13 and @xmath14 may lead to different maximum independent sets . therefore , to conclude the proof",
    ", we also need to demonstrate that short tar - sequences exist between any pair of maximum independent sets that can reach each other .",
    "this is done in the next lemma .",
    "[ lem : shorttarbetweenmaxindsets ] let @xmath13 and @xmath14 be two maximum independent sets of a cograph @xmath2 . if @xmath65 , then there exists a @xmath3-tar - sequence  from @xmath13 to @xmath14 of length @xmath572 .",
    "we prove the statement by induction over @xmath572 .",
    "let @xmath46 be a cotree of @xmath2 .",
    "if @xmath720 then there is nothing to prove , so assume now that @xmath721 . define a _ difference node _ to be a node @xmath50 with @xmath494 and @xmath722 or with @xmath723 and @xmath724 .",
    "consider a _",
    "join node @xmath39 with children @xmath21 and @xmath51 such that @xmath39 is not a difference node , but @xmath21 and @xmath51 are_. we first argue that such a node exists . since @xmath725 , there exists at least one difference node ( a leaf of @xmath46 ) . considering the root @xmath47",
    ", there exists also at least one node that is not a difference node .",
    "so we may consider a difference node @xmath21 for which the parent @xmath39 is not a difference node .",
    "assume that @xmath466 and @xmath726 . since @xmath39 is not a difference node , @xmath727 , where @xmath51 is the other child of @xmath39 .",
    "if @xmath39 is a union node , then we can add @xmath75 to @xmath14 , such that the result is a larger independent set  ( since @xmath98 is a module with @xmath728 , and vertices in @xmath75 are not adjacent to vertices in @xmath498 ) , a contradiction with the maximality of @xmath14 .",
    "so @xmath21 is a join node .",
    "since @xmath13 is an independent set , it follows that @xmath729 , and therefore @xmath51 is also a difference node , which proves that a node @xmath39 with the stated properties exists .",
    "next , we prove that @xmath730 and @xmath731 . consider a @xmath3-tar - sequence  @xmath123 from @xmath13 to @xmath14 . by choice of @xmath39 ,",
    "this sequence contains an independent set  that contains no vertices of @xmath98 .",
    "let @xmath31 be the first such independent set  in the sequence .",
    "so @xmath173 and @xmath732 for some @xmath733 .",
    "because @xmath174 is an independent set  and @xmath98 is a module , @xmath734 contains no vertices that are adjacent to any vertex in @xmath98 .",
    "so @xmath735 is an independent set , which implies that @xmath736 , and thus @xmath730 .",
    "analogously , @xmath731 follows .",
    "since @xmath98 is a module of @xmath2 , it follows that @xmath737 and @xmath738 are also independent sets .",
    "in fact , since their cardinalities sum to @xmath739 , and neither set can be larger than @xmath16 , it follows that both are maximum independent sets of @xmath2 .",
    "denote @xmath740 .    since @xmath730 , a @xmath3-tar - sequence  from @xmath13 to @xmath517 can be obtained by first removing all tokens from @xmath488 , and next adding tokens on all of @xmath489 .",
    "this sequence has length @xmath741 . by induction , there is a @xmath3-tar - sequence  from @xmath517 to @xmath14 of length @xmath742 . because @xmath743 , this proves the statement .",
    "[ lem : reachablesubgraph ] let @xmath46 be a cotree for @xmath2 , and let @xmath0 be an independent set  of @xmath2 such that for all @xmath18 , there exists an independent set  @xmath1 with @xmath24 and @xmath37 . then @xmath744 .",
    "let @xmath745 be a maximum independent set  of @xmath2 .",
    "by induction over the cotree @xmath46 , we will prove that claim  a below holds for every node @xmath50 .",
    "applying claim  a for to the root node of @xmath46 proves the lemma statement .",
    "_ claim a : _ there exists an independent set  @xmath1 of @xmath2 with @xmath746 and @xmath24 .",
    "suppose @xmath50 is a ( trivial ) leaf node .",
    "then claim  a follows immediately from the assumption .",
    "suppose @xmath39 is a join node , with children @xmath21 and @xmath51 .",
    "we may assume w.l.o.g .",
    "that @xmath747 . by induction , there exists an independent set  @xmath1 with @xmath24 and @xmath748 .",
    "therefore , @xmath749 , which proves claim  a for @xmath39 .",
    "finally , suppose @xmath39 is a union node , with children @xmath21 and @xmath51 .",
    "if @xmath750 then claim  a follows trivially for @xmath39 , so assume this is not the case .",
    "since @xmath745 is now a maximum independent set  of @xmath2 with @xmath751 , and @xmath98 is a module of @xmath2 that is the disjoint union of @xmath106 and @xmath311 , it follows that @xmath752 and @xmath753 are maximum independent sets for @xmath49 and @xmath52 , respectively . indeed ,",
    "if this would not be the case , then the size of @xmath745 can be increased by replacing @xmath752 or @xmath753 by arbitrary maximum independent sets of @xmath49 and @xmath52 respectively , while maintaining an independent set , a contradiction .    by induction",
    ", there exists an independent set  @xmath754 with @xmath755 and @xmath756 , and there exists an independent set  @xmath757 with @xmath758 and @xmath759 .",
    "it follows that @xmath760 and @xmath761 are maximum independent sets of @xmath49 and @xmath52 respectively",
    ". we may now apply ( module ) lemma  [ lem : moduleb ] ( with @xmath98 , @xmath106 , @xmath311 , @xmath0 , @xmath754 and @xmath757 in the roles of @xmath107 , @xmath156 , @xmath157 , @xmath13 , @xmath158 , @xmath161 , respectively ) , to conclude that there exists an independent set  @xmath1 of @xmath2 with @xmath24 , @xmath762 , and @xmath763 .",
    "so @xmath764 .",
    "this proves claim  a for @xmath39 .",
    "now we can prove the main theorem from this section .",
    "[ thm : diameter ] let @xmath2 be a cograph on @xmath5 vertices , with independent sets @xmath13 and @xmath14 such that @xmath65 .",
    "then there exists a @xmath3-tar - sequence  from @xmath13 to @xmath14 of length at most @xmath97 .    for an independent set  @xmath0 of @xmath2 , call a vertex @xmath18 _ @xmath3-accessible from @xmath0 _ if there exists an independent set  @xmath1 with @xmath24 and @xmath37 .",
    "since @xmath65 , and @xmath26 is an equivalence relation , it follows that for every vertex @xmath18 , @xmath21 is @xmath3-accessible from @xmath13 if and only if it is @xmath3-accessible from @xmath14 .",
    "so we may consider the subgraph @xmath570 induced by all vertices that are @xmath3-accessible from @xmath13 .",
    "for any independent set  @xmath1 of @xmath2 it now holds that @xmath456 if and only if @xmath765 and @xmath766 , and the same statement holds if we replace @xmath13 by @xmath14 .    since @xmath570 is an induced subgraph of @xmath2 , it is again a cograph , so we may choose @xmath46 to be a cotree of @xmath570 , with root @xmath47 . denote @xmath767 . by definition , @xmath570 satisfies the conditions of lemma  [ lem : reachablesubgraph ] , for both @xmath768 and @xmath769 , so @xmath770 .",
    "theorem  [ thm : shorttarseqtomax ] then shows that there exist @xmath3-tar - sequences from @xmath13 and @xmath14 to maximum independent sets @xmath517 and @xmath523 of @xmath570 respectively , of length at most @xmath771 and @xmath772 .",
    "lemma  [ lem : shorttarbetweenmaxindsets ] shows that there exists a @xmath3-tar - sequence  from @xmath517 to @xmath523 of length @xmath773 .",
    "combining these three @xmath3-tar - sequences gives a @xmath3-tar - sequence  from @xmath13 to @xmath14 in @xmath570 of length at most @xmath774 .",
    "since @xmath570 is an induced subgraph of @xmath2 , this is also a @xmath3-tar - sequence  for @xmath2 .",
    "this immediately yields :    [ corol : tardiameter ] for any cograph @xmath2 on @xmath5 vertices and integer @xmath3 , components of @xmath17 have diameter at most @xmath7 .    combining the previous corollary with lemma  [ lem : tjistar ] yields :    [ corol : tjdiameter ] for any cograph @xmath2 on @xmath5 vertices and integer @xmath3 , components of @xmath35 have diameter at most @xmath12 .",
    "in this paper , we showed that the tar - reachability problem ( and thus the tj - reachability problem ) can be solved efficiently for any graph that admits a cograph decomposition into graphs that satisfy certain properties ( theorem  [ thm : main_alg ] )  call this a _ good graph class_. chordal graphs are given as an example of a good graph class .",
    "in fact , this might be generalized to even - hole - free graphs , provided that the following question can be answered affirmatively : can @xmath16 be computed in polynomial time if @xmath2 is an even - hole - free graph ? this is a well - known open question  @xcite , and also a negative answer ( i.e. np - hardness proof ) would be interesting ( see  @xcite ) .",
    "another good graph class is the class of claw - free graphs , which will be shown in another paper  @xcite .",
    "finally , theorem  [ thm : main_alg ] easily applies to any graph class such that graphs on @xmath5 vertices admit a cograph decomposition into @xmath775 sized graphs : in this case , a trivial ( exponential time ) exhaustive search procedure can be applied to the base graphs , such that the total complexity is still polynomial in @xmath5 .    together",
    ", this shows that the tar - reachability problem can be solved efficiently for quite a rich graph class .",
    "considering the fact that tar - reachability is pspace - hard for perfect graphs  @xcite , the boundary between hard and easy graph classes for this problem starts to become clear .",
    "recall that cographs are exactly the graphs of cliquewidth two , and of modular width two  @xcite .",
    "generalizing our result to an efficient algorithm for graphs of bounded cliquewidth may be too challenging ; a more reasonable goal is to first consider graphs of bounded modular width .",
    "the _ modular width _ of a graph is the largest number of vertices of a prime graph appearing at some node of its unique modular decomposition tree  @xcite .",
    "is there a polynomial time algorithm for tar - reachability for all graphs of modular width at most @xmath3 , for every constant @xmath3 ?",
    "the following two questions related to independent set reconfiguration in cographs are still open : first , what is the complexity of deciding whether there exists a @xmath3-tar - sequence  of length at most @xmath74 between two independent sets of a cograph ? ( recall that for general graphs , this is strongly np - hard  @xcite . ) secondly , what is the complexity of deciding whether @xmath17 is connected , if @xmath2 is a cograph ?",
    "we expect that a variant of our dp algorithm can be used to show that this problem can be decided in polynomial time ."
  ],
  "abstract_text": [
    "<S> we study the following independent set reconfiguration problem , called _ -reachability : _ given two independent sets @xmath0 and @xmath1 of a graph @xmath2 , both of size at least @xmath3 , </S>",
    "<S> is it possible to transform @xmath0 into @xmath1 by adding and removing vertices one - by - one , while maintaining an independent set  of size at least @xmath3 throughout ? </S>",
    "<S> this problem is known to be pspace - hard in general . for the case </S>",
    "<S> that @xmath2 is a cograph ( i.e. @xmath4-free graph ) on @xmath5 vertices , we show that it can be solved in time @xmath6 , and that the length of a shortest reconfiguration sequence from @xmath0 to @xmath1 is bounded by @xmath7 , if such a sequence exists .    more generally , we show that if @xmath8 is a graph class for which ( i ) -reachability can be solved efficiently , ( ii ) maximum independent sets can be computed efficiently , and which satisfies a certain additional property , then the problem can be solved efficiently for any graph that can be obtained from a collection of graphs in @xmath8 using disjoint union and complete join operations . </S>",
    "<S> chordal graphs are given as an example of such a class @xmath8 . </S>"
  ]
}