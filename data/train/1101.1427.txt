{
  "article_text": [
    "numerical techniques and , in particular , computer simulations are by now firmly established as a third pillar of the scientific method , complementing the pillars of experiment ( or observation ) and mathematical theory , both of which were erected already at the birth of modern science in the scientific revolution . while in the early times @xcite simulation studies were not quite competitive with analytical calculations in condensed matter physics and quantum field theory ( usually based on perturbative and variational approaches ) nor were their outcomes adequate for comparison with experimental results ( usually due to limited length or time scales ) , this situation has dramatically changed over the past decades .",
    "this very successful race to catch up was fueled by a combination of two factors : a continuous , sometimes revolutionary refinement of the numerical toolbox , for instance through the invention of cluster algorithms @xcite , reweighting @xcite or generalized - ensemble techniques @xcite in the field of monte carlo simulations , and the impressive increase in generally available computational power , which has followed an exponential form known as moore s law for the past forty years . at any time",
    ", however , there has been no shortage of fascinating scientific problems whose computational study required resources at or beyond the cutting edge of the available technology .",
    "this has led scientists to regularly use the latest commodity hardware as soon as it became available , but has also motivated the design and construction of a number of special purpose machines such as , e.g. , the cluster processor @xcite and janus @xcite for the simulation of spin systems or a series of initiatives for qcd calculations with its recent addition of the qpace architecture @xcite .",
    "it has been true for the last couple of generations of graphics processing units ( gpus ) that their theoretical peak performance , in particular for single - precision floating point operations ( flop / s ) , significantly exceeds that of the corresponding x86 based cpus available at the same time ( as of this writing up to around 100 gflop / s in cpus vs.  up to 5 tflop / s in gpus ) .",
    "it is therefore natural that scientists and , increasingly , also programmers of commercial applications other than computer games , have recently started to investigate the possible value of gpu based computing for their purposes ; for scientific applications see , e.g. , refs .",
    "apart from their mere peak performance , systems based on gpus or other highly parallel architectures such as the cell processor @xcite might outperform current cpu based systems also in terms of their efficiency , i.e. , in terms of flop / s per watt or flop / s per euro and thus might also contribute to the advancement of `` green computing . ''",
    "the low prices and convenient over - the - counter availability of gpu devices clearly make for advantages as compared to custom - built special - purpose machines , for which many man - months or years need to be invested for the design , realization and programming of devices . the relative increase in peak performance of gpus versus cpus",
    "is achieved at the expense of flexibility , however : while today s cpus will perform pretty well on most of a large variety of computer codes and , in particular , in a multi - tasking environment where on - the - fly optimizations such as branch prediction are essential , gpus are optimized for the highly vectorized and parallelized floating - point computations typical in computer graphics applications .",
    "a one - to - one translation of a typical code written for cpus to gpus will therefore , most often , _ not _ run faster and , instead , algorithms and parallelization and vectorization schemes must be chosen very carefully to tailor for the gpu architecture in order to harvest any performance increases .",
    "the efficiency of such calculations in terms of flop / s per _ human _ time crucially depends on the availability of easily accessible programming environments for the devices at hand .",
    "while in view of a lack of such supporting schemes early attempts of general purpose gpu ( gpgpu ) calculations still needed to encapsulate the computational entities of interest in opengl primitives @xcite , the situation changed dramatically with the advent of device - specific intermediate gpgpu language extensions such as ati stream and nvidia cuda @xcite . in the future ,",
    "one hopes to become independent of specific devices with general parallel programming environments such as opencl @xcite .",
    "classical spin systems have turned out to be extremely versatile models for a host of phenomena in statistical , condensed matter and high - energy physics , with applications ranging from critical phenomena @xcite over surface physics @xcite to qcd @xcite . a rather significant effort ,",
    "therefore , has been invested over the years into optimized implementations of monte carlo simulations of spin models .",
    "they hence appear to be particularly suited for an attempt to fathom the potential gain from switching to the gpu architecture .",
    "additionally , there are a plethora of questions relating to classical spin models which , decades of research notwithstanding , are still awaiting a combination of an increase in available computational resources , better algorithms and clever techniques of data analysis to find generally satisfactory answers .",
    "this applies , in particular , to disordered systems such as random - field models and spin glasses @xcite .",
    "as will be discussed below , due to their short - ranged interactions and the typically simple lattice geometries such models appear to be near ideal problems for gpu calculations .",
    "this applies , in particular , to the inherently local single spin - flip algorithms discussed here . for studying the critical behavior of models without disorder",
    ", cluster algorithms will outperform any optimized implementation of a local spin - flip dynamics already for intermediate lattice sizes ; the possibilities for porting such approaches to gpu will be discussed elsewhere @xcite . for disordered systems , on the other hand , efficient cluster algorithms are ( with few exceptions @xcite ) not known . for them , instead , local spin - flip simulations combined with parallel tempering @xcite moves are the state of the art .    when comparing gpu and cpu performance for the case of general purpose computational applications , it has become customary to benchmark different implementations in terms of the relative speed - up ( or slow - down ) of the gpu code versus the cpu implementation @xcite .",
    "while such numbers make for good selling points for the company producing the `` better '' type of computational device , it should be clear that speed - ups , being a relative measure , will vary to a large degree depending on how much effort is invested in the optimization of the codes for the different architectures . to avoid this problem ,",
    "the main focus is put here on the _ absolute _ performance of different implementations , measured for the present application mostly in the wall - clock time for performing a single spin flip , citing speed - up factors only as an additional illustration of the relative performance .",
    "if relative measures of performance are given , the question arises of what type of cpu code to compare to , in particular , since with the advent of multi - core processors and vector extensions such as sse , cpus also offer a significant potential for optimizations .",
    "i decided here to use serial cpu code , reasonably optimized on the level of a high - level programming language and the use of good compilers , as i feel that this comes closest to what is most often being used in actual simulation studies .",
    "as regards the possible effects of further cpu optimizations , see also ref .",
    "@xcite which , however , unfortunately does not cite any measures of absolute performance .",
    "simulations of the ferromagnetic ising model using implementations on gpu have been discussed before @xcite . compared to these implementations , the current approach with the double checkerboard decomposition and multi - hit updates to be discussed below offers significant advantages .",
    "other applications , such as the simulation of ferromagnetic , short - range heisenberg models , the simulation of ising spin glasses with asynchronous multi - spin coding or parallel tempering for lattice spin systems are considered here for the first time .",
    "for some very recent discussions of further spin models see also refs .",
    "@xcite .",
    "the rest of this article is organized as follows . in sec .",
    "[ sec : architecture ] , i give some necessary background on the architecture of the nvidia gpus used in this study and its consequences for algorithm design .",
    "section [ sec : ising ] discusses , in some detail , the chosen implementation of a single - spin flip metropolis simulation of the two - dimensional ( 2d ) ising model and its performance as well as a generalization to the three - dimensional ( 3d ) model .",
    "section [ sec : heisen ] is devoted to generalizations of these considerations to continuous - spin systems , exemplified in the 2d heisenberg model .",
    "in secs .  [",
    "sec : spinglass ] and [ sec : tempering ] , applications to simulations of spin - glass models and the use of parallel - tempering updates are discussed .",
    "finally , sec .",
    "[ sec : concl ] contains my conclusions .",
    "as indicated above , there are significant differences in the general design of cpu and gpu units @xcite .",
    "cpus have been optimized over the past decades to be `` smart '' devices for the rather unpredictable computational tasks encountered in general - purpose computing .",
    "current intel cpus feature about 800 million transistors on one die .",
    "a rather small fraction of them is used for the alus ( arithmetic logic units ) doing actual computations , whereas most of the available transistors are devoted to flow control ( such as out - of - order execution and branch prediction ) and cache memory .",
    "this structure is very successful in increasing the performance of _ single_-threaded applications , which still make up the vast majority of general computer codes .",
    "in contrast , about 80  % of the 1.4 billion transistors on a gpu die of the nvidia gt200 series ( now superseded by the fermi architecture ) are alus .",
    "gpus do not try to be `` clever '' , but they are extremely efficient at doing the same computational steps on different bits of a large data - set in parallel .",
    "this is what makes them interesting for applications in scientific computing .",
    "figure [ fig : hardware ] shows a schematic representation of the general architecture of a current gpu .",
    "the chip contains a number of multiprocessors each composed of a number of parallel processing units .",
    "the systems based on the gt200 architecture used in this study feature 30 multiprocessors of 8 processors each ( versus 15 multiprocessors  32 cores for the gtx 480 fermi card ) .",
    "the systems come with a hierarchy of memory layers with different characteristics .",
    "each processor is equipped with a number of registers which can be accessed with essentially no latency .",
    "the processors in a multiprocessor unit have read / write access to a small amount of shared memory ( @xmath1 kb in the gt200 architecture and @xmath2 kb for fermi cards ) which is on - chip and can be accessed with latencies around a hundred times smaller than those for global memory . the large device or global memory ( up to 6 gb in current tesla systems ) is connected with read / write access to all multiprocessors .",
    "latency for global memory accesses is of the order of 400600 clock cycles ( as compared to , e.g. , one clock cycle for a multiply or add operation ) .",
    "the additional constant and texture memory areas are cached and designed for read - only access from the processing units , in which case they operate very fast with small latencies .",
    "the memory of the host computer can not be accessed directly from within calculations on the gpu , such that all relevant data need to be copied into and out of the gpu device before and after the calculation , respectively . since the processing units of each multiprocessor are designed to perform identical calculations on different parts of a data set ,",
    "flow control for this simd ( single instruction multiple data ) type of parallel computations is rather simple .",
    "it is clear that this type of architecture is near ideal for the type of calculations typical for computer graphics , namely rendering a large number of triangles in a 3d scene or the large number of pixels in a 2d projection in parallel .",
    "the organization of processing units and memory outlined in fig .",
    "[ fig : hardware ] translates into a combination of two types of parallelism : the processing units inside of each multiprocessor work synchronously on the same data set ( vectorization ) , whereas different multiprocessors work truly independent of each other ( parallelization ) .",
    "the corresponding programming model implemented in the cuda framework @xcite is outlined schematically in fig .",
    "[ fig : gridblock ] : computations on gpu are encapsulated in functions ( called `` kernels '' ) which are compiled to the gpu instruction set and downloaded to the device .",
    "they are executed in a two - level hierarchic set of parallel instances ( `` execution configuration '' ) called a `` grid '' of thread `` blocks '' .",
    "each block can be thought of as being executed on a single multiprocessor unit .",
    "its threads ( up to 512 for the gt200 architecture and 1024 for fermi cards ) access the same bank of shared memory concurrently .",
    "ideally , each thread should execute exactly the same instructions , that is , branching points in the code should be reduced to a minimum .",
    "the blocks of a grid ( up to @xmath3 ) are scheduled independently of each other and can only communicate via global memory accesses .",
    "the threads within a block can make use of cheap synchronization barriers and communicate via the use of shared ( or global ) memory , avoiding race conditions via atomic operations implemented directly in hardware . on the contrary",
    ", the independent blocks of a grid can not effectively communicate within a single kernel call .",
    "if synchronization between blocks is required , consecutive calls of the same kernel are required , since termination of a kernel call enforces all block computations and pending memory writes to complete .",
    "since the latency of global memory accesses is huge as compared to the expense of elementary arithmetic operations , many computational tasks on gpu will be limited by memory accesses , i.e. , the bandwidth of the memory subsystem .",
    "it is therefore crucial for achieving good performance to ( a ) increase the number of arithmetic operations per memory access , and ( b ) optimize memory accesses by using shared memory and choosing appropriate memory access patterns .",
    "the latter requirement in particular includes the adherence to the specific _ alignment _ conditions for the different types of memory and clever use of the _ coalescence _ phenomenon , which means that accesses to adjacent memory locations issued by the different threads in a block under certain conditions can be merged into a single request , thus greatly improving memory bandwidth . due to most typical computations being limited by memory accesses ,",
    "it is important to use an execution configuration with a total number of threads ( typically several @xmath0 ) much larger than the total number of processing units ( @xmath4 for the tesla c1060 and @xmath5 for the gtx 480 ) .",
    "if a thread block issues an access , e.g. , to global memory , the gpu s scheduler will suspend it for the number of cycles it takes to complete the memory accesses and , instead , execute another block of threads which has already finished reading or writing its data .",
    "the good performance of these devices thus rests on the idea of latency hiding and transparent scalability through flexible thread scheduling @xcite .",
    "the layout of the gpu architecture outlined above implies guidelines for the efficient implementation of computer simulation codes . along these lines",
    ", a code for single - spin flip metropolis simulations of the ferromagnetic ising model is developed .",
    "we consider a ferromagnetic , nearest - neighbor , zero - field ising model with hamiltonian @xmath6 on square and simple cubic lattices of edge length @xmath7 , using periodic boundary conditions . in the single - spin flip metropolis simulation scheme for this model",
    "each step consists of randomly selecting a spin @xmath8 and proposing a spin flip @xmath9 , which is accepted according to the metropolis criterion @xcite @xmath10,\\ ] ] where @xmath11 corresponds to the energy change incurred by the flip and @xmath12 denotes the inverse temperature .",
    "it is straightforward to show that this update is ergodic , i.e. , all states of the system can be reached in a finite number of spin - flip attempts with non - zero probability , and satisfies the detailed balance condition ensuring convergence to the equilibrium boltzmann distribution . in practice , one usually walks through the lattice in a sequential fashion instead of picking spins at random , which requires less pseudo - random numbers and , generically , leads to somewhat faster convergence .",
    "this updating scheme , in fact , violates detailed balance , but is consistent with the global balance condition which is sufficient to ensure convergence @xcite .",
    "this point is of some importance for the gpu implementation developed here , and will be further discussed below in section [ sec : balance ] .      to leverage the effect of the massively parallel architecture of gpu devices for simulations of spin models , in most cases",
    "domain decompositions where the system is divided into a large number of largely independent sub - units are the only approach with satisfactory scaling properties as the number of processors or the size of the system is increased . for the case of lattice systems , the simplest scheme amounts to a coloring of lattice sites with the minimally feasible number of colors . here , i focus on bipartite graphs such as the square and ( hyper-)cubic lattices where two colors suffice , resulting in a ( generalized ) checkerboard decomposition @xcite .",
    "generalizations to other cases are trivial .     for performing a single spin - flip metropolis simulation of the ising model on gpu .",
    "each of the @xmath13 big tiles is assigned as a thread block to a multiprocessor , whose individual processors work on one of the two sub - lattices of all @xmath14 sites of the tile in parallel.,scaledwidth=60.0% ]    in such a scheme , each site of one sub - lattice can be updated independently of all others ( assuming nearest - neighbor interactions only ) , such that all of them can be treated in parallel followed by an analogous procedure for the second sub - lattice . for an implementation on gpu , the checkerboard decomposition needs to be mapped onto the structure of grid blocks and threads .",
    "although , conceptually , a single thread block suffices to update one sub - lattice in parallel , the limitation to 512 threads per block for the gt200 architecture ( resp .",
    "1024 threads for fermi ) enforces an additional block structure for systems of more than 1024 resp .",
    "2048 spins . for the square lattice , in ref .",
    "@xcite stripes with a height of two lattice spacings were assigned to independent thread blocks while performing all spin updates in global memory .",
    "this has several disadvantages , however : ( a ) shared memory with its much lower latency is not used at all , ( b ) determining the indices of the four neighboring spins of each site requires costly conditionals due to the periodic boundary conditions , and ( c ) the system size is limited to @xmath15 for gt200 ( @xmath16 for fermi ) . here , instead , i suggest a more versatile and efficient approach leveraging the inherent power of the memory hierarchy intrinsic to gpus . to this end",
    "a twofold hierarchy of checkerboard decompositions is used .",
    "figure [ fig : checker ] illustrates this for the case of a square lattice : on the first level , the lattice is divided into @xmath17 big tiles in a checkerboard fashion .",
    "these are then updated by individual thread blocks , where the individual threads exploit a second - level checkerboard decomposition of the @xmath18 lattice sites inside each tile . the size of big tiles is thereby chosen such that the spin configuration on the tile ( plus a boundary layer of spins ) fits into shared memory , such that the spin updates can then be performed entirely inside of this much faster memory area .",
    "on the block level , through the checkerboard arrangement all tiles of one ( `` even '' ) sub - lattice can be updated concurrently before updating the other ( `` odd '' ) half of tiles . inside of each block , again",
    "all sites of the finer sub - lattices are independent of each other and are therefore updated concurrently by the threads of a thread block .    in summary",
    ", the updating procedure looks as follows :    1 .",
    "the updating kernel is launched with @xmath19 thread blocks assigned to treat the _ even _",
    "tiles of the coarse checkerboard .",
    "2 .   the @xmath20 threads of each thread block cooperatively load the spin configuration of their tile plus a boundary layer into shared memory .",
    "3 .   the threads of each block perform a metropolis update of each _ even _ lattice site in their tile in parallel . 4 .",
    "all threads of a block wait for the others to finish at a barrier synchronization point .",
    "the threads of each block perform a metropolis update of each _ odd _ lattice site in their tile in parallel .",
    "the threads of each block are again synchronized .",
    "a second kernel is launched working on the @xmath19 _ odd _ tiles of the coarse checkerboard in the same fashion as for the even tiles .",
    "the cooperative loading of each tile into shared memory is organized in a fashion to ensure _ coalescence _ of global memory accesses @xcite ,",
    "i.e. , subsequent threads in each block access consecutive global memory locations wherever possible .",
    "while it turns out to be beneficial to load tiles into shared memory already for a single update per spin before treating the second coarse sub - lattice due to an avoidance of bank conflicts in global memory as well as the suppressed need to check for periodic wrap - arounds in determining lattice neighbors , the ratio of arithmetic calculations to global memory accesses is still not very favorable .",
    "this changes , however , if a multi - hit technique is applied , where the spins on each of the two coarse sub - lattices are updated several times before returning to the other half of the tiles . as is discussed below in sec .",
    "[ sec : balance ] , this works well , in general , and only close to criticality somewhat increased autocorrelation times are incurred .      by design ,",
    "monte carlo simulations of spin systems require a large amount of pseudo - random numbers .",
    "depending on implementation details , for a system as simple as the ising model , the time required for generating random numbers can dominate the total computational cost .",
    "hence , the efficient implementation of random - number generators ( rngs ) in a massively parallel environment is a crucial requirement for the efficient use of the gpu architecture .",
    "speed is not everything , however , and it is well known that the statistical deficiencies that no _ pseudo _ rng can entirely avoid can have rather dramatic consequences in terms of highly significant deviations of simulation results from the correct answers @xcite .",
    "hence , some effort must be invested in the choice and implementation of an appropriate rng .    from the highly parallel setup described above",
    ", it is clear that each of the @xmath21 concurrent threads must be able to generate its stream of random numbers to a large degree independently of all others , since the bottleneck in any configuration with a centralized random - number production would severely impede scaling of the code to a large number of processing units .",
    "as each of these ( sub-)sequences of random numbers are used in the same simulation , one needs to ensure that ( a ) either each thread generates different members of the same global sequence of numbers or ( b ) the sequences generated by different threads are at least statistically uncorrelated .",
    "the simplest choice of rng is given by the linear congruential generator ( lcg ) of the form @xmath22 with @xmath23 .",
    "the authors of ref .",
    "@xcite used @xmath24 and @xmath25 , originally suggested in ref .",
    "the period of this generator is small with @xmath26 @xcite . in a simulation of a @xmath27 ising system , for instance ,",
    "this period is exhausted already after 256 sweeps . on theoretical grounds , it is argued that one actually should not use more than @xmath28 numbers out of such a sequence @xcite , which would render the sequence of available numbers very short indeed .",
    "additionally , simple lcgs are known to exhibit strong correlations which can be revealed by plotting @xmath29-tuples of successive ( normalized ) numbers as points in @xmath30 , where it is found that , already for rather small @xmath29 , the points are confined to a sequence of hyperplanes instead of being uniformly distributed .",
    "the choice @xmath31 has the advantage that the whole calculation can be implemented entirely in 32-bit integer arithmetic since on most modern architectures ( including gpus ) integer overflows are equivalent to taking a modulo operation . for such power of two moduli @xmath32",
    ", however , the period of the less significant bits is even shorter than that of the more significant bits , such that the period of the @xmath29th least significant bit is only @xmath33 .",
    "an advantage for the parallel calculations performed here is that one can easily skip ahead in the sequence , observing that @xmath34 where @xmath35 therefore , choosing @xmath36 equal to the number @xmath37 of threads , all threads can generate numbers out of the same global sequence ( [ eq : lcg ] ) concurrently .",
    "an alternative setup , that can not guarantee the desired independence of the sequences associated to individual rng instances , however , starts from randomized initial seeds for each generator , without using any skip - ahead @xcite . to improve on the drawback of a short period",
    ", one might consider moving to a generator with larger @xmath32 , for instance @xmath38 , where the modulo operation again can be implemented by overflows , this time for @xmath39-bit integers , a data type which is also available in the cuda framework .",
    "as multiplier i chose @xmath40 with provably relatively good properties @xcite , where an odd offset , here @xmath41 , needs to be chosen to reach the maximal period of @xmath42 .",
    "as for the @xmath43-bit case , this generator can be used in the parallel framework yielding numbers from a common sequence via skip - ahead , or as independent generators with initial randomized seeds , leading to overlapping sub - sequences .     and @xmath44 , @xmath45 , while `` lcg32 '' and `` lcg64 '' correspond to the recursion with @xmath46 and @xmath47 , respectively .",
    "all thread blocks use @xmath48 threads . ]    for high - precision calculations , one normally would not want to rely on a simple lcg",
    ". a significant number of generators with much better statistical properties has been developed in the past , for a review see ref .",
    "@xcite . for our purposes",
    ", however , most of them have severe drawbacks in that they are either quite slow ( such as , for instance , generators that combine a number of elementary rngs or , instead , drop a certain fraction of random numbers generated as in ranlux @xcite ) , that they use a large state to operate on ( for instance @xmath49 32-bit words for the popular mersenne twister @xcite ) , or that it is rather hard to ensure that sequences generated independently are to a reasonable degree uncorrelated ( as for most high - quality generators ) .",
    "while a state larger than a few words is usually not a problem for serial implementations , in the framework of gpu computing where fast local ( i.e. , shared ) memory is very limited , it is impossible to use several hundred words per thread of a thread block only for random number generation .",
    "a reasonable compromise could be given by generators of the ( generalized ) lagged fibonacci type with recursion @xmath50 which operate on a buffer of length @xmath51 with @xmath52 and have good properties for sufficiently large lags @xmath53 and @xmath54 and choosing @xmath55 @xcite . if @xmath56 , the maximal period is @xmath57 .",
    "for an implementation in single precision arithmetic , i.e. , @xmath58 , and @xmath59 ( see below ) , this results in a rather large period @xmath60 .",
    "the recursion ( [ eq : lagged_fibonacci ] ) can be implemented directly in floating - point arithmetic yielding uniform random numbers @xmath61 $ ] via @xmath62 for good quality one needs @xmath63 , leading to relatively large storage requirements , but here the generation of @xmath54 random numbers can be vectorized by the threads of a thread block .",
    "therefore , the required ring buffer of length @xmath51 words is shared by the @xmath20 threads of a block , and hence the storage requirement in only @xmath64 words per thread .",
    "if one chooses @xmath54 only slightly larger than the number of threads per block , only a few words per thread are consumed .",
    "a number of good choices for the lags @xmath53 and @xmath54 are collected in ref .",
    "the best performance is achieved for unity multipliers @xmath65 , at only moderately reduced quality of the resulting random numbers . in this setup ,",
    "different thread blocks use different sequences .",
    "prescriptions for ensuring disjunct sequences are described in ref .",
    "@xcite . in view of the astronomic period , however , it appears safe to just seed the ring buffers of the generators for different blocks with an independent rng .    the lcg generator with @xmath66 and @xmath67 as well as the generalized fibonacci generator were implemented and benchmarked on a tesla c1060 gpu .",
    "the lcgs have been realized with @xmath43- and @xmath39-bit integers , respectively , using the multipliers listed above . for the fibonacci generator , i chose @xmath65 and lags @xmath44 and @xmath45 ( suitable for simulations with tile size up to @xmath68 ) .",
    "the generators were test with a variable number of blocks of @xmath48 threads each ( where @xmath48 is the maximum number of threads allowed on the c1060 device ) .",
    "all generator state information is kept in shared memory .",
    "the results are displayed in fig .",
    "[ fig : rng ] . the characteristic zig - zag pattern results from the commensurability ( or not ) of the number of blocks @xmath69 with the number of @xmath70 multiprocessors on the device , such that the performance is best if @xmath71 , @xmath72 , @xmath73 , @xmath74 and worst if @xmath75 , since in the latter case @xmath76 of the multiprocessors are idle once the last batch of blocks has been scheduled for execution .",
    "the @xmath43-bit lcg is found to take at best @xmath77 ns per random number , whereas the @xmath39-bit lcg and the lagged fibonacci generator are about @xmath78 and @xmath79 times slower , respectively .",
    "lt9t2t7 . & & & & + exact & 1.106079207 & 0 & 0.8616983594 & 0 +   + lcg32 & 1.1060788(15 ) & -0.26 & 0.83286(45 ) & -63.45 + lcg64 & 1.1060801(17 ) & 0.49 & 0.86102(60 ) & -1.14 + fibonacci , @xmath80 & 1.1060789(17 ) & -0.18 & 0.86132(59 ) & -0.64 +   + lcg32 & 1.0944121(14 ) & -8259.05 & 0.80316(48 ) & -121.05 + lcg32 , random & 1.1060775(18 ) & -0.97 & 0.86175(56 ) & 0.09 + lcg64 & 1.1061058(19 ) & 13.72 & 0.86179(67 ) & 0.14 + lcg64 , random & 1.1060803(18 ) & 0.62 & 0.86215(63 ) & 0.71 + fibonacci , @xmath80 & 1.1060890(15 ) & 6.43 & 0.86099(66 ) & -1.09 + fibonacci , @xmath81 & 1.1060800(19 ) & 0.40 & 0.86084(53 ) & -1.64 +    [ tab : rng ]    the quality of the streams of random numbers generated in this way was tested with the metropolis update simulation of the 2d ising model using the double checkerboard update .",
    "the resulting estimates for the internal energy and specific heat of a system of edge length @xmath82 and inverse temperature @xmath83 from simulations employing a number of different generators are collected in tab .",
    "[ tab : rng ] . for comparison , the exact results calculated according to ref .",
    "@xcite are shown as well .",
    "for the sequential updates on cpu , the dominant correlations and short period of the @xmath43-bit lcg lead to highly significant deviations at the chosen rather high level of statistics ( @xmath84 updates per spin ) , which are , however , only visible in the specific heat data . already",
    "the @xmath39-bit lcg and likewise the fibonacci generator result in data completely consistent with the exact values at the given level of statistical accuracy .",
    "the double checkerboard simulations on gpu , on the other hand , appear to be much more sensitive to correlations in the rngs . if all threads sample from the same sequence of random numbers using skipping according to eq .  , the @xmath43-bit lcg produces astronomic and the @xmath39-bit lcg still sizable deviations from the exact result , cf .  the data collected in tab  [ tab : rng ] .",
    "somewhat surprisingly , no significant deviations are produced from either lcg when seeding the lcg of each thread randomly and independently with another rng . in some sense",
    ", this setup appears to mimic the effects of a combined generator @xcite : although all of the sequences traversed by individual threads have significant overlap with each other , the random shifts between different sequences are sufficient to cancel the correlation effects .",
    "the fibonacci generators of eq .",
    ", on the other hand , do not suffer from such problems , although deviations are again larger than for the sequential implementation , and one needs to go to a lag as large as @xmath59 to get fully satisfactory results for the system at hand .",
    "note that the observed differences between cpu and gpu results are entirely due to the different order of spin updates in the sequential and checkerboard setups , and have nothing to do with shortcomings of the gpu architecture .",
    "in particular , all the generators ( and variants ) implemented here on gpu in connection with the corresponding simulation codes guarantee completely reproducible results , i.e. , the sequence of generated spin configurations only depends on the initial seeding of the rngs and not the order in which different blocks or threads are executed .    for general practical applications , the use of the lagged fibonacci generator appears to be a reasonable compromise in that it is only rather insignificantly slower than the @xmath39-bit lcg , but produces random numbers of substantially better quality .",
    "the setup with randomly seeded independent lcgs per thread also yields satisfactory results ( and can be very fast ) , but in the absence of a deeper understanding of how correlations are destroyed in this setup , it can not be entirely recommended for high - precision studies of simple , discrete models such as the ising ferromagnet considered here . for systems with continuous degrees of freedom or with additional quenched disorder ,",
    "however , such correlation effects are presumably less of a problem .",
    "it is worthwhile to note that the checkerboard update , like the sequential update of lattice sites usually applied in a scalar computing context , does not satisfy detailed balance ( see , e.g. , ref .",
    "@xcite ) , @xmath85 on the level of single spin flips since the probability of selecting a spin twice for updating in direct succession vanishes if the lattice sites are treated in a deterministic order .",
    "the global balance condition , @xmath86 on the other hand , which is sufficient to ensure convergence of the chain @xcite , stays satisfied at all times .",
    "the same holds true if the checkerboard update is applied in a multi - hit fashion with each coarse sub - lattice being updated @xmath87 times before moving on to the other sub - lattice .",
    "although detailed balance is not required for sampling the equilibrium distribution , it can be recovered , if desired , e.g. , to ensure that certain dynamical properties hold , on the level of compound moves such as lattice sweeps .",
    "denote , for instance , an update of the even sub - lattice with `` a '' and an update of the odd sub - lattice with `` b '' and a measurement time by `` m '' .",
    "then , a sequence of the form @xmath88 satisfies detailed balance with respect to compound updates and is hence more symmetric than the naive multi - hit implementation .",
    "ising model as a function of inverse temperature @xmath89 .",
    "the gpu calculations were performed with different numbers @xmath29 of multi - hit updates , but at a constant total number of updates . ]",
    "while the multi - hit approach with @xmath90 is a perfectly valid updating scheme , it is clear that very close to the critical point it will be somewhat slower than the @xmath91 version at decorrelating the system as soon as the correlation length @xmath92 exceeds the size @xmath93 of the tiles . assuming that @xmath94 , it takes @xmath95 sweeps to decorrelate the configuration of the tile or , equivalently , for information traveling diffusively to cross the tile . for @xmath96",
    ", one expects multi - hit updates to become inefficient .",
    "figure [ fig : autocorr ] shows the resulting integrated autocorrelation times @xcite @xmath97 of the internal energy of a @xmath98 ising system as a function of inverse temperature @xmath89 and comparing the cpu calculation with gpu simulations with multi - hit updates ranging from @xmath91 up to @xmath99 , using tiles of @xmath100 spins .",
    "note that , in the same way as sequential spin updates in a scalar simulation have different autocorrelation times than purely random updates , the checkerboard ( i.e. , gpu ) way of updating the spins yields slightly different autocorrelation times than the sequential update on cpu .",
    "this effect , however , appears to be weak .",
    "apart from the general expected rounded divergence of autocorrelation times in the vicinity of the critical coupling @xmath101 , fig .",
    "[ fig : autocorr ] clearly reveals the relative increase of @xmath97 as @xmath29 is increased . as a result ,",
    "in the vicinity of @xmath102 there are two competing effects : increasing @xmath29 reduces the overhead of loading tiles from global memory and thus decreases spin - flip times , whereas at the same time it increases autocorrelation times , thus reducing sampling efficiency . as a result , the autocorrelation time in physical units , @xmath103 where @xmath104 denotes the real time for a single spin flip , such that @xmath105 corresponds to the real time for generating an effectively uncorrelated spin configuration , close to @xmath102 has a minimum at intermediate values of @xmath29 .",
    "this is illustrated in fig .",
    "[ fig : autocorr2 ] , again for a @xmath98 system with tile size @xmath68 , where it is seen that , in the vicinity of @xmath102 , multi - hit updates with @xmath106 appear to be optimal .     for the @xmath98 ising system and double checkerboard updates on gpu for different values of the multi - hit parameter @xmath29 .",
    "minimal @xmath107 corresponds to a minimum time of generating a statistically independent spin configuration . ]      using the double checkerboard decomposition loading tiles into shared memory and the rngs discussed above , an optimized code was first constructed for the case of the square - lattice ising model .",
    "the sample code , which has undergone significant further optimizations as compared to the version discussed in ref .",
    "@xcite , can be downloaded from the author s web site @xcite .",
    "multi - hit updates of the square - lattice ising model as a function of linear system size @xmath7 .",
    "the lines correspond to different block sizes @xmath93 . ]",
    "it is a well - known trick valid for discrete models to tabulate the exponential occurring in the acceptance criterion ( [ eq : metropolis ] ) in advance and use a look - up instead of calculating the exponential directly .",
    "it appears natural to store this array in constant memory which is fast through caching @xcite .",
    "this memory , however , is optimized for the different threads of a block synchronously accessing the _ same _ memory element , which is not the typical case here since different spins usually have different local interaction energies . it is found more efficient , therefore , to store this table in texture memory which is fast with different threads accessing different memory locations . while for the cpu code it is beneficial to save arithmetic cycles by drawing random numbers and looking up the value of the boltzmann factor only when @xmath108 , this is not the case on gpu , where such an approach results in thread divergence requiring the corresponding branch to be visited twice . for the code discussed here , i used a single variable of the high - level language to represent a spin .",
    "performance differences depending on whether int ( 32 bit ) , short int ( 16 bit ) or char ( 8 bit ) variables are used are only very moderate .",
    "the results discussed below are for int variables .",
    "a multi - spin coded version is discussed below in sec .",
    "[ sec : spinglass ] .    .",
    "gpu data are for the tesla c1060 device apart from the lowest curve which is for a gtx 480 card .",
    "all data are for tile size @xmath109 and an inverse temperature @xmath83 close to , but off the critical coupling .",
    "there is a weak temperature dependence of spin - flip times due to differences in the number of write operations . ]",
    "the optimum choice of the size @xmath93 of tiles depends on system size and is determined by the relative resource utilization on the considered gpu device .",
    "the corresponding measured spin - flip times for @xmath99 shown in fig .",
    "[ fig : blocks ] are easily understood from the parameters of the tesla c1060 device at hand : tiles should be large enough to provide a sufficient number of threads in each block .",
    "the optimum load is seen when each multiprocessor is assigned with the maximum number of eight thread blocks . since each multiprocessor can accommodate a maximum allowed number of @xmath110 threads , this results in @xmath111 threads per block .",
    "this number is reached for tiles of size @xmath112 spins ( remember that each thread updates two sites ) .",
    "this choice turns out to be optimal for lattice sizes @xmath113 . for smaller lattices , on the other hand",
    ", @xmath68 does not provide enough blocks to load all 30 multiprocessors of the device which requires @xmath114 or @xmath115 for @xmath116 and @xmath117 for @xmath118 .",
    "since @xmath119 is the smallest tile size considered , this is also optimal for the smallest lattice sizes @xmath120 and @xmath121 . for smaller values of @xmath29 ,",
    "the performance of global memory accesses comes into play , which favors larger tile sizes due to the resulting improvements in coalescence , such that @xmath68 turns out to be optimal for any @xmath122 there .",
    "test simulations for the fermi architecture on a gtx 480 card lead pretty much to the same conclusions : there , the maximum number of resident threads per multiprocessor has been increased to 1536 , but this increase is too small to lift the optimum tile size to @xmath123 such that , again , @xmath124 is optimal apart from simulations on the smallest lattices .    .",
    "]    figure [ fig : speedup ] shows the performance data for the final code as compared to the scalar cpu implementation . as a reference cpu",
    "i used an intel core 2 quad q9650 at 3.0 ghz , which is one of the fastest available cpus for single - threaded applications .",
    "the performance of the latter is essentially independent of system size with about @xmath125  ns per spin flip .",
    "the maximum performance on gpu is reached only for system sizes @xmath126 with about @xmath127  ns per spin flip for @xmath128 and @xmath129  ns per spin flip for @xmath99 , resulting in speed - up factors ranging from @xmath70 to @xmath130 .",
    "the fermi architecture results in an extra speed - up of about @xmath131 compared to the tesla c1060 device , leading to a maximum performance of @xmath132  ns per spin flip at @xmath99 or an overall speedup factor of @xmath133 ( the extra speedup for @xmath91 is even slightly larger , probably due to the reduced overhead of kernel calls for the fermi architecture ) . comparing to the previous implementation in ref .",
    "@xcite , one notes that , probably due to inappropriate cache alignment , the ( single - spin coded ) cpu code used there is rather inefficient , such that , e.g. , for a @xmath134 system the code used here is about @xmath135 times faster than that of ref .",
    "@xcite and @xmath136 times faster than the results quoted in ref .",
    "@xcite , leading to a rather unfavorable comparison for the cpu based systems in these works .",
    "their multi - spin coded cpu version is less than a factor of two more efficient than the single - spin coded implementation used here ( see below in sec .  [",
    "sec : spinglass ] for a multi - spin coded version of the program used here ) .",
    "the maximum performance of the gpu implementation of ref .",
    "@xcite with @xmath137 ns on the tesla c1060 is about @xmath138 times less than the present @xmath128 code and a factor of @xmath139 slower at @xmath99 .",
    "the significant speedup at @xmath128 is due to the combined effect of the avoidance of bank conflicts in computing the local interaction energy , the fact that periodic boundaries do not need to be taken account with expensive modulo operations once the tile including its boundary layer has been loaded into shared memory , and the efficient implementation of the metropolis criterion using texture fetches .",
    "the multi - spin coded gpu code ( shared memory version ) of ref .",
    "@xcite is about of the same performance as our single - spin coded version at @xmath128 .        in a practical application measurement cycles",
    "are required on top of the updates , of course .",
    "energy measurements were here realized with tracking the local energy changes at each spin flip and combining them in a final parallel reduction step after the update . at @xmath99 , corresponding to only one measurement per one hundred lattice sweeps , the overhead is small , of the order of 10% , see the data collected in fig .",
    "[ fig : speedup2 ] . at @xmath128 ,",
    "the overhead is about 20% . in view of the potential problems with the quality of random numbers discussed above in sec .",
    "[ sec : rng ] , it is worthwhile to check the influence of the different speeds of rngs discussed above on the overall performance of the ising simulation code . in a simulation as simple as the metropolis update of the ising model , a substantial fraction of time is spent for generating random numbers .",
    "therefore , it is no surprise that it is found that the simulation is slower by a factor of @xmath140 when using the lcg64 instead of the lcg32 generator and by a factor of @xmath141 when using the lagged fibonacci generator ( @xmath99 , @xmath142 ) . in view of the good results for",
    "the randomly initialized lcg32 reported in sec .",
    "[ sec : rng ] , it is probably acceptable to use it for the considered model in view of its good performance . for other applications , however , this issue would need to be revisited .",
    "the generalization of the gpu code from two to three dimensions is straightforward , and only the part responsible for the correct bookkeeping in loading a tile into shared memory becomes more tedious to formulate .",
    "the range of allowable tile sizes is somewhat more restricted by the limitation of the available gpus to 512 threads per block ( resp .",
    "1024 for fermi ) . with the current setup ,",
    "therefore , the only tile sizes that can be reasonably considered are @xmath143 and @xmath144 , if one restricts oneself to powers of two in system as well as in tile sizes .",
    "more general and , perhaps , versatile , setups could be reached by relaxing the power - of - two condition or considering tiles with non - unit aspect ratios , which might lead to additional slight increases in performance . for the sake of simplicity , however , i here refrain from introducing such complications .    the timing results for the 3d code are summarized in fig .",
    "[ fig : speedup3d ] .",
    "the performance of the cpu code is essentially independent of lattice size within the considered range of @xmath145 up to @xmath146 , arriving at around @xmath147 ns per spin flip on the reference cpu used here , which is slower than the 2d code by a bit more than the factor of @xmath148 expected merely from the increased number of nearest neighbors to be included in energy calculations . for the gpu code",
    ", we find rather comparable performance from @xmath143 and @xmath144 with a slight advantage for the latter for lattice sizes exceeding @xmath149 .",
    "the maximum performance on the tesla c1060 is around @xmath150 ns ( at @xmath151 ) , about by the expected factor of @xmath152 less than in two dimensions .",
    "the fermi card is faster by another factor of @xmath153 , resulting in a peak performance of @xmath154 ns per spin flip . as a consequence ,",
    "the observed maximal speed - up factors are @xmath155 for the c1060 and @xmath156 for the gtx 480 .",
    "these speed - ups are very close to those observed in two dimensions , such that the relative efficiency of the cpu and gpu implementations are practically identical in two and three dimensions .",
    "a natural generalization of the ising model is to systems with continuous degrees of freedom , i.e. , o(@xmath157 ) spin models with hamiltonian @xmath158 which are , most often , more realistic for the description of real magnetic materials . for implementations of simulation algorithms on gpu",
    ", this offers the opportunity to test the relative performance of floating - point operations , an application for which gpus are highly optimized by design , since their original purpose in rendering graphics in technical terms to a large percentage reduces to manipulations of matrices of floating - point numbers .    since for the original graphics purposes calculations in double precision",
    "usually are not relevant , traditionally gpu devices have only offered single - precision arithmetic . although double precision calculations could be emulated in software , native support for double precision arithmetic was only introduced with the gt200 architecture , but it came with a massive performance penalty , double precision being around eight times slower than single precision . only with the recent fermi architecture ,",
    "this drawback has been partially removed , double precision calculations there being only around a factor of two slower than single precision arithmetic .",
    "sufficient precision is certainly important for numerical algorithms that have a potential of accumulating rounding and finite - precision errors such as , e.g. , molecular dynamics simulation codes . for monte carlo simulations , on the other hand ,",
    "it is rather obvious that due to the random sampling rounding errors and numerical accuracy are much less of an issue , and it might be acceptable to represent the degrees of freedom in single precision and use double precision only for accumulated quantities in measurements .",
    "implementations in single and in double precision are benchmarked here , also from the point - of - view of the resulting accuracy .     and @xmath151 .",
    "]    in addition to the question of the number of digits , the floating - point implementation on cuda devices is not completely compliant with the ieee-754 floating - point standard which is otherwise practically universally accepted for current computing platforms . in particular ,",
    "devices prior to the fermi series do no support the so - called denormalization feature ( for single - precision calculations ) that ensures sufficient accuracy for numbers close to zero .",
    "furthermore , due to device - specific implementations , the accuracy of operations such as division and square root is sometimes less than the @xmath159 units in the last place ( ulp ) prescribed by the ieee standard . additionally , there are some less dramatic deviations such as the absence of a signaling of floating - point exceptions , the lack of configurable rounding modes and others .",
    "the mentioned limitations are removed with the advent of fermi cards , which can be configured to almost completely adhere to the ieee standard .",
    "regarding transcendental functions such as exponential , sine and logarithm , device - specific and highly performant , but less accurate , versions are provided in the cuda framework in addition to the standard c library implementations that are also available @xcite .",
    "( note , however , that these highly performant implementations are only available in single - precision variants . ) apart from these questions of adherence to the floating - point standard and whether single - precision calculations are sufficient for the purpose at hand , one must keep in mind that parallel algorithms in themselves might lead to finite - precision effects which are different from those seen in serial algorithms .",
    "if for instance , a binary - tree algorithm is used to perform a parallel reduction over an array of values to evaluate their sum ( as in the energy measurement code of the algorithms discussed here ) , the result will be slightly different to that found in a serial calculation since in finite precision addition is not commutative .",
    "such effects can be reduced , however , with appropriate adaptations , for instance sorting the array by size prior to the reduction , such that values of similar magnitude are added first .",
    "such considerations are not specific to gpus , of course , but need to be taken into account whenever parallel algorithms come into play .    to study the effects of these particularities of the massively parallel gpu architecture on the performance and accuracy of a monte carlo simulation , a metropolis single - spin update simulation code was benchmarked for the case of the heisenberg model .",
    "for the sake of simplicity , a new spin orientation is proposed uniformly at each update step , independent of the previous orientation of the spin . in practice , this leads to poor acceptance rates at low temperatures which could be improved by proposing small modifications instead of uniform re - orientations . for the benchmarks considered here , however , this question is irrelevant , since local reorientations lead to almost identical results for the relative performance of the different implementations considered .",
    "in the standard implementation , drawing a random unit vector in three dimensions requires two random numbers and a total of five trigonometric function calls .",
    "in addition , there are @xmath160 multiply - and - add operations for calculating the scalar products in determining the local energy change in an attempted flip for simulations on a @xmath161-dimensional ( hyper-)cubic lattice . compared to the ising system , the exponentials in the metropolis criterion ( [ eq : metropolis ] )",
    "can not be tabulated in advance , leading to an extra special - function call per attempted update . as a result of these differences ,",
    "an update step for the heisenberg model is significantly heavier with arithmetic operations than an ising update which , however , from the point - of - view of gpu computing is a rather favorable situation since this reduces the probability of memory bandwidth limitations .",
    "( note , however , that heisenberg updates also require larger memory transfers since each spin variable requires three floating - point numbers . )    llt2t0 & & & + cpu ( intel q9650 ) & float or double & 183.16 & 1 + & float & 0.74 & 247 + tesla c1060 & float , fast_math & 0.30 & 608 + & double & 4.66 & 39 + & float & 0.50 & 366 + gtx 480 & float , fast_math & 0.18 & 1029 + & double & 1.94 & 94 +    figure [ fig : heisen ] compares the resulting spin - flip times for various gpu and cpu implementations and a system size of @xmath27 spins .",
    "the cpu implementation has exactly the same performance for single and double precision implementations , which is plausible since most arithmetic units in current cpus are double precision anyway .",
    "for single - precision calculations , the use of the intrinsic , fast implementations of the special functions results in a factor of 2.5 speedup of the entire code , while the use of double variables for representing spins results in an about sixfold slow - down for the tesla c1060 and a fourfold slow - down for the fermi card .",
    "overall speed - up factors are rather impressive , ranging from 39 for the double - precision version on the tesla c1060 and 1029 for the single - precision code with fast special functions on the fermi board , cf .  the data collected in tab .  [ tab : heisen ] .",
    "it should be noted , of course , that reduced - precision implementations of special functions are , in principle , also possible on cpu architectures , such that the extra speed - up gained by the use of these functions is not specific to using gpus .        to see whether numerical stability and finite precision are relevant for the calculations considered here , deviations from the required normalization @xmath162",
    "have been monitored for the different implementations . as can be seen from the results presented in fig .",
    "[ fig : stability_heisen ] , a drift of normalization is not an issue here . as expected , deviations of @xmath163 from unity are of the order of @xmath164 for single - precision implementations uniformly for cpu as well as gpu implementations .",
    "maybe surprisingly , deviations are even somewhat smaller for the gpu codes than for the cpu implementation .",
    "using the fast intrinsic implementations of special functions , on the other hand , reduces the accuracy by about one digit , such that deviation are of the order of @xmath165 there .",
    "estimates of the magnetization , internal energy and specific heat extracted from the simulation runs also have been compared between the different implementations and , at the given level of statistical accuracy , no significant deviations have been observed .",
    "( note that reductions in the measurement cycles have been implemented in double precision . )",
    "it appears justified , therefore , to claim that for spin model simulations a representation of the spin variables in single precision , while still doing measurements in double precision , does not introduce systematic deviations of relevance as compared to statistical fluctuations .",
    "the same seems to be valid even when using the fast intrinsic , reduced accuracy implementations of the special functions . in view of the dramatic speed - ups observed in particular for the `` float , fast_math '' implementation , cf.tab .",
    "[ tab : heisen ] , this appears encouraging .",
    "computationally particularly demanding problems in the field of spin systems occur for models with quenched disorder @xcite .",
    "the nature of fluctuations between disorder realizations typically requires averages over at least several thousand disorder configurations to enable reliable results . for the case of spin glasses , where disorder is accompanied by the presence of competing interactions , each disorder configuration exhibits extremely slow dynamics close to or below the spin - glass transition . since no effective",
    "cluster algorithms are available for spin glasses ( with the exception of systems in two dimensions @xcite ) , simulations are restricted to single - spin updates , and the combined effect of disorder average and slow relaxation results in rather excessive computational requirements .",
    "it is not surprising , therefore , that a number of special - purpose computers have been constructed for such problems , the most recent being the janus machine based on fpgas @xcite .",
    "independent disorder realizations of a @xmath112 ising spin glass system on the gt200 and fermi architectures as compared to the cpu implementation . ]    the trivial parallelism inherent in the disorder average and the necessary restriction to local spin updates appears to render spin - glass problems ideal candidates to profit from the massively parallel architecture of gpus . to see to which degree such hopes are borne out in real implementations , i studied the short - range edwards - anderson ising spin glass model with hamiltonian @xmath166 where the exchange couplings @xmath167 are quenched random variables , here drawn from a symmetric bimodal distribution @xmath168 .",
    "compared to the ferromagnetic ising model , the disordered version requires the values of the couplings @xmath167 to be taken into account when calculating the energy change of a spin flip such that an additional data structure for the couplings becomes necessary . for the tiled algorithm described in sec .",
    "[ sec : checker ] above , the values of @xmath167 inside of each tile need to be loaded into shared memory in addition to the spin field .",
    "furthermore , a number @xmath169 of completely independent instances of the spin system with different coupling values can be simulated in parallel .",
    "these different instances are mapped to different thread blocks in the gpu architecture .",
    "apart from these changes , the algorithm is identical to the implementation described for the ferromagnetic model .     or @xmath170 bit variables as a function of the number of disorder realizations .",
    "simulations are for a @xmath171 system , comparing cpu and gpu codes on various devices . ]",
    "the spin - flip times resulting from this implementation are displayed in fig .",
    "[ fig : spinglass ] as a function of the number @xmath169 of disorder realizations simulated simultaneously .",
    "the reference cpu implementation performs at around @xmath172 ns per spin flip on the intel q9650",
    "cpu used here , essentially independent of the number of realizations as those are merely worked on in sequence there .",
    "the gpu code reaches a maximum performance of @xmath173 ns on the tesla c1060 and @xmath174 ns on the fermi card , respectively , corresponding to speed - ups of @xmath175 ( c1060 ) and @xmath176 ( gtx 480 ) .",
    "these speed - ups are practically identical to the maximum speed - ups observed for the ferromagnetic model , whereas in absolute terms due to the extra calculations related to the non - uniform couplings the cpu and gpu implementations for the spin - glass model are about a factor of two slower than the ferromagnetic codes .",
    "it is well known that storing the inherently one - bit information of the orientation of an ising spin in a ( typically ) 4-byte integer variable is a wasteful operation and packing several spin variables in each machine word can result in significant performance improvements @xcite .",
    "while for the case of ferromagnetic models the only possible implementation needs to pack a number of spins from the same lattice into one word of @xmath177 bits , leading to a somewhat involved sequence of bit - wise operations becoming necessary in order to perform the metropolis updates of the coded spin in parallel @xcite ( `` synchronous '' multi - spin coding @xcite ) , the situation in the presence of quenched disorder implies that one can also code @xmath177 spins in the same spatial location of _ independent _ ising lattices corresponding to different disorder configurations in one word ( `` asynchronous '' multi - spin coding @xcite ) .",
    "this setup allows for very efficient implementations using only a few bit - wise operations . depending on the type of integers used",
    ", currently @xmath178 or @xmath170 spins can be represented in one variable . in parallel , 32 or 64 values of bimodal couplings of different realizations",
    "are stored in another field of integers .",
    "the resulting performance characteristics are shown in fig .",
    "[ fig : spinglassmsc ] .",
    "the cpu code performs at @xmath179 ns per spin flip for @xmath178 and a significantly better @xmath180 ns for @xmath170 , corresponding to a speedup of @xmath181 and @xmath182 as compared to the single - spin coded cpu version for @xmath178 and @xmath170 , respectively or @xmath170 spins , which appears justified in view of the statistical independence of the coupling realizations .",
    "this setup was previously tested for the ising spin glass in three dimensions and no significant correlation effects were observed @xcite . ] .",
    "the gpu implementation performs at around @xmath183 ps for 32-bit and @xmath184 ps for 64-bit on the tesla c1060 card . the rather disappointing result for",
    "the @xmath170 version shows that the gt200 architecture is not optimized for @xmath39-bit operations . on the gtx 480 fermi card , on the other hand , the @xmath39-bit multi - spin coded implementation runs as fast as @xmath131 ps per spin flip as compared to @xmath185 ps for the @xmath43-bit version .",
    "the resulting optimal speed - ups compared to the cpu code are hence around @xmath70 for the tesla c1060 and around @xmath186 for the gtx 480 . for the fermi card ,",
    "the resulting code runs around @xmath187 times faster than the ( synchronous ) multi - spin coded simulation of the ferromagnetic model discussed in ref .",
    "it is worthwhile to note that janus performs at around @xmath1 ps per spin flip on the 3d ising spin glass @xcite .",
    "circumstances forbid a clear - cut comparison here , however , since the janus code uses synchronous multi - spin coding and a somewhat better random - number generator .",
    "still , it appears fair to say that an appropriate gpu implementation seems to play in the same league as the special - purpose computer janus at a much smaller investment in capital and human resources .",
    "a rather powerful technique for the simulation of systems with complex free energy landscapes , including spin glasses and bio - polymers , is given by the parallel tempering or replica exchange algorithm @xcite .",
    "there , a number of identical copies of a system are simulated at a set of different , closely neighboring temperatures .",
    "in addition to any chosen intra - replica update , such as the single spin flips according to the metropolis criterion , at fixed intervals an interchange of configurations ( typically ) simulated at neighboring temperatures is attempted and accepted with the generalized metropolis probability @xmath188,\\ ] ] where @xmath189 and @xmath190 . with a properly chosen set of temperatures @xcite , this additional update allows for configurations with slow dynamics at low temperatures to successively diffuse to high temperatures , decorrelate there and finally return back to the low - temperature phase , likely arriving in a different valley of a complex free - energy landscape than where it started from .",
    "$ ] with @xmath191 replicas with one exchange attempt per 100 sweeps of spin flips . ]    through its inherent parallelism of intra - replica updates , this scheme appears to be well suited for the massively parallel architecture of current gpus .",
    "it is tested here in a reference implementation for the ferromagnetic ising model along the lines of the previously discussed single spin - flip code .",
    "the additional copies of the system are mapped to additional thread blocks running in parallel .",
    "since the configurational energy is calculated online from the energy changes of single spin flips via a binary - tree reduction algorithm on tiles , it is automatically available after lattice sweeps and hence its determination does not incur any extra overhead . in the current implementation , replica exchange steps are performed on cpu since the computational effort is low and synchronization between thread blocks is required . as usual , instead of exchanging configurations between replicas only the corresponding temperatures are swapped .",
    "the boltzmann factors according to ( [ eq : metropolis ] ) can still be tabulated , and are now implemented on gpu as fetches from a two - dimensional texture .",
    "a successful replica exchange then requires an update of the texture which is easily possible in the current setup as the exchange moves are carried out on cpu .",
    "the benchmark results of the parallel tempering simulation of the 2d ising model on gpu and cpu is shown in fig .",
    "[ fig : parallel ] .",
    "i chose to use @xmath191 replicas at equally spaced inverse temperatures in the interval @xmath192 $ ] . in a real - world application",
    "one would probably want to use a more elaborate scheme for choosing these temperatures @xcite , but these questions do not have any bearing on the benchmark calculations performed here .",
    "as is clearly visible , the presence of additional copies of the system leads to a much better resource utilization for smaller system sizes than that observed for the single - spin flip simulations .",
    "hence , significant speed - ups are observed already for small systems .",
    "the cpu code performs at a constant @xmath193 ns per combined spin - flip and replica exchange move ( mixed at a ratio of one exchange move per one hundred lattice sweeps ) .",
    "the gpu code arrives at a maximum of around @xmath194 ns for the tesla c1060 and @xmath195 ns for the gtx 480 at @xmath196 .",
    "the speed - up reaches up to @xmath197 ( c1060 ) resp .",
    "@xmath198 ( gtx 480 ) at @xmath196 , but is already @xmath199 ( c1060 ) resp.@xmath200 ( gtx 480 ) for the @xmath118 system . as for disordered systems due to the severe slowing down usually only rather small systems can be studied , good performance of the code is crucial in this regime . increasing the number of exchange moves to one in ten lattice sweeps reduces the maximum performance of the gpu implementation somewhat to @xmath201 ns ( c1060 ) and @xmath202 ns ( gtx 480 ) , respectively .",
    "current gpus have a significant potential for speeding up scientific calculations as compared to the more traditional cpu architecture . in particular",
    ", this applies to the simulation of systems with local interactions and local updates , where the massive parallelism inherent to the gpu design can work efficiently thanks to appropriate domain decompositions .",
    "the simulation of lattice spin systems appears to be a paradigmatic example of this class as the decomposition remains static and thus no significant communication overhead is incurred .",
    "observing substantial speed - ups by factors often exceeding two orders of magnitude as for the case studies reported here requires a careful tailoring of implementations to the peculiarities of the considered architecture , however , in particular paying attention to the hierarchic organization of memories ( including more exotic ones such as texture memory ) , the avoidance of branch divergence and the choice of thread and block numbers commensurate with the capabilities of the cards employed . for achieving good performance ,",
    "it is crucial to understand how these devices hide the significant latency of accessing those memories that do not reside on die through the interleaved scheduling of a number of execution threads significantly exceeding the number of available computing cores .",
    "it is encouraging that employing such devices with the rather moderate coding effort mediated by high - level language extensions such as nvidia cuda or opencl updating times in the same ballpark as those of special purpose machines such as janus @xcite with a vastly higher development effort can be reached .",
    "a regularly uttered objection against the systematic use of gpus for scientific computing criticizes them as being a possibly too special and exotic architecture with unknown future availability and architectural stability as compared to the traditional and extremely versatile x86 cpu design .",
    "while there is certainly some truth to this argument , there can be no doubt about the fact that massive parallelism is not only the present state of the gpu architecture , but also the future of cpu based computing . as of this writing , intel cpus feature up to eight cores and amd chips up to twelve cores per die , the corresponding road - maps projecting even significantly more cores in the foreseeable future .",
    "supercomputers will soon count their number of cores in the millions . due to this",
    "development , serial computing will not remain a viable option for serious computational science much longer .",
    "much effort will need to be invested in the years to come into solving scientific problems employing a _ massive _ number of parallel computational units . in this respect , gpu computing ,",
    "apart from currently being more efficient for many problems in terms of flop / s per watt and per euro than cpu based solutions , is rather less exotic than pioneering .",
    "an ideal application for gpu computing in the field of the simulation of spin systems appear to be disordered systems , where cluster algorithms are in general not efficient and a natural parallelism occurs from the quenched average over disorder , possibly combined with the parallel tempering algorithm . using asynchronous multi - spin coding for the ising spin glass , spin flip times down to @xmath73 ps can be achieved .",
    "systems with continuous spins are particularly well suited for gpu deployment , since one finds a relatively stronger overhead of arithmetic operations over memory fetches as compared to systems with discrete spins there . for the heisenberg model , speed - ups up to a factor of @xmath0 can be obtained when making use of the highly optimized special function implementations in single precision .",
    "while these examples of single - spin flip simulations look rather promising , it is clear that other well - established simulation algorithms for spin systems are less well suited for the parallelism of gpus , including the cluster algorithms in the vicinity of critical points , where spin clusters spanning the whole system need to be identified , or multi - canonical and wang - landau simulations , which require access to the current values of a global reaction coordinate ( such as , e.g. , the energy or magnetization ) for each single spin flip , thus effectively serializing all spin updates .",
    "it is a challenge for future research to find implementations or modifications of such algorithms suitable for massively parallel computers @xcite .",
    "i am indebted to t.  yavorskii for a careful reading of the manuscript . support by the dfg through the emmy noether programme under contract no .  we4425/1 - 1 and by the schwerpunkt fr rechnergesttzte forschungsmethoden in den naturwissenschaften ( srfn mainz ) is gratefully acknowledged .",
    "52 natexlab#1#1[2]#2 , , , , , , ( ) . , , , ( ) .",
    ", , , ( ) . , , , ( ) .",
    ", , , ( ) . , , , , ( ) .",
    ", , , , , , , , , , , , , , , , , , , , , ( ) . , , , , , , , , , , , , , , , , , , , , , , , , , ( ) . , , , , , , ( ) . , , , , , , ( ) . , , , , , ( ) . , , , , ( ) . , . ,",
    ", , , ( ) . , , ( ) . , , , ( ) .",
    "( ed . ) , , , , .",
    ", , , , ( ) . , , , , ( ) . , , , , ( ) .",
    ", , , ( ) . , , , , , , , , in : , , , , ( eds . ) , , volume of _ _ , , , , pp . . , , , , , , , ( ) . , , , , , . , , , , . , , , ( ) . , , , , ( ) . , , , ( ) . , , , , , , , edition , . , , , , edition , .",
    ", , , , edition , .",
    ", , , ( ) . , , in : , , pp . .",
    ", , , ( ) . , , , , .",
    ", , in : ( ed . ) , , , , , p. .",
    ", , , ( ) . , , ( ) . .",
    ", , , , ( ) . , , , , ( ) .",
    ", , in : , , , , p. .",
    ", , , , , ( ) .",
    ", , , , ( ) . , , , ( ) ."
  ],
  "abstract_text": [
    "<S> graphics processing units ( gpus ) are recently being used to an increasing degree for general computational purposes . </S>",
    "<S> this development is motivated by their theoretical peak performance , which significantly exceeds that of broadly available cpus . for practical purposes , however , it is far from clear how much of this theoretical performance can be realized in actual scientific applications . </S>",
    "<S> as is discussed here for the case of studying classical spin models of statistical mechanics by monte carlo simulations , only an explicit tailoring of the involved algorithms to the specific architecture under consideration allows to harvest the computational power of gpu systems . </S>",
    "<S> a number of examples , ranging from metropolis simulations of ferromagnetic ising models , over continuous heisenberg and disordered spin - glass systems to parallel - tempering simulations are discussed . </S>",
    "<S> significant speed - ups by factors of up to @xmath0 compared to serial cpu code as well as previous gpu implementations are observed .    </S>",
    "<S> monte carlo simulations , graphics processing units , ising model , heisenberg model , spin glasses , parallel tempering </S>"
  ]
}