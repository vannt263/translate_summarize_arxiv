{
  "article_text": [
    "new networking technologies such as network virtualization  @xcite , policy - based routing  @xcite , per - flow routing  @xcite , and service chaining  @xcite are leading to an explosion of state maintained at switches in the network core .",
    "current efforts to control this state rely on restricting the per - flow state to the network edges and using tunnels in the network core , which only maintains the traditional per - destination forwarding state .",
    "while solving the state problem , this approach results in suboptimal routing , because multiple flows , each with potentially different delay , jitter , and bandwidth requirements , are aggregated into a single tunnel .    one way of extending per - flow state from the network edge to the core is for the header of each packet to contain an encoding of the packet s required path .",
    "one such approach , termed source routing , encodes the path as a sequence of identifiers ( such as the ip addresses ) of the intermediate hops along the path  @xcite .",
    "this approach results in large packet headers and still requires each switch along the path to perform a table lookup to translate the identifier to an interface ( i.e. , an output port ) from a table that grows as the size of the network grows .        to reduce the size of state , i.e. , the size of the lookup table at each core switch",
    ", one can instead encode the path as a sequence of interface identifiers  @xcite .",
    "for instance , if a switch has @xmath2 interfaces , then each of them could be assigned a distinct label of length @xmath3 and a path encoding is a sequence of such labels .",
    "we refer to this approach as path switching .    for example , consider the scenario depicted in fig .",
    "[ fig : overview ] , in which an incoming packet to the network from endpoint @xmath4 to endpoint @xmath5 has its destination encoded at the ingress switch @xmath6 as @xmath7 .",
    "this encoded path represents a sequence of labels , each uniquely identifying a switch interface on the path between the source and the destination . in our example",
    ", the first switch @xmath6 forwards the packet through its interface @xmath8 to switch @xmath9 ; @xmath9 forwards the packet through its interface @xmath10 to switch @xmath11 ; @xmath11 forwards the packet through its interface @xmath8 to switch @xmath12 ; and so on .",
    "encoding a packet s path in this manner eliminates expensive lookup tables at the switches in the network core , since each switch can identify the next hop from the interface label within the encoded path .",
    "thus , path encoding enables arbitrary routing without the need to maintain per - path or per - flow lookup tables in the core switches .",
    "in particular , paths through the network can be arbitrarily complicated , making this approach ideally suited for service chaining and sophisticated traffic engineering with per - flow granularity .",
    "with such an encoding , the size of a switch s lookup table to translate a label to an interface depends only on the number of interfaces at that switch and therefore remains constant despite network growth .    in this paper",
    ", we propose a path encoding that , rather than constraining the interface labels at a given switch to have the same length , allows the interface labels at the same switch to have variable lengths .",
    "the flexibility of variable - length interface encoding advocated in this paper has the advantage of resulting in shorter encoded paths .",
    "in particular , our contribution is a method for path encoding that minimizes the maximum length of any encoded path in the network .",
    "minimizing this performance measure is appropriate when each encoded path is to be placed inside existing source / destination address header fields . as with any reasonable encoding using a sequence of interface labels ,",
    "the proposed encoding allows the state kept at each switch to remain of constant size independent of the growth of the network in terms of topology as well as in terms of the number of distinct flows .",
    "finally , the proposed method allows each switch along a path to easily and unambiguously determine the correct outgoing interface .",
    "we begin by introducing a mathematical formulation of the problem of computing interface labels that minimize the longest encoded path for a given set of paths .",
    "we call this the _ optimal path - encoding problem_. we prove that this problem is apx - hard , by showing that it is np - hard to approximate to within any factor better than @xmath0 of optimal .",
    "we next describe a @xmath1-approximation algorithm for the optimal path - encoding problem .",
    "finally , we apply the proposed algorithm to several real - world networks ( the at&t mpls backbone network  @xcite and 11 networks from the rocketfuel topology set  @xcite ) . the proposed variable - length encoding results in a reduction of up to @xmath13 in the maximum encoded path length .",
    "the remainder of this paper is organized as follows .",
    "section  [ sec : formulation ] introduces the optimal path - encoding problem .",
    "algorithmic solutions to this problem are presented in sections  [ sec : main ] and  [ sec : proofs ] .",
    "finally , section  [ sec : conclusion ] contains concluding remarks .",
    "we start with a more detailed description of the network architecture in section  [ sec : architecture ] .",
    "a key component of this architecture is the optimal encoding of paths described in section  [ sec : problem ] .",
    "we introduce a mathematical formulation of this problem in section  [ sec : math ] .",
    "consider the conceptual model of a network shown in fig .",
    "[ fig : overview ] .",
    "endpoints are connected to the network via an edge switch .",
    "the network is assumed to be software - defined networking ( sdn ) enabled , i.e. , there is a centralized sdn controller that configures each switch in the network .",
    "the sdn controller installs an interface - label table in each switch , assigning to each ( outgoing ) switch interface a unique binary string called the interface label .",
    "in addition , the sdn controller installs a flow - table in each edge switch , assigning to each incoming flow an encoded path .",
    "each such encoded path is a binary string , consisting of the concatenation of the interface labels in the path .",
    "edge switches use the flow - table entries to modify the packet headers of incoming and outgoing flows .",
    "how this mapping between flows and encoded paths is performed depends on the nature of the packet endpoints .",
    "if the network ingress and egress interfaces in the path uniquely identify the packet endpoints , then the encoded path replaces the source and destination fields .",
    "otherwise , the encoded path is placed in a tunnel header , leaving the existing packet header unchanged .    to facilitate the forwarding operations inside the network",
    ", the path label also contains a pointer field indicating the current position in the encoded path . in order to forward a packet",
    ", the switch reads its path label starting from the position of the pointer .",
    "it then searches its interface - label table for the unique interface that could result in this encoded path ( starting from the current position ) .",
    "it increments the pointer by the length of the label , and forwards the packet over the corresponding interface .    from the above description",
    ", we see that a key component of this architecture is the assignment by the sdn controller of binary labels to switch interfaces .",
    "this assignment needs to be such that switches are able to make correct forwarding decisions . at the same time",
    ", the resulting encoded paths can not be too large so that they can fit inside existing packet source / destination address fields , thereby leaving packet formats invariant .",
    "we next describe this path - encoding problem in detail .",
    "as mentioned above , the goal of path encoding is the assignment of labels to switch interfaces such that the following two objectives are satisfied .",
    "first , to ensure that packets can be properly routed , the encoded paths need to be uniquely decodable .",
    "second , because the encoding is appended to every packet sent through the network , usually in a header of fixed size , the longest encoded path needs to be small .",
    "to all the edge switches @xmath14.,title=\"fig : \" ]   to all the edge switches @xmath14.,title=\"fig : \" ]    one way to solve the path - encoding problem is to assign fixed - length labels to each switch interface .",
    "more precisely , for a switch with @xmath2 interfaces , we can assign a binary label of size @xmath3 bits to each of its interfaces . as an example of this fixed - length labeling ,",
    "consider the network and label assignment depicted on the left side of fig .",
    "[ fig : encoding1 ] . in this example",
    ", we consider all possible paths from switch @xmath15 to any of the edge switches @xmath16 .",
    "the longest encoded path is @xmath17 with encoding @xmath18 of length @xmath19 .",
    "observe that , for ease of presentation , we do not explicitly distinguish between switches and endpoints in this example and in the following .    in this work",
    ", we instead advocate the use of variable - length interface labeling , in which labels for interfaces of the same switch may have different lengths . as an example of this variable - length labeling ,",
    "consider the same network as before , but with the label assignment depicted on the right side of fig .",
    "[ fig : encoding1 ] . assuming the same set of paths as before ,",
    "one longest encoded path is again @xmath20 , but this time , its encoding @xmath21 has only length @xmath8 .",
    "thus , we see that in this example the use of variable - length labels has reduced the longest encoded path from @xmath19 to @xmath8 bits .",
    "to all the edge switches @xmath22.,title=\"fig : \" ]   to all the edge switches @xmath22.,title=\"fig : \" ]    variable - length interface labels have to be used with some care to ensure that the encoded paths are properly decodable .",
    "two problems can occur .",
    "first , the encoded paths may not be unique , i.e. , two different paths with same starting switch may be mapped into the same encoding , thereby preventing proper routing of packets .",
    "as an example , consider the network and label assignment depicted on the left side of fig .",
    "[ fig : encoding2 ] . in this example",
    ", we consider all possible paths from switch @xmath15 to any of the edge switches @xmath11 through @xmath23 .",
    "consider the path encoding @xmath24 at switch @xmath15 .",
    "this encoding could result from either path @xmath25 or path @xmath26 .",
    "the switch @xmath15 has therefore no way of deciding whether to forward a packet with encoded path @xmath24 to switch @xmath6 or switch @xmath12 .",
    "a second problem is that the encoded paths may not be locally decodable .",
    "this occurs when a switch requires global information about the entire network in order to make the correct local forwarding decision .",
    "as an example , consider the same network as before , but with the label assignment depicted on the right side of fig .",
    "[ fig : encoding2 ] . assuming the same set of paths between @xmath15 and all possible edge switches as before",
    ", this assignment leads to unique encoded paths .",
    "however , the encoded paths are not locally decodable .",
    "consider for example the path encoding @xmath24 at switch @xmath15 .",
    "given that @xmath27 is not a valid path , this encoded path is uniquely decodable to path @xmath28 .",
    "therefore , switch @xmath15 needs to forward a packet with path @xmath24 to switch @xmath6 .",
    "however , to make this forwarding decision , @xmath15 needs to be aware of the collection of all possible paths in the network .",
    "local decodability may also be compromised if a switch needs to know the label assignment at other switches in the network .",
    "both of these problems can be avoided if we impose the additional constraint that , at every switch , the collection of labels assigned to the interfaces of this switch form a _ prefix - free set _ , meaning that no label is a prefix of any other label .",
    "if this prefix - free condition is satisfied , then each switch can make its forwarding decision using only local information by finding the unique of its interface labels that forms a prefix of the encoded path .",
    "observe that neither of the two label assignments in fig .",
    "[ fig : encoding2 ] are prefix free ( since @xmath29 is a prefix of @xmath24 at switch @xmath15 ) . on the other hand , both the label assignment in fig .",
    "[ fig : encoding1 ] are prefix free .",
    "we are now ready to introduce a mathematical description of the optimal path - encoding problem .",
    "we are given a directed graph @xmath30 describing the network and a set of paths @xmath31 in @xmath32 .",
    "we are tasked with assigning binary labels @xmath33 , i.e. , a binary string of arbitrary finite length , to each arc @xmath34 .",
    "denote by @xmath35 the length of the label string @xmath36 .",
    "for a path @xmath37 , the size of the path encoding resulting from this assignment of labels is @xmath38 where the summation is over all arcs @xmath39 in the path @xmath40 .    in order to minimize the field size needed to store the path encoding ,",
    "our goal is to minimize the length of the labels for the longest ( with respect to @xmath41 ) encoded path in @xmath31 . as discussed above , we ensure that messages are correctly routable through the network by imposing that the set of labels @xmath42 corresponding to arcs @xmath39 out of any vertex @xmath43 forms a prefix - free set , meaning that no label @xmath36 is a prefix of another label @xmath44 in the same set .",
    "clearly , this prefix condition implies that the encodings of ( partial ) paths with same starting vertex are unique .",
    "moreover , it allows each vertex @xmath45 to make routing decisions based on only its local set of labels @xmath42 .",
    "consider a vertex @xmath45 and its outgoing arcs @xmath46 , and consider a set of label lengths @xmath47 .",
    "a necessary and sufficient condition for the existence of a corresponding prefix - free set of labels @xmath42 with these lengths is that they satisfy",
    "_ kraft s inequality _",
    "@xmath48 see , e.g. , ( * ? ? ?",
    "* theorem  5.2.1 ) .",
    "moreover , for a collection of label lengths satisfying kraft s inequality , the corresponding set of labels can be found efficiently as follows .",
    "let @xmath49 be the largest label length in the set .",
    "construct a perfect binary tree of depth @xmath49 , with each vertex in the tree representing a binary sequence of length up to @xmath49 .",
    "next , find the arc @xmath39 with shortest label length @xmath41 .",
    "assign this arc to the ( lexicographically ) first available vertex of length @xmath41 in the binary tree , and remove all its descendants from the tree .",
    "continue this procedure with the second shortest label length until all labels are chosen .",
    "the vertices of the tree chosen by this procedure correspond to a set of prefix - free labels with the specified label lengths . with this",
    ", we can focus our attention in the following on finding the label lengths .    with this necessary and sufficient condition on the label lengths",
    ", we can now write the optimal path - encoding problem in the following compact form . @xmath50",
    "observe that the constraint @xmath51 guarantees that the optimal values of @xmath52 are nonnegative .",
    "further , since all @xmath41 are integers , the optimal value of @xmath53 is also guaranteed to be an integer .",
    "the remainder of this paper focuses on this minimization problem .",
    "[ rem : static ] our assumption throughout this paper is that the path set @xmath54 is static .",
    "in contrast , assume now that after the label assignment is completed and the corresponding label tables installed in the switches a new path @xmath55 needs to be added .",
    "even though the label assignments were not optimized for @xmath40 , this new path can nonetheless be encoded using the current labels . moreover , since the labels form a prefix free set at each switch , the resulting encoded path is uniquely routable through the network .",
    "thus , enforcing the prefix - free condition has the additional advantage that new paths can always be added without having to change the label assignment . in other words",
    ", the network will continue to operate correctly with dynamically changing path set @xmath54 .",
    "however , since the new path @xmath40 was not part of the optimization problem yielding the label assignment , its encoded length may be larger than @xmath53 .    to alleviate the problem of newly added paths having encoded length larger then @xmath53 as mentioned in remark  [ rem : static ] , the set @xmath54 should not only contain those paths that are currently active , but also any anticipated future paths .",
    "such anticipated future paths may for example be designed to handle congestion and node failures .",
    "recall that once label lengths satisfying kraft s inequality have been fixed , finding the actual labels with those lengths is straightforward using the algorithm described above .",
    "hence , the difficult part of the optimal path - encoding problem is the assignment of label lengths . in the remainder of the paper",
    ", we will therefore focus on this subproblem of assigning label lengths with the understanding that the actual label assignment is then straightforward .",
    "ideally , we would like to solve the optimal path - encoding problem   exactly . for special cases , such as out - arborescences",
    "( i.e. , directed trees in which the root has in - degree zero and every other vertex has in - degree at most one ) , this is possible using dynamic programming , as is illustrated in the next example .",
    "[ eg : tree ]     for example  [ eg : tree ] .",
    "the figure shows next to each arc @xmath39 the length @xmath41 of the binary label @xmath36 associated with that arc . ]",
    "consider the graph @xmath32 shown in fig .",
    "[ fig : tree ] .",
    "the graph is an out - arborescence with three internal vertices labeled @xmath56 as shown in the figure .",
    "the set @xmath31 consists of all paths from the root vertex @xmath57 to the leaves .",
    "this is the abstract version of the network depicted in fig .",
    "[ fig : encoding1 ] in section  [ sec : problem ] .    for out - arborescences ,",
    "the optimal path - encoding problem can be solved exactly using dynamic programming .",
    "consider the vertex @xmath58 .",
    "there are two possible paths through @xmath58 , one for each of its two children .",
    "since these two paths have the same arcs from the root to @xmath58 , their label lengths are the same except for the last arc .",
    "since we are trying to minimize the maximum encoded path length , the optimal allocation of label lengths for these two arcs is @xmath10 for both of them .",
    "this in effect `` equalizes '' the two path lengths .    consider next vertex @xmath59 .",
    "we again aim to equalize the paths through @xmath59 .",
    "there are four such paths , one for each leaf that is a descendant of @xmath59 . in order to equalize them",
    ", we should allocate a shorter length to the arc @xmath60 than the other two outgoing arcs .",
    "the optimal allocation is @xmath10 for the arc @xmath60 and @xmath1 for the other two arcs . with this assignment ,",
    "all four paths through @xmath59 have path length of @xmath1 from @xmath59 onward .",
    "note that this assignment satisfies kraft s inequality .    finally , consider the vertex @xmath57 .",
    "we would again like to equalize paths .",
    "however , due to the integrality constraint , the best we can do here is to assign a label length of @xmath10 to the arc @xmath61 and @xmath1 , @xmath8 , and @xmath8 to the other three outgoing arcs . with this , the maximizing path is along the topmost branch of the tree with length @xmath62 .. an optimal label - length assignment is then @xmath63 , which satisfies kraft s inequality and equalizes the partial paths to length @xmath64 . ]",
    "the example illustrates the performance improvement due to allocating shorter label lengths to arcs on long paths .",
    "in particular , if we were to assign labels of uniform length to each outgoing arc of a vertex , the topmost branch of the tree path would have encoded length @xmath65 .",
    "this example also shows that the label assignment on the right in fig .",
    "[ fig : encoding1 ] is optimal .",
    "while the optimal path - encoding problem can be solved exactly for special cases as seen above , this is unfortunately not the case for general graphs @xmath32 as the following theorem shows .",
    "[ thm : hardness ] approximating the optimal path - encoding problem   by a factor less than @xmath0 is np - hard .",
    "thus , the optimal path - encoding problem is apx - hard .",
    "the proof of theorem  [ thm : hardness ] is reported in section  [ sec : proofs_hardness ] .",
    "the theorem shows that at most we should hope for an efficient constant - factor approximation algorithm for the optimal path - encoding problem .",
    "we next describe such an algorithm with an approximation guarantee of a factor @xmath1 .",
    "consider the relaxed version @xmath66 of the integer minimization problem  .",
    "the function @xmath67 is convex in @xmath52 , and hence this relaxed problem is a convex minimization problem .",
    "in fact , by rewriting kraft s inequality as @xmath68 we see that is a _ geometric program _",
    "* section  4.5 ) .",
    "such problems can be solved efficiently by interior - point methods  ( * ? ? ?",
    "* chapter  11 ) .",
    "let @xmath69 be the minimizer of the relaxed problem .",
    "construct an integer solution @xmath70 and set @xmath71 note that @xmath72 is a valid solution of the integer path - encoding problem  .",
    "moreover , the next theorem asserts that the value @xmath73 of this solution is within a factor @xmath1 of the optimal value @xmath74 of the path - encoding problem  .",
    "[ thm : approximation ] let @xmath73 be the value of the rounded solution and let @xmath74 be the value of the minimizer of the optimal path - encoding problem . then @xmath75    the proof of theorem  [ thm : approximation ] is reported in section  [ sec : proofs_approximation ] .",
    "we illustrate this approximation algorithm with a toy example .",
    "[ eg : integrality ]     for example  [ eg : integrality ] with @xmath76 . ]",
    "consider the graph @xmath32 shown in fig .",
    "[ fig : integrality ] .",
    "the graph is an out - arborescence consisting of @xmath77 vertices .",
    "consider the @xmath78 internal vertices @xmath79 forming the `` spine '' of the graph .",
    "denote the label lengths of the arcs in this spine by @xmath80 as shown in fig .",
    "[ fig : integrality ] .",
    "the set @xmath31 is given by all the paths from the root to the leaves .",
    "the optimal solution for the path - encoding problem is trivial in this case : simply assign a value of @xmath10 to each arc .",
    "the resulting value of @xmath74 is @xmath78 .",
    "let us next evaluate the relaxed problem  . consider an internal vertex @xmath81 and its two outgoing arcs .",
    "assume the first one has length @xmath82 .",
    "then the other outgoing arc has to have length @xmath83 in order to satisfy kraft s inequality with equality .",
    "clearly , the optimal choice of @xmath84 is @xmath10 .",
    "the optimal value of @xmath85 is given by the equation @xmath86 since this equalizes the lengths of all possible paths going through @xmath59 as discussed in example  [ eg : tree ] .",
    "using the same argument , we obtain the general recursion @xmath87 which can be solved to yield the solution @xmath88 of the relaxed problem .",
    "the resulting value of @xmath89 is @xmath90 comparing this to the value @xmath91 of the optimal path - encoding problem , we see that the integrality gap is at least @xmath92 , which is unbounded as @xmath78 increases .",
    "nevertheless , perhaps surprisingly , the rounded solution @xmath93 of the relaxed problem is in fact equal to the optimal solution of the path - encoding problem for all arcs on the spine of the graph .",
    "hence , @xmath94 in this case .",
    "thus , despite an unbounded integrality gap , the rounded solution is optimal in this case and in general yields a constant factor-@xmath1 approximation for the optimal path - encoding problem .",
    "note that @xmath95 so the rounded value @xmath96 on the arcs outside the spine of the graph is in fact considerably larger than the optimal solution of @xmath10 of the path - encoding problem .",
    "since these arcs are not on the longest path , this does not affect the value of @xmath97 .",
    "nevertheless , it does indicate that , in a practical setting , the solution found by the rounding procedure could be further improved by running a local search optimization procedure .    to obtain further intuition for the solution of the relaxed problem  , it is instructive to consider its dual given by @xmath98          \\text{s.t . } & \\displaystyle\\sum_{p\\in{\\mathcal{p } } } \\alpha_p & = 1 & \\\\          & \\alpha_p & \\geq 0 , & \\forall p\\in{{\\mathcal{p}}}.      \\end{array}\\ ] ] here , for arc @xmath99 , @xmath100 denotes the vertex @xmath45 .",
    "moreover , we have used the shorthand notation @xmath101 with the nonstandard convention that a vertex @xmath45 is in the path @xmath40 if any of its _ outgoing _ arcs are in @xmath40 .",
    "it is easily seen that the relaxed primal problem   has a strictly feasible solution , which implies that strong duality holds ( * ? ? ?",
    "* section  5.2.3 ) , i.e. , the two convex programs and have the same value .",
    "the derivation of the dual   is somewhat lengthy and can be found in section  [ sec : proofs_dual ] .",
    "let @xmath102 be a solution to the dual  .",
    "define now a random variable @xmath103 taking values in @xmath104 with @xmath105 for any @xmath34 , where @xmath106 denotes the number of arcs in the path @xmath40 . furthermore , define the random variable @xmath107 observe that @xmath108 takes values in @xmath109 with @xmath110 for any @xmath43 .",
    "finally , let @xmath111 be an independent random variable taking values in @xmath31 with @xmath112 for any @xmath37 .    with these definitions in place",
    ", we can rewrite the dual problem   as @xmath113 where we have made the dependence of the random variables on @xmath114 explicit . here",
    ", @xmath115 denotes the _ conditional entropy _ of @xmath103 given @xmath108 , @xmath116 the derivation of this entropy form of the dual problem is reported in section  [ sec : proofs_entropy ] .",
    "this reformulation of the dual has an intuitive , informal , information - theoretic interpretation .",
    "the quantity @xmath117 is approximately ( up to an additive gap of @xmath10 ) the expected length of the optimal binary prefix - free source code for the random variable with distribution @xmath118 ( * ? ? ?",
    "* theorem  5.4.1 ) .",
    "this distribution describes the probability that , at vertex @xmath45 , a path takes arc @xmath119 under distribution @xmath102 on the paths in @xmath31 .",
    "averaged over all @xmath45 , the quantity @xmath115 is then the average expected label length . since the average path contains @xmath120 arcs , the product @xmath121 can be informally understood as a proxy for the expected size of the path encoding under this path distribution .",
    "the dual is this quantity for the worst - case distribution @xmath102 over the paths @xmath31 .",
    "we can also use the dual to derive a simpler projected gradient - ascent algorithm  @xcite for the path - encoding problem . recall",
    "that strong duality holds , i.e. , that the two problems and have the same value .",
    "moreover , the derivation in section  [ sec : proofs_dual ] shows that the optimal primal solution @xmath122 can easily be derived from the optimal dual solution @xmath123 as    [ eq : primal_sol ] @xmath124    the partial derivative of the dual objective function in with respect to @xmath125 is proportional to @xmath126 this yields the following projected gradient - ascent algorithm . start with an initial solution @xmath127 & { \\mathrel{\\triangleq}}{{\\lvert{{{\\mathcal{p}}}}\\rvert}}^{-1 } & \\forall p\\in{{\\mathcal{p}}}. \\\\      \\intertext{in iteration $ t+1 $ of the algorithm , set }       \\hat{\\alpha}_p[t+1 ]       & { \\mathrel{\\triangleq}}\\alpha_p[t]+\\gamma[t ] \\delta\\alpha_p[t ]      & \\forall p\\in{{\\mathcal{p } } } , \\\\      \\alpha_p[t+1 ]       & { \\mathrel{\\triangleq}}\\bigl(\\hat{\\alpha}_p[t+1]-\\eta[t+1]\\bigr)^+      & \\forall p\\in{{\\mathcal{p}}}. \\end{aligned}\\ ] ] here , @xmath128 , and @xmath129 $ ] is a positive parameter depending on @xmath130 ( but not on @xmath40 ) that can be chosen using either a line - search procedure or fixed to some small constant ( see the discussion in ( * ? ? ?",
    "* section  9.3 ) ) .",
    "the parameter @xmath131 $ ] needs to be chosen in each iteration such that @xmath132 = 1,\\ ] ] which can be performed in @xmath133 expected time as described in @xcite .",
    "as was pointed out in example  [ eg : integrality ] , the integral primal solution found by the rounding procedure can be further improved by refining it with a local search optimization procedure as follows .",
    "find a path with longest encoding .",
    "search along this path for any vertex at which kraft s inequality is not tight , and consider the arc out of this vertex along the chosen path . since kraft s inequality is not tight , we may be able to reduce the label length of this arc without violating kraft s inequality .",
    "if this is the case , reduce this label length by one .",
    "repeat these steps with different longest encoded paths until no further reductions are possible .",
    "once the label lengths are found , the actual labels themselves can then be easily derived using the algorithm described in section  [ sec : math ] .",
    "we illustrate the proposed approximation algorithm with several examples .",
    "[ eg : gamma ] we applied the proposed gradient - ascent algorithm to the simple graph shown in fig .",
    "[ fig : tree ] . with a parameter value of @xmath134",
    ", the algorithm converges in @xmath135 steps to the optimal solution of the convex dual problem , from which we then recover the optimal solution of the convex primal problem using .",
    "the rounding of the primal solution to obtain a solution for the integral version needs to be done with some care , since numerical values ( say @xmath136 , representing the value @xmath10 ) may be erroneously rounded up .",
    "[ eg : att ]        for a more realistic scenario , we consider the at&t mpls backbone network  @xcite as depicted in fig .",
    "[ fig : att ] .",
    "this is a network with @xmath137 vertices and @xmath138 arcs .",
    "there are @xmath139 paths , chosen as the shortest ( by hop distance ) path between each ordered pair of vertices .",
    "a fixed - length encoding yields a maximum encoded path length of @xmath140 bits .",
    "applying the gradient - ascent algorithm for variable - length path encoding proposed in this paper reduces this length to @xmath141 bits .",
    "thus , by optimized variable - length encoding , the encoded path length is reduced by more than @xmath13 in this setting .",
    ".comparison of maximum encoded path length under fixed - length interface labeling and variable - length interface labeling for network topologies from the rocketfuel dataset .",
    "[ cols=\"<,>,>,>,>,>\",options=\"header \" , ]     [ eg : rocketfuel ] we also consider several autonomous systems from the rocketfuel topology set  @xcite . in each case , the paths are chosen as in example  [ eg : att ] .",
    "the path lengths for both fixed and variable - length encodings are summarized in table  [ tab : rocketfuel ] . the average reduction in longest encoded path length is more than @xmath142 .",
    "in this section , we show that it is np - hard to approximate the path - encoding problem better than @xmath0 of optimal .",
    "thus , the problem is apx - hard .",
    "we use a reduction from ( 2,3)-sat , a variant of 3-sat that was analyzed in  @xcite and shown there to be np - complete .",
    "a boolean expression is in conjunctive normal form ( cnf ) if it can be expressed as the conjunction @xmath143 of clauses @xmath144 .",
    "each such clause @xmath145 is the disjunction @xmath146 of literals @xmath147 .",
    "each literal @xmath148 , in turn , is either equal to @xmath149 or its negation @xmath150 , where @xmath151 are boolean variables . in either case",
    ", we refer to @xmath152 as the index @xmath153 of the literal @xmath148 , and we say that variable @xmath149 is involved in clause @xmath145 .    an instance of ( 2,3)-sat consists of a boolean expression @xmath154 in cnf where each clause of @xmath154 has either @xmath1 or @xmath8 literals ( with both types of clauses present ) and each variable is involved in at most 3 clauses .",
    "determining if an instance of ( 2,3)-sat has a satisfying assignment is np - complete  @xcite . notice that in any cnf expression , we can assume without loss of generality that each possible literal appears in at least one clause since otherwise the variable in this literal can easily be removed from the expression .",
    "thus we can assume that in an instance of ( 2,3)-sat every literal appears in one or two clauses .    to show that the optimal path - encoding problem is apx - hard",
    ", we construct a reduction from ( 2,3)-sat .",
    "let @xmath155 be an instance of ( 2,3)-sat consisting of clauses @xmath156 over the variables @xmath157 .",
    "from @xmath155 we construct an instance @xmath53 of the optimal path - encoding problem consisting of a directed graph @xmath158 and a set of paths @xmath31 as follows .",
    "corresponding to variable @xmath149 . ]",
    "we begin by defining the graph @xmath32 . for each variable @xmath149 , @xmath159",
    ", we define the subgraphs @xmath160 of @xmath32 as depicted in fig .",
    "[ fig : variable ] .",
    "subgraph @xmath160 consists of @xmath161 vertices labeled @xmath162 with arcs @xmath163 , @xmath164 , @xmath165 , @xmath166 , @xmath167 , @xmath168 , @xmath169 .",
    "the simple but crucial observation is that at most one of the arcs @xmath163 or @xmath164 in @xmath160 can be assigned length @xmath10 if the lengths are to obey kraft s inequality at @xmath152 .    for each variable @xmath149 ,",
    "@xmath170 we further define the subgraphs @xmath171 .",
    "subgraph @xmath171 consists of @xmath19 vertices @xmath172 with arcs @xmath173 , @xmath174 , @xmath175 and @xmath176 .",
    "observe that the total length of the arcs @xmath173 and @xmath175 is at least @xmath1 if at each node the lengths of the outgoing arcs satisfy kraft s inequality .     from subgraphs @xmath160 , and example of a path @xmath177 corresponding to clause @xmath178 . ]",
    "we now describe how the subgraphs @xmath160 are connected to one another to form the graph @xmath32 .",
    "[ fig : clause ] illustrates the construction for the clause @xmath179 .    for each clause @xmath180 containing @xmath8 literals , we assume without loss of generality that the variable indices are ordered to satisfy @xmath181 .",
    "we say that @xmath182 is a _",
    "successor index _ of @xmath183 and that @xmath184 is a _",
    "successor index _ of @xmath185 . for each clause @xmath186 containing @xmath1 literals ,",
    "we again assume without loss of generality that the variable indices are ordered to satisfy @xmath187 .",
    "we say that @xmath182 is a _",
    "successor index _ of @xmath183 .",
    "we also say that @xmath188 is a _",
    "successor index _ of @xmath185 .",
    "thus , each literal has at most two successor indices since each literal is assumed to be in at most two clauses .",
    "we now describe how @xmath32 is formed by connecting the various subgraphs @xmath189 , @xmath190 . for each literal @xmath149 , @xmath191 , and for each successor index @xmath192 of @xmath149",
    ", we identify vertex @xmath192 in @xmath189 with either vertex @xmath193 or vertex @xmath194 in @xmath160 so that if there are two successor indices of @xmath149 then one is identified with @xmath193 and the other with @xmath194 .",
    "similarly for each literal @xmath150 and for each successor index @xmath192 of @xmath150 we identify vertex @xmath192 in @xmath189 uniquely to one of the vertices @xmath195 or @xmath196 in @xmath160 .",
    "this identification of vertices describes how the subgraphs @xmath197 are connected to one another .",
    "the example shown in fig .",
    "[ fig : clause ] illustrates how node @xmath198 and node @xmath1 are identified as a single node and how node @xmath199 and node @xmath8 are identified as a single node .",
    "it remains to specify the collection of paths @xmath31 in @xmath32 .",
    "consider clause @xmath180 and let @xmath200 , @xmath201 .",
    "for @xmath202 , let @xmath203 be the path in @xmath32 from @xmath204 to @xmath205 . then define @xmath177 as the concatenation of the paths @xmath206 , @xmath207 , and arc @xmath208 .",
    "the red / gray arcs in fig .",
    "[ fig : clause ] show @xmath177 for the example clause @xmath179 .",
    "now consider a clause @xmath209 and let @xmath200 , @xmath210 .",
    "define @xmath206 to be the path in @xmath32 from @xmath211 to @xmath212 .",
    "define @xmath207 to be the path in @xmath32 from @xmath212 to @xmath213 .",
    "then let @xmath214 .",
    "finally , define @xmath177 to be the concatenation of @xmath215 , @xmath216 and @xmath217 .",
    "the set of paths is then chosen as @xmath218 .",
    "this completes the construction of the instance @xmath53 of the optimal path - encoding problem corresponding to the instance @xmath155 of the ( 2,3)-sat problem .",
    "one can easily verify that this construction can be done in time polynomial in the size of the instance @xmath155 .",
    "suppose there is a satisfying assignment @xmath219 for @xmath155 .",
    "then for each @xmath149 assigned the value true in @xmath219 , give arc @xmath163 length @xmath10 and arc @xmath164 length @xmath1 .",
    "similarly for every @xmath149 assigned the value false in @xmath219 give arc @xmath164 length @xmath10 and arc @xmath163 length @xmath1 .",
    "assign length @xmath1 to each arc @xmath165 , and assign length @xmath10 to every other arc .",
    "it can easily be verified that the lengths of the arcs out of each vertex satisfy kraft s inequality . for path",
    "@xmath177 the _ length of @xmath177 _ , is the sum of the lengths of the arcs on @xmath177 .",
    "then the length of @xmath177 is at most @xmath64 for all @xmath220 since at least one of the literals in each clause is true , and hence the corresponding arc has length @xmath10 . to be more precise , for each clause @xmath145 ,",
    "the length of @xmath177 is @xmath19 , @xmath135 or @xmath64 depending on whether clause @xmath145 has @xmath8 , @xmath1 or @xmath10 true literals respectively . of course",
    ", if @xmath145 only contains @xmath1 literals then the length @xmath177 can only be @xmath135 or @xmath64 . to summarize , if a satisfying assignment for @xmath155 exists , then @xmath53 is at most @xmath64 .",
    "conversely , suppose there is an assignment of lengths to the arcs of @xmath32 so that they satisfy kraft s inequality at every vertex and such that the length of @xmath177 is at most @xmath64 for @xmath220 .",
    "then for each @xmath220 it is the case that if @xmath145 contains 3 literals then for at least one of the literals @xmath183 , @xmath185 or @xmath221 ( or if @xmath145 contains only 2 literals then for at least one of @xmath183 or @xmath185 ) the arc @xmath222 has been assigned length 1 .",
    "therefore the truth assignment with @xmath149 set to false if @xmath164 is assigned length @xmath10 and set to true otherwise is a satisfying assignment for @xmath155 .    together",
    ", this argument shows that there is a solution to @xmath53 with maximum path length at most @xmath64 if and only if there is a satisfying assignment for @xmath155 .",
    "put differently , if @xmath155 has no satisfying assignment then any solution to @xmath53 will have maximum path length at least @xmath161 . by the np - hardness of ( 2,3)-sat , this implies that there can not be a polynomial - time approximation algorithm for the optimal path - encoding problem with approximation ratio better than @xmath0 unless @xmath223 .",
    "since @xmath224 for all @xmath225 , the rounded solution @xmath226 is a feasible point for the integer path - encoding problem .",
    "the inequality @xmath227 is trivial , since @xmath226 is a ( suboptimal ) solution to the integer problem .",
    "it remains to show that @xmath228 .",
    "observe that the value of a label size @xmath229 in the optimal solution can be equal to @xmath29 only if @xmath39 is the only outgoing arc of @xmath100 .",
    "but then we can without loss of generality assume that @xmath230 as well .",
    "therefore , for the path @xmath40 resulting in the largest path encoding according to @xmath231 , @xmath232 where @xmath233 follows since @xmath89 is the maximum of @xmath234 over all paths , and since @xmath235 whenever @xmath236 as argued above .",
    "this completes the proof .",
    "we start with the lagrangian @xmath237 the dual is given by @xmath238    we first handle the minimization over @xmath53 .",
    "observe that @xmath239 unless @xmath240 . on the other hand , if this equality is satisfied , then the term @xmath241 has value @xmath29 .",
    "hence , the dual can be simplified to @xmath242    we continue with the minimization over @xmath52 .",
    "taking the derivative of the objective function with respect to @xmath41 and equating to zero yields @xmath243 which has solution",
    "@xmath244 using this , the dual becomes @xmath245    the maximization over the dual variables @xmath246 can be performed analytically .",
    "taking the derivative of the objective function with respect to @xmath247 and equating to zero yields , @xmath248 which has solution @xmath249 where , as before , we use the nonstandard convention that @xmath250 if and only if any of its outgoing arcs are in @xmath40 .",
    "observe that @xmath251 for all @xmath37 implies that @xmath252 as required .",
    "substituting the optimal value of @xmath246 and using that @xmath253 the dual can be simplified to @xmath254 as claimed .",
    "the dual objective function can be rewritten as @xmath255 now , @xmath256 so that the dual objective function becomes @xmath257 as needed to be shown .",
    "we presented a mathematical formulation of the problem of minimizing encoded paths and developed a @xmath1-approximation algorithm for this problem .",
    "the algorithm allows interface labels of variable length at each switch .",
    "compared to a baseline fixed - length encoding , the flexibility of this variable - length approach allows the algorithm to yield up to a @xmath13 reduction in the length of the maximum encoded paths when tested on real - world isp topologies .",
    "while the problem of path encoding was analyzed in this paper from a theoretical point of view , in follow - up work , our proposed variable - length approach has been implemented in the industry - standard open vswitch ( ovs ) in the linux kernel @xcite .",
    "the algorithm presented in this paper assigns labels to switch interfaces , rather than to paths . as a consequence",
    ", new paths can always be added at any time .",
    "moreover , these routes can be pre - optimized by adding future projected paths as well as backup paths to the initial list of paths when running the algorithm .",
    "an interesting open problem for future research is how to incrementally update interface labels to optimize the path encoding for unanticipated topology or path changes .",
    "w.  john , k.  pentikousis , g.  agapiou , e.  jacob , m.  kind , a.  manzalini , m.  risso , d.  staessens , r.  steinert , and c.  meirosu , `` research directions in network service chaining , '' in _",
    "ieee sdn4fns _ , pp .  17 , nov .",
    "2013 .",
    "m.  soliman , b.  nandy , i.  lambadaris , and p.  ashwood - smith , `` source routed forwarding with software defined control , considerations and implications , '' in _ proc .",
    "acm conext student _ , pp .  4344 , dec ."
  ],
  "abstract_text": [
    "<S> packet networks need to maintain state in the form of forwarding tables at each switch . </S>",
    "<S> the cost of this state increases as networks support ever more sophisticated per - flow routing , traffic engineering , and service chaining . </S>",
    "<S> per - flow or per - path state at the switches can be eliminated by encoding each packet s desired path in its header . </S>",
    "<S> a key component of such a method is an efficient encoding of paths through the network . </S>",
    "<S> we introduce a mathematical formulation of this optimal path - encoding problem . </S>",
    "<S> we prove that the problem is apx - hard , by showing that approximating it to within a factor less than @xmath0 is np - hard . </S>",
    "<S> thus , at best we can hope for a constant - factor approximation algorithm . </S>",
    "<S> we then present such an algorithm , approximating the optimal path - encoding problem to within a factor @xmath1 . </S>",
    "<S> finally , we provide empirical results illustrating the effectiveness of the proposed algorithm . </S>"
  ]
}