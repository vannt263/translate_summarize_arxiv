{
  "article_text": [
    "because of the many applications in technological , biological , and social systems , interest in networks has grown significantly in recent years @xcite . in approaches that use differential equations to study network evolution ,",
    "much work has gone into incorporating local spatial correlations to extend the mean field approximation .",
    "one of the simplest methods to do this is the pair approximation @xcite .    to set the framework , consider a network of @xmath2 nodes with links between nodes characterized by an adjacency matrix @xmath3 , where @xmath4 if nodes @xmath5 and @xmath6 are connected and @xmath7 otherwise .",
    "we assume bidirectional links , so @xmath8 , and there is no self  contact , so @xmath9 .",
    "the number of connected pairs and triplets in the network is @xmath10 where @xmath11 is the average number of neighbours per node .",
    "the triplets , comprising of nodes connected by two links , will include as a subset triangles , which are three linked nodes with the same start and end .",
    "a parameter @xmath12 is introduced to characterize the ratio of triangles to triplets : @xmath13 with @xmath14 , networks with values of @xmath12 close to 1 are highly clustered , while low values of @xmath12 close to 0 show little such structure .",
    "the value of @xmath12 , together with @xmath11 , the average number of neighbours per node , will be considered fixed parameters for a given network , and will give an indication of the amount of spatial structure present .",
    "models describing the evolution of networks that incorporate such spatial correlations can be formulated as follows .",
    "suppose there are a set of variables associated with each node , generically labelled by @xmath15 , which is 1 if the node is of type `` @xmath15 '' .",
    "introduce singlets , doublets , and triplets as follows : @xmath16 = \\sum_i a_i \\nonumber\\\\ & & { \\rm doublets\\ of\\ type\\ ab } = [ ab ] = \\sum_{i , j } a_i b_j g_{ij }   = [ ba ] \\nonumber\\\\ & & { \\rm triplets\\ of\\ type\\ abc } = [ abc ] = \\sum_{i , j , k } a_i b_j c_k g_{ij } g_{jk } = [ cba ] \\label{rels}\\end{aligned}\\ ] ] one can show @xmath17 = n \\nonumber\\\\ & & \\sum_b [ ab ] = n[a ] \\nonumber\\\\ & & \\sum_c [ abc ] = \\frac{n(n-1)}{n } [ a][b ] \\label{sum}\\end{aligned}\\ ] ] consider now , for example , the @xmath18 model , in which a given node can exist in one of three states : susceptible ( @xmath19 ) , infected ( @xmath20 ) , or recovered ( @xmath21 ) .",
    "a susceptible node will become infected , with rate characterized by @xmath22 , while infected nodes recover with a rate characterized by @xmath23 .",
    "equations describing these transitions are @xmath24 note that the sum of these equations vanishes , which reflects the fact that the total population remains constant .",
    "these equations describe the evolution of the appropriate singlets @xmath25 $ ] , @xmath26 $ ] , and @xmath27 $ ] , and can be used to derive the corresponding equations for the doublets @xcite : @xmath28}{dt } = - 2\\tau [ ssi ] \\nonumber\\\\ & & \\frac{d\\ , [ si]}{dt } =   \\tau [ ssi ]   -\\tau[isi ] -\\tau[si ] - \\gamma [ si]\\nonumber\\\\ & & \\frac{d\\ , [ sr]}{dt } = \\gamma [ si ] -\\tau [ rsi ] \\nonumber\\\\ & & \\frac{d\\ , [ ii]}{dt } = 2\\tau [ isi ] + 2\\tau[si ] - 2\\gamma [ ii]\\nonumber\\\\ & & \\frac{d\\ , [ ir]}{dt } =   \\tau [ rsi ] + \\gamma [ ii ] - \\gamma [ ir]\\nonumber\\\\ & & \\frac{d\\ , [ rr]}{dt } = 2\\gamma [ ir ] \\label{sirpa}\\end{aligned}\\ ] ] where @xmath29 .",
    "since triplets appear in this equation , we require a closure approximation to express the triplets in terms of doublets ; a common one used in this regard is parameterized by the number of nearest neighbours @xmath11 and the ratio @xmath12 of triangles to triplets @xcite @xmath30 \\approx \\zeta \\frac { [ ab ] [ bc ] } { [ b ] } \\left [ ( 1-\\phi ) +   \\phi \\frac{n}{n } \\frac { [ ac ] } { [ a ] [ c ] } \\right ] \\label{keeling}\\ ] ] where @xmath31 .",
    "although the procedure to generate the equations in the pair approximation is straightforward @xcite , it can become tedious ; if there are @xmath0 mean field equations , there will be @xmath1 equations in the pair approximation . in the next section",
    "we describe the use of programs , written in perl , to assist in these tasks : one program to generate the equations , and another to construct matlab / octave functions that can be used to numerically solve the equations .",
    "additionally , a utility perl script is supplied which , based on the file used in the other programs to describe the equations , will generate a text file that can be loaded into the maple symbolic manipulation program to provide algebraic simplifications of the terms in the equations , as well as check that the standard combination of terms in the equations sums up to zero , which is expected when the total population size is constant ( as in the @xmath18 model described above ) .",
    "after explaining how to install the programs , we will describe their use in the order they would normally be used .",
    "the programs are available at http://physics.uwinnipeg.ca/rkobes/ in a zipped archive called pa_programs.zip .",
    "unzipping the archive will create a subdirectory pa_programs containing a number of files :    * three perl scripts ",
    "make_eqns.pl , make_mfile.pl , and maple_chk.pl  described in this paper ; * documentation in _ html _ format for all three scripts ; * sample _ json _ configuration files ",
    "sir.json , siri.json , and dr.json  for , respectively , the @xmath18 , @xmath32 , and a drug resistant model discussed in this paper . *",
    "a pdf copy of this paper * a readme file summarizing the installation procedure    information on the usage of the programs can be obtained by the perldoc command in perl : in a shell command window , type perldoc make_eqns.pl , for example .",
    "html versions of the documents , suitable for viewing within a web browser , can be made with the pod2html utility : pod2html infile make_eqns.pl outfile make_eqns.html , and similarly for the other scripts .",
    "as perl is very good at text manipulations , and has fairly advanced regular expression support , it is normally available on most modern unix  based systems , including linux and macos ( with the developer tools installed ) .",
    "the most popular binary perl distribution is that distributed by activestate : http://www.activestate.com/activeperl ; this includes a windows version .",
    "the programs should run on versions of perl back to 5.6 .",
    "the only requirement beyond the core perl installation is a perl module called json . on systems using the activeperl binary distribution ,",
    "json can be installed with the ppm utility : in a shell command window , type ppm install json . for especially linux",
    " based systems with a package manager such as rpm or apt - get , there may be pre  built binary distributions available .",
    "on other systems the module will have to be built and installed from the sources , which are available at http://search.cpan.org / dist / json/. how to install modules from sources is described at either http://perldoc.perl.org/perlmodinstall.html or http://www.perlmonks.org/index.pl?node_id=128077 .",
    "this latter link also describes what to do in cases where a user does nt have permission to perform a system  wide module installation .",
    "one aspect of the running of the perl scripts is worth noting .",
    "as it stands , the scripts , containing a .pl extension , can be run from a shell command window as , for example , perl make_eqns.pl .",
    "this can be simplified as follows . on a unix  based system ,",
    "if one makes a line such as # ! /usr",
    "/ bin / perl the first line of a perl script ( where /usr / bin / perl is the perl interpreter , including the full path ) , remove the .pl extension from the filename , make the script executable by running , for example , chmod u+x make_eqns , and then place this file in a directory appearing in your path environment variable .",
    "the script can be run simply as make_eqns . on a windows  based system , there is a perl utility pl2bat which , if run as , for example , pl2bat make_eqns.pl , will create a dos batch file make_eqns.bat . placing this file on a directory appearing in your path environment variable will also enable the script to be run simply as make_eqns .",
    "this program starts from a user  supplied input file , written in _",
    "json _ , that specifies the system under consideration , and outputs _ json _ files describing the mean field and pair approximation equations .",
    "we begin by describing the structure of this input .",
    "_ json _ ( javascript object notation ) is a lightweight text - based open standard designed for human - readable data interchange .",
    "_ json _ files are ordinary text files , which by convention normally have a .json extension .",
    "as such , they can be created with any text editor ; if one uses a word processor such as microsoft word@xmath33 , one must ensure to save the file in text mode , with a final .json extension . as an overview , there are two basic structures in _ json _ :    * a container , enclosed within opening and closing curly braces , consisting of a collection of key / value pairs .",
    "a key and its associated value are separated by a colon , and the key / value pairs are separated by commas . * an ordered list of items , which is enclosed within opening and closing square brackets .",
    "individual items are separated by commas .",
    "the basic data types are    * a number , which can be an integer or real . * a string , which is a double - quoted group of unicode characters with backslash escaping . * a boolean value , which can be _ true _ or _ false_. * the _ null _ value .",
    "see http://www.json.org/ for a general discussion and further links .",
    "the basic @xmath18 model is described by two transitions : an @xmath34 , at rate @xmath35 , and an @xmath36 , at rate @xmath37 .",
    "the @xmath38 transition needs a `` spectator '' @xmath20 node to proceed ( susceptible nodes become infected only when they come into contact with an infected node ) , but the @xmath36 transition proceeds without a `` spectator '' ( infected nodes can recover on their own ) .",
    "[ sir ] illustrates this model .",
    "model.,width=384 ]    the corresponding _ json _ file for this model appears below .",
    ".... # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # file sir.json , specifying transitions in the sir model {    \" s \" : {         \" target \" : \" i \" ,       \" link \" : \" beta \" ,       \" needs \" : \" i \" ,   } ,    \" i \" : {        \" target \" : \" r \" ,       \" link \" : \" gamma \" ,   } ,    \" pa_parameters \" : {       \" beta \" : \" tau \" ,   } ,    \" first \" : \" s \" , } # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    note that new lines and leading and trailing white space on a line have no significance in the _ json _ file ; they are only present here for ease of human readability .    before discussing the structure of this file , an important point should first be noted .",
    "the above file differs in two aspects from the strict _ json _ specification :    * end - commas in list items can optionally appear . *",
    "shell - style comments beginning with a # can be used .",
    "this file would be ruled invalid if processed by a parser following the strict _ json _ specification .",
    "however , the json perl module used in this script has a _ relaxed _ mode that is enabled that allows for these two non - standard extensions .",
    "the _ json _ output files from this script follow the strict _ json _ specification without these non - standard extensions .",
    "the basic features illustrated in this example are as follows .    * except for the special `` pa_parameters '' and `` first '' keys , a key such as , for example , `` s '' : , indicates the start of the description for the s node . *",
    "the properties of each node are given ( in this example ) as a container consisting of key / value pairs .",
    "there are three possible values of the keys : * * the `` target '' field , which is required , indicates the target of the transition . *",
    "* the link field , which is required , indicates the parameter characterizing the transition .",
    "the associated value can be a single variable or a mathematical expression following the rules of matlab / octave  for example , `` 2*g*(1-p ) '' , expressing combinations of several variables .",
    "* * the `` needs '' field , which is optional , indicates whether or not another state variable is needed to cause the transition . *",
    "the purpose of the `` first '' key arises because key / value pairs in a container will not be sorted .",
    "if a `` first '' key is present in the _ json _ file , this will be transferred over to a `` first '' key in the output files .",
    "the presence of such a key in these files , when processed by make_file.pl , will cause the singlets in the matlab / octave update functions to be ordered such that the value of the `` first '' key appears first , after which the rest are sorted alphabetically . if a `` first '' key is not present , the singlets will be sorted alphabetically .",
    "* the purpose of the `` pa_parameters '' key is as follows .",
    "often , when deriving the equations in the pair approximation , a parameter arising in the mean field approximation gets replaced by another parameter in the pair approximation , where the two are related through the number of nearest neighbors , n. for example , in the sir model , the beta parameter in the mean field case gets replaces by tau = beta /",
    "n in the pair approximation . in the json file , one can list parameters related in this way through a container such as + ....    \" pa_parameters \" : {        \" beta \" : \" tau \" ,    } , .... + when constructing the equations in the pair approximation , the parameter `` beta '' will be replaced by `` tau '' .",
    "the relationship between `` beta '' and `` tau '' must be specified by the user in the main program .",
    "the @xmath32 model extends the @xmath18 model by having , as well as the transitions @xmath34 , at rate @xmath35 , and @xmath36 , at rate @xmath37 , of the @xmath18 model , two additional transitions : @xmath39 , at rate @xmath40 , representing a recovered node becoming susceptible , and @xmath41 , which proceeds in the presence of an @xmath20 node at rate @xmath42 , representing a recovered node becoming infected again . fig .",
    "[ siri ] illustrates this model .",
    "model.,width=384 ]    the _ json _ file representing this model appears below .",
    ".... # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # file siri.json , specifying transitions in the siri model   {    \" s \" : {       \" target \" : \" i \" ,       \" link \" : \" beta \" ,       \" needs \" : \" i \" ,    } ,    \" i \" : {       \" target \" : \" r \" ,       \" link \" : \" gamma \"     } ,     \" r \" : [       {         \" target \" : \" s \" ,         \" link \" : \" alpha \" ,       } ,       {         \" target \" : \" i \" ,         \" link \" : \" beta_tilde \" ,         \" needs \" : \" i \" ,       }     ] ,     \" pa_parameters \" : {        \" beta \" : \" tau \" ,        \" beta_tilde \" : \" tau_tilde \"     } ,     \" first \" : \" s \" ,   } # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    the one new feature illustrated here that is not present in the @xmath18 model is the presence of more than one possible transition for a given node ( the r node ) . in such cases , the value of the `` r '' node is a list of containers , each container following the rules for a single transition .      there are more complicated models that involve transition rates between nodes which are not covered by the previous two examples . for example , in the drug resistant model considered in ref .",
    "@xcite , there are two strains of a pathogen , one of which is sensitive to a drug treatment , and the other is resistant .",
    "there are subsequently three classes of infected individuals : @xmath43 and @xmath44 , representing , respectively , untreated and treated nodes infected with the sensitive strain , and @xmath45 , representing a node infected with the resistant strain .",
    "a parameter @xmath46 is introduced , representing the fraction of infected individuals who receive treatment for the sensitive strain ( ie , the treatment level ) .",
    "the susceptible to infected transitions therefore consist of terms :    * @xmath47 , at rate @xmath48 * @xmath49 , at rate @xmath50 * @xmath51 , at rate @xmath52    where @xmath53 is the relative infectiousness of treated individuals infected with the sensitive strain , and @xmath54 represents the relative transmission fitness of the resistant strain . for simplicity , death and",
    "recovered classes are grouped into an @xmath55 node , with @xmath56 , @xmath57 , and @xmath58 parameterizing transitions from , respectively , the @xmath43 , @xmath44 , and @xmath45 nodes to the @xmath55 node . finally , a transition @xmath59 , characterized by rate @xmath60 , is included .",
    "this model is represented in fig .",
    "[ dr ] ( without the `` spectator nodes '' required in the transitions involving @xmath19 ) .",
    "the full _ json _ file for this model appears in the appendix ; the portion describing the @xmath19 transitions is as follows :    .... # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #     \" s \" : [        {           \" target \" : \" i_u \" ,           \" link \" : {               \" i_u \" : \" ( 1-p)*beta \" ,               \" i_t \" : \" ( 1-p)*beta*delta_t \" ,           } ,           \" needs \" : \" i_u \"        } ,        {           \" target \" : \" i_t \" ,           \" link \" : {              \" i_u \" : \" p*beta \" ,              \" i_t \" : \" p*beta*delta_t \" ,           } ,           \" needs \" : \" i_t \" ,        } ,        {           \" target \" : \" i_r \" ,           \" link \" : \" beta*delta_r \" ,           \" needs \" : \" i_r \"        } ,     ]   # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    in this case , the more complicated links specifying the transitions to @xmath43 and @xmath44 are specified by a container , rather than as a simple scalar value as in the previous examples .",
    "each key / value pair within the container is of the form `` node '' : `` parameter_value '' .",
    "the _ json _ file described in the previous sections is then used as input to the perl script make_eqns.pl .",
    "the script may be used with various options as follows , assuming an input _ json _ file sir.json :    * perl make_eqns.pl sir.json : this will generate two text files : sir_mf.txt , describing the mean field equations , and sir_pa.txt , describing the pair approximation equations . *",
    "perl make_equns.pl input sir.json mf mf.txt pa pa.txt : this does the same as the previous usage , but allows you to specify the output file names . * perl make_eqns.pl nmax 35 sir.json the _ nmax _ option , which is optional and has a default of 40 , specifies the maximum length of the lines appearing in sir_mf.txt and sir_pa.txt that specify the equations . * perl make_eqns.pl mfile sir.json the mfile option , if given , will run make_mfile.pl after finishing , which will generate the matlab / octave functions that can be used to solve the system of equations .",
    "the input to make_mfile.pl will be the two output _",
    "files from this script .",
    "the output mfiles from make_mfile.pl will have the default names .",
    "details of generating these matlab / octave files , and how they can be used , will be given in the next section .",
    "* perl make_eqns.pl help : this prints a brief summary of usage of the script and exits .",
    "this program starts from a user  supplied input file , written in _",
    "json _ , that specifies the equations of the system under consideration , and outputs matlab / octave functions that can be used to solve the equations .",
    "these input files are the output from make_eqns.pl described in the previous section , although they can be originate from another source .",
    "the _ json _",
    "file used here describes a system of first ",
    "order differential equations , involving @xmath61 state variables @xmath62 , with @xmath63 . for the mean field model",
    ", @xmath62 would correspond to singlets , while for the pair approximation equations , the @xmath62 would be doublets .",
    "the equations are assumed to have the form @xmath64 where the functions @xmath65 and @xmath66 are functions in principle of all the @xmath62 variables . as a simple example , consider the @xmath18 model of eqs .",
    "( [ sirmf ] ) : @xmath67 the _ json _ files used specify the @xmath68 and @xmath69 functions for each state variable . example",
    "_ json _ files for the @xmath18 mean",
    "field and pair approximation equations follow :      the mean field equations of eqs .",
    "( [ sirmf ] ) for the @xmath18 model are described by the following _ json _ file .",
    ".... # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # file sir_mf.json , derived from sir.json . {     \" i \" : {        \" g \" : \" beta*[s]*[i ] ; \" ,        \" h \" : \" gamma ; \"     } ,     \" r \" : {        \" g \" : \" gamma*[i ] ; \"     } ,     \" s \" : {        \" h \" : \" beta*[i ] ; \"     } ,     \" first \" : \" s \" ,     \" parameters \" : [        \" beta \" ,        \" gamma \"     ] } # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    some items to note about this :    * except for the `` parameters '' and `` first '' keys , which will be explained shortly , the top - level keys of this file are the names of the singlets in the model . *",
    "the names of the singlets are the top ",
    "level keys of this file .",
    "the corresponding value is a container containing at least one , and possibly both , `` g '' and `` h '' keys , which define the equation associated with that singlet .",
    "singlets appearing in the @xmath65 and @xmath66 functions must be enclosed within square brackets .",
    "remember that the factor of x must be factored out of the h equation for the x singlet .",
    "all equations must be valid matlab / octave code , including the ending semicolons .",
    "if it is desired to split up an equation over multiple lines for ease of readability , the associated value of the `` g '' or `` h''| key is a list containing the desired lines , as in , for example , this snippet : + ....     \" i_t \" : {        \" g \" : [           \" p*beta*[s]*[i_u ] + ... \" ,           \" p*beta*delta_t*[s]*[i_t ] ; \"        ] ,        \" h \" : \" mu_t + alpha_t ; \"     } , .... * the redundant equation ( associated usually with the equation of @xmath21 in the @xmath18 model ) , which in principle is derivable from the fact that the population remains constant , must be included in the _ json _ file . *",
    "parameters used in the equations must be declared through a `` parameters '' key , whose value is a list of the parameters appearing in the equations . *",
    "the purpose of the `` first '' key arises because key / value pairs in a container will not be sorted .",
    "if a first \" key is present in this _ json _ file , the singlets in the matlab / octave update functions to be ordered such that the value of the `` first '' key appears first , after which the rest are sorted alphabetically .",
    "if a `` first '' key is not present , the singlets will be sorted alphabetically .",
    "a _ json _ file describing eqs .",
    "( [ sirpa ] ) of the @xmath18 model in the pair approximation is as follows :    .... # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # file sir_pa.json , derived from sir.json .",
    "{     \" ii \" : {        \" g \" : \" 2*tau*([isi ] + [ si ] ) ; \" ,        \" h \" : \" 2*gamma ; \"     } ,     \" ir \" : {        \" g \" : \" tau*[rsi ] + gamma*[ii ] ; \" ,        \" h \" : \" gamma ; \"     } ,     \" rr \" : {        \" g \" : \" 2*gamma*[ir ] ; \"     } ,     \" si \" : {        \" g \" : \" tau*[ssi ] ; \" ,        \" h \" : \" tau*([isi ] + 1 ) + gamma ; \"     } ,     \" sr \" : {        \" g \" : \" gamma*[si ] ; \" ,        \" h \" : \" tau*[rsi ] ; \"     } ,     \" ss \" : {        \" h \" : \" 2*tau*[ssi ] ; \"     } ,     \" first \" : \" s \" ,     \" pa_parameters \" : {        \" beta \" : \" tau \"     } ,     \" parameters \" : [        \" tau \" ,        \" gamma \"     ] ,     \" singlets \" : [        \" s \" ,        \" i \" ,        \" r \"     ] } # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    the comments made about the mean field _ json _ file of the previous section also apply here . in addition , note that    * except for the `` first '' , `` pa_parameters '' , `` parameters '' , and `` singlets '' keys , the top - level keys of this file are the names of the doublets .",
    "* doublets appearing in g and h are denoted by , , etc .",
    "* triplets appearing in g and h are denoted by , , etc . in the matlab",
    "/ octave code these will be translated into appropriate function calls implementing the keeling approximation of eq.([keeling ] ) for triplets in terms of doublets and singlets . *",
    "the meaning of the `` parameters '' and the `` first '' keys are equivalent to that used for the singlet case .",
    "* items specified by a `` pa_parameters '' key , which are of the form s1 : d1 , s2 : d2 , etc . will specify a set of parameter pairs s1 , d1 , s2 , d2 , etc , where s1 is a parameter which would appear in the mean field model and d1 is a derived parameter d1 = s1 / n appearing in the pair approximation model .",
    "this line is optional , and is only used in providing an example main file . *",
    "the list corresponding to the `` singlets '' key is the list of singlet keys .",
    "once the _ json _ file describing the equations is generated , either for the mean field or pair approximation equations , it may be useful at this stage to run the supplied utility perl script maple_chk.pl on it .",
    "this addresses two points present in the _ json _ file :    * the values of the `` g '' and `` h '' keys the _ json _ file are valid matlab / octave code , but especially if they are generated by make_equns.pl , there may be some algebraic simplifications possible that are not implemented .",
    "* by including the normally `` redundant '' state variable , there is a combination of the equations that vanishes identically , reflecting the fact that the population remains constant when all possible transitions are taken into account .",
    "for example , in eqns .",
    "( [ sirmf ] ) for the @xmath18 mean field model , we have the combination of terms : @xmath70 whereas for eqns .",
    "( [ sirpa ] ) for the @xmath18 model in the pair approximation , this is @xmath71}{dt } + 2\\frac{d\\ , [ si]}{dt } + 2\\frac{d\\ , [ sr]}{dt } +   \\frac{d\\ , [ ii]}{dt } + 2\\frac{d\\ , [ ir]}{dt } + \\frac{d\\ , [ rr]}{dt } = 0\\ ] ] which uses the property of @xmath72 = n[a]$ ] from eqns.([sum ] ) , as well as @xmath73 = [ ba]$ ] .",
    "note that the assumption of eq .",
    "( [ keeling ] ) relating the triplets to doublets and singlets is not used here .    if one uses the _",
    "json _ file describing the equations as input into the maple_chk.pl perl script , via running , for example , perl maple_chk.pl sir_mf.json for the mean field equations of the sir model , a text file sir_mf_maple.txt is generated . for this",
    "@xmath18 mean field equations , this file is    ....   var_i_g : = beta * var_s * var_i :   var_i_h : = gamma :   var_r_g : = gamma * var_i :   var_s_h : = beta * var_i :   var_i_g : = simplify ( var_i_g ) ;   var_i_h : = simplify ( var_i_h ) ;   var_i_prime : =   simplify(var_i_g - var_i * ( var_i_h ) ) ;   var_r_g : = simplify ( var_r_g ) ;   var_r_prime : =   simplify(var_r_g ) ;   var_s_h : = simplify ( var_s_h ) ;   var_s_prime : =   simplify ( - var_s * ( var_s_h ) ) ;   sumall : = simplify(var_i_prime + var_r_prime + var_s_prime ) ; ....    this text file can be loaded as _ `` maple input '' _ into maple and evaluated .",
    "some features to note about this file are :    * all variables , except for the last sumall variable , have a var _ prefix .",
    "the maple variable var_i_g , for example , represents the `` g '' term for the `` i '' node , var_r_h represents the `` h '' term for the `` r '' node , and so on . * a series of maple variables with a _ prime suffix",
    "are introduced , representing the equation for the specified node .",
    "for example , var_i_prime in the maple code + ....",
    "var_i_g : = beta * var_s * var_i :   var_i_h : = gamma :   var_i_prime : =   var_i_g - var_i * ( var_i_h ) ; .... + represents the equation @xmath74 * the maple variable sumall : = var_i_prime + var_r_prime + var_s_prime , which is always the last variable defined in the text file , represents the sum of all of the equations @xmath75 which normally vanishes algebraically .",
    "* when the worksheet is evaluated , the presence of the simplify maple function will cause all variables to be displayed in their simplified form .",
    "having constructed the _ json _ file describing the equations , the make_mfile.pl script is then run to generate matlab / octave functions that can be used to solve the equations .",
    "the script may be used as follows ; in these examples , the input _ json _ file is denoted sir_eqns.json .    * perl make_mfile.pl sir_eqns.json : this will generate two files : sir_eqns.m , a matlab / octave file for the model , and sir_eqns_main.m , an example main program . * perl make_mfile.pl input sir_eqns.json mfile mfile.m main main.m : this does the same as the previous usage , but allows you to specify the output names . * perl make_mfile.pl help : this gives a brief summary of usage .",
    "* perl make_mfile.pl gen : this generates a matlab / octave file de_solve.m , which is a file containing functions needed to solve the equations , in addition to the output sir_eqns.m file .",
    "the de_solve.m file is independent of the model under consideration , and thus need be generated only once .",
    "the procedure used to solve the system of equations represented by eq.([gen ] ) is coded in the output matlab / octave file when running this script .",
    "the algorithm is as follows .",
    "the continuous time variable is approximated by a series of discrete steps @xmath76 , with @xmath77 . at any given time step @xmath78 , the @xmath79 equation of the @xmath63 set",
    "is then approximated as @xmath80 where @xmath81 , which is assumed constant and positive , and @xmath82 in this , we have assumed that the update routine has already been performed on the previous equations for @xmath83 .",
    "eq.([genapp ] ) then allows us to solve for the unknown variable @xmath84 : @xmath85 for @xmath77 , with the first @xmath86 value specified by the initial conditions .",
    "since @xmath65 and @xmath66 are ono  negative functions , eq.([genapp ] ) ensures that @xmath84 is positive semi - definite if @xmath87 is .      within the matlab / octave code ,",
    "singlets and doublets are represented as arrays x(i ) .",
    "the array index @xmath5 is defined as follows :    * for a system with @xmath88 singlets , an array index @xmath89 is assigned according to the order that the singlets are defined within the input _ json _ file , which is described under the option of the first key . * for a system with @xmath90 doublets , with @xmath91 for @xmath88 singlets , indices are assigned as follows .",
    "a singlet index is first generated based on the order given in the input _ json _ file .",
    "then , for a doublet @xmath92 $ ] corresponding to singlets @xmath93 and @xmath94 , an index @xmath95 is generated : @xmath96 where @xmath97 .",
    "note that @xmath98 is symmetric in @xmath5 and @xmath6 , so that the doublet @xmath92 $ ] is mapped to the same index as the doublet @xmath99 $ ] , in accordance with the relation @xmath73 = [ ba]$ ] of eq .",
    "( [ rels ] ) . making the choice @xmath100 , the order of the assigned indices for the doublets",
    "is thus determined by the order of the assigned indices for the singlets .    for the triplets appearing in the equations for the pair approximation , using the property @xmath101 = [ cba]$ ] of eqs .",
    "( [ rels ] ) , a linear addressing scheme for a triplet @xmath102 $ ] is @xmath103 which we write in abbreviated form as @xmath104 where @xmath105 and @xmath106 .",
    "triplets appearing in the equations can then be expressed in terms of singlets and doublets using the keeling approximation of eq.([keeling ] ) .",
    "if we denote the singlets by @xmath107 , the doublets by @xmath108 , and the triplets by @xmath109 , then we have @xmath110\\end{aligned}\\ ] ] in this way the triplets can be related to the singlets and doublets . in the update algorithm used in the matlab / octave functions generated by make_mfile.pl , if a triplet appears in the g term , a call to a function zz ( ... ) is made , while another function zz1 ( ... ) is used if it appears in the h term .",
    "the difference between these two functions is that zz1 ( ... ) factors out the necessary x(i ) factor , while zz ( ... ) does not .      as well as generating the matlab / octave file containing the necessary functions to solve the equations , make_mfile.pl also generates a sample main program .",
    "it is in this program that the parameter values and initial conditions are specified , as well as calls made to the functions needed to solve the equations . for a given system of equations , after running make_mfile.pl on the _ json _ file , the only file that needs editing will be the sample main program .    as an example , the following , with some comments removed , is the sample main program generated for the @xmath18 mean field model .",
    ".... % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %   the following lines must be edited % % you may want to uncomment the following line to clear memory % clear all % %   give the values of the parameters of the equations : beta = 0.0 ; gamma = 0.0 ; % give the initial conditions : x0.s = 0.0 ; x0.i = 0.0 ; x0.r = 0.0 ; % specify the range of time desired for the solution : %     t0 = initial time , t1 = final time , numpts = number of points between t0 = 0.0 ; t1 = 0.0 ; numpts = 0.0 ; tspan = linspace(t0 , t1 , numpts ) ; % % end of user input % % % % % the following lines should not need editing % % put the parameter values in a structure data % data.beta = beta ; data.gamma = gamma ; % % % % % call the routine to solve the equations [ t , x , chk ] = de_solve(@sir_mf , data , tspan , x0 ) ; % plot the first two structure members of x , plus the check figure ; plot(t , [ x.s ] , t , [ x.i ] , t , chk ) ; % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % ....    some features illustrated here are as follows .    *",
    "the values of the parameters specified in the parameters key of the _ json _ file are set here .",
    "* in the main program , the state variables @xmath62 are represented as a structure . for the mean field case , the keys of the structures are the name of the singlets , while for the pair approximation equations , the keys are the names of the doublets . for faster execution speed ,",
    "such structures are converted within the matlab / octave functions to arrays with integer indices .",
    "the input initial conditions are specified by a structure , say , x0.key , while the output variable x.key(i ) is a structure with key corresponding to the state variable and index @xmath5 corresponding to the time step . *",
    "the initial and final times are specified by the variables t0 and t1 .",
    "an equally spaced array of time steps tspan(i ) , with i=1 , 2 , ... , numpts is then generated by a call to the linspace function .",
    "if tspan consists of an array with 2 members ( the initial and final time ) , an array is generated within the matlab / octave code with numpts set to a specified value , to be described shortly .",
    "the routine to solve the mean field equations is called as    ....   [ t , x , chk ] = de_solve(@sir_mf , data , tspan , x0 ) ; ....    recall that de_solve.m is generated by running perl make_mfile.pl gen .",
    "the input arguments are    * @sir_mf , which is a function handle pointing to the sir_mf.m file generated when running make_mfile.pl ; * data , which is a structure with keys corresponding to the parameters ; * tspan , which is an array specifying the desired range of time steps ; * x0 , which is the structure x0.key described above specifying the initial conditions .    the output variables , which for the mean field case , are .",
    "these are    * t , which is an array t(i ) containing the range of times . * x , which is the structure of arrays x.key(i ) giving the solutions to the equations at the specified time steps .",
    "* chk , which is an array chk(i ) containing the sum of all state variables at each time t(i ) . as",
    "normally this is a set constant , equal to the number of nodes in the network , this provides a useful check on the numerical accuracy .",
    "a main program for the case of the equations in the pair approximation has similar structure .",
    "one difference between the mean field and pair approximation cases is that , in the pair approximation , de_solve is called as    ....   [ t , x , y , chk ] = de_solve(@sir_pa , data , tspan , x0 ) ; ....    the additional output variable y in this case is a structure y.key(i ) , which is the singlet calculated from the doublets according to the second equation of eqs.([rels ] ) .",
    "the de_solve function can accept , for either the mean field or pair approximation case , an optional 5th argument of a structure , such as in    .... [ t , x , y , chk ] = de_solve(@sir_pa , data , tspan , x0 , opts ) ; ....    this structure can be used to control some of the parameters involved in solving the system of differential equations .",
    "the recognized members of the structure are    * opts.numpts : this option , which has a default of 100 , specifies the number of points to use if the tspan array only contains two points ( ie , the desired start and end times ) . * opts.adaptive : this option , which is boolean and has a default of false , specifies that an adaptive routine should be used that adjusts the step size when solving the equations . in difficult cases , setting this option to true may improve the accuracy , but at the expense of a speed penalty and larger memory usage .",
    "* opts.maxerr : this option , which has a default of 0.001 , is used when opts.adaptive is true to specify the desired error level . *",
    "opts.maxit : this option , which has a default of 40 , is used when opts.adaptive is true to specify the maximum number of iterations tried when attempting to reach the desired error tolerance in a given interval .",
    "the authors would be happy to receive correspondence regarding these programs , including bug reports and suggestions .",
    "the code in these programs is free software ; you may redistribute and/or modify it under the same terms as perl itself .",
    "see http://www.opensource.org/licenses/artistic-license-2.0.php for details .",
    "this work was supported by the natural sciences and engineering research council of canada .",
    "the full _ json _ file for the drug resistant model described in section [ drsection ] appears below .    ....",
    "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # file dr.json {            \" s \" : [        {           \" target \" : \" i_u \" ,           \" link \" : {               \" i_u \" : \" ( 1-p)*beta \" ,               \" i_t \" : \" ( 1-p)*beta*delta_t \" ,           } ,           \" needs \" : \" i_u \"        } ,        {           \" target \" : \" i_t \" ,           \" link \" : {              \" i_u \" : \" p*beta \" ,              \" i_t \" : \" p*beta*delta_t \" ,           } ,           \" needs \" : \" i_t \" ,        } ,        {           \" target \" : \" i_r \" ,           \" link \" : \" beta*delta_r \" ,           \" needs \" : \" i_r \"        } ,     ] ,     \" i_u \" : {         \" target \" : \" x \" ,         \" link \" : \" mu_u \" ,     } ,     \" i_t \" : [        {          \" target \" : \" x \" ,          \" link \" : \" mu_t \" ,        } ,        {          \" target \" : \" i_r \" ,          \" link \" : \" alpha_t \" ,        } ,     ] ,      \" i_r \" : {        \" target \" : \" x \" ,        \" link \" : \" mu_r \" ,     } ,     \" pa_parameters \" : {        \" beta \" : \" tau \"     } ,     \" first \" : \" s \" , } # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ....    99",
    "d.  j.  watts and s.  h.  strogatz , nature ( london ) * 393 * , 440 ( 1998 ) . s.  h.  strogatz , nature ( london ) * 410 * , 268 ( 2001 ) .",
    "r.  albert and a.  -l .",
    "barabsi , rev .",
    "phys .  * 74 * , 47 ( 2002 ) .",
    "m.  e.  j.  newman , siam review * 45 * , 167 ( 2003 ) .",
    "d.  a.  rand , `` correlation equations and pair approximations for spatial ecologies '' , in _ advanced ecological theory : principles and applications _ ( j.  mcglade ( ed . ) , wiley - blackwell ) , 100 ( 1999 ) .",
    "m.  j.  keeling , d.  a.  rand , and a.  j.  morris , proc .",
    "r.  soc .",
    "* b264 * , 1149 ( 1997 ) .",
    "m.  j.  keeling , proc .  r.  soc",
    ".  london * b266 * , 859 ( 1999 ) . m.  van baalen , `` pair approximations for different spatial geometries '' , in _ the geometry of ecological interactions : simplifying spatial complexity _",
    "( u.  dieckmann , r.  law , j.  a.  j.  metz , ( eds . ) , cambridge university press , cambridge ) , 359 ( 2000 ) .",
    "m.  e.  alexander , s.  m.  dietrich , y.  hua , and s.  m.  moghadas , journal of theoretical biology * 259 * , 253 ( 2009 ) ."
  ],
  "abstract_text": [
    "<S> the pair approximation is a simple , low  order method to incorporate effects of local spatial structure in epidemiological models . </S>",
    "<S> however , since for @xmath0 state variables in a model there are @xmath1 equations in the pair approximation , generating these equations , although straightforward , can become tedious . in this paper </S>",
    "<S> we describe two programs written in perl to simplify this process  one to construct the equations , and the other to generate matlab / octave functions to numerically integrate the equations using a positivity - preserving method . a third utility program is also included which generates a maple file that can be used within the maple symbolic manipulation program to simplify algebraically some of the terms in the generated file describing the equations , as well as to check that the usual combination of equations sum up to zero , which is expected in cases where the total population sizes are conserved . </S>"
  ]
}