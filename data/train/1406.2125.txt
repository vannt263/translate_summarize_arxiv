{
  "article_text": [
    "xml , the extensible markup language @xcite , is today one of the most used formats to save and exchange structured data .",
    "being a recommendation of the world wide web consortium ( w3c ) since 1998 , a large software ecosystem has been evolved , including data formats to specify the schema of xml documents .",
    "one of them is the xml schema definition ( xsd ) @xcite .",
    "since its proposal in 2006 , there is an alternative data format especially used in web services : json , the javascript object notation .",
    "its formal language to specify the format of a json document , called json schema , is still in draft status @xcite .",
    "although there are validation tools implementing the ietf draft , the number of json schemas used in practice is still moderate .",
    "one of the reasons is that there is currently no mechanism to translate an already existing xml schema into equivalent json schema .    as an application of xml , xsd documents are valid xml instances .",
    "although json schema is json - based as well , the naive approach of using an already existing xml to json translator as published by @xcite would not result in a valid json schema document . to satisfy the core meta - schema @xcite",
    ", the demanded translator has to provide some additional logic , extending the general problems of translating xml to json instances as presented in @xcite .    in this paper",
    ", we propose an approach for an xsd to json schema language translator based on prolog and constraint handling rules ( chr ) @xcite .",
    "the translator unfolds a given xml schema into chr constraints . by creating a chr constraint for every xsd node it is possible to specify the concrete translation rules of common xml schema fragments in a declarative way in form of chr rules .",
    "the paper is organized as follows . in section [ preliminaries ] , we will give an example to illustrate the problem and we will determine the considered versions of the xsd and json schema specifications .",
    "the paper continues by presenting the introduced chr constraints . in section [ translation_process ]",
    "the overall translation process is presented .",
    "finally , the paper ends with concluding remarks in section [ conclusion ] .",
    "the aim of this work is to create a prolog / chr module that offers a predicate ` xsd2json(xsd , json ) ` which holds the equivalent json schema as ` json ` for a given ` xsd ` instance . before getting into the concrete translation process we want to introduce the used techniques and specify the scope of this tool . in what follows",
    "we explain the problem instance by giving an example of a simple xsd and its expected translated json schema equivalent .      following the formal description of the xml schema language @xcite , an xml schema consists of four components : elements ( ` xs : element ` nodes ) , simple types ( ` xs : simpletype ` nodes ) , complex types ( ` xs : complextype ` nodes ) and attributes ( ` xs : attribute ` nodes ) .",
    "because the also introduced attribute groups and model groups are only placeholders in complex type definitions , we will omit those components for our translator . in section [ fragment_translation ] ,",
    "we will introduce translation rules for each of the four given components , depending on their structure and values .    although the xml schema 1.1 specification has been the official w3c recommendation since april 2012 , we restrict ourselves to the xml schema 1.0 specification .",
    "the more up - to - date specification primarily introduces conditional types and assertions based on xpath expressions .",
    "since there is currently no xpath equivalent for json , it would not be possible to translate those new xpath - based elements at all .",
    "for the target language json schema we refer to the latest version of the specification , draft 04 @xcite , which is already supported by a number of json validators in multiple languages .",
    "a list of current implementations can be found in @xcite .      as a motivating example",
    ", we will consider a small xml document , as shown in figure [ xml_example ] , and its related xsd , as specified in figure [ xsd_example ] .    ....",
    "xml version=\"1.0 \" ? > < percentages >    < value>99</value >    < value>42</value >",
    "< value>0</value > <",
    "/percentages > ....    .... {    \" value \" : [ 99 , 42 , 0 ] } ....    the aim of the language translator is to create an equivalent json schema of the xsd given in figure [ xsd_example ] .",
    "it should respect the following the semantics :    * there is a list of values . *",
    "the list contains at most five values .",
    "* every value must be a nonnegative integer .",
    "following the xsd specification in @xcite , there is additional information implicitly given : by omitting the ` minoccurs ` attribute in an ` xs : element ` within an ` xs : sequence ` its default value ` 1 ` is used , so the list has to contain at least one value .",
    "the equivalent json schema that ensures these constraints is shown in figure [ jsv_example ] and its corresponding json document in figure [ json_example ] .",
    "the ` percentages ` node of the xml document has no equivalent in the json schema instance .",
    "this is caused by the circumstance that the ` percentages ` element adds no constraints and therefore might only be used to create a valid xml document , which requires a single root element .",
    "the language translator uses such assumptions to create a simple , but appropriate json schema .",
    "to provide translation rules for concrete xsd fragments , we use a combination of the logic programming languages prolog and chr @xcite@xcite .",
    "this enables us to specify the translation rules in a declarative way .",
    "since for each xsd node a new chr constraint will be generated , it is possible to create chr rules referencing constraints by their characteristics without having to implement the tree traversal of the xsd document .",
    "we use chr with prolog as its host language . the suggested implementation can be found online at https://github.com/fnogatz/xsd2json and has been tested with the chr library for swi - prolog @xcite . to hold the information of a given xsd term we introduce the following chr constraints :    * ` node(namespace , name , id , children_ids , parent_id ) ` + for each xml node in the xsd document a new ` node/5 ` constraint is generated , holding its namespace and tag name . to obtain a reference",
    ", a unique identifier is added as well as the list of its parent s and children s identifiers . * ` node_attribute(id , key , value , source ) ` + for each xsd attribute a new ` node_attribute/4 ` constraint is propagated , holding its name as ` key ` , its ` value ` and the identifier of the related ` node/5 ` constraint .",
    "the ` source ` is ` source ` for explicitly set and ` default ` for inherited attributes .",
    "for example ` maxoccurs=5 ` of the innermost ` xs : element ` of figure [ xsd_example ] is mapped to a constraint ` node_attribute(_id , maxoccurs,5,source ) ` . * ` text_node(id , text , parent_id ) ` + if an element s child is simply a text and no nested xml node , a ` text_node/3 ` constraint is generated .",
    "it gets a unique identifier like a regular child node and holds the text as well as the identifier of its parent element .",
    "all translated fragments are stored in ` json(id , json ) ` constraints , holding the ` json ` schema of the xsd node with the identifier ` i d ` .",
    "because the entire json schema is built step by step , the innermost fragments of the xsd propagate the first ` json/2 ` constraints .",
    "these will be picked up for the translation of their parent elements , resulting in a json schema for the entire xsd .    ....",
    "xml version=\"1.0 \" ?",
    "> < xs : schema    xmlns : xs=\"http://www.w3.org/2001/xmlschema \" >    < xs : element name=\"percentages \" >      < xs",
    ": complextype >        < xs : sequence >          < xs : element            name=\"value \"            maxoccurs=\"5 \"            type=\"xs : nonnegativeinteger \" / >",
    "< /xs : sequence >      < /xs : complextype >    < /xs : element > < /xs : schema > ....    .... {    \" type \" : \" object \" ,    \" properties \" : {      \" value \" : {        \" type \" : \" array \" ,        \" items \" : {          \" type \" : \" integer \" ,          \" minimum \" : 0 ,           \" exclusiveminimum \" : false        } ,        \" minitems \" : 1 ,        \" maxitems \" : 5      }    } ,    \" required \" : [ \" value \" ] } ....",
    "the overall translation process can be split into six subtasks as illustrated in figure [ fig : translation : steps ] .",
    "the different steps can be distinguished by their function as well as by the used programming language .        in the following",
    "we will present the various steps .",
    "the main part of the translator , the translation rules of xsd fragments , is introduced in section [ fragment_translation ] .",
    "swi - prolog provides a wide support for working with xml documents . by use of its sgml / xml parser @xcite",
    ", an xsd document can be read in as a nested prolog term .",
    "figure [ lst : xsdprolog ] shows the term generated by the built - in ` load_structure/3 ` predicate @xcite for the xsd of figure [ xsd_example ] .    ....",
    "[ element (      ' http://www.w3.org/2001/xmlschema':schema ,         % namespace and name      [ xmlns : xs='http://www.w3.org/2001/xmlschema ' ] ,   % attributes      [ element (                                         % nested elements          ' http://www.w3.org/2001/xmlschema':element ,          [ name = percentages ] ,                          % attributes          [ ... ] )                                % the other nested elements      ] ) ] ....      this nested prolog term can be traversed recursively to propagate the related ` node/5 ` , ` node_attribute/4 ` and ` text_node/3 ` constraints .",
    "their positions are retained by their unique identifiers and references to parent and child nodes .",
    "because prolog s xml parser will only read in explicitly set attributes , we have to add the default attributes as shown in section [ problem_example ] .",
    "the translation rules used in the next step refer to attributes like ` minoccurs ` and ` maxoccurs ` , which can be omitted . to ensure these optional attributes are always present , we propagate a ` node_attribute/4 ` with the ` source ` set to ` default ` , as mentioned in section [ chr_constraints ] .",
    "if there is an identical ` node_attribute/4 ` constraint with its last component set to ` source ` , the default one is removed by a chr simpagation rule .      before examining the most important step",
    ", we will have to a look at the intended result of the overall translation process : a prolog representation of json schema .",
    "like for xml , swi - prolog comes with a library to serialize json . with the ` http / json ` library @xcite a json object",
    "is represented by ` json(l ) ` , in which ` l ` is a list of the form ` [ key1=value1,key2=value2 ,  ] ` .",
    "json arrays are represented by prolog lists .    referring to the constraints propagated in the steps before",
    ", we can translate xsd fragments to their equivalent json schema .",
    "all translation rules follow the same form : they propagate a single ` json/2 ` constraint that holds the json schema of this xsd fragment ; the guard ensures that all ` node/5 ` and ` node_attribute/4 ` constraints are of the xml schema namespace .",
    "the rule s head contains the following parts :    * the ` node/5 ` constraint for which the ` json/2 ` representation is generated . in most cases its children s ` node/5 ` constraints",
    "are referenced by using the ` parent_id ` component .",
    "* some ` node_attribute/4 ` and ` text_node/3 ` constraints , depending on the xsd fragment that has to be translated . * some ` json/2 ` constraints to merge already translated fragments .",
    "this way it is possible to generate the json schema translation of an xsd node by combining the translations of its child nodes .",
    "hereby the propagation rule to generate the json schema for the innermost ` xs : element ` of figure [ xsd_example ] is :    .... node(ns , element , id,_c,_parent ) , node_attribute(id , type , with_ns , _ )    = = > xsd_namespace(ns ) , valid_xsd_type(with_ns , type )    |    convert_xsd_type(type , json ) , json(id , json ) . ....",
    "this rule applies if the ` xs : element ` node has an xsd namespace and is of a primitive xsd data type .",
    "xml schema provides various predefined data types .",
    "although the number of data types defined for json is limited , it is possible to restrict them similarly to constraining facets @xcite in xsd .",
    "therefore we can define a ` convert_xsd_type/2 ` predicate by providing json s equivalents of all predefined xml data types like in table [ tbl : rules : types ] in excerpts .",
    ".translation of simple xsd data types ( extract of @xcite ) [ cols=\"^,^\",options=\"header \" , ]     xsd s primitive data types can be restricted by constraining facets @xcite , for example to specify all possible values for a string .",
    "these facets can be translated by using a similar table of equivalents , which are collected in @xcite .",
    "the primitive data types and constraining facets apply only to ` xs : attribute ` and certain ` xs : element ` nodes . however , an xsd is more than the definition of simple types : via ` xs : complextype ` nodes attributes of elements can be specified as well as their child nodes",
    ". the occurence of ` xs : element ` within an ` xs : sequence ` as shown in figure [ xsd_example ] is a common structure in xsd documents .",
    "therefore we have to translate nested xsd nodes as the last part of this step .",
    "the general approach has already been introduced before : depending on specific ` node/5 ` , ` node_attribute/4 ` and ` text_node/3 ` constraints and sometimes already translated fragments given as ` json/2 ` constraints , we compose the translation of an xsd node .    as an example we introduce the actual translation rule for the nested`xs : sequence`/`xs : element ` structure of the example in figure [ xsd_example ] :    .... node(ns1,sequence , sequence_id,_sc,_sp ) , node(ns2,element , el_id,_ec , sequence_id ) ,      json(el_id , element_json ) , node_attribute(el_id , name , element_name , _ )      node_attribute(el_id , minoccurs , minoccurs,_o ) ,       % _ o to match both origins      node_attribute(el_id , maxoccurs , maxoccurs,_o ) ,       %    ' default ' and ' source '    = = >      xsd_namespace(ns1 ) , xsd_namespace(ns2 )              % valid xsd namespaces ?",
    "| json = [ type = object ,                               % build json object               properties = json ( [                 element_name = json ( [ type = array ,                                     items = element_json ,                                     minitems = minoccurs ,                                     maxitems = maxoccurs                 ] ) ] ) ] ,      ( minoccurs_number > = 1 , full_json = [ required=[element_name]|json ] ;        minoccurs_number < 1 , full_json = json ) ,          % required property ?",
    "json(sequence_id , json(full_json ) ) .",
    "% propagate json ....    many applications of nested structures have been identified , documented in @xcite and implemented by similar propagation rules . because a ` node/5 ` constraint might apply to multiple chr rules",
    ", there can be various ` json/2 ` constraints with the same identifier .",
    "these are merged by a simpagation rule with the help of a self - defined ` merge_json ` prolog predicate .",
    "the previous step terminates as soon as the root element of the given xsd has been translated and its ` json/2 ` constraints have been merged .",
    "in addition the globally defined type definitions are merged into the ` definitions ` object of the root s",
    "` json/2 ` constraint .",
    "finally , the created json schema object is cleaned up : in the creation process , the names of xml attributes ( specified as ` xs : attribute ` in the xsd ) were prefixed with an ` @ ` symbol . if there is no ` xs : element ` in this ` xs : complextype ` with the same name , the attribute s ` @`-prefix is removed .",
    "in this work , a language translator to convert xml schema to an equivalent json schema was implemented .",
    "the entire implementation is available online at https://github.com/fnogatz/xsd2json , its detailed concept can be found in @xcite . as the ` xsd2json ` prolog / chr module was developed in a bottom - up approach , it also provides a test framework and a large number of test cases .",
    "the ` xsd2json ` module is still under development to be applicable for all xml schema instances . due to the lack of various features in json schema it might not be possible to support all constraining semantics . for example",
    ", there is currently no xpath - like way to address a specific property inside a nested json document .",
    "therefore , the xsd elements ` xs : key ` , ` xs : keyref ` and ` xs : unique ` can not be supported as well as the new features like ` xs : assertion ` introduced by the most up - to - date xml schema 1.1 specification .",
    "another missing feature is the handling of referenced xsd documents .",
    "while the current implementation respects multiple namespaces , it translates only a single file .",
    "therefore ` xs : import ` and ` xs : include ` are not supported ."
  ],
  "abstract_text": [
    "<S> despite its rising popularity as data format especially for web services , the software ecosystem around the javascript object notation ( json ) is not as widely distributed as that of xml . for both data formats there exist schema languages to specify the structure of instance documents , but there is currently no opportunity to translate already existing xml schema documents into equivalent json schemas .    in this paper </S>",
    "<S> we introduce an implementation of a language translator . </S>",
    "<S> it takes an xml schema and creates its equivalent json schema document . </S>",
    "<S> our approach is based on prolog and chr . by unfolding the xml schema document into chr constraints , </S>",
    "<S> it is possible to specify the concrete translation rules in a declarative way .    </S>",
    "<S> constraint handling rules , language translator , xml schema , xsd , json schema </S>"
  ]
}