{
  "article_text": [
    "lattice - based cryptography has become a very hot research topic recently with the emergence of new applications to homomorphic encryption .",
    "the hardness of the ring - lwe problem was related to various well - known hard lattice problems  @xcite , and the hardness of the poly - lwe problem was reduced to ring - lwe in  @xcite .",
    "the hardness of the poly - lwe problem is used as the basis of security for numerous cryptosystems , including  @xcite .",
    "the hardness of ring - lwe was also shown @xcite to form a basis for the proof of security of a variant of ntru @xcite .    in  @xcite , the first weaknesses in the poly - lwe problem were discovered for classes of number fields satisfying certain properties .",
    "in addition , a list of properties of number fields were identified which are sufficient to guarantee a reduction between the ring - lwe and the poly - lwe problems , and a search - to - decision reduction for ring - lwe .",
    "unfortunately , in  @xcite , no number fields were found which satisfied both the conditions for the attack and for the reductions .",
    "thus  @xcite produced only examples of number fields which were weak instances for poly - lwe .",
    "the contributions of this paper at a high level are as follows : in section  [ sec : attack ] we strengthen and extend the attacks presented in  @xcite in several significant ways . in section [ sec : moving ] , most importantly , we show how the attacks can be applied also to the ring - lwe problem . in section  [ sec : provable ] , we construct an explicit family of number fields for which we have an efficient attack on the decision ring - lwe problem .",
    "this represents the first successful attacks on the decision ring - lwe problem for number fields with special properties . for galois number fields , we also know that an attack on the decision problem gives an attack on the search version of ring - lwe ( @xcite ) .",
    "in addition , in section  [ sec : exampleattack ] , we present the first successful implementation of the ehl attack at cryptographic sizes and attack both ring - lwe and poly - lwe instances .",
    "for example for @xmath3 and @xmath4 , the attack runs in about 13 hours .",
    "code for the attack is given in appendix [ sec : code ] . in section",
    "[ sec : heuristic ] we give a more general construction of number fields such that heuristically a large percentage of them will be vulnerable to the attacks on ring - lwe .    in more detail",
    ", we consider rings of integers in number fields @xmath5/(f(x))$ ] of degree @xmath6 , modulo a large prime number @xmath0 , and we give attacks on poly - lwe which work when @xmath7 has a root of small order modulo @xmath0 .",
    "the possibility of such an attack was mentioned in  @xcite but not explored further . in sections [ sec : smallset ] and [ sec : smallerror ] , we give _ two _ algorithms for this attack , and in sections [ sec : ex1 ] and [ sec : ex2 ] we give many examples of number fields and moduli , some of cryptographic size , which are vulnerable to this attack .",
    "the most significant consequence of the attack is the construction of the number fields which are weak for the ring - lwe problem ( section [ sec : heuristic ] ) .    to understand the vulnerability of ring - lwe to these attacks , we state and examine the ring - lwe problem for general number rings and demonstrate _ provably weak instances _ of ring - lwe .",
    "we demonstrate the attack in both theory and practice for an explicit family of number fields , providing code and running times for the attack .",
    "the attack runs in time linear in @xmath0 , where @xmath0 is the modulus .",
    "the essential point is that ring - lwe instances can be mapped into poly - lwe instances , and if the map does not distort the error too much , then the instances may be vulnerable to attacks on poly - lwe .",
    "the distortion is governed by the spectral norm of the map , and we compute the spectral norm for the explicit family we construct in section  [ sec : provable ] and analyze when the attack will succeed . for the provably weak family which we construct ,",
    "the feasibility of the attack depends on the ratio of @xmath8 .",
    "we prove that the attack succeeds when @xmath8 is above a certain bound , but in practice we find that we can attack instances where the ratio is almost @xmath9 times smaller than that bound . even for ring - lwe examples which are not taken from the provably weak family , we were able to attack in practice relatively generic instances of number fields where the spectral norm was small enough ( see section  [ sec : exampleattack ] ) .",
    "we investigate cyclotomic fields ( even @xmath1-power cyclotomic fields ) given by an alternate minimal polynomial , which are weak instances of poly - lwe for that choice of polynomial basis .",
    "section [ sec : ex2 ] contains numerous examples of @xmath1-power cyclotomic fields which are vulnerable to attack when instantiated using an alternative polynomial basis , thus showing the heavy dependence in the hardness of these lattice - based problems on the choice of polynomial basis .",
    "in addition , we analyze the case of cyclotomic fields to understand their potential vulnerability to these lines of attack and we explain why cyclotomic fields are immune to attacks based on roots of small order ( section [ sec : cyc ] ) .",
    "finally , we provide code in the form of simple routines in sage to implement the attacks and algorithms given in this paper and demonstrate successful attacks with running times ( section [ sec : exampleattack ] ) .    as a consequence of our results",
    ", one can conclude that the hardness of ring - lwe is both _",
    "dependent on special properties of the number field _ and _ sensitive to the particular choice of @xmath0 _ , and some choices may be significantly weaker than others .",
    "in addition , for applications to cryptography , since our attacks on poly - lwe run in time roughly @xmath10 and may be applicable to a wide range of fields , including even @xmath1-power cyclotomic fields with a bad choice of polynomial basis , these attacks should be taken into consideration when selecting parameters for poly - lwe - based systems such as  @xcite and other variants . for many important applications to homomorphic encryption",
    "( see for example  @xcite ) , these attacks will not be relevant , since the modulus @xmath0 is chosen large enough to allow for significant error growth in computation , and would typically be of size @xmath11 bits up to @xmath12 bits .",
    "for that range , the attacks presented in this paper would not run .",
    "however , in other applications of ring - lwe to key exchange for the tls protocol  @xcite , parameters for achieving @xmath11-bit security are suggested where @xmath13 and @xmath14 , with @xmath15 , and these parameters would certainly be vulnerable to our attacks for weak choices of fields and @xmath0 .",
    "* acknowledgements . *",
    "the authors are indebted to the organizers of the research conference women in numbers 3 ( rachel pries , ling long and the fourth author ) , as well as to the banff international research station , for bringing together this collaboration .",
    "they would also like to thank hao chen for his careful reading of the manuscript , correcting typos , and for providing an improved argument in section [ sec : hs ] .",
    "finally , the authors thank martin albrecht for help with sage .",
    "let @xmath7 be a monic irreducible polynomial in @xmath16 $ ] of degree @xmath6 , and let @xmath0 be a prime such that @xmath7 factors completely modulo @xmath0 .",
    "let @xmath17/f(x)$ ] and let @xmath18/f(x)$ ] .",
    "let @xmath19 .",
    "the uniform distribution on @xmath20 will be denoted @xmath21 . by _ gaussian distribution of parameter @xmath22 _ we refer to a discrete gaussian distribution of mean @xmath23 and variance @xmath24 on @xmath25 , spherical with respect to the power basis .",
    "this will be denoted @xmath26 .",
    "it is important to our analysis that we assume that in practice , elements are sampled from gaussians of parameter @xmath22 truncated at width @xmath27 .",
    "there are two standard poly - lwe problems .",
    "our attack solves the _ decision _ variant , but it also provides information about the secret .    [ plwed ] let @xmath28 be a secret .",
    "decision poly - lwe problem _ is to distinguish , with non - negligible advantage , between the same number of independent samples in two distributions on @xmath29 .",
    "the first consists of samples of the form @xmath30 where @xmath31 is drawn from a discrete gaussian distribution of parameter @xmath22 , and @xmath32 is uniformly random .",
    "the second consists of uniformly random and independent samples from @xmath33 .",
    "[ plwes ] let @xmath28 be a secret .",
    "the _ search poly - lwe problem _",
    ", is to discover @xmath34 given access to arbitrarily many independent samples of the form @xmath35 where @xmath31 is drawn from a discrete gaussian of parameter @xmath22 , and @xmath32 is uniformly random .",
    "the polynomial @xmath36 is called the _ secret _ and the polynomials @xmath37 are called the _ errors_.      the selection of parameters for security is not yet a well - explored topic . generally parameter recommendations for poly - lwe and ring - lwe",
    "are just based on the recommendations for general lwe , ignoring the extra ring structure e.g. @xcite .",
    "sample concrete parameter choices have been suggested , where @xmath38 is the width of the gaussian error distribution ( precisely , @xmath39 ) :    1 .",
    "@xmath40 , @xmath41 , @xmath42 for low , medium and high security , recommended by lindner and peikert in @xcite ; 2 .",
    "@xmath43 for high security used in @xcite ; 3 .",
    "@xmath44 suggested in @xcite for the tls protocol .",
    "here , @xmath45 was actually suggested but it is not prime . here , the authors remark that @xmath0 is taken to be large for correctness but could potentially be decreased .",
    "the attack we are concerned with is quite simple .",
    "it proceeds in four stages :    1 .   transfer the problem to @xmath46 via a ring homomorphism @xmath47 .",
    "2 .   loop through guesses for the possible images @xmath48 of the secret .",
    "3 .   obtain the values @xmath49 under the assumption that the guess at hand is correct .",
    "4 .   examine the distribution of the @xmath49 to determine if it is gaussian or uniform .    if @xmath50 is assumed to have a root @xmath51 or @xmath52 of small order modulo @xmath0 , then this attack is due to eisentraeger - hallgren - lauter @xcite .",
    "the first part is to transfer the problem to @xmath46 .",
    "write @xmath53 for the factorization of @xmath7 over @xmath46 which is possible by assumption . by the chinese remainder theorem ,",
    "if @xmath50 has no double roots , then @xmath54/(x-\\alpha_i ) \\simeq { \\mathbb{f}}_q^n\\ ] ] there are @xmath6 ring homomorphisms @xmath55/(x-\\alpha_i ) \\simeq { \\mathbb{f}}_q , \\quad g(x ) \\mapsto g(\\alpha_i).\\ ] ] fix one of these , by specifying a root @xmath56 of @xmath7 in @xmath46 .",
    "apply the homomorphism to the coordinates of the @xmath57 samples @xmath58 , obtaining @xmath59 .",
    "next , loop through all @xmath60 .",
    "each value @xmath61 is to be considered a guess for the value of @xmath62 . for each guess @xmath61 , assuming that it is a correct guess and @xmath63 , then @xmath64 in the case that the samples were lwe samples and the guess was correct , then this produces a collection @xmath65 of images of errors chosen according to some distribution . if the distributions @xmath66 and @xmath67 are distinguishable , then we can determine whether the distribution was uniform or gaussian . note that @xmath66 will of course be uniform on @xmath46 . if our guess is incorrect , or if the samples are not lwe samples , then the distribution will appear uniform .",
    "therefore , after looping through all guesses , if all the distributions appeared uniform , then conclude that the samples were not lwe samples ; whereas if one of the guesses worked for all samples and always yielded an error distribution which appeared gaussian , assume that particular @xmath61 was a correct guess . in the latter case",
    "this also yields one piece of information about the secret : @xmath68 .",
    "the attack _ will _ succeed whenever    1 .",
    "@xmath0 is small enough to allow looping through @xmath46 , 2 .",
    "@xmath66 and @xmath67 are distinguishable .",
    "our analysis hinges on the difficulty of distinguishing @xmath66 from @xmath67 , as a function of the parameters @xmath22 , @xmath6 , @xmath57 , @xmath0 , and @xmath50 .",
    "distinguishability becomes easier when @xmath22 is smaller ( so @xmath21 and @xmath69 are farther apart to begin with ) , @xmath6 is smaller and @xmath0 is larger ( since then less information is lost in the map @xmath70 ) , and @xmath57 is larger ( since there are more samples to test the distributions ) . the dependence on @xmath50 comes primarily as a function of its roots @xmath71 modulo @xmath0 , which may have properties that make distinguishing easier .    ideally , for higher security , one will choose parameters that make distinguishing nearly impossible , i.e. such that @xmath67 appears very close to uniform modulo @xmath0 . +",
    "* example .",
    "( @xcite ) * we illustrate the attack in the simplest case @xmath72 .",
    "assume @xmath73 , and consider the distinguishability of the two distributions @xmath74 and @xmath75 .",
    "given @xmath58 , make a guess @xmath76 for the value of @xmath77 and compute @xmath78 . if @xmath79 is uniform , then @xmath80 is uniform for all @xmath61 .",
    "if @xmath81 , then there is a guess @xmath61 for which @xmath82 where @xmath83 and @xmath84 . since @xmath85 , where @xmath86 are chosen from @xmath69",
    ", it follows that @xmath87 are sampled from @xmath88 where @xmath89 .",
    "the attack can be described loosely as follows : for each sample , test each guess @xmath61 in @xmath46 to see if @xmath80 is small modulo @xmath0 , and only keep those guesses which pass the test .",
    "repeat with the next sample and continue to keep only the guesses which pass .      in this section",
    ", we assume that there exists a root @xmath52 of @xmath50 such that @xmath52 has small order @xmath90 modulo @xmath0 , that is @xmath91 . then @xmath92",
    "if @xmath90 is small enough , then @xmath93 takes on only a small number of values modulo @xmath0 .",
    "if so , then we can efficiently distinguish whether a value modulo @xmath0 belongs to that subset .",
    "let @xmath94 be the set of possible values of @xmath93 modulo @xmath0 .",
    "we assume for simplicity that @xmath6 is divisible by @xmath90 . then the coefficients @xmath95 of fall into a subset of @xmath96 of size at most @xmath97 .",
    "we sum over @xmath90 terms , hence , @xmath98 residues modulo @xmath0 .",
    "for @xmath99 , this becomes @xmath100 .",
    "the attack described below succeeds with high probability if @xmath101 , that is @xmath102    a collection of @xmath57 poly - lwe samples .",
    "* output : * a guess @xmath61 for @xmath62 , the value of the secret polynomial at @xmath52 ; or else * not plwe * ; or _ * insufficient samples*_.    the value * not plwe * indicates that the collection of samples were definitely not poly - lwe samples .",
    "the value * insufficient samples * indicates that there were not enough samples to determine a single guess @xmath62 . in this case",
    ", the algorithm may be continued on a new set of samples by looping the remaining surviving guesses on the new samples .",
    "create an ordered list of elements of @xmath94 .",
    "let @xmath103 be an empty list .",
    "* for * @xmath61 from @xmath23 to @xmath104 * do *    @xmath105 in the collection of samples * do *    @xmath106 does not equal an element of @xmath94 * then *    ( i.e. begin next value of @xmath61 )    append @xmath61 to @xmath103 ( note : occurs only if the loop of samples completed without a break )    * if * @xmath103 is empty * then *    return * not plwe *    * if * @xmath107 * then *    return @xmath61    * if * @xmath108 * then *    return * insufficient samples *    [ prop : smallset ] assume that @xmath109 algorithm  [ alg : smallset ] terminates in time at most @xmath110 , where the @xmath111 notation hides the @xmath112 factors and the implied constant depends upon @xmath90 . furthermore ,",
    "if the algorithm returns * not plwe * , then the samples were not valid poly - lwe samples .",
    "if it outputs anything other than * not plwe * , then the samples are valid poly - lwe samples with probability @xmath113 .",
    "in particular , this probability tends to @xmath114 as @xmath57 grows .    as discussed above",
    ", there are at most @xmath0 possible values for the elements of @xmath94 under the assumption . to compute each one takes @xmath6 additions per coefficient ( of which there are @xmath90 ) , combined with an additional @xmath90 multiplications and @xmath90 additions .",
    "( here we have assumed the @xmath115 have been computed ; this takes @xmath90 multiplications . )",
    "each addition or multiplication takes time at most @xmath116 .",
    "therefore , computing @xmath94 takes time at most @xmath117 . for sorting ,",
    "it is best to sort as @xmath94 is computed ; placing each element correctly takes @xmath116 time .",
    "the principal double loop takes time at most @xmath118 .",
    "if @xmath119 and @xmath120 are precomputed , then for each guess @xmath61 , the computation of @xmath106 only costs one multiplication and one subtraction modulo @xmath0 ( i.e. @xmath121 ) while it requires only @xmath116 bit comparisons to decide whether this is in the set @xmath94 .    in step 4 , for later samples ,",
    "only guesses which were successful in the previous samples ( i.e. gave a value which was in the set @xmath94 ) are considered . for a sample chosen uniformly at random",
    ", one expects the number of successful guesses to be roughly @xmath122 .",
    "thus for the second sample , we repeat the above test for only @xmath123 guesses . at the @xmath124 sample , retaining only guesses which were successful for all previous samples , we expect to test only @xmath125 guesses , which very quickly goes to zero . hence",
    ", if we examine @xmath57 samples , our tolerance for false positives is proportional to @xmath126 .      in this section ,",
    "we describe the most general @xmath47 attack on the poly - lwe problem , one which can be carried out in any situation .",
    "the rub is that the probability of success will be vanishingly small unless we are in a very special situation .",
    "therefore our analysis actually bolsters the security of poly - lwe .",
    "suppose that @xmath127 .",
    "let @xmath128 be the event that @xmath129 is in the interval @xmath130 for some sample @xmath131 and guess @xmath61 for @xmath132 .",
    "the main idea is to compare @xmath133 and @xmath134 if @xmath135 , then @xmath136 is random modulo @xmath137 for all guesses @xmath138 , that is , @xmath139 if @xmath140 , then @xmath141 . we consider @xmath142 where @xmath86 is chosen according to the distribution @xmath69 ( truncated at @xmath143 ) and distinguish two cases :    1 .",
    "@xmath144 [ one ] 2 .",
    "@xmath145 and @xmath52 has small order @xmath146 modulo @xmath137 [ two ]    * case 1 * ( @xmath144 ) .",
    "the error @xmath147 is chosen according to the distribution @xmath148 truncated at @xmath149 .",
    "hence @xmath150 therefore , assuming that @xmath151 we obtain @xmath152 for @xmath63 . hence @xmath21 and @xmath26 are distinguishable .    * case 2 * ( @xmath145 and @xmath52 has small order @xmath146 modulo @xmath137 )",
    ".    the error can be written as @xmath153 where we assume that @xmath6 is divisible by @xmath90 for simplicity .",
    "for @xmath154 we have that @xmath155 is chosen according to the distribution @xmath156 . as a consequence @xmath93",
    "is sampled from @xmath157 where @xmath158 hence @xmath159 therefore , assuming that @xmath160 we obtain @xmath152 for @xmath63 , and uniform and gaussian are distinguishable .",
    "note that hypothesis implies in particular that @xmath161 . +    a collection of @xmath57 poly - lwe samples .",
    "* output : * a guess @xmath61 for @xmath62 ; or else * not plwe * ; or * insufficient samples*.    the output * insufficient samples * indicates that more samples are needed to make a determination . in this case , the algorithm can be continued by looping through remaining surviving guesses on new samples .",
    "let @xmath103 be an empty list .",
    "* for * @xmath61 from @xmath114 to @xmath104 * do *    @xmath105 in the collection of samples * do *    the minimal residue @xmath106 does not lie in @xmath162 * then *    ( i.e. begin next value of @xmath61 )    append @xmath61 to @xmath103 ( note : occurs only if the loop of samples completed without a break )    * if * @xmath103 is empty * then *    return * not plwe *    * if * @xmath107 * then *    return @xmath61    * if * @xmath108 * then *    return * insufficient samples *    in each of the two cases , we have given conditions on the size of @xmath22 under which @xmath21 and @xmath26 are distinguishable and an attack is likely to succeed .",
    "we now elaborate on the algorithm that would be used .",
    "we denote by @xmath57 the number of samples observed . for each guess @xmath61",
    "mod @xmath0 , we compute @xmath163 for @xmath164 .",
    "if there is a guess @xmath61 mod @xmath0 for which the event @xmath128 occurs for all @xmath165 , then the algorithm returns the guess if it is unique and * insufficient samples * otherwise ; the samples are likely valid poly - lwe samples . otherwise , it reports that they are certainly not valid poly - lwe samples .",
    "[ prop : smallerror ] assume that we are in one of the following cases :    1 .",
    "@xmath144 and @xmath166 2 .",
    "@xmath52 has small order @xmath146 modulo @xmath137 , and @xmath167    then algorithm  [ alg : smallerror ] terminates in time at most @xmath118 , where the implied constant is absolute .",
    "furthermore , if the algorithm returns * not plwe * , then the samples were not valid poly - lwe samples .",
    "if it outputs anything other than * not plwe * , then the samples are valid poly - lwe samples with probability at least @xmath168 .",
    "the proof is as in proposition [ prop : smallset ] , without the first few steps .",
    "we remark that propositions and algorithms [ prop : smallset ] and [ prop : smallerror ] overlap in some cases . for @xmath169 , algorithm",
    "[ alg : smallerror ] is more applicable ( i.e. more parameter choices are susceptible ) , while for @xmath52 of other small orders , algorithm [ alg : smallset ] is more applicable .",
    "we use the term poly - lwe to refer to lwe problems generated by working in a polynomial ring , and reserve the term ring - lwe for lwe problems generated by working with the canonical embedding of a number field as in @xcite . in the previous sections",
    "we have expanded upon eisentrger , hallgren and lauter s observation that for certain distributions on certain lattices given by poly - lwe , the ring structure presents a weakness",
    ". we will now consider whether it is possible to expand that analysis to lwe instances created through ring - lwe for number fields besides cyclotomic ones .    in particular",
    ", the necessary ingredient is that the distribution be such that under the ring homomorphisms of section [ sec : attack ] , the image of the errors is a ` small ' subset of @xmath96 , either the error values themselves are small , or they form a small , identifiable subset of @xmath96 . assuming a spherical gaussian in the canonical embedding of @xmath170 or @xmath171 , we describe a class of number fields for which this weakness occurs",
    ". a similar analysis would apply without the assumption that the distribution is spherical in the canonical embedding .    here , we setup the key players ( a number field and its canonical embedding , etc . ) for general number fields so that these definitions specialize to those in @xcite",
    ". there are some choices inherent in our setup : it may be possible to generalize ring - lwe to number fields in several different ways .",
    "we consider the two most natural ways .",
    "let @xmath172 be a number field of degree @xmath6 with ring of integers @xmath170 whose dual is @xmath171 .",
    "we will embed the field @xmath172 in @xmath173 . note that our setup is essentially that of @xcite , rather than @xcite , but the difference is notational .",
    "let @xmath174 be the @xmath6 embeddings of @xmath172 , ordered so that @xmath175 through @xmath176 are the @xmath177 real embeddings , and the remaining @xmath178 complex embeddings are paired in such a way that @xmath179 for @xmath180 ( i.e. list @xmath181 non - pairwise - conjugate embeddings and then list their conjugates following that ) .    define a map @xmath182 given by @xmath183 the image of @xmath172 is the @xmath184-span of @xmath185 for any basis @xmath186 for @xmath172 over @xmath184 .",
    "this is not the usual minkowski embedding , but it has the virtues that 1 ) the codomain is a real , not complex , vector space ; and 2 ) the spherical or elliptical gaussians used as error distributions in @xcite are , in our setup , spherical or elliptical with respect to the usual inner product .",
    "we denote the usual inner product by @xmath187 and the corresponding length by @xmath188 .",
    "it is related to the trace pairing on @xmath172 , i.e. @xmath189",
    ".    then @xmath170 and @xmath171 form lattices in @xmath173 .",
    "we define a _ ring - lwe error distribution _ to be a spherical gaussian distribution in @xmath173 .",
    "that is , for a parameter @xmath190 , define the _ continuous gaussian distribution function _",
    "@xmath191 $ ] by @xmath192",
    "this gives a distribution @xmath193 on @xmath194 , via the isomorphism @xmath195 to @xmath173 . by approximating @xmath194 by @xmath172 to sufficient precision ,",
    "this gives a distribution on @xmath172 .",
    "from this distribution we can generate the _ ring - lwe error distribution _ on @xmath170 , respectively @xmath171 , by taking a valid discretization @xmath196 , respectively @xmath197 , in the sense of @xcite .",
    "now we have at hand a lattice , @xmath170 , respectively @xmath171 , and a distribution on that lattice . the parameters ( particularly @xmath22 )",
    "are generally advised to be chosen so that this instance of lwe is secure against general attacks on lwe ( which do not depend on the extra structure endowed by the number theory ) .",
    "write @xmath198 and @xmath199 .",
    "the standard ring - lwe problems are as follows , where @xmath172 is taken to be a cyclotomic field @xcite .",
    "let @xmath200 be a secret .",
    "the _ average - case decision ring - lwe problem _",
    ", is to distinguish with non - negligible advantage between the same number of independent samples in two distributions on @xmath201 .",
    "the first consists of samples of the form @xmath202 where @xmath203 is drawn from @xmath204 and @xmath205 is uniformly random , and the second consists of uniformly random and independent samples from @xmath201 .",
    "let @xmath200 be a secret .",
    "the _ search ring - lwe problem _",
    ", is to discover @xmath34 given access to arbitrarily many independent samples of the form @xmath202 where @xmath203 is drawn from @xmath204 and @xmath205 is uniformly random .    in proposing general number field ring - lwe ,",
    "one of two avenues may be taken :    1 .   preserve these definitions exactly as they are stated , or 2 .",
    "eliminate the duals , i.e. replace every instance of @xmath171 with @xmath170 in the definitions above .    to distinguish these two possible definitions",
    ", we will refer to _ dual ring - lwe _ and _ non - dual ring - lwe_. lyubashevsky , peikert and regev remark that for cyclotomic fields , dual and non - dual ring - lwe lead to computationally equivalent problems ( * ? ? ?",
    "* section 3.3 ) .",
    "they go on to say that over cyclotomics , for implementation and efficiency reasons , dual ring - lwe is superior .",
    "generalising dual ring - lwe to general number fields is the most naive approach , but it presents the problem that working with the dual in a general number field may be difficult .",
    "still , it is possible there are families of accessible number fields for which this may be the desired avenue",
    ".    we will analyse the effect of the poly - lwe vulnerability on both of these candidate definitions .",
    "in fact , the analysis will highlight some potential differences in their security , already hinted at in the discussion in ( * ? ? ? * section 3.3 ) .",
    "suppose @xmath172 is a _ monogenic number field _",
    ", meaning that @xmath170 is isomorphic to a polynomial ring @xmath207/f(x)$ ] for some monic irreducible polynomial @xmath50 ( @xmath50 is a _ monogenic polynomial _ ) . in this case , we obtain @xmath208 , for some @xmath209 ( here , @xmath210 is a generator of the different ideal ) , so that @xmath211 and @xmath206 are related by a linear transformation .",
    "thus a ( dual or non - dual ) ring - lwe problem concerning the lattice @xmath206 or @xmath211 can be restated as a poly - lwe problem concerning @xmath25 .",
    "let @xmath52 be a root of @xmath50 .",
    "then @xmath170 is isomorphic to @xmath25 , via @xmath212 .",
    "an integral basis for @xmath170 is @xmath213 .",
    "an integral basis for @xmath171 is @xmath214 .",
    "let @xmath215 be the matrix whose columns are @xmath216 .",
    "let @xmath217 be the matrix whose columns are @xmath218 . if @xmath219 is a vector of coefficients representing some @xmath220 in terms of the basis @xmath221 for @xmath222 , then @xmath223 .",
    "in other words , @xmath224 is an isomorphism ( where @xmath25 is represented as vectors of coefficients ) .",
    "similarly , @xmath225 is an isomorphism .      given an @xmath226 matrix @xmath227 , its _ spectral norm _",
    "@xmath228 is equal to the largest singular value of @xmath227 .",
    "this is also equal to the largest radius of the image of a unit ball under @xmath227 .",
    "this last interpretation allows one to bound the image of a spherical gaussian distribution of parameter @xmath22 on the domain of @xmath227 by another of parameter @xmath229 on the codomain of @xmath227 ( in the sense that the image of the ball of radius @xmath22 will map into a ball of radius @xmath229 after application of @xmath227 ) .",
    "the spectral norm is bounded above by the frobenius norm , which is the @xmath230-norm on the @xmath231 matrix entries .",
    "the normalized spectral norm of @xmath227 is defined to be @xmath232 .",
    "the condition number of @xmath227 is @xmath233 .      via the isomorphism @xmath234",
    "( respectively @xmath235 ) , an instance of the non - dual ( respectively dual ) ring - lwe problem gives an instance of the poly - lwe problem in which the error distribution is the image of the error distribution in @xmath206 ( respectively @xmath211 ) .",
    "in general , this may be an elliptic gaussian distorted by the isomorphism .",
    "if the distortion is not too large , then it may be bounded by a spherical gaussian which is not too large . in that case , a solution to the poly - lwe problem with the new spherical gaussian error distribution may be possible .",
    "if so , it will yield a solution to the original ring - lwe problem .",
    "this is essentially the same reduction described in @xcite .",
    "however , those authors assume that the isomorphism is an orthogonal linear map ; we are loosening this condition .",
    "the essential question in this loosening is how much the gaussian distorts under the isomorphism .",
    "our contribution is an analysis of the particular basis change .",
    "this distortion is governed by the spectral norm @xmath236 of @xmath227 .",
    "if the continuous gaussian in @xmath173 is of parameter @xmath22 ( with respect to the standard basis of @xmath173 ) , then the new spherical gaussian bounding its image is of parameter @xmath237 with respect to @xmath25 ( in terms of the coefficient representation ) .",
    "the appropriate analysis for discrete gaussians is slightly more subtle .",
    "loosely speaking , we find that a ring - lwe instance is weak if the following three things occur :    1 .",
    "[ 7monogenic ] @xmath172 is monogenic .",
    "[ 7root ] @xmath50 satisfies @xmath238 .",
    "[ 7rho ] @xmath236 and @xmath22 are sufficiently small    the first condition guarantees the existence of appropriate isomorphisms to a polynomial ring ; the second and third are required for the poly - lwe attack to apply .",
    "the purpose of the third requirement is that the discrete gaussian distribution in @xmath173 transfers to give vectors @xmath31 in the polynomial ring having the property that @xmath239 lies in the range @xmath162 except with negligible probability ; this allows algorithm [ prop : smallerror ] and the conclusions of proposition [ prop : smallerror ] to apply .",
    "let us now state our main result .",
    "[ thm : redux ] let @xmath172 be a number field such that @xmath240 , and the ring of integers of @xmath172 is equal to @xmath241 $ ] .",
    "let @xmath50 be the minimal polynomial of @xmath242 and suppose @xmath0 is a prime such that @xmath50 has root @xmath114 modulo @xmath0 .",
    "finally , suppose that the spectral norm @xmath236 of @xmath243 satisfies @xmath244 then the non - dual ring - lwe decision problem for @xmath245 can be solved in time @xmath118 with probability @xmath246 , using a dataset of @xmath57 samples .    sampling a discrete gaussian with parameter @xmath22 results in vectors of norm at most @xmath247 except with probability at most @xmath248 ( * ? ? ?",
    "* lemma 2.8 ) . considering the latter to be negligible",
    ", then we can expect error vectors to satisfy @xmath249 and their images in the polynomial ring to satsify @xmath250 therefore , if @xmath251 then we may apply the attack of section [ sec : smallerror ] that assumes @xmath252 and that error vectors lie in @xmath162 .    in",
    "what follows , we find a family of polynomials satisfying the conditions of the theorem , and give heuristic arguments that such families are in fact very common .",
    "the other cases ( other than @xmath72 ) appear out - of - reach for now , simply because the bounds on @xmath236 are much more difficult to attain .",
    "we will not examine them closely .",
    "the parameters of section [ sec : parameters ] are used in implementations where the gaussian is taken over @xmath253 , and security depends upon the proportion of this space included in the ` bell , ' meaning , it depends upon the ratio @xmath254 . in the case of poly - lwe , sampling is done on the coefficients , which are effectively living in the space @xmath253 , so this is appropriate . however , in ring - lwe , the embedding @xmath206 in @xmath173 may be very sparse ( i.e. @xmath211 may be very dense ) . still , the security will hinge upon the proportion of @xmath255 that is contained in the bell .",
    "we have not seen a discussion of security parameters for ring - lwe in the literature , and so we propose that the appropriate meaning of the width of the gaussian , @xmath38 , in this case is @xmath256 where @xmath257 is defined by the above equality .",
    "the reason for this choice is that @xmath206 has covolume @xmath258 ; a very sparse lattice ( corresponding to large determinant ) needs a correspondingly large @xmath22 so that the same proportion of its vectors lie in the bell .",
    "if @xmath236 represents the spectral norm of @xmath259 ( which has determinant @xmath260 ) , then @xmath261 is the normalized spectral norm .",
    "therefore @xmath262 .",
    "hence the bound of theorem [ thm : redux ] becomes @xmath263",
    "consider the family of polynomials @xmath264 for @xmath0 a prime .",
    "these satisfy @xmath238 . by the eisenstein criterion , they are irreducible whenever @xmath104 has a prime factor that appears to exponent @xmath114 .",
    "these polynomials have discriminant @xcite given by @xmath265    [ prop : family1 ] let @xmath6 be power of a prime @xmath57 . if @xmath104 is squarefree and @xmath266 then the polynomials @xmath267 are monogenic .",
    "this is a result of gassert in ( * ? ? ?",
    "* theorem 5.1.4 ) .",
    "as stated , theorem 5.1.4 of @xcite requires @xmath57 to be an odd prime .",
    "however , for the monogenicity portion of the conclusion , the proof goes through for @xmath268 .",
    "[ prop : family2 ] suppose that @xmath267 is irreducible , and the associated number field has @xmath269 complex embeddings .",
    "then @xmath270 or @xmath271 ( whichever is an integer ) , and the normalized spectral norm of @xmath259 is exactly @xmath272    let @xmath205 be a positive real @xmath6-th root of @xmath104 .",
    "then the roots of the polynomial are exactly @xmath273 for @xmath274 odd such that @xmath275 .",
    "the embeddings take @xmath276 to each of the other roots .",
    "there is @xmath277 real embedding if @xmath6 is odd ( otherwise @xmath278 ) , and the rest are @xmath269 complex conjugate pairs , so that @xmath279",
    ". then the dot product of the @xmath90-th and @xmath34-th columns of @xmath259 is @xmath280 therefore , the columns of the matrix are orthogonal to one another .",
    "hence , the matrix is diagonalizeable , and its eigenvalues are the lengths of its column vectors , which is for the @xmath90-th column , @xmath281 therefore the smallest singular value of @xmath215 is @xmath282 and the largest is @xmath283 .",
    "correspondingly , the largest singular values of @xmath259 is @xmath284 .    a standard result of number theory relates the determinant of @xmath215 to the discriminant of @xmath172 via @xmath285 where @xmath286 is the number of complex embeddings of @xmath172 .",
    "combining the smallest singular value with this determinant ( the discriminant is given explicitly at the beginning of this section ) gives the result .",
    "[ thm : redux2 ] suppose @xmath0 is prime , @xmath6 is an integer and @xmath287 satisfies    1 .",
    "@xmath6 is a power of a prime @xmath288 , 2 .",
    "@xmath104 is squarefree , 3 .",
    "@xmath289 , 4 .",
    "we have @xmath290 , where @xmath291    then the non - dual ring - lwe decision problem for @xmath50 and @xmath38 ( defined by ) can be solved in time @xmath118 with probability @xmath246 , using a dataset of @xmath57 samples .    under the stated conditions , @xmath50 has a root @xmath114 modulo @xmath0 , and therefore poly - lwe is vulnerable to the attack specified in algorithm [ alg : smallerror ] .",
    "the other properties guarantee the applicability of theorem [ thm : redux ] via proposition [ prop : family1 ] and [ prop : family2 ] .    under the assumption that @xmath104 is infinitely often squarefree",
    ", this provides a family of examples which are susceptible to attack ( taking , for example , @xmath6 as an appropriate power of @xmath1 ; note that in this case item ( 3 ) is automatic ) .",
    "interestingly , their susceptibility increases as @xmath0 increases relative to @xmath6 .",
    "it is the ratio @xmath8 , rather than their overall size , which controls the vulnerability ( at least as long as @xmath0 is small enough to run a loop through the residues modulo @xmath0 ) .",
    "the quantity @xmath292 can be considered a measure of security against this attack ; it should be small to indicate higher security . for the various parameters indicated in section [ sec : parameters ] ,",
    "the value of @xmath292 is :    [ cols=\"<,<,<,<,<,<\",options=\"header \" , ]     bbce10    p1363.1 : standard specifications for public - key cryptographic techniques based on hard problems over lattices , december 2008 http://grouper.ieee.org/groups/1363/    joppe w. bos , craig costello , michael naehrig , douglas stebila .",
    "post - quantum key exchange for the tls protocol from the ring learning with errors problem , in 36th ieee symposium on security and privacy 2015 , http://eprint.iacr.org/2014/599.pdf    joppe w. bos , kristin lauter , michael naehrig .",
    "private predictive analysis on encrypted medical data , journal of biomedical informatics ( 2014 ) pp .",
    "234243 .",
    "zvika brakerski , adeline langlois , chris peikert , oded regev , damien stehl .",
    "classical hardness of learning with errors , stoc13 proceedings of the 2013 acm symposium on theory of computing , pp .",
    "575584 , acm , new york , 2013 .",
    "zvika brakerski and vinod vaikuntanathan .",
    "fully homomorphic encryption from ring - lwe and security for key dependent messages . in crypto 2011 ,",
    "lecture notes in computer science , volume 6841 , pp .",
    "springer , 2011 .",
    "zvika brakerski , craig gentry , and vinod vaikuntanathan .",
    "fully homomorphic encryption without bootstrapping . in acm trans .",
    "theory 6 ( 2014 ) , no .",
    "3 , art . 13 , 36 pages .",
    "lo ducas , alain durmus .",
    "ring - lwe in polynomial rings .",
    "15th international conference on practice and theory in public key cryptography , pkc 2012 , fischlin , marc , buchmann , johannes , manulis , mark ( eds . ) lecture notes in computer science , volume 7293 .",
    "kirsten eisentraeger , sean hallgren , kristin lauter , weak instances of plwe , proceedings of selected areas of cryptography 2014 , springer international publishing , lecture notes in computer science , volume 8781 , pp .",
    "183194 .",
    "t. alden gassert , prime decomposition in iterated towers and discriminant formulae , phd .",
    "thesis , university of massachusetts , amherst , 2014    n. gttert , t. feller , m. schneider , j. buchmann , s. huss , on the design of hardware building blocks for modern lattice - based encryption schemes . in cryptographic hardware and embedded systems ",
    "ches 2012 , lecture notes in computer science , volume 7428 , 2012 , pp .",
    "512 - 529 .    craig gentry , shai halevi , and nigel p. smart .",
    "fully homomorphic encryption with polylog overhead . in advances in cryptology ",
    "eurocrypt 2012 , lecture notes in computer science , volume 7237 , springer , heidelberg , pp .",
    "465482 .",
    "thore graepel , kristin lauter , and michael naehrig .",
    "ml confidential : machine learning on encrypted data , international conference on information security and cryptology  icisc 2012 , lecture notes in computer science , springer verlag , 26 december 2012 .",
    "jeff hoffstein , jill pipher , and joseph silverman .",
    "ntru : a ring based public key cryptosystem . in proceedings of ants - iii , lecture notes in computer science , volume 1423 , pp .",
    "springer , june 1998 .",
    "kiran kedlaya . a construction of polynomials with squarefree discriminants .",
    "140 , ( 2012 ) pp . 30253033 .",
    "richard lindner , chris peikert .",
    "better key sizes ( and attacks ) for lwe - based encryption . in topics in cryptology",
    " ct - rsa 2011 lecture notes in computer science , volume 6558 , ( 2011 ) pp .",
    "319 - 339 .",
    "vadim lyubashevsky , chris peikert , and oded regev . on ideal lattices and learning with errors over rings . in advances in cryptology ",
    "eurocrypt 2010 , lecture notes in computer science , volume 6110 , pp . 123 , springer , berlin , 2010 .",
    "vadim lyubashevsky , chris peikert , and oded regev . a toolkit for ring - lwe cryptography , advances in cryptology  eurocrypt 2013 ,",
    "lecture notes in computer science , volume 7881 , pp .",
    "3554 , springer , heidelberg , 2013 .",
    "d. w. masser .",
    "the discriminants of special equations .",
    "the mathematical gazette , 50(372):158 - 160 ( may 1966 ) .    d. micciancio and o. regev .",
    "worst - case to average - case reductions based on gaussian measure .",
    "siam j. on computing , 37(1):267302 ( may 2007 ) .",
    "preliminary version in focs 2004 .",
    "d. micciancio and o. regev .",
    "lattice - based cryptography . in post quantum cryptography , pp . 147191 .",
    "springer , february 2009 .",
    "t. pppelmann and t. gneysu , towards practical lattice - based public - key encryption on reconfigurable hardware . in selected areas in cryptography ",
    "sac 2013 lecture notes in computer science 2014 , pp .",
    "oded regev . on lattices , learning with errors , random linear codes , and cryptography .",
    "j. acm , 56(6):140 , 2009 ( preliminary version stoc 2005 )    s.s .",
    "roy , f. vercauteren , n. mentens , d. d. chen and i. verbauwhede , compact ring - lwe cryptoprocessor . in cryptographic hardware and embedded systems ",
    "ches 2014 lecture notes in computer science volume 8731 ( 2014 ) pp .",
    "371391 .    w. a. stein et al .",
    "sage mathematics software ( version 6.4.1 ) , the sage development team , 2014 , http://www.sagemath.org .",
    "damien stehl and ron steinfeld .",
    "making ntruencrypt and ntrusign as secure as worst - case problems over ideal lattices .",
    "in advances in cryptology ",
    "eurocrypt 2011 , lecture notes in computer science , volume 6632 , pp .",
    "2747 , springer , heidelberg , 2011 .",
    "terence tao , van vu .",
    "smooth analysis of the condition number and the least singular value . in mathematics of computation ,",
    "volume 79 , number 272 , pp .",
    "23332352 , 2010 .",
    "the following sage mathematical software  @xcite code verifies that algorithm [ alg : smallerror ] succeeds on the poly - lwe and ring - lwe examples of section [ sec : exampleattack ] . note that algorithm [ alg : smallset ] is a minor modification of algorithm [ alg : smallerror ] .",
    "this code relies on ` discretegaussiandistributionlatticesampler ` , a built - in package in sage .",
    "the sampler is incapable of initializing in sufficiently large dimension to fully test the attacks in this paper .",
    "see the related trac ticket http://trac.sagemath.org/ticket/17764 .",
    "# general preparation of sage :   create a polynomial ring and import gaussiansampler , timer p.<y > = polynomialring(rationalfield ( ) , ' y ' ) from sage.stats.distributions.discrete_gaussian_lattice import discretegaussiandistributionlatticesampler rp = realfield(300 ) # this sets the precision ; if it is insufficient , the implementation wo n't be valid from sage.doctest.util import timer    # give the minkowski lattice for a given ring determined by a polynomial .",
    "# also gives a key to which are real embeddings .",
    "def cmatrix ( ) : # returns a matrix , columns basis 1 , x , x^2 , x^3 , ... given in the canonical embedding      global n , a      n.<a > = numberfield(f )      fdeg = f.degree ( )      key = [ 0 for i in range(fdeg ) ] # 0 = real , 1 = real part of complex emb , 2 = imaginary part      embs = n.embeddings(cc )      m = matrix(rp , fdeg , fdeg )      print \" preparing an embedding matrix :   computing powers of the root .",
    "\"      apows = [ a^j for j in range(n ) ]      print \" finished computing the powers of the root . \"",
    "i = 0      while i < n :          em = embs[i ]          if mod(i,20)==mod(0,20 ) or mod(i,20)==mod(1,20 ) :              print \" embedding matrix : \" , i , \" rows out of \" , n , \" complete . \"",
    "if em(a).imag ( ) = = 0 :              key[i ] = 0              for j in range(n ) :                  m[i , j ] = em(apows[j]).real ( )              i = i + 1          else :              key[i ] = 1              key[i+1 ] = 2              for j in range(n ) :                  m[i , j ] = em(apows[j]).real ( )                  m[i+1,j ] = ( em(apows[j])*i).real ( )              i = i + 2      return m , key          # create samples using a lattice ( given by latmat and its inverse ) , # a gaussian sampler on that lattice , secret , prime def get_sample(latmat , latmatinv , sec , qval , keyval ) :      e = call_sampler ( ) # create error , in r^n      dim = latmat.dimensions()[0 ] # detect dimension of lattice      pre_a = random_vec(qval , dim ) # create a uniformly randomly in terms of basis in cm      a = latmat*pre_a # create a , in r^n      b = vecmul_poly(a , sec , latmat , latmatinv ) + e # create b , in r^n      pre_b = latmatinv*b # move to basis in cm in order to reduce mod q      pre_b_red = vector([modq(c , qval ) for c in pre_b ] )      b = latmat*pre_b_red      return [ a , b ]    # global choices : setup a field and prime , sampler . #",
    "set to dummy values that will be altered when an attack is run q = 1 n = 1 sig = 1/sqrt(2*pi ) zq = integermodring(q ) r.<x > = polynomialring(zq ) f = y + 1 n.<a > = numberfield(f ) s.<z > = r.quotient(f ) # this is p_q cm , key = cmatrix ( ) cmi = cm.inverse ( ) cm cm53 = cm.change_ring(realfield(10 ) ) cmqq = cm53.change_ring(qq ) sampler = discretegaussiandistributionlatticesampler(cmqq.transpose ( ) , sig )    # set the parameters for the attack def setup_params(fval , qval , sval ) :      global q , n , sig , f , s , x , z , zq      f = fval",
    "n = f.degree ( )      q = qval      zq = integermodring(q )      r.<x > = polynomialring(zq )      sig = sval / sqrt(2*pi )      s.<z",
    "> = r.quotient(f )      print \" setting up parameters , polynomial = \" , f , \" and prime = \" , q , \" and sigma = \" , sig      print \" verifying properties :   \"      print \" prime ? \" , q.is_prime ( )      print \" irreducible ? \" , f.is_irreducible ( )      print \" value at 1 modulo q ? \" , mod(f.subs(y=1),q )      return true    # compute the lattices in minkowski space def prepare_matrices ( ) :      global cm , key , cmi , cmqq      print \" preparing matrices . \"",
    "cm , key = cmatrix ( )      print \" embedding matrix prepared . \"",
    "cmi = cm.inverse ( )      print \" inverse matrix found . \"",
    "cm53 = cm.change_ring(realfield(10 ) )      cmqq = cm53.change_ring(qq )      print \" all matrices prepared . \"",
    "return true    # make a vector in r^n into a polynomial , given change of basis matrix and variable to use def make_poly(a , matchange , var ) :      coeffs = matchange*a   # coefficients of the polynomial are given by the change of basis matrix      pol = 0      for i in range(n ) :          pol = pol + zz(round(coeffs[i]))*var^i # var controls where it will live ( what poly ring )      return pol    # make a polynomial into a vector in minkowski space def make_vec(fval , matchange ) :      if fval = = 0 :          coeffs = [ 0 for i in range(n ) ]      else :          coeffs = [ 0 for i in range(n ) ]          colist = lift(fval).coefficients ( )          for i in range(len(colist ) ) :              coeffs[i ] = zz(colist[i ] )      return matchange*vector(coeffs )    # multiplication in the minkowski space via moving to polynomial ring def vecmul_poly(u , v , mat , matinv ) :      poly_u = make_poly(u , matinv , z )      poly_v = make_poly(v , matinv , z )      poly_prod = poly_u*poly_v      return make_vec(poly_prod , mat )    # create the sampler on the lattice embedded in r^n def initiate_sampler ( ) :      global sampler      print \" initiating sampler . \"",
    "sampler = discretegaussiandistributionlatticesampler(cmqq.transpose ( ) , sig )      print \" sampler initiated with sigma \" , rdf(sig )      return true    # produce error vectors , just a test to see how they look def error_test(num ) :      print \" testing the error vector production by producing \" , num , \" errors .",
    "\"      errorlist = [ sampler().norm().n ( ) for _ in range(num ) ]      meannorm = mean(errorlist ) # average norm      maxnorm = max(errorlist ) # maximum norm      print \" the average error norm is \" , rdf(meannorm/ ( sqrt(n)*sampler.sigma*sqrt(2*pi ) ) ) , \" times sqrt(n)*s . \"      maxratio = rdf(maxnorm/ ( sqrt(n)*sampler.sigma*sqrt(2*pi ) ) )      print \" the maximum error norm is \" , maxratio , \" times sqrt(n)*s . \"",
    "if maxratio > 1 :          print \" ~~~~~~~~~~~~~~~~~~~~~~~ error ~~~~~~~~~~~~~~~~~~~~~~~~~ \"          print \" the errors do not satisfy a proven upper bound in norm . \"",
    "return true      # produce samples samps = [ ] numsamps = 1 def create_samples(numsampsval ) :      global samps , numsamps      samps = [ ]      print \" creating samples \"      for i in range(numsampsval ) :          print \" creating sample number \" , i          samp = get_sample(cm , cmi , secret , q , key )          samps.append(samp )      numsamps = len(samps )      print \" done creating \" , numsamps , \" samples . \"      return true    # function for going down to q def go_to_q(a , matchange ) :      pol = make_poly(a , matchange , x )      # print \" debug got pol : \" , pol      pol_eval = pol.subs(x=1 )      # print \" debug eval'd to : \" , pol_eval , \" and then \" , zq((pol_eval ) )      return zq(pol_eval )    # check to make sure moving to q preserves product -- the last two lines should be equal def sanity_check ( ) :      print \" initiating sanity check \"      mat = cmi      pvec1 = random_vec(q , n )      vec1 = cm*pvec1      pvec2 = random_vec(q , n )      vec2 = cm*pvec2      vprod2 = vecmul_poly(vec1,vec2,cm , cmi )      first_thing = go_to_q(vprod2,mat )      second_thing = go_to_q(vec1,mat)*go_to_q(vec2,mat )      if first_thing = = second_thing :          print \" sanity confirmed .",
    "\"      else :          print \" ~~~~~~~~~~~~~~~~~~~~~~~ error ~~~~~~~~~~~~~~~~~~~~~~~~~ \"          print \" sanity problem : \" , first_thing , \" is not equal to \" , second_thing , \" . \"",
    "print \" are you sure your ring has root 1 mod q ? \"      return true    # given a list of elements of z / qz , make a histogram and zero count def histoq(data ) :      hist = [ 0 for i in range(10 ) ] # empty histogram      zeroct=0 # count of zeroes mod q      for datum in data :          e = datum          if e = = 0 :              zeroct = zeroct+1          histbit = floor(zz(e)*10/q )          hist[histbit]=hist[histbit]+1      return [ hist , zeroct ]    # given a list of vectors in r^n , create a histogram of their # values in z / qz under make_poly , together with a zero count def histo(data , cmi ) :      return histoq([go_to_q(datum , cmi ) for datum in data ] )    # create a histogram of error vectors , transported to polynomial ring def histogram_of_errors ( ) :      print \" creating a histogram of errors mod q. \"      errs = [ ]      for i in range(80 ) :",
    "errs.append(sampler ( ) )      hist = histo(errs , cmi )      print \" the number of error vectors that are zero : \" , hist[1 ]      bar_chart(hist[0 ] , width=1).show(figsize=2 )      return true    # create a histogram of the a 's in the samples , transported to polynomial ring def histogram_of_as ( ) :      print \" creating a histogram of sample a 's mod q. \"      a_vals = [ samp[0 ] for samp in samps ]      hist = histo(a_vals , cmi )      print \" the number of a 's that are zero : \" , hist[1 ]      bar_chart(hist[0 ] , width=1).show(figsize=2 )      return true    # create a histogram of errors by correct guess def histogram_of_errors_2 ( ) :      print \" creating a histogram of supposed errors if sample is guessed , mod q. \"      hist = histoq ( [ lift(zq(go_to_q(sample[1],cmi ) - go_to_q(sample[0],cmi)*go_to_q(secret , cmi ) ) ) for sample in samps ] )      print \" the number of such that are zero : \" , hist[1 ]      bar_chart(hist[0 ] , width=1).show(figsize=2 )      return true    # create the secret mod q lift_s = 0 def secret_mod_q ( ) :      global lift_s      lift_s = go_to_q(secret , cmi )      print \" storing the secret mod q.   the secret is \" , secret , \" which becomes \" , lift_s      return true    # algorithm 2 # reportrate controls how often it updates the status of the loop ; larger = less frequently # quickflag = true will run only the secret and a few other values to give a quick idea if it works def alg2(reportrate , quickflag = false ) :      print \" beginning algorithm 2 . \"      numsamps = len(samps )      a = [ 0 for i in range(numsamps ) ]      b = [ 0 for i in range(numsamps ) ]      print \" moving samples to f_q . \"      for i in range(numsamps ) :          sample = samps[i ]          a[i ] = go_to_q(sample[0],cmi )          b[i ] = go_to_q(sample[1],cmi )      possibles = [ ]      winner = [ [ ] , 0 ]      print \" samples have been moved to f_q . \"      for i in range(2 ) :          if i = = 0 :              print \" ! ! ! ! !",
    "round 1 : ! ! ! ! !",
    "first , checking how many samples the secret survives ( peeking ahead ) .",
    "\"              iterat = [ lift_s ]          if i = = 1 :              print \" ! ! ! ! !",
    "round 2 : ! ! ! ! !",
    "now , running the attack naively .",
    "\"              possibles = [ ]              if quickflag :                  print \" we are doing it quickly ( not a full test ) . \"",
    "iterat = xrange(1000 )              else :                  iterat = xrange(q )          for g in iterat :              if mod(g , reportrate ) = = mod(0,reportrate ) :                  print \" currently checking residue \" , g              g = zq(g )              potential = true              ctr = 0              while ctr < numsamps and potential :                  e = abs(lift(zq(b[ctr]-g*a[ctr ] ) ) )                  if e > q/4 and e",
    "< 3*q/4 :                      potential = false                      if ctr = = winner[1 ] :                          winner[0].append(g )                          print \" we have a new tie for longest chain : \" , g , \" has survived \" , ctr , \" rounds . \"",
    "if ctr > winner[1 ] :                          winner = [ [ g],ctr ]                          print \" we have a new longest chain of samples survived : \" , g , \" has survived \" , ctr , \" rounds . \"                  ctr = ctr + 1              if potential = = true :                  print \" we found a potential secret : \" , g                  possibles.append(g )              if g = = lift_s :                  if i = = 0 :                      print \" the real secret survived \" , ctr , \" samples . \"                  # break      print \" full list of survivors of the \" , numsamps , \" samples : \" , possibles      print \" the real secret mod q was : \" , lift_s      if len(possibles ) = = 1 and possibles[0 ] = = lift_s :          print \" success ! \"          return true      else :          print \" failure ! \"          return false    # run a simulation .",
    "def shebang(fval , qval , sval , numsampsval , numtrials , quickflag = false ) :      global sig      print \" welcome to the ring - lwe attack . \"      n = fval.degree ( )      print \" the attack should theoretically work if the following quantity is greater than 1 .",
    "\"      print \" quantity : \" , rdf ( qval/ ( 2*sqrt(2)*sval*n*(qval-1)^ ( ( n-1)/2/n ) ) )      timer = timer ( )      timer2 = timer ( )      timer.start ( )      print \" * * * * * * * * * * phase 1 : setting up system \"      setup_params(fval , qval , sval )      prepare_matrices ( )      print \" computing the adjustment factor for s. \"      cembs = ( n - len(n.embeddings(rr)))/2      detscale = rp ( ( 2^(-cembs)*sqrt(abs(f.discriminant ( ) ) ) ) ^(1/n ) ) # adjust the sigma , s      sval = sval*detscale      sig = sig*detscale      print \" adjusted s for use with this embedding , result is \" , sval      initiate_sampler ( )      print \" the sampler has been created with sigma = \" , sampler.sigma      print \" sampled vectors will have expected norm \" , rdf(sqrt(n)*sampler.sigma )      error_test(5 )      print \" time for phase 1 : \" , timer.stop ( )      timer.start ( )      count_successes = 0      timer2.start ( )      for trialnum in range(numtrials ) :          print \" * ~*~*~*~*~*~*~*~*~*~*~*~ * trial number \" , trialnum , \" * ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~ \"          print \" * * * * * * * * * * phase 2 : create secret and samples \"          create_secret ( )          create_samples(numsampsval )          sanity_check ( )          print \" time for phase 2 : \" , timer.stop ( )          timer.start ( )          print \" * * * * * * * * * * phase 3 : histograms \"          histogram_of_errors ( )          print \" the histogram of errors ( above ) should be clustered at edges for success .",
    "\"          histogram_of_as ( )          print \" the histogram of a 's ( above ) should be fairly uniform . \"          histogram_of_errors_2 ( )          print \" the histogram of sample errors ( above ) should be clustered at edges for success . \"          print \" time for phase 3 : \" , timer.stop ( )          timer.start ( )          print \" * * * * * * * * * * phase 4 : attack algorithm \"          secret_mod_q ( )          result = alg2(10000,quickflag )          print \" result of algorithm 2 : \" , result          print \" time for phase 4 : \" , timer.stop ( )          if result = = true :              count_successes = count_successes + 1          print \" * ~*~*~*~*~*~*~*~*~*~*~*~ * \" , count_successes , \" out of \" , trialnum+1 , \" successes so far . *",
    "* \"      totaltime = timer2.stop ( )      print \" total time for \" , trialnum+1 , \" trials was \" , totaltime      return count_successes ....        .... x = polynomialring(rationalfield ( ) , ' x').gen ( ) def findq(f , m ) :      g = x^m-1      xg = f.xgcd(g )      cofs = xg[2].coefficients ( )      dens = [ a.denominator ( ) for a in cofs ]      facs = lcm(dens).factor ( )      return max([fac[0 ] for fac in facs ] ) ...."
  ],
  "abstract_text": [
    "<S> the _ ring and polynomial learning with errors _ problems ( ring - lwe and poly - lwe ) have been proposed as hard problems to form the basis for cryptosystems , and various security reductions to hard lattice problems have been presented . </S>",
    "<S> so far these problems have been stated for general ( number ) rings but have only been closely examined for cyclotomic number rings . in this paper , we state and examine the ring - lwe problem for general number rings and demonstrate _ provably weak instances _ of the decision ring - lwe problem . </S>",
    "<S> we construct an explicit family of number fields for which we have an efficient attack . </S>",
    "<S> we demonstrate the attack in both theory and practice , providing code and running times for the attack . </S>",
    "<S> the attack runs in time linear in @xmath0 , where @xmath0 is the modulus .    </S>",
    "<S> our attack is based on the attack on poly - lwe which was presented in  @xcite . </S>",
    "<S> we extend the ehl - attack to apply to a larger class of number fields , and show how it applies to attack ring - lwe for a heuristically large class of fields . </S>",
    "<S> certain ring - lwe instances can be transformed into poly - lwe instances without distorting the error too much , and thus provide the first weak instances of the ring - lwe problem . </S>",
    "<S> we also provide additional examples of fields which are vulnerable to our attacks on poly - lwe , including power - of-@xmath1 cyclotomic fields , presented using the minimal polynomial of @xmath2 . </S>"
  ]
}