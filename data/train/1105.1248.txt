{
  "article_text": [
    "facility location is one of the most studied optimization problems in operations research and captures a large variety of applications .",
    "a classical motivation is placing facilities ( e.g , warehouses ) in such a way that the combined costs of customer satisfaction and warehouse construction are minimized . however , there are also plenty of applications in distributed scenarios . for instance , in wireless networks a set of nodes has to be chosen to provide some services ( e.g , a distributed database ) . making such services",
    "available incurs costs at those _ facility _ nodes , while all remaining nodes act as _",
    "clients_. they use the services of the nearest facility node , and are charged a cost proportional to the corresponding distance .",
    "the objective is to determine a set of facility nodes such that the costs caused by the facilities and the clients is as low as possible .",
    "[ [ formal - problem - definition . ] ] formal problem definition .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    we consider the _ metric uncapacitated facility location _ problem in a distributed setting . here , we are given a complete bipartite graph @xmath5 consisting of a set of _ facilities _ @xmath6 and a set of _ clients _ @xmath7 . to each facility",
    "@xmath8 an opening cost @xmath9 is assigned .",
    "each edge @xmath10 in @xmath11 is weighted with the value @xmath12 that represents the costs of connecting client @xmath13 with facility @xmath14 .",
    "the objective is to determine a subset of the facilities to be opened and connect every client to at least one open facility in such a way that the sum of the opening costs and connection costs is minimized .",
    "the linear program representation of the facility location problem and its dual program are as follows : @xmath15 @xmath16 the variable @xmath17 indicates whether facility @xmath14 is open ( @xmath18 ) or closed ( @xmath19 ) .",
    "the other indicator variable @xmath20 has the value @xmath21 if the client @xmath13 is connected to facility @xmath14 , and @xmath22 otherwise . the constraints ( @xmath21 ) guarantee that each client is connected to at least one facility , while the constraints ( @xmath23 ) make sure that a client can only be connected to an open facility .",
    "the problem we consider is _ metric _ , since the values @xmath24 are required to satisfy the triangle inequality ( i.e , @xmath25 ) , and _ uncapacitated _ , since an arbitrary number of clients can be connected to an open facility .",
    "furthermore , for the sake of presentation we assume all @xmath26 to be normalized such that the smallest non - zero value is @xmath21 .",
    "the dual program will be used in the description of our approximation algorithm .",
    "intuitively , a @xmath27 variable can be seen as the amount the client @xmath13 is willing to pay for being connected to a facility . from the point of view of a facility @xmath14",
    ", @xmath27 is the sum of @xmath24 ( the amount @xmath13 pays for a connection to @xmath14 ) and @xmath28 ( the amount it pays for opening @xmath14 ) .",
    "our algorithm is executed in the @xmath0 model , which was introduced by peleg @xcite and is commonly used to model the execution of distributed algorithms on graphs : algorithms are executed in synchronous send - receive - compute rounds . in a single round , each node sends a message to each of its neighbors in the graph . note that the messages sent to each neighbor by a single node are not required to contain the same information .",
    "once all nodes have sent their messages , they receive a single message from each of their neighbors .",
    "after all the messages have been received , every node is allowed to spend an arbitrary amount of time for computation ( i.e , computation is for free and we are only interested in the number of communication rounds ) .",
    "the end of the computation by all nodes marks the start of a new send - receive - compute round .",
    "the message size in the @xmath0 model is bounded .",
    "we will limit the size of the messages used in our algorithm to @xmath29 bits .",
    "the same limitations were also used in @xcite , @xcite and @xcite .",
    "this bound is reasonable , because it allows the nodes to send their i d in a single message .",
    "due to this constraint on message size , we restrict the values @xmath30 and @xmath24 in such a way that it is possible to represent them with @xmath29 bits ( i.e. to be able to send them in a single message ) .",
    "the graph our algorithm is executed on is the complete bipartite graph of clients and facilities .",
    "this means that within a single round each client can communicate with all facilities and each facility can communicate with all clients . since nodes of the same partition can not communicate directly with each other , but instead have to use nodes of the other partition as relays , gathering all information about the graph requires @xmath31 rounds",
    "note that without a limit on the message size our problem could be trivially solved in four rounds ( all information about the graph is gathered at a single node in two rounds , an optimal solution is computed and distributed in two more rounds ) .",
    "we want to stress that , although in our algorithm the nodes communicate with all their neighbors in each round , it is possible to restate the algorithm such that nodes @xmath14 and @xmath13 where @xmath24 is `` large '' ( more than @xmath32 ) never communicate with each other .",
    "[ [ our - contribution . ] ] our contribution .",
    "+ + + + + + + + + + + + + + + + +    we present a distributed approximation algorithm for the metric uncapacitated facility location problem .",
    "it is based on a greedy algorithm by jain et al@xcite ( from here on referred to as ) and yields a guaranteed ( not in expectation ) @xmath33-approximation in @xmath3 rounds ( with high probability ) .",
    "our algorithm is executed in the @xmath0 model on a complete bipartite graph .",
    "although it is strongly related to the _ greedyfl _ algorithm , there are ( due to the parallel execution ) new challenges regarding the selection process that occurs when multiple facilities are eligible for opening .",
    "the difficulty is that we require the cost of the solution computed by our algorithm to be always at most @xmath33 times worse than an optimal solution ( in contrast to similar work by blelloch et al@xcite , where the approximation factor is increased by factor @xmath23 ) .",
    "moreover , unlike other work ( e.g , @xcite , where the approximation factor is given `` in expectation '' ) , our algorithm provides a worst - case guarantee on the approximation factor .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    during the last two decades , the uncapacitated metric facility location problem was of great interest , and a lot of progress has been made concerning the running time and approximation factor of sequential algorithms solving it .",
    "aardal et alintroduced the first polynomial time algorithm yielding a @xmath34-approximation @xcite .",
    "improving this approximation factor was the topic of a multitude of research papers .",
    "for example , chudak et alimproved the approximation factor to @xmath35 @xcite .",
    "the factor has been improved , until eventually byrka designed a @xmath36-approximation algorithm @xcite , which , at this point in time , yields the best known approximation .",
    "although both last mentioned algorithms yield very good approximation factors , they have , due to applying lp - rounding , high running times .",
    "thus , the design of algorithms with slightly worse approximation factors , but better running times , was also of interest in the past .",
    "jain and vazirani used the primal - dual approach to develop and analyze an algorithm with approximation factor @xmath37 and a running time of @xmath38 @xcite .",
    "a simplified and faster @xmath39 version of this algorithm was introduced by mettu and plaxton @xcite .",
    "later on , jain et alimproved the former results by presenting two algorithms in @xcite : one with running time @xmath40 and an approximation factor of @xmath41 ( which we refer to as ) and another one with running time @xmath42 and an approximation factor of @xmath43 ( @xmath4 denoting the number of nodes and @xmath44 the number of edges in the complete bipartite graph of facilities and clients ) .",
    "later on , building upon @xcite , mahdian et alimproved the factor to @xmath45 @xcite .    under the assumption that @xmath46 , guha et alshowed in @xcite that no polynomial time algorithm with an approximation factor better than @xmath47 exists .",
    "thus , an improvement of either the lower or the upper bound for the approximation factor , even in the @xmath37rd or higher fractional digit , is of great interest .",
    "the following results concerning the facility location problem can be found in the distributed scenario : in @xcite pandit et alpresent an algorithm yielding a @xmath48-approximation and a running time of @xmath29 .",
    "their algorithm is a parallel version of the primal - dual algorithm by jain et al@xcite and is  like our algorithm  executed in the @xmath0 model on a complete bipartite graph with message size limited to @xmath29 bits .",
    "pandit et alassume that the difference between the opening costs of the cheapest and the most expensive facility can be arbitrary large .",
    "it is reasonable to drop this assumption , since they ( as well as we ) require that the facility opening costs and distances between clients and facilities are encoded with @xmath29 bits . by dropping this assumption and modifying the algorithm and analysis by pandit et alin a small way ( changing a factor from @xmath23 to @xmath49 ) , it is possible to achieve a @xmath50 approximation factor in @xmath51 rounds .",
    "further improvement of the factor with this approach is not possible , since the approximation factor of @xcite , which pandit et alparallelized , is @xmath37 .",
    "this means that their algorithm , while faster than ours , has a worse approximation factor .",
    "recently , in @xcite pandit et alall presented a technique that can be used to execute greedy facility location algorithms ( like ) in parallel in polylogarithmic time .",
    "although they consider a similar problem as we do , their results are quite different from ours : their approximation factor is @xmath52 in expectation ( their algorithm can produce an arbitrary bad solution , even though this is very unlikely ) , while we can guarantee an approximation factor of @xmath33 in the worst case . also ,",
    "although they do not state their exact approximation factor , the expected approximation factor achieved with their technique can not , to the best of our knowledge , be decreased below @xmath53 , where @xmath54 is the approximation factor of the sequential algorithm ( i.e , @xmath55 if used with ) .",
    "a similar result to @xcite was presented by blelloch et alin @xcite . instead of",
    "the @xmath0 they use a pram model and achieve a @xmath56 approximation with running time @xmath57 by parallelizing the algorithm . in order to choose which facilities to open , they use a technique introduced by rajagopalan and vazirani @xcite .",
    "this technique can also be used to execute greedy facility location algorithms ( in a distributed manner and polylogarithmic time ) and yields a guaranteed approximation factor of @xmath58 , where @xmath54 is again the approximation factor of the corresponding sequential algorithm ( i.e@xmath59 if used with ) .",
    "other results that also use the bound of @xmath29 on the message complexity are @xcite and @xcite . in @xcite moscibroda",
    "et alshow that in @xmath60 communication rounds a @xmath61 approximation in @xmath60 communication rounds ( @xmath62 and @xmath63 are the number of facilities , respectably clients , and @xmath64 a coefficient dependent on instance parameters ) can be achieved in the more general _ non - metric _ facility location problem .",
    "gehweiler et alshow in @xcite that @xmath37 rounds are sufficient to compute a @xmath52-approximation for the uniform facility location problem ( opening each facility incurs the same costs ) .",
    "@xcite applies the approach of mettu and plaxton @xcite , which has been successful in a lot of other settings as well : in the kinetic setting @xcite , in game theoretic settings @xcite , for algorithms working in sublinear time @xcite , and when confronted with perpetual changes to the problem instance @xcite .",
    "[ [ structure - of - the - paper . ] ] structure of the paper .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    in section 2 we give a detailed description of our approximation algorithm and prove its approximation factor by generalizing the techniques and results of @xcite .",
    "our main contribution is section 3 . here",
    ", we deal with the problem of selecting facilities to be opened that arises due to the parallel execution of the _ greedyfl _ algorithm by jain et aland show that our distributed algorithm presented in section 2 terminates in sublinear time .",
    "our parallel algorithm is based on the _ greedyfl _ algorithm by jain et al@xcite .",
    "as stated above , it is executed in the @xmath0 model on a complete bipartite graph .",
    "we will first describe the algorithm and then give an analysis of its approximation factor and running time .",
    "[ [ algorithm - description . ] ] algorithm description . + + + + + + + + + + + + + + + + + + + + + +    due to the completeness of the bipartite graph , in a single synchronous round each client can send to and receive a message from all facilities .",
    "the same applies analogously to each of the facilities . during the algorithm s execution",
    ", clients and facilities can be in various states : clients can be _ not connected _ or _ connected _ , while facilities can be _ closed _ , _ currently - paid _ , or _",
    "open_. intuitively , _",
    "currently - paid _ facilities compete with each other for the permission to change their state to _",
    "all clients start in the _ not connected _ state and all facilities in the _ closed _ state .",
    "when a client @xmath13 changes its state to _ connected _ , it is assigned to an _ open _ facility @xmath14 ( @xmath65 ) and never changes its state again .",
    "a _ closed _ facility can only change its state to _ currently - paid _",
    ", while a _ currently - paid _ facility can either become _ closed _ or @xmath66 .",
    "once a facility is @xmath66 , it never changes its state .",
    "the algorithm terminates , once all clients are _",
    "connected_. the solution returned by our algorithm is the set of all _ open _ facilities and the assignment @xmath67 .",
    "each facility knows now whether it is open or not and each client knows the facility it is assigned to .",
    "@xmath68 $ ] + execute algorithm 4 until there are no _ currently - paid _ facilities left compute @xmath69    the algorithm is executed in a loop and each passing of the loop is referred to as a _",
    "phase_. the behavior of a client during a phase is described in algorithm 1 , while the behavior of a facility is described in algorithm 2 .",
    "facilities and clients interact with each other by transmitting messages ; to each send operation there exists a corresponding receive operation .",
    "the idea of the algorithm is to assign to each client @xmath13 a variable @xmath27 initialized with @xmath21 .",
    "this variable represents the amount a client is willing to pay for being connected to a facility and for opening this facility in the current phase ( i.e , the @xmath27 variable of the dual program ) .",
    "each _ not connected _",
    "client @xmath13 increases this variable in every phase by multiplying it with @xmath49 where @xmath2 is an arbitrary small constant greater than @xmath22 ( fixed at the start of our algorithm ) .",
    "after @xmath27 is increased , all clients send their current @xmath27 to all facilities .",
    "@xmath70 $ ] @xmath71 compute @xmath72 @xmath73 _ currently - paid _ + execute algorithm 3 until there are no _ currently - paid _ facilities left    let @xmath74 be the set of all _ not connected _ clients and @xmath75 .",
    "we say that client @xmath13 _ contributes _ to facility @xmath14 , if @xmath76 ( the client pays @xmath24 for being connected to and @xmath28 for the opening of facility @xmath14 ) . upon receiving the @xmath27 variables ,",
    "every _ closed _",
    "facility @xmath14 computes @xmath77 , which represents the amount _ not connected _ clients are willing to contribute to the payment of opening facility @xmath14 .",
    "if the contribution to the opening of facility @xmath14 ( i.e. @xmath77 ) reaches a point such that @xmath78 , it changes its status to _ currently - paid_.    @xmath79 uniformly distributed random number in @xmath80 $ ] @xmath81 $ ] + @xmath82 $ ] define @xmath83 where @xmath84 + @xmath85 @xmath86 @xmath87 @xmath88 $ ] + @xmath89 $ ] + @xmath90 @xmath91    opening all the _ currently - paid _ facilities could result in a very bad approximation , since it is possible that a single _ not connected _",
    "client @xmath13 is contributing to an arbitrary number of _ currently - paid _ facilities ( i.e. @xmath92 ) and opening just one of these facilities would be sufficient .",
    "thus , a selection procedure is needed to determine which _ currently - paid _ facilities are going to be permanently opened ( change their status to _ open _ ) and which of them will remain closed in this phase ( changing their status from _ currently - paid _ to _ closed _ ) .",
    "furthermore , it is required to determine which client is connected to which facility .",
    "all of this is achieved by the interaction of algorithm 3 ( from the point of view of facility @xmath14 ) and algorithm 4 ( from the point of view of client @xmath13 ) . in each iteration of algorithm 3 and 4 ,",
    "a subset of _ currently - paid _ facilities is chosen to be opened .",
    "the development and analysis of these two algorithms is the main contribution of our paper , as they are responsible for selecting the facilities ( which are going to be opened ) in a fast and efficient way .",
    "the algorithms operate by generating a random number at each facility and then opening a facility , if its number is the highest one in its neighborhood ( the neighborhood of a facility @xmath14 consists of all facilities @xmath93 , such that there is at least one client that contributes to @xmath14 and @xmath93 ) .",
    "only @xmath29 bits are used to represent the generated random number , which is sufficient to guarantee that , with high probability , no two facilities generate the same number .",
    "the main objective of algorithm 3 and 4 is to establish the following fact :    in every phase , after the iterative execution of algorithm 3 and 4 terminates , the following is true for all facilities :    1 .",
    "no facility is _ currently - paid_. 2 .   if facility @xmath14 is _ open _ , then @xmath94 , where @xmath95 .",
    "3 .   if facility @xmath14 is _ closed _ , then @xmath96 , where @xmath97 .    intuitively , ( ii ) means that a facility is only opened , if all clients connected to it can ( together ) pay for its opening , and ( iii ) means that , after a phase ended , there is no _ closed _ facility to which clients contribute enough to pay for its opening . the fact that a _ closed _ facility with @xmath98 can not enter the next phase , as implied by ( iii ) , is of importance .",
    "it ensures that the desired approximation factor can be guaranteed , which is curcial for ( the later introduced ) lemma 2 .",
    "@xmath99 $ ] + define @xmath100 where @xmath101 + @xmath102 $ ] + @xmath103 $ ] + @xmath104 + @xmath105 _ connected _",
    "@xmath106 @xmath107 @xmath108 $ ] +    note that after the algorithm s termination the cost of the solution computed by our algorithm lies in the interval @xmath109 $ ] .",
    "this is due to the following facts : each client is connected to exactly one facility and this facility is _",
    "open_. since @xmath110 a client @xmath13 contributes to the opening of a facility @xmath14 only after @xmath27 covered the costs @xmath24 of connecting @xmath14 to @xmath13 .",
    "also , since we require that only after @xmath78 facility @xmath14 changes its state to _ open _ , the opening of @xmath14 is completely paid for and since @xmath74 is the set of all _ not connected _ clients , it is made sure that a client contributes to the opening of at most one facility .",
    "the running time of the entire algorithm is bounded by @xmath3 rounds : the number of phases is @xmath51 , since in the worst case a client has distance @xmath111 to its nearest facility and this facility has opening costs of @xmath111 ( the @xmath24 and @xmath30 are limited by @xmath29 bits ) .",
    "thus , increasing the @xmath112 value iteratively by multiplying it with @xmath49 , where @xmath113 , results in @xmath51 rounds .",
    "later , we will show that with high probability algorithm 3 and 4 terminate after @xmath114 rounds . the value chosen for @xmath2 not only determines the runtime , but also the approximation factor , which is @xmath115 .",
    "[ [ analysis - of - the - approximation - factor - and - runtime . ] ] analysis of the approximation factor and runtime .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    intuitively , the algorithm can be seen as continuously and simultaneously increasing the @xmath27 values .",
    "this allows to open a facility @xmath14 in the exact moment it is paid for ( i.e. , when @xmath116 ) ; a property which is essential for proving its approximation factor .",
    "in contrast , our algorithm increases the @xmath27 values in discrete steps and thus , in general , it may occur that @xmath98 .",
    "the goal of this section is to show that  even though our algorithm may yield a very different solution from the sequential algorithm ",
    "the costs of the optimal and our solution do not differ too much .",
    "namely , we show that our approximation factor is at most @xmath117 times greater than the approximation factor of .",
    "our proof uses similar arguments as , and is based on , the one of jain et al , but it turns out that in order to apply the results of jain et al , we need to get a deeper insight into the structural properties of the linear programs involved .",
    "the @xmath27 and @xmath28 values computed by our algorithm can be interpreted as a solution to the dual program of the facility location program presented in the introduction .",
    "however , they do not necessarily represent a feasible solution : our algorithm opens a facility when @xmath118 ( summing over all _ not connected _ clients ) and not , as required by constraint ( 4 ) , over all the clients . if we choose @xmath119 such that @xmath120 and @xmath121 constitute a feasible dual solution , the duality theorem yields that our solution is by a factor of at most @xmath119 more expensive than an optimal solution . for their original , sequential algorithm jain et algave an upper bound of @xmath41 for @xmath119 @xcite .",
    "they denoted the used technique as dual fitting with a factor - revealing lp .",
    "we will construct such a factor revealing program ( see ) for our algorithm and establish a structural connection between it and the lp by jain et al(see ) for their sequential algorithm ( ) .    to this end",
    ", consider a single facility @xmath14 and assume , that w.l.o.g@xmath122 holds only for the first @xmath123 clients and that @xmath124 .",
    "the next two lemmas express the constraints imposed by both the algorithm and the facility location problem .",
    "they resemble similar lemmas to those used in the proof for the sequential algorithm ( cf .",
    "@xcite ) ( their proofs can be found in the appendix ) .",
    "[ lem : metric_lp_property ] for any two clients @xmath13 , @xmath125 and a facility @xmath14 , we have @xmath126 .",
    "[ lem : facilities_not_overpaied_property ] for every client @xmath13 and facility @xmath14 , the execution of the algorithm guarantees that @xmath127 .",
    "our algorithm ensures that the constraints stated by the two lemmas above are met .",
    "thus , we now want to find the minimum value for @xmath119 such that @xmath128 holds , without violating the lemmas statements .",
    "equivalently , we want to maximize the ratio @xmath129 ( again , without violating the constraints ) .",
    "this formulation yields the following family of linear programs , referred to as the factor - revealing lp .",
    "@xmath130    @xmath131    note that constraints @xmath132 resp@xmath133 are only used to sort the @xmath27 values in order to ease the formulation of constraints @xmath134 resp@xmath135 .",
    "the following theorem quantifies the correlation between our ( ) and the original factor - revealing lps ( ) .    for any @xmath136 , the optimal solution to",
    "is bounded by @xmath137 , and thus the approximation factor of our algorithm is also @xmath137 .",
    "jain et alshowed that @xmath138 can be at most @xmath41 in . in our modified version @xmath138 can be at most @xmath137 : fix a problem instance by setting the @xmath24 variables and the @xmath30 variable to arbitrary values @xmath139 and consider the following two propositions .",
    "[ propositionlp1 ] in an optimal solution @xmath140 to , @xmath141 at least one of the two properties is true :    1 .",
    "@xmath142 , where @xmath143 2 .",
    "@xmath144 and @xmath145    note that the term @xmath146 is fixed . since we deal with a maximization problem , which is bounded ( see constraint @xmath134 of ) , each @xmath27 is bounded .",
    "since @xmath147 represents an optimal solution , for each @xmath27 there must be at least one constraint that bounds @xmath27 and is also tight .",
    "if this tight constraint is of the form @xmath148 , ( i ) holds .",
    "otherwise , there must be at least one tight constraint of the form @xmath149 , i.e. @xmath150 .",
    "this argument can be analogously applied to @xmath151 : either @xmath152 , or there exists a @xmath153 such that @xmath154 . like this",
    ", we can build a recursion for @xmath155 , which terminates as soon as we reach a variable @xmath156 with @xmath157 and thus ( i ) holds for @xmath158 .",
    "note that for every @xmath27 there must be such a terminating sequence , since constraint @xmath134 is the only constraint which gives an absolute upper bound on the variables .",
    "otherwise , the @xmath27 would be unbounded .",
    "the recursion yields @xmath159 , implying @xmath160 .",
    "since also @xmath161 ( constraint @xmath162 ) , we have @xmath163 , proving ( ii ) .",
    "[ propositionlp2 ] given an optimal solution @xmath164 to and an optimal solution @xmath165 to , we have @xmath166 .",
    "since the constraints in are a relaxation of the constraints of , the solution @xmath147 is also a feasible solution of .",
    "based on proposition [ propositionlp1 ] we know that to any @xmath27 at least one of the following cases applies :    1 .",
    "@xmath142 i.ethe constraint @xmath148 is tight .",
    "notice that for @xmath167 satisfying the constraint @xmath168 we have , due to the set @xmath169 containing the set @xmath170 , @xmath171 .",
    "according to proposition [ propositionlp1 ] we know that @xmath172 and @xmath145 . constraint ( 2 ) of _ fr - dist _ guarantees that @xmath173 . since we can apply case ( i ) for @xmath174 , we have @xmath175 , which yields @xmath176 .",
    "given any instance of the facility location problem , we know that the optimal solution to the lp is bounded by @xmath41 and that , by proposition [ propositionlp2 ] , the solution to for the same instance is at most by a factor of @xmath177 larger . since the problem instance was chosen arbitrarily , the theorem s statement follows .",
    "in this section we are only concerned with a single _ phase _ of our algorithm ( i.ethe loop in which algorithm 3 and 4 are invoked and which establishes fact @xmath21 ) .",
    "we show that it terminates after @xmath114 rounds with high probability .",
    "to simplify notation , @xmath6 and @xmath7 do not refer to all facilities respall clients ( as was the case before ) .",
    "instead , let @xmath6 represent the set of all facilities that are in the _ currently - paid _ state and @xmath7 denote the set of all _ not connected _ clients contributing to a _ currently - paid _ facility . all the other clients and facilities effectively do not take part in the execution of algorithm 3 and 4 in the considered phase and thus can be ignored .",
    "we consider the bipartite graph @xmath178 .",
    "there is an edge in @xmath179 between @xmath8 and @xmath180 if and only if client @xmath13 contributes to @xmath14 ( i.e. @xmath181 ) .",
    "furthermore , we assume that there are no isolated nodes ( i.e@xmath182 for all @xmath183 ) .",
    "let @xmath184 .",
    "by @xmath185 we denote the @xmath186 , where there is an edge @xmath187 between two facilities @xmath188 if and only if they share a common client in @xmath11 .",
    "we use @xmath189 and @xmath190 to denote the degree and neighborhood of a node in @xmath11 respectively .",
    "if the neighborhood includes the node itself , we write @xmath191 .",
    "similarly , we use @xmath192 , @xmath193 , and @xmath194 to denote the corresponding properties in @xmath195 .    in each execution of algorithm 3 and 4 the set @xmath6 of _ currently - paid _",
    "facilities shrinks ( they change their status to _ closed _ or _ open _ ) .",
    "also , with every facility changing its state from _ currently - paid _ to _ open _ clients that are connected to those newly opened facilities are removed from @xmath7 .",
    "removing these clients form @xmath7 can potentially cause _ currently - paid _ facilities to change their state to _ closed _ ( they lose contributing clients and their opening costs are not paid for anymore ) . since it can not be guaranteed that a _ currently - paid _ facility which loses a contributing client is not longer fully paid for , applying a distributed mis ( maximal independent set ) algorithm ( e.gluby s mis algorithm @xcite ) on @xmath195 does not help to solve our problem : a facility that loses a contributing client ( i.ea facility that is not part of the mis ) might still be fully paid for . if such a facility is not opened in the current phase ( i.e , ( iii ) of fact 1 does not hold )",
    ", clients contributing to it will raise their @xmath27 values in the next phase , which in turn could violate the constraints of the lp . since shrinking @xmath6 by removing _",
    "currently - paid _ facilities that are not paid for only decreases the runtime of algorithm 3 and 4 , we will assume ( in order to consider the worst case ) that facilities never change their status from _ currently - paid _ to _ closed _ as the result of clients changing their state to _ connected _",
    "( i.e , losing contributing clients ) .    [ [ a - simplified - problem - description . ] ] a simplified problem description .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in order to alleviate describing the shrinking process of the set of _ currently - paid _ facilities , we simplify the analysis of algorithm 3 and 4 by omitting the information about the values of @xmath24 and @xmath30 and simulating the distributed execution of the algorithms by the algorithm facilityselect .",
    "its input is the bipartite graph @xmath11 and it possesses global knowledge .",
    "@xmath196 ( _ subsequently , determine @xmath197 such that @xmath198 for all @xmath199 ) _ ) + generate a uniformly distributed random value @xmath200 $ ] + add @xmath14 to @xmath201 + eliminate @xmath202 from @xmath11 +    as the execution of facilityselectprogresses , @xmath6 , @xmath7 , @xmath179 , and @xmath4 change .",
    "we denote these sets and @xmath4 in round @xmath203 as @xmath204 , @xmath205 , @xmath206 and @xmath207 .",
    "however , most of the time we consider only the effect of a single iteration of the while loop on the graph . in these cases ,",
    "we omit the time parameter and simply use @xmath6 , @xmath7 , @xmath179 , and @xmath4 to refer to the corresponding values in the considered iteration .    [",
    "[ time - required - to - shrink - the - bipartite - graph . ] ] time required to shrink the bipartite graph .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this paragraph analyzes the time required to remove all nodes from @xmath11 .",
    "it is easy to see that a fixed facility @xmath208 is selected with probability @xmath209 by this strategy .",
    "first , we show that , in expectation , facilityselectremoves at least @xmath210 clients and at least @xmath211 edges in a single iteration of the while loop .",
    "[ prop : lower_bound_on_expected_eliminated_clients ] the expected number of clients removed by facilityselectin a single iteration of the while loop is at least @xmath210 .    for a facility @xmath208 ,",
    "let @xmath212 denote a random variable counting the number of clients @xmath213 removed because of @xmath14 being added to @xmath201 or not .",
    "that is , @xmath214 since @xmath201 is an independent set in @xmath195 , the total number of clients removed in one iteration can be described by the random variable @xmath215 . using the inequality @xmath216 ,",
    "we compute : @xmath217    [ prop : lower_bound_on_expected_eliminated_edges ] the expected number of edges removed by facilityselectin a single iteration of the while loop is at least @xmath211 .",
    "first note that , since by lemma  [ prop : lower_bound_on_expected_eliminated_clients ] the expected number of clients eliminated is at least @xmath210 and there are no isolated clients , the expected number of edges removed is at least @xmath210 .",
    "it remains to show that the expected number of edges removed is at least @xmath218 . for a facility @xmath208 ,",
    "let us define random variables @xmath219 counting the number of edges removed because of @xmath14 being added to @xmath201 or not .",
    "that is , @xmath220 since @xmath201 is an independent set in @xmath195 , the total number of edges removed by strategy facilityselectcan be described by the random variable @xmath221 defined as @xmath222 . using the inequality @xmath223 ,",
    "we compute : @xmath224    as an corollary , we get that , in expectation , the number of edges is reduced by at least its square root :    [ cor : lower_bound_on_expected_eliminated_edges ] the expected number of edges removed by facilityselectin a single iteration of the while loop is at least @xmath225",
    ".    lemma  [ prop : lower_bound_on_expected_eliminated_edges ] and the equality @xmath226 imply @xmath227 .",
    "if the number of edges is greater or equal @xmath228 , the expected number of _ clients _ removed by facilityselectin one iteration of the while loop is at least @xmath229 . if it is smaller or equal @xmath228 , the expected number of removed _ edges _ is at least @xmath230 .",
    "for the first statement , we can bound the expected number of removed clients with the help of lemma [ prop : lower_bound_on_expected_eliminated_clients ] as follows : @xmath231 the second statement follows immediately from corollary  [ cor : lower_bound_on_expected_eliminated_edges ] .",
    "we call a round @xmath203 _ edge - heavy _ , if in this round the number of edges is at least @xmath232 .",
    "otherwise , we refer to it as _ edge - light_.    [ client_constant_fraction ] for an arbitrary round @xmath203 , consider the effect of several iterations of facilityselect s while loop starting at round @xmath203 .",
    "a.   after @xmath233 ( not necessarily consecutive ) _ edge - heavy _ rounds ,",
    "at least @xmath234 clients are removed in expectation .",
    "b.   after @xmath235 ( not necessarily consecutive ) _ edge - light _",
    "rounds , at least @xmath236 edges are removed in expectation .",
    "we prove only the first statement , since the second can be proven analogously .",
    "let @xmath237 denote a random variable counting the number of clients removed during @xmath233 edge - heavy rounds .",
    "if @xmath238 , the number of clients in each of the considered rounds was at least @xmath239 . thus , by lemma",
    "[ prop : lower_bound_on_expected_eliminated_clients ] , in each of these @xmath233 rounds at least @xmath240 clients were removed in expectation . if @xmath241 , the number of removed clients is trivially lower bounded by @xmath239 .",
    "we get : @xmath242&\\geq\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}\\cdot pr\\left(y\\geq\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}\\right)+\\frac{1}{2}\\sqrt{n_t}\\cdot\\sqrt{\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}}\\cdot pr\\left(y<\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}\\right)\\\\      & \\geq\\frac{{\\left\\lvertc_t\\right\\rvert}}{2\\sqrt{2}}\\cdot pr\\left(y\\geq\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}\\right)+\\frac{{\\left\\lvertc_t\\right\\rvert}}{2\\sqrt{2}}\\cdot pr\\left(y<\\frac{{\\left\\lvertc_t\\right\\rvert}}{2}\\right ) = \\frac{{\\left\\lvertc_t\\right\\rvert}}{2\\sqrt{2 } }      \\enspace .",
    "\\end{split}\\ ] ]    [ client_edge_constant_probability ] for an arbitrary round @xmath203 , consider the effect of several iterations of facilityselect s while loop starting at round @xmath203 .",
    "a.   [ client_constant_probability ] the probability of removing at least @xmath243 clients after @xmath233 _ edge - heavy _",
    "rounds is at least a constant @xmath244 .",
    "b.   [ edge_constant_probability ] the probability of removing at least @xmath245 edges after @xmath235 _ edge - light _",
    "rounds is at least a constant @xmath244 .",
    "we prove only the first statement .",
    "the second can be proven analogously .    by lemma [ client_constant_fraction ]",
    "@xmath234 clients are removed after @xmath233 _ edge - heavy _",
    "rounds in expectation .",
    "let @xmath246 define a random variable counting the number of clients removed after @xmath233 _ edge - heavy _ rounds .",
    "now define @xmath247 to be the probability that more than @xmath243 clients are removed .",
    "we can bound @xmath248 $ ] in the following way : @xmath249 \\leq \\mu n + ( 1-\\mu ) \\frac{1}{4\\sqrt{2}}{\\left\\lvertc_t\\right\\rvert}\\ ] ] solving this inequality for @xmath247 yields @xmath250 , where @xmath54 is a positive constant .",
    "we are now ready to prove our main theorem .",
    "algorithm facilityselectterminates with high probability after @xmath251 iterations of the while loop .    by lemma  [ client_edge_constant_probability ] , starting at iteration @xmath203 we lose at least a constant fraction of either the clients or the edges with a non - zero , constant probability after at most @xmath252 rounds .",
    "partition the number of iterations done by facilityselectinto phases of @xmath253 rounds .",
    "let @xmath212 denote a binary random variable indicating whether the @xmath14-th phase was _ good _ ( we lost at least the above mentioned constant fraction of either clients or edges ) .",
    "we need about @xmath254 good rounds to ensure that the problem size has become @xmath52 .",
    "since we have @xmath255 for some positive constant @xmath54 , we get for @xmath256 : @xmath257\\geq2\\log(n ) \\enspace.\\ ] ] that is , in expectation it takes about @xmath258 phases until facilityselectterminates . applying a standard chernoff bound yields : @xmath259\\right\\rvert}>\\frac{e[x]}{2}\\right ) < 2^{-4e[x]/3 } \\enspace.\\ ] ] in other words ,",
    "facilityselectterminates with high probability after at most @xmath260 steps .",
    "we presented a parallel execution of a greedy sequential algorithm for the facility location problem and showed that we can preserve its approximation factor .",
    "however , there are other sequential facility location algorithms based on the greedy approach introduced by jain et althat yield ( better ) approximation factors of 1.61 @xcite and 1.52 @xcite",
    ". it might be possible to execute them in the @xmath0 model with a sublinear running time using the technique we introduced in this paper .",
    "when our algorithm chooses which facilities should be opened , it bases its decision solely on the information provided by the bipartite graph @xmath11 used in section 3 and all other information ( client contribution , distance , facility opening costs ect . )",
    "is abstracted away ( section 3 provides reasons for this abstraction ) . at this level of abstraction",
    "the lower bound of solving the problem is @xmath261 : consider a bipartite graph with @xmath261 facilities with degree of @xmath262 , and @xmath263 clients with degree @xmath23 .",
    "edges are chosen in such a way that any two facilities are in hop distance of 2 of each other .",
    "it would be interesting to know in what way the entire available information can be used to improve the runtime and whether a poly - logarithmic runtime is possible with the same approximation factor .",
    "if @xmath264 the lemma obviously holds . thus , let us assume the opposite .",
    "let @xmath203 be the phase when our algorithm connects client @xmath125 to some facility @xmath93 and @xmath265 the phase @xmath93 was opened .",
    "facility @xmath93 was either opened before @xmath125 was connected to it ( @xmath266 ) or opened exactly in the same phase client @xmath125 was connected to it ( @xmath267 ) .",
    "since @xmath268 , we know that client @xmath13 was connected in phase @xmath269 . at time",
    "@xmath270 the contribution of client @xmath13 was not enough to cover the distance between @xmath13 and @xmath93 , since otherwise @xmath13 would be connected in phase @xmath265 with @xmath93 .",
    "this means that once the contribution of @xmath13 reaches @xmath271 , client @xmath13 will be connected to @xmath93 .",
    "since the contribution is increased by multiplying the current @xmath147 value with @xmath49 , it can not become greater than @xmath272 , hence @xmath273 .",
    "thanks to the triangle inequality we have @xmath274 .    to prove by contradiction , we assume that the inequality does not hold . thus , we have @xmath275 . since we ordered the clients according to their @xmath147 value , we know that for @xmath276 we have @xmath277",
    "let @xmath203 be the phase client @xmath13 was connected to a facility . by the assumption facility @xmath14",
    "is fully paid for ( i.e @xmath14 s current payment is @xmath278 ) in phase @xmath266 .",
    "there must be at least one client @xmath174 , with @xmath279 and @xmath280 which was connected to @xmath14 in a phase @xmath281 . for this client @xmath174",
    ", we have @xmath282 , since the algorithm will stop increasing @xmath283 when @xmath174 is connected to a fully paid facility ( see fact 1 ) ."
  ],
  "abstract_text": [
    "<S> we present a randomized distributed approximation algorithm for the metric uncapacitated facility location problem . </S>",
    "<S> the algorithm is executed on a bipartite graph in the @xmath0 model yielding a @xmath1 approximation factor , where @xmath2 is an arbitrary small positive constant . </S>",
    "<S> it needs @xmath3 communication rounds with high probability ( @xmath4 denoting the number of facilities and clients ) . to the best of our knowledge </S>",
    "<S> , our algorithm currently has the best approximation factor for the facility location problem in a distributed setting . </S>",
    "<S> it is based on a greedy sequential approximation algorithm by jain et al(j . </S>",
    "<S> acm 50(6 ) , pages : 795 - 824 , 2003 ) . </S>",
    "<S> the main difficulty in executing this sequential algorithm lies in dealing with situations , where multiple facilities are eligible for opening , but ( in order to preserve the approximation factor of the sequential algorithm ) only a subset of them can actually be opened . </S>",
    "<S> note that while the presented runtime bound of our algorithm is `` with high probability '' , the approximation factor is not `` in expectation '' but always guaranteed to be @xmath1 . </S>",
    "<S> thus , our main contribution is a sublinear time selection mechanism that , while increasing the approximation factor by an arbitrary small additive term , allows us to decide which of the eligible facilities to open . </S>"
  ]
}