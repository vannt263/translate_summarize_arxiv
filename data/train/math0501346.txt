{
  "article_text": [
    "we generalise a sifting procedure introduced originally by sims  ( * ? ? ?",
    "* section 4 ) ( see also ( * ? ? ?",
    "* section 2 ) and  ( * ? ? ?",
    "* chapter  4 ) ) for computation with permutation groups .",
    "our version is given in the context of black - box groups , and is based on a chain of subsets rather than a subgroup chain .",
    "the essential ingredient is a scheme for sifting a group element @xmath0 down a descending chain @xmath1 of non - empty subsets of a subgroup @xmath2 of a finite group @xmath3 .",
    "the sifting procedure seeks elements @xmath4 such that , for each @xmath5 , @xmath6 and @xmath7 ; in addition @xmath8 , and @xmath9 or its inverse lies in @xmath10 .",
    "in many instances the @xmath11 will lie in @xmath12 , but this is not required in general .",
    "( conditions on membership for the @xmath11 are given in definition [ basicsiftcond ] ( c ) . )",
    "a major objective of this work is to give a careful presentation of a randomised generalised sifting algorithm with an analysis that proves a guaranteed upper bound on the probability of failure and provides an estimate of the complexity in terms of the input size .",
    "we present our results in a sequence of steps .",
    "this ` modular ' approach enables us to focus in our exposition on the new concepts and methods introduced at each stage .",
    "first we present in section  [ sect : sift ] a skeleton version of the generalised sifting algorithm sift that involves a sequence of basic modules , namely various versions of a procedure called basicsift , for which only the input and output requirements are given explicitly .",
    "we prove in theorem  [ thm : sift ] that the algorithm sift is a las vegas algorithm .",
    "next , in sections  [ sect : mc ] and  [ sect : cl ] , we present more details of the versions of basicsift we have developed , and prove in theorems  [ prop : basic - mc ] and  [ prop : basic - cr ] that for these versions , basicsift is a monte carlo algorithm .",
    "this exposition of basicsift is given in terms of a generic membership test ismember for which only the input and output requirements are given explicitly .",
    "note that the basicsift modules will often be monte carlo algorithms with a non - zero probability of returning an incorrect result .",
    "however the complete algorithm sift is a las vegas algorithm since we can test with certainty that , for our output element @xmath13 , the element @xmath14 is equal to the identity .",
    "( see definition [ algdefs ] for a discussion of these types of algorithms . )    in section  [ sect : conj ] , we introduce a version of ismember based on random conjugates .",
    "it was this version that inspired the development of the conceptual framework presented in the paper .",
    "the idea can best be understood by briefly considering the following special case .",
    "suppose that a finite group @xmath3 has a chain of subgroups @xmath15 and that @xmath16 is such that , for each @xmath17 , the subset @xmath18 of @xmath19-conjugates lying in @xmath20 forms a single @xmath20-conjugacy class @xmath21 .",
    "then for @xmath22 , the conjugate @xmath23 lies in @xmath20 if and only if @xmath24 for some @xmath25 , and , in turn , this holds if and only if @xmath26 .",
    "thus @xmath27 if and only if @xmath28 , that is to say , a membership test for @xmath23 to lie in the subgroup @xmath20 is equivalent to a membership test for @xmath29 to lie in the subset @xmath30 . development of this idea to handle the general case where the subsets @xmath18 split into several @xmath20-conjugacy classes led to the theory presented in section  [ sect : conj ] .",
    "in section  [ sect : orders ] , we give full details of a version of ismember that relies on element orders .",
    "for the corresponding version of basicsift we are then able to provide in corollary  [ final ] , our most comprehensive complexity estimate .    before presenting the theoretical details we give a worked example of our algorithm for the higman - sims sporadic simple group in section  [ example ] .",
    "this example was chosen to illustrate most of the methods that will be developed in the paper .",
    "the original motivation for this research stems from the matrix group recognition project , see @xcite , and in particular the need to recognize constructively all quasi - simple matrix groups over finite fields .",
    "the usual approach has been to design algorithms for recognizing finite quasi - simple groups by their intrinsic properties as abstract groups rather than building different algorithms for each of their different matrix representations .",
    "this has resulted in the development of recognition algorithms for most of the almost simple groups represented as black - box groups ( see @xcite ) .",
    "a black - box group is one in which the elements are represented ( possibly non - uniquely ) as binary strings of bounded length and in which we can perform the following operations ( and only these ) : we can test whether two given strings represent the same group element , and we can produce strings representing the inverse of a given element , and the product of two given elements . in this paper",
    "we give algorithms that involve only these ` black - box operations ' of equality tests , extracting inverses , and multiplying group elements .",
    "thus our algorithms are black - box algorithms .",
    "we are aware of the impressively successful practical algorithms of  @xcite for recognizing sporadic groups based on the theory of involution centralisers",
    ". however , there seemed to be no framework available to analyse the probability of completion or the cost of these algorithms .",
    "our motivation was based on both experience and hope : experience with developing recognition algorithms for finite symmetric and alternating groups in @xcite complete with proofs and complexity analyses ; and hope that the ideas of charles sims could be made effective for black - box groups , where information needed about a permutation or matrix action must be derived from purely group theoretic properties .",
    "success in computing with some of the sporadic simple groups suggested that our new approach would provide an alternative method for recognizing and computing with these groups .",
    "we believe that we have been successful , both theoretically and in practice .",
    "the algorithmic framework presented in this paper offers an effective and convenient means of analysing membership tests for sporadic simple groups and other groups , providing proofs of completion probability and complexity .",
    "the framework offers flexibility in choice of subset chains and types of the basic sifting procedures .",
    "explicit examples of the algorithms have been developed and implemented for several of the sporadic groups and perform very well in practice . in section  [",
    "sect : appns ] we summarise the information about these examples and also present some details concerning the implementations of the procedures presented in this paper .",
    "we emphasise that all groups that occur in this paper are finite .",
    "the aim of this section is to explain our approach using the example of the higman - sims group @xmath31 .",
    "we think of @xmath31 as a group given to us in its most natural representation , that is , a group of permutations with degree  100 . throughout this section",
    "we use various facts concerning @xmath31 , and the validity of these facts can easily be checked using the atlas  @xcite , or a computer algebra package , such as gap  @xcite or magma  @xcite . in order to describe subgroups of @xmath31 we use the notation introduced in the atlas .",
    "suppose that @xmath32 are standard generators in the sense of @xcite for @xmath31 given on the atlas web site  @xcite .",
    "assume that @xmath3 is a black - box group isomorphic to @xmath31 and @xmath33 are standard generators for @xmath3 obtained using the procedure described in the online atlas  @xcite .",
    "then the map @xmath34 can be extended in a unique way to an isomorphism @xmath35 . since @xmath31 is a permutation group , it is possible to compute , using the schreier - sims algorithm , a base and a strong generating set for @xmath31 . using them",
    ", a permutation in @xmath31 can efficiently be written as a word in @xmath36 .",
    "thus , if @xmath37 then @xmath38 , as a word in @xmath29 and @xmath39 , can be computed efficiently .",
    "the constructive recognition of the black - box group @xmath3 requires us to perform the opposite process : given @xmath40 , we must find an element @xmath41 such that @xmath42 .",
    "this is equivalent to writing the element @xmath0 as a word in @xmath29 and @xmath39 .    in order to complete our task , we specify some ( precomputed and stored ) elements and subgroups in @xmath3 .",
    "we use the following important convention :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ every element we introduce in @xmath3 from now on will be expressed as a word in @xmath43 .",
    "similarly , every subgroup of @xmath3 we use will be given with a generating set , and each generator in this set is assumed to be a word in @xmath43 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath44 be a maximal subgroup of @xmath3 isomorphic to @xmath45 .",
    "a generating set for such a subgroup can be found by computing a generating set for a maximal subgroup in @xmath31 isomorphic to @xmath45 , and mapping the generators into @xmath3 using @xmath46 . in the same way",
    ", we find a maximal subgroup @xmath47 in @xmath44 isomorphic to @xmath48 .",
    "let @xmath49 be a cyclic subgroup of @xmath47 of order @xmath50 in a complement @xmath51 for @xmath52 . to be consistent with the notation to be introduced in later sections of the paper",
    "we will denote a generator of @xmath49 by @xmath19 .",
    "we emphasise that this element @xmath19 lies in @xmath49 and is not a standard generator of @xmath31 .",
    "let @xmath19 be an element of order @xmath50 in @xmath49 , and set @xmath53 .",
    "the four generators of @xmath49 are all conjugate to each other in @xmath3 and in @xmath44 ; they fall into two conjugacy classes of @xmath47 , and they are pairwise not conjugate in @xmath49 .",
    "thus there are elements @xmath54 , @xmath55 such that @xmath56 , @xmath57 and @xmath58 .",
    "set @xmath59 , @xmath60 , and @xmath61 .",
    "we therefore have a chain of subgroups @xmath62 with @xmath63 , @xmath64 , @xmath65 , @xmath66 .",
    "let @xmath40 . if we were to perform sims s usual sifting procedure , we would look for an element @xmath67 such that @xmath68 .",
    "the probability that a random @xmath69 satisfies this property is @xmath70 .",
    "what we do instead is as follows .",
    "let @xmath71 .",
    "we look for an element @xmath67 such that @xmath72 . as @xmath73 and @xmath74 ,",
    "the probability that @xmath72 , for a random @xmath69 , is @xmath75 .    in order to make this work",
    ", we must have a membership test for @xmath76 . since @xmath77",
    ", we have , as explained in the introduction , that , for @xmath78 , @xmath79 if and only if @xmath80 . thus to obtain a membership test for @xmath76 , we only need to design a membership test for @xmath44 .",
    "let @xmath78 , and let @xmath81 be a generating set for @xmath44 ; set @xmath82 .",
    "it is clear that @xmath83 if and only if @xmath84 . now about one quarter of the elements of @xmath3 have order  15 or  11 , but no element in @xmath44 has order equal to one of these numbers .",
    "hence we select random elements in @xmath85 .",
    "if such a random element has order  11 or  15 , then we conclude with certainty that @xmath86 .",
    "if , however , after many random selections we do not find an element with order  11 or  15 , then we may say that @xmath83 with a certain high probability . this can be formulated to give a one - sided monte carlo membership test for @xmath76 ;",
    "see section  [ sect : orders ] for details .",
    "the intersection @xmath88 is the union of two conjugacy classes in @xmath47 , namely @xmath89 and @xmath90 where @xmath54 and we set @xmath59 as above .",
    "let @xmath91 denote the set @xmath92 .",
    "as @xmath93 and @xmath94 , we have @xmath95 .",
    "now we seek an element @xmath96 such that @xmath97 .",
    "we will call an element @xmath96 ` good ' if and only if @xmath98 , or equivalently , if and only if @xmath99 .",
    "if @xmath100 is a uniformly distributed random element of @xmath44 and @xmath101 , then @xmath102 is a uniformly distributed random element of the conjugacy class @xmath103 . for each @xmath104",
    "there are @xmath105 choices for @xmath96 such that @xmath106 .",
    "therefore the total number of ` good ' elements is @xmath107 , and so the probability that @xmath100 is ` good ' is @xmath108 .    in order to test whether @xmath99 , recall that @xmath47 is isomorphic to @xmath48 . a deterministic membership test for @xmath47",
    "can easily be designed using the fact that @xmath109 where @xmath110 is the centre of @xmath52 : namely , to test whether an element @xmath22 lies in @xmath47 simply test whether @xmath111 .",
    "the group @xmath49 is cyclic with order  8 .",
    "set @xmath113 where @xmath60 .",
    "as @xmath114 , we obtain @xmath115 .",
    "we look for an element @xmath116 such that , given @xmath98 , we have @xmath117 . using the definition of @xmath118 , we obtain that , given @xmath98 , the condition @xmath117 holds if and only if @xmath119 .",
    "arguing as for the previous case , the probability that , given @xmath98 , a random @xmath116 yields @xmath117 is at least @xmath120 .",
    "it is easy to compute that this number is @xmath121 . at the end of this process we have with high probability that @xmath122 .",
    "therefore after a number of equality tests we obtain a word @xmath123 in @xmath43 such that @xmath124 where @xmath125 . as @xmath126 , using the map @xmath46 , it is easy to compute each element of @xmath127 as a word in @xmath43 . then comparing @xmath128 against the elements of @xmath127 , it is now easy to express @xmath0 as a word in @xmath43 .",
    "thus the main ingredients of this process are a descending chain of subgroups @xmath129 , a sequence of subsets @xmath130 defined in terms of the centraliser of the element @xmath19 , and the sequence @xmath131 of subsets where we take @xmath132 . our sifting procedure progressed through the following descending chain of non - empty subsets : @xmath133 the final step was a series of equality tests with the elements of @xmath134 .",
    "in this section we collect several results that we need in our proofs . for an event @xmath135 , @xmath136 denotes the probability of @xmath135 . for events @xmath137 and @xmath138 , @xmath139 denotes the probability of @xmath137 , given that @xmath138 holds .",
    "we recall that @xmath140 .",
    "the following result from elementary probability theory will often be used in this article .",
    "[ lem : prob ] if @xmath137 , @xmath138 , @xmath141 are events such that @xmath142 , then @xmath143    as @xmath144 and @xmath145 , we obtain @xmath146    [ rem : mc ] if @xmath147 , then @xmath148 .",
    "observe that the function @xmath149 is strictly decreasing for @xmath147 and @xmath150 .",
    "the following is a general version of dedekind s modular law .",
    "its proof can be carried out following that of  @xcite .",
    "[ dede ] if @xmath151 and @xmath152 are subsets and @xmath153 is a subgroup of a group such that @xmath154 then @xmath155 .    in this paper",
    "we use several types of randomised algorithms , that is , algorithms that involve a random choice at some point , so that they do not behave in the same way every time the algorithm is run .",
    "we also use algorithms which involve no random choices , that is , deterministic algorithms .",
    "we collect together here the definitions of these types of algorithms . to aid our exposition",
    "we give slightly different definitions of these algorithm types than normal , and we comment on the differences below .",
    "[ algdefs ] ( a ) let @xmath156 be a real number satisfying @xmath157 .",
    "monte carlo algorithm _ with ` error probability ' @xmath158 is an algorithm that always terminates after a finite number of steps , such that the probability that the algorithm gives an incorrect answer is at most @xmath158 .",
    "( b )  a _",
    "one - sided monte carlo _ algorithm is a monte carlo algorithm which has two types of output ( typically ` yes ' and ` no ' ) , and one of the answers is guaranteed to be correct .",
    "( c )  a _ las vegas algorithm _ with ` failure probability ' @xmath158 ( where @xmath159 ) terminates after a finite number of steps and either returns an answer , or reports failure . an answer , if given , is always correct , while the probability that the algorithm reports failure is at most @xmath158 .",
    "\\(d ) for the purposes of this paper , a _ deterministic algorithm _ is a monte carlo algorithm for which the ` error probability ' @xmath158 is @xmath160 , or equivalently , a las vegas algorithm for which the ` failure probability ' @xmath156 is @xmath160 .",
    "note that our definitions of monte carlo and las vegas algorithms vary from the usual ones in that we allow @xmath158 to be zero .",
    "the reason for this is that some versions of our  algorithm may be deterministic , that is , have zero probability of failure or of returning an incorrect answer . for ease of exposition we decided to treat such an algorithm as a special case of a monte carlo or las vegas algorithm .",
    "in this section we present an algorithm for sifting an element @xmath0 of a finite group @xmath3 down a ( given and precomputed ) descending chain ( [ chain ] ) of subsets of a subgroup @xmath2 of @xmath3 .",
    "the algorithm returns either fail , or a word @xmath161 such that @xmath162 , @xmath6 for each @xmath5 , and @xmath9 or its inverse lies in @xmath10 . if @xmath163 , then ( see theorem  [ thm : sift ] ) the probability that the algorithm returns fail is proved to be at most some pre - assigned quantity @xmath156 .",
    "usually the @xmath11 are returned as words in a given set @xmath164 of generators for @xmath2 , or as straight line programs from the given generating set @xmath164 .",
    "the algorithm is applied in one of the following contexts .    1 .",
    "the element @xmath0 is known to lie in @xmath2 and the purpose of the algorithm is to express @xmath0 as a word in a given generating set . in this context",
    ", theorem  [ thm : sift ] proves that the algorithm fails with probability at most @xmath156 , for some pre - assigned non - negative real number @xmath165 .",
    "hence , in this context , algorithm  [ sift ] is a _",
    "las vegas algorithm_. 2 .",
    "we only assume that @xmath40 , and the aim is to discover whether or not @xmath0 lies in @xmath2 . in this context",
    ", theorem  [ thm : sift ] proves that if the algorithm returns an expression for @xmath0 , then @xmath0 must lie in @xmath2 . on the other hand , if the algorithm returns fail then the element @xmath0 may or may not lie in @xmath2 .",
    "moreover , if @xmath163 , then the probability that the algorithm will return  is less than some pre - assigned real number @xmath158 where @xmath166 .",
    "hence , in this context ( if we interpret the result fail as a finding that @xmath167 ) , algorithm  [ sift ] is a _ one - sided monte carlo algorithm_.    in either case we allow the probability bound @xmath158 to be zero , and in this situation the resulting algorithm is deterministic .",
    "the basic building block for our algorithm is described in the following definition .",
    "[ basicsiftcond ] a @xmath168-tuple @xmath169 is said to satisfy the _",
    "basic sift condition _ in a group @xmath3 , if the following hold :    1 .",
    "@xmath3 is a finite group with a subgroup @xmath2 ; 2 .",
    "@xmath170 and @xmath171 are non - empty subsets of @xmath2 such that either @xmath172 or @xmath173 ; 3 .",
    "@xmath174 is a monte carlo algorithm whose input is a pair @xmath175 , where @xmath40 and @xmath158 is a non - negative real number .",
    "it satisfies the following condition , either for all inputs @xmath176 ( in which case it is a deterministic algorithm ) , or for all inputs @xmath175 with @xmath177 . _",
    "the output @xmath39 is either fail , or an element of @xmath2 such that @xmath178 ( if @xmath173 ) or @xmath179 ( if @xmath180 ) .",
    "moreover , if @xmath181 , then @xmath182 _    to avoid confusion we comment on the formulation of the condition in definition [ basicsiftcond ] ( c ) .",
    "note that @xmath170 is in general not a subgroup , and hence @xmath178 , for @xmath183 , does not imply that either of @xmath39 or @xmath184 lies in @xmath170 .",
    "after considering many special cases , we realised that the set inclusion @xmath178 was the appropriate requirement .",
    "suppose that @xmath3 is a finite group with a subgroup @xmath2 and @xmath185 is a chain of non - empty subsets of @xmath3 , and set @xmath186 .",
    "suppose further that , for @xmath187 , @xmath188 is an algorithm such that @xmath189 satisfies the basic sift condition in @xmath3 .",
    "then there is a las vegas algorithm that , for a given @xmath40 , returns either ` failure ' or an element @xmath190 of @xmath2 such that @xmath6 for each @xmath5 , the element @xmath9 or its inverse lies in @xmath10 , and @xmath191 . indeed , as shown in theorem  [ thm : sift ] , algorithm  [ sift ] has this property .",
    "algorithm  [ sift ] : sift + @xmath192    [ thm : sift ] suppose that @xmath3 , @xmath2 , @xmath193 , and @xmath194 are as in the previous paragraph , and let sift denote algorithm  @xmath195 .",
    "let @xmath40 and @xmath196 be non - negative real numbers such that @xmath197 . then the following hold .    1 .",
    "if @xmath198 returns a group element @xmath29 , then @xmath199 and @xmath200 , where @xmath6 for each @xmath201 , and @xmath202 if @xmath10 contains @xmath203 , while @xmath204 otherwise .",
    "2 .   the conditional probability that @xmath205 returns fail , given that @xmath163 , is at most @xmath206 .",
    "\\(i ) suppose that a group element @xmath207 is returned",
    ". then the @xmath11 are group elements computed as in algorithm  [ sift ] . from definition [ basicsiftcond ] ( c ) , since each @xmath11 is a group element , we have that @xmath6 for each @xmath201 , and also for @xmath208 if @xmath209 ; while if @xmath210 , then @xmath204 .",
    "further , if @xmath209 , then @xmath211 contains @xmath9 , and hence @xmath10 contains @xmath9 .",
    "finally , for each @xmath17 , @xmath11 lies in @xmath2 since the algorithm @xmath188 involves random selections from the group @xmath2 .",
    "moreover , by the last * if * statement of algorithm  [ sift ] we have @xmath162 so that @xmath199 .",
    "\\(ii ) let @xmath212 denote the event that @xmath163 , and recall that @xmath213 and @xmath186 . for each @xmath214 ,",
    "let @xmath215 denote the event that the @xmath17-th execution of the * for * loop in algorithm  [ sift ] is attempted , is successful and returns a correct answer .",
    "in other words , @xmath216 also define @xmath217 to be the event that the final execution of the * for * loop is attempted , is successful and returns a correct answer .",
    "that is , @xmath218 then the probability that algorithm  [ sift ] returns @xmath219 with @xmath6 for all @xmath220 , and @xmath162 , given that @xmath163 , is , by definition , @xmath221 .",
    "now @xmath222 , and hence by several applications of lemma  [ lem : prob ] , we have that @xmath223 . since @xmath224 satisfies the basic sift condition in @xmath3 for each @xmath225 , @xmath226 for each @xmath225 .",
    "hence @xmath227 since @xmath228 for all @xmath17 , we have @xmath229 ( use induction on @xmath230 ) , and hence the required probability in part",
    "( ii ) is at most @xmath231 .",
    "algorithm  [ sift ] allows different types of algorithms to be used for different links of the chain .",
    "for example , if @xmath232 is small , then @xmath233 relies sometimes on nothing more than an exhaustive search through the elements of @xmath232 with the parameter @xmath234 .",
    "two special types of @xmath174 algorithms are described in detail in sections  [ sect : conj ] and  [ sect : orders ] .",
    "we first explore their common properties as one - sided monte carlo algorithms in sections  [ sect : mc ] and  [ sect : cl ] .",
    "in this section we present a general approach to designing a @xmath168-tuple that satisfies the basic sift condition .",
    "the results of this section will become relevant in the discussion of the two algorithms in sections  [ sect : conj ] and  [ sect : orders ] .",
    "we will use one of the general methods given in this section in nearly all cases when we wish to sift an element of @xmath12 into the next subset @xmath235 in a subset chain  .",
    "the exceptional case occurs when @xmath236 and @xmath237 , and , as we mentioned at the end of the previous section , in this exceptional case we would typically use an exhaustive search through @xmath12 to find the required ` sifting element ' .",
    "our general approach assumes that we are able to test membership in each of the @xmath12 and to select a uniformly distributed random element from some subset ` related to ' @xmath12 in the chain  ; see  section  [ example ] for examples .",
    "[ memtest ] a @xmath168-tuple @xmath238 is said to satisfy the _ membership test condition in @xmath3 _ if the following hold :    * @xmath3 and @xmath2 are finite groups such that @xmath239 ; * @xmath170 and @xmath171 are non - empty subsets of @xmath2 such that @xmath240 .",
    "* @xmath241 is a one - sided monte carlo algorithm whose input is a pair @xmath242 , where @xmath183 and @xmath243 is a non - negative real number .",
    "it satisfies the following condition , either for all inputs @xmath244 ( in which case it is a deterministic algorithm ) , or for all inputs @xmath242 with @xmath245 . _",
    "the output is either true or false , and moreover , if @xmath246 then the output is true , and also @xmath247 . _",
    "* note : * for an enhanced version of an @xmath241 test giving back additional information for later use consult the examples for @xmath248 and @xmath249 in section [ sect : appns ] .",
    "we show that if a @xmath168-tuple @xmath238 satisfies the membership test condition in a group @xmath3 , then we can design an algorithm @xmath174 such that @xmath169 satisfies the basic sift condition in @xmath3 .",
    "as mentioned above , we assume that we can select uniformly distributed random elements from some subset @xmath250 of @xmath3 ` related to ' the subset @xmath170 .",
    "the most general conditions that the subset @xmath250 must satisfy are given in the following definition .",
    "[ def : hl ] suppose that @xmath3 is a finite group and @xmath251 .",
    "we say that @xmath252 is a _ sifting triple _ if @xmath253    the reason why we introduce the subset @xmath250 in a sifting triple is that it is rarely possible to make random selections from arbitrary subsets of @xmath3 , such as @xmath170 , but we can often make random selections from subgroups .",
    "thus one choice for @xmath250 is a subgroup satisfying ( [ eq : hl ] ) .",
    "moreover we can sometimes obtain a more efficient algorithm by restricting to a ` nice subset ' @xmath250 of such a subgroup , provided that we can still make random selections from @xmath250 .",
    "sometimes this is possible simply because @xmath250 is small enough to hold in the memory . in that latter case",
    "we do not have to perform a random search , but can use an exhaustive search .",
    "this is analysed in section  [ subsec : cosetreps ] .",
    "if @xmath252 is a sifting triple then the number @xmath254 is called the _",
    "sifting parameter_. we note that the definition of a sifting triple implies that @xmath255 .",
    "the sifting parameter plays an important rle in estimating the complexity of algorithm  [ sift ] .",
    "algorithm  [ basicsift ] : @xmath256[basicsift ] @xmath257",
    "@xmath258 @xmath259    [ prop : basic - mc ] suppose that @xmath238 satisfies the membership test condition in a group @xmath3 and that @xmath250 is a subgroup of @xmath2 such that @xmath252 is a sifting triple .",
    "if @xmath260 returns uniformly distributed , independent random elements of @xmath250 , and  is algorithm  @xmath261 , then the @xmath168-tuple @xmath169 satisfies the basic sift condition in @xmath3 .",
    "moreover the cost of executing @xmath262 is at most @xmath263 where @xmath264 and @xmath265 and @xmath266",
    "are upper bounds for the costs of a group operation in @xmath3 , a random selection from @xmath250 , and one run of the procedure @xmath267 , respectively , where @xmath268 if @xmath241 is deterministic , and @xmath269 otherwise .",
    "if a group element @xmath39 is returned then , by ( [ eq : hl ] ) , @xmath270 .",
    "let @xmath135 denote the event that `` the output of the procedure is either  or an element @xmath39 with @xmath271 '' .",
    "we are required to show that @xmath272 .",
    "suppose that @xmath273 .",
    "for @xmath274 , let @xmath215 denote the event `` the @xmath275-th execution of the procedure  occurs '' ; let @xmath276 denote the element @xmath39 returned by the @xmath275-th execution of , and let @xmath277 denote the result returned by the call to @xmath278 . if @xmath215 does not occur for some @xmath17 then the values of @xmath276 and @xmath277 are undefined .",
    "the event @xmath215 is the disjoint union of the following three events : @xmath279 note that @xmath215 occurs if and only if , for each @xmath280 , the event @xmath281 occurred and @xmath282 , that is to say , @xmath283 .",
    "similarly , given , @xmath273 , the event @xmath135 occurs if and only if either @xmath284 occurs , or , for some @xmath17 , each of @xmath285 occurs , @xmath286 and @xmath287 .",
    "suppose now that @xmath273 , and let @xmath288 such that @xmath271 . then by ( [ eq : hl ] ) , @xmath289 , and hence @xmath290 . by the definition of the membership test condition , the conditional probability @xmath291 that the returned value of @xmath292 is true , given that @xmath290 , satisfies @xmath293 .",
    "let @xmath294 denote the sifting parameter @xmath295 .",
    "since we are making independent uniform random selections , we have , for each @xmath296 , that the probability @xmath297 is independent of @xmath17 , and also that @xmath298 set @xmath299 .",
    "then , using the rule @xmath300 , @xmath301 with @xmath291 as defined above , and similarly @xmath302 .",
    "the procedure finishes when processing the @xmath17-th random element @xmath276 if it has not finished while processing @xmath303 for any @xmath280 , and either @xmath304 or @xmath305 occurs .",
    "in this situation , if @xmath304 occurs , then by the requirements of the membership test condition , the procedure will return @xmath276 with @xmath306 ; similarly , if @xmath305 occurs , then again the procedure will return @xmath276 , but this time with @xmath286 .",
    "thus the procedure returns the element @xmath276 with @xmath286 ( for a particular value of @xmath17 ) if and only if @xmath307 occurs , and @xmath308 it follows that the procedure returns an element @xmath288 with @xmath271 if and only if @xmath305 occurs for some @xmath309 , and the probability of this is @xmath310 since @xmath311 . finally , the procedure returns fail if and only if the event @xmath312 occurs and the probability of this is @xmath313 .",
    "we derive the required estimates of these probabilities as follows .",
    "note that , since @xmath314 and @xmath293 , we have @xmath315 and this is @xmath160 if @xmath268 , and is @xmath316 otherwise . hence , the probability that the procedure returns an element @xmath288 , with @xmath178 and @xmath271 , is @xmath160 if @xmath241 is deterministic , and is at most @xmath316 otherwise .",
    "similarly , the probability that the procedure returns fail is @xmath317 by the definition of @xmath318 , where @xmath319 if @xmath241 is deterministic , and @xmath320 otherwise .",
    "thus @xmath169 satisfies the basic sift condition in  @xmath3 .",
    "finally we estimate the cost . for each run of the * repeat * loop ,",
    "first we select a random element of @xmath250 at a cost of at most @xmath321 .",
    "then we perform a group operation to compute @xmath322 and we run ismember@xmath323 at a cost of at most @xmath324 , where @xmath268 if @xmath241 is deterministic , and @xmath325 otherwise .",
    "the number of runs of the loop is at most @xmath318 and , by lemma  [ rem : mc ] , @xmath318 is @xmath326 .",
    "thus the upper bound for the cost is proved .",
    "( note that , for @xmath165 we have that @xmath327 also . )    as already explained before theorem  [ prop : basic - mc ] , we often work with sifting triples @xmath252 in which @xmath250 is a subgroup of @xmath2 .",
    "usually , there will be another subgroup @xmath328 , which is used to define @xmath171 and we have @xmath329 .",
    "in this situation the following concept applies .",
    "suppose that @xmath3 is a finite group and that @xmath330 are subgroups of @xmath3 .",
    "a non - empty subset @xmath331 of @xmath250 is said to be _ left @xmath332-uniform _ if @xmath331 has the same number of elements in each of the left @xmath332-cosets in @xmath250 . in other words",
    ", @xmath333 is constant for all @xmath334 .",
    "a left @xmath332-uniform subset in @xmath250 must contain a left transversal for @xmath332 in @xmath250 . notice that @xmath250 is left @xmath335-uniform , and more generally ,",
    "if @xmath332 is a subgroup , then any left transversal for @xmath332 in @xmath250 is left @xmath332-uniform . as will become clear in the next lemma , @xmath332-uniform sets @xmath331 have ` nice ' properties with respect to the calculation of probabilities . in certain cases we need to consider sifting triples @xmath336 in which @xmath331 is a left @xmath332-uniform subset in some subgroup @xmath250",
    "for which @xmath252 is also a sifting triple .",
    "we show that in such cases the sifting parameter @xmath337 is independent of the subgroup @xmath332 and the left @xmath332-uniform subset @xmath331 , and depends only on the subgroup @xmath250 .",
    "[ lem : p ] let @xmath338 be a sifting triple in which @xmath250 is a subgroup , let @xmath332 be a subgroup of @xmath250 with @xmath329 , and let @xmath331 be a left @xmath332-uniform subset of @xmath250 .",
    "then @xmath336 is also a sifting triple and @xmath339 .    since @xmath340 and @xmath341",
    ", it follows that @xmath342 .",
    "let @xmath343 . we shall show that @xmath344",
    ". the result will then follow . by ( [ eq : hl ] ) ,",
    "note that , since @xmath332 is a subgroup of @xmath250 , and since @xmath331 is left @xmath332-uniform , it follows that @xmath346 , and @xmath347 .",
    "in addition , we have @xmath348 .",
    "thus lemma  [ dede ] implies that @xmath349 , and in particular , @xmath350 is a union of @xmath351 left @xmath332-cosets , for some @xmath352 .",
    "each of these cosets is contained in @xmath353 and hence is of the form @xmath354 for some @xmath355 .",
    "thus @xmath356 for some @xmath357 .",
    "further , since @xmath331 is left @xmath332-uniform , the size @xmath358 is independent of @xmath17 .",
    "moreover , for each @xmath359 , @xmath360 , and since @xmath361 it follows that @xmath362 and therefore @xmath363 . on the other hand , @xmath364 has size @xmath365 . since @xmath331 has exactly @xmath366 elements in each of the left @xmath332-cosets in @xmath250 , we have @xmath367 , and hence @xmath368 proving the claim .",
    "we now turn to a second general approach to designing a @xmath168-tuple that satisfies the basic sift condition .",
    "this algorithm is defined for the case when we have a sifting triple @xmath252 and a subgroup @xmath369 as in lemma  [ lem : p ] . unlike algorithm  [ basicsift ] , where we choose elements of @xmath250 at random , algorithm  [ basicsiftcr ] deterministically tests every element of a complete set @xmath331 of left coset representatives calculated beforehand .",
    "thereby we turn the random search above into a deterministic exhaustive search .",
    "as will be explained below , this can reduce the expected value of the runtime significantly .",
    "we use algorithm  [ basicsiftcr ] when the index of @xmath332 in @xmath250 , and thus the size of @xmath331 , is small enough to allow @xmath331 to be stored completely .",
    "we still allow the use of randomised or deterministic methods . in the latter case ,",
    "the whole basic sift procedure is deterministic .",
    "we would like to draw attention to a little trick we use to simplify the analysis of the error probability of algorithm  [ basicsiftcr ] .",
    "we artificially introduce a randomly chosen order in which the coset representatives are tried .",
    "this makes the analysis less dependent on the input group element .",
    "algorithm  [ basicsiftcr ] : [ basicsiftcr ] @xmath370",
    "@xmath371    [ prop : basic - cr ] suppose that @xmath238 satisfies the membership test condition in a group @xmath3 .",
    "assume further that @xmath250 is a subgroup of @xmath2 , such that @xmath252 is a sifting triple , that @xmath328 with @xmath372 , and that @xmath373 is a left transversal of @xmath332 in  @xmath250 .",
    "if , for any @xmath374 , @xmath375 returns uniformly distributed , independent random elements of @xmath376 , and is algorithm  @xmath377 , then the @xmath168-tuple @xmath169 satisfies the basic sift condition in @xmath3 .    the cost of executing @xmath378 is less than @xmath379 where @xmath380 is an upper bound for the cost of selecting a random element from a subset of @xmath331 , @xmath381 and @xmath266 are upper bounds for the costs of a group operation in @xmath3 , and one run of the procedure @xmath382 , respectively . here",
    "@xmath268 if @xmath241 is deterministic , and @xmath383 otherwise , where @xmath384 .",
    "we remark first , that for every @xmath385 there is an element @xmath386 such that @xmath387 by hypothesis  ( [ eq : hl ] ) . as @xmath331 is a left transversal for @xmath332 in @xmath250 , there are @xmath388 and @xmath389 such that @xmath390 .",
    "now @xmath391 , and so @xmath392 .",
    "therefore , if @xmath385 , then algorithm  [ basicsiftcr ] can not return fail , as the test is one - sided monte carlo . also , this argument proves all statements in the theorem in the case where is deterministic .",
    "thus from now on we will assume that is not deterministic , and therefore that @xmath393 , and hence @xmath243 is non - zero .",
    "as @xmath394 , the set @xmath170 is a union of left @xmath250-cosets , and , a fortiori , also a union of left @xmath332-cosets .",
    "analogously , @xmath372 means that @xmath171 is a union of left @xmath332-cosets , and , of course , so is @xmath395 .",
    "for any given @xmath0 , the algorithm looks for a random element @xmath39 in @xmath396 such that @xmath397 ; in other words , it searches the coset @xmath398 for elements of @xmath171 .",
    "thus , the number of elements @xmath388 with @xmath399 is equal to the number of left @xmath332-cosets contained in @xmath400 .",
    "let @xmath181 .",
    "as , by lemma  [ lem : p ] , @xmath339 , and @xmath401 we obtain that @xmath402    let @xmath135 denote the event `` the procedure returns @xmath403 with @xmath404 '' . to check the basic sift condition for algorithm  [ basicsiftcr ] in the case of a randomised test , we have to show that @xmath405 .",
    "suppose now that @xmath181 .",
    "for @xmath406 , let @xmath215 denote the event : `` the @xmath17-th execution of the procedure randomelement occurs '' ; let @xmath276 denote the element @xmath39 returned by the @xmath17-th execution of the procedure @xmath407 , and let @xmath277 denote the result returned by the call to @xmath408 ( for steps @xmath17 that do not happen , @xmath276 and @xmath277 are undefined ) .",
    "then @xmath215 is the disjoint union of the following three events : @xmath409    note that @xmath215 occurs if and only if , for each @xmath280 , the event @xmath281 occurred and @xmath282 , that is to say , @xmath410 . similarly , given @xmath181 , the event @xmath135 occurs if and only if , for some @xmath17 , each of @xmath411 occurs , @xmath412 , and @xmath287 .",
    "thus , given @xmath181 , the event @xmath135 occurs if and only if , @xmath413 occurs for some @xmath17 with @xmath414 .",
    "since in step @xmath17 we choose @xmath276 only among those coset representatives that have not been tried before and we only reach step @xmath17 if @xmath415 for @xmath416 , the probability @xmath417 is not independent of @xmath17 .",
    "namely , @xmath418 where @xmath419 , as in step @xmath17 there are @xmath420 coset representatives in the set @xmath376 of which @xmath421 do not multiply @xmath0 into @xmath171 .",
    "it is easy to see that @xmath422 and so @xmath423 similarly we have @xmath424    as in the proof of theorem  [ prop : basic - mc ] , algorithm  [ basicsiftcr ] finishes in step @xmath17 , if it has not finished in an earlier step , and @xmath304 or @xmath305 occurs . in this situation ,",
    "if @xmath304 occurs , then the procedure will return @xmath276 with @xmath425 , which is a correct result .",
    "therefore , an error produced by step @xmath17 occurs exactly in the event @xmath305 , and @xmath426 moreover , no error can possibly occur in step @xmath17 for @xmath427 .",
    "therefore , for an input @xmath428 with @xmath181 , the total probability that algorithm  [ basicsiftcr ] returns an element @xmath429 with @xmath430 is @xmath431 note that , for @xmath432 , @xmath433 hence @xmath434 we can simplify the sum further by repeated use of the well known summation formula for binomial coefficients : @xmath435 the last summand ( with @xmath436 ) is equal to @xmath437 . in the latter form",
    "it can be added to the second last summand resulting in @xmath438 .",
    "this can be repeated until the first summand , thereby proving that @xmath439 this , however , implies that the total probability of an error is @xmath440 thus , as @xmath441 , for an arbitrary element @xmath385 , the error probability is bounded by @xmath442    as for the cost , the loop terminates at the latest after @xmath230 steps , each of which has a random element selection from @xmath376 , one group multiplication for computing @xmath443 , and one call to @xmath241 .    our hypotheses in theorem  [ prop : basic - cr ] imply that @xmath331 is @xmath332-uniform .",
    "however , since we want to store @xmath331 completely , there is no point in choosing left @xmath332-uniform sets with two or more elements in each left @xmath332-coset of @xmath250 .      to compare",
    "algorithms  [ basicsift ] and  [ basicsiftcr ] , assume that @xmath250 is a subgroup and we want to sift from a set @xmath170 with @xmath444 down to a set @xmath171 with @xmath348 , and that @xmath328 with @xmath445 = k$ ] .",
    "then we can either use algorithm  [ basicsift ] or use algorithm  [ basicsiftcr ] with @xmath331 being a left transversal of @xmath332 in @xmath250 .",
    "recall that @xmath446 , say ( see lemma  [ lem : p ] ) .",
    "let @xmath230 denote the index @xmath447 , and let @xmath448 denote @xmath449 .",
    "in the second case we have to calculate and store @xmath331 beforehand . in algorithm",
    "[ basicsiftcr ] , once we compute that a random element @xmath39 does not multiply @xmath0 into @xmath171 , @xmath39 can not be selected again by a subsequent call of @xmath407 .",
    "therefore we expect that algorithm  [ basicsiftcr ] performs better than algorithm  [ basicsift ] in this situation .    in algorithm  [ basicsift ]",
    "the bound for the error probability in all calls of the test is @xmath450 ( recall that @xmath451 ) , whereas in algorithm  [ basicsiftcr ] the bound for the error probability for the @xmath241 calls is @xmath452 ( at least when @xmath156 is not too big so that @xmath453 is not defined to be @xmath454 ) , which is a little bit more than @xmath455 .",
    "thus , due to the deterministic nature of the choice of @xmath39 in algorithm  [ basicsiftcr ] , we can afford bigger error bounds for the @xmath241 tests .",
    "further , the expected number of steps in algorithm  [ basicsift ] is @xmath456 ( geometric distribution ) , which is @xmath457 as @xmath458 .",
    "the expected number of steps in algorithm  [ basicsiftcr ] is @xmath459 .",
    "these calculations suggest that , whenever it is possible to store all elements of @xmath331 , algorithm  [ basicsiftcr ] should be preferred over algorithm  [ basicsift ] .",
    "if the @xmath241 test is deterministic and happens to work not only for elements of @xmath170 , but also for arbitrary elements of @xmath460 , then one can dispense with the hypothesis @xmath461 altogether and apply algorithm  [ basicsiftcr ] verbatim for any set @xmath462 satisfying @xmath463 for all @xmath464 . in this case algorithm  [ basicsiftcr ] will be a fully deterministic algorithm with guaranteed finite runtime of at most @xmath465 steps .",
    "in this section we describe a rather general situation where the conditions in ( [ eq : hl ] ) are guaranteed to hold .",
    "the conditions on the subsets @xmath170 , @xmath171 of the finite group @xmath3 are as follows : @xmath466    under these conditions we derive also a new expression for the sifting parameter @xmath295 required for algorithm  [ basicsift ] and theorem  [ prop : basic - mc ] .",
    "[ prop : localhk ] let @xmath3 , @xmath250 , @xmath332 , @xmath141 , @xmath467 , @xmath170 , and @xmath171 be as above so that  ( [ localhk ] ) holds",
    ". then @xmath468 , and if @xmath469 then @xmath252 is a sifting triple .",
    "further , @xmath470 where @xmath471 is a set of representatives in @xmath467 for the left @xmath250-cosets contained in @xmath170 .",
    "since @xmath472 we have @xmath473 , that is , @xmath468 .",
    "note that , since @xmath474 , we have @xmath475 and @xmath476 .",
    "suppose now that @xmath477 .",
    "since @xmath478 and @xmath250 is a subgroup , it follows that @xmath340 .",
    "let @xmath479 . to complete the proof of",
    ", we need to show that @xmath480 is non - empty . since @xmath479 and @xmath481 we have @xmath482 where @xmath483 , @xmath484 , and hence @xmath485 and @xmath486 . as @xmath475",
    ", we obtain @xmath487 .",
    "thus @xmath488 .",
    "now it only remains to show that the assertion in the displayed line of the proposition is valid .",
    "it follows from   that , for @xmath479 , @xmath489 , by dedekind s modular law ( lemma  [ dede ] ) .",
    "hence , for all @xmath479 , we have @xmath490 suppose that @xmath479 and @xmath482 where @xmath483 and @xmath484 .",
    "then @xmath491 and so the minimum value of @xmath492 over all @xmath479 is equal to the minimum value of @xmath493 over all @xmath494 .",
    "the displayed assertion follows .",
    "we will apply algorithm  [ basicsift ] with @xmath170 , @xmath171 as in ( [ localhk ] ) in the following context : @xmath2 is a subgroup of a finite group @xmath3 , the group @xmath2 has a descending subgroup chain @xmath495 and also has a sequence of non - empty subsets @xmath496 thus ( [ localhk ] ) holds for @xmath497 for each @xmath5 . by proposition  [ prop : localhk ]",
    ", we have a descending chain @xmath498 and by proposition  [ prop : localhk ] , algorithm  [ basicsift ] applies to each of the pairs @xmath499 such that @xmath500 ( @xmath501 ) . thus if , for @xmath502 , the @xmath168-tuple @xmath503 satisfies the membership test condition in @xmath3 for some algorithm @xmath504 , and",
    "if we have an algorithm @xmath505 such that the @xmath168-tuple @xmath506 satisfies the basic sift condition in @xmath3 , then we may use the procedures @xmath188 in algorithm  [ sift ] .",
    "if @xmath507 is small , @xmath233 may simply test each member of @xmath508 for equality with the input element ( if @xmath509 ) , or its inverse ( if @xmath510 ) .",
    "the next two sections offer some possibilities for these procedures that have been effective for computing with some of the sporadic simple groups .",
    "in this section we apply the theory developed in sections  [ sect : mc ] and  [ sect : cl ] , especially in section  [ sect : cl ] , to sift an element down a subgroup chain such as ( [ lchain ] ) making use of an auxiliary subset sequence .",
    "this application uses conjugates of an element @xmath19 with the following property : @xmath511 we construct an associated subset sequence ( [ cchain ] ) recursively as follows .",
    "the first subset is @xmath512 where @xmath513 .",
    "consider a typical link in the chain ( [ lchain ] ) , say @xmath514 for @xmath515 , and suppose that we have already constructed the subset @xmath516 corresponding to @xmath517 , and @xmath516 is of the form @xmath518 , where @xmath519 is a set of @xmath517-conjugacy class representatives in @xmath520 .",
    "then @xmath521 , and by condition ( [ a ] ) , each @xmath522 is non - empty . for each @xmath523 , choose @xmath524 such that @xmath525 is a set of representatives for the @xmath526-conjugacy classes in @xmath522 .",
    "define @xmath527 , and define the subset @xmath528 corresponding to @xmath526 by @xmath529 .",
    "in addition set @xmath530 .",
    "we prove that ( [ localhk ] ) holds , and we also derive two expressions for the sifting parameter @xmath295 required for algorithm  [ basicsift ] and theorem  [ prop : basic - mc ] .",
    "the first expression shows that @xmath295 is a ratio of the sizes of two special subsets of conjugates of the element @xmath19 , while the second expression provides a means of computing @xmath295 from the orders of various centraliser subgroups .",
    "[ prop : conj ] suppose that @xmath3 , @xmath2 , @xmath19 , @xmath517 , @xmath526 , @xmath516 , @xmath528 , @xmath531 , @xmath532 , and the @xmath533 , for @xmath534 , are as at the beginning of this section , and set @xmath535 , @xmath536 , @xmath537 , @xmath538 and @xmath539 .",
    "then @xmath540 and   holds , and if also @xmath541 , then @xmath252 is a sifting triple .",
    "further , @xmath542    by the definition of @xmath543 , we have that @xmath544 . also , since   holds , for each @xmath545 there exists @xmath546 such that @xmath547 .",
    "thus @xmath548 , and so , since @xmath517 is a subgroup , we have @xmath549 hence @xmath540 . to prove   it is sufficient to prove that @xmath550 . from the definition of @xmath170 we have @xmath551 thus   holds .",
    "moreover , if @xmath469 , then , by proposition  [ prop : localhk ] , then @xmath252 is a sifting triple .    it remains to show that the value of the sifting parameter @xmath295 is as claimed .",
    "suppose that @xmath343 , and that @xmath552 with @xmath553 , @xmath554 , and @xmath546 .",
    "we claim that @xmath555 . as @xmath546 , we certainly have @xmath556 .",
    "an easy calculation shows that @xmath557 , and so @xmath558 .",
    "therefore @xmath559 . finally ,",
    "by dedekind s modular law ( lemma  [ dede ] , which applies since @xmath560 ) , we obtain @xmath561 proving our claim .",
    "next we show that @xmath562 , with @xmath533 as defined before proposition  [ prop : conj ] ( recall that @xmath534 ) .",
    "let @xmath563 , so that @xmath564 for some @xmath546 and @xmath565 .",
    "since @xmath566 , it follows that @xmath567 . by the definition of @xmath532",
    ", there is some @xmath568 such that @xmath569 , and so @xmath570 .",
    "therefore @xmath571 , and we obtain that @xmath572 . conversely consider @xmath573 , where @xmath574 and @xmath575 . as @xmath576 , we have @xmath577 .",
    "further , @xmath578 . thus @xmath579 .",
    "therefore our claim is proved .",
    "putting the calculations in the last two paragraphs together , we have shown , for @xmath552 with @xmath553 , @xmath580 , and @xmath546 , that @xmath581 now we calculate the size of @xmath582 .",
    "we first observe that @xmath582 is a union of left @xmath526-cosets , and hence , it suffices to compute the number of such cosets contained in @xmath582 . if @xmath583 and @xmath584 are distinct elements of @xmath585 , then @xmath586 and @xmath587 , and so it follows from the definition of @xmath585 that @xmath588 and @xmath589 are distinct conjugacy classes in @xmath526 .",
    "thus @xmath590 and @xmath591 are disjoint .",
    "therefore @xmath582 is the disjoint union , over all @xmath592 , of @xmath593 .",
    "let @xmath594 .",
    "then @xmath595 if and only if @xmath596 .",
    "thus the number of left @xmath526-cosets in @xmath593 is @xmath597 .",
    "hence , the definition of @xmath585 implies that @xmath598 thus @xmath599 and also @xmath600 therefore we obtain that the displayed assertions for the sifting parameter also hold .",
    "the main benefit of working with conjugates is that , using the notation of proposition  [ prop : conj ] , membership of @xmath29 in @xmath170 or @xmath171 is equivalent to membership of @xmath23 in @xmath517 or @xmath526 , respectively ; see lemma  [ lem : conj1 ] .",
    "it is often easier to test whether a random conjugate of a known element lies in a subgroup than to test membership of a random element in a subgroup or subset .",
    "this is true in particular if we have detailed information about subgroups of @xmath517 or @xmath526 generated by two @xmath19-conjugates .",
    "algorithm  [ newismember ] : @xmath601 + @xmath602    [ lem : conj1 ] let @xmath3 , @xmath2 , @xmath19 , @xmath517 , @xmath526 , @xmath516 , @xmath528 , @xmath531 , @xmath532 , be as in proposition  [ prop : conj ] , set @xmath535 and @xmath536 , and let @xmath22 .    1 .   the element @xmath273 if and only if @xmath603 , and similarly , @xmath604 if and only if @xmath605 .",
    "if @xmath606 satisfies the membership test condition in @xmath3 , for some algorithm @xmath241 , then so does @xmath607 where the algorithm @xmath601 is given by  @xmath608 .",
    "it follows from the definition of @xmath609 that @xmath610 .",
    "the first assertion in part ( a ) is then obvious , and the second follows similarly .    to prove part ( b ) , recall the second assertion of part ( a ) , namely that @xmath604 if and only if @xmath605 . if this condition holds then the membership test condition ( see definition  [ memtest ] ) on @xmath241 implies that @xmath611 and hence we obtain @xmath612",
    ". also , by part ( a ) , @xmath613 if and only if @xmath614 . by the membership test condition on @xmath241 we have @xmath615 and hence by the ` definition ' of @xmath601 in algorithm  [ newismember ] , @xmath616",
    "thus the membership test condition holds for @xmath607 in @xmath3 .    by lemma  [ lem : conj1 ] , we can use @xmath617 to replace the algorithm @xmath292 in the @xmath174 algorithm  [ basicsift ] .",
    "some explicit instances of ismember will be discussed in section  [ sect : appns ] .",
    "we discuss here one special case , namely where @xmath618 . here",
    "it turns out that lemma  [ lem : conj1 ] applies with @xmath619 . before proving this assertion in lemma  [ lem : conj2 ] below",
    ", we make a few comments about the context in which it will arise .",
    "( this context below occurs in several applications to sporadic simple groups . )",
    "if condition ( [ a ] ) holds for a subgroup chain ( [ lchain ] ) , then we construct , as at the beginning of this section , subsets @xmath609 and @xmath518 , for each @xmath17 , such that ( [ cchain ] ) and ( [ clchain ] ) both hold .",
    "note that @xmath620 and that @xmath621 for each @xmath17 ; see proposition  [ prop : conj ] .",
    "also @xmath622 , for all @xmath623 .",
    "this means that @xmath624 contains @xmath19 , and hence contains @xmath625 .",
    "thus @xmath626 contains an element of @xmath627 .",
    "in particular , if @xmath628 , then @xmath629 contains an element of @xmath630 .",
    "( note , however , that this element of @xmath609 need not be equal to @xmath203 . )    it is tempting to consider refining the chain ( [ lchain ] ) by inserting the subgroup @xmath631 to obtain a new chain with second last subgroup equal to @xmath631",
    ". however condition ( [ a ] ) may fail to hold for this new chain .",
    "for example if the original @xmath632 then @xmath19 is an involution , and @xmath633 , but only one of the three @xmath634-conjugacy classes in @xmath635 meets @xmath631 non - trivially .",
    "nevertheless , the situation @xmath636 arises often in applications , so we end this section by extending the framework to include this case .    [",
    "lem : conj2 ] suppose that @xmath3 , @xmath2 , @xmath19 , @xmath517 , @xmath526 , @xmath516 , @xmath528 , @xmath531 , @xmath532 are as in proposition  @xmath637 , that @xmath535 , @xmath536 , and that @xmath638 . then @xmath639 and @xmath640 moreover , if @xmath641 satisfies the membership test condition in @xmath3 , for some algorithm @xmath241 , then so does @xmath642 where the algorithm @xmath601 is given by  @xmath608 .    by the definition of @xmath532 and @xmath526 @xmath643 however , @xmath526 centralises @xmath644 and so @xmath645 , which implies that @xmath646 moreover , since @xmath647 , we obtain that @xmath648 .",
    "since @xmath526 is abelian , @xmath649 , and since @xmath650 acts on the set of @xmath651 generators of @xmath631 , with kernel @xmath630 and with @xmath652 as one of the orbits , it follows that @xmath653 .",
    "the final assertion is part ( b ) of lemma  [ lem : conj1 ] .",
    "in this section we present a version of basicsift that has proved useful especially for the first link in a chain such as ( [ chain ] ) for several sporadic simple groups @xmath3 .",
    "it requires the relevant subsets to be subgroups .",
    "we give some applications that use this version in section  [ sect : appns ] .    as in section  [",
    "sect : conj ] , we will describe a version of the procedure ismember that can be used in the @xmath174 algorithms  [ basicsift ] and  [ basicsiftcr ] .",
    "let @xmath3 and @xmath2 be finite groups such that @xmath239 , and suppose that @xmath170 and @xmath171 are subgroups of @xmath2 , with @xmath654 .",
    "therefore condition ( [ eq : hl ] ) automatically holds with @xmath655 .",
    "an extra requirement is that for all subgroups @xmath656 such that @xmath657 , a reasonable proportion of the elements of @xmath656 have orders that do not occur as orders of elements in @xmath171 .",
    "we define @xmath658 assume that @xmath659 and let @xmath660 be a number such that for all @xmath656 with @xmath657 the proportion of the elements of @xmath656 with orders in @xmath661 is at least @xmath660 .",
    "we suppose that @xmath662 . as usual",
    "we assume that random selections in the procedure are made independently and uniformly from the relevant subgroups . moreover , we emphasise that this is a ` black - box algorithm ' , and in particular it is not easy to find the order of an element efficiently . to test if an element @xmath0 has a particular order @xmath663 , we check first that @xmath664 which implies that the order of @xmath0 divides @xmath448 , and then , for each maximal proper divisor @xmath665 of @xmath448 , we test that @xmath666 .",
    "we define @xmath667 to be the number of integers that are either equal to or a maximal proper divisor of an element of @xmath661 . then for @xmath163 we can test if the order of @xmath0 lies in @xmath661 by examining @xmath667 powers of @xmath0 .",
    "algorithm  [ ismember - orders ] : ismemberorders + @xmath668    [ prop : orders ] suppose that @xmath3 , @xmath2 , @xmath170 , @xmath171 , @xmath661 , @xmath667 , and @xmath660 are as above .",
    "also suppose that , for any @xmath656 satisfying @xmath669 , @xmath670 returns uniformly distributed , independent random elements of @xmath656 . then @xmath671 satisfies the membership test condition in @xmath3 , where ismember is algorithm  @xmath672 .",
    "further , the cost of running @xmath673 is @xmath674 where @xmath675 is the maximum integer in @xmath661 , and @xmath381 , @xmath321 are upper bounds for the costs of a group operation in @xmath3 , and making a random selection from any subgroup of the form @xmath676 ( @xmath40 ) , respectively .    *",
    "remark : * in algorithm  [ ismember - orders ] we have to make a random selection from a possibly different group @xmath677 for every step of the loop . because the known algorithms for producing ( pseudo- ) random elements in groups all involve an initialisation phase",
    ", the constant @xmath321 here could be much bigger than the constant @xmath678 or even the corresponding constant @xmath321 in other algorithms of this paper .    if @xmath246 , then by one of the conditions on the input , no element of @xmath679 has order in @xmath661 , and hence the output is true .",
    "now suppose that @xmath680 so that @xmath681 . by assumption , the proportion of elements of @xmath682 with order in @xmath661 is at least @xmath660 .",
    "thus , after @xmath318 independent random selections from @xmath682 , the probability that we do not find at least one element with order in @xmath661 is at most @xmath683 .",
    "the definition of @xmath318 implies that @xmath684 .",
    "thus the membership test condition is satisfied .",
    "now we estimate the cost . for each random @xmath685 , we compute @xmath686 for each @xmath448 that is either equal to or a maximal divisor of an element of @xmath661 .",
    "we do this by first computing @xmath687 , where @xmath688 .",
    "we use these elements to compute @xmath686 , for each relevant @xmath448 , with at most @xmath689 group multiplications .",
    "thus the cost of computing all of the relevant @xmath686 is at most @xmath690 .",
    "the number of random @xmath691 to be processed is at most @xmath318 , which , by lemma  [ rem : mc ] , is @xmath692 .",
    "thus an upper bound for the cost is @xmath693 .    in most cases",
    "when algorithm  [ ismember - orders ] is used , we have that @xmath171 is maximal in @xmath170 , and so the only possibility for @xmath656 in proposition  [ prop : orders ] is @xmath171 or @xmath170 .",
    "also it is often true that @xmath661 consists entirely of primes , and then @xmath694 .",
    "[ final ] use the notation of proposition  @xmath695 and suppose that @xmath696 .",
    "let @xmath174 be algorithm  @xmath261 with algorithm  @xmath672 as @xmath241 .",
    "then the cost of executing @xmath697 with @xmath698 is @xmath699 where @xmath321 is the cost of selecting a random element of @xmath170 , @xmath700 is an upper bound for the cost of selecting a random element from a subgroup of the form @xmath701 , where @xmath273 , and @xmath381 is the cost of a group operation in @xmath3 .    using the notation of theorem  [ prop : basic - mc ] , since @xmath702 , we have @xmath703 , which is @xmath704 .",
    "thus , by theorem  [ prop : basic - mc ] and proposition  [ prop : orders ] , the cost of this version of basicsift@xmath705 is @xmath706 where @xmath707 .",
    "now @xmath708 and the assertion follows .",
    "in section  [ example ] we presented a simple algorithm to write an element of @xmath31 as a word in a given generating set .",
    "this algorithm served as an example for the theory developed in this paper .",
    "we now examine how the steps of the @xmath31 algorithm in section  [ example ] fit into the theoretical framework presented in the subsequent sections .",
    "we use the notation of section  [ example ] .    as in section",
    "[ example ] , @xmath3 is a group isomorphic to @xmath31 , and we set @xmath709 .",
    "let @xmath44 be a maximal subgroup of @xmath3 isomorphic to @xmath45 .",
    "then @xmath44 has a subgroup @xmath153 of order  16 .",
    "we noted in section  [ example ] that the proportion of elements of order @xmath710 or @xmath711 in @xmath31 is @xmath712 , while @xmath44 does not contain any such element .",
    "let @xmath713 be algorithm  [ ismember - orders ] with @xmath714 and @xmath715 .",
    "then , by proposition  [ prop : orders ] , @xmath716 satisfies the membership test condition in @xmath3 .",
    "let @xmath71 where @xmath717 and @xmath718 as in section  [ example ] and let @xmath719 be algorithm  [ newismember ] with @xmath713 as @xmath241 .",
    "then , by lemma  [ lem : conj1 ] , @xmath720 also satisfies the membership test condition in @xmath3 , and we use algorithm  [ basicsift ] to obtain an algorithm @xmath721 such that @xmath722 satisfies the basic sift condition in @xmath3 .    in the next step",
    "we recall that @xmath723 .",
    "we noted that @xmath724 , and so it is easy to design a deterministic algorithm @xmath725 such that the @xmath168-tuple @xmath726 satisfies the membership test condition in @xmath3 ( just check whether a generator for @xmath727 is mapped into @xmath727 ) .",
    "we set @xmath728 as in section [ sect : secondsubset ] .",
    "using algorithm  [ newismember ] , we find an algorithm @xmath729 , using @xmath725 as @xmath241 , such that @xmath730 also satisfies the membership test condition in @xmath3 , and we use algorithm  [ basicsift ] to build an algorithm @xmath731 so that @xmath732 satisfies the basic sift condition in  @xmath3 .",
    "as @xmath49 is a cyclic group of order  @xmath50 and @xmath733 as in section [ sect : thirdsubset ] , it is easy to check membership in @xmath49 , and following the procedure explained above , it is easy to obtain an algorithm @xmath734 such that @xmath735 satisfies the basic sift condition in  @xmath3 . in section  [ example ]",
    "we set @xmath125 , and , using this fact , we can easily test membership in @xmath134 . thus the @xmath168-tuple @xmath736 can be constructed .    finally , it is possible to list all 16 elements of @xmath134 and , via an exhaustive search , to construct an algorithm @xmath737 such that @xmath738 satisfies the basic sift condition in  @xmath3 .",
    "algorithm  [ sift ] can be used with @xmath722 , @xmath732 , @xmath735 , @xmath736 , and @xmath738 to sift an element through the chain @xmath739",
    "an important part of the research presented here is to find explicitly a suitable subset chain   and a @xmath174 algorithm for each step in this chain for many sporadic simple groups .",
    "note that all example chains in this section provide pure black - box algorithms .",
    "no particular prior knowledge about the representations of the groups is used during the sifting . of course , to construct the chains we made heavy use of lots of available information and especially of nice representations .    in the implementations ,",
    "all occurring group elements are expressed as straight line programs in terms of standard generators in the sense of @xcite and @xcite .",
    "one could improve the performance by using specially crafted @xmath241 tests relying on specific information about the given representation .",
    "also , other methods will be better for certain representations .",
    "in this section we assume that @xmath740 is one of the sporadic simple groups . for each group",
    "@xmath3 a subset @xmath12 in the chain   will be a product @xmath741 with suitable @xmath19 , @xmath531 , and @xmath517 .",
    "we also set @xmath742 and the sequence @xmath743 will be referred to as a _",
    "@xmath141-sequence_. the ingredients @xmath19 , @xmath517 , @xmath531 are in the tables below . in order to present the subset chains in the most compact form , we use the following notation .    * the @xmath19-column . * if the function is used to sift through this step of the subset chain , then this column specifies the conjugacy class of @xmath19 used by .",
    "the conjugacy class is given using the atlas notation ; see @xcite .",
    "we can assume without loss of generality that @xmath19 is contained in all subgroups @xmath517 where we need the hypothesis @xmath744 .",
    "if the function is not used in this step of the chain then a dash is displayed in the appropriate cell .    *",
    "the @xmath127-column .",
    "* this column contains information about the centralisers occurring in the @xmath141-sequence @xmath745 .",
    "note that the @xmath516 satisfy the conditions in ( [ cchain ] ) .    *",
    "the @xmath746-column . * here we only specify the number of elements in @xmath609 . in each of the examples , we set @xmath747 and , for @xmath748",
    ", the subset @xmath749 is constructed using the procedure at the beginning of section  [ sect : conj ] .    * the @xmath517-column .",
    "* in each table we list the subgroups @xmath750 that are used to construct the subgroup chain  ; this chain will be referred to as the @xmath250-chain .",
    "each such subgroup is specified as precisely as necessary to define the descending subset chain .",
    "for example , in @xmath31 , the group @xmath44 is specified as @xmath45 ( atlas notation , see @xcite ) , which means that any subgroup of @xmath3 that is isomorphic to @xmath45 can play the rle of @xmath44 .",
    "similarly , one may take @xmath47 to be any subgroup of @xmath44 that is the semidirect product of an extraspecial group of order @xmath751 and a 2-group , as explained in the corresponding cell of the table .    *",
    "the @xmath294-column . * in this column we display the sifting parameter @xmath752 ( see definition [ def : hl ] and proposition [ prop : conj ] ) .    * the @xmath174-column ( bs ) . *",
    "we describe the @xmath174 algorithm that is used in a particular step of the subset chain .",
    "the letter r stands for ( see algorithm [ basicsift ] ) and the letter c stands for ( see algorithm [ basicsiftcr ] ) . note that in some cases algorithm [ basicsiftcr ] is also used to try a certain set of group elements , such as the set @xmath531 or its inverses .",
    "* the @xmath241-column . * in this column we describe , how we test membership in the subgroup @xmath517 .",
    "if an @xmath19 is specified in the @xmath19-column , then we first design an algorithm @xmath241 for the pair @xmath753 using the parameters in the same cell of the table .",
    "then we use algorithm  [ newismember ] to obtain a new algorithm @xmath241 for the pair @xmath754 , and finally , algorithm  [ basicsift ] yields a @xmath168-tuple @xmath755 satisfying the basic sift condition in  @xmath3 .",
    "the membership test @xmath241 for the pair @xmath753 is described using the following notation .",
    "\\(a ) if a set @xmath661 of element orders is specified , algorithm  [ ismember - orders ] is used for the @xmath241 test for @xmath517 . in this case",
    "we also specify the probability @xmath660 to find an element of such an order in @xmath756 .",
    "\\(b ) if , in the @xmath174-column of the table , an @xmath517 is specified to be the centraliser or the normaliser of an element or a subgroup , then , using this fact , we build a deterministic algorithm to determine membership of @xmath517 .",
    "\\(c ) finally , the symbol @xmath203 in that column indicates that we use an exhaustive search to test equality in the subgroup @xmath517 .",
    "this method will be used in the special case when @xmath757 .",
    "note that the symbol `` 1 '' may stand either for the trivial subgroup or for the identity element , but its meaning is always clear from the context .",
    "@xmath758    the first example is in table [ m11_1 ] , which describes a subset chain for the sporadic simple mathieu group @xmath248 . in table",
    "[ m11_2 ] we present another subset chain for @xmath248 to demonstrate a new idea , namely that information gained during an ismember test can be used further .",
    "table [ m12 ] contains a subset chain for the sporadic simple mathieu group @xmath759 . in table",
    "[ m22 ] we describe a subset chain for the sporadic simple mathieu group @xmath760 . table [ j2_1 ] presents a subset chain for the sporadic simple janko group @xmath761 , that uses only deterministic membership tests .",
    "in contrast , table [ j2_2 ] shows another chain for @xmath761 with membership tests using element orders .",
    "we conclude this section with a larger example , in which we demonstrate yet another idea , namely that there may be `` branches '' in chains , leading to different behaviour of the algorithm under certain circumstances , that may occur during the calculation .",
    "see table [ ly ] for details and note  ( i ) to table  [ ly ] for an explanation .",
    "we have implemented the generalised sifting algorithms using the subset chains described in the tables below for some of the sporadic simple groups .",
    "the implementations were written in the  gap  4 computational algebra system  @xcite and will be made available separately in the future .",
    "information on the performance of our implementations can be found in table  [ perf ] and in the notes to that table .    in practical implementations the sifting",
    "is carried out in several stages . in the first stage",
    "we sift our element into a smaller subgroup ( usually a centraliser of an element ) , and then we start a new sifting procedure in that subgroup .",
    "we repeat this until we reach the trivial subgroup containing only the identity element . in our tables",
    "we indicate the boundary between different stages by a horizontal line .",
    "for instance in table 1 , we first sift our element into the subgroup 2.s4 , and then carry out a new sifting procedure in @xmath762 .",
    "@xmath763      let @xmath19 be as in the table and select @xmath22 .",
    "we want to write the element @xmath29 as a word in a given nice generating set .",
    "choose an element @xmath764 such that @xmath765\\neq 1 $ ] and let @xmath766 with @xmath767 .",
    "then @xmath44 has 12 sylow 11-subgroups , namely @xmath768 and @xmath769 for @xmath770 . for @xmath771 , @xmath772 if and only if @xmath773 coincides with one of the sylow 11-subgroups of @xmath44 .",
    "further , such a sylow subgroup is self - centralising in @xmath3 .",
    "thus the membership test @xmath772 is carried out by checking whether @xmath774=1 $ ] or @xmath775=1 $ ] for some @xmath776 .",
    "the second step of the sifting can be made more efficient as follows .",
    "assume that @xmath772 . if @xmath774=1 $ ] then @xmath777 , and we can proceed to the third step of the sifting procedure . if @xmath775=1 $ ] then , for @xmath778 we have that @xmath779 .",
    "thus , storing some information about the membership test in the first step , we can immediately select the sifting element @xmath780 in the second step .",
    "@xmath781    @xmath782      here the elements from @xmath783 are tried together with elements from the group @xmath47 to reach the centraliser of @xmath19 .",
    "the probability @xmath784 is the minimum of the probability for the two cases @xmath785 and @xmath786 .",
    "@xmath787    @xmath788      * @xmath789 , so we get an index @xmath790 for free . *",
    "the @xmath791 of @xmath792 is in @xmath127 , and hence @xmath793 .",
    "@xmath794    in sections [ example ] and [ hsrevisited ] we already described the subgroup chain for the sporadic simple higman - sims group @xmath31 presented in table [ hs_1 ] .",
    "we found this chain very useful to illustrate the ideas used in this paper .",
    "however , it turns out that one can design a much more efficient chain for @xmath31 whose details are presented in table [ hs_2 ] .",
    "@xmath795      * the @xmath796 in @xmath797 is equal to @xmath798 , therefore we can test membership of @xmath799 in @xmath797 efficiently . * here we reach @xmath127 , since @xmath800 .    @xmath801      * @xmath802 for some @xmath803 .",
    "we store an element @xmath804 with @xmath805 and handle the cases @xmath806 and @xmath807 separately , which allows us to jump directly to step @xmath808 in these cases .",
    "otherwise , we can work with a single conjugacy class @xmath809 in @xmath44 .",
    "of course , most of the time this latter case will occur , as @xmath809 has @xmath810 elements . *",
    "the centraliser of a @xmath811 element in @xmath812 is @xmath813 .",
    "however , we already have avoided the @xmath791 in the center by the special cases in step @xmath203 .",
    "note that we have reduced the number @xmath814 to @xmath203 , because @xmath815 , again by the special cases in step @xmath203 .",
    "* @xmath49 is the centraliser in @xmath47 of an element of order @xmath791 . * in this step we store the complete set of @xmath168 possible results for @xmath799 together with elements of @xmath3 to conjugate them back to @xmath19 .",
    "so we can reach @xmath127 after this step with no additional costs .",
    "* @xmath816 is from @xmath817 in @xmath812 .",
    "by @xmath818 in @xmath819 we mean a @xmath791-group with an elementary - abelian center of order @xmath820 with an elementary - abelian group of order @xmath821 as factor group .",
    "as in ( ii ) is the centraliser of a @xmath811 element in @xmath812 is @xmath813 .",
    "however , since @xmath816 lies in @xmath817 of @xmath812 , we automatically reach @xmath822 .",
    "* note ( iv ) applies analogously .",
    "* @xmath823 is an involution in @xmath824 .",
    "* @xmath825 is an element of order @xmath711 in @xmath467 . *",
    "the sylow-@xmath791-subgroup is normal , therefore just looking for element orders tests membership .",
    "the algorithms presented in this paper were implemented for the sporadic simple groups above .",
    "we used matrix representations of these groups and table  [ perf ] contains some average running times in seconds .",
    "for each representation , we sifted @xmath826 pseudo random elements and the running times are for those @xmath826 calls to sift on a machine with a pentium iv processor running at @xmath827 ghz with @xmath828 mb of main memory .",
    "the third column contains the average number of multiplications necessary for one call to sift , including the generation of pseudo random elements .",
    "note that the initialization phase of the pseudo random generator ( using product replacement ) involves @xmath829 multiplications for every newly generated group object . in all cases",
    "the bound for the error probability was @xmath830 .",
    "[ perf ] @xmath831",
    "the research presented in this paper forms part of the first author s phd project , supported by an australian postgraduate award , and was also funded by the australian research council discovery grant dp0557587 . much of the work leading to this article was carried out while the fourth author was employed as a research associate in the department of mathematics and statistics of the university of western australia ; he was also supported by the hungarian scientific research fund ( otka ) grants f049040 and t042706 .",
    "we wish to express our thanks to eamonn obrien for helpful comments on an earlier version of this paper , and also to an anonymous referee for a number of perceptive observations and queries on our submitted draft , which , in each instance , led to an improvement in the article .",
    "robert  m. beals , charles  r.  leedham - green , alice  c.  niemeyer , cheryl  e. praeger , and kos seress . a black - box group algorithm for recognizing finite symmetric and alternating groups i. , 355(5):20972113 , 2003 .",
    "f.  celler and c.  r. leedham - green . a constructive recognition algorithm for the special linear group . in _ the atlas of finite groups",
    ": ten years on ( birmingham , 1995 ) _ , pages 1126 .",
    "cambridge university press , cambridge , 1998 .",
    "gene cooperman , larry finkelstein , and steve linton .",
    "constructive recognition of a black box group isomorphic to @xmath834 . in _ groups and computation ii ( new brunswick , nj , 1995 ) _ , pages 85100 .",
    "soc . , providence , ri , 1997 .",
    "charles  r.  leedham - green . the computational matrix group project . in william",
    "m. kantor and kos seress , editors , _ groups and computation iii _ , pages 85101 .",
    "osu mathematical research institute publications , walter de gruyter , 2000 .",
    "charles  r. leedham - green , alice  c. niemeyer , e.a .",
    "obrien , and cheryl  e. praeger .",
    "recognising matrix groups over finite fields . in v.  weispfenning j.  grabmeier , e.  kaltofen , editors , _ computer algebra handbook , foundations , applications , systems _ , pages 459460 , springer - verlag , berlin , new york , 2003 .",
    "charles  c. sims . computing with subgroups of automorphism groups of finite groups . in _ proceedings of the 1997 international symposium on symbolic and algebraic computation ( kihei , hi ) _ , pages 400403 ( electronic ) , new york , 1997 ."
  ],
  "abstract_text": [
    "<S> we present a generalisation of the sifting procedure introduced originally by sims for computation with finite permutation groups , and now used for many computational procedures for groups , such as membership testing and finding group orders . </S>",
    "<S> our procedure is a monte carlo algorithm , and is presented and analysed in the context of black - box groups . </S>",
    "<S> it is based on a chain of subsets instead of a subgroup chain . </S>",
    "<S> two general versions of the procedure are worked out in detail , and applications are given for membership tests for several of the sporadic simple groups .    </S>",
    "<S> our major objective was that the procedures could be proved to be monte carlo algorithms , and their costs computed . </S>",
    "<S> in addition we explicitly determined suitable subset chains for six of the sporadic groups , and we implemented the algorithms involving these chains in the gap computational algebra system . </S>",
    "<S> it turns out that sample implementations perform well in practice . </S>",
    "<S> the implementations will be made available publicly in the form of a gap package .         </S>",
    "<S> = 11 @'\"27\"2a.\"613a  </S>",
    "<S> \" 2d\"2f\"603a  = </S>"
  ]
}