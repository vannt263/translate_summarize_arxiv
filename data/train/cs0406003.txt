{
  "article_text": [
    "finite state automata ( fsas ) and weighted finite state automata ( wfsas ) are well known , mathematically well defined , and offer many practical advantages .",
    "@xcite . they permit , among others , the fast processing of input strings and can be easily modified and combined by well defined operations .",
    "both fsas and wfsas are widely used in language and speech processing @xcite .",
    "a number of software systems have been designed to manipulate fsas and wfsas @xcite .",
    "most systems and applications deal , however , only with _ 1-tape _ and _",
    "2-tape automata _ , also called acceptors and transducers , respectively .    _ multi - tape automata _ ( mtas ) @xcite offer additional advantages such as the possibility of storing different types of information , used in nlp , on different tapes or preserving intermediate results of transduction cascades on different tapes so that they can be re - accessed by any of the following transductions .",
    "mtas have been implemented and used , for example , in the morphological analysis of semitic languages , where the vowels , consonants , pattern , and surface form of words have been represented on different tapes of an mta @xcite .",
    "this report defines various operations for _ weighted multi - tape automata _ ( wmtas ) and describes algorithms that have been implemented for those operations in the wfsc toolkit @xcite .",
    "some algorithms are new , others are known or similar to known algorithms .",
    "the latter will be recalled to make this report more complete and self - standing .",
    "we present a new approach to _ multi - tape intersection _ , meaning the intersection of a number of tapes of one wmta with the same number of tapes of another wmta . in our approach ,",
    "multi - tape intersection is not considered as an atomic operation but rather as a sequence of more elementary ones , which facilitates its implementation .",
    "we show an example of multi - tape intersection , actually transducer intersection , that can be compiled with our approach but not with several other methods that we analyzed .",
    "to show the practical relevance of our work , we include an example of application : the preservation of intermediate results in transduction cascades .    for the structure of this report see the table of contents .",
    "presented in a survey paper a number of results and problems on finite 1-way automata , the last of which  the decidability of the equivalence of deterministic k - tape automata  has been solved only recently and by means of purely algebraic methods @xcite .",
    "rabin and scott considered the case of two - tape automata claiming this is not a loss of generality .",
    "they adopted the convention  @xmath1 that the machine will read for a while on one tape , then change control and read a while on the other tape , and so on until one of the tapes is exhausted @xmath1 \" .",
    "in this view , a two - tape or @xmath0-tape machine is just an ordinary automaton with a partition of its states to determine which tape is to be read .",
    "define the notion of `` one - letter @xmath2-tape automaton '' and the main idea is to consider this restricted form of @xmath2-tape automata where all transition labels have exactly one tape with a non - empty single letter .",
    "then they prove that one can use `` classical '' algorithms for 1-tape automata on a one - letter @xmath2-tape automaton .",
    "they propose an additional condition to be able to use classical intersection .",
    "it is based on the notion that a tape or coordinate is _ inessential _",
    "iff @xmath3  ( @xmath4 is a regular relation over @xmath5 ) and @xmath6 , @xmath7 . and thus to perform an intersection",
    ", they assume that there exists at most one common essential tape between the two operands .",
    "define a non - deterministic _",
    "@xmath0-way finite - state transducer _ that is similar to a classic transducer except that the transition function maps @xmath8 to @xmath9  ( with @xmath10 ) .",
    "to perform the _ intersection _ between two @xmath0-tape transducers , they introduced the notion of _ same - length relations _ . as a result",
    ", they treat a subclass of @xmath0-tape transducers to be intersected",
    ".    defines an @xmath0-tape finite state automaton and an _ @xmath0-tape finite - state transducer _ , introducing the notion of _ domain tape _ and _ range tape _ to be able to define a unambiguous composition for @xmath0-tape transducers .",
    "operations on @xmath0-tape automata are based on @xcite , the intersection in particular .",
    "in this section we recall the basic definitions of the algebraic structures monoid and semiring , and give a detailed definition of a weighted multi - tape automaton ( wmta ) based on the definitions of a weighted automaton and a multi - tape automaton @xcite .",
    "a _ monoid _ is a structure @xmath11 consisting of a set @xmath12 , an associative binary operation @xmath13 on @xmath12 , and a _ neutral _ element @xmath14 such that @xmath15 for all @xmath16 .",
    "a monoid is called _ commutative _ iff @xmath17 for all @xmath18 .    a set",
    "@xmath19 equipped with two binary operations , @xmath20 ( _ collection _ ) and @xmath21 ( _ extension _ ) , and two neutral elements , @xmath22 and @xmath14 , is called a _ semiring _ , iff it satisfies the following properties :    1 .",
    "@xmath23 is a commutative monoid 2 .",
    "@xmath24 is a monoid 3 .",
    "extension is _",
    "left- _ and _ right - distributive _ over collection : + @xmath25 4 .",
    "@xmath22 is an annihilator for extension :   @xmath26    we denote a generic semiring as @xmath27 .",
    "some automaton algorithms require semirings to have specific properties .",
    "composition , for example , requires it to be commutative @xcite and @xmath28-removal requires it to be _ k - closed _ @xcite .",
    "these properties are defined as follows :    1 .",
    "commutativity :   @xmath29 2 .",
    "k - closedness :   @xmath30    the following well - known semirings are commutative :    1 .",
    "@xmath31  : the boolean semiring , with @xmath32 2 .",
    "@xmath33  : a positive integer semiring with arithmetic addition and multiplication 3 .",
    "@xmath34  : a positive real semiring 4 .",
    "@xmath35  : a real tropical semiring , with @xmath36    a number of algorithms require semirings to be equipped with an order or partial order denoted by @xmath37 . each idempotent semiring @xmath38 ( i.e. , @xmath39 ) has a natural partial order defined by @xmath40 . in the above examples , the boolean and the real tropical semiring are idempotent , and hence have a natural partial order .      in analogy to a weighted automaton and a multi - tape automaton ( mta )",
    ", we define a _ weighted multi - tape automaton _ ( wmta ) , also called weighted @xmath0-tape automaton , over a semiring @xmath38 , as a six - tuple @xmath41    with    20mm42mm90 mm @xmath42 & & being a finite alphabet + @xmath43 & & the finite set of states + @xmath44 & @xmath45 & the set of initial states + @xmath46 & @xmath45 & the set of final states + @xmath0 & & the arity , i.e. , the number of tapes of @xmath47 + @xmath48 & @xmath49 & being the finite set of @xmath0-tape transitions and + @xmath38 & @xmath50 & the semiring of weights .",
    "+    for any state @xmath51 ,    20mm42mm90 mm @xmath52 & @xmath53 & denotes its initial weight , with @xmath54 , + @xmath55 & @xmath53 & its final weight , with @xmath56 , and + @xmath57 & @xmath58 & its finite set of out - going transitions .",
    "+    for any transition @xmath59 , with @xmath60 ,    20mm42mm90 mm @xmath61 & @xmath62 & denotes its source state + @xmath63 & @xmath64 & its label , which is an @xmath0-tuple of strings + @xmath65 & @xmath66 & its weight , with @xmath67 , and + @xmath68 & @xmath69 & its target state +    a _ path _ @xmath70 of length @xmath71 is a sequence of transitions @xmath72 such that @xmath73 for all @xmath74 . a path is said to be _ successful _",
    "iff @xmath75 and @xmath76 . in the following we consider only successful paths .",
    "the label of a successful path @xmath70 equals the concatenation of the labels of its transitions @xmath77    and is an @xmath0-tuple of strings @xmath78    if all strings @xmath79 ( with @xmath80 ) of a tuple @xmath81 are equal , we use the short - hand notation @xmath82 on the terminal string @xmath83 . for example : @xmath84    the @xmath0 strings on any transition @xmath85 are not `` bound '' to each other .",
    "for example , the string triple @xmath86 can be encoded , among others , by any of the following sequences of transitions : @xmath87 or @xmath88 or @xmath89 , etc .",
    "the weight @xmath90 of a successful path is @xmath91    we denote by @xmath92 the ( possibly infinite ) set of successful paths of @xmath47 and by @xmath93 the ( possibly infinite ) set of successful paths for the @xmath0-tuple of strings @xmath81",
    "@xmath94    we call @xmath95 the @xmath0-ary or @xmath0-tape relation of @xmath47 . it is the ( possibly infinite ) set of @xmath0-tuples of strings @xmath81 having successful paths in @xmath47 : @xmath96    the weight for any @xmath0-tuple of strings @xmath97 is the collection ( semiring sum ) of the weights of all paths labeled with @xmath81  : @xmath98    by relation we mean simply a co - occurrence of strings in tuples .",
    "we do not assume any particular relation between those strings such as an input - output relation .",
    "all following operations and algorithms are independent from any particular relation .",
    "it is , however , possible to define an arbitrary weighted relation between the different tapes of @xmath95 .",
    "for example , @xmath99 of a weighted _ transducer _",
    "@xmath100 is usually considered as a weighted input - output relation between its two tapes , that are called _ input tape _ and _ output tape_.    in the following we will not distinguish between a language @xmath101 and a 1-tape relation @xmath102 , which allows us to define operations only on relations rather than on both languages and relations .",
    "this section defines operations on string @xmath0-tuples and @xmath0-tape relations , taking their weights into account .",
    "whenever these operations are used on transitions , paths , or automata , they are actually applied to their labels or relations respectively .",
    "for example , the binary operation @xmath103 on two automata , @xmath104 , actually means @xmath105 .",
    "the unary operation @xmath106 on one automaton , @xmath107 , actually means @xmath108 .",
    "ultimately , we are interested in multi - tape intersection and transduction .",
    "the other operations are introduced because they serve as basis for the two .",
    "we define the _ pairing _ of two string tuples , @xmath109 , and its weight as @xmath110    pairing is associative ( concerning both the string tuples and their weights )  : @xmath111    we will not distinguish between 1-tuples of strings and strings , and hence , instead of @xmath112 or @xmath113 , simply write @xmath114 .",
    "the _ concatenation _ of two string tuples of equal arity , @xmath115 , and its weight are defined as @xmath116    concatenation is associative ( concerning both the string tuples and their weights )  : @xmath117    again , we will not distinguish between 1-tuples of strings and strings , and hence , instead of @xmath118 or @xmath119 , simply write @xmath120 .",
    "the relation retween pairing and concatenation can be expressed through a matrix of string tuples @xmath121\\ ] ]    where the @xmath122 are horizontally concatenated and vertically paired : @xmath123    note , this equation does not hold for the weights of the @xmath122 , unless they are defined over a commutative semiring @xmath38 .      the _ cross - product _ of two @xmath0-tape relations , @xmath124 ,",
    "is based on pairing and is defined as @xmath125    the weight of each string tuple @xmath126 follows from the definition of pairing .",
    "the cross product is an associative operation .",
    "a well - know special case is the cross - product of two acceptors ( 1-tape automata ) leading to a transducer ( 2-tape automaton )  : @xmath127      the _ projection _ , @xmath128 , of a string tuple is defined as @xmath129 it retains only those strings ( i.e. , tapes ) of the tuple that are specified by the indices @xmath130 , and places them in the specified order .",
    "projection indices can occur in any order and more that once .",
    "thus the tapes of @xmath81 can , e.g. , be reversed or duplicated : @xmath131    the weight of the @xmath0-tuple @xmath81 is not modified by the projection ( if we consider @xmath81 not as a member of a relation ) .    the projection of an @xmath0-tape relation is the projection of all its string tuples : @xmath132    the weight of each @xmath133 is the collection ( semiring sum ) of the weights of each @xmath134 leading , when projected , to @xmath135 : @xmath136    the _ complementary projection _ , @xmath137 , of a string @xmath0-tuple @xmath81 removes all those strings ( i.e. , tapes ) of the tuple that are specified by the indices @xmath130 , and preserves all other strings in their original order .",
    "an _ inverse projection _ because it is not the inverse of a projection in the sense : @xmath138 and @xmath139 . ] it is defined as @xmath140    complementary projection indices can occur in any order , but only once .",
    "the complementary projection of an @xmath0-tape relation equals the complementary projection of all its string tuples : @xmath141    the weight of each @xmath142 is the collection of the weights of each @xmath134 leading , when complementary projected , to @xmath135  : @xmath143      we define the _ auto - intersection _ of a relation , @xmath144 , on the tapes @xmath145 and @xmath2 as the subset of @xmath146 that contains all @xmath81 with equal @xmath83 and @xmath147 : @xmath148    the weight of any @xmath149 is not modified .    for example",
    "( figure  [ fig : aint : a11 ] ) @xmath150    auto - intersection of regular @xmath0-tape relations is not necessarily regular . for example",
    "( figure  [ fig : aint : a13 ] ) @xmath151    the result is not regular because @xmath152 is not regular .",
    "the multi - tape intersection of two multi - tape relations , @xmath153 and @xmath154 , uses @xmath155 tapes in each relation , and intersects them pair - wise . the operation",
    "pairs each string tuple @xmath156 with each string tuple @xmath157 iff @xmath158 with @xmath159 for all @xmath160 .",
    "multi - tape intersection is defined as : @xmath161    all tapes @xmath162 of @xmath154 that have directly participated in the intersection are afterwards equal to the tapes @xmath163 of @xmath153 , and are removed .",
    "all tapes @xmath163 are kept for possible reuse by subsequent operations .",
    "all other tapes of both relations are preserved without modification .",
    "the weight of each @xmath164 is @xmath165    this weight follows only from pairing ( eq .",
    "[ eq : op : pairingweight ] ) .",
    "it is not influenced by complementary projection ( eq .  [ eq : op : cprojweight ] ) because any two @xmath166 that differ in @xmath167 also differ in @xmath168 , and hence can not become equal when the @xmath167 are removed .",
    "the multi - tape intersection of two relations , @xmath153 and @xmath154 , can be compiled by @xmath169    as can been seen from @xmath170    multi - tape intersection is a generalization of classical intersection of transducers which is known to be not necessarily regular @xcite  : @xmath171    consequently , multi - tape intersection has the same property . in our approach",
    "this results from the potential non - regularity of auto - intersection ( eq .  [ eq : op : mltint : proc ] ) .",
    "+ we speak about _ single - tape intersection _ if only one tape is used in each relation ( @xmath172 ) .",
    "a well - known special case is the intersection of two acceptors ( 1-tape automata ) leading to an acceptor @xmath173    and yielding the relation @xmath174    another well - known special case is the composition of two transducers ( 2-tape automata ) leading to a transducer . here",
    ", we need , however , an additional complementary projection : is expressed either by the @xmath175 or the @xmath176 operator . however , @xmath177 equals @xmath178 which corresponds to @xmath179 in functional notation @xcite . ] @xmath180    it yields the relation : @xmath181    multi - tape and single - tape intersection are neither associative nor commutative , except for special cases with @xmath182 , such as the above intersection of acceptors and transducers .      a wmta , @xmath47 , can be used as a transducer having @xmath155 input tapes , @xmath183 to @xmath184 , and @xmath185 output tapes , @xmath186 to @xmath187 , which do not have to be consecutive or disjoint .    to apply @xmath47 to a weighted @xmath155-tuple of input strings ,",
    "the tuple @xmath188 is converted into an input wmta , @xmath189 , having one single path labeled with @xmath188 and weighted with @xmath190 .",
    "an output wmta , @xmath191 , whose relation contains all weighted @xmath185-tuples of output strings , @xmath192 , is then obtained through multitape - intersection and projection : @xmath193",
    "the following example of classical transducer intersection of @xmath194 and @xmath195 is regular : could be written as   @xmath196 . ]",
    "@xmath197    it has one theoretical solution which is    @xmath198 + this solution can not be compiled with any of the above mentioned previous approaches ( section  [ sec : previous ] ) . it can not be enabled by any pre - transformation of the wmtas that does not change their relations , @xmath199 and @xmath200 .",
    "all above mentioned approaches do not exceed the following alternatives .",
    "one can start by typing all symbols ( and @xmath28 ) with respect to the tapes , to make the alphabets of different tapes disjoint ( which can be omitted for symbols occurring on one tape only )  :    @xmath201_2@xmath202_2@xmath203_1@xmath204_1@xmath204_1@xmath205_1@xmath206_2@xmath207_1@xmath208_1@xmath209_2@xmath210 + then , one converts @xmath0 tapes into @xmath211 tape , such that each transition , labeled with @xmath0 symbols , is transformed into a sequence of @xmath0 transitions , labeled with @xmath211 symbol each , which is equivalent to ganchev s approach @xcite  :    @xmath212_2@xmath213_2@xmath214_1@xmath215_1@xmath216_1@xmath217_2@xmath204_1@xmath218_1@xmath219_2@xmath204_1@xmath220 + after these transformations , it is not possible to obtain the above theoretical solution by means of classical intersection of 1-tape automata , even not after @xmath28-removal :    @xmath221      alternatively , one could start with synchronizing the wmtas .",
    "this is not possible across a whole wmta , but only within `` limited sections '' : in our example this means before , inside , and after the cycles :    @xmath222 + then , one can proceed as before by first typing the symbols with respect to the tapes    @xmath223_2@xmath224_2@xmath225_1@xmath204_1@xmath204_1@xmath226_1@xmath227 + and then transforming @xmath0 tapes into @xmath211 tape    @xmath228_2@xmath229_2@xmath230_1@xmath216_1@xmath231_1@xmath232_1@xmath233 + the solution can not be compiled with this alternative either , even not after @xmath28-removal :    @xmath234      to compile multi - tape intersection according to the above procedure ( eq .  [ eq : op : mltint : proc ] ) @xmath235    we proceed in 3 steps .",
    "first , we compile @xmath236 in one single step with an algorithm that follows the principle of transducer composition and simulates the behaviour of mohri s @xmath28-filter ( section  [ sec : alg : sgint]).-filter has been shown to work on arbitrary transducers @xcite .",
    "] for the above example , we obtain    @xmath237 +    next , we compile @xmath238 using our auto - intersection algorithm ( section  [ sec : alg : autoint ] )    @xmath239 +    and finally , @xmath240 with a simple algorithm for complementary projection :    @xmath241 + this final result equals the theoretical solution .",
    "in this section we propose and recall algorithms for the above defined operations on wmtas : cross - product , auto - intersection , single - tape and multi - tape intersection . by convention ,",
    "our wmtas have only one initial state @xmath242 , without loss of generality , since for any wmta with multiple initial states there exists a wmta with a single initial state accepting the same relation .",
    "we will use the following variables and definitions .",
    "the variables @xmath243 $ ] , @xmath244 $ ] , etc .",
    "serve for assigning temporarily additional data to a state @xmath245 .",
    "+    [ cols= \" < , < , < \" , ]      we describe two alternative algorithms to compile the cross product of two wmtas , @xmath246 and @xmath247 .",
    "the second algorithm is almost identical to classical algorithms for crossproduct of automata .",
    "nevertheless , we recall it to make this report more complete and self - standing .",
    "both algorithms require the semirings of the two original automata , @xmath246 and @xmath247 , to be equal ( @xmath248 ) .",
    "the second algorithm requires the common semiring @xmath249 to be commutative .",
    "* cross product through path concatenation : *   the first algorithm pairs the label of each transition @xmath250 with @xmath251 ( producing @xmath252 ) , and the label of each transition @xmath253 with @xmath254 ( producing @xmath255 ) , and then concatenates @xmath256 with @xmath257 .",
    "we will refer to it as where the suffix _ pc _ stands for _ path concatenation_.    we start with a wmta @xmath258 that is equipped with the union of the alphabets , the union of the state sets , and the union of the transition sets of @xmath259 and @xmath260 .",
    "the initial state of @xmath258 equals that @xmath259 , its set of final states equals that of @xmath260 , and its semiring equals those of @xmath259 and @xmath260 ( line  [ pc : crosspc : l1 ] ) .",
    "first , we ( post- ) pair the labels of all transitions originally coming from @xmath259 with @xmath251 , and ( pre- ) pair the labels of all transition from @xmath260 with @xmath254 .",
    "then , we connect all final states of @xmath259 with the initial state of @xmath260 through @xmath261-transitions , as is usually done in the concatenation of automata .",
    "the disadvantages of this algorithm are that the paths of @xmath258 become longer than in the second algorithm below and that each transition of @xmath258 is partially labeled with @xmath28 , which may increase the running time of subsequently applied operations .",
    "to adapt this algorithm to non - weighted mtas , one has to remove the weight from line  [ pc : crosspc : l7 ] and replace line  [ pc : crosspc : l8 ] with : @xmath262 .",
    "+ * cross product through path alignment : *   the second algorithm pairs each string tuple of @xmath246 with each string tuple of @xmath247 , following the definition ( eq .  [",
    "eq : op : crprod ] ) .",
    "the algorithm actually pairs each path @xmath263 of @xmath246 with each path @xmath264 of @xmath247 transition - wise , and appends @xmath28-transitions to the shorter of two paired paths , so that both have equal length .",
    "we will refer to this algorithm as where the suffix _ pa _ stands for _ path alignment_.    we start with a wmta @xmath258 whose alphabet is the union of the alphabets of @xmath259 and @xmath260 , whose semiring equals those of @xmath259 and @xmath260 , and that is otherwise empty ( line  [ pc : crosspa : l1 ] ) .",
    "first , we create the initial state @xmath265 of @xmath258 from the initial states of @xmath259 and @xmath260 , and push @xmath265 onto the stack ( lines  [ pc : crosspa : l3 ] , [ pc : crosspa : l27][pc : crosspa : l33 ] ) . while the stack is not empty , we take states @xmath245 from it and access the states @xmath266 and @xmath267 that are assigned to @xmath245 through @xmath244 $ ] ( lines  [ pc : crosspa : l5 ] ,  [ pc : crosspa : l6 ] ) .",
    "if both @xmath266 and @xmath267 are defined @xmath268 , we pair each outgoing transition @xmath269 of @xmath266 with each outgoing transition @xmath270 of @xmath267 ( lines  [ pc : crosspa : l7][pc : crosspa : l9 ] ) , and create a transition in @xmath258 ( line  [ pc : crosspa : l13 ] ) whose label is the pair @xmath271 and whose target @xmath272 corresponds to the tuple of targets @xmath273 ( line  [ pc : crosspa : l10 ] ) . if @xmath272 does not exist yet , it is created and pushed onto the stack ( lines  [ pc : crosspa : l27][pc : crosspa : l33 ] ) .",
    "if we encounter a final state @xmath266 ( with @xmath274 ) in @xmath259 , we follow the path beyond @xmath266 on an @xmath28-transition that exists only `` virtually '' but not `` physically '' in @xmath259 ( lines  [ pc : crosspa : l14 ] ,  [ pc : crosspa : l15 ] ) .",
    "the target of the resulting transition in @xmath258 corresponds to the tuple of targets @xmath275 with @xmath276 being undefined @xmath277 because @xmath269 does not exist physically ( line  [ pc : crosspa : l16 ] ) .",
    "if we encounter a final state @xmath267 ( with @xmath278 ) in @xmath260 , we proceed similarly ( lines  [ pc : crosspa : l20][pc : crosspa : l25 ] ) .",
    "the final weight of an undefined state @xmath279 is assumed to be @xmath14  : @xmath280  .    to adapt this algorithm to non - weighted mtas",
    ", one has to remove the weights from the lines  [ pc : crosspa : l13 ] ,  [ pc : crosspa : l19 ] , and  [ pc : crosspa : l25 ] , and replace line  [ pc : crosspa : l30 ] with : @xmath262 @xmath281 .",
    "we propose an algorithm that attempts to constructs the auto - intersection @xmath47 of a wmta @xmath246 .",
    "our approach has some minor similarity with synchronization algorithms for transducers @xcite  : it uses the concept of delay between two tapes and assigns leftover - strings to states ( see above ) .    in the context of our approach , we understand by _ construction _ the compilation of reachable states @xmath245 and transitions @xmath85 of @xmath47 , such that the absolute value of the delay @xmath282 , regarding tape @xmath145 and @xmath2 , does not exceed a limit @xmath283 at any state @xmath245 , i.e. : @xmath284 .",
    "the limit @xmath283 is imposed , i.e. , any state whose delay would exceed it is not constructed .",
    "we distinguish two cases . in the first case ,",
    "the delay of none of the reachable and coreachable states exceeds a limit @xmath285  ( with @xmath286 ) , i.e. : @xmath287 .",
    "we call it a construction with _ bounded delay _ or a _ successful _ construction because it is guarantied to generate the attempted result @xmath288 . in this case",
    "the relation @xmath289 has bounded delay , too , and is rational .",
    "the limit @xmath285 is not imposed , i.e. , any state @xmath245 whose delay exceeds it would still be constructed ( which places the construction into the second case if @xmath245 becomes coreachable ) .    in the second case ,",
    "the delay of reachable and coreachable states is potentially unbounded .",
    "it exceeds @xmath285 , and would actually exceed any limit if it was not ( brute - force ) delimited by @xmath283 , i.e. : @xmath290 .",
    "we call this a construction with _ potentially unbounded delay_. it is not successful , and we can not conclude on the correctness of the result @xmath47 and on the boundedness and rationality of the relation @xmath289",
    ".    we will first describe the algorithm and then present some examples for further illustration .",
    "our algorithm starts with the compilation of the limits @xmath285 and @xmath283 , then proceeds with the construction of @xmath47 , and finally verifies the success of the construction , according to the above conditions .",
    "+ * compilation of limits : *   first , we traverse @xmath246 recursively , without traversing any state more than once , and record three values : @xmath291 , being the maximal delay at any state , @xmath292 , the minimal delay at any state , and @xmath293 , the maximal absolute value of the delay of any cycle ( lines  [ pc : autoint : l403 ] , [ pc : autoint : l501][pc : autoint : l510 ] ) .",
    "to do so , we assign to each state @xmath266 of @xmath246 a variable @xmath294\\!=\\!(\\chi_1,\\chi_2)$ ] with the above defined meaning .",
    "the delay at a state @xmath266 is @xmath295 ( lines  [ pc : autoint : l501 ] ,  [ pc : autoint : l502 ] ) .",
    "the delay of a cycle on @xmath266 is the difference between @xmath296 at the end and @xmath297 at the beginning of the cycle ( line  [ pc : autoint : l504 ] ) .",
    "then , we compile @xmath298 , the maximal absolute value of delay required to match any two cycles . for example , let @xmath299 , encoded by two cycles . to obtain a match between @xmath300 and @xmath301 of a path @xmath302 of @xmath303 , we have to traverse the first cycle 3 times and the second two times , allowing for any permutation : @xmath304 .",
    "this illustrates that in a match between any two cycles of @xmath246 , the absolute value of the delay does not exceed @xmath305 ( line  [ pc : autoint : l404 ] ) .",
    "next , we compile the first limit , @xmath285 , that will not be exceeded by a construction with bounded delay . in a match of two cycles",
    "this limit equals @xmath298 , and for any other match it is @xmath306 . in a construction with bounded delay , the absolute value of the delay in @xmath47 does therefore not exceed @xmath307 ( line  [ pc : autoint : l405 ] ) .",
    "finally , we compile a second limit , @xmath283 , that allows us , in case of potentially unbounded delay , to construct a larger @xmath47 than @xmath285 does .",
    "unboundedness can only result from matching cycles in @xmath246 . to obtain a larger @xmath47 , with states whose delay exceeds @xmath285",
    ", we have to unroll the cycles of @xmath246 further until we reach ( at least ) one more match between two cycles .",
    "therefore , @xmath308 ( line  [ pc : autoint : l405a ] ) .",
    "+ * construction : *   we start with a wmta @xmath258 whose alphabet and semiring equal those of @xmath259 and that is otherwise empty ( line  [ pc : autoint : l102 ] ) . to each state",
    "@xmath245 that will be created in @xmath258 , we will assign two variables : @xmath243\\!=\\!q_1 $ ] indicating the corresponding state @xmath266 in @xmath259 , and @xmath309\\!=\\!(s , u)$ ] stating the leftover string @xmath310 of tape @xmath145 ( yet unmatched in tape @xmath2 ) and the leftover string @xmath311 of tape @xmath2 ( yet unmatched in tape @xmath145 ) .",
    "then , we create an initial state @xmath265 in @xmath258 and push it onto the stack ( lines  [ pc : autoint : l104 ] , [ pc : autoint : l301][pc : autoint : l310 ] ) . as long as the stack is not empty ,",
    "we take states @xmath245 from it and follow each of the outgoing transitions @xmath312 of the corresponding state @xmath313 $ ] in @xmath259 ( lines  [ pc : autoint : l105][pc : autoint : l106 ] ) .",
    "a transition @xmath269 in @xmath259 is represented as @xmath314 in @xmath258 , with the same label and weight . to compile the leftover strings @xmath315\\!=\\!(s^\\prime , u^\\prime)$ ] of its target @xmath316 in @xmath258",
    ", we concatenate the leftover strings @xmath309\\!=\\!(s , u)$ ] of its source @xmath317 with the @xmath145-th and @xmath2-th component of its label , @xmath318 and @xmath319 , and remove the longest common prefix of the resulting strings @xmath320 and @xmath321 ( lines  [ pc : autoint : l107 ] , [ pc : autoint : l201][pc : autoint : l204 ] ) .    if both leftover strings @xmath322 and @xmath323 of @xmath272 are non - empty ( @xmath324 ) then they are incompatible and the path that we are following is invalid . if either @xmath322 or @xmath323 is empty ( @xmath325 ) then the current path is valid ( at least up to this point ) ( line  [ pc : autoint : l108 ] ) . only in this case and only if the delay between @xmath322 and @xmath323 does not exceed @xmath283 , we construct a transition @xmath326 in @xmath258 corresponding to @xmath269 in @xmath259 ( line  [ pc : autoint : l108 ] ,  [ pc : autoint : l110 ] ) . if its target @xmath316 does not exist yet , it is created and pushed onto the stack ( lines  [ pc : autoint : l109 ] , [ pc : autoint : l301][pc : autoint : l310 ] ) .",
    "the infinite unrolling of cycles is prevented by @xmath283 . +",
    "* verification : *   to see whether the construction was successful and whether @xmath327 , we have to check for the above defined conditions . since all states of @xmath47 are reachable , it is sufficient to verify their delay and coreachability ( line  [ pc : autoint : l112 ] )  : @xmath328 .",
    "we illustrate the algorithm through the following three examples that stand each for a different class of wmtas .",
    "* example 1 : *   the relation of the wmta , @xmath329 , of the first example is the infinite set of string tuples @xmath330  ( figure  [ fig : aint : a11 ] ) .",
    "only one of those tuples , namely @xmath331 , is in the relation of the auto - intersection , @xmath332 , because all other tuples contain different strings on tape @xmath211 and @xmath333 . in the construction ,",
    "an infinite unrolling of the cycle is prevented by the incompatibility of the leftover substrings in @xmath334 $ ] and @xmath335 $ ] respectively .",
    "the construction is successful .",
    "the example is characterized by : @xmath336)|>\\delta_{\\rm max }      & \\rightarrow & { \\it successful }          \\spc{2ex}\\rightarrow\\spc{2ex }    { \\it rational}\\;\\aint{1,3}(\\;)\\end{aligned}\\ ] ]     and its successfully constructed auto - intersection @xmath332 .",
    "( dashed parts are not constructed . )",
    "[ fig : aint : a11 ] ]     and its successfully constructed auto - intersection @xmath332 .",
    "( dashed parts are not constructed . )",
    "[ fig : aint : a11 ] ]    * example 2 : *   in the second example ( figure  [ fig : aint : a12 ] ) , the relation of @xmath329 is the infinite set of string tuples @xmath337 . only one of those tuples , namely @xmath338 , is in the relation of the auto - intersection @xmath339 . in the construction ,",
    "an infinite unrolling of the cycle is prevented by the limit of delay @xmath283 .",
    "although the result contains states with @xmath340)|>\\delta_{\\rm max}$ ] , none of them is coreachable ( and would disappear if the result was pruned ) .",
    "the construction is successful .",
    "the example is characterized by : @xmath341)|>\\delta_{\\rm max } \\;\\logand\\ ; \\fct{coreachable}{q }      & \\rightarrow & { \\it successful }          \\spc{2ex}\\rightarrow\\spc{2ex }    { \\it rational}\\;\\aint{1,2}(\\;)\\end{aligned}\\ ] ]     and its successfully constructed auto - intersection @xmath339 .",
    "( dashed parts are not constructed .",
    "states @xmath245 marked with have @xmath342)|>\\delta_{\\rm max}$ ] . )",
    "[ fig : aint : a12 ] ]     and its successfully constructed auto - intersection @xmath339 .",
    "( dashed parts are not constructed .",
    "states @xmath245 marked with have @xmath342)|>\\delta_{\\rm max}$ ] . )",
    "[ fig : aint : a12 ] ]    * example 3 : *   in the third example ( figure  [ fig : aint : a13 ] ) , the relation of @xmath329 is the infinite set of string tuples @xmath343 .",
    "the auto - intersection , @xmath344 , is not rational and has unbounded delay .",
    "its complete construction would require an infinite unrolling of the cycles of @xmath329 and an infinite number of states in @xmath345 which is prevented by @xmath283 .",
    "the construction is not successful because the result contains coreachable states with @xmath340)|>\\delta_{\\rm max}$ ] .",
    "the example is characterized by : @xmath346)|>\\delta_{\\rm max } \\;\\logand\\ ; \\fct{coreachable}{q }      & \\rightarrow & { \\it not~successful}\\end{aligned}\\ ] ]     and its partially constructed auto - intersection @xmath347 .",
    "( dashed parts are not constructed .",
    "states @xmath245 marked with have @xmath342)|>\\delta_{\\rm max}$ ] . )",
    "[ fig : aint : a13 ] ]     and its partially constructed auto - intersection @xmath347 .",
    "( dashed parts are not constructed .",
    "states @xmath245 marked with have @xmath342)|>\\delta_{\\rm max}$ ] . )",
    "[ fig : aint : a13 ] ]      we propose an algorithm that performs single - tape intersection of two wmtas , @xmath246 and @xmath247 , in one step . instead of first building the cross - product , @xmath348 , and then deleting most of its paths by auto - intersection ,",
    "@xmath349 , according to the above procedure ( eq .  [ eq : op : mltint : proc ] ) , the algorithm constructs only the useful part of the cross - product .",
    "it is very similar to classical composition of two transducers , and incorporates the idea of using an @xmath28-filter in the composition of transducers containing @xmath28-transitions ( * ? ? ?",
    "* figure  10 ) that will be explained below . instead of explicitly using an @xmath28-filter",
    ", we simulate its behaviour in the algorithm .",
    "we will refer to the algorithm as : @xmath350    the complementary projection , @xmath351 , could be easily integrated into the algorithm in order to avoid an additional pass .",
    "we keep it apart because serves also as a building block of another algorithm where this projection must be postponed .      to compose two transducers , @xmath194 and @xmath195 , containing @xmath28-transitions , are using an @xmath28-filter transducer . in their approach , @xmath194 and @xmath195",
    "are pre - processed ( figure  [ fig : epsfilter ] )  : each @xmath28 on tape 2 of @xmath194 is replaced by an @xmath352 and each @xmath28 on tape 1 of @xmath195 by an @xmath353 . in addition , a looping transition labeled with @xmath354 is added to each state of @xmath194 , and a loop labeled with @xmath355 to each state of @xmath195 .",
    "the pre - processed transducers are then composed with the filter @xmath356 in between : @xmath357 .",
    "@xmath358 +    -filter @xmath358 and two transducers , @xmath259 and @xmath260 , pre - processed for filtered composition .",
    "( for didactic reasons we are using slightly different labels than mohri _",
    "et al _ ) .",
    "[ fig : epsfilter ] ]    @xmath259 -filter @xmath358 and two transducers , @xmath259 and @xmath260 , pre - processed for filtered composition .",
    "( for didactic reasons we are using slightly different labels than mohri _",
    "et al _ ) .",
    "[ fig : epsfilter],title=\"fig : \" ] @xmath260 -filter @xmath358 and two transducers , @xmath259 and @xmath260 , pre - processed for filtered composition .",
    "( for didactic reasons we are using slightly different labels than mohri _",
    "et al _ ) .",
    "[ fig : epsfilter],title=\"fig : \" ]    the filter controls how @xmath28-transitions are composed along each pair of paths in @xmath259 and @xmath260 respectively . as long as there are equal symbols ( @xmath28 or not ) on the two paths , they are composed with each other and we stay in state 0 of @xmath358 .",
    "if we encounter a sequence of @xmath28 in @xmath259 but not in @xmath260 , we move forward in @xmath259 , stay in the same state in @xmath260 , and in state 1 of @xmath358 . if we encounter a sequence of @xmath28 in @xmath260 but not in @xmath259 , we move forward in @xmath260 , stay in the same state in @xmath259 , and in state 2 of @xmath358 .",
    "our algorithm requires the semirings of the two wmtas to be equal ( @xmath248 ) and commutative .",
    "all transitions must be labeled with @xmath0-tuples of strings not exceeding length 1 on the intersected tapes @xmath145 of @xmath259 and @xmath2 of @xmath260 which means no loss of generality :   @xmath360      we start with a wmta @xmath258 whose alphabet is the union of the alphabets of @xmath259 and @xmath260 , whose semiring equals those of @xmath259 and @xmath260 , and that is otherwise empty ( line  [ pc : intcreps : l1 ] ) .",
    "first , we create the initial state @xmath265 of @xmath258 from the initial states of @xmath259 , @xmath260 , and @xmath358 , and push @xmath265 onto the stack ( lines  [ pc : intcreps : l3 ] , [ pc : intcreps : l26][pc : intcreps : l32 ] ) . while the stack is not empty , we take states @xmath245 from it and access the states @xmath266 , @xmath267 , and @xmath361 that are assigned to @xmath245 through @xmath362 $ ] ( lines  [ pc : intcreps : l5 ] ,  [ pc : intcreps : l6 ] ) .",
    "we intersect each outgoing transition @xmath269 of @xmath266 with each outgoing transition @xmath270 of @xmath267 ( lines  [ pc : intcreps : l7a ] ,  [ pc : intcreps : l7b ] ) .",
    "this succeeds only if the @xmath145-th label component of @xmath269 equals the @xmath2-th label component of @xmath270 , where @xmath145 and @xmath2 are the two intersected tapes of @xmath259 and @xmath260 respectively , and if the corresponding transition in @xmath358 has target 0 ( line  [ pc : intcreps : l8 ] ) .",
    "only if it succeeds , we create a transition in @xmath258 ( line  [ pc : intcreps : l12 ] ) whose label results from pairing @xmath363 with @xmath364 and whose target @xmath272 corresponds with the triple of targets @xmath365 .",
    "if @xmath272 does not exist yet , it is created and pushed onto the stack ( lines  [ pc : intcreps : l26][pc : intcreps : l32 ] ) .",
    "subsequently , we handle all @xmath28-transitions in @xmath259 ( lines  [ pc : intcreps : l13][pc : intcreps : l18 ] ) and in @xmath260 ( lines  [ pc : intcreps : l19][pc : intcreps : l24 ] ) .",
    "if we encounter an @xmath28 in @xmath259 and are in state 0 or 1 of @xmath358 , we have to move forward in @xmath259 , stay in the same state in @xmath260 , and go to state 1 in @xmath358 .",
    "therefore we create a transition in @xmath258 whose target corresponds to the triple @xmath366   ( lines  [ pc : intcreps : l13][pc : intcreps : l18 ] ) .",
    "the algorithm works similarly if and @xmath28 is encountered in @xmath260 ( lines  [ pc : intcreps : l19][pc : intcreps : l24 ] ) .    to adapt this algorithm to non - weighted mtas",
    ", one has to remove the weights from the lines  [ pc : intcreps : l12 ] ,  [ pc : intcreps : l18 ] , and  [ pc : intcreps : l24 ] , and replace line  [ pc : intcreps : l29 ] with : @xmath262 @xmath281 .",
    "we propose two alternative algorithms for the multi - tape intersection of two wmtas , @xmath246 and @xmath247 .",
    "both algorithms work under the conditions of their underlying basic operations : the semirings of the two wmtas must be equal ( @xmath248 ) and commutative . the second ( more efficient algorithm ) requires all transitions to be labeled with @xmath0-tuples of strings not exceeding length 1 on ( at least ) one pair of intersected tapes @xmath163 of @xmath246 and @xmath162 of @xmath247 which means no loss of generality :   @xmath367      our first algorithm , that we will refer to as , follows the exact procedure of multi - tape intersection ( eq .  [ eq : op : mltint : proc ] ) , using the algorithms for cross product , auto - intersection , and complementary projection .",
    "the second ( more efficient ) algorithm , that we will call , uses first the above single - tape intersection algorithm to perform cross product and one auto - intersection in one single step ( for intersecting tape @xmath183 with @xmath186 ) , and then the auto - intersection algorithm ( for intersecting all remaining tapes @xmath163 with @xmath162 , for @xmath368 ) .",
    "this second algorithm has been used to compile successfully the example of transducer intersection in section  [ sec : exm:2tapeintersect ] .",
    "many applications of wmtas and wmta operations are possible , such as the morphological analysis of semitic languages or the extraction of words from a bi - lingual dictionary that have equal meaning and similar form in the two languages ( cognates ) .    we include only one example in this report , namely the preservation of intermediate results in transduction cascades , which actually stands for a large class of applications .",
    "transduction cascades have been extensively used in language and speech processing ( * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* ; * ? ? ?",
    "* among many others ) .    in a ( classical ) weighted transduction cascade , @xmath369 , a set of weighted input strings , encoded as a weighted acceptor , @xmath370 ,",
    "is composed with the first transducer , @xmath371 , on its input tape ( figure  [ fig : transcascade ] ) .",
    "the output projection of this composition is the first intermediate result , @xmath372 , of the cascade .",
    "it is further composed with the second transducer , @xmath373 , which leads to the second intermediate result , @xmath374 , etc .",
    "the output projection of the last transducer is the final result , @xmath375  : @xmath376    ]    at any point in the cascade , previous results can not be accessed .",
    "this holds also if the cascade is composed into a single transducer , @xmath377 .",
    "none of the `` incorporated '' sub - relations in @xmath377 can refer to a sub - relation other than its immediate predecessor : @xmath378    in a weighted transduction cascade , @xmath379 , that uses wmtas and multi - tape intersection , intermediate results can be preserved and used by all subsequent transductions .",
    "suppose , we want to use the two previous results at each point in the cascade ( except in the first transduction ) which requires all intermediate results , @xmath380 , to have two tapes ( figure  [ fig : wmtatranscascade ] )  : the projection of the output - tape of the last wmta is the final result , @xmath375  : @xmath381    ]    this augmented descriptive power is also available if the whole cascade is intersected into a single wmta , @xmath100 , although @xmath100 has only two tapes in our example .",
    "this can be achieved by intersecting iteratively the first @xmath265 wmtas until @xmath265 reaches @xmath155  : @xmath382    each @xmath383 contains all wmtas from @xmath194 to @xmath384 .",
    "the final result @xmath100 is built from @xmath385  : @xmath386    each ( except the first ) of the `` incorporated '' multi - tape sub - relations in @xmath100 will still refer to its two predecessors .",
    "in our second example of a wmta cascade , @xmath379 , each wmta uses the output of its immediate predecessor , as in a classical cascade ( figure  [ fig : wmtatranscascade2 ] ) .",
    "in addition , the last wmta uses the output of the first one : @xmath387    ]    as in the previous example , the cascade can be intersected into a single wmta , @xmath100 , that exceeds the power of a classical transducer cascade , although it has only two tapes : @xmath388",
    "we wish to thank several anonymous reviewers ."
  ],
  "abstract_text": [
    "<S> this report defines various operations and describes algorithms for _ weighted multi - tape automata _ ( wmtas ) . </S>",
    "<S> it presents , among others , a new approach to _ multi - tape intersection _ , meaning the intersection of a number of tapes of one wmta with the same number of tapes of another wmta , which can be seen as a generalization of transducer intersection . in our approach , </S>",
    "<S> multi - tape intersection is not considered as an atomic operation but rather as a sequence of more elementary ones . </S>",
    "<S> we show an example of multi - tape intersection , actually transducer intersection , that can be compiled with our approach but not with several other methods that we analyzed . </S>",
    "<S> finally we describe an example of practical application , namely the preservation of intermediate results in transduction cascades . </S>"
  ]
}