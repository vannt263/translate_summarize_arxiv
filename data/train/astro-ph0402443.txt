{
  "article_text": [
    "n - body simulations are a key tool in astrophysics .",
    "applications range from cosmological problems involving dark matter to stellar systems and dynamics of galaxies . in many astrophysical problems",
    ", @xmath2 can be very large . for precision calibration of statistical weak lensing ,",
    "large dynamic range is required and this provides a challenge to existing computational resources .",
    "a recent development has been the move towards large massively parallel computers with cheap commodity components and relatively slow interconnects .",
    "the burden of coding in the presence of a large memory hierarchy ( commonly several layers of cache , local memory , remote memory , and secondary storage ) , and distributed message passing libraries is now placed on the scientist who wishes to utilize the large machines .",
    "our goal is to provide the community with a generic n - body code which runs close to optimally on inexpensive clusters . in this paper",
    "we describe the design and implementation of the algorithm , and performance numbers for cosmological applications .",
    "most real world applications on modern microprocessors achieve a small fraction of theoretical peak speed , often only a few percent .",
    "an order of magnitude in speedup is available through the use of assembly coded libraries .",
    "these include routines such as fft s that have been optimized to take advantage of the particular benefits that a given hardware manufacturer can offer in terms of instruction set and processor architecture developments .",
    "a second limiting factor is the amount of physical memory .",
    "most n - body codes are not very efficient in memory use . in principle , one only requires 6 numbers per particle to store the positions and velocities . in practice , other data structures such as density fields and force fields dominate memory usage .",
    "in this paper we present an algorithm that approaches minimal memory overhead , using only seven numbers per particle , plus temporary storage which is small .",
    "the computation is off - loaded onto highly optimized fft s , and the communication cost on parallel machines is mitigated by a two level mesh hierarchy .",
    "in this section we describe the physical decomposition of our algorithm .",
    "gravity is a long range force , and every particle interacts pairwise with every other particle .",
    "the use of a mesh @xcite allows a reduction in computational cost from @xmath3 to @xmath4 .",
    "unfortunately , fft s are highly non - local , and would in principle require global transposes that move large amounts of data between processors",
    ". this can be costly in terms of network resources , especially in economical parallel clusters that employ long latency slow ethernet .",
    "a two level mesh can circumvent this drastic demand on communication hardware resources .",
    "we follow the lines of hydra @xcite , which decomposes the gravitational force into long and short range components .",
    "several authors have described parallel implementations of particle mesh algorithms .",
    "tpm @xcite and gotpm @xcite merge particle mesh and tree algorithms , and have full implementations of the particle - mesh ( pm ) algorithm if one turns off the trees .",
    "these codes are not publicly available , and they were not designed as optimal pm codes . @xcite have also implemented a distributed memory pm scheme , but which requires significant bandwidth .",
    "the long range components can be computed on a coarse mesh .",
    "we use a global coarse mesh which is four times coarser in each dimension than the fine mesh , resulting in a 64-fold savings in global mesh communications .",
    "the fine mesh does not need to be globally stored all the time , as we only need to store the tiles that are being worked on . for coarse mesh fourier transforms , we used the freely available parallel fftw library @xcite .",
    "this library is based on slab decomposition , which our current code adheres to .    in order to obtain optimal performance on shared memory multiprocessor nodes within a clustered environment , the fine mesh is computed on independent cubic sections of the slab .",
    "this allows for multiple processors to update fine mesh forces in parallel and reduces memory overhead by only requiring a fraction of the mesh and its associated structures to exist in memory at a given time .",
    "coarse mesh calculations and particle indexing are also parallelized through shared memory at the loop level to maintain high processor load .",
    "thread - level parallelization has thus been implemented through the use of openmp on the majority of the code , with the only exception being the particle passing routine . due to the lack of freely available thread - safe mpi implementations we have limited message passing to only single thread executed regions of the code , a design choice that maximizes portability .",
    "first , we describe the two - level mesh gravity solver as covered in @xcite .",
    "their method is based on a spherically symmetric decomposition of the potential and force laws . here",
    ", we consider the decomposition of the gravitational potential , although this method is applied equally well to the direct gravitational force .    the gravitational potential @xmath5 is obtained through a convolution , @xmath6 of the density field @xmath7 with a kernel @xmath8 . in order to solve this on a two - level mesh we separate the kernel into a short - range component @xmath9 and a long - range component @xmath10 where the short - range cutoff @xmath11 is a free parameter that will dictate the size of the buffer used between fine mesh tiles and consequently the amount of particles required for passing between nodes .",
    "the function @xmath12 is chosen to be a polynomial , @xmath13 whose coefficients , @xmath14 are determined from the conditions @xmath15 these restrictions ensure that the long - range kernel smoothly turns over near the cutoff and that the short - range term smoothly goes to zero at the cutoff .    the long - range potential @xmath16 is computed by performing the convolution over the coarse - grained global density field @xmath17 .",
    "the superscript @xmath18 denotes that the discrete fields are constructed on a coarse grid .",
    "mass assignment onto the coarse grid is accomplished using the cloud - in - cell ( cic ) interpolation scheme with cloud shape being the same as a coarse cell .",
    "the long - range force field @xmath19 is obtained by finite differencing the long - range potential and force interpolation is carried out using the same cic scheme to ensure no fictitious self - force .    since the two - level mesh scheme uses grids at different resolutions , the decomposition given by equations ( [ eqn : ws ] ) and ( [ eqn : wl ] ) needs to be modified . in fourier space , we can write the long - range potential as @xmath20[\\tilde{w}_l({\\boldsymbol{k}})\\tilde{s}_w({\\boldsymbol{k}})],\\ ] ] where @xmath21 and @xmath22 are the fourier transforms of the mass smoothing window @xmath23 and kernel sampling window @xmath24 , respectively . the mass smoothing window takes into account the cic mass assignment scheme for constructing the coarse density field .",
    "the kernel sampling window corrects for the fact that the long - range kernel given by equation ( [ eqn : wl ] ) is sampled on a coarse grid . in fourier space , the corrected short - range potential kernel is now given by @xmath25 and can be slightly anisotropic , particularly near the short - range cutoff . in figure  [ force_res ]",
    "we display the contribution to the short and long range force by randomly placed particle pairs on the mesh using the spherically symmetric force matching method .",
    "the errors associated with this data set are shown in figure  [ sph_force_comp_err ] .          in this section",
    "we present a general procedure that we use to minimize the error from the two level mesh .",
    "the basic strategy is to minimize the error variance in the total force . since",
    "a variance is a quadratic quantity in the linear sum of two kernels , minimization is a linear problem in the value of the kernel at each point .",
    "we will formulate the problem , and show its solution .",
    "this generalizes the standard procedure of matching spherically symmetric kernels as described in section [ sec : sph ] .",
    "since our fine grid is cubical and not spherical , we can utilize its anisotropy to minimize the force matching error .",
    "we also discuss some residual freedom in the error weights .",
    "we define the error variance @xmath26 of the true force to the grid force @xmath27 ^ 2 w_i .",
    "\\label{eqn : err}\\ ] ] each error term is given a weight @xmath28 , which may be chosen to give constant fractional error , constant radial error , or any other prescription .",
    "our goal is to find a grid force law which minimizes the error given by equation ( [ eqn : err ] ) . for a two level grid , we decompose the grid force into two parts , @xmath29 where @xmath30 is given as the numerical gradient of a potential .",
    "the forces are cic interpolated from the nearest grid cell .",
    "so at each fine grid cell , one has a unique linear coarse force , and the force is also defined at arbitrary separations .",
    "the primary source of grid error arises from the inhomogeneity of the cic interpolation : the force between particles depends not only on their separation , but also on their position relative to the grid cells .",
    "intuitively , one expects the force error to be minimized when the coarse force is smoothly varying , since its inhomogeneity is greatest .    in the potential and force calculation",
    ", we perform a convolution over the density field . to restrict the communication overhead , we require the fine grid force to be short range , in our case 16 fine grid cells .",
    "the total number of non - redundant entries in the force kernel is @xmath31 .",
    "since equation ( [ eqn : err ] ) is quadratic in both the short range potential and the long range force , the exact solution is given by the solution of a linear equation .",
    "we evaluate the sum in expression equation ( [ eqn : err ] ) by placing particles at all integral fine grid cell separations .",
    "the minimization may not be unique , so we use an eigenvalue decomposition and discard zero eigenvectors .",
    "we note that the pair weighting in equation ( [ eqn : err ] ) gives more weight to large separations since there are more wide separation pairs .",
    "also , as written it minimizes the total force error , not the fractional error .",
    "we use a weight function that weighs pairs depending on their separation . in our implementation , each pair is weighted by the actual euclidean separation , which corresponds to constant fractional error . the coarse grid force at a separation of zero and one coarse grid cell are also set to be zero .    in the actual implementation , we generate a vector of 816 variables for the @xmath32 non - redundant entries of the fine grid potential @xmath33 , and a vector of 360 variables to represent the non - redundant three components of the coarse grid force on a @xmath34 grid . call this vector of 1176 unknowns @xmath35 .",
    "we then produce a list of 12320 equations , which over - constrains the solutions . for each fine grid cell , we have two sets of three equations , one for each of the three force components .",
    "we generate equations on an extended @xmath36 grid of fine grid cells , zero padding the fine grid entries beyond the cutoff .",
    "this results in a set of equations @xmath37 .",
    "the least squares solution yields @xmath38 .",
    "the square matrix @xmath39 may not always be invertible , so we perform a singular value decomposed solution .",
    "the actual condition number of the system is @xmath40 ( apart from singular values ) .",
    "double precision is useful to see the spectrum , where one sees a clear break of eight orders of magnitude between the zero eigenvalues and the non - zero ones . despite the large amount of over - determinacy",
    ", there are 255 singular values which are left undetermined , and set to zero .",
    "most of them probably correspond to coarse grid entries that are at too large separations to be constrained .",
    "the actual solution took less than one minute on a laptop .",
    "in contrast , storing the full grid of @xmath41 kernel entries ( which allows one to shortcut symmetries ) would result in 64 times more unknowns , and require a supercomputer to solve the @xmath42 times more expensive problem .",
    "since we probe only one eighth of one octant in the force kernel , we need to explicitly enforce boundary conditions on the minimization .",
    "this is done by requiring the long range force to have zero transverse force along the axes , and to be symmetric along the diagonals .",
    "this optimal force matching results in an anisotropic short range kernel with cubic support .",
    "this differs from most approaches which usually impose spherical symmetry on the decomposition .",
    "the resulting errors , shown in figure  [ lsq_force_comp_err ] , have a smaller scatter than those in figure  [ sph_force_comp_err ] .",
    "the basic logic of the 2-level particle mesh algorithm is presented in figure  [ algor ] . in this method ,",
    "particles local to each node are stored in a non - ordered list . to reduce time spent organizing the particles based on their locations within the mesh",
    ", a linked list is constructed by threads in parallel that associates particles contained within each cell of the coarse mesh .",
    "this is achieved by storing the tail of each threads chain as well as the head , allowing for a merger of the individual lists .",
    "since the linked list is used for determining which particles are to be passed to adjacent nodes it is generated at the beginning of the program execution , as well as following particle passing each time - step .    `  ` + ` subroutine  particle_mesh(code ) ` + `  if  ( first_step )  call  link_list ` + `  call  position_update ` + `  call  particle_pass ` + `  call  link_list ` + `  ! ` @xmath43`omp  end  parallel ` + `  call",
    "coarse_mesh ` + `  call  particle_deletion ` + ` end  subroutine  particle_mesh ` +    density attribution and velocity updating is implemented with the cic interpolation scheme on both mesh levels . on the fine mesh we use a potential kernel and calculate the force by finite - differencing the potential ,",
    "while on the coarse mesh we directly calculate the force utilizing a force kernel .",
    "direct calculation of the force requires @xmath44 extra fourier transforms per coarse time - step , however , this prevents the loss of accuracy associated with finite - differencing and only incurs a minor overhead relative to the fine mesh calculations since there is @xmath45 less data to process .",
    "the code can support any type of force kernel that one would like to construct and is easily interchangeable .",
    "kernels generated with the methods illustrated in sections  [ sec : sph ] and  [ sec : lsm ] are included with the code .",
    "each fine mesh cube requires a buffer density region along its surface area to calculate fine mesh forces within the fine range force cut - off . for the dimensions perpendicular to the decomposition",
    "this can be readily obtained using the particles in the slab , however , additional information is required about the density in the dimension along the decomposition from adjacent nodes .",
    "this layout is presented in figure  [ decomp ] .",
    "we communicate buffer particles from adjacent nodes to locally calculate the density in the buffer region .",
    "this approach removes the communication dependency from mesh calculations and allows it to be done in tandem with the passing of migratory particles , minimizing local processing cost as well as removing potentially complicated communication patterns that could lead to deadlock .",
    "the slab decomposition of the physical volume guides the approach that is used to pass particles between nodes .",
    "referencing of particles based on their location within the mesh is implemented through a linked list spanning the coarse mesh .",
    "the interface between nodes is searched using the linked list to determine if particles lie within the region for buffer construction or migration .",
    "particles that migrate are indexed in an additional deletion list and all of the particles to be passed are included in a buffer for passing .",
    "the passing then occurs over all nodes synchronously and is repeated in the other direction , re - using the buffer .",
    "this is a suitable approach for cosmological applications as the particle flux is relatively balanced between nodes and is dominated by the buffer region .    rather than an additional loop at the end of the step for deletion of buffer particles and particles that exited the node , this process is done during the passing routine and",
    "is illustrated in figure  [ partlist ] .",
    "particles that are to be deleted are shuffled to the end of the particle list using the deletion list .",
    "the incoming buffer region is then searched for new local particles and these are swapped to the end of the now contiguous local particle list . in this fashion one need only change the index of the total number of particles in the list at the end of the step to delete particles that lie outside of the local mesh .        in an effort to maintain a high processor load",
    "we have developed a file transfer interface for the mpi fftw library .",
    "the mpi fftw routines currently are not thread - safe and rather than having only one thread per node participate in the calculation of the coarse mesh fourier transform we execute a separate program which runs an fftw process for each processor on each node .",
    "while this offers no gain in performance for single processor nodes it can provide nearly linear speed - up on multi - processors with a memory overhead equal to that used to store the coarse grid density . the data that is to be transformed is first decomposed on each node by the pmfast process into a number of slabs equal to the number of processors that the node contains .",
    "this data is then written to a file - system , at which point the fftw processes read in the data , perform the transform and write it back .",
    "the pmfast process then reads the decomposed slab and resumes operation . by using temporary file - systems in ram",
    "we avoid the latency cost of having to communicate this information to disk .",
    "we use the time step constraint @xmath46 where @xmath47 is the grid spacing and @xmath48 is the maximal gravitational acceleration .",
    "the coarse grid has four times the grid spacing , and a smoother gravitational field , so the time step is typically limited by the fine grid .",
    "we can exploit this and compute the coarse grid forces less frequently than the fine grid .",
    "second order accuracy in time can be maintained using strang - type operator splitting .",
    "the code currently supports a variable time - step scheme in which multiple fine grid updates are performed for every coarse grid step .",
    "this is currently done in an @xmath49 ratio , where @xmath2 is an odd integer and represents the number of fine steps calculated per coarse step sweep . in order to maintain second order accuracy",
    "all of the fine - steps within the sweep are calculated with the same time interval , and the coarse step is done halfway through the sweep with @xmath50 the time interval used for the fine steps .",
    "the length of the time - step is variable and limited by the maximum acceleration calculated on both the fine and coarse meshes as well as expansion to maintain integration accuracy .",
    "for example , if @xmath51 , we perform two fine step , one combined fine - coarse step , followed by two more fine steps . the code computes and displays the maximal acceleration on the fine and coarse grids at each time - step .",
    "we have already described a range of design choices which minimizes memory and network requirements . to further optimize the code in the presence of memory hierarchies ( cache ) , we use the linked lists in each coarse mesh cell to compute densities and update velocities . on the fine grid ,",
    "the forces are computed by taking the gradient of the potential on a small sub - grid .",
    "then we loop over all particles on the fine sub - grid , which leaves the forces in cache .      for cosmological applications ,",
    "we use periodic boundary conditions .",
    "the advantage of the two level mesh is that isolated boundary conditions are easily applied .",
    "the standard procedure of using a kernel of twice the size of the computational domain usually results in an eightfold computational cost penalty . in the two level grid",
    ", we only need to double the coarse grid .",
    "even a doubled coarse grid is only 1/8th the size of the fine grid , and still a small cost for the whole computation .",
    "this is currently not implemented in the code .",
    "cosmological initial conditions for use in simulations with pmfast can be obtained from the website for the code , or one may employ another generator such as grafic2 @xcite , a gaussian random field generator which can be obtained from http://arcturus.mit.edu/grafic/      our goal is to be able to control errors to enable precise cosmological simulations with a goal of achieving 1% accuracy on the non - linear dark matter power spectrum down to scales below one mpc .",
    "this is about an order of magnitude smaller than the non - linear scale .",
    "errors arise from a range of approximations .",
    "the grid forces deviate at the grid scale , the coarse - fine overlap scale , and on the box scale .",
    "particle discreteness leads to poisson noise .",
    "and the finite time step leads to time truncation error .",
    "the contribution of the fractional error for randomly placed particle pairs in both the radial and tangential directions is displayed in figure  [ sph_force_comp_err ] using the spherically matched kernel and  [ lsq_force_comp_err ] using the least squares method matched kernel .            in order to gauge the cosmological accuracy of the code we have included in figure  [ pow_spectrum ] a comparison between a @xmath0 mesh simulation computed using pmfast and the power spectrum as generated by the halofit algorithm @xcite .",
    "generation of the spectrum from the simulation data requires more memory than is currently available in any single node .",
    "we thus plotted a spliced curve composed of three spectra calculated from the same distribution .",
    "inspection of the power at different wavebands was achieved by first scaling the data - set to a @xmath52 mesh , followed by scalings to @xmath53 and @xmath54 grids which were then folded into 64 and 4096 cubes respectively and superimposed onto a @xmath52 mesh .",
    "cell mesh simulation using 6.4 billion particles ( solid line ) and the spectrum as computed using the halofit algorithm at a redshift of 0 ( dotted line),width=384 ]    figure [ fig : slice ] shows the distribution of particles within a @xmath55 kpc thick slice .",
    "a region is shown in higher resolution in figure [ fig : slice_inset ] .",
    "the code also generates on the fly two - dimensional density projections , which are used for weak gravitational lensing analysis .",
    "the projection of the density field to the mid - plane is shown in figure [ fig : rho_proj ] .",
    "billion particle cosmological simulation at a redshift of 0 .",
    "the inset is shown in figure  [ fig : slice_inset].,width=384 ]         cell density projection at a redshift of 0.033 calculated from the @xmath1 particle simulation .",
    "the box width is 200 @xmath56 mpc.,width=576 ]      our production platform is an ia-64 cluster consisting of 8 nodes , each of which contains four 733 mhz itanium-1 processors and 64 gb ram .",
    "the cluster has point - to - point gigabit ethernet connections between each node .",
    "the maximum fine mesh grid size that we have run is @xmath0 using @xmath1 particles .",
    "the total fine mesh grid length depends on the number of nodes used in the simulation , the width of each fine mesh cube ( dashed boundary in figure  [ decomp ] and the buffer length such that @xmath57    with moderate clustering and a maximum particle imbalance of 12% from mean density each time - step sweep at a 5:1 fine to coarse ratio takes approximately @xmath58 to complete .",
    "this time does not vary significantly for minor load imbalances .",
    "the time estimate is obtained by taking the time taken for 5 fine steps plus one coarse step , and dividing by 5 .",
    "the fine grid fft s account for less than 20% of the computation time .",
    "the code has also been timed on the local cita beowulf cluster @xcite , composed of dual xeon 2.4 ghz processors nodes with 1 gb ram and gigabit ethernet using smaller grid sizes .",
    "table  [ timing ] includes timing data for the simulation on the two platforms using a @xmath59 fine to coarse mesh time - step ratio .",
    "we performed a weak scaling test , where the size of each fine sub - grid is 128 grid cells .",
    "this results in an effective 80 usable fine grid cells after overlap . in this regime ,",
    "the overlap makes density assignment and fine grid fft s a factor of 4 inefficient . on the ia-64 production platform",
    "this overlap only accounts for 25% of the volume using a fine mesh of 512 cells . due to the overlap between fine grids ,",
    "it is not easy to time a pure strong scaling test while keeping the total grid size fixed .",
    "our fine grid was restricted to be a power of two .",
    "the code also exhibits good performance under weak scaling on the ia-32 platform , becoming memory limited at 12 nodes utilizing a @xmath60 total fine mesh .",
    "the weak scaling curve is displayed in figure  [ wscale ] .",
    "l r r r | r platform & & ia-64 + nodes&4&8&12&8 + particles / node&@xmath61&@xmath62&@xmath63&@xmath64 + position update&0.1&0.3&0.7&99.6 + particle passing&0.8&3.6&7.9&262.1 + link list&0.2&0.9&2.1&60.1 + fine mesh&3.6&14.7&34.8&1,513.8 + coarse mesh&2.7&3.2&3.6&166.2 + timestep&7.3&22.7&49.1&2,101.8 + particles / sec&@xmath65&@xmath66&@xmath67&@xmath68 +    [ timing ]",
    "the current code works on a one - dimensional slab decomposition , which limits the degree of parallelism that can be achieved before surface area effects begin to dominate the computing cost .",
    "the local cita beowulf cluster has 256 nodes , which makes a 1-d decomposition across the whole cluster impractical .",
    "of course a 3-d decomposition can be implemented along the same lines , which is in progress .",
    "the current code works on two levels .",
    "this dictates the number of overlap cells needed between coarse and fine grid forces . in principle",
    ", one could use a larger number of grids , and reduce the overlap range by a factor of two .",
    "similarly , one can trade - off the global communications bandwidth with the local buffer size . in a multi - level implementation",
    ", only the top level would be done globally .",
    "this could be on an even coarser grid than our current implementation .",
    "if one passed density fields instead of particles , the buffer regions would also be hierarchical .",
    "the communication costs are then dominated by the overlap between the finest and second finest grids , which could be reduced to 8 fine grid cells .",
    "the buffers for the coarser cells are still 8 grid cells on each coarsened level , but these are a factor of 4 cheaper , and asymptotically only add up to a 1/3 overhead .",
    "the total coarse grid must be at least a factor of eight finer than the width of the logical computer lattice if one does not want buffers to span more than the nearest neighbors .",
    "for the proposed universe simulator with 10000 nodes , this would be 21 processors on a side , corresponding to a @xmath69 coarse grid , whose global communication is completely negligible .      with the current speedup and efficiency ,",
    "the code is memory limited on most existing machines .",
    "while we have already reduced the memory overhead close to the theoretical minimum , one could gain many orders of magnitude in capacity by implementing an out - of - core design in which simulation data is cached to disk @xcite .",
    "in such a scheme , a multi - level grid as described in the previous section would be needed .",
    "we have presented a new freely available parallel particle - mesh n - body code that takes a significant step towards achieving optimality in cpu , communication and memory performance .",
    "the only @xmath70 memory required is six floating point and one integer per particle .",
    "a two level force decomposition allows for the use of a short range force which minimizes communication .",
    "it also eliminates the need to store a global fine grid density field .",
    "cpu performance is optimized by the use of vendor optimized fft libraries , which allows one to deploy very fine grids .",
    "the code is available for download at :      hockney , r. w. & eastwood , j. w. , 1988 , computer simulation using particles ( philadelphia : iop publishing ) couchman , h. m. p. , 1991 ,",
    "apj , 368 , l23 xu , g. , 1995 , apjs , 98 , 355 dubinski , j. & kim , j. & park , c. , & humble , r. , 2004 , newa , 9 , 111 ferrel , r. c. & bertschinger , e. , 1995 , arxiv : astro - ph/9503042 frigo , m. & johnson , s. g. , 1998 , proc .",
    "1998 ieee intl .",
    "acoustics speech and signal processing , 3 , 1381 trac , h. & pen , u. , 2004 , aas , 203 bertschinger , e. , 2001 , apjs , 137 , 1 smith , r. e. & peacock , j. a. & jenkins , a. & white , s. d. m. & frenk , c. s. & pearce , f. r. & thomas , p. a. & efstathiou , g. & couchman , h. m. p. , 2003 ,",
    "mnras , 341 , 1311 dubinski , j. & humble , r. & pen , u. & loken , c. & martin , p. , 2003",
    ", arxiv : astro - ph/0305109"
  ],
  "abstract_text": [
    "<S> we present a new parallel pm n - body code named pmfast that is freely available to the public . </S>",
    "<S> pmfast is based on a two - level mesh gravity solver where the gravitational forces are separated into long and short range components . </S>",
    "<S> the decomposition scheme minimizes communication costs and allows tolerance for slow networks . </S>",
    "<S> the code approaches optimality in several dimensions . </S>",
    "<S> the force computations are local and exploit highly optimized vendor fft libraries . </S>",
    "<S> it features minimal memory overhead , with the particle positions and velocities being the main cost . </S>",
    "<S> the code features support for distributed and shared memory parallelization through the use of mpi and openmp respectively .    </S>",
    "<S> the current release version uses two grid levels on a slab decomposition , with periodic boundary conditions for cosmological applications . </S>",
    "<S> open boundary conditions could be added with little computational overhead . </S>",
    "<S> we present timing information and results from a recent cosmological production run of the code using a @xmath0 mesh with @xmath1 particles . </S>",
    "<S> pmfast is cost - effective , memory - efficient , and is publicly available .    </S>",
    "<S> methods : numerical , cosmology : theory , large - scale structure of universe 02.60.-cb , 95.75.pq , 98.80-k </S>"
  ]
}