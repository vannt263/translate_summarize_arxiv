{
  "article_text": [
    "the question of determining whether two given structures ( for instance , algebraic or combinatorial ) are isomorphic has been a long - standing open problem in mathematics",
    ". a range of structures can be efficiently ( i.e. in polynomial time ) encoded by graphs @xcite , so for these it is sufficient to solve this problem for graphs .",
    "considerable and continuing effort has been devoted to the graph isomorphism ( gi ) problem , due to both the variety of practical applications , and its relationship to questions of computational complexity .",
    "efficient gi algorithms exist for certain restricted classes of graphs , such as trees @xcite , planar graphs @xcite , and graphs with bounded valence @xcite .",
    "indeed , for many practical applications , the gi problem can be viewed as ` easy ' , in that algorithms exist , such as brendan mackay s ` nauty ' algorithm @xcite , which can distinguish pairs of graphs taken from many classes of graphs efficiently .",
    "however as yet , there is no known algorithm with polynomial bounds to solve gi for general graphs .",
    "currently , the best known general gi algorithms scale with @xmath0 @xcite .",
    "in fact , the exact complexity status of gi is unknown and generates much of the interest surrounding the problem .",
    "no np - completeness proof has been found , and indeed it seems likely that the gi problem is not np - complete , in part because the corresponding testing and counting problems are polynomial - time equivalent , unlike the apparent case for all other known np - compete problems . in these cases , the counting problem seems to be much harder , although of course this can not be proven without solving the @xmath1 problem .    just as isomorphism testing of certain structures is equivalent to graph isomorphism , there are various other problems with equivalent difficulty .",
    "problems such as finding the automorphism group of a graph @xcite , and several subsets of gi , such as isomorphism of regular graphs , connected graphs , undirected graphs , and graphs of diameter 2 and girth 4 are all examples of problems equivalent to gi in general @xcite . in other words , solving gi for any of the above classes of graphs would provide an efficient method for solving gi in general .    in this work ,",
    "the emphasis is on polynomial versus non - polynomial time computability of gi .",
    "although we detail the specific scaling of the proposed algorithms to follow , we recognize that their current implementation may not be optimized , and it is likely that variations based on the same general theme could be developed that scale with lower order polynomials . for now , however , the important theoretical direction is towards establishing a polynomially scaling gi algorithm .    in this paper",
    "we present an algorithm utilizing the action of quantum walks on graphs to distinguish given pairs of graphs .",
    "firstly , we introduce the concept of a quantum walk , and relate it to the more familiar classical random walk .",
    "we then discuss possible efficient , classical implementations of quantum walks on general graphs .",
    "a detailed discussion of a resulting gi algorithm follows , including scaling arguments , and results from testing against various sets of graphs .",
    "finally , the corresponding quantum gi algorithm is discussed .",
    "there has been considerable interest in quantum walks recently , with a variety of papers published regarding their properties @xcite , uses @xcite , and possible physical implementations @xcite .",
    "they are motivated by notions of quantum systems , and indeed can be thought of as the quantum analogue of simple classical random walks .",
    "consider a classical random walk on a line . in its simplest form ,",
    "it consists of flipping a coin , moving either left or right depending on the outcome of the coin flip , then repeating these steps .",
    "the coin provides a means of randomizing the chosen direction of propagation .",
    "for example , consider an unbiased discrete walk on the integers , in which direct walking is allowed only between consecutive integers .",
    "if the walk is started at the origin , then after one step the walker would be at @xmath2 or @xmath3 with equal probability , and after two steps , at @xmath4 with probability @xmath5 , and @xmath6 or @xmath7 with probability @xmath8 .    for our purposes ,",
    "we identify three important differences in the definition of a quantum walk .",
    "firstly , since it is defined in terms of a physically implementable quantum system , both the coin and shifting operations are constrained to be unitary .",
    "in addition , all possible paths of the walk are sampled simultaneously - in other words , we can think of the evolution of the walk as being the evolution of the probability amplitude distribution , rather than involving a walk along a distinct path . finally , as a result of the previous two requirements , quantum walks have memory , in that the outcome of the ` coin flip ' depends on outcome of previous coin flips .",
    "in fact , quantum walks in their present form have a one - step memory .",
    "this is achieved by increasing the state space of the walk , splitting each node of the position space into a group of @xmath9 sub - nodes ( or ` coin positions ' ) , as illustrated in figure [ subnode ] , where @xmath9 is the number of outgoing ` edges ' from the node . in this case",
    "we are assuming that the walk is associated with some geometric structure containing edges , in which walking occurs only along these edges .",
    "the coin operator acts differently on each sub - node , thus giving the walk its memory .",
    "much of the interest in quantum walks has been based around their markedly different spreading characteristics , compared to those from simple classical random walks .",
    "unbiased quantum walks along a line result in spreading with visible interference patterns such as that of figure [ probdist ] ( solid line ) , whereas simple classical random walks give rise to a gaussian distribution ( dashed line in figure [ probdist ] ) . to investigate what causes these differences in propagation , we considered distributions resulting from altered quantum walks , in which one or more of the three requirements above were relaxed .",
    "we found that both the memory of the walk and the simultaneous sampling of all paths are needed to produce similar probability distributions to figure [ probdist ] ( solid line ) .",
    "the combination of these two properties results in interference / interactions between different paths of the walk , not seen in classical random walks and certainly not possible with markovian processes .",
    "this interaction between paths is the key difference between classical random walks and quantum walks .",
    "the third requirement , that of unitarity , is not strictly necessary to produce such probability distributions , and can be relaxed for classical implementations of these walks .",
    "it is however , necessary for a closed quantum system , and is an implicit property of any quantum implementation .    for the remainder of this paper we will only be utilizing the probability amplitude distributions associated with these walks .",
    "this removes any random aspect to both walks , as the evolution of the probability distributions is in both cases a deterministic process .",
    "it also removes one of the major nominal differences between the definitions of quantum and classical random walks described above , with the classical random walk now also involving sampling of all possible paths simultaneously .",
    "however , though simultaneous , the sampling of different paths proceeds independently , unlike the quantum walk , due to the lack of memory between steps .",
    "quantum walks on graphs are defined as above , with the shifting operator defined intuitively in terms of the edge set of the graph , so that direct transitions are allowed only between vertices connected by an edge .",
    "note that each vertex , or node , can be thought of as having a group of sub - nodes ( or coin positions ) , each associated with an outgoing edge .",
    "this means that each edge is now associated with two coin positions , one from each vertex connected by the edge . in effect",
    ", this describes a directed graph , as each end of an edge is defined , and can be manipulated , separately .    for a more formal mathematical definition of quantum",
    "walks along graphs , consider an undirected graph @xmath10 , characterized by a set of vertices ( or nodes ) @xmath11 , together with a set of edges @xmath12 , being unordered pairs connecting the vertices .",
    "a step of the walk is composed of both a coin operation and a shifting operation ( in either order ) . associated with each node @xmath13 with valency @xmath14",
    "is a group of @xmath14 sub - nodes .",
    "each sub - node is in turn associated with a directed edge outgoing from @xmath15 , as described above .",
    "the shifting operator then acts on the extended position space , spanned by these sets of sub - nodes .",
    "its action consists of swapping the probability amplitudes of the pair of sub - nodes associated with each edge .",
    "for example , representing the amplitude corresponding to the di - edge connecting @xmath15 to @xmath16 as @xmath17 , and the amplitude corresponding to the di - edge in the opposite direction , connecting @xmath16 to @xmath15 , as @xmath18 , the action of the shifting operator is defined by @xmath19    the coin operator acts on the same extended position space , and its action consists of independently mixing the probability amplitudes associated with each group of sub - nodes of a given node .",
    "for example , given an undirected graph @xmath10 with @xmath20 vertices and @xmath21 edges ( i.e. @xmath22 and @xmath23 ) , there are @xmath24 sub - nodes , or coin positions , hence the position space of the walk can be represented by a @xmath24 column matrix .",
    "then the shifting operator ( @xmath25 ) can be represented as a ( @xmath26 ) permutation matrix , and the coin operator ( @xmath27 ) as a unitary ( @xmath26 ) block diagonal matrix , with each block representing a group of sub - nodes associated with a node .",
    "each step of the walk is then represented by a unitary ( @xmath26 ) matrix @xmath28 , where @xmath29 , acting on the state space .",
    "note that quantum walks involve unitary evolution and are hence reversible .",
    "unlike classical random walks , they do not approach a stationary probability distribution .",
    "indeed , for graphs with a high degree of regularity or large automorphism group , the resulting probability distributions often exhibit periodic behaviour .",
    "observations of probability distributions resulting from quantum walks along various graphs showed a strong relationship between the complexity of the probability amplitude distribution , and the size of the automorphism group .",
    "moreover , since the amplitude distributions obtained showed a high sensitivity to minor changes in the graph , it seemed likely that properties of the probability distribution might serve as an effective tool for producing a graph certificate that would enable the topological uniqueness of a graph to be established .",
    "these observations provided the motivation behind looking into a possible gi algorithm based on quantum walks .",
    "initially , this was with a view to quantum systems ( and hence a quantum algorithm ) only . however , while constructing the algorithm it became evident that for the purposes required here , quantum walks can be implemented efficiently on a classical computer .",
    "consider the situation above , with a quantum walk along a simple , undirected graph with @xmath20 nodes and @xmath21 edges .",
    "there are exactly @xmath24 coin positions , where @xmath30 .",
    "matrix multiplication between two matrices of size ( @xmath31 ) requires @xmath32 computational time .",
    "each step of the walk involves applying the shifting and coin operations to the state vector , of length @xmath24 . then given shifting and coin operators",
    "both described by ( @xmath26 ) matrices , each step of the walk can be implemented on a classical computer in a time that scales with o(@xmath33 ) , being at most @xmath34 .",
    "in fact the shifting operator can be implemented much faster than @xmath34 .",
    "a more straightforward implementation than matrix multiplication , involving directly rearranging the elements of the state space , has an upper bound scaling of @xmath35 . in this case , the permutation of the state space corresponding to the shifting operator is implemented by sequentially mapping between individual states , via a temporary section of computer memory .",
    "similarly , the coin operator , a block diagonal matrix containing @xmath20 blocks each of size at most @xmath20 , can also be implemented with an upper bound scaling of @xmath35 .",
    "hence quantum walks on graphs , in the form described above , are efficiently implementable on a classical computer , with the computational time required to simulate a step of the walk being on the order of @xmath35 .    for the purposes of a gi algorithm",
    ", the coin operator must not be biased with respect to the labeling of the vertices . in particular",
    ", this means that each block ( or ` coin ' ) of the coin matrix must be symmetric , with the form @xmath36    since each coin must also be unitary , the grover coin , having the definition @xmath37 is the only purely real , non - trivial coin satisfying the constraint that symmetry with respect to labeling is preserved .",
    "similarly , the shifting operator must not be biased with respect to labeling .",
    "hence its action can only consist of either the identity operation , or shifting along the edge with which the corresponding coin position is associated . as a consequence ,",
    "the shifting operator applied twice is simply the identity operator .",
    "a simple gi algorithm directly employing quantum walks could consist of starting in an equal superposition of all states , evolving a quantum walk along two graphs for some fixed number of steps , then comparing the two sets of probability amplitude distributions obtained .",
    "if the probability amplitude at one node of one graph had no corresponding match for any node of the other graph , the graphs would be necessarily distinct .",
    "consider two graphs in which each node on one graph has the same number of cycles of every length as at least one node on the other graph .",
    "we will term such graphs ` walk - equivalent ' .",
    "it is clear that the method above distinguihes graphs which are not walk - equivalent .",
    "indeed , such a naive method is quite effective at distinguishing most graphs .",
    "however , the method fails to distinguish very similar graphs , including some vertex transitive graphs , and all strongly regular graphs with the same parameters .",
    "similar methods have been independently attempted in previous work @xcite .",
    "al . performed single - particle quantum walks on closed graphs , but they concluded that such walks fail to identify non - isomorphic strongly regular graphs @xcite .",
    "al . introduced a new matrix representation inspired by quantum walks @xcite .",
    "this representation appears to yield different spectra for sets of non - isomorphic strongly regular graphs , but it fails to distinguish other regular graphs , and general non - regular graphs .",
    "note that methods which attempt to solve gi in general tend to break down for certain difficult classes of graphs , most notably strongly regular graphs , pairs of which are commonly used as test cases for proposed gi algorithms . a strongly regular graph ( srg ) with parameters",
    "@xmath38 is a @xmath9-regular graph of order @xmath20 , such that all pairs of adjacent nodes have exactly @xmath39 common neighbors , and all pairs of non - adjacent nodes have exactly @xmath40 common neighbors .",
    "so applied in their simplest manner , quantum walks can not distinguish certain classes of graphs , including srg s with the same parameters .",
    "however we have significantly more freedom available in the construction of such an algorithm . in this case",
    ", we can add certain inhomogeneities into the graphs , with the aim of breaking the symmetry with respect to the walks that exists between them .",
    "such inhomogeneities could take a variety of forms , such as self loops or gadgets added to a node , extra nodes added along an edge , or phase additions to nodes or edges . of these forms , phase represents a particularly elegant addition to such walks , in that the connectivity of the graph is left unaltered , and the definition of quantum walks allows for phase additions to nodes or edges ( directed or undirected ) without significant extra computational costs .",
    "phase can be added equivalently to the coin operator ( added to blocks of the coin matrix ) or the shifting operator ( added to directed edges ) , or as a separate third component of a step of the walk ( added directly to the state space ) .",
    "for example , a @xmath41-phase can be added to a di - edge @xmath42 by altering the action of the shifting operator from : @xmath43    although pairs of ` walk - equivalent ' graphs are often not distinguished using simple quantum walks , if phase additions are made to two or more nodes , cycles originating from , or involving , these nodes will also interact .",
    "the connectivity , or geometric relationship between such paths then becomes important , and affects the evolution of the walks .",
    "any gi algorithm as a whole must not be biased with respect to the labeling of the vertices , since we require identical results to be produced from all possible permutations of a graph .",
    "so if phase is added about certain nodes ( termed ` reference nodes ' ) , we need to cycle over all possible such selections within the algorithm .",
    "given some arbitrary vertex of a graph as a reference node , the labeling of this node is considered fixed , however to preserve the arbitrary labeling of all other nodes , phase additions can only be made to groups of nodes defined solely in terms of this reference node .",
    "the only such groups are the groups of vertices at each fixed distance from the chosen vertex , and the sets of edges mapping both within and between each of these groups , shown in figure [ ranked ] .",
    "explicitly , for a chosen vertex @xmath15 of a graph @xmath10 , these are the sets of vertices : @xmath44 for any constant @xmath45 , where @xmath46 is the distance between @xmath47 and @xmath15 , and the sets of edges : @xmath48 = b\\right\\},\\ ] ] for any constant @xmath49 .",
    "distinct phase additions can be made to nodes or directed edges within each of these divisions , consistently with respect to labeling .",
    "if two or more reference nodes are selected , further divisions can be made , consisting of nodes or edges connecting these nodes , or at some fixed distance from two or more of them .",
    "given two isomorphic graphs , for each possible set of chosen reference nodes on one graph , there must be at least one corresponding set of reference nodes on the other graph yielding an identical probability amplitude distribution .",
    "the aim of a gi algorithm is then to implement a scheme of phase additions in which , for all non - isomorphic pairs of graphs , there are efficiently measurable differences between the resulting probability distributions .",
    "based on this phase addition scheme , we propose the following gi algorithm .",
    "we are given a pair of graphs @xmath50 and @xmath51 .",
    "for each graph @xmath10 with order @xmath20 , we initialize a quantum walk , starting in an equal superposition of all states .",
    "we then ( arbitrarily ) choose two nodes @xmath52 and @xmath53 on the graph , termed ` reference nodes ' .",
    "for each of these two nodes , consider the groups : @xmath54 defined only in terms of the reference nodes .",
    "these groups are the reference node itself ( @xmath55 ) and the groups of adjacent nodes ( @xmath56 ) and non - adjacent nodes ( @xmath57 ) .",
    "phase additions are made at each step of the walk to @xmath55 , the edges connecting @xmath56 to @xmath57 , and to the edges connecting @xmath56 to @xmath55 .",
    "the walk is evolved for a number of steps with an upper limit of @xmath58 , to ensure that the walk samples all areas of the graph , with any differences in amplitude propagating back to the reference nodes . at each step of the walk , the probability amplitude associated with the node @xmath52",
    "is recorded .",
    "the process is then repeated for all @xmath59 possible choices of @xmath52 and @xmath53 , producing @xmath59 sets of probability amplitudes .    in order to establish a ` baseline ' measure of the symmetry of each graph individually with respect to these walks , the sets are compared pairwise . in other words ,",
    "each set of @xmath20 probability amplitudes , corresponding to some pair of reference nodes , is compared to every other set , building up a comparison table with @xmath60 elements .",
    "if the set resulting from one pair of reference nodes @xmath15 and @xmath16 matches that resulting from another pair @xmath61 and @xmath62 , we write a `` 0 '' on the comparison table , in the position @xmath63 .",
    "otherwise , if the sets do not match , this is recorded as a `` 1 '' .",
    "for the two given graphs , we then obtain two tables , labeled ( a - a@xmath64 ) and ( b - b@xmath64 ) , representing the comparison of each graph to its own permutation . a third table ( a - b ) , also containing @xmath60 elements , is constructed by pairwise comparison of the sets of probability amplitudes from one graph to those from the other graph .",
    "these tables provide a measure of the relative amplitude distributions resulting from walks along the two graphs . in effect",
    ", the ( a - a@xmath64 ) table represents a comparison of graph a to itself ( or equivalently to a permutation of itself ) , whereas the ( a - b@xmath64 ) table represents a direct comparison between the amplitude distributions resulting from graphs a and b.    comparing the amplitudes of the reference nodes ( i.e. partial states ) is for our purposes equivalent to comparison of the entire distributions , since differences in parts of the distributions propagate through to all nodes with repeated application of the walks . in effect , repeated steps of the walk results in a recursive partitioning of the vertex set based on the relative connectivity of each node from the pair of reference nodes . in other words ,",
    "differences between the overall states after some number of steps ( manifested as differences between the amplitudes of some small subset of nodes in each graph ) are propagated throughout the entire distribution after repeated steps of the walk , and in particular propagated to the reference nodes , which are then measured .",
    "if the comparison table ( a - b ) is different to ( a - a@xmath64 ) or ( b - b@xmath64 ) ( beyond a permutation ) , the two graphs a and b are necessarily non - isomorphic .",
    "for the purposes of the algorithm , the total number of `` 1 ' 's in the three comparison tables ( a - a@xmath64 ) , ( b - b@xmath64 ) and ( a - b ) are compared .",
    "if these totals differ , the graphs a and b are again necessarily different .",
    "the important question is whether the converse is true - whether equal sets of probability amplitude distributions resulting in equal comparison tables imply that the graphs _ are _ isomorphic .",
    "computational testing against databases of graphs , detailed in section [ testing ] , supports this possibility , and attempts to establish a formal proof are currently in progress .",
    "the use of two reference nodes is a vital aspect of this algorithm .",
    "addition of phase about only one reference node fails to identify sufficient connectivity information .",
    "for instance , the properties of strongly regular graphs ( namely that they are regular , all pairs of adjacent nodes have the same number of common neighbors , and all pairs of non - adjacent nodes have the same number of common neighbors ) mean that they can not be distinguished through the use of a single reference node , since the propagation of phase from this node will be identical for srg s with the same parameters .",
    "specifically , the number of paths of any given length between two points at some fixed distance is identical , and hence the propagation of phase throughout the graph , eminating from a single reference node is also identical .",
    "however given two or more reference points , the complex amplitudes associated with paths originating from both points will interact , leading to differences in the resulting amplitude distributions of the walks . taking further steps of the walks recursively partitions the vertex set , based on the relative connectivity of the nodes .",
    "essentially , differences occuring within the probability amplitude distributions arising from quantum walks along two graphs will propagation through the distribution .",
    "for instance , if the amplitude at node @xmath65 is different after some number of steps of the walk , all nodes connected to @xmath65 will have different amplitudes after taking further steps of the walk . expressing the veracity of the above gi algorithm in an alternate form",
    ", it requires that all isomorphism classes of graphs are distinguished based on the connectivity of nodes relative to all possible pairs of reference points",
    ".    given differences in the amplitude distributions resulting from walks along a pair of graphs , these differences will appear in the comparison tables produced by the algorithm , as `` 1 ' 's in positions where the `` 0 ' 's ( matches ) would otherwise occur when comparing one of the graphs to a permutation of itself .",
    "for example , consider the two strongly regular graphs with parameters ( 16,6,2,2 ) , shown in figure [ srgs16 ] .",
    "running through the above steps , we find that for the first graph , adding phase about nodes 1 and 2 , the amplitude distribution measured at node 1 matches that obtained for 144 other pairs of nodes of this graph , shown in the comparison table of figure [ comp](a ) .",
    "however , it does not match the amplitudes obtained from any of the other pairs from the second graph , as shown in the comparison table of figure [ comp](b ) .",
    "if these two graphs were isomorphic this total number of matches would be necessarily identical .",
    "hence , the graphs are distinguished .",
    "the complexity of this algorithm can be ascertained by first noting ( from section [ qw ] ) that the computational time required to implement a step of a quantum walk along a graph of order @xmath20 scales with an upper bound of @xmath35 .",
    "constructing the sets of probability amplitudes requires taking @xmath20 steps of the walk for each of the @xmath59 pairs of phase nodes , hence requiring a total computational time of @xmath66 .",
    "an upper bound of @xmath35 comparisons are then made between elements of these sets of amplitudes .",
    "hence the algorithm in its present form scales with @xmath67 .",
    "this complexity calculation , however , does not take into account the possible precision required for the probability amplitude . it may be possible that after the walk is evolved for the required number of steps , the differences in probability amplitudes between non - isomorphic graphs are exponentially small relative to the graph size . since the information that is required when comparing a pair of graphs is the relative values of the probability amplitudes , and not their absolute values , it is possible that this problem can be circumvented ( at least in the classical case ) , given appropriate alterations to the algorithm .",
    "this is the subject of further study however , and will be left as an open problem at this stage .",
    "since the problems of testing for isomorphic graphs , and finding a specific mapping ( isomorphism ) between isomorphic graphs are turing equivalent @xcite , we can extend the algorithm described above to provide an efficient ( polynomial time ) method to either find an isomorphism between graphs which are not distinguished and hence prove they are isomorphic , or prove that the algorithm does not solve gi .    specifically , consider two graphs a and b which are not distinguished by the above algorithm .",
    "we choose a node of a , and fix its labeling , for instance by adding a self loop or gadget to the node .",
    "we repeat this for one node of b , fixing its labeling in the same way , and then compare the graphs using the above algorithm .",
    "we then repeat this method , cycling over all @xmath59 combinations of single nodes in a and b. if the two graphs are isomorphic , isomorphisms between them will be manifested as matches between the graphs .",
    "hence any mapping compiled from such matches represents an isomorphism between the graphs .",
    "this mapping can then be applied to the adjacency matrices , and easily checked .",
    "if it does not represent a mapping between the adjacency matrices of the two graphs , then the algorithm can not distinguish the graphs down to their isomorphism classes .",
    "the benefit of this addendum to the algorithm is that the end result of comparing a pair of graphs ( which is arrived at in polynomial time ) must be one of the following : definite knowledge that the graphs are not isomorphic , definite knowledge that the graphs are isomorphic , or a proof that the algorithm does not solve gi .",
    "we tested the above algorithm against a variety of graphs , listed in tables [ table1 ] and [ table2 ] , taken from databases at @xcite .",
    "a wide variety of classes of graphs were chosen , in order to demonstrate that the algorithm is not limited to a specific type of graph .",
    "in particular , a large number of strongly regular graphs ( srg s ) were examined , as groups of srg s with the same parameters are particularly similar , and often used as test cases for proposed gi algorithms .",
    "in addition , groups of projective planes were chosen as they again represent a particularly difficult class of graphs to distinguish . in each case , all graphs were compared pairwise .    in practice",
    ", most graphs do not need to be compared directly as described in the previous section . instead , given two graphs , each graph",
    "can first be compared to its own permutation , with the total number of  0\"s recorded as above summed , resulting in a single integer .",
    "this represents the total number of matches obtained from pairwise comparisons of the probability amplitudes resulting from each pair of reference nodes . if this total differs between the two graphs , they are again necessarily distinct",
    "otherwise , they can then be compared directly .",
    "this presents the possibility of developing a succinct graph certificate using a similar method .",
    "currently , this scheme only yields an incomplete certificate , in that the final integer obtained is not unique to the graph .",
    "however , it is still quite useful for pairwise comparisons of large groups of graphs .",
    "all graphs of each set in tables [ table1 ] and [ table2 ] were first compared indirectly , via this incomplete graph certificate , greatly decreasing the required number of direct comparisons .",
    "for example , there are 32548 strongly regular graphs with parameters ( 36,15,6,6 ) , requiring @xmath68 pairwise comparisons . of these",
    "however , only @xmath69 pairs possessed the same certificate , and were then distinguished with direct comparisons .",
    "all non - isomorphic graphs tested were successfully distinguished .",
    ".[table1]groups of srg s tested ( all graphs in each group were compared pairwise ) . [ cols=\"<,<\",options=\"header \" , ]     it is apparent that there is considerable freedom associated with the chosen phase additions in such a method .",
    "an alternate , simpler phase scheme could involve the addition of phase , at each step , to only the two chosen reference nodes .",
    "even simpler would be to restrict this phase to a @xmath70-phase addition . in effect , restriction to @xmath70-phase additions means that we are no longer working with phases encompassing the one dimensional complex unit circle , but rather two points - the set @xmath71 .",
    "this simplified scheme was tested against all the graphs of tables 1 and 2 , distinguishing all pairs expect one , a pair of srg s with parameters ( 40,12,2,4 ) . specifically , these are the point graph of the generalized quadrangle gq(3,3 ) and its dual ( i.e. the point graph and line graph of gq(3,3 ) ) .",
    "these graphs are particularly similar , being both distance transitive ( and hence rank 3 ) , and having the same size automorphism group . given that they were an exception amongst all graphs tested , being the only non - isomorphic pair not distinguished with the simplest two - phase scheme , several other rank 3 graphs , together with additional generalized quadrangles were tested .",
    "in particular , gq(5,5 ) and gq(7,7 ) ( having orders 156 and 400 respectively ) , together with their respective duals , were compared .",
    "again , the simple two - phase scheme was not sufficient to distinguish them , with the original scheme , involving further phase additions , to edges , required .",
    "all other pairs of rank 3 graphs tested , ranging in order from 49 to 364 , were distinguished using the simple two - phase scheme .",
    "up to this point only a classical implementation of a gi algorithm employing quantum walks has been discussed .",
    "however as the name suggests , quantum walks can be very efficiently implemented on a quantum computer , or some quantum system specifically designed to implement them .",
    "the advantage of a quantum system is the availability of a state space , or memory that grows exponentially with the number of qubits , allowing in particular for a quantum walk to be evolved more efficiently than on a classical computer .",
    "there are also disadvantages in the quantum implementation however .",
    "the complete knowledge of the evolution of the probability amplitude distribution is not available for a quantum system , and instead repeated measurements must be made to approximate the parts of the wavefunction of interest .",
    "hence any algorithm developed would no longer be deterministic .",
    "in some ways the quantum implementation has less freedom in the possible properties of the walk , in that it is restricted to be a unitary process .",
    "depending on the properties of the implementation used however , potentially useful expansions to the algorithm may be accompanied by significantly less , if any , additional costs , compared to those associated with a classical implementation .",
    "modifications must be made to this algorithm to implement it within the constraints of a quantum system .",
    "specifically , since the probability distribution is not directly known , the measurement process requires some important changes .",
    "we can no longer simply record the probability amplitude at one of the phase nodes at each step .",
    "rather than recording these amplitudes from each graph separately , then comparing them , the amplitudes from the two graphs are directly compared . after evolving the walk along each graph separately for",
    "some given number of steps , an additional node is introduced into the system , connecting the two nodes on each graph that are to be compared , as shown in figure [ measurement ] .",
    "the probability amplitudes in each of these two nodes are shifted into the connecting node , with a @xmath70-phase change applied to the wavepacket entering from one direction .",
    "if the connected vertices from each graph have identical probability amplitudes , the @xmath70-phase change will cause them to cancel out exactly , otherwise there will be some non - zero probability to find the walk at this connecting node .",
    "the advantage of this method lies in the requirement of only one measurement , which is a direct comparison between the graphs .",
    "if the connected nodes are equivalent with respect to the walk , there will always be zero probability to measure the walk at the connecting node , hence the measurement itself will not alter the system .",
    "if they are not equivalent , the effects from the measurement will not matter , as all that is required is a zero or non - zero measurement .",
    "note that such a measurement will still need to be repeated many times ( or until a non - zero measurement is made ) to achieve the desired level of accuracy .",
    "in particular , assume the connected nodes are not equivalent with respect to the walk , and the average probability of a non - zero measurement is @xmath72 . assuming this probability remains constant at each step , the probability @xmath73 of a non - zero measurement after @xmath74 steps , is : @xmath75\\nonumber\\\\ & & \\approx 1 - e^{-m / p } \\textrm { for large $ p$}.\\end{aligned}\\ ] ] assuming the walk on a graph of order @xmath20 is on average evenly distributed along all @xmath20 nodes , the average probability is simply @xmath76 . in practice",
    ", the probability amplitude of the walks is often concentrated in small subsets of a graph . accounting for this by taking the average probability at a given node to be @xmath77 , for some constant @xmath78",
    ", we then obtain : @xmath79 giving an error after @xmath74 measurements of approximately @xmath80 .",
    "so to obtain any fixed accuracy , the number of required measurements scales with @xmath81 .    considering the scaling of this quantum algorithm , we note that the two steps of obtaining the sets of amplitudes , and comparing these sets , can no longer be performed separately within the algorithm . instead , for each pair of phase nodes on one graph",
    ", we must cycle over all @xmath59 possible pairs on the other graph , for each one comparing the amplitudes as described above , leading to @xmath60 possible combinations .",
    "@xmath82 steps are required for each set of parameters .",
    "assuming an efficient implementation of the quantum walks , the time to execute one step of the walk scales with @xmath83 .",
    "the complete algorithm would then scale with @xmath84 .    as in section",
    "[ algorithm ] , this complexity consideration is only correct if the differences between the amplitudes of non - isomorphic graphs are assumed to scale at worst polynomially with graph size . otherwise the @xmath85 factor is no longer valid , and the complexity of the algorithm may no longer be polynomial in @xmath20 .",
    "note that the actual space explored in the algorithm ( via the walk along the graph ) involves a memory with an upper bound of @xmath59 , where @xmath20 is the number of vertices .",
    "specifically the memory required scales with @xmath86 , where @xmath87 is the number of edges in the graph . since there will only be exactly @xmath88 states accessed by the walk , requiring in theory only @xmath89 qubits in a quantum implementation .",
    "this allows a more efficient implementation of quantum walks than that attainable with the classical method .",
    "nonetheless , the polynomial growth ( with graph size ) of the state space of a quantum walk along a graph is the reason why quantum walks can also be simulated in polynomial time on a classical computer .",
    "we hope that this work will aid in a deeper understanding of the properties of quantum walks and how they differ from simple classical random walks . for the purposes of evolving such walks within a polynomially growing state space , without the presence of noise or quantum measurements",
    ", we see that they are classically efficiently implementable .",
    "it is an interesting question as to which algorithms exist employing quantum walks that can not be implemented classically .    with regards to the classical gi algorithm developed in this work ,",
    "several open questions remain .",
    "the algorithm successively distinguished all non - isomorphic graphs tested , including groups of graphs traditionally considered to be ` difficult ' to distinguish .",
    "how to prove whether it can distinguish general graphs is the focus of further work .",
    "the general methods employed here may also prove beneficial in the construction of other algorithms .",
    "the measurement method utilized by the quantum gi algorithm is quite novel , and represents an effective means of extracting information from system wavefunctions without undesirable disturbances to the system .",
    "possible derivatives of quantum walks , for instance with multiple - step memories , may also provide fruitful areas of future study . finally , the key property of quantum walks used here to distinguish graphs , namely the interactions between all possible paths through the state space , conceivably has a variety of other uses . for problems",
    "in which rapid sampling of the state space , and control of the interactions between paths through this space are desired , quantum walks provide promising candidates for their solution .",
    "we would like to thank gordon royle for some fruitful discussions and very useful data .",
    "we thank ivec for an intership grant , vital technical support and use of their sgi altix supercomputer .",
    "we also thank a. woods , c.h .",
    "li , c. praeger and j. twamley for their interest in the work , and valuable discussions .",
    "samples of the comparison tables resulting from the two strongly regular graphs of figure [ srgs16 ] .",
    "( a ) and ( b ) represent the ( a - a@xmath64 ) and ( a - b ) comparison tables respectively , from positions ( 1,2 , * , * ) .",
    "if the graphs were isomorphic , these tables would necessarily contain the same number of  1\"s and  0\"s.,width=321 ]     an illustration of the proposed quantum measurement scheme .",
    "the amplitude at two nodes is compared by connecting them via an additional node introduced into the system , at which the measurement is made.,width=321 ]"
  ],
  "abstract_text": [
    "<S> given the extensive application of classical random walks to classical algorithms in a variety of fields , their quantum analogue in quantum walks is expected to provide a fruitful source of quantum algorithms . </S>",
    "<S> so far , however , such algorithms have been scarce . in this work , </S>",
    "<S> we enumerate some important differences between quantum and classical walks , leading to their markedly different properties . </S>",
    "<S> we show that for many practical purposes , the implementation of quantum walks can be efficiently achieved using a classical computer . </S>",
    "<S> we then develop both classical and quantum graph isomorphism algorithms based on discrete - time quantum walks . </S>",
    "<S> we show that they are effective in identifying isomorphism classes of large databases of graphs , in particular groups of strongly regular graphs . </S>",
    "<S> we consider this approach to represent a promising candidate for an efficient solution to the graph isomorphism problem , and believe that similar methods employing quantum walks , or derivatives of these walks , may prove beneficial in constructing other algorithms for a variety of purposes . </S>"
  ]
}