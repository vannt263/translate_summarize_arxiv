{
  "article_text": [
    "efficient solutions to similarity or proximity search problem have many increasingly important applications in several areas , most notably in ( multi)media and information retrieval . besides the usual database centric model some similarity",
    "searching methods can be seen as nearest neighbor classifiers as well , and have applications as internal tools in many systems ( e.g.  for lossy video or audio compression , pattern recognition and clustering , bioinformatics , machine learning , artificial intelligence , data mining ) .",
    "metric space is a pair @xmath0 , where @xmath1 is an universe of objects , and @xmath2 is a distance function @xmath3 .",
    "the distance function is _ metric _ , if it satisfies for all @xmath4 @xmath5 in the point of view of the applications , we have some subset @xmath6 of objects , @xmath7 , and we are interested in the proximity of the objects towards themselves , or towards some query objects .",
    "the most fundamental type of query is _ range query _ : retrieve all objects in the database @xmath8 that are within a certain similarity threshold @xmath9 to the given query object @xmath10 , that is , compute @xmath11 .",
    "another common query ( which can be solved with suitably adapted range query as well ) is to retrieve the @xmath12-nearest neighbors of @xmath10 in @xmath8 .",
    "a large number of different data structures and query algorithms have been proposed , see e.g.  @xcite .      in this paper",
    "we take a fresh look on the well - known gnat @xcite data structure .",
    "while it has some attractive properties , it is often dismissed as having too large memory requirements ( which is partially based on too coarse analysis , as we show ) .",
    "we give several techniques to improve the space complexity , make it memory adaptive in a way that is arguably more elegant than in the baseline gnat , improving its search performance on the same time .",
    "we also show that it is possible to replace gnat s hyperplane partitioning with ball partitioning , which gives more flexibility in certain situations and can also further improve the performance .",
    "it is also possible to increase the tree arity while keeping the same memory usage .",
    "recently gnat gained new interest also in the form of egnat @xcite , a dynamic and external memory based variant of gnat .",
    "many of our techniques can benefit egnat as well , and we discuss some methods that can improve construction and insertion costs in our gnat variant .",
    "we conclude with experimental results that show substantial improvements in space usage and query performance .",
    "we briefly review the algorithms relevant to the present work .",
    "our work is based on gnat , but gnat itself has some connections to aesa ( which we will make more explicit in what follows ) .",
    "egnat is a dynamic external memory variant of gnat .",
    "we also give a new analysis for gnat in this section .",
    "approximating eliminating search algorithm ( aesa ) @xcite is one of the most well - known and one of simplest approaches to index a metric space .",
    "it is also the best in terms of number of distance evaluations needed to answer range or @xmath12-nn queries .",
    "the drawbacks are its quadratic space requirement and high extra cpu time ( the time spent on other work than pure distance evaluations ) .    the data structure is simply a precomputed matrix of all the @xmath13 distances between the @xmath14 objects in @xmath8 .",
    "the space complexity is therefore @xmath15 and the matrix is computed with @xmath15 distance computations .",
    "this makes the structure highly impractical for large @xmath14 .",
    "the range query algorithm is also simple .",
    "first the distance @xmath16 between the query @xmath10 and randomly selected pivot @xmath17 is evaluated . if @xmath18 , then @xmath19 is reported .",
    "then each object @xmath20 that does not satisfy @xmath21 is eliminated , i.e.  we compute a new set @xmath22 .",
    "note that the distances @xmath23 can be retrieved from the precomputed matrix .",
    "however , the elimination process has to make a linear scan over the set @xmath8 , so the cost is the time for one distance computation plus @xmath24 extra cpu time .",
    "this process is repeated with a new pivot @xmath19 taken from the qualifying set @xmath25 .",
    "this selection can be random , or e.g.  the one that minimizes the lower bound distance to @xmath10 ( which can be maintained during the search with constant factor overhead ) .",
    "this is repeated until @xmath26 becomes empty . by experimental results",
    "@xcite the search algorithm makes only a constant number distance computations on average , which means @xmath24 extra cpu time on average .",
    "one should note that the @xmath27 result means that @xmath14 does not affect the number of distance evaluations , while the `` constant '' has exponential dependence on the dimension of the space and the search radius .",
    "there are many approaches to reduce the space and/or the extra cpu time ( e.g.  @xcite ) , but these induce more distance computations or extra cpu time or work only for @xmath12-nn queries ( @xcite ) .      geometric near - neighbor access tree ( gnat ) @xcite is based on hyperplane partitioning applied recursively to obtain an @xmath28-ary tree ( where @xmath28 is a constant / parameter ) .",
    "the tree is built as follows :    1 .",
    "select @xmath28 _ centers _ or pivots ( called split points in @xcite ) @xmath29 .",
    "2 .   associate each object in @xmath30 with the closest center in @xmath31 , obtaining sets @xmath32 .",
    "3 .   compute a _ distance range table _",
    "@xmath33 for the current node , where @xmath34 $ ] , defined as @xmath35,\\ ] ] where @xmath36 .",
    "4 .   build the children @xmath37 recursively using the same method for @xmath38 .",
    "thus the centers @xmath31 induce a recursive voronoi partitioning of the space .",
    "the centers can be selected at random , or using some heuristic @xcite method .",
    "it is also possible ( and common ) to stop the recursion when some predefined number of @xmath39 objects are left ( i.e.  @xmath40 ) , and simply store the remaining objects as a bucket in the leaf .",
    "notice that if for @xmath41 the sets @xmath42 are empty , then @xmath43 and the range table in fact becomes ( almost ) the same matrix that aesa uses .",
    "the difference is that @xmath33 uses more space , as each @xmath44 value is a duplicate of the corresponding @xmath45 value , and aesa uses the symmetry @xmath46 ( in this special case ) to store only half of the matrix .",
    "gnat is often cited to have @xmath47 space complexity , which is an obvious upper bound , but much tighter bound of @xmath48 can also be derived .",
    "we give more detailed analysis below .",
    "we assume that the tree is balanced , i.e.  has depth @xmath49 .",
    "this is hard to guarantee with hyperplane partitioning , but nevertheless in practice the tree tends to have @xmath50 average depth @xcite .",
    "the space complexity can be expressed as , but we use the simpler formula which gives an upper bound . ] @xmath51 and by substituting we get @xmath52 by noticing that the recursion stops when @xmath53 we obtain @xmath54 .",
    "on the other hand , if the tree is extremely unbalanced , say , @xmath55 of the children are empty , and all objects go to the remaining branch , the space is @xmath56 .",
    "the solution is simple , again @xmath57 .",
    "the time complexity to build the tree is @xmath58 .",
    "it is easy to see that the time spent in each level of the ( recursion ) tree is @xmath48 , and hence the whole process takes @xmath59 time . in the worst case ( for unbalanced tree ) the time becomes @xmath60 .",
    "as we will see later , using non - constant arities of the the form @xmath61 in the nodes , for some @xmath62 , gives much better query performance while using the same space as the standard constant arity variant .",
    "the price to pay is even costlier preprocessing step in general .",
    "the range search algorithm for a query object @xmath10 and range @xmath9 resembles the method that aesa uses , except that it is recursive in gnat , starting from the root of the tree :    1 .",
    "select a pivot @xmath63 ( each pivot at most once ) .",
    "2 .   compute @xmath64 , and if @xmath18 , then report @xmath19 .",
    "3 .   if the query ball does not intersect the range associated with some center , then the center ( and the corresponding subtree ) can be pruned , i.e.  if @xmath65 \\cap r_{i , j}$ ] is empty , we can eliminate @xmath66 ; or in other words , if @xmath34 $ ] , then if @xmath67 or @xmath68 we can eliminate @xmath66 .",
    "4 .   repeat the steps 13 until all surviving centers have been tried .",
    "5 .   for each survived center @xmath69 search",
    "recursively the corresponding subtree @xmath70 .",
    "again notice that if the subtrees are empty , then the above algorithm `` degenerates '' into aesa .      as presented , gnat is a static structure once built .",
    "egnat @xcite is a dynamic version of gnat that allows insertions ( relatively easy ) and deletions ( needing novel ideas ) of objects .",
    "egnat is also designed to work efficiently with external memory ( disk ) setting .",
    "we do not go into the details , except for the search algorithm ( ignoring the modification that is needed to handle deletions of objects ) .",
    "egnat uses the same distance range tables as gnat , but uses otherwise simpler ( and less powerful ) algorithm .",
    "more precisely , given a query object @xmath10 , the egnat search algorithm computes _ all _ the distances @xmath71 , reporting @xmath72 if @xmath73 , and finding the nearest neighbor of @xmath10 among the centers in @xmath31 , i.e.  it computes @xmath74 and records @xmath75 .",
    "then all @xmath28 centers are scanned sequentially , and the children @xmath76 is pruned if @xmath77 does not intersect the range @xmath41 .",
    "note that this method has lower extra cpu time than gnat , but in general makes more distance evaluations , and the difference increases when the tree arity increases . on the other hand",
    ", egnat uses relatively low arities .",
    "we present several orthogonal improvements to the baseline gnat .",
    "all of them can be combined into a single algorithm .",
    "assume now that the node arities are of the form @xmath78 , where @xmath79 is the number of objects associated on a node at level @xmath76 of the tree . if the tree is balanced , the space becomes now @xmath80 the solution is @xmath81 , which is easy to see by writing the recurrence as @xmath82 that is , the tree has depth @xmath83 now , and the total space per tree level is @xmath24 .",
    "the time complexity to build the tree is @xmath84 , which solves to @xmath85 . as we see in sec .",
    "[ sec : exp ] , this performs much better than using constant arity , where @xmath86 . note that as a side effect this method also gears the tree towards balance , as the arities are `` automatically '' higher for nodes that have many objects associated with them .",
    "if the node arities are of the form @xmath61 , for @xmath87 ( where above we considered the case @xmath88 ) , the space becomes @xmath89 for @xmath90 , the total space per tree _ level",
    "_ decreases when @xmath91 increases , which gives a ( somewhat loose ) upper bound @xmath92 similarly the construction time becomes @xmath93 notice that for @xmath94 the tree has only one node ( the root ) and the space becomes @xmath95 , and we have effectively turned gnat into aesa . indeed , when @xmath96 the gnat search algorithm becomes aesa , as in this case all the child nodes are empty and hence the @xmath44 and @xmath45 values in the range tables are equal , and the range table matrix also becomes symmetric .",
    "note that the higher arity we use , the smaller clusters the hyperplane partitioning produces , and therefore the @xmath97 ranges in the range tables become smaller , which in turn enable more pruning , as the probability of intersecting with the ( range ) query ball becomes smaller .",
    "thus we have a smooth transition from ght - like tree .",
    "] to gnat to aesa if we adjust @xmath91 from @xmath98 to @xmath99 .",
    "likewise , the preprocessing time grows from @xmath100 to @xmath15 .",
    "an interesting point is that while gnat ( preprocessing ) is based on hyperplane partitioning , the range tables and the search algorithm do not make _ any _ assumption of this .",
    "thus the algorithm works as is , even if we replace the hyperplane partitioning with ball partitioning .",
    "this gives some interesting opportunities to tune the data structure , in particular it is easy to control the ( un)balance of the tree .",
    "the drawback as compared to hyperplane partitioning is that the ball clusters can intersect , which means that even exact search might need to enter more than one branch of the tree during the search . on the other hand , in dynamic settings , such as in egnat ,",
    "ball partitioning gives more flexibility to handle the insertions .    to implement the ball partitioning , we basically need to only change the preprocessing step 2 ( see sec .  [ sec : gnat ] ) for the baseline gnat , while the search algorithm stays intact .",
    "that is , we replace the step 2 with the following ( the arities can still be selected as @xmath101 ) :    1 .",
    "select ball capacities @xmath102 .",
    "2 .   for each @xmath103 , in ascending order , select a radius @xmath104 so that @xmath72 with radius @xmath104 covers exactly @xmath105 objects in @xmath106 ; put these into @xmath38 .",
    "3 .   put the remaining objects @xmath107 into @xmath108 .    for the step 2 ( a ) ,",
    "a simple way is to set each @xmath109 , where @xmath110 .",
    "setting @xmath111 gives a balanced tree .",
    "however , as is shown by the experimental results ( sec .",
    "[ sec : exp ] ) , unbalanced ball partitioned tree can be much more efficient in some search tasks , especially in high dimensions and / or large query radii .",
    "the reason for this is that in high dimensions the distance distributions are very concentrated , and unbalancing effectively makes the covering balls smaller , and hence the probability of intersecting with each other and the query ball decreases .",
    "another reason is that as the right - most path of the tree gets longer , the clusters get more compact and more distances are evaluated in the preprocessing phase , which pays off at the search phase .",
    "note that when using constant arity @xmath28 in all nodes , and @xmath112 does not affect the space complexity , but increases the preprocessing time .",
    "for non - constant arities of the form @xmath113 both space and preprocessing costs are increased quite significantly .",
    "we do not give the formulas here , but just refer to the experimental results in sec .",
    "[ sec : exp ] .",
    "it is also interesting to notice that using gnat with ball partitioning , huge arity for the root and/or large buckets for the leaves we obtain a tree of height 1 , which then resembles list of clusters ( lc ) @xcite with range tables added on top ( i.e.  lc uses only @xmath114 values for pruning ) .",
    "another way to obtain a similar data structure ( plus the added range tables ) , is to use small to moderate constant arity @xmath28 and quite small @xmath115 , and use bucketing for subsets of size @xmath116 .",
    "we remark that methods like excluded middle point ( ball ) partitioning @xcite could also be adapted to work with gnat with some effort , but we leave that as a future work .",
    "the space complexity can be controlled by adjusting the arity , either using the fixed arity @xmath28 or using the dynamic method as described in sec .",
    "[ sec : powa ] .",
    "however , this also affects the search cost at the same time , possibly by a large factor .",
    "moreover , in external memory egnat the arity @xmath28 is limited by the disk block size .",
    "we show how fixed - point representation can be used to reduce the space , as well as give another method that enables controlling the arity and the size of the range tables somewhat independently .",
    "we suggest an implementation method that can compress the distance range matrix without reducing its dimensions ( i.e.  tree arity ) .",
    "the distance range entries in @xmath33 are either continuous or discrete , depending on the metric space , and typically stored using e.g.  floats ( 4 bytes ) or ints ( typically 4 bytes ) in c / c++/java - programming languages .",
    "if in the discrete case the distance range is small ( such as edit distance of relatively short strings ) , then using smaller integer type ( such as char ) may suffice , or one can use custom coded smaller integer representations ( e.g.  use 4 high - order bits of the @xmath44 and @xmath45 values and encode them into a single 8-bit byte ) .    in case of continuous distance values",
    ", one can resort to fixed - point representation .",
    "that is , store the @xmath41 entries in fixed - point representation in the preprocessing step , and when the values are needed in the search phase , retrieve and convert back to floating point .",
    "note that we need not to do any arithmetic in the fixed - point representation .",
    "we use the notation to denote a fixed - point type that is encoded with @xmath39 bits , @xmath28 bits are reserved for the magnitude ( unsigned integer ) part , and @xmath117 for the fractional part . for example , stores the number in 8-bits ( one byte ) , where 2 bits are reserved for the integer part and 6 bits for the fractional part .",
    "this could be used to represent the distances in 10 dimensional unitary cube with euclidean distance .",
    "conversions are easy .",
    "if @xmath118 is a floating point type and @xmath119 a fixed point type , then we can do the conversions as @xmath120 and @xmath121 , where we assume truncation as the rounding mode for the least significant fraction bit when converting to integer type .",
    "the value @xmath122 is called a scaling factor .",
    "if we want to always round up the least significant fraction bit , then we can simply do @xmath123 .",
    "indeed , in order to the gnat search algorithm to work correctly , we need to round up the @xmath45 values . given @xmath124 $ ] in floating point representation , we actually store @xmath125.\\ ] ] that is , round @xmath44 down and @xmath45 up .",
    "one problem with fixed - point representation is that we can not have large magnitude and good precision with a small number of bits , which is a problem if the distance values can be sometimes large and sometimes small .",
    "the other problem is more implementation specific , i.e.  how to fix ( this could be done dynamically , however ) .",
    "one solution that works quite well for a lot of different scenarios is to use some kind of range transform .",
    "for example , one could convert @xmath126 into fixed - point representation instead of converting plain @xmath118 . again , notice that this is not a problem as we do no arithmetic in fixed - point representation .",
    "however , @xmath126 is suitable only if @xmath127 .",
    "better method is to use @xmath128 , for some @xmath129 , as this transforms all positive numbers towards @xmath99 . on the other hand , using very small",
    "@xmath130 would mean too much loss of precision . in practice values like @xmath131 work",
    "very well for .",
    "the conversion becomes now @xmath132.\\ ] ] to convert a fixed point value @xmath119 back to floating point we do @xmath133    as shown in the experimental results , using just one byte to store the ( continuous ) distance values gives negligible performance loss while reducing the space by a factor of 4 .",
    "in some cases using fixed - point instead of floating point actually increases the performance ( i.e.  cpu time ) a little , probably due to better cache utilization .",
    "another idea is to have smaller range tables by not ( fully ) indexing every center .",
    "note that egnat uses just one column of @xmath33 ( corresponding to the nearest neighbor of @xmath10 in @xmath31 ) in each node during searching .",
    "this gives the idea of limiting the set of centers where the nearest neighbor can be selected , effectively removing some of the columns from @xmath33 .",
    "that is , we can select a subset @xmath134 , and compute @xmath135 sized distance range tables .",
    "this does not affect the arity of the tree , just the pruning process , which is trivial to adapt in the case of egnat . for gnat we can replace the aesa - like algorithm e.g.  with a laesa - like algorithm @xcite .",
    "preprocessing time for the @xmath33 tables is also improved .    in any case , this can make the search algorithm potentially worse , i.e.  it may not prune the tree as effectively now , but in return the tree arity can be larger thanks to the smaller tables .",
    "the arities can be increased by a factor @xmath136 , for @xmath137 , if @xmath138 , while keeping the same memory usage for the tables ( per node ) .",
    "this again makes the clusters smaller , giving an opportunity to more effective pruning .",
    "this method may have a positive effect especially in secondary memory implementation .",
    "we have implemented the algorithms in c and ran various experiments with different data sets .",
    "we used random vectors in uniformly distributed unitary cube as well as 112 dimensional color histograms , both with euclidean distance , as well as an english dictionary and a larger dictionary ( combined from several languages , duplicates removed ) with edit - distance .",
    "the databases are from @xcite .",
    "in each case we picked 1000 objects randomly and used them as the queries , building the database using the rest . in each case the index is built the whole way down , i.e.  no bucketing was used for the leaves .",
    "pivots were selected in random in all cases .",
    "we call our algorithm gnatty in what follows .",
    "we used both hyperplane partitioning ( as in original gnat ) and ( unbalanced ) ball partitioning . for ball - partitioning , the optimal value of @xmath115 ( see sec .  [",
    "sec : ballp ] ) depends on the dimensionality of the space and the selectiveness of the queries , as well as the arities .",
    "in particular , for the `` easy '' cases the optimum is @xmath111 , and it decreases as the queries become `` harder '' .",
    "[ fig : gamma ] shows two cases ( random vectors in 15 dimensional space and a string dictionary ) where it is beneficial to use @xmath112 .",
    "note that the space complexity is also affected , in particular for non - constant arities and large @xmath91 , which means that in most cases the optimum @xmath115 may be impractical .",
    "in general , keeping @xmath115 close to @xmath99 and adjusting @xmath91 gives better control for the space / time trade - offs .",
    "in all the subsequent plots we use a fixed @xmath139 , as it usually gives quite a noticable performance boost , while not affecting the space complexity when using non - constant arities too much .    , range query retrieves 10 neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as above , but for string dictionary and @xmath140 . ]",
    ", range query retrieves 10 neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as above , but for string dictionary and @xmath140 . ]",
    ", range query retrieves 10 neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as above , but for string dictionary and @xmath140 . ]",
    ", range query retrieves 10 neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as above , but for string dictionary and @xmath140 . ]",
    ", range query retrieves 10 neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as above , but for string dictionary and @xmath140 . ]",
    "[ fig : alpha ] shows the effect of @xmath91 for two synthetic vector spaces and for english dictionary .",
    "the space is very close to @xmath141 for @xmath142 , but starts to increase rapidly after that .",
    "note however that the data itself can take a lot of space ; e.g.  vectors in 15 dimensional space ( using one float per coordinate ) requires @xmath143 bytes , which is easily more than what the range tables require for moderate @xmath91 . in any case",
    ", if there are available memory , increasing @xmath91 reduces the number of distance evaluations steadily .",
    "observe that ball partitioning gives better results than the original hyperplane partitioning , especially for strings .",
    ", range query retrieves 10 or 100 nearest neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as the previous two , but for strings . ]",
    ", range query retrieves 10 or 100 nearest neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as the previous two , but for strings . ]",
    ", range query retrieves 10 or 100 nearest neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as the previous two , but for strings . ]",
    ", range query retrieves 10 or 100 nearest neighbors ; 2nd plot : the number of range tables entries corresponding to the previous plot ; 3rd and 4th plots : as the previous two , but for strings . ]",
    "[ fig : eqmem ] compares gnatty ( using ball partitioning ) against the original gnat ( hyperplane partitioning and constant arity ) and two variants of egnat , so that all methods use the same amount of memory .",
    "we also compare against gnatty that uses fixed - point ( fp ) ( see sec .  [",
    "sec : fp ] ) to store the range tables ( 1 byte per distance ; the baseline method uses 1 float , i.e.  4 bytes ) .",
    "recall that egnat ( besides the added dynamism and external memory implementation ) is as gnat with simpler pruning rules .",
    "as seen in the plots , this does not work well for large arities ( the original egnat uses relatively low arities ) .",
    "hence we added a nearest neighbor ( nn ) index over the pivots so that the nearest pivot ( along with any pivot in the range ) to the query can be retrieved faster .",
    "the performance of gnatty fp is close to gnatty , even if the former uses only 1/4th of the space and approximated distance values .",
    "we include list of clusters ( lc ) @xcite as a baseline competitor .",
    "lc uses only @xmath24 space .",
    "the bucket size for lc was optimzed for @xmath144 and @xmath140 , for color histograms and strings , respectively .    as an other example ,",
    "using @xmath145 on the color histograms database , gnat with hyperplane partitioning would need @xmath146 to reach the performance of gnatty with ball partitioning and @xmath142 . on the large string dictionary for @xmath140 ,",
    "gnat would need @xmath147 to match gnatty with @xmath148 .",
    "note that the constant factor in the @xmath149 space complexity is often relatively small , as near the leaves it is not possible to use the full arity as there are not enough objects left .",
    "e.g. , for @xmath150 and the strings dictionary , gnat requires `` only '' about @xmath151 range table entries .",
    "we also ran preliminary experiments on using smaller range tables ( see sec .",
    "[ sec : smalltables ] ) . as expected",
    ", this reduces the performance , some of which can be bought back by using larger arities ( sometimes the performance is improved a bit ) .",
    "the net effect is that using the same space the tree height can be reduced , but the queries become somewhat slower , and this effect increases the smaller the range tables become .",
    "we omit the plots . nevertheless , the technique has some promise for external memory implementation , which is a subject of future work .    , the other gnat variant use constant arity that results in the same memory consumption as in gnatty , except gnatty fp uses 1/4th of the memory gnatty uses .",
    "lc uses linear space .",
    "bottom : as above , but gnatty uses @xmath152 . ]    , the other gnat variant use constant arity that results in the same memory consumption as in gnatty , except gnatty fp uses 1/4th of the memory gnatty uses .",
    "lc uses linear space . bottom : as above , but gnatty uses @xmath152 . ]",
    "we have shown several methods how to improve gnat and verfied their practical performance . however , there are many possibilities for further work .    *",
    "the hyperplane partitioning construction cost can be lowered somewhat by using an auxiliary index to solve the 1-nn queries in step 2 of the construction algorithm , especially for high arities .",
    "that is , build 1-nn index for the centers / pivots , and use 1-nn queries for each object to find its associated center .",
    "* bulk loading the tree can also be lazy , i.e.  a branch of the tree can be built only on demand , when the search algorithm enters it , which amortizes the search and construction costs . *",
    "the range tables for the nodes can be also built in the same spirit as the previous item , i.e.  any @xmath41 value can be initialized to some default value and the real value is computed when it is needed the first time .",
    "this can be also used with the egnat insertion algorithm to amortize its cost ; i.e.   new elements are inserted into leaves , which are initially buckets and promoted to full gnat like internal nodes when they becomes full .",
    "* gnatty techniques can be used for external memory implementation as well .",
    "egnat uses the same arity for all internal nodes ( including root ) , depending on the disk block size .",
    "however , the root node can be made ( much ) larger than the other nodes , as it can be kept in main memory all the time .",
    "l.  mic , j.  oncina , e.  vidal , a new version of the nearest - neighbor approximating and eliminating search ( aesa ) with linear preprocessing - time and memory requirements , pattern recognition letters 15 ( 1994 ) 917 ."
  ],
  "abstract_text": [
    "<S> geometric near - neighbor access tree ( gnat ) is a metric space indexing method based on hierarchical hyperplane partitioning of the space . </S>",
    "<S> while gnat is very efficient in proximity searching , it has a bad reputation of being a memory hog . </S>",
    "<S> we show that this is partially based on too coarse analysis , and that the memory requirements can be lowered while at the same time improving the search efficiency . </S>",
    "<S> we also show how to make gnat memory adaptive in a smooth way , and that the hyperplane partitioning can be replaced with ball partitioning , which can further improve the search performance . </S>",
    "<S> we conclude with experimental results showing the new methods can give significant performance boost .    </S>",
    "<S> gnat , egnat , aesa , metric space indexing , generalized hyperplane partitioning , ball partitioning </S>"
  ]
}