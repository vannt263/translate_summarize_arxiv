{
  "article_text": [
    "while traditional logic and constraint logic programming ( clp ) languages are untyped and unmoded , recent languages such as mercury  @xcite and hal  @xcite require type , mode and determinism declarations for ( exported ) predicates .",
    "this information allows the generation of efficient target code ( e.g.  mode information can provide an order of magnitude speed improvement  @xcite ) , improves robustness and facilitates efficient integration with foreign language procedures .",
    "here we describe our experience with mode checking in the hal compiler .",
    "hal is a clp language designed to facilitate `` plug - and - play '' experimentation with different solvers . to achieve this",
    "it provides support for user - defined constraint solvers , global variables and dynamic scheduling .",
    "mode checking in hal is one of the most complex stages in the compilation . since",
    "predicates can be given multiple mode declarations , mode checking is performed for each of these modes and the compiler creates a specialized _ procedure _ for each mode ( i.e.it performs multi - variant specialization ) .",
    "mode checking involves traversing each predicate mode declaration to check that if the predicate is called with the input instantiation specified by the mode declaration then the following two properties are satisfied .",
    "first , the predicate mode declaration is _ input - output correct _ , that is , it is guaranteed that if the input instantiation satisfies this declaration then the result is an output instantiation that satisfies the declaration . and",
    "second , the predicate is _ call correct _ , that is , if the input instantiation satisfies this declaration then each literal occurring in the definition of the predicate is called with an input instantiation satisfying one of its declared modes .",
    "call correctness may require the compiler to re - order literals in the body of each rule , so that literals are indeed called with an appropriate input instantiation .",
    "such reordering is essential in logic programming languages which wish to support multi - moded predicates while , at the same time , retaining a prolog programming style in which a single predicate definition is provided for all modes of usage . and an important function of this reordering is to appropriately order the equalities inserted by the compiler during program normalisation for matching / constructing non - variable predicate arguments .",
    "the need to reorder rule bodies is one reason why mode checking is a rather complex task .",
    "however , it is not the only reason .",
    "three other issues exacerbate the difficulty of mode checking .",
    "first , instantiations ( which describe the possible states of program variables ) may be very complex and interact with the type declarations .",
    "second , accurate mode checking of higher - order predicates is difficult .",
    "third , the compiler needs to handle automatic initialization of solver variables .",
    "although mode inference and checking of logic programs has been a fertile research field for many years , almost all research has focused on mode checking / inference in traditional ( and thus untyped ) logic programming languages where the analysis assumes the given literal ordering is fixed and can not assume that a program is type correct .",
    "thus , a main contribution of this paper is a complete definition of mode checking in the context of clp languages which are strongly typed and which may require reordering of rule body literals during mode checking .    a second contribution of the paper is to describe the algorithms for mode checking currently employed in the hal compiler .",
    "since hal and the logic programming language mercury share similar type and mode systems , much of our description and formalization also applies to mode checking in mercury ( which has not been previously described ) .",
    "however , there are significant differences between mode checking in the two languages . in hal",
    "there is the need to handle automatic initialization of solver variables , and , in general , complex modes ( other than ` in ` and ` out ` ) are used more frequently since constraint solver variables are usually not ground . furthermore , determining the best reordering in hal is more complex than in mercury because the order in which constraints are solved can have a more significant impact on efficiency @xcite .",
    "also , hal handles a limited form of polymorphic mode checking . on the other hand , mercury s mode system allows the specification of additional information about data structure liveness and usage .    the rest of the paper is organized as follows . in the following section we review related work .",
    "section [ sec : lang ] provides an informal view of the role of types , modes , and instantiations in the hal language .",
    "its aim is to give insight into the more rigorous formalization provided in section [ sec : trees ] which introduces type - instantiation grammars for combining type and instantiation information as the basis for mode checking in hal .",
    "section [ sec : basic ] describes the basic steps performed for mode checking hal programs .",
    "section [ sec : init ] focuses on the automatic initialization needed by the modes of usage of some predicates .",
    "section [ sec : higher ] discusses mode checking of higher order predicates and objects , while section [ sec : poly ] shows how to handle simple polymorphic modes .",
    "finally , section [ sec : concl ] provides our conclusions and discusses some future work .",
    "starting with  @xcite there has been considerable research into mode checking and inference in traditional logic programming languages",
    ". however , as indicated above , there are two fundamental differences between that work and ours .",
    "first , almost all research assumes that mode analysis is not required to reorder clause bodies .",
    "second , while almost all research has focused on untyped logic programming languages , mode checking of hal relies on predicates and program variables having a single ( parametric polymorphic ) hindley - milner type and the type correctness of the program with respect to this type .",
    "access to type information allows us to handle more complex instantiations than are usually considered in mode analysis and also to handle mode checking of higher - order predicates in a more rigorous fashion : in most previous work higher - order predicates are largely ignored .",
    "another important difference is that we are dealing with constraint logic programming languages in which program variables need to be appropriately initialized before being sent to some constraint solver as part of a constraint .",
    "requiring explicit initialization of solver variables puts additional burden on the programmer and makes it impossible to write multi - moded predicate definitions for which different modes require different variable initialisations .",
    "we have consequently chosen for the hal compiler to _ automatically _ initialize solver variables , i.e.  the compiler generates initialization code whenever necessary . in order to perform",
    "such automatic initialization mode checking in hal must track which program variables are currently uninitialized ( in our terminology are ) .",
    "tracking of uninitialized variables also supports powerful optimizations which can greatly improve performance . for this reason the mercury mode checker also tracks uninitialized variables .",
    "this need to track uninitialized program variables is a significant difference between mode checking in the mercury and hal languages , and most logic programming work on modes .",
    "it is not the same as tracking so - called `` free '' variables in traditional logic programming : first free variables may be aliased to other variables , something that is not possible with uninitialized variables , second , uninitialized variables have to be tracked exactly : the compiler must not fail to initialize a variable , neither should it initialize a variable more than once .",
    "we will now review selected related work in detail .",
    "the original work on mode checking in strongly typed logic languages with reorderable clause bodies is that of  @xcite , which gives an informal presentation of a mode system based on types .",
    "this is perhaps the closest work in spirit since it was the basis of mode checking in mercury .",
    "however , its mode system is much simpler than ours and it does not consider higher - order predicates or the problems of automatic initialization . the remaining work does not consider compile - time reordering .",
    "perhaps the most closely related work in traditional logic programming language analysis is the early work of  @xcite which uses regular trees to define types and instantiations , and uses these trees to perform mode inference .",
    "main differences are that  @xcite does not consider reordering or tracking uninitialized variables . other more technical differences are that , although we use deterministic tree grammars to formalize types , our type analysis  @xcite is based on a hindley - milner approach .",
    "a key difference with this and other work such as that of  @xcite is that we describe instantiations for polymorphic types , including higher - order objects .",
    "also , in  @xcite depth restrictions are imposed to make the generated regular trees finite .",
    "this is not needed in our approach .",
    "finally , they use definite and possible sharing analysis to improve instantiation information .",
    "this is not done yet in hal for complexity reasons ( sharing analysis is quite expensive and thus a danger for practical compilation ) , however a simple sharing and aliasing analysis should indeed prove to be useful .",
    "after the early work of  @xcite , there has been a significant amount of research aimed at improving the precision of the analysis by providing additional information about the structure of the terms .",
    "initially , this was achieved by performing some simple pattern analysis and then providing this information to other analyses ( see for example , @xcite ) .",
    "later , with the gradual success of typed languages , pattern information was substituted by type information with which more accurate results could be obtained , i.e. , type information was annotated with different kinds of information some of which were mode information ( see , for example , @xcite ) .",
    "but most of this work was designed to either provide a general framework for combining type information with other kinds of information , or to infer some particular kind of information ( such as mode information ) from a program without reordering the literals in the body of predicates .",
    "furthermore , they were not interested in tracking uninitialized variables nor keeping enough instantiation information ( i.e.  which particular tree constructors can occur ) for optimizations such as switch detection  @xcite . again ,",
    "further differences arise since we consider higher - order mode inference and polymorphic modes",
    ".    recent work on _ directional types _",
    "( see e.g.  @xcite ) is much more analogous to hal mode checking .",
    "there , they are interested in determining mode - correctness of a program given ( user supplied ) mode descriptions ( called directional types ) .",
    "apart from previously mentioned differences , the framework of  @xcite uses directional types that are much simpler than the instantiations that we deal with here .",
    "interestingly , the work of  @xcite uses directional type correctness to show that a run - time reordering of a well - typed program will not deadlock , somewhat analogous to our compile - time reordering .",
    "type dependency analysis  @xcite is also related to mode checking .",
    "their analysis determines type dependencies from which we can read all the correct modes or directional types of a program .",
    "the framework is however restricted to use types ( and modes ) defined by unary function symbols and an aci operator .",
    "other related work has been on mode checking for concurrent logic programming languages @xcite : there the emphasis has been on detecting communication patterns and possible deadlocks .    the only other logic programming system we are aware of which does significant mode checking is ciao  @xcite .",
    "the ciao logic programming system  @xcite does mode checking using its general assertion checking framework ciaopp based on abstract interpretation  @xcite .",
    "modes are considered as simply one form of assertion , and indeed the notion of what is a mode is completely redefinable .",
    "the default modes are analyzed by the ciaopp preprocessor using a combination of regular type inference and groundness , freeness and sharing analyses .",
    "ciao modes are more akin to directional types , than the strong modes of hal and mercury , and the compiler will check them if possible , and optionally add run - time tests for modes that could not be checked at compile time . as with other earlier work the fundamental differences with the hal mode system are in treatment of uninitialized variables , reordering , higher - order and polymorphic modes .",
    "this section provides an informal view of the role of types , modes , and instantiations in the hal language .",
    "the aim is to provide insight into the more rigorous formalization that will be provided in the following sections .",
    "we do this by explaining the example hal program shown in figure  [ fig : stack ] , which implements a polymorphic stack using lists .",
    "note that hal follows the basic clp syntax , with variables , rules and predicates defined as usual ( see , for example , @xcite for an introduction to clp ) .",
    ": - typedef list(t ) - > ( [ ] ; [ t|list(t ) ] ) .",
    "+   + : - instdef elist - > [ ] .",
    "+ : - instdef list(i ) - > ( [ ] ; [ i|list(i ) ] ) .",
    "+ : - instdef nelist(i ) - > [ i|list(i ) ] .",
    "+   + : - modedef out(i ) - > ( new - > i ) .",
    "+ : - modedef in(i ) - > ( i - > i ) . +   + : - pred push(list(t),t , list(t ) ) .",
    "+ : - mode push(in , in , out(nelist(ground ) ) ) is det .",
    "+ push(s0,e , s1 ) : - s1 = [ e|s0 ] . +   + : - pred pop(list(t),t , list(t ) ) .",
    "+ : - mode pop(in , out , out ) is semidet .",
    "+ : - mode pop(in(nelist(ground)),out , out ) is det .",
    "+ pop(s0,e , s1 ) : - s0 = [ e|s1 ] .",
    "+   + : - pred empty(list(t ) ) .",
    "+ : - mode empty(in ) is semidet .",
    "+ : - mode empty(out(elist ) ) is det .",
    "+ empty(s ) : - s = [ ] .",
    "+      informally , a ground type describes a set of ground terms and is used as a reasonable approximation of the ground values a particular program variable can take .",
    "it is therefore an invariant over the life time of the variable .",
    "types in hal are prescriptive rather than descriptive , they restrict the possible values of a variable . unlike much of the work performed on types for logic programming languages , our types only include the ground ( also called fixed ) values that a variable can take .",
    "later we will describe how instantiations are used to express when a variable takes a value which is not completely fixed .",
    "types are specified using type definition statements . for instance , in the example shown in figure  [ fig : stack ] , the line    : - typedef list(t ) - > ( [ ] ; [ t|list(t ) ] ) .",
    "defines the polymorphic type constructor ` list/1 ` where ` list(t ) ` is the type of lists with elements of parametric type ` t ` .",
    "these lists are made up using the ` [ ] /0 ` and ` ./2 ` ( represented by ` [ \\cdot|\\cdot ] ` ) tree constructors .",
    "hal includes the usual set of built - in basic types : ` float ` ( floating point numbers ) , ` int ` ( integers ) , ` char ` ( characters ) and ` string ` ( strings ) .",
    "like most typed languages , hal provides the means to define type equivalences .",
    "for example , the statement    : - typedef vector = list(int ) .    defines the type ` vector ` to be a list of integers .",
    "equivalence types are simply macros for type expressions , and the compiler replaces equivalence types by their definition ( circular type equivalences are not allowed ) . from now on we assume that equivalence types have been eliminated from the type expressions we consider . this can be achieved straightforwardly by applying substitution .",
    "finally , hal allows a type to be declared as _ hidden _ so that its definition is not visible outside the module in which it is defined .",
    "we note that the treatment of hidden types is almost identical to that of type parameters and so omit them for simplicity .",
    "it is important to note that a program variable s type is used by a compiler to determine the _ representation format _ for that variable , i.e. , the particular way in which program variables are stored during execution . as a result",
    ", two program variables may have different types even though the representation of their values can be identical .",
    "for example , in a language providing both the ascii character set and an extended international character set , variables representing each kind of character would need to have different types since their internal representation is different .      in hal a constraint solver",
    "is defined using a new type .",
    "assume for example , that a programmer wishes to implement a constraint solver over floating point numbers .",
    "from the point of view of the user , the variables will take floating point values and thus one might expect them to have the built - in type ` float ` .",
    "but their internal representation can not be a float as they need to keep track of internal information for the solver . as a result",
    ", the type of the variables can not be the built - in type ` float ` but must be some other type defined by the solver , and whose implementation is hidden from the outside world .",
    "this is were we use abstract types , to hide this view from the outside world .",
    "[ ex : cfloat ] for example a floating point solver type ` cfloat ` might be defined as    : - typedef cfloat - > var(int ) ; val(float ) .    where the integer in the ` var ` tree constructor refers to a column number in a ( global ) simplex tableaux , and the ` val ` constructor is used to represent simple fixed value floating point numbers .",
    "types defined by solvers are called _ solver types _ and variables with a solver type are called _",
    "solver variables_. solvers must also provide an initialization procedure ( ` init/1 ` ) and at least the equality ( ` = /2 ` ) constraint for the type , although many other constraints will be usually provided .",
    "note that solver variables must be initialized before they can be involved in any constraint .",
    "this is required so that the solver can keep track of its variables and initialize the appropriate internal data - structures for them .",
    "the case of herbrand solver types ( i.e. , types for which there is a full unification solver ) is somewhat special .",
    "any user - defined type can be declared to be a herbrand solver type by annotating its type definition with the words `` deriving solver '' .",
    "for example :    : - typedef",
    "hlist(t ) - > ( [ ] ; [ t|hlist(t ) ] ) deriving solver .",
    "defines the ` hlist ` herbrand type .",
    "the compiler will then automatically create an initialization predicate for the type ( which is actually identical for all herbrand types ) and an equality predicate for the type which handles not only simple construction , deconstruction and assignment of non - variable terms ( which is the only equality support provided for non - solver types ) , but full unification . as a result , while variables with non - solver type ` list ` are always required to be bound at run - time to a list of fixed length ( so that the limited support provided by construction , deconstruction and assignment is enough ) , variables with type ` hlist ` may be bound to open ended lists , where the tail of the list is an unbound ( list ) variable .",
    "instantiations define the set of values , within a type , that a program variable may have at a particular program point in the execution , as well as the possibility that the variable ( as yet ) takes no value .",
    "instantiation information is vital to the compiler to determine whether equations on terms are being used to construct terms , deconstruct terms or check the equality of two terms .",
    "furthermore , instantiation information is needed to infer the determinism of predicates ( i.e. , how many answers a predicate has ) and to perform many other low - level optimizations .",
    "although instantiations may seem very similar to types , they should not be confused : a type is invariant over the life of the variable , while instantiations change .",
    "additionally , instantiations reflect the possibility of a variable having no value yet , or being `` constrained '' to some unknown set of values .",
    "hal provides three _ base _ instantiations for a variable : ground , old and new .",
    "a variable is ` ground ` if it is known to have a unique value ; the compiler might not know exactly which value within the type ( it might depend on the particular execution ) , but it knows it is fixed ( for a solver variable this happens whenever the variable can not be constrained further ) .",
    "a variable is ` new ` if it has not been initialized and it has never appeared in a constraint ( thus the name ` new ` ) .",
    "thus , it is known to take no value yet .",
    "as we have indicated , the instantiation ` new ` leads to a crucial difference between mode checking in mercury and hal , and that investigated in most other research into mode checking of logic programs .",
    "mercury and hal demand that at each point in execution the compiler knows whether a variable has a value or not .",
    "this allows many compiler optimizations , and is a key to the difference in execution speed of mercury and hal to most other logic programming systems .",
    "the requirement to always have accurate instantiation information about which variables are ` new ` drives many of the decisions made in the mode checking system .",
    "in particular , it means that a ` new ` variable is not allowed to appear inside a data structure , and can only be given a value by assignment or , if it is a solver variable , after initialization .",
    "finally , the instantiation ` old ` is used to describe a solver variable that has been initialized but for which nothing is known about its possible values .",
    "note that the variable might be unconstrained , it might be ground , or anything in between ( e.g.  be greater than 5 ) ; the compiler simply does not know . in the case in which ` old ` is associated with a non - solver variable , it is deemed to be equivalent to ` ground ` .",
    "note that in mercury , where there are no solver types , each variable always has an instantiation which is either ` new ` or ( a subset of ) ` ground ` .",
    "it is important to note that ` new ` is not analogous to free in the usual logic programming sense .",
    "a free variable in the hal context is an ` old ` variable ( thus , it has been initialized by the appropriate solver ) which has never been bound to a non - variable term .",
    "thus , free variables might have been aliased , while ` new ` variables can not .",
    "this is exploited by the compiler by not giving a run - time representation to new variables . as a consequence",
    ", a ` new ` variable can not occur syntactically more than once . for data structures such as trees or lists of solver variables ,",
    "more complex instantiation states may be used .",
    "these instantiations are specified using instantiation definition statements which look very much like type definitions , the only difference being that the arguments themselves are instantiations rather than types .",
    "for instance , in the example shown in figure  [ fig : stack ] , the lines    : - instdef elist - > [ ] .",
    "+ : - instdef list(i ) - > ( [ ] ; [ i|list(i ) ] ) .",
    "+ : - instdef nelist(i ) - > [ i|list(i ) ] .",
    "define the instantiation constructors ` elist/0 ` , ` list/1 ` and ` nelist/1 ` , which in the example are associated with variables of type ` list/1 ` . in that context ,",
    "the instantiation ` elist ` describes empty lists .",
    "the polymorphic instantiation ` list(i ) ` describes lists with elements of parametric instantiation ` i ` ( note the deliberate reuse of the type name ) .",
    "finally , the instantiation ` nelist(i ) ` describes non - empty lists with elements of parametric instantiation ` i ` .",
    "when associated with a variable , an instantiation requires the variable to be bound to one of the outer - most functors in the right - hand - side of its definition , and the arguments of the functor to satisfy the instantiation of the corresponding arguments in the instantiation definition . in the case of ` elist ` , it would mean the variable is ` ground ` . in the remaining two cases , it would depend on the parametric instantiation ` i ` , but at the very least the variable would be known to be a nil - terminated list , i.e.  its length is fixed .",
    "note that the separation of instantiation information from type information means we can associate the same instantiation for different types .",
    "for example , a program variable with solver type ` hlist(int ) ` and instantiation ` list(ground ) ` indicates that the program variable has a fixed length list as its value . a program variable with non - solver type ` list(int ) ` and instantiation ` list(ground ) ` indicates the same , but since the type is not a solver type , this would always be the case .",
    "the separation of instantiation information from type information also makes the handling of polymorphic application much more straightforward , since we will simply associate a different type with the same instantiation .    as mentioned before , the instantiation ` new ` is not allowed to appear as an argument of any other instantiation . as a result",
    ", a variable can only be inserted in a data structure if it is either ` ground ` or initialized ( and thus must be ` old ` ) .",
    "the main reason for this is the requirement for accurate mode information about ` new ` variables .",
    "it quickly becomes very difficult to _ always _ have correct instantiation information about which variables ( and parts of data structures ) are ` new ` . while sharing and aliasing analyses",
    "might allow us to keep track which variables are ` new ` in more situations , inevitably they lead to situations where we can not determine whether the value of a variable is ` new ` or not , which is not acceptable to the compiler .",
    "we do however plan to use sharing and aliasing analysis to keep track of initialized ( ` old ` ) variables that have yet to be constrained ( analogous to free variables in prolog ) .",
    "a mode is of the form @xmath0 where @xmath1 describes the _ call _ ( or input ) instantiation and @xmath2 describes the _ success _ ( or output ) instantiation .",
    "the _ base _ modes are mappings from one base instantiation to another : we use two letter codes ( ` oo ` , ` no ` , ` og ` , ` gg ` , ` ng ` ) based on the first letter of the instantiation , e.g.  ` ng ` is ` new`@xmath3`ground ` .",
    "the usual modes ` in ` and ` out ` are also provided ( as renamings of ` gg ` and ` ng ` , respectively ) .",
    "modes are specified using mode definition statements .",
    "for instance , in the example shown in figure  [ fig : stack ] , the lines    : - modedef out(i ) - > ( new - > i ) .",
    "+ : - modedef in(i ) - > ( i - > i ) .    are mode definitions , defining macros for modes .",
    "the ` out(i ) ` mode requires a new object on call and returns an object with instantiation ` i ` .",
    "the ` in(i ) ` mode requires instantiation ` i ` on call and has the same instantiation on success .",
    "hal allows the programmer to define mode equivalences and instantiation equivalences . as for type equivalences , from now on we assume that these equivalences have been eliminated from the program . for example    : - modedef in = in(ground ) .",
    "+ : - modedef out = out(ground ) .",
    "define ` in ` as equivalent to ` ground - > ground ` , and ` out ` as ` new - > ground ` .",
    "the equality constraint is a special predicate in hal .",
    "equality will be normalized in hal programs to take one of two forms @xmath4 , and @xmath5 where @xmath6 are variables .",
    "each form of equality supports a number of modes .",
    "the equality @xmath4 can be used in two modes . in the first mode ,",
    "* copy * ( ` : = ` ) , either @xmath7 or @xmath8 must be and the other variable must not be . assuming @xmath7 is new the value of @xmath8 is copied into @xmath7 . in the second mode * unify * ( ` = = ` ) both @xmath7 and @xmath8 must not be new .",
    "this requires a full unification .",
    "the equality @xmath5 can also be used in two modes . in the first mode ,",
    "* construct * ( ` : = ` ) , @xmath9 must be and each of @xmath10 not .",
    "a new @xmath11 structure is built on the heap , and the values of @xmath10 are copied into this structure . in the second mode ,",
    "* deconstruct * ( ` = : ` ) , each of @xmath10 must be and @xmath9 must not be . if @xmath9 is of the form @xmath12 then the value of @xmath13 is copied into @xmath14 , otherwise the deconstruct fails . as we shall see later , mode checking shall extend the use of these modes for other implicit modes .",
    "hal allows the programmer to declare the type and modes of usage of predicates . in our example of figure  [ fig : stack ] , the lines    : - pred pop(list(t),t , list(t ) ) .",
    "+ : - mode pop(in , out , out ) is semidet .",
    "+ : - mode pop(in(nelist(ground)),out , out ) is det .",
    "give such declarations for predicate ` pop/3 ` .",
    "the first line is a polymorphic type declaration ( with parametric type ` t ` ) .",
    "it specifies the types of each of the three arguments of ` pop/3 ` .",
    "the second and third lines are mode declarations specifying the two different modes in which the predicate can be executed . for example , in the first mode the first argument is ` ground ` on call and success , while the second and third arguments are ` new ` on call and ` ground ` on success .",
    "each mode declaration for a predicate defines a _ procedure _ , a different way of executing the predicate .",
    "the role of mode checking is not just to show these modes are correct , but also to reorder conjunctions occurring in the predicate definition in order to create these procedures .",
    "the second and third lines also contain a determinism declaration .",
    "these describe how many answers a predicate may have for a particular mode of usage : ` nondet ` means any number of solutions ; ` multi ` at least one solution ; ` semidet ` at most one solution ; ` det ` exactly one solution ; ` failure ` no solutions ; and ` erroneous ` a run - time error .",
    "thus , in the second line , since ` pop/3 ` for this mode of usage is guaranteed to have at most one solution but might fail ( when the first argument is an empty list ) , the determinism is ` semidet ` . for the second mode ,",
    "the first argument is not only known to be ground but also to be a non - empty list . as a result",
    ", the predicate can be ensured to have exactly one solution and so its determinism is ` det ` .",
    "notice how by providing more complex instantiations we can improve the determinism information of the predicate .",
    "they also lead to more efficient code , since unnecessary checks ( e.g.  that the first argument of ` pop/3 ` is bound to ` ./2 ` ) are eliminated .",
    "currently , hal requires predicate mode declarations for each predicate and checks they are correct .",
    "predicate type declarations , on the other hand , can be omitted and , if so , will be inferred by the compiler  @xcite .",
    "in this section we formalize type and instantiation definitions in terms of ( extended ) regular tree grammars .",
    "then we introduce type - instantiation ( ti- ) grammars which combine type and instantiation information and are the basis for mode checking in hal . throughout the section",
    "we will use ` teletype ` font when referring to ( fixed ) type and instantiation expressions , and font when referring to non - terminals of tree grammars .",
    "we begin by defining basic terminology and hal programs .    a _ signature _",
    "@xmath15 is a set of pairs @xmath16 where @xmath11 is a _ function symbol _ and @xmath17 is the integer _ arity _ of @xmath11 .",
    "a function symbol with 0 arity is called a _",
    "constant_. given a signature @xmath15 the set of all _ trees _ ( the herbrand universe ) , denoted @xmath18 , is defined as the least set satisfying : @xmath19 we assume ( for simplicity ) that @xmath15 contains at least one constant symbol ( i.e.  a symbol with arity 0 ) .",
    "let @xmath20 be a set of symbols called _",
    "variables_. the set of all _ terms _ over @xmath15 and @xmath20 , denoted @xmath21 , is similarly defined as the least set satisfying : @xmath22    a _ substitution _ over signature @xmath15 and variable set @xmath20 is a mapping from variables to terms in @xmath23 , written @xmath24 .",
    "we extend substitutions to map terms in the usual way .",
    "unifier _ for two terms @xmath25 and @xmath26 is a substitution @xmath27 such that @xmath28 and @xmath29 are syntactically identical .",
    "a _ most general unifier _ of two terms @xmath25 and @xmath26 , denoted @xmath30 is a unifier @xmath27 such for every other unifier @xmath31 of @xmath25 and @xmath26 there exists a substitution @xmath32 such that @xmath31 is the composition of @xmath27 with @xmath32 .",
    "note that the only substitutions we shall deal with are over type and instantiation parameters .    as we will be dealing with programs , types and instantiations",
    "there will be a number of signatures of interest .",
    "let @xmath33 be the set of program variable symbols , and @xmath34 be the tree constructors appearing in the program , and @xmath35 be the predicate symbols appearing in the program .",
    "let @xmath36 and @xmath37 be the type variables and type constructors , and similarly let @xmath38 and @xmath39 be the instantiation variables and instantiation constructors .",
    "note that these alphabets may overlap .",
    "an _ atom _ is of the form @xmath40 where @xmath41 and @xmath42 .",
    "literal _ is either an atom , a variable - variable equation @xmath4 where @xmath43 , or a variable - functor equation @xmath5 where @xmath44 and @xmath6 are distinct elements of @xmath33 .",
    "@xmath45 is a literal , a conjunction of goals @xmath46 , a disjunction of goals @xmath47 or an if - then - else @xmath48 ( where @xmath49 are goals ) .",
    "a _ predicate definition _ is of the form @xmath50 where @xmath51 is an atom and @xmath45 is a goal .",
    "note that we are assuming the programs have been normalized , so that each literal has distinct variables as arguments , each equality is either of the form @xmath4 or @xmath52 , where @xmath53 are distinct variables , and multiple bodies for a single predicate have been replaced by one disjunctive body .",
    "a _ predicate type declaration _ is of the form    : - pred @xmath54    where @xmath55 are type expressions .",
    "a _ predicate mode declaration _ is of the form    : - mode @xmath56    where @xmath57 are ground instantiation expressions .",
    "complete predicate definition _ for predicate symbol @xmath42 consists of a predicate definition , a predicate type declaration , and a non - empty set of predicate mode declarations for @xmath58 .",
    "a _ program _ is a collection of complete predicate definitions for distinct predicate symbols .",
    "tree grammars are a well understood formalism ( see , for example , @xcite ) for defining regular tree languages .",
    "we first review the standard definitions for tree grammars since we shall have to extend these in order to handle the complexities of mode checking .    a _ tree grammar _ @xmath59 over signature @xmath15 and _ non - terminal set _",
    "@xmath60 is a finite set of _ production rules _ of the form @xmath61 where @xmath62 and @xmath25 is of the form @xmath63 where @xmath64 and @xmath65 . for each @xmath62 and",
    "@xmath64 we require that there is at most one rule of the form @xmath66 ; hence the grammars are _",
    "deterministic_.    we have chosen to restrict ourselves to deterministic tree grammars : these grammars are expressive enough for hindley - milner types and they give rise to simpler , more efficient algorithms  an important consideration for a compiler designed for large real - world programs .",
    "we assume that from a grammar @xmath59 we can determine its _ root non - terminal _ , denoted @xmath67 . in reality",
    "this is an additional piece of information attached to each grammar .",
    "we shall write grammars so that the root non - terminal appears on the left hand side of the first production rule in @xmath59 .    it will often be useful to extract a sub - grammar @xmath68 from a grammar @xmath59 defining some non - terminal @xmath9 appearing in @xmath59 .",
    "if @xmath9 is a non - terminal occurring in grammar @xmath59 , then @xmath69 is the set of rules in @xmath59 for @xmath9 and all other non - terminals reachable from @xmath9 . or",
    "more precisely , @xmath69 is the smallest set of rules satisfying @xmath70 the root of the grammar @xmath69 is @xmath9 , i.e.  @xmath71 .",
    "[ ex : gs ] consider the signature @xmath72/0 , \\textrm{`}.\\textrm{'}/2 , a/0 , b/0 , c/0 , d/0\\}$ ] and the non - terminal set \\ { , @xmath73 , @xmath74 , @xmath75 , @xmath76 } , then two example regular tree grammars over this signature and non - terminal set are @xmath77 :    & & [ ] + & & [ | ] + & & a + & & b + & & c +    and @xmath78 :    & & [ ] + & & [ | ] + & & [ | ] + & & b + & & c + & & d +    the root non - terminal of @xmath77 is , while the root non - terminal of @xmath78 is . the grammar @xmath79 consists of the last three rules of @xmath77 while the grammar @xmath80 includes all of the rules of @xmath78 but we would write the third rule in the first position , to indicate the root non - terminal was .",
    "a production of form @xmath81 in some grammar @xmath59 can be used to rewrite a term @xmath82 containing an occurrence of @xmath9 to the term @xmath83 where @xmath26 is obtained by replacing the occurrence of @xmath9 in @xmath25 by @xmath84 .",
    "this is called a _ derivation step _ and is denoted by @xmath85 .",
    "we let @xmath86 be the transitive , reflexive closure of @xmath87 .",
    "the _ language generated _ by @xmath59 , denoted by @xmath88\\!]$}}{}$ ] , is the set @xmath89    for example , consider the grammars of example  [ ex : gs ] .",
    "the set @xmath90\\!]$}}$ ] is all lists of @xmath91 s , @xmath92 s and @xmath93 s , while @xmath94\\!]$}}$ ] is all even length lists of @xmath92 s , @xmath93 s and @xmath95 s .    for brevity we shall often write tree grammars in a more compressed form .",
    "we use @xmath96 as shorthand for the set of production rules : @xmath97 , @xmath98 ,  , @xmath99 .",
    "the @xmath100\\!]$}}{}$ ] function induces a pre - order on tree grammars : @xmath101 iff @xmath102\\!]$ } } { } \\subseteq { \\mbox{$[\\![$ } } { } r_2 { \\mbox{$]\\!]$}}{}$ ] .",
    "if we regard grammars with the same language as equivalent , @xmath103 gives rise to a natural partial order over these equivalence classes of tree grammars .",
    "in fact they form a lattice .",
    "however , we shall largely ignore these equivalence classes since all of our operations work on concrete grammars .",
    "we shall also make use of two special grammars .",
    "the first is the _",
    "least tree grammar _ , which we denote by @xmath104 .",
    "we define that @xmath105\\!]$}}= \\emptyset$ ] , and so , as its name suggests we have that @xmath106 for all grammars @xmath59 . during mode checking",
    "the @xmath104 grammar indicates where execution is known to fail .",
    "the second special grammar is the _ error grammar _ , denoted by @xmath107 .",
    "it is used to indicate that a mode error has occurred and we define that @xmath108 for all tree grammars @xmath59 .",
    "we use @xmath109 to denote the meet ( i.e.  greatest lower bound ) operator on grammars , and @xmath110 to denote the join ( i.e.  least upper bound ) operator .",
    "we assume that the non - terminals appearing in the two grammars to be operated on are renamed apart .",
    "we have that @xmath111\\!]$ } } { } = { \\mbox{$[\\![$ } } { } r_1 { \\mbox{$]\\!]$ } } { } \\cap { \\mbox{$[\\![$ } } { } r_2 { \\mbox{$]\\!]$}}{}$ ] . because we restrict ourselves to deterministic tree grammars",
    "the join is inexact : that is to say , @xmath112\\!]$ } } { } \\supseteq { \\mbox{$[\\![$ } } { } r_1 { \\mbox{$]\\!]$ } } { } \\cup { \\mbox{$[\\![$ } } { } r_2 { \\mbox{$]\\!]$}}{}$ ] , and for some @xmath77 and @xmath78 , @xmath112\\!]$ } } { } \\ne { \\mbox{$[\\![$ } } { } r_1 { \\mbox{$]\\!]$ } } { } \\cup { \\mbox{$[\\![$ } } { } r_2 { \\mbox{$]\\!]$}}{}$ ] .",
    "of course , since it is the join , it is as precise as possible : for any grammar @xmath59 such that @xmath88\\!]$ } } { } \\supseteq { \\mbox{$[\\![$ } } { } r_1 { \\mbox{$]\\!]$ } } { } \\cup{\\mbox{$[\\![$ } } { } r_2 { \\mbox{$]\\!]$}}{}$ ] , we have that @xmath88\\!]$ } } { } \\supseteq { \\mbox{$[\\![$ } } { } r_1 \\sqcup r_2 { \\mbox{$]\\!]$}}{}$ ] .",
    "algorithms for determining if @xmath113 , and constructing @xmath114 and @xmath115 are straightforward and omitted .",
    "consider the grammars @xmath77 and @xmath78 of example  [ ex : gs ] .",
    "their meet @xmath114 is :    & & [ ]  ;   [  |   ] + & & b  ;   c + & & [  |   ] +    while their join @xmath115 is :    & & [ ]  ;   [  |   ] + & & a  ;   b  ;   c  ;   d + & & [ ]  ;   [  |   ] +    note that the language generated by the grammar @xmath115 could be represented with fewer rules . in the compiler",
    "there is no effort to build minimal representations of grammars since non - minimal grammars do not seem to occur that often in practice .",
    "types in hal are polymorphic hindley - milner types . _",
    "type expressions _ ( or _ types _ ) are terms in the language @xmath116 where @xmath37 are _ type constructors _ and variables @xmath36 are _ type parameters_. each type constructor @xmath117 must have a definition .",
    "a _ type definition _ for @xmath117 is of the form    : - typedef   @xmath118  - >   @xmath119 .    where @xmath120 are distinct type parameters , @xmath121 are distinct tree constructor / arity pairs , and @xmath122 are type expressions involving at most parameters @xmath120 . the type definition for @xmath16 may optionally have ` deriving solver ` appended",
    "if so then types of the form @xmath123 are _ solver types _ , otherwise they are _ non - solver types_.    clearly , the type definition for @xmath11 can be viewed as simply a set of production rules over signature @xmath34 and non - terminal set @xmath124 .",
    "we can associate with each ( non - parameter ) type expression the production rules that define the topmost symbol of the type .",
    "let @xmath25 be a type expression of the form @xmath123 and let @xmath16 have type definition    : - typedef   @xmath118  - >   @xmath119 .",
    "we define @xmath125 to be the production rules : @xmath126 where @xmath127 . if @xmath128 we define @xmath125 to be the empty set .",
    "we can extend this notation to associate a tree grammar with a type expression .",
    "let @xmath129 be the least set of production rules such that : @xmath130 we assume that @xmath131 . note at this point we make no distinction between solver types and non - solver types ; this will only occur once we consider instantiations .    in order to avoid type expressions that depend on an infinite number of types we restrict the type definitions to be _ regular _",
    "a type @xmath25 is _ regular _ if @xmath129 is finite .",
    "consider for example the non - regular type definition :    : - typedef erk(t ) - > node(erk(list(t ) ) , t ) .    the meaning of the type ` erk(int ) ` depends on the meaning of the type ` erk(list(int ) ) ` , which depends on the meaning of the type ` erk(list(list(int ) ) ) ` , etc . by restricting to regular types",
    "we are guaranteed that each type expression only involves a finite number of types .    a _ ground type expression _",
    "@xmath25 is an element of @xmath132 .",
    "the grammar corresponding to ground type expression @xmath25 defines the meaning of the type expression as a set of trees ( @xmath133\\!]$}}$ ] ) .",
    "note that during run - time every variable ( for each invocation of a predicate ) has a unique ground type in @xmath132 .",
    "given the type definitions :    : - typedef abc - > a ; b ; c. + : - typedef list(t ) - > [ ] ; [ t | list(t ) ] .",
    "then the grammar @xmath77 shown in example  [ ex : gs ] is @xmath134 .",
    "the set @xmath90\\!]$}}$ ] is the set of lists of ` a ` s , ` b ` s and ` c ` s .",
    "the grammar @xmath135 is    & & [ ]  ;   [ | ]    the set @xmath136\\!]$}}= \\ { [ ] \\}$ ] .",
    "note that the grammars corresponding to non - ground type expressions are not very interesting , as illustrated in the above example .",
    "we can think of a non - ground type expression as a mapping from grounding substitutions to ( ground ) types whose meaning is then given by their corresponding grammar .",
    "the built - in types ` float ` , ` int ` , ` char ` and ` string ` are conceptually expressible as ( possibly infinite ) tree grammars . for example , ` int ` can be thought of as having the ( infinite ) definition :    : - typedef int - > 0 ; 1 ; -1 ; 2 ; -2 ; 3 ; ...    though the infinite number of children will render some of the algorithms on tree grammars ineffective this is easily avoided in the compiler by treating the type expressions specially ( we omit details in our algorithms since it is straightforward )",
    ".    note that in hal , type inference and checking is performed using a constraint - based hindley - milner approach on the type expressions  @xcite . in this paper",
    "we assume that type analysis has been performed previously , and there are no type errors .",
    "for the purposes of mode checking the type correctness of a program has four main consequences .",
    "first , each program variable is known to have a unique polymorphic type .",
    "second , all values taken by a variable during the execution are known to be members of this type .",
    "third , calls to a polymorphic predicate are guaranteed to have an equal or more specific type than that of the predicate .",
    "fourth , all type parameters appearing in the type of a variable in the body of a predicate are known to also appear in the type of some variable in the head of the predicate . together , these guarantee that whenever we compare grammars during mode checking , they correspond to exactly the same type .",
    "this is used to substantially simplify the algorithms for mode checking ( see , for example , the re - definition of function @xmath103 in section  [ sec : type - inst ] , and the assumption on the existence of type environment @xmath27 at the beginning of section  [ sec : sched - ho ] ) .",
    "types only express sets of fixed values ( subsets of @xmath137 ) .",
    "however , during execution variables do not always have a fixed value and it is the role of mode checking to track these changes in variable instantiation .",
    "thus , in order to perform mode checking we need to introduce special constants , # ` fresh ` # and # ` var ` # , to represent the two kinds of non - fixed values that a program variable can have during execution .",
    "the # ` fresh ` # constant is used to represent that a program variable takes no value ( i.e. ,  it has not been initialized ) , and corresponds to the ` new ` instantiation .",
    "note that in hal there is no run - time representation for # ` fresh ` # variables . as a result",
    ", the compiler needs to know at all times whether a variable is ` new ` or not .",
    "thus , any tree language including # ` fresh ` # and some other term is not a valid description of the values of a program variable .",
    "the # ` var ` # constant is used to represent a program variable ( or part of a value ) that has been initialized but not further constrained .",
    "it corresponds to a `` free '' variable in the usual logic programming sense .",
    "the # ` var ` # constructor will arise in descriptions of ` old ` instantiations , where we can define values which are not fixed .",
    "of course it will only make sense for variables of solver types to take on this value .",
    "the values that a variable can take are thus represented by trees in @xmath138 .",
    "a type expression by itself represents a set of fixed values .",
    "an instantiation by itself has little meaning , it is just a term in the language of expressions .",
    "its meaning is only defined when it is considered in the context of a type expression .",
    "for instance , the meaning of ` ground ` depends upon the type of the variable it is referring to .    in the following section we define a function @xmath139 which takes a type expression @xmath25 and an instantiation @xmath140 and returns a tree - grammar defining the set of ( possibly non - fixed ) values that a program variable with the given type and instantiation can take . in this section",
    "we define the function @xmath141 which is the function @xmath142 for the particular case in which @xmath140 is a base instantiation . in order to avoid name clashes",
    ", the function creates a unique non - terminal grammar symbol @xmath143 for the type @xmath25 and base instantiation @xmath144 with which it is called and returns this together with the grammar for @xmath25 and @xmath144 .",
    "the symbol @xmath145 represents the root of the tree - grammar which defines the possible values of a variable of type @xmath25 and instantiation @xmath140 .",
    "when a program variable is ` new ` it can only have one possible value , # ` fresh`#. hence the grammar returned by @xmath146 for any type @xmath25 is simply    ti(t , ) & & # ` fresh ` #    in a slight abuse of notation we will use to refer to this grammar .",
    "when a program variable is ` ground ` it can take any fixed value . if the type @xmath25 of the variable is ground , then @xmath147 is identical to the grammar defining its type ( @xmath129 ) .",
    "type parameters complicate this somewhat . since we are going to reason about the values of variables with non - ground types we need a way of representing the possible ground values of a type parameter .",
    "we introduce new constants of the form @xmath148 where @xmath149 to represent these languages .",
    "so for @xmath128 the grammar @xmath150 is defined as    ti(t,`ground ` ) & & $ ` ground`(t)$    for arbitrary types",
    "@xmath25 , @xmath150 is defined as the union of the rules    ti(t,`ground ` ) & & f(ti(t_1,`ground ` ) ,  , ti(t_n,`ground ` ) )    for each @xmath151 occurring in @xmath129 , with    ti(t,`ground ` ) & & $ ` ground`(t)$    for each @xmath152 occurring in @xmath129 .",
    "conceptually , the new constant @xmath148 is a place holder for the grammar @xmath153 obtained if @xmath154 were replaced by the ground type @xmath26 .",
    "when a program variable is ` old ` it can take any initialized value .",
    "this will have a different effect on the parts of the type which are solver types themselves and on those which are not .",
    "non - solver types do not allow the possibility of taking an initialized but unbound value ( represented by the value # ` var ` # ) .",
    "thus , for solver types @xmath25 we shall add a production rule @xmath155 to the usual rules defining the type , while non - solver types remain unchanged . in order to handle type parameters we introduce another set of constants @xmath156 where @xmath149 .",
    "each constant is simply a place holder for @xmath157 obtained if @xmath154 were replaced by the ground type @xmath26 .",
    "thus , @xmath158 for @xmath128 is defined as    ti(,`old ` ) & & $ ` ground`(t)$  ;   $ ` old`(t)$    and otherwise @xmath158 is defined as the rules    ti(t,`old ` ) & & f(ti(t_1,`old ` ) ,  ,",
    "ti(t_n,`old ` ) )    for each rule @xmath151 in @xmath129 , together with    ti(t,`old ` ) & & # ` var ` #    for each solver type @xmath26 occurring in @xmath129 , and    ti(t,`old ` ) & & $ ` ground`(t)$  ;   $ ` old`(t)$    for each type variable @xmath152 occurring in @xmath129 .",
    "the reason we represent an ` old ` variable of type @xmath25 using both the @xmath159 and @xmath160 , is that then a ` ground ` variable of type @xmath25 defines a sublanguage .",
    "this will simplify many algorithms .",
    "[ ex : labcs ] given the type definitions :    : - typedef abc - > a ; b ; c. + : - typedef hlist(t ) - > [ ] ; [ t | hlist(t ) ] deriving solver .",
    "then @xmath161 is the grammar :    ti(,`old ` ) & & [ ]  ;   [ ti(,`old ` )  |   ti(,`old ` ) ]  ;   # ` var ` # + ti(,`old ` ) & & a  ;   b  ;   c    the set @xmath162\\!]$}}{}$ ] includes the values @xmath163 , [ a | \\#\\texttt{var}\\ # ] , [ b ] , [ b , a , c , a | \\#\\texttt{var}\\ # ] $ ] . the symbol # ` var ` # represents an uninstantiated variable , and so the second and fourth values are open - ended lists .    as another example ,",
    "imagine we swap which type is a solver type .",
    "that is , suppose we have definitions    : - typedef habc - > a ; b ; c deriving solver . + : - typedef list(t ) - > [ ] ; [ t | list(t ) ] .",
    "then @xmath164 is the grammar :    ti(,`old ` ) & & [ ]  ;   [ ti(,`old ` )  |   ti(,`old ` ) ] + ti(,`old ` ) & & a  ;   b  ;   c  ;   # ` var ` #    the set @xmath165\\!]$}}{}$ ] includes the values @xmath163 , [ a ] , [ \\#\\texttt{var}\\ # , b , \\#\\texttt{var}\\#]$ ] which are all fixed - length lists whose elements may be variables . note that the two occurrences of the symbol # ` var ` # in the last tree do not necessarily represent the same solver variable .",
    "finally @xmath166 is ( using the first definition )    ti(,`old ` ) & & [ ]  ;   [ ti(t,`old ` )  |   ti(,`old ` ) ]  ;   # ` var ` # + ti(t,`old ` ) & & $ ` ground`(t)$  ;   $ ` old`(t)$    let us now consider instantiations in general , rather than only base instantiations . _ instantiation expressions _ ( or _ instantiations _ ) are terms in the language @xmath167 where @xmath39 are _ instantiation constructors _ and variables @xmath38 are _ instantiation parameters_. each instantiation constructor @xmath168 must have a definition .",
    "often , we will overload functors as both type and instantiation constructors ( so @xmath37 and @xmath39 are not disjoint ) .",
    "the base instantiations ( ` ground ` , ` old ` and ` new ` ) are simply special 0-ary elements of @xmath39 .",
    "an _ instantiation definition _ for @xmath169 is of the form :    : - instdef   @xmath170  - >   @xmath171    where @xmath172 are distinct instantiation parameters , @xmath173 are distinct tree constructors , and @xmath174 are instantiation expressions other than ` new ` involving at most the parameters @xmath172 . just as for type definitions , we demand that instantiation definitions are _ regular_.    we can associate a set of production rules @xmath175 with an instantiation expression @xmath140 just as we do for type expressions . for the base instantiations we define @xmath176 .",
    "a _ ground instantiation _ is an element of @xmath177 .",
    "the existence of instantiation parameters during mode analysis would significantly complicate the task of the analyzer .",
    "this is mainly because functions to compare type - instantiations or to compute their join and meet would need to return a set of constraints involving instantiation parameters .",
    "furthermore , predicate mode declarations containing instantiation parameters might need to express some constraints involving those instantiations .",
    "therefore , for simplicity , hal ( like mercury ) requires instantiations appearing in a predicate mode declaration to be ground . as a result , mode checking only deals with ground instantiations and , from now on , we will assume all instantiations are ground .",
    "the reason this problem does not arise with type parameters is that , as mentioned before , type correctness guarantees that whenever we compare type - instantiations , the two types being compared are syntactically identical .",
    "thus , if two type parameters are being compared , they are guaranteed to be the same type parameter .      in this section",
    "we define the function @xmath142 which takes a type expression @xmath25 and a ground instantiation expression @xmath140 and returns a _ type - instantiation tree grammar _ ( or _ ti - grammar _ ) .",
    "mode checking will manipulate _ _ ti - grammar__s , built from the types and instantiations occurring in the program .",
    "the function rt defines the meaning of combining a type with an instantiation by extending base to non - base instantiations .",
    "a non - base instantiation combines with a type in a manner analogous to the @xmath109 operation over the rules defining each other .",
    "intuitively the function rt intersects the grammars of @xmath25 and @xmath140 .",
    "this is not really the case because of special treatment of type parameters and base instantiations .",
    "figure  [ fig : rt ] gives the algorithm for computing @xmath142 .",
    "the function @xmath178 does all of the work .",
    "it creates a unique grammar symbol @xmath145 for the type @xmath25 and instantiation @xmath140 with which it is called and returns this with the type instantiation grammar for @xmath25 and @xmath140 .",
    "its last argument @xmath179 is the set of grammar symbols constructed in the parent calls : this is used to check that the symbol @xmath145 has not already been encountered and so avoids infinite recursion .",
    "the root of the grammar @xmath59 returned is the symbol @xmath145 .",
    "note that it is a mode error to associate a non - base instantiation with a parameter type @xmath180 , since we can not know what function symbols make up the type @xmath25 . in this case",
    "the algorithm returns the special @xmath107 grammar indicating a mode error .",
    "xx = xx = xx = xx = xx = xx = xx = xx = rt(@xmath25,@xmath140 ) + @xmath181 : = rt(@xmath25,@xmath140,@xmath182 ) + * return * @xmath59 +   + rt(@xmath25,@xmath140,@xmath179 ) + * if * ( @xmath183 ) * return * @xmath184 + * if * ( @xmath140 is a base instantiation ) * return * ( base(@xmath25,@xmath140 ) , @xmath145 ) + * if * ( @xmath128 ) * return * @xmath185 + @xmath59 : = @xmath182 + * foreach * rule @xmath186 in @xmath175 + * if * exists rule @xmath187 in @xmath125 + * for * @xmath188 = @xmath189 + @xmath190 : = rt(@xmath191,@xmath192 , @xmath193 ) + * if * ( @xmath194 ) * return * @xmath185 + * endfor * + @xmath59 : = @xmath195 + * endif * + * endfor * + * return * @xmath196    [ ex : rts ] consider the types ` list/1 ` and ` habc ` of example  [ ex : labcs ] and instantiation ` nelist/1 ` from the program in figure  [ fig : stack ] .",
    "then ti - grammar @xmath197 is    ti ( , ) & & [ ti ( , )  |   ti ( , ) ] + ti ( , ) & & [ ]  ;   [ ti ( , )  |   ti ( , ) ] + ti ( , ) & & a  ;   b  ;   c  ;   # ` var ` #    while @xmath198 is    ti ( , ) & & [ ti(t , ) | ti ( , ) ] + ti ( , ) & & [ ]  ;   [ ti(t , )  |   ti ( , ) ] + ti(t , ) & & $ ` ground`(t)$    a ti - grammar is thus a regular tree grammar defined over the signature @xmath199 and non - terminal set @xmath200    note that by construction the partial ordering and meet and join on tree grammars extend to ti - grammars including type parameters . as mentioned before , type correctness guarantees that during mode checking we will only compare ti - grammars for the same type parameter @xmath149 . for this reason ,",
    "we only need note that @xmath201 for a parameter @xmath149 , which follows from the construction since @xmath202\\!]$}}= \\ { \\$\\texttt{ground}(v)\\$ \\}$ ] and @xmath203\\!]$}}= \\ { \\$\\texttt{ground}(v)\\$ ,   \\$\\texttt{old}(v)\\$ \\}$ ] and the meet and join operations follow in the natural way .",
    "the operations that we perform on ti - grammars during mode checking will be @xmath103 , abstract conjunction and abstract disjunction .",
    "abstract conjunction differs slightly from @xmath109 since we will be changing variables with a ti - grammar to ti - grammars for bound values ( whenever the variable becomes instantiated ) .",
    "the abstract conjunction operation @xmath204 is defined as : @xmath205    abstract disjunction is again slightly different from the @xmath110 operation . since the compiler needs to know whether the value of a variable is ` new ` or not , we need to ensure the abstract disjunction operation does not create ti - grammars ( other than @xmath107 ) in which this information is lost , i.e. , grammars that include # ` fresh ` # as well as other terms . the abstract disjunction operation @xmath206 is defined as : @xmath207    finally , we introduce the concept of a _ type - instantiation state _ ( or _ ti - state _ ) @xmath208 , which maps program variables to ti - grammars .",
    "ti - grammars are used during mode checking to store the possible values of the program variables at each program point .",
    "we can extend operations on ti - grammars to ti - states over the same set of variables in the obvious pointwise manner .",
    "given ti - states @xmath209 and @xmath210 then :    * @xmath211 iff @xmath212 for all @xmath213 , * @xmath214 and * @xmath215 .",
    "mode checking is a complex process which aims to reorder body literals to satisfy the mode constraints provided by each mode declaration .",
    "the aim of this is to be able to generate specialized code for each mode declaration .",
    "the code corresponding to each mode declaration is referred to as a _ procedure _ , and calls to the original predicate are replaced by calls to the appropriate procedure .",
    "recall that before mode checking is applied the hal compiler performs type checking ( and inference ) so that each program variable has a type , and the program is guaranteed to be type correct .",
    "we now define what it means for a hal program to be well - moded .",
    "the execution of a hal program is performed on _ procedures _ which are predicates re - ordered for a particular mode . at run - time",
    "each type parameter has an associated ground type . for our purposes",
    "we assume a given _ type environment _ @xmath27 ( a ground type substitution ) describes the run - time types associated with each type parameter .",
    "a _ call _ to a procedure @xmath58 in mode @xmath56 is a type environment @xmath27 and a _ value _",
    "@xmath216 for each argument @xmath217 .",
    "it follows from type correctness of the program that @xmath218\\!]$}}\\cup   \\{\\#\\texttt{fresh}\\#\\}$ ] for each argument @xmath217 .",
    "a program is _ input - output mode - correct _ if any call to a predicate which is correct with respect to the input instantiation for some mode declared for that predicate will only have answers that are correct with respect to the output instantiation of that mode .",
    "more formally , a program is _ input - output mode - correct _ if for each procedure @xmath58 with declared type @xmath54 in mode @xmath56 , and for any call of the form @xmath219 with type environment @xmath27 such that @xmath220\\!]$ } } , 1 \\leq i \\leq n$ ] , it is the case that the resulting values @xmath221 on success of the procedure are such that @xmath222\\!]$ } } , 1 \\leq i \\leq n$ ] .",
    "in other words , the declared mode is satisfied by the code generated for the procedure .",
    "for example the first mode for predicate ` pop/3 ` , defined in example  [ fig : stack ] ,    : - mode pop(in , out , out ) is semidet .",
    "will be shown to be input - output mode - correct by showing that if the first argument to ` pop/3 ` is ground at call time , and the last two arguments ` new ` , then all three arguments will be ground on success of the predicate .",
    "a program is _ call mode - correct _ if any call to a predicate which is correct with respect to the input instantiation for some mode declared for that predicate will only lead to calls to literals within the definition of the predicate which are mode - correct .",
    "more formally , a program is _ call mode - correct _ if for each procedure @xmath58 with declared type @xmath54 in mode @xmath56 , and for any call of the form @xmath219 with type environment @xmath27 such that @xmath220\\!]$ } } , 1 \\leq i \\leq n$ ] , it is the case that each call to a procedure @xmath223 with type ( given by the occurrence in the definition of @xmath58 ) @xmath224 in mode @xmath225 of the form @xmath226 is such that @xmath227\\!]$ } } , 1 \\leq i \\leq n'$ ] , and any call to an equality of the form @xmath4 is either a copy or unify , and any call to an equality of the form @xmath5 is either a construct or deconstruct . in other words",
    "each mode - correct call leads to only mode - correct calls .",
    "[ ex : dup ] consider the following code which duplicates the top element of the stack :    : - pred dupl(list(t ) , list(t ) ) .",
    "% duplicate top of stack + : - mode dupl(in(nelist(ground ) ) , out(nelist(ground ) ) ) is det .",
    "+ dupl(s0 , s ) : - s0 = [ ] , s = [ ] .",
    "+ dupl(s0 , s ) : - push(s0 , a , s ) , pop(s0 , a , s1 ) .",
    "showing call mode - correctness for the procedure for ` dupl/2 ` involves showing that any correct call to ` dupl/2 ` ( that is with the first argument a non - empty ground list , and its second argument ` new ` ) will call ` push/3 ` and ` pop/3 ` with correct input instantiations for one of their given modes , and each equation must be either a construct or deconstruct .",
    "a program is _ well - moded _ if it is input - output mode - correct and call mode - correct .",
    "we shall now explain mode checking by showing how to check whether each program construct is schedulable for a given ti - state @xmath228 and , if so , what the resulting ti - state @xmath229 is .",
    "the scheduling also returns a goal illustrating the order of execution of conjunctions , and the mode for each equation or predicate call .",
    "if the program construct is not schedulable for the given ti - state it may be reconsidered after other constructs have been scheduled .",
    "we assume that before checking each construct for an initial ti - state @xmath228 , we extend @xmath228 so that any variable of type @xmath25 local to the construct is assigned the ti - grammar .",
    "consider the equality @xmath4 where @xmath7 and @xmath8 are variables of type @xmath25 and the current ti - state is @xmath230 ( where @xmath231 is the ti - state for the remaining variables ) .",
    "the two standard modes of usage for such an equality are * copy * ( ` : = ` ) and * unify * ( ` = = ` ) . if exactly one of @xmath77 and @xmath78 is ( say @xmath77 ) ,",
    "the * copy * @xmath232 can be performed and the resulting ti - state is @xmath233 .",
    "if both are not then * unify * @xmath234 is performed and the resulting instantiation is @xmath235 . if neither of the two modes of usage apply ( i.e.   both variables are new ) , the literal is not schedulable ( although it might become schedulable after automatic initialization , see section [ sec : init ] ) .",
    "consider the equality @xmath5 where @xmath236 are variables with types @xmath237 and current ti - state @xmath238 .",
    "the two standard modes of usage of such an equality are * construct * ( ` : = ` ) and * deconstruct * ( ` = : ` ) .",
    "the * construct * mode applies if @xmath59 is and none of the @xmath239 are .",
    "the resulting ti - state is @xmath240 where @xmath68 is the ti - grammar defined by @xmath241 , where @xmath91 is a new non - terminal , ( i.e.  the grammar defining the terms constructible from an @xmath11 with arguments from @xmath242 respectively ) .",
    "the * deconstruct * mode applies if each @xmath239 is and @xmath59 is not and has no production rule @xmath243 ( which means it is definitely bound to some functor ) .",
    "the resulting ti - state is @xmath244 where @xmath245 are defined below . if @xmath59 has a production rule of the form @xmath246 , then the @xmath247 .",
    "if @xmath59 has no rule of this form , then the resulting ti - state is the same but with @xmath248 , indicating that the * deconstruct * must fail . if some of the variables @xmath249 are and some are not ( say @xmath250 ) the mode checking process decomposes the equality constraint into a * deconstruct * followed by new equalities by introducing fresh variables , e.g.  @xmath251 .",
    "these new equalities are handled as above .",
    "note that if @xmath252 and some @xmath253 then the literal is not schedulable ( although it might become schedulable after automatic initialization , again see section [ sec : init ] ) .",
    "assume ` x ` and `",
    "y ` are ground lists , while ` a ` is .",
    "scheduling the goal ` y = [ a|x ] ` results in the code ` y = :  [ a|f ] , x = = f ` .",
    "the above uses of deconstruct are guaranteed to be safe at run - time and correspond to the modes of usage allowed by mercury .",
    "hal , in addition to the above , allows the use of the * deconstruct * mode when @xmath9 is ` old ` ( i.e.  @xmath59 contains a production rule @xmath254 ) . in this case",
    "we check whether @xmath59 has a production rule of the form @xmath246 and we proceed as in the previous paragraph . note that this is ( the only place ) where the hal mode system is not completely strong ( i.e.  run - time mode errors can occur ) .",
    "the following example illustrates the need for this behavior .",
    "[ ex : runtimeerror ] consider the types ` abc/0 ` and ` hlist/1 ` from example  [ ex : labcs ] , the following use of ` append/3 ` may not detect a mode error until run - time :    : - pred append(hlist(abc ) , hlist(abc ) , hlist(abc ) ) .",
    "+ : - mode append(oo , oo , no ) is nondet .",
    "+ append(x , y , z ) : - x = [ ] , y = z. + append(x , y , z ) : - x = [ a|x1 ] , append(x1 , y , z1 ) , z = [ a|z1 ] .",
    "the equation ` x = [ a|x1 ] ` is schedulable as a deconstruct since ` x ` is ` old ` .",
    "however , if at run - time ` x ` is not bound when ` append/3 ` is called , the deconstruct will generate a run - time error since ` a ` is not a solver variable and , thus , it can not be initialized .",
    "note that if we did not allow deconstruction on ` old ` variables then the above predicate would not pass mode checking thus preventing mode - correct goals like    ? - x = [ a , b , c ] , init(y ) , append(x , y , z ) .    from being compiled .",
    "if we never allow herbrand solver types to contain non - solver types ( as in the example above ) , the problem can not occur .",
    "this gap in mode checking seems unavoidable if we are to allow herbrand solver types to contain non - solver types .",
    "however , it seems that in practice this gap is not problematic : in most programs , the possibility of a run - time mode error does not exist . whenever it does , the compiler emits a warning message .",
    "in fact , we have never detected a run - time mode error .      in this subsection",
    "we describe the scheduling of predicate calls so that the resulting program after scheduling is call mode - correct .",
    "consider the predicate call @xmath255 where each @xmath14 is a variable with type @xmath256 .",
    "assume @xmath257 has the mode declaration @xmath56 where @xmath258 are the call and success instantiations , respectively , for argument @xmath188 , and the current ti - state is @xmath259 .",
    "note that the handling of polymorphic application is hidden here , since the type @xmath256 of the variable @xmath14 is type in the calling literal @xmath255 , which may be more specific than the declared / inferred type of argument @xmath140 of @xmath257 . because instantiations are separate from types this is straightforwardly expressed by constructing the ti - grammar for the mode specific calling type @xmath256 and the appropriate instantiations .",
    "the predicate call can be scheduled if for each @xmath260 the current ti - state restricts the @xmath188-th argument more than ( defines a subset of ) the calling ti - state required for @xmath257 , i.e.  @xmath261 .",
    "if the predicate call is schedulable for this mode the new ti - state is @xmath262 .",
    "the predicate call can also be scheduled if for each @xmath188 such that @xmath263 then @xmath264 . for each such @xmath188 , the argument @xmath249 in predicate call @xmath265",
    "is replaced by @xmath266 , where @xmath266 is a fresh new program variable , and the equation @xmath267 is added after the predicate call .",
    "such `` extra '' modes are usually referred to as _ implied modes_.    consider the goal empty(s0 ) for the program of figure  [ fig : stack ] where the type of ` s0 ` is given by @xmath268 ( which is more specific than the declared type ` list(t ) ` ) and the current ti - state is @xmath269 .",
    "the two modes for ` empty ` ( in expanded form ) are    : - mode empty(ground - > ground ) is semidet .",
    "+ : - mode empty(new - > ground ) is det .",
    "the first mode of ` empty ` can not be scheduled since @xmath270 , but the second mode can be scheduled , since @xmath271 .",
    "if more than one mode of the same predicate is schedulable , in theory the compiler should try each possibility .",
    "unfortunately , this search may be too expensive .",
    "for this reason , hal ( like mercury ) chooses one schedulable mode and commits to it .",
    "this behavior might lead to the compiler failing to check a mode - correct procedure ( see example  [ non - check ] ) . in order to minimize this risk ,",
    "we choose a schedulable mode whose success ti - state @xmath228 defined as @xmath272 is minimal ; that is , for each other schedulable mode with success ti - state @xmath229 it is the case that @xmath273 .",
    "note that there may be more than one mode with a minimal success ti - state . in the case that we have more than one mode with the same minimal success state",
    "then we use a mode with a minimal call ti - state .    consider the scheduling of the goal ` pop(a , b , c ) ` where current ti - state is @xmath274 where @xmath77 and @xmath275 are defined by the grammars    r_1 & & [ r_2  |   r_3 ] + r_2 & & b + r_3 & & [ ]    that is @xmath276 $ ] and @xmath277 $ ] .",
    "neither of the declared modes for ` pop ` , shown below , are immediately applicable .",
    ": - mode pop(in , out , out ) is semidet .",
    "+ : - mode pop(in(nelist(ground)),out , out ) is det .",
    "but both modes fit the conditions for an implied mode . since the second mode has a more specific success ti - state ( the first argument is known to be non - empty ) it is chosen . the resulting code is ` pop_mode2(a , b , fresh ) , fresh = c ` , where mode checking will then schedule the new equation appropriately .",
    "the idea is to maintain as much instantiation information as possible , thus restricting as little as possible the number of schedulable modes for the remaining literals . in our experience with compiling real programs",
    "this policy seems adequate to avoid any problems .",
    "it is straightforward , but in practice too expensive , to implement a complete search for all possible schedules .      to determine if a conjunction @xmath46 is schedulable for initial ti - state @xmath228 we choose the left - most goal @xmath278 which is schedulable for @xmath228 and compute the new ti - state @xmath279",
    "this default behavior schedules goals as close to the programmer given left - to - right order as possible .",
    "if the state @xmath279 assigns @xmath104 to any variable , then the subgoal @xmath278 must fail and hence the whole conjunction is schedulable .",
    "the resulting ti - state @xmath229 maps all variables to @xmath104 , and the final conjunction contains all previously scheduled goals followed by ` fail ` . if @xmath279 does not assign @xmath104 to any variable we continue by scheduling the remaining conjunction @xmath280 with initial ti - state @xmath279 .",
    "if all subgoals are eventually schedulable we have determined both an order of evaluation for the conjunction and a final ti - state .",
    "consider scheduling the goal    y = [ u1|u2 ] , u2 = [ ] , x = [ u1|u3 ] .",
    "where ` x ` is initially @xmath281 , and the remaining variables are .",
    "the first literal is not schedulable and will remain so until both ` u1 ` and ` u2 ` are no longer new .",
    "we consider then the second literal , which is schedulable as a construct , thus changing the type - instantiation of ` u2 ` to @xmath282 .",
    "since the first literal remains unschedulable , we consider the third literal which is schedulable as a deconstruct , thus changing the type - instantiation of ` x ` , ` u1 ` and ` u3 ` to @xmath198 , @xmath283 and @xmath281 , respectively . since both ` u1 ` and ` u2 ` are no longer new , the first literal is now schedulable as a construct .",
    "the resulting code is    u2 : = [ ] , x = :  [ u1|u3 ] , y : = [ u1|u2 ] .    in the final ti - state",
    "the instantiation of @xmath284 is given by the tree - grammar    ` y ` & & [ ti(t , ) | ti((t ) , ) ] + ti((t ) , ) & & [ ] + ti(t , ) & & $ ` ground`(t)$    in other words it is a list of length exactly one .    to determine",
    "if a disjunction @xmath47 is schedulable for initial ti - state @xmath228 we check whether each subgoal @xmath278 is schedulable for @xmath228 and , if so , compute each resulting ti - state @xmath279 , obtaining the final ti - state @xmath285 .",
    "if this ti - state assigns @xmath107 to any variable or one of the disjuncts @xmath278 is not schedulable then the whole disjunction is not schedulable .    to determine whether an if - then - else @xmath286 is schedulable for initial ti - state @xmath228 , we determine first whether @xmath287 is schedulable for @xmath228 with resulting ti - state @xmath288 .",
    "if not , the whole if - then - else is not schedulable . otherwise , we try to schedule @xmath289 in state @xmath288 ( resulting in state @xmath290 say ) and @xmath291 in state @xmath228 ( resulting in state @xmath292 say )",
    ". the resulting ti - state is @xmath293",
    ". if one of @xmath289 or @xmath291 is not schedulable or @xmath229 includes @xmath107 the whole if - then - else is not schedulable .",
    "note that the analysis of @xmath286 is identical to that of @xmath294 except that all goals of @xmath287 must be scheduled before those of @xmath289 .      in this subsection",
    "we discuss how mode - correctness is checked for each mode declaration .",
    "to check that a predicate with head @xmath255 and declared ( or inferred ) type @xmath295 satisfies the mode declaration @xmath296 , we build the initial ti - state @xmath297 .",
    "the body of the predicate is then analyzed starting from the state @xmath228 . the mode declaration is correct if ( a ) everything is schedulable and ( b ) if the final ti - state is @xmath298 , then for each argument variable @xmath217 , @xmath299 .",
    "if the body is not schedulable or the resulting instantiations are not strong enough , a mode error results .",
    "note that ( a ) ensures that the predicate is call mode - correct for that mode while ( b ) ensures that it is input - output mode - correct .",
    "consider mode checking of the following code from example  [ ex : dup ] which makes use of the code in figure  [ fig : stack ] :    : - pred dupl(list(t ) , list(t ) ) .",
    "% duplicate top of stack + : - mode dupl(in(nelist(ground ) ) , out(nelist(ground ) ) ) is det .",
    "+ dupl(s0 , s ) : - s0 = [ ] , s = [ ] .",
    "+ dupl(s0 , s ) : - push(s0 , a , s ) , pop(s0 , a , s1 ) .",
    "we start by constructing the initial ti - state @xmath300 where @xmath301 is the ti - grammar shown in example  [ ex : rts ] .",
    "checking the first disjunct ( rule ) we have ` s0 = [ ] ` schedulable as a deconstruct .",
    "the resulting ti - state assigns @xmath104 to ` s0 ` , and thus the whole conjunction is schedulable with @xmath302 . checking the second disjunct ,",
    "we first extend @xmath228 to map ` a ` and ` s1 ` to . examining the first literal ` push(s0 , a , s ) ` we find that it is not schedulable since ` a ` has instantiation and is required to be . examining the second literal ` pop(s0 , a , s1 ) ` we find that both modes declared for ` pop/3 ` are schedulable .",
    "since the second mode has more specific success instantiations , it is chosen and the ti - grammars for ` a ` and ` s1 ` become @xmath283 and @xmath303 , respectively . now",
    "the first literal is schedulable obtaining for ` s ` the ti - grammar @xmath304 .",
    "restricting to the original variables the final ti - state is @xmath305 . taking the join @xmath306 . checking this against the declared success instantiations we find the declared mode is correct .",
    "the code generated for the procedure is :    dupl_mode1(s0 , s ) : - fail .",
    "+ dupl_mode1(s0 , s ) : - pop_mode2(s0 , a , s1 ) , push_mode1(s0 , a , s ) .",
    "where ` pop_mode2/3 ` and ` push_mode1/3 ` are the procedures associated with the second and first modes of the predicates , respectively .    note that the hal compiler s current mode analysis does not track variable dependencies and thus it may obtain a final type - instantiation state weaker than expected .",
    "[ ex : lcint ] consider the solver type ` habc/0 ` of example  [ ex : labcs ] .",
    "the following program does not pass mode checking :    : - pred p(list(habc ) , habc ) .",
    "+ : - mode p(list(old ) - > ground , in ) is semidet .",
    "+ p(l , e ) : - l = [ ] .",
    "+ p(l , e ) : - l = [ e1|l1 ] , e = e1 , p(l1 , e ) .",
    "the first literal of the second rule is a deconstruct .",
    "after that deconstruct variable `",
    "l ` is never touched and hence its instantiation is never updated ; in particular it is not updated when the instantiation of ` e1 ` and ` l1 ` change .",
    "the inferred type - instantiation for ` l ` at the end of the second rule is thus @xmath197 rather than @xmath307 .",
    "hence , mode checking fails .",
    "this could be overcome by adding a definite sharing analysis and/or a dependency based groundness analysis to the mode checking phase .",
    "whenever a variable which definitely shares with another ( through an equation @xmath308 ) is touched , we modify the resulting ti - state as if the equation @xmath308 has been rescheduled to update sharing variables .",
    "this is ( partially ) implemented , for example , in the alias branch of the mercury compiler .",
    "as mentioned before , constraint solvers must provide an initialization procedure ( ` init/1 ` ) for their solver type .",
    "this procedure takes a solver variable with instantiation ` new ` and returns it with instantiation ` old ` , after initializing whatever data - structures ( if any ) the solver needs .",
    "many of the predicates exported by constraint solvers ( including most constraints ) require the solver variables appearing as arguments to be already initialized .",
    "thus , explicit initializations for local variables may need to be introduced .",
    "not only is this a tedious exercise for the programmer , it may even be impossible for multi - moded predicate definitions since each mode may require different initialization instructions .",
    "therefore , the hal mode checker automatically inserts variable initializations .",
    "in particular , whenever a literal can not be scheduled because there is a requirement for an argument of type @xmath25 to be @xmath309 when it is and @xmath25 is a solver type , then the ` init/1 ` predicate for type @xmath25 can be inserted to make the literal schedulable .",
    "assume we have an integer solver with solver type ` cint/0 ` .",
    ": - pred length(list(cint ) , int ) .",
    "+ : - mode length(out(list(old ) ) , in ) is nondet .",
    "+ : - mode length(in(list(old ) ) , out ) is det .",
    "+ length(l , n ) : - l = [ ] , n = 0 .",
    "+ length(l , n ) : - l = [ x|l1 ] , + ( n1,1,n ) , n > 0 , length(l1 , n1 ) .    where the predicate ` + ( x , y , z ) ` models @xmath310 and requires at least two arguments to be ground on call and all arguments are ground on return .    for the first mode ` l = [ x|l1 ] ` can not be scheduled as a construct until ` x ` has a ti - grammar different from . hence , ` x ` needs to be initialized . in the second mode ` l = [ x|l1 ] ` can be scheduled as a deconstruct and thus no initialization is needed .",
    "the two resulting procedures are :    length_mode1(l , n ) : - ( l : = [ ] , n = = 0 + ; + @xmath311(n1 , 1 , n ) , n",
    "> 0 , length_mode1(l1 , n1 ) , init(x ) , l : = [ x|l1 ] ) .",
    "+ length_mode2(l , n ) : - ( l = = [ ] , n : = 0 + ; l = :  [ x|l1 ] , length_mode2(l1 , n1 ) , + @xmath312(n1 , 1 , n ) , n > 0 )",
    ".    where we have rewritten the call to ` + /3 ` to show the mode more clearly ( ` + _ { outinin } ` indicates that the first argument is ` out ` and the rest are ` in ` , ` + _ { ininout } ` indicates that the third argument is ` out ` and the other arguments are ` in ` ) .",
    "unfortunately , unnecessary initialization may slow down execution and introduce unnecessary variables ( when it interacts with implied modes ) .",
    "hence , we would like to only add those initializations required so that mode checking will succeed .",
    "the hal mode checker implements this by first trying to mode the procedure without allowing initialization .",
    "if this fails it will start from the previous partial schedule looking for the leftmost unscheduled literal @xmath313 which can be scheduled by initializing variables which ( a ) have either a solver type or a parameter type ( e.g.  @xmath149 ) and ( b ) do not appear in an unscheduled literal to the left which equates them to a term ( if so , chances are the equation will become a construct and no initialization is needed ) . if such an @xmath313 is found the appropriate initialization calls are inserted before @xmath313 , and then scheduling continues once more trying to schedule without initialization . if no @xmath313 is found the whole conjunct is not schedulable .",
    "this two phase approach is applied at each conjunct level individually .",
    "consider the following program where ` cint/0 ` is a solver type :    : - instdef evenlist(t ) - > ( [ ] ; [ t|oddlist(t ) ] ) .",
    "+ : - instdef oddlist(t ) - > [ t|evenlist(t ) ] . +   + : - pred pairlist(list(cint),int ) .",
    "+ : - mode pairlist(out(evenlist(old)),in ) is nondet .",
    "+ pairlist(l , n ) : - n = 0 , l = [ ] .",
    "+ pairlist(l , n ) : - n > 0 , + ( n1,1,n ) , l = [ v|l1 ] , l1 = [ v|l2 ] , pairlist(l2,n1 ) .",
    "in the first phase all literals in the second rule are schedulable except ` l = [ v|l1 ] ` and ` l1 = [ v|l2 ] ` which can be neither a construct ( ` v ` , ` l1 ` and ` l2 ` are new ) nor a deconstruct ( both ` l ` and ` l1 ` are new ) . in the second phase",
    "we examine the two remaining unscheduled literals : the second literal can be scheduled by initializing ` v ` .",
    "once this is done the first literal can be scheduled obtaining :    pairlist(l , n ) : - n = = 0 , l : = [ ] .",
    "+ pairlist(l , n ) : - = n > 0 , + @xmath311(n1,1,n ) , pairlist(l2,n1 ) , + init(v ) , l1 : = [ v|l2 ] , l : = [ v|l1 ] .",
    "many other different initialization heuristics could be applied .",
    "we are currently investigating more informed policies which give the right tradeoff between adding constraints as early as possible , and delaying constraints until they can become tests or assignments .",
    "higher - order programming is particularly important in hal because it is the mechanism used to implement dynamic scheduling , which is vital in clp languages for extending and combining constraint solvers .",
    "higher - order programming introduces two new kinds of literals : construction of higher - order objects and higher - order calls .    a _ higher - order object _",
    "is constructed using an equation of the form @xmath314 where @xmath315 are variables and @xmath257 is an @xmath316-ary predicate with @xmath317 .",
    "the variable @xmath318 is referred to as a _ higher - order object_. _ higher - order calls _ are literals of the form ` call`@xmath319 where @xmath320 are variables . essentially , the `",
    "call ` literal supplies the @xmath321 arguments missing from the higher - order object @xmath318 .    in order to represent types and instantiations for higher - order objects we need to extend the languages of type and instantiation expressions .",
    "the _ higher - order type _ of a higher - order object @xmath318 constructed in the previous paragraph is of the form @xmath322 where @xmath323 is a new special type constructor and @xmath324 are types .",
    "it provides the types of the @xmath321 arguments missing from @xmath318 .",
    "the _ higher - order instantiation _ of @xmath318 is of the form @xmath325 where @xmath323 is a new special instantiation construct and @xmath326 give the call and success instantiations of argument @xmath188 respectively .",
    "it provides the modes of the @xmath321 arguments missing from @xmath318 .",
    "note that for the first time we allow ` new ` instantiations appearing inside instantiation expressions ( since they will often be call instantiations ) .",
    "but their appearance is restricted to the outermost arguments of higher - order instantiations .",
    "now we must extend the @xmath142 operation to handle higher - order types and instantiations .",
    "let us first consider the case in which @xmath140 is the higher - order instantiation @xmath327 .",
    "if @xmath25 is the higher - order type @xmath328 then @xmath142 returns the grammar    ti(t , i ) & & $ ` ipred`$(root(tc_k+1 ) , root(ts_k+1 ) ,  , root(tc_n ) , root(ts_n ) )    together with the grammars @xmath329 where @xmath330 and @xmath331 .",
    "if @xmath25 is not a higher - order type or has the wrong arity then @xmath332 , indicating an error . the new constant $ ` ipred`$ simply collects the call and success ti - grammars for the higher - order object s missing arguments .",
    "the extension of @xmath142 for the case of base instantiations @xmath140 is similar to the treatment of type parameters .",
    "a higher - order object can be ` new ` or ` ground ` , but if it is ` old ` this is identical to ` ground ` since higher - order objects never have an attached solver .",
    "@xmath333 is treated as before ( i.e.  it creates a ti - grammar ) .",
    "similarly @xmath334 generates a production rule using a new constant $ ` gpred`$ of the form @xmath335 @xmath336 generates the same grammar ( since it is equivalent ) . since we will only compare the higher - order ti - grammar against other ti - grammars for the same type we can safely omit the information about the argument types ( @xmath337 ) .    the new constant $ ` gpred`$ acts like @xmath338 but it can also be compared with more complicated ti - grammars ( with production rules for function symbol $ ` ipred`$ ) of the same type .",
    "the full code for @xmath142 is given in the appendix .",
    "[ ex : map ] consider the following code :    : - pred map(pred(t1,t2 ) , list(t1 ) , list(t2 ) ) .",
    "+ : - mode map(in(pred(in , out ) is det ) , in , out ) is det .",
    "+ map(h , [ ] , [ ] ) .",
    "+ map(h , [ a|as ] , [ b|bs ] ) : - call(h , a , b ) , map(h , as , bs ) . +   + : - typedef sign - > ( neg ; zero ; pos ) .",
    "+   + : - pred mult(sign , sign , sign ) .",
    "+ : - mode mult(in , in , out ) is det .",
    "+   + ? - h1 = mult(pos ) , map(h1 , [ neg , zero , pos ] , l1 ) .",
    "the ` map/3 ` predicate takes a higher - order predicate with two missing arguments of parametric types ` t1 ` and ` t2 ` and modes ` in ` and ` out ` , respectively .",
    "the ti - grammar describing the input instantiation of the first argument of ` map/3 ` is the grammar with root @xmath339 , defined by    a_1 & & $ ` ipred`$(ti(,),ti(,),,ti ( , ) ) + ti ( , ) & & $ ` ground`(t1)$ + ti ( , ) & & $ ` ground`(t2)$ + & & # ` fresh ` #    this predicate is applied to a list of ` t1`s , returning a list of ` t2`s .",
    "the literal ` h1 = mult(pos ) ` constructs a higher - order object which multiplies the sign of its first argument by ` pos ` , returning the result in its second argument .",
    "the type - instantiation of ` h1 ` , @xmath340 , is the grammar with root @xmath341 and rules :    a_2 & & $ ` ipred`$(ti(,),ti ( , ) , , ti ( , ) ) + ti ( , ) & & neg  ;   zero  ;   pos + & & # ` fresh ` #    we need to extend the ordering @xmath103 to higher - order type - instantiations as well as the operations @xmath204 and @xmath206 .",
    "two higher - order ti - grammars @xmath59 and @xmath68 defined with rules    root(r ) & & $ ` ipred`$(xc_1 , xs_1 ,  , xc_n , xs_n )    and    root(r ) & & $ ` ipred`$(xc_1 , xs_1 ,  , xc_n , xs_n )    satisfy @xmath342 iff for @xmath343 , @xmath344 and @xmath345 . intuitively ,",
    "if @xmath342 , then any higher - order @xmath346 should be replaceable by @xmath347 .",
    "for this to work , two conditions must be fulfilled .",
    "first , @xmath59 must be able to deal with any values that @xmath68 can deal with ( and perhaps more ) .",
    "thus , @xmath344 . and second , @xmath59 must return the same values as @xmath68 or less .",
    "thus , @xmath345 . for more details see the example below .",
    "we define @xmath348 for any ti - grammar @xmath59 of the appropriate type except .",
    "the full definition of @xmath103 is given in the appendix .",
    "the @xmath204 and @xmath206 operations follow naturally from the ordering , and are given in the appendix .    consider the following code and goal :    : - typedef abc - > a ; b ; c. + : - instdef ab - > a ; b. +   + : - pred ho1(abc , abc ) .",
    "+ : - mode ho1(in(ab),out(ab ) ) is det . + ho1(a , b ) : - a = b. +   + : - pred ho2(abc , abc ) .",
    "+ : - mode ho2(in , out ) is det .",
    "+ ho2(a , b ) : - a = a , b = b. + ho2(a , b ) : - a = b , b = c. + ho2(a , b ) : - a = c , b = a. +   + ? - ho1 = ho1 , ho2 = ho2 , ( ho = ho1 ; ho = ho2 ) .    during scheduling of the disjunction ,",
    "the ti - grammar for ` ho1 ` is rt(`pred(abc , abc ) ` , ` pred(in(ab),out(ab ) ) ` ) , i.e. :    & & $ ` ipred`$ ( , , , ) + & & a  ;   b + & & # ` fresh ` #    and the ti - grammar for ` ho2 ` is    & & $ ` ipred`$ ( , , , ) + & & a  ;   b  ;   c + & & # ` fresh ` #    the abstract disjunction of these two grammars to build the ti - grammar for ` ho ` gives    & & $ ` ipred`$ ( , , , ) +    notice the call ti - grammars have been abstractly conjoined .",
    "this illustrates the contravariant nature of calling instantiations of higher - order predicates . the higher - order object in ` ho ` can only be safely applied to an input ` a ` or ` b ` since it may be predicate ` ho1 ` .",
    "it can only be guaranteed to give output ` a`,`b ` or ` c ` since it may be predicate ` ho2 ` .      intuitively , a higher - order equation @xmath314 is schedulable if @xmath318 is and @xmath349 are at least as instantiated as the call instantiations of one of the modes declared for @xmath58 .",
    "if this is true for more than one mode , we again choose one schedulable mode ( using the same criteria used for calls to first order predicates ) and commit to it .",
    "if it is not true for any mode , the equation is delayed until the arguments become more instantiated .",
    "formally , let the current ti - state be @xmath350 and the types @xmath351 .",
    "let the ( declared or inferred ) predicate type of @xmath58 be @xmath352 , then ( because of type correctness ) we have that there exists @xmath27 such that @xmath353 .",
    "consider the declared mode @xmath56 .",
    "the higher - order equation is schedulable if @xmath252 and for each @xmath354 .",
    "the resulting ti - state is @xmath355 where @xmath356 and @xmath357 for @xmath358 and @xmath359 , where @xmath91 is a new non - terminal , together with the grammars for @xmath360 .",
    "note that the instantiation of each @xmath249 is unchanged and , in fact , will not be updated even when @xmath318 is called .",
    "this is because in general we can not ensure when or if the call has actually been made . as a result ,",
    "mode checking with higher - order objects can be imprecise .",
    "in particular , if one of the @xmath239 is we may not know if it becomes initialised or not since we do not know if the call to @xmath318 which will initialise it has been made . since we must be able to precisely track when a variable has become initialised",
    ", we do not allow a call to be scheduled if this is the case ( hence the @xmath361 condition above ) .    a higher - order call `",
    "call`@xmath362 is schedulable if @xmath363 are at least as instantiated as the call instantiations of the arguments of the higher - order type - instantiation previously assigned to @xmath318 .",
    "if this is not true , the call is delayed until the arguments become more instantiated .",
    "formally , let the current ti - state be @xmath364 .",
    "the call is schedulable if @xmath59 has a production rule of the form @xmath365 and for each @xmath366 .",
    "the resulting instantiation is @xmath367 .",
    "just as for normal predicate calls , implied modes are also possible where if , for example , @xmath368 is , we can replace @xmath369 with a fresh variable @xmath370 and a following equation @xmath371 . and , if necessary",
    ", the mode checker will add calls to initialise solver variables .",
    "consider the following code and assume all goals are schedulable in the order written :    : - instdef only_a - > a. + : - modedef abc2a - > ( ground - > only_a ) .",
    "+   + : - pred p(abc , abc , abc ) + : - mode p(abc2a , in , out(only_a ) ) is semidet .",
    "+   + ? - @xmath372 , p(a , b , c ) , @xmath373 .",
    "+ ? - @xmath372 , h = p(a ) , call(h , b , c ) , @xmath373 .    the two queries would appear to have identical effects . however , mode checking for the second goal will not determine that the instantiation for ` a ` becomes ` only_a ` by the time it reaches goal @xmath373 . assuming ` a `",
    "was ` ground ` before ` h = p(a ) ` , then the type - instantiation of ` h ` is the grammar with root @xmath374 and rules :    x & & $ ` ipred`$(ti(,),ti ( , ) , , ti ( , ) ) + ti ( , ) & & a  ;   b  ;   c + ti ( , ) & & a + & & # ` fresh ` #    of course in this case it is obvious that the predicate is being called before @xmath373 , and so it could be inferred that the instantiation of ` a ` was at that point .",
    "however , in the usual case such analysis is harder , since the construction of a higher - order term and its eventual execution are usually performed in different predicates .",
    "indeed , in general it is impossible to know at compile time whether at a given program point the higher - order predicate has been executed or not .",
    "polymorphic predicates are very useful because they can be used for different types .",
    "unfortunately , mode information can be lost since only the base instantiations ` ground ` , ` new ` , and ` old ` can be associated with type parameters .",
    "consider the interface to the stack data type defined in figure [ fig : stack ] and the following program :    : - pred q(abc ) .",
    "+ : - mode q(in ) is semidet .",
    "+ : - mode q(in(only_a ) ) is det . +   + ? - empty(s0 ) , i0 = a , push(s0 , i0 , s1 ) , pop(s1 , i , s2 ) , q(i ) .",
    "although list ` s1 ` is indeed a list only containing items ` a ` this information is lost after executing ` push ` since the output instantiation declared for this predicate is simply ground . because of this , the first mode of predicate ` q/1 ` will be selected for literal ` q(i ) ` , thus losing the information that ` q(i ) ` could not fail .",
    "this loss of instantiation information for arguments to polymorphic predicates may have severe consequences for higher - order objects because the base instantiation ` ground ` applied to polymorphic code does not contain enough information for the higher - order object to be used ( called ) .    consider the following goal using code from figure  [ fig : stack ] and example  [ ex : map ] :    ? - empty(s0 ) , i0 = mult(pos ) , push(s0,i0,s1 ) , pop(s1,i , s2 ) , map(i,[neg],s ) .",
    "when item ` i ` is extracted from the list its ti - grammar is @xmath375",
    "where @xmath25 is type @xmath376 . as a result",
    ", it can not be used in ` map ` since its mode and determinism information has been lost , i.e.  the check @xmath377 fails .    we could overcome the above problem by having a special version of each stack predicate to handle the higher - order predicate case .",
    "but this requires modifying the ` stack ` module , defeating the idea of an abstract data type .",
    "also , this modification is required for each mode of the higher - order object that the programmer wishes to make use of .",
    "clearly , this is not an attractive proposition .",
    "our approach is to use polymorphic type information to recover the lost mode information .",
    "this is an example of `` theorems for free ''  @xcite : since the polymorphic code can only equate terms with polymorphic type , it can not create instantiations and , thus , the output instantiations of polymorphic arguments must result from the calling instantiations of non - output arguments .",
    "hence , they have to be at least as instantiated as the join of the input instantiations .      to recover instantiation information we extend mode checking for procedures with polymorphic types to take into account the extra mode information that is implied by the polymorphic type .",
    "consider the predicate call @xmath378 where @xmath10 are variables with type @xmath379 and current ti - state @xmath259 .",
    "suppose the predicate type declared ( or inferred ) for @xmath257 is @xmath352 .",
    "note that because of type correctness there exists the type substitution @xmath27 where @xmath353 .",
    "xx = xx = xx = xx = xx = collect_set(@xmath77,@xmath78,@xmath179 ) + @xmath7 : = @xmath380 ; @xmath8 : = @xmath381 + * if * ( @xmath382 ) * return * @xmath182 + * if * ( @xmath383 ) * return * @xmath182 + * if * ( @xmath384 ) * return * @xmath385 + * if * ( @xmath386 ) * return * @xmath387 + @xmath388 : = @xmath182 + * foreach * rule @xmath389 in @xmath77 + * if * exists rule @xmath390 in @xmath78 + * for * @xmath140 : = @xmath189 + @xmath388 : = @xmath391 collect_set(@xmath392 , @xmath393 , @xmath394 ) + * return * @xmath388 +    assume the literal is schedulable for mode declaration @xmath56 .",
    "we proceed by matching the ti - trees @xmath395 against the current instantiations @xmath239 in a process analogous to the matching that occurs in the meet function .",
    "note that @xmath395 is the ti - grammar which contains information on the positions of type parameters in the declared type of @xmath257 .",
    "consider the function collect_set(@xmath396 ) , defined in figure  [ collect_set ] , which returns the set of triples @xmath397 and @xmath398 obtained by collecting each ti - grammar , @xmath68 , in @xmath78 matching occurrences of @xmath399 and @xmath400 in @xmath77 .",
    "let @xmath401 collect_set(@xmath402 ) .",
    "we will use this information to compute the success instantiations as follows : since the only success type - instantiation information for elements of parametric type @xmath154 must come from its call type - instantiations , we can safely assume that any success type - instantiation is at least as instantiated as the join ( upper bounds ) of the calls .    note that when determining ground success information , we need only consider ground calling instantiations , since ground success instantiations can not result from old call instantiations . on the other hand , for old success information , we need to consider both old and ground calling instantiations , since old success instantiations can result from either .",
    "hence the following definitions for @xmath403 and @xmath404 , which compute upper bounds on success instantiations for @xmath154 based on the call instantiation information collected in @xmath388 : @xmath405 because the literal is schedulable for the given mode we know that no @xmath406 contains for any @xmath25 .",
    "thus , the abstract disjunctions in @xmath403 and @xmath404 never lead to @xmath107 .",
    "let @xmath407 be the result of replacing in @xmath408 each non - terminal @xmath9 with productions of the form @xmath409 by @xmath410 and removing the rules for @xmath9 , and replacing each non - terminal @xmath9 with productions of the form @xmath411 by @xmath412 and removing the rules for @xmath9 , and finally adding the rules in @xmath404 and @xmath403 .",
    "the new ti - state resulting after scheduling the polymorphic literal is @xmath413 .",
    "[ ex : hopush ] assume we are scheduling the ` push/3 ` literal in the goal using code from figure  [ fig : stack ] and example  [ ex : map ] :    ? - empty(s0 ) , i0 = mult(pos ) , push(s0,i0,s1 ) , pop(s1,i , s2 ) , map(i,[neg],s ) .    for current ti - state @xmath414 ,",
    "the remaining variables being , where @xmath275 is the grammar    ti ( , ) & & [ ] +    and @xmath415 is the grammar with root @xmath416 defined by    a & & $ ` ipred`$(ti(,),ti ( , ) , , ti ( , ) ) + ti ( , ) & & neg  ;   zero  ;   pos    the ti - grammars defined by the declared type and mode declarations for the first two arguments of ` push/3 ` are : @xmath417 or the grammar    ti ( , ) & & [ ]  ;   [ ti ( , )  |  ti ( , ) ] + ti ( , ) & & $ ` ground`(t)$    and , @xmath418 , the grammar    ti ( , ) & & $ ` ground`(t)$    the literal is schedulable and the matching process determines that @xmath419 , @xmath420 and @xmath421 .",
    "the improved analysis determines that extra success instantiation ( @xmath422 ) for the third argument ( ` s1 ` ) by improving @xmath198 which is    ti ( , & & [ ti ( , )  |   ti ( , ] + ti ( , & & [ ]  ;   [ ti ( , )  |   ti ( , ] + ti ( , ) & & $ ` ground`(t)$    replacing the last rule by @xmath415 and occurrences of @xmath423 by @xmath424 obtaining    ti ( , & & [ a  |   ti ( , ] + ti ( , & & [ ]  ;   [ a  |   ti ( , ] + a & & $ ` ipred`$(ti(,),ti ( , ) , , ti ( , ) ) + ti ( , ) & & neg  ;   zero  ;   pos    note that the mode information of the higher - order term has been preserved . the mode checking for the call to ` pop/3 ` will similarly preserve the higher - order mode information , and",
    "the original goal will be schedulable .",
    "the interaction between polymorphic mode analysis and higher - order constructs and calls is in fact slightly more complicated than discussed previously .",
    "this is because higher - order objects allow us to give arguments to a predicate in a piecewise manner .",
    "this affects the execution of collect_set which was collecting the set @xmath388 over all predicate arguments simultaneously . in order to handle these",
    "accurately we need to store the information from @xmath388 found during the higher - order object construction , to be used in the higher - order call .",
    "that is , we need to store @xmath403 and @xmath404 for each type parameter @xmath154 appearing in the remaining arguments as part of the ti - grammar for the higher - order object .    an alternative approach used by the hal compiler is to update the success instantiations stored in the ti - grammar of the higher - order object based on the extra information from polymorphism .",
    "when the call to the higher - order polymorphic predicate is analyzed , the matching process also matches the success instantiations of the higher - order object to recover the previous matching information .",
    "the ultimate aim of mode checking is to ensure that the compiler has correct instantiation information at every program point in order to allow program optimization .",
    "it is reasonably straightforward ( but laborious ) to show that the mode checking defined in this paper ensures that the resulting program has input - output and call correctness .",
    "some subtle points that arise are as follows .",
    "first , it is an invariant that any ti - grammar ( or sub - grammar ) @xmath59 occurring in the mode checking process that contains rule @xmath254 must be equivalent to @xmath425 for some @xmath25 , which means that when variables are bound indirectly ( through shared variables ) the correctness of the ti - state is maintained .",
    "second , if a procedure is input - output correct for its declared type , then it is also input - output correct for any instance of the type .",
    "this follows from the limited possibilities for manipulating objects of variable type ( essentially copying and testing equality ) .",
    "this means that compiler optimizations can safely be applied .",
    "the only mode error that may be detected at run - time arises from situations explained in section  [ sec : eq ] and example  [ ex : runtimeerror ] .",
    "the compiler emits warnings when such a possibility exists .",
    "we have described for the first time mode checking for clp languages , such as hal , which have strong typing and re - orderable clause bodies , and described the algorithms currently used in the hal compiler .",
    "the actual implementation of these algorithms in the hal compiler is considerably more sophisticated than the simple presentation here .",
    "partial schedules are computed and stored and accessed only when enough new instantiation information has been created to reassess them .",
    "operations such as @xmath103 are tabled and hence many operations are simply a lookup in a table .",
    "we have found mode checking is efficient enough for a practical compiler .",
    "for the compiler compiling itself ( 29000 lines of hal code in 27 highly interdependent modules compiled in 15 mins 20 secs ) mode checking requires 16.4% of overall compile time .",
    "while compiling the libraries ( 4600 lines of hal code in 12 almost independent modules compiled in 47 secs ) it takes 13.1% of overall compile time . and",
    "compiling a suite of small to medium size benchmarks ( 6200 lines of hal code in 67 modules compiled in 183 secs ) it takes 13.0% of overall compile time ,    there is considerable scope for future work .",
    "one aim is to strengthen mode checking .",
    "we plan to add tracking of aliasing and groundness dependencies .",
    "another problem is that currently hal ( like mercury ) never undoes a feasible choice of ordering the literals .",
    "this can lead to correctly moded programs not being checkable as in example [ non - check ] . in practice",
    "this behavior is rare , but we would like to explore more complete strategies .",
    "[ non - check ] consider the following declarations and goal :    : - pred p(list(int),list(int ) ) .",
    "+ : - mode p(out , out ) is det .",
    "+ : - mode p(in(evenlist(ground)),out(evenlist(ground ) ) ) is det .",
    "+   + : - pred q(list(int ) ) .",
    "+ : - mode q(out(evenlist(ground ) ) ) is det",
    ". +   + : - pred r(list(int ) ) .",
    "+ : - mode r(in(evenlist(ground ) ) ) is det . +   + ?",
    "- p(l0 , l1 ) , q(l0 ) , r(l1 ) .",
    "the first two literals of the goal are schedulable in the order given , as ` p_mode1(l0 , l1 ) , q_mode1(l2 ) , l2 = l0 ` but then ` r(l1 ) ` is not schedulable ( the list ` l1 ` may not be of even length ) .",
    "there is a feasible schedule : ` q_mode1(l0 ) , p_mode2(l0 , l1 ) , r_mode1(l1 ) ` which is missed by both hal and mercury , since they do nt undo the feasible schedule for the first two literals . in order to avoid this problem hal",
    "allows the user to name modes of a predicate and hence specify exactly which mode is required .",
    "a second aim is to improve the efficiency of the reordered code , by , for instance , reducing the number of initializations .",
    "the final aim is to provide mode inference as well as mode checking ",
    "the ability to reorder body literals makes this a potentially very expensive process .",
    "we would like to thank fergus henderson and zoltan somogyi for discussions of the mercury mode system , and their help in modifying mercury to support hal features .",
    "we would also like to thank the anonymous referees whose suggestions have enormously improved the paper .",
    "directional types and the annotation method .",
    "_ 33 , _  3 , 179220 .    ,",
    "cabeza , d. , carro , m. , hermenegildo , m. , lpez - garca , p. , and puebla , g. 2002 . the ciao prolog system reference manual . tech . rep .",
    ", technical university of madrid ( upm ) .",
    "http://clip.dia.fi.upm.es/software/ciao .",
    "xperimental evaluation of a generic abstract interpretation algorithm for prolog .   _",
    "16 , _  1 , 35101 .",
    "type dependencies for logic programs using aci - unification .",
    "_ 238 , _  12 , 131159 .    ,",
    "codognet , p. , and corsini , m. 1990 .",
    "abstract interpretation of concurrent logic languages . in _",
    "north american conference on logic programming_. 215232 .",
    ", dauchet , m. , gilleron , r. , jacquemard , f. , lugiez , d. , tison , s. , and tommasi , m. 1997 .",
    "tree automata techniques and applications .",
    "available on : ` http://www.grappa.univ-lille3.fr/tata ` .",
    "static inference of modes and data dependencies in logic programs .",
    "_ 11 , _  3 , 418450 .    ,",
    ", m. , harvey , w. , marriott , k. , and stuckey , p. 1999a .",
    "herbrand constraint solving in hal . in _ logic programming : proceedings of the 16th international conference _",
    ", d.  d. schreye , ed .",
    "mit press , 260274 .",
    ", , m. , harvey , w. , marriott , k. , and stuckey , p. 1999b .",
    "an overview of hal . in _ proceedings of the fourth international conference on principles and practices of constraint programming _ , j.  jaffar , ed .",
    "springer - verlag .",
    ", , m. , and stuckey , p. 1999 .",
    "type constraint solving for parametric and ad - hoc polymorphism . in _ proceedings of the 22nd australian",
    "computer science conference _ ,",
    "j.  edwards , ed .",
    "springer - verlag , 217228 .    , demoen , b. , marriott , k. , and stuckey , p. 2002 . to the gates of hal : a hal tutorial . in _ proceedings of the sixth international symposium on functional and logic",
    "programming_. number 2441 in lncs .",
    "springer - verlag , 4766 .",
    "academei kaido , budapest .    ,",
    "somogyi , z. , and conway , t. 1996 .",
    "determinism analysis in the mercury compiler . in",
    "_ proceedings of the australian computer science conference_. 337346 .    ,",
    "puebla , g. , bueno , f. , and lpez - garca , p. 2003 .",
    "program development using abstract interpretation ( and the ciao system preprocessor ) . in _ proceedings of the 10th international symposium on static analysis _",
    ", r.  cousot , ed .",
    "lncs , vol .",
    "springer .",
    "\\1993 . deriving descriptions of possible values of program variables by means of abstract interpretation .",
    "_ 13 _ , 205258 .",
    "the 3 r s of optimizing constraint logic programs : refinement , removal , and reordering . in _",
    "annual acm conference on principles of programming languages_. acm , 334344 .",
    "mit press .",
    "bstract interpretation of prolog programs .",
    ", 181198 .    , simoens , w. , janssens , g. , and bruynooghe , m. 1995 .",
    "n the practicality of abstract equation systems . in _ international conference on logic programming_. mit press , 781795 .",
    "polymorphic type schemes and recursive definitions . in _",
    "international symposium on programming_. lncs , vol .",
    "springer - verlag , 217228 .",
    "cambridge university press .",
    "precise and expressive mode systems for typed logic programming languages . ph.d .",
    "thesis , department of computer science and software engineering , university of melbourne .",
    "http://www.cs.mu.oz.au/research/mercury/information/papers/dmo-thesis.ps.gz .    ,",
    "boizumault , p. , and malesieux , f. 1999 . typed static analysis : application to groundness analysis of prolog and lambda - prolog . in _ proceedings of the international symposium on functional and logic programming_. lncs .",
    "springer - verlag , 267283 .    , hill , p. , and king , a. 2000 .",
    "mode analysis domains for typed logic programs . in _ proceedings of the 9th international workshop on logic - based program synthesis and transformation _",
    ", a.  bossi , ed .",
    "springer - verlag , 82101 .",
    "\\1987 . a system of precise modes for logic programs .",
    "in _ logic programming : proceedings of the 4th international conference_. 769787 .    , henderson , f. , and conway , t. 1996 . the execution algorithm of mercury : an efficient purely declarative logic programming language .  _ 29",
    "_ , 1764 .",
    "theorems for free . in _ conference on functional programming languages and computer architecture_. acm press , 347359 .",
    "in this appendix we give full versions of the tree operations mentioned in the paper .",
    "the basic tree operations are relatively straightforward , but new kinds of nodes for solver variables , polymorphic types and higher - order terms complicate this somewhat .",
    "recall that we assume we are dealing with type correct programs , hence the operations make use of this to avoid many redundant comparisons .",
    "for example when comparing the order of two ti - grammars , then if one is a predicate type , the other must be an identical predicate type .",
    "xx = xx = xx = xx = xx = xx = xxxxxxxxxxxxxxxxxxxxx = xxxxxxx = lt(@xmath427 , @xmath428 , @xmath179 ) + * if * ( @xmath429 ) * return true * + * if * ( @xmath430 ) * return false * + * if * ( @xmath431 ) * return true * + * if * ( @xmath432 ) * return false * + * case * : + @xmath433 : * return * @xmath434 + @xmath435 : % % @xmath436 + * return * @xmath437 + @xmath438 : % % @xmath439 + * return * @xmath440 + @xmath441 : % % @xmath442 + * return * @xmath443 + @xmath444 : % % non - base higher - order ti + * if * ( @xmath443 ) * return * * true * + * let * @xmath445 + * for * @xmath140 : = @xmath446 + * if * ( @xmath447 ) * return * * false * + * if * ( @xmath448 ) * return * * false * + * endfor * + * return true * + * default * : + * foreach * @xmath449 + * if * ( @xmath450 ) + * for * @xmath140 : = @xmath451 + * if * ( @xmath452 ) * return false * + * endfor * + * else * * return * * false * + * endfor * + * return true *      xx = xx = xx = xx = xx = xx = xxxxxxxxxxxxxxxxxxxxx = xxxxxxx = conj(@xmath427,@xmath428,@xmath179 ) + * if * ( @xmath430 ) * return * @xmath455 + * if * ( @xmath429 ) * return * @xmath455 + * if * ( @xmath456 ) * return * @xmath457 + * if * ( @xmath458 ) * return * @xmath459 + * case * : + @xmath460 : * return * ( @xmath428 , @xmath461 ) + @xmath435 : % % @xmath436 + * return * ( @xmath428,@xmath461 ) + @xmath438 : % % @xmath439 + * return * ( @xmath427,@xmath462 ) + @xmath441 : % % @xmath442 + * return * ( @xmath428,@xmath461 ) + @xmath444 : % % non - base higher - order ti + * if * ( @xmath443 ) * return * ( @xmath427,@xmath462 ) + * let * @xmath463 + * for * @xmath140 : = @xmath446 + @xmath464 : = @xmath465 + @xmath466 : = @xmath467 + * if * ( @xmath468 ) * return * @xmath455 + * endfor * + @xmath257 : = = @xmath469 + @xmath470 + * return * @xmath471 + * default * : + @xmath257 : = @xmath182 + * foreach * @xmath449 + * if * ( @xmath450 ) + * for * @xmath140 : = @xmath189 + @xmath472 : = @xmath473 ) + * if * ( @xmath474 ) * return * @xmath455 + * endfor * + @xmath257 : = @xmath475 + * endfor * + * return * @xmath476      xx = xx = xx = xx = xx = xx = xxxxxxxxxxxxxxxxxxxxx = xxxxxxx = disj(@xmath427,@xmath428,@xmath179 ) + * if * ( @xmath430 ) * return * @xmath455 + * if * ( @xmath429 ) * return * @xmath455 + * if * ( @xmath479 ) * return * @xmath480 + * if * ( @xmath456 ) * return * @xmath455 + * if * ( @xmath481 ) * return * @xmath482 + * case * : + @xmath460 : * return * ( @xmath107 , @xmath483 ) + @xmath435 : % % @xmath436 + * return * ( @xmath427,@xmath462 ) + @xmath438 : % % @xmath439 + * return * ( @xmath428,@xmath461 ) + @xmath441 : % % @xmath442 + * return * ( @xmath427,@xmath462 ) + @xmath484 : % % non - base higher - order ti + * if * ( @xmath443 ) * return * ( @xmath428,@xmath461 ) + * let * @xmath463 + * for * @xmath140 : = @xmath446 + @xmath464 : = @xmath485 + @xmath466 : = @xmath486 + * if * ( @xmath468 ) * return * @xmath455 + * endfor * + @xmath257 : = = @xmath487 + @xmath488 + * return * @xmath489 + * default * : + @xmath257 : = @xmath182 + * foreach * @xmath449 + * if * ( @xmath450 ) + * for * @xmath140 : = @xmath189 + @xmath472 : = @xmath490 ) + * if * ( @xmath474 ) * return * @xmath455 + * endfor * + @xmath257 : = @xmath491 + * else * + @xmath257 : = = @xmath492 + @xmath493 + * endif * + * endfor * + * foreach * @xmath494 + * if * ( @xmath495 ) + @xmath257 : = @xmath496 + @xmath497 + * endfor * + * return * @xmath498      xx = xx = xx = xx = xx = xx = xx = xx = rt(@xmath25,@xmath140,@xmath179 ) + * if * ( @xmath500 ) * return * @xmath184 + * case * : + @xmath140 is a base instantiation : * return * base(@xmath25,@xmath140,@xmath179 ) + @xmath501 : + * if * ( @xmath502 ) * return * @xmath185 + * let * @xmath25 be of the form @xmath503 + * for * @xmath188 = @xmath189 + @xmath504 : = rt(@xmath505 , @xmath506 , @xmath179 ) + @xmath507 : = rt(@xmath505 , @xmath508 , @xmath179 ) + * if * ( @xmath509 ) * return * @xmath185 + * endfor * + @xmath59 : = @xmath510 + @xmath488 + * return * @xmath196 + * default * : + * if * ( @xmath128 ) * return * @xmath185 + @xmath59 : = @xmath182 + * foreach * @xmath511 + * if * ( @xmath512 ) + * for * @xmath188 = @xmath189 + @xmath190 : = rt(@xmath191 , @xmath192 , @xmath513 ) + * if * ( @xmath194 ) * return * @xmath455 + * endfor * + @xmath59 : = @xmath195 + * endif * + * endfor * + * return * @xmath196    xx = xx = xx = xx = xx = xx = xx = xx = base(@xmath25,@xmath144,@xmath179 ) + * if * ( @xmath514 ) * return * ( @xmath515 ) + * if * ( @xmath516 ) * return * ( @xmath182,@xmath143 ) + * if * ( @xmath128 ) : + * if * ( @xmath517 ) * return * ( @xmath518 ) + * else * * return * ( @xmath519 ) + * else if * ( @xmath25 is of the form @xmath503 ) + * return * ( \\{@xmath520 } , @xmath521 ) + * else * + @xmath59 : = @xmath182 + * foreach * @xmath522 in @xmath125 + * for * @xmath523 + @xmath524 : = base(@xmath505,@xmath144,@xmath525 ) + * endfor * + @xmath59 : = @xmath526 + * endfor * + * if * ( @xmath527 and @xmath25 is a solver type ) * then * @xmath59 : = @xmath528 + * return * @xmath529"
  ],
  "abstract_text": [
    "<S> recent constraint logic programming ( clp ) languages , such as hal and mercury , require type , mode and determinism declarations for predicates . </S>",
    "<S> this information allows the generation of efficient target code and the detection of many errors at compile - time . </S>",
    "<S> unfortunately , mode checking in such languages is difficult . </S>",
    "<S> one of the main reasons is that , for each predicate mode declaration , the compiler is required to appropriately re - order literals in the predicate s definition . </S>",
    "<S> the task is further complicated by the need to handle complex instantiations ( which interact with type declarations and higher - order predicates ) and automatic initialization of solver variables . here </S>",
    "<S> we define mode checking for strongly typed clp languages which require reordering of clause body literals . </S>",
    "<S> in addition , we show how to handle a simple case of polymorphic modes by using the corresponding polymorphic types .    </S>",
    "<S> * note : * this article is to published in _ theory and practice of logic programming_. cambridge university press .    </S>",
    "<S> strong modes , mode checking , regular grammars </S>"
  ]
}