{
  "article_text": [
    "one of the possible generalizations of the _ discrete logarithm problem _ to arbitrary groups is the so - called _ conjugacy search problem _ : given two elements @xmath0 of a group @xmath1 and the information that @xmath2 for some @xmath3 , find at least one particular element @xmath4 like that . here",
    "@xmath5 stands for @xmath6 .",
    "the ( alleged ) computational difficulty of this problem in some particular groups ( namely , in braid groups ) has been used in several group based cryptosystems , most notably in @xcite and @xcite .",
    "it seems however now that the conjugacy search problem alone is unlikely to provide sufficient level of security ; see @xcite and @xcite for explanations .    in this paper",
    "we employ another problem , which generalizes the conjugacy search problem , but at the same time resembles the factorization problem which is at the heart of the rsa cryptosystem .",
    "this problem which some authors ( see e.g. @xcite , @xcite ) call the _ decomposition problem _ is as follows :    _ given an element @xmath7 of a ( semi)group @xmath1 , a subset @xmath8 and an element @xmath9 , find elements @xmath10 such that @xmath11 .",
    "_    the conjugacy search problem ( more precisely , its subgroup - restricted version used in @xcite ) is a special case of the decomposition problem if one takes @xmath12 .",
    "the usual factorization problem for integers used in the rsa cryptosystem is also a special case of the decomposition problem if one takes @xmath13 and @xmath14 , the multiplicative ( semi)group of integers modulo @xmath15 .",
    "it is therefore conceivable that with more complex ( semi)groups used as platforms , the corresponding cryptosystem may be more secure . at the same time , in the group that we use in this paper ( r. thompson s group ) , computing ( the normal form of ) a product of elements is faster than in @xmath16 .",
    "a key exchange protocol based on the general decomposition problem is quite straightforward ( see e.g. @xcite ) : given two subsets @xmath17 such that @xmath18 for any @xmath19 , and given a public element @xmath20 , alice selects private @xmath21 and sends the element @xmath22 to bob .",
    "similarly , bob selects private @xmath23 and sends the element @xmath24 to alice",
    ". then alice computes @xmath25 , and bob computes @xmath26 . since @xmath27 in @xmath1 , one has @xmath28 ( as an element of @xmath1 ) , which is now alice s and bob s common secret key .    in this paper , we suggest the following modification of this protocol which appears to be more secure ( at least for our particular choice of the platform ) against so - called  length based \" attacks ( see e.g. @xcite , @xcite ) , according to our experiments ( see our section [ selection ] ) . given two subsets @xmath17 such that @xmath18 for any @xmath29 , and given a public element @xmath20 , alice selects private @xmath30 and @xmath31 and sends the element @xmath32 to bob .",
    "bob selects private @xmath33 and @xmath34 and sends the element @xmath35 to alice",
    ". then alice computes @xmath36 , and bob computes @xmath37 . since @xmath27 in @xmath1 , one has @xmath28 ( as an element of @xmath1 ) , which is now alice s and bob s common secret key .",
    "the group that we suggest to use as the platform for this protocol is thompson s group @xmath38 well known in many areas of mathematics , including algebra , geometry , and analysis .",
    "this group is infinite non - abelian . for us , it is important that thompson s group has the following nice presentation in terms of generators and defining relations :    @xmath39    this presentation is infinite .",
    "there are also finite presentations of this group ; for example ,    @xmath40    but it is the infinite presentation above that allows for a convenient normal form , so we are going to use that presentation in our paper .",
    "for a survey on various properties of thompson s group , we refer to @xcite . here",
    "we only give a description of the  classical \" normal form for elements of @xmath38 .",
    "the classical normal form for an element of thompson s group is a word of the form @xmath41 such that the following two conditions are satisfied :    1 .",
    "@xmath42 and @xmath43 2 .",
    "if both @xmath44 and @xmath45 occur , then either @xmath46 or @xmath47 occurs , too .",
    "we say that a word @xmath7 is in _ seminormal form _ if it is of the form ( [ eq : norm_form1 ] ) and satisfies ( nf1 ) .",
    "we show in section [ wp ] that the time complexity of reducing a word of length @xmath48 to the normal form in thompson s group is @xmath49 , i.e. , is almost linear in @xmath48 .",
    "another advantage of cryptographic protocols based on symbolic computation over those based on computation with numbers is the possibility to generate a random word one symbol at a time .",
    "for example , in rsa , one uses random prime numbers which obviously can not be generated one digit at a time but rather have to be precomputed , which limits the key space unless one wants to sacrifice the efficiency .",
    "we discuss key generation in more detail in our section [ selection ] .",
    "_ acknowledgments .",
    "_ we are grateful to v. guba for helpful comments and to r. haralick for making a computer cluster in his lab available for our computer experiments .",
    "let @xmath38 be thompson s group given by its standard infinite presentation ( [ eq : inf_pres ] ) and @xmath50 a positive integer .",
    "define sets @xmath51 and @xmath52 as follows .",
    "the set @xmath51 consists of elements whose normal form is of the type @xmath53 i.e. positive and negative parts are of the same length @xmath54 , and @xmath55 the set @xmath52 consists of elements represented by words in generators @xmath56 . obviously , @xmath52 is a subgroup of @xmath38 .",
    "let @xmath57 and @xmath58 .",
    "then @xmath59 in the group @xmath38 .",
    "let @xmath60 and @xmath61 where @xmath62 for every @xmath63 .",
    "by induction on @xmath64 and @xmath54 it is easy to show that in the group @xmath38 one has    @xmath65 where @xmath66 is the operator that increases indices of all generators by @xmath67 ( see also our section [ wp ] ) .",
    "this establishes the claim .",
    "let @xmath68 be an integer .",
    "the set @xmath51 is a subgroup of @xmath38 generated by @xmath69    the set @xmath51 contains the identity and is clearly closed under taking inversions , i.e. , @xmath70 . to show that @xmath51 is closed under multiplication we take two arbitrary normal forms from @xmath51 : @xmath71 and @xmath72 and",
    "show that the normal form of @xmath73 belongs to @xmath51 .",
    "first , note that since the numbers of positive and negative letters in @xmath73 are equal , the lengths of the positive and negative parts in the normal form of @xmath73 will be equal , too ( see the rewriting system in the beginning of our section [ wp ] ) .",
    "thus , it remains to show that the property ( [ eq : condition ] ) of indices in the normal form of @xmath74 is satisfied .",
    "below we sketch the proof of this claim .",
    "consider the subword in the middle of the product @xmath73 marked below : @xmath75 and find a seminormal form for it using relations of @xmath38 ( move positive letters to the left and negative letters to the right starting in the middle of the subword ) .",
    "we refer the reader to algorithm [ al : semi_norm_form_np ] in section [ wp ] for more information on how this can be done .",
    "denote the obtained word by @xmath7 .",
    "the word @xmath7 is the product of a positive and a negative word : @xmath76 . by induction on",
    "@xmath77 one can show that both @xmath15 and @xmath48 satisfy the condition ( [ eq : condition ] )",
    ".    then we find normal forms for words @xmath15 and @xmath48 using relations of @xmath38 ( for @xmath15 move letters with smaller indices to the left of letters with bigger indices , and for @xmath48 move letters with smaller indices to the right of letters with bigger indices ) . by induction on the number of operations",
    "thus performed , one can show that the obtained words @xmath78 and @xmath79 satisfy the condition ( [ eq : condition ] ) .",
    "therefore , the word @xmath80 is a seminormal form of @xmath73 satisfying the condition ( [ eq : condition ] ) .",
    "finally , we remove those pairs of generators in @xmath81 that contradict the property ( nf2 ) ( we refer the reader to our algorithm [ al : semi_norm_form_erase ] for more information ) . again , by induction on the number of  bad pairs \" , one can show that the result will satisfy the condition ( [ eq : condition ] ) .",
    "therefore , @xmath73 belongs to @xmath51 , i.e. , @xmath51 is closed under multiplication , and therefore , @xmath51 is a subgroup .",
    "now we show that the set of words @xmath82 generates the subgroup @xmath51 .",
    "elements @xmath83 clearly belong to @xmath51 . to show the inclusion @xmath84",
    ", we construct the schreier graph of @xmath85 ( depicted in figure [ fi : schreier_graph ] ) and see that any word from @xmath51 belongs to the subgroup on the right .     the schreier graph of the subgroup @xmath86 .",
    "the black dot denotes the right coset corresponding to @xmath87 . ]",
    "now we give a formal description of the protocol based on the decomposition problem mentioned in the introduction .    * ( 0 ) * fix two positive integers @xmath88 and a word @xmath89 .",
    "* ( 1 ) * alice randomly selects private elements @xmath90 and @xmath91 .",
    "then she reduces the element @xmath92 to the normal form and sends the result to bob .    * ( 2 ) * bob randomly selects private elements @xmath93 and @xmath94 . then he reduces the element @xmath35 to the normal form and sends the result to alice .    * ( 3 ) * alice computes @xmath95 , and bob computes @xmath96 . since @xmath27 in @xmath38 , one has @xmath28 ( as an element of @xmath38 ) , which is now alice s and bob s common secret key .",
    "in practical key exchange we suggest to choose the following parameters .    * ( 1 ) * select ( randomly and uniformly ) the parameter @xmath97 from the interval @xmath98 $ ] and the parameter @xmath67 from the set @xmath99 .    * ( 2 ) * select the  base \" word @xmath7 as a product of generators @xmath100 and their inverses .",
    "this is done the following way .",
    "we start with the empty word @xmath101 .",
    "when we have a current word @xmath102 , we multiply it on the right by a generator from @xmath103 and compute the normal form of the product .",
    "the obtained word is denoted by @xmath104 .",
    "we continue this process until the obtained word @xmath104 has length @xmath67 .    *",
    "( 3 ) * select @xmath105 and @xmath106 as products of words from @xmath107 and their inverses .",
    "this is done essentially the same way as above for @xmath7 .",
    "we start with the empty word @xmath108 .",
    "let @xmath109 be the currently constructed word of length less than @xmath67 .",
    "we multiply @xmath109 on the right by a randomly chosen word from @xmath110 and compute the normal form of the product .",
    "denote the obtained normal form by @xmath111 .",
    "continue this process until the obtained word @xmath111 has length @xmath67 .    *",
    "( 4 ) * select @xmath112 and @xmath113 as products of generators from @xmath114 and their inverses . to do that ,",
    "start with the empty word @xmath101 .",
    "multiply a current word @xmath102 on the right by a generator from @xmath103 and compute the normal form of the product .",
    "denote the obtained word by @xmath104 .",
    "continue this process until the obtained word @xmath104 has length @xmath67 .",
    "we would like to point out that the key space in the proposed scheme is exponential in @xmath67 ; it is easy to see that @xmath115 .",
    "the parameters above were chosen in such a way to prevent a length - based attack .",
    "note that for thompson s group , a length - based attack could be a threat since the normal form of any element represents a geodesic in the cayley graph of @xmath38 .",
    "since ideas behind length - based attacks were never fully described , we present below a typical algorithm ( adapted to our situation ) implementing such an attack ( algorithm [ al : length_attack ] ) .",
    "define a directed labelled graph @xmath116 as follows :    * the set of vertices @xmath117 corresponds to the set of all elements of the group @xmath38 . *",
    "the set of edges @xmath118 contains edges @xmath119 such that @xmath120 in the group @xmath38 , with labels of two types : * * @xmath121 , where @xmath122 . *",
    "* @xmath123 , where @xmath124 .    for an element @xmath125",
    "denote by @xmath126 the connected component of @xmath127 containing @xmath7 . from the description of the protocol",
    "it follows that @xmath7 and the element @xmath128 transmitted by alice to bob belong to @xmath129 , and breaking alice s key is equivalent to finding a label of a path from @xmath7 to @xmath81 in @xmath126 .    to test our protocol , we performed a series of experiments .",
    "we randomly generated keys ( as described above ) and ran algorithm [ al : length_attack ] ( see below ) on them .",
    "[ al : length_attack ] keeps constructing @xmath126 and @xmath130 until a shared element is found .",
    "the sets @xmath131 and @xmath132 in the algorithm accumulate constructed parts of the graphs @xmath133 and @xmath130 .",
    "the sets @xmath134 and @xmath135 are called the sets of marked vertices and are used to specify vertices that are worked out .    _ ( length - based attack ) _ [ al : length_attack ] + input .",
    "the original public word @xmath7 and the word @xmath81 transmitted by alice .",
    "a pair of words @xmath136 , @xmath137 such that @xmath138",
    ". + initialization . put @xmath139 , @xmath140 , @xmath141 , @xmath142",
    ". + computations .    1 .",
    "find a shortest word @xmath143 .",
    "2 .   multiply @xmath144 by elements @xmath110 on the left and by elements @xmath103 on the right and add each result into @xmath131 with the edges labelled accordingly .",
    "3 .   add @xmath144 into @xmath145 .",
    "4 .   perform the steps a ",
    "c with @xmath146 and @xmath147 replaced by @xmath132 and @xmath148 , respectively .",
    "5 .   if @xmath149 then goto a. 6 .",
    "if there is @xmath150 then find a path in @xmath131 from @xmath7 to @xmath151 and a path in @xmath132 from @xmath151 to @xmath81 .",
    "concatenate them and output the label of the result .",
    "we performed a series of tests implementing this length - based attack ; in each test we let the program to run overnight .",
    "none of the programs gave a result , i.e. , the success rate of the length - based attack in our tests was 0 .",
    "in this section , we show that the time complexity of reducing a word of length @xmath48 to the normal form in thompson s group @xmath38 is @xmath49 , i.e. , is almost linear in @xmath48 .",
    "our algorithm is in two independent parts : first we reduce a given word to a seminormal form ( algorithm [ al : semi_norm_form2 ] ) , and then further reduce it to the normal form by eliminating  bad pairs \" ( algorithm [ al : semi_norm_form_erase ] ) .",
    "we also note that crucial for algorithm [ al : semi_norm_form2 ] is algorithm [ al : semi_norm_form ] which computes a seminormal form of a product of two seminormal forms .",
    "our strategy for computing a seminormal form of a given @xmath125 is therefore recursive (  divide and conquer \" ) : we split the word @xmath7 into two halves : @xmath152 , then compute seminormal forms of @xmath153 and @xmath154 , and then use algorithm",
    "[ al : semi_norm_form ] to compute a seminormal form of @xmath7 .",
    "let us denote by @xmath156 the normal form for @xmath157 ; it is unique for a given element of @xmath38 . recall that we say that a word @xmath7 is in _ seminormal form",
    "_ if it is of the form ( [ eq : norm_form1 ] ) and satisfies ( nf1 ) ( see the introduction ) .",
    "a seminormal form is not unique . as usual , for a word @xmath7 in the alphabet @xmath158 by @xmath151 we denote the corresponding freely reduced word .",
    "the first part is achieved ( lemma [ le : r_term ] ) by using the following rewriting system ( for all pairs @xmath160 such that @xmath161 ) : @xmath162 and , additionally , for all @xmath163 @xmath164 we denote this system of rules by @xmath165 .",
    "it is straightforward to check ( using the confluence test , see ( * ? ? ?",
    "* proposition 3.1 ) ) that @xmath165 is confluent .",
    "the following lemma is obvious .",
    "let us now examine the action of @xmath165 more closely .",
    "this action is similar to sorting a list of numbers , but with two differences : indices of generators may increase , and some generators may disappear .    by lemma [ le : r_term ] , for any word @xmath7 in generators of @xmath38 ,",
    "the final result of rewrites by @xmath165 is a seminormal form .",
    "therefore , to compute a seminormal form we implement rewrites by @xmath165 .",
    "we do it in a special manner in algorithm [ al : semi_norm_form ] in order to provide the best performance . for convenience we introduce a parametric function @xmath166 defined on the set of all words in the alphabet @xmath167 by @xmath168        consider first the case where a word @xmath7 is a product of @xmath153 and @xmath154 given in seminormal forms .",
    "let @xmath172 and @xmath173 , where @xmath174 and @xmath175 ( @xmath176 ) are the positive and negative parts of @xmath177 . clearly , one can arrange the rewriting process for @xmath178 by @xmath165 the following way :    1 .",
    "rewrite the subword @xmath179 of @xmath7 to a seminormal form @xmath180 .",
    "denote by @xmath181 the obtained result .",
    "2 .   rewrite the positive subword @xmath182 of @xmath81 to a seminormal form @xmath15 .",
    "denote by @xmath183 the obtained result .",
    "3 .   rewrite the negative subword @xmath184 of @xmath185 to a seminormal form @xmath48 .",
    "denote by @xmath186 the obtained result .",
    "[ al : semi_norm_form_np]_(seminormal form of a product of negative and positive seminormal forms ) _ + signature . @xmath190 .",
    "seminormal forms @xmath48 and @xmath15 ( where @xmath191 and @xmath192 ) , and numbers @xmath193 .",
    "seminormal form @xmath7 such that @xmath194 .",
    "+ computations .    1 .   if @xmath195 or @xmath196 then output a product @xmath197 .",
    "2 .   if @xmath198 then 1 .   compute @xmath199 .",
    "output @xmath7 .",
    "3 .   if @xmath200 then 1 .   compute @xmath201 .",
    "2 .   output @xmath202 .",
    "4 .   if @xmath203 then 1 .   compute @xmath204 .",
    "2 .   output @xmath205 .",
    "[ le : merging_correct_np ] for any seminormal forms @xmath48 and @xmath15 ( where @xmath206 and @xmath207 ) and numbers @xmath193 the output @xmath208 of algorithm [ al : semi_norm_form_np ] is a seminormal form for @xmath209 .",
    "furthermore , the time complexity required to compute @xmath7 is bounded by @xmath210 for some constant @xmath211 .    since in each iteration",
    "we perform the constant number of elementary steps and in each subsequent iteration the sum @xmath212 is decreased by one , the time complexity of algorithm [ al : semi_norm_form_np ] is linear .",
    "we prove correctness of algorithm",
    "[ al : semi_norm_form_np ] by induction on @xmath212 .",
    "assume that @xmath213 .",
    "then at step a ) we get output @xmath214 which is an empty word .",
    "clearly , such @xmath7 is a seminormal form for @xmath197 , so the base of induction is done .",
    "assume that @xmath215 and for any shorter word the statement is true .",
    "consider four cases .",
    "if @xmath216 or @xmath217 then one of the words is trivial and , obviously , the product @xmath197 is a correct output for this case .",
    "if @xmath198 then @xmath218 cancels out inside of the product @xmath219 , and by the inductive assumption we are done .",
    "if @xmath200 then @xmath220 is the smallest index in @xmath219 and therefore , using @xmath165 , the word @xmath209 can be rewritten the following way : @xmath221 note that since @xmath220 is the smallest index in @xmath209 , the smallest index in @xmath222 is not less than @xmath220 . by the inductive assumption",
    ", @xmath7 is a seminormal form for @xmath223 .",
    "therefore , @xmath224 and it is a seminormal form .      using ideas from algorithm [ al : semi_norm_form_np ] one can easily implement an algorithm merging positive words and an algorithm merging negative words , so that statements similar to lemma [ le : merging_correct_np ] would hold .",
    "we will denote these two algorithms by @xmath225 and @xmath226 , respectively .",
    "thus , computation of a seminormal form of a product of two arbitrary seminormal forms has the following form .",
    "[ al : semi_norm_form]_(seminormal form of a product of seminormal forms ) _ + signature . @xmath227 .",
    "seminormal forms @xmath153 and @xmath154 .",
    "seminormal form @xmath7 such that @xmath228 .",
    "+ computations .    1 .",
    "represent @xmath177 as a product of a positive and negative word ( @xmath172 and @xmath229 ) .",
    "2 .   compute @xmath230 and represent it as a product of a positive and negative word @xmath231 .",
    "3 .   compute @xmath232 .",
    "4 .   compute @xmath233 .",
    "output @xmath234 .",
    "[ le : merging_correct ] for any pair of seminormal forms @xmath153 and @xmath154 the word @xmath235 is a seminormal form of the product @xmath236 .",
    "moreover , the time - complexity of computing @xmath7 is bounded by @xmath237 for some constant @xmath211 .",
    "[ al : semi_norm_form2 ] _ ( seminormal form ) _ + signature . @xmath238 .",
    "a word @xmath7 in generators of @xmath38 .",
    "+ output . a seminormal form @xmath144 such that @xmath239 in @xmath38",
    ". + computations .",
    "let @xmath7 be a word in generators of @xmath38 .",
    "the output of algorithm [ al : semi_norm_form2 ] on @xmath7 is a seminormal form for @xmath7 .",
    "the number of operations required for algorithm [ al : semi_norm_form2 ] to terminate is @xmath245 , where @xmath211 is a constant independent of @xmath7 .",
    "the first statement can be proved by induction on the length of @xmath7 .",
    "the base of the induction is the case where @xmath246 . in this case",
    "@xmath7 is already in a seminormal form , and the output is correct .",
    "the induction step was proved in lemma [ le : merging_correct ] .",
    "to prove the second statement we denote by @xmath247 the number of steps required for algorithm",
    "[ al : semi_norm_form2 ] to terminate on an input of length @xmath48 . then clearly @xmath248 where the last summand @xmath249 is the complexity of merging two seminormal forms with the sum of lengths at most @xmath250 .",
    "it is an easy exercise to show that in this case @xmath251 .",
    "[ le : bad_pair_removal ] let @xmath252 be a seminormal form , @xmath253 be the pair of generators in @xmath7 which contradicts ( nf2 ) , where @xmath254 and @xmath255 are maximal with this property .",
    "let @xmath256 then @xmath81 is in a seminormal form and @xmath257 .",
    "moreover , if @xmath258 is the pair of generators in @xmath81 which contradicts ( nf2 ) ( where @xmath254 and @xmath255 are maximal with this property ) , then @xmath259 and @xmath260 .",
    "it follows from the definition of ( nf2 ) and seminormal forms that all indices in @xmath261 are greater than @xmath262 and , therefore , indices in @xmath263 are greater than @xmath264 .",
    "now it is clear that @xmath81 is a seminormal form .",
    "then doing rewrites opposite to rewrites from @xmath165 we can get the word @xmath81 from the word @xmath7 .",
    "thus , @xmath265 .",
    "there are two possible cases : either @xmath266 and @xmath267 or @xmath259 and @xmath260 .",
    "we need to show that the former case is , in fact , impossible .",
    "assume , by way of contradiction , that @xmath266 and @xmath267 . now observe that if @xmath253 is a pair of generators in @xmath7 contradicting ( nf2 ) , then @xmath268 contradicts ( nf2 ) in @xmath269 .",
    "therefore , inequalities @xmath266 and @xmath267 contradict the choice of @xmath254 and @xmath255 .    by lemma [ le : bad_pair_removal ]",
    "we can start looking for bad pairs in a seminormal form starting from the middle of a word .",
    "the next algorithm implements this idea .",
    "the algorithm is in two parts .",
    "the first part finds all  bad \" pairs starting from the middle of a given @xmath7 , and the second part applies @xmath169 to segments where it is required .",
    "a notable feature of algorithm [ al : semi_norm_form_erase ] is that it does not apply the operator @xmath270 immediately ( as in @xmath81 of lemma [ le : bad_pair_removal ] ) when a bad pair is found , but instead , it keeps the information about how indices must be changed later .",
    "this information is accumulated in two sequences ( stacks ) , one for the positive subword of @xmath7 , the other one for the negative subword of @xmath7",
    ". also , in algorithm [ al : semi_norm_form_erase ] , the size of stack @xmath271 ( or @xmath272 ) equals the length of an auxiliary word @xmath153 ( resp .",
    "@xmath154 ) . therefore , at step b ) , @xmath273 ( resp .",
    "@xmath274 ) is defined if and only if @xmath275 ( resp .",
    "@xmath276 ) is defined .",
    "[ al : semi_norm_form_erase]_(erasing bad pairs from a seminormal form ) _ + signature . @xmath277 .",
    "+ input . a seminormal form @xmath278 .",
    "+ output . a word @xmath7 which is the normal form of @xmath144 .",
    "+ initialization .",
    "let @xmath279 , @xmath280 , @xmath281 , @xmath282 , and @xmath283 .",
    "let @xmath284 and @xmath285 be the positive and negative parts of @xmath144 .",
    "additionally , we set up two empty stacks @xmath271 and @xmath272 . + computations .    1 .",
    "let the current @xmath284 and @xmath285 .",
    "2 .   let @xmath273 be the leftmost letter of @xmath153 , @xmath274 the rightmost letter of @xmath154 , and @xmath286 ( @xmath176 ) the top element of @xmath287 , i.e. , the last element that was put there .",
    "if any of these values does not exist ( because , say , @xmath287 is empty ) , then the corresponding variable is not defined . 1 .   if @xmath288 and ( @xmath196 or @xmath289 ) , then : 1 .",
    "multiply @xmath153 on the left by @xmath290 ( i.e. @xmath291 ) ; 2 .   erase @xmath290 from @xmath292 ; 3 .   push @xmath293 into @xmath271 ; 4 .",
    "2 .   if @xmath294 and ( @xmath195 or @xmath295 ) , then : 1 .   multiply @xmath154 on the right by @xmath296 ( i.e. @xmath297 ) ; 2 .   erase @xmath296 from @xmath298 ; 3 .   push @xmath293 into @xmath272 ; 4 .",
    "if @xmath299 and ( the numbers @xmath300 and @xmath301 ( those that are defined ) are not equal to @xmath302 or @xmath303 ) , then : 1 .   erase @xmath290 from @xmath292 ; 2 .",
    "erase @xmath296 from @xmath298 ; 3 .   if @xmath271 is not empty , increase the top element of @xmath271 ; 4 .",
    "if @xmath272 is not empty , increase the top element of @xmath272 ; 5 .",
    "4 .   if 1)-3 ) are not applicable ( when @xmath299 and ( one of the numbers @xmath300 , @xmath301 is defined and is equal to either @xmath302 or @xmath303 ) ) , then : 1 .",
    "multiply @xmath153 on the left by @xmath290 ( i.e. @xmath291 ) ; 2 .   multiply @xmath154 on the right by @xmath296 ( i.e. @xmath297 ) ; 3 .",
    "erase @xmath290 from @xmath292 ; 4 .",
    "erase @xmath296 from @xmath298 ; 5 .   push @xmath293 into @xmath271 ; 6 .",
    "push @xmath293 into @xmath272 ; 7 .",
    "if @xmath292 or @xmath298 is not empty then goto 1 ) .",
    "while @xmath153 is not empty : 1 .",
    "let @xmath304 be the first letter of @xmath153 ( i.e. @xmath305 ) ; 2 .",
    "take ( pop ) @xmath306 from the top of @xmath271 and add to @xmath307 ( i.e. @xmath308 ) ; 3 .",
    "multiply @xmath292 on the right by @xmath309 ( i.e. @xmath310 ) ; 4 .",
    "erase @xmath304 from @xmath153 .",
    "while @xmath154 is not empty : 1 .",
    "let @xmath311 be the last letter of @xmath154 ( i.e. @xmath312 ) ; 2 .   take ( pop ) @xmath306 from the top of @xmath272 and add to @xmath313 ( i.e. @xmath314 ) ; 3 .   multiply @xmath298 on the left by @xmath315 ( i.e. @xmath316 ) ; 4 .",
    "erase @xmath311 from @xmath154 .",
    "return @xmath317 .    the output of algorithm",
    "[ al : semi_norm_form_erase ] is the normal form @xmath7 of a seminormal form @xmath144 . the number of operations required for algorithm",
    "[ al : semi_norm_form_erase ] to terminate is bounded by @xmath318 , where @xmath319 is a constant independent of @xmath144 .",
    "the first statement follows from lemma [ le : bad_pair_removal ] .",
    "the time estimate is obvious from the algorithm since the words @xmath320 are processed letter - by - letter , and no letter is processed more than once .",
    "d. hofheinz and r. steinwandt , _ a practical attack on some braid group based cryptographic primitives _ , in public key cryptography , 6th international workshop on practice and theory in public key cryptography , pkc 2003 proceedings , y.g .",
    "desmedt , ed . ,",
    "lecture notes in computer science * 2567 * , pp . 187198 , springer , 2002 .",
    "j. hughes and a.  tannenbaum , _ length - based attacks for certain group based encryption rewriting systems _ , workshop seci02 securit de la communication sur intenet , september 2002 , tunis , tunisia .",
    "+ http://www.storagetek.com/hughes/    k. h. ko , s. j. lee , j. h. cheon , j. w. han , j. kang , c. park , _ new public - key cryptosystem using braid groups _ , advances in cryptology  crypto 2000 ( santa barbara , ca ) , 166183 , lecture notes in comput .",
    "1880 * , springer , berlin , 2000 .",
    "v. shpilrain and a. ushakov , _ the conjugacy search problem in public key cryptography : unnecessary and insufficient _ , applicable algebra in engineering , communication and computing , to appear ."
  ],
  "abstract_text": [
    "<S> recently , several public key exchange protocols based on symbolic computation in non - commutative ( semi)groups were proposed as a more efficient alternative to well established protocols based on numeric computation . </S>",
    "<S> notably , the protocols due to anshel - anshel - goldfeld and ko - lee et al . exploited the _ conjugacy search problem _ in groups , which is a ramification of the discrete logarithm problem . </S>",
    "<S> however , it is a prevalent opinion now that the conjugacy search problem alone is unlikely to provide sufficient level of security no matter what particular group is chosen as a platform .    in this paper </S>",
    "<S> we employ another problem ( we call it the _ decomposition problem _ ) , which is more general than the conjugacy search problem , and we suggest to use r. thompson s group as a platform . </S>",
    "<S> this group is well known in many areas of mathematics , including algebra , geometry , and analysis . </S>",
    "<S> it also has several properties that make it fit for cryptographic purposes . </S>",
    "<S> in particular , we show here that the word problem in thompson s group is solvable in almost linear time . </S>"
  ]
}