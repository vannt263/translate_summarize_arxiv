{
  "article_text": [
    "motion estimation ( me ) and motion compensation ( mc ) are the fundamental techniques of video coding to remove the temporal redundancy between video frames .",
    "block matching - based me and block - based mc have been integrated into the reference softwares of almost all the existing video coding standards , including the currently widely adopted h.264/mpeg-4 avc @xcite and the state - of - the - art h.265/mpeg - h high efficiency video coding ( hevc ) @xcite .",
    "the underlying model of block - based mc is translational motion model , which is too simple to efficiently describe the complex motions in natural videos , such as rotation and zooming . during the development of the video coding standards",
    ", many efforts have been made to characterize the complex motions .",
    "for example , partitioning blocks into smaller ones can handle complex motions to some extent @xcite , but may incur more overhead bits for block partitions and more motion vectors ( mvs ) .",
    "therefore , since the translational motion model has not been changed , the standard - based video coding framework is unable to represent the complex motions such as rotation and zooming efficiently .    in the year of as early as 1993 , seferidis _ et al . _",
    "@xcite pointed out that high - order motion models , such as affine , bilinear , and perspective motion models , were more efficient to characterize the complex motions than the translational one .",
    "among all the high - order motion models introduced in @xcite , affine motion model has received the most attention of research due to its simplicity .",
    "previous work on affine motion model can be divided into two categories : global affine motion model and local affine motion model .    for global affine motion model @xcite ,",
    "usually several groups of model parameters are used to build global affine motion models between two frames , and then each reference frame is warped several times using different model parameters to generate multiple warped references . however , due to a limited number of global affine motion models , such methods are less capable of providing accurate motion parameters for every local motion region . besides",
    ", the increased number of reference frames due to the warped ones will increase the me computations significantly .    local affine motion model can be further categorized into mesh - based and generalized block - based . in the mesh - based methods @xcite ,",
    "the vertices of the mesh are known as control points , whose mvs are used to determine the motions of all the other pixels through locally variant motion models .",
    "since the control point is shared by the neighboring blocks , it is difficult for us to determine the mvs of the control point through me in a block - based rate - distortion optimization ( rdo ) process due to the spatial dependency between neighboring blocks .",
    "therefore , the mesh - based methods can not be well integrated into the modern video coding standards .    in the generalized block - based methods @xcite , each block can determine its own affine motion parameters .",
    "this is consistent with the standardized video coding framework , only replacing mvs by affine motion parameters for mc .",
    "generalized block - based affine motion model is intuitively promising to better characterize complex motions , thereby improving coding efficiency .",
    "however , both me and mc under affine motion models are significantly more complex than the traditional block matching - based me and block - based mc .",
    "existing works have not achieved a good balance between coding efficiency and coding complexity . some of them failed to achieve significantly better rate - distortion ( r - d ) performance , whilst others had too much complexity .    in this paper",
    ", we propose a video coding framework using the approach of generalized block - based affine motion model , which can achieve a better trade - off between coding efficiency and computational complexity .",
    "the framework can be seamlessly integrated into the modern video coding standards , e.g. , hevc . in summary",
    ", the proposed framework mainly has the following key contributions :    * a four - parameter affine motion model is studied in this paper .",
    "different from previous works that adopted the six - parameter model , the four - parameter model has only four degrees of freedom or equivalently needs only two mvs to represent .",
    "it saves two parameters for each block",
    ". meanwhile , this model can accurately characterize rotation , zooming , translation , and any combination of them .",
    "therefore , it can handle most of the complex motions in natural videos . * to efficiently encode affine motion parameters , we propose two techniques : advanced affine motion vector prediction combined with fast affine me , and affine model merge .",
    "the proposed fast affine me algorithm iteratively updates the two mvs of a block according to gradient descent .",
    "it was originally proposed for the six - parameter affine motion model in our previous work @xcite , and extended for the four - parameter model herein .",
    "the proposed gradient - based fast affine me algorithm can converge very fast , thus can reduce the encoding complexity significantly .",
    "in addition , the proposed affine model merge tries to reuse the affine motion parameters of neighboring blocks instead of regenerating a new model from the mvs of the neighbors .",
    "the affine model merge can make full use of the motion model correlation between neighboring blocks , and thus can improve the coding efficiency .",
    "* we also propose two fast affine mc techniques to reduce both the encoding and decoding complexities .",
    "a one - step sub - pixel interpolation filter which can decrease the interpolation times significantly is developed to replace the previous two - step sub - pixel interpolation .",
    "moreover , the block - based mc rather than the pixel - based mc is adopted for acceleration , together with an adaptive choice of block size to ensure interpolation precision .",
    "we perform experiments to verify the efficiency of the proposed video coding framework integrated with hevc .",
    "compared to hevc main profile , our proposed techniques altogether can achieve significant bitrate savings while maintain computational efficiency .",
    "this paper is organized as follows . in section [ sec::related work ] , we will give a brief review of the related works . the proposed low - complexity four - parameter affine motion model",
    "based framework will be introduced in section [ sec::affine algorithm ] .",
    "the experimental results are shown in section [ sec::experimental results ] .",
    "finally , section [ sec::conclusions ] concludes this paper .",
    "the affine motion model utilized in me and mc can be divided into two categories : global affine motion model and local affine motion model . for global affine motion model ,",
    "wiegand _ et al . _",
    "@xcite proposed to use several global affine motion models to generate several warped reference frames .",
    "the warped reference frames were used to obtain a better prediction , and the index of the warped reference frame was needed to be transmitted to the decoder . to reduce the overhead bitrate , li _ et al . _",
    "@xcite developed a 4-d vector quantizer to code the affine motion parameters more efficiently .",
    "besides , yu _",
    "@xcite proposed to use only one global affine motion model , and the mvs of the salient features between the original frame and reference frame were used to determine the affine motion parameters to generate a warped reference frame .",
    "however , the global affine motion model based methods can not provide accurate affine motion parameters for each local motion region .",
    "the local affine motion model can be utilized in two manners : mesh - based methods and generalized block - based methods .",
    "nakaya and harashima @xcite firstly proposed to use 2-d mesh to perform mc and designed a simple method to determine the mvs of the control points .",
    "@xcite proposed to add control points hierarchically to better determine the motion models of each block .",
    "al - regib _ et al .",
    "_ @xcite further developed the method and proposed a content - based irregular mesh to better describe the object boundary .",
    "however , due to the various block sizes in modern video coding framework , the problem of determining the mvs of control points through rdo remains difficult .    besides the mesh - based methods ,",
    "the generalized block - based methods have also been studied by many researchers .",
    "@xcite considered to derive a better prediction block through affine motion model using the surrounding translational mvs . besides , cheung and siu @xcite proposed to use the neighboring information to estimate the affine motion parameters of the current block and added an affine mode into the mode decision process .",
    "then narroschke and swoboda @xcite found that the affine motion model was more suitable for the large blocks introduced in hevc .",
    "_ @xcite extended the work in @xcite for hevc and designed the affine skip / direct mode to improve the coding efficiency .",
    "this work was further developed to a quite complex affine mc framework and many coding modes including affine skip / direct , affine merge , and affine inter were designed to fully exploit the motion correlation between neighboring blocks @xcite .",
    "moreover , heithausen and vorwerk @xcite investigated and compared the performance of different kinds of high - order motion models in hevc . also , with the development of the merge mode @xcite in hevc , chen _ et al . _",
    "@xcite further developed the affine skip / direct mode to incorporate with the merge mode for the translational motion model and proposed to add some temporal motion candidates into the candidate lists .",
    "however , the previous affine merge schemes always attempted to regenerate a new affine motion model through the motion information of the neighboring blocks . since the neighboring blocks may correspond to different objects or have totally different motion models",
    ", the regenerated affine motion model may be inaccurate .",
    "there is a class of local affine motion modeling algorithms designed specifically for the zooming motion in videos .",
    "@xcite proposed to use the zooming model to generate a better motion vector predictor ( mvp ) for the current block .",
    "since this work only generated a better mvp , the r - d performance improvement was limited .",
    "the algorithm in @xcite further developed a zooming motion model to better characterize the zooming motion and proposed to use linear regression to estimate the mv of the current block from the mvs of the neighboring blocks .",
    "besides , po _ et al . _",
    "@xcite proposed to generate multiple zooming references using a group of model parameters and designed a sub - sampled block - matching algorithm to reduce the complexity of me over a number of reference frames .",
    "@xcite proposed a 3-d diamond pattern search to reduce the number of search points during me .",
    "one critical issue , which hinders the adoption of affine as well as other high - order motion models , is the significant increase of me complexity . in fact , in the modern video coding framework , the me process always takes the majority of the encoding time even for translational motion model . due to the high complexity of me ,",
    "the fast me algorithms @xcite have been hot research topics for a long time . for example , the famous enhanced predictive zonal search ( epzs ) @xcite algorithm was adopted into the h.264/avc reference software .",
    "hevc reference software integrated a so - called test zone search ( tzs ) @xcite method which was a further development of epzs .",
    "both methods show quite good trade - offs between the r - d performance and encoding complexity for the me of the translational motion model . however , it is not easy to apply them to high - order motion models , for which more parameters need to be determined through me .",
    "although there were also some algorithms trying to design fast me algorithm for zooming motion @xcite , it is not easy to extend those algorithms to more general cases . therefore , there is an urgent need to design a fast me algorithm for high - order motion models .",
    "the proposed four - parameter affine mc framework will be introduced from three aspects .",
    "firstly , we will introduce the derivation and representation of the proposed four - parameter affine motion model .",
    "secondly , the two methods to encode the affine mvs will be introduced in detail .",
    "thirdly , we will introduce the coding tools to speed up the mc process .",
    "the typical six - parameter affine motion model can be described as @xmath0 where @xmath1 , @xmath2 , @xmath3 , @xmath4 , @xmath5 , and @xmath6 are the six affine motion parameters .",
    "the @xmath7 and @xmath8 are the coordinates of the same pixel before and after the transform of the affine motion model .",
    "in essence , an affine transform is any transform that preserves lines and parallelism .",
    "therefore , the affine motion model can characterize translation , rotation , zooming , shear mapping , and so on .",
    "however , the most common motions in daily videos only include six kinds of typical camera motions ( camera track , boom , pan , tilt , zoom , and roll ) and the typical object motions ( translation , rotation , and zooming ) , for which six model parameters are more than necessary .",
    "it should be noted that the rotation here means the object rotates in a 2-d plane that is parallel with the camera .",
    "also , the object zooming can be characterized using an affine motion model only if the relative distance between the object and camera keeps unchanged or the object has a planar surface .",
    "since this paper focuses on the local affine model , we can assume that a local block has a planar surface as long as the block is small enough .",
    "in the following , the typical object motions will be used as examples to explain the physical interpretation of the proposed four - parameter affine motion model .",
    "in fact , as shown in fig.[four - parameter affine model ] ( a ) , if only the combination of rotation and translation is needed to be characterized , the relationship between the coordinates of the same pixel before and after the transformation can be described as @xmath9 where @xmath10 is the rotation angle .",
    "besides , as shown in fig .",
    "[ four - parameter affine model ] ( b ) , if only the combination of zooming and translation is to be characterized , the relationship can be described as @xmath11 where @xmath12 is the zooming factor in both @xmath13 and @xmath14 directions , respectively .    both the combinations of rotation / zooming and translation need three parameters to characterize . if we combine the rotation , zooming , and translation together , four parameters will be needed and the relationship can be described as @xmath15 if we replace @xmath16 and @xmath17 with @xmath18 and @xmath2 , ( [ rotation and zooming model ] ) can be rewritten as @xmath19 where @xmath20 and @xmath21 are the horizontal and vertical components of mv for the position @xmath7 .",
    "( [ four parameter model ] ) is the four - parameter affine motion model used in this paper to accurately characterize the combination of rotation , zooming , and translation .    comparing the six - parameter affine motion model in ( [ six parameter model ] ) with the four - parameter affine motion model in ( [ four parameter model ] ) , it can be obviously seen that fewer parameters will be calculated under the four - parameter affine motion model for each block thus the decoding complexity can be slightly reduced . besides , the encoding complexity will also be reduced since the proposed fast affine me algorithm which will be introduced later on can converge faster under the four - parameter affine motion model .",
    "last but not least , the four - parameter affine motion model can lead to better r - d performance for most natural sequences due to the bits savings of header information .          according to ( [ four parameter model ] ) , there are four unknown model parameters . instead of these four parameters",
    ", we can also use two mvs to equivalently represent the model because using mvs is more consistent with existing video coding framework .",
    "those two mvs can be chosen at any locations of the current block for representing the motion model . in this paper , we choose the mvs at the top left and top right locations of the current block , because these two locations are adjacent to the previously reconstructed blocks , and the corresponding mvs can be more accurately predicted . in a typical @xmath22 block as shown in fig .",
    "[ affine_model ] , if we denote the mv of top left pixel @xmath23 as @xmath24 and the mv of top right pixel @xmath25 as @xmath26 , the four unknown model parameters @xmath1 , @xmath2 , @xmath3 , and @xmath6 can be solved as follows according to ( [ four parameter model ] ) .",
    "@xmath27 then ( [ four parameter model ] ) can be expressed as a linear combination of @xmath24 and @xmath26 , @xmath28 where @xmath29 , @xmath30 , @xmath31 , and @xmath32 are equal to @xmath33 , @xmath34 , @xmath35 , and @xmath36 , respectively . @xmath37 and @xmath38 are the horizontal and vertical parts of @xmath39 .",
    "it should be noted that @xmath29 , @xmath30 , @xmath31 , and @xmath32 are all related to the coordinate of the current pixel .",
    "( [ linear model ] ) can also be written in a vector form , @xmath40 where @xmath41 , @xmath42 @xmath43\\ ] ] eq .",
    "( [ vector form ] ) shows that @xmath24 and @xmath26 control the motions of all the pixels in a block .",
    "if we know the motions of all the pixels in the block , then the mc process can be performed and the corresponding prediction block can be obtained . therefore , the key problem becomes how to determine @xmath24 and @xmath26 . in this paper , the precisions of both @xmath24 and @xmath26",
    "are set as @xmath44 pixel to get a good trade - off between the affine motion model accuracy and overhead bits .",
    "this is also consistent with hevc .",
    "there are usually two methods to determine the translational mv in a typical encoder of hevc ( hm or x265 ) : amvp mode combined with a fast me algorithm and merge mode .",
    "the amvp mode constructs an mvp candidate list for the translational mv and the me process is used to get the optimal mv for mc .",
    "the merge mode constructs a merge candidate list and reuses the motion information of the neighboring blocks .",
    "analogously , we also design two methods in this paper to determine the affine mvs : advanced affine motion vector prediction ( aamvp ) mode combined with a fast affine me method and affine model merge ( amm ) mode .",
    "similar to the amvp mode , the aamvp mode tries to obtain a candidate list of mv tuples to predict @xmath45 .",
    "the construction of aamvp candidate list is performed in three steps .",
    "firstly , we find the available mvp candidates for @xmath24 , @xmath26 , and @xmath46 ( the mv of the bottom left corner ) separately . as shown in fig .",
    "[ affine mvp ] , the mvs of neighboring blocks a , b , and c are used as the candidates for the mvp of @xmath24 , the mvs of neighboring blocks d and e are used for the mvp of @xmath26 , and the mvs of neighboring blocks f and g are used for the mvp of @xmath46 .",
    "we will use the derivation of the candidates for @xmath47 ( the mvp of @xmath24 ) as an example to explain .",
    "the availability of the mvs of blocks a , b , and c will firstly be checked ( for example , intra mode means unavailable ) . if available",
    ", we will then check whether the mvs of blocks a , b , and c are pointing to the same reference frame as the given one .",
    "if yes , the candidates for @xmath47 are found .",
    "if not , scaling operations are applied to make the mvs of blocks a , b , and c point to the same reference frame as the given one so as to obtain the candidates for @xmath47 .",
    "the derivation processes of @xmath48 and @xmath49 ( the mvp of @xmath26 and @xmath46 ) are similar to that of @xmath47 .",
    "secondly , a candidate list of mv tuples is constructed .",
    "the @xmath47 and @xmath48 are combined to get a candidate list .",
    "there are two constraints for @xmath47 and @xmath48 . on one hand , the @xmath47 and",
    "@xmath48 should not be equal since the equal @xmath47 and @xmath48 means translational motion model .",
    "on the other hand , the differences between @xmath47 and @xmath48 in both horizontal and vertical directions should not be larger than a predefined threshold .",
    "too large differences mean @xmath47 and @xmath48 are probably from different objects , which makes the combination of @xmath47 and @xmath48 in a single motion model unreasonable .",
    "the threshold is set as half of the block size in our implementation .",
    "since we may find multiple candidates through the above steps , they should be put into the candidate list in a specified order . note",
    "that , we have the following relationships between @xmath24 , @xmath26 , and @xmath46 ( refer to fig . [ affine mvp ] and eq .",
    "( [ four parameter model ] ) ) .",
    "@xmath50 these relationships can be easily converted to the following constraints for @xmath24 , @xmath26 , and @xmath46 .",
    "@xmath51 since the better mvp tuple will be the one more approximated to the mv tuple , we calculate a criterion named @xmath52 as follows . @xmath53",
    "the smaller @xmath52 value means that the combination of @xmath47 and @xmath48 is more probable to form a real affine motion model and therefore , it should be put in the relatively earlier position in the candidate list .",
    "thirdly , if the number of mv tuples in the candidate list is less than the maximum number of candidates , each component of the mv tuple set as the translational motion is added to the candidate list to guarantee parsing robustness @xcite .",
    "the maximum number of mv tuples is set as @xmath54 to be consistent with hevc amvp mode .",
    "after the above steps , we will have a candidate list of mv tuples with two candidates .",
    "after the derivation of mvp tuple candidate lists , the affine me needs to be performed to find the optimal parameters , i.e. two mvs for a block .",
    "a straightforward method is to search all the combinations of @xmath24 and @xmath26 within a predefined search range @xmath55 .",
    "however , such a method will lead to the complexity of @xmath56 since two mvs are needed to be jointly determined .",
    "huang et al .",
    "@xcite provide a simplified fast me method to optimize one mv out of the two mvs iteratively . in this case",
    ", the complexity will be reduced to @xmath57 as the two mvs are optimized independently . however , optimizing one mv out of the two mvs iteratively may be unable to achieve the optimal r - d performance . moreover , since the affine mc is rather complex , the above mentioned me algorithms are unable to achieve acceptable encoding complexity .",
    "therefore , we propose a gradient - based fast affine me algorithm which can solve the two mvs simultaneously at each iteration and converge to the optimal combination quickly",
    ". the encoding complexity will be determined by the iteration times in the proposed algorithm . and according to our empirical study , @xmath58 and @xmath59 times of iteration will be enough for the uni - directional and bi - directional prediction , respectively .",
    "therefore , the proposed algorithm can reduce the encoder complexity significantly compared with previously studied affine me algorithms .",
    "the essence of the fast affine me algorithm is to adjust @xmath24 and @xmath26 to minimize the mean square error ( mse ) between the current block and the prediction block .",
    "the start search point of affine me is the best mv tuple among mv tuples in the aamvp candidate list and the mv tuple with each component equal to the best translational motion .",
    "the mse between the current block and the prediction block can be expressed as @xmath60 where @xmath61 is a collection of all the pixels in the current block , and @xmath62 is the position of the current pixel in the current picture .",
    "@xmath63 is the current picture .",
    "@xmath64 is the reference picture .",
    "@xmath65 is the mv of position @xmath62 .",
    "define that at the @xmath66 iteration , the mv of position @xmath62 is @xmath67 .",
    "assume that the mvs in the corner positions @xmath68 will change by @xmath69 to obtain the minimum mse between the current block and the prediction block in the next iteration , then according to ( [ vector form ] ) , the change of mvs for all the pixels in the block can be expressed as @xmath70 then @xmath71 can be calculated through @xmath72 where @xmath73 is the corresponding position of @xmath62 in the reference block in the @xmath66 iteration . using the taylor s expansion and ignoring the high - order terms , we have @xmath74    as mentioned above , the optimization target is to select the best @xmath69 by minimizing the mse , @xmath75 combining ( [ picreftaylor ] ) and ( [ optimization target ] ) , we will have @xmath76 where @xmath77 is equal to @xmath78 . formula (",
    "[ optimization target final ] ) is actually an unconstrained optimization problem . by setting to zero the gradients with respect to @xmath69",
    ", we can obtain @xmath79 where @xmath80 represents the @xmath81 column of matrix @xmath82 .",
    "formula ( [ equationtosolve ] ) is actually a system of linear equations .",
    "@xmath77 can be calculated after the @xmath66 iteration by subtracting the prediction block from the original block .",
    "both @xmath82 and @xmath80 are known values according to ( [ vector form ] ) .",
    "@xmath83 is the gradient value at pixel @xmath73 in the reference picture , which can be estimated using the sobel operator as shown in eq .",
    "( [ sobel ] ) .",
    "@xmath84\\ ] ]    therefore , for each iteration , just a simple system of linear equations needs to be solved to get the @xmath85 .",
    "if all components of @xmath86 are @xmath87 after the @xmath88th iteration , the @xmath89 will be used to get the prediction block .",
    "different from the traditional fast me algorithms which can only find the best mv one by one , both @xmath24 and @xmath26 can be found out simultaneously through the proposed gradient - based fast affine me algorithm .",
    "therefore , the proposed algorithm can simultaneously guarantee the r - d performance and reduce the encoder complexity significantly .",
    "after the two affine mvs are determined , the affine mvp tuple in the affine mvp tuple list which will lead to smaller affine mvd will be used as the final affine mvp tuple and the two corresponding affine mvds will be encoded in a similar way as the mvd for the translational motion model .",
    "such a scheme will lead to about two times of bits cost per prediction unit ( pu ) since two mvds are transmitted per pu . however , since the affine motion model can improve the prediction accuracy , the number of pus will reduce significantly due to the use of large blocks , which will lead to less number of mvds and fewer bits for header information .",
    "besides , the residue bits will also decrease obviously due to the improved prediction precision brought by the affine motion model .",
    "different from the existing affine merge mode which tries to regenerate an affine motion model according to the neighboring motion information @xcite , the amm mode fully reuses the affine motion model of the neighboring blocks that also use affine mode ( including aamvp and amm mode ) .",
    "it should be emphasized that the amm mode is used only when at least one of the neighboring blocks uses affine mode .",
    "[ amm example ] gives a typical example showing the difference between the amm and existing affine merge mode . in fig .",
    "[ amm example ] , the two green squares represent two neighboring ctus . in this case ,",
    "the two ctus are within the same object that is rotating .",
    "thus , it implies that the two ctus probably share the same affine motion model parameter @xmath10 .",
    "the situation is similar for zooming motion and the zooming factor @xmath12 is the same for neighboring ctus .",
    "therefore , the reuse of the affine motion model of the neighboring blocks means we can reuse the parameters @xmath1 and @xmath2 in ( [ four parameter model ] ) since the zooming factor and rotation angle are the same for the neighboring blocks within one object .",
    "note however that the parameters c and f may be different for neighboring blocks .",
    "this is indeed the reuse of model parameters , rather than using the mvs of neighboring blocks , as previous work did @xcite . in the previous work ,",
    "the regenerated model from the neighboring red and green blocks may lead to inaccurate model parameters .    to reuse the affine motion model of the neighboring blocks",
    ", we should firstly traverse the neighboring blocks to find the blocks using affine mode .",
    "the search order of the amm candidates is a , b , c , d , and e as shown in fig .",
    "[ affine model merge ] , which is the same as the merge mode for translational motion model in hevc .",
    "if a , b , c , d , or e uses affine motion model , the candidate is added to the amm candidate lists . if no neighboring blocks use affine motion model , the amm mode will be skipped for the current block .",
    "the number of amm candidates is set as 1 to reduce the header bits for amm index .",
    "then we will use the neighboring affine motion parameters to derive the affine motion parameters of the current block . as shown in fig .",
    "[ affine model merge ] , since the top left pixel @xmath90 with motion @xmath24 and top right pixel @xmath91 with motion @xmath26 determine the affine motion parameters of the current block , we will deduce the @xmath24 and @xmath26 using the rule of the same @xmath1 and @xmath2 in neighboring blocks . in the following ,",
    "block a will be used as an example to explain the detailed deduction process .",
    "firstly , we will find the pu containing the block a and obtain the motion information of the pu : the top left pixel @xmath92 with motion @xmath46 , the top right pixel @xmath93 with motion @xmath94 , the bottom left pixel @xmath95 with motion @xmath96 .",
    "it should be noted that if block a uses affine mode , it means that @xmath46 , @xmath94 , and @xmath96 are with the same inter direction ( forward , backward , or bi - direction ) and reference index .",
    "then we can calculate the @xmath24 of the current block according to the relative position of the current position with the neighboring pu , @xmath97 then the @xmath26 of the current block can be calculated using the rule of the same @xmath1 and @xmath2 in the neighboring blocks , @xmath98 the @xmath24 and @xmath26 can be calculated in a similar way if the block b , c , d , or e uses affine mode . the amm mode with residue and amm skip mode without residue",
    "are both supported in our scheme .",
    "the complexity of affine mc mainly comes from two aspects : the times of interpolation and the complexity of each interpolation .",
    "we have mainly designed two coding tools focusing on these two aspects to speed up the affine mc process .",
    "the first one is to design a one - step sub - pixel interpolation filter to decrease the complexity of each interpolation .",
    "the second one is to use the affine interpolation - precision - based adaptive block size mc instead of pixel - based mc to decrease the times of interpolation .      to obtain the affine prediction block with non - integer mvs , for the luma component , the traditional two - step interpolation filter @xcite will first interpolate the @xmath99 pixel accuracy using discrete cosine transform based interpolation filter ( dctif ) , which is the interpolation filter for translational mc in hevc .",
    "then the bilinear interpolation will be performed if the mv is beyond @xmath99 pixel accuracy .",
    "the situation is similar for chroma component , the @xmath100 pixel accuracy is firstly interpolated using dctif and then the bilinear interpolation is applied for higher pixel accuracy .",
    "the traditional two - step interpolation method mainly has three shortcomings .",
    "firstly , the computational complexity of the traditional method is much higher compared with the translational mc . to interpolate a pixel higher than @xmath99 pixel accuracy , up to four dctif and one bilinear interpolation operations",
    "should be performed , which will bring quite significant complexity burdens to both the encoder and decoder . secondly , the bilinear interpolation filter is unable to achieve a satisfactory r - d performance for the fractional interpolation @xcite .",
    "thirdly , the arbitrary mv precision is unfriendly to the hardware implementation .    to overcome the disadvantages brought by the traditional interpolation filter",
    ", we will first determine the mv limitation precision to prevent the unfriendly arbitrary mv precision .",
    "the mv limitation precisions of luma and chroma components are set as @xmath101 to obtain a balance between r - d performance and hardware implementation .",
    "according to our empirical study , higher interpolation precision beyond @xmath101 brings out only little improvement in mc accuracy . besides",
    ", a one - step sub - pixel interpolation filter designed based on the principle of dctif is used to interpolate the @xmath101 pixel precision . since",
    "the dctif outperforms the bilinear interpolation filter in the aspect of interpolating the fractional pixels @xcite , the proposed one - step sub - pixel interpolation filter can achieve better r - d performance compared with the traditional two - step interpolation filter .",
    "this will also be verified by the experimental results shown in the next section .",
    "moreover , the one - step sub - pixel interpolation filter can obtain the prediction pixel using only one dctif operation for all the pixel precisions and thus can reduce the mc complexity significantly . to unify with the translational interpolation filter in hevc ,",
    "the taps of interpolation filter for luma and chroma components are set as @xmath59 and @xmath102 , respectively . due to the limited space , the interpolation filter coefficients for luma and chroma components",
    "are not shown in this paper .",
    "more detailed interpolation coefficients can be found in @xcite .      to further reduce the mc complexity",
    ", we try to decrease the mv resolution from pixel level to block level to decrease the interpolation times . as shown in fig .",
    "[ fig : mc_size ] ( a ) , if the size of the mc unit is a pixel , which allows different pixels with various mvs , to interpolate a @xmath103 pixel shown as the small red square , @xmath104 fractional pixels ( @xmath59 horizontal interpolations to obtain the triangles and @xmath105 vertical to obtain the red square ) need to be calculated . therefore , to interpolate a @xmath106 block , we need to perform totally @xmath107 times of interpolation . however , as shown in fig .",
    "[ fig : mc_size ] ( b ) , if the size of the mc unit is a @xmath106 block , only totally @xmath108 fractional pixels ( @xmath109 horizontal interpolations to obtain the triangles , @xmath110 vertical interpolations to obtain the red squares ) need to be calculated . the reduction of the interpolation times mainly comes from the reduction of repetitive interpolation operations for the neighboring pixels with the same mv .",
    "it should be noted that the difference between block - based mc and pixel - based mc will become much more significant if the mc block size becomes larger .    according to the above analysis , we know that decreasing the mv resolution from the pixel level to the block level can reduce the mc complexity significantly .",
    "however , it may also lead to some r - d performance losses on high - order motion models . to deal with such a problem , an affine interpolation - precision - based adaptive block size mc scheme is proposed to adapt to the various video characteristics .",
    "the basic concept of the affine interpolation - precision - based adaptive block size mc is that the affine mv precision of the current block will not be lower than a predefined precision .",
    "the size of each mc unit is determined by @xmath111 where @xmath112 and @xmath113 are the width and height of the current pu .",
    "all the pixels in a pu share the same affine motion parameters .",
    "@xmath114 is the relatively larger mv difference between the horizontal and vertical directions for the top left and top right positions .",
    "@xmath115 is the corresponding mv difference of the top left and bottom left positions .",
    "@xmath116 determines the minimum precision of the affine interpolation , and it is set as @xmath117 in our experiment .",
    "it can be seen from ( [ affine block size ] ) that the larger @xmath114 or @xmath115 is , the smaller the size of the mc unit will be to guarantee the affine interpolation precision .",
    "the minimum size of an affine mc unit is set as @xmath102 .",
    "to evaluate the performance of the proposed four - parameter affine mc framework , the proposed algorithm is implemented in the hevc reference software hm-16.7 @xcite . the low delay ( ld ) main profile and random access ( ra ) main profile configurations specified in @xcite are used as the test conditions .",
    "the quantization parameters ( qp ) tested are @xmath118 , @xmath119 , @xmath120 , and @xmath121 following the hevc common test condition .",
    "bjontegaard delta - rate ( bd - rate ) @xcite is employed in our experiments for fair r - d performance comparison .    as the proposed algorithm is designed to better characterize the combination of rotation , zooming , and translation , some sequences with rich rotation or zooming motions",
    "are selected to verify the performance of the proposed algorithm . to be more specific , some segments with rich rotation or zooming motions",
    "are extracted from the full sequences to better explain the benefits brought by the proposed algorithm .",
    "these segments will be called as affine test sequences in the following parts .",
    "the detailed characteristics of the affine test sequences are shown in table [ sequences with affine ] . from table [ sequences with affine ] , we can see that the affine test sequences include various spatial / temporal resolutions and different characteristics .",
    ".characteristics of affine test sequences ( sequences with rich rotation or zooming motions ) [ cols= \" > , > , > , > , > \" , ]",
    "in this paper , an effective four - parameter affine motion compensation framework is proposed to better characterize the combination of rotation , zooming , and translation . in the framework ,",
    "a four - parameter affine motion model is firstly proposed and analyzed .",
    "then the four parameters are proposed to be coded in two manners : advanced affine motion vector prediction and affine model merge . especially , different from the traditional merge mode to regenerate a new affine motion model using the neighboring motion information , the affine model merge mode reuses the affine motion model of the neighboring blocks using affine mode .",
    "moreover , two fast motion compensation tools including one - step sub - pixel interpolation filter and affine interpolation - precision - based adaptive block size motion compensation are proposed to speed up the affine motion compensation process .",
    "the proposed framework is implemented in the reference software of high efficiency video coding ( hevc ) .",
    "the experimental results show that the proposed affine motion compensation framework can achieve much better rate distortion performances compared with the hevc anchor for the sequences with rich rotation or zooming motions .",
    "the experimental results demonstrate the effectiveness of the proposed affine motion compensation framework .    in the current implementation ,",
    "we only focus on a quite simple four - parameter affine motion model to characterize the combination of rotation , zooming , and translation .",
    "however , how to effectively characterize other complex motions using high - order motion models remains an open issue . besides , the global high - order motion model is sometimes more effective than the local high - order motion model .",
    "we will try to integrate the global and local high - order motion models into a whole framework in our future work .",
    "t.  wiegand , g.  sullivan , g.  bjontegaard , and a.  luthra , `` overview of the h.264/avc video coding standard , '' _ circuits and systems for video technology , ieee transactions on _ , vol .  13 , no .  7 , pp",
    ". 560576 , jul .",
    "g.  sullivan , j.  ohm , w .- j .",
    "han , and t.  wiegand , `` overview of the high efficiency video coding ( hevc ) standard , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "22 , no .  12 , pp .",
    "16491668 , dec . 2012 .",
    "kim , j.  min , t.  lee , w .- j .",
    "han , and j.  park , `` block partitioning structure in the hevc standard , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "22 , no .  12 , pp .",
    "16971706 , dec . 2012 .",
    "t.  wiegand , e.  steinbach , and b.  girod , `` affine multipicture motion - compensated prediction , '' _ circuits and systems for video technology , ieee transactions on _ , vol .  15 , no .  2 , pp .",
    "197209 , feb .",
    "x.  li , j.  r. jackson , a.  k. katsaggelos , and r.  m. merserau , `` multiple global affine motion model for h.264 video coding with low bit rate , '' _ proceedings of spie - the international society for optical engineering _ ,",
    "vol . 5685 , pp .",
    "185194 , 2005 .",
    "c .- l . huang and c .- y .",
    "hsu , `` a new motion compensation method for image sequence coding using hierarchical grid interpolation , '' _ circuits and systems for video technology , ieee transactions on _ , vol .  4 , no .  1 ,",
    "4252 , feb .",
    "cheung and w .- c .",
    "siu , `` local affine motion prediction for h.264 without extra overhead , '' in _ circuits and systems ( iscas ) , proceedings of 2010 ieee international symposium on _ , may 2010 , pp .",
    "15551558 .",
    "h.  huang , j.  woods , y.  zhao , and h.  bai , `` control - point representation and differential coding affine - motion compensation , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "23 , no .  10 , pp .",
    "16511660 , oct .",
    "l.  li , h.  li , z.  lv , and h.  yang , `` an affine motion compensation framework for high efficiency video coding , '' in _ 2015 ieee international symposium on circuits and systems ( iscas ) _ , may 2015 , pp . 525528 .",
    "g.  al - regib , y.  altunbasak , and r.  mersereau , `` hierarchical motion estimation with content - based meshes , '' _ circuits and systems for video technology , ieee transactions on _ , vol .  13 , no .  10 , pp . 10001005 , oct .",
    "r.  kordasiewicz , m.  gallant , and s.  shirani , `` affine motion prediction based on translational motion vectors , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "17 , no .",
    "10 , pp . 13881394 , oct .",
    "2007 .        c.  heithausen and j.  h. vorwerk , `` motion compensation with higher order motion models for hevc , '' in _ 2015 ieee international conference on acoustics , speech and signal processing ( icassp ) _ , april 2015 , pp .",
    "14381442 .",
    "p.  helle , s.  oudin , b.  bross , d.  marpe , m.  bici , k.  ugur , j.  jung , g.  clare , and t.  wiegand , `` block merging for quadtree - based partitioning in hevc , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "22 , no .",
    "17201731 , dec . 2012 .",
    "wong , k .- w .",
    "cheung , and k .- h .",
    "ng , `` subsampled block - matching for zoom motion compensated prediction , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "20 , no .  11 , pp . 16251637 , nov .",
    "kim , j .- h . lee , c .- k .",
    "kim , and b .-",
    "kim , `` zoom motion estimation using block - based fast local area scaling , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "22 , no .  9 , pp . 12801291 ,",
    "2012 .",
    "c.  zhu , x.  lin , and l .- p .",
    "chau , `` hexagon - based search pattern for fast block motion estimation , '' _ circuits and systems for video technology , ieee transactions on _ , vol .",
    "12 , no .  5 , pp .",
    "349355 , may 2002 .",
    "n.  purnachand , l.  alves , and a.  navarro , `` improvements to tz search motion estimation algorithm for multiview video coding , '' in _ systems , signals and image processing ( iwssip ) , 2012 19th international conference on _ , apr .",
    "2012 , pp . 388391 .",
    "h.  lv , r.  wang , x.  xie , h.  jia , and w.  gao , `` a comparison of fractional - pel interpolation filters in hevc and h.264/avc , '' in _ visual communications and image processing ( vcip ) , 2012 ieee _ , nov .",
    "2012 , pp ."
  ],
  "abstract_text": [
    "<S> in this paper , we study a simplified affine motion model based coding framework to overcome the limitation of translational motion model and maintain low computational complexity . </S>",
    "<S> the proposed framework mainly has three key contributions . </S>",
    "<S> first , we propose to reduce the number of affine motion parameters from 6 to 4 . </S>",
    "<S> the proposed four - parameter affine motion model can not only handle most of the complex motions in natural videos but also save the bits for two parameters . </S>",
    "<S> second , to efficiently encode the affine motion parameters , we propose two motion prediction modes , i.e. , advanced affine motion vector prediction combined with a gradient - based fast affine motion estimation algorithm and affine model merge , where the latter attempts to reuse the affine motion parameters ( instead of the motion vectors ) of neighboring blocks . </S>",
    "<S> third , we propose two fast affine motion compensation algorithms . </S>",
    "<S> one is the one - step sub - pixel interpolation , which reduces the computations of each interpolation . </S>",
    "<S> the other is the interpolation - precision - based adaptive block size motion compensation , which performs motion compensation at the block level rather than the pixel level to reduce the interpolation times . </S>",
    "<S> our proposed techniques have been implemented based on the state - of - the - art high efficiency video coding standard , and the experimental results show that the proposed techniques altogether achieve on average 11.1% and 19.3% bits saving for random access and low delay configurations , respectively , on typical video sequences that have rich rotation or zooming motions . meanwhile , the computational complexity increases of both encoder and decoder are within an acceptable range .    </S>",
    "<S> li : an efficient four - parameter affine motion model for video coding    affine motion model , four - parameter , affine model merge , high efficiency video coding , motion compensation , motion estimation </S>"
  ]
}