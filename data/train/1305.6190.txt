{
  "article_text": [
    "the notion of classical simulation of quantum computation provides a mathematically precise tool for studying fundamental questions that are often only vaguely formulated  questions of the relationship between classical and quantum computing power and the computational possibilities engendered by particular kinds of quantum resources .",
    "we may consider a restricted class @xmath0 of quantum circuits defined by specified limited quantum ingredients and ask whether it can be classically efficiently simulated or not .",
    "computational hardness is notoriously difficult to establish and in the latter case we are generally content to establish that the efficient simulation of @xmath0 would imply some further property such as p@xmath1np , that is widely regarded as implausible . in the former case of @xmath0 being classically efficiently",
    "simulatable we may consider enlarging @xmath0 to @xmath2 by inclusion of some extra specific quantum ingredient @xmath3 and investigating the resulting change in classical simulation complexity .",
    "if for example , @xmath2 allows universal quantum computation then in this mathematically precise sense , @xmath3 may be regarded as an `` essential resource for quantum computational power '' ( relative to a background of quantum effects that are `` computationally lame '' ) .",
    "below we will see examples of seemingly quite modest expansions of resources leading to dramatic changes in simulation complexity , indicating that the computational landscape between classical and quantum computing power is a richly complex one .",
    "this paper is devoted to developing a case study of simulation of clifford circuits supplemented with a variety of extra ingredients .",
    "the choice of clifford circuits is a particularly interesting and relevant one for a variety of reasons .",
    "clifford computations provide one of the earliest significant examples of classically simulatable quantum computations in the gottesman - knill theorem @xcite ( see also @xcite ) , showing in particular that the presence of non - trivial entanglements in a quantum computation is not necessarily a signature of computational speed - up .",
    "clifford gates also have a rich associated pure mathematical theory that may be drawn upon in the study of simulation properties , as well as having a rich physical and practical significance in the theory and implementation of quantum computation .",
    "for example clifford operations feature prominently in the theory of quantum error correction and fault tolerance @xcite and in measurement - based quantum computation @xcite .",
    "it is well known that the clifford gates supplemented with any non - clifford operation generate a dense subgroup of @xmath4 and are hence universal for quantum computation @xcite . here",
    "we will consider extensions of clifford circuits of a different , perhaps seemingly more innocuous kind .",
    "more precisely we will characterise the classical simulation complexity of sixteen cases of extended clifford circuits that are defined by four binary choices .",
    "our main results are summarised in figure 1 .",
    "the acronyms in figure 1 that define the extensions and their classical simulation complexities are all explained in detail in section [ prelim ] below , and briefly they are as follows : in(bits ) and in(prod ) refer to allowing computational basis states and general product states as inputs .",
    "out(1 ) and out(many ) refer to having single bit and multi - bit outputs .",
    "nonadapt and adapt refer to circuits with intermediate measurements , with the circuit gates being respectively fixed or chosen adaptively as a function of previous measurement outcomes .",
    "weak and strong refer to two notions of classical simulation that provide respectively a sample of the output distribution and a calculation of actual probability values . in the body of the tables",
    ", cl - p denotes that classical efficient simulation is possible , qc - hard denotes that universal quantum computation is possible , and # p - hard asserts that classical simulation could be used to solve arbitrary problems in the classical class # p ( and hence np too ) .",
    "these results demonstrate a remarkable sensitivity of the classical simulation complexity of clifford circuits under various small modifications . in section [ mainresults ]",
    "we highlight some interesting comparisons amongst these simulation complexities .",
    "in particular the issue of the last sentence of the abstract above is discussed in example 2 of section [ mainresults ] .",
    "finally in section [ proofs ] we provide proofs of all results given in figure 1 .",
    "for completeness we indicate proofs for all sixteen cases . some cases were previously known ( cf references in our text ) but to the best of our knowledge others have not previously been given in the literature .",
    "finally we mention here some related work on the classical simulation complexity of various extensions and generalizations of clifford circuits .",
    "see @xcite for simulation of clifford circuits supplemented with few non - stabilizer ( pure or mixed ) inputs and/or few non - clifford gates ; see @xcite for quantum computing with adaptive clifford circuits with product state inputs ( we will revisit this scenario as one of the sixteen cases in figure 1 ) ; see @xcite for simulations of clifford circuits supplemented with certain non - clifford gates by restricting the circuit structure ; see @xcite for generalizations of the gottesman - knill theorem to higher - dimensional systems ; see @xcite for generalizations of clifford circuits based on projective normalisers of finite unitary groups .",
    "let @xmath5 denote the standard 1-qubit pauli matrices @xcite ( amongst which we include the identity matrix ) . an _",
    "@xmath6-qubit pauli operator _ is any operator of the form @xmath7 where @xmath8 and each @xmath9 is a pauli matrix .",
    "an @xmath6-qubit unitary operation @xmath10 is called a _ clifford operation _ if the set of all pauli operators is preserved under conjugation by @xmath10 i.e. for any @xmath6-qubit pauli operator @xmath3 , @xmath11 is again a pauli operator .",
    "it is known that @xmath10 is clifford iff @xmath10 can be expressed as a circuit of the following gates ( cf @xcite ) : the 1-qubit hadamard gate @xmath12 , the phase gate @xmath13 and the 2-qubit controlled-@xmath14 gate @xmath15 , which we call _ basic clifford gates_. moreover any @xmath6-qubit clifford operation can be expressed as a circuit of @xmath16 basic clifford gates ( see @xcite and theorem 10.6 of @xcite ) .    a _ unitary clifford circuit _ is a circuit comprising only the basic clifford gates .",
    "the size of the circuit is the number of gates of which it consists .    as a further extension",
    "we will allow measurements in the body of the circuit .",
    "the term _ measurement _ will always mean a single qubit measurement in the computational basis .",
    "let @xmath17 denote a measurement of the @xmath18 qubit line with outcome @xmath19 .",
    "then a _ clifford circuit with @xmath20 intermediate measurements _ has the form @xmath21 where @xmath22 are unitary clifford circuits ( possibly of size zero ) .",
    "we assume that measurements are non - destructive and the measured qubit , set to the designated post - measurement state , may generally be an input into subsequent operations e.g. @xmath23 sets qubit line @xmath24 to @xmath25 which may then be input into @xmath26 .",
    "a _ non - adaptive clifford circuit _ is a clifford circuit with intermediate measurements in which the choice of operations in the circuit does not depend on the outcomes of ( previous ) measurements .",
    "hence such a circuit is fully defined by eq .",
    "( [ cmmt ] ) where the @xmath27 s and measurement line labels @xmath28 s are fixed a priori .    by the term _ adaptive clifford circuit",
    "_ we will mean a process of the form eq .",
    "( [ cmmt ] ) in which the choice of operations is allowed to depend on previous measurement outcomes . to make this dependency explicit",
    "we can expand the notation of eq .",
    "( [ cmmt ] ) as @xmath29 note that the size of the circuits @xmath30 may vary with @xmath31 .",
    "the total number @xmath32 of operations in the adaptive circuit eq .",
    "( [ adaptcliff ] ) is defined to be the maximum number of elementary clifford gates and measurements over all possible choices of measurement outcomes @xmath33 .",
    "alternatively we could uniformise the size of each @xmath27 by including additional identity gates to make its size independent of @xmath31 . similarly to uniformise the number of intermediate measurements in the adaptive process",
    "( as a function of measurement outcomes ) we could formally allow @xmath34 to be zero ( for qubit lines labelled 1 to @xmath6 ) to indicate that a measurement is not performed , but replaced by an identity gate .",
    "the scenarios of non - adaptive and adaptive clifford circuits will be denoted respectively by the acronyms nonadapt and adapt .",
    "we mention here two elementary simplifications of circuit structures that will be useful in proofs of classical simulation properties .",
    "stated informally we have the following facts ( with formal statements and proofs given in lemmas [ lemmacu ] and [ lemmacad ] in section [ proofs ] below ) : + ( i ) without loss of generality ( wlog ) non - adaptive circuits may be assumed to be unitary ; + ( ii ) in ( adaptive or non - adaptive ) circuits with intermediate measurements , wlog the measured qubits may be assumed to always be discarded after measurement ( and not used in subsequent operations ) .",
    "furthermore for adaptive circuits the choice of lines for intermediate measurements may be assumed to be non - adaptive .",
    "in addition to the circuit itself there are two further ingredients for the full specification of a computational process viz .",
    "specification of the input and of the output .",
    "we will distinguish two classes of input states  computational basis input states , denoted by the acronym in(bits ) , and general product state inputs , denoted in(prod ) . for outputs we will distinguish the scenarios of a single bit output ( resulting from a specified final 1-qubit measurement ) , denoted out(1 ) , and the scenario of a many - bit output , denoted out(many ) .",
    "in the latter case , for an @xmath6-qubit circuit the output @xmath35 results from a final measurement on a specified set @xmath36 of @xmath37 lines and generally we can have @xmath38 .",
    "a _ description of a clifford computational task @xmath39 _ with @xmath32 operations on @xmath6 qubits is made up of the following ingredients : + ( i ) a description of an ( adaptive , non - adaptive or unitary ) clifford circuit on @xmath6 lines comprising @xmath32 operations .",
    "for unitary or non - adaptive circuits we give a list of @xmath32 basic clifford gates and intermediate measurements on specified qubit lines ; for adaptive circuits ( cf eq .",
    "( [ adaptcliff ] ) ) we require that each @xmath30 and @xmath34 is given as a function computable in classical @xmath40 time ; + ( ii ) specification of an input state @xmath41 which we always take to be either a computational basis state or a general product state ; + ( iii ) specification of one or more output measurement lines @xmath36 . + let @xmath42 denote the output probability distribution of the corresponding quantum process .",
    "we will consider sets of computational tasks subject to the restrictions introduced above viz .",
    "the eight combinations of adapt vs. nonadapt , in(bits ) vs. in(prod ) and out(1 ) vs. out(many ) . in each case",
    "it is natural to assume that the total length ( as a classical bit string ) of the full description ( i ) , ( ii ) and ( iii ) of the computational task is @xmath43 .",
    "in particular we assume that there are no extraneous qubit lines that are not acted upon ( so @xmath44 ) and we assume that input product states are specified with @xmath43 bits .",
    "the latter technical issue of accuracy ( for our later purposes of simulation complexity characterisations ) may be addressed by setting up a suitable notion of approximation , but we do not elaborate it here for sake of clarity and conceptual transparency .",
    "we introduce two notions of classical simulation for clifford computational tasks .",
    "a _ weak classical simulation _ for a set of computational tasks is a classical randomised computation which , given a description of a task @xmath39 as input , outputs a _ sample _ of the output distribution @xmath42 of @xmath39 .",
    "strong classical simulation _ for a set of tasks is a classical computation whose input is a description of a task @xmath39 and bit values for a subset of its output lines .",
    "the output is the value of the corresponding marginal probability of the output distribution of @xmath39 i.e. we have a classical computation of any desired output probability or marginal probability of @xmath39 .    a weak or strong classical simulation is called _ efficient _ if the corresponding classical computation runs in classical poly@xmath45 time .",
    "( again here for strong simulation , as previously noted for in(prod ) , there is a further technical issue of precision and more formally we would require the output probability or marginal to be computed to @xmath46 bits of precision in poly@xmath47 time ) .",
    "we will use the acronyms weak ( resp .",
    "strong ) to indicate that we are considering a weak ( resp .",
    "strong ) classical simulation for a set of tasks .",
    "we will use the acronym cl - p ( `` classical poly time '' ) to assert that the associated simulation is efficient .",
    "if the computational task @xmath39 is implemented as a quantum process it will require @xmath48 quantum computational steps so existence of an efficient weak classical simulation implies that @xmath39 offers no quantum computational time benefit over classical computation ( up to the usual polynomial overheads of resources commonly accepted in complexity theory ) .    in the case of out(many )",
    "there are generally exponentially many output probabilities @xmath42 ( as @xmath37 may be @xmath49 ) so in strong efficient simulation we can not ask for a computation of them all . the inclusion of computation of marginals in the definition of strong simulation guarantees the following eponymously desirable result .",
    "[ lemmaterdiv ] let @xmath50 be a probability distribution over @xmath6 binary variables .",
    "suppose that each of the @xmath6 marginals @xmath51 may be efficiently classically computed for any choice of values @xmath52 , and suppose that any 1-bit distribution @xmath53 with @xmath54 efficiently computable , may be efficiently sampled",
    ". then @xmath50 may be efficiently sampled . + hence for any set of computational tasks , efficient strong classical simulation implies efficient weak classical simulation .    for a proof",
    "see proposition 1 of @xcite .",
    "for completeness we mention that there are also notions of weak simulations which incorporate various types of approximations @xcite ; these will however not be relevant for the present work .",
    "we will also be interested in establishing that some sets of clifford computational tasks are unlikely to have efficient classical simulations and for this purpose we introduce some further complexity notions .",
    "consider the following classical computational task called # sat ( cf @xcite ) : + input : a boolean function @xmath55 from @xmath6 bits to one bit ( given say as a bit string encoding a formula in standard 3-cnf form @xcite ) .",
    "+ problem : determine the number # @xmath55 of @xmath6-bit strings @xmath56 with @xmath57 .",
    "+ note that # sat is a generalisation of the well known np - complete problem sat @xcite ( which asks only if # @xmath55 is non - zero ) so it is very unlikely that # sat has a poly time classical algorithm ; indeed the latter would imply equality of the complexity classes p and np , and also that any problem in # p may be computed in poly time @xcite .",
    "a set @xmath0 of clifford computational tasks @xmath39 is called _",
    "# p - hard _ if an efficient strong simulation of @xmath0 would give rise to an efficient classical solution of # sat . more precisely @xmath0 is # p - hard if given any input @xmath55 of size @xmath32 for the # sat problem , it may be converted by a classical poly@xmath45 time computation @xmath58 into ( a description of ) a task @xmath59 in @xmath0 with the following property : # @xmath55 may be computed by a classical poly@xmath45 time algorithm from the results of strong classical simulation of @xmath59 . hence efficient strong classical simulation of @xmath0 would imply p@xmath1np and that # p is computable in poly time .    finally we introduce a notion of _ qc - hardness _ for a set @xmath0 of clifford computational tasks .",
    "this will be used to indicate that @xmath0 is unlikely to have an efficient weak classical simulation .",
    "broadly speaking @xmath0 will be qc - hard ( `` quantum computing hard '' ) if it is rich enough to encode universal quantum computation , so then efficient classical weak simulation of @xmath0 would imply that all quantum computation could be classically efficiently simulated .",
    "more precisely we will adopt the following definition .",
    "let @xmath60 be the set of basic unitary clifford gates together with the phase gate @xmath61 .",
    "it is known @xcite that @xmath60 is a universal set of gates for quantum computation .",
    "let @xmath10 be any circuit of gates from @xmath60 with a specified computational basis state input and 1-bit output from measurement of a specified output line .",
    "then @xmath0 is qc - hard if any such @xmath10 may be simulated by a member @xmath62 of @xmath0 i.e. @xmath63 has 1-bit output whose probability distribution for the given computational basis input coincides with that of @xmath10 . here as before",
    ", @xmath58 is a poly time translation of the description of @xmath10 into the description of a member of @xmath0 . hence efficient weak classical simulation of @xmath0",
    "would imply efficient classical simulation of universal quantum computing .",
    "we now consider the sixteen sets of clifford computational tasks defined by all combinations of the following four binary choices    \\(i ) nonadapt vs. adapt    \\(ii ) in(bits ) vs. in(prod )    \\(iii ) out(1 ) vs. out(many )    \\(iv ) weak vs. strong .",
    "the corresponding simulation complexities that we will prove , are summarised in figure 1 .",
    "the original gottesman - knill theorem @xcite asserts that efficient classical simulations exist for the case adapt , in(bits ) , out(many ) and weak ( cf .",
    "theorem [ thm5 ] below ) .",
    "in contrast , we find here that eight of the sixteen cases of extended clifford circuits are not ( likely to be ) classically efficiently simulatable .",
    "we draw attention to some examples of extreme changes of simulation complexity resulting from seemingly modest modifications in the defining computational resources .",
    "perhaps the most significant such comparisons for issues of computing power will be cases involving only weak simulations , since implementing the circuit itself as a quantum process yields only one sample of the output probability distribution , in contrast to the far greater information resulting from strong simulation ( cf .",
    "@xcite ) .",
    "* example 1 .",
    "* for the case of non - adaptive ( or equivalently , unitary ) circuits with general product state inputs , we have that 1-bit outputs are classically efficiently simulatable in both weak and strong senses .",
    "however allowing just many bit outputs results in # p hardness for strong simulation and a more subtle certification of hardness ( related to ph collapse ) for weak simulation .",
    "this indicates a significant increase of computational power associated to the passage from out(1 ) to out(many ) i.e. merely sampling more lines of the same class of quantum processes ( and see also @xcite where a similar phenomenon is observed for computational processes defined by commuting quantum circuits ) .    on the other hand , in the case of adaptive circuits with computational basis inputs the passage from one to many output lines",
    "remains classically efficiently simulatable in the weak sense ( all other adaptive cases already being qc- or # p - hard ) .",
    "note also that in our definitions of classical simulation we ask for simulation only of the output distribution of the computational task , and not of intermediate measurement distributions ( if there are any ) .",
    "indeed inclusion of the latter could elevate an out(1 ) scenario to out(many ) via consideration of intermediate measurement outcomes together with the single bit output of the task , and the associated simulation complexity could radically change .",
    "@xmath64    * example 2 . *",
    "another particularly interesting comparison is that of weak simulation for general product state inputs and single bit outputs , with the transition from non - adaptive to adaptive circuits i.e. we compare + case a : in(prod ) , out(1 ) , weak , nonadapt to + case b : in(prod ) , out(1 ) , weak , adapt .",
    "+ case a admits efficient weak classical simulation whereas case b is qc - hard . but now note that the passage from case a to case b involves the inclusion of a purely _ classical _ extra resource viz .",
    "classical adaptive choice of gates , without introducing any new gates .",
    "furthermore the class of quantum processes occurring in runs of case b is _ exactly the same _ as the class occurring in runs of case a , since any single actual run of an adaptive circuit can occur as a run of a non - adaptive circuit ( that non - adaptively prescribes the sequence of gates that were adaptively chosen ) . indeed from an experimentalist s point of view",
    "cases a and b may be claimed to be totally indistinguishable in the following sense : suppose an experimentalist @xmath65 has the ability to implement basic clifford gates and measurements .",
    "a theorist @xmath66 directs @xmath65 by announcing one by one , a sequence of basic gates and measurements , which @xmath65 successively implements . for each measurement instruction",
    "@xmath65 announces the measurement outcome before further instructions from @xmath66",
    ". then @xmath65 can not tell whether @xmath66 is choosing gates adaptively ( case b ) or not ( case a )  the demands on @xmath65 s laboratory are exactly the same , and case b results in no new quantum processes . yet case b can perform universal quantum computation whereas case a is fully classically efficiently simulatable .",
    "@xmath64    the sixteen cases of extended clifford circuits give rise to a rich landscape of simulation complexities . apart from cl - p , qc - hardness and # p - hardness",
    ", we will see in the course of the proofs that connections to other major complexity classes appear as well . for example",
    "remark below theorem [ thm5 ] ) , uniform families of adaptive clifford circuits with computational basis inputs have precisely the same power as a universal randomised classical computation .",
    "thus the class of languages decidable by such clifford processes in poly - time with bounded error , is precisely bpp .",
    "what is more , just changing from computational basis inputs to arbitrary product state inputs ( and keeping the other parameters equal ) yields universal quantum computation , so in the same poly - time bounded error setting , these clifford processes now give precisely bqp @xcite .",
    "we will also find that post - selected non - adaptive clifford circuits with product state inputs have the same power as bqp with postselection ( cf .",
    "theorem [ thm7 ] and @xcite ) , which is known to coincide with the class pp @xcite .",
    "finally we recall that the simulation complexity of non - adaptive clifford circuits with computational basis inputs and single bit outputs is known to be characterized by the class @xmath67l @xmath68 p @xcite .",
    "in this section we give proofs of theorems 1 to 7 that appear as seven of the sixteen cases depicted in figure 1 . for the remaining cases",
    "it may be easily checked that they all follow from the seven basic cases using the following simple facts : + ( i ) if a set of tasks is cl - p then any subset is cl - p too ; + ( ii ) if a subset of tasks is qc- or # p - hard then the full set is qc- or # p - hard too ; + ( iii ) replacing in(bits ) by in(prod ) , or replacing out(1 ) by out(many ) , increases the set of computational tasks ; + ( iv ) by lemma [ lemmaterdiv ] , if strong simulation is cl - p , then weak simulation is cl - p too ( keeping all other resource choices unchanged ) .",
    "we will use the following notations relating to bit strings and pauli operators . for any @xmath6-bit strings @xmath69 and @xmath70 , @xmath71 will denote the @xmath6-bit string with @xmath72 ( and @xmath67 being addition mod 2 ) , and @xmath73 will denote the mod 2 inner product .",
    "we will also use the notation @xmath74 and @xmath75 .",
    "@xmath76 will denote the computational basis state corresponding to @xmath77 .",
    "then the following properties are easily verified for any @xmath6-bit strings @xmath78 : @xmath79 since @xmath80 , any pauli operator @xmath3 can be written uniquely as @xmath81 for some @xmath82 and @xmath6-bit strings @xmath83 and @xmath84 . labelling the @xmath85 values by 2-bit strings @xmath86 , we call the @xmath87-bit string @xmath88 the _ label _ of @xmath3 and @xmath85 the _ phase _ of @xmath3 .",
    "if @xmath89 is any basic clifford gate ( acting on specified qubit line(s ) , and extended by @xmath90 on all other lines ) , and @xmath3 is any @xmath6-qubit pauli operator , then the label of @xmath91 can be easily computed from the label of @xmath3 in @xmath49 time .",
    "in fact only the phase of @xmath3 and the label entries pertaining to the line(s ) of action of the basic clifford gate are modified .",
    "we begin by proving two elementary simplifications of circuit structures that were mentioned in section [ prelim ] . to formally establish these we use the following construction :",
    "let @xmath10 be any ( adaptive or non - adaptive ) circuit on @xmath6 lines with @xmath20 intermediate measurements , input state @xmath41 and final output measurements on lines @xmath92 .",
    "introduce an enlarged unitary circuit @xmath93 on @xmath94 lines defined as follows . for each intermediate measurement @xmath95 on line @xmath96 of @xmath10 introduce an extra ancilla qubit ( line @xmath97 ) in state @xmath98 and replace the measurement operation by the unitary clifford operation @xmath99 ( where @xmath100 is the 2-qubit controlled-@xmath101 operation with source @xmath102 and target @xmath46 ) .",
    "[ lemmacu ] suppose @xmath10 with input and output as above is a non - adaptive circuit with @xmath20 intermediate measurements .",
    "then there is a _ unitary _",
    "circuit @xmath103 on @xmath94 lines which is equivalent to @xmath10 in the following sense : if @xmath103 has input @xmath104 then measurement of lines @xmath105 of @xmath103 will result in the same probability distribution of outputs as @xmath10 on @xmath41 .",
    "[ lemmacad ] suppose @xmath10 as above is an adaptive circuit .",
    "then there is an adaptive circuit @xmath106 on @xmath94 lines which is equivalent to @xmath10 ( in the sense given in lemma [ lemmacu ] above ) and + ( i ) in @xmath106 after each intermediate measurement @xmath107 the line @xmath96 and its post - measurement state are not further used in any subsequent operations of @xmath106 .",
    "furthermore the choice of line @xmath96 here is always non - adaptive i.e. independent of previous measurement outcomes .",
    "+ ( ii ) in @xmath106 the set of output lines @xmath108 is disjoint from the set of intermediate measured lines",
    ".    * proof . * to construct @xmath106 we take @xmath93 as above , but after each extra @xmath99 operation we immediately measure line @xmath97 , and use its output as the result of the intermediate measurement @xmath109 of @xmath10 , for subsequent adaptations .",
    "@xmath64        [ thm1 ]",
    "let @xmath0 be the set of computational tasks defined by non - adaptive clifford circuits , general product state inputs and single bit outputs . then @xmath0 may be strongly efficiently classically simulated .",
    "* this result has been proved in @xcite and we summarise the argument here . using lemma [ lemmacu ]",
    "we may assume wlog that the clifford circuit is unitary .",
    "let @xmath110 be a unitary clifford circuit with product state input @xmath111 .",
    "write @xmath112 .",
    "we may assume that the output , with probabilities @xmath113 is obtained from line 1 ( as the swap gate is clifford ) .",
    "let @xmath114 . then @xmath115 .",
    "now @xmath116 is a pauli operator so after successive conjugations by the @xmath22 s we get @xmath117 where the label of the latter is easily computed in @xmath40 time .",
    "thus @xmath118 and the latter expression , being a product of @xmath6 @xmath119 matrix expectation values , is readily computable in @xmath40 time , providing the efficient strong classical simulation ( as @xmath120 too ) .",
    "@xmath64    * remark .",
    "* the simple method of the above proof does not generalise to the case of out(many ) with @xmath49 output lines .",
    "indeed we will see ( cf theorems [ thm4 ] and [ thm6 ] below ) that this case is # p - hard but remains classically efficiently strongly simulatable if we restrict the input states to just computational basis states i.e. to in(bits ) .",
    "[ thm2 ] let @xmath0 be the set of computational tasks defined by adaptive clifford circuits , computational basis state inputs and single bit outputs .",
    "then the strong classical simulation of @xmath0 is # p - hard .    *",
    "proof . * with the availability of adaptation we are able to apply the gate @xmath121 or the identity gate @xmath122 ( on lines @xmath102 and @xmath46 ) chosen conditionally according to the result of a measurement on another line @xmath96 .",
    "thus if these lines are promised to be in computational basis states we can apply the toffoli gate .",
    "( note however that we can not by this method apply the toffoli gate coherently on general quantum states because the adaptation requires a measurement on line @xmath96 ) . then with the availability of computational basis state inputs , using @xmath101 and this toffoli construction",
    ", we can efficiently implement universal classical computation .",
    "thus if @xmath55 is any boolean function from @xmath6 bits to one bit , we can implement the transformation @xmath123 ( so long as the input is a computational basis state ) .",
    "consider now the following process which is allowed in @xmath0 : starting with @xmath6 qubits each in state @xmath98 , apply @xmath12 to each and measure each to generate a uniformly random @xmath6-qubit computational basis state @xmath124 . then apply @xmath125 and finally measure the qubit line of @xmath126 to give a single bit output",
    ". clearly the probability of obtaining 1 is @xmath127 so strong simulation of this process is # p - hard .",
    "@xmath64      [ thm3 ] let @xmath0 be the set of computational tasks defined by adaptive clifford circuits , general product state inputs and single bit outputs .",
    "then the weak classical simulation of @xmath0 is qc - hard .",
    "* this result is well known , see e.g. @xcite .",
    "it suffices to show that within the given resource constraints , the phase gate @xmath128 may be implemented on any desired qubit line .",
    "this is achieved by introducing an extra ancilla qubit labelled @xmath129 , in state @xmath130 ( respecting availability of product state inputs ) and then applying the process of lemma [ sgate ] below , and finally applying the clifford gate @xmath131 to line @xmath96 conditionally on the value of the ancilla measurement outcome ( which is possible since adaptation is available ) . @xmath64    [ sgate ] let @xmath132 be an @xmath6-qubit state on lines 1 to @xmath6 and let @xmath128 .",
    "let @xmath133 be an extra ancillary qubit .",
    "then @xmath134 where @xmath135 denotes the application of @xmath136 to qubit @xmath96 , and @xmath137 is the application of @xmath138 to lines @xmath129 and @xmath96 with @xmath96 as target line .",
    "[ thm4 ] let @xmath0 be the set of computational tasks defined by non - adaptive clifford circuits , computational basis state inputs and multiple bit outputs",
    ". then @xmath0 may be strongly efficiently classically simulated .",
    "* proof . * the techniques of @xcite and alternatively @xcite may be used to prove theorem [ thm4 ] . here",
    "we give a proof using a third method .",
    "let @xmath10 be a non - adaptive clifford circuit with computational basis input @xmath139 and let @xmath140 be any subset of the output lines .",
    "we will show that the corresponding marginal probability @xmath141 may be efficiently classically computed .",
    "we may assume the following standardised situation : + ( i ) @xmath10 is unitary ( by lemma [ lemmacu ] ) ; + ( ii ) @xmath142 and @xmath143 ( since we can pre- and post- include extra @xmath101 gates on lines where @xmath144 or @xmath145 are 1 ) ; + ( iii ) @xmath146 for @xmath147 ( since swap gates are clifford operations ) .",
    "+ thus for @xmath10 unitary with input @xmath148 let @xmath149 be the probability of obtaining 0 from measurement of each of the lines 1 to @xmath150 . using @xmath151 and writing @xmath152 for @xmath150-bit strings we have @xmath153 where @xmath154 is the @xmath6-qubit pauli operator @xmath155 obtained by extending the @xmath150-qubit operator @xmath156 by @xmath157 @xmath90 s .",
    "this is a sum with potentially exponentially many terms ( e.g. if @xmath158 ) yet it can be evaluated in poly@xmath159 time as follows . using the clifford conjugation relations we have @xmath160 with @xmath161 and @xmath162 .",
    "furthermore , for each @xmath163 these labels can be computed efficiently .",
    "next , introduce basis vectors @xmath164 in @xmath165 ( having 1 in the @xmath166 slot ) for @xmath167 . then since @xmath168 and @xmath169 we have @xmath170 next note that since @xmath171 we have @xmath172 furthermore if @xmath173 then @xmath174 and since @xmath175 we must have @xmath176 , so that @xmath177 with @xmath178 . furthermore , using @xmath179 we get @xmath180 introducing @xmath181 we thus get @xmath182 next we characterise @xmath183 .",
    "we have @xmath184 iff @xmath185 so by eq .",
    "( [ basis ] ) , @xmath183 is the subspace of @xmath165 given by the solution space of @xmath186 where @xmath116 is the @xmath187 sized matrix with @xmath188 for @xmath189 as the columns . using the label update rules for clifford conjugations , all @xmath188 s",
    "can be computed in @xmath190 time .",
    "thus we can compute a basis @xmath191 of @xmath183 ( and hence also the information of its dimension @xmath37 ) in @xmath190 time .",
    "then @xmath184 iff @xmath192 for @xmath193 and @xmath194 finally recalling that @xmath195 we see from eqs ( [ star1 ] ) and ( [ star2 ] ) that @xmath196 is a linear function of @xmath163 , so writing @xmath197 and @xmath198 we have @xmath199 now @xmath200 is a balanced function for @xmath201 ( i.e. taking values @xmath202 equally often ) so @xmath203 concluding our efficient classical computation of @xmath204 .",
    "+ to summarise : given the description of the circuit @xmath10 we first compute @xmath188 for @xmath205 ( from the clifford conjugation relations ) giving the matrix @xmath116 via columns .",
    "then we compute any basis @xmath191 of ker@xmath206 , and compute the @xmath37-bit string @xmath207 ( again from the clifford conjugation relations in eq .",
    "( [ cliff ] ) with @xmath208 there ) .",
    "then @xmath209 if @xmath210 and @xmath211 otherwise .",
    "@xmath64      [ thm5 ] let @xmath0 be the set of computational tasks defined by adaptive clifford circuits , computational basis state inputs and multiple bit outputs . then @xmath0 may be weakly efficiently classically simulated .",
    "* note that by theorem [ thm2 ] strong simulation in this scenario even with _",
    "bit outputs , is # p - hard .",
    "the weak simulation that we give in the proof of theorem [ thm5 ] below will use the strong simulation result of theorem [ thm4 ] .",
    "a different proof of theorem [ thm5 ] may be given in terms of the stabiliser formalism ( see @xcite , especially the gottesman knill theorem 10.7 therein ) which develops a description of the evolving state through the course of the computation .    *",
    "remark . * a family of clifford computational tasks @xmath212 , where @xmath213 acts on @xmath6 qubits , is said to be uniform if the description of @xmath213 can be computed in poly@xmath159 time by a ( deterministic ) classical turing machine on input of @xmath6 .",
    "theorem [ thm5 ] shows that uniform families of adaptive clifford circuits with computational basis state inputs and multiple bit outputs do not have additional power over polynomial - time randomised classical computation .",
    "interestingly , the power of such uniform families of clifford computational tasks in fact _ coincides _ with polynomial - time randomised classical computation .",
    "this follows from the constructions in the proof of theorem [ thm2 ] where it was shown how to generate random bits and realize toffoli gates with adaptive clifford circuits acting on computational basis state inputs ( see also @xcite for related insights on realizing universal classical computation with adaptive stabilizer measurements ) .",
    "finally we note the interesting comparison with the case of product states ( replacing computational basis states ) as inputs ( keeping all other parameters the same ) where the associated uniform families of clifford computational tasks have precisely the same power as universal _ quantum _ computation ( which similarly immediately follows from the proof of theorem [ thm3 ] ) .",
    "* let @xmath10 be an adaptive circuit on @xmath6 qubit lines with @xmath20 intermediate measurements , input @xmath214 and @xmath37 output lines .",
    "by lemma [ lemmacad ] we may wlog instead work with an extended circuit @xmath106 on @xmath94 lines having the following form ( rearranging the order of lines in lemma [ lemmacad ] ) : @xmath106 has input @xmath215 and the output measurements are on lines @xmath216 ( wlog , as swap operations are clifford ) .",
    "furthermore the @xmath18 intermediate measurement yielding outcome @xmath217 for @xmath218 is on line @xmath96 and then line @xmath96 is not further used in @xmath106 . as such",
    ", these measurements can be viewed as outputs too with the caveat that subsequent choices of gates may depend on the values @xmath219 as they sequentially emerge .",
    "a full run of @xmath106 ( including its @xmath37 output measurements ) samples an associated probability distribution @xmath220 .",
    "now if @xmath221 for @xmath222 are specified then the circuit up to the @xmath166 measurement becomes non - adaptive ( i.e. the adaptive choices have been specified ) and hence we can efficiently compute the marginal @xmath223 by theorem [ thm4 ] . similarly if @xmath224 all adaptations have been specified and by theorem [ thm4 ] we can again efficiently compute the corresponding marginals @xmath223 .",
    "hence by lemma [ lemmaterdiv ] we can efficiently sample the distribution @xmath220 and the last @xmath37 bits of the sample provides a weak efficient classical simulation of @xmath106 and hence of @xmath10 too .",
    "@xmath64      [ thm6 ]",
    "let @xmath0 be the set of computational tasks defined by non - adaptive clifford circuits , general product state inputs and multiple bit outputs",
    ". then the strong classical simulation of @xmath0 is # p - hard .",
    "* we will show that efficient strong simulation of @xmath0 would imply efficient strong simulation of universal quantum computation and hence provide an efficient solution of the # sat problem ( using the process described in the proof of theorem [ thm2 ] to express @xmath225 for any boolean @xmath55 as a probability value ) .",
    "thus let @xmath226 be any quantum circuit comprising basic clifford gates and @xmath136 gates with a product state input , and single bit output denoted @xmath227 .",
    "consider again the process of lemma [ sgate ] . in our present scenario for @xmath0 we do not have adaptation available so we can not implement @xmath136 gates as we did in the proof of theorem [ thm3 ] .",
    "instead we proceed as follows .",
    "suppose there are @xmath20 s gates in @xmath226 .",
    "for each such gate introduce an ancilla in state @xmath228 and replace the @xmath136 gate by the sequence of operations in lemma [ sgate ] , resulting in a non - adaptive circuit @xmath229 now involving only basic clifford gates .",
    "then @xmath229 has @xmath230 outputs viz .",
    "@xmath227 and measurements of the @xmath20 ancilla lines denoted @xmath231 , and we have @xmath232 strong classical efficient simulation of @xmath0 ( which allows multi - line outputs ) implies that we can compute both of the @xmath229 probabilities in the above quotient and hence @xmath233 i.e. we then get a strong efficient simulation of @xmath226 .",
    "@xmath64      [ thm7 ] let @xmath0 be the set of computational tasks defined ( as in theorem [ thm6 ] ) by non - adaptive clifford circuits , general product state inputs and multiple bit outputs .",
    "if @xmath0 could be weakly efficiently classically simulated , then the polynomial hierarchy ph would collapse to its third level .",
    "* for the definition of ph we refer to @xcite .",
    "the proof of theorem [ thm7 ] below rests on techniques introduced in @xcite and below we will be content to describe the relationship of the class @xmath0 in theorem [ thm7 ] to the constructions of @xcite and refer to the latter for further details of the proof .",
    "* theorem [ thm7 ] provides a partial answer to an open problem raised in @xcite viz .",
    "the question of the computational power of non - adaptive clifford circuits with product state inputs and multiple bit outputs .    * proof . *",
    "consider again the process of lemma [ sgate ] . now",
    "instead of utilising adaptation ( as we did in the proof of theorem [ thm3 ] ) or conditional probabilities ( as we did above in theorem [ thm6 ] ) , we could alternatively implement @xmath136 using the process of lemma [ sgate ] if we were able to _ post - select _ on measurement outcomes viz .",
    "we post - select the value 0 of the ancilla measurement .",
    "it follows that our class @xmath0 _ together with post - selection _ contains universal quantum computation , and even more , universal quantum computation with post - selection .",
    "aaronson @xcite has shown that the class bqp with post - selection coincides with the classical class pp ( cf @xcite for definitions ) .",
    "thus our class @xmath0 with post - selection contains pp .",
    "now let @xmath234 be any class of bounded error quantum circuits such that @xmath234 with post - selection contains pp .",
    "then ( as elaborated in @xcite ) weak efficient classical simulation of @xmath234 for output measurements on many lines , implies that @xmath234 with post - selection is contained in bpp with post - selection @xcite . then according to a result of classical complexity theory ( cf @xcite for details ) , the latter inclusion ( implying that pp is contained in bpp with post - selection ) implies that ph collapses to its third level .",
    "hence weak efficient classical simulation of our class @xmath0 would imply this collapse .",
    "rj was supported in part by the ec networks q - essence and qcs .",
    "preliminary versions of this work were presented at the conferences aqis12 ( suzhou china , september 2012 ) and qansas11 ( agra india , december 2011 ) .",
    "gottesman , d. 1999 the heisenberg representation of quantum computers .",
    "in group22 : proceedings of the xxii international colloquium on group theoretical methods in physics , pp .",
    "32 - 43 . international press .",
    "arxiv : quant - ph/9807006v1 ."
  ],
  "abstract_text": [
    "<S> clifford gates are a winsome class of quantum operations combining mathematical elegance with physical significance . </S>",
    "<S> the gottesman - knill theorem asserts that clifford computations can be classically efficiently simulated but this is true only in a suitably restricted setting . </S>",
    "<S> here we consider clifford computations with a variety of additional ingredients : ( a ) strong vs. weak simulation , ( b ) inputs being computational basis states vs. general product states , ( c ) adaptive vs. non - adaptive choices of gates for circuits involving intermediate measurements , ( d ) single line outputs vs. multi - line outputs . </S>",
    "<S> we consider the classical simulation complexity of all combinations of these ingredients and show that many are not classically efficiently simulatable ( subject to common complexity assumptions such as p not equal to np ) . </S>",
    "<S> our results reveal a surprising proximity of classical to quantum computing power viz . a class of classically simulatable quantum circuits which yields universal quantum computation if extended by a purely classical additional ingredient that does not extend the class of quantum processes occurring . </S>"
  ]
}