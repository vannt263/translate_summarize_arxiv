{
  "article_text": [
    "gallager in @xcite showed that for @xmath5 and @xmath6 , there exist @xmath7 regular low - density parity - check ( ldpc ) codes for which the bit error probability tends to zero asymptotically whenever we operate below the threshold .",
    "richardson and urbanke in @xcite derived the capacity of ldpc codes for various message passing algorithms and described density evolution , a deterministic algorithm to compute thresholds .",
    "zyablov and pinsker @xcite analyzed ldpc codes under a simpler decoding algorithm known as the bit flipping algorithm and showed that almost all the codes in the regular ensemble with @xmath8 can correct a constant fraction of worst case errors .",
    "sipser and spielman in @xcite used expander graph arguments to analyze bit flipping algorithm .",
    "burshtein and miller in @xcite applied expander based arguments to show that message passing algorithms can also correct a fixed fraction of worst case errors when the degree of each variable node is at least five .",
    "@xcite showed that linear programming decoder @xcite is also capable of correcting a fraction of errors .",
    "recently , burshtein in @xcite showed that regular codes with variable nodes of degree four are capable of correcting a linear number of errors under bit flipping algorithm .",
    "he also showed tremendous improvement in the fraction of correctable errors when the variable node degree is at least five .    in this paper",
    ", we consider the error correction capability of the ensemble @xmath9 of @xmath10 regular ldpc codes as defined in @xcite when decoded using the gallager a algorithm .",
    "we analyze decoding failures using the notion of trapping sets and prove that a code with girth @xmath11 can not correct all @xmath12 or fewer errors . using this result , we prove that for any @xmath13 , for sufficiently large block length @xmath14 , no code in the @xmath15 ensemble can correct @xmath16 fraction of errors .",
    "this result settles the problem of error correction capability of column - weight - three codes .",
    "the rest of the paper is organized as follows . in section [ section2 ]",
    "we establish the notation and describe the gallager a algorithm .",
    "we then characterize the failures of the gallager a decoder with the help of fixed points .",
    "we also introduce the notions of trapping sets , failure sets and critical number . in section [ section3 ]",
    "we investigate the relation between error correction capacity and girth of the code .",
    "we extend the results to bit flipping algorithm in section [ section4 ] and conclude in section [ section5 ] .",
    "ldpc codes @xcite are a class of linear block codes which can be defined by sparse bipartite graphs @xcite .",
    "let @xmath17 be a bipartite graph with two sets of nodes : @xmath14 variable nodes and @xmath18 check nodes .",
    "the check nodes ( variable nodes ) connected to a variable node ( check node ) are referred to as its neighbors .",
    "the degree of a node is the number of its neighbors .",
    "this graph defines a linear block code @xmath19 of length @xmath14 and dimension at least @xmath20 in the following way : the @xmath14 variable nodes are associated to the @xmath14 coordinates of codewords .",
    "a vector @xmath21 is a codeword if and only if for each check node , the sum of its neighbors is zero .",
    "such a graphical representation of an ldpc code is called the tanner graph @xcite of the code .",
    "the adjacency matrix of @xmath17 gives @xmath22 , a parity check matrix of @xmath23 .",
    "an @xmath7 regular ldpc code has a tanner graph with @xmath14 variable nodes each of degree @xmath24 ( column weight ) and @xmath25 check nodes each of degree @xmath26 ( row weight ) .",
    "this code has length @xmath14 and rate @xmath27 @xcite . in the rest of the paper we consider codes in the @xmath10 , @xmath28 , regular ldpc code ensemble .",
    "note that the column weight and row weight are also referred to as left degree and right degree in literature .",
    "it should also be noted that the tanner graph is not uniquely defined by the code and when we say the tanner graph of an ldpc code , we only mean one possible graphical representation .",
    "the girth @xmath29 is the length of the shortest cycle in @xmath17 . in this paper",
    ", @xmath30 represents a variable node , @xmath31 represents an even degree check node and @xmath32 represents an odd degree check node .",
    "gallager in @xcite proposed two simple binary message passing algorithms for decoding over the binary symmetric channel ( bsc ) ; gallager a and gallager b. see @xcite for a detailed description of gallager b algorithm . for column - weight - three codes , which are the main focus of this paper , these two algorithms are the same",
    ". every round of message passing ( iteration ) starts with sending messages from variable nodes ( first half of the iteration ) and ends by sending messages from check nodes to variable nodes ( second half of the iteration ) .",
    "let @xmath33 , a binary @xmath14-tuple be the input to the decoder .",
    "let @xmath34 denote the message passed by a variable node @xmath35 to its neighboring check node @xmath36 in @xmath37 iteration and @xmath38 denote the message passed by a check node @xmath36 to its neighboring variable node @xmath35 .",
    "additionally , let @xmath39 denote the set of all messages from @xmath35 , @xmath40 denote the set of all messages from @xmath35 except to @xmath36 , @xmath41 denote the set of all messages to @xmath36 .",
    "@xmath42 and @xmath43 are defined similarly .",
    "the gallager a algorithm can be defined as follows .",
    "@xmath44    at the end of each iteration , an estimate of each variable node is made based on the incoming messages and possibly the received value .",
    "the decoded word at the end of @xmath37 iteration is denoted as @xmath45 .",
    "the decoder is run until a valid codeword is found or a maximum number of iterations @xmath46 is reached , whichever is earlier .",
    "the output of the decoder is either a codeword or @xmath47 .    _ a note on the decision rule : _ different rules to estimate a variable node after each iteration are possible and it is likely that changing the rule after certain iterations may be beneficial .",
    "however , the analysis of various scenarios is beyond the scope of this paper . for column - weight - three codes",
    "only two rules are possible .",
    "* decision rule a : if all incoming messages to a variable node from neighboring checks are equal , set the variable node to that value ; else set it to received value * decision rule b : set the value of a variable node to the majority of the incoming messages ; majority always exists since the column - weight is three    we adopt decision rule a throughout this paper .",
    "we now characterize failures of the gallager a decoder using fixed points and trapping sets @xcite .",
    "consider an ldpc code of length @xmath14 and let @xmath48 be the binary vector which is the input to the gallager a decoder .",
    "let @xmath49 be the support of @xmath48 .",
    "the support of @xmath48 is defined as the set of all positions @xmath50 where @xmath51 . without loss of generality ,",
    "we assume that the all zero codeword is sent over bsc and that the input to the decoder is the error vector .",
    "hence , throughout this paper a message of @xmath52 is alternatively referred to as an incorrect message , a received value of @xmath52 is referred to as an initial error .",
    "@xcite a decoder failure is said to have occurred if the output of the decoder is not equal to the transmitted codeword .",
    "@xmath48 is called a _ fixed point _ if @xmath53    that is , the message passed from variable nodes to check nodes along the edges are the same in every iteration .",
    "since the outgoing messages from variable nodes are same in every iteration , it follows that the incoming messages from check nodes to variable nodes are also same in every iteration and so is the estimate of a variable after each iteration . in fact , the estimate after each iteration coincides with the received value .",
    "it is clear from above definition that if the input to the decoder is a fixed point , then the output of the decoder is the same fixed point .",
    "@xcite let @xmath48 be a fixed point",
    ". then @xmath49 is known as a trapping set .",
    "a @xmath54 trapping set @xmath55 is a set of @xmath56 variable nodes whose induced subgraph has @xmath57 odd degree checks .    [ thm1 ]",
    "let @xmath19 be a code in the ensemble of @xmath10 regular ldpc codes .",
    "let @xmath55 be a set consisting of @xmath56 variable nodes with induced subgraph @xmath58 .",
    "let the checks in @xmath58 be partitioned into two disjoint subsets ; @xmath59 consisting of checks with odd degree and @xmath60 consisting of checks with even degree .",
    "let @xmath61 and @xmath62 .",
    "@xmath55 is a trapping set iff : ( a ) every variable node in @xmath58 is connected to at least two checks in @xmath60 and ( b ) no two checks of @xmath59 are connected to a variable node outside @xmath58 .",
    "see appendix [ appendix1 ]    we note that theorem [ thm1 ] is a consequence of fact 3 in @xcite .",
    "we also remark that theorem [ thm1 ] can be extended to higher column weight codes but in this paper we restrict our attention to column - weight - three codes .",
    "if the variable nodes corresponding to a trapping set are in error , then a decoder failure occurs .",
    "however , not all variable nodes corresponding to trapping set need to be in error for a decoder failure to occur .",
    "@xcite the minimal number of variable nodes that have to be initially in error for the decoder to end up in the trapping set @xmath55 will be referred to as _",
    "critical number _ for that trapping set .",
    "a set of variable nodes which if in error lead to a decoding failure is known as a _ failure set_.    _ remarks _    1 .",
    "to `` end up '' in a trapping set @xmath55 means that , after a possible finite number of iterations , the decoder will be in error , on at least one variable node from @xmath63 at every iteration @xcite .",
    "the notion of a failure set is more fundamental than a trapping set .",
    "however , from the definition , we can not derive necessary and sufficient conditions for a set of variable nodes to form a failure set .",
    "3 .   a trapping set is a failure set .",
    "subsets of trapping sets can be failure sets . more specifically ,",
    "for a trapping set of size @xmath56 , there exists at least one subset of size equal to the critical number which is a failure set .",
    "4 .   the critical number of a trapping set is not fixed .",
    "it depends on the outside connections of checks in @xmath60 .",
    "however , the maximum value of critical number of a @xmath54 trapping set is @xmath56 .",
    "fig.[sixcycle ] shows a subgraph induced by a set of three variable nodes @xmath64 .",
    "if no two odd degree check nodes from @xmath65 are connected to a variable outside the subgraph , then by theorem [ thm1 ] , fig.[sixcycle ] is a @xmath66 trapping set . on the other hand ,",
    "if two odd degree checks , say @xmath67 and @xmath68 , are connected to another variable node , say @xmath69 , the subgraph resembles fig .",
    "[ 42trappingset ] .",
    "assuming no other connections , fig.[42trappingset ] is a @xmath70 trapping set .",
    "we make the following observations :    1 .   the three variable nodes in a @xmath66 trapping set form a six cycle",
    ". however , not all six cycles are @xmath66 trapping sets .",
    "apart from the subgraph induced by variable nodes , the outside connections should be known to determine whether a given subgraph is a trapping set or not .",
    "the @xmath70 trapping set in fig.[42trappingset ] illustrates this point .",
    "the critical number of a @xmath66 trapping set is three .",
    "there exist @xmath70 trapping sets with critical number three and it is highly unlikely that a @xmath70 trapping set does not contain a failure set of size three .",
    "however , we can show by a counterexample that this is indeed possible .",
    "a @xmath54 trapping set is not unique i.e. , two trapping sets with same @xmath56 and @xmath57 can have different underlying topological structures ( induced subgraphs ) .",
    "so , when we talk of a trapping set , we refer to a specific topological structure . in this paper ,",
    "the induced subgraph is assumed to be known from the context .",
    "4 .   to avoid a trapping set in a code , it is sufficient to avoid topological structures isomorphic to the subgraph induced by the trapping set . for example to avoid @xmath66 trapping sets of fig.[sixcycle ] , it is sufficient to avoid six cycles .",
    "it is possible that a code has six cycles but no @xmath66 trapping sets . in this case",
    "all six cycles are part of @xmath70 or other trapping sets .",
    "[ sixcycle ]        [ 42trappingset ]",
    "burshtein and miller in @xcite applied expander based arguments to message passing algorithms .",
    "they analyzed ensembles of irregular graphs and showed that if the degree of each variable node is at least five , then message passing algorithms can correct a fraction of errors .",
    "codes with column weight three and four can not achieve the expansion required for these arguments .",
    "recently , burshtein in @xcite developed a new technique to investigate the error correction capability of regular ldpc codes and showed that at sufficiently large block lengths , almost all codes with column weight four are also capable of correcting a fraction of errors under bit flipping algorithm .",
    "for column - weight - three codes he notes that such a result can not be proved .",
    "this is because a non negligible fraction of codes have parallel edges in their tanner graphs and such codes can not correct a single worst case error .    in this paper",
    "we prove a stronger result by showing that for any given @xmath71 , at sufficiently large block lengths @xmath14 , no code in the @xmath15 ensemble can correct all @xmath4 or fewer errors under gallager a algorithm and show that this holds for the bit flipping algorithm also .",
    "@xcite [ lemma1 ] a code whose tanner graph has parallel edges can not correct a single worst case error .",
    "see @xcite .",
    "the proof is for bit flipping algorithm , but also applies to gallager a algorithm .",
    "[ lemma2 ] let @xmath23 be an @xmath72 regular ldpc code with girth @xmath73 .",
    "then @xmath23 has at least one failure set of size two or three",
    ".    see appendix [ appendix2 ] .",
    "[ lemma3 ] let @xmath23 be an @xmath72 regular ldpc code with girth @xmath74 .",
    "then @xmath23 has least one failure set of size three or four .    since @xmath74",
    ", there is at least one six cycle . without loss of generality , we assume that @xmath64 together with the three even degree checks @xmath75 and the three odd degree checks @xmath65 form a six cycle as in fig.[sixcycle ] . if no two checks from @xmath65 are connected to a variable node , then @xmath64 is a @xmath66 trapping set and hence a failure set of size three . on the contrary ,",
    "assume that @xmath64 do not form a @xmath66 trapping set",
    ". then there exists @xmath69 which is connected to at least two checks from @xmath65 .",
    "if @xmath69 is connected to all the three checks , @xmath76 is a codeword of weight four and it is easy to see that @xmath64 is a failure set .",
    "now assume that @xmath69 is connected to only two checks from @xmath65 . without loss of generality ,",
    "let the two checks be @xmath67 and @xmath68 .",
    "let the third check connected to @xmath69 be @xmath77 as shown in fig.[42trappingset ] .",
    "if @xmath78 and @xmath77 are not connected to a common variable node then @xmath76 is a @xmath70 trapping set and hence a failure set of size four .",
    "if @xmath78 and @xmath77 are connected to say @xmath79 , we have two possibilities : ( a ) the third check is @xmath80 and ( b ) the third check of @xmath79 is @xmath81 ( the third check can not be @xmath82 or @xmath83 as this would introduce a four cycle ) .",
    "we claim that in both cases @xmath76 is a failure set .",
    "the two cases are discussed below .",
    "case ( a ) : let @xmath84 .",
    "@xmath85 the messages in the second half of first iteration are , @xmath86 similar equations hold for @xmath87 . for @xmath78",
    "we have @xmath88 similar equations hold for @xmath77 . at the end of first iteration",
    ", we note that @xmath89 and @xmath90 receive all incorrect messages , @xmath91 and @xmath79 receive two incorrect messages and all other variable nodes receive at most one incorrect message .",
    "we therefore have @xmath92 and @xmath93 .",
    "the messages sent by variable nodes in the second iteration are , @xmath94 the messages passed in second half of second iteration are same as in second half of first iteration , except that @xmath95 . at the end of second iteration , we note that @xmath89 and @xmath90 receive all incorrect messages , @xmath91 and @xmath79 receive two incorrect messages and all other variable nodes receive at most one incorrect message .",
    "the situation is same as at the end of first iteration .",
    "the algorithm runs for _ m _ iterations and the decoder outputs @xmath96 which implies that @xmath76 is a failure set .",
    "case ( b ) : the proof is along the same lines as for case ( a ) .",
    "the messages for first iteration are the same .",
    "the messages in the first half of second iteration are , @xmath97 the messages passed in second half of second iteration are same as in second half of first iteration , except that @xmath98 and @xmath99 . at the end of second iteration , @xmath100 and",
    "@xmath79 receive two incorrect messages and all other variable nodes receive at most one incorrect message and hence @xmath101 .",
    "the messages passed in first half of third iteration ( and therefore subsequent iterations ) are same as the messages passed in first half of second iteration .",
    "the algorithm runs for _ m _ iterations and the decoder outputs @xmath96 which implies that @xmath76 is a failure set .",
    "let @xmath23 be an @xmath72 regular ldpc code with girth @xmath102 .",
    "then @xmath23 has at least one failure set of size four or five",
    ".    see appendix [ appendix2 ] .",
    "_ remark : _ it might be possible that lemmas [ lemma2][lemma4 ] can be made stronger by further analysis , i.e. , it might be possible to show that a code with girth four has a failure set of size two , a code with girth six has failure set of size three and a code with girth eight has a failure set of size four . however , these weaker lemmas are sufficient to establish the main theorem .",
    "[ lemma5 ] let @xmath23 be an @xmath72 regular ldpc code with girth @xmath11 .",
    "then the set of variable nodes @xmath103 involved in the shortest cycle is a trapping set of size @xmath12 .",
    "since @xmath23 has girth @xmath29 , there is at least one cycle of length @xmath29 . without loss of generality , assume that @xmath103 form a cycle of minimum length as shown in fig.[mincycle ] .",
    "let the even degree checks be @xmath104 and the odd degree checks be @xmath105 .",
    "note that each variable node is connected to two checks from @xmath60 and one check from @xmath59 and @xmath106 is connected to @xmath107 .",
    "we claim that no two checks from @xmath59 can be connected to a common variable node .",
    "the proof is by contradiction .",
    "assume @xmath108 and @xmath109 ( @xmath110 are connected to a variable node @xmath111 . then @xmath112 form a cycle of length @xmath113 and @xmath114 form a cycle of length @xmath115 .",
    "since @xmath11 , @xmath116 this implies that there is a cycle of length less than @xmath29 , which is a contradiction as the girth of the graph is @xmath29 .    by theorem [ thm1 ]",
    ", @xmath103 is a trapping set .",
    "[ corollary1 ] for a code to correct all @xmath0 or fewer errors , it is necessary to avoid all cycles up to length @xmath1 .",
    "we now state and prove the main theorem .",
    "[ thm2 ] consider the standard @xmath10 regular ldpc code ensemble .",
    "let @xmath71 .",
    "let @xmath117 be the smallest integer satisfying @xmath118 then , for @xmath119 , no code in the @xmath120@xmath10 ensemble can correct all @xmath4 or fewer errors .",
    "first observe that for any @xmath121 , we have @xmath122    from [ theorem c.1 @xcite ] and [ lemma c.1 @xcite ] , we have the girth @xmath29 of any code in @xmath15 is bounded by @xmath123 for @xmath121 , equations ( [ girtheq1 ] ) and ( [ girtheq2 ] ) imply that for any code in the @xmath15 ensemble , the girth is bounded by @xmath124 the result now follows from corollary [ corollary1 ] .",
    "the bit flipping algorithm does not belong to the class of message passing algorithms .",
    "however , the definitions from section [ section2 ] and the results from section [ section3 ] can be generalized to the parallel bit flipping algorithm @xcite . without loss of generality",
    "we assume that the all zero codeword is sent .",
    "we begin with a few definitions .",
    "@xcite a variable node is said to be corrupt if it is different from its original sent value . in our case , a variable node is corrupt if it is @xmath52 .",
    "a check node is said to be satisfied if it is connected to even number of corrupt variables and unsatisfied otherwise .",
    "let @xmath33 be the input to the parallel bit flipping decoder .",
    "@xmath125 is a trapping set for bit flipping algorithm if the set of corrupt variables after every iteration is @xmath125 .",
    "[ thm3 ] let @xmath126 be a set of variable nodes satisfying the conditions of theorem [ thm1 ] .",
    "then @xmath126 is a trapping set for the bit flipping algorithm .",
    "let @xmath127 .",
    "then @xmath126 is the set of corrupt variable nodes .",
    "observe that a variable flips if it is connected to at least two unsatisfied checks .",
    "since no variable is connected to two unsatisfied checks , the set of corrupt variable nodes is unchanged and by definition @xmath126 is a trapping set .",
    "we note that theorem [ thm3 ] is also a consequence of fact 3 from @xcite .",
    "a trapping set for gallager a is also a trapping set for bit flipping algorithm .",
    "it can be shown that lemmas [ lemma1][lemma5 ] and theorem [ thm2 ] also hold for the bit flipping algorithm .",
    "in this paper we have investigated the error correction capability of column - weight - three codes under gallager a and extended the results to bit flipping algorithm .",
    "future work includes investigation of sufficient conditions to correct a given number of errors for column - weight - three as well as higher column weight codes .",
    "[ [ appendix1 ] ]    _ proof of theorem [ thm1 ] : _ let @xmath33 be the input to the decoder with @xmath128 . then , @xmath129 let a check node @xmath130 . then , @xmath131 let a check node @xmath132 . then , @xmath133 for any other check node @xmath36 , @xmath134 . by the conditions of the theorem , at the end of first iteration , any @xmath135 receives at least two @xmath52 s and any @xmath136 receives at most one @xmath52",
    "so , we have @xmath137 by definition , @xmath126 is a trapping set .    to see that the conditions stated are necessary observe that for a variable node to send the same messages as in the first iteration , it should receive at least two messages which coincide with the received value .    @xmath32    [ [ appendix2 ] ]    _ proof of lemma [ lemma2 ] : _ let @xmath138 be the variable nodes that form a four cycle with even degree checks @xmath139 and odd degree checks @xmath140 .",
    "if @xmath83 and @xmath78 are not connected to a common variable node , then @xmath141 is a @xmath142 trapping set and hence a failure set of size two .",
    "now assume that @xmath83 and @xmath78 are connected to a common variable node @xmath90 .",
    "then , @xmath64 is a @xmath143 trapping set and therefore a failure set of size three .",
    "@xmath32    _ proof of lemma [ lemma4 ] : _ let @xmath144 be the variable nodes that form an eight cycle ( see fig.[44trappingset ] ) . if no two checks from @xmath145 are connected to a common variable node , then @xmath146 is a @xmath147 trapping set and hence a failure set of size four . on the other hand ,",
    "if @xmath146 is not a trapping set , then there must be at least one variable node which is connected to two checks from @xmath145 .",
    "assume that @xmath67 and @xmath77 are connected to @xmath79 and the third check of @xmath79 is @xmath148 ( see fig.[53trappingset ] ) .",
    "we claim that @xmath149 is a failure set .",
    "let @xmath150 and @xmath151 be as defined in theorem [ thm1 ] .",
    "[ 44trappingset ]        [ 53trappingset ]        * case 1 : * no two checks from @xmath152 are connected to a common variable node .",
    "then @xmath153 is a @xmath154 trapping set and hence a failure set of size five .",
    "* case 2 : * all the three checks in @xmath151 are connected to a common variable node , say @xmath155 .",
    "then @xmath156 is a codeword of weight six and it is easy to see that @xmath153 is a failure set .",
    "* case 3 : * there are variable nodes connected to two checks from @xmath151 .",
    "there can be at most two such variable nodes ( if there are three such variable nodes , they will form a cycle of length less than or equal to six violating the condition that the graph has girth eight ) . note that if @xmath157 , the decoder has a chance of correcting only if a check node in @xmath150 receives an incorrect message from a variable node outside @xmath153 in some @xmath37 iteration .",
    "we now prove that this is not possible .",
    "indeed in the first iteration    @xmath158    by similar arguments as in the proof for theorem [ thm1 ] , it can be seen that the only check nodes which send incorrect messages to variable nodes outside @xmath153 are @xmath159 and @xmath148 .",
    "there are now two subcases .",
    "* subcase 1 : * there is one variable node connected to two checks from @xmath151 .",
    "let @xmath155 be connected to @xmath68 and @xmath80 .",
    "it can be seen that the third check connected to @xmath155 can not belong to @xmath150 as this would violate the girth condition .",
    "so , let the third check be @xmath160 .",
    "in the first half of second iteration , we have @xmath161 the only check nodes which send incorrect messages to variable nodes outside @xmath153 , are @xmath162 and @xmath160 .",
    "the variable node @xmath155 is connected to @xmath68 and @xmath80 . if @xmath148 and @xmath160 are not connected to any common variable node , we are done . on the other hand ,",
    "let @xmath148 and @xmath160 be connected to a variable node , say @xmath163 .",
    "the third check of @xmath163 can not be in @xmath150 .",
    "proceeding as in the case of proof for lemma [ lemma3 ] , we can prove that @xmath153 is a failure set by observing that there can not be a variable node outside @xmath153 which sends an incorrect message to a check in @xmath150 .    * subcase 2 : * there are two variable nodes connected to two checks from @xmath151 .",
    "let @xmath68 and @xmath80 be connected to @xmath155 and @xmath68 and @xmath148 connected to @xmath163 .",
    "proceeding as above , we can conclude that @xmath153 is a failure set .",
    "this work is funded by nsf under grant ccf-0634969 , itr-0325979 and insic - ehdr program .",
    "the authors would like to thank anantharaman krishnan for illustrations .",
    "a.  shokrollahi , `` an introduction to low - density parity - check codes , '' in _ theoretical aspects of computer science : advanced lectures_.1em plus 0.5em minus 0.4emnew york , ny , usa : springer - verlag new york , inc . , 2002 , pp .",
    "175197 .",
    "s.  k. chilappagari , s.  sankaranarayanan , and b.  vasic , `` error floors of ldpc codes on the binary symmetric channel , '' in _ international conference on communications _ ,",
    "vol .  3 , june 11 - 15 2006 , pp . 10891094 ."
  ],
  "abstract_text": [
    "<S> in this paper , we investigate the error correction capability of column - weight - three ldpc codes when decoded using the gallager a algorithm . </S>",
    "<S> we prove that the necessary condition for a code to correct @xmath0 errors is to avoid cycles of length up to @xmath1 in its tanner graph . as a consequence of this result , </S>",
    "<S> we show that given any @xmath2 such that @xmath3 , no code in the ensemble of column - weight - three codes can correct all @xmath4 or fewer errors . </S>",
    "<S> we extend these results to the bit flipping algorithm .    * index terms *    low - density parity - check codes , gallager a algorithm , trapping sets , error correction capability </S>"
  ]
}