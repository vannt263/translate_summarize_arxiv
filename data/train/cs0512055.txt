{
  "article_text": [
    "given a logic program @xmath0 , can we determine that @xmath0 terminates for certain queries ?",
    "this is the well - known termination problem in logic programming .",
    "it is undecidable in general .",
    "two different ways have been explored in the literature to attack this problem .",
    "the first way is to perform termination analysis at compile time , thus referred to as a _ static _",
    "approach @xcite , while the other is to characterize and test termination of a logic program by applying a loop checking technique , thus referred to as a _ dynamic _ approach @xcite .",
    "loop checking is a technique for detecting and cutting infinite derivations at run time @xcite .",
    "static termination analysis has been extensively studied in the literature @xcite ( see @xcite for a survey ) . however , although a number of loop checking mechanisms have been proposed @xcite , it is only in @xcite that the idea of using a loop checking technique for termination analysis is formally presented .",
    "the intuition behind a dynamic approach is as follows .",
    "given a complete loop checking mechanism ( that cuts any infinite derivations ) and a set of queries , we run the program for each query while performing loop checking .",
    "if the query evaluation terminates without cutting any derivations , the program terminates for any query , otherwise it is potentially non - terminating for some queries .    in this paper , we are concerned with dynamic termination approaches .",
    "the core of such an approach is a characterization of infinite sldnf - derivations , as any loop checking mechanism relies on it . in @xcite ,",
    "the first such characterization is established for general logic programs .",
    "however , this characterization applies only to concrete queries and can not handle moded queries .",
    "a moded query contains ( abstract ) atoms like @xmath1 where @xmath2 is a term ( i.e. , a constant , variable or function ) and @xmath3 is an input mode .",
    "an _ input mode _ stands for an arbitrary ground ( i.e.  variable - free ) term .",
    "moded queries are commonly used in termination analysis of logic programs , where to prove that a logic program terminates for a moded query @xmath1 is to prove that the program terminates for any ( concrete ) query @xmath4 where @xmath5 is a ground term . consider the following logic program :    @xmath6 = @xmath7 @xmath8 = @xmath9 ` @xmath10 + @xmath11 . `",
    "@xmath12    for any concrete query @xmath13 , evaluating @xmath13 over @xmath14 will terminate .",
    "however , we can not evaluate a moded query @xmath15 while applying a loop checking mechanism to infer that @xmath14 terminates for @xmath15 .    in this paper , we present a dynamic approach to characterizing and testing termination of logic programs for moded queries . for a logic program @xmath0 and a moded query @xmath16 ,",
    "the first issue we address is how to formulate an sldnf - derivation for @xmath16 .",
    "we will introduce a framework called a _ moded - query forest _ , which consists of all ( generalized ) sldnf - trees rooted at a ground instance of @xmath16 .",
    "an sldnf - derivation for @xmath16 is defined over the moded - query forest such that @xmath0 terminates for @xmath16 if and only if the moded - query forest contains no infinite sldnf - derivations .",
    "a moded - query forest may have an infinite number of sldnf - trees , so it is infeasible to test termination of a logic program by traversing the moded - query forest .",
    "we will introduce a compact approximation for a moded - query forest , called a _ moded generalized sldnf - tree_. the key idea is to treat an input mode as a special variable like a skolem constant . as a result , top - down derivations for a moded query can be constructed in the same way as the ones for a concrete query . a characterization of termination of a logic program for moded queries is then established in terms of some novel properties of a moded generalized sldnf - tree .    the paper is organized as follows .",
    "section [ pre ] reviews some basic concepts including generalized sldnf - trees .",
    "section [ sec2 ] establishes a characterization for logic programs with moded queries .",
    "section [ sec4 ] develops an algorithm for testing termination of logic programs for moded queries .",
    "section [ related - work ] describes some closely related work , and section [ conclusion ] concludes .",
    "we assume the reader is familiar with standard terminology of logic programs as described in @xcite .",
    "variables begin with a capital letter @xmath17 or @xmath18 , and predicate , function and constant symbols with a lower case letter .",
    "let @xmath19 be an atom / term .",
    "the size of @xmath19 , denoted @xmath20 , is the number of occurrences of function symbols , variables and constants in @xmath19 .",
    "a list is of the form @xmath21 $ ] or @xmath22 $ ] where @xmath2 is a term and @xmath23 is a list . for our purpose ,",
    "the symbols @xmath24 , @xmath25 $ ] and @xmath26 in a list are treated as function symbols .",
    "two atoms are called _ variants _ if they are the same up to variable renaming .",
    "a ( general ) logic program @xmath0 is a finite set of clauses of the form @xmath27 where @xmath19 is an atom and @xmath28s are literals . throughout the paper",
    ", we consider only herbrand models . the herbrand universe and herbrand base of @xmath0",
    "are denoted by @xmath29 and @xmath30 , respectively .",
    "a goal @xmath31 is a headless clause @xmath32 where each literal @xmath33 is called a subgoal .",
    "the initial goal , @xmath34 , is called a top goal . without loss of generality , we assume that a top goal consists only of one atom . for a top goal @xmath35 , @xmath36 is called a query .",
    "@xmath16 is a _ moded query _",
    "if some arguments of @xmath19 are input modes ( in this case , @xmath19 is called an _ abstract _ atom ) ; otherwise , it is a _ concrete query_. an input mode always begins with a letter @xmath37 .    throughout the paper ,",
    "we choose to use the best - known _ depth - first , left - most _ control strategy ( used in prolog ) to describe our approach ( it can be adapted to any other fixed control strategies ) .",
    "so the _ selected subgoal _ in each goal is the left - most subgoal .",
    "a node in a top - down derivation tree ( like sldnf - trees ) is represented by @xmath38 where @xmath39 is the name of the node and @xmath31 is a goal labeling the node .",
    "an ancestor - descendant relation is defined on selected subgoals .",
    "@xmath19 is an ancestor subgoal of @xmath40 , denoted @xmath41 , if the proof of @xmath19 goes via the proof of @xmath40 .",
    "the ancestor - descendant relation is expressed using an _ ancestor list_. the ancestor list of a subgoal @xmath40 at a node @xmath42 , denoted @xmath43 , consists of all pairs @xmath44 such that @xmath19 at @xmath45 is an ancestor subgoal of @xmath40 at @xmath42 .    to characterize infinite derivations",
    "more precisely , in @xcite standard sldnf - trees @xcite are extended to sldnf@xmath46-trees .",
    "informally , an sldnf@xmath46-tree is an sldnf - tree except that each node @xmath39 is associated with an ancestor list @xmath47 for each subgoal @xmath33 . in particular , let @xmath48 be a selected subgoal at @xmath39 , then a subsidiary child sldnf@xmath46-tree @xmath49 rooted at @xmath50 will be built for solving this negative subgoal . compared with a standard subsidiary sldnf - tree @xmath51 for @xmath52 , @xmath49 has two distinct features .",
    "first , @xmath53 inherits the ancestor list @xmath54 .",
    "this mechanism bridges the ancestor - descendant relationships across sldnf@xmath46-trees and is especially useful in identifying infinite derivations across sldnf@xmath46-trees .",
    "second , @xmath49 terminates at the first success leaf , so it may not include all branches of @xmath51 . this pruning mechanism ( used in prolog )",
    "is very useful in not only improving the efficiency of query evaluation but also avoiding some possible infinite derivations ( see example [ eg - p2 ] ) .",
    "_ let @xmath0 be a logic program , @xmath34 a top goal , and @xmath55 the sldnf@xmath46-tree for @xmath56 .",
    "a _ generalized sldnf - tree _ for @xmath57 , denoted @xmath58 , is rooted at @xmath59 and consists of @xmath55 along with all its descendant sldnf@xmath46-trees , where parent and child sldnf@xmath46-trees are connected via  @xmath60 \" . in @xmath58 any path starting at the root node @xmath59 ( and ending at either a leaf or non - leaf node )",
    "is called a _",
    "generalized sldnf - derivation_. _     @xmath60 \" is called a _",
    "negation arc_. for simplicity , in the sequel by a derivation we refer to a generalized sldnf - derivation",
    ". moreover , for any node @xmath38 we use @xmath61 to refer to the selected ( i.e.  the left - most ) subgoal in @xmath31 .",
    "a derivation step is denoted by @xmath62 , meaning that applying clause @xmath63 to @xmath61 produces @xmath64 . for a substitution of two variables , @xmath65 in @xmath61 and @xmath66 in ( the head of ) @xmath63",
    ", we always use @xmath65 to substitute for @xmath66 , i.e. @xmath67 .",
    "in @xcite , a characterization of termination of logic programs is established for concrete queries .",
    "we reproduce the characterization and then extend it to the case of moded queries .",
    "[ symbol - seq ] _ let @xmath2 be a term or an atom and @xmath68 be a string that consists of all predicate symbols , function symbols , constants and variables in @xmath2 , which is obtained by reading these symbols sequentially from left to right .",
    "symbol string _ of @xmath2 , denoted @xmath69 , is the string @xmath68 with every variable replaced by @xmath70 . _    for instance , let @xmath71 , @xmath72 and @xmath73 $ ] .",
    "then @xmath74 , @xmath75 and @xmath76]$ ] .",
    "note that @xmath77 $ ] is a simplified representation for the list @xmath78]$ ] .",
    "[ sub - seq ] _ let @xmath79 and @xmath80 be two symbol strings .",
    "@xmath79 is a _ projection _ of @xmath80 , denoted @xmath81 , if @xmath79 is obtained from @xmath80 by removing zero or more elements . _",
    "[ gvar ] _ let @xmath82 and @xmath83 be two atoms .",
    "@xmath84 is said to _ loop into _ @xmath85 , denoted @xmath86 , if @xmath87 .",
    "let @xmath38 and @xmath88 be two nodes in a derivation with @xmath89 and @xmath90 . then @xmath91 is called a _ loop goal _ of @xmath31 .",
    "_    observe that if @xmath92 then @xmath93 , and that if @xmath94 is a loop goal of @xmath95 that is a loop goal of @xmath96 then @xmath94 is a loop goal of @xmath96 . since a logic program has only a finite number of clauses , an infinite derivation results from repeatedly applying the same set of clauses , which leads to either infinite repetition of selected variant subgoals or infinite repetition of selected subgoals with recursive increase in term size",
    ". by recursive increase of term size of a subgoal @xmath19 from a subgoal @xmath40 we mean",
    "that @xmath19 is @xmath40 with a few function / constant / variable symbols added and possibly with some variables changed to different variables . such crucial dynamic characteristics of an infinite derivation are captured by loop goals .    [ th1 ] let @xmath97 be a top goal with @xmath19 a concrete query .",
    "any infinite derivation @xmath98 in @xmath58 is of the form    @xmath6 @xmath99    such that for any @xmath100 , @xmath101 is a loop goal of @xmath102 .",
    "this theorem leads to the following immediate result .",
    "[ th - iff ] a logic program @xmath0 terminates for a concrete query @xmath16 if and only if @xmath58 has no infinite derivation of the form    @xmath6 @xmath99    such that for any @xmath100 , @xmath101 is a loop goal of @xmath102 .",
    "let @xmath103 be the set of predicate symbols in @xmath0 and let @xmath104 contain a concrete query @xmath105 for each @xmath106-nary predicate symbol @xmath107 in @xmath103 .",
    "note that @xmath104 is finite , as @xmath103 is finite . since @xmath104 covers all most general concrete queries for @xmath0 ,",
    "it is immediate that @xmath0 terminates for any concrete queries if and only if it terminates for all queries in @xmath104 .    in order to extend corollary [ th - iff ] to handle moded queries ,",
    "we first define derivations for a moded query .",
    "[ mod - tree ] _ let @xmath0 be a logic program and @xmath108 a moded query .",
    "the _ moded - query forest _ for @xmath16 over @xmath0 , denoted @xmath109 , consists of all generalized sldnf - trees built from @xmath57 , where @xmath110 with all @xmath111s being ground terms from @xmath29 .",
    "a derivation for @xmath16 is a derivation in any generalized sldnf - tree of @xmath109 . _",
    "therefore , a logic program @xmath0 terminates for a moded query @xmath16 if and only if @xmath109 has no infinite derivations .",
    "[ eg0 ] _ consider the logic program @xmath14 given in section [ intr ] .",
    "let @xmath15 be a moded query .",
    "the moded - query forest @xmath112 consists of generalized sldnf - trees @xmath113 , @xmath114 , etc .",
    ", as shown in figure [ fig0 ] where for simplicity the symbol @xmath115 in each goal and all ancestor lists attached to each node are omitted .",
    "note that @xmath112 has an infinite number of generalized sldnf - trees .",
    "however , any individual tree , @xmath58 with @xmath116 ( @xmath117 ) , is finite .",
    "@xmath112 contains no infinite derivations , thus @xmath14 terminates for @xmath15 . _    in a moded - query forest , all input modes are instantiated into ground terms in @xmath29 .",
    "when @xmath29 is infinite , the moded - query forest would contain infinitely many generalized sldnf - trees .",
    "thus it is infeasible to check termination of a logic program for a moded query by applying corollary [ th - iff ] over a moded - query forest .",
    "an ideal way is to directly evaluate input modes and build a compact generalized sldnf - tree for a moded query .",
    "unfortunately , query evaluation in logic programming accepts only terms as arguments of a top goal @xmath118 an input mode @xmath37 is not directly evaluable .",
    "observe the following property of an input mode : it stands for an arbitrary ground term , that is , it can be any term from @xmath29 .",
    "therefore , during query evaluation it can be instantiated against any term .",
    "this suggests that we may approximate the effect of an input mode by treating it as a special variable like a _",
    "skolem constant_. a skolem constant is an unknown constant and behaves like a variable . as a result ,",
    "top - down derivations for a moded query can be constructed in the same way as the ones for a concrete query , where an input mode @xmath37 is treated as a special variable @xmath18 .",
    "[ mod - der ] _ let @xmath0 be a logic program and @xmath108 a moded query .",
    "the _ moded generalized sldnf - tree _ for @xmath16 over @xmath0 is defined to be the generalized sldnf - tree @xmath58 for @xmath57 , where @xmath119 with all @xmath120s being distinct variables not occurring in any @xmath121 .",
    "the variables @xmath122 for the input modes @xmath123 are called _ input variables_. _    in a moded generalized sldnf - tree , an input variable @xmath18 may be substituted by either a ground term @xmath5 or a non - ground function @xmath124 ( note that @xmath18 will never be substituted by a non - input variable ) . if @xmath18 is substituted by @xmath124 , all variables in @xmath124 are also called input variables .",
    "_ let @xmath98 be a derivation in a moded generalized sldnf - tree .",
    "moded instance _ of @xmath98 is a derivation obtained from @xmath98 by first instantiating all input variables at the root node with ground terms and then passing the instantiation down to the other input variables along the derivation @xmath98 .",
    "_    let @xmath125 be a moded query .",
    "any moded instance of a derivation @xmath98 for @xmath16 is a derivation rooted at @xmath126 , where all @xmath111s are ground terms from @xmath29 .",
    "this means that any moded instance is a derivation in a moded - query forest @xmath109 .",
    "[ eg1 ]    _ consider the logic program @xmath14 again .",
    "let @xmath127 be a moded query .",
    "then @xmath128 .",
    "the moded generalized sldnf - tree @xmath58 is depicted in figure [ fig1 ] .",
    "since @xmath18 is an input variable , @xmath129 is an input variable , too ( due to the mgu ( most general unifier ) @xmath130 ) .",
    "for the same reason , all @xmath131s are input variables ( @xmath132 ) .",
    "@xmath58 has the following infinite derivation : @xmath133 by instantiating @xmath18 with different ground terms , we obtain different moded instances from this derivation .",
    "for example , instantiating @xmath18 with @xmath134 , @xmath135 and @xmath136 respectively yields the following moded instances :",
    "_    @xmath137 = @xmath138 .",
    "+ @xmath139 .",
    "+ @xmath140 .",
    "all these moded instances are derivations in the moded - query forest @xmath109 of figure  [ fig0 ] .    in a moded generalized sldnf - tree @xmath58",
    "as shown in figure [ fig1 ] , a moded query @xmath15 is approximated by a concrete query @xmath141 . since @xmath141 is more general than @xmath15 in the sense that @xmath15 covers only all ground instances of @xmath141 , @xmath58 may contain some more general derivations not covered by @xmath109 .",
    "so we have the following immediate result .",
    "[ th2 ] let @xmath109 and @xmath58 be the moded - query forest and the moded generalized sldnf - tree for @xmath16 over @xmath0 , respectively . if @xmath109 has an infinite derivation @xmath142 , @xmath58 has an infinite derivation @xmath98 with @xmath142 as a moded instance .",
    "but conversely , it is not necessarily true that if @xmath58 has an infinite derivation then @xmath109 has an infinite derivation .",
    "our goal is to establish a characterization of infinite derivations for a moded query such that the converse part of theorem [ th2 ] is true under some conditions .",
    "consider the infinite derivation in figure [ fig1 ] again .",
    "the input variable @xmath18 is substituted by @xmath143 , @xmath129 is then substituted by @xmath144 ,  .",
    "the substitutions go recursively and produce an infinite chain of substitutions for @xmath18 of the form @xmath145  .",
    "the following lemma shows that infinite derivations containing such an infinite chain of substitutions have no infinite moded instances .",
    "[ lem1 ] if a derivation @xmath98 in a moded generalized sldnf - tree @xmath58 is infinite but none of its moded instances is infinite , then there is an input variable @xmath18 such that @xmath98 contains an infinite chain of substitutions for @xmath18 of the form @xmath146 ( some @xmath147s would be the same ) .",
    "* proof : * we distinguish four types of substitution chains for an input variable @xmath18 in @xmath98 :    1 .   [ sub1 ] @xmath148 or @xmath149  .",
    "that is , @xmath18 is never substituted by any terms .",
    "[ sub2 ] @xmath150 where @xmath5 is a ground term .",
    "that is , @xmath18 is substituted by a ground term .",
    "[ sub3 ] @xmath151 , ... , where @xmath152 is the last non - ground function in the substitution chain for @xmath18 in @xmath98 . in this case",
    ", @xmath18 is recursively substituted by a finite number of functions .",
    "[ sub4 ] @xmath153  . in this case",
    ", @xmath18 is recursively substituted by an infinite number of functions .    for type [ sub1 ]",
    ", @xmath98 retains its infinite extension for whatever ground term we replace @xmath18 with . for type [ sub2 ] , @xmath98 retains its infinite extension when we use @xmath5 to replace @xmath18 . to sum up , for any input variable @xmath18",
    "whose substitution chain is of type [ sub1 ] or of type [ sub2 ] , there is a ground term @xmath5 such that replacing @xmath18 with @xmath5 does not affect the infinite extension of @xmath98 . in this case , replacing @xmath18 in @xmath98 with @xmath5 leads to an infinite derivation less general than @xmath98 .    for type [ sub3 ] , note that all variables appearing in the @xmath154s are input variables . since @xmath152 is the last non - ground function in the substitution chain for @xmath18 in @xmath98 , the substitution chain for every variable @xmath155 in @xmath152 is either of type [ sub1 ] or of type [ sub2 ] .",
    "therefore , we can replace each @xmath155 with an appropriate ground term @xmath156 without affecting the infinite extension of @xmath98 .",
    "after this replacement , @xmath98 becomes @xmath157 and @xmath152 becomes a ground term @xmath158 .",
    "now @xmath159 is the last non - ground function in the substitution chain for @xmath18 in @xmath157 . repeating the above replacement recursively , we will obtain an infinite derivation @xmath160 , which is @xmath98 with all variables in the @xmath154s replaced with a ground term .",
    "assume @xmath161 becomes a ground term @xmath5 in @xmath160 .",
    "then the substitution chain for @xmath18 in @xmath160 is of type [ sub2 ] .",
    "so replacing @xmath18 with @xmath5 in @xmath160 leads to an infinite derivation @xmath162 .",
    "the above constructive proof shows that if the substitution chains for all input variables in @xmath98 are of type [ sub1 ] , [ sub2 ] or [ sub3 ] , then @xmath98 must have an infinite moded instance .",
    "since @xmath98 has no infinite moded instance , there must exist an input variable @xmath18 whose substitution chain in @xmath98 is of type [ sub4 ] .",
    "that is , @xmath18 is recursively substituted by an infinite number of functions .",
    "note that some @xmath147s would be the same because a logic program has only a finite number of function symbols .",
    "this concludes the proof .",
    "we are ready to introduce the following principal result .",
    "[ th - main ] let @xmath109 and @xmath58 be the moded - query forest and the moded generalized sldnf - tree for @xmath16 over @xmath0 , respectively .",
    "@xmath109 has an infinite derivation if and only if @xmath58 has an infinite derivation @xmath98 of the form @xmath164 such that ( i ) for any @xmath100 , @xmath101 is a loop goal of @xmath102 , and ( ii ) for no input variable @xmath18 , @xmath98 contains an infinite chain of substitutions for @xmath18 of the form @xmath165    * proof : * ( @xmath166 ) assume @xmath109 has an infinite derivation @xmath142 . by theorem",
    "[ th2 ] , @xmath58 has an infinite derivation @xmath98 with @xmath142 as a moded instance . by theorem [ th1 ]",
    ", @xmath98 is of form ( [ eq2 ] ) and satisfies condition ( i ) .",
    "assume , on the contrary , that @xmath98 does not satisfy condition ( ii ) .",
    "that is , for some input variable @xmath18 , @xmath98 contains an infinite chain of substitutions for @xmath18 of the form @xmath165 note that for whatever ground term @xmath5 we assign to @xmath18 , this chain can be instantiated at most as long in length as the following one : @xmath167 where @xmath168 , @xmath111s are ground terms and @xmath169 .",
    "this means that replacing @xmath18 with any ground term @xmath5 leads to a finite moded instance of @xmath98 .",
    "therefore , @xmath98 has no infinite moded instance in @xmath109 , a contradiction .",
    "( @xmath170 ) assume , on the contrary , that @xmath109 has no infinite derivation . by lemma [ lem1 ] , we reach a contradiction to condition ( ii ) . @xmath163    the following corollary is immediate to theorem [ th - main ] .",
    "[ cor - main ] a logic program @xmath0 terminates for a moded query @xmath16 if and only if the moded generalized sldnf - tree @xmath58 has no infinite derivation of form ( [ eq2 ] ) satisfying conditions ( i ) and ( ii ) of theorem [ th - main ] .    [ eg0 - 1 ] _ consider the moded generalized sldnf - tree @xmath58 in figure [ fig1 ] .",
    "it has one infinite derivation satisfying condition ( i ) of theorem [ th - main ] , where for each @xmath171 , @xmath172 .",
    "however , the chain of substitutions for @xmath18 in this derivation violates condition ( ii ) . by corollary [ cor - main ]",
    ", @xmath14 terminates for the moded query @xmath15 .",
    "_    [ eg - nonstop ]    _ consider the following logic program :",
    "_    @xmath6 = @xmath173 @xmath8 = @xmath174 ` @xmath175 + @xmath176 . `",
    "@xmath10    for a moded query @xmath15 , the moded generalized sldnf - tree @xmath177 is shown in figure [ fig - nonstop ] , where @xmath178 represents an infinite extension .",
    "note that the input variable @xmath18 is allowed to appear in negative subgoals .",
    "the infinite derivation in @xmath177 satisfies both condition ( i ) and condition ( ii ) of theorem [ th - main ] , where for each @xmath171 , @xmath172 . by corollary [ cor - main ]",
    ", @xmath179 does not terminate for @xmath15 .",
    "we develop an algorithm for checking termination of logic programs for moded queries based on corollary [ cor - main ] .",
    "we begin by introducing a loop checking mechanism .",
    "a loop checking mechanism , or more formally a _ loop check _ @xcite , defines conditions for us to cut a ( possibly infinite ) derivation at some node .",
    "informally , a loop check is said to be _ weakly sound _ if for any generalized sldnf - tree @xmath58 , @xmath58 having a success derivation before cut implies it has a success derivation after cut ; it is said to be _ complete _ if it cuts all infinite derivations in @xmath58 .",
    "note that there exists no loop check that is both weakly sound and complete @xcite . in this paper , we focus on complete loop checks because we want to apply them to test termination of logic programs .",
    "[ mq - check ] _ given a repetition number @xmath180 , _ lp - check _ is defined as follows : any derivation @xmath98 in @xmath58 is cut at a node @xmath181 if @xmath98 has a partial derivation @xmath182 such that ( a ) for any @xmath183 , @xmath101 is a loop goal of @xmath102 , and ( b ) for all @xmath184 , the clause @xmath185 applied to @xmath102 is the same . _",
    "* remark : * ( 1 ) the repetition number @xmath186 specifies the minimum number of loop goals required for a derivation to be cut .",
    "( 2 ) by cutting a derivation at a node @xmath42 we mean removing all descendants of @xmath42 .",
    "[ check - comp ] lp - check is a complete loop check .",
    "* proof : * let @xmath98 be an infinite derivation in @xmath58 . by theorem [ th1 ] , @xmath98 is of the form @xmath187 such that for any @xmath188 , @xmath189 is a loop goal of @xmath190 . since a logic program has only a finite number of clauses , there must be a clause @xmath185 being repeatedly applied at infinitely many nodes @xmath191 where for each @xmath100 , @xmath192 .",
    "then for any @xmath193 , @xmath98 has a partial derivation of form ( [ eq3 ] ) .",
    "so @xmath98 will be cut at node @xmath194 .",
    "this shows that any infinite derivation can be cut by lp - check .",
    "that is , lp - check is a complete loop check .",
    "[ eg1 - 1 ] _ let us choose @xmath195 and consider the infinite derivation @xmath98 in figure [ fig1 ] .",
    "@xmath196 at @xmath197 is a loop goal of @xmath198 at @xmath199 that is a loop goal of @xmath141 at @xmath200 .",
    "moreover , the same clause @xmath12 is applied at the three nodes .",
    "@xmath98 satisfies the conditions of lp - check and is cut at node @xmath197 .",
    "_    we want to apply lp - check to determine termination of logic programs for moded queries .",
    "recall that to prove that a logic program @xmath0 terminates for a moded query @xmath201 is to prove that @xmath0 terminates for any query @xmath202 @xmath203 where each @xmath111 is a ground term .",
    "this can be reformulated in terms of a moded - query forest , that is , @xmath0 terminates for @xmath16 if @xmath109 has no infinite derivations .",
    "then , corollary [ cor - main ] shows that @xmath0 terminates for @xmath16 if the moded generalized sldnf - tree @xmath58 has no infinite derivation @xmath98 of form ( [ eq2 ] ) that satisfies the two conditions ( i ) and ( ii ) .",
    "although this characterization can not be directly used for automated termination test because it requires generating infinite derivations in @xmath58 , it can be used together with lp - check , as lp - check is able to guess if a partial derivation would extend to an infinite one . before describing our termination testing algorithm",
    ", we prepare one more condition for definition [ mq - check ] based on condition ( ii ) of theorem  [ th - main ] .",
    "* condition ( c ) : * for no input variable @xmath18 in @xmath204 , @xmath18 is recursively substituted by at least one function via a chain of substitutions from @xmath205 down to @xmath181 .    for instance",
    ", in figure [ fig1 ] , @xmath18 is recursively substituted by @xmath143 and @xmath144 via a chain of substitutions @xmath206 , @xmath207 from @xmath200 down to @xmath197 .",
    "observe that lp - check and condition ( c ) implement conditions ( i ) and ( ii ) of theorem [ th - main ] , respectively .",
    "although the implementation is not complete in that it guesses an infinite extension ( [ eq2 ] ) from a partial derivation ( [ eq3 ] ) , such a guess is most likely correct because it makes full use of the key features ( conditions ( i ) and ( ii ) of theorem [ th - main ] ) of an infinite derivation .",
    "this motivates the following algorithm .",
    "[ alg1 ]    _ testing termination of a logic program @xmath0 for a moded query @xmath16 , given a repetition number @xmath180 . _    1 .   initially , set @xmath208 .",
    "construct the moded generalized sldnf - tree @xmath58 , where for each partial derivation @xmath98 satisfying the conditions of lp - check , if @xmath98 satisfies condition ( c ) then goto [ no ] , else set @xmath209 and extend @xmath98 with clause @xmath185 skipped .",
    "return _ terminating _ if @xmath208 ; otherwise return _ most likely terminating _ 3 .",
    "[ no ] return _ most likely non - terminating_.    starting from the root node @xmath59 , we generate derivations of a moded generalized sldnf - tree @xmath58 step by step .",
    "if a partial derivation @xmath98 of the form @xmath210 is generated , which satisfies the conditions of lp - check , then @xmath98 is most likely to extend infinitely in @xmath58 ( via clause @xmath185 ) . by theorem [ th2",
    "] , however , @xmath98 may not have infinite moded instances in @xmath109 .",
    "so in this case , we further check @xmath98 against condition ( c ) .",
    "if condition ( c ) is satisfied , we think that @xmath98 is most likely to have moded instances that extend infinitely in @xmath109 .",
    "algorithm [ alg1 ] then returns _ most likely non - terminating _ for @xmath16 .",
    "otherwise , we continue to extend @xmath98 by applying a new clause @xmath211 ( @xmath212 ) to @xmath213 ( @xmath185 is skipped to avoid possible infinite extension ) .",
    "after all derivations are generated , we distinguish between two cases : if no derivation was cut by lp - check ( i.e. there was no partial derivation @xmath98 satisfying the conditions of lp - check ) , algorithm [ alg1 ] returns _ terminating _ for @xmath16 ; otherwise , some derivations were cut by lp - check ( @xmath209 ) , so algorithm [ alg1 ] returns _ most likely terminating _ for @xmath16 .",
    "* remark : * since a concrete query could be viewed as a special moded query containing no input variables , algorithm [ alg1 ] applies to concrete queries as well . for a concrete query @xmath16 , condition ( c ) holds for any derivations . therefore , algorithm [ alg1 ] returns _ most likely non - terminating _ for @xmath16 once a derivation satisfying the conditions of lp - check is generated .",
    "[ th - terminating ] @xmath0 terminates for @xmath16 if algorithm [ alg1 ] returns an answer _",
    "terminating_.    * proof : * if algorithm [ alg1 ] returns _ terminating _ , no derivations were cut by lp - check , so the moded generalized sldnf - tree @xmath58 for @xmath16 is finite . by theorem [ th2 ] , @xmath109 has no infinite derivation and thus @xmath0 terminates for @xmath16 .",
    "@xmath163    algorithm [ alg1 ] applies lp - check to cut possible infinite derivations in @xmath58 .",
    "since lp - check is a complete loop check , it cuts all infinite derivations at some depth .",
    "this means that @xmath58 after cut by lp - check is finite .",
    "therefore , algorithm [ alg1 ] always terminates .",
    "let @xmath103 be the set of predicate symbols in @xmath0 .",
    "define    @xmath8 @xmath214 is a @xmath106-ary predicate symbol in @xmath215 .",
    "note that @xmath216 contains all most general moded queries of @xmath0 in the sense that any moded query of @xmath0 is an instance of some query in @xmath216 .",
    "since @xmath103 is finite , @xmath216 is finite .",
    "therefore , we can test termination of @xmath0 for all moded queries by applying algorithm [ alg1 ] to ( a subset of ) @xmath216 .",
    "[ th - inc ] for any two moded queries @xmath217 and @xmath218 with @xmath219 ,",
    "if algorithm [ alg1 ] returns an answer _ terminating _ ( resp .",
    "_ most likely terminating _ ) for @xmath220 , it returns an answer _ terminating _ ( resp . _ most likely terminating _ ) for @xmath221 .",
    "* proof : * any derivation in @xmath222 that satisfies the conditions of lp - check and condition ( c ) must appear in @xmath223 and satisfy the conditions .",
    "if algorithm [ alg1 ] returns _ terminating _ for @xmath220 , @xmath223 is the same as @xmath222 with no derivations cut by lp - check . in this case , it returns _ terminating _ for @xmath221 .",
    "if algorithm [ alg1 ] returns _ most likely terminating _ for @xmath220 , @xmath223 has derivations cut by lp - check , but none of which satisfies condition ( c ) . in this case",
    ", @xmath222 has derivations cut by lp - check , none of which satisfies condition ( c ) . therefore , algorithm [ alg1 ] returns _ most likely terminating _ for @xmath221 .",
    "@xmath163    we use five representative examples to illustrate the effectiveness of algorithm [ alg1 ] ( interested readers are encouraged to apply the algorithm to other benchmark programs ) . for each logic program @xmath224",
    ", we expect that if @xmath224 terminates for a query @xmath16 , then algorithm [ alg1 ] returns _ terminating _ or _ most likely terminating _ for @xmath16 , else it returns _ most likely non - terminating _ for @xmath16 .",
    "let us choose a repetition number @xmath225 .",
    "[ eg1 - 2 ] _ since the partial derivation ( figure [ fig1 ] ) between @xmath200 and @xmath197 satisfies the conditions of lp - check , algorithm [ alg1 ] expects that the derivation is most likely to extend infinitely in @xmath58 .",
    "it then checks against condition ( c ) to see if it has moded instances that would extend infinitely in @xmath109 .",
    "clearly , condition ( c ) is not satisfied .",
    "so algorithm [ alg1 ] skips @xmath12 and tries to get a new clause ( not yet applied at @xmath197 ) to expand @xmath197 . since no new clause is available for @xmath197 and all derivations of @xmath58 except those being cut by lp - check",
    "have been generated , algorithm [ alg1 ] returns _ most likely terminating _ for @xmath16 .",
    "_    [ eg - nonstop-2 ] _ the partial derivation between @xmath200 and @xmath197 satisfies both the conditions of lp - check and condition ( c ) , so algorithm [ alg1 ] returns _ most likely non - terminating _ for @xmath15 . _",
    "[ eg - p2 ]    _ consider the following logic program : _",
    "@xmath6 = @xmath226 @xmath8 = @xmath227 . `",
    "@xmath10 + @xmath228 . `",
    "@xmath175 + @xmath229 . `",
    "@xmath230    for a moded query @xmath15 , algorithm [ alg1 ] generates a moded generalized sldnf - tree @xmath177 , as depicted in figure [ fig - p2 ] where input variables are underlined .- tree rooted at @xmath231 for @xmath232 terminates at the first success leaf @xmath233 , so @xmath197 is not extended .",
    "] since no derivation is cut by lp - check , algorithm [ alg1 ] returns _ terminating _ for @xmath15 .",
    "[ eg2 ]    _ consider the following logic program : _    @xmath6 = @xmath234 @xmath8 = @xmath235,x , x)$ ] . `",
    "@xmath236 + @xmath237,u,[x|z])\\leftarrow append(y , u , z)$ ] . ` @xmath238    let us choose the three simplest moded queries :    @xmath239 = @xmath240 , + @xmath241 , + @xmath242 .",
    "since applying clause @xmath236 produces only leaf nodes , for simplicity we ignore it when depicting moded generalized sldnf - trees .",
    "it is quite easy to determine the termination behavior for the above three moded queries .",
    "algorithm [ alg1 ] builds @xmath223 , @xmath222 and @xmath243 as shown in figures [ fig2 ] ( a ) , ( b ) and ( c ) , respectively .",
    "note that all the derivations starting at @xmath200 and ending at @xmath199 satisfy the conditions of lp - check , so they are cut at @xmath199 .",
    "since the derivations in @xmath223 and @xmath243 do not satisfy condition ( c ) ( @xmath18 is recursively substituted via a chain of substitutions @xmath244 , \\underline{y}/[x_1|y_1]$ ] ) , algorithm [ alg1 ] returns _ most likely terminating _ for @xmath220 and @xmath245 .",
    "since the derivation in @xmath222 satisfies condition ( c ) , algorithm [ alg1 ] returns _ most likely non - terminating _ for @xmath221 . by theorem",
    "[ th - inc ] , we infer that @xmath246 most likely terminates for all moded queries in @xmath247 except for @xmath221 .",
    "[ eg3 ]    _ consider the following logic program : _",
    "@xmath6 = @xmath248 @xmath8 = @xmath249 . `",
    "@xmath250 + @xmath251 . `",
    "@xmath252 + @xmath253 . `",
    "@xmath236 + @xmath254 . ` @xmath238    @xmath255 consists of fourteen moded queries , seven for @xmath256 and seven for @xmath257 .",
    "applying algorithm [ alg1 ] yields the solution : ( 1 ) @xmath258 most likely terminates for all moded queries of @xmath257 except for @xmath259 that is most likely non - terminating , and ( 2 ) @xmath258 most likely terminates for @xmath260 and @xmath261 but is most likely non - terminating for the remaining moded queries of @xmath256 . for illustration , we depict two moded generalized sldnf - trees for @xmath262 and @xmath260 , as shown in figures [ fig - eg3 ] ( a ) and ( b ) , respectively . in the two moded generalized sldnf - trees ,",
    "the partial derivation from @xmath200 down to @xmath199 satisfies the conditions of lp - check but violates condition ( c ) , so clause @xmath250 is skipped when expanding @xmath199 . when the derivation is extended to @xmath263 , the conditions of lp - check are satisfied again , where @xmath264 is a loop goal of @xmath265 that is a loop goal of @xmath266 . since the derivation for @xmath262 ( figure [ fig - eg3 ] ( a ) ) also satisfies condition ( c ) , algorithm [ alg1 ]",
    "returns an answer @xmath267_most likely non - terminating _",
    "@xmath267 for this moded query .",
    "the derivation for @xmath260 ( figure [ fig - eg3 ] ( b ) ) does not satisfy condition ( c ) , so clause @xmath236 is skipped to expand @xmath263 . for simplicity , we omitted all derivations leading to a leaf node @xmath268 .",
    "because there is no derivation satisfying both the conditions of lp - check and condition ( c ) , algorithm [ alg1 ] ends up with an answer @xmath267 _ most likely terminating _",
    "@xmath267 for @xmath260 .",
    "it is then immediately inferred by theorem [ th - inc ] that @xmath258 most likely terminates for @xmath261 .    for each of the above five example logic programs , @xmath269 , it terminates for a moded query if and only if applying algorithm [ alg1 ] with the smallest repetition number @xmath225 yields an answer @xmath267 _ terminating _ or _ most likely terminating _",
    "@xmath267 for the query .",
    "this is true for commonly used benchmark logic programs in the literature . due to the undecidability of the termination problem ,",
    "however , there exist cases that algorithm [ alg1 ] yields an incorrect answer unless a big repetition number is used .",
    "consider the following carefully created logic program :    @xmath6 = @xmath270 @xmath8 = @xmath271 ` @xmath10 + @xmath272 ` @xmath12 + @xmath273 ` @xmath175    @xmath274 does not terminate for a moded query @xmath275 , but algorithm [ alg1 ] will return _ most likely terminating _ for @xmath16 unless the repetition number @xmath186 is set above 100 .",
    "the question of which repetition number ( also called _ depth bound _ in some literature ) is optimal remains open for a long time in loop checking @xcite . in @xcite",
    ", the authors say  the only way to deal with this problem is by heuristically tuning the depth bound in practical situations .",
    "\" however , up till now we see no heuristic methods reported in the literature .    in this paper",
    ", we propose a simple yet effective heuristic method for handling the repetition number problem .",
    "observe that due to the large argument @xmath276 in its head , the second clause of @xmath274 can not be applicable to @xmath277 .",
    "however , the second argument of @xmath277 can grow as large as @xmath276 if the first clause is repeatedly applied .",
    "our intuition then is that instead of choosing a big repetition number , we use a small one ( say @xmath225 ) with some additional constraints that help @xmath277 grow up to its expected size before a derivation is cut . for each @xmath106-ary predicate symbol @xmath107 ,",
    "let @xmath278 ( @xmath279 ) denote the maximum layers of nested functions in the @xmath280-th argument of all clause heads @xmath281 .",
    "for instance , in @xmath274 @xmath282 and @xmath283 .",
    "the following heuristic defines a constraint .",
    "* heuristic 1 : * when some arguments of @xmath281 grow in a sequence of loop goals , if a derivation is cut at some loop goal , each @xmath280-th growing argument of @xmath281 in this goal has at least @xmath278 layers of nested functions .",
    "it is easy to enhance lp - check with heuristic 1 , simply by adding a third condition to definition [ mq - check ] :    1 .",
    "let @xmath284 .",
    "if some arguments of @xmath281 grow from @xmath205 , @xmath285 , ... , to @xmath181 , then each @xmath280-th growing argument of @xmath281 at @xmath181 has at least @xmath278 layers of nested functions .",
    "it is easy to prove that enhancing lp - check with heuristic 1 does not change the completeness of lp - check .",
    "let @xmath98 be an infinite derivation and let @xmath68 be the set of finite partial derivations of @xmath98 satisfying conditions ( a ) and ( b ) of lp - check and satisfying the if - part of condition ( c ) .",
    "assume , on the contrary , that no derivation in @xmath68 satisfies the then - part of condition ( c ) ( in this case , @xmath98 will not cut by lp - check enhanced with heuristic 1 ) .",
    "this case will never occur unless for some @xmath280-th argument of @xmath281 , @xmath278 is an infinite number . since @xmath278 is finite , the above assumption",
    "does not hold .",
    "[ eg - p5 ]    _ consider the logic program @xmath274 again .",
    "let us choose @xmath225 . by enhancing lp - check with heuristic 1 , algorithm [ alg1 ]",
    "builds a moded generalized sldnf - tree for the moded query @xmath275 as shown in figure [ fig - eg5 ] .",
    "note that the first three nodes satisfy conditions ( a ) and ( b ) of lp - check but violate condition ( c ) .",
    "although the second argument of @xmath281 grows from @xmath200 through @xmath286 to @xmath199 , it has not grown to its maximum @xmath283 .",
    "so the extension continues until it reaches @xmath287 .",
    "the three nodes @xmath288 , @xmath289 and @xmath287 satisfy conditions ( a ) , ( b ) and ( c ) .",
    "since they do not satisfy condition ( c ) , algorithm [ alg1 ] cuts the derivation by skipping the clause @xmath10 for @xmath287 .",
    "when the extension goes to @xmath290 , the three nodes @xmath291 , @xmath292 and @xmath290 satisfy conditions ( a ) , ( b ) and ( c ) and condition ( c ) , thus algorithm [ alg1 ] returns _ most likely non - terminating _ for @xmath293 .",
    "_    as opposed to @xmath16 , for another interesting moded query @xmath294 , algorithm [ alg1 ] will yield an answer _ most likely terminating_.      algorithm [ alg1 ] establishes a general framework for dynamic termination analysis of general logic programs with concrete or moded queries .",
    "it claims _ terminating_/_non - terminating _ only if the answer is provably terminating / non - terminating ( see theorem [ th - terminating ] ) ; otherwise it gives an approximate answer : _ most likely terminating _ or _ most likely non - terminating_. although exploring all possible provably correct cases is beyond the scope of this paper ( an interesting topic for further work ) , we identify the following two simple yet commonly occurring cases .    for",
    "a logic program @xmath0 and a moded query @xmath16 , assume that algorithm [ alg1 ] encounters a partial derivation @xmath98 @xmath295 that contains no negation arc  @xmath60 \" and satisfies the conditions of lp - check , where for any @xmath183 , @xmath296 is a variant of @xmath297 and the sequence @xmath298 of clauses applied between @xmath299 and @xmath300 is the same as the sequence between @xmath301 and @xmath299 .",
    "@xmath0 is non - terminating for @xmath16 if @xmath98 satisfies condition ( c ) and @xmath208 .",
    "* proof : * since we use a fixed depth - first , left - most control strategy and @xmath98 contains no negation arc , , the evaluation of @xmath19 at @xmath53 will stop once one success derivation for @xmath19 is generated . some ( infinite ) derivations for @xmath19 may then be skipped .",
    "] @xmath98 will be extended towards an infinite derivation @xmath142 by repeatedly applying the same sequence @xmath298 of clauses , thus leading to an infinite number of loop goals @xmath302 , @xmath303 , ... , where for each @xmath304 , @xmath305 is a variant of @xmath306 .",
    "since @xmath98 satisfies condition ( c ) , @xmath142 also satisfies condition ( c ) because we apply the same sequence of clauses to variants of subgoals . by lemma [ lem1 ] , @xmath142 must have an infinite moded instance .",
    "the condition @xmath208 indicates that algorithm [ alg1 ] never incorrectly cuts any derivations before , hence @xmath0 is non - terminating for @xmath16 .",
    "@xmath163    if @xmath98 does not satisfy condition ( c ) and for each @xmath184 , @xmath102 contains only one subgoal , then the moded generalized sldnf - tree @xmath58 contains an infinite derivation with an infinite moded instance if and only if it contains an infinite derivation with an infinite moded instance after skipping the clause @xmath185 at @xmath181 .    *",
    "proof : * following the above proof of optimization strategy 1 , when @xmath98 does not satisfy condition ( c ) , @xmath142 does not satisfy condition ( c ) , either . by lemma [ lem1 ]",
    ", @xmath142 has no infinite moded instance .    for simplicity ,",
    "let @xmath298 be the sequence of two clauses , @xmath307 .",
    "assume for each @xmath308 , we have derivation steps @xmath309 since @xmath296 is a variant of @xmath297 , @xmath310 is a variant of @xmath311 .",
    "let us cut @xmath142 at @xmath181 ( i.e. extend @xmath98 with the clause @xmath185 skipped ) .",
    "assume that @xmath58 has an infinite derivation @xmath312 with an infinite moded instance before this cut , and that on the contrary it has no infinite derivation with an infinite moded instance after the cut .",
    "@xmath312 must be an extension of @xmath98 by repeatedly applying @xmath307 for a certain number of times and then at some node @xmath313 ( or @xmath314 ) , skipping @xmath185 ( or @xmath315 ) to go towards an infinite derivation . since @xmath316 is a variant of @xmath317 , ( resp .",
    "@xmath318 is a variant of @xmath319 ) , a copy ( up to variable renaming ) of the infinite derivation starting from @xmath313 ( or from @xmath314 ) will appear starting from @xmath320 ( or from @xmath321 ) .",
    "this copy of an infinite derivation has the same infinite moded instances as @xmath312 .",
    "this contradicts our assumption .",
    "the above proof shows that if @xmath58 has an infinite derivation with an infinite moded instance , then it has an infinite derivation with an infinite moded instance after skipping @xmath185 at @xmath181 . since @xmath98 is negation - free ( with no negation arcs )",
    ", the converse also holds .",
    "this proves the correctness of optimization strategy 2 .",
    "@xmath163    when the condition of optimization strategy 2 holds , we can extend @xmath98 with the clause @xmath185 skipped safely .",
    "therefore , in this case we do not need to set @xmath209 in algorithm [ alg1 ] ( setting @xmath209 leads to an approximate answer ) .    plugging the above two strategies into algorithm [ alg1 ]",
    "gives rise to the following new algorithm .",
    "[ alg2 ]    _ testing termination of a logic program @xmath0 for a moded query @xmath16 , given a repetition number @xmath180 . _    1 .   initially , set @xmath208",
    ". construct the moded generalized sldnf - tree @xmath58 , where for each partial derivation @xmath98 satisfying the conditions of lp - check , if @xmath98 satisfies condition ( c ) then goto [ no ] , else set @xmath209 unless the condition of optimization strategy 2 holds , and extend @xmath98 with clause @xmath185 skipped .",
    "2 .   return _ terminating _ if @xmath208 ; otherwise return _ most likely terminating _ 3 .",
    "return _ non - terminating _ if the condition of optimization strategy 1 holds ; otherwise return _ most likely non - terminating_.    [ eg - more ]    _ we test the termination of logic programs , @xmath322 , again by applying algorithm [ alg2 ] . _    for @xmath14 , the partial derivation ( figure [ fig1 ] ) between @xmath200 and @xmath197 satisfies the condition of optimization strategy 2 ,",
    "so algorithm [ alg2 ] skips @xmath12 .",
    "it keeps @xmath208 till the end and returns _ terminating _ for @xmath16 ( algorithm [ alg1 ] returns _ most likely terminating _ ) .    for @xmath179 ,",
    "neither of the two strategies is applicable , so algorithm [ alg2 ] returns _ most likely non - terminating _ for @xmath15 as algorithm [ alg1 ] does .    for @xmath323 ,",
    "algorithm [ alg2 ] returns _ terminating _ for @xmath15 . for a query @xmath228",
    ", its derivation satisfies the condition of optimization strategy 1 , thus leading to an answer _ non - terminating _ ( algorithm [ alg1 ] returns _ most likely non - terminating _ ) .    for @xmath246 , like algorithm [ alg1 ] , algorithm [ alg2 ] builds @xmath223 , @xmath222 and @xmath243 as shown in figures [ fig2 ] ( a ) , ( b ) and ( c ) , respectively for the three moded queries .",
    "the derivations in @xmath223 and @xmath243 satisfy the condition of optimization strategy 2 , so algorithm [ alg2 ] keeps @xmath208 till the end and returns an answer _ terminating _ ( algorithm [ alg1 ] returns _ most likely terminating _ ) for @xmath220 and @xmath245 .",
    "the derivation in @xmath222 satisfies the condition of optimization strategy 1 , so algorithm [ alg2 ] returns an answer _ non - terminating _ ( algorithm [ alg1 ] returns _ most likely non - terminating _ ) for @xmath221 . by theorem [ th - inc ]",
    ", we infer that @xmath246 terminates for all moded queries in @xmath247 except for @xmath221 that does not terminate .    for @xmath258 ,",
    "neither of the two strategies is applicable , so algorithm [ alg2 ] returns the same answers as algorithm [ alg1 ] .    for @xmath274 , algorithm [ alg2 ]",
    "returns the same answers as algorithm [ alg1 ] for any moded queries with a predicate symbol @xmath107 . for the query @xmath228 , optimization strategy 1 applies ,",
    "so algorithm [ alg2 ] returns an answer _ non - terminating_.",
    "termination of a logic program can be addressed in either a static or a dynamic way .",
    "static termination analysis builds from the source code of a logic program some well - founded termination conditions / constraints in terms of level mappings , interargument size relations and/or instantiation dependencies @xcite .",
    "in contrast , a dynamic termination approach characterizes and tests termination of a logic program by applying a loop checking technique .",
    "it directly makes use of some essential dynamic characteristics of infinite derivations , such as repetition of variant subgoals and recursive increase in term size , which are hard to capture in a static way ( for example , it is difficult to apply static termination analysis to prove that @xmath323 terminates for a moded query @xmath15 and that @xmath274 terminates for @xmath324 but does not terminate for @xmath293 ) .",
    "this paper develops a new dynamic approach with a characterization and a testing algorithm for moded queries . to the best of our knowledge ,",
    "no similar work has been reported in the literature .",
    "the core of a dynamic termination approach is a characterization of infinite derivations . in @xcite ,",
    "the first such characterization is established for general logic programs .",
    "however , it applies only to concrete queries and can not handle moded queries .",
    "a dynamic termination approach uses a loop checking mechanism ( a loop check ) to implement a characterization of infinite derivations .",
    "representative loop checks include va - check @xcite , os - check @xcite , and vaf - checks @xcite .",
    "all apply to positive logic programs . in particular",
    ", va - check applies to function - free logic programs , where an infinite derivation is characterized by a sequence of selected _ variant subgoals_. os - check identifies an infinite derivation with a sequence of selected subgoals with the same predicate symbol _ whose sizes do not decrease_. vaf - checks take a sequence of selected _ expanded variant subgoals _ as major characteristics of an infinite derivation .",
    "expanded variant subgoals are variant subgoals except that some terms may grow bigger . in this paper , a new loop check mechanism ,",
    "lp - check ( with heuristic 1 ) , is introduced in which an infinite derivation is identified with a sequence of _ loop goals_. lp - check is more effective than va - check , os - check and vaf - checks , none of which can handle the logic program @xmath274 .",
    "most importantly , enhancing lp - check with condition ( c ) leads to the first loop check for moded queries .",
    "we have presented a dynamic approach to characterizing and testing termination of a general logic program .",
    "the approach is very powerful and useful . it can be used ( 1 ) to test if a logic program terminates for a given concrete or moded query , ( 2 ) to test if a logic program terminates for all concrete or moded queries , and ( 3 ) to find all ( most general ) concrete / moded queries that are most likely terminating ( or non - terminating ) . for any concrete / moded query ,",
    "the algorithm yields an answer _ terminating _ , _ most likely terminating _ , _ non - terminating _ or _ most likely non - terminating_. for a great majority of representative logic programs we collected in the literature , an answer _ most likely terminating _ ( resp . _ most likely non - terminating _ ) implies terminating ( resp . non - terminating ) .",
    "the algorithm can be incorporated into prolog as a debugging tool , which would provide the user with valuable debugging information for him / her to understand the causes of non - termination .",
    "a conspicuous advantage of a dynamic termination approach over static termination analysis is that it tests termination on the fly ( i.e. by evaluating some queries ) , thus capturing essential characteristics of infinite derivations .",
    "this makes a dynamic approach able to guess if a partial derivation is most likely to extend towards an infinite one .",
    "although static termination analysis has been extensively studied over the last few decades , exploration of dynamic termination approaches is just at the beginning .",
    "we expect to see more prosperous research in this direction .",
    "many problems are open , including extensions to typed queries @xcite and to logic programs with tabling @xcite .",
    "our ongoing work aims to develop a dynamic termination analyser and make a comparative study with existing static termination analysers .",
    "it is also promising future work to combine static and dynamic approaches for a hybrid termination analyser .",
    "a. brodsky and y. sagiv , inference of inequality constraints in logic programs , in : _ proc . of the tenth acm sigact - sigmod - sigart symposium on principles of database systems",
    "_ , denver , usa , acm press , 1991 , pp . 227 - 240 .",
    "m. bruynooghe , m. codish , j. gallagher , s. genaim , and w. vanhoof , termination analysis of logic programs through combination of type - based norms , _ acm transactions on programming languages and systems _ , to appear .",
    "d. chan , constructive negation based on the completed database , in : r. a. kowalski and k. a. bowen ( eds . ) , _ proc .",
    "of the fifth international conference and symposium on logic programming _ , seattle , usa , mit press , 1988 , pp .",
    "111 - 125 .",
    "s. decorte , d. de schreye and m. fabris , automatic inference of norms : a missing link in automatic termination analysis , in : d. miller ( ed . ) , _ proc . of the 1993 international symposium on logic programming _ , vancouver , canada , mit press , 1993 , pp .",
    "420 - 436 .",
    "n. lindenstrauss and y. sagiv , automatic termination analysis of logic programs , in : l. naish ( ed . ) _ proc . of the fourteenth international conference on logic programming _ , leuven , belgium . mit press , 1997 , pp .",
    "63 - 77 .",
    "f. mesnard and u. neumerkel , applying static analysis techniques for inferring termination conditions of logic programs , _ the 8th international symposium on static analysis _ ,",
    "paris , france , 2001 , pp .",
    "93 - 110 .",
    "l. plmer , termination proofs for logic programs based on predicate inequalities , in : d. h. d. warren and p. szeredi ( eds . ) , _ proceedings of the seventh international conference on logic programming _ , mit press , cambridge , ma , 1990 , pp . 634 - 648 ."
  ],
  "abstract_text": [
    "<S> the termination problem of a logic program can be addressed in either a static or a dynamic way . </S>",
    "<S> a static approach performs termination analysis at compile time , while a dynamic approach characterizes and tests termination of a logic program by applying a loop checking technique . in this paper </S>",
    "<S> , we present a novel dynamic approach to termination analysis for general logic programs with moded queries . </S>",
    "<S> we address several interesting questions , including how to formulate an sldnf - derivation for a moded query , how to characterize an infinite sldnf - derivation with a moded query , and how to apply a loop checking mechanism to cut infinite sldnf - derivations for the purpose of termination analysis . </S>",
    "<S> the proposed approach is very powerful and useful . </S>",
    "<S> it can be used ( 1 ) to test if a logic program terminates for a given concrete or moded query , ( 2 ) to test if a logic program terminates for all concrete or moded queries , and ( 3 ) to find all ( most general ) concrete / moded queries that are most likely terminating ( or non - terminating ) .    </S>",
    "<S> * keywords : * logic programming , moded queries , termination analysis , loop checking . </S>"
  ]
}