{
  "article_text": [
    "the graph isomorphism problem is the decision problem of determining whether two finite graphs , @xmath0 and @xmath1 are isomorphic , denoted @xmath2 .",
    "the graphs are isomorphic if and only if there exists a bijection @xmath3 between the two sets of vertices @xmath4 and @xmath5 such that , for every pair of vertices @xmath6 in @xmath4 , the edge @xmath7 exists in @xmath8 if and only if the corresponding edge @xmath9 exists in e.@xcite formally :    @xmath10    the graph isomorphism problem is of particular interest in the field of computational complexity theory , since it is one of only a few problems whose complexity class is not solidly classified : it is not known to be solvable in polynomial time , yet neither has it been shown to be np - complete .",
    "thus , it is often placed in the theoretical complexity class of ` @xmath11-intermediate'@xcite ( which , by ladner s theorem , exists if and only if @xmath12@xcite ) .",
    "in addition , efficient algorithms for detecting graph isomorphism are of great practical importance across a variety of fields , including network analysis , organic chemistry , condensed matter physics , chemical engineering , electronic engineering , computational biology , and others.@xcite@xcite@xcite    there exist many algorithms which run in polynomial ( or even sub - polynomial ) time in all practical cases , but which degenerate to exponential time in the worst - case@xcite , making them unsatisfactory from a complexity - theoretic point of view . we provide a brief outline of one such algorithm ( mckay s nauty ) , for the purpose of demonstrating how its approach , and the approach adopted by many similar state - of - the - art algorithms , differs from the uniqueness tree method proposed in this paper .",
    "we then provide both a formal and an informal statement of the uniqueness tree algorithm itself , along with an illustrative example of its application to a pair of non - isomorphic graphs .",
    "next , we give a formal proof that the algorithm runs in septic polynomial ( @xmath13 ) time in the worst case , and that the algorithm will always correctly detect the presence of an isomorphism between two graphs , whenever one exists .",
    "we propose that the converse statement is also true ( i.e. that the algorithm will correctly discern the lack of an isomorphism , whenever one does not exist ) , and give a brief sketch of a possible proof method , though this statement remains a conjecture .",
    "finally , we supply experimental evidence of both the algorithm s effectiveness in determining isomorphism / non - isomorphism between random graphs , and its polynomial efficiency .    for the purposes of this paper",
    ", we will consider only simple graphs ( i.e. unweighted , undirected graphs containing no loops or multiple edges ) .",
    "however , it is possible to generalise these methods to directed graphs , as well as to graphs in which multiple edges and loops are permitted , as will be shown in a future work .",
    "most practical graph isomorphism algorithms work by reducing graphs to a so - called ` canonical form ' - an object whose structure is independent of the particular ordering of the vertices , but dependent upon all other properties of the graph.@xcite thus , if the canonical forms for two graphs are equivalent , then the graphs must be isomorphic ; conversely , if the canonical forms differ , then the graphs must be non - isomorphic .",
    "nauty , as with most similar algorithms , operates by producing a so - called ` search tree ' as its canonical graph form , which is a rooted tree in which each vertex corresponds to a distinct ` partition ' ( colouring ) of the graph s vertices .",
    "loosely , the process of partition refinement is as follows:@xcite    1 .",
    "the root of the tree is an initial ( uniform ) colouring of the graph . + 2 .",
    "if two vertices share the same colour in a particular partition , but have neighbourhoods with different colourings , then ` refine ' the partition by assigning each vertex a new colour .",
    "this refined partition is a child vertex of the original partition .",
    "if a particular partition can not be refined further , then that vertex of the tree becomes a leaf , with no children .",
    "however , the uniqueness tree algorithm does not produce a single search tree to represent a graph .",
    "rather , it produces a set of ` uniqueness trees ' : one for each vertex of the graph . in turn",
    ", each vertex of a uniqueness tree represents a single vertex of the graph , as opposed to the richer structure of an entire vertex partition .",
    "this paper conjectures that the set of uniqueness trees is a canonical graph form , and provides some initial justification for that assertion .",
    "for two finite , simple graphs @xmath14 and @xmath15 , the uniqueness tree algorithm associates a rooted tree @xmath16 with every vertex @xmath17 , and @xmath18 with every vertex @xmath19 .",
    "this paper proposes that , if every tree associated with a vertex of @xmath20 is uniquely isomorphic to a tree associated with a vertex of @xmath21 , then @xmath20 and @xmath21 are isomorphic :    @xmath22    checking this criterion is an efficient process , since an isomorphism between two rooted trees may be computed in linear ( @xmath23 ) time , where @xmath24 is the number of vertices in each tree.@xcite    the process for generating the uniqueness tree for a vertex @xmath25 is as follows :    1 .",
    "the root of the tree is the vertex @xmath25 itself .",
    "every vertex in the current level of the tree which is not ` unique ' ( i.e. every vertex which appears in the current level more than once ) becomes a leaf , producing no children .",
    "every unique vertex in the current level of the tree produces 1 child for every adjacent vertex in the graph .",
    "this process continues until either the tree self - terminates ( i.e. there are no more unique vertices on the current level ) , or the height of the tree reaches @xmath24 ( the size of the graph ) .      as an illustrative example",
    ", we shall test for isomorphism between the following pair of graphs :    clearly , @xmath20 and @xmath21 are not isomorphic ( @xmath20 is planar and @xmath21 is not ) .",
    "however , they are equivalent in every other respect , since @xmath21 is simply an embedding of @xmath20 from a plane onto a mbius strip . in the interests of brevity , we shall not apply the entire algorithm , since to do so would require generating 16 uniqueness trees , and then making up to 36 comparisons between them .",
    "rather , we shall simply show that vertex @xmath26 in @xmath20 can not be equivalent to vertex @xmath26 in @xmath21 , and the non - isomorphism of @xmath20 and @xmath21 follows trivially .    for graph @xmath20 , the first level of @xmath26 s uniqueness tree contains @xmath26 s immediate adjacencies : @xmath27 , @xmath28 and @xmath20 ( all of which are unique ) .",
    "similarly , @xmath27 s children on the second level of the tree are @xmath26 , @xmath29 and @xmath21 ( @xmath27 s immediate adjacencies ) , @xmath28 s children are @xmath26 , @xmath29 and @xmath30 , and @xmath20 s children are @xmath26 , @xmath30 and @xmath21",
    ". since @xmath26 , @xmath29 , @xmath30 and @xmath21 all appear multiple times on the second level , all of the vertices becomes leaves and the tree terminates .    on the other hand , the first level of @xmath26 s uniqueness tree for graph @xmath21 contains the adjacent vertices @xmath27 , @xmath28 and @xmath21 , which are , again , unique .",
    "@xmath27 s children on the second level of the tree are then @xmath26 , @xmath29 and @xmath20 , @xmath28 s children are @xmath26 , @xmath29 and @xmath30 , and @xmath21 s children are @xmath26 , @xmath8 and @xmath20 .",
    "vertices @xmath26 , @xmath29 and @xmath20 become leaves , since they are not unique at this level .",
    "since vertices @xmath30 and @xmath8 are both unique on the second level , their adjacencies ( @xmath28 , @xmath8 and @xmath20 for vertex @xmath30 , and @xmath29 , @xmath30 and @xmath21 for vertex @xmath8 ) are carried to the third level of the tree . since @xmath28 , @xmath29 , @xmath30 , @xmath8 , @xmath20 and @xmath21",
    "are all unique on the third level , their adjacencies will , in turn , be carried up to the fourth level , and so on .",
    "already , we can see that the two uniqueness trees can not possibly be isomorphic ( since the first tree has only two levels , whilst the second has at least four ) , and so vertex @xmath26 in graph @xmath20 can not be equivalent to vertex @xmath26 in graph @xmath21 .",
    "the uniqueness tree algorithm may be divided into two distinct stages : the tree generation stage , and the tree comparison stage .    then , for two graphs @xmath14 and @xmath15 :",
    "for two finite , simple graphs @xmath0 and @xmath1 , each of size @xmath24 , the uniqueness tree algorithm runs in septic polynomial time ( @xmath13 ) in the worst case .    since the uniqueness tree algorithm can be divided into two sequential stages ( tree generation and tree comparison ) , we shall analyse the time complexity of each stage separately , and then add the two complexities together .",
    "the tree generation algorithm runs in sextic polynomial time ( @xmath31 ) in the worst case .    1 .",
    "the total number of uniqueness trees which must be generated is @xmath32 .",
    "the maximum width of a single uniqueness tree is @xmath33 ( since the maximum number of unique vertices which can appear in a single level is @xmath24 , and each vertex can have a maximum of @xmath34 adjacencies , giving a maximum of @xmath35 children on the next level , all of which would be leaves ) .",
    "@xmath36 the maximum number of vertices in each uniqueness tree is @xmath37 ( since the maximum width is @xmath33 , and the maximum height is @xmath23 ) .",
    "the maximum number of operations required to generate each vertex in the tree is @xmath33 ( i.e. a maximum of @xmath34 comparisons with other vertices in the graph , plus a maximum of @xmath35 comparisons with other vertices in the current level of the tree , in order to test uniqueness ) .",
    "@xmath36 the worst case time complexity of the tree generation algorithm is + @xmath38 . @xmath39",
    "the tree comparison algorithm runs in septic polynomial time @xmath13 in the worst case .    1 .",
    "the first tree of graph @xmath20 must be compared with a maximum of @xmath24 trees from graph @xmath21 , the second with @xmath40 trees , and so on .",
    "+ @xmath36 the maximum number of tree comparisons which must be made is @xmath41 .",
    "determining an isomorphism between the two rooted trees requires comparing the heights of both trees , comparing the total number of vertices in each level of each tree , and comparing the total number of children possessed by each vertex in each level of each tree .",
    "+ 3 .   comparing the heights of two rooted trees",
    "requires @xmath42 operation .",
    "+ 4 .   comparing the total number of vertices in each level of two rooted trees",
    "requires @xmath23 operations in the worst case ( since each tree may hold a maximum of @xmath24 levels ) .",
    "each level may contain a maximum of @xmath35 vertices , each of which must be compared with a maximum of @xmath35 vertices in the corresponding level of the other tree , for each of a possible @xmath24 levels of the tree .",
    "+ @xmath36 comparing the total number of children possessed by each vertex in each level of each tree requires + @xmath43 operations in the worst - case .",
    "@xmath36 the worst case time complexity for detecting an isomorphism between the two rooted trees is + @xmath44 .",
    "@xmath36 the worst case time complexity of the tree comparison algorithm is + @xmath45 . @xmath39    since @xmath46 , the desired theorem follows directly from these two lemmas .",
    "if two graphs @xmath14 and @xmath15 are isomorphic , then the uniqueness tree algorithm will correctly determine that @xmath2 .",
    "the key point is that the uniqueness tree algorithm is based entirely around vertex adjacencies ( which are graph - invariant ) , and does not depend at all upon vertex ordering .",
    "suppose that @xmath47 and @xmath48 .    1 .",
    "if a vertex @xmath49 is not unique to a particular level of a particular uniqueness tree for graph @xmath20 , then the vertex @xmath50 will be also non - unique to the equivalent level of the equivalent vertex tree for graph @xmath21 .",
    "conversely , if vertex @xmath49 is unique to that level , then vertex @xmath25 in the next level of @xmath20 s tree will have the same uniqueness property as vertex @xmath51 in @xmath21 s tree , and so on .",
    "thus , it follows that if @xmath52 , then graphs @xmath20 and @xmath21 will produce an equivalent set of uniqueness trees .",
    "since an isomorphism is defined as a bijection @xmath3 between the sets @xmath4 and @xmath5 which satisfies the above property , the desired theorem follows naturally .",
    "@xmath39      if two graphs @xmath14 and @xmath15 are not isomorphic , then the uniqueness tree algorithm will correctly determine that @xmath53 .",
    "one possible approach to proving this proposition may be an analogy to the positive case , as in the following informal sketch :    1 .   if @xmath53 , then ( without loss of generality ) there must exist at least one @xmath48 , such that @xmath54 ( by negation of the definition of isomorphism ) .",
    "if vertex @xmath49 ( in a particular level of a particular uniqueness tree for graph @xmath20 ) has a different uniqueness property to vertex @xmath50 ( in the equivalent level of the equivalent uniqueness tree for graph @xmath21 ) , then the uniqueness trees produced will be non - isomorphic , since one vertex will become a leaf , whilst the other will not .",
    "conversely , if vertices @xmath49 and @xmath50 are both unique , then there will be an instance of the vertex @xmath51 in the next level of @xmath21 s tree , without a corresponding instance of the vertex @xmath25 in @xmath20 s .",
    "thus , the uniqueness trees produced will be non - isomorphic , since the vertices in the next level will have different uniqueness properties as a result .",
    "+ 4 .   additionally ,",
    "if vertices @xmath49 and @xmath50 are both non - unique , then the non - uniqueness of vertex @xmath50 may be the result of having @xmath51 as its parent vertex in @xmath21 s tree , whilst @xmath25 can not be a parent vertex of @xmath49 in @xmath20 s tree . if this is the case , then the uniqueness trees produced will , again , be non - isomorphic .",
    "clearly , further work will be required to either formalise a proof of this proposition , or to demonstrate why it is incorrect .",
    "for the purposes of experimentally verifying both the effectiveness and efficiency of the uniqueness tree method , we present a practical implementation of the algorithm in java ; the complete source code for this algorithm , along with all of the tests described in this section , may be found in the appendix .",
    "independent verification of these experimental findings is strongly encouraged .",
    "the algorithm was tested on 10,000 pairs of random graphs , ranging in size from 1 to 100 ( 100 pairs of each ) .",
    "the graph pairs were known to be isomorphic , since the second graph was generated by randomly permuting the vertices of the first .",
    "the presence of an isomorphism was correctly detected in all 10,000 cases .",
    "when testing proposed algorithms for graph isomorphism , generating pairs of graphs which are known to be non - isomorphic is a fundamentally difficult problem , since doing so pre - supposes an effective criterion for detecting isomorphisms in the first place .",
    "it is trivial to generate pairs of graphs with differing graph invariant properties , but then one is simply testing the capability of the algorithm to discern those particular graph invariants , rather than its ability to detect non - isomorphism in general .    for the purpose of the present experimental test , we will attempt to generate a pair of similar but non - isomorphic graphs , by creating a second graph that is a vertex - permutation of the first ( as above ) , but with one edge randomly replaced . clearly , there is a small probability of inadvertently creating an isomorphic pair , particularly when the graphs involved are small . indeed ,",
    "when tested on the first 900 pairs of graphs with @xmath55 , some apparent false - positives were produced .",
    "however , when these possible exceptions were tested ( either by hand , or by cross - checking with nauty ) , it was determined that all of the problematic graphs had been , by chance , isomorphic . for the remaining 9,100 pairs of graphs with @xmath56",
    ", there were no false positives .",
    "the total computation time required for the algorithm to test for isomorphism between 10,000 pairs of random isomorphic test graphs ( 100 pairs of each size @xmath24 , with @xmath24 ranging from 1 to 100 ) was recorded , and then plotted as a function of @xmath24 .",
    "the equivalent process was repeated for 10,000 pairs of random non - isomorphic test graphs , also :    for large @xmath24 , taking the natural logarithm of both axes produces a straight line , demonstrating the asymptotically polynomial efficiency of the algorithm ( since if @xmath57 , then @xmath58 , with the gradient of the line thus representing the degree of the polynomial ) :    the seemingly anomalous points observed for low values of @xmath24 are due to intrinsic computational overheads , which naturally smooth out for larger graphs .",
    "thus , removing the results for the first 2,000 graph pairs from each plot ( i.e. the values @xmath59 ) produces a much better linear fit in both cases :    these plots suggest that the uniqueness tree algorithm runs in approximately quintic polynomial time ( @xmath60 ) on average for random graphs , which is consistent with our proof that the time complexity should never exceed @xmath13 .",
    "this paper has presented the polynomial time ` uniqueness tree ' algorithm , and used a combination of rigorous results and heuristic verification to propose that it may represent an effective approach to tackling the graph isomorphism problem .",
    "the importance placed upon the graph isomorphism problem within computational complexity theory is primarily due to its present status as a prime candidate for an ` @xmath11-intermediate ' problem@xcite ( a problem that is neither in the complexity class @xmath61 , nor @xmath11-complete ) , and many other proposed @xmath11-intermediate problems are known to be reducible to gi.@xcite thus , if the graph isomorphism problem could be shown to be solvable in polynomial time , it would constitute evidence against the existence of the @xmath11-intermediate set ( and therefore , by ladner s theorem , evidence that @xmath62@xcite ) .",
    "as such , any indication of the possibility of a polynomial time solution for gi would have significant implications for the entire field .    further research into the effectiveness of the uniqueness tree algorithm will centre around attempting to either prove or disprove the proposition that it is able to correctly discern the lack of an isomorphism in all relevant cases .",
    "extensions of the methods described in this paper to non - simple and directed graphs will appear in a future work , along with possible generalisations of the uniqueness tree approach to related problems in graph theory ( including graph automorphism , subgraph homeomorphism , etc . ) .",
    "the author is grateful to richard bridges , for many helpful suggestions and clarifications during the early stages of this research .",
    "99 a. prolubnikov , _ reduction of the graph isomorphism problem to equality checking of n - variables polynomials and the algorithms that use the reduction _ , http://arxiv.org/pdf/1512.03139v4.pdf ( 2016 ) 1 a. dawar , _ report on the graph isomorphism problem _ , dagstuhl seminar 15511 on the graph isomorphism problem ( 2015 ) 1 - 2 m. bodirsky , m. grohe , _ non - dichotomies in constraint satisfaction complexity _ , automata , languages and programming lncs 5126 ( 2008 ) 184 w. fan , _ graph pattern matching revised for social network analysis _ , proceedings of the 15th international conference on database theory ( 2012 ) 8 t. akutsu , h. nagamochi , _ comparison and enumeration of chemical graphs _ , computational and structural biotechnology journal 5 ( 6 ) ( 2013 ) 2 j. whitham , _ a graph matching search algorithm for an electronic circuit repository _ , meng thesis , university of york ( 2004 ) 5 p. foggia , c. sansone , m. vento , _ a performance comparison of five algorithms for graph isomorphism _ , proceedings of the 3rd iapt tc-15 workshop on graph - based representations in pattern recognition ( 2001 ) 2 b. d. mckay , a. piperno , _ practical graph isomorphism , ii _ , https://arxiv.org/pdf/1301.1493.pdf ( 2013 ) 2 b. d. mckay , _ practical graph isomorphism _ , congressus numerantium 30 ( 1981 ) 54 s. r. buss , _ alogtime algorithms for tree isomorphism , comparison , and canonization _ , computational logic and proof theory 1289 ( 2005 ) 19 g. l. miller , _ graph isomorphism , general remarks _",
    ", journal of computer and system sciences 18 ( 2 ) ( 1979 ) 129                  private static int [ ] [ ] uniquenesstreeheight ;      private static int [ ] [ ] [ ] uniquenesstreewidth ;      private static int [ ] [ ] [ ] [ ] uniquenesstreevertices ;      private static int [ ] [ ] [ ] [ ] uniquenesstreevertexchildcount ;                    uniquenesstreeheight = new int[2][n ] ;          uniquenesstreewidth = new int[2][n][n ] ;          uniquenesstreevertices = new int[2][n][n][n * n ] ;          uniquenesstreevertexchildcount = new int[2][n][n][n * n ] ;                              for ( int k = 0 ; k < vertexdegree[0][i ] ; k++ ) {                          if ( vertexadjacency[0][i][k ] = = j ) {                              verticesadjacent = true ;                          }                      }                        if ( !",
    "verticesadjacent ) {                          vertexadjacency[0][i][vertexdegree[0][i ] ] = j ;                          vertexadjacency[0][j][vertexdegree[0][j ] ] = i ;                          vertexdegree[0][i ] + = 1 ;                          vertexdegree[0][j ] + = 1 ;                      }                  }              }          }      }                for ( int i = 0 ; i < vertexcount[0 ] ; i++ ) {              int swap = rnd.nextint ( vertexcount[0 ] ) ;              int temp = vertexmap[i ] ;              vertexmap[i ] = vertexmap[swap ] ;              vertexmap[swap ] = temp ;          }            for ( int i = 0 ; i < vertexcount[0 ] ; i++ ) {              vertexdegree[1][vertexmap[i ] ] = vertexdegree[0][i ] ;              for ( int j = 0 ; j < vertexdegree[0][i ] ; j++ ) {                  vertexadjacency[1][vertexmap[i]][j ] = vertexmap[vertexadjacency[0][i][j ] ] ;              }          }      }              for ( int i = 0 ; i < vertexcount[1 ] ; i++ ) {              if ( vertexdegree[1][i ] >",
    "0 ) {                  vertexdegree[1][i ] -= 1 ;                  vertexdegree[1][vertexadjacency[1][i][vertexdegree[1][i ] ] ] -= 1 ;                                   for ( int j = 0 ; j < vertexcount[1 ] ; j++ ) {                      if ( i ! = j & & j ! = vertexadjacency[1][i][vertexdegree[1][i ] ] ) {                          boolean verticesadjacent = false ;                                                   for ( int k = 0 ; k < vertexdegree[1][j ] ; k++ ) {                              if ( vertexadjacency[1][j][k ] = = i ) {                                  verticesadjacent = true ;                              }                          }",
    "if ( ! verticesadjacent ) {                              vertexadjacency[1][i][vertexdegree[1][i ] ] = j ;                              vertexadjacency[1][j][vertexdegree[1][j ] ] = i ;                              vertexdegree[1][i ] + = 1 ;                              vertexdegree[1][j ] + = 1 ;                              j = vertexcount[1 ] ;                              i = vertexcount[1 ] ;                          }                      }                  }              }          }      }                                    for ( int l = 0 ; l < uniquenesstreewidth[i][j][uniquenesstreeheight[i][j ] - 1 ] ; l++ ) {                              if ( k ! = l & & uniquenesstreevertices[i][j][uniquenesstreeheight[i][j ] - 1][k ] = = uniquenesstreevertices[i][j][uniquenesstreeheight[i][j ] - 1][l ] ) {                                  vertexunique = false ;                              }                          }                                  for ( int l = 0 ; l < vertexdegree[i][uniquenesstreevertices[i][j][uniquenesstreeheight[i][j ] - 1][k ] ] ; l++ ) {                                  uniquenesstreevertices[i][j][uniquenesstreeheight[i][j]][uniquenesstreewidth[i][j][uniquenesstreeheight[i][j ] ] ] =                                           vertexadjacency[i][uniquenesstreevertices[i][j][uniquenesstreeheight[i][j ] - 1][k]][l ] ;                                  uniquenesstreevertexchildcount[i][j][uniquenesstreeheight[i][j ] - 1][k ] + = 1 ;                                  uniquenesstreewidth[i][j][uniquenesstreeheight[i][j ] ] + = 1 ;                              }                          }                      }                  }              }          }      }        public static boolean computeisomorphism ( ) {          for ( int i = 0 ; i < 2 ; i++ ) {              for ( int j = 0 ; j < vertexcount[i ] ; j++ ) {                  for ( int k = 0 ; k < uniquenesstreeheight[i][j ] ; k++ ) {                      for ( int l = 0 ; l < uniquenesstreewidth[i][j][k ] ; l++ ) {                          uniquenesstreevertexchildcountoccurrence[i][j][k][uniquenesstreevertexchildcount[i][j][k][l ] ] + = 1 ;                      }                  }              }          }                              for ( int k = 0 ; k < uniquenesstreeheight[0][i ] ; k++ ) {                          if ( uniquenesstreewidth[0][i][k ] ! = uniquenesstreewidth[1][j][k ] ) {                              verticesequivalent = false ;                          }                            for ( int l = 0 ; l < vertexcount[0 ] ; l++ ) {                              if ( uniquenesstreevertexchildcountoccurrence[0][i][k][l ] ! = uniquenesstreevertexchildcountoccurrence[1][j][k][l ] ) {                                  verticesequivalent = false ;                              }                          }                      }                        if ( verticesequivalent ) {                          vertexmapped[0][i ] = true ;                          vertexmapped[1][j ] = true ;                      }                  }              }          }              public static void main ( string [ ] args ) {          int falseresults = 0 ;                   for ( int i = 1 ; i < 100 ; i++ ) {              system.out.println(i ) ;              long starttime = system.currenttimemillis ( ) ;                      generaterandomgraph(i ) ;                  generateisomorphicgraph ( ) ;                  //generatenonisomorphicgraph",
    "( ) ;                  generateuniquenesstrees ( ) ;                  if ( ! computeisomorphism ( ) ) {                  //if ( computeisomorphism ( ) & & i > 9 ) {                      falseresults + = 1 ;                      system.out.println ( \" false result ! \" + falseresults ) ;                  }              }                try {                  filewriter = new filewriter ( \" output.csv \" , true ) ;                  bufferedwriter = new bufferedwriter ( filewriter ) ;                  bufferedwriter.write(integer.tostring(i ) + \" , \" + integer.tostring((int)(system.currenttimemillis ( ) - starttime ) ) ) ;                  bufferedwriter.newline ( ) ;                  bufferedwriter.close ( ) ;              } catch ( ioexception ex ) {                  system.out.println ( \" error writing to output file . \" ) ;              }          }      } } ...."
  ],
  "abstract_text": [
    "<S> this paper presents the novel ` uniqueness tree ' algorithm , as one possible method for determining whether two finite , undirected graphs are isomorphic . </S>",
    "<S> we prove that the algorithm has polynomial time complexity in the worst case , and that it will always detect the presence of an isomorphism whenever one exists . </S>",
    "<S> we also propose that the algorithm will equivalently discern the lack of an isomorphism whenever one does not exist , and some initial justifications are given for this proposition , although it can not yet be rigorously proven . finally , we present experimental evidence for both the effectiveness and efficiency of the uniqueness tree method , using data gathered from a practical implementation of the algorithm . </S>",
    "<S> some consequences and directions for further research are discussed .    </S>",
    "<S> graph isomorphism , computational complexity , canonical labelling </S>"
  ]
}