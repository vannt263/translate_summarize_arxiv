{
  "article_text": [
    "crocopat is a tool for manipulating relations , including directed graphs ( binary relations ) .",
    "crocopat is powerful , because it manipulates relations of arbitrary arity ; it is efficient in terms of time and memory , because it uses the data structure binary decision diagram ( bdd ,  @xcite ) for the internal representation of relations ; it is fairly easy to use , because its language is simple and based on the well - known predicate calculus ; and it is easy to integrate with other tools , because it uses the simple and popular rigi standard format ( rsf ) as input and output format for relations .",
    "crocopat is free software ( released under lgpl ) and can be obtained from http://www.software-systemtechnik.de/crocopat .",
    "* overview .",
    "* crocopat is a command line tool which interprets programs written in the relation manipulation language ( rml ) .",
    "its inputs are an rml program and relations in the rigi standard format ( rsf ) , and its outputs are relations in rsf and other text produced by the rml program .",
    "the programming language rml , and the input and output of relations from and to rsf files are introduced with the help of many examples in section  [ s : lanintro ] .",
    "section  [ s : advanced ] describes advanced programming techniques , in particular for improving the performance of rml programs and for circumventing limitations of rml .",
    "the manual concludes with references of crocopat s command line options in section  [ s : pat ] , of rsf in section  [ s : rsf ] , and of rml in section  [ s : lan ] .",
    "the rml reference includes a concise informal description of the semantics , and a formal description of the syntax and the core semantics .",
    "* applications .",
    "* crocopat was originally developed for analyzing graph models of software systems , and in particular for finding patterns in such graphs  @xcite .",
    "existing tools were not appropriate for this task , because they were limited to binary relations ( e.g. grok  @xcite , rpa @xcite , and relview  @xcite ) , or consumed too much time or memory ( e.g. relational database management systems and prolog interpreters ) .",
    "applications of graph pattern detection include    * the detection of implementation patterns  @xcite , object - oriented design patterns ( section  [ s : pattern ] , @xcite ) , and architectural styles  @xcite , * the detection of potential design problems ( section  [ s : pattern ] , @xcite ) , * the inductive inference of design patterns  @xcite , * the identification of code clones  @xcite , * the extraction of scenarios from models of source code  @xcite , and * the detection of design problems in databases  @xcite .",
    "the computation of transitive closures of graphs  another particular strength of crocopat  is not only needed for the detection of some of the above patterns , but has also been applied for dead code detection and change impact analysis  @xcite . computing and analyzing the difference between two graphs supports checking the conformance of the as - built architecture to the as - designed architecture @xcite , and studying the evolution of software systems between different versions .",
    "calculators for relations have also been used to compute views of systems on different levels of abstraction by lifting and lowering relations  @xcite , and to calculate software metrics ( section  [ s : numerical ] , @xcite ) .",
    "although we are most familiar with potential applications in the analysis of software designs , we are confident that crocopat can be beneficial in many other areas . for example , calculators for relations have been used for program analyses like points - to analysis  @xcite , and for the implementation of graph algorithms  ( section  [ s : control ] , @xcite ) .",
    "this section introduces rml , the programming language of crocopat , on examples .",
    "the core of rml are relational expressions based on first - order predicate calculus , a well - known , reasonably simple , precise and powerful language .",
    "relational expressions are explained in subsection  [ s : re ] , and additional examples involving relations of arity greater than two are given in subsection  [ s : pattern ] . besides relational expressions ,",
    "the language includes control structures , described in subsection  [ s : control ] , and numerical expressions , described in subsection  [ s : numerical ] .",
    "the input and output of relations is described in subsection  [ s : output ] .",
    "a more concise and a more formal specification of the language can be found in section  [ s : lan ] .",
    "although the main purpose of this section is the introduction of the language , some of the application examples may be of interest by themselves . in subsection",
    "[ s : control ] , simple graph algorithms are implemented , and in the subsections  [ s : pattern ] and  [ s : numerical ] the design of object - oriented software systems is analyzed .",
    "this subsection introduces relational expressions using relationships between people as example .",
    "remember that @xmath0-ary relations are sets of ordered @xmath0-tuples . in this subsection",
    ", we will only consider the cases @xmath1 ( unary relations ) and @xmath2 ( binary relations , directed graphs ) .",
    "crocopat manipulates tuples of strings , thus unary relations in crocopat are sets of strings , and binary relations in crocopat are sets of ordered pairs of strings .",
    "* adding elements . *",
    "the statement    .... male(\"john \" ) ; ....    expresses that john is male .",
    "( in some languages , e.g. the logic programming language prolog  @xcite , such statements are called facts . )",
    "it adds the string john to the unary relation male .",
    "because each relation variable initially contains the empty relation , john is so far the only element of the set male .",
    "an explicit declaration of variables is not necessary .",
    "however , variables should be defined ( i.e. , assigned a value ) before they are first used , otherwise crocopat prints a warning .    .... male(\"joe \" ) ; ....    adds the string joe to the set male , such that it now has two elements .",
    "similarly , we can initialize the variable female :    .... female(\"alice \" ) ; female(\"jane \" ) ; female(\"mary \" ) ; ....    to express that the john and mary are the parents of alice and joe , and joe is the father of jane , we create a binary relation variable parentof which contains the five parent - child pairs :    .... parentof(\"john \" , \" alice \" ) ; parentof(\"john \" , \" joe \" ) ; parentof(\"mary \" , \" alice \" ) ; parentof(\"mary \" , \" joe \" ) ; parentof(\"joe \" , \" jane \" ) ; ....    * assignments .",
    "* the following statement uses an _ attribute _",
    "x to assign the set of joe s parents to the set joesparent :    .... joesparent(x ) : = parentof(x , \" joe \" ) ; ....    now joesparent contains the two elements john and mary . as another example",
    ", the following assignment says that x is a child of y if and only if y is a parent of x :    .... childof(x , y ) : = parentof(y , x ) ; ....    john is the father of a person if and only if he is the parent of this person .",
    "the same is true for joe :    .... fatherof(\"john \" , x ) : = parentof(\"john \" , x ) ; fatherof(\"joe \" , x ) : = parentof(\"joe \" , x ) ; ....    because the scope of each attribute is limited to one statement , the attribute in the first statement and the attribute in the second statement are different , despite of their equal name  x.    * basic relational operators . *",
    "the relation fatherof can be described more concisely : x is father of  y if and only if x is a parent of y and x is male :    .... fatherof(x , y ) : = parentof(x , y ) & male(x ) ; ....    of course , we can define a similar relation for female parents :    .... motherof(x , y ) : = parentof(x , y ) & female(x ) ; ....    besides the operator _ and _ ( & ) , another important operator is _ or _ ( | ) .",
    "for example , we can define the parentof relation in terms of the relations motherof and fatherof : x  is a parent of  y if and only if x  is the mother or the father of  y :    .... parentof(x , y ) : = motherof(x , y ) | fatherof(x , y ) ; ....    * quantification . *",
    "parents are people who are a parent of another person .",
    "more precisely , x is a parent if and only if there _ exists _ ( ex ) a y such that x is a parent of y.    .... parent(x ) : = ex(y , parentof(x , y ) ) ; ....    now the set parent consists of john , mary , and joe .",
    "there is also an abbreviated notation for existential quantification which is similar to anonymous variables in prolog and functional programming languages :    .... parent(x ) : = parentof(x , _ ) ; ....    with the operator _ not _ ( ! ) , we can compute who has no children :    .... childless(x ) : = !",
    "ex(y , parentof(x , y ) ) ; ....    equivalently , x childless if _ for all _ ( fa ) y holds that x is not a parent of y :    .... childless(x ) : = fa(y , ! parentof(x ,",
    "y ) ) ; ....    in both cases , the set childless contains alice and jane .",
    "* transitive closure .",
    "* to compute the grandparents of a person we have to determine the parents of his or her parents :    .... grandparentof(x , z ) : = ex(y , parentof(x , y ) & parentof(y , z ) ) ; ....    now grandparentof contains the two pairs ( john , jane ) and ( mary , jane ) . to find out all ancestors of a person , i.e. parents , parents of parents , parents of parents of parents , etc",
    ", we have to apply the above operation ( which is also called composition ) repeatedly until the fixed point is reached , and unite the results .",
    "the transitive closure operator tc does exactly this :    .... ancestorof(x , z ) : = tc(parentof(x , z ) ) ; ....    the resulting relation ancestorof contains any pair from parentof and grandparentof .",
    "( it also contains grand - grandparents etc . , but there are none in this example . )",
    "the transitive closure operator tc can only be applied to binary relations .    * predefined relations , the universe . *",
    "the relations false and true are predefined .",
    "false is the empty relation , and true is the full relation .",
    "more precisely , there is one predefined relation false and one predefined relation true for every arity . in particular",
    ", there is also a 0-ary relation false ( ) , which is the empty set , and a 0-ary relation true ( ) , which contains only  @xmath3 ( the tuple of length  @xmath4 ) .",
    "intuitively , these 0-ary relations can be used like boolean literals . by the way , the statement    .... male(\"john \" ) ;",
    "....    is an abbreviation of the assignment    .... male(\"john \" ) : = true ( ) ; ....    the result of true(x ) is the so - called _",
    "universe_. the universe contains all string literals that appear in the input rsf stream ( if there is one , see subsection  [ s : output ] ) and on the left hand side of assignments in the present rml program . for example , the string literals used on the left hand side of the assignments in the examples of this subsection are alice , jane , joe , john , and mary , so the set true(x ) contains these five elements .",
    "see subsection  [ s : universe ] for more information on the universe .",
    "the binary relations = , ! = , , and > = for the lexicographical order of the strings in the universe are also predefined .",
    "for example , siblings are two _ different _ people who have a common parent :    .... siblingof(x , y ) : = ex(z , parentof(z , x ) & parentof(z , y ) ) & ! = ( x , y ) ; ....",
    "the infix notation is also available for binary relations , so the expression ! = ( x , y ) can also be written as  x!=y .",
    "note that the predefined relations , like any other relation , are restricted to the universe .",
    "thus the expression `` a''=``a '' yields false ( ) if ( and only if ) the string a is not in the universe .",
    "further relational expressions are provided to match posix extended regular expressions  ( * ? ? ?",
    "* section  9.4 ) .",
    "these relational expressions start with the character @ , followed by the string for the regular expression .",
    "for example ,    ....",
    "startswithj(x ) : = @\"^j\"(x ) ; ....    assigns to the set startswithj the set of all strings in the universe that start with the letter j , namely jane , joe , and john .",
    "a short overview of the syntax of regular expressions is given in subsection  [ s : syntax ] .",
    "* boolean operators . * two relations can be compared with the operators = , ! = , , or > = . because such comparisons evaluate to either true ( ) or false ( ) , they are called boolean expressions . for example ,    ....",
    "grandparentof(x , y ) < ancestorof(x , y ) ....    yields true ( ) , because grandparentof is a proper subset of ancestorof .",
    "however ,    ....",
    "grandparentof(x , y ) = ancestorof(x , y ) ....    yields false ( ) , because the two relations are not equal .",
    "the six comparison operators should not be confused with the six predefined relations for the lexicographical order .",
    "the operators take two relations as parameters , while the predefined relations take strings or attributes as parameters .",
    "* file format rsf .",
    "* crocopat reads and writes relations in rigi standard format ( rsf ,  ( * ? ? ?",
    "* section  4.7.1 ) ) .",
    "files in rsf are human - readable , can be loaded into and saved from many reverse engineering tools , and are easily processed by scripts in common scripting languages .    in an rsf file , a tuple of an @xmath0-ary relation is represented as a line of the form    .... relationname element1 element2 ... elementn ....    the elements may be enclosed by double quotes . because white space serves as delimiter of the elements , elements that contain white space _",
    "must _ be enclosed by double quotes .",
    "a relation is represented as a sequence of such lines .",
    "the order of the lines is arbitrary .",
    "an rsf file may contain several relations .",
    "as an example , the relation parentof from the previous subsection can be represented in rsf format as follows :    .... parentof john alice parentof john joe parentof mary alice parentof mary joe parentof joe   jane ....    * input . * rml has no input statements .",
    "when crocopat is started , it first reads input relations in rsf from the standard input before it parses and executes the rml program .",
    "rsf reading can be skipped with the -e command line option .",
    "if the input relations are available as files , they can be feeded into crocopat s standard input using the shell operator :    .... crocopat prog.rml < parentof.rsf > parentof2.rsf ....    an alternative solution ( which also works with more than one file ) is to pass command line arguments to the program .",
    "command line arguments can be accessed in rml as $ 1 , $ 2 , etc .",
    "for example , when the program    ....",
    "childof(x , y ) : = parentof(y , x ) ; print [ \" child \" ] childof(x,$1 ) to $ 1 + \" .rsf \" ; print [ \" child \" ] childof(x,$2 ) to $ 2 + \" .rsf \" ; ....    is executed with    .... crocopat io.rml joe mary < parentof.rsf ....    then the first print statement writes to the file joe.rsf , and the second print statement writes to mary.rsf .",
    "command line arguments are not restricted to specifying file names , but can be used like string literals . however , in contrast to string literals , command line arguments are never added to the universe , and thus can not be used on the left hand side of relational assignments .      this subsection introduces the control structures of rml , using algorithms for computing the transitive closure of a binary relation  r as examples .    * while statement . * as a first algorithm , the relation r is composed with itself until the fixed point is reached .    ....",
    "result(x , y ) : = r(x , y ) ; prevresult(x , y ) : = false(x , y ) ; while ( prevresult(x , y )",
    "! = result(x , y ) ) {      prevresult(x , y ) : = result(x , y ) ;      result(x , z ) : = result(x , z ) | ex(y , result(x , y ) & result(y , z ) ) ; } ....    the program illustrates the use of the while loop , which has the usual meaning : the body of the loop is executed repeatedly as long as the condition after while evaluates to  true ( ) .    * for statement . *",
    "the second program computes the transitive closure of the relation  r using the warshall algorithm .",
    "this algorithm successively adds arcs . in the first iteration",
    ", an arc @xmath5 is added if the input graph contains the arcs @xmath6  node@xmath7 and @xmath8node@xmath9 . in the second iteration",
    ", an arc @xmath10 is added if the graph that results from the first iteration contains the arcs @xmath6  node@xmath11 and @xmath8node@xmath12 . and",
    "so on , for all nodes of the graph ( in arbitrary order . )",
    ".... result(x , y ) : = r(x , y ) ; node(x ) : = result(x , _ ) & result(_,x ) ; for node in node(x ) {    result(x , y ) : = result(x , y ) | ( result(x , node ) & result(node , y ) ) ; } ....    the program illustrates the use of the for loop .",
    "the relation after in must be a unary relation .",
    "the iterator after for is a string variable and takes as values the elements of the unary relation in lexicographical order .",
    "thus , the number of iterations equals the number of elements of the unary relation .    for the implementation of the transitive closure operator of rml , we experimented with several algorithms .",
    "an interesting observation in these experiments was that the empirical complexity of some algorithms for practical graphs deviated strongly from their theoretical worst case complexity , thus some algorithms with a relatively bad worst - case complexity were very competitive in practice . in our experiments ,",
    "the first of the above algorithms was very fast , thus we made it available as operator tcfast .",
    "the implementation of the tc operator of rml is a variant of the warshall algorithm .",
    "it is somewhat slower than tcfast ( typically about 20 percent in our experiments ) , but often needs much less memory because it uses no ternary relations .    * if statement .",
    "* the following example program determines if the input graph r is acyclic , by checking if its transitive closure contains loops ( i.e. arcs from a node to itself ) :    .... selfarcs(x , y ) : = tc(r(x , y ) ) & ( x = y ) ; if ( selfarcs ( _ , _ ) ) {      print \" r is not acyclic \" , endl ; } else {      print \" r is acyclic \" , endl ; } ....      in this subsection , relations of arity greater than two are used for finding potential design patterns and design problems in structural models of object - oriented programs .",
    "the examples are taken from  @xcite .",
    "the models of object - oriented programs contain the call , containment , and inheritance relationships between classes . here",
    "containment means that a class has an attribute whose type is another class .",
    "the direction of inheritance relationships is from the subclass to the superclass . as an example",
    ", the source code    .... class containedclass { } class superclass { } class subclass extends superclass {      containedclass c ; } ....    corresponds to the following rsf file :    .... inherit    subclass   superclass contain    subclass   containedclass ....    ]    * composite design pattern .",
    "* figure  [ fig : composite ] shows the class diagram of the composite design pattern  @xcite . to identify possible instances of this pattern , we compute all triples of a component class , a composite class , and a leaf class ,",
    "such that ( 1 ) composite and leaf are subclasses of component , ( 2 ) composite contains an instance of component , and ( 3 ) leaf does not contain an instance of component .",
    "the translation of these conditions to an rml statement is straightforward :    .... comppat(component , composite , leaf ) : =    inherit(composite , component )                                         & contain(composite , component )                                         & inherit(leaf , component )                                         & !",
    "contain(leaf , component ) ; ....    * degenerate inheritance . *",
    "when a class c inherits from another class a directly and indirectly via a class b , the direct inheritance is probably redundant or even misleading .",
    "the following statement detects such patterns :    .... deginh(a , b , c ) : =    inherit(c , b )                   & inherit(c , a )                   & tc(inherit(b , a ) ) ; ....    * cycles . * to understand an undocumented class , one has to understand all classes it uses . if one of the ( directly or indirectly ) used classes is the class itself , understanding this class is difficult .",
    "all classes that participate in cycles can be found using the transitive closure operator , as shown in subsection  [ s : control ] .",
    "however , in many large software systems hundreds of classes participate in cycles , and it is tedious for a human analyst to find the actual cycles in the list of these classes . in our experience , it is often more useful to detect cycles in the order of ascending length . as a part of such a program ,",
    "the following statements detects all cycles of length  @xmath13 .    ....",
    "use(x , y ) : = call(x , y ) | contain(x , y ) | inherit(x , y ) ; cycle3(x , y , z ) : = use(x , y ) & use(y , z ) & use(z , x ) ; cycle3(x , y , z ) : = cycle3(x , y , z ) & ( x < = y ) & ( x < = z ) ; ....    to see the purpose of the third statement , consider three classes a , b , and c that form a cycle .",
    "after the second statement , the relation variable cycle3 contains three representatives of this cycle : @xmath8a ,  b ,  c@xmath14 , @xmath8b ,  c ,  a@xmath14 and @xmath8c ,  a ,  b@xmath14 .",
    "the third statement removes two of these representatives from cycle3 , and keeps only the tuple with the lexicographically smallest class at the first position , namely @xmath8a ,  b ,  c@xmath14 .      in this subsection",
    ", a software metric is calculated as example for the use of numerical expressions in rml programs .",
    "therefore , we extend the structural model of object - oriented programs introduced in the previous subsection with a binary relation packageof .",
    "this relation assigns to each package the classes that it contains .",
    "( packages are high - level entities in object - oriented software systems that can be considered as sets of classes . )",
    "robert martin s metric for the instability of a package is defined as @xmath15 , where @xmath16 is the number of classes outside the package that use classes inside the package , and @xmath17 is the number of classes inside the package that use classes outside the package  @xcite .    ....",
    "use(x , y ) : = call(x , y ) | contain(x , y ) | inherit(x , y ) ; package(x ) : = packageof(x , _ ) ; for p in package(x ) {      caclass(x ) : = !",
    "packageof(p , x ) & ex(y , use(x , y ) & packageof(p , y ) ) ;      ca : = # ( caclass(x ) ) ;      ceclass(x ) : = packageof(p , x ) & ex(y , use(x , y ) & !",
    "packageof(p , y ) ) ;      ce : = # ( ceclass(x ) ) ;      if ( ca + ce > 0 ) {          print p , \" \" , ce / ( ca+ce ) , endl ;      } } ....",
    "this section describes advanced programming techniques , in particular for improving efficiency and circumventing language limitations . the first subsection explains how to control the memory usage of crocopat .",
    "the second and third subsection describe how relational expressions are evaluated in crocopat , and how to assess and improve the efficiency of their evaluation .",
    "the fourth subsection explains why the universe is immutable during the execution of an rml program and how to work around this limitation .",
    "crocopat represents relations using the data structure binary decision diagram ( bdd ,  @xcite ) .",
    "when crocopat is started , it reserves a fixed amount of memory for bdds , which is not changed during the execution of the rml program . if the available memory is insufficient , crocopat exits with the error message      the bdd memory can be controlled with the command line option  -m , followed by an integer number giving the amount of memory in mbyte .",
    "the default value is  50 .",
    "the actual amount of memory reserved for bdds is not infinitely variable , so the specified value is only a rough upper bound of the amount of memory used .    it can also be beneficial to reserve less memory , because the time used for allocating memory increases with the amount of memory .",
    "when the manipulated relations are small or the algorithms are computationally inexpensive , memory allocation can dominate the overall runtime .",
    "this subsection explains how crocopat evaluates relational expressions .",
    "based on this information , hints for performance improvement are given .",
    "understanding the subsection requires basic knowledge about bdds and the impacts of the variable order on the size of bdds .",
    "an introduction to bdds is beyond the scope of this manual , we refer the reader to  @xcite .    the attributes in an rml program are called _ user attributes _ in the following .",
    "for example , the expression r(x , y ) contains the user attributes x and  y. for the internal representation of relations , crocopat uses a sequence of _ internal attributes _ , which are distinct from the user attributes .",
    "we call these internal attributes i1 , i2 , i3 , ... for example , the binary relation r is internally represented as a set of assignments to the internal attributes i1 and  i2 .",
    "when the expression r(x , y ) is evaluated , the internal attributes i1 and i2 are renamed to the user attributes x and y. therefore all bdd nodes of the representation of r have to be traversed .",
    "thus , the time for evaluating the expression r(x , y ) is at least linear in the number of bdd nodes of  r s representation .",
    "the order of the internal attributes in the bdd is always i1 , i2 , ... the order of the user attributes in the bdd may be different in the evaluation of each statement , because the scope of user attributes is restricted to one statement .",
    "the order of the user attributes in the bdd in the evaluation of a statement is the order in which crocopat encounters the user attributes in the execution of the statement . in the example statement        * avoid renaming large relations . *",
    "the time for the evaluation of the expression r(x , y ) is at least linear in the number of bdd nodes in the representation of  r , because all bdd nodes have to be renamed from internal attributes to user attributes .",
    "usually this effort for renaming does not dominate the overall runtime , but in the following we give an example where it does .        assigns the outneighbors of the graph node node1 to the set outneighbor .",
    "the evaluation of r(x , y ) costs @xmath18 time in this example , because of the renaming of all nodes .",
    "the `` real computation '' , namely the conjunction and the existential quantification , can be done in @xmath19 time .",
    "so the renaming dominates the overall time .",
    "the bdd attribute order on the right hand side of the assignment is y , z , x , while the bdd attribute order on the left hand side is x , y , z. because the two orders are different , attributes have to be swapped to execute the assignment .",
    "this can be easily avoided by using the equivalent statement      of course , swapping attributes can not always be avoided .",
    "however , developers of rml programs should know that swapping attributes can be expensive , and should minimize it when performance is critical .",
    "* ensure good attribute orders . *",
    "a detailed discussion of bdd attribute orders is beyond the scope of this manual ( see e.g.  ( * ? ? ?",
    "* section  1.3 ) for details ) , but the basic rule is that related attributes should be grouped together . in the two assignment statements      the attributes v and",
    "w are related , and the attributes x and y are related , while v and w are unrelated to x and  y. in s1 , related attributes are grouped together , but not in  s2 . for many relations  r , the bdd representation of  s1 will be drastically smaller than the bdd representation of  s2 .",
    ".... number of tuples in the relation : 461705 number of values ( universe ) : 6218 number of bdd nodes : 246986 percentage of free nodes in bdd package : 1614430 / 1966102 = 82 % attribute order : y z x ....    the first line gives the cardinality of the relation , the second line the cardinality of the universe , the third line the size of the bdd that represents the result of the expression , and the fifth line the attribute order in this bdd .",
    "knowledge of the computational complexity of rml s operators is useful to optimize the performance of rml programs .",
    "this subsection gives theoretical complexity results , but also discusses the limits of their practical application .",
    "table  [ t : complexity ] shows the asymptotic worst case time complexity for the evaluation of rml s relational operators .",
    "the times do not include the renaming of internal attributes discussed in the previous subsection , and the evaluation of subexpressions .",
    "it is assumed that the caches of the bdd package are sufficiently large .",
    "this assumption is closely approximated in practice when the manipulated bdds only occupy a small fraction of the available nodes in the bdd package .",
    "otherwise , performance may be improved by increasing the bdd memory ( see subsection  [ ss : memory ] ) .    when the operands of an expression are relations , the computation time is given as function of the sizes of their bdd representation .",
    "( the only exception are the transitive closure operators , where a function of the size of the universe gives a more useful bound . )",
    "this raises the problem of how to estimate these bdd sizes .",
    "many practical relations have regularities that enable an ( often dramatically ) compressed bdd representation , but the analytical derivation of the typical compression rate for relations from a particular application domain is generally difficult . our advice is to choose some representative examples and measure the bdd sizes with the print relinfo statement .    it is important to note that table  [ t : complexity ] gives _ worst - case _ computation times . in many cases ,",
    "the typical practical performance is much better than the worst case .",
    "for example , the relational comparison operators (= , > ) and the binary logic operators ( & , | , - > , ) are very common in rml programs .",
    "their worst - case complexity is the product of the sizes of their operand bdds , which is alarmingly high .",
    "however , in practice the performance is often much closer to the sum of the operand bdd sizes .",
    "similarly , the quantification operators are often efficient despite their prohibitive worst case runtime ( which is difficult to derive because quantification is implemented as a series of several bit - level operations ) .",
    "another practically important example for the gap between average - case and worst - case runtime are the transitive closure operators .",
    "the worst case complexity of their bdd - based implementation is the same as for implementations with conventional data structures .",
    "however , the bdd - based implementations are much more efficient for many practical graphs  @xcite . even in the comparison of different bdd - based implementations ,",
    "a better worst - case complexity does not imply a better performance in practice .",
    "we conclude from our experience that knowledge of the theoretical complexity complements but can not replace experimentation in the development of highly optimized rml programs .",
    ".worst case time complexity of the evaluation of relational expressions .",
    "re , re1 , re2 are relational expressions , x , x1 , x2 are attributes , and ne1 , ne2 are numerical expressions .",
    "_ bddsize_@xmath8re@xmath14 is the number of bdd nodes of the result of the expression re , and @xmath0  is the cardinality of the universe .",
    "[ cols= \" < , < \" , ]          the _ universe _ @xmath21 is the finite set of all string literals that appear in the input rsf file , or on the left side of a relational assignment . the finite set of _ attributes _ of the rml program is denoted by @xmath22 ( @xmath23 ) . an _",
    "attribute assignment _ is a total function @xmath24 which maps each attribute to its value and ( for notational convenience ) each string literal to itself .",
    "the set of all attribute assignments is denoted by @xmath25 .",
    "the finite set of _ relation variables _ in the rml program is denoted by @xmath26 .",
    "a _ relation assignment _ is a total function @xmath27 , which maps each relation variable to a relation of arbitrary arity .",
    "the set of all relation assignments is denoted by  @xmath28 .",
    "the semantics of relational expressions and statements are given by the following interpretation functions : @xmath29 \\bbbkl.\\bbbkr_s & : & \\mbox{\\em stmt}s \\to                    ( rel(\\crel ) \\to rel(\\crel ) ) \\\\",
    "\\end{array}\\ ] ] so we define the semantics of an expression as the set of attribute assignments that satisfy the expression , and the semantics of a statement as a transformation of the relation assignment .",
    "the interpretation functions are defined inductively in figure  [ fig : sem ] .",
    "\\bbbkl \\mbox{{\\em rel\\_expr$_1$}~{\\tt",
    "->}~{\\em rel\\_expr$_2 $ } } \\bbbkr_e ( s ) & = &        \\bbbkl \\mbox{{\\tt ! } ~{\\tt ( } { \\em rel\\_expr$_1$}{\\tt ) } ~{\\tt |\\,(}{\\em rel\\_expr$_2$}{\\tt ) } } \\bbbkr_e ( s ) \\\\[1ex ]        \\bbbkl \\mbox{{\\em rel\\_expr$_1$}~{\\tt < ->}~{\\em rel\\_expr$_2 $ } } \\bbbkr_e ( s ) & = &        \\bbbkl \\mbox{{\\tt ( } { \\em rel\\_expr$_1$}~{\\tt ->}~{\\em rel\\_expr$_2$}{\\tt ) } ~{\\tt \\&\\,}{\\tt ( } { \\em rel\\_expr$_2$}~{\\tt ->}~{\\em rel\\_expr$_1$}{\\tt ) } } \\bbbkr_e ( s ) \\\\[1ex ]        \\bbbkl \\mbox{{\\tt ex(}{\\em attribute}{\\tt , } ~{\\em rel\\_expr}{\\tt ) } } \\bbbkr_e ( s ) & = &        \\big\\ { v \\in val(\\cx ) ~\\big|~ \\exists v ' \\in \\bbbkl \\mbox{{\\em rel\\_expr } } \\bbbkr_e(s )                                     ~\\forall x \\in \\cx \\setminus \\{\\mbox{{\\em attribute}}\\ } : v(x ) = v'(x ) \\big\\}\\\\[1ex ]        \\bbbkl \\mbox{{\\tt fa(}{\\em attribute}{\\tt , } ~{\\em rel\\_expr}{\\tt ) } } \\bbbkr_e ( s ) & = &        \\bbbkl \\mbox{{\\tt ! } ~{\\tt ex(}{\\em attribute}{\\tt , } ~{\\tt ! } ~{\\tt ( } { \\em rel\\_expr}{\\tt ) ) } } \\bbbkr_e ( s ) \\\\[1ex ]        \\bbbkl \\mbox{{\\tt tc(}{\\em rel\\_var}{\\tt ( } { \\em attribute}$_1${\\tt , } ~{\\em attribute}$_2${\\tt ) ) } } \\bbbkr_e ( s )                  & \\stackrel{\\mbox{\\em \\footnotesize lfp}}{= } &        \\bbbkl \\mbox{~~~~{\\em rel\\_var}{\\tt ( } { \\em attribute}$_1${\\tt , } ~{\\em attribute}$_2${\\tt ) } } \\\\           & & \\mbox{~~{\\tt | ex(}{\\em attribute}$_3${\\tt , } ~~~             { \\em rel\\_var}{\\tt ( } { \\em attribute}$_1${\\tt , } ~{\\em attribute}$_3${\\tt ) } } \\\\           & & \\mbox{\\hspace{27mm}{\\tt \\ & tc(}{\\em rel\\_var}{\\tt ( } { \\em attribute}$_3${\\tt , } ~{\\em attribute}$_2${\\tt ) ) ) } } \\bbbkr_e ( s ) \\\\[1ex ]        \\bbbkl \\mbox{{\\tt tcfast(}{\\em rel\\_var}{\\tt ( } { \\em attribute}$_1${\\tt , } ~{\\em attribute}$_2${\\tt ) ) } } \\bbbkr_e ( s ) & = &        \\bbbkl \\mbox{{\\tt tc(}{\\em rel\\_var}{\\tt ( } { \\em attribute}$_1${\\tt , } ~{\\em attribute}$_2${\\tt ) ) } } \\bbbkr_e ( s ) \\\\[3ex ]                \\bbbkl \\mbox{{\\tt = ( } { \\em rel\\_expr}$_1${\\tt , } ~{\\em rel\\_expr}$_2${\\tt ) } } \\bbbkr_e ( s ) & = &        \\mathit{val}(\\cx ) \\mbox{,~~~if }          \\bbbkl \\mbox{{\\em rel\\_expr$_1 $ } } \\bbbkr_e(s ) = \\bbbkl \\mbox{{\\em rel\\_expr$_2 $ } } \\bbbkr_e(s ) \\\\        & & \\emptyset \\mbox{,~~~~~~~~~~~otherwise}\\\\[1ex ]        \\bbbkl \\mbox{{\\tt < ( } { \\em rel\\_expr}$_1${\\tt , } ~{\\em rel\\_expr}$_2${\\tt ) } } \\bbbkr_e ( s ) & = &        \\mathit{val}(\\cx ) \\mbox{,~~~if }          \\bbbkl \\mbox{{\\em rel\\_expr$_1 $ } } \\bbbkr_e(s ) \\subsetneq \\bbbkl \\mbox{{\\em rel\\_expr$_2 $ } } \\bbbkr_e(s ) \\\\        & & \\emptyset \\mbox{,~~~~~~~~~~~otherwise}\\\\[1ex ]          \\big ( \\bbbkl \\mbox{{\\em rel\\_var}{\\tt ( } { \\em term}$_1${\\tt , } $ \\dots${\\tt , } { \\em term}$_n${\\tt ) } { \\tt : = } ~{\\em rel\\_expr } } \\bbbkr_s ( s)\\big ) ( r ) & = &        s(r ) , \\hspace{64mm}\\mbox{if } r \\not= \\mbox{\\em rel\\_var}\\\\[1.5ex ]        & & \\quad \\big\\ { \\big ( v(term_1 ) , \\dots , v(term_n ) \\big)~\\big|~v \\in \\bbbkl \\mbox{\\em rel\\_expr } \\bbbkr_e(s ) \\big\\ } \\\\[1ex ]        & & \\cup~\\big\\ { t \\in s(\\mbox{\\em r})~|~ \\exists i : term_i \\in \\cc \\wedge term_i \\not= t_i \\big\\ } ,           \\qquad\\quad \\mbox{if } r = \\mbox{\\em rel\\_var }    \\end{array}\\ ] ] with @xmath31 .",
    "the symbol @xmath32 denotes the least fixed point .",
    "g.  antoniol , r.  fiutem , and l.  cristoforetti .",
    "design pattern recovery in object - oriented software . in _ proceedings of the 6th ieee international workshop on program comprehension ( iwpc 1998 ) _",
    ", pages 153160 .",
    "ieee computer society , 1998 .",
    "ralf behnke , rudolf berghammer , and peter schneider . machine support of relational computations : the kiel relview system .",
    "technical report 9711 , institut fr informatik und praktische mathematik , christian - albrechts - universitt kiel , 1997 .",
    "rudolf berghammer , barbara leoniuk , and ulf milanese .",
    "implementation of relational algebra using binary decision diagrams . in h.",
    "de  swart , editor , _ proceedings of the 6th international conference on relational methods in computer science ( relmics 2001 ) _ , lncs 2561 , pages 241257 , berlin , 2002 .",
    "springer - verlag .",
    "marc berndl , ondrej lhotk , feng qian , laurie  j. hendren , and navindra umanee .",
    "points - to analysis using bdds . in _ proceedings of the acm sigplan conference on programming language design and implementation ( pldi 2003 ) _ ,",
    "pages 103114 .",
    "acm , 2003 .",
    "dirk beyer , andreas noack , and claus lewerentz .",
    "simple and efficient relational querying of software structures . in _ proceedings of the 10th working conference on reverse engineering ( wcre 2003 ) _ , pages 216225 .",
    "ieee computer society , 2003 .",
    ". automatic detection of design problems in object - oriented reengineering . in _ proceedings of technology of object - oriented languages and systems ( tools 1999 ) _",
    ", pages 1832 .",
    "ieee computer society , 1999 .",
    "richard  c. holt .",
    "structural manipulations of software architecture using tarski relational algebra . in _ proceedings of the 5th working conference on reverse engineering ( wcre 1998 ) _ , pages 210219 .",
    "ieee computer society , 1998 .",
    "christian krmer and lutz prechelt .",
    "design recovery by automated search for structural design patterns in object - oriented software . in _ proceedings of the 3rd working conference on reverse engineering ( wcre 1996 ) _ , pages 208215 .",
    "ieee computer society , 1996 .",
    "rudolf  k. keller , reinhard schauer , sbastien robitaille , and patrick pag .",
    "pattern - based reverse - engineering of design components . in _ proceedings of the 21st international conference on software engineering ( icse 1999 ) _ , pages 226235 .",
    "acm , 1999 .",
    "bernt kullbach and andreas winter . querying as an enabling technology in software reengineering . in _ proceedings of the 3rd european conference on software maintenance and reengineering ( csmr 1999 ) _ ,",
    "pages 4250 , 1999 .",
    "kim mens , roel wuyts , and theo dhondt . declarative codifying software architectures using virtual software classifications . in _ proceedings of the 29th international conference on technology of object - oriented languages and systems - europe ( tools 1999 ) _ , pages 3345 .",
    "ieee computer society , 1999 .",
    "jrg niere , wilhelm schfer , jrg  p. wadsack , lothar wendehals , and jim welsh . towards pattern - based design recovery . in _ proceedings of the 24th international conference on software engineering ( icse 2002 ) _ , pages 338348 .",
    "acm , 2002 .",
    "forrest shull , walclio  l. melo , and victor  r. basili .",
    "an inductive method for discovering design patterns from object - oriented software systems .",
    "technical report cs - tr-3597 , computer science department , university of maryland , 1996 .",
    "mohlalefi sefika , aamod sane , and roy  h. campbell .",
    "monitoring compliance of a software system with its high - level design models . in _ proceedings of the 18th international conference on software engineering ( icse 1996 ) _ , pages 387396 .",
    "ieee computer society , 1996 .",
    "paolo tonella and giulio antoniol .",
    "object oriented design pattern inference . in _ proceedings of the international conference on software maintenance ( icsm 1999 ) _ , pages 230238 .",
    "ieee computer society , 1999 .",
    "jingwei wu , ahmed  e. hassan , and richard  c. holt . using graph patterns to extract scenarios . in _ proceedings of the 10th international workshop on program comprehension ( iwpc 2002 ) _",
    ", pages 239247 .",
    "ieee computer society , 2002 ."
  ],
  "abstract_text": [
    "<S> crocopat is an efficient , powerful and easy - to - use tool for manipulating relations of arbitrary arity , including directed graphs . </S>",
    "<S> this manual provides an introduction to and a reference for crocopat and its programming language  rml . </S>",
    "<S> it includes several application examples , in particular from the analysis of structural models of software systems . </S>"
  ]
}