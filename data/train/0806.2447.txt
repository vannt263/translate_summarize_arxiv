{
  "article_text": [
    "in the quest to develop quantum programming languages , quantum extensions of functional languages provide a promising route , hence the explosion of works on quantum lambda calculi and quantum functional languages @xcite@xcite@xcite@xcite .",
    "the current language proposals can be split into two categories . in the first category , qubits are manipulated as pointers towards a quantum memory @xcite@xcite , thus the syntax does not provide an explicit description of the qubits .",
    "it does , however , together with a linear type system , give a convenient and coherent way to handle operations on qubits .",
    "a drawback is that the semantics of quantum operations can not be given intrinsically in the syntax , as this would require the actual state of the quantum memory to be known . in the second category of languages @xcite@xcite@xcite",
    "the description of the qubits is part of the programming language , and no type system is required .",
    "an advantage here is that the entire semantics can be expressed simply as a rewrite system between terms of the language .",
    "this turns into a weakness regarding measurements , because the inherently probabilistic nature of measurement makes it difficult to express as part of a rewrite system .",
    "in fact , neither category of languages allow this feature .",
    "@xcite@xcite    the case of altenkirch and grattage s _ qml _",
    "@xcite is not so clear - cut , but it does illustrate this difficulty . _",
    "qml _ includes measurements with an operational semantics given in terms of quantum circuits .",
    "however , the corresponding algebraic theory @xcite stands only for a pure quantum subset of the language , with classical - control and measurement omitted .",
    "van tonder s @xmath1 @xcite is a higher - order untyped lambda calculus which includes quantum properties .",
    "this calculus carries a history track to keep the necessary information to invert reductions , to ensure that the global computation process is unitary .",
    "it is closely related to linear logic , with the syntax being a fragment of the one introduced by wadler @xcite , extended with constants to represent quantum entities such as qubits and gates .",
    "linearity concepts are used to distinguish definite terms from arbitrary superposition terms .",
    "these syntactic markers constitute the main difference with arrighi and dowek s _ lineal _ @xcite@xcite , which is more permissive .",
    "as mentioned previously , measurement is not included in these two proposals .",
    "the work presented here shows how to add measurement to a quantum lambda calculus with explicit qubits in an elegant manner .",
    "this is done with full details for the @xmath1-calculus , with a proof that confluence , and hence the consistency of the operational semantics , is preserved by this extension .",
    "although this calculus does not need a proof of confluence in the original setting , due to the fixed reduction strategy , this proof is necessary in the presence of measurement .",
    "furthermore , it is non - trivial and has the novelty of showing the confluence in a probabilistic setting with the branching produced by the measurement .",
    "the methods illustrated here are general , and applying these techniques to _ qml _ and _ lineal _ is in progress .",
    "in contrast to measurement in classical mechanics , which gives the value of a given observable with an associated error , measurements in quantum mechanics have an intrinsically probabilistic character . that is , a quantum measurement can give , _ a priori _ , a certain number of results , each one with some finite probability .",
    "moreover , the state of the system after the measurement is changed in an irreversible manner by the act of measurement .",
    "this unintuitive behaviour is of acute importance in quantum information processing .",
    "measurement is a key property in many quantum information processing tasks , such as quantum cryptography , superdense coding , and in quantum search algorithms .",
    "not having measurements can lead to misinterpretations .",
    "consider as an example the quantum teleportation algorithm with deferred measurement @xcite as defined in fig .",
    "[ alg : telep ] . here",
    "it is unclear if alice and bob can be physically separated , as all the channels used are quantum channels .",
    "an obvious question arises : why use this algorithm if there is a quantum channel between alice and bob ?",
    "measuring the final state will result in the original logical - qubit having been transferred to bob .",
    "the problem is not one of correctness , but of interpretation .",
    "secondly , understanding measurement is essential to avoid misinterpreting quantum computation as a whole ( e.g. why quantum computation does not lead straightforwardly to an exponential jump in complexity ) .",
    "this work takes the view that in order to understand the possibilities and limitations of quantum computation , measurement needs be formalised in an elegant manner .",
    "note that the projective measurement discussed in this paper is not the only possibility for a quantum measurement , but it is one of the simplest .",
    "in addition , any quantum measurement can be reproduced by the action of a unitary mapping and a projective measurement .",
    "@xmath2          & { \\mathbf{let}\\ } ( e_1 , e_2 ) = { { \\textrm{\\sf{epr}}}}{\\ \\mathbf{in}\\ } \\\\          & { \\mathbf{let}\\ } ( q ' , y ' ) = { { \\textrm{\\sf{alice}}}}\\ ( q , e_1 ) { \\ \\mathbf{in}\\ } \\\\          & \\quad { { \\textrm{\\sf{bob}}}}\\ ( q ' , y ' , e_2 )      \\end{aligned}$ ]    where    @xmath3                  & { \\mathbf{let}\\ } ( q ' , y ' ) = { \\textit{cnot}\\,}\\ ( q , e_1 ) { \\ \\mathbf{in}\\ } \\\\              & ( ( h\\ q ' ) , y ' )          \\end{aligned}\\\\ { { \\textrm{\\sf{bob}}}}\\ ( q ' , y ' , e_2 ) \\rightarrow          \\begin{aligned}[t ]                  & { \\mathbf{let}\\ } ( y '' , e_2 ' ) = \\textit{cx}\\,\\ ( y ' , e_2 ) { \\ \\mathbf{in}\\ } \\\\                  & { \\mathbf{let}\\ } ( q '' , e_2 '' ) = \\textit{cz}\\,\\ ( q ' , e_2 ' ) { \\ \\mathbf{in}\\ } \\\\                  & \\quad ( q '' , y '' , e_2 '' )          \\end{aligned}\\\\ { { \\textrm{\\sf{epr}}}}\\equiv { \\textit{cnot}\\,}\\ ( ( h\\ 0),0)\\end{array}$ ]       @xmath4 } & { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 1,0 ] } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { * { \\xy * + < .6em>{h};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 2,0 ] } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } &   { { * { \\xy * + < .6em>{\\xy *",
    "! < 0em,1.1em > h\\cir<1.1em>{ur_dr},!u-<0em,.4em>;p+<.5em,.9em > * * h\\dir{- } \\pos",
    "< -.6em,.4em > * { } ,",
    "< .6em,-.4em > * { } \\endxy};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1]}}}\\\\ { * !",
    "r!<.5em,0em>=<0em>{{\\left\\vert{0}\\right\\rangle } } }     & { * { \\xy * + < .6em>{h};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 1,0 ] } { \\ar @{- } [ 0,-1 ] } }   & { * { \\xy{<0em,0em > * { } \\ar @ { - } + < .4em,0em > \\ar @ { - } -<.4em,0em > \\ar @ { - } + < 0em,.4em > \\ar @ { - } -<0em,.4em>},*+<.8em>\\frm{o}\\endxy } { \\ar @{- } [ 0,-1]}}{\\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 1,0 ] } { \\ar @{- } [ 0,-1 ] } }        & { \\ar @{- } [ 0,-1 ] } &   { { * { \\xy",
    "* + < .6em>{\\xy * !",
    "< 0em,1.1em > h\\cir<1.1em>{ur_dr},!u-<0em,.4em>;p+<.5em,.9em > * * h\\dir{- } \\pos",
    "< -.6em,.4em > * { } ,",
    "< .6em,-.4em > * { } \\endxy};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1]}}}\\\\ { * ! r!<.5em,0em>=<0em>{{\\left\\vert{0}\\right\\rangle } } }     &   { \\ar @{- } [ 0,-1 ] } & { * { \\xy{<0em,0em > * { } \\ar @ { - } + < .4em,0em >",
    "\\ar @ { - } -<.4em,0em > \\ar @ { - } + < 0em,.4em > \\ar @ { - } -<0em,.4em>},*+<.8em>\\frm{o}\\endxy } { \\ar @{- } [ 0,-1]}}{\\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { * { \\xy * + < .6em>{x};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { * { \\xy * + < .6em>{z};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } &   { * ! r!<.5em,0em>=<0em>{q } } { \\pos\"1,8\".\"2,8\".\"1,8\".\"2,8\"!c*+<.7em>\\frm{-- } } } \\end{aligned}\\ ] ]    circuit for the quantum teleportation algorithm with deferred measurement    in the second section of this paper , the process of adding measurement is shown with full details for van tonder s @xmath1 .",
    "the section concludes with an implementation of the teleportation algorithm in extended @xmath1 .",
    "section 3 discusses and proves confluence for extended @xmath1 .",
    "finally , section 4 closes with details of ongoing and future work .",
    "adding a measurement operator to a quantum lambda calculus can be achieved with only small changes to the grammar . in this section",
    "we show how to change the syntax , add well - formedness rules for terms , and give the operational semantics .      to account for measurements , the grammar of @xmath1",
    "must be extended with a family of measurement operators @xmath5 , which measure the qubits indicated by the set @xmath6 .",
    "in addition , it is necessary to make the syntax for qubits precise , because their `` shape '' is needed by the measurement operator .",
    "this is achieved in a manner following on from _ lineal _ @xcite and _ qml _ @xcite . regarding van tonder s original syntax ,",
    "the only significant change is to split `` constants '' into qubit - constants , measurement - constants and gate - constants .",
    "the extended syntax is shown in figure [ fig : syntax ] and the added rules of well - formedness are given in figure [ fig : well - formed ] .",
    "a term is a pre - term produced by the syntax in figure [ fig : syntax ] which follows the rules for well - formedness given by van tonder @xcite plus the rules in figure [ fig : well - formed ] . amongst these rules",
    "note that _ m _ and _ gate _ state that @xmath5 and @xmath7 are simply constant symbols .",
    "_ zero _ and _ one _ force @xmath8 and @xmath9 respectively to be non - linear terms .",
    "_ tensor _ and _ ! tensor _",
    "allow tensorial products between qubits to be written .",
    "although terms like @xmath10 are not allowed , they are a contraction for @xmath11 .",
    "_ superposition _ provides a way of writing qubits in superpositions , and _ simplification _ allows subterms with the scalar factor @xmath12 to be removed .",
    "note that a term with a pattern @xmath13 is not well - formed , but there is always an equivalent term which can express this in a well - formed way .",
    "for example , the term @xmath14 is not well - formed , however , it is equivalent to @xmath15 which is well - formed .",
    "@xmath16    @xmath17\\hspace{4 cm } \\inference{}{\\vdash c_u}[gate]\\\\ \\\\",
    "! { \\left\\vert{0}\\right\\rangle}}[zero]\\hspace{4 cm } \\inference{}{\\vdash",
    "! { \\left\\vert{1}\\right\\rangle}}[one]\\\\ \\\\",
    "\\inference{\\gamma \\vdash q_1 \\qquad \\delta \\vdash q_2}{\\gamma , \\delta \\vdash q_1 \\otimes q_2}[tensor]\\hspace{1 cm } \\inference{\\gamma \\vdash",
    "\\qquad \\delta \\vdash !",
    "q_2}{\\gamma , \\delta \\vdash ! q_1 \\otimes ! q_2}[!tensor]\\\\ \\\\",
    "\\inference{\\sum\\limits_{i=0}^{2^n-1}{|\\alpha_i|^2}=1 \\qquad \\alpha_i \\in \\mathbb{c } , i=0\\dots 2^n-1}{\\vdash \\alpha_0 ( ! { \\left\\vert{0}\\right\\rangle}\\otimes \\cdots \\otimes ! { \\left\\vert{0}\\right\\rangle } ) + \\cdots + \\alpha_{2^n-1 } ( ! { \\left\\vert{1}\\right\\rangle}\\otimes \\cdots \\otimes ! { \\left\\vert{1}\\right\\rangle})}[superposition]\\\\ \\\\ \\inference{\\alpha_r=0 , r \\in \\{0,\\dots,2^n-1\\ } \\qquad \\gamma \\vdash \\sum\\limits_{i=0}^{2^n-1}{\\alpha_i q_i}}{\\gamma \\vdash \\sum\\limits_{\\begin{subarray}{l } i=0 \\\\",
    "i\\neq r \\end{subarray}}^{2^n-1}{\\alpha_i q_i}}[simplification ] \\end{array}\\ ] ]    the usual @xmath18construction will be used as a useful shorthand , defined as : @xmath19 it is interesting to note that a cloning machine such as @xmath20 is syntactic - sugar for @xmath21 , which is forbidden by the well - formedness rules since @xmath22 is linear ( it can not appear twice ) , and moreover there is no way to tensor variables : they can only be qubit - constants .    @xmath18can also be used over lists , as per van tonder s @xmath23 , but they are written here as a tensor product .",
    "for example , the term @xmath24 is the same as @xmath25 .",
    "additionally , note that @xmath26 is used following van tonder s @xmath23 ; it is an overloading of the operator @xmath27 , denoting both the tensor product between qubits and also list constructors .",
    "measurement in quantum systems is an inherently probabilistic operation . following di pierro _",
    "@xcite , where a probabilistic rewrite system is defined over a @xmath0-calculus , the operational semantics for measurement in extended @xmath1 is defined as follows : @xmath28    c [ @xmath29    @xmath28    where    * @xmath30 . * @xmath31 with @xmath32 for @xmath33 . *",
    "@xmath34 is the set of binary words of length @xmath35 such that they coincide with @xmath36 on the letters of index @xmath6 .",
    "* @xmath37 . *",
    "the notation @xmath38 means that @xmath39 goes to @xmath40 with probability @xmath41 .",
    "it is instructive to look at an example of this rule in action :    let @xmath42 , @xmath43 and @xmath44 with @xmath45 and @xmath46 is the @xmath47 bit in the binary representation of @xmath48 . according to the previous rule , @xmath49 will generate @xmath50 different outputs ( corresponding to the different possible values of the qubits @xmath51 , @xmath52 and @xmath53 , which are measured ) .",
    "take as an example the output @xmath54 ( its 3-bit binary representation is @xmath55 ) .",
    "hence , @xmath56 which are the numbers @xmath48 between @xmath12 and @xmath57 whose binary representation is of the form @xmath58 ( so they coincide with @xmath36 , if we compare the bits @xmath51 , @xmath52 and @xmath53 of @xmath48 with the bits @xmath59 , @xmath51 and @xmath52 of @xmath36 ) .",
    "then , the final term is : @xmath60 where + @xmath61 + @xmath62    which represents the following quantum state : @xmath63      measurement as a feature is only useful if the result of the measurement can be used to determine the future evolution of the program .",
    "hence a conditional statement similar to that given in qml is needed . however , in contrast to qml s @xmath64 statements @xcite , only base - qubits are allowed in the condition .",
    "this is all that is required , as the _ if _ structure is only needed to provide a way to read the output of measurements .",
    "conditional statements are realised by adding the following to the syntax : @xmath65 and the operational semantic is given by : @xmath28    c [ @xmath66 +   + [ @xmath67 +    @xmath28    note that as the condition may be not be a base - qubit , it is not guaranteed that the whole term will reduce .",
    "this addition is required , as without such an _ if _ statement such as this being added to the language , this extension to measurements would have been equivalent to a simple extension from unitary constants to quantum operation constants .      with the rules developed so far , the teleportation algorithm can be rewritten as shown in fig .",
    "[ alg : telepm ] .",
    "@xmath68      & { \\mathbf{let}\\ } x\\otimes y = { { \\textrm{\\sf{epr}}}}{\\ \\mathbf{in}\\ } \\\\          & { \\mathbf{let}\\ } b_1\\otimes b_2 = m_{\\{1,2\\}}\\ { { \\textrm{\\sf{alice}}}}\\ q\\ x { \\ \\mathbf{in}\\ } \\\\          & \\quad { { \\textrm{\\sf{bob}}}}\\ b_1\\ b_2\\ y   \\end{aligned}$ ]    where    @xmath69                                 & { \\mathbf{let}\\ } r\\otimes w = { \\textit{cnot}\\,}\\ q\\otimes x { \\ \\mathbf{in}\\ } \\\\                                 &   ( ( h\\ r)\\otimes w )                                \\end{aligned}\\\\ { { \\textrm{\\sf{bob}}}}\\ b_1\\ b_2\\ y{\\rightarrow_{1}}{{\\textrm{\\sf{zed}}}}\\ b_1\\ ( { { \\textrm{\\sf{ex}}}}\\ b_2\\ y ) \\\\ { { \\textrm{\\sf{ex}}}}\\ b\\ x{\\rightarrow_{1}}{\\ \\mathbf{if}\\ } b { \\ \\mathbf{then}\\ } ( x\\ y ) { \\ \\mathbf{else}\\ } y \\\\ { { \\textrm{\\sf{zed}}}}\\ b\\ x{\\rightarrow_{1}}{\\ \\mathbf{if}\\ } b { \\ \\mathbf{then}\\ } ( z\\ x ) { \\ \\mathbf{else}\\ } x \\\\ { { \\textrm{\\sf{epr}}}}\\equiv { \\textit{cnot}\\,}\\ ( ( h\\ ! { \\left\\vert{0}\\right\\rangle})\\otimes ! { \\left\\vert{0}\\right\\rangle } ) \\end{array}$ ]       @xmath70 } & { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 1,0 ] } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { * { \\xy * + < .6em>{h};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { { * { \\xy * + < .6em>{\\xy * ! <",
    "0em,1.1em > h\\cir<1.1em>{ur_dr},!u-<0em,.4em>;p+<.5em,.9em > * * h\\dir{- } \\pos",
    "< -.6em,.4em > * { } ,",
    "< .6em,-.4em > * { } \\endxy};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } } & { * ! < 0em,.04em>-<.07em,.11em>{\\xy * = < .45em>[o][f]{}\\endxy}}{\\ar @{= } [ 0,-1]}{\\ar @{= } [ 1,0 ] } \\\\ { * !",
    "r!<.5em,0em>=<0em>{{\\left\\vert{0}\\right\\rangle } } }     & { * { \\xy * + < .6em>{h};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{- } [ 0,-1 ] } & { { * -=-{\\bullet}}{\\ar @{- } [ 1,0 ] } { \\ar @{- } [ 0,-1 ] } }        & { * { \\xy{<0em,0em > * { } \\ar @ { - } + < .4em,0em > \\ar",
    "@ { - } -<.4em,0em > \\ar @ { - } +",
    "< 0em,.4em > \\ar @ { - } -<0em,.4em>},*+<.8em>\\frm{o}\\endxy } { \\ar @{- } [ 0,-1]}}{\\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { { * { \\xy * + < .6em>{\\xy * ! < 0em,1.1em > h\\cir<1.1em>{ur_dr},!u-<0em,.4em>;p+<.5em,.9em > * * h\\dir{- } \\pos < -.6em,.4em > * { } , < .6em,-.4em > * { } \\endxy};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } } & { * ! < 0em,.04em>-<.07em,.11em>{\\xy * = < .45em>[o][f]{}\\endxy}}{\\ar @{= } [ 0,-1]}{\\ar @{= } [ -1,0]}\\\\ { * ! r!<.5em,0em>=<0em>{{\\left\\vert{0}\\right\\rangle } } }     & { \\ar @{- } [ 0,-1 ] } & { * { \\xy{<0em,0em > * { } \\ar @ { - } + < .4em,0em > \\ar",
    "@ { - } -<.4em,0em > \\ar @ { - } +",
    "< 0em,.4em > \\ar @ { - } -<0em,.4em>},*+<.8em>\\frm{o}\\endxy } { \\ar @{- } [ 0,-1]}}{\\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { \\ar @{- } [ 0,-1 ] } & { * { \\xy * + < .6em>{z^{b_1}x^{b_2}};p\\save+lu;+ru * * \\dir{-}\\restore\\save+ru;+rd * * \\dir{-}\\restore\\save+rd;+ld * * \\dir{-}\\restore\\pos+ld;+lu * * \\dir{-}\\endxy } { \\ar @{- } [ 0,-1 ] } } { \\ar @{= } [ -1,0 ] } & { \\ar @{- } [ 0,-1 ] } & { * ! l!<-.5em,0em>=<0em>{q } } } } \\end{aligned}\\ ] ]    circuit for the original quantum teleportation algorithm",
    "when defining a language , a grammar must also be provided ( how to construct terms ) , and a semantics ( how these terms compute ) .",
    "the semantics can be denotational ( terms are mapped to elements of a semantic domain , each corresponding to what is computed by the term ) or operational ( terms are mapped into other terms , with each transition corresponding to a computational step ) . clearly it must be proved that the semantics provided is unambiguous and consistent .",
    "for example , the semantics will usually induce an equational theory upon terms ( via equality in the semantics domain or by equating two terms if one reduces to the other ) , and it is important that this theory should not equate all terms .    in @xmath1 a consistent equational theory is given .",
    "however , adding measurement does not correspond to a simple system for equational reasoning .",
    "it is not possible to proceed by replacing terms by equal terms according to any equational theory , since measurement is a probabilistic operation , and each reduction instance could produce different terms that are impossible to reconcile in the system . in the presence of an operational semantics , a usual method of proving the consistency result is to provide a proof of confluence .",
    "this property states that the order in which the transition rules are applied does not matter to the end result , thus removing any ambiguity . in this section",
    "it is shown how such a study of confluence can still be carried through , even in the presence of probabilities .",
    "as @xmath1 provides a fixed reduction strategy , proving confluence in the original language is trivial , because there is only one possible reduction at each step .",
    "however , this is not the case in the presence of measurement , where proving confluence is non - trivial .",
    "whilst the above - mentioned probabilistic reductions are an elegant and concise way to present the operational semantics , the study of confluence is not immediate in this setting . for confluence , it is necessary to prove that if any term @xmath39 can reduce to @xmath48 and to @xmath71 , then there exists a @xmath36 such that @xmath72 .",
    "however , in a probabilistic calculus it could be that @xmath73 and @xmath74 , where @xmath41 and @xmath75 represent the probability of the respective reduction occurring , and there is no @xmath36 that both @xmath48 and @xmath71 could reduce to .",
    "for example , given @xmath76 , a measurement operator in the computational basis , it follows that @xmath77 and @xmath78 .",
    "however , there is no @xmath36 such that @xmath79 and @xmath80 .    a nave way to deal with this would be to assume that if there is some normal form that can be reached with a certain probability , then by following any path it must to be possible to reach the same normal form with the same probability . however , this definition is not rigorous , and not applicable to terms without a normal form .",
    "hence , it does not allow the development of a formal proof of confluence .",
    "probabilistic transitions need to be abstracted out in order to allow only one possible normal form for each term , and to deal with terms without normal form . with this aim ,",
    "the following definition gives a notion of confluence for probabilistic calculi :    [ def : termensable ] a term ensemble @xmath81 is defined as a collection of terms @xmath82 , each with an associated probability @xmath83 , such that @xmath84 .",
    "note that given a term @xmath39 , it may be considered as a term ensemble @xmath85 .",
    "consider the term ensemble @xmath86 , where the term @xmath87 appears twice . by summing the probabilities of any equivalent terms ,",
    "this ensemble can be identified with the more compact ensemble @xmath88 .    throughout this paper",
    "the symbol @xmath89 will be used for both @xmath90-equivalences and equalities . when referring to a set , _",
    "i.e. _ where each element appears once , it is considered to be modulo @xmath90-equivalence .    the appropriate steps such that @xmath91 is identified with @xmath92 need to be taken . definition [ def : simpensemble ] formalises this equivalence :    [ def : simpensemble ] let @xmath93 be a function that takes a term ensemble and returns a set defined by @xmath94 as the co - domain is a set , it allows only one instance of each element .",
    "let @xmath95 be a function that takes a term and a term ensemble and returns the sum of the probabilities associated to each instance of the term in the ensemble : @xmath96    finally , let @xmath97 be a function that takes a term ensemble and returns a term ensemble defined by @xmath98    a term ensemble @xmath99 is thus said to be _ equivalent _ to a term ensemble @xmath100 , @xmath101 , _ iff _",
    "note that the definition of @xmath97 is correct , as @xmath103 trivially sums to @xmath59 .",
    "a deterministic transition rule between term ensembles can also be defined :    [ def : transition ] if @xmath104 is a probabilistic rewrite system over terms , let @xmath105 be the deterministic rewrite system over term ensembles written @xmath106 and defined as @xmath107 where all the reductions between single terms are produced by following any rule in @xmath104 , or none",
    ".    given a probabilistic rewrite system @xmath108 , then @xmath109 preserves ensembles .",
    "let @xmath81 and @xmath110 be term ensembles such that @xmath111 .",
    "then , by definition [ def : transition ] , @xmath112    hence , @xmath113 .    using these concepts , ( strong )",
    "confluence for a probabilistic rewrite system can be expressed as show in definition [ def : confluence ] .",
    "[ def : confluence ] let @xmath114 be a probabilistic rewrite system .",
    "@xmath114 is said to be confluent if , for each term ensemble @xmath115 such that @xmath116 , there exist equivalent term ensembles @xmath99 and @xmath100 such that @xmath117 .",
    "@xmath114 is said to be _ strongly _ confluent if , for each term ensemble @xmath115 , such that @xmath118 , there exist equivalent term ensembles @xmath99 and @xmath100 such that @xmath119 .",
    "note that strong confluence of @xmath114 implies the confluence of @xmath114 , and also that the confluence of @xmath114 implies the strong confluence of @xmath120 .",
    "it is possible to extend the hindley - rosen lemma @xcite@xcite to these notions of confluence , as follows :    [ prop : confluenceunion ] let @xmath114 and @xmath121 be strongly confluent probabilistic rewrite systems .",
    "if @xmath114 and @xmath121 strongly commute , that is if for each term ensemble @xmath115 such that @xmath122 , there exist equivalent term ensembles @xmath99 and @xmath100 such that @xmath123 , therefore @xmath124 is strongly confluent .",
    "theorem [ pablo ] allows the remaining proofs to be simplified , by showing that it is enough to prove strong confluence ( commutation ) for a single - term term ensemble .",
    "[ pablo ] let @xmath125 and @xmath126 be probabilistic rewrite systems such that : @xmath127    then @xmath128 , @xmath129 and @xmath130 such that @xmath131 and @xmath132 , there exist equivalent @xmath99 and @xmath100 such that @xmath133 and @xmath134 .",
    "let @xmath135 , @xmath136 and @xmath137 such that @xmath131 and @xmath132 , _ i.e. _ for each @xmath138 : @xmath139    consider the single term term - ensembles @xmath140 , and the term ensembles @xmath141 and @xmath142 . by equation ( [ thm : pablo - transition ] ) , for each @xmath138 , @xmath143 and @xmath144 . by our hypothesis , for each @xmath138 there exist equivalent term ensembles @xmath145 and @xmath146 such that @xmath147 and @xmath148 .    by taking @xmath149 and @xmath150",
    ", it follows that @xmath133 and @xmath134 . as @xmath151 @xmath152",
    ", it is trivially the case that @xmath101 .",
    "lemma [ lemacorto ] guarantees that equivalence between term ensembles is a congruence by adding identical context to each term in both of the ensembles :    [ lemacorto ] given two equivalent term ensembles @xmath153 and @xmath154 and any context @xmath155 , the term ensembles @xmath156},\\ , { \\alpha_i}\\rangle\\}}$ ] and @xmath157},\\ , { \\gamma_j}\\rangle\\}}$ ] are also equivalent .",
    "@xmath158 , defined as equal to @xmath159 , then    @xmath160},\\ , { { \\textrm{\\sf{sumprob}}}(t,\\omega_1)}\\rangle\\}}\\right ) \\\\    & = & { \\textrm{\\sf{min}}}\\left({\\{\\langle{c[w_k / x]},\\ , { \\delta_k}\\rangle\\}}\\right ) \\\\   & = & { \\textrm{\\sf{min}}}\\left(\\bigcup\\limits_{t\\,\\in\\,{\\textrm{\\sf{first}}}(\\omega_2 ) } { \\{\\langle{c[t / x]},\\ , { { \\textrm{\\sf{sumprob}}}(t,\\omega_2)}\\rangle\\}}\\right ) \\\\   & = & \\bigcup\\limits_{t\\,\\in\\,{\\textrm{\\sf{first}}}(\\tau_2 ) } { \\{\\langle{t},\\ , { { \\textrm{\\sf{sumprob}}}(t,\\tau_2)}\\rangle\\ } } \\\\   & = & { \\textrm{\\sf{min}}}(\\tau_2)\\end{aligned}\\ ] ]    and hence @xmath161 .",
    "the strong confluence of the added rules is formally expressed and proved by theorem [ omegas ] .",
    "[ omegas ] the probabilistic reduction rules system @xmath162 is strongly confluent .",
    "given term ensembles @xmath163 , @xmath129 and @xmath130 , where @xmath164 , and such that @xmath165 and @xmath132 , then by proving there exist equivalent term ensembles @xmath99 and @xmath100 such that @xmath133 and @xmath166 , theorem [ pablo ] shows that this system is strongly confluent .",
    "this result is proved here using structural induction over @xmath39 .",
    "1 .   @xmath167 .",
    "note that there is no rule in @xmath126 that can reduce @xmath39 in this case , and hence only @xmath168 is applicable , producing @xmath169 .",
    "therefore there can not exist any @xmath170 .",
    "2 .   [ trivial ] @xmath171 .",
    "hence @xmath172 .",
    "[ abstraccion ] @xmath173 .",
    "+ let @xmath174 where @xmath175 , with @xmath84 , and let @xmath176 where @xmath177 with @xmath178 . + by induction ,",
    "there exist equivalent term ensembles @xmath179 and @xmath180 such that @xmath181 and @xmath182 . +",
    "hence @xmath183 and @xmath184 can be taken , which are equivalent by lemma [ lemacorto ] .",
    "4 .   @xmath185 , analogous to case ( [ abstraccion ] ) .",
    "[ aplic ] @xmath186 .",
    "consider the following cases : 1 .",
    "[ largo ] let @xmath187 where @xmath188 , with @xmath84 , and + let @xmath189 where @xmath190 , with @xmath178 . +",
    "this case is analogous to case ( [ abstraccion ] ) , as lemma [ lemacorto ] is applicable .",
    "2 .   let @xmath191 and @xmath192 .",
    "this follows case ( [ largo ] ) .",
    "3 .   [ mixed ]",
    "let @xmath191 and @xmath193 , then take @xmath194 4 .",
    "let @xmath195 , @xmath196 where @xmath197 , with @xmath84 .",
    "this follows case ( [ trivial ] ) .",
    "consider the following cases : 1 .",
    "let @xmath199 where @xmath200 , with @xmath84 and + let @xmath201 where @xmath202 , with @xmath178 .",
    "+ this is analogous to ( [ aplic].[mixed ] ) . in fact , any combination that implies that @xmath129 and @xmath130 are obtained by the reduction of @xmath87 , @xmath203 or @xmath204 , is analogous to one of the subcases of case ( [ aplic ] ) .",
    "2 .   let @xmath205 , and let @xmath206 where @xmath207 , with @xmath178 .",
    "then take @xmath172 .",
    "( analogous if @xmath202 and @xmath208 ) .",
    "3 .   let @xmath205 , and let @xmath201 where @xmath202 , with @xmath178 . then take @xmath209 .",
    "( analogous for @xmath204 ) .      before formalising the confluence for the whole calculus ,",
    "some key examples are presented :    * _ cloning _ arguments : @xmath210 + the problem here is that if copying a measurement is allowed , this may give different results for each measurement . however , by measuring first and then applying the abstraction , both measurements are the same . in @xmath1 ,",
    "these kinds of terms are disallowed by the well - formedness rules @xcite ; a linear argument can appear only once in the body of a function .",
    "* _ copying _ arguments : @xmath211 + when the argument is linear , there is no rule in the operational semantics of @xmath1 that allows the application of a non - linear abstraction to a linear term .",
    "hence , @xmath76 must apply first , producing a non - linear output ( either @xmath212 or @xmath213 ) . * _ promoting _ arguments : @xmath214 + in this case copying the measurement operation twice is allowed , and this is the only applicable reduction strategy because @xmath215 terms are values in @xmath1 .    in light of the above statements , a formal proof of confluence for the entire system",
    "is required .",
    "lemma [ sincontexto ] ensures that , under some hypotheses , measurement is independent of context :    [ sincontexto ] let @xmath46 be a variable and let @xmath39 be a linear term with only one linear instance of @xmath46 .",
    "if @xmath216 , then @xmath217{\\stackrel{(m)}\\rightarrow_{p}}t[v / x]$ ] .",
    "structural induction over @xmath39    1 .",
    "let @xmath39 be such that @xmath218 @xmath219=t = t[v / x]$ ] .",
    "2 .   let @xmath220 .",
    "@xmath221 = m { \\stackrel{(m)}\\rightarrow_{p}}v = x[v / x]$ ] .",
    "[ lambda ] let @xmath222 . by induction @xmath223 { \\stackrel{(m)}\\rightarrow_{p}}\\lambda y.t'[v / x]$ ] .",
    "4 .   let @xmath224 .",
    "analogous to case ( [ lambda ] ) .",
    "[ app ] let @xmath186 , with @xmath225 .",
    "then @xmath226 $ ] = @xmath227\\ t_2)$ ] and by induction , @xmath227\\ t_2){\\stackrel{(m)}\\rightarrow_{p}}(t_1[v / x]\\ t_2)$ ] , which is equal to @xmath228 $ ] .",
    "let @xmath186 , with @xmath229 .",
    "analogous to case ( [ app ] ) .",
    "let @xmath230 .",
    "analogous to case ( [ app ] ) .",
    "next , it is proved that the original reduction rules system from @xmath1 and the new rules for measurements strongly commute .",
    "this is suggestive of the confluence of the whole system    [ thm2 ] the probabilistic reduction rules systems @xmath231 @xmath232 and @xmath162 strongly commute .    if it is proved that given term ensembles @xmath163 , @xmath129 and @xmath130 , @xmath164 , such that @xmath131 and @xmath132",
    ", then this implies that there exist equivalent term ensembles @xmath99 and @xmath100 such that @xmath133 and @xmath134 , then @xmath125 and @xmath126 verify the hypotheses for theorem [ pablo ] , which proves strong commutation between them .",
    "this result is proved here using structural induction over @xmath39 .",
    "1 .   @xmath233 .",
    "note that there is no rule in @xmath126 nor @xmath125 that can reduce @xmath39 in this case , hence only @xmath168 is applicable , producing @xmath169 .",
    "therefore there can not exists any @xmath170 .",
    "[ thm2:trivial ] @xmath171 .",
    "hence @xmath172 .",
    "( analogous for @xmath169 ) .",
    "[ thm2:lambda ] @xmath173 , @xmath234 and @xmath176 such that @xmath131 and @xmath132 . by induction , there exist equivalent @xmath235 and @xmath236 such that @xmath237 and @xmath238",
    ". then take @xmath239 and @xmath240 which are equivalent by lemma [ lemacorto ] .",
    "4 .   @xmath241 .",
    "analogous to case ( [ thm2:lambda ] ) .",
    "[ thm2:app ] @xmath186 .",
    "consider the following cases : 1 .",
    "[ thm2:aplica ] @xmath242 and @xmath243 .",
    "analogous to case ( [ thm2:lambda ] ) ; note that lemma [ lemacorto ] also holds in this case .",
    "[ thm2:aplica2 ] @xmath244 and @xmath245 .",
    "analogous to subcase ( [ thm2:aplica ] ) .",
    "[ thm2:mixed ] @xmath244 and @xmath243 .",
    "take @xmath246 ( similarly if @xmath247 and @xmath248 ) .",
    "[ aplic : gate ] @xmath249 and @xmath250 , this follows case ( [ thm2:trivial ] ) .",
    "note that if instead of @xmath251 an expression like @xmath252 is given , it is subcase ( [ thm2:aplica2 ] ) which applies , where @xmath253 .",
    "@xmath254 and @xmath169 .",
    "this follows the analogous to case ( [ thm2:trivial ] ) .",
    "@xmath255 , @xmath256},\\ , { 1}\\rangle\\}}$ ] , @xmath257 . by lemma [ sincontexto ] , @xmath258},\\ , { \\gamma_j}\\rangle\\}}$ ] can be taken .",
    "note that if @xmath259 , with the same @xmath129 , then @xmath203 must be non - linear due to the well - formedness rules and hence in this situation it is the subcase ( [ aplic : gate ] ) .",
    "then @xmath129 has to be obtained by the reduction of @xmath261 or @xmath203 , hence , it is analogous to previous cases .",
    "note that if , for instance , @xmath262 and suppose that @xmath129 is obtained by the reduction of @xmath263 ( it can not be the application of the@xmath264statement to @xmath203 because there is not any rule that performs such a reduction ) then @xmath265 .",
    "consider the following cases : 1 .",
    "let @xmath266 where @xmath267 and let @xmath201 where @xmath202 and @xmath178 .",
    "analogous to ( [ thm2:app].[thm2:mixed ] ) .",
    "in fact , any combinations that implies that @xmath129 and @xmath130 are obtained by reduction of @xmath87 , @xmath203 , or @xmath204 , is analogous to one of the subcases of case ( [ thm2:app ] ) .",
    "2 .   let @xmath266 where @xmath267 and @xmath268 , then take @xmath265 .",
    "analogous if @xmath269 and @xmath270 .",
    "3 .   let @xmath271 where @xmath269 and @xmath268 , then take @xmath272 . similarly if @xmath267 and @xmath270 .",
    "it has been shown that @xmath126 and @xmath125 strongly commute , and hence @xmath273 and @xmath274 strongly commute .",
    "moreover , @xmath126 is confluent , and hence @xmath273 is strongly confluent .",
    "now , supposing @xmath125 is confluent , it follows that @xmath274 is strongly confluent .",
    "proposition [ prop : confluenceunion ] entails that @xmath275 is strongly confluent , and therefore that @xmath276 is confluent .",
    "therefore , the extension of van tonder s calculus presented here preserves confluence .",
    "this paper extends the quantum lambda calculus @xmath1 , defined by van tonder , with a family of measurement operations @xmath5 , which measure the qubits indicated by the set @xmath6 , and an _ if _ structure which allows reading of the output of these measurements . by defining the notion of ensembles of terms , and extending the rewrite system to a deterministic system between term ensembles , a proof of confluence for this extended calculus",
    "is presented .",
    "the extended calculus is therefore confluent , and retains the simplicity of van tonder s original calculus .",
    "the proof of confluence follows a method which can be applied to other calculi that make use of probabilistic transition rules .",
    "for example , this method could be applied to both _",
    "lineal _ and to _ qml _ , and this is the subject of ongoing research .",
    "the addition of a measurement operation to @xmath1 , which preserves confluence , is a significant development .",
    "this allows a more natural expression of quantum algorithms that intrinsically make use of measurement , such as quantum teleportation , superdense coding , and quantum search algorithms .",
    "moreover , having an operational semantic for measurements gives a way for understanding the behaviour of this quantum procedure , and this is a possible topic for future work .",
    "a. daz - caro would like to thank pablo e. martnez lpez for useful comments and helpful suggestions on an early draft of this paper , and the capp ( qcg ) group at the laboratoire dinformatique de grenoble for their hospitality .",
    "the authors would also like to thank simon perdrix for fruitful discussions .",
    "arrighi , p. and g.  dowek , _ linear - algebraic lambda - calculus : higher - order , encodings and confluence _ , in : b.  buchberger , editor , _ term rewriting and applications , 19th international conference , rta-08 _ , to appear in lncs ( 2008 ) , eprint available at arxiv : quant - ph/0612199 .",
    "prost , f. , _ taming non - compositionality using new binders _ , in : s.  g. akl , c.  s. calude , m.  j. dinneen , g.  rozenberg and t.  wareham , editors , _ uc _ , lecture notes in computer science * 4618 * ( 2007 ) , pp .",
    "150162 .",
    "wadler , p. , _ a syntax for linear logic _ , in : s.  d. brookes , m.  g. main , a.  melton , m.  w. mislove and d.  a. schmidt , editors , _ proceedings of the 9th international conference on mathematical foundations of programming semantics _ ( 1994 ) , pp ."
  ],
  "abstract_text": [
    "<S> this paper demonstrates how to add a measurement operator to quantum @xmath0-calculi . </S>",
    "<S> a proof of the consistency of the semantics is given through a proof of confluence presented in a sufficiently general way to allow this technique to be used for other languages . </S>",
    "<S> the method described here may be applied to probabilistic rewrite systems in general , and to add measurement to more complex languages such as _ qml _ @xcite or _ lineal _ @xcite@xcite , which is the subject of further research .    ,    ,    and    quantum lambda calculus , measurement , confluence , probabilistic rewrite system </S>"
  ]
}