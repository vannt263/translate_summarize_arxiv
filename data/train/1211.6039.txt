{
  "article_text": [
    "the basic robot model we employ has been thoroughly described in  @xcite .",
    "robots are modeled as points freely moving in @xmath0 ( or @xmath1 ) .",
    "each robot has its own coordinate system and its own unit distance , which may differ from the others .",
    "robots operate in cycles that consist of four phases : wait , look , compute , and move .    in a waitphase",
    "a robot is idle ; in a lookphase it gets a snapshot of its surroundings ( including the positions of the other robots ) ; in a computephase it computes a destination point ; in a movephase it moves toward the destination point it just computed , along a straight line .",
    "then the cycle repeats over and over .",
    "robots are anonymous and oblivious , meaning that they do not have distinct identities , they all execute the same algorithm in each computephase , and the only input to such algorithm is the snapshot coming from the previous lookphase .    in a movephase",
    ", a robot may actually reach its destination , or it may be stopped before reaching it .",
    "if a robot always reaches its destination by the end of each movephase , then the model is said to be _",
    "rigid_. if a robot can unpredictably be stopped before , the model is _ non - rigid_. however , even in non - rigid models , during a movephase , a robot must always be found on the line segment between its starting point and the destination point .",
    "moreover , there is a constant distance @xmath2 that a robot is guaranteed to walk at each cycle .",
    "that is , if the destination point that a robot computes is at most @xmath3 away ( referred to some global coordinate system ) , then the robot is guaranteed to reach it by the end of the next movephase .",
    "on the other hand , if the destination point is more than @xmath3 away , the robot is guaranteed to approach it by at least @xmath3 .    in the basic model",
    ", robots can not communicate in conventional ways or store explicit information , but a later addition to this model allows each robot to carry a `` colored light '' that is visible to every robot ( refer to  @xcite ) .",
    "there is a fixed amount of possible light colors , and a robot can compute its destination and turn its own light to a different color during a computephase , based on the light colors that it sees on other robots and on itself . usually ,",
    "when robots start their execution , they have all their lights set to a predetermined color . however , we are also interested in algorithms that work regardless of the initial color configurations of the robots .    in the fully synchronous model ( fsynch )",
    "all robots share a common notion of time , and all their phases are executed synchronously .",
    "the semi - synchronous model ( ssynch ) is similar , but not every robot may be active at every cycle .",
    "that is , some robots are allowed to `` skip '' a cycle at unpredictable times , by extending their waitphase to the whole cycle . however , the robots that are active at a certain cycle still execute it synchronously .",
    "also , no robot can remain inactive for infinitely many consecutive cycles .",
    "finally , in the asynchronous model ( asynch ) there is no common notion of time , and each robot s execution phase may last any amount of time , from a minimum @xmath4 to an unboundedly long , but finite , time .",
    "figure  [ f0 ] shows all the possible models arising from combining synchronousness , rigidity , and arbitrarity of the initial light colors .",
    "the trivial inclusions between models are also shown .    without loss of generality , in this paper we will assume lookphases in asynchto be instantaneous , and",
    "we will assume that a robot s light s color may change only at the very end of a computephase .",
    "gatheringis the problem of making a finite set of robots in the plane reach the same location in a finite amount of time , and stay there forever , regardless of their initial positions .",
    "such location should not be given as input to the robots , but they must implicitly determine it , agree on it , and reach it , in a distribute manner . note that this problem is different from convergence , in which robots only have to approach a common location , but may never actually reach it .",
    "for any set of more than two robots , gatheringhas been solved in non - rigid asynch , without using colored lights ( see  @xcite ) .",
    "the special case with only two robots is also called rendezvous , and it is easily seen to be solvable in non - rigid fsynchbut unsolvable in rigid ssynch , if colored lights are not used ( see  @xcite ) .",
    "[ r14 ] if only one color is available , rendezvousis solvable in non - rigid fsynchand unsolvable in rigid ssynch .    in non - rigid fsynch ,",
    "consider the algorithm that makes each robot move to the midpoint of the current robots positions . at each move",
    ", the distance between the two robots is reduced by at least @xmath5 , until it becomes less than @xmath5 , and the robots gather .",
    "suppose that an algorithm exists that solves rendezvousin rigid ssynchby using just one color .",
    "let us assume that the two robots axes are oriented symmetrically , in opposite directions .",
    "this implies that , if we activate both robots at each cycle , they obtain isometric snapshots , and thus they make moves that are symmetric with respect to their current midpoint .",
    "therefore , by doing so , the robots can never meet unless they compute the midpoint .",
    "if they do it , we just activate one robot for that cycle ( and each time this happens , we pick a different robot , alternating ) . as a result ,",
    "the robots never meet , regardless of the algorithm .    however , in  @xcite it was shown how rendezvouscan be solved even in non - rigid asynchusing lights of four different colors , and starting from a preset configuration of colors .",
    "optimizing the amount of colors was left as an open problem .      in this paper",
    ", we will determine the minimum number of colors required to solve rendezvousin all models shown in figure  [ f0 ] , with some restrictions on the class of available algorithms .",
    "recall that robots do not necessarily share a global coordinate system , but each robot has its own .",
    "if the coordinate system of a robot is not even self - consistent ( i.e. , it can unpredictably change from one cycle to another ) , then the only reliable reference for each robot is the position of the other robot(s ) around it . in this case , the only type of move that is consistent will all possible coordinate systems is moving to a linear combination of the robots positions , whose coefficients may depend on the colored lights . in particular , when the robots are only two , we assume that each robot may only compute a destination point of the form @xmath6 for some @xmath7 . in turns , @xmath8 is a function of @xmath9 and @xmath10 only . this class of algorithms will be denoted by @xmath11 .    in section  [ s2 ] , we will prove that two colors are sufficient to solve rendezvousin non - rigid ssynchwith arbitrary initial configuration and in rigid asynchwith preset initial configuration , whereas three colors are sufficient in non - rigid asynchwith arbitrary initial configuration .",
    "all the algorithms presented are of class @xmath11 .    on the other hand , in section  [ s3 ] we show that even termination detection can be achieved in non - rigid asynchwith arbitrary initial configuration using only three colors , although our algorithm is not of class @xmath11 ( indeed , no algorithm of class @xmath11 can detect termination in rendezvous ) .",
    "in contrast , in section  [ s4 ] we prove that no algorithm of class @xmath11 using only two colors can solve rendezvousin rigid asynchwith arbitrary initial configuration or in non - rigid asynchwith preset initial configuration .",
    "finally , in section  [ s5 ] we put all these results together and we conclude with a complete characterization of the minimum amount of colors that are needed to solve rendezvousin every model ( see theorem  [ r20 ] ) .",
    "for non - rigid ssynch , we propose algorithm  [ alg1 ] , also represented in figure  [ f1 ] .",
    "labels on arrows indicate the color that is seen on the other robot , and the destination of the next movewith respect to the position of the other robot . ``",
    "0 '' stands for `` do not move '' , `` '' means `` move to the midpoint '' , and `` 1 '' means `` move to the other robot '' .",
    "the colors used are only two , namely @xmath12 and @xmath13 .",
    "[ alg1 ]    @xmath14    [ r3 ] if the two robots start a cycle with their lights set to opposite colors , they eventually gather .",
    "both robots retain their colors at every cycle , and the @xmath12-robot keeps computing the other robot s location , while the @xmath13-robot keeps waiting .",
    "hence , their distance decreases by at least @xmath3 for every cycle in which the @xmath12-robot is active , until the distance becomes smaller than @xmath3 , and the robots gather .",
    "[ r1 ] algorithm  [ alg1 ] solves rendezvousin non - rigid ssynch , regardless of the colors in the initial configuration .",
    "if the robots start in opposite colors , they gather by lemma  [ r3 ] .",
    "if they start in the same color , they keep alternating colors until one robot is active and one is not .",
    "if this happens , they gather by lemma  [ r3 ] .",
    "otherwise , the two robots are either both active or both inactive at each cycle , and they keep computing the midpoint every other active cycle .",
    "their distance decreases by at least @xmath5 each time they move , until it becomes smaller than @xmath5 , and they finally gather .",
    "we prove that algorithm  [ alg1 ] solves rendezvousin rigid asynchas well , provided that the initial color is @xmath12 for both robots .",
    "[ r4 ] if , at some time @xmath15 , the two robots have opposite colors and neither of them is in a computephase that will change its color , they will eventually solve rendezvous .",
    "each robot retains its color at every cycle after time @xmath15 , because it keeps seeing the other robot in the opposite color at every lookphase .",
    "as soon as the @xmath12-robot performs its first lookafter time @xmath15 , it starts chasing the other robot . on the other hand ,",
    "as soon as the @xmath13-robot performs its first lookafter time @xmath15 , it stops forever .",
    "eventually , the two robots will gather and never move again .",
    "[ r2 ] algorithm  [ alg1 ] solves rendezvousin rigid asynch , provided that both robots start with their lights set to @xmath12 .",
    "let @xmath16 be the first robot to perform a look .",
    "then @xmath16 sees the other robot @xmath17 set to @xmath12 , and hence it turns @xmath13 and computes the midpoint @xmath18 .",
    "then , as long as @xmath17 does not perform its first look , @xmath16 stays @xmath13 because it keeps seeing @xmath17 set to @xmath12 .",
    "hence , if @xmath17 performs its first lookafter @xmath16 has turned @xmath13 , lemma  [ r4]applies , and the robots will solve rendezvous .    on the other hand , if @xmath17 performs its first lookwhen @xmath16 is still set to @xmath12 ( hence still in its starting location ) , @xmath17 will turn @xmath13 and compute the midpoint @xmath18 , as well . if some robot reaches @xmath18 and performs a lookwhile the other robot is still set to @xmath12 , the first robot waits until the other turns @xmath13 . without loss of generality ,",
    "let @xmath16 be the first robot to perform a lookwhile the other robot is set to @xmath13 .",
    "this must happen when @xmath16 is in @xmath18 and set to @xmath13 , hence it will turn @xmath12 and stay in @xmath18 . if @xmath16 turns @xmath12 before @xmath17 has reached @xmath18 , then lemma  [ r4]applies .",
    "otherwise , @xmath16 turns @xmath12 when @xmath17 is already in @xmath18 , and both robots will stay in @xmath18 forever , as they will see the other robot in @xmath18 at every look .      for non - rigid asynch , we propose algorithm  [ alg3 ] , also represented in figure  [ f3 ] .",
    "the colors used are three , namely @xmath12 , @xmath13 , and @xmath19 .",
    "[ alg3 ]    @xmath14    [ r26 ] a robot retains its color if and only if it sees the other robot set to a different color .",
    "if , at some time @xmath15 , the two robots are set to different colors , and neither of them is in a computephase that will change its color , they will eventually solve rendezvous .",
    "the two robots keep seeing each other set to different colors , and hence they never change color , by observation  [ r26 ] .",
    "one of the two robots will eventually stay still , and the other robot will then approach it by at least @xmath3 at every movephase , until their distance is less than @xmath3 , and they gather . as soon as they have gathered",
    ", they will stay in place forever .",
    "[ r24 ] algorithm  [ alg3 ] solves rendezvousin non - rigid asynch , regardless of the colors in the initial configuration .",
    "if the robots start the execution at different colors , they solve rendezvousby lemma  [ r25 ] .",
    "if they both start in @xmath12 , then let @xmath16 be the first robot to perform a look .",
    "@xmath16 plans to turn @xmath13 and move to the midpoint .",
    "if it turns @xmath13 before the other robot @xmath17 has performed a look , then lemma  [ r25]applies .",
    "otherwise , @xmath17 plans to turn @xmath13 and move to the midpoint , as well .",
    "if a robot stops and sees the other robot still set to @xmath12 , it waits . without loss of generality ,",
    "let @xmath16 be the first robot to perform a lookand see the other robot set to @xmath13 .",
    "@xmath16 now plans to turn @xmath19 , but if it does so before @xmath17 has performed a look , lemma  [ r25]applies .",
    "so , let us assume that both robots have seen each other in @xmath13 and they both plan to turn @xmath19 . once again",
    ", if a robot turns @xmath19 and sees the other robot still in @xmath13 , it waits . without loss of generality ,",
    "let @xmath16 be the first robot to see the other robot in @xmath19 .",
    "@xmath16 plans to turn @xmath12 , but if it does so before @xmath17 has performed a look , lemma  [ r25]applies .",
    "assume that both robots see each other in @xmath19 and they both plan to turn @xmath12 .",
    "if a robot turns @xmath12 and sees the other robot still in @xmath19 , it waits . at some point , both robots are in @xmath12 again , in a waitphase , but they have approached each other .",
    "they both moved toward the midpoint in their first cycle , and then they just made null moves .",
    "as a consequence , if their distance was smaller than @xmath5 , they have gathered . otherwise , the distance has decreased by at least @xmath5 . as the execution goes on and the same pattern of transitions repeats , the distance keeps decreasing until the robots gather .",
    "as soon as they have gathered , they never move again , hence rendezvousis solved .    the cases in which the robots start both in @xmath13 or both in @xmath19 are resolved with the same reasoning .",
    "note that all the states with both robots set to the same color and in a waitphase have been reached in the analysis above .",
    "suppose we wanted our robots to acknowledge that they have gathered , in order to turn off , or `` switch gears '' and start performing a new task .    if the model is ssynch , termination detection is trivially obtained by checking at each cycle if the robots locations coincide .",
    "unfortunately , in asynch , correct termination detection is harder to obtain .",
    "observe that both algorithm  [ alg1 ] ( for rigid asynch ) and algorithm  [ alg3 ] ( for non - rigid asynch ) fail to guarantee termination detection . indeed , suppose that robot @xmath16 is set to @xmath12 and sees the other robot @xmath17 set to @xmath13 , and that the two robots coincide .",
    "then @xmath16 can not tell if @xmath17 is still moving or not . if @xmath17 is not moving , it is safe for @xmath16 to terminate , but if @xmath17 is moving , then @xmath16 has still to `` chase '' @xmath17 , and can not terminate yet .    to guarantee correct termination detection in non - rigid asynch , we propose algorithm  [ alg2 ] , also represented in figure  [ f2 ] .",
    "note that different rules may apply depending on the distance between the two robots , indicated by @xmath20 in the picture .",
    "however , robots need only distinguish between zero and non - zero distances .",
    "the colors used are again three , namely @xmath12 , @xmath13 , and @xmath19 .    [ alg2 ]    @xmath14    [ r7 ] no robot can move while it is set to @xmath19 .",
    "[ r6 ] if some robot ever turns @xmath19 from a different color , the two robots will gather and their execution will terminate correctly .",
    "a robot can turn @xmath19 only if it performs a lookwhile the other robot is in the same location .",
    "if robot @xmath16 performs a lookat time @xmath15 that makes it turn @xmath19 , then @xmath16 stays @xmath19 forever after , unless it sees the other robot @xmath17 set to @xmath19 as well , in a different location .",
    "let @xmath21 be the first time this happens .",
    "due to observation  [ r7 ] , @xmath16 does not move between @xmath15 and @xmath22 . on the other hand ,",
    "@xmath17 coincides with @xmath16 at time @xmath15 .",
    "then @xmath17 must turn some other color and move away from @xmath16 , and then turn @xmath19 at some time @xmath23 such that @xmath24 .",
    "but , in order to turn @xmath19 , @xmath17 would have to coincide with @xmath16 , which is a contradiction .",
    "hence @xmath16 will stay @xmath19 and never move after time @xmath15 .",
    "as soon as @xmath17 sees @xmath16 set to @xmath19 , it starts moving toward it ( after turning @xmath12 , if @xmath17 is also set to @xmath19 and not coincident with @xmath16 ) , covering at least @xmath3 at each movephase , until their distance becomes less than @xmath3 and @xmath17 finally reaches @xmath16 .",
    "then @xmath17 will turn @xmath19 as well , and both robots will terminate correctly after seeing each other again .",
    "[ r5 ] if , at some time @xmath15 , the two robots are set to @xmath12 and @xmath13 respectively , and neither of them is in a computephase that will change its color , they will eventually gather and terminate correctly .    if some robot ever turns @xmath19 after time @xmath15 , gathering and termination are ensured by lemma  [ r6 ] . otherwise , the two robots keep seeing each other set to opposite colors , and hence they never change color .",
    "the @xmath13-robot will eventually stay still , and the @xmath12-robot will then approach it by at least @xmath3 at every movephase , until their distance is less than @xmath3 , and they gather .",
    "the @xmath13-robot then turns @xmath19 , and lemma  [ r6]applies again .",
    "let @xmath25 denote the position of robot @xmath16 at time @xmath26 .",
    "[ r8 ] let @xmath15 be a time instant at which both robots are set to @xmath12 , and neither of them is in a computephase .",
    "let us assume that robot @xmath16 will stay still until the end of its current phase ( even if it is a movephase ) , and that robot @xmath17 will either stay still until the end of its current phase , or its destination point is @xmath16 s current location .",
    "then @xmath16 and @xmath17 will eventually gather and terminate correctly .",
    "if @xmath17 is not directed toward @xmath16 at time @xmath15 , let @xmath20 be the distance between @xmath25 and @xmath27 .",
    "otherwise , let @xmath22 be the time at which @xmath17 performed its last look , and let @xmath20 be the distance between @xmath28 and @xmath25 .",
    "furthermore , let @xmath29 .",
    "we will prove our claim by well - founded induction on @xmath30 , so let us assume our claim to hold for every @xmath31 such that @xmath32 .    the first robot to perform a lookafter time @xmath15 sees the other robot set to @xmath12 .",
    "if they coincide ( i.e. , if @xmath17 has reached @xmath16 or if @xmath33 ) , the first robot turns @xmath19 , and lemma  [ r6]applies .",
    "if they do not coincide , the first robot turns @xmath13 .",
    "if it turns @xmath13 before the other robot has performed a look , then lemma  [ r5]applies .",
    "otherwise , when the second robot performs its first lookafter time @xmath15 , it sees the first robot still set to @xmath12 . once again , if they coincide , the second robot turns @xmath19 and lemma  [ r6]applies . at this point ,",
    "if @xmath34 and @xmath17 was directed toward @xmath16 at time @xmath15 , the robots have gathered and terminated correctly .",
    "hence , if @xmath16 and @xmath17 perform their first lookat times @xmath35 and @xmath36 respectively , we may assume that both will turn @xmath13 , @xmath16 computes the midpoint @xmath37 of @xmath38 and @xmath39 , and @xmath17 computes the midpoint @xmath40 of @xmath41 and @xmath42 .",
    "observe that , if @xmath17 s destination was not @xmath16 at time @xmath15 , then @xmath43 .    without loss of generality ,",
    "let @xmath16 be the first robot to perform the second look .",
    "@xmath16 sees @xmath17 set to @xmath13 , hence it turns @xmath12 .",
    "if @xmath17 performs the second lookafter @xmath16 has already turned @xmath12 , then @xmath17 necessarily sees @xmath16 in @xmath12 ( because @xmath16 keeps seeing @xmath17 in @xmath13 ) , and lemma  [ r5]applies .    otherwise , both robots see each other in @xmath13 , and both eventually turn @xmath12 . without loss of generality ,",
    "let @xmath17 be the first robot to perform the third look .",
    "if @xmath34 and @xmath17 was not directed toward @xmath16 at time @xmath15 , the robots have indeed gathered in @xmath43 , so @xmath17 turns @xmath19 and lemma  [ r6]applies .    at this point",
    "we may assume that @xmath44 , hence @xmath45 .",
    "we claim that the distance @xmath46 between @xmath16 and @xmath17 is now at most @xmath47 .",
    "indeed , if @xmath17 was not directed toward @xmath16 at time @xmath15 , then each robot has either reached @xmath43 , or has approached it by at least @xmath3 . in any case , @xmath48 . otherwise ,",
    "if @xmath17 was directed toward @xmath16 at time @xmath15 , then observe that both @xmath37 and @xmath40 lie between @xmath25 and @xmath49 .",
    "moreover , @xmath17 has performed its first lookwhile at distance at most @xmath50 from @xmath25 , and subsequently it has further approached @xmath25 . on the other hand , @xmath16 is found between @xmath25 and @xmath18 , thus at distance not greater than @xmath51 from @xmath25 .",
    "hence , @xmath52 .",
    "now , @xmath17 is the first robot to perform the third look , and sees @xmath16 either already in @xmath12 or still in @xmath13 . in the first case",
    ", the inductive hypothesis applies , because @xmath16 is not in a computephase , and its destination is @xmath16 itself . in the second case",
    ", @xmath17 computes @xmath16 s location , and it keeps doing so until @xmath16 turns @xmath12 .",
    "when this happens , the inductive hypothesis applies again .",
    "[ r10 ] if , at some time @xmath15 , both robots are set to @xmath13 and are both in a waitor in a lookphase , they will eventually gather and terminate correctly .    the reasoning in the proof of lemma  [ r8]also implicitly addresses this case .",
    "indeed , the configuration in which both robots are set to @xmath13 and in a waitor a lookphase is reached during the analysis , and is incidentally resolved , as well .",
    "[ r9 ] algorithm  [ alg2 ] solves rendezvousin non - rigid asynchand terminates correctly , regardless of the colors in the initial configuration .    if both robots start in @xmath12 , lemma  [ r8]applies .",
    "if they both start in @xmath13 , corollary  [ r10]applies .",
    "if one robot starts in @xmath12 and the other one starts in @xmath13 , then lemma  [ r5]applies .",
    "if exactly one robot starts in @xmath19 , it will stay still forever , and the other robot will eventually reach it , turn @xmath19 as well , and both will terminate .    if both robots start in @xmath19 and they are coincident , they will terminate .",
    "if they are not coincident , let @xmath16 be the first robot to perform a look .",
    "@xmath16 will then turn @xmath12 and move toward the other robot @xmath17 .",
    "if @xmath17 performs its first lookwhen @xmath16 has already turned @xmath12 , it will wait , @xmath16 will eventually reach it , turn @xmath19 , and both will terminate .",
    "otherwise , @xmath17 performs its lookwhen @xmath16 is still set to @xmath19 , hence @xmath17 will turn @xmath12 as well , and move toward @xmath16 .    then",
    ", one robot will keep staying @xmath12 and moving toward the other one , until both have turned @xmath12 . without loss of generality ,",
    "let @xmath16 be the first robot to see the other one set to @xmath12 .",
    "if they are coincident , @xmath16 turns @xmath19 and lemma  [ r6]applies .",
    "otherwise , @xmath16 turns @xmath13 .",
    "if this happens before @xmath17 has seen @xmath16 in @xmath12 , then lemma  [ r5]applies .",
    "otherwise , both robots will turn @xmath13 .",
    "as long as only one robot has turned @xmath13 , it stays @xmath13 and does not move . at some point , one robot sees the other in @xmath13 and corollary  [ r10]applies .",
    "observe that algorithms  [ alg1 ] ,  [ alg3 ] and  [ alg2 ] only produce moves of three types : stay still , move to the midpoint , and move to the other robot .",
    "it turns out that , regardless of the number of available colors , any algorithm for rendezvousmust use those three moves under some circumstances .",
    "[ r12 ] for any algorithm solving rendezvousin rigid fsynch , there exist a color @xmath53 and a distance @xmath54 such that any robot set to @xmath53 that sees the other robot at distance @xmath20 and set to @xmath53 moves to the midpoint .",
    "assume both robots start with the same color and in distinct positions .",
    "we may assume that both robots get isometric snapshots at each cycle , so they both turn the same colors , and compute destination points that are symmetric with respect to their midpoint .",
    "if they never compute the midpoint and their execution is rigid and fully synchronous , they never gather .",
    "[ r21 ] for any algorithm solving rendezvousin rigid ssynch , there exist two colors @xmath53 and @xmath55 and a distance @xmath54 such that any robot set to @xmath53 that sees the other robot at distance @xmath20 and set to @xmath55 moves to the other robot s position .",
    "we activate one robot on even cycles , and the other robot on odd cycles .",
    "if no robot ever computes the other robot s position and they perform rigid movements , they never gather .",
    "[ r22 ] for any algorithm solving rendezvousin rigid ssynch , there exist two colors @xmath53 and @xmath55 and a distance @xmath54 such that any robot set to @xmath53 that sees the other robot at distance @xmath20 and set to @xmath55 does not move .",
    "we keep activating only one robot at each cycle ( alternately ) , except when one robot computes the other robot s position .",
    "whenever this happens , we activate both robots for that cycle .",
    "if no robot ever performs a null move , they never gather .",
    "the above observations partly justify the choice to restrict our attention to a specific class of algorithms : from now on , every algorithm we consider computes only destinations of the form @xmath56 where the parameter @xmath7 depends only on @xmath9 and @xmath10 .",
    "similarly , a robot s next light color depends only on the current colors of the two robots lights , and not on their distance . recall from section  [ s1 ] that this class of algorithms is denoted by @xmath11 .",
    "notice that algorithms  [ alg1 ] and  [ alg3 ] both belong to @xmath11 , but algorithm  [ alg2 ] does not , because it may output a different color depending if the two robots coincide or not .    a statement of the form @xmath57 is shorthand for `` if a robot is set to @xmath53 and sees the other robot set to @xmath55 , it turns @xmath58 and makes a move with parameter @xmath8 '' , where @xmath59 and @xmath7 .",
    "the negation of @xmath57 will be written as @xmath60 , where s a transition with an unspecified move parameter will be denoted by @xmath61 .      here",
    "we assume that the model is rigid asynch , that only two colors are available , namely @xmath12 and @xmath13 , and that the initial configuration is with both robots set to @xmath12 .",
    "all our impossibility results for this very special model are then applicable to both non - rigid asynchwith preset initial configuration and rigid asynchwith arbitrary initial configuration .",
    "so , let an algorithm that solves rendezvousin this model be given .",
    "if the algorithm belongs to class @xmath11 , then the following statements hold .",
    "[ r13 ] @xmath62 .",
    "if the execution starts with both robots in @xmath12 , and @xmath63 , then no robot ever transitions to @xmath13 , and rendezvousis not solvable , due to proposition  [ r14 ] .",
    "[ r16 ] if @xmath64 , then @xmath65 .",
    "let us assume by contradiction that @xmath66 .",
    "if @xmath67 with @xmath68 , we let the two robots execute two cycles each , alternately . as a result , each robot keeps seeing the other robot in @xmath12 , and their distance is multiplied by @xmath69 at every turn . hence the robots never gather .",
    "if @xmath70 , we let robot @xmath16 perform a whole cycle and the lookand computephases of the next cycle , while the other robot @xmath17 waits . at this point ,",
    "their distance has halved , @xmath16 is set to @xmath12 , and is about to move to @xmath17 s position .",
    "now @xmath17 performs two whole cycles , reaching @xmath16 s position with its light set to @xmath12 .",
    "finally , we let @xmath16 finish its cycle . as a result ,",
    "the distance between the two robots has halved , both robots have performed at least a cycle , they are in a waitphase , and they are both set to @xmath12 . hence , by repeating the same pattern of moves , they never gather .",
    "[ r19 ] if @xmath64 and @xmath71 , then @xmath72 .",
    "assume by contradiction that @xmath64 and @xmath73 with @xmath74 .",
    "we let both robots perform a lookand a computephase simultaneously . both turn @xmath13 and compute the midpoint @xmath18 .",
    "then we let robot @xmath16 finish the current cycle and perform a new look . as a result",
    ", @xmath16 will turn @xmath12 and will move away from @xmath18 .",
    "now let the other robot @xmath17 finish its first cycle and perform a whole new cycle .",
    "@xmath17 reaches @xmath18 , sees @xmath16 still set to @xmath13 and still in @xmath18 , hence @xmath17 turns @xmath12 and stays in @xmath18 . finally , we let @xmath16 finish the current cycle . at this point ,",
    "both robots are set to @xmath12 , they are in a waitphase , both have performed at least one cycle , and their distance has been multiplied by @xmath75 . therefore , by repeating the same pattern of moves , they never gather .",
    "[ r17 ] if @xmath64 and @xmath72 , then @xmath76 .    by lemma  [ r16 ] , @xmath65 .",
    "assume by contradiction that @xmath77 with @xmath74 .",
    "we let both robots perform a looksimultaneously , so both plan to turn @xmath13 and move to the midpoint @xmath18 .",
    "we let robot @xmath16 finish the cycle , while the other robot @xmath17 waits",
    ". then we let @xmath16 perform a whole other cycle .",
    "so @xmath16 sees @xmath17 still in @xmath12 , and moves away from @xmath18 , while staying @xmath13 .",
    "now we let @xmath17 finish its first cycle and move to @xmath18 . finally , we let both robots perform a new cycle simultaneously . as a result ,",
    "both robots are set to @xmath12 and are in a waitphase , both have performed at least one cycle , and their distance has been multiplied by @xmath75 . by repeating the same pattern of moves , they never gather .",
    "[ r18 ] if @xmath64 and @xmath72 , then @xmath78 .",
    "let us first assume that @xmath79 with @xmath68 .",
    "we let one robot perform a whole cycle , thus turning @xmath13 and moving to the midpoint",
    ". then we let the other robot perform a cycle , at the end of which both robots are set to @xmath13 . finally , we let both robots perform a cycle simultaneously , after which they are back to @xmath12 and in a waitphase . because their distance has been multiplied by @xmath69 , by repeating the same pattern of moves they never gather .",
    "assume now that @xmath80 .",
    "we let robot @xmath16 perform a lookand a computephase , thus turning @xmath13 and computing the midpoint .",
    "now we let the other robot @xmath17 perform a whole cycle , at the end of which it is set to @xmath13 and has reached @xmath16 .",
    "then we let @xmath16 finish its cycle , moving away from @xmath17 .",
    "finally , we let both robots perform a new cycle simultaneously , which takes them back to @xmath12 . their distance has now halved , and by repeating the same pattern of moves they never gather .",
    "assume that @xmath81 , and let robot @xmath16 perform an entire cycle , thus turning @xmath13 and moving to the midpoint . due to lemma  [ r17 ] , @xmath76 , which means that , from now on , both robots will retain colors .",
    "hence , @xmath16 will always stay still , and @xmath17 will never reach @xmath16 unless @xmath78 .",
    "[ r23 ] algorithm  [ alg1 ] does not solve rendezvousin rigid asynch , if both robots are set to @xmath13 in the initial configuration .",
    "let both robots perform a lookphase , so that both will turn @xmath12 .",
    "we let robot @xmath16 finish the current cycle and perform a new look , while the other robot @xmath17 waits . hence , @xmath16 will stay @xmath12 and move to @xmath17 s position .",
    "now we let @xmath17 finish the current cycle and perform a new look .",
    "so @xmath17 will turn @xmath13 and move to the midpoint @xmath18 .",
    "we let @xmath16 finish the current cycle , thus reaching @xmath17 , and perform a whole new cycle , thus turning @xmath13 . finally , we let @xmath17 finish the current cycle , thus turning @xmath13 and moving to @xmath18 . as a result ,",
    "both robots are again set to @xmath13 , they are in a waitphase , both have executed at least one cycle , and their distance has halved .",
    "thus , by repeating the same pattern of moves , they never gather .",
    "[ r15 ] there is no algorithm of class @xmath11 that solves rendezvoususing two colors in rigid asynchfrom all possible initial configurations .    because robots may start both in @xmath12 or both in @xmath13 , the statement of lemma  [ r13 ] , holds also with @xmath12 and @xmath13 exchanged .",
    "hence @xmath62 , but also @xmath71",
    ". moreover , by proposition  [ r12 ] , either @xmath64 or @xmath82 . by symmetry , we may assume without loss of generality that @xmath64 .",
    "now , by lemma  [ r19 ] , @xmath72 . additionally , by lemma  [ r17]and lemma  [ r18 ] , @xmath76 and @xmath78 .",
    "these rules define exactly algorithm  [ alg1 ] , which is not a solution , due to lemma  [ r23 ] .",
    "[ r11 ] there is no algorithm of class @xmath11 that solves rendezvoususing two colors in non - rigid asynch , even assuming that both robots are set to a predetermined color in the initial configuration .",
    "let both robots be set to @xmath12 in the initial configuration , and let @xmath83 be given . by lemma  [ r13 ] , @xmath84 , for some @xmath85 .",
    "if @xmath86 , we place the two robots at distance @xmath87 from each other , and we let them perform a whole cycle simultaneously . if @xmath88 , we place the robots at distance @xmath89 , and we let them perform a cycle simultaneously , but we stop them as soon as they have moved by @xmath3 . as a result ,",
    "both robots are now set to @xmath13 , and at distance @xmath20 from each other .",
    "this means that any algorithm solving rendezvouswith both robots set to @xmath12 must also solve it with both robots set to @xmath13 , as well .",
    "similarly , we can place the two robots at distance @xmath90 or @xmath91 , depending if @xmath68 or @xmath92 .",
    "then we let only one robot perform a full cycle , and we let it finish or we stop it after @xmath3 , in such a way that it ends up at distance exactly @xmath20 from the other robot .",
    "at this point , one robot is set to @xmath12 and the other is set to @xmath13 .",
    "it follows that any algorithm for rendezvousmust effectively solve it from all possible initial configurations .",
    "but this is impossible , due to theorem  [ r15 ] .",
    "we considered deterministic distributed algorithms for rendezvousfor mobile robots that can not use distance information , but can only reduce ( or increase ) their distance by a constant factor , depending on the color of the lights that both robots are carrying .",
    "we called this class of algorithms @xmath11 .",
    "we gave several upper and lower bounds on the number of different colors that are necessary to solve rendezvousin different robot models .",
    "based on these results , we can now give a complete characterization of the number of necessary colors in every possible model , ranging from fully synchronous to semi - synchronous to asynchronous , rigid and non - rigid , with preset or arbitrary initial configuration .",
    "* one color is sufficient for rigid and non - rigid fsynch ; * two colors are necessary and sufficient for rigid ssynch , non - rigid ssynch , and rigid asynch ; * three colors are necessary and sufficient for non - rigid asynch .",
    "* one color is sufficient for rigid and non - rigid fsynch ; * two colors are necessary and sufficient for rigid and non - rigid ssynch ; * three colors are necessary and sufficient for rigid and non - rigid asynch .          similarly , theorem  [ r2]states that two colors are necessary and sufficient for rigid asynchwith preset initial configuration",
    "on the other hand , by theorem  [ r15]and theorem  [ r11 ] , three colors are necessary in the three remaining models , and by theorem  [ r24]three colors are also sufficient .    in the three models in which three colors are necessary and sufficient , it remains an open problem to determine whether using distance information to its full extent would make it possible to use only two colors .",
    "an interesting variation on this model is when the light on a robot can be seen only by the other robot(s ) . in this case ,",
    "algorithms of class @xmath11 are inadequate to solve rendezvouseven in rigid asynchwith preset initial configuration , regardless of the number of available colors .",
    "in contrast , three colors are necessary and sufficient for all ssynchmodels .    on the other hand ,",
    "if the light is visible only to the robot that is carrying it ( i.e. , internal memory ) , then no algorithm of class @xmath11 can solve rendezvous , even in rigid ssynchwith preset initial configuration , regardless of the number of colors .",
    "s.  das , p.  flocchini , g.  prencipe , n.  santoro , and m.  yamashita .",
    "the power of lights : synchronizing asynchronous robots using visible bits . in _ proceedings of the 32nd international conference on distributed computing systems",
    "_ , pp .  506515 , 2012 ."
  ],
  "abstract_text": [
    "<S> we study the rendezvous problem for two robots moving in the plane ( or on a line ) . </S>",
    "<S> robots are autonomous , anonymous , oblivious , and carry colored lights that are visible to both . </S>",
    "<S> we consider deterministic distributed algorithms in which robots do not use distance information , but try to reduce ( or increase ) their distance by a constant factor , depending on their lights colors .    </S>",
    "<S> we give a complete characterization of the number of colors that are necessary to solve the rendezvous problem in every possible model , ranging from fully synchronous to semi - synchronous to asynchronous , rigid and non - rigid , with preset or arbitrary initial configuration .    </S>",
    "<S> in particular , we show that three colors are sufficient in the non - rigid asynchronous model with arbitrary initial configuration . </S>",
    "<S> in contrast , two colors are insufficient in the rigid asynchronous model with arbitrary initial configuration and in the non - rigid asynchronous model with preset initial configuration .    additionally , </S>",
    "<S> if the robots are able to distinguish between zero and non - zero distances , we show how they can solve rendezvous and detect termination using only three colors , even in the non - rigid asynchronous model with arbitrary initial configuration . </S>"
  ]
}