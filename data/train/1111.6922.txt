{
  "article_text": [
    "[ [ mastermind - at - a - glance . ] ] * _ mastermind at a glance . _",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + +    _ mastermind _ is a code - breaking board game released in 1971 , which sold over 50 million sets in 80 countries .",
    "the israeli postmaster and telecommunication expert mordecai meirowitz is usually credited for inventing it in 1970 , although an almost identical paper - and - pencil game called _ bulls and cows _ predated mastermind , perhaps by more than a century  @xcite .",
    "the classic variation of the game is played between a _",
    "codemaker _ , who chooses a secret sequence of four colored pegs , and a _ codebreaker _ , who tries to guess it in several attempts",
    "there are six available colors , and the secret code may contain repeated colors . after each attempt",
    ", the codebreaker gets a _ rating _ from the codemaker , consisting in the number of correctly placed pegs in the last guess , and the number of pegs that have the correct color but are misplaced .",
    "the rating does not tell which pegs are correct , but only their amount .",
    "these two numbers are communicated by the codemaker as a sequence of smaller black pegs and white pegs , respectively ( see , where the secret code is concealed behind a shield , and each guess is paired with its rating ) .",
    "if the codebreaker s last guess was wrong , he guesses again , and the game repeats until the secret code is found , or the codebreaker reaches his limit of ten trials . ideally , the codebreaker plans his new guesses according to the information he collected from the previous guesses . depicts a complete game of mastermind , where colors are encoded as numbers between zero and five , and the codebreaker finally guesses the code at his sixth attempt .",
    "guess & rating + & @xmath2 + & @xmath3@xmath2 + & @xmath3@xmath2 + & @xmath2 + & @xmath3@xmath2@xmath2@xmath2 + & @xmath3@xmath3@xmath3@xmath3 +    [ tab:1 ]    [ [ previous - work . ] ] * _ previous work .",
    "_ * + + + + + + + + + + + + + + + + + +    recently , focardi and luccio pointed out the unexpected relevance of mastermind in real - life security issues , by showing how certain api - level bank frauds , aimed at disclosing user pins , can be interpreted as an extended mastermind game played between an insider and the bank s computers  @xcite . on the other hand ,",
    "goodrich suggested some applications to genetics of the mastermind variation in which scores consist of black pegs only , called _ single - count ( black peg ) mastermind _  @xcite .    as a further generalization of the original game , we may consider _",
    "@xmath4-mastermind _ , where the secret sequence consists of @xmath5 pegs , and there are @xmath6 available colors .",
    "chvtal proved that the codebreaker can always determine the secret code in @xmath4-mastermind after at most @xmath7 guesses , each computable in polynomial time , via a simple divide - and - conquer strategy  @xcite .",
    "this upper bound was later lowered by a constant factor in  @xcite , while goodrich also claimed to be able to lower it for single - count ( black peg ) mastermind , hence using even less information  @xcite .",
    "unfortunately , after a careful inspection , goodrich s method turns out to outperform chvtal s several techniques given in  @xcite asymptotically ( as @xmath5 grows , and @xmath6 is a function of @xmath5 ) only if @xmath8 , for every @xmath9 .",
    "however , despite being able to guess any secret code with an efficient strategy , the codebreaker may insist on really minimizing the number of trials , either in the worst case or on average .",
    "knuth proposed a heuristic that exhaustively searches through all possible guesses and ratings , and greedily picks a guess that will minimize the number of eligible solutions , in the worst case  @xcite .",
    "this is practical and worst - case optimal for standard @xmath10-mastermind , but infeasible and suboptimal for even slightly bigger instances .",
    "the size of the solution space is employed as an ideal quality indicator also in other heuristics , most notably those based on genetic algorithms  @xcite .    in order to approach the emerging complexity theoretic issues , stuckman and zhang introduced the mastermind satisfiability problem ( msp ) for @xmath4-mastermind , namely the problem of deciding if a given sequence of guesses and ratings has indeed a solution , and proved its -completeness  @xcite .",
    "similarly , goodrich showed that also the analogous satisfiability problem for single - count ( black peg ) mastermind is -complete  @xcite .",
    "interestingly , stuckman and zhang observed that the problem of detecting msp  instances with a unique solution is turing - reducible to the problem of producing an eligible solution .",
    "however , the determination of the exact complexity of the first problem is left open  @xcite .",
    "[ [ our - contribution . ] ] * _ our contribution . _",
    "* + + + + + + + + + + + + + + + + + + + + +    in this paper we study # msp , the _ counting problem _ associated with msp , i.e. , the problem of computing the number of solutions that are compatible with a given set of guesses and ratings .",
    "we do this for standard @xmath4-mastermind , as well as its single - count variation with only black peg ratings , and the analogous single - count variation with only white peg ratings , both in general and restricted to instances with a fixed number of colors @xmath6 .",
    "our main theorem states that , in all the aforementioned variations of mastermind , # msp  is either trivially polynomial or -complete under _ parsimonious reductions_. capturing the true complexity of # msp  is an improvement on previous results ( refer to  @xcite ) because :    * evaluating the size of the search space is a natural and recurring subproblem in several heuristics , whereas merely deciding if a set of guesses has a solution seems a more fictitious problem , especially because in a real game of mastermind we already know that our previous guesses and ratings _ do _ have a solution . *",
    "the reductions we give are parsimonious , hence they yield stronger versions of all the previously known -completeness proofs for msp  and its variations . moreover , we obtain the same hardness results even for @xmath11-mastermind , whereas all the previous reductions used unboundedly many colors ( see ) . *",
    "our main theorem enables simple proofs of a wealth of complexity - related corollaries , including the hardness of detecting unique solutions , which was left open in  @xcite ( see ) .",
    "[ [ paper - structure . ] ] * _ paper structure . _ * + + + + + + + + + + + + + + + + + + + +    in we define # msp  and its variations .",
    "contains a statement and proof of our main result , , and an example of reduction . in",
    "we apply to several promise problems with different assumptions on the search space , and finally in we suggest some directions for further research .",
    "[ [ codes - and - ratings . ] ] * _ codes and ratings . _ * + + + + + + + + + + + + + + + + + + + + + +    for @xmath4-mastermind , let the set @xmath12 be the _ code space _ , whose elements are _ codes _ of @xmath5 numbers ranging from @xmath13 to @xmath14 . following chvtal , we define two _ metrics _ on the code space  @xcite .",
    "if @xmath15 and @xmath16 are two codes , let @xmath17 be the number of subscripts @xmath18 with @xmath19 , and let @xmath20 be the largest @xmath21 , with @xmath22 running through all the permutations of @xmath23 . as observed in  @xcite , @xmath24 and @xmath25 are indeed distance functions , respectively on @xmath12 and @xmath26 ( i.e. , the code space where codes are equivalent up to reordering of their elements )",
    ".    given a secret code @xmath27 chosen by the codemaker , we define the _ rating _ of a guess @xmath28 , for all the three variants of mastermind we want to model .    * for standard mastermind , let @xmath29 . * for single - count black peg mastermind ,",
    "let @xmath30 . * for single - count white peg mastermind ,",
    "let @xmath31 .",
    "a guess is considered correct in single - count white peg @xmath4-mastermind whenever its rating is @xmath5 , therefore the secret code has to be guessed only up to reordering of the numbers . as a consequence , the codebreaker can always guess the code after @xmath14 attempts : he can determine the number of pegs of each color via monochromatic guesses , although this is not an optimal strategy when @xmath6 outgrows @xmath5 .",
    "on the other hand , order does matter in both other variants of mastermind , where the guess has to coincide with the secret code for the codebreaker to win .",
    "[ [ satisfiability - problems . ] ] * _ satisfiability problems . _",
    "* + + + + + + + + + + + + + + + + + + + + + + + + + + + +    next we define the mastermind satisfiability problem for all three variants of mastermind .",
    "msp  ( respectively , msp - black , msp - white ) .",
    "+ _ input : _ @xmath32 , where @xmath33 is a finite set of queries of the form @xmath34 , where @xmath28 and @xmath35 is a rating .",
    "+ _ output : _",
    "yes if there exists a code @xmath36 such that @xmath37 ( respectively , @xmath38 , @xmath39 ) for all @xmath40 .",
    "no otherwise .",
    "msp  and msp - black  are known to be -complete problems  @xcite .",
    "we shall see in how msp - white  is -complete , as well .",
    "further , we may want to restrict our attention to instances of mastermind with a fixed number of colors .",
    "thus , for every constant @xmath6 , let @xmath41-msp  be the restriction of msp  to problem instances with exactly @xmath6 colors ( i.e. , whose input is of the form @xmath42 ) .",
    "similarly , we define @xmath41-msp - black  and @xmath41-msp - white .",
    "[ [ counting - problems . ] ] * _ counting problems . _",
    "* + + + + + + + + + + + + + + + + + + + + + +    all the above problems are clearly in , thus it makes sense to consider their _ counting versions _ , namely # msp , # msp - black , # @xmath41-msp , and so on , which are all  problems  @xcite .",
    "basically , these problems ask for the size of the solution space after a number of guesses and ratings , i.e. , the number of codes that are coherent with all the guesses and ratings given as input .",
    "recall that reductions among  problems that are based on oracles are called _ turing reductions _ and are denoted with @xmath43 , while the more specific reductions that map problem instances preserving the number of solutions are called _ parsimonious reductions _ , and are denoted with @xmath44 .",
    "each type of reduction naturally leads to a different notion of -completeness : for instance , # @xmath45-sat  is -complete under turing reductions , while # @xmath46-sat  is -complete under parsimonious reductions  @xcite .",
    "problems that are -complete under parsimonious reductions are _ a fortiori _ -complete , while it is unknown whether all -complete problems are -complete , even under turing reductions  @xcite .",
    "next we give a complete classification of the complexities of all the counting problems introduced in .",
    "[ thm : main ]    1 .",
    "[ thm : maina ] # msp , # msp - black  and # msp - white  are -complete under parsimonious reductions .",
    "[ thm : mainb ] # @xmath41-msp  and # @xmath41-msp - black  are -complete under parsimonious reductions for every @xmath47 .",
    "[ thm : mainc ] # @xmath41-msp - white  is solvable in deterministic polynomial time for every @xmath48 .",
    "( notice that # @xmath49-msp  and # @xmath49-msp - black  are trivially solvable in deterministic linear time . )    [ l1 ] for every @xmath48 , # @xmath41-msp - white  is solvable in deterministic polynomial time .",
    "in @xmath26 there are only @xmath50 possible codes to check against all the given queries , hence the whole process can be carried out in polynomial time , for any constant @xmath6 .",
    "[ l2 ] for every @xmath48 , +    # @xmath41-msp  @xmath44 # @xmath51-msp ,    # @xmath41-msp - black  @xmath44 # @xmath51-msp - black .    given the instance @xmath32 of # @xmath41-msp  ( respectively , # @xmath41-msp - black ) , we convert it into @xmath52 , where @xmath53 is a sequence of @xmath5 consecutive @xmath6 s , and @xmath54 ( respectively , @xmath55 ) .",
    "the new query @xmath34 implies that the new color @xmath6 does not occur in the secret code , hence the number of solutions is preserved and the reduction is indeed parsimonious .",
    "[ l3 ] # @xmath46-sat  @xmath44 # msp - white .    given a 3-cnf boolean formula @xmath56 with @xmath57 variables and @xmath58 clauses , we map it into an instance of msp - white  @xmath32 . for each clause @xmath59 of @xmath56",
    ", we add three fresh _ auxiliary variables _",
    "@xmath60 , @xmath61 , @xmath62 . for each variable @xmath63 ( including auxiliary variables ) , we define two colors @xmath63 and @xmath64 , representing the two possible truth assignments for @xmath63 .",
    "we further add the _ mask color _",
    "@xmath65 , thus getting @xmath66 colors in total .",
    "we let @xmath67 ( we may safely assume that @xmath68 ) , and we construct @xmath33 as follows .    1 .   [ l3s1 ]",
    "add the query @xmath69 .",
    "[ l3s2 ] for each variable @xmath63 , add the query @xmath70 .",
    "3 .   [ l3s3 ] for each clause @xmath71 ( where each literal may be positive or negative ) , add the query @xmath72 .",
    "[ l3s4 ] for each clause @xmath59 , further add the query @xmath73 .    by  , the mask color does not occur in the secret code ; by  , each variable occurs in the secret code exactly once , either as a positive or a negative literal .",
    "moreover , by  , at least one literal from each clause must appear in the secret code .",
    "depending on the exact number of literals from @xmath59 that appear in the code ( either one , two or three ) , the queries in   and   always force the values of the auxiliary variables @xmath60 , @xmath61 and @xmath62 .",
    "( notice that , without  , there would be two choices for @xmath60 and @xmath61 , in case exactly two literals of @xmath59 appeared in the code . ) as a consequence , the reduction is indeed parsimonious .",
    "[ l4 ] # @xmath46-sat  @xmath44 # @xmath74-msp - black .",
    "we proceed along the lines of the proof of , with similar notation .",
    "we add the same auxiliary variables @xmath60 , @xmath61 , @xmath62 for each clause @xmath59 , and we construct the instance of @xmath74-msp - black  @xmath75 , where @xmath67 .",
    "this time we encode literals as _ positions _ in the code : for each variable @xmath63 , we allocate two specific positions @xmath63 and @xmath64 , so that @xmath76 ( respectively , @xmath77 ) in code @xmath78 if and only if variable @xmath63 is assigned the value true ( respectively , false ) . notice that , in contrast with , we are not using a mask color here .",
    "@xmath33 is constructed as follows .    1 .   [ l4s1 ]",
    "add the query @xmath79 .",
    "[ l4s2 ] for each variable @xmath63 , add the query @xmath80 , where @xmath81 if and only if @xmath82 .",
    "[ l4s3 ] for each clause @xmath71 , add the query @xmath83 , where @xmath81 if and only if @xmath84 .",
    "( without loss of generality , we may assume that @xmath85 , @xmath86 and @xmath87 are occurrences of three mutually distinct variables  @xcite . )",
    "[ l4s4 ] for each clause @xmath59 , further add the query @xmath83 , where @xmath81 if and only if @xmath88 .    by  , every solution must contain @xmath5 times @xmath13 and @xmath5 times @xmath89 , in some order .",
    "the semantics of  , and   is the same as that of the corresponding steps in , hence our construction yields the desired parsimonious reduction . indeed , observe that , if altering @xmath0 bits of a binary code increases its rating by @xmath35 , then exactly @xmath90 of those @xmath0 bits are set to the right value . in  , altering @xmath91 bits of the code in   increases its rating by @xmath55 , hence exactly one of those bits has the right value , which means that @xmath92 in any solution @xmath93 .",
    "similarly , in   ( respectively ,  ) , @xmath94 ( respectively , @xmath95 ) and @xmath96 , hence exactly three ( respectively , two ) of the bits set to @xmath89 are correct ( cf .  the ratings in ) .    [ l5 ] # @xmath46-sat  @xmath44 # @xmath74-msp .",
    "we replicate the construction given in the proof of , but we use the proper ratings : recall that the ratings of msp  are pairs of scores ( black pegs and white pegs ) . the first score ( black pegs )",
    "has the same meaning as in msp - black , and we maintain these scores unchanged from the previous construction . by doing so ,",
    "we already get the desired set of solutions , hence we merely have to show how to fill out the remaining scores ( white pegs ) without losing solutions .    referring to the proof of , we change the rating in   from @xmath5 to @xmath97 , because every @xmath13 in the guess is either correct at the correct place , or redundant .",
    "the rating in   is changed from @xmath5 to @xmath11 .",
    "indeed , let @xmath23 be any other variable ( distinct from @xmath63 ) , so that @xmath98",
    ". then , exactly one between @xmath99 and @xmath100 is a misplaced @xmath13 , which can be switched with the misplaced @xmath89 from either @xmath101 or @xmath102 .",
    "all the other @xmath13 s in @xmath53 are either correct at the correct place , or redundant .    similarly , the rating in   ( respectively ,  ) changes from @xmath103 to @xmath104 ( respectively , @xmath105 ) . indeed , exactly two ( respectively , one ) @xmath89 s are in a wrong position in @xmath53 .",
    "if either @xmath76 or @xmath77 is wrong , then both @xmath101 and @xmath102 are wrong and of opposite colors , hence they can be switched .",
    "once again , all the other @xmath13 s in @xmath53 are either correct at the correct place , or redundant .",
    "all the claims easily follow from , , , , , and the -completeness of # @xmath46-sat  under parsimonious reductions  @xcite .    [ [ example . ] ] * _ example . _ * + + + + + + + + + + + +    as an illustration of , we show how the boolean formula @xmath106 is translated into a set of queries for @xmath74-msp . for visual convenience , @xmath13 s and @xmath89 s are represented as white and black circles , respectively .    [ cols=\"<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,<,^\",options=\"header \" , ]     the solutions to both problems are exactly ten , and are listed below .",
    "we remark that , in order to determine the values of the auxiliary variables @xmath60 , @xmath61 and @xmath62 when a solution to the boolean satisfiability problem is given , it is sufficient to check how many literals of @xmath59 are satisfied .",
    "@xmath60 is true if and only if exactly one literal is satisfied , @xmath61 is false if and only if all three literals are satisfied , and @xmath62 is true if and only if @xmath107 .",
    "we describe some applications of to several complexity problems .    [ cor : npc ] @xmath74-msp ,",
    "@xmath74-msp - black  and msp - white  are -complete .",
    "parsimonious reductions among  problems are _ a fortiori _ karp reductions among the corresponding  problems .",
    "so far , we made no assumptions on the queries in our problem instances , which leads to a more general but somewhat fictitious theory . since in a real game of mastermind the codebreaker",
    "s queries are guaranteed to have at least a solution ( i.e. , the secret code chosen by the codemaker ) , more often than not the codebreaker is in a position to exploit this information to his advantage .",
    "however , we show that such information does not make counting problems substantially easier .",
    "# @xmath74-msp , # @xmath74-msp - black  and # msp - white , with the promise that the number of solutions is at least @xmath0 , are all -complete problems under turing reductions , for every @xmath108 .",
    "let # match  be the problem of counting the matchings of any size in a given graph , which is known to be -complete under turing reductions  @xcite .",
    "let @xmath109 be the problem # @xmath74-msp  ( respectively , # @xmath74-msp - black , # msp - white ) restricted to instances with at least @xmath0 solutions , and let us show that # match  @xmath43 @xmath109 . given a graph @xmath110 , if it has fewer than @xmath0 edges , we can count all the matchings in linear time .",
    "otherwise , there must be at least @xmath0 matchings ( each edge @xmath111 yields at least the matching @xmath112 ) , so we parsimoniously map @xmath110 into an instance of @xmath109 via , we call an oracle for @xmath109 , and output its answer .    the following result , for @xmath1 , settles an issue concerning the determination of msp  instances with unique solution , which was left unsolved in  @xcite .",
    "we actually prove more : even if a solution is given as input , it is hard to determine if it is unique .",
    "therefore , not only solving mastermind puzzles is hard , but _ designing _",
    "puzzles around a solution is also hard .",
    "[ cor : zhang ] for every @xmath108 , the problem of deciding if an instance of @xmath74-msp , @xmath74-msp - black  or msp - white  has strictly more than @xmath0 solutions is -complete , even if @xmath0 solutions are explicitly given as input .",
    "not only do the parsimonious reductions given in preserve the number of solutions , but they actually yield an explicit polynomial - time computable transformation of solutions ( cf .  the remark at the end of ) .",
    "hence , the involved -complete problems are also -complete as function problems , and their decision @xmath0-  counterparts are accordingly -complete  @xcite .",
    "remarkably , even if the codebreaker somehow knows that his previous queries are sufficient to uniquely determine the solution , he still has a hard time finding it .",
    "[ cor : unique ] the promise problem of finding the solution to an instance of @xmath74-msp , @xmath74-msp - black  or msp - white , when the solution itself is known to be unique , is -hard under randomized turing reductions .",
    "it is known that sat  @xmath113 usat , where usat  is the promise version of sat  whose input formulas are known to have either zero or one satisfying assignments  @xcite .",
    "let @xmath114 be the composition of this reduction with the parsimonious one from boolean formulas to instances of @xmath74-msp  ( respectively , @xmath74-msp - black , msp - white ) given by .",
    "our turing reduction proceeds as follows : given a boolean formula @xmath56 , compute @xmath115 and submit it to an oracle that finds a correct solution @xmath93 of @xmath74-msp  ( respectively , @xmath74-msp - black , msp - white ) when it is unique .",
    "then output yes if and only if @xmath93 is indeed a solution of @xmath115 , which can be checked in polynomial time .",
    "in we showed that # @xmath41-msp - white  is solvable in polynomial time when @xmath6 is a constant , while in we proved that it becomes -complete when @xmath116 . by making the code polynomially longer and filling the extra space with a fresh color , we can easily prove that also # @xmath117n)\\right)$]-msp - white  is -complete , for every constant @xmath0 .",
    "an obvious question arises : what is the lowest order of growth of @xmath118 such that # @xmath119-msp - white  is -complete ?",
    "we observed that # msp  is a subproblem of several heuristics aimed at optimally guessing the secret code , but is # msp  really inherent in the game ?",
    "perhaps the hardness of mastermind is not captured by # msp  or even msp , and there are cleverer , yet unknown , ways to play .",
    "+ _ input : _",
    "@xmath120 , where @xmath32 is an instance of msp , and @xmath121 .",
    "+ _ output : _",
    "yes if the codebreaker has a strategy to guess the secret code in at most @xmath0 attempts , using information from @xmath33 .",
    "no otherwise .      to make the game more fun to play for the codemaker ,",
    "whose role is otherwise too passive , we could let him change the secret code at every turn , coherently with the ratings of the previous guesses of the codebreaker . as a result",
    ", nothing changes for the codebreaker , except that he may perceive to be quite unlucky with his guesses , but the codemaker s game becomes rather interesting : by , even deciding if he has a non - trivial move is -complete , but he can potentially force the codebreaker to always work in the worst - case scenario , and make him pay for his mistakes .",
    "we call this variation _ adaptive mastermind_."
  ],
  "abstract_text": [
    "<S> mastermind is a popular board game released in 1971 , where a codemaker chooses a secret pattern of colored pegs , and a codebreaker has to guess it in several trials . after each attempt </S>",
    "<S> , the codebreaker gets a response from the codemaker containing some information on the number of correctly guessed pegs . </S>",
    "<S> the search space is thus reduced at each turn , and the game continues until the codebreaker is able to find the correct code , or runs out of trials .    in this paper </S>",
    "<S> we study several variations of # msp , the problem of computing the size of the search space resulting from a given ( possibly fictitious ) sequence of guesses and responses . </S>",
    "<S> our main contribution is a proof of the -completeness of # msp  under parsimonious reductions , which settles an open problem posed by stuckman and zhang in 2005 , concerning the complexity of deciding if the secret code is uniquely determined by the previous guesses and responses . </S>",
    "<S> similarly , # msp  stays -complete under turing reductions even with the promise that the search space has at least @xmath0 elements , for any constant @xmath0 . </S>",
    "<S> ( in a regular game of mastermind , @xmath1 . )    </S>",
    "<S> all our hardness results hold even in the most restrictive setting , in which there are only two available peg colors , and also if the codemaker s responses contain less information , for instance like in the so - called single - count ( black peg ) mastermind variation . </S>"
  ]
}