{
  "article_text": [
    "a programmable device can operate in different ways depending on the instructions being inserted in it .",
    "a quantum device may take these instructions not only in the form of classical data , but also in the form of a quantum state @xcite .",
    "if distinct programs correspond to distinguishable quantum states , then the situation is no different from classical programming . yet the setting changes when the instructions correspond to non - orthogonal pure quantum states ; this may allow to do something that is not possible with classical programming . using quantum resources instead of classical ones in programming of a device may have advantages , as is the case of a semiquantum bell scenario @xcite .",
    "any quantum measurement can be viewed as a process where the system of interest is brought into contact with an initially uncorrelated apparatus and after an interaction the value of the measured quantity is read from the apparatus pointer scale @xcite .",
    "a quantum measurement set - up may be used as a programmable device by considering the state of the apparatus as a program @xcite .",
    "this kind of a quantum multimeter can implement measurements of different observables even if the other parts of the device except the programming state are kept fixed .",
    "however , it is known that for two different sharp quantum observables the corresponding programming states must be orthogonal @xcite and hence , in this case , there is no quantum advantage over classical programming .    in another related scenario",
    "an experimenter is not changing any parts of a measurement device , but is allowed to perform classical operations to post - process the measurement data .",
    "in this way one can implement exactly those sets of quantum observables that are jointly measurable @xcite .",
    "the limitation in the case of sharp observables is that only commuting sharp observables are jointly measurable @xcite .",
    "interestingly , it was observed in @xcite that by allowing both quantum programming and classical post - processing it is possible to overcome the limitations that hold when the two procedures are used separately .",
    "indeed , it was demonstrated that there is a programmable device which implements , after post - processing , non - commuting sharp qubit observables by using non - orthogonal programming states .    in this work",
    "we generalize the multimeter presented in @xcite and show that a similar defeat of the limitations is possible in all finite dimensions .",
    "this generalization is achieved by studying the programmability of covariant observables .",
    "we then continue by deriving an inequality between the programming resources , classical and quantum , and the corresponding programmed observables .",
    "this result reveals the true underlying limitations of post - processing assisted quantum programming of observables .",
    "in this preliminary section we fix the notations and recall some basic concepts used throughout this work .",
    "we denote a complex separable hilbert space by @xmath0 , with either finite or countably infinite dimension .",
    "the set of bounded linear operators on @xmath0 is denoted by @xmath1 , the set of trace class operators by @xmath2 and the set of projections by @xmath3 .",
    "the identity element in @xmath1 is denoted by @xmath4 .",
    "the support of an operator @xmath5 is denoted by @xmath6}$ ] .",
    "a _ quantum state _ is represented as a positive operator @xmath7 with @xmath8}=1 $ ] and the set of quantum states of @xmath0 is denoted by @xmath9 .",
    "states @xmath10 and @xmath11 are said to be orthogonal when @xmath12 } \\cap { \\textrm{supp}[\\varrho_2 ] } = \\{0\\}$ ]",
    ". the extremal elements of @xmath9 are called _ pure _ or equivalently _ vector states _ , since any such element can be written as @xmath13 for some unit vector @xmath14 , where @xmath15 for all @xmath16 .",
    "the transformations of quantum states are represented as normal linear mappings @xmath17 that are completely positive and trace - preserving : such transformations are called _",
    "quantum channels_. equivalently , @xmath18 is a quantum channel whenever its dual mapping @xmath19 , defined via the duality relation @xmath20 } = { \\textrm{tr}\\left[{\\mathcal{e}}^*(b)\\ , t\\right]}$ ] for all @xmath21 , is completely positive and unital , that is @xmath22 .",
    "let @xmath23 be a non - empty finite set .",
    "we say that a map @xmath24 is an @xmath25-valued _ quantum observable _ ( povm ) whenever @xmath26 for all @xmath27 and @xmath28 .",
    "the non - zero operators @xmath26 , @xmath29 in the range of an observable are called effects .",
    "furthermore , we call an observable @xmath30 _ sharp _ ( pvm ) if all the effects of @xmath31 are projections , @xmath32 for every @xmath33 .",
    "we often shorten the notation by writing @xmath34 .",
    "the observables on @xmath35 form a convex set which is denoted by @xmath36 .",
    "we say that the conditional probability @xmath37 $ ] is a _",
    "post - processing _ of @xmath38 into @xmath39 if @xmath40 is a probability measure for every @xmath41 and @xmath42 for all @xmath43 ; in such a case we write shortly @xmath44 .",
    "it is known that extremal elements of the set of observables , shortly _ extremal observables _ , can only be post - processed by merging together effects of the smeared observable . in other words , if @xmath45 is an observable that can be post - processed into an extremal observable @xmath46 with @xmath47 $ ] , then @xmath48 for all @xmath49 and @xmath43 @xcite .      a _ measurement set - up _ is a 4-tuple @xmath50 , where @xmath51 is the hilbert space associated to the measurement apparatus , @xmath52 is the pointer observable , @xmath53 is a quantum channel describing the measurement interaction and @xmath54 is the initial probe state @xcite . the observable measured in this process",
    "is given by @xmath55 } \\",
    ", , \\qquad x \\subset \\omega_n,\\end{aligned}\\ ] ] in above , we will say that the observable @xmath56 is realized in the measurement @xmath57 .    from eq .",
    "it is readily concluded that measurements may be altered to realise different observables by changing the initial probe state .",
    "we will call such action _ quantum programming _ and the programmable device , mathematically described by a triplet @xmath58 , a _",
    "quantum multimeter_. any initial state of the probe then acts as a programming instruction for the multimeter and is thus called a _",
    "programming state_.    the programming states of any two unequal sharp observables are necessarily orthogonal regardless of the multimeter ; see @xcite and ex.[ex : sharportho ] .",
    "more generally , this orthogonality persists whenever the two programmed observables can be post - processed into different sharp ones with some fixed post - processing .",
    "interestingly , however , this orthogonality need no longer hold if the post - processings are allowed to be different @xcite , as we shall demonstrate shortly",
    ". therefore , one can introduce post - processing as an additional programming resource , that is the programmed observable @xmath59 } \\ , , \\quad x\\subset \\omega_m \\,.\\end{aligned}\\ ] ] depends , not only on the state @xmath60 , but also on the post - processing @xmath61 $ ] . to emphasize the difference to mere state dependent programming we will call this scenario _ post - processing assisted quantum programming_.",
    "in this section we use the framework of covariant observables to generalize the multimeter presented in @xcite .",
    "the main conclusion is that with post - processing assisted programming it is possible to realize different sharp observables with non - orthogonal programming states .",
    "we begin by recalling some basic facts about covariant observables .",
    "let @xmath0 be a finite @xmath62-dimensional hilbert space .",
    "let @xmath63 be a finite group and @xmath64 be its irreducible projective representation .",
    "for each @xmath65 , we define a mapping @xmath66 by formula @xmath67 the operators @xmath68 are positive and it is a direct consequence of schur s lemma that @xmath69 for some constant @xmath70 . calculating the traces of both sides we see that @xmath71 and @xmath72 is hence an observable .",
    "the structure of an observable @xmath72 is completely determined by the state @xmath73 , which is called the seed operator for @xmath72 . to shorten the notation",
    ", we also denote @xmath74 when @xmath75 .",
    "we recall from @xcite that all observables @xmath72 of the form of eq . can be programmed with a single multimeter .",
    "namely , fix an orthonormal basis @xmath76 of @xmath0 . for each @xmath77",
    ", we define a unit vector @xmath78 as @xmath79 for each @xmath77 , we define @xmath80 .",
    "a direct calculation gives @xmath81= \\frac{d } { \\ # g } { \\textrm{tr}\\left[\\varrho u(g)\\ , \\xi \\,u(g)^*\\right ] } =   { \\textrm{tr}\\left[{\\mathsf{e}}_\\xi(g ) \\",
    ", \\varrho \\right ] } \\ , , \\ ] ] for all @xmath82 , where the transpose @xmath83 is defined with respect to the orthonormal basis @xmath76 .",
    "since any @xmath73 defines a normalized povm via eq.[eq : seed ] , this also shows that @xmath84 , hence @xmath85 is an observable on @xmath86 .",
    "finally , we define the partial swap channel @xmath87 for all @xmath88 .",
    "then @xmath89 is a multimeter which for any @xmath90 , @xmath91 being arbitrary , realizes the observable @xmath92 ( see fig.[fig : covmultimeter ] ) .",
    "interestingly , this result implies that if two unequal covariant observables , that owe the same irreducible representation and differ only in the seeds @xmath93 and @xmath94 , are either sharp or can be made into unequal sharp observables with a fixed post - processing , then @xmath93 and @xmath94 are necessarily orthogonal .    ,",
    "@xmath95 , corresponding to the same irreducible projective representation @xmath96 with the programming states @xmath97.,scaledwidth=90.0% ]      as in the previous subsection , @xmath96 is an irreducible projective representation of @xmath63 of degree @xmath62 .",
    "we make an additional assumption that @xmath63 has a cyclic subgroup @xmath98 of order @xmath99 .",
    "this is obviously a restrictive assumption and allows only to use specific groups .",
    "however , we will later demonstrate by examples that there are useful instances of this type .",
    "our aim is to find sharp observables as post - processings of covariant observables .",
    "the method proceeds as follows .",
    "we fix an eigenvector @xmath100 of the unitary operator @xmath101 . for any @xmath102 ,",
    "the vector @xmath100 is also an eigenvector of @xmath103 and hence @xmath104 it follows that @xmath105 for a different left coset @xmath106 we get @xmath107 we conclude that by dividing @xmath63 into the left cosets of @xmath108 and forming the respective post - processing of @xmath109 , we obtain a sharp observable with @xmath62 outcomes .",
    "different eigenvectors of the unitary operator @xmath101 may lead to different sharp observables .",
    "however , since the applied post - processing is determined by the subgroup @xmath108 and is therefore the same for all those sharp observables , these programming vectors are necessarily orthogonal .",
    "the described method above becomes more effective when @xmath63 has several cyclic subgroups @xmath110 of the same order .",
    "further , we impose that any two operators @xmath111 and @xmath112 do not commute when @xmath113 , so that it is guaranteed that we can choose non - orthogonal ( and non - parallel ) eigenvectors @xmath114 of @xmath115 , respectively . from a practical point of view , it is easier to start with a group that has several cyclic subgroups of the same order and then check if there exists an irreducible projective representation with the desired degree .",
    "the quaternionic group @xmath116 consists of @xmath117 elements @xmath118 satisfying the equations @xmath119 and @xmath120 for each @xmath121 .",
    "there are three cyclic subgroups of order @xmath122 : @xmath123 , @xmath124 and @xmath125 .",
    "the previously described construction works for an irreducible projective representation of degree @xmath126 .",
    "we thus choose the following irreducible representation of @xmath116 : @xmath127 we get three different sharp observables , the programming vectors @xmath128 being eigenvectors of @xmath129 , respectively .",
    "they can be chosen such that the corresponding one - dimensional projections are : @xmath130 the sharp observables obtained by this post - processing assisted programming are hence the complementary qubit observables consisting of the projections @xmath131 , @xmath132 and @xmath133 , respectively .",
    "we have thus reproduced the result first presented in @xcite .",
    "let @xmath62 be a prime and let @xmath134 be the cyclic group of integers modulo @xmath62 .",
    "the product group @xmath135 can be consider as a finite phase space @xcite .",
    "it has @xmath136 cyclic subgroups of order @xmath62 .",
    "the generating elements of these cyclic subgroups can be chosen to be @xmath137 and @xmath138 .",
    "the earlier described construction works for an irreducible projective representation of degree @xmath139 .",
    "we fix an orthonormal basis @xmath140 of a @xmath62-dimensional hilbert space @xmath0 .",
    "we denote @xmath141 and define the following projective unitary representation @xmath96 of @xmath135 in @xmath0 : @xmath142 the programming vectors @xmath143 are eigenvectors of the operators @xmath144 and @xmath145 , respectively .",
    "they can be chosen to be : @xmath146 where @xmath147 , @xmath148 . in particular , we have @xmath149 for @xmath113 .",
    "as was explained before , each of these eigenvectors will lead to a sharp observable via appropriate post - processing .",
    "not much is known about the mutual dependencies of the programming states of general quantum observables , except those of sharp observables .",
    "such scenarios are important since often the implemented observables differ from the perfectly sharp ones . on the other hand , to our best knowledge the dependencies of post - processings and the programmed observables in post - processing assisted quantum programming have not been studied before . in this section",
    "we address these issues by introducing an inequality between measures of  closeness  of the programming resources and the corresponding programmed observables .",
    "we note that similar analysis was recently made for programming of quantum channels in @xcite .",
    "fidelity @xmath150 is a commonly used measure of distinguishability of quantum states .",
    "there are many equivalent ways to express fidelity , two of which we will recall next for the later use .",
    "firstly , the theory of uhlmann states that @xmath151 where the maximum is taken over all purifications @xmath152 of @xmath153 , @xmath154 @xcite . secondly fidelity may also be recast as @xmath155}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}(i ) \\ , \\varrho_2\\right]}^{1/2},\\end{aligned}\\ ] ] for all @xmath156 , where the minimum is taken over all observables @xmath24 @xcite .",
    "the latter formulation is closely related to so - called _ bhattacharyya coefficient _ @xmath157 that quantifies the divergence between two ( discrete ) probability measures : @xmath158 , where @xmath159 $ ] , @xmath160 .",
    "from this onwards we will use a short notion @xmath161}$ ] and write @xmath162 if @xmath163 . with these tools and definitions",
    "we are ready to formulate the results of this subsection .",
    "[ prop : mainobs ] suppose two observables @xmath164 and @xmath165 can be programmed with states @xmath93 and @xmath94 , respectively .",
    "then @xmath166 for all @xmath167 .",
    "fix states @xmath167 and let @xmath168 be any purifications of them , respectively . furthermore , let @xmath169 be the any purifications of the programming states @xmath170 , respectively . then in the total hilbert space @xmath171 we have @xmath172}^{1/2 }",
    "\\ , { \\textrm{tr}\\left [ { \\mathcal{v}}^ * ( { \\mathbbm{1}}\\otimes { \\mathsf{z}}(i ) ) \\ , \\varrho_2\\otimes \\xi_2\\right]}^{1/2 } \\nonumber \\\\ & & = \\sum_i { \\textrm{tr}\\left[{\\mathsf{e}}_1 ( i)\\,\\varrho_1\\right]}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}_2 ( i ) \\,\\varrho_2\\right]}^{1/2}.\\end{aligned}\\ ] ] since @xmath173 we conclude the proof by taking the maxima over all the possible purifications in the above inequality .    motivated by the previous proposition , we may define a quantity @xmath174 which sets the relation @xmath175 between the programmed observables @xmath176 and the programming states @xmath177 , @xmath154 .",
    "we wish to point out that due to the double infima taken over the state space @xmath178 is always well defined , although @xmath179 can be indefinite in general as the denominator may vanish .",
    "below we have listed some of its properties .",
    "[ prop : obsfid ] let @xmath180 .",
    "the quantity @xmath178 satisfies the following properties :    * @xmath181 , * @xmath182 $ ] , *",
    "@xmath183 iff @xmath184 , * @xmath185 , for all unitaries @xmath96 , * @xmath186 , * @xmath187 ,    for all channels @xmath188 and post - processings @xmath37 $ ] .    the first and the fourth properties follow trivially from the symmetry and unitary invariance of the fidelity of quantum states .",
    "the second one can be proved by noticing that @xmath189 , for all @xmath190 , where the latter limit follows immediately from the cauchy - schwartz inequality .    to prove ( b3 ) , we first suppose that @xmath191 , however , make a counter - assumption that @xmath192 .",
    "then there exists a state @xmath82 such that @xmath193 , implying that @xmath194 .",
    "therefore , @xmath195 .",
    "this contradiction proves the implication @xmath196 . on the other hand ,",
    "suppose that @xmath197 . then @xmath198}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}(i ) \\",
    ", \\varrho_2\\right ] } ^{1/2 }   \\nonumber \\\\   & \\geq & \\min_{{\\mathsf{e } } }   \\sum_i { \\textrm{tr}\\left[{\\mathsf{e}}(i ) \\,\\varrho_1\\right]}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}(i ) \\ , \\varrho_2\\right ] }",
    "^{1/2 }   \\nonumber \\\\   & = & f(\\varrho_1 , \\varrho_2).\\end{aligned}\\ ] ] hence , @xmath199 together with ( b2 ) proves that @xmath183 .",
    "we next prove ( b5 ) .",
    "suppose a hilbert space @xmath200 where @xmath201 admits a unitary dilation , @xmath202 $ ] for all @xmath203 and some fixed unitary @xmath96 on @xmath204 and fixed state @xmath205 .",
    "then @xmath206}^{1/2 } { \\textrm{tr}\\left[\\text{tr}_{{\\mathcal{k}}'}[u^ * ( { \\mathsf{e}}_2(i ) \\otimes { \\mathbbm{1}}_{{\\mathcal{k } } ' } ) u \\ , \\varrho_2 \\otimes \\eta\\right]}^{1/2 } \\nonumber \\\\ & = & b(p^{u^*({\\mathsf{e}}_1 \\otimes { \\mathbbm{1}}_{{\\mathcal{k } } ' } ) u}_{\\varrho_1\\otimes \\eta},p^{u^*({\\mathsf{e}}_2 \\otimes { \\mathbbm{1}}_{{\\mathcal{k } } ' } ) u}_{\\varrho_2\\otimes \\eta}).\\end{aligned}\\ ] ] therefore @xmath207}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}_2(i ) \\otimes { \\mathbbm{1}}_{{\\mathcal{k } } ' } \\ , \\chi_2\\right]}^{1/2 } } { f(\\chi_1,\\chi_2 ) } \\nonumber \\\\ & \\geq & \\inf_{\\chi_1,\\chi_2 } \\frac{\\sum_i { \\textrm{tr}\\left[{\\mathsf{e}}_1(i ) \\ , \\text{tr}_{{\\mathcal{k}}'}[\\chi_1]\\right]}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}_2(i ) \\ ,",
    "\\text{tr}_{{\\mathcal{k}}'}[\\chi_2]\\right]}^{1/2 } } { f(\\text{tr}_{{\\mathcal{k}}'}[\\chi_1],\\text{tr}_{{\\mathcal{k}}'}[\\chi_2 ] ) } \\nonumber \\\\ & = & b({\\mathsf{e}}_1 , { \\mathsf{e}}_2),\\end{aligned}\\ ] ] where we used the properties ( b4 ) and the monotonicity of the fidelity , @xmath208 for all channels @xmath209 .    finally , we prove ( b6 ) .",
    "fix any post - processing @xmath210 $ ] .",
    "since @xmath211 for all @xmath212 we have @xmath213}^{1/2 } { \\textrm{tr}\\left[{\\mathsf{e}}_2(j ) \\ , \\varrho_2\\right ] } ^{1/2 } \\nonumber \\\\ & \\leq &   \\sum_i \\left(\\sum_j \\lambda(i |",
    "j ) \\ , { \\textrm{tr}\\left[{\\mathsf{e}}_1(j ) \\,\\varrho_1\\right]}\\right)^{1/2 } \\left(\\sum_j \\lambda(i | j ) \\ , { \\textrm{tr}\\left[{\\mathsf{e}}_2(j ) \\,\\varrho_2\\right]}\\right ) ^{1/2 } \\nonumber \\\\ & = & b(\\lambda\\star p^{{\\mathsf{e}}_1}_{\\varrho_1},\\lambda\\star p^{{\\mathsf{e}}_2}_{\\varrho_2}),\\end{aligned}\\ ] ] where the estimation follows from cauchy - schwartz inequality .    for @xmath178 to be a satisfactory upper bound for the fidelity of the programming states , we should be able to bind it to some known results on programmability of quantum observables .",
    "the following example establishes such a connection .",
    "[ ex : sharportho ] suppose that two different sharp observables @xmath214 and @xmath215 can be programmed with states @xmath93 and @xmath94 respectively",
    ". then @xmath216 or equivalently @xmath93 and @xmath94 are orthogonal . in verifying this claim",
    "we follow the proof of prop.4 in @xcite .",
    "let us fix disjoint sets @xmath217 such that condition @xmath218 holds . then there exist unit vectors @xmath219 and @xmath220 such that @xmath221 @xmath222 and @xmath223 .",
    "furthermore , @xmath224 and @xmath225 .",
    "hence , @xmath226 @xmath227 and @xmath228 for @xmath154 , so that we have @xmath229}^{\\frac{1}{2 } } { \\textrm{tr}\\left[{\\mathsf{a}}_2(x_i ) \\ , p_{\\varphi_2}\\right]}^{\\frac{1}{2 } } \\nonumber \\\\ & & +   \\sum_{x_i\\in y }   { \\textrm{tr}\\left[{\\mathsf{a}}_1(x_i ) \\ , p_{\\varphi_1}\\right]}^{\\frac{1}{2 } } { \\textrm{tr}\\left[{\\mathsf{a}}_2(x_i ) \\ , p_{\\varphi_2}\\right]}^{\\frac{1}{2 } } \\nonumber \\\\ & & + \\sum_{x_i\\in ( x\\cup y)^c }   { \\textrm{tr}\\left[{\\mathsf{a}}_1(x_i ) \\ , p_{\\varphi_1}\\right]}^{\\frac{1}{2 } } { \\textrm{tr}\\left[{\\mathsf{a}}_2(x_i ) \\ , p_{\\varphi_2}\\right]}^{\\frac{1}{2 } } \\\\ & = & 0.\\end{aligned}\\ ] ] since @xmath230",
    ", we have @xmath231 which proves the claim .",
    "this implies that no state programmable multimeter @xmath232 described by a separable hilbert space @xmath51 can realize all observables , since there is only a countable number of orthogonal states in @xmath233 .      as noted in sect.[sec : covariant ] , post - processing can be an advantageous resource in quantum programming . in @xcite",
    "it was left as an open question whether it is possible to realize all observables if in addition to programming post - processing is allowed . using the tools developed above we provide a negative answer to this question .    following the above considerations",
    ", we define the  closeness  of two post - processings @xmath234 and @xmath235 $ ] via @xmath236    [ lem : min ] @xmath237 .",
    "trivially @xmath238 since @xmath239 @xmath240 are probability measures on @xmath241 for every @xmath242 . on the other hand , using cauchy - schwartz inequality , we confirm that @xmath243    the following proposition is the main result of this section .    [ prop : postp1 ] suppose two observables @xmath164 and @xmath244 can be programmed with states @xmath93 and @xmath94 , respectively .",
    "then for any post - processings @xmath234 and @xmath235 $ ] @xmath245 for all @xmath167 .    by the previous lemma[lem : min ] we have @xmath246 for all @xmath247 . from prop.[prop :",
    "mainobs ] we already know @xmath248 . therefore , @xmath249}\\right)^{1/2 } \\left(\\lambda_2(i|j ) \\ , { \\textrm{tr}\\left[{\\mathsf{e}}_2(i ) \\,\\varrho_2\\right]}\\right)^{1/2 } \\nonumber \\\\ & \\leq & \\sum_i \\left (   \\sum_j \\lambda_1(i|j ) \\ , { \\textrm{tr}\\left[{\\mathsf{e}}_1(i ) \\,\\varrho_1\\right ] } \\right)^{1/2 } \\ , \\left (   \\sum_j \\lambda_2(i|j ) \\ , { \\textrm{tr}\\left[{\\mathsf{e}}_2(i ) \\,\\varrho_2\\right ] } \\right)^{1/2 } \\nonumber \\\\ & = & b(\\lambda_1 \\star p^{{\\mathsf{e}}_1}_{\\varrho_1},\\lambda_2 \\star p^{{\\mathsf{e}}_2}_{\\varrho_2}),\\end{aligned}\\ ] ] where the second estimate is due to cauchy - schwartz inequality",
    ".    it follows from the previous proposition that @xmath250 .",
    "suppose now that it is possible to realize two different sharp observables via post - processing assisted programming . from ex.[ex",
    ": sharportho ] it can be concluded that then either @xmath216 or @xmath251 .",
    "assume that the hilbert space @xmath51 of the multimeter @xmath232 is separable and the pointer observable @xmath85 is @xmath252-valued .",
    "then one can use post - processing assisted programming to realize at most @xmath253 sharp observables with @xmath25-outcomes with @xmath232 . here",
    "@xmath254 is the binomial coefficient @xmath255 which characterizes the size of the set @xmath256 \\,|\\ , f(\\lambda_i , \\lambda_j ) = 0\\}$ ] .",
    "this proves that , with the above assumptions , even post - processing assisted programming can not universally realize all quantum observables comprising an uncountable set .",
    "we end the section by pointing out that the trade - off between the fidelities @xmath257 and @xmath258 when programming sharp observables is more subtle than what is captured by @xmath259 .",
    "let us recall , that in the quaternion example of sect.[sec : covariant ] we considered the post - processing assisted programming of three sharp spin - observables where , in particular , the programming states @xmath260 satisfy @xmath261 , @xmath262 .",
    "it turns out that the choice of states @xmath260 , @xmath263 , is optimal in the following sense .     and @xmath94 in post - processing assisted programming of sharp spin - observables @xmath264 versus @xmath265 .",
    "the bound , due to the right - hand - side of ineq . , attains its minimum @xmath266 for @xmath267 .",
    ", scaledwidth=100.0% ]    let @xmath93 and @xmath94 be the programming states of any observables @xmath164 and @xmath268 that can be post - processed into sharp spin - observables @xmath264 , @xmath269 @xmath270 , @xmath154 , respectively . due to",
    "the extremality of @xmath271 there exist @xmath272 such that @xmath273 and @xmath274 @xcite .",
    "in particular , for the set @xmath275 the following table holds    [ tab : sets ]    [ cols=\"<,^,^\",options=\"header \" , ]     where @xmath276 and @xmath277 $ ] are some probability measures . defining a merging type",
    "post - processing @xmath278 $ ] according to the previous table we have @xmath279 for all states @xmath280 satisfying @xmath281 . by choosing these states appropriately ,",
    "we get the following inequality @xmath282 for example , the first term follows from choosing @xmath283 , @xmath154 . by maximizing the right - hand - side over @xmath276 and @xmath284",
    "we get a universally valid upper bound for programming states @xmath93 and @xmath94 in post - processing assisted quantum programming plotted in fig.[fig : combi ] as a function of @xmath265 . for the orthogonal spin directions , @xmath267 , the upper bound reaches its minimum @xmath266 .",
    "m.t . acknowledges financial support from the university of turku graduate school ( utugs ) .",
    "the authors are grateful to juha - pekka pellonp for his comments on the manuscript ."
  ],
  "abstract_text": [
    "<S> a quantum multimeter is a programmable device that can implement measurements of different observables depending on the programming quantum state inserted in it . </S>",
    "<S> the advantage of this arrangement over a single purpose device is in its versatility : one can realize various measurements by changing the programming state . </S>",
    "<S> the classical manipulation of measurement output data is known as post - processing . in this work </S>",
    "<S> we study the post - processing assisted quantum programming , namely a protocol where quantum programming and classical post - processing are combined . </S>",
    "<S> we provide examples showing that these two processes combined can be more efficient than either of them used separately . </S>",
    "<S> furthermore , we derive an inequality relating the programming resources and the corresponding programmed observables that enables us to study the limitations on post - processing assisted quantum programming . </S>"
  ]
}