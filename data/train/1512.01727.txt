{
  "article_text": [
    "the subset sum problem asks whether one or more integers in a given input set sum to a target value .",
    "for example , given the set @xmath3 , do any of these integers sum to 10 ?",
    "the answer is yes , as @xmath4 sums to 10 .",
    "this may be apparent for one to see , but instructing a computer to solve a problem like this in an efficient manner may prove to be quite difficult .",
    "the most straightforward approach to solving the subset sum problem is to test every combination of values in some systematic way .",
    "for example , we may check all integers individually to see if any are 10 .",
    "if the sum is not found , then we may try all pairs of integers ( @xmath5 , @xmath6 , ... , @xmath7 ) . if the sum is still not found",
    ", then we may try all triples , quadruples , and so on until we have either found the sum or exhausted all possibilities .",
    "this solution works but is inefficient for larger input sets , with a computational efficiency of @xmath8 .",
    "the approach introduced in this paper leverages a unique data structure termed a subset tree , in which all subsets of a particular length @xmath9 are ordered in a min - heap fashion .",
    "a binary search is then performed on this ordered set of @xmath9-subsets . if the target sum is not found in the subset tree of length @xmath9 , then the subset tree of length @xmath10 is generated and searched .",
    "this process continues in an iterative fashion until the sum is found or the subsets used to generate the subset tree are equal to the length of the set . to minimize space complexity of each subset tree ,",
    "the subsets are generated as needed during the binary search phase of the algorithm rather than building the complete subset tree upfront . to account for sets with negative integers",
    "when building the subset tree , each value is offset by a value that produces a set of strictly positive integers .",
    "this value is the absolute value of the minimum negative integer in the set plus one .",
    "the complexity of this algorithm is @xmath0 , where @xmath1 is the length of the set and @xmath2 is the index of the subset tree being located during the binary search .",
    "a sample implementation of this algorithm has been provided .",
    "the provided implementation includes sample code for each section discussed in this paper .",
    "a dynamic programming solution exists in pseudo - polynomial time @xmath11 , where @xmath12 is the target value and @xmath1 is the length of the set .",
    "this approach maintains an array of boolean values @xmath13 and employs recursive arithmetic operations for each element in the set from the index of the target value .",
    "the value of the array at each index computed by the algorithm is set to true , indicating that there exists a subset in the set which sums to the value of the index . the solution to whether a subset exists which sums to the target value",
    "can then be found by accessing the boolean value of @xmath13 .",
    "the complexity of this algorithm has since been improved to @xmath14 ( koiliaris and xu , 2015 ) .",
    "sort @xmath15 into increasing order + define a tree @xmath16 where : ( i ) the root is the singleton consisting only of the first element ( ii ) the left child of a set whose maximum element is @xmath17th in the sorted input list is obtained by replacing that element by element @xmath18 ( iii ) the right child is obtained by including element @xmath18 without removing any existing element + return @xmath16 +    improvements to the exponential time algorithm have been explored , bringing the running time down to @xmath19 ( horowitz and sahni , 1974 ) .",
    "the algorithm takes a set of length @xmath1 and partitions the elements into two sorted sets of @xmath20 each .",
    "one list is stored for each of the two sets , with each list consisting of the sums for all @xmath21 possible subsets .",
    "the algorithm maintains two pointers : one pointer starting at the smallest sum in the first list and the other pointer starting at the largest sum in the second list .",
    "if the sum of these two sums equals the target value , then the search terminates .",
    "if the sum is less than the target value , then the first pointer is incremented by one position .",
    "if the sum is greater than the target value , then the second pointer is decremented by one position .",
    "this process continues until the target value is found or the search space has been exhausted .",
    "this @xmath19 solution has been improved through the use of min - heaps ( schroeppel and shamir , 1981 ) . rather than evaluating and sorting the list of sums for all subsets in the divided set ,",
    "these sums are generated in order through the use of the min - heap data structure .",
    "the first list is divided into two additional lists @xmath22 and @xmath23 , resulting in a length of @xmath24 .",
    "the subsets from each list are generated and sorted in increasing order .",
    "a min - heap is then constructed from the pairs of subsets from @xmath22 and @xmath23 . as each subset from the min - heap",
    "is needed , it is popped from the top of the heap and the head element @xmath25 is replaced with the subset @xmath26 .",
    "subsequently , all pairs of subsets from @xmath22 and @xmath23 are generated in order of their total sum .",
    "likewise , the second list is divided into two additional lists and the subsets are generated in order .",
    "however , these subsets are generated in decreasing order via a max - heap .",
    "the aforementioned exponential algorithm is then applied in which the subsets of the first list are incremented and the subsets of the second list are decremented as necessary until the target value is found or both heaps become empty .",
    "the running time of this method is @xmath27 .",
    "building upon the prior work with min - heaps of subsets , a binary min - heap may be used to extend the solution to the initial input set as a whole when the input set contains only positive integers .",
    "a binary min - heap is a binary tree whose parent nodes are less than or equal to their child nodes .",
    "because it makes no guarantee of total sorting ( i.e. the root node is always the smallest in the tree ) , it is considered a partially - ordered data structure . assuming all positive integers , algorithm 1 is used to generate a tree of subsets in order of increasing sum , where @xmath15 is the input set of positive integers , @xmath28 is the target value , and @xmath16 is the subset that sums to the target value .",
    "figure 1 visualizes the complete min - heap binary tree for the set @xmath29 . by repeating step 2 of algorithm 1 for each node ,",
    "the heap - ordered binary tree is generated as demonstrated .",
    "the @xmath2 smallest elements of the heap - ordered tree can be found in time @xmath30 ( frederickson , 1993 ) .",
    "this is done through the hierarchical grouping of particular elements in the heap and maintaining them in a recursively defined data structure .",
    "an alternate solution to finding the @xmath2th smallest element of a min - heap is shown in algorithm 2 , where the input @xmath31 is a min - heap binary tree of subsets . in this case",
    ", the lookup is performed in time @xmath32 .    .",
    "]    because each child node is trivially derived from its parent node , the search may be performed in a lazy manner and child nodes may be generated only as required for the search . in the aforementioned example @xmath29 , if the 4th smallest subset is desired , then the root node of @xmath33 and its children , @xmath34 and @xmath35 , are generated .",
    "per algorithm 2 , the subsequent child nodes for both of the root node s child nodes are generated in the same step as adding the root node s children to _ m_. thus , the lookup is effectively performed on a virtual array without the need to generate all nodes in the power set of the input .",
    "a binary search can be performed on the sorted list of subsets that can be made from the input set .",
    "since there are @xmath36 subsets in total , a binary search to find a target sum @xmath28 can be performed in time @xmath37 .",
    "this reduces to @xmath38 , or @xmath39 .",
    "since each search for the @xmath2th largest element takes @xmath32 time , a binary search on the virtual sorted list of all subsets to find the sum will take @xmath40 time , where @xmath41 .",
    "however , if negative integers are included in the initial set alongside positive integers , then the approach taken to construct a heap - ordered binary tree will not suffice , as algorithm 1 would place negative integers in the child nodes of subsets of strictly positive integers and violate the properties of the min - heap .",
    "therefore , a modification to algorithm 1 is necessary to handle cases of sets with both positive and negative integers .",
    "assume a set of integers with both positive and negative values . to continue using a heap - ordered tree constructed in a similar fashion as previously discussed , all values in the set",
    "must be scaled by some offset value to be made positive .",
    "this can be done by adding the absolute value of the least element plus one to all elements .",
    "the offset applied to each element must also be stored for future use in the algorithm .",
    "define a min - heap of nodes to visit @xmath42 + insert the root node of @xmath31 into @xmath42 + define an empty array @xmath43 + while @xmath44 : ( i ) pop the root node of @xmath42 ( ii ) add the popped node to @xmath43 ( iii ) add the popped node s children to @xmath42    as an example , take the set @xmath45 and the target sum @xmath46 .",
    "the scaled input is @xmath47 .",
    "the offset value @xmath48 must also be stored , as it will be applied to the target sum later .    .",
    "]    despite this new set consisting of all positive values , algorithm 1 can not be applied as is .",
    "this is due to the lack of a consistent target value for subsets of different lengths .",
    "for example , although @xmath49 sums to @xmath46 , the scaled subset @xmath50 will only sum to the target value by adding the offset to the target three times . in this case , the target value must be scaled from @xmath46 to @xmath51 .",
    "generally , the target sum can only be compared to a scaled subset of size @xmath9 if @xmath52 is added to the target value itself .",
    "therefore , @xmath1 min - heaps must be generated , with each one consisting of all subsets of equal length .",
    "a binary search may then be performed on each min - heap .    maintaining an ordered min - heap of subsets of the same length",
    "can be accomplished through the use of a unique data structure similar to the binomial heap , introduced here as the heap - ordered subset tree .",
    "the subset tree is a heap - ordered tree structure consisting of @xmath9-length subsets of a set @xmath15 of length @xmath1 .",
    "the process of constructing a subset tree @xmath31 of order @xmath9 from set @xmath15 is detailed in algorithm 3 .    for a subset tree of order @xmath9 ,",
    "the total number of nodes is bounded at @xmath53 , where @xmath1 is the total number of elements in the input set .",
    "each node has at most @xmath1 children and the height of the tree is at most @xmath1 .    to demonstrate a simple example , figure 2 displays the 4-subset tree for the set @xmath54 .",
    "sort the input set @xmath15 + set the root node of the subset tree @xmath31 to the @xmath9 smallest elements of @xmath15 + the first child node is the subset of the parent node with the parent node s greatest element replaced with the next greatest element in @xmath15 .",
    "if no such greater element exists , then the end of @xmath15 has been reached and this child node should not be generated .",
    "+ let the variable @xmath17 be equal to the penultimate index in the subset of the parent node : ( i ) the next child node is the subset of the parent node with the element at index @xmath17 replaced by the next greatest element from index @xmath17 in @xmath15 .",
    "if that element already exists in the subset , then increment the conflicting element with its next greatest element in @xmath15 .",
    "( ii ) repeat with any additional conflicts until none exist or there is no greater element in @xmath15 with which to increment .",
    "if the latter is the case , then the end of @xmath15 has been reached and this child node should not be generated .",
    "+ decrement @xmath17 by 1 and repeat step 4 for all subsequent child nodes until @xmath17 is less than the smallest index at which the parent node incremented its subset value + terminate and return @xmath31 when the greatest element in the subset is equal to the greatest element in @xmath15 +    as algorithm 3 must be performed with subsets consisting of only positive elements , this operation is performed on the scaled set as opposed to the initial set .    although this operation generates the tree in its entirety , it is trivial to generate nodes up to the @xmath2th smallest element due to the partial ordering in which the subset tree is constructed .",
    "this optimization minimizes the space needed for subset trees to be stored , which is especially useful for subsets of an arbitrarily large input set .",
    "the complete algorithm for the subset sum problem for sets of both positive and negative integers is provided in algorithm 4 , where @xmath15 is a given input set of length @xmath1 , @xmath28 is the target value , and @xmath55 is the returned subset .",
    "the solution begins by sorting the set and uniformly scaling each member of the set to a positive value .",
    "for @xmath56 to @xmath1 , where @xmath1 is the length of the input set , a binary search is performed on all subsets of the appropriate length .",
    "the subsets are generated in order of their sum with the use of the subset tree .",
    "this iteration is continued until a subset is found which sums to the target value or the search space has been exhausted . in the case",
    "that no subset of a given set exists for a given target value , an empty subset is returned .",
    "sort @xmath15 + offset each element in @xmath15 by the absolute value of the least element in @xmath15 plus one + store this @xmath57 value + define a variable @xmath16 and set it to 1 .",
    "this is the order of the virtual subset heap being searched . +",
    "while @xmath58 and a subset @xmath55 that sums to @xmath59 has not been found : ( i ) perform a binary search for @xmath59 on the @xmath16-subset tree @xmath31 ( ii ) if a subset @xmath55 is found , then terminate the loop .",
    "else , increment @xmath16 by 1 and repeat step 5(i ) . do this",
    "until a subset has been found or @xmath60 + if a subset @xmath55 has been found , then subtract @xmath57 from each element in @xmath55 and return @xmath55 .",
    "else , return an empty subset .",
    "+    the sorting step of the algorithm is independent to its implementation .",
    "the binary search is performed in time logarithmic to the size of the binomial coefficient @xmath53 , where @xmath1 is the length of the input set and @xmath9 is the order of the subset tree .",
    "each lookup is performed in time dependent on the @xmath2 value .",
    "since the number of child nodes at each deleted node in the subset tree can be @xmath1 , the heapify procedure requires additional computation , with the overhead bringing it from time @xmath61 to time @xmath62 ; the lookup in its entirety takes @xmath40 time . since this @xmath63 operation must be run @xmath1 times in the worst case in which no subset exists , the overall complexity of this algorithm is @xmath0 .",
    "returning to the previous example of the input set @xmath45 and the target value of @xmath46 , the algorithm is executed as follows :    1 .",
    "@xmath45 is sorted . in this case , the set was already sorted .",
    "an offset of @xmath48 is applied to @xmath45 , producing a scaled set of @xmath47 .",
    "3 .   @xmath16 is set to @xmath56 .",
    "4 .   a binary search for @xmath59 , or @xmath48 ,",
    "is performed on the subset tree of order @xmath16 , or @xmath56 .",
    "since no subset is found , @xmath16 is incremented by @xmath56 . as @xmath64",
    ", the search is continued .",
    "6 .   a binary search for @xmath59 , or @xmath65 , is performed on the subset tree of order @xmath16 , or @xmath66 .",
    "since no subset is found , @xmath16 is incremented by @xmath56 .",
    "as @xmath64 , the search is continued .",
    "a binary search for @xmath59 , or @xmath51 , is performed on the subset tree of order @xmath16 , or @xmath67 .",
    "9 .   the subset @xmath50 is found .",
    "subtract @xmath57 from each element to produce the subset @xmath49 .",
    "return @xmath49 .",
    "the subset sum problem continues to offer unique approaches to its solution through the use of various methodologies deviating from the naive brute - force approach , ranging from dynamic programming solutions to uses of data structures such as the min - heap to provide an iterative search space of subsets of positive integers . building upon existing heap - based solutions",
    ", this paper introduced the subset tree data structure , allowing for proper heap - ordering of all subsets of an arbitrary length despite whether the input set consists of positive elements , negative elements , or both .",
    "standard @xmath2th - minimum lookup procedures can then be performed through a binary search on all subsets of a particular length @xmath9 .",
    "iterating through all possible lengths of subsets from a given set , target values may be found in time @xmath0 , where @xmath1 is the length of the set and @xmath2 is the index of the list of subsets that is being searched .",
    "future work in this area may include improving the algorithm to allow for heap - ordering of subsets from a set of both positive and negative elements in a single tree , removing the need for the iteration step over subset trees of a particular order .",
    "this improvement would also have the auxiliary benefit of removing the need to apply and store an offset value to the initial set , further optimizing the space required for the algorithm to find a solution .",
    "frederickson , greg n. `` an optimal algorithm for selection in a min - heap . '' _ information and computation _ 104.2 ( 1993 ) : 197 - 214 ."
  ],
  "abstract_text": [
    "<S> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ in the field of algorithmic analysis , one of the more well - known exercises is the subset sum problem . </S>",
    "<S> that is , given a set of integers , determine whether one or more integers in the set can sum to a target value . aside from the brute - force approach of verifying all combinations of integers , </S>",
    "<S> several solutions have been found , ranging from clever uses of various data structures to computationally - efficient approximation solutions . in this paper , a unique approach </S>",
    "<S> is discussed which builds upon the existing min - heap solution for positive integers , introducing a tree - based data structure influenced by the binomial heap . termed the subset tree </S>",
    "<S> , this data structure solves the subset sum problem for all integers in time @xmath0 , where @xmath1 is the length of the set and @xmath2 is the index of the list of subsets that is being searched . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </S>"
  ]
}