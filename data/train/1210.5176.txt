{
  "article_text": [
    "deciding if a graph can be @xmath0-edge - colored ( that is , whether or not it is of class one ) is known to be @xmath1-complete even for maximum degree @xmath2 ( holyer @xcite ) .",
    "therefore , assu - ming @xmath3 , the problem of 3-edge - coloring a cubic graph becomes intractable as the number of its vertices increases .",
    "possible ways to  break \" intractability are restricting the problem or admitting probabilistic solutions . here",
    "we take the second approach , proposing a simple and fast heuristic algorithm to 3-edge - color a cubic graph @xmath4 .",
    "experimental data suggest that , when @xmath4 is 3-edge - colorable ( an asymptotically almost sure property by the results of robinson and wormald @xcite ) , our algorithm efficiently gives an explicit solution and , hence , allows us to break intractability .",
    "the algorithm is easily generalized to graphs with maximum degree @xmath0 .",
    "all graphs are assumed to be connected and with no loops or multiple edges .",
    "the heuristic algorithm is called @xmath5 ( for  conflicting vertex displacement \" ) and starts with a random coloring of the edges of @xmath4 using 3 colors .",
    "conflicting vertex _ is a vertex whose incident edges are not properly colored ( at least two of them are equally colored ) .",
    "the main loop of the algorithm consists of the following steps .",
    "first , randomly choose a conflicting vertex and take one of the unproperly colored edges as the starting point of a kempe chain .",
    "that is , a 2-edge - colored path whose two colors are the original unproper color of the starting edge and a new color that makes the vertex unconflicting or , at least , reduces the number of edges with repeated color ( a suitable new color always exists , and can be randomly chosen when it is not unique ) .",
    "then , swap the two colors along the chain .",
    "such an operation does not create new conflicts but moves the conflict along the path . stop the color swapping when , either ,",
    "another conflicting vertex is reached , where the conflicts may cancel out , or the number of swaps attains a given limit ( at most the number of vertices in the graph ) .",
    "next , choose again a conflicting ( not necessarily different ) vertex and start a new kempe chain . repeat the procedure until , either , all conflicts are solved ( so getting a 3-edge - coloring ) or a fixed limit ( made precise below ) is reached .",
    "the number of conflicting vertices may stabilize even if @xmath4 is not a snark ( a class two graph , see fiol @xcite , gardner @xcite , or isaacs @xcite ) because not every color swap succeeds in solving one conflict . to avoid an infinite loop , we keep a counter of the number of times a new conflicting vertex is chosen and reset this counter to zero only when the number of conflicting vertices decreases .",
    "if the counter reaches a certain , constant , value @xmath6 or _ repetition limit _ then the main loop is restarted from a new initial random coloring of the edges .",
    "the maximum number of times the main loop can be restarted is the _ iteration limit _ , @xmath7 .",
    "if we reach this limit , we stop and assume that the cubic graph can not be properly 3-edge - colored .",
    "then the non - null probability of making a wrong assumption is the price for  breaking \" intractability .",
    "assuming the worst case , every time a conflicting vertex is chosen at most @xmath8 colors are swapped along a kempe chain , and at most all @xmath8 vertices in the graph could be conflicting .",
    "if the number of conflicting vertices ceases to decrease , the choice of a new conflicting vertex can be repeated no more than @xmath6 times , the repetition limit , before the main loop restarts from a new random coloring of the edges , and the number of restarts is at most the iteration limit , @xmath7 .",
    "the cost of randomly coloring the graph edges is @xmath9 , and at most @xmath7 random colorings must be done .",
    "the parameters @xmath6 and @xmath7 are fixed during the execution of the algorithm .",
    "therefore , the expected running time is @xmath10 .",
    "given the pessimistic estimation , it could be better in practice ( see section 6 ) .",
    "a similar complexity analysis is valid in more general cases ( section 5 ) .",
    "the basic idea ( conflict displacement ) is the same , but this case is slightly more complex . we measure the `` conflict level '' of a vertex ( how far it is from having its incident edges properly colored ) by its degree ( @xmath0 if the graph is @xmath0-regular ) minus the number of different colors used in its incident edges .",
    "this gives a measure of the color repetition : assuming the colors are always in the range 0,1,2, ... ,@xmath11 , if the number of different colors used in the incident edges of a vertex is equal to the degree of that vertex , then no color is repeated and the conflict level is 0 . if the same color is used in every incident edge , there are @xmath11 repetitions of that color and the conflict level of the vertex is @xmath11 .",
    "the range of possible conflict level values is 0,1,2, ... ,@xmath11 .",
    "a data structure , a dictionary to be precise , mapping each conflict level value to the set of vertices with that conflict level , is updated as the kempe switches change the coloring of the edges ( see section 8) .",
    "this information is needed because in the new algorithm conflicting vertices are chosen according to their conflict level : vertices with the highest conflict level are chosen first .",
    "the conflict level value 0 and its corresponding set of unconflicting vertices do not need to be present in the dictionary .    instead of the number of conflicting vertices , the total number of conflicts is used to measure the `` conflictivity '' of the graph : this is the sum of the conflict levels over all vertices in the graph , and it may be larger than the number of vertices in the graph .    to reduce the conflictivity of the initial arbitrary edge - coloring a simple greedy algorithm can be used instead of the random coloring that was sufficient in the cubic case .",
    "besides this , and implementation details aside , the conflicting vertex choice based on the highest conflict level and the conflictivity measure based on the sum of all conflict levels are the only relevant modifications of the algorithm done to deal with the general case .",
    "as in the previous analysis , and asuming the worst case again , every time a conflicting vertex is chosen at most @xmath8 swaps are done along a kempe chain . in the present case we use the sum of all conflict levels to measure the conflictivity of the graph , which is at most @xmath12 .",
    "if the conflictivity measure ceases to decrease , the choice of a new conflicting vertex can be repeated no more than @xmath6 times , the repetition limit , before the main loop restarts from a new pre - coloring of the edges , and the number of restarts is at most the iteration limit , @xmath7 .",
    "the cost of pre - coloring all @xmath13 graph edges using a random coloring or the greedy algorithm is @xmath14 or possibly better , depending on the efficiency of sampling from the set of @xmath15 available colors , and at most @xmath7 pre - colorings must be done .",
    "the parameters @xmath6 and @xmath7 are fixed during the execution of the algorithm .",
    "therefore , the expected running time is @xmath16 . as in the previous case ,",
    "the estimation is pessimistic and the performance could be better in practice ( see section 7 ) .    roughly speaking ,",
    "our approach , with its vertex - centered measure of conflict , is similar to the edge - centered approach by lee , wan and guan ( @xcite ) .",
    "these authors improved on @xmath0-edge - coloring algorithms by giving a polynomial ( albeit probabilistic ) algorithm .",
    "the @xmath5 algorithm is simpler and easy to implement ( see section 8) .",
    "we tested the performance of the heuristic algorithm by measuring the time needed to 3-edge - color random cubic graphs . more specifically , for each randomly generated cubic graph , we measured the time needed to find a 3-edge - coloring , the number of iterations of the main loop , and the average time per iteration ( the coloring time divided by the number of iterations ) .",
    "for each number of vertices , we obtained the minimum , average , and maximum values of each of these magnitudes over a set of 30 random instances , and we plotted the results .",
    "it seems that the heuristic algorithm finds a 3-edge - coloring , if any , with high probability .",
    "the average running time appears to grow linearly with the number of vertices ( see the first figure ) .",
    "the same happens with the average time per iteration ( not shown ) , whereas the average number of iterations does not seem to depend on the number of vertices ( see the second figure ) .",
    "a linearly growing average running time is in agreement with the @xmath17 expected running time .",
    "we followed the same testing procedure as in the cubic case ( measuring the average running time over 30 instances ) , but varying the number @xmath8 of vertices and the value of @xmath0 .",
    "the growth of the average running time is in agreement with the expected @xmath18 behaviour .",
    "the following figure shows four plots , corresponding to four different values of the variable @xmath0 ( 3 , 7 , 11 and 15 ) .",
    "we used the python language ( version 2.7.3 ) to implement the heuristic algorithm .",
    "this language allows us to use the networkx package to generate random regular graphs , and the matplotlib package to plot the results of the performance tests .    in order to facilitate the reproducibility of our results , or the use of the cvd algorithm to anyone",
    "interested , we give a complete python implementation of the algorithm described in section 4 , depending only on the python standard library and the networkx package .",
    "the plot of section 6 was created using the algorithm described in section 3 , specific for cubic graphs , with a very similar ( slightly simpler ) implementation .",
    ".... # # # implementation data # # # # operating system : linux-3.2.0 - 31-generic - x86_64-with - ubuntu-12.04-precise # cpu : intel(r ) core(tm ) i3 cpu        m 370   @ 2.40ghz .",
    "cache size : 3072 kb # cpu speed : 933.000 hz    # # # python code # # # from random import choice , randint import networkx as nx    def properlycolored(g , u , d ) :      return len(set(g[u].values()))==g.degree(u ) and all(color in range(d ) for                                                          color in g[u].values ( ) ) def checkedgecoloring(g , d ) :      return all(properlycolored(g , u , d ) for u in g.nodes ( ) )    def conflictlevel(g , u ) : return g.degree(u)-len(set(g[u].values ( ) ) )    def createconflictdictionary(g , d ) :      conflict_dictionary = dict([(i , set ( [ ] ) ) for i in range(1,d ) ] )      for u in g.nodes ( ) :          conflict_level_u = conflictlevel(g , u )          if conflict_level_u>0 : conflict_dictionary[conflict_level_u].add(u )      return conflict_dictionary    def updateconflictdictionary(g , u , conflict_dictionary , old_conflict_level_u ) :      conflict_level_u = conflictlevel(g , u )      if old_conflict_level_u>0 :          conflict_dictionary[old_conflict_level_u].remove(u )      if conflict_level_u>0 :          conflict_dictionary[conflict_level_u].add(u )      return conflict_level_u - old_conflict_level_u    def maxconflictlevel(conflict_dictionary ) :      return max([conflict_level for conflict_level in conflict_dictionary                  if len(conflict_dictionary[conflict_level])>0 ] )    def totalnumberofconflicts(conflict_dictionary ) :      return sum(conflict_level*len(conflict_dictionary[conflict_level ] )                 for conflict_level in conflict_dictionary )    def coloredgeandupdate(g , u , v , color , conflict_dictionary ) :      old_conflict_level_u = conflictlevel(g , u )      old_conflict_level_v = conflictlevel(g , v )      g[u][v]=g[v][u]=color      updateconflictdictionary(g , u ,                               conflict_dictionary ,                               old_conflict_level_u )      return updateconflictdictionary(g , v ,                                      conflict_dictionary ,                                      old_conflict_level_v )     def kempenext(g , last , node , new_color , conflict_dictionary ) :      available_for_next=[w for w in g[node ] if w!=last                                             and g[node][w]==new_color ]      if available_for_next== [ ] : next_node = none      else : next_node = choice(available_for_next )      old_color = g[last][node ]      conflict_level_variation = coloredgeandupdate(g , last , node , new_color ,                                                  conflict_dictionary )      return conflict_level_variation , old_color , next_node    def kempestep(g , last , node , new_color , conflict_dictionary ) :      conflict_level_variation , old_color , next_node = kempenext(g , last , node ,                                                             new_color ,                                                             conflict_dictionary )      if conflict_level_variation<0 or next_node==none : return node , none , none      return node , next_node , old_color    def kempeprocess(g , last , node , new_color , conflict_dictionary ) :      kempe_chain = set ( [ ] )      while new_color!=none and last not in kempe_chain :          kempe_chain.add(last )          last , node , new_color = kempestep(g , last , node , new_color ,                                        conflict_dictionary )    def kempestart(g , d , node , conflict_dictionary ) :      colors = set(range(d ) )      next_node = none      for adjacent in g[node ] :          edge_color = g[node][adjacent ]          if edge_color in colors : colors.remove(edge_color )          else : next_node = adjacent",
    "if next_node!=none :          kempeprocess(g , node , next_node , choice(list(colors)),conflict_dictionary )    def precoloring(g , d ) : # pre - coloring with a greedy algorithm      for e in g.edges ( ) : g[e[0]][e[1]]=g[e[1]][e[0]]=none      for e in g.edges ( ) :          available_colors = set(range(d ) )          available_colors-=set(g[e[0]].values ( ) )          available_colors-=set(g[e[1]].values ( ) )          if available_colors==set ( ) : g[e[0]][e[1]]=g[e[1]][e[0]]=randint(0,d-1 )          else : g[e[0]][e[1]]=g[e[1]][e[0]]=choice(list(available_colors ) )     # def precoloring(g , d ) : # random pre - coloring #    for e in g.edges ( ) : g[e[0]][e[1]]=g[e[1]][e[0]]=randint(0,d-1 )    def heuristic(g , d , repetition_limit ) :          repetitioncounter=0          conflict_dictionary = createconflictdictionary(g , d )          previous = current = totalnumberofconflicts(conflict_dictionary )          while previous>0 :              highest_conflict_level = maxconflictlevel(conflict_dictionary )              node = choice(list(conflict_dictionary[highest_conflict_level ] ) )              kempestart(g , d , node , conflict_dictionary )              current = totalnumberofconflicts(conflict_dictionary )              if current==0 : return true              if current>=previous :                  repetitioncounter+=1                  if repetitioncounter > repetition_limit : return false              else : repetitioncounter=0              previous = min(previous , current )          return true    def applyheuristic(g , d , repetition_limit , iteration_limit ) :      precoloring(g , d )      number_of_iterations=1      while not heuristic(g , d , repetition_limit ) :          if number_of_iterations > iteration_limit : break          precoloring(g , d )          number_of_iterations+=1      print \" number of iterations:\",number_of_iterations      print \" edge - coloring successful:\",checkedgecoloring(g , d )    # # # example # # # repetition_limit = iteration_limit=50 number_of_vertices=50000 degree=3 g = nx.random_regular_graph(degree , number_of_vertices ) applyheuristic(g , degree , repetition_limit , iteration_limit ) ....",
    "odd graphs , @xmath19 with @xmath20 an integer , are defined in the following way : the vertices correspond to the @xmath21-subsets of a @xmath22-set , and two vertices are adjacent if their corresponding subsets are disjoint .",
    "it is conjectured ( biggs @xcite , fiorini and wilson @xcite ) that odd graphs are of class one except for @xmath23 ( the petersen graph ) and @xmath24 a power of two ( when the graph has an odd number of vertices , implying that it is trivially of class two ) . in their book , fiorini and wilson comment results for @xmath25 .",
    "we used the @xmath5 algorithm to test that the conjecture is true for @xmath26 .",
    "we have seen that random cubic and @xmath0-regular graphs can be edge - colored with empirical efficiency by a relatively simple heuristic algorithm ( with simple data structures ) .",
    "many combinatorial problems , for instance logical circuit problems ( fiol @xcite ) , can be to 3-edge - coloring of cubic graphs or edge - coloring of regular graphs .",
    "therefore , any efficient edge - coloring heuristic might be useful to solve them .",
    "moreover , efficient edge - coloring is of practical interest in many applications .",
    "n. biggs , some odd graph theory , _ second international conference on combinatorial mathematics ( new york , 1978 ) _ , pp . 7181 , annals of the new york academy of sciences , * 319 * , new york academy of sciences , new york , 1979 .",
    "fiol , a boolean algebra approach to the construction of snarks , in _ graph theory , combinatorics and applications _ , vol .",
    "y. alavi , g. chartrand , o.r .",
    "oellermann , and a.j .",
    "schwenk ) john wiley & sons ( 1991 ) 493524 .",
    "fiorini , s. , wilson , r.j .",
    "edge - colouring of graphs_. pitman , 1977 . m. gardner , mathematical games : snarks , boojums and other conjectures related to the four - color - map theorem , _ sci .",
    "* 234 * ( 1976 ) 126130 .",
    "i. holyer , the @xmath1-completeness of edge - colouring , _ siam j. comput . _",
    "* 10 * ( 1981 ) 718720 .",
    "r. isaacs , infinite families of nontrivial trivalent graphs which are not tait colorable , _ am .",
    "monthly _ * 82 * ( 1975 ) no .",
    "3 , 221239 . t.t .",
    "lee , y. wan , h. guan , randomized @xmath0-edge - coloring via quaternion of complex colors ( extended abstract ) , _ arxiv:1104.1852v1 [ cs.ds ] _ ( 2011 ) .",
    "robinson , n.c .",
    "wormald , almost all cubic graphs are hamiltonian , _ random struct . &",
    "alg . _ * 5 * ( 1994 ) 363374 .",
    "doi : 10.1002/rsa.3240050209"
  ],
  "abstract_text": [
    "<S> a simple but empirically efficient heuristic algorithm for the edge - coloring of graphs is presented . </S>",
    "<S> its basic idea is the displacement of  conflicts \" ( repeated colors in the edges incident to a vertex ) along paths of adjacent vertices whose incident edges are recolored by swapping alternating colors ( that is , doing a kempe interchange ) . </S>",
    "<S> the results of performance tests on random cubic and @xmath0-regular graphs are presented , and a full implementation of the algorithm is given to facilitate its use and the reproducibility of results . </S>"
  ]
}