{
  "article_text": [
    "h - pilot ( hierarchical proving by instantiation in local theory extensions ) is an implementation of the method for hierarchical reasoning in local theory extensions presented in @xcite : it reduces the task of checking the satisfiability of a ( ground ) formula over the extension of a theory with additional function symbols subject to certain axioms ( a set of clauses ) to the task of checking the satisfiability of a formula over the base theory .",
    "the idea is to replace the set of clauses which axiomatize the properties of the extension functions by a finite set of instances thereof .",
    "this reduction is polynomial in the size of the initial set of clauses and is always sound .",
    "it is complete in the case of so - called _ local extensions _",
    "@xcite ; in this case , it provides a decision procedure for validity for the universal fragment of the theory extension ( or alternatively for satisfiability of ground clauses w.r.t .  the theory extension ) if the clauses obtained by the hierarchical reduction belong to a fragment for which satisfiability is decidable in the base theory .",
    "the satisfiability of the reduced set of clauses is then checked with a specialized prover for the base theory .",
    "state of the art smt provers such as cvc3 @xcite , yices @xcite and z3 are very efficient for testing the satisfiability of _ ground formulae _ over standard theories , but use heuristics in the presence of _ universally quantified _ formulae , hence can not detect _ satisfiability _ of such formulae .",
    "h - pilot recognizes a class of local axiomatizations , performs the instantiation and hands in a ground problem to the smt provers or other specialized provers , for which they are know to terminate with a yes / no answer , so it can be used as a tool for steering standard smt provers , in order to provide decision procedures in the case of local theory extensions .",
    "h - pilot can also be used for generating models of satisfiable formulae ; and even more , it can be coupled to programs with graphic facilities to provide graphical representations of these models .",
    "being a decision procedure for many theories important in verification , h - pilot is extremely helpful for deciding truth or satisfiability in a large variety of verification problems .",
    "this is an extended version of the description of h - pilot presented at cade 22 @xcite .",
    "many problems in mathematics and computer science can be reduced to proving the satisfiability of conjunctions of literals in a background theory ( which can be the extension of a base theory with additional functions ",
    "e.g. , free , monotone , or recursively defined  or a combination of theories ) .",
    "considerable work has been dedicated to the task of identifying situations where reasoning in extensions and combinations of theories can be done efficiently and accurately .",
    "the most important issues which need to be addressed in this context are :    * finding possibilities of reducing the search space without losing completeness , and * making modular or hierarchical reasoning possible .    in @xcite , givan and mcallester introduced and studied the so - called `` local inference systems '' , for which validity of ground horn clauses can be checked in polynomial time . a link between this",
    "proof theoretic notion of locality and algebraic arguments used for identifying classes of algebras with a word problem decidable in ptime @xcite was established in @xcite . in @xcite",
    "these results were further extended to so - called _ local extensions _ of theories .",
    "locality phenomena were also studied in the verification literature , mainly motivated by the necessity of devising methods for efficient reasoning in theories of pointer structures @xcite and arrays @xcite .",
    "in @xcite we showed that these results are instances of a general concept of locality of a theory extension ",
    "parameterized by a closure operator on ground terms .",
    "the main idea of locality and local extensions is to limit the search space for counterexamples ( hence the name ) .",
    "we consider the following setup .",
    "let @xmath0 be a theory in some signature @xmath1 .",
    "we consider extensions @xmath2 of @xmath0 with function symbols in a set @xmath3 ( extension functions ) whose properties are axiomatized by a set @xmath4 of ( universally closed ) @xmath5-clauses .",
    "let @xmath6 be an additional set of constants .",
    "* let @xmath7 be a set of ground @xmath8-clauses .",
    "we want to check whether or not @xmath7 is satisfiable w.r.t .",
    "@xmath9 .    * method .",
    "* let @xmath10 $ ] be the set of those instances of @xmath4 in which every subterm starting with an extension function is a ground subterm already appearing in @xmath4 or @xmath7 . if @xmath7 is unsatisfiable w.r.t .",
    "@xmath11 $ ] then it is also unsatisfiable w.r.t .",
    "the converse is not necessarily true .",
    "we say that the extension @xmath9 of @xmath0 is _ local _ if it satisfies the following condition :    = @xmath13 = for every set @xmath7 of ground @xmath8-clauses it holds that + @xmath14 if and only if @xmath15 \\cup g \\models \\bot.$ ]    thus , the method is sound and complete for _ local theory extensions_.    assume that the extension @xmath16 is local and let @xmath7 be a set of ground clauses .",
    "let @xmath17 be the purified form of @xmath18 obtained by introducing fresh constants for the @xmath3-terms , adding their definitions @xmath19 to @xmath20 , and replacing @xmath21 in @xmath7 and @xmath10 $ ] by @xmath22 .",
    "( then @xmath3-functions occur only in @xmath20 in unit clauses of the form @xmath19 . )",
    "the following are equivalent .    1 .",
    "@xmath23 has a ( total ) model .",
    "2 .   @xmath24 \\cup g$ ] has a partial model where all subterms of @xmath4 and @xmath7 and all @xmath1-functions are defined .",
    "3 .   @xmath25 has a total model , where + @xmath26 .",
    "[ th - reduction ]    a variant of this notion , namely @xmath27-locality , was also studied , where the set of instances to be taken into account is @xmath28 $ ] , where @xmath27 is a closure operator which may add a ( finite ) number of new terms to the subterms of @xmath7 .",
    "we also analyzed a generalized version of locality , in which the clauses in @xmath29 and the set @xmath7 of ground clauses are allowed to contain first - order @xmath1-formulae .      among the theory extensions which we proved to be local or @xmath27-local in previous work",
    "are :    * a fragment of the theory of pointers with stored scalar information in the nodes introduced in @xcite , further analyzed in @xcite ; * a fragment of the theory of arrays with integer indices , and elements in a given theory introduced in @xcite , further analyzed in @xcite ; * theories of functions over an ordered domain or over a numerical domain satisfying monotonicity or boundedness conditions @xcite ; * various combinations of such extensions @xcite .",
    "we can also consider successive extensions of theories : @xmath30 .",
    "if every variable in @xmath31 occurs below a function symbol in @xmath32 , this reduction process can be iterated @xcite .    for local theory extensions ,",
    "theorem  [ th - reduction ] allows us to reduce the original problem to a satisfiability problem over the base theory @xmath33 .",
    "the software system ( hierarchical proving by instantiation in local theory extensions ) for hierarchical reasoning in local theory extensions is implemented as follows : a given proof task ( set of ground clauses ) , over the extension of a theory with functions axiomatized by a set of clauses , is reduced to an equi - satisfiable ground problem over the base theory in the manner of theorem  [ th - reduction ] .",
    "after has carried out this reduction , it hands over the transformed problem to a dedicated prover for the base theory .",
    "this reduction is always sound .",
    "for local theory extensions the hierarchical reduction is sound and complete .",
    "if the formulas obtained in this way belong to a fragment decidable in the base theory , h - pilot provides a decision procedure for testing satisfiability of ground formulas . if the reduced formulas are satisfiable ( modulo the base theory ) , can be used for model generation , which is of great help in detecting and localizing errors .      h - pilot is implemented in ocaml .",
    "the system , together with a manual and examples , can be downloaded from www.mpi - inf.mpg.de/~ihlemann / software/. there is both a 32-bit and a 64-bit linux version available . to improve user - friendliness ,",
    "a clausifier has also been integrated into ( sect .",
    "[ sec - clausification ] ) .",
    "h - pilot recognizes a class of local axiomatizations ; it has advanced abilities to handle the common data structures of _ arrays _ ( sect .",
    "[ sec - arrays ] ) and _ pointers _ ( sect .",
    "[ sec - pointers ] ) .",
    "h - pilot performs the instantiation and hands in a ground problem to the smt provers or other specialized provers , for which they are known to terminate with a yes / no answer , so it can be used as a tool for steering standard smt provers , in order to provide decision procedures in the case of local extensions .",
    "the provers integrated with are the general - purpose prover spass ( @xcite ) ; the smt - solvers yices ( @xcite ) , cvc3 ( @xcite ) and z3 ( @xcite ) ; and the prover redlog ( @xcite ) for non - linear real problems .",
    "state - of - the - art smt provers , such as the ones above , are very efficient for testing the satisfiability of ground formulas over standard theories , such as linear arithmetic ( real , rational or integer ) , but use heuristics in the presence of universally quantified formulas , hence , can not reliably detect satisfiability of such formulas . however ,",
    "if smt solvers are used for finding software bugs , being able to detect the actual satisfiability of satisfiable sets of formulas is crucial ( cf .  ) .",
    "for local theory extensions , offers the possibility of detecting satisfiability and of constructing models for satisfiable sets of clauses . on request , provides an extensive step - by - step trace of the reduction process , making its results verifiable ( sect .",
    "[ sec - run ] ) .     has been used in large case studies , where its ability ( 1 ) to handle _ chains _ of extensions , ( 2 ) to detect unsatisfiability _ and _ satisfiability , and ( 3 ) to construct models of satisfiable sets of clauses has been crucial .      the main algorithm",
    "which hierarchically reduces a decision problem in a theory extension to a decision problem in the base theory can be divided into a preprocessing part , the main loop and a post - processing part ; see figure [ fig : struct ] .",
    "r.4     * preprocessing . *",
    "the input is read and parsed .",
    "if it is detected to be in smt format , we set the options to `` use arithmetic '' ( e.g. , @xmath34 , @xmath35 , ... are predefined )",
    ". if the input is not in clause normal form ( cnf ) , it is translated to cnf , then the input is flattened and linearized . the program",
    "then checks if the clauses in the axiomatization given are local extensions and sets the flag ` -local ` to true / false .",
    "this ends the preprocessing phase .",
    "* main algorithm . * the main loop proceeds as follows : we consider chains of extensions @xmath36 , where @xmath37 of @xmath33 with function symbols in a set @xmath32 ( extension functions ) whose properties are axiomatized by a set @xmath38 of @xmath39-clauses .",
    "let @xmath40 .",
    "as long as the extension level @xmath41 is greater than @xmath42 , we compute @xmath43 $ ] ( @xmath44 $ ] for arrays ) . if no separation of the extension symbols is required , we stop here ( the result will be passed to an external prover that can reason about the extension of the theory @xmath33 with free function symbols in @xmath45 ) .",
    "otherwise , we perform the hierarchical reduction by purifying @xmath38 and @xmath7 ( to @xmath46 , @xmath47 respectively ) and by adding corresponding instances of the congruence axioms @xmath48 . to prepare for the next iteration",
    ", we transform the clauses into the form @xmath49 ( compute prenex form , skolemize ) . if @xmath43 $ ] ( @xmath50 ) is not ground , we quit with a corresponding message .",
    "otherwise we set @xmath51 and @xmath52 .",
    "we flatten and linearize @xmath53 and decrease @xmath41 .",
    "if level @xmath54 is reached @xmath55 is handed to an external prover .",
    "* post - processing .",
    "* if the answer is `` unsatisfiable '' then @xmath56 . if the answer is `` satisfiable '' and all extensions were local , then @xmath7 is satisfiable w.r.t .",
    "@xmath57 and we know how to build a model .",
    "if the answer is satisfiable but we do not know that all extensions are local , or if the instantiated clauses ( of level @xmath58 ) were not ground , we answer `` unknown '' .",
    "we present the different parts of in more detail .",
    "h - pilot receives as input a many - sorted specification of the signature ; a specification of the hierarchy of local extensions to be considered ; an axiomatization @xmath59 of the theory extension(s ) ; a set @xmath7 of ground clauses containing possibly additional constants .",
    "h - pilot allows the following preprocessing functionality .",
    "* translation to clause form . *",
    "h - pilot provides a translator to clause normal form ( cnf ) for ease of use .",
    "first - order formulas can be given as input ; translates them into cnf . in the present implementation",
    ", the cnf translator does not provide the full functionality of flotter ( @xcite )  it has only restricted subformula renaming  but is powerful enough for most applications .",
    "* flattening / linearization . * methods for recognizing local theory extensions usually require that the clauses in the set @xmath4 extending the base theory are _ flat _ and _ linear _ , which does nothing to improve readability . if the flags -linearize and/or",
    "-flatten are used then the input is flattened and/or linearized ( the general purpose flag -preprocess may also be used ) .",
    "h - pilot allows the user to enter a more intelligible non - flattened version and will perform the flattening and linearization of @xmath4 .    *",
    "recognizing syntactic criteria which imply locality .",
    "* examples of local extensions include ( fragments of ) the theories of the common data structures : the theory of arrays ( see section  [ sec - arrays ] ) and the theory of pointers ( see section  [ sec - pointers ] ) , respectively ( and also iterations and combinations thereof ) . in the preprocessing phase h - pilot",
    "analyzes the input clauses to check whether they are in one of these fragments .    *",
    "if the flag -array is on , checks if the input is in the `` array property fragment '' .",
    "* if the keyword `` pointer '' is detected , checks if the input is in the appropriate pointer fragment and adds missing `` nullability '' terms , i.e. , it adds premises of the form `` @xmath60 '' , in order to relieve the user of this clerical labor .",
    "if the answer is `` yes '' then we know that the extensions we consider are local , i.e. , that h - pilot can be used as a decision procedure .      the main algorithm hierarchically reduces a decision problem in a theory extension to a decision problem in the base theory .    given a set of clauses @xmath4 and a set of ground clauses @xmath7 , the algorithm we use carries out a hierarchical reduction of @xmath7 to a set of formulas in the base theory .",
    "it then hands over the new problem to a dedicated prover such as yices , cvc3 or z3 .",
    "h - pilot is also coupled with redlog ( for handling non - linear real arithmetic ) and with spass .    r.4   [ fig : hierarchy ]    * loop .",
    "* for a chain of local extensions : @xmath61 a satisfiability check w.r.t .",
    "the last extension can be reduced ( in @xmath62 steps ) to a satisfiability check w.r.t .",
    "the only caveat is that at each step the reduced clauses @xmath63 need to be ground .",
    "groundness is assured if each variable in a clause appears at least once under an extension function . in that case",
    ", we know that at each reduction step the total clause size only grows polynomially in the size of @xmath7 ( @xcite ) .",
    "h - pilot  allows the user to specify a chain of extensions by tagging the extension functions with their place in the chain ( e.g. , if @xmath64 belongs to @xmath65 but not to @xmath66 it is declared as level 3 )",
    ".    let @xmath40 .",
    "as long as the extension level @xmath41 is larger than @xmath42 , we compute @xmath43 $ ] ( @xmath67 $ ] in case of arrays ) . if no separation of the extension symbols is required , we stop here ( the result will be passed to an external prover ) .",
    "otherwise , we perform a hierarchical reduction by purifying @xmath38 and @xmath7 ( to @xmath68 respectively ) and by adding corresponding instances of the congruence axioms @xmath48 . to prepare for the next iteration",
    ", we transform the clauses into the form @xmath69 ( compute prenex form , skolemize ) .",
    "if @xmath43 / { { \\mathcal k}}_i^0 $ ] is not ground , we quit with a corresponding message .",
    "otherwise our new proof task @xmath55 becomes @xmath70 , our new extension clauses are @xmath71 and our new base theory becomes @xmath72 .",
    "we flatten and linearize @xmath53 and decrease @xmath41 .",
    "if level @xmath54 is reached , we exit the main loop and @xmath55 is handed to an external prover .",
    "completeness is guaranteed if all extensions are known to be local and if each reduction step produces a set of ground clauses for the next step .",
    "depending on the answer of the external provers to the satisfiability problem @xmath73 , we can infer whether the initial set @xmath7 of clauses was satisfiable or not .",
    "* if @xmath73 is unsatisfiable w.r.t .",
    "@xmath33 then we know that @xmath7 is unsatisfiable .",
    "* if @xmath73 is satisfiable , but h - pilot failed to detect this , and the user did not assert the locality of the sets of clauses used in the axiomatization , its answer is `` unknown '' . * if @xmath73 is satisfiable and h - pilot detected the locality of the axiomatization , then the answer is `` satisfiable '' . in this case , h - pilot takes advantage of the ability of smt - solvers to provide counterexamples for the satisfiable set @xmath73 of ground clauses and specifies a counterexample of @xmath7 by translating the basic smt - model of the reduced proof task to a model of the original proof task .",
    "this improves readability greatly , especially when we have a chain of extensions .",
    "the counterexamples can be graphically displayed using mathematica ( cf .",
    "section  [ sec - model - generation ] ) .",
    "this is currently done separately ; an integration with mathematica is planned for the future .",
    "the input file consists of a _ declaration _ part ( for function symbols in the base theory , for extension functions , for relations , and constants ) , specifications of the _ types _ and of the base theory , a part containing _ axiomatizations _ of base theory / extension functions ; and a part containing the set of _ ground clauses _ whose satisfiability is being checked .",
    "@xmath74_start_@xmath75 : : = @xmath74_base_functions_@xmath75 @xmath74_extension_functions_@xmath75 @xmath74_relations_@xmath75 @xmath74_constants_@xmath75 @xmath74_interval_@xmath75 + @xmath74_basetheory_@xmath75 @xmath74_formulasorclauses_@xmath75 @xmath74_groundformulas_@xmath75 @xmath74_query_@xmath75      * type declarations : * we allow for declarations of standard types :    @xmath74_domain_@xmath75 = : : = bool @xmath76int @xmath76real @xmath76pointer @xmath76pointer # @xmath74_int_@xmath75 + @xmath76scalar @xmath76free @xmath76free # @xmath74_int_@xmath75    declarations of simple types such as intervals are also allowed :    @xmath74_interval_@xmath75 = : : = @xmath77@xmath78 + @xmath76interval : = @xmath74_int_@xmath75 @xmath74_sm_@xmath75 @xmath74_identifier_@xmath75 ; + @xmath76interval : = @xmath74_identifier_@xmath75 @xmath74_sm_@xmath75 @xmath74_int_@xmath75 ; + @xmath76interval : = @xmath74_int_@xmath75 @xmath74_sm_@xmath75 @xmath74_identifier_@xmath75 @xmath74_sm_@xmath75 @xmath74_int_@xmath75 ;    @xmath74_int_@xmath75 : : = _ any non - negative number . _",
    "@xmath74_sm_@xmath75 : : = < = @xmath76 <    further details are given in section  [ types ] .",
    "* function and relation declarations . *",
    "the declaration part contains sort and type declarations for the function symbols in the base theory , for the extension function symbols , for the relation symbols and for the constants :    @xmath74_base_functions_@xmath75 : : = base_functions : = \\ { @xmath74_function_list_@xmath75 }",
    "@xmath74_extension_functions_@xmath75 : : = extension_functions : = \\ { @xmath74_function_list_@xmath75 }",
    "@xmath74_relations_@xmath75 : : = relations : = \\ { @xmath74_relation_list_@xmath75 }    @xmath74_constants_@xmath75 : : = @xmath78@xmath76constants : = \\ { constant_list }    @xmath74_constant_list_@xmath75 : : = @xmath74_constant_@xmath75 @xmath74_additional_constants_@xmath75    @xmath74_additional_constants_@xmath75 : : = @xmath78@xmath76 , @xmath74_constant_@xmath75 @xmath74_additional_constant_@xmath75    @xmath74_constant_@xmath75 = : : = ( @xmath74_identifier_@xmath75 , bool ) + @xmath76 ( @xmath74_identifier_@xmath75 , int ) + @xmath76 ( @xmath74_identifier_@xmath75 , real ) + @xmath76 ( @xmath74_identifier_@xmath75 , scalar ) + @xmath76 ( @xmath74_identifier_@xmath75 , pointer ) + @xmath76 ( @xmath74_identifier_@xmath75 , pointer # @xmath74_int_@xmath75 ) + @xmath76 ( @xmath74_identifier_@xmath75 , free ) + @xmath76 ( @xmath74_identifier_@xmath75 , free # @xmath74_int_@xmath75 )    @xmath74_function_list_@xmath75 : : = @xmath78@xmath76@xmath74_function_@xmath75 @xmath74_additional_functions_@xmath75    @xmath74_additional_functions_@xmath75 : : = @xmath78@xmath76 , @xmath74_function_@xmath75 @xmath74_additional_functions_@xmath75    @xmath74_relation_list_@xmath75 : : = @xmath78@xmath76@xmath74_relation_@xmath75 @xmath74_additional_relations_@xmath75    @xmath74_additional_relations_@xmath75 : : = @xmath78@xmath76 , @xmath74_relation_@xmath75 @xmath74_additional_relations_@xmath75    we allow for predefined relation declarations ( e.g.  for relations such as @xmath79 or @xmath80 as well as for new relation declarations . in each case we specify together with the relation symbols also their arity .    @xmath74_relation_@xmath75",
    ": : = ( @xmath74_uneqs_@xmath75 , @xmath74_int_@xmath75 ) @xmath76 ( @xmath74_identifier_@xmath75 , @xmath74_int_@xmath75 )    we allow for several forms of function declaration : we can declare the number of arguments of the function ( ( 1),(2 ) ) ; the number of arguments and the level ( for predefined arithmetical operations over the integers ( 3 ) , or reals ( 4 ) or for uninterpreted functions ( 5 ) ) ; the number of arguments , the level , and the sort of the domain and codomain ( without repetitions if the domain and codomain are the same ( 6 ) ; separately specified if they are different ( 7 ) ) .    @xmath74_function_@xmath75 = : : = ( @xmath74_identifier_@xmath75 , @xmath74_int_@xmath75 )   = ( 1 ) + @xmath76 ( @xmath74_arithop_@xmath75 , @xmath74_int_@xmath75 ) ( 2 ) + @xmath76 ( @xmath74_arithop_@xmath75 , @xmath74_int_@xmath75 , @xmath74_int_@xmath75 , int ) ( 3 ) + @xmath76 ( @xmath74_arithop_@xmath75 , @xmath74_int_@xmath75 , @xmath74_int_@xmath75 , real ) ( 4 ) + @xmath76 ( @xmath74_identifier_@xmath75 , @xmath74_int_@xmath75 , @xmath74_int_@xmath75 ) ( 5 ) + @xmath76 ( @xmath74_identifier_@xmath75 , @xmath74_int_@xmath75 , @xmath74_int_@xmath75 , @xmath74_domain_@xmath75 ) ( 6 ) + @xmath76 ( @xmath74_identifier_@xmath75 , @xmath74_int_@xmath75 , @xmath74_int_@xmath75 , @xmath74_domain_@xmath75 , @xmath74_domain_@xmath75 ) ( 7 )    at the moment declarations of functions which accept arguments of different sorts are not supported .",
    "we support axiomatizations for the base theory :    @xmath74_base_theory_@xmath75 : : = @xmath78@xmath76base : = @xmath74_clause_list_@xmath75    axiomatizations of the properties of the extension functions :    @xmath74_formulasorclauses_@xmath75 : : = @xmath78 @xmath76@xmath74_formulas_@xmath75 @xmath76@xmath74_clauses_@xmath75 + @xmath76@xmath74_formulas_@xmath75@xmath74_clauses_@xmath75 @xmath76@xmath74_clauses_@xmath75@xmath74_formulas_@xmath75    as well as input of the ground formulae whose ( un)satisfiability is being checked :    @xmath74_formulas_@xmath75 : : = formulas : = @xmath74_formula_list_@xmath75    @xmath74_formula_list_@xmath75 : : = @xmath74_formula_@xmath75 @xmath76@xmath74_formula_@xmath75 ; @xmath74_additional_formulas_@xmath75    @xmath74_additional_formulas_@xmath75 : : = @xmath78@xmath76@xmath74_formula_@xmath75 ; @xmath74_additional_formulas_@xmath75    @xmath74_formula_@xmath75 = : : = @xmath74_atom_@xmath75 + @xmath76not ( @xmath74_formula_@xmath75 ) + @xmath76or ( @xmath74_formula_@xmath75 @xmath74_formula_plus_@xmath75 ) + @xmath76and ( @xmath74_formula_@xmath75 @xmath74_formula_plus_@xmath75 ) + @xmath76 ( @xmath74_formula_@xmath75  > @xmath74_formula_@xmath75 ) + @xmath76 ( @xmath74_formula_@xmath75 @xmath74_formula_@xmath75 ) + @xmath76 ( forall @xmath74_variables_@xmath75 ) .",
    "@xmath74_formula_@xmath75 + @xmath76 ( exists @xmath74_variables_@xmath75 ) .",
    "@xmath74_formula_@xmath75    @xmath74_formula_plus_@xmath75 : : = , @xmath74_formula_@xmath75 @xmath74_formula_star_@xmath75    @xmath74_formula_star_@xmath75 : : = @xmath78 @xmath76 , @xmath74_formula_@xmath75 @xmath74_formula_star_@xmath75    @xmath74_ground_formulas_@xmath75 : : = @xmath78 @xmath76ground_formulas : = @xmath74_formula_list_@xmath75    @xmath74_query_@xmath75 : : = query : = @xmath74_ground_clauses_@xmath75    @xmath74_clauses_@xmath75 : : = clauses : = @xmath74_clause_list_@xmath75    @xmath74_base_clause_list_@xmath75 : : = @xmath78@xmath76@xmath74_clause_@xmath75 ; @xmath74_additional_base_clauses_@xmath75    @xmath74_additional_base_clauses_@xmath75 : : = @xmath78@xmath76@xmath74_base_clause_@xmath75 ; @xmath74_additional_base_clauses_@xmath75    @xmath74_base_clause_@xmath75 : : = @xmath74_clausematrix_@xmath75 @xmath76@xmath74_universalquantifier_@xmath75 @xmath74_clausematrix_@xmath75    @xmath74_clause_list_@xmath75 : : = @xmath74_clause_@xmath75 @xmath76@xmath74_clause_@xmath75 ; @xmath74_additional_clauses_@xmath75    @xmath74_additional_clauses_@xmath75 : : = @xmath78 @xmath76@xmath74_clause_@xmath75 ; @xmath74_additional_clauses_@xmath75    @xmath74_clause_@xmath75 = : : = @xmath74_clausematrix_@xmath75 + @xmath76@xmath74_universalquantifier_@xmath75 @xmath74_clausematrix_@xmath75 + @xmath76\\ { @xmath74_formula_@xmath75 } or @xmath74_clausematrix_@xmath75 + @xmath76@xmath74_universalquantifier_@xmath75 \\ { @xmath74_formula_@xmath75 } or @xmath74_clausematrix_@xmath75 + @xmath76\\ { @xmath74_formula_@xmath75 }  > @xmath74_clausematrix_@xmath75 + @xmath76@xmath74_universalquantifier_@xmath75 \\ { @xmath74_formula_@xmath75 } ",
    "@xmath74_clausematrix_@xmath75    @xmath74_universalquantifier_@xmath75 : : = ( forall @xmath74_variables_@xmath75 ) .",
    "@xmath74_variables_@xmath75 : : = @xmath74_name_@xmath75 @xmath74_additional_variable_@xmath75    @xmath74_additional_variables_@xmath75 : : = @xmath78@xmath76 , @xmath74_name_@xmath75 @xmath74_additional_variables_@xmath75    @xmath74_ground_clauses_@xmath75 : : = @xmath78 @xmath76@xmath74_clausematrix_@xmath75 ; @xmath74_ground_clauses_@xmath75    @xmath74_clausematrix_@xmath75 : : = @xmath74_literal_@xmath75 @xmath76@xmath74_disjunctive_clause_@xmath75 @xmath76@xmath74_sorted_clause_@xmath75    @xmath74_disjunctive_clause_@xmath75 : : = or ( @xmath74_literal_@xmath75 @xmath74_literal_plus_@xmath75 )    @xmath74_literal_plus_@xmath75 : : = , @xmath74_literal_@xmath75 @xmath74_literal_star_@xmath75    @xmath74_literal_star_@xmath75 : : = @xmath78 @xmath76 , @xmath74_literal_@xmath75 @xmath74_literal_star_@xmath75    @xmath74_sorted_clause_@xmath75 : : = @xmath74_atom_list_@xmath75 ",
    "@xmath74_atom_list_@xmath75    @xmath74_atom_list_@xmath75 : : = @xmath78@xmath76@xmath74_atom_@xmath75 @xmath74_atom_star_@xmath75    @xmath74_atom_star_@xmath75 : : = @xmath78@xmath76 , @xmath74_atom_@xmath75 @xmath74_atom_star_@xmath75    @xmath74_literal_@xmath75 : : = @xmath74_atom_@xmath75 @xmath76not ( @xmath74_atom_@xmath75 )    @xmath74_atom_@xmath75 : : = @xmath74_equality_atom_@xmath75 @xmath76@xmath74_ineq_atom_@xmath75 @xmath76@xmath74_predicate_atom_@xmath75    @xmath74_equality_atom_@xmath75 : : = @xmath74_term_@xmath75 = @xmath74_term_@xmath75    @xmath74_ineq_atom_@xmath75 : : = @xmath74_term_@xmath75 @xmath74_uneqs_@xmath75 @xmath74_term_@xmath75    @xmath74_predicate_atom_@xmath75 : : = @xmath74_identifier_@xmath75 [ @xmath74_term_@xmath75 @xmath74_additional_terms_@xmath75 ]    @xmath74_arguments_@xmath75 : : = @xmath74_term_@xmath75 @xmath74_additional_terms_@xmath75    @xmath74_additional_terms_@xmath75 : : = @xmath78@xmath76 , @xmath74_term_@xmath75 @xmath74_additional_terms_@xmath75    @xmath74_term_@xmath75 = : : = @xmath74_name_@xmath75 + @xmath76@xmath74_operator_@xmath75 ( @xmath74_arguments_@xmath75 ) + @xmath76@xmath74_array_@xmath75 ( @xmath74_arguments_@xmath75 ) + @xmath76@xmath74_update_@xmath75 ( @xmath74_arguments_@xmath75 ) + @xmath76@xmath74_term_arith_@xmath75 @xmath74_arithop_@xmath75 @xmath74_term_arith_@xmath75    @xmath74_term_arith_@xmath75 = : : = @xmath74_name_@xmath75 + @xmath76@xmath74_operator_@xmath75 ( @xmath74_arguments_@xmath75 ) + @xmath76 ( @xmath74_term_arith_@xmath75 @xmath74_arithop_@xmath75 @xmath74_term_arith_@xmath75 )    @xmath74_arithop_@xmath75 : : = + @xmath76- @xmath76 @xmath76/    @xmath74_uneqs_@xmath75 : : = < = @xmath76>= @xmath76 < @xmath76 >    @xmath74_operator_@xmath75 : : = @xmath74_identifier_@xmath75    @xmath74_array:_@xmath75 = : : = write ( @xmath74_identifier_@xmath75 , @xmath74_term_@xmath75 , @xmath74_term_@xmath75 ) + @xmath76write ( @xmath74_array_@xmath75 , @xmath74_term_@xmath75 , @xmath74_term_@xmath75 )    @xmath74_update_@xmath75 = : : = update ( @xmath74_identifier_@xmath75 , @xmath74_term_@xmath75 , @xmath74_term_@xmath75 ) + @xmath76update ( @xmath74_update_@xmath75 , @xmath74_term_@xmath75 , @xmath74_term_@xmath75 )    @xmath74_name_@xmath75 : : = @xmath74_identifier_@xmath75    @xmath74_identifier_@xmath75 : : = _ any string consisting of letters and numbers starting with a letter . _ +",
    "has several input parameters controlling its behavior .",
    "they can be listed by calling ` hpilot.opt -help ` .    [ cols= \" < , < \" , ]",
    "in @xcite we used h - pilot for verifying the correctness of the controller of a system of trains moving on a linear track . in @xcite , h - pilot s ability to decide the pointer fragment of section  [ sec - pointers ] has been used in the verification of real - time systems which exhibit rich and dynamic data structures .",
    "there h - pilot was part of a tool chain employed for the verification of a case study from the european train control system standard , describing the controller of a system of trains moving on a rail track with complex topology  modeled using two - sorted pointer structures .",
    "the tool chain received as input a high level specification and a formula ( a safety property ) , and generated proof obligations , which were automatically verified using h - pilot ( with yices ) .",
    "the verification problem we considered are expressed as satisfiability problems for universally quantified formulas , hence can not be solved by smt - solvers alone .",
    "the experimental results show h - pilot to be a very efficient tool for the discharging of all the proof tasks of the case study .",
    "the full type system implemented in increased the efficiency considerably by blocking unnecessary instantiations .",
    "the tool chain used in the case study range from a specification language for real - time systems called cod to the translation of such a specification via phase - event automata ( syspect / pea ) to transition constraint systems ( tcs ) which can then be exported to h - pilot .",
    "the invariant for every transition in the tcs was checked .    since the invariant was too complex to be handled by the clausifier of we checked the invariant for every transition in two parts yielding 92 proof obligations .",
    "further , we performed tests to ensure that the specifications are consistent .",
    "the time to compute the tcs from the specification was insignificant .",
    "the overall time to verify all transition updates with yices and in the unsatisfiable case ( when the invariant is correct ) does not differ much .",
    "there is one example ",
    "the speed update  on which was 5 times faster than yices alone .",
    "we also made tests with the verification of a set of conditions which was not inductive over all transitions . here",
    ", was able to provide a model after 8s whereas yices detected unsatisfiability for 17 problems , returned `` unknown '' for 28 , and timed out once . for",
    "the consistency check was able to provide a model after 3s , whereas yices answered `` unknown '' .    during the development of the case study helped us finding the correct transition invariants by providing models for satisfiable sets of clauses ( occurring when the safety formulae were not invariant under transitions ) .",
    "the arrays @xmath81 and @xmath82 are considered to be equal between the constants @xmath83 and @xmath84 .",
    "we prove that if we update @xmath81 at @xmath85 to @xmath86 then @xmath81 and @xmath82 should be equal between @xmath83 and @xmath85 .",
    "the formula above denies this and should therefore be inconsistent .",
    "we call h - pilot with      ` -preprocess ` is needed as usual ; we use ` -prclauses ` to get a trace of the program .",
    "( because the array keyword ` write ` appears in the input we do nt have to use the flag ` -arrays ` : it is implicit . )",
    "the trace looks as follows ( to improve readability we aligned the level labels and often left out the listing of the extension ground terms due to space constraints ) .",
    "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * starting hpilot * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * arrays_from_book.loc adding formula : and ( ( forall i ) .",
    "( and ( l < = i , i < = u )  > a(i ) = b(i ) ) , not((forall i ) . ( and ( l",
    "< = i , i < = + ( u , _ 1 ) )  > read(write(a , + ( u , _ 1),b(+(u , _ 1 ) ) ) , i ) = b(i ) ) ) ) done .",
    "clausifying formulas ... ( forall z_1 ) . or ( not(l",
    "< = z_1 ) , not(z_1 < = u ) ,",
    "a(z_1 ) = b(z_1 ) ) l",
    "sk_1 < = + ( u , _ 1 ) not(read(write(a , + ( u , _ 1 ) , b(+(u , _ 1 ) ) ) , sk_1 ) = b(sk_1 ) ) yielding 4 new clauses : read(write(a , + ( u , _ 1 ) , b(+(u , _ 1 ) ) ) , sk_1 ) = b(sk_1 )  >",
    "l : 0 ; extension ground terms : b(sk_1 ) , b(+(u , _ 1 ) )  >",
    "sk_1 < = + ( u , _ 1 ) l : 0 ; extension ground terms : ",
    "> l < = sk_1 l : 0 ; extension ground terms : [ z_1 ] l",
    "z_1 < = u  > a(z_1 ) = b(z_1 )",
    "l : 0 ; extension ground terms :      replacing writes ... we have 1 levels .",
    "our base theory is : empty .",
    "splitting clause [ i ]  >",
    "i = + ( u , _ 1 ) , a_w1(i ) = a(i )",
    "l : 1 ; terms : on eq i = + ( u , _",
    "1 ) checking apf for clause [ i ] i < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(i ) = a(i ) l : 0 ; extension ground terms :  >",
    "true checking apf for clause [ i ] + ( + ( u , _ 1 ) , _ 1 ) < = i ",
    "> a_w1(i ) = a(i )",
    "l : 0 ; extension ground terms : ",
    "> true checking apf for clause [ z_1 ] l < = z_1 ,",
    "z_1 < = u  > a(z_1 ) = b(z_1 )",
    "l : 1 ; extension ground terms : ",
    "> true recalculating all levels .      after rewriting we have as clauses",
    "k : [ i , x_1 ] x_1 = i ,",
    "i < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(i ) = a(x_1 ) l : 1 ; extension ground terms : [ i , x_1 ] x_1 = i , + ( + ( u , _ 1 ) , _ 1 ) < = i ",
    "> a_w1(i ) = a(x_1 ) l : 1 ; extension ground terms : [ z_1 , x_1 ] x_1 = z_1 , l < = z_1 , z_1 < = u  > a(z_1 ) = b(x_1 )",
    "l : 1 ; extension ground terms : and as query : ",
    "< = sk_1 l : 0 ; extension ground terms :  > sk_1",
    "< = + ( u , _ 1 ) l : 0 ; extension ground terms : a_w1(sk_1 ) = b(sk_1 )  >",
    "l : 1 ; extension ground terms : a_w1(sk_1 ) , b(sk_1 )  >",
    "a_w1(+(u , _ 1 ) ) = b(+(u , _ 1 ) ) l : 1 ; extension ground terms : a_w1(+(u , _ 1)),b(+(u , _ 1 ) )",
    "our query g is : ",
    "> l < = sk_1 l : 0 ; extension ground terms :  >",
    "sk_1 < = + ( u , _ 1 ) l : 0 ; extension ground terms : a_w1(sk_1 ) = b(sk_1 )  >",
    "l : 1 ; extension ground terms : a_w1(sk_1 ) , b(sk_1 )  >",
    "a_w1(+(u , _ 1 ) ) = b(+(u , _ 1 ) ) l : 1 ; extension ground terms : a_w1(+(u , _ 1)),b(+(u , _ 1 ) ) xxxxxxxxxxx end preprocessing .",
    "we have 5 index terms for minimal locality l , sk_1 , u , + ( u , _ 1 ) , + ( u , _ 2 ) k has 3 members .",
    "[ i , x_1 ] x_1 = i ,",
    "i < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(i ) = a(x_1 ) l : 1 ; [ i , x_1 ] x_1 = i , + ( + ( u , _ 1 ) , _ 1 ) < = i  >",
    "a_w1(i ) = a(x_1 ) l : 1 ; [ z_1 , x_1 ] x_1 = z_1 , l < = z_1 ,",
    "z_1 < = u  > a(z_1 ) = b(x_1 )",
    "l : 1 ; computing k < g > ... k",
    "< g > looks as follows : k_g has 75 members .",
    "[ ] l = l , l < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(l ) = a(l ) l : 0 ; [ ] l = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(sk_1 ) = a(l ) l : 0 ; [ ] l = u , u",
    "< = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(u ) = a(l ) l : 0 ; [ ] l = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(+(u , _ 1 ) ) = a(l ) l : 0 ; [ ] l = + ( u , _ 2 ) , + ( u , _ 2 )",
    "< = -(+(u , _ 1 ) , _ 1 )  > a_w1(+(u ,",
    "_ 2 ) ) = a(l ) l : 0 ; [ ] sk_1 = l , l < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(l ) = a(sk_1 ) l : 0 ; [ ] sk_1 = sk_1 ,",
    "sk_1 < = -(+(u , _ 1 ) , _ 1 ) ",
    "a_w1(sk_1 ) = a(sk_1 ) l : 0 ; [ ] sk_1 = u , u < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(u ) = a(sk_1 ) l : 0 ; [ ] sk_1 = + ( u , _ 1 ) , + ( u , _",
    "1 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(+(u , _ 1 ) ) = a(sk_1 ) l : 0 ; [ ] sk_1 = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(+(u , _ 2 ) ) = a(sk_1 ) l : 0 ; [ ] u = l ,",
    "l < = -(+(u , _ 1 ) , _ 1 )  > a_w1(l ) = a(u ) l : 0 ; [ ] u = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(sk_1 ) = a(u ) l : 0 ; [ ] u = u ,",
    "u < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(u ) = a(u ) l : 0 ; [ ] u = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  > a_w1(+(u , _ 1 ) ) = a(u ) l : 0 ; [ ] u = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(+(u , _ 2 ) ) = a(u ) l : 0 ; [ ] + ( u , _ 1 ) = l ,",
    "l < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(l ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = sk_1 , sk_1",
    "< = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(sk_1 ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = u , u < = -(+(u , _ 1 ) , _ 1 )  > a_w1(u ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  > a_w1(+(u , _ 1 ) ) = a(+(u,_1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(+(u , _ 2 ) ) = a(+(u,_1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = l , l < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(l ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  > a_w1(sk_1 ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = u , u < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(u ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> a_w1(+(u , _ 1 ) ) = a(+(u,_2 ) )",
    "l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  >",
    "a_w1(+(u , _ 2 ) ) = a(+(u,_2 ) ) l : 0 ; [ ] l",
    "= l , + ( + ( u , _ 1 ) , _ 1 ) < = l  >",
    "a_w1(l ) = a(l ) l : 0 ; [ ] l = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "a_w1(sk_1 ) = a(l ) l : 0 ; [ ] l = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > a_w1(u ) = a(l ) l : 0 ; [ ] l = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > a_w1(+(u",
    ", _ 1 ) ) = a(l ) l : 0 ; [ ] l = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 )  > a_w1(+(u , _ 2 ) ) = a(l ) l : 0 ; [ ] sk_1 = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  >",
    "a_w1(l ) = a(sk_1 ) l : 0 ; [ ] sk_1 = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "a_w1(sk_1 ) = a(sk_1 ) l : 0 ; [ ] sk_1 = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > a_w1(u ) = a(sk_1 )",
    "l : 0 ; [ ] sk_1 = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 ) ",
    "> a_w1(+(u , _ 1 ) ) = a(sk_1 ) l : 0 ; [ ] sk_1 = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> a_w1(+(u , _ 2 ) ) = a(sk_1 ) l : 0 ; [ ] u = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  >",
    "a_w1(l ) = a(u ) l : 0 ; [ ] u = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "a_w1(sk_1 ) = a(u ) l : 0 ; [ ] u = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > a_w1(u ) = a(u )",
    "l : 0 ; [ ] u = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > a_w1(+(u , _ 1 ) ) = a(u )",
    "l : 0 ; [ ] u = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 )  > a_w1(+(u , _ 2 ) ) = a(u ) l : 0 ; [ ] + ( u , _",
    "1 ) = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  >",
    "a_w1(l ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "a_w1(sk_1 ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > a_w1(u ) = a(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > a_w1(+(u , _ 1 ) ) = a(+(u,_1 ) )",
    "l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 )  > a_w1(+(u , _ 2 ) ) = a(+(u,_1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = l , + ( + ( u , _ 1 ) , _ 1 ) < = l ",
    "> a_w1(l ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "a_w1(sk_1 ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > a_w1(u ) = a(+(u , _ 2 ) ) l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > a_w1(+(u , _ 1 ) ) = a(+(u,_2 ) )",
    "l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> a_w1(+(u , _ 2 ) ) = a(+(u,_2 ) ) l : 0 ; [ ] l = l , l",
    "< = l , l < = u  >",
    "a(l ) = b(l ) l : 0 ; [ ] sk_1 = l , l",
    "< = l , l < = u  >",
    "a(l ) = b(sk_1 ) l : 0 ; [ ] u = l ,",
    "< = l , l < = u  >",
    "a(l ) = b(u ) l : 0 ; [ ] + ( u , _",
    "1 ) = l , l",
    "< = l , l < = u  >",
    "a(l ) = b(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = l , l",
    "< = l , l < = u  >",
    "a(l ) = b(+(u , _ 2 ) ) l : 0 ; [ ] l = sk_1 ,",
    "l < = sk_1 ,",
    "sk_1 < = u  > a(sk_1 ) = b(l ) l : 0 ; [ ] sk_1 = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > a(sk_1 ) = b(sk_1 ) l : 0 ; [ ] u = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > a(sk_1 ) = b(u ) l : 0 ; [ ] + ( u , _",
    "1 ) = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > a(sk_1 ) = b(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > a(sk_1 ) = b(+(u , _ 2 ) ) l : 0 ; [ ] l = u , l < = u ,",
    "u < = u  > a(u ) = b(l ) l : 0 ; [ ] sk_1 = u",
    ", l < = u , u < = u  > a(u ) = b(sk_1 )",
    "l : 0 ; [ ] u = u , l < = u ,",
    "u < = u  > a(u ) = b(u )",
    "l : 0 ; [ ] + ( u , _",
    "1 ) = u , l < = u ,",
    "u < = u  > a(u ) = b(+(u , _ 1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = u , l < = u ,",
    "u < = u  > a(u ) = b(+(u , _ 2 ) ) l : 0 ; [ ] l = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u ",
    "> a(+(u , _ 1 ) ) = b(l ) l : 0 ; [ ] sk_1 = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > a(+(u , _ 1 ) ) = b(sk_1 ) l : 0 ; [ ] u = + ( u , _ 1 ) ,",
    "l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > a(+(u , _ 1 ) ) = b(u ) l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _",
    "> a(+(u , _ 1 ) ) = b(+(u,_1 ) )",
    "l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u",
    " > a(+(u , _ 1 ) ) = b(+(u,_2 ) ) l : 0 ; [ ] l = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u  > a(+(u , _ 2 ) ) = b(l )",
    "l : 0 ; [ ] sk_1 = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u  > a(+(u ,",
    "_ 2 ) ) = b(sk_1 ) l : 0 ; [ ] u = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u  > a(+(u ,",
    "_ 2 ) ) = b(u ) l : 0 ; [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u ",
    "> a(+(u , _ 2 ) ) = b(+(u,_1 ) ) l : 0 ; [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u  > a(+(u ,",
    "_ 2 ) ) = b(+(u,_2 ) ) l : 0 ;      computing defs ... we have the following definitions :  > e_1 = a(l )",
    "l : 0 ; extension ground terms : a(l ) ",
    "> e_2 = a(sk_1 )",
    "l : 0 ; extension ground terms : a(sk_1 ) ",
    "> e_3 = a(u )",
    "l : 0 ; extension ground terms : a(u ) ",
    "> e_4 = a(+(u , _ 1 ) )",
    "l : 0 ; extension ground terms : a(+(u , _ 1 ) )  > e_5 = a(+(u , _ 2 ) )",
    "l : 0 ; extension ground terms : a(+(u , _ 2 ) ) ",
    "> e_6 = a_w1(l )",
    "l : 0 ; extension ground terms : a_w1(l )  > e_7 = a_w1(sk_1 )",
    "l : 0 ; extension ground terms : a_w1(sk_1 ) ",
    "> e_8 = a_w1(u )",
    "l : 0 ; extension ground terms : a_w1(u ) ",
    "> e_9 = a_w1(+(u , _ 1 ) )",
    "l : 0 ; extension ground terms : a_w1(+(u , _ 1 ) ) ",
    "> e_10 = a_w1(+(u , _ 2 ) )",
    "l : 0 ; extension ground terms : a_w1(+(u , _ 2 ) ) ",
    "> e_11 = b(l )",
    "l : 0 ; extension ground terms : b(l ) ",
    "> e_12 = b(sk_1 )",
    "l : 0 ; extension ground terms : b(sk_1 )  > e_13 = b(u )",
    "l : 0 ; extension ground terms : b(u ) ",
    "> e_14 = b(+(u , _ 1 ) )",
    "l : 0 ; extension ground terms : b(+(u , _ 1 ) ) ",
    "> e_15 = b(+(u , _ 2 ) )",
    "l : 0 ; extension ground terms : b(+(u , _ 2 ) ) purified : k_g has 75 members .",
    "[ ] l = l , l < = -(+(u , _ 1 ) , _ 1 )  > e_6 = e_1",
    "l : 0 ; extension ground terms : [ ] l = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  > e_7 = e_1",
    "l : 0 ; extension ground terms : [ ] l = u , u < = -(+(u , _ 1 ) , _ 1 )  > e_8 = e_1",
    "l : 0 ; extension ground terms : [ ] l = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  > e_9 = e_1",
    "l : 0 ; extension ground terms : [ ] l = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  > e_10 = e_1",
    "l : 0 ; extension ground terms : [ ] sk_1 = l , l",
    "< = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_6 = e_2",
    "l : 0 ; extension ground terms : [ ] sk_1 = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  > e_7 = e_2",
    "l : 0 ; extension ground terms : [ ] sk_1 = u , u < = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_8 = e_2",
    "l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 1 ) , + ( u , _",
    "1 ) < = -(+(u , _ 1 ) , _ 1 )  > e_9",
    "l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  > e_10",
    "= e_2 l : 0 ; extension ground terms : [ ] u = l ,",
    "l < = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_6 = e_3",
    "l : 0 ; extension ground terms : [ ] u = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_7 = e_3",
    "l : 0 ; extension ground terms : [ ] u = u , u < = -(+(u , _ 1 ) , _ 1 )  > e_8 = e_3",
    "l : 0 ; extension ground terms : [ ] u = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  > e_9",
    "= e_3 l : 0 ; extension ground terms : [ ] u = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  > e_10 = e_3 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = l , l < = -(+(u , _ 1 ) , _ 1 )  > e_6 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = sk_1 , sk_1",
    "< = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_7 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = u , u < = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_8 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , + ( u , _",
    "1 ) < = -(+(u , _ 1 ) , _ 1 ) ",
    "> e_9 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  > e_10 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = l , l < = -(+(u , _ 1 ) , _ 1 )  > e_6 = e_5 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = sk_1 , sk_1 < = -(+(u , _ 1 ) , _ 1 )  > e_7 = e_5",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = u , u < = -(+(u , _ 1 ) , _ 1 )  > e_8 = e_5",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , + ( u , _ 1 ) < = -(+(u , _ 1 ) , _ 1 )  > e_9",
    "= e_5 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , + ( u , _ 2 ) < = -(+(u , _ 1 ) , _ 1 )  > e_10 = e_5",
    "l : 0 ; extension ground terms : [ ] l = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  > e_6 = e_1",
    "l : 0 ; extension ground terms : [ ] l = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "e_7 = e_1 l : 0 ; extension ground terms : [ ] l = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > e_8 = e_1",
    "l : 0 ; extension ground terms : [ ] l = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > e_9 = e_1 l : 0 ; extension ground terms : [ ] l = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> e_10 = e_1",
    "l : 0 ; extension ground terms : [ ] sk_1 = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  > e_6 = e_2",
    "l : 0 ; extension ground terms : [ ] sk_1 = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "l : 0 ; extension ground terms : [ ] sk_1 = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > e_8 = e_2 l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > e_9 = e_2 l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> e_10 = e_2",
    "l : 0 ; extension ground terms : [ ] u = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  > e_6 = e_3",
    "l : 0 ; extension ground terms : [ ] u = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "e_7 = e_3 l : 0 ; extension ground terms : [ ] u = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > e_8 = e_3",
    "l : 0 ; extension ground terms : [ ] u = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > e_9 = e_3 l : 0 ; extension ground terms : [ ] u = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> e_10 = e_3",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  > e_6 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "e_7 = e_4 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > e_8 = e_4 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > e_9 = e_4 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 ) ",
    "> e_10 = e_4",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = l , + ( + ( u , _ 1 ) , _ 1 ) < = l  > e_6 = e_5",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = sk_1 , + ( + ( u , _ 1 ) , _ 1 ) < = sk_1  >",
    "e_7 = e_5 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = u , + ( + ( u , _ 1 ) , _ 1 ) < = u  > e_8 = e_5",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 1 )  > e_9 = e_5 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , + ( + ( u , _ 1 ) , _ 1 ) < = + ( u , _ 2 )  > e_10 = e_5",
    "l : 0 ; extension ground terms : [ ] l = l , l",
    "< = l , l < = u  > e_1 = e_11",
    "l : 0 ; extension ground terms : [ ] sk_1 = l , l",
    "< = l , l < = u  > e_1 = e_12",
    "l : 0 ; extension ground terms : [ ] u = l , l",
    "< = l , l < = u  > e_1 = e_13 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = l , l",
    "< = l , l < = u  > e_1 = e_14 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = l , l",
    "< = l , l < = u  > e_1 = e_15 l : 0 ; extension ground terms : [ ] l = sk_1 ,",
    "l < = sk_1 ,",
    "sk_1 < = u  > e_2 = e_11 l : 0 ; extension ground terms : [ ] sk_1 = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > e_2 = e_12 l : 0 ; extension ground terms : [ ] u = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > e_2 = e_13 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = sk_1 , l < = sk_1 ,",
    "sk_1 < = u  > e_2 = e_14 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = sk_1 , l < = sk_1 ,",
    " > e_2 = e_15",
    "l : 0 ; extension ground terms : [ ]",
    "l = u , l < = u , u < = u  > e_3 = e_11 l : 0 ; extension ground terms : [ ] sk_1 = u , l < = u ,",
    "u < = u  > e_3 = e_12 l : 0 ; extension ground terms : [ ] u = u , l < = u ,",
    "u < = u  > e_3 = e_13 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = u , l < = u ,",
    "u < = u  > e_3 = e_14 l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = u , l < = u ,",
    "u < = u  > e_3 = e_15 l : 0 ; extension ground terms : [ ] l = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > e_4 = e_11 l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > e_4 = e_12 l : 0 ; extension ground terms : [ ] u = + ( u , _ 1 ) ,",
    "l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > e_4 = e_13 l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u ",
    "> e_4 = e_14",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 1 ) , l < = + ( u , _ 1 ) , + ( u , _ 1 ) < = u  > e_4 = e_15 l : 0 ; extension ground terms : [ ] l = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u",
    " > e_5 = e_11",
    "l : 0 ; extension ground terms : [ ] sk_1 = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u",
    " > e_5 = e_12",
    "l : 0 ; extension ground terms : [ ] u = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u",
    " > e_5 = e_13",
    "l : 0 ; extension ground terms : [ ] + ( u , _",
    "1 ) = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u",
    " > e_5 = e_14",
    "l : 0 ; extension ground terms : [ ] + ( u , _ 2 ) = + ( u , _ 2 ) , l < = + ( u , _ 2 ) , + ( u , _ 2 ) < = u",
    " > e_5 = e_15",
    "l : 0 ; extension ground terms : ",
    "> l < = sk_1 l : 0 ; extension ground terms :  >",
    "sk_1 < = + ( u , _ 1 ) l : 0 ; extension ground terms : e_7 = e_12  > l : 0 ; extension ground terms : ",
    "> e_9 = e_14",
    "l : 0 ; extension ground terms :      replacing d by n0 : this yields 30 clauses .",
    "1 ) = + ( u , _ 2 ) ",
    "> e_14 = e_15",
    "l : 0 ; extension ground terms : u = + ( u , _ 2 ) ",
    "> e_13 = e_15",
    "l : 0 ; extension ground terms : u = + ( u , _ 1 ) ",
    "> e_13 = e_14",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 2 ) ",
    "> e_12 = e_15",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 1 ) ",
    "> e_12 = e_14",
    "l : 0 ; extension ground terms : sk_1 = u ",
    "> e_12 = e_13",
    "l : 0 ; extension ground terms : l = + ( u , _ 2 ) ",
    "> e_11 = e_15",
    "l : 0 ; extension ground terms : l = + ( u , _ 1 ) ",
    "> e_11 = e_14",
    "l : 0 ; extension ground terms : l = u ",
    "> e_11 = e_13",
    "l : 0 ; extension ground terms : l = sk_1 ",
    "> e_11 = e_12",
    "l : 0 ; extension ground terms : + ( u , _ 1 ) = + ( u , _ 2 ) ",
    "> e_9 = e_10",
    "l : 0 ; extension ground terms : u = + ( u , _ 2 ) ",
    "> e_8 = e_10",
    "l : 0 ; extension ground terms : u = + ( u , _ 1 ) ",
    "> e_8 = e_9",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 2 ) ",
    "> e_7 = e_10",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 1 ) ",
    "> e_7 = e_9",
    "l : 0 ; extension ground terms : sk_1 = u ",
    "> e_7 = e_8",
    "l : 0 ; extension ground terms : l = + ( u , _ 2 ) ",
    "> e_6 = e_10",
    "l : 0 ; extension ground terms : l = + ( u , _ 1 ) ",
    "> e_6 = e_9",
    "l : 0 ; extension ground terms : l = u ",
    "> e_6 = e_8",
    "l : 0 ; extension ground terms : l = sk_1 ",
    "> e_6 = e_7",
    "l : 0 ; extension ground terms : + ( u , _ 1 ) = + ( u , _ 2 ) ",
    "> e_4 = e_5",
    "l : 0 ; extension ground terms : u = + ( u , _ 2 ) ",
    "> e_3 = e_5",
    "l : 0 ; extension ground terms : u = + ( u , _ 1 ) ",
    "> e_3 = e_4",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 2 ) ",
    "> e_2 = e_5",
    "l : 0 ; extension ground terms : sk_1 = + ( u , _ 1 ) ",
    "> e_2 = e_4",
    "l : 0 ; extension ground terms : sk_1 = u ",
    "> e_2 = e_3",
    "l : 0 ; extension ground terms : l = + ( u , _ 2 ) ",
    "> e_1 = e_5",
    "l : 0 ; extension ground terms : l = + ( u , _ 1 ) ",
    "> e_1 = e_4",
    "l : 0 ; extension ground terms : l = u ",
    "> e_1 = e_3",
    "l : 0 ; extension ground terms : l = sk_1 ",
    "> e_1 = e_2",
    "l : 0 ; extension ground terms :    finally we hand over to a prover ( yices is default here ) .",
    "the program checked earlier that the problem was in a decidable fragment of the theory of arrays ( apf ) , which is @xmath27-local .",
    "hence yices answer can always be trusted irrespective of whether the answer is satisfiable or unsatisfiable.    the problem is in apf handing over to yices : total number of clauses : 109 .",
    "unsat unsat h - pilot spent 0.161975s on the problem .",
    "of which clausification took 0.006998s .",
    "the prover needed 0.021996s for the problem .",
    "total running time : 0.183971s .",
    "base_functions:=(+,2 ) , ( - , 2 ) extension_functions:=(next , 1 , 1 , pointer ) , ( prev , 1 , 1 , pointer ) , ( priority , 1 , 1 , pointer , real ) relations:=(>= , 2 ) constants:=(null , pointer ) , ( a , pointer ) , ( b , pointer )          null = a prev(b ) = a prev(a ) = d_5 next(prev(prev(b ) ) ) = e_5 next(prev(b ) ) = d_1 next(b ) = a prev(prev(b ) ) = d_5 prev(next(prev(b ) ) ) = d_5 prev(next(b ) ) = d_5 prev(next(a ) ) = d_5 next(a ) = d_1 priority(next(a ) ) = 0 priority(next(prev(b ) ) ) = 0 priority(prev(b ) ) = 5 priority(b ) = 6 priority(a ) = 5    we can make this model total by defining @xmath95 and @xmath96 whenever @xmath97 resp.@xmath98 are undefined ( cf .",
    "section  [ sec - pointers ] ) .",
    "the obtained model can be visualized using mathematica ( this last step is currently performed separately ; it is not yet integrated into h - pilot , but an integration is planned for the near future . ) .",
    "the result is presented below .",
    "consider now the following example : decide whether @xmath99 we formulate a satisfiable version , by replacing the argument @xmath100 in the conclusion with a new variable @xmath101 .",
    "the problem obtained this way can be formulated as follows in the input format of h - pilot .",
    "this work was partly supported by the german research council ( dfg ) as part of the transregional collaborative research center `` automatic verification and analysis of complex systems '' ( sfb / tr 14 avacs , ` www.avacs.org ` ) .",
    "40 n.  bjrner and l.  m. de  moura . z3@xmath103 : applications , enablers , challenges and directions . in _ proceedings of the sixth international workshop on constraints in formal verification , cfv09 _ , 2009 .",
    "http://research.microsoft.com/en-us/um/people/leonardo/cfv09.pdf .",
    "a.  bauer , m.  pister , and m.  tautschnig .",
    "tool - support for the analysis of hybrid systems and models . in r.  lauwereins and j.",
    "madsen , editors , _ design , automation , and test in europe , date07 _ , pages 924929 .",
    "acm , 2007 .",
    "j.  faber , c.  ihlemann , s.  jacobs , v.  sofronie - stokkermans . automatic verification of parametric specifications with complex topologies . in d.",
    "mry and s.merz editors , _ proceedings of ifm10 , lncs 6396 _ , pages 152167 , springer , 2010 .",
    "h.  ganzinger : relating semantic and proof - theoretic concepts for polynomial time decidability of uniform word problems . in : _",
    "16th ieee symposion on logic in computer science _ , pages 8192 .",
    "ieee press , new york , 2001 .",
    "h.  ganzinger , v.  sofronie - stokkermans and u.  waldmann .",
    "modular proof systems for partial functions with weak equality . in d.  basin and m.",
    "rusinowitch , editors , _ proceedings of ijcar04 , lnai 3097 _ , pages 168182 , 2004 .",
    "y.  ge and l.  m. de  moura .",
    "complete instantiation for quantified formulas in satisfiabiliby modulo theories . in a.",
    "bouajjani and o.  maler , editors , _ proceedings of cav09 , lncs 5643 _ , pages 306320 .",
    "springer , 2009 .          c.  ihlemann , s.  jacobs , and v.  sofronie - stokkermans . on local reasoning in verification . in c.  r. ramakrishnan and j.  rehof , editors ,",
    "_ proceedings of tacas08 , lncs 4963 _ , pages 265281 .",
    "springer , 2008 .",
    "v.  sofronie - stokkermans .",
    "hierarchical and modular reasoning in complex theories : the case of local theory extensions . in : b.  konev and f.",
    "wolter , editors , _ proceedings of frocos07 , lncs 4720 _ , pages 4771 .",
    "springer , 2007 ."
  ],
  "abstract_text": [
    "<S> this system description provides an overview of h - pilot ( hierarchical proving by instantiation in local theory extensions ) , a program for hierarchical reasoning in extensions of logical theories . </S>",
    "<S> h - pilot reduces deduction problems in the theory extension to deduction problems in the base theory . </S>",
    "<S> specialized provers and standard smt solvers can be used for testing the satisfiability of the formulae obtained after the reduction . for a certain type of theory extension ( namely for _ local theory extensions _ ) this hierarchical reduction is sound and complete and  if the formulae obtained this way belong to a fragment decidable in the base theory  </S>",
    "<S> h - pilot provides a decision procedure for testing satisfiability of ground formulae , and can also be used for model generation .    </S>",
    "<S> * table of contents * </S>"
  ]
}