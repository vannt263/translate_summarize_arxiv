{
  "article_text": [
    "the key objective of digital communications is to transmit information reliably from one point to another . with the introduction of iterative error correction codes ( such as turbo , low - density parity - check and repeat - accumulate codes ) ,",
    "error correction technology has become a vital means of achieving this aim in most current communication systems .",
    "a key performance measure of a coding scheme is its decoding threshold , which is the maximum noise level at which it can correct errors . in this paper , we design an efficient optimization technique to maximize the threshold of low - density parity - check ( ldpc ) codes .    in  @xcite a numerical technique , called density evolution ( de ) was formulated to find the threshold of the belief propagation ( bp ) decoding algorithm for a given ldpc ensemble .",
    "an ldpc ensemble is the set of all ldpc codes with a particular property set , usually the degree distribution of their graphical ( tanner graph ) representation .",
    "de determines expected iterative decoding performance of a particular code ensemble by tracking the probability density function of tanner graph edge messages through the iterative decoding process .",
    "this problem for the code designer is then to search for the ensemble with the best threshold from which a specific code may then be chosen .",
    "multi - edge type ldpc ( met - ldpc ) codes  @xcite are a generalization of ldpc codes . unlike standard ldpc ensembles which contain a single statical equivalence class of tanner graph edges , in the multi - edge setting several edge classes can be defined and every node is characterized by the number of connections to edges of each class . the advantage of the met generalization is greater flexibility in code structure and improved decoding performances .",
    "the code optimization of ldpc and met - ldpc codes is a non - linear cost function maximization problem , where the de threshold is the cost function and the tanner graph structure and edge distribution gives the variables to be optimized . in the majority of previous research in code optimization found in the literature ,",
    "the optimization algorithm called differential evolution ( dif.e ) has been applied to finding good degree distributions for ldpc codes .",
    "this technique has been successfully applied to the design of good irregular ldpc codes for a range of channels  @xcite .",
    "shokrollahi and sorn  @xcite used an improved version of dif.e by proposing a new step called discrete recombination in order to increase the diversity of the new parameters in the search .",
    "richardson and urbanke  @xcite suggested using hill - climbing method to optimize met - ldpc codes . in our work , we develop a new code optimization technique to optimize codes more efficiently .",
    "this technique can be thought of as minimizing the randomness in dif.e  @xcite or limiting the search space in ordinary exhaustive search and hill - climbing .",
    "this technique is then successfully applied to design good irregular ldpc codes and met - ldpc codes .    in previous research of code optimization  @xcite ,",
    "the structure of the ldpc and met - ldpc tanner graph is determined via trail and error or exhaustive search , while only the edge distributions within a given structure are optimized . in this research",
    ", we propose a new nested method to optimize both the structure and edge distribution for ldpc and met - ldpc codes .",
    "this is particularly important for met - ldpc codes where , to date , it is not clear a priori which structures will be good .",
    "this paper is organized as follows .",
    "section ii briefly reviews the basic concepts of standard ldpc codes and met - ldpc codes . in section",
    "iii we review the code optimization problem for standard and met - ldpc codes and discus our proposed code optimization technique . in section",
    "iv we discuss the code optimization result obtained for several examples .",
    "section v concludes the paper .",
    "as the name suggests , an ldpc code is a linear block code described by a sparse parity - check matrix .",
    "an ldpc parity - check matrix can be represented in graphical form by a tanner graph .",
    "suppose the ldpc parity - check matrix , @xmath0 has @xmath1 columns and @xmath2 rows ; the corresponding tanner graph consists of @xmath1 variable nodes , @xmath2 check nodes , and an edge for every non - zero entry in @xmath0 .",
    "each variable node represents a bit of the codeword while each check node represents a parity - check constraint of the code .",
    "assuming @xmath0 is full rank , the code rate , r is given by @xmath3 .",
    "an ldpc code ensemble is typically specified by an edge degree distribution ( @xmath4 ) from the perspective of tanner graph edges : @xmath5 @xmath6 where @xmath7 ( resp . , @xmath8 )",
    "is the fraction of edges that are connected to degree @xmath9 variable nodes ( resp . , check nodes ) and @xmath10 ( resp . , @xmath11 ) is the maximum variable node degree ( resp . , check node degree ) .",
    "we let @xmath12 ( resp . ,",
    "@xmath13 ) be the set of @xmath9 s for non zero @xmath7 ( resp . , @xmath8 ) .",
    "the tanner graph for a rate - half irregular ldpc code is shown in fig .",
    "[ fig.st_tanner ] , where @xmath12 = [ 2 , 3 , 6 , 20 ] , @xmath13 = [ 7 , 8 ] and the degree distribution is given by @xmath14 and @xmath15 .",
    "( resp . , @xmath16 ) represents the variable nodes ( resp . , check nodes ) .",
    "number of nodes for different edge types are shown as fractions of the code length @xmath1 , width=172 ]      met - ldpc code ensembles are generally described based on a node - perspective , as opposed to the edge - perspective that is normally used for standard ldpc code ensembles .",
    "the met - ldpc code ensemble can be specified through two multinationals associated to the variable and check nodes  @xcite .",
    "@xmath17    @xmath18    where @xmath19 and @xmath20 are vectors defined as follows .",
    "let @xmath21 denote the number of edge types used in the graph ensemble and @xmath22 denote the number of different channels over which a bit may be transmitted .",
    "let the vector @xmath23 $ ] be a multi - edge degree and @xmath24 $ ] be a received degree where @xmath25 is associated with punctured variables ( variables not transmitted to the receiver ) .",
    "the vector of variables corresponding to the edge distributions is denoted by @xmath26 $ ] and @xmath27 .",
    "the vector of variables corresponding to the received distributions is denoted by @xmath28 $ ] and @xmath29 .",
    "@xmath30 are non - negative reals corresponding to the fraction of variable nodes with type ( @xmath31 ) and the fraction of check nodes with type ( @xmath32 ) in the graph respectively . in this research ,",
    "all the received variables are transmitted through a single link ( i.e @xmath22 = 1 ) .",
    "hence for un - punctured variables in the codeword ( i.e @xmath25 = 0 , @xmath33 = 1 ) @xmath34 = [ 0 , 1 ] and for punctured variables(i.e @xmath25 = 1 , @xmath33 = 0 ) @xmath34 = [ 1 , 0 ] .",
    "we can determine the decoding threshold for a given ldpc code ensemble defined by its degree distribution pair ( @xmath35 ) via de  @xcite .",
    "our task is to find the degree distribution pair which yields the largest possible threshold .",
    "this a is non - linear cost function maximization problem .      on the binary erasure channel ( bec )",
    "the optimization problem is as follows . on other channels",
    "an appropriate de function , or a suitable approximation , is used for ( 5 ) .",
    "+ for a fixed code rate , r and maximum number of decoder iterations , @xmath36 , where r @xmath37 $ ] and @xmath38 ,    max @xmath39 @xmath40    subject to : @xmath41    where @xmath42 is a recursive function described by @xmath43    variables : @xmath44 + where @xmath45 and @xmath46 are given by ( [ eq : st_ldpc_lamda ] ) and ( [ eq : st_ldpc_roh ] ) respectively .",
    "constraints : @xmath47 where @xmath48 and @xmath49    traditionally , the optimization problem is considered for a fixed @xmath12 and @xmath13 chosen via trail and error or intuition . that is",
    "the allowed degrees ( for which @xmath7 and @xmath8 are non - zero ) are fixed in advance .",
    "here we include the allowed degrees as variables in the optimization .",
    "this allows later generalization to met - ldpc codes where the choice of @xmath12 and @xmath13 is not straight forward .    in this case",
    "we add constraints to restrict the number of non - zero entries in @xmath45 and @xmath46 and their maximum range as follows : @xmath50      here we show the problem statement for a met - ldpc code . in this case",
    "@xmath51 is a vector @xmath52 $ ] where @xmath21 is the number of edge classes and @xmath53 for all @xmath9 .",
    "+ for a fixed code rate , r and maximum number of decoder iterations , @xmath36 , where r @xmath37 $ ] and @xmath38 ,    max @xmath54 , @xmath40    subject to : @xmath55    where @xmath56 is a recursive function described by @xmath57    where @xmath58 @xmath59    constraints : @xmath60 where @xmath61 and @xmath62 are given by ( [ eq : met_ldpc_lamda ] ) and ( [ eq : met_ldpc_roh ] ) respectively and @xmath63 denotes a vector of all 1 s with the length determined by the context . + we will consider these optimization problems using a range of existing non - convex optimization methods and a proposed method .      the adaptive range ( ar ) method forms the next set of points for evaluation as a random selection of the set of points close to the current optimum over the search space .",
    "the size of the search space is adapted as the algorithm progresses .",
    "the algorithm is as follows :    inputs are :    * optimization parameters : population size ( np ) , range multiplier ( rm ) , the tolerance on the best vector ( @xmath64 ) * tanner graph limits : @xmath65 * decoder limits : maximum number of iterations ( @xmath36 )    1 .",
    "* initialization * @xmath66 for the first generation ( @xmath67 ) , choose np length-@xmath68 vectors @xmath69 , @xmath70 , using the queen s move strategy  @xcite where @xmath68 is the number of free elements of the degree distribution pair ( @xmath71 ) .",
    "* threshold * @xmath66 for each vector @xmath69 , run de for the given number of iterations and record the ensemble threshold ( @xmath54 ) . then select the vector with largest threshold ( @xmath72 , @xmath73 ) and the vector with next largest threshold ( @xmath74 , @xmath75 ) .",
    "* random local search * @xmath66 for the next generation @xmath76 , new vectors are generated according to the following scheme .",
    "for each @xmath77 , @xmath70 , randomly choose each of its element that is at most sr away from that of the current best vector .",
    "note that each element must lie between zero and one .",
    "@xmath78                              \\end{gathered}\\ ] ] @xmath79 @xmath80 4 .",
    "* recalculation of search range * @xmath66 recalculate sr when @xmath81 @xmath82 5 .   * stopping criterion * @xmath66 halt if there is no improvement in threshold after three iterations .",
    "otherwise return to step 2 .",
    "= [ 2 , 3 , 7 , 25 ] , where @xmath83 is fixed to 0.2024 and @xmath84 given by ( 7),width=240 ]    l |c| c| c |c |c |c| c| c| c||c| c| c | & & & & + & * ar * & * dif.e * & * dif.e.r * & * ar * & * dif.e * & * dif.e.r * & * ar * & * dif.e * & * dif.e.r * & * ar * & * dif.e * & * rs * + & 0.2962 & 0.2985 & 0.2987 & 0.2774 & 0.2750 & 0.2770 & 0.2621 & 0.2630 & 0.2636 & 0.2610 & 0.2672 & 0.2860 + & 0.1749 & 0.1740 & 0.1741 & 0.2020 & 0.2040 & 0.2025 & 0.1816 & 0.1810 & 0.1801 & 0.1832 & 0.1758 & - + & - & - & - & - & - & - & - & - & - & - & - & 0.3326 + & 0.2418 & 0.2485 & 0.2489 & - & - & - & - & - & - & - & - & - + & - & - & - & 0.2626 & 0.2560 & 0.2610 & 0.2670 & 0.2690 & 0.2706 & 0.2640 & 0.2797 & - + & - & - & - & - & - & - & - & - & - & - & - & 0.1834 + & 0.2872 & 0.2790 & 0.2784 & - & - & - & - & - & - & - & - & - + & - & - & - & 0.2580 & 0.2650 & 0.2595 & - & - & - & - & - & - + & - & - & - & - & - & - & 0.2893 & 0.2870 & 0.2856 & 0.2918 & 0.2772 & 0.1980 + & 0.3094 & 0.3533 & 0.3571 & 0.1083 & 0.0748 & 0.1026 & - & - & - & - & - & - + & 0.6976 & 0.6467 & 0.6429 & 0.8917 & 0.9252 & 0.8974 & 0.6171 & 0.6338 & 0.6418 & 0.6036 & 0.6912 & 0.8872 + & - & - & - & - & - & - & 0.3829 & 0.3662 & 0.3582 & 0.3964 & 0.3088 & 0.1128 + & * 0.4939 * & * 0.4940 * & * 0.4940 * & * 0.4949 * & * 0.4949 * & * 0.4949 * & * 0.4955 * & * 0.4955 * & * 0.4955 * & * 0.4955 * & * 0.4954 * & * 0.4915 * + & 0.4935 & 0.4939 & 0.4938 & 0.4948 & 0.4949 & 0.4948 & 0.4954 & 0.4955 & 0.4955 & 0.4955 & 0.4954 & 0.4915 + & 2.2e-4 & 9.8e-5 & 6.0e-5 & 9.2e-5 & 0 & 1.6e-4 & 1.8e-4 & 5.5e-17 & 5.5e-17 & 5.5e-17 & 0 & 5.5e-17 + & 50 & 50 & 50 & 100 & 100 & 100 & 100 & 100 & 100 & 50 & 50 & 50 + & 18 & 25 & 14 & 14 & 21 & 14 & 15 & 21 & 14 & 5860 & 3430 & 7036 + & 900 & 1250 & 700 & 1400 & 2100 & 1400 & 1500 & 2100 & 1400 & 286778 & 171046 & 348626 + & 51 & 42 & 700 & 42 & 34 & 1400 & 37 & 29 & 1400 & 22345 & 11702 & 21729 + & * 71.277 * & * 87.002 * & * 2062.1 * & * 63.586 * & * 82.072 * & * 3349.0 * & * 63.960 * & * 84.100 * & * 3787.4 * & * 12744 * & * 6846.9 * & * 13027 * + & 74.785 & 155.50 & 2012.9 & 86.592 & 118.54 & 3669.8 & 70.664 & 102.53 & 3853.8 & 13483 & 7573.1 & 15282 + & 14.382 & 40.313 & 136.92 & 16.662 & 28.435 & 180.32 & 13.278 & 16.804 & 61.308 & 801.12 & 688.07 & 1184.9 +   +   +   +    to find the best optimization algorithm of ( @xmath71 ) given ( @xmath85 ) fixed , we compare our proposed algorithm , ar method with dif.e  @xcite and differential evolution with recombination ( dif.e.r )  @xcite .",
    "we considered three optimization problems from  @xcite . in all cases ,",
    "initialization was via queen s move strategy  @xcite and stopping criterion was set as halt if there is no improvement in threshold after three generations .",
    "the population size at each generation was fixed at 50 ( case 1 ) or 100 ( case 2 and 3 ) .",
    "for all three optimization problems , we set rm=0.5 in the ar method .",
    "table  [ table : some good degree distributions ] shows our results and the table entries give the degree distribution and simulation parameters for the best case over 10 trials .",
    "the numbers in brackets give the average and standard deviation for @xmath54 and simulation time ( cpu.t ) over the 10 trials .",
    "while all three algorithms returned the same optimal threshold up to three significant decimal points , the ar method was significantly quicker .",
    "the superiority of the ar method , in this example , is due to the shape of the de cost function for fixed ( @xmath85 ) as shown in fig .",
    "[ fig.cost function ] .",
    "although rounding off the threshold to a fixed number of significant figures does result in multiple points with the same threshold , there are otherwise no local maxima to trap the optimization algorithm .",
    "the ar method , which is a type of local search optimization technique works well in the absence of multiple local maxima .",
    "next , we jointly optimized ( @xmath85 ) and ( @xmath35 ) using the ar method , dif.e and random search ( rs ) for the ( @xmath85 ) variables with an inner optimization of ar for the ( @xmath86 ) variables . when including the allowed degrees in the optimization , the task now is to solve an integer optimization , as the node degrees can only be integer values",
    ". in the ar method , optimization of ( @xmath35 )",
    "was done using rm and sr ( initial setting ) as described in section iv.a .",
    "for optimization of ( @xmath85 ) , 1 and 15 was selected for rm and sr ( initial setting ) respectively .",
    "to compare the three optimization algorithms , we consider ldpc codes with rate - half , @xmath87 , @xmath88 and constraint on the maximum bit node degree of @xmath89 30 . in all cases @xmath86 were initialized with the queens move method .",
    "the last three columns of table  [ table : some good degree distributions ] show our results .",
    "the combined optimization using either ar or dif.e returns the same ( @xmath85 ) set as found in  @xcite .",
    "optimization returns the same degree set found in  @xcite via intuition and trail and error .",
    "the ar method was significantly faster than the dif.e method and the rs method failed to achieve the best degree combination in all 10 trails . ar and",
    "dif.e algorithms return the same threshold value with an accuracy of three significant decimal points for the same ( @xmath85 ) , although the ( @xmath71 ) sets are sightly different .",
    "this is because there can be more than one ( @xmath71 ) set for each ( @xmath85 ) that obtains the same threshold when it is evaluated within three significant figures .",
    "in this section we apply our optimization techniques to met - ldpc ensembles where the combined optimization technique is particularly useful to explore the wide range of possible structures .    similarly to standard ldpc codes we found that , for the inner optimization ( i.e. , optimizing the node fractions , denoted as @xmath90 and @xmath91 in fig .",
    "[ fig.met_ldpc ] , for a fixed code structure , denoted as @xmath92 and @xmath93 in the same figure ) , the ar method returns a higher optimal threshold than dif.e . the met - de cost function when allowed degrees are fixed ,",
    "has a global maximum and no other local maxima .",
    "an example of this cost function for the 4-edge class met - ldpc code given in table vi of  @xcite on a bi - awgn channel is shown in fig .",
    "[ fig.met inner cost function ] .      to examine the properties of the met - de cost function for the generalization of the met - ldpc code structure , we consider met - ldpc codes with four variable node classes , maximum allowable variable node degree of 10 and edge class 4 containing degree-1 variable nodes as in the example in  @xcite .",
    "the met - de cost function for this situation has local maxima .",
    "[ fig.met outer cost function ] shows an example of this cost function as the node degree of the class 1 and class 2 variable nodes are varied . in this scenario dif.e outperforms the ar method by escaping local maxima which is reflected in the performance of each algorithm as shown in table  [ table : met optimization ] .",
    "hence we propose that , met - ldpc codes be optimized using the ar method as the met degree distribution optimization technique and dif.e to optimize the met code structure . through the joint optimization",
    "we gain a threshold improvement of 0.007 compared to the reference met - ldpc code ( table vi of  @xcite ) which has a threshold of @xmath94=0.9682 over the bi - awgn channel . here",
    "we see the benefit of met - ldpc codes as standard lpdc codes require a maximum node degree of 85 to obtain a threshold this high  @xcite .    represent punctured variable nodes.,width=172 ]     ( i.e @xmath95 , \\lambda_2 = [ 0 , 0 , 3 , 0 ] , \\lambda_3 = [ 0 , 0 , 3 , 0 ] , \\lambda_4 = [ 0 , 0 , 0 , 1 ]   $ ] ) where @xmath96 and @xmath97 is given by ( 20),width=288 ]     , \\lambda_2 = [ 0 , 0 , 3 , 0 ] , \\lambda_3 = [ 0 , 0 , 3 , 0 ] , \\lambda_4 = [ 0 , 0 , 0 , 1 ]   $ ] , width=288 ]    .optimization of 4-edge class rate - half met - ldpc codes on the bi - awgn channel [ cols=\"^,^,^,^,^,^,^,^,^ \" , ]",
    "in this paper , we introduced a novel code optimization technique which can be successfully applied to optimize degree distributions for both standard ldpc codes and met - ldpc codes .",
    "we then proposed a joint optimization technique for met - ldpc codes which allows the optimization of the met structure and degree distribution given just the number of edge classes and maximum node degrees .",
    "we found that our proposed ar method works best for optimizing the edge degree distribution for a given set of allowed degrees while dif.e works best for optimizing the set of allowed degrees .",
    "t.  j. richardson , m.  a. shokrollahi , and r.  l. urbanke , `` design of capacity - approaching irregular low - density parity - check codes , '' _ ieee trans .",
    "47 , no .  2 ,",
    "619637 , feb ."
  ],
  "abstract_text": [
    "<S> a low - density parity - check ( ldpc ) code is a linear block code described by a sparse parity - check matrix , which can be efficiently represented by a bipartite tanner graph . </S>",
    "<S> the standard iterative decoding algorithm , known as belief propagation , passes messages along the edges of this tanner graph . </S>",
    "<S> density evolution is an efficient method to analyze the performance of the belief propagation decoding algorithm for a particular ldpc code ensemble , enabling the determination of a decoding threshold . </S>",
    "<S> the basic problem addressed in this work is how to optimize the tanner graph so that the decoding threshold is as large as possible . </S>",
    "<S> we introduce a new code optimization technique which involves the search space range which can be thought of as minimizing randomness in differential evolution or limiting the search range in exhaustive search . </S>",
    "<S> this technique is applied to the design of good irregular ldpc codes and multi - edge type ldpc codes . </S>"
  ]
}