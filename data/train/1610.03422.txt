{
  "article_text": [
    "a one - time pad can famously be used only once  @xcite , i.e. , a secret key as long as the message is needed to encrypt it with information / theoretic security .",
    "but this does not hold anymore if the honest players can use quantum technologies to communicate .",
    "a quantum key distribution ( qkd ) protocol  @xcite allows players to expand an initial short secret key , and thus encrypt messages that are longer than the length of the original key . instead of first expanding a key , and then using it for encryption , one can also swap the order if the initial key is long enough : one first encrypts a message , then recycles the key .",
    "this is possible due to the same physical principles as qkd : quantum states can not be cloned , so if the receiver holds the exact cipher that was sent , the adversary can not have a copy , and thus does not have any information about the key either , so it may be reused .",
    "this requires the receiver to verify the authenticity of the message received , and if this process fails , a net key loss occurs  the same happens in qkd : if an adversary tampers with the communication , the players have to abort and also lose some of the initial secret key .",
    "some ideas for recycling encryption keys using quantum ciphers were already proposed in 1982  @xcite .",
    "many years later , gottesman  @xcite and then damgrd et al .",
    "@xcite showed how to encrypt a classical message in a quantum state and recycle the key . at roughly the same time , the first protocol for authenticating quantum messages was proposed by barnum et al .",
    "@xcite , who also proved that quantum authentication necessarily encrypts the message as well .",
    "their protocol was then adapted to recycle key by oppenheim and horodecki  @xcite .",
    "but the security definitions in these initial works on quantum authentication have a major flaw : they do not consider the possibility that an adversary may hold a purification of the quantum message that is encrypted .",
    "this was corrected by hayden , leung and mayers  @xcite , who give a composable security definition for quantum authentication with key recycling .",
    "they then show that the family of protocols from  @xcite are secure , and prove that one can recycle part of the key if the message is accepted .",
    "the security proof from  @xcite does however not consider all possible environments .",
    "starting in works by simmons in the 80 s and then stinson in the 90 s ( see , for example , @xcite ) the classical literature on authentication studies two types of attacks : _ substitution attacks _  where the adversary obtains a valid pair of message and cipher and attempts to substitute the cipher with one that will decode to a different message  and _ impersonation attacks _  where the adversary directly sends a forged cipher to the receiver , without knowledge of a valid message / cipher pair . to the best of our knowledge",
    ", there is no proof showing that security against impersonation attacks follows from security against substitution attacks , hence the literature analyzes both attacks separately .",
    "this is particularly important in the case of composable security , which aims to prove the security of the protocol when used in any arbitrary environment , therefore also in an environment that first sends a forged cipher to the receiver , learns wether it is accepted or rejected , then provides a message to the sender to be authenticated , and finally obtains the cipher for this message .",
    "this is all the more crucial when key recycling is involved , since the receiver will already recycle ( part of ) the key upon receiving the forged cipher , which is immediately given to the environment .",
    "the work of hayden et al .",
    "@xcite only considers environments that perform substitution attacks ",
    "i.e. , first provide the sender with a message , then change the cipher , and finally learn the outcome of the authentication as well as receive the recycled key .",
    "hence they do not provide a complete composable security proof of quantum authentication .",
    "more recently , alternative security definitions for quantum authentication have been proposed , both without  @xcite and with  @xcite key recycling .",
    "these still only consider substitution attacks , and furthermore , they are , strictly speaking , not composable . while it is possible to prove that these definitions imply security in a composable framework ( if one restricts the environment to substitution attacks ) , the precise way in which the error @xmath0 carries over to the framework has not been worked out in any of these papers .",
    "if two protocols with composable errors @xmath0 and @xmath1 are run jointly ( e.g. , one is a subroutine of the other ) , the error of the composed protocol is bounded by the sum of the individual errors , @xmath2 . if a security definition does not provide a bound on the composable error , then one can not evaluate the new error after composition .. ] for example , quantum authentication with key recycling requires a backwards classical authentic channel , so that the receiver may tell the sender that the message was accepted , and allow her to recycle the key .",
    "the error of the complete protocol is thus the sum of errors of the quantum authentication and classical authentication protocols .",
    "definitions such as those of @xcite are not sufficient to directly obtain a bound on the error of such a composed protocol .    in the other direction",
    ", it is immediate that if a protocol is @xmath0/secure according to the composable definition used in this work , then it is secure according to @xcite with the same error @xmath0 .",
    "more precisely , proving that the quantum authentication scheme constructs a secure channel is sufficient to satisfy @xcite ",
    "i.e. , the ideal functionality is a secure channel which only allows the adversary to decide if the message is delivered , but does not leak any information about the message to the adversary except its length ( confidentiality ) , nor does it allow the adversary to modify the message ( authenticity ) . and proving that the scheme constructs a secure channel that additionally generates fresh secret key is sufficient to satisfy the definition of _ total authentication _ from @xcite .",
    "garg et al .",
    "@xcite also propose a definition of _ total authentication with key leakage _ , which can be captured in a composable framework by a secure channel that generates fresh key and leaks some of it to the adversary .",
    "this is however a somewhat unnatural ideal functionality , since it requires a deterministic leakage function , which may be unknown or not exist , e.g. , the bits leaked can depend on the adversary s behavior  this is the case for the _ trap code _",
    "@xcite , discussed in .",
    "the next natural step for players in such a situation is to extract a secret key from the partially leaked key , and thus the more natural ideal functionality is what one obtains after this privacy amplification step  @xcite : a secure channel that generates fresh secret key , but where the key generated may be shorter than the key consumed .",
    "the ideal functionality used in the current work provides this flexibility : the amount of fresh key generated is a parameter which may be chosen so as to produce less key than consumed , the same amount , or even more .",
    "hence , with one security definition , we encompass all these different cases  no key recycling , partial key recycling , total key recycling , and even a net gain of secret key . furthermore , having all these notions captured by ideal functionalities makes for a particularly simple comparison between the quite technical definitions appearing in @xcite .      in this work we use the abstract cryptography ( ac )",
    "framework  @xcite to model the composable security of quantum authentication with key recycling .",
    "ac views cryptography as a resource theory : a protocol constructs a ( strong ) resource given some ( weak ) resources . for example , the quantum authentication protocols that we analyze construct a secure quantum channel  a channel that provides both _",
    "confidentiality _ and _ authenticity _  that additionally produces fresh key . in order to construct this resource ,",
    "we require shared secret key , an insecure ( noiseless ) quantum channel and a backwards authentic classical channel .",
    "these are all resources , that may in turn be constructed from weaker resources , e.g. , the classical authentic channel can be constructed from a shared secret key and an insecure channel , and noiseless channels are constructed from noisy channels . due to this constructive aspect of the framework , it is also called _ constructive cryptography _ in the literature  @xcite .    although this approach is quite different from the universal composability ( uc ) framework  @xcite , in the setting considered in this work ",
    "with one dishonest player and where recipients are denoted by classical strings  the two frameworks are essentially equivalent and the same results could have been derived with a quantum version of uc  @xcite . in uc , the constructed resource would be called _ ideal functionality _ , and the resources used in the construction are setup assumptions .",
    "we thus first formally define the ideal resource constructed by the quantum authentication protocol with key recycling  the secure channel that produces fresh key mentioned in this introduction  as well as the resources required by this construction .",
    "we then prove that a family of quantum authentication protocols proposed by barnum et al .",
    "@xcite satisfy this construction , i.e. , no distinguisher ( called environment in uc ) can distinguish the real system from the ideal resource and simulator except with an advantage @xmath0 that is exponentially small in the security parameter .",
    "this proof considers all distinguishers allowed by quantum mechanics , including those that perform impersonation attacks .",
    "we show that in the case where the message is accepted , every bit of key may be recycled . and",
    "if the message is rejected , one may recycle all the key except the bits used to one - time pad the cipher .",
    "we prove that this is optimal , i.e. , an adversary may obtain all non / recycled bits of key .",
    "this improves on previous results , which recycled less key .",
    "more specifically , hayden et al .",
    "@xcite , while also analyzing protocols from @xcite , only recycle part of the key in case of an accept , and lose all the key in case of a reject .",
    "garg et al .",
    "@xcite propose a new protocol , which they prove can recycle all of the key in the case of an accept , but do not consider key recycling in the case of a reject either .",
    "the protocols we analyze are also more key efficient than that of  @xcite .",
    "we give two instances which need @xmath3 bits of initial secret key , instead of the @xmath4 required by @xcite , where @xmath5 is the length of the message and @xmath0 is the error .",
    "note that the family of protocols for which we provide a security proof is a subset of the ( larger ) family introduced in  @xcite .",
    "more precisely , barnum et al .",
    "@xcite define quantum authentication protocols by composing a quantum one - time pad and what they call a _ purity testing code _  which , with high probability , will detect any noise that may modify the encoded message  whereas we require a stricter notion , a _ strong purity testing code _  which , with high probability , will detect any noise .",
    "this restriction on the family of protocols is necessary to recycle all the key .",
    "in fact , there exists a quantum authentication scheme , the _ trap code _",
    "@xcite , which is a member of the larger class from  @xcite but not the stricter class analyzed here , and which leaks part of the key to the adversary , even upon a successful authentication of the message  this example is discussed in .",
    "we then give two explicit instantiations of this family of quantum authentication protocols .",
    "the first is the construction used in @xcite , which requires an initial key of length @xmath6 , where @xmath5 is the length of the message and @xmath7 is the security parameter , and has error @xmath8 .",
    "the second is an explicit unitary @xmath9/design  @xcite discovered by chau  @xcite , which requires @xmath10 bits of initial key bits of key , but we show that some of the unitaries are redundant when used for quantum authentication and can be dropped . ] and has error @xmath11 .",
    "both constructions have a net loss of @xmath12 bits of key if the message fails authentication .",
    "since several other explicit quantum authentication protocols proposed in the literature are instances of this family of schemes , our security proof is a proof for these protocols as well  this is discussed further in .",
    "finally , we show how to construct the resources used by the protocol from nothing but insecure noisy channels and shared secret key , and calculate the joint error of the composed protocols .",
    "we also show how to compensate for the bits of key lost in the construction of the backwards authentic channel , so that the composed protocol still has a zero net key consumption if no adversary jumbles the communication .      in",
    "we give a brief introduction to the main concepts of ac , which are necessary to understand the notion of cryptographic construction and corresponding security defintion . a more extended introduction to ac",
    "is provided in . in we",
    "then define the resources constructed and used by a quantum authentication scheme with key recycling .",
    "we introduce the family of protocols from  @xcite that we analyze in this work , and then prove that they construct the corresponding ideal secure channel .",
    "we also prove that the number of recycled bits is optimal . in we",
    "show how to construct the various resources used by the quantum authentication protocol , and put the pieces together to get a security statement for the joint protocol that constructs the secure quantum channel that generates fresh key from nothing but noisy insecure channels and shared secret key .",
    "finally , in we discuss the relation between some quantum authentication schemes that have appeared in the literature and those analyzed here , as well as some open problems .",
    "as already mentioned in , the ac framework  @xcite models cryptography as a resource theory . in this section we give a brief overview of how these constructive statements are formalized .",
    "we illustrate this with an example taken from @xcite , namely authentication of classical messages with message authentication codes ( mac ) . an expanded version of this introduction to ac is provided in .",
    "[ .5][c ]    1.4    ( ch ) at ( 0,0 ) ; at ( ch.north west ) insecure channel @xmath13 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( -,0 ) to ( -,- ) ; ( , - ) to ( , 0 ) to ( bob.center ) ;    [ .5][c ]    1.4    ( ch ) at ( 0,0 ) ; at ( ch.north west ) authentic channel @xmath14 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( 0,0 ) to node ( handle ) ( 330:2 * ) ; ( 2*,0 ) to ( bob.center ) ; ( -,0 ) to ( -,- ) ; ( handle.center |- 0,- ) to node[auto , swap , pos=.3 ] @xmath15 ( handle.center ) ;    [ .5][c ]    .2    ( keybox ) at ( 0,0 ) ; ( key ) at ( 0,- ) key ; at ( keybox.north west ) secret key @xmath16 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ; ( up ) at ( 0 , ) ; ( down ) at ( 0,- ) ;    ( alice |- up ) to node[auto ] req .",
    "( keybox.west |- up ) ; ( bob |- up ) to node[auto , swap ] req .",
    "( keybox.east |- up ) ; ( key.west |- down ) to node[auto , pos=.8 ] @xmath17 ( alice |- down ) ; ( key.east |- down ) to node[auto , swap , pos=.8 ] @xmath17 ( bob |- down ) ;    [ .5][c ]    1.5.2    ( ch ) at ( 0,0 ) ; at ( ch.north west ) insecure channel @xmath13 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( -,0 ) to ( -,- ) ; ( , - ) to ( , 0 ) to ( bob.center ) ;    ( keybox ) at ( 0 , ) ; ( key ) at ( 0,u- ) key ; at ( keybox.north west ) secret key @xmath16 ; ( keylabel ) at ( keybox.north ) ; ( up ) at ( 0,+ ) ; ( down ) at ( 0,u- ) ;    ( alice |- up ) to node[auto , pos=.4 ] req .",
    "( keybox.west |- up ) ; ( bob |- up ) to node[auto , swap , pos=.4 ] req .",
    "( keybox.east |- up ) ; ( key.west |- down ) to node[auto , pos=.8 ] @xmath17 ( alice |- down ) ; ( key.east |- down ) to node[auto , swap , pos=.8 ] @xmath17 ( bob |- down ) ;    ( comp ) ; at ( comp.north west ) composed resource @xmath18 ;    in an @xmath7 player setting , a _ resource _ is an object with @xmath7 interfaces , that allows every player to input messages and receive other messages at her interface .",
    "the objects depicted in are examples of resources .",
    "the insecure channel in allows alice to input a message at her interface on the left and allows bob to receive a message at his interface on the right .",
    "eve can intercept alice s message and insert a message of her choosing at her interface .",
    "the authentic channel resource depicted in also allows alice to send a message and bob to receive a message , but eve s interface is more limited than for the insecure channel : she can only decide if bob receives the message or not , but not tamper with the message being sent . the key resource drawn in provides each player with a secret key when requested . if two resources @xmath16 and @xmath13 are both available to the players , we write @xmath18 for the resource resulting from their parallel composition",
    "this is to be understood as the resources being merged into one : the interfaces belonging to player @xmath19 are simultaneously accessible to her as one new interface , which we depict in .",
    "_ converters _ capture operations that a player might perform locally at her interface .",
    "for example , if the players share a key resource and an insecure channel , alice might decide to append a mac to her message .",
    "this is modeled as a converter @xmath20 that obtains the message @xmath21 at the outside interface , obtains a key at the inside interface from a key resource @xmath16 and sends @xmath22 on the insecure channel @xmath13 , where @xmath23 is taken from a family of strongly @xmath9/universal hash functions  @xcite .",
    "we illustrate this in .",
    "converters are always drawn with rounded corners . if a converter @xmath24 is connected to the @xmath19 interface of a resource @xmath25 , we write @xmath26 or @xmath27 for the new resource obtained by connecting the two . and @xmath28 interfaces on the left and converters at the @xmath29 interface on the right , though there is no mathematical difference between @xmath26 and @xmath27 . ]",
    "2.89 .75 i.846 ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( a ) at ( -,0 ) @xmath30 + @xmath31 ; at ( a.north west ) @xmath32 ; ( alice ) at ( -,0 ) ;    ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ; ( b ) at ( , 0 ) @xmath33 + @xmath34 ; at ( b.north west ) @xmath35 ; ( bob ) at ( , 0 ) ;    ( keybox ) at ( 0 , ) ; ( keyinnerboxleft ) at ( -i , ) ; ( keyinnerboxright ) at ( i , ) ; ( key ) at ( 0 , ) key ; at ( keybox.north west ) secret key @xmath16 ; ( channel ) at ( 0,- ) ; at ( channel.north west ) insecure channel @xmath13 ; ( eveleft ) at ( -.4,-1.75 ) ; ( everight ) at ( .4,-1.75 ) ; ( ajunc ) at ( eveleft |- a3 ) ; ( bjunc ) at ( everight |- b3 ) ;    ( key ) to node[auto , swap , pos=.15,yshift=-2 ] @xmath17 ( a1 ) ; ( key ) to node[auto , pos=.15,yshift=-2 ] @xmath17 ( b1 ) ; ( a1 ) to node[auto , pos=.5 ] req .",
    "( keyinnerboxleft ) ; ( b1 ) to node[auto , swap , pos=.5 ] req .",
    "( keyinnerboxright ) ;    ( alice.center ) to node[auto , pos=.4 ] @xmath21 ( a2 ) ; ( b2 ) to node[auto , pos=.75 ] @xmath36 ( bob.center ) ;    ( a3 ) to ( ajunc.center ) to node[pos=.8,auto , swap ] @xmath37 ( eveleft.center ) ; ( everight.center ) to node[pos=.2,auto , swap ] @xmath38 ( bjunc.center ) to ( b3 ) ;    a protocol is then defined by a set of converters , one for every honest player .",
    "another type of converter that we need is a _ filter_. the resources illustrated in depict a setting with an adversary that has some control over these resources . for a cryptographic protocol to be useful it is not sufficient to provide guarantees on what happens when an adversary is present",
    ", one also has to provide a guarantee on what happens when no adversary is present , e.g. , if no adversary tampers with the message on the insecure channel , then bob will receive the message that alice sent .",
    "we model this setting by covering the adversarial interface with a filter that emulates an honest behavior . in",
    "we draw an insecure and an authentic channel with filters @xmath39 and @xmath40 that transmit the message to bob . in the case of the insecure channel",
    ", one may want to model an honest noisy channel when no adversary is present .",
    "this is done by having the filter @xmath39 add some noise to the message .",
    "a dishonest player removes this and has access to a noiseless channel as in .",
    "[ .5][c ]    1.4    ( ch ) at ( 0,0 ) ; at ( ch.north west ) insecure channel @xmath13 ; ( fil ) at ( 0,- ) ; at ( fil.north west ) @xmath39 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( -,0 ) to ( -,- ) ; ( -,- ) to ( , - ) ; ( , - ) to ( , 0 ) to ( bob.center ) ;    [ .5][c ]    1.4    ( ch ) at ( 0,0 ) ; at ( ch.north west ) authentic channel @xmath14 ; ( fil ) at ( 0,- ) ; at ( fil.north west ) @xmath40 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( bob.center ) ; ( -,0 |- ch.center ) to ( -,0 |- fil.center ) ; ( , 0 |- fil.center ) to node[auto , swap , pos=.45,xshift=-1 ] @xmath41 ( , 0 |- ch.center ) ;    we use the term _ filtered resource _ to refer to a pair of a resource @xmath25 and a filter @xmath39 , and often write @xmath42",
    ". such an object can be thought of as having two modes : it is characterized by the resource @xmath43 when no adversary is present and by the resource @xmath25 when the adversary is present .",
    "the final object that is required by the ac framework to define the notion of construction and prove that it is composable , is a ( pseudo/)metric defined on the space of resources that measures how close two resources are . in the following , we use a distinguisher based metric , i.e. , the maximum advantage a distinguisher has in guessing whether it is interacting with resource @xmath25 or @xmath44 , which we write @xmath45 .",
    "more specifically , let @xmath46 be a distinguisher , and le @xmath47 $ ] and @xmath48 $ ] be the binary random variables corresponding to @xmath46 s output when connected to @xmath25 and @xmath44 , respectively . then the distinguishing advantage between @xmath25 and @xmath44",
    "is defined as @xmath49 = 0    \\right ] - \\pr\\left [ \\ad[\\as ] = 0 \\right ] \\right|\\,.\\ ] ] since we study information / theoretic security in this work , the supremum is taken over the set of all possible distinguishers allowed by quantum mechanics .",
    "this is discussed further in .",
    "we are now ready to define the security of a cryptographic protocol .",
    "we do so in the three player setting , for honest alice and bob , and dishonest eve .",
    "thus , in the following , all resources have three interfaces , denoted @xmath50 , @xmath28 and @xmath29 , and a protocol is then given by a pair of converters @xmath51 for the honest players .",
    "we refer to @xcite for the general case , when arbitrary players can be dishonest .",
    "[ def : security ] let @xmath52 be a protocol and @xmath53 and @xmath54 denote two filtered resources .",
    "we say that _ @xmath55 constructs @xmath56 from @xmath57 within @xmath0 _ , which we write @xmath58 , if the two following conditions hold :    1 .   [",
    "eq : def.cor ] we have @xmath59 2 .   [ eq : def.sec ] there exists a converter @xmath60  which we call simulator  such that @xmath61    if it is clear from the context what filtered resources @xmath57 and @xmath62 are meant , we simply say that @xmath55 is @xmath0/secure .",
    "the first of these two conditions measures how close the constructed resource is to the ideal resource in the case where no malicious player is intervening , which is often called _ correctness _ in the literature .",
    "the second condition captures _ security _ in the presence of an adversary .",
    "for example , to prove that the mac protocol constructs an authentic channel from an insecure channel and a secret key within @xmath0 , we need to find a converter @xmath63 such that the real system @xmath64 can not be distinguished from the ideal system @xmath65 with advantage greater than @xmath0 . the simulator @xmath63 drawn in satisfies this requirement if the family of hash functions @xmath66 is @xmath0/almost strongly @xmath9/universal  @xcite .",
    "-1.1 .75 ( channel ) at ( 0 , ) ; at ( channel.north west ) authentic channel @xmath14 ; ( alice ) at ( - , ) ; ( bob ) at ( , ) ;    ( sim ) at ( 0 , ) ; at ( sim.north west ) @xmath67 ; ( sleft ) at ( -.809 , ) ; ( sright ) at ( .809 , ) ; ( sim.north ) to ( sim.south ) ;    ( ajunc ) at ( sleft |- alice ) ; ( bjunc ) at ( sright |- bob ) ;    ( alice.center ) to node[pos=.15,auto ] @xmath21 ( .4 , ) to node[pos=.54 ] ( ejunc ) + ( 160:-.8 ) ; ( ajunc.center ) to node[pos=.63,auto , swap ] @xmath21 ( sleft ) ; ( 1.2 , ) to node[pos=.75,auto ] @xmath68 ( bob.center ) ; ( sright ) to node[pos=.4,auto , swap ] @xmath15 ( ejunc.center ) ;    ( sltext ) at ( -.809 , ) @xmath69 ; ( srtext ) at ( .809 , ) @xmath70 + @xmath71 ;    ( eveleft ) at ( sleft |- 0 , ) ; ( everight ) at ( sright |- 0 , ) ; ( sleft ) to node[pos=.75,auto , swap ] @xmath37 ( eveleft.center ) ; ( everight.center ) to node[pos=.25,auto , swap ] @xmath38 ( sright ) ;    ( key ) at ( .15,+.8 ) key ; ( key ) to ( sleft ) ;    [ rem : efficiency ] the protocols and simulators discussed in this work are all efficient .",
    "the protocols we consider are either trivially efficient or taken from other work , in which case we refer to these other works for proofs of efficiency .",
    "the efficiency of the simulator used to prove the security of quantum authentication has been analyzed in @xcite .",
    "all other simulators used in the security proofs run the corresponding honest protocols , and are thus efficient because the protocols are .",
    "we therefore do not discuss efficiency any further in this work .",
    "we start with some technical preliminaries in , where we introduce ( strong ) purity testing codes , which are a key component of the family of quantum authentication protocols of @xcite . in",
    "we give a constructive view of quantum authentication with key recycling : we define the resource that such a protocol is expected to construct , as well as the resources that are required to achieve this . in",
    "we describe the family of protocols that we analyze in this work , along with a variant in which the order of the encryption and encoding operations has been swapped , which we prove to be equivalent . in",
    "we give a security proof for the family of quantum authentication protocols defined earlier . and",
    "in we show that the number of recycled key bits is optimal .",
    "finally , in we give two explicit constructions of purity testing codes and get the exact parameters of the quantum authentication protocols with these codes .      [ [ pauli - operators . ] ] pauli operators .",
    "+ + + + + + + + + + + + + + + +    to denote a pauli operator on @xmath7 qubits we write either @xmath72 or @xmath73 , where @xmath21 and @xmath74 are @xmath7-bit strings indicating in which positions bit and phase flips occur , and @xmath75 is the concatenation of @xmath21 and @xmath74 , which is used when we do not need to distinguish between @xmath21 and @xmath74 .",
    "two pauli operators @xmath76 and @xmath77 with @xmath78 and @xmath79 commute ( anti / commute ) if the symplectic inner product @xmath80 is @xmath41 ( is @xmath81 ) , where @xmath82 is the scalar product of the vectors and the arithmetic is done modulo @xmath9 . hence , for any @xmath83 and @xmath73 @xmath84",
    "we use several times the following equality @xmath85 where @xmath86 means that all bits of the string @xmath87 are @xmath41 .",
    "[ [ purity - testing - code . ] ] purity testing code .",
    "+ + + + + + + + + + + + + + + + + + + +    an error correcting code ( ecc ) that encodes an @xmath5 qubit message in a @xmath88 qubit code word is generally defined by an isomorphism from @xmath89 to @xmath90 . in this work",
    "we define an ecc by a unitary @xmath91 .",
    "the code word for a state @xmath92 is obtained by appending a @xmath7 qubit state @xmath93 to the message , and applying @xmath94 , i.e. , the encoding of @xmath92 is @xmath95 .",
    "we do not need to use the decoding properties of eccs in this work , we only use the them to detect errors , i.e. , given a state @xmath96 , we apply the inverse unitary @xmath97 and measure the last @xmath7 qubits to see if they are @xmath93 or not .",
    "the first property we require of our codes , is that they map any pauli error @xmath73 into another pauli error @xmath98 , i.e. , @xmath99 for some global phase @xmath100 .",
    "this is always the case for any @xmath94 that can be implemented with clifford operators . in particular , all stabilizer codes have this property , which are used in @xcite to define purity testing codes .",
    "note that the mapping from @xmath87 to @xmath101 is a permutation on the set of indices @xmath102 that depends only on the choice of code .",
    "a code will detect an error @xmath73 if @xmath103 for @xmath104 , where @xmath72 acts on the first @xmath5 qubits and @xmath105 on the last @xmath7 .",
    "measuring these last qubits would yield the syndrome @xmath106 , since @xmath105 flips the bits in the positions corresponding to the bits of @xmath106 . and",
    "an error @xmath73 will act trivially on the message if @xmath107 . in particular ,",
    "if @xmath108 , then this error will not be detected , but not change the message either .    for a code indexed by a key @xmath17 , we denote by @xmath109 the set of pauli errors that are not detected by this code , and by @xmath110 we denote the undetected errors which act trivially on the message .",
    "a purity testing code is a set of codes @xmath111 such that when a code @xmath112 is selected uniformly at random , it will detect with high probability all pauli errors which act non / trivially on the message .",
    "a purity testing code with error @xmath0 is a set of codes @xmath111 , such that for all pauli operators @xmath73 , @xmath113    as mentioned in , we use a stricter definition of purity testing code in this work .",
    "we require that all non / identity paulis get detected with high probability , even those that act trivially on the message .",
    "intuitively , the reason for this is that , with the original definition of purity testing , if the adversary introduces some noise @xmath73 , by learning whether the message was accepted or not , she will learn whether that error acts trivially on the message or not , and thus learn something about the ecc used .",
    "this means that the adversary learns something about the key used to choose the ecc , and hence it can not be recycled in its entirety .",
    "a strong purity testing code with error @xmath0 is a set of codes @xmath111 , such that for all non / identity pauli operators @xmath73 , @xmath114    in we provide explicit constructions of strong purity testing codes .",
    "the main result in this paper is a proof that the family of quantum authentication protocols of barnum et al .",
    "@xcite restricted to strong purity testing codes can be used to construct a secure quantum channel that additionally produces fresh key , which we denote @xmath115 and illustrate in .",
    "such a filtered resource can be thought of as a merger between a secure channel ",
    "i.e. , a resource that transmits a message from alice to bob , only allowing eve to learn that a message has been transmitted ( or the length of the message , if this is not predetermined ) and also allowing her to prevent bob from getting the message  and a secret key resource ",
    "i.e. , a resource as depicted in , that provides both honest players with a new secret key , but where eve has additional power to control the length of the secret key distributed .",
    "the resource @xmath116 is parametrized by @xmath117 values . the length of the message @xmath5 that it can transmit , and two values @xmath118 denoting the length of the secret key that is generated .",
    "if eve is not active , both players get a fresh secret key of length @xmath119 .",
    "however , eve can prevent the players from recycling all the key , so a key of length @xmath120 is generated instead .",
    "furthermore , eve can prevent alice from learning whether the cipher was received by bob , so that she can not recycle any key ",
    "if alice were to recycle her key before bob receives the cipher , eve could use the information from the recycled key to modify the cipher without being detected .",
    "a more detailed description of this filtered resource is provided in the caption of .",
    ".6    ( channel ) at ( 0,0 ) ; at ( channel.north west ) secure channel @xmath116 ; ( aliceup ) at ( - , ) ; ( alicemiddle ) at ( -,0 ) ; ( alicedown ) at ( -,- ) ; ( bobup ) at ( , ) ; ( bobmiddle ) at ( , 0 ) ; ( bobdown ) at ( , - ) ; ( eveleft ) at ( -,- ) ; ( evecenter ) at ( 0,- ) ; ( everight ) at ( , - ) ;    ( alicedown ) to node[auto , pos=.1,yshift=-1 ] @xmath121 ( -,- ) to + ( 340:2 * ) ; ( + , - ) to node[auto , pos=.8,yshift=-1 ] @xmath122 ( bobdown ) ; ( eveleft |- alicedown ) to ( eveleft ) ;    ( key ) at ( , 0 ) key ; ( key ) to node[auto , pos=.2 ] @xmath17 ( bobmiddle ) ; ( key ) to ( , 0 ) to node[auto , swap , pos=.1 ] @xmath17 node[pos=.53 ] ( handle ) + ( 200:2 * ) ; ( -,0 ) to ( alicemiddle ) ;    ( everight ) to node[pos=.19,xshift=-1,auto , swap ] @xmath15 node[circle , fill , pos=.65,inner sep=1.5 ] ( key ) ; ( evecenter ) to node[pos=.17,xshift=-1,auto , swap ] @xmath15 ( handle.center ) ;    ( aliceup ) to node[auto , yshift=-1 ] req .",
    "( channel.west |- aliceup ) ; ( bobup ) to node[auto , swap , yshift=-1 ] req .",
    "( channel.east |- bobup ) ;    ( channels ) at ( , 0 ) ; at ( channels.north west ) secure channel @xmath116 ; ( aliceups ) at ( -+ , ) ; ( alicemiddles ) at ( -+,0 ) ; ( alicedowns ) at ( -+,- ) ; ( bobups ) at ( + , ) ; ( bobmiddles ) at ( + , 0 ) ; ( bobdowns ) at ( + , - ) ; ( fil ) at ( , - ) ; at ( fil.east ) @xmath123 ; ( evelefts ) at ( -+,- ) ; ( evecenters ) at ( , - ) ; ( everights ) at ( + , - ) ;    ( alicedowns ) to node[auto , pos=.07,yshift=-1 ] @xmath121 node[auto , pos=.93,yshift=-1 ] @xmath121 ( bobdowns ) ; ( evelefts |- alicedowns ) to ( evelefts |- fil.north ) ;    ( keys ) at ( + , 0 ) key ; ( keys ) to node[auto , pos=.2 ] @xmath17 ( bobmiddles ) ; ( keys ) to node[auto , swap , pos=.1 ] @xmath17 ( alicemiddles ) ;    ( everights |- fil.north ) to node[pos=.22,xshift=-1,auto , swap ] @xmath41 ( keys ) ; ( fil.north ) to node[pos=.18,xshift=-1,auto , swap ] @xmath41 ( , 0 ) ; at ( everights |- bobdowns ) ;    ( aliceups ) to node[auto , yshift=-1 ] req .",
    "( channels.west |- aliceups ) ; ( bobups ) to node[auto , swap , yshift=-1 ] req .",
    "( channels.east |- bobups ) ;    to construct @xmath115 , the quantum authentication protocol will use a shared secret key to encrypt and authenticate the message .",
    "this means that the players must share a secret key resource @xmath124 ( ) , is empty , this resource has a trivial empty filter , which we do not write down . ]",
    "where @xmath125 denotes the length of the key this resource provides .",
    "they also need to share an insecure quantum channel , which is used to send the message , and is illustrated in without a filter and in with a filter .",
    "the authentication protocol we consider is designed to catch any error , so if it is used over a noisy channel , it will always abort .",
    "we thus assume that the players share a noiseless channel , which we denote @xmath126 , i.e. , @xmath13 is controlled by the adversary as in .",
    "but if no adversary is present , the filter @xmath127 is noiseless . finally , the players need a backwards authentic channel , that can send one bit of information from bob to alice .",
    "this is required so that alice may learn whether the message was accepted and recycle the corresponding amount of key . the authentic channel and its filter @xmath128 are drawn in figures  [ fig : channel.dishonest.authentic ] and [ fig : channel.honest.authentic ] .",
    "putting this together in the case of an active adversary , we get , where the converters for alice s and bob s parts of the quantum authentication protocol are labeled @xmath129 and @xmath130 , respectively .    1.5    ( auth ) at ( 0,0 ) ; at ( auth.north west ) authentic channel @xmath14 ; ( ch ) at ( -,- ) ; at ( ch.north ) insecure ch .  @xmath13 ; ( key ) at ( 0 , ) ; at ( key.north west ) secret key @xmath124 ; ( prota ) at ( -,0 ) ; at ( prota.north west ) @xmath131 ; ( a1 ) at ( - , ) ; ( a2 ) at ( -,0 ) ; ( a3 ) at ( -,- ) ; ( protb ) at ( , 0 ) ; at ( protb.north east ) @xmath132 ; ( b1 ) at ( , ) ; ( b2 ) at ( , 0 ) ; ( b3 ) at ( , - ) ;    ( aliceup ) at ( - , ) ; ( alicemiddle ) at ( -,0 ) ; ( alicedown ) at ( -,- ) ; ( bobup ) at ( , ) ; ( bobmiddle ) at ( , 0 ) ; ( bobdown ) at ( , - ) ; ( eveleftl ) at ( --,- ) ; ( eveleftr ) at ( -+,- ) ; ( everightl ) at ( -,- ) ; ( everightr ) at ( + , - ) ;    ( alicedown ) to node[auto , pos=.4 ] @xmath121 ( a3 ) ; ( a3 ) to ( eveleftl |- alicedown ) to ( eveleftl ) ; ( eveleftr ) to ( eveleftr |- bobdown ) to ( b3 ) ; ( b3 ) to node[auto , pos=.8 ] @xmath133 ( bobdown ) ;    ( aliceup ) to node[auto , pos=.3 ] req . ( a1 ) ; ( bobup ) to node[auto , swap , pos=.3 ] req . ( b1 ) ; ( a2 ) to node[auto , swap , pos=.8 ] @xmath134 ( alicemiddle ) ; ( b2 ) to node[auto , pos=.6 ] @xmath135 ( bobmiddle ) ;    ( key ) at ( 0 , ) key ; ( key ) to node[auto , swap , pos=.2 ] @xmath17 ( a1 ) ; ( key ) to node[auto , pos=.2 ] @xmath17 ( b1 ) ; ( kleft ) at ( -1.1 , ) ; ( kright ) at ( 1.1 , ) ; ( a1 ) to node[auto , pos=.5 ] req .",
    "( kleft ) ; ( b1 ) to node[auto , swap , pos=.5 ] req .",
    "( kright ) ;    ( b2 ) to ( , 0 ) to node[pos=.53 ] ( handle ) + ( 200:2 * ) ; ( -2*,0 ) to ( a2 ) ; ( everightr |- bobmiddle ) to ( everightr ) ; ( everightl ) to node[auto , swap , pos=.1,xshift=-2 ] @xmath15 ( handle.center ) ;    a protocol @xmath136 is then a quantum authentication protocol with error @xmath137 if it constructs @xmath138 from @xmath139 within @xmath137 , i.e. , @xmath140    in we describe the protocol , and in we prove that is satisfied and provide the parameters @xmath141 .",
    "the family of quantum authentication protocols from @xcite consists in first encrypting the message to be sent with a quantum one - time pad , then encoding it with a purity testing code and a random syndrome .",
    "we do the same , but with a strong purity testing code .",
    "we also extend the protocol so that the players recycle all the key if the message is accepted , and the key used to select the strong purity testing code if the message is rejected .",
    "so that alice may also recycle the key , bob uses the backwards authentic classical channel to notify her of the outcome .",
    "we refer to this as the `` encrypt / then / encode '' protocol , the details of which are provided in .    quantum authentication  encrypt / then / encode    1 .",
    "alice and bob obtain uniform keys @xmath17 , @xmath87 , and @xmath106 from the key resource , where @xmath17 is long enough to choose an element from a strong purity testing code that encodes @xmath5 qubits in @xmath88 qubits , @xmath87 is @xmath142 bits and @xmath106 is @xmath7 bits . 2 .",
    "alice encrypts the message @xmath143 she receives with a quantum one - time pad using the key @xmath87 .",
    "she then appends an @xmath7 qubit state @xmath144 , and encodes the whole thing with a strong purity testing code , obtaining the cipher @xmath145 .",
    "3 .   alice sends @xmath146 to bob on the insecure channel .",
    "bob receives a message @xmath147 , he applies @xmath148 , decrypts the @xmath50 part and measures the @xmath149 part in the computational basis .",
    "if the result of the measurement is @xmath106 , he accepts the message and recycles @xmath17 , @xmath87 and @xmath106 .",
    "if the result is not @xmath106 , he rejects the message , and recycles @xmath17 .",
    "bob sends alice a bit on the backwards authentic channel to tell her if he accepted or rejected the message .",
    "when alice receives bob s bit , she either recycles all the keys or only @xmath17 .",
    "alternatively , one may perform the encoding and encryption in the opposite order : alice first encodes her message with the strong purity testing code with syndrome @xmath41 , then does a quantum one - time pad on the resulting @xmath88 qubit state .",
    "this `` encode / then / encrypt '' protocol is described in .    quantum authentication  encode / then / encrypt    1 .",
    "alice and bob obtain uniform keys @xmath17 and @xmath87 from the key resource , where @xmath17 is long enough to choose an element from a strong purity testing code that encodes @xmath5 qubits in @xmath88 qubits and @xmath87 is @xmath6 bits long . 2 .",
    "alice appends a @xmath7 qubit state @xmath150 to the message @xmath143 she receives , encodes it with a strong purity testing code chosen according to the key @xmath17 , and encrypts the whole thing with a quantum one - time pad using the key @xmath87 .",
    "she thus obtains the cipher @xmath151 .",
    "3 .   alice sends @xmath146 to bob on the insecure channel .",
    "4 .   bob receives a message @xmath147 , he applies @xmath73 , then @xmath148 , and measures the @xmath149 part in the computational basis .",
    "if the result of the measurement is @xmath41 , he accepts the message and recycles @xmath17 and @xmath87 .",
    "otherwise , he rejects the message , and recycles @xmath17 .",
    "bob sends alice a bit on the backwards authentic channel to tell her if he accepted or rejected the message .",
    "when alice receives bob s bit , she either recycles all the keys or only @xmath17 .",
    "the encode / then / encrypt protocol uses @xmath7 bits more key , and since these bits are not recycled in case of a reject , it is preferable to use the encrypt / then / encode protocol .",
    "these protocols are however identical : no external observer can detect which of two is being run .",
    "this holds , because the encode / then / encrypt protocol performs phase flips on a syndrome that is known to be in a computational basis state @xmath152 .",
    "thus , they have no effect and can be skipped .",
    "likewise , bob performs phase flips on @xmath149 before measuring in the computational basis  he might as well skip these phase flips , since they have no effect either .",
    "we formalize this statement by proving ( in ) that the converters corresponding to the two different protocols are indistinguishable .",
    "this result is similar in spirit to proofs that some prepare / and / measure quantum key distribution ( qkd ) protocols are indistinguishable from entanglement - based qkd protocols , and thus security proofs for one are security proofs for the other  @xcite .",
    "since these two protocols are indistinguishable , we provide a security proof in for the encode / then / encrypt protocol .",
    "however , in , when we count the number of bits of key consumed , we count those of the encrypt / then / encode protocol .    [",
    "lem : ete ] let @xmath153 and @xmath154 denote the pairs of converters modeling alice s and bob s behavior in the encrypt / then / encode and encode / then / encrypt protocols , respectively .",
    "then @xmath155    we start with alice s part of the protocol .",
    "let @xmath156 and @xmath131 receive keys @xmath17 , @xmath87 and @xmath106 as in the protocol from , as well as an extra key @xmath74 of length @xmath7 that is needed by @xmath131 , since it requires more key .",
    "the distinguisher prepares a state @xmath157 , and sends the @xmath50 part to the system .",
    "@xmath156 outputs @xmath158 where in the last line we used .",
    "this is exactly the state output by @xmath131 if when receiving the key @xmath159 , the protocol uses the pauli @xmath98 for the quantum one - time pad .    for bob s part of the protocol ,",
    "let the distinguisher prepare a state @xmath160 and send the @xmath161 part to the system .",
    "the subnormalized state held jointly by @xmath162 and the distinguisher after decoding and performing the measurement is given by @xmath163 we again obtain the state that is jointly held by @xmath132 and the distinguisher if when receiving the key @xmath159 , the protocol uses the pauli @xmath98 for the quantum one - time pad .",
    "[ rem : classicalmessage ] if part of the message is classical ",
    "i.e. , it is diagonal in the computational basis and known not to have a purification held be the distinguisher  then running the same proof as , one can show that it is sufficient to perform bit flips on that part of the message , the phase flips are unnecessary .",
    "this is the case with the protocol from , that generates a key @xmath21 locally and sends it to bob using a quantum authentication scheme .",
    "we use this to save some bits of key in the bounds from and .",
    "suppose that there exists a strong purity testing code @xmath111 of size @xmath164 and with error @xmath0 that encodes an @xmath5 qubit message in an @xmath88 qubit cipher . and let @xmath165 denote alice and bob s converters when running the encode / then / encrypt protocol from .",
    "more precisely , if @xmath129 receives a message at its outer interface , it requests a key from the key resource , encrypts the message as described and sends the cipher on the insecure channel .",
    "it may receive three symbols from the backwards authentic channel : an error @xmath166 , in which case it does not recycle any key , a message @xmath41 saying that @xmath130 did not receive the correct state , in which case it recycles the part of the key of length @xmath167 used to choose the code , or a message @xmath81 saying that @xmath130 did receive the correct state , in which case it recycles all the key .",
    "if @xmath129 first receives a message on the backward authentic channel before receiving a message to send , it will not recycle any key .",
    "similarly , when @xmath130 receives a cipher on the insecure channel , it requests a key from the key resource , performs the decryption , outputs either the message or an error depending on the result of the decryption , and sends this result back to @xmath129 on the authentic channel .",
    "the real system consisting of these converters and the resources they use is depicted in .",
    "[ thm : auth ] let @xmath168 denote the protocol described above",
    ". then @xmath168 constructs a secure channel that recycles key , @xmath169 , given an insecure quantum channel @xmath126 , a backward authentic channel @xmath170 and a secret key @xmath171 , i.e. , @xmath172 with @xmath173 , where @xmath0 is the error of the strong purity testing code .    in order to prove this theorem",
    ", we need to find a simulator such that the real and ideal systems are indistinguishable except with advantage @xmath174 .",
    "the simulator that we use is illustrated in .",
    ".6 ( channel ) at ( 0,0 ) ; at ( channel.north west ) secure channel @xmath116 ; ( sim ) at ( 0,- ) ; at ( sim.north east ) @xmath175 ; ( aliceup ) at ( - , ) ; ( alicemiddle ) at ( -,0 ) ; ( alicedown ) at ( -,- ) ; ( bobup ) at ( , ) ; ( bobmiddle ) at ( , 0 ) ; ( bobdown ) at ( , - ) ; ( eveleftl ) at ( -3*,- ) ; ( eveleftr ) at ( -,- ) ; ( everightl ) at ( , - ) ; ( everightr ) at ( 3*,- ) ;    at ( -2.5*,- ) @xmath176 ;    ( alicedown ) to node[auto , pos=.1,yshift=-1 ] @xmath121 ( -,- ) to + ( 340:2 * ) ; ( + , - ) to node[auto , pos=.8,yshift=-1 ] @xmath122 ( bobdown ) ; ( eveleftl |- alicedown ) to ( eveleftl |-sim.north ) ; ( eveleftl     ( key ) at ( , 0 ) key ; ( key ) to node[auto , pos=.2 ] @xmath17 ( bobmiddle ) ; ( key ) to ( -+,0 ) to node[auto , swap , pos=.1 ] @xmath17 node[pos=.53 ] ( handle ) + ( 200:2 * ) ; ( --,0 ) to ( alicemiddle ) ;    ( everightl |- sim.north ) to node[pos=.2,xshift=-1,auto , swap ] @xmath15 node[circle , fill , pos=.61,inner sep=1.5 ] ( key ) ; ( eveleftr ) to node[pos=.08,xshift=-1,auto , swap ] @xmath15 ( handle.center ) ;    ( everightr |- sim.south ) to node[auto , pos=.6 ] @xmath15 ( everightr ) ; ( everightl ) to node[auto , pos=.5,xshift=-1,swap ] @xmath177 ( everightl |- sim.south ) ;    ( aliceup ) to node[auto , yshift=-1 ] req .",
    "( channel.west |- aliceup ) ; ( bobup ) to node[auto , swap , yshift=-1 ] req .",
    "( channel.east |- bobup ) ;    it is trivial to show that correctness holds with error @xmath41 , namely that @xmath178 we now prove the case of security , i.e. , @xmath179    the real and ideal systems , drawn in figures  [ fig : auth.real ] and [ fig : auth.ideal ] have @xmath180 inputs .",
    "the distinguisher thus has the choice between @xmath181 possible orders for providing inputs .",
    "however , most of these orders are redundant and do not need to be analyzed .",
    "providing the requests for the secret keys before they are ready is pointless .",
    "so it is sufficient to look at the case where these requests are made as soon as the keys are available for recycling , i.e. , after bob has received the message from alice and after alice has received the confirmation from bob .",
    "what is more , neither sending alice an error on the backwards authentic channel nor allowing her to get bob s confirmation will help either way , since the distinguisher already knows what output alice will produce , so we can completely ignore this input . that leaves only @xmath9 in - ports , and thus @xmath9 orders to analyze :    1 .",
    "the distinguisher first inputs a message at alice s interface , gets the cipher at eve s interface , inputs a possibly modified cipher at eve s interface , gets the output at bob s interface , and requests the recycled key .",
    "2 .   the distinguisher first inputs a fake cipher at eve s interface ,",
    "gets the output at bob s interface , makes a request for his recycled key , then inputs a message at alice s interface and receives the cipher for that message .",
    "we start with the first case , the initial message is sent to alice .",
    "the distinguisher prepares a message @xmath182 and inputs the @xmath183 part at alice s interface .",
    "the ideal channel then notifies the simulator that a message has been input .",
    "the simulator prepares a maximally entangled state @xmath176 of dimension @xmath184 and outputs the @xmath185 register at eve s interface .",
    "the distinguisher now holds a bipartite state in @xmath186 , to which it applies a unitary @xmath187 . without loss of generality ,",
    "one may write the unitary as @xmath188 , where @xmath189 are paulis acting on the cipher register @xmath185 and @xmath190 act on the distinguisher s internal memory @xmath29 . the resulting state in the @xmath185 register is input back in the @xmath29 interface .",
    "the simulator now measures @xmath191 in the bell basis defined by the projectors @xmath192 .",
    "if the outcome is @xmath193  where @xmath194  it tells the channel that the cipher was not modified . in which case the contents of the register @xmath183 is output at bob s interface with an @xmath195 flag . furthermore , it generates a fresh uniform key @xmath196 , where @xmath197 and @xmath198 .",
    "if the outcome is @xmath199 , then the simulator notifies the channel to delete the message and output a @xmath200 flag , as well as prepare only the shorter key @xmath17 .",
    "the distinguisher then sends a request to obtain the fresh key .",
    "so the final state held by the distinguisher interacting with the ideal system is @xmath201",
    "\\\\ { } +    \\sum_{j \\neq 0 } \\proj{{\\textsf{rej } } } \\tensor \\tau^{k } \\tensor e^e_j \\rho^e    \\hconj{\\left(e^e_j\\right)}\\,,\\end{gathered}\\ ] ] where @xmath202 and @xmath203 are fully mixed states and @xmath204{\\proj{\\psi}^{me}}$ ] .",
    "one could append states @xmath205 and @xmath206 in the @xmath200 branch of so that both terms have the same number of registers ; we omit them for simplicity .    in the real system , for the secret key @xmath196",
    ", the state before bob s measurement of the syndrome is given by @xmath207 where @xmath208 denotes the symplectic product defined in .",
    "let @xmath209 be the set of indices @xmath210 such that the error @xmath211 produces a syndrome @xmath106 when code @xmath17 is used , i.e. , @xmath212 ( see )",
    ". for @xmath213 , let @xmath214 then @xmath215 the next step in bob s protocol consists in measuring the syndrome .",
    "if @xmath108 is obtained , he outputs the message as well as the key @xmath196 and a flag @xmath195 .",
    "otherwise he deletes the message , outputs @xmath17 with the flag @xmath200",
    ". the final state held be the distinguisher in this case is @xmath216 where we have used @xmath217 for some unitary @xmath218 .    setting @xmath219 the distance between real and ideal systems may be written as @xmath220    @xmath221 and @xmath222 are both pure states , so from we bound their distance as @xmath223 where @xmath224 is the vector @xmath9/norm and we used the fact that @xmath225 . from jensen s inequality and using",
    "we obtain @xmath226 finally , because the code is a strong purity testing code with error @xmath0 and that @xmath227 with @xmath228 , we get @xmath229    in the reject branch of the real system we have @xmath230 where we used again .",
    "thus @xmath231 putting all this together we get @xmath232    we now consider the second case : the distinguisher first prepares a state @xmath233 and inputs the @xmath185 part at eve s interface , then obtains the output at bob s interface",
    ". note that in the ideal case the channel always outputs a @xmath200 message at bob s interface .",
    "thus , if the cipher is accepted by bob  who outputs a state @xmath221  the distinguisher must be interacting with the real system and can already output this guess . in the case of a rejection , it now holds a bipartite system @xmath234  the recycled key @xmath235 and its purifying system @xmath29 .",
    "it then applies an isometry @xmath236 to this system and inputs the @xmath183 part of the resulting state at alice s interface .",
    "after which it obtains a cipher at eve s interface and holds the tripartite system @xmath237  the recycled key @xmath235 , the cipher @xmath185 and its internal memory @xmath29 .",
    "we denote this state @xmath238 in the ideal case and @xmath239 in the real case , and we need to bound @xmath240    in a first step , we assume that the state @xmath233 prepared by the distinguisher is an antisymmetric fully entangled state , which we denote @xmath241 , where @xmath242 is the hamming weight of @xmath243 and @xmath244 is the string @xmath21 with all bits flipped . in the ideal case",
    "the simulator notifies the channel to reject the cipher , and the state @xmath245 is output at bob s interface .",
    "the distinguisher then holds @xmath246 . in the real case",
    ", bob applies the decoding algorithm , i.e. , first a pauli @xmath247 , then a unitary @xmath248 and finally measures @xmath7 bits of the syndrome in the computational basis .",
    "since the antisymmetric state is invariant under @xmath249 , one could equivalently apply the inverse operation , @xmath250 , to the @xmath29 system , i.e. , the state after bob s measurement is given by @xmath251 if @xmath108 bob accepts the cipher as being valid , which happens with probability @xmath252 , i.e. , @xmath253 .",
    "in the case where @xmath254 , he deletes the cipher , so the remaining state is given by @xmath255 where @xmath256 @xmath235 is made public and the @xmath257 system is the part of the key kept secret by the players .",
    "let @xmath258 denote the completely positive , trace / preserving ( cptp ) map consisting of the distinguisher s next step  the isometry @xmath236  and the final operation of the ideal system  deleting the message system @xmath183 that is input at alice s interface and outputting a fully mixed state @xmath259 .",
    "let @xmath260 denote the cptp map consisting of the distinguisher s next step and the final operation of the real system  encoding the message system @xmath183 according to the protocol and outputting the resulting cipher .",
    "we have @xmath261 and @xmath262 .",
    "thus , @xmath263 since @xmath264 . finally , note that we have @xmath265 for @xmath266{u \\left",
    "( \\tau^k \\tensor \\tau^e\\right )      \\hconj{u}}$ ] , since the random pauli @xmath73 applied by the encryption algorithm completely decouples the cipher from @xmath234 .",
    "putting this together , we get @xmath267 since a strong purity testing code will always have an error @xmath268 .    the final case that remains to consider is when the distinguisher prepares a state @xmath233 that is not the antisymmetric state .",
    "we will reduce this case to that of the entangled antisymmetric by using the entangled state @xmath269 to teleport the @xmath177 part of any state @xmath270 .",
    "let the teleportation scheme be given by the projectors @xmath271 on @xmath272 which incur a pauli correction @xmath273 on the @xmath185 system , i.e. , @xmath274{\\sum_a p^c_a \\tensor m^{ec'}_a \\left (      \\proj{\\psi^-}^{ce } \\tensor",
    "\\proj{\\psi}^{c'e'}\\right ) p^c_a \\tensor m^{ec'}_a } = \\proj{\\psi}_{ce ' } \\,.\\ ] ] so the distinguisher prepares an entangled state @xmath275 and the state it wishes to send to bob , @xmath270 .",
    "it teleports the @xmath177 register to the @xmath185 register , and sends this to bob , who performs his decryption operation @xmath276 .",
    "this results in the shared state @xmath277 \\\\ & \\qquad = \\frac{1}{2^{\\nu+2m+2n } } \\sum_{k,\\ell , a } \\proj{k,\\ell \\xor    a } \\tensor \\big [ \\left(\\hconj{\\left(u_k^c\\right ) } p^c_\\ell \\tensor m^{ec'}_a\\right)\\\\    & \\qquad \\qquad \\qquad \\qquad     \\left ( \\proj{\\psi^-}^{ce } \\tensor \\proj{\\psi}^{c'e'}\\right )      \\left(p^c_\\ell u^c_k \\tensor m^{ec'}_a\\right ) \\big ] \\\\ & \\qquad = \\frac{1}{2^{\\nu+2m+2n } } \\sum_{k,\\ell , a } x^l_a \\proj{k,\\ell }    x^l_a \\tensor \\big [ \\left(i^c \\tensor m^{ec'}_a p^e_\\ell u^e_k \\right)\\\\    & \\qquad \\qquad \\qquad \\qquad \\left ( \\proj{\\psi^-}^{ce } \\tensor \\proj{\\psi}^{c'e'}\\right )      \\left(i^c \\tensor \\hconj{\\left(u_k^e\\right ) } p^e_\\ell      m^{ec'}_a\\right ) \\big]\\,,\\end{aligned}\\ ] ] where @xmath278 flips the bits of @xmath87 in the positions where @xmath279 .",
    "the teleportation of @xmath280 is thus equivalent to a measurement of the distinguisher s system followed by a correction of the secret key @xmath87 .",
    "this may however be performed after bob measures the syndrome and accepts or rejects the cipher he received .",
    "the probability of accepting the cipher is thus unchanged , and plugging in the result from the case where the distinguisher sends bob half of the anti / symmetric entangled state , we find that the state of the real system in the rejection branch after bob s operations is @xmath281 where @xmath282 .",
    "and in the ideal system the state after the ideal channel outputs a rejection is @xmath283 .",
    "we thus obtain the same bound on the distance between real and ideal systems as in the previous case .",
    "it follows from that is also a proof of security for the encrypt / then / encode protocol from , i.e. , @xmath284 with @xmath173 .",
    "thus , in the case where the message is not accepted by bob , @xmath12 bits of key are lost .",
    "we prove here that this is optimal : one can not recycle any extra bit of key .",
    "[ lem : auth.optimal ] there exists an adversarial strategy to obtain all the secret bits that are not recycled in the encrypt / then / encode protocol .",
    "the distinguisher prepares epr pairs @xmath285 and provides the @xmath183 part to alice .",
    "it then receives the cipher and thus holds the state @xmath286 which it keeps .",
    "it then sends a bogus cipher to bob , and obtains the key @xmath17 after bob recycles it .",
    "it applies the decoding unitary @xmath287 , measures the @xmath149 register to get the secret key @xmath106 and measures the joint @xmath288 register in the bell basis to get the secret key @xmath87 .",
    "the protocols we have given in use strong purity testing codes , and the parameters of the key used , key recycled and error depend on the parameters of these codes . in this section we give two constructions of purity testing codes .",
    "the first requires less initial secret key , the second has a better error parameter .",
    "both have the same net consumption of secret key bits .",
    "the first construction is from barnum et al .",
    "@xcite . they give an explicit strong purity testing code with @xmath289 and @xmath290 . and",
    "we remove one of the keys ( and thus increase the error ) , so as to get simpler final expressions . ] plugging this in the parameters from with the encrypt / then / encode protocol , we get the following .",
    "[ cor : auth.1 ] the encrypt / then / encode protocol with the purity testing code of @xcite requires an initial key of length @xmath6 .",
    "it recycles all bits if the message is accepted , and @xmath7 bits if the message is rejected .",
    "the error is @xmath292    the second construction we give is based on an explicit purity testing code by chau  @xcite  though he does not name it this way .",
    "chau  @xcite finds a set of unitaries @xmath293 in dimension @xmath294 such that , if @xmath17 is chosen uniformly at random , any non / identity pauli is mapped to every non / identity pauli with equal frequency , i.e. , @xmath295 with @xmath296 and @xmath297 , @xmath298 where @xmath299 is some global phase .",
    "we prove in , , that this is a strong purity testing code with @xmath300 for @xmath301 .",
    "it also has @xmath302 , hence @xmath303 .",
    "note that when composed with paulis as in the encode / then / encrypt protocol , @xmath304 is a unitary @xmath9/design  @xcite .",
    "it follows that any ( approximate ) unitary @xmath305/design is a good quantum authentication scheme ( see for a formal proof ) .",
    "[ cor : auth.2 ] the encrypt / then / encode protocol with the purity testing code of @xcite requires an initial key of length @xmath10 .",
    "it recycles all bits if the message is accepted , and @xmath306 bits if the message is rejected .",
    "the error is @xmath307 .",
    "we proved in that the quantum authentication protocols from figures  [ fig : protocol.1 ] and [ fig : protocol.2 ] construct a secure channel that recycles key @xmath138 from a shared secret key @xmath308 , a noiseless insecure quantum channel @xmath309 and a backwards authentic classical channel @xmath128 , namely , @xmath310 in this section we show how to construct the required resources from nothing but shared secret key and noisy channels , then put it all together to get the exact bounds of the composed protocols .",
    "we discuss in how to obtain the authentic channel : it can be constructed from a shared secret key and an insecure channel using any ( classical ) mac / type authentication scheme  @xcite .",
    "channels are however usually not noiseless .",
    "this is solved by using error correction : an error correction code constructs a noiseless channel given a noisy channel ( with known noise ) , and is presented in .",
    "were we to put things together at this point , we would construct the desired secure quantum channel from nothing but shared secret key and insecure noisy channels .",
    "but even in the case where no adversary is present , we would still consume some secret key , because we do not recycle the key from the backwards authentic channel .",
    "so in we construct shared secret key given a secure channel  we simply share secret key using the channel .",
    "combining all these pieces together , we obtain our secure quantum channel without any net consumption of key in the case where the adversary does not tamper with the messages .",
    "the security of the composed scheme follows immediately from the security of each component and the composition theorem of ac  @xcite . finally , in we discuss a setting in which the backwards authentic channel is not needed , thus allowing a more efficient use of the quantum channel",
    " since we do not need it to distribute key , and can thus use all of its capacity to send messages .",
    "we used classical authentication as an example in : an authentication protocol @xmath311 constructs an authentic channel @xmath128 given a ( noiseless ) insecure channel @xmath126 and a secret key @xmath312 , @xmath313 the corresponding real and ideal systems were illustrated in figures  [ fig : classicalauth.real ] and [ fig : classicalauth.ideal ] , respectively . appending the mac @xmath314 to the message @xmath21 is sufficient to construct the authentic channel with error @xmath0 if the family of functions @xmath66 is @xmath0/almost strongly @xmath9/universal  @xcite . in our case , bob only needs to send a @xmath81-bit message to alice .",
    "if the key @xmath17 has length @xmath315 , a @xmath316/almost strongly @xmath9/universal family of functions for @xmath81-bit messages is given by @xmath317 , where @xmath318 are the first @xmath319 bits of @xmath17 and @xmath320 are the last @xmath319 bits .",
    "[ lem : classicalauth ] the authentication scheme described above satisfies with @xmath321",
    ".    follows from ( * ? ? ?",
    "* lemma 9 ) .      both the classical authentication protocol discussed in and [ sec : construction.auth ] , as well as the quantum authentication protocol analyzed in produce an error message as soon as there is any disturbance on the channel .",
    "realistic channels are naturally noisy , so for such protocols to even make sense , one needs an extra layer of error correction that is designed to correct the specific noise on the channel . here , we formalize this as a constructive statement .",
    "let @xmath322 encode a message with an error correcting code ( ecc ) given by the completely positive , trace / preserving ( cptp ) map @xmath258 , and @xmath323 decode the message with the cptp map @xmath324 , as illustrated in . and let @xmath325 be the error of the ecc for noise given by a cptp map @xmath260 , i.e. , @xmath326 then @xmath327 constructs a noiseless ( insecure ) channel @xmath328 from a noisy ( insecure ) channel @xmath329 , if the filter @xmath39 introduces the noise @xmath260 , i.e. , @xmath330    [ .5][c ]    1.3    ( ch ) at ( 0,0 ) ; at ( ch.north ) insecure ch .",
    "@xmath331 ; ( fil ) at ( 0,- ) ; ( noise ) at ( 0,- ) @xmath260 ; at ( fil.north west ) @xmath39 ; ( prota ) at ( -,0 ) ; ( pia ) at ( -,0 ) @xmath258 ; at ( prota.north west ) @xmath322 ; ( protb ) at ( , 0 ) ; ( pib ) at ( , 0 ) @xmath324 ; at ( protb.north west ) @xmath323 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( pia ) ; ( pia ) to ( -,0 ) to ( -,- ) ; ( -,- ) to ( noise ) ; ( noise ) to ( , - ) ; ( , - ) to ( , 0 ) to ( pib ) ; ( pib ) to ( bob.center ) ;    [ .5][c ]    1.3    ( ch ) at ( 0,0 ) ; at ( ch.north west ) insecure channel @xmath13 ; ( fil ) at ( 0,- ) ; at ( fil.north west ) @xmath127 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ;    ( alice.center ) to ( -,0 ) to ( -,- ) ; ( -,- ) to ( , - ) ; ( , - ) to ( , 0 ) to ( bob.center ) ;    [ .5][c ]    1.4    ( ch ) at ( 0,0 ) ; at ( ch.north ) insecure ch .  @xmath331 ; ( prota ) at ( -,0 ) ; ( pia ) at ( -,0 ) @xmath258 ; at ( prota.north west ) @xmath322 ; ( protb ) at ( , 0 ) ; ( pib ) at ( , 0 ) @xmath324 ; at ( protb.north west ) @xmath323 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ; ( evel ) at ( -,- ) ; ( ever ) at ( , - ) ;    ( alice.center ) to ( pia ) ; ( pia ) to ( -,0 ) to ( evel ) ; ( ever ) to ( , 0 ) to ( pib ) ; ( pib ) to ( bob.center ) ;    [ .5][c ]    1.3 ( ch ) at ( 0,0 ) ; at ( ch.north west ) insecure channel @xmath13 ; ( fil ) at ( 0,- ) ; at ( fil.north west ) @xmath332 ; ( alice ) at ( -,0 ) ; ( bob ) at ( , 0 ) ; ( evel ) at ( -,- ) ; ( ever ) at ( , - ) ;    ( siml ) at ( -,- ) @xmath258 ; ( simr ) at ( , - ) @xmath324 ;    ( alice.center ) to ( -,0 ) to ( siml ) ; ( siml ) to ( evel ) ; ( ever ) to ( simr ) ; ( simr ) to ( , 0 ) to ( bob.center ) ;    note that the resources @xmath13 and @xmath331 are of different dimension , since an error correcting code will map a quantum state to a new one of larger dimension . in this work",
    "we generally we do not use different notation for channels of different dimensions , since the dimension is usually clear from the context , and we juste write @xmath13 for an insecure channel .",
    "we distinguish a noiseless from a noisy channel by its filter , @xmath127 and @xmath39 , respectively .",
    "[ lem : noiseless ] if the filter @xmath39 introduces noise given by a cptp map @xmath260 , and the encoding and decoding maps @xmath258 and @xmath324 satisfy , then the protocol @xmath333 that uses this ecc satisfies .",
    "we need to prove that @xmath334 and @xmath335 for some simulator @xmath332 to satisfy the two conditions from .",
    "these systems are drawn in .",
    "one can easily check from the figure that the first condition holds because the ecc was designed to achieve exactly this . @xmath336 and @xmath337 are each a pair of channels , one performing the encoding operation @xmath258 , the other the decoding operation @xmath324 , so the second condition holds with distance @xmath41 .",
    "naturally , only makes sense if there exists a code than can correct the errors introduced by @xmath260 , i.e. , if there exist maps @xmath338 that satisfy . in this work ,",
    "when we talk about a noisy channel resource , we always mean such a channel that has non / zero capacity .",
    "it is trivial to share secret key using a secure channel : alice generates a uniform string and sends it on the secure channel to bob .",
    "if the channel can transmit an @xmath339 qubit state and we use it to share a @xmath340 bit key , then @xmath5 qubits can still be used to transmit a message .",
    "this protocol is depicted in .",
    ".6 ( channel ) at ( 0,0 ) ; at ( channel.north west ) secure ch .  @xmath341 ; ( pia ) at ( -,0 ) ; at ( pia.north west ) @xmath342 ; at ( pia.south ) @xmath343 ;    ( pib ) at ( , 0 ) ; at ( pib.north west ) @xmath344 ; ( aliceup ) at ( - , ) ; ( alicemiddle ) at ( -,0 ) ; ( alicedown ) at ( -,- ) ; ( bobup ) at ( , ) ; ( bobmiddle ) at ( , 0 ) ; ( bobdown ) at ( , - ) ; ( eveleft ) at ( -,- ) ; ( evecenter ) at ( 0,- ) ; ( everight ) at ( , - ) ;    ( pia.east |- alicedown ) to node[auto , pos=.1,yshift=-1 ] @xmath345 ( -,- ) to + ( 340:2 * ) ; ( + , - ) to ( pib.west |- bobdown ) ; at ( pib.west |- bobdown ) @xmath133 ; ( eveleft |- alicedown ) to ( eveleft ) ;    ( alicedown ) to node[auto , yshift=-1 ] @xmath121 ( pia.west |- alicedown ) ; ( pib.east |- bobdown ) to node[auto , pos=.5,yshift=-1 ] @xmath122 ( bobdown ) ;    ( key ) at ( , 0 ) key ; ( key ) to node[auto , pos=.2 ] @xmath17 ( pib ) ; ( key ) to ( , 0 ) to node[auto , swap , pos=.1 ] @xmath17 node[pos=.53 ] ( handle ) + ( 200:2 * ) ; ( -,0 ) to ( pia ) ;    ( pia ) to node[auto , swap , pos=.75,yshift=-1 ] @xmath346 ( alicemiddle ) ; ( pib ) to node[auto , pos=.5,yshift=-1 ] @xmath347 ( bobmiddle ) ;    ( everight ) to node[pos=.19,xshift=-1,auto , swap ] @xmath15 node[circle , fill , pos=.65,inner sep=1.5 ] ( key ) ; ( evecenter ) to node[pos=.17,xshift=-1,auto , swap ] @xmath15 ( handle.center ) ;    ( pia.east |- aliceup ) to node[auto , yshift=-1 ] req .",
    "( channel.west |- aliceup ) ; ( pib.west |- bobup ) to node[auto , swap , yshift=-1 ] req .",
    "( channel.east |- bobup ) ; ( aliceup ) to node[auto , yshift=-1 ] req .",
    "( pia.west |- aliceup ) ; ( bobup ) to node[auto , swap , yshift=-1 ] req .",
    "( pib.east |- bobup ) ;    [ lem : morekey ] let @xmath348 denote the protocol described above .",
    "it constructs a @xmath349 secure channel from a @xmath350 secure channel with no error , i.e. , @xmath351    this lemma trivially holds with an empty simulator .",
    "if we compose all the protocols described above , we obtain the system depicted in .",
    "let @xmath352 denote the composition of alice s converters and @xmath353 denote the composition of bob s converters .",
    "we then immediately get that the @xmath52 constructs a secure channel with key recycling , @xmath349 , from secret keys @xmath308 and @xmath312 , and two noisy channels @xmath354 and @xmath355 with error @xmath356 , where the arrows are used to distinguisher the forward quantum channel and the backward classical channel , i.e , @xmath357    1.5 1 ( keylong ) at ( 0,3 * ) ; at ( keylong.north west ) secret key @xmath124 ; ( keyshort ) at ( 0,2 * ) ; at ( keyshort.north west ) secret key @xmath358 ; ( chback ) at ( 0 , ) ; at ( chback.north west ) insecure channel @xmath359 ; ( chforward ) at ( -,0 ) ; at ( chforward.north west ) ins .",
    "@xmath360 ;    ( peccbacka ) at ( - , ) ; at ( peccbacka.north ) @xmath361 ; ( peccbackb ) at ( , ) ; at ( peccbackb.north ) @xmath362 ; ( peccforwarda ) at ( -,0 ) ; at ( peccforwarda.north ) @xmath363 ; ( peccforwardb ) at ( , 0 ) ; at ( peccforwardb.north ) @xmath364 ; ( pcautha ) at ( --,3*/2 ) ; at ( pcautha.north ) @xmath20 ; ( pcauthb ) at ( + , 3*/2 ) ; at ( pcauthb.north ) @xmath365 ; ( pqautha ) at ( --2*,3*/2 ) ; at ( pqautha.north ) @xmath131 ; ( pqauthb ) at ( + 2*,3*/2 ) ; at ( pqauthb.north ) @xmath132 ; ( pkeya ) at ( --3*,3*/2 ) ; ( keylabela ) at ( pkeya.north ) @xmath366 ; ( pkeyb ) at ( + 3*,3*/2 ) ; ( keylabelb ) at ( pkeyb.north ) @xmath367 ;    ( compa ) ; at ( compa.north west ) composed protocol @xmath352 ; ( compb ) ; at ( compb.north west ) composed protocol @xmath353 ;    ( aliceup ) at ( -,5*/2 ) ; ( alicemiddle ) at ( -,3*/2 ) ; ( alicedown ) at ( -,/2 ) ; ( bobup ) at ( , 5*/2 ) ; ( bobmiddle ) at ( , 3*/2 ) ; ( bobdown ) at ( , /2 ) ; ( eveleftl ) at ( --,- ) ; ( eveleftr ) at ( -+,- ) ; ( everightl ) at ( -,- ) ; ( everightr ) at ( + , - ) ;    ( aq ) at ( --2*,3 * ) ; ( bq ) at ( + 2*,3 * ) ; ( ak1 ) at ( -+,3 * ) ; ( bk1 ) at ( -,3 * ) ; ( ac ) at ( --,2 * ) ; ( bc ) at ( + , 2 * ) ; ( ak2 ) at ( -+,2 * ) ; ( bk2 ) at ( -,2 * ) ;    ( aliceup.center ) to node[auto , pos=.4 ] req .",
    "( pkeya.west |- aliceup ) ; ( pkeya.west |- alicemiddle ) to node[auto , swap , pos=.6 ] @xmath17 ( alicemiddle.center ) ; ( alicedown.center ) to node[auto , pos=.4 ] @xmath121 ( pkeya.west |- alicedown ) ; ( bobup.center ) to node[auto , pos=.4,swap ] req .",
    "( pkeyb.east |- aliceup ) ; ( pkeyb.east |- alicemiddle ) to node[auto , pos=.6 ] @xmath17 ( bobmiddle.center ) ; ( pkeyb.east |- alicedown ) to node[auto , pos=.6 ] @xmath121 ( bobdown.center ) ;    ( pkeya.east |- aliceup ) to ( pqautha.west |- aliceup ) ; ( pqautha.west |- alicemiddle ) to ( pkeya.east |- alicemiddle ) ; ( pkeya.east |- alicedown ) to ( pqautha.west |- alicedown ) ; ( pkeyb.west |- aliceup ) to ( pqauthb.east    alicemiddle ) ; ( pqauthb.east |- alicedown ) to ( pkeyb.west |- alicedown ) ;    ( ak1 ) to ( aq ) ; ( aq ) to ( ak1 ) ; ( bk1 ) to ( bq ) ; ( bq ) to ( bk1 ) ; ( pcautha ) to ( pqautha ) ; ( pqauthb ) to ( pcauthb ) ; ( pqautha.east |- chforward ) to ( peccforwarda ) ; ( peccforwardb ) to ( pqauthb.west |- chforward ) ;    ( ak2 ) to ( ac ) ; ( ac ) to ( ak2 ) ; ( bk2 ) to ( bc ) ; ( bc ) to ( bk2 ) ; ( peccbacka ) to ( pcautha.east |- chback ) ; ( pcauthb.west |- chback ) to ( peccbackb ) ;    ( peccforwarda ) to ( eveleftl |- chforward ) to ( eveleftl.center ) ; ( eveleftr.center ) to ( eveleftr |- chforward ) to ( peccforwardb ) ; ( peccbackb ) to ( everightr |- chback ) to ( everightr.center ) ; ( everightl.center ) to ( everightl |- chback ) to ( peccbacka ) ;    in the following we assume for simplicity that @xmath368 and take @xmath369 . plugging in @xmath370 and the parameters from the two explicit quantum authentication protocols from",
    ", we get the following two corollaries . uses the explicit construction proposed by barnum et al .",
    "@xcite . uses the explicit unitary @xmath9/design construction from chau@xcite ( see for details ) .",
    "[ cor : construction.1 ] for any @xmath5 and @xmath7 , there exist an explicit protocol that requires @xmath371 bits of secret key , a forward noisy insecure quantum channel and a backward noisy insecure classical channel , to construct a secure channel for an @xmath5 qubit quantum message , which recycles all the key if the message is accepted and @xmath7 bits if the message is rejected , and has error @xmath372    follows from the composition theorem from ac  @xcite as well as , , , , and .",
    "[ cor : construction.2 ] for any @xmath5 and @xmath7 , there exists an explicit protocol that requires @xmath373 bits of secret key , a forward noisy insecure quantum channel and a backward noisy insecure classical channel , to construct a secure channel for an @xmath5 qubit quantum message , which recycles all the key if the message is accepted and @xmath374 bits if the message is rejected , and has error @xmath375    follows from the composition theorem from ac  @xcite as well as , , , , and .",
    "note that both schemes have a loss of @xmath376 key bits if the message is not successfully authenticated : @xmath142 bits used to one - time pad the quantum message of length @xmath5 , @xmath377 bits to one - time pad the two classical strings of @xmath7 bits ",
    "the @xmath7 bits of key sent to replace those consumed by the backwards authentic channel and the @xmath7 bits used as syndrome  and finally the @xmath7 bits consumed by the backwards authentic channel can not be replaced , so they are lost as well .",
    "the backwards authentic channel is crucial in the construction of the secure channel with key recycling analyzed in this section , because without it , alice would not know that her message arrived  let alone whether it was accepted or not  and thus not be able to recycle the key .",
    "one can however skip the authentic channel if the players share a stronger resource , e.g. , another secure quantum channel that recycles key .",
    "this is the case if the players construct secure quantum channels in both directions and alternate between the two : first alice sends a quantum message to bob , then bob to alice , then alice to bob , etc .",
    "let them share two sets of keys , one set is used for the forward communication , the other is used for the backward communication .",
    "if at any point a message is not successfully authenticated , this means that an eavesdropper is disturbing the communication , and the players abort and stop communicating .",
    "thus , bob only sends his next message to alice if he successfully received her message .",
    "so if alice successfully authenticates bob s message , she knows that hers was received , and can recycle all of her key to send the next message .",
    "we thus avoid any explicit confirmation of reception , since sending the next message is in itself the confirmation .    one case",
    "easily show that the composition of @xmath7 rounds of this protocol , each round sending an @xmath5 qubit quantum message , constructs a secure channel for @xmath378 qubits , which we denote @xmath379 .",
    "unlike the resource @xmath380 which gave the adversary a @xmath81 bit input to decide if the message is delivered or not , @xmath379 provides the adversary with a bit of input for every block of @xmath5 qubits  but if one block is prevented from being delivered , none of the subsequent messages are delivered either .",
    "the error of this construction is @xmath7 times the error of each round , @xmath381",
    ". this may continue arbitrary long if no adversary introduces noise on the channel , since the quantum authentication protocol recycles every bit of key .",
    "the family of quantum authentication protocols of barnum et al .",
    "@xcite as well as the subset analyzed in this work are large classes , which include many protocols appearing independently in the literature .",
    "the signed polynomial code @xcite , the clifford code @xcite ( which is a unitary @xmath117/design  @xcite ) and the unitary @xmath382/design scheme from @xcite and all instances which use a strong purity testing code .",
    "our results apply directly to the clifford and unitary @xmath382/design schemes  which have in the same error as the unitary @xmath9/design scheme from .",
    "but the signed polynomial code uses an ecc on qudits , not qubits , so our proof does not cover this case , and would have to be adapted to do so .",
    "the trap code  @xcite is an example of a quantum authentication scheme that uses a purity testing code that is not a strong purity testing code , i.e. , errors which do not modify the message do not necessarily provoke an abort .",
    "for example , if the adversary performs a simple bit flip in one position , this will provoke an abort with probability @xmath383 in the variant from @xcite and with probability @xmath384 in the variant from @xcite , but leaves the message unmodified if no abort occurs .",
    "if the adversary learns whether bob accepted the message or not , she will learn whether the ecc used detects that specific bit flip or not , and thus learn something about the key used to select the ecc .",
    "hence , the players can not recycle the entire key , even in the case where the message is accepted .",
    "the restriction to strong purity testing codes is thus necessary to recycle every bit .",
    "it remains open how many bits of key can be recycled with the trap code .    another quantum authentication scheme , auth - qft - auth , has been proposed in @xcite , where the authors prove that some of the key can be recycled as well .",
    "we do not know if this scheme fits in the family from  @xcite or not .",
    "in the classical case , almost strongly @xmath9/universal hash functions  @xcite are used for authentication , and any new family of such functions immediately yields a new mac .",
    "likewise , any new purity testing code provides a new quantum authentication scheme .",
    "however , it is unknown whether all quantum authentication schemes can be modeled as a combination of a one - time pad and a purity testing code , or whether there exist interesting schemes following a different pattern .",
    "we have proven that a loss of @xmath12 bits of key is inevitable with these schemes if the adversary tampers with the channel . in the case of the unitary @xmath9/design scheme , which has the smallest error ,",
    "this is @xmath385 bits of key which are consumed .",
    "a loss of @xmath142 bits will always occur , since these are required to one - time pad the message .",
    "it remains open whether there exist other schemes  which do not fit the one - time pad + purity testing code model  which recycle more key .",
    "another open question is whether it is possible to find a prepare / and / measure scheme to encrypt and authenticate a classical message in a quantum state , so that all of the key may be recycled if it is successfully authenticated .",
    "note that such a scheme would necessarily have to be designed to work on a noisy channel , because quantum eccs are not prepare / and / measure , so one can not compose it with an ecc to withstand a noisy channel as in this work .",
    "some ideas for achieving this are discussed in  @xcite .",
    "cp would like to thank anne broadbent , frdric dupuis and debbie leung for useful discussions .",
    "cp is supported by the european commission fp7 project raquel ( grant no .",
    "323970 ) , us air force office of scientific research ( afosr ) via grant  fa9550 - 16 - 1 - 0245 , the swiss national science foundation ( via the national centre of competence in research ` quantum science and technology ' ) and the european research council  erc ( grant no .",
    "258932 ) .    [ app ]",
    "as already mentioned in , the ac framework  @xcite models cryptography as a resource theory . the ac framework does however not explicitly define these resources .",
    "it follows a top / down paradigm and only specifies on each level of abstraction the properties of objects that are absolutely essential  the axioms these objects must satisfy .",
    "this simplifies the framework by removing unnecessary and cumbersome information ",
    "e.g. , a model of computation  and results in more general framework that is not hard / coded with a specific communication or scheduling model . in this section",
    "we give a brief introduction to ac . we illustrate this with an example taken from @xcite , namely that appending a message authentication code ( mac ) to a classical message is sufficient to construct a classical authentic channel given an insecure channel and a shared secret key .",
    "we refer the interested reader to the original ac paper  @xcite for a detailed treatment of the abstract layer and to @xcite for more gentle introductions to ac .",
    "an @xmath386/_resource _ is an ( abstract ) system with interfaces specified by a set @xmath386 , e.g. , @xmath387 .",
    "each interface @xmath388 is accessible to a user @xmath19 .",
    "the objects depicted in are examples of resources .",
    "the insecure channel in allows alice to input a message at her interface on the left and allows bob to receive a message at his interface on the right .",
    "eve can intercept alice s message and insert a message of her choosing at her interface .",
    "the authentic channel resource depicted in also allows alice to send a message and bob to receive a message , but eve s interface is more limited than for the insecure channel : she can only decide if bob receives the message or not , but not tamper with the message being sent .",
    "the key resource drawn in provides each player with a secret key when requested .",
    "additionally , resources are equipped with a parallel composition operator , @xmath389 , that maps two resources to another resource .",
    "this is to be understood as both resources being merged into one , that can be accessed in any arbitrary order .",
    "for example , if players share a secret key resource @xmath16 and a channel resource @xmath13 , they have the resource @xmath18 available , as depicted in .",
    "given access to @xmath18 , the players could , e.g. , get a key from @xmath16 and use it to encode a message that is sent on @xmath13    _ converters _ capture operations that a player might perform locally at her interface .",
    "these are ( abstract ) systems with two interfaces , an _ inside _ interface and an _ outside _ interface .",
    "the inside interface connects to an interface of a resource , and the outside interface becomes the new interface of the resource resulting from the connection of this converter and resource .",
    "for example , in the setting described a paragraph higher , alice might decide to append a mac to her message .",
    "this is modeled as a converter @xmath20 that obtains the message @xmath21 at the outside interface , obtains a key at the inside interface from a key resource @xmath16 and sends @xmath22 on the insecure channel @xmath13 , where @xmath23 is taken from a family of strongly @xmath9/universal hash functions  @xcite .",
    "we illustrate this in .",
    "converters are always drawn with rounded corners .    if a converter @xmath24 is connected to the @xmath19 interface of a resource @xmath25 , we write @xmath26 or @xmath27 for the new resource obtained by connecting the two  in this work we adopt the convention of writing converters at the @xmath50 and @xmath28 interfaces on the left and converters at the @xmath29 interface on the right , though there is no mathematical difference between @xmath26 and @xmath27",
    ". serial and parallel composition of converters is defined as follows : @xmath390 by definition , converters at different interfaces commute , i.e. , @xmath391 if @xmath392 .",
    "this allows us to draw systems as in without having to specify an order in which @xmath20 and @xmath365 are connected to the resource @xmath18 .",
    "a protocol is then defined by a set of converters , one for every honest player .",
    "another type of converter that we need is a _",
    "filter_. the resources illustrated in depict a setting with an adversary that has some control over these resources . for a cryptographic protocol to be useful it is not sufficient to provide guarantees on what happens when an adversary is present , one also has to provide a guarantee on what happens when no adversary is present , e.g. , if no adversary tampers with the message on the insecure channel , then bob will receive the message that alice sent .",
    "we model this setting by covering the adversarial interface with a filter that emulates an honest behavior./interfaces that are blank if the adversary is not active . ] in we draw an insecure and an authentic channel with filters @xmath39 and @xmath40 that transmit the message to bob . in the case of the insecure channel , one may want to model an honest noisy channel when no adversary is present .",
    "this is done by having the filter @xmath39 add some noise to the message .",
    "a dishonest player removes this and has access to a noiseless channel as in .",
    "we use the term _ filtered resource _ to refer to a pair of a resource @xmath25 and a filter @xmath39 , and often write @xmath42 .",
    "such an object can be thought of as having two modes : it is characterized by the resource @xmath43 when no adversary is present and by the resource @xmath25 when the adversary is present .",
    "parallel composition of filtered resources naturally follows from parallel composition of resources and converters : @xmath393    the final object that is required by the ac framework to define the notion of construction and prove that it is composable , is a ( pseudo/)metric defined on the space of resources that measures how close two resources are . in the following , we use a distinguisher based metric , i.e. , the maximum advantage a distinguisher has in guessing whether it is interacting with resource @xmath25 or @xmath44 , which we write @xmath45 .",
    "this is discussed further in .",
    "we are now ready to define the security of a cryptographic protocol .",
    "we do so in the three player setting , for honest alice and bob , and dishonest eve .",
    "thus , in the following , all resources have three interfaces , denoted @xmath50 , @xmath28 and @xmath29 , and a protocol is then given by a pair of converters @xmath51 for the honest players .",
    "we refer to @xcite for the general case , when arbitrary players can be dishonest . for convenience , we reproduce here .",
    "[ def : security.app ] let @xmath52 be a protocol and @xmath53 and @xmath54 denote two filtered resources .",
    "we say that _ @xmath55 constructs @xmath56 from @xmath57 within @xmath0 _ , which we write @xmath58 ,",
    "if the two following conditions hold :    1 .",
    "[ eq : def.cor.app ] we have @xmath59 2 .   [ eq : def.sec.app ] there exists a converter @xmath60  which we call simulator  such that @xmath61    if it is clear from the context what filtered resources @xmath57 and @xmath62 are meant , we simply say that @xmath55 is @xmath0/secure .",
    "the first of these two conditions measures how close the constructed resource is to the ideal resource in the case where no malicious player is intervening , which is often called _ correctness _ in the literature .",
    "the second condition captures _ security _ in the presence of an adversary .",
    "for example , to prove that the mac protocol constructs an authentic channel from an insecure channel and a secret key within @xmath0 , we need to find a converter @xmath63 such that the real system @xmath64 can not be distinguished from the ideal system @xmath65 with advantage greater than @xmath0 . the simulator @xmath63 drawn in satisfies this requirement if the family of hash functions @xmath66 is @xmath0/almost strongly @xmath9/universal  @xcite .",
    "it follows from the composition theorem of the ac framework  @xcite that if two protocols @xmath394 and @xmath395 are @xmath0- and @xmath396/secure , the composition of the two is @xmath397/secure . more precisely , let protocols @xmath394 and @xmath395 construct @xmath62 from @xmath57 and @xmath398 from @xmath62 within @xmath0 and @xmath396 , respectively , i.e. , @xmath399 it then follows from the triangle inequality of the metric that @xmath400 constructs @xmath398 from @xmath57 within @xmath401 , @xmath402 a similarly statement holds for parallel composition .",
    "let @xmath394 and @xmath395 construct @xmath62 and @xmath403 from @xmath57 and @xmath404 within @xmath0 and @xmath396 , respectively , i.e. , @xmath405 if these resources and protocols are composed in parallel , we find that @xmath406 constructs @xmath407 from @xmath408 within @xmath401 , @xmath409 proofs of these statements can be found in @xcite .",
    "as stated at the beginning of this section , the ac framework @xcite specifies only the necessary axioms that resources and converters must satisfy so that one can prove that the resulting notion of construction is composable .",
    "modeling concrete systems such as those in figures  [ fig : channel.dishonest ] , [ fig : classicalauth.real ] , [ fig : channel.honest ] or [ fig : classicalauth.ideal ] , requires an instantiation of the framework with mathematical objects that capture interactive quantum information / processing systems .",
    "such an instantiation has been given in @xcite and proven to satisfy the axioms of ac , where the interactive systems are called _",
    "causal boxes_.    unlike the model of systems used in quantum uc  @xcite , in which the output of a system is given by a quantum message and a classical string denoting a recipient , causal boxes allow messages to be sent to a superposition of different players ; they even allow superpositions of different numbers of messages to be generated in superpositions of different orders  @xcite .",
    "this generality is however not needed in the current work , because all converters and resources involved in the construction of secure channels have a very simple structure . for this work",
    ", a system @xmath44 can be modeld as having internal memory @xmath410 , and sets of in - ports @xmath411 and out - ports @xmath412 with message spaces @xmath413 and @xmath414 , respectively . furthermore , upon receiving a message at @xmath415 , @xmath44 always produces outputs at a fixed set of out - ports @xmath416 such that @xmath417 if @xmath392 .",
    "a system @xmath44 is thus entirely described by a set of completely positive , trace / preserving ( cptp ) maps @xmath418 where @xmath419 and @xmath420 is the space of linear operators on @xmath421 . upon receiving a message at some port @xmath415 , the system",
    "@xmath44 then applies the map @xmath422 and outputs the messages in the registers @xmath423 .    for a fixed order of messages received ,",
    "this specific type of system has been called a _ quantum strategy _",
    "@xcite , _ quantum comb _",
    "@xcite or _ operator tensor _",
    "@xcite  here we use the terminology from @xcite , namely _",
    "comb_. a comb can be represented more compactly as a single cptp map @xmath424 , and using the composition rules for combs  @xcite or causal boxes  @xcite , two such systems can be composed to obtain a new system of the same type . the exact formula for composing systems is not needed in the current work ;",
    "in all special cases where we connect two systems , the resulting system can easily be worked out by hand .",
    "we refer the interested reader to @xcite for the generic cases .",
    "as mentioned at the end of we use a distinguisher metric to define the distance between two systems @xmath25 and @xmath44 .",
    "this means that another system @xmath46 , a _ distinguisher _ , is given access to either @xmath25 or @xmath44 , and has to guess to which of the two it is connected .",
    "let @xmath47 $ ] and @xmath48 $ ] be the binary random variables corresponding to @xmath46 s guess , then the distinguishing advantage between @xmath25 and @xmath44 for this specific distinguisher is given by @xmath425 = 0 \\right ] -    \\pr\\left [ \\ad[\\as ] = 0 \\right ] \\right|\\,,\\ ] ] and the distance is given by @xmath426 where the supremum is taken over all distinguishers allowed by quantum mechanics ",
    "it has been proven in @xcite that @xmath427 is indeed a metric .    due to the simple structure of the systems considered in this work , the distinguishing metric can be reduced to the following strategy  for the general case of the distinguishing metric between causal boxes we refer the reader to @xcite .",
    "let the distinguisher have internal memory @xmath428 .",
    "it choses an in - port @xmath429 , and prepares a state @xmath430 .",
    "the @xmath431 part is sent to the system at the @xmath429 port .",
    "it then receives the output on ports @xmath432 , which it appends to its internal memory .",
    "it measures its internal memory to decide on the next in - port @xmath433 , applies a map @xmath434 , and inputs the @xmath435 part at the corresponding port .",
    "this process is repeated until there are no more unused ports , after which it measures its internal memory and produces one bit of output , its final guess . in the case",
    "where the two systems being compared only have one in - port , this metric reduces to the diamond norm . and",
    "if the systems have no in - port ( or one trivial in - port of dimension @xmath81 ) , this results in the trace / distance between the states output by the two systems .",
    "the concept of a unitary @xmath9-design was originally proposed in @xcite .",
    "the following ( equivalent ) definition is taken from @xcite .",
    "a unitary @xmath9-design is a finite set of unitaries @xmath436 on @xmath437 such that for all @xmath438 @xmath439 where @xmath440 is the haar measure .",
    "equivalently , @xmath441 is a unitary @xmath9-design if for any quantum channel @xmath442 and state @xmath443 , @xmath444    one way to construct a unitary @xmath9-design is by finding a set of unitaries @xmath111 that map all non / identity paulis to each other with equal frequency , i.e. , @xmath445 such that @xmath297 and @xmath446 , @xmath447 where @xmath448 is some global phase and @xmath294 is the dimension of the hilbert space .",
    "a unitary @xmath9/design is then obtained by composing these unitaries with paulis , i.e. , the set @xmath449 is a unitary @xmath9/design .",
    "this has been used in @xcite to show that the clifford group is a unitary @xmath9-design , and is further discussed in @xcite .",
    "chau  @xcite finds a set @xmath111 satisfying . to understand his construction",
    ", we must view the indices @xmath21 and @xmath74 of a pauli operator @xmath72 as elements of a galois field @xmath450 .",
    "let @xmath451 be any element of the special linear group of @xmath452 matrices over the finite field @xmath453 , i.e. , matrices with determinant @xmath81 .",
    "chau then finds unitaries @xmath454 such that @xmath455 for some global phase @xmath456 that may depend on @xmath457 , where the arithmetic in the indices is done in @xmath453 . by considering the entire set",
    "@xmath458 one can verify that is satisfied .",
    "since @xmath459 , we need @xmath460 bits of key to chose the unitary .",
    "we now show that this set is a strong purity testing code .",
    "[ lem : purity ] any set @xmath111 satisfying with @xmath461 is a strong purity testing code with @xmath300 .",
    "an error @xmath73 is not detected if it is mapped to @xmath462 .",
    "there are @xmath463 such paulis @xmath98 which are not identity .",
    "since the unitaries @xmath464 are constructed to map @xmath73 to all non / identity @xmath98 with equal frequency , then @xmath465 of them will not detect @xmath73 .",
    "a unitary @xmath305/design is defined similarly to a unitary @xmath9/design , except that it has a @xmath305/fold tensor product instead of a @xmath9/fold tensor product in . intuitively , if a unitary @xmath9/design is a good quantum authentication scheme , then so should any ( approximate ) unitary @xmath305/design for any @xmath466 .",
    "the argument we use in the proof is that a unitary @xmath9/design satisfies .",
    "this also holds for unitary @xmath117/designs ( given by the clifford group  @xcite ) , but not necessarily for @xmath467 , where the unitaries are not elements of the clifford group anymore .",
    "one can however show directly from that a unitary @xmath9/design is a strong purity testing code,/design scheme , is that chau s construction  @xcite is a subset of a unitary @xmath9/design that satisfies but not .",
    "we still have to compose it with a random pauli to obtain the unitary @xmath9/design . ] and since all ( approximate ) unitary @xmath305/designs ( approximately ) satisfy , they can all be used to construct quantum authentication schemes that have the same key recycling properties as unitary @xmath9/designs .",
    "[ lem : purity.2 ] any @xmath1/approximate @xmath305/design with @xmath466 is a strong purity testing code with error @xmath468 .    to prove that a set of unitaries is a strong purity testing code , one has to show that it can be used to detect all non / identity pauli errors with high probability .",
    "setting @xmath469 for a non / identity pauli @xmath73 in , one can show that that the rhs becomes ( see , e.g. , @xcite ) , @xmath470 if @xmath461 , @xmath471 where @xmath345 is the first @xmath5 qubits of @xmath121 and the last @xmath7 qubits are used as syndrome , then the probability of obtaining @xmath41 when performing a measuring in the computational basis on the syndrome is @xmath472 thus , if the distance between the lhs and rhs of is @xmath1 , then the probability of not detecting a pauli error is less than @xmath468 .",
    "[ lem : trace2norm ] let @xmath92 and @xmath473 be two subnormalized states .",
    "then @xmath474 where @xmath224 is the vector @xmath9/norm .",
    "it was shown in ( * ? ? ?",
    "* lemma  a.2.3 ) that if @xmath475 is real , then @xmath476 for complex @xmath475 we define @xmath477 .",
    "it then follows from ( * ? ? ?",
    "* lemma  a.2.3 ) that @xmath478 to prove this lemma it remains to show that @xmath479 since combining this with @xmath480 we get .",
    "dorit aharonov , michael ben - or , and elad eban .",
    "interactive proofs for quantum computations . in _ proceedings of innovations in computer science , ics 2010 _ , pages 453469 .",
    "tsinghua university press , 2010 . .",
    "charles  h. bennett and gilles brassard .",
    "quantum cryptography : public key distribution and coin tossing . in _ proceedings of ieee international conference on computers , systems , and",
    "signal processing _ , pages 175179 , 1984 .",
    "howard barnum , claude crpeau , daniel gottesman , adam smith , and alain tapp .",
    "authentication of quantum messages . in",
    "_ proceedings of the 43rd symposium on foundations of computer science , focs  02 _ , pages 449458 .",
    "ieee , 2002 . .",
    "michael ben - or , claude crpeau , daniel gottesman , avinatan hassidim , and adam smith .",
    "secure multiparty quantum computation with ( only ) a strict honest majority . in _ proceedings of the 47th symposium on foundations of computer science , focs  06 _ , pages 249260 , 2006 . .",
    "anne broadbent , gus gutoski , and douglas stebila .",
    "quantum one - time programs . in _ advances in cryptology ",
    "crypto 2013 _ , volume 8043 of _ lecture notes in computer science _ , pages 344360 .",
    "springer , 2013 .",
    ".      ran canetti .",
    "universally composable security : a new paradigm for cryptographic protocols . in _ proceedings of the 42nd symposium on foundations of computer science , focs  01 _ , pages 136145 .",
    "ieee , 2001 . .",
    "frdric dupuis , jesper  buus nielsen , and louis salvail .",
    "actively secure two - party evaluation of any quantum operation . in reihaneh safavi - naini and ran canetti , editors , _ advances in cryptology ",
    "crypto 2012 _ , volume 7417 of _ lecture notes in computer science _ , pages 794811 .",
    "springer , 2012 . .",
    "ivan damgrd , thomas  brochmann pedersen , and louis salvail . a quantum cipher with near optimal key - recycling . in _ advances in cryptology ",
    "crypto 2005 _ , volume 3621 of _ lecture notes in computer science _ ,",
    "pages 494510 .",
    "springer , 2005 . .",
    "ueli maurer .",
    "constructive cryptography  a new paradigm for security definitions and proofs . in _ proceedings of theory of security and applications , tosca 2011 _ , volume 6993 of _ lecture notes in computer science _ , pages 3356 .",
    "springer , 2012 . .",
    "renato renner and robert knig .",
    "universally composable privacy amplification against quantum adversaries . in joe",
    "kilian , editor , _ theory of cryptography , proceedings of tcc 2005 _ , volume 3378 of _ lecture notes in computer science _",
    ", pages 407425 .",
    "springer , 2005 . .",
    "valerio scarani , helle bechmann - pasquinucci , nicolas  j. cerf , miloslav du  ek , norbert ltkenhaus , and momtchil peev .",
    "the security of practical quantum key distribution .",
    ", 81:13011350 , september 2009 . .",
    "dominique unruh .",
    "universally composable quantum multi - party computation . in _ advances in cryptology ",
    "eurocrypt 2010 _ , volume 6110 of _ lecture notes in computer science _ , pages 486505 .",
    "springer , 2010 . ."
  ],
  "abstract_text": [
    "<S> we show that a family of quantum authentication protocols introduced in [ barnum et al . , </S>",
    "<S> focs 2002 ] can be used to construct a secure quantum channel and additionally recycle all of the secret key if the message is successfully authenticated , and recycle part of the key if tampering is detected . </S>",
    "<S> we give a full security proof that constructs the secure channel given only insecure noisy channels and a shared secret key . </S>",
    "<S> we also prove that the number of recycled key bits is optimal for this family of protocols , i.e. , there exists an adversarial strategy to obtain all non - recycled bits . </S>",
    "<S> previous works recycled less key and only gave partial security proofs , since they did not consider all possible distinguishers ( environments ) that may be used to distinguish the real setting from the ideal secure quantum channel . </S>"
  ]
}