{
  "article_text": [
    "the problem of maximum satisfiability  ( maxsat ) consists of identifying the largest number of clauses in a cnf formula that can be satisfied .",
    "variations of the maxsatinclude partial maxsatand weighted maxsat . for partial maxsatsome clauses ( i.e.  the hard clauses ) must be satisfied whereas others ( i.e.  the soft clauses ) may not be satisfied . for weighted maxsat , each clause has a given weight , and the objective is to maximize the sum of the weights of satisfied clauses .",
    "the maxsatproblem and its variations find a number of relevant practical applications , including design debugging of embedded systems  @xcite and fpga routing  @xcite .",
    "unfortunately , the techniques that have proved to be extremely effective in boolean satisfiability  ( sat ) can not be applied directly to maxsat  @xcite . as a result ,",
    "most of the existing algorithms  @xcite implement only a restricted number of techniques , emphasizing bound computation and/or dedicated inference techniques . despite the extensive research work in this area ,",
    "existing maxsattechniques and algorithms do not scale for large problem instances from practical applications .",
    "recent work  @xcite proposed alternative approaches , that build on the existence of effective sat solvers for identifying unsatisfiable subformulas , and so can indirectly exploit existing effective sat techniques  @xcite .",
    "however , even though modern sat solvers are effective at proving unsatisfiability and generating unsatisfiable subformulas , the algorithms described in  @xcite are in general ineffective for maxsat , and so this work focused on partial maxsatwith a reduced number of soft clauses .",
    "this paper reviews previous maxsatalgorithms based on identifying unsatisfiable subformulas for maxsat , proposes key optimizations to one of these algorithms  @xcite , and develops a new algorithm also based on identifying unsatisfiable subformulas .",
    "experimental results , obtained on a wide range of practical problem instances , show that the new maxsatalgorithms can be orders of magnitude more efficient than the original algorithms  @xcite , being in general consistently more efficient than previous maxsatsolvers on instances obtained from practical applications .",
    "the paper is organized as follows .",
    "section  [ sec : defs ] briefly introduces the maxsatproblem and existing algorithms .",
    "afterwards , section  [ sec : msu ] reviews maxsatalgorithms based on unsatisfiable subformula identification  @xcite .",
    "section  [ sec : nmsu1 ] proposes optimizations to these algorithms , and section  [ sec : nmsu3 ] proposes a new maxsatalgorithm .",
    "experimental results on a large sample of problem instances , obtained from a number of practical applications , are analyzed in section  [ sec : res ] .",
    "the paper concludes in section  [ sec : conc ] .",
    "this section provides definitions and background knowledge for the maxsatproblem . due to space constraints , familiarity with sat and related topics",
    "is assumed  @xcite .",
    "the maximum satisfiability ( maxsat ) problem can be stated as follows . given an instance of sat represented in conjunctive normal form ( cnf ) , compute an assignment to the variables that maximizes the number of satisfied clauses .",
    "variations of the maxsatproblem include the partial maxsatand the weighted maxsatproblem . in the partial maxsat problem some clauses ( i.e.  the _ hard _ clauses ) must be satisfied , whereas others ( i.e.  the _ soft _ clauses ) may not be satisfied . in the weighted maxsat problem ,",
    "each clause has a given weight , and the objective is to maximize the sum of the weights of satisfied clauses .    during the last decade",
    "there has been a growing interest on studying maxsat , motivated by an increasing number of practical applications , including scheduling , routing , bioinformatics , and design automation  @xcite . despite the clear relationship with the sat problem ,",
    "most modern sat techniques can not be applied directly to the maxsatproblem  @xcite . as a result",
    ", most maxsatalgorithms are built on top of the standard dpll  @xcite algorithm , and so do not scale for industrial problem instances  @xcite .",
    "the most often used approach for maxsat(e.g .",
    "most of the solvers in the maxsatcompetition  @xcite ) is based on a branch and bound algorithm , emphasizing the computation of a lower bound and the application of inference rules that simplify the instance  @xcite .",
    "results from the maxsatcompetition  @xcite indicate that solvers based on branch and bound with additional inference rules are currently the most efficient maxsatsolvers , outperforming all other existing approaches .",
    "one alternative approach for solving the maxsatproblem is to use pseudo - boolean optimization ( pbo ) ( e.g.  @xcite ) .",
    "the pbo approach for maxsatconsists of adding a new ( _ blocking ) _ variable to each clause .",
    "the blocking variable @xmath0 for clause @xmath1 allows satisfying clause @xmath1 independently of other assignments to the problem variables .",
    "the resulting pbo formulation includes a cost function , aiming the minimization of the number of blocking variables assigned value 1 .",
    "clearly , the solution of the maxsatproblem is obtained by subtracting from the number of clauses the solution of the pbo problem .    despite its simplicity , the pbo formulation does not scale for industrial problems , since the large number of clauses results in a large number of blocking variables , and corresponding larger search space . observe that , for most instances from practical applications , the number of clauses largely exceeds the number of variables . for the resulting pbo problem , the number of variables equals the sum of the number of variables and clauses in the original sat problem .",
    "hence , the resulting instance of pbo has a much larger search space than the original instance of sat .    besides the pbo model ,",
    "a number of alternative algorithms exist for maxsat .",
    "examples include , opt - sat  @xcite and sub - sat  @xcite .",
    "opt - sat imposes an ordering on the boolean variables on an existing sat solver .",
    "experimental results for maxsatindicate that this approach is slower than a state - of - art pbo solver , e.g.  minisat+  @xcite , and so it is unlikely to scale for industrial problems . on the other hand ,",
    "sub - sat solves a relaxed version of the original problem , hence the exact maxsatsolution may not be computed .",
    "moreover , the experimental comparison in  @xcite suggests that sub - sat is not competitive with unsatisfiability - based maxsatalgorithms .",
    "other approaches have been proposed  @xcite , that are based on the relation of minimally unsatisfiable subformulas and maximally satisfiable subformulas  @xcite .",
    "however , these approaches are based on enumeration of maximally satisfiable subformulas , and so do not scale for instances with a large number of unsatisfiable subformulas . as a result , for most instances only approximate results can be obtained .",
    "more recently , an alternative approximate approach to maxsathas been proposed  @xcite .",
    "the motivation for this alternative approach is the potential application of maxsatin design debugging , and the fact that existing maxsatapproaches do not scale for industrial problem instances .",
    "however , this approach is unable to compute exact solutions to the maxsatproblem .",
    "the next section addresses maxsatalgorithms that use the identification of unsatisfiable subformulas .",
    "modern sat solvers can be instructed to generate a resolution refutation for unsatisfiable formulas  @xcite .",
    "the resolution proof is usually represented as a proof trace , which summarizes the resolution steps used for creating each clause learnt by the sat solver .",
    "besides resolution refutations , proof traces allow identifying unsatisfiable subformulas , which serve as the source for the resolution refutation .",
    "a simple iterative procedure allows generating minimal unsatisfiable subformulas ( mus ) from computed unsatisfiable sub - formulas  @xcite .",
    "all modern conflict - driven clause learning ( cdcl ) sat solvers can be easily adapted to generate proof traces , and indirectly , unsatisfiable sub - formulas .",
    "as mentioned in the previous section , one of the major drawbacks of the pbo model for maxsatis the large number of blocking variables that must be considered . the ability to reduce the number of required blocking variables",
    "is expected to improve significantly the ability of sat / pbo based solvers for tackling instances of maxsat . moreover , any solution to the maxsatproblem will be unable to satisfy clauses that _ must _ be part of an unsatisfiable subformula .",
    "consequently , one approach for reducing the number of blocking variables is to associate blocking variables only with clauses that are part of unsatisfiable subformulas .",
    "however , it is not simple to identify all clauses that are part of unsatisfiable subformulas .",
    "one alternative is the identification and relaxation of unsatisfiable subformulas .",
    "this section describes the unsatisfiability - based maxsatalgorithm described in  @xcite . in what follows this algorithm",
    "is referred to as msu1 ( fu&malik s maxsatalgorithm based on unsatisfiable subformulas ) .",
    "it should be observed that the original algorithm was proposed for partial maxsat , but the modifications for the plain maxsatproblem are straightforward .",
    "algorithm  [ alg : msu1 ] summarizes fu&malik s  @xcite maxsatalgorithm .",
    "the algorithm iteratively finds unsatisfiable cores ( line  [ li : msu : satcall ] ) , adds new blocking variables to the non - auxiliary clauses in the unsatisfiable core ( line  [ li : msu : newbv ] ) , and requires that exactly one of the new blocking variables must be assigned value 1 ( line  [ li : msu : card ] ) .",
    "this constraint is referred to as the _ one - hot _ constraint in  @xcite .",
    "the algorithm terminates whenever the cnf formula is satisfiable , and the number of assigned blocking variables is used for computing the solution to the maxsatproblem instance .",
    "the clauses used for implementing the _ one - hot _ constraint are declared auxiliary ; all other clauses are non - auxiliary .",
    "observe that each non - auxiliary clause may receive more than one blocking variable , and the total number of blocking variables a clause receives corresponds to the number of times the clause is part of an unsatisfiable core . as suggested earlier in this section , by focusing on identification and relaxation ( with blocking variables ) of unsatisfiable sub - formulas , msu1 and the other algorithms described later attempt to reduce the number of blocking variables that is necessary to use while solving the maxsatproblem .",
    "clauses of cnf formula @xmath2 are the _ initial _ clauses clauses in @xmath2 are tagged non - auxiliary @xmath3 working formula , initially set to @xmath2 [ li : msu : init - loop ] @xmath4[li : msu : satcall ] @xmath5 [ li : msu : unsat ] @xmath6 @xmath7 @xmath8 is not auxiliary @xmath9 is a new blocking variable @xmath10 [ li : msu : newbv ] @xmath11 is tagged non - auxiliary @xmath12 @xmath13 @xmath14[li : msu : card ] constraint in  @xcite @xmath15 clauses in @xmath16 are tagged auxiliary [ li : msu : sat ] @xmath17 @xmath18 [ li : msu : sol ]    a proof of correctness of algorithm msu1 is given in  @xcite . however ,  @xcite does not address important properties of the algorithm , including the number of blocking variables that must be used in the worst case , or the worst - case number of iterations of the algorithm .",
    "this section establishes some of these properties . in what follows",
    ", @xmath19 denotes the number of variables and @xmath20 denotes the number of clauses .",
    "[ prop : mbs ] during the execution of algorithm  [ alg : msu1 ] , non - auxiliary clauses can have multiple blocking variables .",
    "consider the following example cnf formula : @xmath21 one possible execution of the algorithm follows .",
    "identify core @xmath22 .",
    "add blocking clauses , respectively @xmath23 , and require @xmath24 .",
    "identify core @xmath25 .",
    "add blocking clauses , respectively @xmath26 , and require @xmath27 .",
    "identify core @xmath28 , where @xmath29 denotes clauses from encoding @xmath30 in cnf .",
    "add blocking clauses to non - auxiliary clauses , respectively @xmath31 , and require @xmath32 . at this stage , some of the non",
    "- auxiliary clauses have two blocking variables , e.g.  @xmath33 and @xmath34 are associated with @xmath35 .",
    "[ prop : nbs ] during the execution of algorithm  [ alg : msu1 ] , for iteration @xmath36 , exactly @xmath37 blocking variables must be assigned value 1 , or the formula is unsatisfiable .",
    "observe that each iteration adds a constraint requiring the sum of a set of new blocking variables to be equal to 1 .",
    "hence , at iteration @xmath36 , either @xmath37 blocking variables are assigned value 1 , or the formula is unsatisfiable .    [",
    "prop : nbcs ] during the execution of algorithm  [ alg : msu1 ] , if @xmath38 is satisfiable , at most 1 of the blocking variables associated with a given clause can be assigned value 1 .",
    "each blocking variable is associated with a clause as the result of identifying an unsatisfiable core .",
    "consider clause @xmath1 that is part of two cores @xmath39 and @xmath40 , each adding to @xmath1 a blocking variable , respectively @xmath41 and @xmath42 .",
    "assume that the formula could be satisfied such that @xmath1 would have the two blocking variables @xmath41 and @xmath42 assigned value  1 .",
    "this would imply that both cores @xmath39 and @xmath40 could be deactivated by blocking clause  @xmath1 .",
    "but this would also imply that the second core @xmath40 could not have been identified , since assigning @xmath41 would deactivate core @xmath40 ; a contradiction .",
    "this result allows deriving an upper bound on the number of iterations of algorithm  [ alg : msu1 ] .",
    "[ prop : iter ] the number of iterations of algorithm  [ alg : msu1 ] is @xmath43 .",
    "immediate from propositions  [ prop : nbs ] and  [ prop : nbcs ] . at each iteration @xmath36 , @xmath37 blocking variables must be assigned value 1 . moreover",
    ", none of these blocking variables can be from the same clause .",
    "hence , at iteration @xmath44 all clauses must be satisfied by assigning a blocking variable to 1 .",
    "hence , the number of iterations of algorithm  [ alg : msu1 ] is @xmath45 .",
    "it should be observed that the algorithm will _ never _ execute @xmath44 steps .",
    "indeed , for arbitrary cnf formulas , at least half of the clauses can be trivially satisfied  @xcite , and so the number of iterations never exceeds @xmath46 .",
    "moreover , the upper bound on the number of iterations serves for computing an upper bound on the total number of blocking variables .    [ prop : mxnbv ] during the execution of algorithm  [ alg : msu1 ] , the number of blocking variables is @xmath47 in the worst case .    from proposition  [ prop : iter ] the number of iterations is @xmath43 . in each iteration , each unsatisfiable core can have at most @xmath20 clauses ( i.e.  the number of original clauses ) . hence the result follows .",
    "the previous result provides an upper bound on the number of blocking variables .",
    "a tight lower bound is not known , even though a trivial lower bound is @xmath48 .",
    "this section proposes improvements to fu&malik s maxsatalgorithm  @xcite described in the previous section .",
    "the resulting algorithm is referred to as msu2 .",
    "the _ one - hot _ constraint used in msu1  @xcite corresponds to the well - known pairwise encoding for equals  1 constraints  @xcite , i.e. cardinality constraints of the form @xmath49 .",
    "usually , equals  1 constraints are encoded with two constraints , one atmost  1 constraint ( i.e.  @xmath50 ) and one atleast  1 constraint ( i.e.  @xmath51 ) .",
    "it is also well - known that the pairwise encoding requires @xmath52 clauses , one clause for the atleast  1 constraint , and @xmath53 binary clauses for the atmost  1 constraint .",
    "hence , the quadratic number of clauses results from encoding the atmost  1 constraint . for large @xmath54 , as is often the case for the maxsatproblem , the pairwise encoding can require a prohibitively large number of clauses .",
    "for example , for an unsatisfiable core with 10,000 clauses , the resulting atmost  1 constraint is encoded with 49,995,000 binary clauses . for practical applications ,",
    "unsatisfiable cores are likely to exceed 10,000 clauses . as shown in section  [ sec : res ] , in many cases , the pairwise encoding of an atmost  1 constraint exhausts the available physical memory resources .",
    "there are a number of alternatives to the pairwise encoding of atmost  1 constraints  @xcite , all of which are linear in the number of variables in the constraint .",
    "these encodings can either use sequential counters , sorters , or binary decision diagrams ( bdds ) .",
    "one simple alternative is to use bdds for encoding a cardinality constraint .",
    "a boolean circuit is extracted from the bdd representation , which can then be converted to cnf using tseitin s encoding  @xcite . in most cases ,",
    "the encoding takes into account the polarity optimizations of plaisted and greenbaum  @xcite when generating the cnf formula . for the atmost  1 constraint , the bdd - based encoding of a cardinality constraint is linear in @xmath19  @xcite . for the results in section  [ sec : res ] ,",
    "the most significant performance gains are obtained from using a bdd - based encoding for atmost  1 constraints , using tseitin s encoding and plaisted&greenbaum s polarity optimizations .",
    "one final remark is that fu&malik s algorithm will also work if only atmost  1 constraints are used instead of equals  1 constraints .",
    "this allows saving one ( possibly quite large ) clause in each iteration of the algorithm .",
    "another potential drawback of fu&malik s algorithm is that there can be several blocking variables associated with a given clause ( see the analysis of algorithm  [ alg : msu1 ] , including propositions  [ prop : mbs ] and  [ prop : mxnbv ] ) .",
    "each time a clause @xmath8 is part of a computed unsatisfiable core , a _",
    "new _ blocking variable is added to @xmath8 .",
    "observe that correctness of the algorithm requires that more than one blocking variable may be associated with each clause . on the other hand , despite the potentially large ( but at most linear in @xmath20 ) number of blocking variables associated with each clause , _ at most",
    "_ one of these additional blocking variables can be used for actually preventing the clause from participating in an unsatisfiable core ( see proposition  [ prop : nbcs ] ) .",
    "a simple improvement for pruning the search space associated with blocking variables is to require that _ at most one _ of the blocking variables associated with a given clause @xmath8 can be assigned value 1 . for a given clause @xmath1 ,",
    "let @xmath55 be the blocking variables associated with @xmath1 .",
    "as a result , the condition that at most 1 of the blocking variables of @xmath1 is assigned value 1 is given by : @xmath56    in general , the previous condition is useful when algorithm  [ alg : msu1 ] must execute a large number of iterations , and many clauses are involved in a significant number of unsatisfiable cores .",
    "consider the example given in the proof of proposition  [ prop : mbs ] . in the third iteration of the algorithm , the first clause @xmath35 has been modified to @xmath57 . as a result",
    ", the cnf encoding of the additional constraint @xmath58 can be added to the cnf formula .",
    "since this is an atmost  1 constraint , the encoding proposed in the previous section can also be used .",
    "this section proposes a new alternative algorithm for maxsat . compared to the algorithms described in the previous sections , msu1 and msu2",
    ", the new algorithm guarantees that _ at most 1 _ blocking variable is associated with each clause . as a result ,",
    "the worst case number of blocking variables that can be used is @xmath20 .",
    "moreover , during a first phase , the new algorithm extracts identified cores , whereas in a second phase the algorithm addresses the problem of computing the number of blocking variables that must be assigned value 1 .",
    "the objective of the first phase is to simplify identification of disjoint unsatisfiable cores .",
    "@xmath3 working formula , initially set to @xmath2 @xmath59 [ li : msu3:first - loop ] @xmath4 @xmath5 [ li : msu3:1:unsat ] @xmath60 @xmath61 [ li : msu3:1:sat ] [ li : msu3:1stloop - end ] @xmath62[li : msu3:bv - start ] @xmath63 @xmath7 @xmath9 is a new blocking variable @xmath13 @xmath64[li : msu3:bv - end ] @xmath65 @xmath66 @xmath67 [ li : msu3:init - loop ] @xmath4 @xmath5 [ li : msu3:unsat ] @xmath68 @xmath7 @xmath8 has no blocking variable @xmath9 is new blocking variable @xmath10 @xmath11 is tagged non - auxiliary @xmath12 @xmath13 @xmath69 @xmath70 @xmath67 clauses in @xmath16 are tagged auxiliary [ li : msu3:sat ] @xmath71[li : msu3:sol ]    algorithm  [ alg : msu3 ] shows the new maxsatalgorithm .",
    "the first phase of the algorithm is shown in lines  [ li : msu3:first - loop ] to  [ li : msu3:1stloop - end ] . during this phase disjoint cores",
    "are identified and removed from the formula .",
    "the first set of blocking variables are associated with each clause in an unsatisfiable core in lines  [ li : msu3:bv - start ] to  [ li : msu3:bv - end ] .",
    "the second phase of the algorithm is shown in lines  [ li : msu3:init - loop ] to  [ li : msu3:sol ] . during this phase",
    "the lower bound on the number of blocking variables assigned value 1 is iteratively increased until the cnf formula becomes satisfiable .",
    "for each identified unsatisfied core , a unique blocking variable is associated with non - auxiliary clauses that do not have a blocking variable .",
    "the cardinality constraint @xmath72 is encoded with one atleast  @xmath73 ( @xmath74 ) and one atmost  @xmath73 ( @xmath75 ) constraints . as with msu2",
    ", these constraints are represented with bdds and converted to cnf using tseitin s transformation  @xcite and including the polarity optimizations of plaisted and greenbaum  @xcite . in this case",
    "the size of the representation if @xmath76 , where @xmath54 is the number of variables  @xcite and @xmath73 is the cardinality constraint bound .    despite msu3 guaranteeing that the number of blocking variables never exceeds @xmath20 , there are a few potential drawbacks .",
    "the atleast @xmath73 and atmost  @xmath73 cardinality constraints used by msu3 are significantly more complex to encode than the simple atmost  1 constraint used by msu1 and msu2 . as a result",
    ", msu3 is expected to perform better when the maxsatsolution is not far from the total number of clauses .",
    "as mentioned earlier for msu1 , algorithm  [ alg : msu3 ] can use atmost  @xmath73 cardinality constraints instead of equals  @xmath73 constraints .",
    "finally , algorithm msu2 also allows evaluating whether two phases can be useful for solving maxsat .",
    "clearly , the algorithm could easily be modified to also use only one phase .",
    "this section evaluates a number of maxsatsolvers on industrial test cases .",
    "most instances are obtained from unsatisfiable industrial instances used in past sat competitions  @xcite or available from satlib  @xcite .",
    "the classes of instances considered were the following :    1 .   bounded model checking sintances from ibm  @xcite .",
    "the problem instances were restricted to unsatisfiable instances , up to 35 computation steps , for a total of 252 .",
    "instances from the parametrized pipelined - processor verification problem  @xcite .",
    "the problem instances were restricted to the smallest 58 instances .",
    "3 .   verification of out - of - order microprocessors , from uclid  @xcite .",
    "31 unsatisfiable instances were considered .",
    "4 .   circuit testing instances  @xcite .",
    "228 unsatisfiable instances were considered .",
    "automotive product configuration  @xcite .",
    "84 unsatisfiable instances were considered .",
    "in addition , instances from design debugging  @xcite ( 29 unsatisfiable instances ) and fpga routing  @xcite ( 16 unsatisfiable instances ) were also considered .",
    "these maxsatinstances are known to be difficult , and most have no known maxsatsolutions . as a result ,",
    "the total number of problem instances used in the experiments was 698 .",
    "the maxsatsolvers considered were the following : the best performing solver in the maxsat2007 evaluation  @xcite , maxsatz  @xcite , a pbo formulation of the maxsatproblem solved with minisat+ , one of the best performing pbo solvers  @xcite , an implementation of the algorithm based on identification of unsatisfiable cores ( msu1 )  @xcite , msu1 with the improvements proposed in section  [ sec : nmsu1 ] ( msu2 ) , and the new maxsatalgorithm described in section  [ sec : nmsu3 ] ( msu3 ) .",
    "msu1 , msu2 and msu3 are built on top of the same unsatisfiable core extractor , implemented with minisat  1.14  @xcite .",
    "other alternative maxsatalgorithms were not considered  @xcite .",
    "existing results for opt - sat indicate that it is not competitive with the pbo model solved with minisat+ .",
    "on the other hand , both sub - sat  @xcite and hycam  @xcite only compute approximate solutions .",
    "moreover , results from  @xcite also show that existing approaches based on enumerating all minimally unsatisfiable subformulas  @xcite are not competitive .    with respect to the pbo model",
    ", minisat+ was configured to use sorters for the cost function .",
    "the reason for using sorters is that for many problem instances the use of bdds would exhaust the available physical memory .",
    "the results for all maxsatsolvers on all problem instances were obtained on a linux server running rhe linux , with a xeon 5160 3.0 ghz dual - core processor . for the experiments , the available physical memory of the server was 2 gbyte .",
    "the time limit was set to 1000 seconds per instance .",
    "figure  [ fig : all - all ] plots the run times of each solver sorted by increasing run times .",
    "as can be observed , the performance difference for the maxsatsolvers considered is significant .",
    "msu2 and msu3 solve many more problem instances than any of the other solvers .",
    "( 0,0 )    ( 12600,9720)(0,0)(1925,3850 )    ( 0,0)[r ]    0    ( 1925,4914 )    ( 0,0)[r ]    200    ( 1925,5978 )    ( 0,0)[r ]    400    ( 1925,7042 )    ( 0,0)[r ]    600    ( 1925,8106 )    ( 0,0)[r ]    800    ( 1925,9170 )    ( 0,0)[r ]    1000    ( 2200,3300 )    ( 0,0 )    0    ( 3568,3300 )    ( 0,0 )    100    ( 4936,3300 )    ( 0,0 )    200    ( 6304,3300 )    ( 0,0 )    300    ( 7671,3300 )    ( 0,0 )    400    ( 9039,3300 )    ( 0,0 )    500    ( 10407,3300 )    ( 0,0 )    600    ( 11775,3300 )    ( 0,0 )    700    ( 687,6510)(7262,2475 )    ( 0,0 )    instances    ( 4238,1375 )    ( 0,0)[r ]    maxsatz    ( 4238,825 )    ( 0,0)[r ]    pbo    ( 4238,275 )    ( 0,0)[r ]    msu1    ( 9988,1375 )    ( 0,0)[r ]    msu2    ( 9988,825 )    ( 0,0)[r ]    msu3    as can also be observed in figure  [ fig : all - all ] , msu1 exhibits a sharp transition between instances it can solve and instances it is unable to solve .",
    "the reason is due to the size of the computed unsatisfiable cores . for the more complex instances , the size of the cores is significant , and so msu1 most often aborts due to excessive memory requirements .",
    ".number of aborted instances , out of a total of 698 instances [ cols=\"<,^,^,^,^,^\",options=\"header \" , ]     for the design debugging instances the results are quite different .",
    "table  [ tab : dd : res ] shows the cpu times for all maxsatsolvers on all design debugging instances  @xcite .",
    "as before , the unsatisfiability - based maxsatalgorithms perform remarkably better than the other algorithms , maxsatz and the pbo model . in addition , and also as before , msu2 is the best performing algorithm , and aborts only one instance .",
    "msu3 also aborts only one instance , but in general performs worse than msu2 . finally , msu1 aborts 2 instances , and performs worse than msu2 for almost all instances . for instances with large unsatisfiable cores (",
    "e.g.  b15-bug - onevec - gate-0 ) the linear encoding used in msu2 ensures manageable size representations of the atmost  1 constraints .",
    "the same holds true to msu3 , for small values of @xmath73 .",
    "in contrast , msu1 uses a quadratic encoding and so it often aborts instances with large unsatisfiable cores . moreover , for instances requiring the identification of several unsatisfiable cores sharing common clauses , the additional constraints proposed in section  [ ssec : bvconstr ] are useful for msu2 .",
    "it should be observed that the only design debugging instance that is aborted by both msu2 and msu3 is also aborted by the unsatisfiable core extractor , again suggesting that performance of unsatisfiability - based maxsatsolvers is indexed to the efficiency of sat solvers .",
    "recent work has shown that maxsathas a number of significant practical applications  @xcite . however , current state of the art maxsatsolvers are ineffective on most problem instances obtained from practical applications .",
    "this paper focus on solving maxsatproblem instances obtained form practical applications , and conducts a detailed analysis of maxsatalgorithms based on unsatisfiable subformula identification .",
    "moreover , the paper develops improvements to existing algorithms and proposes a new maxsatalgorithm .",
    "the proposed improvements ( msu2 ) and new algorithm ( msu3 ) provide significant performance improvements , and allow indexing the hardness of solving practical instances of maxsatto the ability of modern sat solvers for proving unsatisfiability and identifying unsatisfiable subformulas .",
    "the algorithms described in this paper are by far the most effective for instances obtained from practical applications , clearly outperforming existing state of the art maxsatsolvers , and further improvements are to be expected .    despite the promising results of the new maxsatalgorithms ,",
    "a number of research directions can be envisioned . as the experimental results show , the role of encoding cardinality constraints is significant , and an extensive evaluation of alternative encodings should be considered . the unsatisfiable core extractor is based on minisat  1.14 .",
    "a core extractor based a more recent sat solver is expected to improve the efficiency of msu1 , msu2 and msu3 .",
    "finally , the problem instances for the fpga routing problem are still challenging , even though the new maxsatalgorithms can solve some of these instances , and so motivate the development of further improvements to maxsatalgorithms .                          .",
    "grgoire , b.  mazure , and c.  piette . boosting a complete technique to find mss and mus thanks to a local search oracle . in _ international joint conference on artificial intelligence _ ,",
    "pages 23002305 , 2007 .",
    "p.  manolios and s.  k. srinivasan .",
    "a parameterized benchmark suite of hard pipelined - machine - verification problems . in _",
    "advanced research working conference on correct hardware design and verification methods _ , pages 363366 , october 2005 .",
    "nam , k.  a. sakallah , and r.  a. rutenbar .",
    "satisfiability - based layout revisited : detailed routing of complex fpgas via search - based boolean sat . in _ international symposium on field - programmable gate arrays _ , february 1999 .",
    "l.  zhang and s.  malik . validating sat solvers using an independent resolution - based checker : practical implementations and other applications . in _ design , automation and testing in europe conference _ , march 2003 ."
  ],
  "abstract_text": [
    "<S> maximum satisfiability ( maxsat ) is a well - known optimization problem , with several practical applications . </S>",
    "<S> the most widely known maxsatalgorithms are ineffective at solving hard problems instances from practical application domains . </S>",
    "<S> recent work proposed using efficient boolean satisfiability ( sat ) solvers for solving the maxsatproblem , based on identifying and eliminating unsatisfiable subformulas . however , these algorithms do not scale in practice . </S>",
    "<S> this paper analyzes existing maxsatalgorithms based on unsatisfiable subformula identification . </S>",
    "<S> moreover , the paper proposes a number of key optimizations to these maxsatalgorithms and a new alternative algorithm . </S>",
    "<S> the proposed optimizations and the new algorithm provide significant performance improvements on maxsatinstances from practical applications . </S>",
    "<S> moreover , the efficiency of the new generation of unsatisfiability - based maxsatsolvers becomes effectively indexed to the ability of modern sat solvers to proving unsatisfiability and identifying unsatisfiable subformulas . </S>"
  ]
}