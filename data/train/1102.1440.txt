{
  "article_text": [
    "coalescing and annihilating random walks are important tools in the theory of interacting particle systems @xcite ( where they serve as duals of the fundamental _ voter _ and _ antivoter model _ ) .",
    "they are also useful in the theory of discrete markov chains @xcite , particularly related to _ perfect sampling _ via coupling from the past @xcite .",
    "a model from the statistical physics of social balance @xcite led us in @xcite to considering an extension of annihilating random walks to hypergraphs .",
    "in this note we study the @xmath0-version of the system from @xcite . specifically , we consider    [ maindef ] let @xmath3 be an integer .",
    "@xmath0-annihilating walk on a hypergraph @xmath4 _ is defined as follows : each node @xmath5 of @xmath4 is initially endowed with a number @xmath6 ( interpreted as number of _ particles _ ) .",
    "the allowed moves are specified as follows : choose a node @xmath5 such that @xmath7 and a hyperedge @xmath8 containing @xmath5 . change the state of @xmath9 to @xmath10 . also change the state of every node @xmath11 , @xmath12 to @xmath13 .",
    "the dynamics from definition  [ maindef ] has a very intuitive description : a number of indistinguishable particles are initially placed at the vertices of @xmath4 , each vertex holding from 0 to @xmath14 particles . at each step",
    "we choose a vertex @xmath5 containing at least one particle and a hyperedge containing @xmath5 .",
    "we delete one particle at @xmath5 and add one particle at every vertex @xmath15 . if the number of particles at some @xmath16 reaches @xmath1 , these @xmath1 particles are removed from @xmath16 ( they  collectively annihilate  ) .",
    "we are mainly interested in the complexity of the following two problems :    given hypergraph @xmath17 and states @xmath18 , decide whether @xmath19 is reachable from @xmath20 .",
    "given hypergraph @xmath17 and states @xmath18 , decide whether @xmath19 is reachable from any state @xmath21 reachable from @xmath20 .",
    "of course , reachability and recurrence are fundamental prerequisites for studying the _ random _ version of this dynamical system as a finite - state markov chains , the problem that was the original motivation of our research .",
    "there are simple algorithms that put the complexity of these two problems above in the complexity classes pspace and expspace , respectively : for reachability we simply consider reachability in the ( exponentially large ) state space directed graph @xmath22 with vertex set @xmath23 . for recurrence",
    "we combine enumeration of all vertices @xmath24 reachable from @xmath20 ( via breadth first search ) with testing reachability of @xmath19 from @xmath24 .",
    "the main purpose of this paper is to show that under a quite liberal sufficient condition , reachability and recurrence questions for @xmath0-annihilating walks on hypergraphs can be decided in polynomial time ( actually they belong to the apparently weaker class @xmath25-l @xcite , but we wo nt discuss this issue here any further ) , by solving a certain system of linear equations over @xmath26 .",
    "for simplicity of modular arithmetic , in this paper we will assume that @xmath2 is a prime ( so that @xmath0 is a field ) .",
    "this is most likely not an essential assumption , but it will make some of the tricks employed ( e.g. observation 2 below ) easier .",
    "after completing our paper @xcite we found out that the dynamics we study there is naturally related to a classical problem in the area of combinatorial games .",
    "specifically , the dynamics studied in @xcite is a generalization to hypergraphs of a variant of the _ lights out ( @xmath27)-game _ @xcite , a problem that has seen significant investigation .",
    "the version we considered in @xcite is the apparently more constrained _ lit - only @xmath28-game _ :",
    "let @xmath29 be a finite graph .",
    "each vertex @xmath30 has a lightbulb ( that is either  on `` or ' ' off  ) and a light switch . in the _ lights out",
    "( @xmath27)-game _ pressing the light switch at any given vertex @xmath5 changes the state of the lightbulbs at _ all neighbors of @xmath5_. in the @xmath28-game the action also changes the state of the lightbulb at @xmath5 .",
    "the _ lit - only _ versions of the @xmath27 and @xmath28 games only allow toggling switches of lit vertices .",
    "sutner @xcite showed that the all zeros state is reachable from the all - ones state in the @xmath28-game .",
    "this was generalized to scherphuis @xcite to the lit - only @xmath28-game .",
    "a recent result ( @xcite theorem 3 ) significantly overlaps with our result in @xcite , essentially showing that the lit - restriction does not make a difference for reachability on hypergraphs that arise as so - called _ neighborhood hypergraphs _ @xcite of a given graph ; this result is incomparable to ours , as it does not require , as we do , that the degree of each hyperedge to be at least three ; on the other hand we do not restrict ourselves to neighborhood hypergraphs .",
    "is the ' ' all ones  state then the only state @xmath20 allowed by our result as a preimage of @xmath19 is @xmath31 .",
    "]    lights out games were considered for finite fields @xmath0 , @xmath32 as well , e.g. in @xcite .",
    "our framework differs from the one in that paper in several important ways : first we consider the @xmath28-game ( rather than the @xmath27-game ) .",
    "second our definition differs slightly in the specification of the dynamics , as the value of the scheduled vertex _",
    "decreases _ , rather than increases , by one ( as it does in @xcite ) .",
    "the motivation for this variation is our desired connection with the theory of _ interacting particle systems _",
    "@xcite , particularly with the definition of coalescing / annihilating random walks .",
    "the further connections with this latter theory are also worth mentioning : threshold coalescing and annihilating random walks , where several particles have to be present at a site for interaction with the new particle to occur , have previously been studied ( e.g. @xcite ) in the interacting particle systems literature . compared to this work",
    "our results differ in an important respect : instead of working on a lattice like @xmath33 our result considers the case of a finite hypergraph .",
    "remarkably few results in this area ( e.g. @xcite , @xcite , see also @xcite chapter 14 ) consider the case of a finite graph topology , much less that of a finite hypergraph .",
    "finally , we briefly discuss the connections between the dynamical model studied in this paper and the statistical physics of social dynamics @xcite . as stated , a model insipired by the sociological theory of _ social balance _",
    "@xcite that originated in the statistical physics literature @xcite , was the original motivation for our work @xcite .",
    "we do not see how to sensibly extend the model in @xcite so that it corresponds to our generalization of annihilating random walks . on the other hand",
    "such walks correspond via _ duality _ ( see @xcite chapter 14 and @xcite ) to a fundamental model of opinion dynamics , the _",
    "antivoter model_.  cyclic  extensions of antivoter models have been investigated as well ( e.g. @xcite ) , and we can define such a `` cyclic '' extension that corresponds via duality to our @xmath0-generalization of annihilating random walks .",
    "details ( and a more complete study of our system as a markov chain ) are left for future work .",
    "let @xmath34 and @xmath35 be states of the system such that @xmath36 is reachable from @xmath34 .",
    "define variables @xmath37 denoting the number of times ( modulo @xmath1 ) that vertex @xmath5 and hyperedge @xmath8 are chosen in the process from definition  [ maindef ] .",
    "the effect of scheduling pair @xmath38 , given current configuration @xmath39 , is to modify the value of @xmath40 by @xmath41 and of all @xmath42 by + 1 ( mod p ) .",
    "hence :    @xmath43    we will denote by @xmath44 the system of equations  ( [ diff ] ) .    does the converse hold ? i.e. is the solvability of system @xmath44 sufficient for the state @xmath19 to be reachable from @xmath20 ?    [ counter ] in general the answer to the previous question is negative : figure  1 provides a counterexample : from state @xmath45 $ ] one can not reach state @xmath46 $ ] , even though the system has a solution in @xmath47 .",
    "indeed , the only other configurations reachable from @xmath48 $ ] are easily seen to be @xmath49 $ ] and its permutations , as well as @xmath50 $ ] . alternatively , state @xmath51 $ ] is a _ garden - of - eden _ state , since no edge can be the last one to be scheduled and produce configuration @xmath52 $ ] on its vertices ; indeed , the scheduled vertex would have had zero particles to start with , making the move illegal .",
    "[ fig1 ]     ( p=3 ) ( b ) .",
    "the system and its solution , width=170,height=170 ]    @xmath53 @xmath54    nevertheless , in some conditions a converse does actually hold :    [ goodh ] a hypergraph @xmath4 is _ good _ if :    * @xmath4 is connected . * for every hyperedge @xmath55 , @xmath56 .",
    "* for every two hyperedges @xmath57 , @xmath58 .",
    "in particular , @xmath4 is _ simple _ , i.e. for no two hyperedges @xmath59 it holds that @xmath60 .",
    "we have to impose conditions in definition  [ goodh ] to obtain    [ trees ] let @xmath4 be a good hypergraph .",
    "let @xmath20 be an initial configuration that is not identical to the `` all zeros '' configuration * 0 * , and let @xmath19 be a final configuration .    then @xmath19 is reachable from state @xmath20 if and only if system @xmath44 has a solution in @xmath0 .",
    "we will need the following definitions :    when system @xmath44 is solvable we define _ the norm of the system @xmath44 _ as the quantity @xmath61 where @xmath62 ranges over all solutions of the system and the @xmath63 s and the sum are taken in @xmath64 , rather than @xmath0 .",
    "let @xmath29 be a hypergraph , @xmath65 be a hyperedge in @xmath4 , and @xmath66 a vertex .",
    "we define state vector @xmath67 by @xmath68    let @xmath29 be a hypergraph , @xmath65 be a hyperedge in @xmath4 , @xmath69 be a state and @xmath70 .",
    "we denote by @xmath71}$ ] the following state : @xmath72}(v)=\\left\\{\\begin{array}{ll }                w(v ) & \\mbox { , if } v\\not \\in l , \\\\",
    "w(v)+a(v ) & \\mbox { , otherwise.}\\\\                \\end{array }         \\right.\\ ] ]    also , with the conventions in the previous definition , we will write @xmath73}$ ] instead of @xmath74}$ ] and , for @xmath75 , @xmath76}$ ] instead of @xmath77}$ ] . vector @xmath76}$ ] can be interpreted as applying k moves at vertex v on edge l.    [ good ] a pair of vertices @xmath78 is _ good in state @xmath69 _ if @xmath79 .",
    "we first make the following simple    [ trick ] let @xmath80 be a configuration on hypergraph @xmath4 and @xmath81 two vertices of @xmath4 in the same hyperedge @xmath8 such that pair @xmath78 is good in @xmath80 . then one can change configuration @xmath80 into configuration @xmath82 that has the same number of particles at @xmath83 but the number of particles at any other vertex @xmath5 of @xmath8 increases by one ( mod @xmath1 ) .",
    "the move only involves edge @xmath8 and some of its vertices .",
    "a similar statement holds for decreasing labels by one ( mod @xmath1 ) , instead of increasing them .    if @xmath84 and @xmath85 first make a move at vertex @xmath86 then make a move at vertex @xmath87 .",
    "the number of particles at @xmath83 stays the same , whereas it increases by two ( mod p ) at any other vertex .",
    "since @xmath2 is prime , @xmath1 is relatively prime to 2 .",
    "we repeat this process @xmath88 times , where @xmath88 is chosen such that @xmath89 ( mod p ) .",
    "if @xmath90 then @xmath91 ( mod p ) , so we may repeat the above scheme with moves first made at @xmath87 then at @xmath86 .",
    "the proof for the second case is identical , with @xmath92 ( mod @xmath1 ) .",
    "we prove theorem  [ trees ] by induction on @xmath93 , the number of hyperedges of @xmath4 .",
    "* * case @xmath94 : * suppose system @xmath44 has a solution . since @xmath4 contains a single edge @xmath8 , @xmath95 for all vertices @xmath96 ( otherwise the system would contain an equation @xmath97 , with @xmath98 ) .",
    "thus we can assume that @xmath4 consists of exactly those vertices @xmath99 connected by edge @xmath8 .",
    "denote @xmath100 the vector @xmath101 and , for simplicity , let @xmath102 be shorthands for @xmath103,\\overline{w}[v_{2}],\\ldots , \\overline{w}[v_{k}]$ ] .",
    "similarly , let @xmath104 stand for @xmath105 $ ] , where @xmath106 , @xmath107 . also define @xmath108 .",
    "system @xmath44 reads : @xmath109 + the solvability ( and solutions ) of system @xmath44 can easily be characterized in this case , and depends on whether @xmath110 or @xmath111 . in the former case",
    "one can easily check that for any @xmath112 system @xmath44 has an unique solution @xmath113 $ ] , @xmath114 . in the latter case ,",
    "the system @xmath44 has a solution if and only if @xmath115 ( mod p ) .",
    "indeed , the condition follows immediately from summing the equations of the system . on the other hand",
    "if @xmath115 holds one can easily verify that the following family @xmath116 with @xmath117 arbitrary in @xmath0 , represents the family of solutions of system @xmath44 .",
    "+ in what follows we will not refer to this case dichotomy , but will simply prove the result by induction over @xmath118 . with little risk of ambiguity , we will also denote @xmath119 a solution of @xmath44 witnessing the value of the norm . * * * case @xmath120 * : + let @xmath121 be the unique index such that @xmath122 .",
    "then @xmath123 and @xmath124 for @xmath125 , the equalities being interpreted in @xmath0 . in other words , we need to show how to change state vector @xmath126 $ ] into state vector @xmath127 $ ] .",
    "+ if @xmath128 a simple move at @xmath129 changes state @xmath20 into @xmath19 directly .",
    "so the only case that needs a proof is @xmath130 .",
    "+ let @xmath125 such that @xmath131 .",
    "such an index exists since @xmath132 .",
    "furthermore , by reassigning indices we may assume without loss of generality that @xmath133 and @xmath134 . thus target state vector",
    "is @xmath135 $ ] 1 .",
    "first , using @xmath136 times the trick from observation  [ trick ] at vertices @xmath86 and @xmath87 changes @xmath137 $ ] into @xmath138 $ ] .",
    "we choose @xmath139 ( mod p ) in such a way so that @xmath140 ( mod p ) .",
    "next , apply ( p-2 ) times the trick in observation  [ trick ] between vertices @xmath87 and @xmath24 to turn the state vector into @xmath141 $ ] . + apply now a move at @xmath142 to turn the state vector into @xmath143 $ ] .",
    "if @xmath144 ( mod p ) then by applying 2-r times ( mod p ) the trick in observation  [ trick ] to vertices @xmath86 and @xmath87 we reach the desired final state .",
    "3 .   suppose we can not reach case 2 for * any * choice of @xmath145 with @xmath146 .",
    "therefore , vector @xmath20 contains only zeros and @xmath147 , with at least one @xmath148 . rearranging indices",
    ", we may assume @xmath149 $ ] , for some @xmath150 , and the target vector is @xmath151 $ ] .",
    "this is easy to accomplish : first make @xmath14 moves at vertex @xmath87 . then use observation  [ trick ] twice at vertices @xmath86 and @xmath87 , to reach desired state @xmath19 . * * * case @xmath152 : * if either there exist two indices @xmath153 with @xmath122 , or only such index exists , but a single move at @xmath154 moves the configuration to @xmath155 then we are done : we first make one available move that brings the system to @xmath24 .",
    "now it is easily checked that system @xmath156 is solvable and has norm x-1 ; we apply the induction hypothesis .",
    "+ the only remaining case is @xmath157 $ ] and @xmath158 $ ] .",
    "this is easily solved : first apply @xmath159 times the trick in observation  [ trick ] to vertices @xmath86 and @xmath87 in order to change the state of the system to @xmath160 $ ] .",
    "then make a move @xmath161 times at @xmath87 .",
    "+ this concludes the proof of the case @xmath152 and , with it , of case @xmath94 .",
    "+ [ first ] if @xmath112 are nonzero states differing only on hyperedge @xmath8 such that @xmath19 is reachable from @xmath20 via moves of edge @xmath8 only , then @xmath20 is reachable in this way from @xmath19 as well .",
    "that is , we can `` undo '' a sequence of moves on a given edge as long as the initial and the final states are nonzero .",
    "+ we can simply reason in the hypergraph @xmath162 containing edge @xmath8 only .",
    "since @xmath19 is reachable from @xmath20 , system @xmath163 has a solution @xmath164 .",
    "it is easy to see that @xmath165 is a solution to @xmath166 and we apply the result proved in case 1 .",
    "+ we can generalize the preceding observation to the case when the hypergraph does not consist of a single edge anymore : + [ second ] let @xmath167 be a path in hypergraph @xmath4 .",
    "let @xmath20 be a state such that there exists @xmath168 with @xmath169 .",
    "for @xmath170 let @xmath171 , @xmath172 , and assume that @xmath173 for all @xmath174 .",
    "then configuration @xmath19 , specified by @xmath175 is reachable from @xmath20 ( and viceversa ) by making moves only along path @xmath176 .",
    "+ observation  [ second ] informally states that one can ",
    "propagate a one  along the path from @xmath86 to @xmath177 as long as vertices between the two are initially zero , and then restore the configuration ( see figures 2 and 3 ) .",
    "+ the forward moves are easy : schedule , in turn , vertices @xmath178 , on edges @xmath179 respectively .",
    "we use the fact that labels of @xmath180 are initially zero , hence scheduling them in turn increases the label of the next node ( @xmath177 , in case of the last one ) by one .",
    "the new nodes ( except maybe the last ) get values equal to one , so they can be scheduled in turn .",
    "vertices that are  internal  to one of the edges @xmath181 get value 1 . + the backward schedule is only a little more complicated : first we  undo `` in succession the forward moves on edges @xmath182 , using case 1 of the theorem and the fact that each of @xmath181 contains at least one ' ' internal  node ( whose label is 1 ) .",
    "the proof of this last claim crucially uses the last two conditions in the definition of good hypergraphs .",
    "+ we are left with vertex @xmath87 with a label of 1 .",
    "we can use it to restore the correct values on edge @xmath183 as well .",
    "+ [ forward ] + [ backward ] * * case @xmath184 : * the proof shares the overall structure with the corresponding proof in the case @xmath185 from @xcite , although the specific cases are _ not _ those from @xcite , but reasonably different ones , employing some combinatorial constructions ( e.g. observation  [ trick ] ) that were not needed in the original proof",
    ". + there are two possibilities : 1 .",
    "* for some @xmath65 the system @xmath44 has a solution @xmath186 with @xmath187 for all @xmath66 . *",
    "+ then we define hypergraph @xmath188",
    ". system @xmath189 is solvable : indeed , every solution of @xmath44 such that @xmath187 for all @xmath66 is a solution of @xmath189 .",
    "+ intuitively we would like to reason inductively , removing edge @xmath190 and dealing with hypergraph @xmath191 instead of @xmath4 .",
    "however , removing edge @xmath190 can potentially make hypergraph @xmath191 disconnected , and can also create components on which @xmath20 is identically zero .",
    "this creates a problem in changing state from @xmath20 to @xmath19 on the connected components of @xmath191 .",
    "we will show that one can use hyperedge @xmath190 to eliminate this problem and  combine  the independent scheduling strategies .",
    "+ we first classify the components of @xmath191 into four categories : 1 .",
    "connected components @xmath176 of @xmath191 such that @xmath192 .",
    "connected components @xmath193 of @xmath191 such that @xmath194 but there exists a vertex @xmath195 with @xmath196 .",
    "3 .   connected components @xmath197 of @xmath191 such that @xmath198 and @xmath199 .",
    "connected components @xmath22 of @xmath191 such that @xmath200 .",
    "+ components of type ( d ) can be eliminated from consideration , as the state on vertices of such components does not change .",
    "also , we may assume that there exists at least one component of type ( c ) , or else we would eliminate such components from consideration as well .",
    "also , since @xmath201 was connected , every connected component contains at least one vertex from @xmath190 .",
    "+ let @xmath202 @xmath203 + the proof comprises several subcases : 1 .",
    "_ there exists @xmath204 with @xmath205 and @xmath206 vertices in l such that @xmath207}_{f(z_{2})}(z_{2})\\neq w^{[w_{1}(z_{1},l),z_{1},l]}_{f(z_{3})}(z_{3})\\ ] ] _ + to show that @xmath19 is reachable from @xmath20 we employ the following schedule : 1 .",
    "first schedule vertex @xmath208 in edge @xmath190 successively ( @xmath209 times ) until @xmath210 .",
    "this makes vertices @xmath211 of @xmath190 that belong to components of type ( c ) assume nonzero values . indeed , such vertices initially had zero values , @xmath209 was nonzero , and the sum @xmath212 is invariant throughout the process . also , by definition of connected components of type ( c ) and the fact that @xmath205 , every connected component of this type must contain such a vertex @xmath211 of @xmath190 .",
    "+ the new state of the system is of course ( according to our notation ) @xmath213}_{1}$ ] .",
    "next we use the induction hypothesis on the connected components @xmath80 of type ( c ) to change the state from @xmath214}_{1}|_{c}$ ] to @xmath214}_{2}|_{c}$ ] .",
    "here we employ the fact that for every @xmath75 @xmath215}_{2}-w^{[k , z_{1},l]}_{1}=w_{2}-w_{1}$ ] , therefore the system associated to the reachability problem on each connected component @xmath80 of type ( c ) is a subset of @xmath44 , hence solvable .",
    "since vertices @xmath190 in @xmath80 , @xmath216 have ( as we previously argued ) nonzero values in @xmath214}_{1}$ ] , reachability on such components follows by the induction hypothesis .",
    "now we apply the trick in observation  [ trick ] , scheduling alternatively , @xmath217 times , vertices @xmath218 and @xmath219 .",
    "the crucial aspect is that _ at the beginning of this process vertices @xmath218 and @xmath219 have different values _",
    ", hence pair @xmath220 is good at the beginning of this stage .",
    "this is easily seen by the conditions we impose on @xmath221 .",
    "+ the number of alternations is specially chosen so that the outcome of this stage is that labels of all vertices in @xmath190 , other than @xmath221 , decrease by one .",
    "crucially , at the end of this stage vertex @xmath208 has label @xmath14 ( since before this stage its state was zero ) .",
    "the next step is to schedule vertex @xmath208 and edge @xmath190 @xmath222 times .",
    "this is possible since @xmath223 .",
    "crucially , the sequence of moves preserves the property that @xmath218 and @xmath219 have different labels , so pair @xmath220 is good in the resulting state .",
    "next we apply the trick in observation  [ trick ] , scheduling alternatively ( @xmath224 times ) vertices @xmath218 and @xmath219 .",
    "+ the number of alternations is chosen so that it increases the state of every vertex in @xmath190 , other than @xmath218 and @xmath219 , by one .",
    "this allows us to compute the state of every vertex @xmath225 at this stage : @xmath226 if @xmath186 belongs to a component of type ( a ) or ( b ) , @xmath227 if @xmath186 belongs to a component of type ( c ) .",
    "+ indeed , in the first case the only changes to the state were those imposed by scheduling vertex @xmath208 a total of @xmath1 times ( hence the net effect modulo @xmath1 is null ) and scheduling vertices @xmath218 and @xmath219 @xmath228 times each ( hence their net effect modulo @xmath1 is also null ) . for vertices in components of type ( c )",
    "the additional change at step ( ii ) ensures that at the end of the process their state is @xmath227 .",
    "finally , we use the induction hypothesis on @xmath93 to change state on components of type ( a ) and ( b ) from @xmath20 to @xmath19 _ without employing edge @xmath190_. this makes the system assume state @xmath19 on all vertices .",
    "there exists @xmath204 with @xmath205 , subcase ( a ) does not apply and there exists @xmath229 in a component of type ( c ) such that @xmath230 . _",
    "+ we can reduce this subcase to the previous one as follows : in the previous schedule , before step ( iii ) use the forward propagation trick in observation  [ second ] on a shortest path @xmath176 from a vertex @xmath229 with @xmath231 to some vertex @xmath218 of edge @xmath190 .",
    "this changes the state to exactly one vertex of @xmath190 , namely @xmath218 .",
    "moreover @xmath232 ( since @xmath218 belongs to a component of type ( c ) ) , so the conditions of subcase ( a ) are satisfied ( with @xmath219 chosen arbitrarily in @xmath233 .",
    "the value of node @xmath218 does not change throughout the rest of the schedule in subcase ( a ) , so after its completion we can  undo  the propagation , using observation  [ second ] , from @xmath218 to @xmath234 , without employing edge @xmath190 .",
    "@xmath235 , and subcases ( a ) and ( b ) do not apply . _",
    "+ let @xmath204 with @xmath205 .",
    "+ there exists @xmath236 such that @xmath237 for all @xmath238 , @xmath239 .",
    "+ moreover , either @xmath208 is the only vertex of @xmath190 in components of type ( a ) or ( b ) , or the equality is true for @xmath208 as well .",
    "+ let @xmath240 and @xmath241 .",
    "@xmath236 since ( as subcase ( b ) does not apply ) @xmath242 and q is a component of type ( c ) .",
    "we then apply the fact that subcase ( a ) does not apply .",
    "+ the last part of the claim follows from the fact that no matter how we choose @xmath208 subcases ( a ) and ( b ) do not apply .",
    "+ we first perform the first two steps of the schedule in subcase ( a ) .",
    "the resulting state on edge @xmath190 is @xmath243 .",
    "note that since @xmath236 and @xmath2 is prime , @xmath244 .",
    "+ next , choose an edge @xmath8 of @xmath193 that intersects @xmath190 at vertex @xmath87 .",
    "schedule vertex @xmath87 and edge @xmath8 , thus decreasing the label of vertex @xmath87 by one .",
    "this creates a new value on one vertex different from @xmath208 and allows us to continue with the schedule in subcase ( a ) . after completing this schedule",
    "we  undo  the move at edge @xmath8 . in this case , since subcase ( a ) does not apply we can infer natural restrictions on the values of @xmath112 on a vertex @xmath238 : * * @xmath20 assumes only values @xmath245 on all vertices of @xmath190 in components of type ( a ) and ( b ) . *",
    "* @xmath19 assumes an unique value @xmath246 on all vertices of @xmath190 in components of type ( c ) .",
    "+ note also that there exists a component @xmath193 of type ( c ) that does _ not _ consist of an isolated vertex .",
    "indeed , components of type ( c ) exist , by our assumption .",
    "no such component that intersect @xmath190 can consist of an isolated vertex only , or they would yield an equation @xmath247 , with @xmath248 , in the system @xmath44 . + we specify the following schedule : * * first , change the state from @xmath20 to @xmath19 on components of type ( a ) and ( b ) without using edge @xmath190 .",
    "this follows from the solvability of the resulting system .",
    "* * now schedule vertex @xmath218 and edge @xmath190 @xmath249 times .",
    "the net result is that all vertices of @xmath190 in components of type ( c ) now have nonzero values equal to @xmath249 .",
    "also vertex @xmath218 now has a zero label . * * schedule all components of type ( c ) , including q , using their vertices of @xmath190 that are nonzero , to change their state from @xmath250}_{1}$ ] to @xmath250}_{2}$ ] . at this point system state",
    "is @xmath251}_{2}$ ] .",
    "in particular all the vertices of @xmath4 outside edge @xmath190 have the correct labels specified by state @xmath19 , and vertices of @xmath190 in components of type ( c ) have the common value @xmath252 . * * if there exist two vertices @xmath219 , @xmath253 whose labels at this stage are different then we can use them to restore the correct values to all vertices as follows : employ observation  [ trick ] alternating vertices @xmath219 and @xmath234 @xmath254 times each , in order to decrease the labels of all other vertices of @xmath190 ( crucially , including @xmath218 ) by 1 ( modulo @xmath1 ) .",
    "this changes the label of @xmath218 to @xmath14 .",
    "next , schedule @xmath218 and edge @xmath190 @xmath255 times , thus canceling ( modulo @xmath1 ) the effect of scheduling them in stage ( ii ) .",
    "this transformation preserves the fact that the labels of @xmath219 and @xmath234 are different , so we can schedule them again @xmath256 times each , to increase all labels of vertices in @xmath190 - except theirs - by one ( modulo @xmath1 ) , cancelling the effect of their earlier scheduling of vertex labels in edge @xmath190 . * * in the opposite case we employ the following trick to change the value of some vertex @xmath257 in @xmath258 ( hence necessarily @xmath259 ) as follows : let @xmath164 be a node of @xmath193 with @xmath260 chosen to minimize distance to @xmath190 .",
    "let @xmath176 be a path of minimal length connecting @xmath164 to @xmath261 , and let @xmath262 be the connection point .",
    "all nodes closer to @xmath190 have zero values .",
    "we apply the  forward `` trick to nodes of @xmath176 to increase the label of @xmath262 by one . at this point",
    "we satisfy the conditions of the previous step with @xmath263 , @xmath264 . then we ' ' undo `` the move on path @xmath176 using the ' ' backward  trick .",
    "there exists @xmath204 with @xmath205 , and subcases ( a ) and ( b ) do not apply_. + in this case , since subcases ( a ) and ( b ) do not apply we can infer natural restrictions on the values of @xmath112 on a vertex @xmath238 : * * @xmath20 assumes only values @xmath245 on all vertices of @xmath190 in components of type ( a ) and ( b ) .",
    "@xmath265 on all such vertices . *",
    "* @xmath266 for all vertices @xmath238 in components of type ( c ) .",
    "@xmath19 assumes an unique value @xmath246 on all vertices of @xmath190 in components of type ( c ) .",
    "+ subcase ( b ) may fail to apply because of nonexistence of either @xmath218 or @xmath219 with the required properties , or both .",
    "+ the case when @xmath219 exists is easy : just specify the following schedule : * * start , as in subcase ( a ) , scheduling vertex @xmath208 and edge @xmath190 @xmath209 times , followed by all components of type ( c ) , including q , using their vertices of @xmath190 that are nonzero , to change their state from @xmath267}_{1}$ ] to @xmath267}_{2}$ ] . *",
    "* then apply the propagation trick from @xmath219 to @xmath268 . * * last , change the state from @xmath20 to @xmath19 on components of type ( a ) and ( b ) without using edge @xmath190 .",
    "this follows from the solvability of the resulting system .",
    "+ so assume that @xmath219 does _ not _ exist . in this case , since on components of type ( c ) @xmath19 is not identically zero it follows that @xmath269 .",
    "@xmath270_. + in this case we reduce the problem to one of the previous subcases as follows : @xmath132 , hence there exist a vertex @xmath5 with @xmath196 .",
    "choose such @xmath5 at minimal distance from @xmath190 , let @xmath176 be a path connecting it to a vertex in @xmath190 .",
    "we first use the  forward propagation trick  in observation  [ second ] to change the state to state @xmath24 such that @xmath271 .",
    "system @xmath156 has a solution with @xmath272 , for all @xmath273 , obtained by changing the solution of @xmath44 along path @xmath176 .",
    "we then apply one of the previous cases and conclude that @xmath19 is reachable from @xmath24 , hence from @xmath20 .",
    "2 .   * for all @xmath65 , all solutions @xmath186 of @xmath44 satisfy @xmath274 for some @xmath66 . *",
    "+ the proof follows by induction on the norm @xmath62 of system @xmath44 . * * * case i : @xmath120*. in this case @xmath20 and @xmath19 differ on a single edge @xmath8 , and we try to convert * * * case ii : @xmath152*. consider a solution @xmath275 with smallest norm . if for some @xmath66 with @xmath274 scheduling pair @xmath276 once yields a nonzero state @xmath24 then system @xmath156 falls into case 1 , or is solvable and has smaller norm . from the induction hypothesis @xmath19",
    "is reachable from @xmath24 , hence from @xmath20 .",
    "+ we now show that , under the hypothesis that @xmath184 the remaining alternative can not happen . indeed , assuming otherwise , then for all @xmath66 such that @xmath274 , @xmath277 , @xmath278 for all @xmath279 . since @xmath184 ,",
    "in any two intersecting edges @xmath59 @xmath4 has two vertices @xmath83 _ not _ in the common intersection with an equal label in @xmath20 ( either 1 or @xmath14 ) .",
    "they can not be _ both _ turned to zero by scheduling a single edge .",
    "we have seen that reachability is easy to test . in the next result",
    "we show that recurrence essentially reduces to two reachability tests :    [ recurrence ] in conditions of theorem  [ trees ] , given hypergraph @xmath17 and states @xmath18 , @xmath132 , state @xmath19 is a recurrent state for the dynamics started at @xmath20 if and only if :    * \\(1 ) @xmath19 is reachable from @xmath20 . * \\(2 ) state @xmath280 is _ not _ reachable from @xmath20 .",
    "necessity of the two conditions is trivial .",
    "suppose therefore that conditions ( 1 ) and ( 2 ) are satisfied , and let @xmath21 be a state reachable from @xmath20 .",
    "state @xmath155 because of condition ( 2 ) . on the other hand",
    "let @xmath281 be a solution of the system @xmath282 and @xmath283 be a solution of the system @xmath284 .",
    "one can immediately verify that @xmath285 ( where the difference is taken componentwise in @xmath0 ) is a solution of the system @xmath286 .",
    "applying theorem  [ trees ] we infer that @xmath19 is reachable from @xmath24 .",
    "consider the markov chain specified by running the @xmath0-annihilating random walk on a good hypergraph @xmath4 .    1",
    ".   transient states for the dynamics are those states @xmath287 such that system @xmath288 is solvable .",
    "all other states are either recurrent or inaccessible , depending on the starting point for the dynamics .",
    "it would be interesting ( especially in light of observation  [ counter ] ) to study reachability and recurrence on graphs . perhaps excluding configuration @xmath289 as a final state ( along the lines of the condition imposed in @xcite on the final configuration ) is enough to recover the connection with linear algebra .",
    "another issue for further study ( interesting , in light of the connection with annihilating random walks ) is the dynamics of _ modular lights - out games under random update _",
    ", seen as finite state markov chains ( see @xcite chapter 14 and @xcite for related results ) . of particular interest is the observation that the antivoter model was used in the analysis of a randomized algorithm for 2-coloring a graph @xcite .",
    "this was later extended to colorings with more than two colors and/or other coloring restrictions ( e.g. @xcite , see also @xcite ) and 2-colorings of hypergraphs .",
    "whether cyclic antivoter models and related concepts are useful in the analysis of randomized coloring algorithms is an interesting issue for further study .",
    "this work has been supported by a project on postdoctoral programs for sustainable development in a knowledge - based society , contract posdru/89/1.5/s/60189 , cofinanced by the european social fund via the sectorial operational program for human resource development 2007 - 2013 ."
  ],
  "abstract_text": [
    "<S> we study a dynamical system motivated by our earlier work @xcite on the statistical physics of social balance on graphs @xcite , that can be viewed as a generalization of annihilating walks along two directions : first , the interaction topology is a hypergraph ; second , the  number of particles  at a vertex of the hypergraph is an element of a finite field @xmath0 of integers modulo @xmath1 , @xmath2 . </S>",
    "<S> equivalently , particles move on a hypergraph , with a moving particle at a vertex being replaced by one indistiguishable copy at each neighbor in a given hyperedge ; particles at a vertex collectively annihilate when their number reaches @xmath1 . </S>",
    "<S> the system we study can also be regarded as a natural generalization of certain lights - out games @xcite to finite fields and hypergraph topologies .    </S>",
    "<S> our result shows that under a liberal sufficient condition on the nature of the interaction hypergraph there exists a polynomial time algorithm ( based on linear algebra over @xmath0 ) for deciding reachability and recurrence of this dynamical system . </S>",
    "<S> interestingly , we provide a counterexample that shows that this connection does _ not _ extend to all graphs . </S>"
  ]
}