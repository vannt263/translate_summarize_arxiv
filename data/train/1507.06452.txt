{
  "article_text": [
    "personalizing the user experience is a continuous growing challenge for various digital applications .",
    "this is of particular importance when recommending releases on the netflix platform , when digesting latest yahoo news , or for helping users to find their next musical obsession .    among the different approaches towards personalization , matrix factorization ranges among the most popular ones @xcite . in this line of work",
    ", data is represented in the form of a user - item matrix , encoding user - item interactions in the form of binary or real values .",
    "matrix factorization aims at decomposing a matrix into latent representations designed to accurately reconstruct observed interaction values .",
    "most interestingly , these latent features are also used to predict missing ( or unknown ) ratings ( i.e. if item @xmath0 is exposed to user @xmath1 , what would be his rating ) . however , by trying to predict the unknown ratings based on a model trained on the observed ratings , the recommender systems implicitly assume that the distribution of the observed ratings is representative of the distribution of the unknown ones .",
    "this is called the _ missing at random _ assumption @xcite , and it is probably a wrong asumption in most real - world applications . in the case of a movie recommender system , for example ,",
    "users rate movies that they have seen , and their choices are biased by their interests .    in this work , building on the _ not missing at random assumption _  @xcite we make the hypothesis that it is more likely for an unknown item to be weakly rated , this due to the huge amounts of existing items coupled to the limited number of items a user may be interested in .",
    "this translates into a strong prior suggesting that unknown ratings should be reconstructed from latent features as small values ( i.e. close to 0 ) .",
    "while this assumption may be wrong for specific cases , such constraints act as a good regularizer that helps in significantly improving the recommendations .",
    "our work is not the first to propose new interpretation of the missing data in a matrix factorization framework @xcite .",
    "however , to the best of our knowledge , we are the first to propose an _ online learning _",
    "mechanism that sets an explicit prior on unknown values and this , without any significant additional cost .",
    "we introduce a method to update our model each time a new rating is observed with a time complexity independent of the size of the data ( i.e. the total number of users , items , and ratings ) .",
    "this fast update mechanism allows keeping the model up to date when a flow of new users , items and ratings enters the system .",
    "the contributions of this work are as follows :    we extend the squared loss , the absolute loss  and the generalized kullback - liebler divergence  to take into account an explicit prior on unknown values .    for each loss function",
    ", we derive an efficient _ online learning algorithm _ to update the parameters of the model with a complexity independent of the data size .",
    "we validate the hypothesis that applying an explicit prior on missing ratings improves the recommendations in a static and in a dynamic setting on three public datasets .",
    "our methods are easy to implement and we provide an open - source implementation of the squared loss  and absolute loss .    the rest of this paper is organized as follows .",
    "section  [ sec : recommendation - problem ] summarizes the recommendation problem and section  [ sec : missing - data ] formulates how to apply priors on unknown values in the context of recommendation .",
    "section  [ sec : loss - funtcions ] extends three loss functions and shows how they can be optimized in a static and dynamic fashion .",
    "section  [ sec : experiments ] presents our experimental results and section  [ sec : related - work ] discusses works related to our study .",
    "section  [ sec : conclusion ] concludes this paper .",
    "before addressing the challenge of interpreting missing data , let us state the standard recommendation problem .",
    "we have at our disposal @xmath2 items rated by @xmath3 different users , where the rating given by the @xmath4 user to the @xmath5 item is denoted by @xmath6 . in many real applications , these ratings",
    "take an integer value between 1 and 5 . in this work",
    ", we assume that ratings are positive and that an item rated by user @xmath1 with a high numerical value is preferred by this user over items she ranked with lower numerical values .",
    "we denote by @xmath7 the set of all known ratings , and by @xmath8 and @xmath9 the set of known ratings of user @xmath1 and item @xmath0 , respectively .",
    "if @xmath10 we say that the rating is _",
    "unknown_.    for a while , the objective of recommender systems has been to predict the _ value _ of unknown ratings @xcite .",
    "it is now widely accepted that a more practical goal is to correctly _ rank _ the unknown ratings for each user , while the actual value of the rating is of little interest @xcite .",
    "this has led to a change in the way methods are evaluated ( in terms of ranking metrics such as ndcg , auc or map , instead of rating prediction metrics as measured by rmse ) .",
    "we embrace that shift towards _ ranking _ , and the purpose of adding a prior on the unknown ratings is not to improve matrix factorization techniques in terms of rmse , but in terms of ranking metrics .",
    "matrix factorization methods produce for each user and each item a vector of @xmath11 ( @xmath12 and @xmath2 ) real values that we call _ latent features_. we denote by @xmath13 the row vector containing the @xmath11 features of the @xmath4 user , and @xmath14 the row vector , composed of @xmath11 features , associated to the @xmath5 item . also , we denote by @xmath15 the @xmath16 matrix whose @xmath4 row is @xmath17 , and @xmath18 as the @xmath19 matrix whose @xmath5 column is @xmath20 .",
    "matrix factorization is presented as an optimization problem , whose general form is :    @xmath21    where @xmath22 is a regularization term ( often @xmath23 or @xmath24 norms ) , and @xmath25 measures the error that the latent model makes on the observed ratings .",
    "most often , @xmath25 is the squared error .    using a matrix factorization approach for predicting unknown ratings relies on the hypothesis that a model accurately predicting observed rating generalizes well to unknown ratings . in the following section",
    ", we argue that the former hypothesis is easily challenged .",
    "launchcast is yahoo s former music service , where users could , among other things , rate songs . in a survey of 2006 , users were asked to rate randomly selected songs @xcite .",
    "the distribution of ratings of random songs was then compared to the distribution of voluntary ratings .",
    "the experiment concluded that the distribution of the ratings for random songs was strongly dominated by low ratings , while the voluntary ratings had a distribution close to uniform @xcite .",
    "intuitively , a simple process could explain the results : users chose to rate songs they listen to , and listen to music they expect to like , while avoiding genres they dislike .",
    "therefore , most of the songs that would get a bad rating are not voluntary rated by the users .",
    "since people rarely listen to random songs , or rarely watch random movies , we should expect to observe in many areas a difference between the distribution of ratings for random items and the corresponding distribution for the items selected by the users .",
    "this observation has a direct impact on the presumed capacity of matrix factorization to generalize a model based on observed ratings to unknown ratings .",
    "building on the _ not missing at random assumption _",
    "@xcite , we propose to incorporate in the optimization problem stated in equation [ eq : classic_problem ] a prior about the unknown ratings , in order to limit the bias caused by learning on observed ratings :    @xmath26    the objective function ( equation [ eq : prior_problem ] ) has now two parts ( besides the regularization ) : the first part fits the model to the observed ratings , and the second part drives the model toward a prior estimate @xmath27 on the unknown ratings . in absence of further knowledge about a specific dataset",
    ", we suggest to use @xmath28 , the worst rating , as a prior estimate .",
    "the coefficient @xmath29 allows to balance the influence of the unknown ratings , and the original formulation is obtained with @xmath30 .",
    "we expect @xmath29 to be small to deal with the problem of class imbalance .",
    "indeed , in real - life applications the number of known ratings @xmath31 is very small in comparison to the number of unknown ratings ( @xmath32 ) , and if @xmath29 is close to 1 , or larger , the second term of the objective function will completely dominate the other parts and drive all the users and items features to zero .",
    "it is therefore important to find a right balance between the influence of the few known ratings and of the many unknown ones .    in order to have a more intuitive feeling of the influence of both parts of the objective function we introduce @xmath33 , which can be interpreted as an influence ratio between unknown and known ratings . if @xmath34 , the unknown ratings are ignored , if @xmath35 , both the known ratings and the unknown ratings have the same global influence on the objective function , if @xmath36 , the unknown ratings are twice as important as the known ratings , etc .",
    "a more involved model could assume an adaptive @xmath37 per user or item , which could lead to additional , albeit small , gains .",
    "however , this implies more parameters to tune , more cumbersome equations to explain and an involved process to prove that the complexity of the method remains the same . due to limited space ,",
    "instead , we provide a general demonstration of the method and leave the adaptive model for future work .",
    "an obvious difficulty raised by the new optimization problem introduced earlier is the apparent increase in complexity .",
    "the naive complexity of evaluating this objective function is @xmath38 , while it is @xmath39 for classical matrix factorization approaches ( equation [ eq : classic_problem ] ) . in this section ,",
    "we demonstrate how it is possible to use our new model without the naive additional cost , and present a way to perform fast updates to incorporate new ratings in the model .    to this end",
    ", we show the applicability of our method when @xmath25 is the squared loss  in section  [ sec : square - loss ] and the absolute loss  in section  [ sec : absolute - loss ] . for the sake of demonstration",
    ", we also discuss its applicability on the generalized kullback - liebler divergence  in section  [ sec : kullback - leibler ] .",
    "finally , in section  [ sec : static - dynamic ] we outline how the method can be enforced in a static setting , and a dynamic setting with continuous updates of new ratings , items and users .      by considering @xmath25 as the squared loss , and @xmath22 as the @xmath23 regularization , the optimization problem becomes :    @xmath40    for the sake of simplicity , let us forget about the regularization term of the objective function for now ( adding it to the following development is trivial ) , and let us call @xmath41 the objective function without regularization .",
    "we want to be able to update the features of one user or of one item in a time independent of the size of the dataset ( @xmath42 ) . in the remainder , we show that it is possible to compute @xmath43 and @xmath44 with a complexity linear in the number of ratings provided by user @xmath1 ( @xmath45 ) or given to item @xmath0 ( @xmath46 ) , respectively . on most datasets , and for most users and items , we have @xmath47 and @xmath48 , and , therefore computing the gradient for one user or one item is fast .",
    "first , let us separate @xmath49 in @xmath3 blocks @xmath50 that contain only the terms of @xmath49 depending on @xmath17 :    @xmath51    notice that we have : @xmath52    if we adopt a naive computation , the second term of equation ( [ eq : l_w_i ] ) is more time expensive because most items are not rated by the user .",
    "however , the sum on unknown ratings ( i.e. @xmath53 ) , can be formulated as the difference between the sum on all items ( i.e. @xmath54 ) and the sum on rated items only ( i.e. @xmath55 ) . by so doing ,",
    "the sum on unknown ratings disappears from the computations :    @xmath56    where we have posed @xmath57 , a @xmath58 matrix independent of @xmath1 ( i.e. it is the same matrix for all @xmath50 ) . assuming that @xmath59 is known , we can now compute @xmath50 and @xmath60 with a complexity of @xmath61 . from equations [ eq : l_w_i ] and [ eq :",
    "sl_trick ] , we obtain :    @xmath62 + \\alpha { \\mathbf{w}_{i}}\\mathbf{s^h } { \\mathbf{w}_{i}^{t}}\\end{split } \\label{eq : block}\\end{aligned}\\ ] ]    we can easily derive :    @xmath63 { \\mathbf{h}_{j}}+ 2 \\alpha { \\mathbf{w}_{i}}\\mathbf{s^h } \\end{split } \\label{eq : gradient}\\end{aligned}\\ ] ]    symmetrically , if @xmath64 , we have :    @xmath65 + \\alpha { \\mathbf{h}_{j}}\\mathbf{s^w } { \\mathbf{h}_{j}^{t}}\\end{split } \\label{eq : fast_block}\\end{aligned}\\ ] ]    and : @xmath66 { \\mathbf{w}_{i}}+ 2 \\alpha { \\mathbf{h}_{j}}\\mathbf{s^w } \\end{split } \\label{eq : fast_gradient}\\end{aligned}\\ ] ]    assuming that @xmath67 is known , the complexity of computing @xmath68 or @xmath69 is now @xmath70 , and the complexity of computing it for every @xmath71 is @xmath72 .      a similar development can be done when the squared loss is replaced by the absolute loss . with the absolute loss , @xmath49 becomes :    @xmath73    as with the squared loss , we divide @xmath49 into @xmath50 and @xmath68 .",
    "@xmath74    as with the squared loss , we will change the expression of @xmath50 to remove the sum over all unknown ratings , but in this case we have to impose non - negativity of the features to go further .",
    "if @xmath75 , we have @xmath76 , and therefore :    @xmath77    here , instead of @xmath67 and @xmath59 , we will define @xmath78 and @xmath79 .",
    "we can now express @xmath50 and @xmath80 efficiently :    @xmath81    so that : @xmath82 where @xmath83 if @xmath84 , and equals @xmath85 otherwise .",
    "assuming @xmath86 is known , the complexity of computing @xmath50 or @xmath80 is now @xmath87 .",
    "the corresponding expression of @xmath68 and @xmath88 is trivial , and the complexity to compute them is @xmath89 .      for the sake of demonstration on other common loss functions in matrix factorization , we show here the applicability of the sparsity trick on the generalized kullback - liebler divergence  ( gkl )  @xcite .",
    "we do not elaborate further on this function in the rest of the paper .",
    "the generalized kullback - liebler divergence  is defined as follows :    @xmath90    the gkl is not defined when @xmath91 . in the following",
    "we extend the gkl by using its limit value :    @xmath92    using equation [ eq : gkl ] and [ eq : gkl_0 ] , @xmath49 becomes :    @xmath93    we now follow the same development as with the other losses .",
    "we define @xmath50 :    @xmath94    in the case of the gkl , the process to remove the sum on unknown ratings is the same as with the absolute loss , except that in absence of absolute value we do not have to impose non - negativity of the features :    @xmath95    this leads to :    @xmath96    now we can easily derive @xmath60 :    @xmath97    the corresponding expression of @xmath68 and @xmath88 is obtained symmetrically . as with the absolute loss , the complexity of computing @xmath50 or @xmath80 is now @xmath87 ( it is @xmath89 for @xmath68 and @xmath88 ) .",
    "we introduce an online algorithm to learn the latent factors from the input data in a static setting , and show how it can accommodate updates in a dynamic setting .      in order to factorize a whole new set of data we propose to use a randomized block coordinate descent @xcite . at each iteration , all the users and items are traversed in a random order .",
    "for each of them a gradient step is performed on their features while keeping the other features constant .    we can use a line search @xcite to determine the size of the gradient step because the variation of @xmath49 for a modification of @xmath17 is entirely determined by @xmath50 and can therefore be computed efficiently .",
    "line search allows to avoid the burden of tuning the step size , proper to stochastic gradient descent ( sgd ) methods @xcite .",
    "moreover , using line search guarantees the convergence of the value of the objective function .",
    "indeed , each gradient step decreases ( or rather _ can not increase _ ) the objective function which is bounded from below .",
    "this implies that the variation of the objective function converges to zero .",
    "the complete procedure for the factorization through randomized block coordinate descent is summarized in algorithm [ alg : static ] .",
    "* complexity .",
    "* in the case of the squared loss , the computation of fast gradient step relies on knowing @xmath67 and @xmath59 . their initial value is computed in @xmath98 and @xmath99 , respectively , and the cost of updating them after each gradient step is @xmath100 .",
    "the total complexity of an iteration of our algorithm is therefore @xmath101 , as good as the best factorization methods that do not use priors on unknown ratings @xcite .    in the case of the absolute loss  and generalized kullback - liebler divergence , the computation uses @xmath102 and @xmath86 .",
    "their initial value is computed in @xmath103 and @xmath104 , while the cost of updating them is @xmath105 .",
    "the total complexity of one iteration then becomes @xmath106 , which is lower than the squared loss complexity .",
    "however , this usually comes at a cost on the performance of the results , as we will show in the experiments in section  [ sec : experiments ] .",
    "@xmath107 +  the ratings @xmath7 .",
    "+  the number of features @xmath11 .",
    "+    .5    ' '' ''    height .2pt    .5    initialize @xmath15 and @xmath18 .",
    "compute @xmath67 and @xmath59 ( @xmath102 and @xmath86 ) in the case of a user ( @xmath1 ) * do * perform a gradient step on @xmath17 using line search update @xmath67 ( @xmath102 ) in the case of an item ( @xmath0 ) * do * perform a gradient step on @xmath108 using line search update @xmath59 ( @xmath86 )      the expressions of @xmath50 , @xmath68 , and their gradients ( equations ( [ eq : block ] ) , ( [ eq : gradient ] ) , ( [ eq : fast_block ] ) and ( [ eq : fast_gradient ] ) ) allow us to compute the latent representations of one user or one item in a time independent of the number of users and items in the system .",
    "we can use that ability to design a simple algorithm for updating an existing factorization when a new rating is added to @xmath7 : if user @xmath1 rates item @xmath0 , we iteratively perform gradient steps for @xmath17 and @xmath108 , keeping all other features constant .",
    "this relies on the assumption that a new rating will only affect significantly the user and item that are directly concerned with it .",
    "although this assumption can be disputed , we will show in our experiments ( section [ sec : dynamic ] ) that our update algorithm produces recommendations of stable quality , indicating that limiting our updates to the directly affected users and items does not degrade the factorization over time .",
    "when ratings are produced by new users or given to new items , a new set of features for that user or item is created before performing the local optimization .",
    "various initialization strategies could be explored here . however , as we show in our experimental results , assigning a random value to one of the features and setting the others to zero performs well in practice .",
    "the update procedure is summarized in algorithm [ alg : update ] .",
    "* complexity .",
    "* as mentioned earlier , our update algorithm is independent of the number of users or items in the system , making it suitable for very large datasets .",
    "each iteration of the update algorithm is composed of two gradient steps ( one on the user s features , and one on the item s features ) . in particular , the complexity of one iteration is @xmath109 for the squared loss , and only @xmath110 for the absolute loss  and the gkl .",
    "this difference in complexity becomes significant when @xmath11 is large with regards to the average number of ratings per user and per item .",
    "updates based on classic sgd methods have an even smaller complexity ( @xmath111 ) , but we will show in section [ sec : experiments ] that our method produces recommendations of much higher quality , while still being able to satisfy applications requiring low - latency updates .",
    "@xmath107 +  the new rating @xmath6 .",
    "+  the ratings of user @xmath1 ( @xmath8 ) and of item @xmath0 ( @xmath9 ) . +    .5    ' '' ''",
    "height .2pt    .5    if @xmath17 ( @xmath108 ) does not exist , initialize it ( for example by setting a random feature to 1 ) .",
    "add @xmath6 to @xmath8 and @xmath9 .",
    "we perform several experiments to demonstrate the following key points :    using priors on the unknown values leads to overall improved quality of ranking , in a static or dynamic setting .",
    "the quality does not degrade with time , i.e. , as more updates are added , the model does not lose accuracy .    our methods can outperform traditional techniques on various large datasets .    in our experiments ,",
    "we test the performance of the squared loss  ( sl ) and the absolute loss  ( al ) with and without prior on unknown values . in section  [ sec : exp - setup ] we describe our experimental setup : the benchmarked datasets used , the performance metrics recorded and how we tune the various parameters of the models tested during the experiments . then , in sections  [ sec : static ] and  [ sec : dynamic ] we describe the results of our methods in a _",
    "static _ and _ dynamic _ learning setting , respectively , and how they compare with state - of - the - art methods . in section",
    "[ sec : delay ] we illustrate the importance of fast updates by studying the impact of having a delay between the arrival of new ratings and the update of the factorization . in section  [ sec : exp - param - influence ] we investigate in depth the influence of parameter values selected in the two loss functions ( squared and absolute loss ) .",
    "finally , details allowing the reproducibility of the results are given in section  [ sec : exp - reproducibility ] .",
    "here we briefly describe the experimental setup used for the static and dynamic learning and how the parameters of the different methods are tuned .      during the experiments , we use three datasets with distinct features .",
    "table  [ table : datasets ] summarizes the characteristics of these datasets which provide different challenges to the recommendation task :    : this is the well - known movie ratings dataset produced by the grouplens project .",
    "we use the version containing 1 million ratings , with at least 20 ratings for each user .",
    ": this is a collection of ratings about food products extracted from the amazon comments  @xcite .",
    "the dataset is much sparser than , with most users having only a handful of ratings , making it a very hard dataset for the recommendation task .",
    ": this is a larger collection of ratings extracted from the movie section of amazon  @xcite .",
    "this dataset is also sparser than , although not as sparse as .",
    "= 0.4 cm    .characteristics of the datasets used .",
    "[ cols=\"<,>,>,>\",options=\"header \" , ]     [ table : datasets_block_size ]    the evaluation is performed as follows : an initial model is built based on all the ratings present before the test block , then , for each rating of the test block , two steps are performed in the following order :    1 .",
    "the current model is evaluated by computing the auc over the new ( user , item ) pair .",
    "notice that in this case , computing the auc means computing the proportion of items not yet rated by the user that the model ranks lower than the item that was just rated .",
    "an auc of 1 means that the new item was the top recommendation of the method for that user .",
    "2 .   the model is updated using the new rating .",
    "it is worth noticing that the rating may concern a new user or item , and , therefore , features for that new user / item have to be added to the model .",
    "parameter tuning is done as described above , but starting at the beginning of the validation block and ending before the test block .",
    "the values of parameters tested are the same as in the static test ( see table [ table : parameters ] ) .",
    "* baseline . *",
    "we compared our methods to vowpal wabbit ( vw ) .",
    "vw  is a machine learning framework solving different optimization problems for classification and ranking , by implementing a carefully optimized , stochastic gradient descent ( sgd ) using feature hashing @xcite and adaptive gradient steps @xcite .",
    "we are using the vw s implementation of low - rank interactions based on factorization machines  @xcite .",
    "* results .",
    "* figure  [ fig : dynamic_results - movielens ] shows how the average auc evolves as new ratings enter the system .",
    "we first observe that the quality of the results does not decrease over time , indicating that our update algorithm can work for long periods of time without propagating or amplifying errors . as in the static experiment",
    ", we confirm that adding a prior on unknown ratings improves the quality of the ranking and , again , this is maintained across time .",
    "moreover , the sgd approach of vw  is outranked in each dataset by our approach with prior .",
    "* research question .",
    "* we test the performance of delayed models produced by our methods in delivering recommendations to users .",
    "* process followed . * in order to address this question , we simulate a recommender system that is not able to incorporate new ratings in the model as soon as they enter the system .",
    "to do so , we modify the process of dynamic learning presented in section  [ sec : dynamic ] to impose a delay between the arrival of a new rating and the update of the factorization .",
    "more precisely , after the @xmath4 rating is given by a user , the model is updated up to the @xmath112 rating ( @xmath113 being the arbitrary delay ) .",
    "this way , the model is always @xmath113 ratings behind the last one arrived ( the ratings are sorted by real time of arrival ) . in real applications ,",
    "the delay would probably vary , depending on the level of activity of the users .",
    "however , this experiment gives a first impression of the impact of delays on the recommendation task .",
    "* results .",
    "* figure  [ fig : delay ] shows the impact of a delay on the average auc of the squared loss  and absolute loss  with prior for a dense dataset like and a sparse dataset like . we observe that even a small delay can affect the quality of the recommendation , depending on the characteristics of the data . for",
    ", if the model is behind by @xmath114 ratings , the average auc drops by @xmath115 , and it goes down by about @xmath116 when the model is behind by @xmath117 ratings , and this applies to both loss functions . on the other hand , for the much sparser",
    ", the effect is more apparent . with only @xmath114 ratings behind ,",
    "the model s auc already drops by @xmath118 .    to show the effect of fast updates on weakly - engaged ( or cold ) users",
    ", we also report the impact of delays on those users for both and with the squared loss  which performs best ( figure  [ fig : delay ] , cold users ) .",
    "we define such users as the ones that rated at most two items . as hypothesized , the cost induced by delayed predictions ( for five ratings delayed ) is higher for cold users . we observe a relative drop in auc of 11.8% and 13.4% for weakly - engaged users on and , respectively , while when considering all the users , the relative drop is 1.1% and 12.9% , respectively .    in such sparse scenarios ,",
    "cold users perform only a handful of actions before deciding to abandon the site or not . therefore , it is important to consider cold users in the model as soon as they arrive , to keep them engaged by fast , efficient and good recommendations .",
    ", imposed as a number of ratings that the model is behind the current rating . ]",
    "* research question .",
    "* we test to which extent the number of features ( @xmath11 ) , the weight of the prior ( @xmath37 ) and the regularization coefficient ( @xmath119 ) affect the auc and the runtime per update on our loss functions .",
    "figure [ fig : parameter - influence ] shows the results of this investigation for different values of these parameters , for both squared loss  and absolute loss  and on each dataset .",
    "the results are obtained using the dynamic learning process .",
    "* number of features . * concerning the quality of ranking ( auc ) , we observe the usual overfitting / under - fitting trade - off ( figure  [ fig : parameter - influence](a ) ) .",
    "the optimal number of features depends on the dataset as well as on the loss function used , suggesting that a careful tuning of that parameter is always needed .    in some cases",
    ", speed constraints will force the use a suboptimal number of features .",
    "indeed , the update runtime heavily depends on the number of features .",
    "figure  [ fig : parameter - influence](d ) suggests a linear relationship between runtime and number of features . for both losses there",
    "is indeed a linear role of the number of features in the theoretical complexity ( section [ sec : static - dynamic ] ) .",
    "notice , however , that the theoretical complexity of the squared loss  also has a quadratic term that becomes dominant for large number of features ( with regards to the number of ratings per users ) . also note that while the squared loss  produces better auc , the absolute loss  is able to sustain higher update rates , and can therefore be the loss of choice when speed is the first criterion .    * regularization coefficient . *",
    "the influence of @xmath119 seems rather limited , except for high values that cause both the auc and the update runtime to drop ( figure[fig : parameter - influence](b ) and ( e ) ) .",
    "a small regularization is supposed to increase the quality of the model by reducing overfitting , but this effect is not visible here .",
    "the reason may be that the role of regularization is already taken by the prior on unknown ratings .",
    "introducing the prior seems to have the side effect of making the regularization obsolete ( or redundant ) .",
    "in fact , we confirm this with the results for @xmath120 which demonstrate no impact on the quality or runtime .",
    "again , we see that setting a prior on unknown ratings increases the quality of recommendations without increasing the complexity of the solution . while it adds a term and a parameter to the objective function , it allows to remove one and its associated parameters",
    ".    * unknown / known influence ratio . *",
    "the ratio @xmath37 influences the performance of the squared loss  algorithm in the following way : the auc increases when a prior on unknown values is added ( @xmath121 ) , but the exact value of @xmath37 has little influence ( in the observed range ) ( figure  [ fig : parameter - influence](c ) ) .",
    "the absolute loss is more sensitive to the value of @xmath37 , with the auc decreasing when @xmath37 becomes too large ( on and ) .",
    "however , in both cases , and on all datasets , giving the same weight to the known and unknown ratings ( @xmath35 ) offers a significant improvement over not using a prior , suggesting that @xmath35 can be used as a first guideline , avoiding the burden of further parameter tuning .",
    "the update runtime is also affected by @xmath37 , decreasing when @xmath37 increases ( figure  [ fig : parameter - influence](f ) ) .",
    "the explanation can be that the prior on unknown ratings acts as a regularizer , driving features towards 0 , and in doing so speeding up the convergence .",
    "* runtime . * in general",
    ", our technique demonstrates low running time which is heavily dependent on the number of features used , and less on the regularization applied or the ratio of unknown over known values .",
    "these results demonstrate that our method can satisfy applications requiring low - latency updates .",
    "the implementation of the algorithms introduced in section  [ sec : loss - funtcions ] is available on github : + https://github.com/rdevooght/mf-with-prior-and-updates .",
    "for both als - uv and mult - nmf we use the implementation of graphchi , an open source tool for graph computation with impressive performance  @xcite .",
    "the code and documentation of vowpal wabbit is available on its github page : + https://github.com/johnlangford/vowpal_wabbit/wiki .",
    "the datasets are available on the snap webpage : + http://snap.stanford.edu/data/index.html    the dataset is available on the grouplens page : + http://www.grouplens.org / datasets / movielens/.",
    "the problem of recommending products based on the actions and feedback from other users ( rather than based on content similarity ) is often called _ collaborative filtering _ , and dates back 20 years ago , with works such as tapestry  @xcite and grouplens  @xcite .",
    "the field is now dominated by methods based on matrix factorization , with algorithms such as als  @xcite , the multiplicative update rule  @xcite , and the stochastic gradient descent method ( sgd )  @xcite .",
    "the missing at random assumption has yet to get the attention it deserves in collaborative filtering . both  @xcite and  @xcite",
    "have validated the hypothesis of ratings missing not at random .",
    "practical propositions for the interpretation of missing data can be found in the fields of one - class collaborative filtering and collaborative filtering based on implicit feedback , where the missing at random assumption is often obviously untenable  @xcite .",
    "@xcite offers an interesting approach where missing ratings are considered as optimization variables ; they use an em algorithm to optimize in turn the factorization and the estimation of missing values .",
    "unfortunately , that method has a high complexity , and the proposed approximations that work with large problems remove some of the method s appeal .    none of those works , however , consider the real world , dynamic scenario of continuously observing new ratings , users and items",
    ". other works @xcite focus on the dynamic update of matrix factorization ( mainly through the use of sgd ) , but those , on the other hand , implicitly rely on the missing at random assumption , and therefore suffer from lower accuracy in predictions . other state - of - art methods for matrix factorization scale by relying on stochastic gradient computation @xcite , while we rely on exact gradient approach . in this work , at the difference of what is mostly seen on",
    "scalable machine learning techniques nowadays @xcite , we base our approach on coordinate random block descent to compute exact gradient in order to deal with missing data of large scale matrices .",
    "in this work we proposed a new , simple , and efficient , way to incorporate a prior on unknown ratings in several loss functions commonly used for matrix factorization .",
    "we experimentally demonstrated the importance of adding such a prior to solve the problem of collaborative ranking .",
    "we also tackled the problem of updating the factorization when new users , items and ratings enter the system .",
    "we believe that this problem is central to real applications of recommendation systems , because new users constantly enter those systems and the factorization must be kept up to date to give them recommendations immediately after their first few interactions with the platform .",
    "we offer an update algorithm whose complexity is independent of the size of the data , making it a good approach for large datasets . in the future , we would like to explore how our methods perform under real workloads of updates with variable arrival rates of ratings per user and item . furthermore",
    ", we would like to test the performance of our methods in platforms built to analyze streams of data such as storm , twitter s distributed processing engines platform .",
    "r. devooght is supported by the belgian fonds pour la recherche dans lindustrie et lagriculture ( fria , 1.e041.14 ) .",
    "chin , y.  zhuang , y .- c .",
    "juan , and c .- j .",
    "lin . a learning - rate schedule for stochastic gradient methods to matrix factorization .",
    "in _ advances in knowledge discovery and data mining _ , pages 442455 .",
    "springer , 2015 .",
    "j.  dean , g.  corrado , r.  monga , k.  chen , m.  devin , m.  mao , a.  senior , p.  tucker , k.  yang , q.  v. le , et  al .",
    "large scale distributed deep networks . in _ advances in neural information processing systems _ , pages 12231231 , 2012 .",
    "s.  rendle , c.  freudenthaler , z.  gantner , and l.  schmidt - thieme .",
    "bpr : bayesian personalized ranking from implicit feedback . in _ proc . of the 25th conference on uncertainty in artificial intelligence _ ,",
    "pages 452461 .",
    "auai press , 2009 .",
    "p.  resnick , n.  iacovou , m.  suchak , p.  bergstrom , and j.  riedl .",
    "grouplens : an open architecture for collaborative filtering of netnews . in _ proc . of the 1994 acm conference on computer",
    "supported cooperative work _ , pages 175186 , 1994 .",
    "y.  zhou , d.  wilkinson , r.  schreiber , and r.  pan .",
    "large - scale parallel collaborative filtering for the netflix prize . in _ algorithmic aspects in information and management _ ,",
    "pages 337348 .",
    "springer , 2008 ."
  ],
  "abstract_text": [
    "<S> advanced and effective collaborative filtering methods based on explicit feedback assume that unknown ratings do not follow the same model as the observed ones ( _ not missing at random _ ) . in this work , </S>",
    "<S> we build on this assumption , and introduce a novel dynamic matrix factorization framework that allows to set an explicit prior on unknown values . </S>",
    "<S> when new ratings , users , or items enter the system , we can update the factorization in time independent of the size of data ( number of users , items and ratings ) . </S>",
    "<S> hence , we can quickly recommend items even to very recent users . </S>",
    "<S> we test our methods on three large datasets , including two very sparse ones , in static and dynamic conditions . in each case </S>",
    "<S> , we outrank state - of - the - art matrix factorization methods that do not use a prior on unknown ratings . </S>"
  ]
}