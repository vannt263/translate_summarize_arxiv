{
  "article_text": [
    "the demand for high - definition video streaming services such as youtube and netflix is driving the rapid growth of internet traffic . in order to mitigate the effect of this increased load on the underlying communication infrastructure , content delivery networks deploy storage memories or caches throughout the network .",
    "these caches can be populated with some of the content during off - peak traffic hours .",
    "this cached content can then be used to reduce the network load during peak traffic hours when users make the most requests .",
    "content caching has a rich history , see for example  @xcite and references therein .",
    "more recently , it has been studied in the context of video - on - demand systems for which efficient content placement schemes have been proposed in  @xcite among others .",
    "the impact of different content popularities on the performance of caching schemes has been investigated for example in  @xcite .",
    "a common feature among the caching schemes studied in the literature is that those parts of a requested file that are available at nearby caches are served locally , whereas the remaining files parts are served via orthogonal transmissions from an origin server hosting all the files .",
    "recently , @xcite proposed a new caching approach , called _ coded caching _ , that exploits cache memories not only to deliver part of the content locally , but also to create coded multicasting opportunities among users with different demands .",
    "it is shown there that the reduction in rate due to these coded multicasting opportunities is significant and can be on the order of the number of users in the network .",
    "the setting considered in @xcite consists of a single layer of caches between the origin server and the end users .",
    "the server communicates directly with all the caches via a shared link , and the objective is to minimize the required transmission rate by the server . for this basic network scenario ,",
    "coded caching is shown there to be optimal within a constant factor .",
    "these results have been extended to nonuniform demands in  @xcite and nonuniform cache - access in @xcite , and to online caching systems in  @xcite .    in practice",
    ", many caching systems consist of not only one but multiple layers of caches , usually arranged in a tree - like hierarchy with the origin server at the root node and the users connected to the leaf caches  @xcite . each parent cache communicates with its children caches in the next layer , and the objective is to minimize the transmission rates in the various layers .",
    "there are several key questions when analyzing such hierarchical caching systems .",
    "a first question is to characterize the optimal tradeoff between the cache memory sizes and the rates of the links connecting the layers .",
    "one particular point of interest is if there is any tension between the rates in the different layers in the network .",
    "in other words , if we reduce the rate in one layer , does it necessarily increase the rate in other layers ?",
    "if there is no such tension , then both layers can simultaneously operate at minimum rate .",
    "a second question is how to extend the coded caching approach to this setting .",
    "can we can simply apply the single - layer scheme from @xcite in each layer separately or do we need to apply coding across several layers in order to minimize transmission rates ?",
    "files is connected to @xmath0 mirrors each able to store @xmath1 of the files .",
    "each of the mirrors , in turn , is connected to @xmath2 caches each able to store @xmath3 of the files .",
    "a single user is attached to each of these caches .",
    "once the mirrors and caches are filled , each user requests one of the @xmath4 files .",
    "the aim is to minimize the rate @xmath5 from the server to the mirrors and the rate @xmath6 from the mirrors to the caches . in the figure , @xmath7 , @xmath8 , @xmath9 , and @xmath10 . ]    in this work , we focus on a hierarchical caching system with two layers of caches as depicted in fig .",
    "[ fig : setup ] . for simplicity",
    ", we will refer to the first layer of caches as mirrors .",
    "we propose a new caching scheme exploiting two types of coded caching opportunities : the first type involves only a single layer at a time , i.e. , it operates between a node and its direct children .",
    "these single - layer coding opportunities are available over the link connecting the origin server to the mirrors and also in the link connecting each mirror to the user caches .",
    "the second type involves two layers at a time .",
    "these two - layer opportunities are available between the origin server and the user caches .",
    "we show that , by striking the right balance between these two types of coded caching opportunities , the proposed caching scheme attains the approximately optimal memory - rate tradeoff to within a constant additive and multiplicative gap .",
    "due to the possible interaction between the two cache layers , the network admits many different prefetching and delivery approaches .",
    "it is thus perhaps surprising that a combination of these two basic schemes is sufficient to achieve the approximately optimal memory - rate tradeoff .",
    "furthermore , investigating the achievable rates also reveals that there is no tension between the rates over the first and second layers up to the same aforementioned gap .",
    "thus , both layers can simultaneously operate at approximately minimum rate .",
    "the remainder of the paper is organized as follows .",
    "we describe the problem setting in section  [ sec : problemsetup ] and provide some preliminaries in section  [ sec : singlelayer ] .",
    "section  [ sec : results ] presents our main results and discusses their engineering implications .",
    "section  [ sec : achievableschemes ] introduces the proposed caching scheme and characterizes its performance .",
    "the proofs of our main results are discussed in section  [ sec : proofs ] and their details are provided in the appendices .",
    "appendix  [ sec : lowerbounds ] proves information - theoretic bounds on the performance of any caching scheme .",
    "the proof of the constant multiplicative and additive gap between the performance of the proposed scheme and the optimal caching scheme is provided in appendices  [ sec : gapr1 ] and [ sec : gapr2 ] .",
    "we consider a hierarchical content delivery network as illustrated in fig .",
    "[ fig : setup ] in section  [ sec : intro ] .",
    "the system consists of a single origin server hosting a collection of @xmath4 files each of size @xmath11 bits .",
    "the server is connected through an error - free broadcast link to @xmath0 mirror sites , each with memory of size @xmath12 bits .",
    "each mirror , in turn , is connected through an error - free broadcast link to @xmath2 users .",
    "thus , the system has a total of @xmath13 users .",
    "each user has an associated cache memory of size @xmath14 bits .",
    "the quantities @xmath1 and @xmath3 are the normalized memory sizes of the mirrors and user caches , respectively .",
    "we refer to the @xmath15th user attached to mirror @xmath16 as `` user @xmath17 '' and the corresponding cache as `` cache ( @xmath18 ) '' . throughout",
    ", we will focus on the most relevant case where the number of files @xmath4 is larger than the total number of users @xmath13 in the system different popular movies of length @xmath19 minutes each , this would correspond to more than @xmath20 different files .",
    "] , i.e. , @xmath21 .",
    "the content delivery system operates in two phases : a _ placement phase _ followed by a _ delivery phase_. the placement phase occurs during a period of low network traffic . in this phase , all the mirrors and user caches store content related to the @xmath4 files ( possibly using randomized strategies ) , while satisfying the corresponding memory constraints .",
    "crucially , this is done without any prior knowledge of future user requests .",
    "the delivery phase occurs during a period of high network traffic . in this phase",
    ", each user requests one of the @xmath4 files from the server .",
    "formally , the user requests can be represented as a matrix @xmath22 with entry @xmath23 denoting the request of user @xmath17 .",
    "the user requests are forwarded to the corresponding mirrors and further on to the server .",
    "based on the requests and the stored contents of the mirrors and the user caches during the placement phase , the server transmits a message @xmath24 of size at most @xmath25 bits over the broadcast link to the mirrors .",
    "each mirror @xmath16 receives the server message and , using its own memory content , transmits a message @xmath26 of size at most @xmath27 bits over its broadcast link to users @xmath28 . using only the contents of its cache @xmath17 and the received message @xmath26 from mirror @xmath16 , each user @xmath29 attempts to reconstruct its requested file @xmath30 .    for a given request matrix @xmath22",
    ", we say that the tuple @xmath31 is _",
    "feasible for request matrix @xmath22 _ if , for large enough file size @xmath11 , each user @xmath17 is able to recover its requested file @xmath32 with probability arbitrarily close to one .",
    "we say that the tuple @xmath33 is _ feasible _ if it is feasible for all possible request matrices @xmath22 .",
    "the object of interest in the remainder of this paper is the feasible rate region :    [ defn : feasibleregion ] for memory sizes @xmath34 , the _ feasible rate region _ is defined as @xmath35",
    "the proposed achievable scheme for the hierarchical caching setting makes use of the coded caching scheme developed for networks with a single layer of caches . in this section",
    ", we recall this single - layer caching scheme .",
    "consider the special case of the hierarchical caching setting with no cache memory at the users and only a single user accessing each mirror , i.e. , @xmath36 and @xmath37 .",
    "let the normalized mirror memory size be @xmath38 and the number of mirrors @xmath39 .",
    "this results in a system with only a single layer of caches ( namely the mirrors ) .",
    "note that for this single - layer scenario , each mirror is forced to recover the file requested by its corresponding user and then forward the entire file to it .",
    "thus , a transmission rate of @xmath40 over the link from the mirror to the user is both necessary and sufficient in this case .",
    "the goal is to minimize the transmission rate @xmath5 from the server to the mirrors .",
    "this single - layer setting was recently studied in @xcite , where the authors proposed a coded caching scheme . for future reference",
    ", we recall this scheme in algorithm  [ alg:1 ] and illustrate it below in example  [ ex : basic ] .",
    "the authors showed that rate @xmath41 is feasible in this setting , where @xmath42 is given by @xmath43^+\\ ] ] with @xmath44^+ \\defeq \\max\\{x , 0\\}.\\ ] ] the right hand side of   consists of three terms .",
    "the first term is the rate without caching .",
    "the second term , called _ local caching gain _ , represents the savings due to a fraction of each file being locally available .",
    "the third term , called _ global caching gain _ , is the gain due to coding .",
    "it is shown in  @xcite that this achievable rate @xmath5 is within a constant factor of the minimum achievable rate for this single - layer setting for any value of @xmath4 , @xmath45 , and @xmath46",
    ". we will refer to the placement and delivery procedures of the single - layer coded caching scheme in algorithm  [ alg:1 ] as baseplacement(@xmath47 ) and basedelivery(@xmath47 ) , respectively .",
    "@xmath48 \\defeq \\{1,2,\\ldots , k\\ } , [ n ] \\defeq \\{1,2,\\ldots , n\\}$ ] request vector @xmath49 in line  [ alg:1_send ] , @xmath50 denotes bit - wise xor operation . for any subset",
    "@xmath51 $ ] of mirrors , @xmath52 denotes the bits of file @xmath53 requested by user @xmath15 stored exclusively at mirrors in @xmath54 .",
    "mirror @xmath16 independently stores a subset of @xmath55 bits of file @xmath56 , chosen uniformly at random [ alg:1_cache ] [ alg:1_sloop ] [ alg:1_sloop ] server sends @xmath57 [ alg:1_send ]    [ ex : basic ] consider the single - layer setting as described above with @xmath58 files and @xmath59 mirrors each of size @xmath60 $ ] . for ease of notation ,",
    "denote the files by @xmath61 and @xmath62 . in the placement phase of algorithm  [ alg:1",
    "] , each mirror stores a subset of @xmath63 bits of each of the two files , chosen uniformly and independently at random . each bit of a file",
    "is thus stored in a given mirror with probability @xmath64 .",
    "consider file @xmath61 and notice that we can view it as being composed of @xmath65 subfiles @xmath66 where @xmath67 denotes the bits of file @xmath61 which are exclusively stored in the mirrors in @xmath54 .",
    "for example , @xmath68 denotes the bits of file @xmath61 which are stored only in mirror one , and @xmath69 denotes the bits of file @xmath61 which are available in both mirrors one and two . for large enough file size @xmath11 , we have by the law of large numbers that @xmath70 for any subset @xmath54 .",
    "file @xmath62 can similarly be partitioned into subfiles .    in the delivery phase ,",
    "suppose for example that the first user requests file @xmath61 and the second user requests file @xmath62 . by line  [ alg:1_send ] in algorithm  [ alg:1 ] , the server transmits @xmath71 , @xmath72 , and @xmath73 where @xmath50 denotes bit - wise xor .",
    "consider mirror one whose corresponding user has requested file @xmath61 .",
    "mirror one already knows the subfiles @xmath74 from its cache memory .",
    "further , the server s transmission provides the subfile @xmath72 .",
    "finally , from @xmath75 transmitted by the server , the mirror can recover @xmath76 since it has @xmath77 stored in its cache memory .",
    "thus , from the contents of its memory and the server transmission , mirror one can recover @xmath78 and then forward it to its attached user .",
    "similarly , mirror two can recover file @xmath62 and forward it to its attached user .",
    "the number of bits transmitted by the server is given by @xmath79 which agrees with the expression in .",
    "while the above discussion focuses on @xmath37 user accessing each mirror , the achievable scheme can easily be extended to @xmath80 by performing the delivery phase in @xmath2 stages with one unique user per mirror active in each stage . from  (",
    "* section v ) , the resulting rate over the first link is @xmath81",
    "as the main result of this paper , we provide an approximation of the feasible rate region @xmath82 for the general hierarchical caching problem with two layers .",
    "we start by introducing some notation . for @xmath83 $ ] ,",
    "define the rates    [ eqn : totalrates ] @xmath84    where @xmath42 is defined in   in section  [ sec : singlelayer ] .",
    "next , consider the following region :    [ defn : achievableratesg ] for memory sizes @xmath34 , define @xmath85 \\bigr\\ }   \\ ; + \\ ;          \\mathbb{r}^2_+,\\ ] ] where @xmath86 denotes the positive quadrant , @xmath87 are defined in , and the addition corresponds to the minkowski sum between sets .    as will be discussed in more detail later",
    ", the set @xmath88 is the rate region achieved by appropriately sharing the available memory between two basic achievable schemes during the placement phase and then using each scheme to recover a certain fraction of the requested files during the delivery phase .",
    "each of these two schemes is responsible for one of the two terms in @xmath89 and @xmath90 .",
    "the parameters @xmath91 and @xmath92 dictate what fraction of each file and what fraction of the memory is allocated to each of these two schemes .",
    "the set @xmath88 is thus the rate region achieved by all possible choices of the parameters @xmath91 and @xmath92 .",
    "our main result shows that , for any memory sizes @xmath93 , the region @xmath88 just defined approximates the feasible rate region @xmath82 .    [",
    "theorem : bounds ] consider the hierarchical caching problem in fig .",
    "[ fig : setup ] with @xmath4 files , @xmath0 mirrors , and @xmath2 users accessing each mirror .",
    "each mirror and user cache has a normalized memory size of @xmath1 and @xmath3 , respectively .",
    "then we have @xmath94 where @xmath82 and @xmath88 are defined in   and , respectively , and where @xmath95 and @xmath96 are finite positive constants independent of all the problem parameters .",
    "theorem  [ theorem : bounds ] shows that the region @xmath97 is indeed feasible ( since @xmath98 ) .",
    "moreover , the theorem shows that , up to a constant additive and multiplicative gap , the scheme achieving @xmath88 is optimal ( since @xmath99 ) . from our analysis",
    ", we have the constants @xmath100 and @xmath101 . however , numerical results suggest that the constants are in fact much smaller .",
    "the proof of theorem  [ theorem : bounds ] is presented in section  [ sec : proofs ] .",
    "the proof actually shows a slightly stronger result than stated in the theorem . recall that the parameters @xmath91 and @xmath92 control the weights of the split between the two basic coded caching schemes mentioned above . in general",
    ", one would expect a tension between the rates @xmath102 and @xmath103 over the first and second hops of the network .",
    "in other words , the choice of @xmath91 and @xmath92 minimizing the rate @xmath102 over the first hop will in general _ not _ minimize the rate @xmath103 over the second hop .     and",
    "@xmath3 , the figure qualitatively depicts the feasible rate region @xmath104 and its bounds .",
    "as shown in the figure , the feasible rate region @xmath104 can be bounded by two rectangular regions with corner points @xmath105 and @xmath106 .",
    "thus , up to the constant additive and multiplicative gap , there is no tension between the rates @xmath5 over the first hop and the rate @xmath6 over the second hop of the optimal scheme for the hierarchical caching problem . ]",
    "however , the proof of theorem  [ theorem : bounds ] shows that there exists @xmath107 and @xmath108 ( depending on @xmath4 , @xmath1 , @xmath3 , @xmath0 , and @xmath2 ) such that @xmath109 and @xmath110 are _ simultaneously _ approximately minimized .",
    "thus , surprisingly , there is in fact _ no tension _ between the rates over the first hop and the second hop for the optimal hierarchical caching scheme up to a constant additive and multiplicative gap ( see fig .",
    "[ fig : bounds ] ) .",
    "the next example shows that this is by no means obvious , and , indeed , we conjecture that it is only true approximately .",
    "[ eg : tension ] consider a setting with a single mirror @xmath111 and memory sizes @xmath112 .",
    "assume we use the proposed caching scheme with parameters @xmath113 and @xmath114 .",
    "as we will see later , this corresponds to placing one half of each file at the mirror and the other half at each of the caches . by",
    ", we see that the rate tuple @xmath115 is achievable .",
    "clearly , this minimizes the rate @xmath5 over the first hop .",
    "however , it is far from optimal for the second hop",
    ".    now , assume we use the proposed caching scheme with parameters @xmath116 . by",
    ", this achieves the rate tuple @xmath117 .",
    "observe that for an increase in rate of @xmath118 over the first link , we were able to decrease the rate of the second link from @xmath119 to just one .",
    "we conjecture that the rate tuple @xmath120 itself is not achievable . over the first link , the mirror and each user together must store the entire content , which suggests that the cached contents of the mirror and each user do not overlap .",
    "however , to achieve rate @xmath121 over the second link , the mirror needs to be able to exploit coded multicasting opportunities between the users , which suggests that the cached contents of the mirror and the users should overlap .",
    "this tension suggests that the rate tuple @xmath122 is not achievable . ]",
    "if true , this implies that there is tension between the two rates but that this tension accounts for at most a constant additive and multiplicative gap .",
    "before we provide the specific values of @xmath107 and @xmath108 , we describe the two schemes controlled by these parameters in a bit more detail .",
    "both schemes make use of the coded caching scheme for networks with a single layer of caches from @xcite as recalled in section  [ sec : singlelayer ] .",
    "the first scheme uses a very natural decode - and - forward type approach .",
    "it uses the single - layer scheme between the server and the @xmath0 mirrors .",
    "each mirror decodes all messages for its children and re - encodes them using the single - layer scheme between the mirror and its @xmath2 attached users .",
    "thus , this first scheme creates and exploits coded multicasting opportunities between the server and the mirrors and between each mirror and its users .",
    "the second scheme simply ignores the content of the mirrors and applies the single - layer scheme directly between the server and the @xmath123 users .",
    "thus , this second scheme creates and exploits coded multicasting opportunities between the server and all the users . with a choice of @xmath124 ,",
    "all weight is placed on the first scheme and the second scheme is not used . with a choice of @xmath125 ,",
    "all weight is placed on the second scheme and the first scheme is not used .     and @xmath108 .",
    "]    with this in mind , let us return to the choice of @xmath107 and @xmath108 .",
    "we consider the following three different regimes of @xmath1 and @xmath3 , as depicted in fig .",
    "[ fig : alphabeta0 ] : @xmath126    we set @xmath127          \\left ( \\displaystyle \\frac{m_1}{m_1 + m_2k_2 } , 0 \\right )          & \\text{in regime ii } , \\\\[1em ]          \\left(\\displaystyle \\frac{m_1}{n } , \\frac{1}{4 } \\right )          & \\text{in regime iii}.      \\end{cases}\\ ] ] substituting this choice into , the corresponding achievable rates are    [ eqn : upperbounds0 ] @xmath128               \\displaystyle \\min \\left\\ { k_1k_2 , \\frac{m_1}{m_1 + m_2k_2 } \\cdot \\frac{(n - m_1)k_2}{m_1 + m_2k_2 } + \\frac{m_2k_2}{m_1 + m_2k_2 } \\cdot \\frac{nk_2 - m_1}{m_1 + m_2k_2 } \\right\\ } & \\text{in regime ii},\\\\[.85em ]              \\displaystyle \\frac{(n - m_1)^2}{nm_2 }               & \\text{in regime iii } ,          \\end{cases } \\\\          \\shortintertext{and } \\nonumber\\\\          \\label{eqn : upperboundsr20 }          r_2(\\alpha^\\star , \\beta^\\star )           & \\approx \\min \\left\\ { k_2 , \\frac{n}{m_2 } \\right\\ } ,      \\end{aligned}\\ ] ]    where the approximation is up to a constant additive and multiplicative gap as before .    from  , we see that in every regime we need to share between the two basic schemes . in particular , using the natural decode - and - forward type approach ( i.e. , scheme one ) alone can be highly suboptimal as the next two examples show .",
    "[ eg : df1 ] let @xmath129 and @xmath130 so that the mirrors have zero memory and the user caches are able to store the entire database of files .",
    "this setting falls into regime i. we focus on the rate over the first link from the server to the mirrors .",
    "we know that in this example the optimal rate @xmath5 is @xmath131 . by  , the rate @xmath109 is approximately equal to @xmath121 ( a constant ) .",
    "however , the rate achieved by using only the first ( decode - and - forward ) scheme is equal to @xmath132 , which could be much larger .",
    "[ eg : df2 ] let @xmath133 , @xmath134 , @xmath111 , and @xmath135 .",
    "this setting falls into regime iii . by  , the rate @xmath109 is approximately equal to @xmath136 . on the other hand , the rate achieved by using only the first ( decode - and - forward ) scheme is approximately equal to @xmath137 , which could again be much larger .",
    "in this section , we introduce a class of caching schemes for the hierarchical caching problem .",
    "we begin in sections  [ sec : schemea ] and  [ sec : schemeb ] by using the baseplacement and basedelivery procedures defined in section  [ sec : singlelayer ] for networks with a single layer of caches to construct two basic caching schemes for networks with with two layers of caches .",
    "we will see in section  [ sec : schemeg ] how to combine these two schemes to yield a near - optimal scheme for the hierarchical caching problem .",
    "mirrors and @xmath138 users per mirror .",
    "scheme a uses a decode - and - forward type approach to apply the single - layer coded caching scheme recalled in section  [ sec : singlelayer ] to a network with two layers .",
    "we independently cache content in each of the layers during the placement phase . in the delivery phase ,",
    "the mirrors decode all the files requested by their users and re - encode them for their children .",
    "for example , in the figure mirror one decodes files @xmath61 , @xmath62 and re - encodes them for the two attached users . ]",
    "informally , this scheme places content in the mirrors so that using the server transmission and their own content , each mirror can recover all the files requested by their attached users . in turn",
    ", each mirror then acts as a server for these files .",
    "content is stored in the attached user caches so that from the mirror transmission and its own cache content , each user can recover its requested file .",
    "see fig .",
    "[ fig : systema ] for an illustration of the scheme .    more formally , in the placement phase",
    ", we use the baseplacement@xmath139 procedure recalled in section  [ sec : singlelayer ] to store portions of the files @xmath140 across the @xmath0 mirrors .",
    "also , for each mirror @xmath16 , we use the baseplacement@xmath141 procedure to independently store portions of the files @xmath142 across caches @xmath143 , @xmath144 ,  , @xmath145 corresponding to the users with access to mirror @xmath16 .",
    "in other words , each mirror independently stores a random @xmath146-bit subset of every file , and each user cache independently stores a random @xmath147-bit subset of every file .    during the delivery phase , the server uses the basedelivery@xmath139 procedure to the mirrors in order to enable them to recover the @xmath2 files @xmath148 .",
    "in other words , each mirror decodes all files requested by its attached users .",
    "next , each mirror @xmath16 uses the basedelivery@xmath149 procedure to re - encode these files for its @xmath0 users .",
    "this enables each user @xmath17 to recover its requested file @xmath30 .",
    "thus , scheme a exploits coded multicasting opportunities between the server and the mirrors and between the mirrors and their users .",
    "the rates for caching scheme a are as follows . by  ,",
    "the rate over the link from the server to the mirror is    [ eqn : achievabilitya ] @xmath150    [ ex : achievablea ] consider the setup in fig .",
    "[ fig : systema ] with @xmath151 files , @xmath152 mirrors , and @xmath138 users per mirror .",
    "the mirror and user cache memory sizes are @xmath153 and @xmath154 , respectively .",
    "for ease of notation , denote the files by @xmath61 , @xmath62 , @xmath155 and @xmath156 .",
    "using scheme a , each mirror independently stores a random @xmath157-bit subset of every file , and each user cache independently stores a random @xmath158-bit subset of every file .    in the delivery phase , assume the four users request files @xmath61 , @xmath62 , @xmath155 , and @xmath156 , respectively .",
    "the server uses the basedelivery procedure to enable the first mirror to recover files @xmath61 and @xmath62 and to enable the second mirror to recover files @xmath155 and @xmath156 .",
    "this uses a rate of @xmath159 mirror one then uses the basedelivery procedure to re - encode the files @xmath61 and @xmath62 for its to attached users .",
    "similarly , mirror two uses the basedelivery procedure to re - encode the files @xmath155 and @xmath156 for its attached users .",
    "this uses a rate of @xmath160       mirrors and @xmath138 users per mirror .",
    "scheme b ignores the memory at the mirrors and uses the single - layer coded caching scheme recalled in section  [ sec : singlelayer ] directly between the server and the users .",
    "the mirrors are only used to forward the relevant messages transmitted by the server to their users . ]    informally , this scheme places content across the @xmath13 user caches so that using the server transmissions and its own cache content , each user can recover its requested file .",
    "the storage capabilities of the mirrors in the network are completely ignored and the mirrors are only used to forward relevant parts of the server transmissions to the corresponding users . see fig .",
    "[ fig : systemb ] for an illustration .",
    "more formally , in the placement phase , we use the baseplacement@xmath161 procedure to store portions of the files @xmath162 across the @xmath13 user caches and leave all the mirrors empty . in other words ,",
    "each user cache independently stores a random @xmath147-bit subset of every file .    during the delivery phase",
    ", the server uses the basedelivery@xmath163 procedure directly for the @xmath13 users .",
    "recall from the description in section  [ sec : singlelayer ] that the basedelivery procedure transmits several sums of file parts .",
    "the transmission of mirror @xmath16 consists of all those sums transmitted by the server that involve at least one of the @xmath2 files @xmath164 , requested by its attached users @xmath143 , @xmath165 ,  , @xmath145 .",
    "from the information forwarded by the mirrors , each user is able to recover its requested file .",
    "thus , scheme b exploits coded multicasting opportunities directly between the server and the users across two layers .",
    "the rates for caching scheme b are as follows . by  , the rate over the link from the server to the mirrors is    [ eqn : achievabilityb ] @xmath166{dcachingum } to result in a rate }          \\label{eqn : achievabilityb2 }          r_2^b & \\defeq { r}\\!\\left(\\frac{m_2}{n } , k_2 \\right ) .",
    "\\end{aligned}\\ ] ]    between each mirror and its attached users .",
    "[ ex : achievableb ] consider the setup in fig .",
    "[ fig : systemb ] with @xmath151 files @xmath167 mirrors , and @xmath138 users per mirror .",
    "the user cache memory size is @xmath154 ( the mirror memory size @xmath1 is irrelevant here ) .",
    "for ease of notation , denote the files by @xmath61 , @xmath62 , @xmath155 and @xmath156 .",
    "furthermore , it will be convenient in the remainder of this example to label the users and caches as @xmath168 as opposed to @xmath169 .",
    "using scheme b , each user cache independently stores a random @xmath158-bit subset of every file .    in the delivery phase , assume the four users request files @xmath61 , @xmath62 , @xmath155 , and @xmath156 , respectively .",
    "the server uses the basedelivery procedure to enable the users to recover their requested files as follows .",
    "consider file @xmath61 , and denote by @xmath67 the bits of file @xmath61 stored exclusively at the user caches in @xmath170 , and similarly for the other files @xmath171 .",
    "the transmission from the server to the mirrors is then @xmath172 for large enough file size @xmath11 , this uses a normalized rate of @xmath173    let us focus on mirror one . since its attached users request files @xmath61 and @xmath62 , it forwards every sum including parts of either of those files .",
    "thus , mirror one transmits @xmath174 this uses a normalized rate of @xmath175       mirrors and @xmath138 users per mirror . for given @xmath91 and @xmath92 ,",
    "the system is split into two disjoint subsystems .",
    "we use caching scheme a for delivering the first parts of the files over the first subsystem and use caching scheme b for delivering the second parts of the files over the second subsystem . ]",
    "the generalized caching scheme divides the system into two subsystems , the first one operated according to caching scheme a and the second one according to caching scheme b. fix parameters @xmath176 $ ] .",
    "the first subsystem includes the entire memory of each mirror and a @xmath92 fraction of each user cache memory .",
    "the second subsystem includes the remaining @xmath177 fraction of each user cache memory .",
    "we split each file into two parts of size @xmath178 and @xmath179 bits , respectively .",
    "we use scheme a from section  [ sec : schemea ] to store and deliver the first parts of the files over the first subsystem .",
    "similarly , we use scheme b from section  [ sec : schemeb ] for the second parts of the files over the second subsystem .",
    "see fig .",
    "[ fig : achievability ] for an illustration .",
    "since our system is a composition of two disjoint subsystems , the net rate over each transmission link is the sum of the corresponding rates in the two subsystems .",
    "from  , the rates @xmath180 required by scheme a over the first subsystem are    [ eqn : subsystem1 ] @xmath181    similarly , from , the rates @xmath182 required by scheme b over the second subsystem are    [ eqn : subsystem2 ] @xmath183    the formal derivation for these rate expressions is provided in appendix  [ sec : appendixb ] .    combining   and  ,",
    "the net rates @xmath184 and @xmath185 of the generalized caching scheme are    [ eqn : netrates ] @xmath186    note that this coincides with .      the generalized caching scheme described in the last section is parametrized by @xmath91 and @xmath92 .",
    "we now choose particular values @xmath107 and @xmath108 for these parameters .",
    "recall from in section  [ sec : results ] the three regimes for the memory sizes @xmath1 and @xmath3 :    a.   @xmath187 and @xmath188 , b.   @xmath189 , c.   @xmath187 and @xmath190 .",
    "we set @xmath191          \\left ( \\displaystyle \\frac{m_1}{m_1 + m_2k_2 } , 0 \\right )          & \\text{in regime ii } , \\\\[1em ]          \\left(\\displaystyle \\frac{m_1}{n } , \\frac{1}{4 } \\right )          & \\text{in regime iii}.      \\end{cases}\\ ] ] see also  .",
    "our proof of theorem  [ theorem : bounds ] will demonstrate that for any given @xmath93 and this choice of parameters @xmath192 , the rates @xmath193 for the generalized caching scheme are within a constant multiplicative and additive gap of the minimum feasible rates . before proceeding with the proof of this fact , we provide intuition for the choice of these parameters as well as their impact on the achievable scheme in each of these regimes .",
    "a.   we want to optimize the values of @xmath194 with respect to both @xmath195 .",
    "let us start with the rate @xmath90 . from   and  , both caching schemes a and b achieve rate @xmath196 on the link from a mirror to its attached users . as we will see later",
    ", this rate is in fact approximately optimal for this link .",
    "the generalized caching scheme combines caching schemes a and b , and it can be easily verified from that @xmath197 results in @xmath198 .",
    "thus , @xmath199 is near optimal with respect to @xmath90 . to find the optimal common value , we analyze how the rate @xmath200 varies with @xmath91 and find that among all values in @xmath201 $ ] , the choice @xmath202 results in the near - optimal rate for this regime .",
    "thus , we choose @xmath203 for this regime .",
    "+ we now discuss the impact of this choice on the structure of the generalized caching scheme in this regime . recall that caching scheme a",
    "is used to store and deliver the first parts of the files , each of size @xmath204 bits .",
    "since @xmath205 and the mirror memory size is @xmath206 bits , this implies that the _ entire _ first parts of all the @xmath4 files can be stored in each mirror .",
    "thus , in this regime , the server does not communicate with the mirrors regarding the first file parts and each mirror , in turn , acts as a sever for these files parts to its attached users .",
    "thus , the generalized caching scheme only exploits coded multicasting opportunities between each mirror and its attached users via caching scheme a and between the server and all the users via caching scheme b. b.   observe that the user cache memory @xmath3 is small in this regime , in particular @xmath207 .",
    "it can be verified that the rate @xmath6 in this case has to be at least on the order of @xmath2 . on the other hand ,",
    "it is easy to see from that @xmath208 for any choice of parameters @xmath194 .",
    "thus , we only need to optimize @xmath194 with respect to the rate @xmath209 over the second link .",
    "the optimizing values can be found as @xmath210 .",
    "+ recall from section  [ sec : schemeg ] that caching scheme a is assigned a @xmath108 fraction of each user cache memory . since @xmath211 for this regime , no user cache memory is assigned for scheme a. thus , in this regime , the generalized caching scheme only exploits coded multicasting opportunities between the server and its attached mirrors via caching scheme a and between the server and all the users via caching scheme b. c.   we would like to again choose @xmath212 in this regime as in regime i. however , since the rate @xmath209 over the first link increases with @xmath92 , and since @xmath213 is large ( on the order of @xmath121 ) in this regime , this choice would lead to an unacceptably large value of @xmath5 .",
    "thresholding @xmath92 at @xmath214 ( or any other constant for that matter ) in this regime enables us to simultaneously achieve the dual purpose of limiting its impact on the rate @xmath5 , while still managing to reduce the rate @xmath6 sufficiently .",
    "thus , for this regime we choose @xmath215 .",
    "+ as was the case in regime i , since @xmath216 , each mirror is able to store the entire first parts of the @xmath4 files and thus , the server does not communicate with the mirrors under caching scheme a. thus , in this regime , the generalized caching scheme only exploits coded multicasting opportunities between each mirror and its attached users via caching scheme a and between the server and all the users via caching scheme b.      we next calculate the achievable rates @xmath109 and @xmath110 of the generalized caching scheme described in section  [ sec : schemeg ] with the choice of parameters @xmath107 and @xmath108 as given in section  [ sec : parameters ] .",
    "the achievable rates @xmath218 for the generalized caching scheme are given in terms of the function @xmath42 , defined in .",
    "it is easy to see that @xmath219    as defined in , our choice of parameters @xmath220 takes different values for the three different regimes of @xmath93 .",
    "we evaluate the achievable rates for each of these regimes .",
    "\\i ) @xmath187 and @xmath188 .",
    "recall from   that @xmath221 in regime i. from and , the achievable rates @xmath222 and @xmath223 are upper bounded as    [ eqn : ra ] @xmath224 and @xmath225    \\ii ) @xmath189 . recall from that @xmath226 in regime ii . from and",
    ", the achievable rate @xmath222 is upper bounded as    [ eqn : rc ] @xmath227 for the first inequality we have used that @xmath228 implies @xmath229 and @xmath230 in the bound . on the other hand , from and the achievable rate @xmath223 is trivially upper bounded as @xmath231    where the last equality follows since @xmath232 in regime  ii .",
    "\\iii ) @xmath187 and @xmath190 .",
    "recall from   that @xmath233 in regime iii . from and ,",
    "the achievable rates @xmath222 and @xmath223 are upper bounded as    [ eqn : rb ] @xmath234 and @xmath235    combining , , and , we obtain the following upper bound on the achievable rate @xmath222 :    [ eqn : upperbounds ] @xmath236              \\displaystyle \\min \\left\\ { k_1k_2 , \\frac{m_1}{m_1 + m_2k_2 } \\cdot \\frac{(n - m_1)k_2}{m_1 + m_2k_2 } + \\frac{m_2k_2}{m_1 + m_2k_2 } \\cdot \\frac{nk_2 - m_1}{m_1 + m_2k_2 } \\right\\ } & \\text{in regime ii},\\\\[.85em ]              \\displaystyle \\frac{4(n - m_1)^2}{3nm_2 } & \\text{in regime iii}.           \\end{cases }          \\label{eqn : upperboundsr1}\\ ] ] similarly , combining , , and , we obtain the following upper bound on the achievable rate @xmath223 : @xmath237    these upper bounds will be used in the next sections to prove that the achievable rates for our generalized caching scheme are within a constant multiplicative and additive gap of the corresponding lower bounds .",
    "recall the definitions of the feasible rate region @xmath239 in   and of the region @xmath97 in  , respectively .",
    "the result then follows immediately from in section  [ sec : schemeg ] , which shows that any rate pair in @xmath88 is achievable using the generalized caching scheme .",
    "the proof consists of two steps .",
    "we first prove lower bounds @xmath241 on the feasible rates , i.e. , for any @xmath93 , and @xmath242 , we have @xmath243 we compute these lower bounds @xmath244 in appendix  [ sec : lowerbounds ] .",
    "next , we show that for any @xmath93 , the gap between the achievable rates @xmath217 and the lower bounds @xmath245 is bounded , i.e. , @xmath246 where @xmath247 are finite positive constants independent of all the problem parameters .",
    "the proof of the above inequalities , bounding the gap between the achievable rates and the lower bounds , involves separate analysis for several different regimes of @xmath93 , and is deferred to appendices  [ sec : gapr1 ] and  [ sec : gapr2 ] .",
    "combining , , for any @xmath93 , and @xmath248 , we have @xmath249 since @xmath88 is precisely the set of tuples of the form @xmath250 for some @xmath251 $ ] , this shows that @xmath240 , completing the proof .    as mentioned in section  [ sec : results ] , the proof above shows a stronger result than claimed in the theorem statement .",
    "in particular , it shows that for any @xmath1 and @xmath3 there exists parameters @xmath107 and @xmath108 such that both @xmath252 and @xmath110 are _ simultaneously _ approximately close to their minimum value . in other words ,",
    "up to a constant additive and multiplicative gap , there is no tension between the rates over the first and second hops of the network for the optimal caching scheme .",
    "this appendix derives the rate expressions and in section  [ sec : schemeg ] for the two subsystems using the generalized caching scheme .",
    "recall that the first subsystem is concerned with caching and delivering the first @xmath91 fraction of each file .",
    "it includes the entire memory of each mirror and the first @xmath92 fraction of each user cache .",
    "let @xmath253 denote the equivalent file size , as well as mirror memory and user cache memory , normalized by the equivalent file size , for this subsystem . from ,",
    "the rates @xmath180 ( normalized by the file size @xmath11 ) required by caching scheme a on this subsystem are given by @xmath254    the second subsystem is concerned with caching and delivering the second @xmath255 fraction of each file .",
    "it only uses the memory in the second @xmath256 fraction of each user cache .",
    "let @xmath257 denote the equivalent file size and user cache memory , normalized by the equivalent file size , for this subsystem . from , the rates @xmath182 ( again normalized by the file size @xmath11 ) required by caching scheme b on this subsystem are given by @xmath258",
    "given any @xmath93 , we want to establish lower bounds on the rates @xmath259 for the tuple @xmath260 to be achievable .",
    "our lower bounds are similar to the one proposed in @xcite for single - layer caching networks .",
    "assume the tuple @xmath260 is feasible and consider the shared communication link between the server and the mirrors .",
    "fix @xmath261 and @xmath262 .",
    "consider the set of @xmath263 users @xmath17 with @xmath264 and @xmath265 .",
    "consider a request matrix @xmath22 with user @xmath29 requesting @xmath266 .",
    "since the tuple @xmath260 is feasible , each user @xmath29 can recover its requested file from the transmission from the server of rate @xmath5 along with the contents of mirror @xmath16 of size @xmath1 and cache @xmath29 of size @xmath3 .",
    "now , consider a different request matrix @xmath22 in which user @xmath29 requests @xmath267 . again from the server transmission of rate @xmath5 and the two cache memories of sizes @xmath1 and @xmath3 each user @xmath17 can recover its requested file .",
    "note that , while the transmission of the server can depend on the request matrix , the contents of the caches do not .",
    "repeat the same argument for a total of @xmath268 request matrices .",
    "then we have the following cut - set bound @xcite : @xmath269 on the left - hand side of  , the first term corresponds to the @xmath270 transmissions from the server , one for each request matrix , of rate @xmath5 each ; the second term corresponds to the @xmath271 mirror memories ; and the third term corresponds to the @xmath272 user memories .",
    "the right - hand side of   corresponds to the @xmath272 different files that are reconstructed by the users for each of the @xmath270 request matrices .",
    "can be rewritten as @xmath273    we can modify the above argument slightly to get an alternate lower bound on the rate @xmath5 . instead of @xmath268 transmissions , we will use @xmath274 transmissions in to get @xmath275 or , equivalently , @xmath276    since the inequalities and hold true for any choice of @xmath261 and @xmath277 , we have the following lower bound on the rate @xmath5 for the tuple @xmath260 to be feasible : @xmath278      assume the tuple @xmath260 is feasible and consider the link between mirror one and its attached users .",
    "let @xmath279 .",
    "consider the set of @xmath280 users @xmath281 with @xmath282 .",
    "consider a request matrix @xmath22 with user @xmath281 requesting @xmath283 .",
    "since the tuple @xmath33 is feasible , each user @xmath284 can recover its requested file from the message transmitted by mirror one of rate @xmath6 and the contents of its cache of size @xmath3 .",
    "now , consider a different request matrix @xmath22 in which user @xmath284 requests @xmath285 .",
    "again from the mirror transmission of rate @xmath6 and its cache of size @xmath3 each user @xmath281 can recover its requested file .",
    "note that , while the transmission of the mirror can depend on the request matrix , the contents of the caches do not .",
    "repeat the same argument for a total of @xmath286 request matrices .",
    "then we have the following cut - set bound @xcite : @xmath287 or , equivalently , @xmath288    since this inequality holds true for any choice of @xmath289 , we have the following lower bound on the rate @xmath6 for the tuple @xmath260 to be feasible : @xmath290",
    "we prove that the rate @xmath109 over the first hop , for the generalized caching scheme , as described in is within a constant additive and multiplicative gap of the minimum feasible rate @xmath5 for all values of @xmath93 .",
    "recall from and fig .",
    "[ fig : alphabeta0 ] that we use different parameters @xmath220 for the generalized caching scheme in the three different regimes of @xmath292 , regimes  i , ii , and iii . to prove the result",
    ", we will consider each of these regimes of @xmath292 in sequence , and bound the gap between the achievable rate @xmath109 and the corresponding lower bound @xmath293 , as derived in appendix  [ sec : lowerbounds ] .",
    "henceforth , we focus on the case where @xmath294 . for @xmath295 ( @xmath296 )",
    ", it is easy to see that the optimal rate is within the constant factor @xmath297 of the rate of the network with @xmath111 ( @xmath37 ) .",
    "the optimum rate for @xmath298 ( @xmath37 ) can be characterized easily following the results of @xcite .",
    "we begin with regime  i.    [ [ displaystyle - m_1-m_2k_2-ge - n-0-le - m_1-fracn4 ] ]      [ sec : bgregimei ] for this regime , recall from that the achievable rate @xmath109 is upper bounded as @xmath300 on the other hand , recall the following lower bound on the rate @xmath5 from : @xmath301 for characterizing the gap between the achievable rate and the lower bound , we further divide this regime into three subregimes as follows : @xmath302      & \\hspace{-2in}\\textup{\\ref{sec : regimeicaseb } ) } & \\",
    "\\displaystyle \\frac{n}{2k_1 } \\le m_1 < \\frac{n}{4 } & , \\ \\ \\frac{3n}{4k_2 } \\le m_2 < \\frac{n}{4 } , \\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeicasec } ) } & \\ \\displaystyle 0 \\le m_1 < \\frac{n}{4 } & , \\ \\ \\frac{n}{4 } \\le m_2 \\le n. \\end{aligned}\\ ] ]",
    "the subregimes above only consider @xmath303 since for regime  i , we have @xmath304 and @xmath305 , and thus @xmath306 .",
    "we now consider the three subregimes one by one .",
    "let @xmath308 in the lower bound in .",
    "using @xmath309 for any @xmath310 , we can confirm that this is a valid choice since @xmath311 then , by evaluating we have @xmath312 where @xmath313 follows since @xmath314 for any @xmath315 ; @xmath316 follows since @xmath317 using , @xmath21 , and @xmath318 ; and @xmath319 follows since we have @xmath318 .",
    "combining with , we have @xmath320      let @xmath322          \\left ( \\left\\lfloor \\frac{n}{4m_2}\\right\\rfloor , 1 \\right )   & \\mbox { otherwise , }        \\end{cases}\\end{aligned}\\ ] ] in .",
    "this is a valid choice since for @xmath323 , we have @xmath324      1 \\le       & \\left\\lfloor \\frac{m_1}{m_2 } \\right\\rfloor        \\le \\frac{m_1}{m_2 }       \\le \\frac{n/ 4}{3 n / ( 4k_2 ) }       = \\frac{k_2}{3},\\end{aligned}\\ ] ] and for @xmath325 , we have @xmath326 note that @xmath327 and @xmath328 .",
    "further , since @xmath314 for any @xmath310 , we have @xmath329 .",
    "finally , substituting @xmath330 in , we obtain @xmath331 where @xmath313 follows from @xmath332 using @xmath21 and @xmath318 . combining with , we have @xmath333      we trivially have @xmath335 combined with , this yields @xmath336    sections  [ sec : regimeicasea ] ,  [ sec : regimeicaseb ] , and  [ sec : regimeicasec ] cover all the cases in regime i. combining , , and , it follows that the achievable rate @xmath337 and the lower bound @xmath338 are within a constant multiplicative and additive gap for this regime .",
    "[ sec : bgregimeii ]    for this regime , recall from that the achievable rate @xmath222 is upper bounded as @xmath340 for characterizing the gap between the achievable rate and the lower bounds , we further divide this regime into the following subregimes : @xmath341      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicaseb } ) } & \\ \\displaystyle 0   \\le m_1 < \\frac{n}{k_1 } & , \\ \\ \\frac{n}{k_1k_2 } \\le m_2 < \\frac{n}{3k_2},\\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicasec } ) } & \\ \\displaystyle 0 \\le m_1",
    "< \\frac{n}{k_1 } & , \\ \\ \\frac{n}{3k_2 } \\le m_2 < \\frac{n}{4},\\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicased } ) } & \\ \\displaystyle",
    "\\frac{n}{k_1}\\le m_1 < \\frac{n}{4 } & , \\ \\    0 \\le m_2 < \\frac{n}{4k_2},\\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicasee } ) } & \\ \\displaystyle   \\frac{n}{k_1}\\le m_1 < \\frac{n}{4 } & , \\",
    "\\frac{n}{4k_2 } \\le m_2 < \\frac{n}{4},\\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicasef } ) } & \\",
    "\\displaystyle   \\frac{n}{4 } \\le m_1 \\le n & , \\",
    "\\   0 \\le m_2 < \\frac{n - m_1}{2k_2},\\\\[1em ]      & \\hspace{-2in}\\textup{\\ref{sec : regimeiicaseg } ) } & \\",
    "\\displaystyle    \\frac{n}{4 } \\le m_1 \\le n & , \\ \\",
    "\\frac{n - m_1}{2k_2 } \\le m_2 < \\frac{n - m_1}{k_2}.   \\end{aligned}\\ ] ] the subregimes above only consider @xmath342 since from the definition of regime  ii , we have @xmath343 using @xmath344 .",
    "we now consider the different subregimes one by one .",
    "[ [ sec : regimeiicasea ] ]      let @xmath346 in the lower bound .",
    "this is a valid choice since @xmath318 , and thus @xmath347 .",
    "evaluating , we obtain @xmath348 where @xmath313 follows since @xmath314 for any @xmath315 ; and @xmath316 follows from @xmath349 , @xmath350 , and @xmath21 . combining with , we have @xmath351      let @xmath353 in .",
    "note that this is a valid choice since @xmath354 substituting @xmath330 in , we have @xmath355 where @xmath313 follows from @xmath314 for any @xmath310 ; and @xmath316 follows from @xmath349 , @xmath356 , and since @xmath357 using @xmath21 .",
    "combined with , we have @xmath358      let @xmath360 in the lower bound in .",
    "this is a valid choice since @xmath361 evaluating , we obtain @xmath362 where @xmath313 follows from @xmath314 for any @xmath310 ; and @xmath316 follows since @xmath363 using @xmath318 , and @xmath364 using , @xmath21 , and @xmath318 . combining with , we have @xmath365      let @xmath367 in .",
    "note that this is a valid choice since @xmath368 substituting @xmath330 in , we obtain @xmath369 where @xmath313 follows since @xmath314 for any @xmath315 ; and @xmath316 follows since @xmath370 using and @xmath21 . combining with ,",
    "we have @xmath371      let @xmath373          \\left ( \\left\\lfloor \\frac{n}{4m_2}\\right\\rfloor , 1 \\right ) & \\mbox { otherwise , }        \\end{cases}\\end{aligned}\\ ] ] in .",
    "this is a valid choice since for @xmath323 , we have @xmath374      1 \\le   & \\left\\lfloor \\frac{m_1}{m_2 } \\right\\rfloor \\le \\frac{m_1}{m_2 }   \\le \\frac{n/ 4}{n / ( 4k_2 ) } = k_2,\\end{aligned}\\ ] ] and for @xmath325 , we have @xmath375 note that @xmath327 and @xmath328 .",
    "further , since @xmath314 for any @xmath310 , we have @xmath376 . also , note that @xmath377 using @xmath21 and @xmath318 . finally , substituting @xmath330 in ,",
    "we obtain @xmath378 combining with , we have @xmath379      substituting @xmath381 in the lower bound , we obtain @xmath382 where @xmath313 follows since @xmath383 using @xmath21 and @xmath318 . on the other hand ,",
    "from we obtain @xmath384 where @xmath313 follows since @xmath385 for this case ; and @xmath316 follows since @xmath386 . combining with , we obtain @xmath387 where @xmath313 follow since @xmath386 .",
    "let @xmath389 in .",
    "this is a valid choice since @xmath390 and @xmath228 , so that @xmath391 substituting @xmath330 in , we obtain @xmath392 where @xmath313 follows from @xmath314 for any @xmath310 , and @xmath393 using @xmath21 and @xmath318 . on the other hand ,",
    "from we obtain @xmath394 where @xmath313 follows since @xmath228 for regime  ii and @xmath316 follows since @xmath395 for this case . combining with , we have @xmath396 where @xmath313 follows since @xmath397 for this case .    sections  [ sec : regimeiicasea ] - [ sec : regimeiicaseg ] cover all the cases in regime  ii . combining , , , , , , and shows that the achievable rate @xmath398 and the lower bound @xmath293 are within a constant multiplicative and additive gap in this regime .",
    "[ [ displaystyle - m_1-m_2k_2-ge - n - fracn4-le - m_1-le - n ] ]      [ sec : bgregimeiii ]    for this regime , recall from that the achievable rate @xmath109 is upper bounded as @xmath400 to characterize the gap between the achievable rate and the lower bounds , we further divide regime  iii into the two subregimes + [ sec : regimeiiicasea ] ) @xmath401 , + [ sec : regimeiiicaseb ] ) @xmath402 .",
    "+ we now consider the subregimes one by one .",
    "let @xmath389 in the lower bound .",
    "this is a valid choice since @xmath404 substituting @xmath330 in , we obtain @xmath405 where @xmath313 follows from @xmath314 for any @xmath310 and @xmath406 using , @xmath21 , and @xmath318 . combining with , we have @xmath407      we trivially have @xmath408 combining with and using @xmath409 for this case , we have @xmath410 sections  [ sec : regimeiiicasea ] and  [ sec : regimeiiicaseb ] cover all the cases in regime iii . combining and",
    ", it follows that the achievable rate @xmath337 and the lower bound @xmath338 are within a constant multiplicative and additive gap for regime  iii .",
    "regimes  i , ii , and iii cover all possible values for @xmath292 . for each regime",
    ", we have shown that the achievable rate @xmath5 for the generalized caching scheme is within a constant additive and multiplicative gap of the minimum feasible rate .",
    "in particular , for any @xmath93 , and any feasible rate pair @xmath411 , we have @xmath412",
    "we prove that the rate @xmath110 for the generalized caching scheme , as described in , is within a constant additive and multiplicative gap of the corresponding lower bound @xmath414 , as derived in appendix  [ sec : lowerbounds ] , for all values of @xmath93 .",
    "as before , we focus on the case where @xmath294 . the case of @xmath415 or @xmath416",
    "is easily analyzed using the results of @xcite .    from , we have the following upper bound on the achievable rate @xmath223 of the generalized caching scheme for any @xmath93 : @xmath417 on the other hand , recall the following lower bound on the rate @xmath6 from : @xmath418 to characterize the gap between the achievable rate and the lower bounds , we study two different cases .",
    "1 .   @xmath421 : let @xmath422 in .",
    "this is a valid choice since @xmath344 , and thus @xmath423 substituting @xmath280 in yields @xmath424 where @xmath313 follows since @xmath314 for any @xmath310 and @xmath425 using @xmath21 and @xmath318 . comparing and , we have @xmath426 2 .",
    "@xmath420 : we trivially have @xmath427 combining with , we have @xmath428    cases 1 ) and 2 ) cover all values of the memory sizes @xmath93 . combining , , it follows that the achievable rate @xmath429 of the generalized caching scheme and the lower bound @xmath430 are within a constant multiplicative and additive gap for all values of @xmath93 . in particular , for any @xmath93 , and any feasible rate pair @xmath248 , we have @xmath431"
  ],
  "abstract_text": [
    "<S> caching of popular content during off - peak hours is a strategy to reduce network loads during peak hours . </S>",
    "<S> recent work has shown significant benefits of designing such caching strategies not only to deliver part of the content locally , but also to provide coded multicasting opportunities even among users with different demands . exploiting both of these gains </S>",
    "<S> was shown to be approximately optimal for caching systems with a single layer of caches .    motivated by practical scenarios , we consider in this work a hierarchical content delivery network with two layers of caches . </S>",
    "<S> we propose a new caching scheme that combines two basic approaches . </S>",
    "<S> the first approach provides coded multicasting opportunities within each layer ; the second approach provides coded multicasting opportunities across multiple layers . by striking the right balance between these two approaches , we show that the proposed scheme achieves the optimal communication rates to within a constant multiplicative and additive gap . </S>",
    "<S> we further show that there is no tension between the rates in each of the two layers up to the aforementioned gap . </S>",
    "<S> thus , both layers can simultaneously operate at approximately the minimum rate . </S>"
  ]
}