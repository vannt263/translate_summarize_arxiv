{
  "article_text": [
    "many problems , particularly in combinatorics , reduce to asking whether some graph with a given property exists , or alternatively , asking how many such non - isomorphic graphs exist . such graph search and graph enumeration problems are notoriously difficult , in no small part due to the extremely large number of symmetries in graphs . in practical problem solving , it is often advantageous to eliminate these symmetries which arise naturally due to graph isomorphism : typically , if a graph @xmath0 is a solution then so is any other graph @xmath1 that is isomorphic to @xmath0 .",
    "general approaches to graph search problems typically involve either : _ generate and test _ , explicitly enumerating all ( non - isomorphic ) graphs and checking each for the given property , or _ constrain and generate _",
    ", encoding the problem for some general - purpose discrete satisfiability solver ( i.e. sat , integer programming , constraint programming ) , which does the enumeration implicitly . in the explicit approach , one typically iterates , repeatedly applying an extend and",
    "reduce approach : first _ extend _ the set of all non - isomorphic graphs with @xmath2 vertices , in all possible ways , to graphs with @xmath3 vertices ; and then _ reduce _ the extensions to their non - isomorphic ( canonical ) representatives . in the constraint based approach",
    ", one typically first encodes the problem and then applies a constraint solver in order to produce solutions .",
    "the ( unknown ) graph is represented in terms of boolean variables describing it as an adjacency matrix @xmath4 .",
    "the encoding is a conjunction of constraints that constitute a model , @xmath5 , such that any satisfying assignment to @xmath5 is a solution to the graph search problem .",
    "typically , symmetry breaking constraints  @xcite are added to the model to reduce the number of isomorphic solutions , while maintaining the correctness of the model .    it remains unknown whether a polynomial time algorithm exists to decide the graph isomorphism problem .",
    "nevertheless , finding good graph isomorphism algorithms is critical when exploring graph search and enumeration problems .",
    "recently an algorithm was published by which runs in time @xmath6 , for some constant @xmath7 , and solves the graph isomorphism problem .",
    "nevertheless , top of the line graph isomorphism tools use different methods , which are , in practice , faster .",
    "introduces an algorithm for graph canonization , and its implementation , called ` nauty `  ( which stands for _ no automorphisms , yes ? _ ) , is described in @xcite .",
    "in contrast to earlier works , where the canonical representation of a graph was typically defined to be the smallest graph isomorphic to it ( in the lexicographic order ) , ` nauty `  introduced a notion which takes structural properties of the graph into account . for details on",
    "how ` nauty `  defines canonicity and for the inner workings of the ` nauty ` algorithm see  @xcite . in recent years",
    "` nauty `  has gained a great deal of popularity and success .",
    "other , similar tools , are  @xcite and  @xcite .",
    "the ` nauty `  graph automorphism tool consists of two main components .",
    "( 1 ) a c library , ` nauty ` , which may be linked to at runtime , that contains functions applicable to find the canonical labeling of a graph , and ( 2 ) a collection of applications , ` gtools ` , that implement an assortment of common tasks that ` nauty `  is typically applied to . when downloading the tool both components are included . during compilation static library files",
    "are created for the c library .",
    "these files may be linked to at runtime , and header files are provided which may be included in foreign c code . during compilation , the applications of ` gtools `  are compiled into a set of command line applications .",
    "this paper presents a lightweight prolog interface to both components of ` nauty `  which we term ` pl - nauty `  and ` pl - gtools ` .",
    "the implementation of ` pl - nauty `  is by direct use of prolog s foreign language interface .",
    "the implementation of ` pl - gtools `  is slightly more complex .",
    "each ` gtools `  application is run as a child process with the input and output controlled via unix pipes .",
    "the ` pl - gtools `  framework provides a set of general predicates to support this type of application integration .",
    "the integration of ` nauty `  into prolog facilitates programming with the strengths of the two paradigms : logic programming for solving graph search problems on the one hand , and efficient pruning of ( intermediate ) solutions modulo graph isomorphism , on the other .",
    "it enables prolog programs which address graph search problems to apply ` nauty `  natively , through prolog , in the process of graph search and enumeration .",
    "graphs may be generated non - deterministically and may be canonized deterministically .",
    "it also facilitates the interaction with various graph representations : those used in ` nauty ` , and those more natural for use with prolog .",
    "the interface for ` nauty `  from within prolog combines well also with other tools and techniques typically applied when addressing graph search problems , such as constraint and sat based programming .",
    "for example , recent work  @xcite , presents a computer - based proof that the ramsey number @xmath8 , thus closing a long open problem concerning the value of @xmath9 . that paper made extensive use of sat solvers , symmetry breaking techniques , and the ` nauty ` library .",
    "it was this experience that led us to implement `",
    "pl - nauty ` .",
    "the remaining sections of this paper are organized in the following manner : section  ( [ sec : prelim ] ) introduces the definitions used throughout the paper , as well as the running example of ramsey graphs .",
    "section  ( [ sec : pln ] ) introduces the core of the `",
    "pl - nauty `  library by examples .",
    "section  ( [ sec : plg ] ) details the ` pl - gtools `  framework , and details the template used to integrate ` gtools `  applications with prolog .",
    "section  ( [ sec : tech ] ) closes some technical loose ends , including details of supported platforms , package availability , and additional references to source code . finally , section  [ sec : conclude ] concludes .",
    "a graph @xmath10 consists of a set of vertices @xmath11={\\left\\ {         \\begin{array}{l}1,\\ldots , n\\end{array }         \\right\\}}$ ] and a set of edges @xmath12 . in the examples presented in this paper graphs are always simple . meaning that they are undirected , there are no self loops , and no multiple edges .",
    "the tools we present allow also directed graphs and support vertex - coloring .",
    "two graphs @xmath13,e)$ ] and @xmath14,e')$ ] are said to be isomorphic if the vertices of one graph may be permuted to obtain the other .",
    "namely , if there exists a permutation @xmath15\\to[n]$ ] such that @xmath16 .",
    "graph isomorphism is an equivalence relation . as such",
    ", it induces equivalence classes on any set of graphs , wherein graphs @xmath0 , @xmath1 are in the same equivalence class if @xmath0 and @xmath1 are isomorphic .",
    "the canonical representation of a graph @xmath0 is some fixed value @xmath17 such that for every graph @xmath1 isomorphic to @xmath0 we have @xmath18 .",
    "the running example we use throughout this paper concerns the generation of ramsey graphs : a @xmath19 ramsey graph , where @xmath20 , is a graph @xmath0 with @xmath2 vertices such that @xmath0 contains no clique of size @xmath21 nor an independent set of size @xmath22 .",
    "we denote by @xmath23 the set of all non - isomorphic ramsey @xmath19 graphs .",
    "the ramsey number @xmath24 is the smallest natural number @xmath2 for which no @xmath19 graph exist .",
    "the ` pl - nauty `  interface is implemented using the foreign language interface of swi - prolog  @xcite .",
    "the ` nauty `  c library is linked with corresponding c code written for prolog , which involves four low - level prolog predicates : ( 1 )  ` densenauty/8 ` , ( 2 )  ` canonic_graph/6 ` , ( 3 )  ` isomorphic_graphs/6 ` , and ( 4 )  ` graph_convert/5 ` . the experienced ` nauty",
    "`  user will find ` densenauty/8 ` to be a direct interface to the corresponding c function in ` nauty ` .",
    "the ` canonic_graph/6 ` predicate performs graph canonization only .",
    "the ` isomorphic_graphs/6 ` predicate tests two graphs for isomorphism , and ` graph_convert/5 ` converts between the supported graph formats such as between the ` graph6 `  @xcite format often used in ` nauty `  and the boolean adjacency matrices natural in logic programming .",
    "we present several examples of the ` pl - nauty `  library in prolog .",
    "the first two examples revolve around enumerating ramsey graphs modulo isomorphism .",
    "the rest are simple demonstrations of the core `",
    "pl - nauty `  predicates in various cases . in the first example",
    "we apply a straightforward iterative approach to enumerate all solutions modulo isomorphism .",
    "the second example illustrates how ` nauty `   integrates into an existing tool - chain , all specified as part of the prolog process .",
    "here we first construct a constraint model , infused with a partial symmetry breaking predicate .",
    "then , apply the finite domain constraint compiler  @xcite ( written in prolog ) to obtain a cnf model , apply a sat solver ( through its prolog interface ) , and then generate all solutions of constraint model . at the end of each iteration",
    "we apply predicates from the ` pl - nauty `  library to remove isomorphic solutions .",
    "the core of the code , with an emphasis on using the ` pl - nauty `  library is presented below .",
    "the complete code is available for download as part of the `",
    "pl - nauty `  library , in the ` examples ` directory .      in the code below , the predicate ` genramseygt(s , t , n , graphs ) ` iterates starting from the empty graph to generate in ` graphs ` , the set of all canonical ramsey @xmath25 colorings .",
    "we represent graphs as boolean adjacency matrices : a list of ` n ` length-`n ` lists . at iteration ` i ` it takes , ` acc ` , the canonical set of ramsey @xmath26 colorings computed thus far and calls the predicate ` extendramsey(s , t , i , acc , newacc ) ` to obtain , ` newacc ` , the canonical set of ramsey @xmath27 colorings .    ....",
    "genramseygt(s , t , n , graphs ) : -           genramsey(0 , s , t , n , [ [ ] ] , graphs ) .",
    "genramsey(i , s , t , n , acc , graphs ) : -           i < n , ! , i1 is i+1 ,           extendramsey(s , t , i , acc , newacc ) ,           genramsey(i1 , s , t , n , newacc , graphs ) .",
    "genramsey(n , _ , _ , n , graphs , graphs ) .",
    "....    the predicate ` extendramsey(s , t , n , graphs , newgraphs ) ` takes a list , ` graphs ` of ( canonical ) ramsey @xmath25 graphs .",
    "then , a new vertex is added in all possible ways to each graph in ` graphs ` and those new graphs that are ramsey @xmath28 colorings are canonized . finally , the resulting graphs are sorted to remove duplicates , resulting in ` newgraphs ` .",
    "it is the call to ` canonic_graph/3 ` that interfaces to our prolog integration of the ` nauty `  tool .    ....",
    "extendramsey(s , t , n , graphs , newgraphs ) : -           n1 is n+1 ,           findall(canonic ,                   ( member(graph , graphs ) ,                    addvertex(graph , newgraph ) ,                    isramsey(s , t , n1,newgraph ) ,              / * # 1 ( test)*/                    canonic_graph(n1 , newgraph , canonic )    / * # 2 ( reduce)*/                    ) ,                   graphstmp ) ,           sort(graphstmp , newgraphs ) .",
    "....    the predicate ` addvertex(matrix , extendedmatrix ) ` extends non - deterministically an adjacency ` matrix ` with a new vertex by adding a new first row and equal first column .    ....",
    "addvertex(matrix,[newrow|newrows ] ) : -           newrow = [ 0|xs ] ,           addfirstcol(matrix , xs , newrows ) .",
    "addfirstcol ( [ ] , [ ] , [ ] ) .",
    "addfirstcol([row|rows],[x|xs],[[x|row]|newrows ] ) : -           member(x,[0,1 ] ) ,           addfirstcol(rows , xs , newrows ) .    ....    to complete the example",
    ", we illustrate the test predicate ` isramsey(s , t , n , graph ) ` which succeeds if the given ` graph ` is a ramsey @xmath25 coloring .",
    "this is so if it is not possible to ` choose ` ` s ` vertices from the graph , the edges between which are all `` colored '' 0 , or ` t ` vertices from the graph , the edges between which are all `` colored '' 1 .    ....",
    "isramsey(s , t , n , graph ) : -                 forall ( choose(n , s , vs ) , mono(0 , vs , graph ) ) ,                 forall ( choose(n , t , vs ) , mono(1 , vs , graph ) ) .",
    "mono(color , vs , graph ) : -                 cliqeedges(vs , graph , es ) ,                 maplist(==(color ) , es ) .           cliqeedges ( [ ] , _ , [ ] ) .",
    "choose(n , k , c ) : -         cliqeedges([i|is],graph , es ) : -                         numlist(1,n , ns ) ,               cliqeedges(i , is , graph , es0 ) ,                   length(c , k ) ,               cliqeedges(is , graph , es ) .",
    "choose(c , ns ) .",
    "cliqeedges ( _ , [ ] , _ , [ ] ) .                           choose ( [ ] , [ ] ) .",
    "cliqeedges(i,[j|js ] , graph , [ e|es ] ) : -           choose([i|is],[i|js ] ) : -               nth1(i , graph , gi ) ,                              choose(is , js ) .",
    "nth1(j , gi , e ) ,                            choose(is,[_|js ] ) : -               cliqeedges(i , js , graph , es ) .",
    "choose(is , js ) .    ....",
    "we first demonstrate the application of the ` genramseygt ` to the so called , `` party problem '' .",
    "what is the smallest number of people that must be invited to a party so that at least three know each other , or at least three do not know each other .",
    "this is the smallest @xmath29 for which there is no @xmath30 coloring .",
    "the following two calls illustrate that there is a single canonical coloring when @xmath31 and none when @xmath32 .",
    "so , the answer to the party problem ( as well - known ) is 6 .    ....       ? - genramseygt(3,3,5,gs ) .       gs = [ [ [ 0,1,1,0,0 ] ,               [ 1,0,0,1,0 ] ,               [ 1,0,0,0,1 ] ,               [ 0,1,0,0,1 ] ,               [ 0,0,1,1,0 ] ] ] .       ?",
    "- genramseygt(3,3,6,gs ) .",
    "gs = [ ] .    ....",
    "we make three observations regarding the generation of graphs in this example .",
    "consider the predicate ` extendramsey/5 ` .    1 .",
    "if the call ` canonic_graph(n1 , newgraph , canonic ) ` , at the line marked ` / * # 2 * / ` , is replaced by the line ` canonic = newgraph ` , then all solutions are found , not just the canonical ones .",
    "for example , when @xmath31 there are 12 solutions , all of them isomorphic .",
    "+ ....       ? - genramseygt(3,3,5,gs ) , length(gs , m ) .",
    "m = 12 .",
    "if the call to ` isramsey(s , t , n1,newgraph ) ` , at the line marked ` / * # 1 * / ` , is removed then we generate all non - isomorphic graphs on ` n ` vertices .",
    "for example , + ....       ? - genramseygt(3,3,5,gs ) , length(gs , m ) .",
    "m = 34 .",
    "if both changes are made , then we generate all graphs on ` n ` vertices .",
    "+ ....       ? - genramseygt(3,3,5,gs ) , length(gs , m ) .",
    "m = 1024 .    ....",
    "we now demonstrate the application of the ` genramseygt ` to generate incrementally all non - isomorphic @xmath33 ramsey colorings .",
    "it is known @xcite that @xmath34 .",
    "table  ( [ tab:35n ] ) summarizes the enumeration of all non - isomorphic @xmath33 colorings graphs .",
    "the first row indicates the number of ( non - isomorphic ) colorings generated .",
    "the next rows detail the time ( in seconds ) to compute these colorings and the time spent in the calls to ` canonic_graph ` .",
    "it is notable that the time spent to reduce solutions modulo isomorphism using ` nauty `  is negligible .    to summarize this section",
    ", we stress that this is a toy application with the intention to illustrate an application of the integration of prolog with the ` nauty `  package . a more elaborate solution of this problem",
    "would , for example , combine the calls    ....",
    "addvertex(graph , newgraph ) , isramsey(s , t , n1,newgraph )    ....    in ` extendramsey ` to add edges connecting the new vertex to the rest of the graph incrementally so as not to violate the ` isramsey ` condition .",
    "this combination could also perform various propagation based optimizations .      in the code below , the predicate ` genramseycg(s , t , n , graphs ) ` encodes an instance ` ramsey(s , t , n ) ` to a finite domain constraint model .",
    "we adopt  @xcite for this purpose . the call to ` encode/3 ` generates a constraint model , ` constraints ` and the @xmath35 ` matrix ` of boolean ( prolog ) variables .",
    "the ` matrix ` structure serves as a mapping between the instance variables , which talks about the search for ramsey colorings , and the ` constraints ` variables .",
    "it specifies the connection between variables in the constraint model and edges in the unknown graph we are searching for .",
    "the call to ` bcompile/2 ` compiles the constraints to a corresponding ` cnf ` .",
    "the call to ` solveall/3 ` iterates with the underlying sat solver to provide all satisfying ` assignments ` of the ` cnf ` ( modulo the variables of interest in the list ` booleans ` ) .",
    "satisfying assignments are then decoded back to the world of graphs in the call to ` decode/3 ` , and finally it is here that we call on the predicate ` canonic_graph/3 ` from the ` pl - nauty `  interface to restrict solutions to their canonical forms and remove isomorphic solutions by sorting these .    ....",
    "genramseycg(s , t , n , graphs ) : -           encode(ramsey(s , t , n ) , matrix , constraints ) ,           bcompile(constraints , cnf ) ,           projectvariables(matrix , booleans ) ,           solveall(cnf , booleans , assignments ) ,           decode(assignments , matrix , graphs0 ) ,           maplist(canonic_graph(n ) , graphs0 , graphs1 ) ,           sort(graphs1 , graphs ) .",
    "....    the predicate ` encode/3 ` is presented below .",
    "it first creates an @xmath35 adjacency ` matrix ` with boolean variables representing the object of the search for a ramsey(s , t;n ) graph .",
    "it then imposes three sets of constraints : ( 1 ) the call to ` lex_star/2 ` constrains the rows of ` matrix ` to be pairwise lexicographically ordered .",
    "this implements the symmetry break described in  @xcite ; ( 2 ) the first call to ` no_clique/4 ` constrains the graph represented by ` matrix ` to contain no independent set of size ` s ` , and ( 3 ) the second call to ` no_clique/4 ` constrains the graph represented by ` matrix ` to contain no clique of size ` t ` .",
    "the full details of the example are available for download as part of the ` pl - nauty `  library , in the ` examples ` directory .    ....",
    "encode(ramsey(s , t , n ) , map(matrix ) , constraints ) : -               adj_matrix_create(n , matrix ) ,               lex_star(matrix , cs1-cs2 ) ,           / * # 1 * /               no_clique(0 , s , matrix , cs2-cs3 ) ,    / * # 2 * /               no_clique(1 , t , matrix , cs3-cs4 ) ,    / * # 3 * /               cs4 = [ ] ,               constraints = cs1 .",
    "....    the following illustrates the  constraint model , with the associated adjacency matrix , produced by a call to the ` encode/3 ` predicate for a ramsey @xmath36 instance .",
    "note that the elements on the diagonal of the matrix are @xmath37 which is how _ false _ is represented in .",
    "the constraint model consists of three types of constraints corresponding to the three annotated calls in ` encode/3 ` .    ....",
    "[ [ -1,a , b , c , d ] ,      [ a,-1,e , f , g ] ,      [ b , e,-1,h , i ] ,      [ c , f , h,-1,j ] ,      [ d , g , i , j,-1 ] ]         % # 1 pairwise lexicographical order   % # 2 no independent set     % # 3 no clique       bool_arrays_lex([b , c , d],[e , f , g ] ) ,     bool_array_or([a , b , e ] ) ,     bool_array_or([-a ,- b ,- e ] ) ,       bool_arrays_lex([a , b , d],[f , h , j ] ) ,     bool_array_or([a , c , f ] ) ,     bool_array_or([-a ,- c ,- f ] ) ,       bool_arrays_lex([a , f , g],[b , h , i ] ) ,     bool_array_or([a , d , g ] ) ,     bool_array_or([-a ,- d ,- g ] ) ,       bool_arrays_lex([a , e , f],[d , i , j ] ) ,     bool_array_or([b , c , h ] ) ,     bool_array_or([-b ,- c ,- h ] ) ,       bool_arrays_lex([b , e , i],[c , f , j ] ) ,     bool_array_or([b , d , i ] ) ,     bool_array_or([-b ,- d ,- i ] ) ,       bool_arrays_lex([c , f , h],[d , g , i ] ) ,     bool_array_or([c , d , j ] ) ,     bool_array_or([-c ,- d ,- j ] ) ,                                            bool_array_or([e , f , h ] ) ,     bool_array_or([-e ,- f ,- h ] ) ,                                            bool_array_or([e , g , i ] ) ,     bool_array_or([-e ,- g ,- i ] ) ,                                            bool_array_or([f , g , j ] ) ,     bool_array_or([-f ,- g ,- j ] ) ,                                            bool_array_or([h , i , j ] ) ,     bool_array_or([-h ,- i ,- j ] )     ....    table  ( [ tab:35n_sat ] ) summarizes the enumeration of all non - isomorphic @xmath33 colorings graphs using the constrain and generate approach .",
    "the first row indicates the number of ( non - isomorphic ) colorings generated .",
    "the second row indicates the number of colorings found when solving the constraint model ( with the partial symmetry break ) .",
    "the next rows detail the time ( in seconds ) to compute these colorings and the time spent in the calls to ` canonic_graph ` .",
    "it is notable that the time spent to reduce solutions modulo isomorphism using ` nauty `  is negligible .",
    "the ` graph_convert/5 ` predicate performs conversions between the different graph formats that are supported by ` pl - nauty ` .",
    "supported formats include : adjacency matrices , adjacency lists , edge lists , and the ` graph6 ` format . as an example , to convert a graph , or a list of graphs , from the ` graph6 ` format , to prolog s adjacency matrix format :    ....        ? - graph = ` dqk ' ,            graph_convert(5 , graph6_atom , adj_matrix , graph , adjmatrix ) .",
    "graph = ` dqk ' ,        adjmatrix = [ [ 0,1,1,0,0 ] , [ 1,0,0,1,0 ] , [ 1,0,0,0,1 ] , [ 0,1,0,0,1 ] , [ 0,0,1,1,0 ] ]    ....    ....        ? - graphs = [ ` dro',`dbg',`ddw',`dlo',`d[s',`dps',`dyc',`dqk',`dmg',`dkk',`dhc',`duw ' ] ,           maplist(graph_convert(5 , graph6_atom , adj_matrix ) , graphs , adjmatrices ) .",
    "graphs       = [ ` dro',`dbg',`ddw',`dlo',`d[s',`dps',`dyc',`dqk',`dmg',`dkk',`dhc',`duw ' ] ,        adjmatrices = [ [ [ 0,0,1,0,1],[0,0,0,1,1],[1,0,0,1,0],[0,1,1,0,0],[1,1,0,0,0 ] ] ,                       [ [ 0,1,0,0,1],[1,0,0,1,0],[0,0,0,1,1],[0,1,1,0,0],[1,0,1,0,0 ] ] ,                       [ [ 0,1,0,1,0],[1,0,0,0,1],[0,0,0,1,1],[1,0,1,0,0],[0,1,1,0,0 ] ] ,                       [ [ 0,0,0,1,1],[0,0,1,0,1],[0,1,0,1,0],[1,0,1,0,0],[1,1,0,0,0 ] ] ,                       [ [ 0,0,1,1,0],[0,0,1,0,1],[1,1,0,0,0],[1,0,0,0,1],[0,1,0,1,0 ] ] ,                       [ [ 0,1,1,0,0],[1,0,0,0,1],[1,0,0,1,0],[0,0,1,0,1],[0,1,0,1,0 ] ] ,                       [ [ 0,0,1,0,1],[0,0,1,1,0],[1,1,0,0,0],[0,1,0,0,1],[1,0,0,1,0 ] ] ,                       [ [ 0,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1],[0,1,0,0,1],[0,0,1,1,0 ] ] ,                       [ [ 0,0,0,1,1],[0,0,1,1,0],[0,1,0,0,1],[1,1,0,0,0],[1,0,1,0,0 ] ] ,                       [ [ 0,1,0,1,0],[1,0,1,0,0],[0,1,0,0,1],[1,0,0,0,1],[0,0,1,1,0 ] ] ,                       [ [ 0,1,0,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,1],[1,0,0,1,0 ] ] ,                       [ [ 0,0,1,1,0],[0,0,0,1,1],[1,0,0,0,1],[1,1,0,0,0],[0,1,1,0,0 ] ] ]    ....      the ` canonic_graph/6 ` predicate performs graph canonization and it takes the form ` canonic_graph(n , inputfmt , outputfmt , graph , perm , canonic ) ` where ` inputfmt ` is the format of the ` n ` vertex input graph ( ` graph ` ) , ` outputfmt ` is the format of the canonical graph ( ` canonic ` ) , and ` perm ` is the permutation whose application to the input graph renders the canonical representative . for example :    ....        ? -",
    "n = 5 ,           graph = [ [ 0,1,0,0,0 ] , [ 1,0,1,0,1 ] , [ 0,1,0,1,0 ] , [ 0,0,1,0,1 ] , [ 0,1,0,1,0 ] ] ,           canonic_graph(n , adj_matrix , adj_matrix , graph , perm , canonic ) .",
    "n        = 5 ,        graph    = [ [ 0,1,0,0,0],[1,0,1,0,1],[0,1,0,1,0],[0,0,1,0,1],[0,1,0,1,0 ] ] ,        canonic = [ [ 0,0,0,0,1],[0,0,0,1,1],[0,0,0,1,1],[0,1,1,0,0],[1,1,1,0,0 ] ] ,        perm     = [ 1 , 5 , 2 , 4 , 3 ]    ....    a compact version of ` canonic_graph/6 ` is also included in ` pl - nauty `  in the form of the predicate ` canonic_graph/3 ` . the predicate ` canonic_graph/3 ` takes the form ` canonic_graph(nvert , graph , canonic ) ` and it is equivalent to ` canonic_graph(nvert , adj_matrix , adj_matrix , graph ,  _ , canonic ) ` .",
    "for example :    ....        ?",
    "- n = 5 ,           graph = [ [ 0,1,0,0,0 ] , [ 1,0,1,0,1 ] , [ 0,1,0,1,0 ] , [ 0,0,1,0,1 ] , [ 0,1,0,1,0 ] ] ,           canonic_graph(n , graph , canonic ) .",
    "n        = 5 ,        graph    = [ [ 0,1,0,0,0],[1,0,1,0,1],[0,1,0,1,0],[0,0,1,0,1],[0,1,0,1,0 ] ] ,        canonic = [ [ 0,0,0,0,1],[0,0,0,1,1],[0,0,0,1,1],[0,1,1,0,0],[1,1,1,0,0 ] ]    ....      the ` isomorphic_graphs/6 ` predicate tests for graph isomorphism .",
    "it takes the form : ` isomorphic_graphs(n , graph1 , graph2 , perm , canonic , opts ) ` and tests if the two ` n ` vertex input graphs , ` graph1 ` and ` graph2 ` are isomorphic via a permutation ` perm ` .",
    "if they are then ` canonic ` is the canonical form they share .",
    "the predicate takes a list ` opts ` of options to customize the behavior of this predicate .",
    "options include any of the following : ` fmt1(fmt1 ) ` the format of ` graph1 ` , ` fmt2(fmt2 ) ` the format of ` graph2 ` , ` cgfmt(cgfmt ) ` the format of ` canonic ` . in the case",
    "where ` graph1 ` and ` graph2 ` are not isomorphic the predicate will fail silently .",
    "for example :    ....        ?",
    "- n = 5 ,           graph1 = [ [ 0,1,0,1,1 ] , [ 1,0,1,0,0 ] , [ 0,1,0,1,0 ] , [ 1,0,1,0,1 ] , [ 1,0,0,1,0 ] ] ,           graph2 = [ [ 0,1,0,1,1 ] , [ 1,0,1,0,0 ] , [ 0,1,0,0,1 ] , [ 1,0,0,0,1 ] , [ 1,0,1,1,0 ] ] ,           isomorphic_graphs(n , graph1 , graph2 , perm , canonic , [ ] ) .",
    "n        = 5 ,        graph1   = [ [ 0,1,0,1,1],[1,0,1,0,0],[0,1,0,1,0],[1,0,1,0,1],[1,0,0,1,0 ] ] ,        graph2   = [ [ 0,1,0,1,1],[1,0,1,0,0],[0,1,0,0,1],[1,0,0,0,1],[1,0,1,1,0 ] ] ,        perm     = [ 1,2,3,5,4 ] ,        canonic = [ [ 0,1,0,1,0],[1,0,0,0,1],[0,0,0,1,1],[1,0,1,0,1],[0,1,1,1,0 ] ]          ? - n = 5 ,           graph1 = [ [ 0,1,1,0,1],[1,0,0,0,1],[1,0,0,0,0],[0,0,0,0,0],[1,1,0,0,0 ] ] ,           graph2 = [ [ 0,1,0,0,1],[1,0,1,1,0],[0,1,0,0,1],[0,1,0,0,1],[1,0,1,1,0 ] ] ,           isomorphic_graphs(n , graph1 , graph2 , perm , canonic , [ ] )",
    ".          false .    ....",
    "most of the core predicates of ` pl - nauty ` and many of the examples described above are based on the ` densenauty/8 ` predicate .",
    "the ` densenauty/8 ` predicate is a direct interface to the ` nauty `  c library function of the same name .",
    "the predicate is called in a similar fashion to its counterpart in the ` nauty `  c library .",
    "a complete documentation of ` densenauty/8 ` may be found in the source code provided with ` pl - nauty ` , and in the ` nauty `  user guide @xcite .",
    "briefly , the predicate ` densenauty/8 ` takes the following form :    ....    densenauty(nvert , graph , labeling , partition ,                permutation , orbits , canonic , opts )    ....    where ` nvert ` is the number of vertices in the input graph , ` graph ` is the input graph , ` labeling ` , ` partition ` and ` orbits ` are the labeling , partition and orbits of the input graph , as described in the ` nauty `  user guide @xcite , ` canonic ` is the canonical form of the input graph , and ` permutation ` is the permutation of the nodes of the input graph which may be applied to obtain the canonic representative . the last argument",
    ", ` opts ` is used to modify the behavior of ` densenauty ` .",
    "for example , it may be used to control the format of the input graph , and canonic representative .",
    "the ` nauty `  graph automorphism tool comes with a collection of applications called ` gtools ` , that implement an assortment of common tasks that ` nauty `  is typically applied to . during installation ( of ` nauty ` ) these are compiled into a set of command line applications .",
    "these applications can not simply be loaded using the foreign language interface .",
    "each application is like a black box .",
    "we do not wish to access its source code .",
    "one straightforward approach to integrate ` gtools `  with prolog is to run each such application from within prolog , write its output to a temporary file , and then to read the file , and continue with the task that the prolog program is addressing .",
    "a more elegant solution makes use of unix pipes to skip that intermediate step of writing and reading from files .",
    "the output is directly read / written via prolog .",
    "the voodoo is using pipes ( which are like in - memory files ) .",
    "we have implemented a prolog library called ` pl - gtools ` , which provides a framework for calling the applications in ` gtools `  using unix pipes .",
    "the ` pl - gtools `  framework supports two types of ` gtools `  applications which take any number of command line arguments and write their output to standard output .",
    "the first type does not require any input , and the second requires some form of input ( from standard input ) .",
    "we present a general template to support the two `` sides '' of the pipe : a child predicate ( which typically executes a ` gtools `  command ) , and a parent predicate ( which typically reads the output of the child ) .",
    "the framework includes predicates : ` gtools_exec/6 ` and ` gtools_fetch/2 ` , and two additional predicates for applications which respectively require uni- and bi - directional communication : ` gtools_fork_exec/2 ` and ` gtools_fork_exec_bidi/2 ` . for uni - directional communication , a call to ` gtools_fork_exec(parent , child ) `",
    "will fork and execute the ` parent ` goal as the parent process and the ` child ` goal as the child process .",
    "it assumes that both ` parent ` and ` child ` take an additional argument which is unified with the corresponding input / output streams ( to support communication from child to parent ) . for bi - directional communication ,",
    "a call to ` gtools_fork_exec_bidi(parent , child ) ` is exactly the same , except that the ` parent ` and ` child ` take two additional arguments to support two way communication .",
    "the predicate ` gtools_fetch/2 ` reads the next line from the output stream of the child and converts it to an atom .",
    "when the end of the stream is reached then the predicate fails .",
    "a call to ` gtools_exec/6 ` takes the form ` gtools_exec(nautydir , cmd , args , inputstream , outputstream , errorstream ) ` where : ` nautydir ` is the directory in the file system which contains the ` gtools `  applications , ` cmd ` is the name of the ` gtools `  command that we which to execute , and ` args ` is its argument list .",
    "the final three arguments specify the standard input , output and error streams .",
    "the call to ` gtools_exec/6 ` invokes the ` exec/1 ` predicate of swi - prolog , replacing the current process image with ` cmd ` and its ` args ` .",
    "we present two example uses of ` pl - gtools ` .",
    "the first , calls ` geng ` from ` gtools ` , which iterates over all non - isomorphic graphs with a given number of vertices . the second , calls ` shortg ` from ` gtools ` , which reduces a set of graphs to non - isomorphic members .",
    "this example illustrates how the framework is applied for an application which reads no input .",
    "the ` gtools `  application ` geng ` receives an argument ` n ` and outputs one line for each non - isomorphic graph with @xmath2 vertices .",
    "its prolog implementation consists of three predicates : ` geng/2 ` , ` parent_geng/2 ` and ` child_geng/2 ` .",
    "the predicate ` geng/2 ` is the main predicate which backtracks over all results of the ` gtools ` application .",
    "the predicates ` parent_geng/2 ` and ` child_geng/2 ` implement respectively the parent and child sides of the pipe .    ....",
    "geng(n , graph ) : -               gtools_fork_exec(geng : parent_geng(graph ) , geng : child_geng(n ) ) .",
    "parent_geng(graph , read ) : -               gtools_fetch(read , graph ) .",
    "child_geng(n , stream ) : -               gtools_exec(`nauty26r3 ' , geng , [ ` -q ' , n ] , _ , stream , _ ) .        ....      this example illustrates how the framework is applied for an application which reads from standard input .",
    "the ` shortg ` application reads a list of graphs in the ` graph6 ` format  @xcite from standard input , and removes all isomorphic duplicates , writing to standard output .",
    "it can be applied as follows :    after integrating ` shortg ` with ` pl - gtools `  it could be called from prolog like so :    ....        ?",
    "- inputgraphs = [ ` dro',`dbg',`ddw ' ,                          ` dlo',`d[s',`dps ' ,                          ` dyc',`dqk',`dmg ' ,                          ` dkk',`dhc',`duw ' ] , % a list of graphs in graph6 format           shortg(inputgraphs , outputgraphs ) .",
    "% the call to shortg          inputgraphs   = [ ` dro',`dbg',`ddw',`dlo',`d[s',`dps ' , ` dyc',`dqk ' | ... ] ,        outputgraphs = [ ` dqk ' ] .",
    "....    the implementation of ` shortg ` in prolog consists of three predicates and is very similar to that for ` geng ` except that communication between the child and parent processes is bi - directional .",
    "shortg(in , out ) : -            gtools_fork_exec_bidi(shortg : parent_shortg(in , out ) , shortg : child_shortg ) .",
    "parent_shortg(in , out , pread , pwrite ) : -               maplist(writeln(pwrite ) , in ) ,               flush_output(pwrite ) ,               close(pwrite ) ,               findall(o , gtools_fetch(pread , o ) , out ) ,               close(pread ) .",
    "child_shortg(cread , cwrite ) : -               gtools_exec(`nauty26r3 ' , shortg , [ ` -q ' ] , cread , cwrite , _ ) .    ....    in this example , ` shortg/2 ` takes two arguments : ` in ` a list of input graphs in the ` graph6 ` format , to be reduced modulo isomorphism , and ` out ` will be unified with the set of reduced graphs .",
    "the predicate calls the ` gtools_fork_exec_bidi/2 ` predicate .",
    "pipes are opened to setup two way communication between the parent and child .",
    "two additional predicates are implemented : one for the parent process and one for the child process .",
    "each predicate takes , as its last two arguments the read and write ends of the pipes , so communication may be established . in our case , the parent writes the set of input graphs to the write end of the pipe , and then reads the results from the read end of the child s pipe .",
    "the child calls ` gtools_exec/6 ` , and executes ` shortg/2 ` .",
    "a short overview of some technical details regarding ` pl - nauty `  and ` pl - gtools `  follows .",
    "the package containing ` pl - nauty `  and ` pl - gtools `  is available for download from the ` pl - nauty `  homepage at : http://www.cs.bgu.ac.il/~frankm/plnauty .",
    "the package contains a ` readme ` file , which contains usage and installation instructions , as well as an ` examples ` directory containing the examples discussed in this paper .",
    "the c code for ` pl - nauty `  may be found in the ` src ` directory .",
    "also in the ` src ` directory are the two module files for ` pl - nauty `  and ` pl - gtools ` .    both ` pl - nauty `  and ` pl - gtools `  were compiled and tested on debian linux and ubuntu linux using the 7.x.x branch of swi - prolog .",
    "it is important to mention that both ` pl - nauty `  and ` pl - gtools `  contain linux specific features , and are oriented towards swi - prolog .",
    "it should also be noted that ` pl - nauty `  is not thread - safe , for reasons of performance . if you require a thread - safe version of ` pl - nauty `  you should synchronize calls to the predicates of the ` pl - nauty `  module .",
    "we have presented , and made available , a prolog interface to the core components of the ` nauty `  graph - automorphism tool  @xcite which is often cited as `` the world s fastest isomorphism testing program '' ( see for example http://www3.cs.stonybrook.edu/~algorith/implement/nauty/implement.shtml ) .",
    "the contribution of the paper is in the utility of the tool which we expect to be widely used .",
    "the tool facilitates programming with the strengths of two paradigms : logic programming for solving graph search problems on the one hand , and efficient pruning of ( intermediate ) solutions modulo graph isomorphism , on the other .",
    "it enables prolog programs which address graph search problems to apply ` nauty `  natively , through prolog , in the process of graph search and enumeration .",
    "graphs may be generated non - deterministically and may be canonized deterministically .      , frank , m. , itzhakov , a. , and miller , a. 2016 .",
    "computing the ramsey number r(4,3,3 ) using abstraction and symmetry breaking .",
    ", 119 . also in : proceedings of the thirteenth international conference on integration of artificial intelligence and operations research techniques in constraint programming .    ,",
    "miller , a. , prosser , p. , and stuckey , p.  j. 2013 . breaking symmetries in graph representation . in _ proceedings of the 23rd international joint conference on artificial intelligence , beijing , china _ , f.  rossi , ed . ijcai / aaai ."
  ],
  "abstract_text": [
    "<S> this paper presents the ` pl - nauty `  library , a prolog interface to the ` nauty `  graph - automorphism tool . adding the capabilities of ` nauty `  to prolog combines the strength of the `` generate and prune '' approach that is commonly used in logic programming and constraint solving , with the ability to reduce symmetries while reasoning over graph objects . </S>",
    "<S> moreover , it enables the integration of ` nauty `  in existing tool - chains , such as sat - solvers or finite domain constraints compilers which exist for prolog . </S>",
    "<S> the implementation consists of two components : ` pl - nauty ` , an interface connecting ` nauty ` s c library with prolog , and ` pl - gtools ` , a prolog framework integrating the software component of ` nauty ` , called ` gtools ` , with prolog . </S>",
    "<S> the complete tool is available as a swi - prolog module . </S>",
    "<S> we provide a series of usage examples including two that apply to generate ramsey graphs . </S>",
    "<S> this paper is under consideration for publication in tplp . </S>"
  ]
}