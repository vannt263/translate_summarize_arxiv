{
  "article_text": [
    "the decoding algorithms for the best known classes of error - correcting code to date , namely concatenated (  turbo \" ) codes @xcite and low - density parity check ( ldpc ) codes @xcite , have been shown to be instances of a much more general algorithm called the _ sum - product _ ( sp ) algorithm @xcite .",
    "this algorithm solves the general problem of marginalizing a product of functions which take values in a semiring @xmath0 . in the communications context , @xmath0 is equal to @xmath1 and the maximization of each marginal function minimizes the error rate on a symbol - by - symbol basis .",
    "it was also shown that many diverse situations may allow the use of sp based reception @xcite , including joint iterative equalization and decoding ( or _ turbo equalization _ ) @xcite and joint source - channel decoding @xcite .",
    "recently , a linear - programming ( lp ) based approach to decoding linear ( and especially ldpc ) codes was developed for binary @xcite and nonbinary coding frameworks @xcite .",
    "the concept of _ pseudocodeword _ proved important in the performance analysis of both lp and sp based decoders @xcite . also , linear - programming decoders for irregular repeat - accumulate ( ira ) codes and turbo codes were described in @xcite .",
    "regarding applications beyond coding , an lp - based method for low - complexity joint equalization and decoding of ldpc coded transmissions over the magnetic recording channel was proposed in @xcite .    in this paper",
    "it is shown that the problem of maximizing a product of @xmath0-valued functions is amenable to an approximate ( suboptimal ) solution using an lp relaxation , under two conditions : first , that the semiring @xmath0 is equal to a subset of @xmath1 , and second , that all non - pendant factor nodes are indicator functions for a local behaviour .",
    "fortunately , these conditions are satisfied by almost all practical communication receiver design problems .",
    "interestingly , the lp exhibits a `` separation effect '' in the sense that pendant factor nodes in the factor graph contribute the cost function , and non - pendant nodes determine the lp constraint set .",
    "this distinction is somewhat analagous to the case of sp - based reception where pendant factor nodes contribute initial messages exactly once , and all other nodes update their messages periodically .",
    "our lp receiver generalizes the lp _ decoders _ of @xcite .",
    "it is proved that both the sp and lp based receivers are inhibited by the same phenomenon which we characterize as a set of _ pseudoconfigurations _ ; this is not intuitively obvious since the sp receiver derives from an attempt to minimize error rate on a symbol - by - symbol basis , while the lp receiver derives from an attempt to minimize the configuration error rate .",
    "we begin by introducing some definitions and notation .",
    "suppose that we have variables @xmath2 , @xmath3 , where @xmath4 is a finite set , and the variable @xmath2 lies in the finite set @xmath5 for each @xmath3 .",
    "let @xmath6 ; then @xmath7 is called a _ configuration _ , and the cartesian product @xmath8 is called the _",
    "configuration space_. suppose now that we wish to find that configuration @xmath9 which maximizes the product of real - valued functions @xmath10 where @xmath11 is a finite set , @xmath12 and @xmath13 for each @xmath14 .",
    "we define the _ optimum _ configuration @xmath15 to be that configuration @xmath9 which maximizes ( [ eq : factorization_of_global_function ] ) .",
    "the function @xmath16 is called the _ global function _",
    "@xcite .    the factor graph for the global function @xmath16 and",
    "its factorization ( [ eq : factorization_of_global_function ] ) is a ( bipartite ) graph defined as follows .",
    "there is a variable node for each variable @xmath17 ( @xmath3 ) and a factor node for each factor @xmath18 ( @xmath14 ) .",
    "an edge connects variable node @xmath17 to factor node @xmath18 if and only if @xmath17 is an argument of @xmath18 .",
    "note that for any @xmath19 , @xmath20 is the set of @xmath21 for which @xmath17 is an argument of @xmath18 .",
    "also , for any @xmath21 , the set of @xmath19 for which @xmath17 is an argument of @xmath18 is denoted @xmath22 .",
    "the _ degree _ of a node @xmath23 , denoted @xmath24 , is the number of nodes to which it is joined by an edge .",
    "any node @xmath23 for which @xmath25 is said to be _",
    "pendant_.    define @xmath26 i.e. , @xmath27 is the set of @xmath3 for which variable node @xmath2 is connected to a pendant factor node .",
    "then , for @xmath28 , define @xmath29 we assume that the function @xmath30 is positive - valued for each @xmath28 . also , denoting the cartesian product @xmath31 , we define the projection @xmath32 also , we adopt the notation @xmath33 for elements of @xmath34 .    next",
    "define @xmath35 .",
    "so , without loss of generality we may write @xmath36 now , assume that all factor nodes @xmath37 , @xmath38 , are indicator functions for some local behaviour @xmath39 , i.e. , @xmath40 \\quad \\forall j\\in { { \\mathcal{l}}}\\ ] ] where the indicator function for the logical predicate @xmath41 is defined by @xmath42 = \\left\\ { \\begin{array}{cc } 1 & \\textrm { if } p \\textrm { is true } \\\\ 0 & \\textrm { otherwise . }",
    "\\end{array}\\right.\\ ] ] note that we write any @xmath43 as @xmath44 , i.e. , @xmath45 is indexed by @xmath20 .",
    "also we define the _ global behaviour _ @xmath46 as follows : for any @xmath47 , we have @xmath48 if and only if @xmath49 for every @xmath50 .",
    "the configuration @xmath9 is said to be _",
    "valid _ if and only if @xmath51 .",
    "we assume that the mapping @xmath52 is injective on @xmath46 , i.e. , if @xmath53 and @xmath54 , then @xmath55 .",
    "this corresponds to a ` well - posed ' problem . note that in the communications context",
    ", since all non - pendant factor nodes are indicator functions , observations may only be contributed through the set of pendant factor nodes .",
    "therefore , failure of the injectivity property in the communications context would mean that one particular set of channel inputs could correspond to two different transmit information sets , which would reflect badly on system design .",
    "so we have @xmath56 denote @xmath57 for @xmath3 , and @xmath58 .",
    "now , for each @xmath3 , define the mapping @xmath59 by @xmath60 ) _",
    "{ \\gamma \\in a_i } \\ ; .\\ ] ] building on these mappings , we also define @xmath61 according to @xmath62 we note that @xmath63 is injective .",
    "now , for vectors @xmath64 , we adopt the notation @xmath65 in particular , we define the vector @xmath66 by setting @xmath67 for each @xmath68 , @xmath69 .",
    "this allows us to develop the formulation of the optimum configuration as @xmath70 note that the optimization has reduced to the maximization of an inner product of vectors , where the first vector derives only from observations ( or  channel information \" ) and the second vector derives only from the global behaviour ( the set of valid configurations ) .",
    "this problem may then be recast as a linear program @xmath71 where @xmath72 and the maximization is over the convex hull of all points corresponding to valid configurations : @xmath73",
    "in this section we define a lower - complexity lp to solve for the optimum configuration , and prove that its performance is equivalent to the original . here , for each @xmath21 , let @xmath74 be an arbitrary element of @xmath5 , and let @xmath75 ( note that for each @xmath21 , @xmath76 , otherwise @xmath2 is not a ` variable ' ) .",
    "denote @xmath77 for every @xmath3 , and denote @xmath78 .",
    "then , for each @xmath3 , define the mapping @xmath79 by @xmath80 ) _",
    "{ \\gamma \\in a_i^{- } } \\ ; .\\ ] ] building on this , we also define @xmath81 according to @xmath82 we note that @xmath83 is injective .",
    "now , for vectors @xmath84 , we adopt the notation @xmath85 in particular , we define the vector @xmath86 by setting @xmath87\\ ] ] for each @xmath68 , @xmath88 .",
    "our new lp is then given by @xmath89 where @xmath90 and the maximization is over the convex hull of all points corresponding to valid configurations : @xmath91    the following proposition proves the equivalence of the original and lower - complexity linear programs .",
    "[ prop : lp_equivalence ] the linear program defined by ( [ eq : xopt_lp2])([eq : convex_hull_lp2 ] ) produces the same ( optimum ) configuration output as the linear program defined by ( [ eq : xopt_lp1])([eq : convex_hull_lp1 ] ) .    it is easy to show that the simple bijection @xmath92 defined by @xmath93 where @xmath94 which has inverse given by @xmath95 has the property that @xmath96",
    "if and only if @xmath97 . also observe that if @xmath98 , @xmath99 \\tilde{g}_i^{(\\alpha ) } \\nonumber \\\\ & = & \\sum_{\\alpha \\in { { \\mathcal{a}}}_i^{- } } \\log h_i(\\alpha ) g_i^{(\\alpha ) } - \\log h_i(\\alpha_i ) [ 1 - g_i^{(\\alpha_i ) } ] \\nonumber \\\\ & = & \\boldsymbol{\\lambda } { { \\mbox{\\boldmath $ g$}}}^t- \\log h_i(\\alpha_i )   \\label{eq : cost_fn_equivalence}\\end{aligned}\\ ] ] i.e. the bijection @xmath100 preserves the cost function up to an additive constant . taken together , these two facts imply that @xmath101 maximizes @xmath102 over @xmath103 if and only if @xmath98 maximizes @xmath104 over @xmath105 .",
    "this proves the result , and justifies the use of the notation @xmath15 in ( [ eq : xopt_lp2 ] ) .",
    "to reduce complexity of the lp , we introduce auxiliary variables whose constraints , along with those of the elements of @xmath84 , will form the relaxed lp problem .",
    "we denote these auxiliary variables by @xmath106 and we form the following vector @xmath107 for each @xmath108 , let @xmath109 be an arbitrary element of @xmath110",
    ". the constraints of the relaxed lp problem are then @xmath111 @xmath112 @xmath113 and @xmath114    constraints  ( [ eq : equation - polytope-4])-([eq : equation - polytope-7 ] ) form a polytope which we denote by @xmath115 .",
    "the maximization of the objective function @xmath102 over @xmath115 forms the relaxed lp problem .",
    "observe that the further constraints @xmath116 @xmath117 and @xmath118 follow from the constraints  ( [ eq : equation - polytope-4])-([eq : equation - polytope-7 ] ) , for any @xmath119 .",
    "the receiver algorithm works as follows .",
    "first , we say a point in a polytope is _ integral _ if and only if all of its coordinates are integers . if the lp solution @xmath120 is an integral point in @xmath115 , the output is the configuration @xmath121 ( we shall prove in the next section that this output is indeed in @xmath46 ) .",
    "this configuration may be equal to the optimum configuration ( we call this ` correct reception ' ) or it may not be ( we call this ` incorrect reception ' ) . of course , in the communications context , we are usually only interested in a subset of the configuration symbols , namely the information bits . if the lp solution is not integral , the receiver reports a ` receiver failure ' .",
    "note that in this paper , we say that the receiver makes a _ reception error _ when the receiver output is not equal to the correct configuration ( this could correspond to a ` receiver failure ' , or to an ` incorrect reception ' ) .",
    "we next define another linear program , and prove that its performance is equivalent to that defined in section [ sec : efficient_lp ] .",
    "this new program is more computationally complex than that defined previously , but ( due to its equivalence and simplicity of description ) is more useful for theoretical work . for this",
    "we define @xmath122 and @xmath123 according to @xmath124 again , @xmath125 is injective . for vectors",
    "@xmath126 , we denote @xmath127 and @xmath128 , where @xmath129 for each @xmath3 .",
    "the new lp optimizes the cost function @xmath104 over the polytope @xmath130 defined with respect to variables @xmath131 and @xmath132 , the constraints ( [ eq : equation - polytope-4 ] ) and ( [ eq : equation - polytope-5 ] ) , and the following single constraint : @xmath133 note that ( [ eq : equation - polytope-1 ] ) , together with the constraints @xmath134 and @xmath135 follow from the constraints  ( [ eq : equation - polytope-4 ] ) , ( [ eq : equation - polytope-5 ] ) and ( [ eq : equation - polytope - theoretical ] ) , for any @xmath136 .    in this case ,",
    "the receiver output is equal to the configuration @xmath137 in the case where the lp solution @xmath138 is an integral point in @xmath130 ( again , this output is in @xmath46 ) , and reports a ` receiver failure ' if the lp solution is not integral .",
    "the following theorem ensures the equivalence of the two linear programs , and also assures the _ optimum certificate _ property , i.e. , if the receiver output is a configuration , then it is the optimum configuration .",
    "[ prop : lp_equivalence_2 ] the linear program defined by ( [ eq : equation - polytope-4 ] ) , ( [ eq : equation - polytope-5 ] ) and ( [ eq : equation - polytope - theoretical ] ) produces the same output ( configuration or receiver failure ) as the linear program defined by ( [ eq : equation - polytope-4])([eq : equation - polytope-7 ] ) . also , in the case of configuration output , if the receiver output is a configuration , then it is the optimum configuration , i.e. , @xmath139 .",
    "it is straightforward to show that the mapping @xmath140 defined by @xmath141 and with inverse @xmath95 is a bijection from one polytope to the other ( i.e. @xmath84 satisfies ( [ eq : equation - polytope-4])([eq : equation - polytope-7 ] ) for some vector @xmath132 if and only if @xmath126 with @xmath142 satisfies ( [ eq : equation - polytope-4 ] ) , ( [ eq : equation - polytope-5 ] ) and ( [ eq : equation - polytope - theoretical ] ) for the same vector @xmath132 ) .",
    "also , since @xmath142 implies @xmath98 , ( [ eq : cost_fn_equivalence ] ) implies that the bijection @xmath143 preserves the cost function up to an additive constant .",
    "next , we prove that for every configuration @xmath51 , there exists @xmath132 such that @xmath144 .",
    "let @xmath51 , and define @xmath145 letting @xmath96 and @xmath146 , it is easy to check that @xmath119 and @xmath136 ( and that in fact @xmath147 ) .",
    "this property ensures that every valid configuration @xmath51 has a  representative \" in the polytope , and thus is a candidate for being output by the receiver .",
    "next , let @xmath119 and let @xmath126 be such that @xmath148 .",
    "suppose that all of the coordinates of @xmath132 are integers .",
    "then , by ( [ eq : equation - polytope-4 ] ) and ( [ eq : equation - polytope-5 ] ) , for any @xmath149 we must have @xmath150 for some @xmath151 .",
    "now we note that for any @xmath3 , @xmath152 , if @xmath153 then ( using ( [ eq : equation - polytope - theoretical ] ) ) @xmath154 and thus @xmath153 .",
    "therefore , there exists @xmath9 such that @xmath155 therefore , @xmath7 is a valid configuration ( @xmath51 ) .",
    "also we may conclude from ( [ eq : starstar ] ) that @xmath156 and therefore @xmath157 .",
    "also , from the definition of the mapping @xmath143 , we have @xmath158 .    summarizing these results , we conclude that @xmath159 optimizes the cost function @xmath104 over @xmath130 and is integral if and only if @xmath160 optimizes the cost function @xmath102 over @xmath115 and is integral , where @xmath161 and @xmath162 .",
    "thus both lp receivers output either a receiver failure , or the optimum configuration , and have the same performance .",
    "the lp receiver of section [ sec : efficient_lp ] has lower complexity and is suitable for implementation ( e.g. for the program of section [ sec : equalization_decoding ] ) ; however , for theoretical work the lp of section [ sec : efficient_lp_theoretical ] is more suitable ( we shall use this polytope throughout section [ sec : pcfs ] ) .",
    "in this section , we prove a connection between the failure of the lp and sp receivers based on _ pseudoconfiguration _ concepts .      a _ linear - programming pseudoconfiguration _",
    "( lp pseudoconfiguration ) is a point @xmath163 in the polytope @xmath130 with rational coordinates .",
    "note that , since the coefficients of the lp are rational , the lp output must be the lp pseudoconfiguration which minimizes the cost function .",
    "we next define what is meant by a finite cover of a factor graph .",
    "let @xmath164 be a positive integer , and let @xmath165 .",
    "let @xmath166 be the factor graph corresponding to the global function @xmath167 and its factorization given in ( [ eq : factorization_of_global_function ] ) .",
    "a _ cover configuration _ of degree @xmath164 is a vector @xmath168 where @xmath169 for each @xmath3 .",
    "define @xmath170 as the following function of the cover configuration @xmath171 of degree @xmath164 : @xmath172 where , for each @xmath19 , @xmath173 , @xmath174 is a permutation on the set @xmath175 , and for each @xmath19 , @xmath176 , @xmath177 a _ cover _ of the factor graph @xmath166 , of degree @xmath164 , is a factor graph for the global function @xmath170 and its factorisation ( [ eq : cover_graph_factorization ] ) . in order to distinguish between different factor node labels",
    ", we write ( [ eq : cover_graph_factorization ] ) as @xmath178 where @xmath179 for each @xmath19 , @xmath176 .",
    "it may be seen that a cover graph of degree @xmath164 is a graph whose vertex set consists of @xmath164 copies of @xmath2 ( labelled @xmath180 ) and @xmath164 copies of @xmath37 ( labelled @xmath181 ) , such that for each @xmath19 , @xmath173 , the @xmath164 copies of @xmath2 and the @xmath164 copies of @xmath37 are connected in a one - to - one fashion determined by the permutations @xmath182 .",
    "we define the _ cover behaviour _ @xmath183 as follows .",
    "the cover configuration @xmath171 lies in @xmath183 if and only if @xmath184 for each @xmath19 , @xmath176 .    for any @xmath185 ,",
    "a _ graph - cover pseudoconfiguration _ is a valid cover configuration ( i.e. one which lies in the behaviour @xmath183 ) .    for any graph - cover pseudoconfiguration",
    ", we also define the _ graph - cover pseudoconfiguration vector _",
    "@xmath186 according to @xmath187 and @xmath188 for each @xmath21 , @xmath189 . finally , we define the _ normalized graph - cover pseudoconfiguration vector _ @xmath126 by @xmath190 .      in this section",
    ", we show the equivalence between the set of lp pseudoconfigurations and the set of graph - cover pseudoconfigurations .",
    "the result is summarized in the following theorem .",
    "[ thm : pcw_equivalence ] there exists an lp pseudoconfiguration @xmath163 if and only if there exists a graph - cover pseudoconfiguration with normalized pseudoconfiguration vector @xmath131 .",
    "suppose @xmath171 is a graph - cover pseudoconfiguration for some cover of degree @xmath164 of the factor graph , and @xmath131 is its normalized graph - cover pseudoconfiguration vector .",
    "then , @xmath191 for all @xmath3 , @xmath69 .",
    "next define @xmath132 according to @xmath192 for all @xmath149 , @xmath193 .",
    "then it is easily seen that ( [ eq : equation - polytope-4 ] ) , ( [ eq : equation - polytope-5 ] ) and ( [ eq : equation - polytope - theoretical ] ) are satisfied , and so @xmath194 .    to prove the other direction , suppose @xmath194 .",
    "denote by @xmath164 the lowest common denominator of the ( rational ) variables @xmath195 for @xmath50 , @xmath196 .",
    "define @xmath197 for @xmath50 , @xmath196 ; these must all be nonnegative integers .",
    "also define @xmath198 for all @xmath3 , @xmath69 ; these must all be nonnegative integers by ( [ eq : equation - polytope - theoretical ] ) .",
    "we now construct a cover graph of degree @xmath164 as follows .",
    "begin with @xmath164 copies of vertex @xmath2 ( labelled @xmath180 ) and @xmath164 copies of vertex @xmath37 ( labelled @xmath181 ) , for @xmath3 , @xmath14 .",
    "then proceed as follows :    * label @xmath199 copies of @xmath2 with the value @xmath200 , for each @xmath3 , @xmath69 . by ( [ eq : sum_g_equals_1 ] )",
    ", all copies of @xmath2 are labelled .",
    "* label @xmath201 copies of @xmath37 with the value @xmath202 , for every @xmath149 , @xmath193 . by ( [ eq : equation - polytope-5 ] )",
    ", all copies of @xmath37 are labelled . * next , let @xmath203 denote the set of copies of @xmath2 labelled with the value @xmath200 , for @xmath21 , @xmath189 . also , for all @xmath50 , @xmath173 , @xmath189 , let @xmath204 denote the set of copies of @xmath37 whose label @xmath202 satisfies @xmath205 .",
    "the vertices in @xmath203 and the vertices in @xmath204 are then connected by edges in an arbitrary one - to - one fashion , for every @xmath50 , @xmath173 , @xmath189 .",
    "+ numerically , this connection is always possible because @xmath206 for every @xmath50 , @xmath173 , @xmath69 .",
    "here we have used  ( [ eq : equation - polytope - theoretical ] ) .",
    "finally , for each @xmath68 and @xmath207 satisfying @xmath208 , the @xmath164 copies of @xmath2 are connected to the @xmath164 copies of @xmath37 in an arbitrary one - to - one fashion .",
    "it is easy to check that the resulting graph is a cover graph for the original factorization .",
    "therefore , this vertex labelling yields a graph - cover pseudoconfiguration .",
    "in this section we consider an example application where we use the above framework to design an lp receiver for a system using binary coding and binary phase - shift keying ( bpsk ) modulation over a frequency selective channel ( with memory @xmath209 ) with additive white gaussian noise ( awgn ) .",
    "information - bearing data are encoded to form codewords of the binary code @xmath210 where @xmath211 is the code s @xmath212 _ parity - check matrix _ over @xmath213 .",
    "denote the set of code bit indices and parity - check indices by @xmath214 and @xmath215 respectively .",
    "we factor the indicator function for the code into factors corresponding to each local parity check : for @xmath216 , define the single - parity - check code over @xmath213 by @xmath217 where @xmath218 is the support of the @xmath219-th row of @xmath211 for each @xmath216 , and the summation is over @xmath213 .",
    "thus @xmath220 if and only if @xmath221 for each @xmath216 .",
    "the bpsk modulation mapping @xmath222 , which maps from @xmath213 to @xmath1 , is given by @xmath223 and @xmath224 .",
    "the channel has @xmath225 taps @xmath226 and the received signal for the communication model may be written as @xmath227 where @xmath228 is a zero - mean complex gaussian random variable with variance @xmath229 .",
    "we adopt a state - space ( trellis ) representation for the channel , with state space @xmath230 ; also let @xmath231 .",
    "the local behaviour ( or trellis edge set ) for the state - space model , denoted @xmath232 , is assumed to be time - invariant , although extension to the case of time - variant channel is straightforward . for simplicity",
    "we assume that the initial and final states of the channel are not known at the receiver . for @xmath233 , let @xmath234 , @xmath235 , @xmath236 and @xmath237 denote the channel input , output , start state and end state respectively .",
    "thus if we set @xmath238 and adopt the notation @xmath239 , we may have @xmath240 , @xmath241 , @xmath242 , and @xmath243 .",
    "also let @xmath244 .",
    "the structure of the lp may be written as follows ( we use the efficient lp defined in section [ sec : efficient_lp ] ) .",
    "the variables of the lp are and @xmath245 serve as indicator functions for the single - parity - check codewords and the channel outputs respectively . ]",
    "@xmath246 @xmath247 @xmath248 and the lp constraints are ( here @xmath249 ) @xmath250 and @xmath251 which follow from ( [ eq : equation - polytope-4 ] ) , @xmath252 and @xmath253 from ( [ eq : equation - polytope-5 ] ) , @xmath254 from ( [ eq : equation - polytope-6 ] ) , and @xmath255 and @xmath256 from ( [ eq : equation - polytope-7 ] ) .    also , the lp cost function is @xmath257 where we have , for @xmath258 , @xmath259 , @xmath260 note that in this application , the variables @xmath261 , together with the constraint ( [ eq : sumg_equals_sumq ] ) , would be removed due to their redundancy , and the variables @xmath262 used directly in the cost function ( [ eq : cost_fn_turbo_eq ] ) .",
    "the resulting lp is capable of joint equalization and decoding , and has strong links ( via theorems [ prop : lp_equivalence_2 ] and [ thm : pcw_equivalence ] ) to the corresponding `` turbo equalizer '' based on application of the sum - product algorithm to the same factorization of the global function .",
    "the author would like to acknowledge the support of the institute of advanced studies , university of bologna ( isa - esrf fellowship ) ."
  ],
  "abstract_text": [
    "<S> it is shown that any communication system which admits a sum - product ( sp ) receiver also admits a corresponding linear - programming ( lp ) receiver . </S>",
    "<S> the two receivers have a relationship defined by the local structure of the underlying graphical model , and are inhibited by the same phenomenon , which we call _ </S>",
    "<S> pseudoconfigurations_. this concept is a generalization of the concept of _ pseudocodewords _ for linear codes . </S>",
    "<S> it is proved that the lp receiver has the ` optimum certificate ' property , and that the receiver output is the lowest cost pseudoconfiguration . </S>",
    "<S> equivalence of graph - cover pseudoconfigurations and linear - programming pseudoconfigurations is also proved . </S>",
    "<S> while the lp receiver is generally more complex than the corresponding sp receiver , the lp receiver and its associated pseudoconfiguration structure provide an analytic tool for the analysis of sp receivers . </S>",
    "<S> as an example application , we show how the lp design technique may be applied to the problem of joint equalization and decoding . </S>"
  ]
}