{
  "article_text": [
    "we have developed the program diana ( diagram analyser ) , which allows to calculate feynman diagrams as ` input ' for further formulae manipulating languages ( mainly form @xcite ) @xcite , @xcite ( see also http://www.physik.uni-bielefeld.de/`~`tentukov/diana.html ) .",
    "meanwhile there exists a series of applications @xcite , which would not have been possible without diana .",
    "the problem is that in order to cope with the high precision experiments of present - day high energy accelerators , the corresponding calculations within the ` standard model ' ( sm ) of elementary particle physics must be of similar precision .",
    "this means , e.g. , for 1-loop approximations even for @xmath2 processes the calculation of the order of several hundred diagrams .",
    "this number increases rapidly with the number of external legs and/or the number of loops such that one is easily forced to calculate a number of diagrams of the order of thousands . for this one",
    "needs an automation to generate the diagrams and this is what diana does .    having produced the form ` input ' for each of the diagrams , in a next step the execution of the form program has to run for each diagram separately and the analytic result of all the separate calculations has to be summed up . in many cases like",
    "e.g. 1-loop @xmath2 calculations the execution time of the form jobs is still relatively short and one can just run the corresponding jobs one after the other ( e.g. in terms of ` folders ' ) . in more complicated cases , however , not only the number of diagrams increases but also the analytic calculation of the single diagrams gets more and more time consuming . here",
    "it pays to distribute the essentially independent calculations of the separate diagrams over different computers .",
    "in the project described here we have extended diana to be able to perform this task and we give detailed hints for potential users of how to apply it .",
    "the program diana , written in c , contains two ingredients :    1 .",
    "analyzer of diagrams . 2 .",
    "interpreter of a special text manipulating ( tm ) language .",
    "the analyzer reads qgraf @xcite output and passes the necessary information to the interpreter . for each diagram the interpreter performs the tm program , producing input for further evaluation ( e.g. by means of form ) of the diagram . the tm language is a tex - like language .",
    "the main goal of the language is the creation of text files .",
    "similar to the tex language , each command has to begin with an escape ( `` @xmath3 '' ) character .",
    "all lines without escape - characters are simply typed to the output file . some of the tm commands are built - in tm operators while some are user - defined functions ( returning a value ) written in the tm language itself .",
    "the main goal of parallel processing is to reduce wall - clock time which is the users waiting time .",
    "parallelism does nt come for free ; always it has some overhead with respect to serial execution , but it can significantly reduce the wall - clock time .    not every problem can be divided into parallel tasks .",
    "an example of a parallelizable problem is the multiplication of two matrices .",
    "an example of a non - parallelizable problem is the calculation of the fibonacci series ( 1,1,2,3,5 ,  ) by means of the formula @xmath4 .",
    "computations in perturbative quantum field theory involve the calculation of feynman diagrams .",
    "diana is used to produce the input for their further analytic evaluation .",
    "in fact diana needs a `` model file '' produced by the user and then generates the `` input '' in terms of formally defined vertices and propagators and of coupling parameters @xcite .",
    "this generation of feynman diagrams itself is not a good parallelizable problem .",
    "moreover , the time diana spends to produce such input is negligible with respect to the time used for the diagram evaluation .",
    "thus the present approach consists in generating input for each diagram sequentially , with the possibility to parallelize the further evaluation .",
    "after the diagrams are generated , diana may be used as a `` control center '' for further evaluations ( in parallel ) by invoking the corresponding programs and providing them the generated input . to avoid a cluster / processor overloading , each time only one job per node / processor is actually running while all the rest is queued .",
    "such an approach is known as a batch queueing system ( bqs ) .",
    "there exist a lot of such systems , both free and commercial @xcite .",
    "usually , these systems are aimed to deal with a big number of different isolated tasks , while in our case we have a huge number of nearly even tasks .",
    "there are two kinds of optimization of bqs available .",
    "the first is for the case when the average number of jobs is much larger than the number of nodes . in this case bqs",
    "usually provides various complicated methods for scheduling , message pasting , job run - time quotas and resource management in order to distribute computational resources among various tasks of all kinds . in our case",
    "all these mechanisms are not needed . secondly ,",
    "if the average number of jobs is comparable with the number of nodes , which is typical for parallel computation , a bqs should provide load balancing , process migration mechanisms and some others .    compared to that , diana has to implement parallelism in terms of job queueing , and the typical situation consists of a long queue of nearly even tasks with the same priority .",
    "evidently , we need not any load balancing . indeed , the best procedure is to send a new task to a node immediately when the node becomes free .",
    "thus , the real problem in our case is the problem of synchronization .",
    "traditionally , this problem is ignored in bqs since all jobs are assumed to be completely independent .",
    "the synchronization problem arises in true parallel systems .",
    "since we use queueing in order to implement a parallelism , the problem is of immediate interest in our case .",
    "the tm language contains several groups of operators permitting diana to make a fine co - operation with the underlying operational system ( unix ) .",
    "the operators ` \\system ( ) ` and ` \\asksystem ( ) ` execute an external command synchronously ( see sect .",
    "[ synchoperators ] ) , i.e. they wait for the command to be completed .",
    "the operator ` \\pipe ( ) ` ( sect .",
    "[ thepipe ] ) starts the external command opening an input - output channel for it , and can be used in order to extend diana in the spirit of a component model ( sect .",
    "[ compmod ] ) . the term `` component model '' ( see ,",
    "e.g. , @xcite ) means that a software system is built from `` components '' .",
    "components are high level aggregations of smaller software pieces , and provide a `` black box '' building block approach to software construction .",
    "let us now suppose that we use a cluster with disk space shared by means of nfs , and all results must be collected into one resulting file ` log.all ` , while every job produces a file ` log . # ` where ` # ` is the order number of the job . since jobs are running and completing independently of each other , we can only collect all ` log .",
    "# ` into ` log.all ` after _ all _ the jobs are finished .",
    "this leads to producing a lot of files ` log . # ` at an intermediate step , which can overload a file system .",
    "the simple solution is to allow some of the newly started jobs to be synchronized with all previously started jobs . indeed , in this case after each job we can start another `` slave '' job , which appends the ` log . # ` file containing the result of the `` master '' job to the file ` log.all ` . to obtain a correct order of the file ` log.all ` , this copying job must be performed only after all earlier jobs are finished .",
    "another problem with cluster computations is that the optimal placement of the resulting file ` log .",
    "# ` is usually a ` /tmp ` directory which is local with regard to the current node , on which the job `` number ` # ` '' is performed .",
    "but to do this , the `` slave '' copying job has to `` stick '' to the `` master '' job , i.e. it must be performed on the same node as the `` master '' job .",
    "both above mentioned problems are solved by means of so - called job attributes , see sect .",
    "[ attribs ] .",
    "yet another problem is the transaction problem , which in our case means whether a job group should be restarted on failure , and what the failure / success conditions are .",
    "sometimes it is necessary to perform some complicated job with many unreliable intermediate steps ( e.g. , breakdown of some connection ) and at the end return the exit code depending on the status of the whole transaction . in such cases",
    "it is useful to have a possibility to restart the job many times .",
    "but for conventional jobs consisting of one external program the number of restarts must not be too large in order to permit the user to kill jobs which failed",
    ".    conditions on which a job is assumed to have failed may be rather complicated , too .",
    "for example , the above mentioned copying `` slave '' job is just a quick system command `` cp '' .",
    "the probability of its failure is very low , less then the probability of some network connection failure during the commands initiation .",
    "if started , such a job , most probably , will be completed successfully independently of the diana client / server status .",
    "that is why it is reasonable to assume that the job is successful if it is started by the server . on the other hand ,",
    "the `` master '' job is expected to return _ some _ exit code , but not to be killed by some signal .",
    "for the solution of these problems see sect .",
    "[ attribs ] as well .",
    "the operator ` \\_exec ( ) ` and companions can be used to define several macros and tm functions in order to create a bqs which meets our requirements ; for a simplified example see sect .",
    "[ parascript ] .",
    "there is the possibility to build a really powerful bqs based on the ` \\_exec ( ) ` family combined with external components communicating with diana through the operator ` \\pipe ( ) `",
    ". a simplified version of this is demonstrated .",
    "the operator ` \\system(command ) ` executes the external ` command ` and returns the exit code .",
    "usually , 0 means that the invoked program was executed successfully .",
    "example : ` \\system(ls ) ` types to the screen the content of the current directory and returns 0 .    the operator ` \\asksystem(command , text ) ` executes the external ` command ` , using the second argument as its `` standard input '' .",
    "it reads the first line of the external command output and stores it .",
    "then the external command is terminated , and the stored line is returned . for example , ` \\asksystem(cat , hello ! ) ` returns the text `` hello ! '' , but ` \\asksystem(cat , one!\\eol()two ! ) ` returns the text `` one ! ''",
    "( ` \\eol ( ) ` is the diana command ending the line ) .",
    "another example :    .... \\offleadingspaces    * host : \\asksystem(hostname , ) ; \\asksystem(date , ) ....    in the tm program has led to the following line in the produced output :    .... * host : phya24 ; fri may   30 22:51:38 cet 2003 ....",
    "the operator ` \\asksystem ( ) ` is used to `` ask '' a single question from the command , as described above . in order to organize a dialog with an external program",
    ", the operator ` \\pipe(command ) ` can be used .",
    "it starts the ` command ` , swallowing its standard input and output .",
    "it returns an integer number , a pid of a newly started process , or an empty string , if it fails .",
    "further , the returned pid can be used in order to send some text to the program , or to read program output .",
    "after the operator ` \\pipe ( ) ` returns the control to the tm program , the program initiated by ` command ` continues to run .",
    "its standard input and output references are stored by diana . both input and output",
    "are not connected with any terminal device .",
    "the running external program is visible from the tm program as a duplex `` pipe '' identified by the pid of the external program .",
    "the operator ` \\closepipe(rpipe ) ` ( here ` rpipe ` is the pid of the external program returned by ` \\pipe ( ) ` ) terminates the external program .",
    "it closes the programs io channels , sends to the program a kill signal and waits for the ` command ` to be finished .",
    "there are two operators to write to the pipe .",
    "one is ` \\topipe(rpipe , text ) ` , and another is ` \\linetopipe(rpipe , text ) ` .",
    "the latter appends a new line symbol to the text placed into the pipe while the former sends ` text ` to the pipe as it is .",
    "the necessity of two operators comes from the fact that most of interactive programs have line - oriented input / output .",
    "the program reads from the terminal a whole line and will not continue until the line is completed . on the other hand , sometimes it is necessary to use character - oriented input / output .",
    "the corresponding reading operators are ` \\frompipe(rpipe ) ` and ` \\linefrompipe(rpipe ) ` .",
    "the operator ` \\linefrompipe ( ) ` reads from the pipe and returns a whole line .",
    "the operator is fast , but it is aimed to read only lines .",
    "in contrast , the operator ` \\frompipe ( ) ` can be used in order to read parts of lines .",
    "it stops reading if the line is completed , at an end - of - file condition or if there are no more data available in the pipe .",
    "the operator ` \\frompipe ( ) ` reads from the pipe character - by - character , therefore it is much slower then the operator ` \\linefrompipe()`linefrompipe ( ) makes bufferred reading .",
    "it reads some block from the pipe , and then returns the part of the block corresponding the first whole line .",
    "after the operator is performed , some piece of the text corresponding to the beginning of the next line is also transferred from the pipe into an internal buffer . ] .",
    "it is not allowed to mix ` \\frompipe ( ) ` and ` \\linefrompipe ( ) ` . the result may be unpredictable and probably not what one expects .",
    "these operators may be used to deal with the diana standard input / output . if the first argument , ` rpipe ` , is @xmath5 , the operators ` \\topipe(rpipe , text ) ` and ` \\linetopipe(rpipe , text ) ` will output their second argument to the terminal .",
    "the same with ` \\frompipe ( ) ` and ` \\linefrompipe ( ) ` : if their arguments are @xmath5 , these operators read from the keyboard .",
    "the operators ` \\frompipe ( ) ` and ` \\linefrompipe ( ) ` block the tm program until some data will be available from the pipe .",
    "sometimes this is not acceptable . in order to solve this problem",
    ", the user can apply the operator ` \\ispipeready(rpipe ) ` ( is - pipe - ready ) .",
    "the operator returns ` ok ` if there are data available for the ` \\frompipe ( ) ` operator .",
    "if ` \\ispipeready ( ) ` returns an empty string , the operator ` \\frompipe ( ) ` invoked afterwards will block the tm program and wait for some data to be available .",
    "the operator ` \\ispipeready ( ) ` may be used only in combination with ` \\frompipe ( ) ` .",
    "the operator ` \\linefrompipe ( ) ` may still return some text immediately even if the operator ` \\ispipeready ( ) ` has returned an empty string .",
    "the operator ` \\checkpipe(rpipe , signum ) ` sends the signal `` ` signum ` '' ( an integer number ) to the external program initiated by ` \\pipe ( ) ` . if the signal is delivered successfully , the operator returns ` ok ` .",
    "if the signal can not be delivered , e.g. if the external program was terminated , then the operator returns an empty string . if the first argument , ` rpipe ` , is @xmath5 , the operator does nothing and returns ` ok ` since diana assumes that the user checks the standard input / output . if the second argument , ` signum ` , is @xmath6 , it is assumed to be 0",
    ". it must be an integer number , symbolic names are not accepted .",
    "the primary purpose of the operator is to send the signal 0 to the pipe : this signal will not affect the program but all checking will be performed .",
    "the operator ` \\pipe ( ) ` can be used to add some functionality to diana in the spirit of a component model ( see introduction ) .",
    "let us suppose that we need to deal with high precision arithmetic . under unix",
    ", there exists the command `` ` dc ` ''  a standard desk calculator which supports unlimited precision arithmetic .",
    "it reads arguments from the standard input as so - called `` reverse - polish notation '' and types the answer to the standard output .    the following function `",
    "\\fdiv(a , b ) ` returns the quotient ` a`/`b ` with 10 fraction digits :    .... \\function fdiv a , b;\\modesave()\\-     \\if not exist\"_dc\"then        \\if\"\\export(_dc,\\pipe(dc))\"eq\"\"then           \\killexp(_dc )           \\moderestore()\\return ( )        \\endif        \\linetopipe(\\import(_dc),\\(10 k ) )     \\endif     \\let(a,\\tr(-,_,\\get(a ) ) )     \\let(b,\\tr(-,_,\\get(b ) ) )     \\linetopipe(\\import(_dc),\\(c ) \\get(a)\\ ( ) \\get(b)\\ ( / p ) )     \\moderestore()\\return(\\linefrompipe(\\import(_dc ) ) ) \\end ....    this is a very simple demo version , it is non - optimal and does not contain exception handling .",
    "first , if ` dc ` is not running , the function starts ` dc ` , swallowing its input - output channels ( it assumes that the external program ` dc ` is started if the global variable ` _ dc ` is defined ) .",
    "then it sets the precision 10 , sending the line `` ` 10 k ` '' to ` dc ` .",
    "it replaces possible signs `` ` - ` '' in both ` a ` and ` b ` by the symbol `` ` _ ` '' : the input ` dc ` language requires negative numbers to be preceded by `` ` _ ` '' ; the sign `` ` - ` '' can not be used for this , since it is a binary operator for subtraction .",
    "then the function sends the line `` ` c |a| |b| / p ` '' to the running ` dc ` command .",
    "the calculator clears previous results ( command ` c ` ) , evaluates the quotient and puts the result to the standard output ( command ` p ` ) .    in this example",
    "it is possible to use the operator + ` \\asksystem(dc , 10 k |a| |b| / p ) ` + instead :    .... \\function fdiv a , b;\\modesave()\\-     \\let(a,\\tr(-,_,\\get(a ) ) )     \\let(b,\\tr(-,_,\\get(b ) ) )     \\moderestore()\\return (       \\asksystem(dc , \\(10 k ) \\get(a)\\ ( ) \\get(b)\\ ( / p ) )     ) \\end ....    for each call of ` \\fdiv(a , b ) ` it would start ` dc ` , evaluate and return the result .",
    "the time consumed by such a function will be about 100 times larger than the variant with ` \\pipe ( ) ` , but it is possible in principle .",
    "another example illustrates the `` real '' dialog with the component used to organize some simple gui .",
    "let s suppose some tcl / tk script is placed into the executable file ` guidemo ` ( see appendix [ guidemo ] ; this example is available at + http://www.physik.uni-bielefeld.de/`~`component_model.tar.gz ) .",
    "a )    b )    c )    this small `` widget '' with two buttons , `` run / stop '' and `` quit '' represents a simple dialog ( see fig .  [ guidemoss ] ) .",
    "every time the user clicks the `` run / stop '' checkbutton , the script types to the standard output 0 or 1 ( supposed to be swallowed by diana ) , depending on the state of the button , and reads the window header from the standard input .",
    "if the user clicks the `` quit '' button , then the script outputs the line ` quit ` to the standard output , and exits .",
    "the script is started by means of the operator ` \\pipe(./guidemo ) ` during initialization of a tm program :    .... \\begin(initialization )     . . .",
    "\\export(guidemo,\\pipe(./guidemo ) )     \\topipe(\\import(guidemo),start / quit?\\eol ( ) )     \\if\"\\frompipe(\\import(guidemo))\"ne\"1\"then        \\exit(-1 )     \\endif     \\topipe(\\import(guidemo),run\\ ( ) 0 ... \\eol ( ) ) \\end(initialization ) ....    at this point the window appears with the title `` start / quit ? '' ( fig .",
    "[ guidemoss ] a ) ) , and the execution of the tm program will be suspended since it is blocked while waiting for the data from the pipe .    if the user clicks on the `` quit '' button , the tm program will be finished . if the user switches on the `` run / stop '' button , the tm program starts to run ( fig .",
    "[ guidemoss ] b ) ) .",
    "each time the user clicks one of the buttons ( or closes the window ) , the script emits some text , which becomes available for ` \\frompipe ( ) ` .    in the beginning of the `` ` regular ` '' section there is the following tm code :    .... \\section(regular )    \\if\"\\ispipeready(\\import(guidemo))\"eq\"ok\"then \\beginlabels \\label(_start ) \\goto(_\\frompipe(\\import(guidemo ) ) ) \\label(_0 ) \\topipe(\\import(guidemo),stop\\ ( ) \\currentdiagramnumber()\\eol ( ) ) \\goto(_start ) \\label ( _ ) \\label(_quit ) \\exit(-1 ) \\label(_1 ) \\topipe(\\import(guidemo),run\\ ( ) \\currentdiagramnumber() ... \\eol ( ) ) \\endlabels \\endif ....    if the user switches off the `` run / stop '' button , this code suspends the execution of the tm program ( fig .",
    "[ guidemoss ] c ) ) .",
    "the number of the current diagram will be typed into the title .",
    "the user can continue ( checking the `` run / stop '' button ) , or interrupt the tm program by means of the `` quit '' button .",
    "the operator ` \\system ( ) ` executes commands synchronously , i.e. it waits for them to be completed and returns an exit code .",
    "in contrast , the operator ` \\_exec ( ) ` executes commands in the background .",
    "similar to the operator ` \\pipe ( ) ` , it does not wait for the command to be completed .",
    "it returns an empty string on success , or some diagnostics on failure .",
    "this operator may be used to * parallelyze * the evaluation of a process by running more than one job simultaneously .",
    "all jobs started by the operator ` \\_exec ( ) ` are running independently of the tm program invoking them . to synchronize the tm program with all these jobs",
    ", there is an operator ` \\_waitall ( ) ` .",
    "it suspends execution of the tm program until timeout is expired , or until all jobs started by the ` \\_exec ( ) ` operator are completed ( for further options see sect .",
    "[ relatedpar ] ) .",
    "it returns the number of jobs which are not yet finished , or an empty string , if there are no jobs anymore .",
    "the single argument of the operator ` \\_waitall ( ) ` is a timeout in milliseconds .",
    "e.g. , ` \\_waitall(1000 ) ` will return in one second the number of remaining jobs .",
    "if the user wants to know how many jobs are not yet finished , he may use the operator ` \\_waitall(0 ) ` .    to avoid overloading of a processor , by default at each time only one job is actually running while all the rest is waiting in the queue .",
    "the operator ` \\_exec ( ) ` just queues jobs .",
    "on smp computers , the optimal number of simultaneously running jobs is the number of processors .",
    "this number can be changed by means of the option ` -smp ` .",
    "thus , ` -smp 8 ` tells diana to run on the computer 8 jobs simultaneously while all the rest is queued .    in case of a cluster of computers with a current directory shared by means of nfs e.g. ,",
    "the operator ` \\_exec ( ) ` can use diana servers running on other computers . to run diana as a server ,",
    "the user may use one of the following two options : the option ` -s ` tells diana to run a server listening to some port , and the option ` -d ` forces diana to fork out a `` daemon '' running in the background and listening to the port instead of diana .",
    "thus , each computer on which the user has executed the command ( possibly automized , see macro ` startservers ` below )    .... diana -d 1 -q ....    becomes available to perform the commands queued by the operator ` \\_exec ( ) ` ( we assume that the current directory is shared by nfs among all computers in the cluster ) . here ` -d 1 ` tells diana to run a daemon accepting only one connection , and the option ` -q ` terminates the father diana process . for smp computers",
    "the optimal argument for the ` -d ` ( or ` -s ` ) option is the number of processors .",
    "running jobs are controlled by means of `` handlers '' .",
    "these can be understood as communication channels between running jobs and diana .",
    "their number is the highest possible number of simultaneously running jobs . by default",
    ", the operator ` \\_exec ( ) ` will give priority to local handlers , i.e. if the two possibilities occur simultaneously to run a job locally or on a remote server , the job will be started on the local computer .",
    "when diana starts a new job , it tries to use one of the free handlers with minimal _",
    "nice_. the nice is an integer number which is set for each handler . by default , the local handler has nice 0 , while the remote handler has nice 1 .",
    "the nice of local handlers can be set by an optional parameter for the option ` -smp ` , separated by a comma from the mandatory parameter .",
    "thus , ` -smp 8 ` tells diana to run on the computer 8 jobs simultaneously with nice 0 while ` -smp 8,2 ` tells diana to run these 8 jobs with nice 2 .    the same with the remote server : ` -d 2 ` ( or ` -s 2 ` ) tells diana to run a daemon ( server ) accepting two connections with nice 1 , and ` -d 2,0 ` ( or ` -s 2,0 ` ) tells diana to run a daemon ( server ) accepting two connections with nice 0 .",
    "two operators ` \\_exec ( ) ` and ` _ waitall ( ) ` permit the user to organize a simple parallel session for evaluations on smp computers and/or clusters of independent computers with shared disk space .",
    "but very often this is not enough ( see introduction ) .",
    "therefore , each job started by the operator ` \\_exec ( ) ` must have further _ attributes _",
    "( for a complete list see the end of the present section ) .",
    "the first one is the `` sync '' attribute ; if it is set , the job will be started to run only after all previously started jobs are completed .",
    "the second attribute is the `` sticky '' attribute .",
    "this attribute requires a parameter , which gives reference to the `` master '' job to which the `` slave '' ( getting this parameter ) has to stick .",
    "if this attribute is set , the `` slave '' will be performed on the same node as the `` master '' job was running .    if the `` master '' job fails _ before _",
    "the `` sticky '' `` slave '' job was started , the latter will fail too if a third attribute is set ; otherwise it will be performed independently of the result of the `` master '' job .",
    "let s call this attribute `` stickyfail '' .",
    "there are some other attributes , which will be explained further down .",
    "the total number of attributes is 32 , but at present many of them are merely reserved for future developments .",
    "the operator ` \\_execattr(attr , param ) ` is used to change default job attributes . `",
    "attr ` is a string of length 32 in general .",
    "the position of each character corresponds to one of the attributes .",
    "the first character corresponds to the `` sync '' attribute , the second one to the `` sticky '' attribute , etc .",
    "if the corresponding character is 0 , then the attribute is cleared , if 1 , the attribute is set ; any other character means that the attribute will not be changed .",
    "if the string ` attr ` is longer than 32 , all extra characters will be ignored .",
    "if it is shorter , all remaining attributes will not be changed . examples :",
    ".... \\_execattr(00000000000000000000000000000000 , ) ....    clears all attributes .    .... \\_execattr(1 , ) ....    sets the `` sync '' attribute .    the second argument , `",
    "param ` , is used to attach a parameter to attributes which require it .",
    "parameters are attached consecutively only to those attributes which require them and only to attributes which are set .",
    "if more than one parameter is specified , they have to be separated by the end - of - file symbol ( eof ) , which can be obtained by the operator ` \\eof ( ) ` .",
    "if less parameters than set attributes are specified , they will be cycled over all set attributes requiring a parameter .",
    "each job started by ` \\_exec ( ) ` has a unique name , provided by the user ( see below ) or defined automatically .",
    "the parameter for sticky attributes is the name of the `` master '' job .",
    "it is not allowed to stick to jobs which are not yet queued .",
    "the name of the last queued job can be obtained by the operator ` \\lastjobname ( ) ` .",
    "so , the operator    .... \\_execattr(!10,\\lastjobname ( ) ) ....    does not change the `` sync '' attribute , raises the `` sticky '' attribute to stick the new job to the job queued just before , and clears the `` stickyfail '' attribute .",
    "another example :    .... \\_execattr(111,\\lastjobname ( ) ) ....    the newly created job will be executed firstly after the `` master '' job _ and all previously queued jobs _ are finished , secondly , on the same node on which the `` master '' job was performed , and thirdly only if the `` master '' job was successful .",
    "if the parameter for the `` sticky '' attribute is an empty string , the last job name will be used and the above example is equivalent to    ....",
    "\\_execattr(111 , ) .",
    "....    the operator ` \\_exec ( ) ` queues jobs defined by commands with arbitrary number of command line arguments . the command and the arguments must be pushed into a stack in natural order by means of the operator ` \\push ( ) ` .",
    "e.g. , in order to execute a command `` ` ls -l ` '' , the user has to prepare the stack by means of the following set of operators :    .... \\push(\\eof ( ) ) \\push(ls ) \\push(-l ) ....    and then invokes the operator ` \\_exec ( ) ` .",
    "the command line arguments appear in the stack in reverse order , reading from top to bottom , i.e. in the stack the eof is situated on the bottom .",
    "the ` \\_exec ( ) ` operator reverses the command line arguments from the stack such that they appear in natural order again .",
    "the exact syntax of the ` \\_exec ( ) ` operator is as follows :    .... \\_exec(name , attr , param ) .",
    "....    here ` name ` is the unique job name .",
    "if it is left empty , which is recommended in general , it will be assigned automatically .    the second and third argument",
    "have the same meaning as described above in connection with the ` \\_execattr ( ) ` operator . here",
    "they are considered as local arguments and the default ones are not overwritten by the ` \\_exec ( ) ` .",
    "besides these most important attributes we describe two more useful ones .",
    "they are `` successcondition '' and `` restart '' .",
    "if the job is sent to a server , diana waits for an answer from it .",
    "the server reports success / failure of starting the job , and after the job is completed , the server reports the status of the job returned by the system .    by default",
    ", the job is assumed to be successful if the server reports the status . however , sometimes it is useful to investigate the status returned by the system , or assume that the job is successful if it is started by the server ( see the discussion in the introduction ) .",
    "the `` successcondition '' attribute ( the fourth one ) can accept a parameter which can take the following values :    * -2  the job is successful if it is started by the server ; * -1  the same like without the attribute .",
    "the job is successful if the server reports the status returned by the system . * from 0 to 255  the job is successful if the external program initiated by the job has been completed and returned the exit code less or equal to the specified number .",
    "another problem with success / failure conditions is the question how many times the job should be restarted when it fails . by default , the job is not restarted at all on failure . to change this behaviour , a fifth attribute can be set .",
    "we call it the `` restart '' attribute .",
    "the corresponding parameter is the number of restarts , which must be an unsigned integer from 0 to 255 .",
    "here is the synopsis of all attributes actually used by diana for the time being : +    [ cols=\"^,^,^ \" , ]      as described in sect .",
    "[ parandsync ] , the operator ` \\_waitall ( ) ` returns control if there are no more running jobs or if the timeout is expired . as third possibility",
    "the operator will return control if some data are available on a definite pipe .",
    "this pipe must be set by means of the operator ` \\setpipeforwait(rpipe ) ` , where ` rpipe ` is the pid returned by the operator ` \\pipe ( ) ` , or 0 . in the latter case the operator ` \\_waitall ( ) ` will return control if there is something typed on the keyboard .",
    "if control is returned due to available data from the pipe , the number returned by the operator ` \\_waitall ( ) ` is preceded by a minus sign .",
    "if all jobs finish simultaneously with data occurring in the pipe only a minus sign is returned .",
    "the operator ` \\getpipeforwait ( ) ` returns the pid of the pipe which has been set by ` \\setpipeforwait(rpipe ) ` or an empty string if there is no active pipe for ` \\_waitall ( ) ` .    `",
    "\\pingserver(ip ) ` checks if a diana server is available on a given ip address .",
    "the argument ` ip ` is the ip address in standard dot notation .",
    "the operator returns ` alive ` if the server responds , or an empty string if the server can not be found or does not respond .    `",
    "\\killserver(ip ) ` kills the diana server running on the specified ip address .",
    "the argument ` ip ` is again the ip address in standard dot notation .",
    "the operator returns ` ok ` on success , or an empty string on failure .    `",
    "\\killservers ( ) ` kills all running diana servers .",
    "it returns an empty string on success , or ` none ` on failure .    `",
    "\\lastjobname ( ) ` returns the name of the last job started by the operator ` \\_exec ( ) ` .    `",
    "\\lastjobnumber ( ) ` returns the number of the last job started by the operator ` \\_exec ( ) ` .    ` \\whichip(jobname ) ` returns the ip address as 8 hexadecimal digits or an empty string on failure .    `",
    "\\whichpid(jobname ) ` returns the pid as a hexadecimal number or an empty string on failure .    `",
    "\\getnametostick(jobname ) ` returns the name of the `` master '' job to which the specified `` sticky '' job ` jobname ` has to stick . on failure",
    "it returns an empty string .    `",
    "\\jobtime(jobname ) ` returns 8 hexadecimal digits , the job running time in milliseconds . if the job is not yet running , the operator returns `` 00000000 '' .    `",
    "\\jobstime(jobname ) ` returns 8 hexadecimal digits , the job starting time in milliseconds .",
    "the starting time is counted from the moment of the diana job queuing mechanism being activated till the time the job starts to run .",
    "if the job is not yet started , it returns `` 00000000 '' .    `",
    "\\jobftime(jobname ) ` returns 8 hexadecimal digits , the job finishing time in milliseconds .",
    "the finishing time is counted from the moment of the diana job queuing mechanism being activated till the job is completed . if the job is not yet finished , it returns `` 00000000 '' .    `",
    "\\rmjob(jobname ) ` removes the named job .",
    "if the job is running , the related external programs will automatically be killed by the signal sigkill .",
    "the operator returns an empty string independently of the result .    `",
    "\\clearjobs ( ) ` clears all jobs .",
    "it returns an empty string on success , or the string `` client is dead . ''    ` \\jobstatus(jobname ) ` returns the status of a specified job .",
    "the status is given in terms of 8 hexadecimal digits .",
    "the first two digits stand for the ` exit ( ) ` argument of the external program if the program exited normally , otherwise they are `` 00 '' .",
    "the third and fourth digits are the following : `` 00 ''  normal exit , `` 01 ''  exit because of non - caught signal , `` 02 ''  the job was not run , `` 03 ''  no such job , `` 04 ''  job is finished , but its status is lost ( often occurs after the debugger being detached ) ; otherwise  `` ff '' . if the job was removed by the operator ` \\rmjob ( ) ` , the third digit will not be `` 0 '' but `` 1 '' .",
    "the last 4 digits stand for the number of the signal that caused the external program to terminate if the fourth digit was `` 1 '' , otherwise `` 0000 '' .    `",
    "\\startjobtimeout(timeout ) ` sets the timeout for attempts to start jobs ( milliseconds ) .",
    "after the timeout is expired and the job is not yet running , it will be moved to another handler if the total number of the timeout hits is less then 10 .",
    "if the number of timeout hits is 10 , the job fails .",
    "time is counted from the moment of the job being sent to the remote ( or local ) server .",
    "the operator returns the previous value of the timeout or an empty string on failure .    `",
    "\\gconnecttimeout ( ) ` sets the timeout for the connection with a remote server ( milliseconds ) .",
    "it returns the previous value of the timeout , or an empty string on failure .    `",
    "\\jobhits(jobname ) ` returns 6 hexadecimal digits .",
    "the first two digits stand for the number of times the job was restarted due to the start timeout expiration .",
    "the third and fourth digits stand for the number of times the job was restarted after failures and the last two digits represent the current placement of the job : `` 01 ''  the job is in the main queue , `` 02 ''  the job is in the synchronous queue , `` 03 ''  the job is finished , `` 04 ''  the job failed , `` 05 ''  the job runs , `` 06 ''  the job is ready to run as a non - sticky job , `` 07 ''  the job is ready to run as a sticky job .",
    "` \\failedn ( ) ` returns number of failed jobs , or an empty string , on failure .    `",
    "\\hex2sig(sig ) ` converts diana s internal signals hexadecimal representation to local system ones ( decimal numbers ) .    `",
    "\\sendsig(jobname , signal ) ` sends a signal to the external program which was initiated by the specified job .",
    "note , the signal will be sent to _ all _ external programs initiated by the job .",
    "it expects that the ` signal ` is either a symbolic name sig  (",
    "the sig prefix may be omitted ) , or a number .",
    "all possible symbolic names are ( a subset from the conventional unix signal identifiers ) : sighup sigint sigquit sigill sigabrt sigfpe sigkill sigsegv sigpipe sigalrm sigterm sigusr1 sigusr2 sigchld sigcont sigstop sigtstp sigttin sigttou sigbus sigpoll sigprof sigsys sigtrap sigurg sigvtalrm sigxcpu sigxfsz sigiot sigemt sigstkflt sigio sigcld sigpwr siginfo siglost sigwinch . if the signal is specified by a number , the signal will be sent as it is .",
    "if the signal is specified by a symbolic name , diana will convert it into an internal representation transferred to the remote server",
    ". this may be useful if the numerical representation of signals on the remote system differs from the local one .",
    "the operator returns an empty string on success ; on failure it returns : `` 10 ''  job is not run , `` 20 ''  ca nt read a signal from diana ; less then 10 : `` 01 ''  an invalid signal was specified , `` 02 ''  the pid or process group does not exist , `` 03 ''  the process does not have permission to send the signal , `` 04 ''  unknown error .    ` \\getjobinfo(jobn , format ) ` returns information about the job number ` jobn ` , formatted according to ` format ` .",
    "the latter is a string of type ` n1/w1: ...",
    ":nn / wn ' ` , where ` n # ` is a field number and ` w # ` is its width .",
    "if ` w#`@xmath7 , the text in the field will be right justified and padded on the left with blanks .",
    "if ` w#`@xmath8 , then the text in the field will be left justified and padded on the right with blanks .",
    "if ` w#`=0 , then the width of the field will be of the text length .",
    "here is a complete list of all available fields :    1 .",
    "current placement , see above ; 2 .",
    "return code , 8 hexadecimal digits , see above ; 3 .",
    "ip address ( in dot notation ) ; 4 .",
    "pid ( decimal number ) ; 5 .",
    "attributes ( decimal integer ) ; 6 .",
    "timeout hits ( decimal number ) , see above ; 7 .",
    "fail hits ( decimal number ) , see above ; 8 .",
    "max fail hits ( decimal number ) , see above ; 9 .",
    "errorlevel ( decimal number ) , see above ; 10 .",
    "the job name ; 11 .",
    "number of command line arguments ; 12 .",
    "all command line arguments starting from a second one ( spaces separated ) ; 13 .",
    "all command line arguments starting from a third one ( spaces separated ) ; 14 .",
    "all command line arguments starting from a fourth one ( spaces separated ) .",
    "if ` n # ` is zero or negative its absolute value is interpreted as the position of a single command line argument .",
    "example : ` \\getjobinfo(1 , 4/10:3/15 ) ` returns the pid of the external program of the first job and the ip address of the computer on which the job runs .",
    "pid will be returned as a decimal number padded by spaces on the left to fit a field of width 10 , and ip will be returned in dot notation padded by spaces on the left to fit a field of width 15 .    ` \\tracejobson(filename ) ` starts jobs tracing ( for details see + http://www.physik.uni-bielefeld.de/`~`tentukov/parallel_demo.tar.gz ) into files ( `` filename.var '' and `` filename.nam '' ) , returns an empty string .    `",
    "\\tracejobsoff ( ) ` ceases tracing .",
    "it returns an empty string .",
    "after it has stopped , tracing can not be continued until all jobs are cleared by means of the operator ` \\clearjobs ( ) ` .",
    "very often the external program may run in a subshell as a conventional unix command . for such cases",
    "the following high - level tm function ` \\exec(command ) ` can be defined :    .... \\function exec cmd ;   \\push(\\eof ( ) )   \\push(sh )   \\push(-c )   \\push(\\get(cmd ) )   \\return(\\_exec(,00011,255\\eof()4 ) ) \\end ....    the function starts the job consisting of some ( maybe composed ) standard unix command",
    ". the job will be successful if the command returns some exit code ( under unix there is no possibility to have an exit code higher then 255 ) . on failure",
    "the job will be restarted up to four times ( the number 4 after ` \\eof ( ) ` ) .",
    "the function ` \\stick(command ) ` :    .... \\function stick cmd ;   \\push(\\eof ( ) )   \\push(sh )   \\push(-c )   \\push(\\get(cmd ) )   \\return(\\_exec(,11110,\\eof()-2 ) ) \\end ....    performs the command ` cmd ` only after all earlier jobs are completed ( the first 1 of the second argument of ` \\exec ( ) ` ) .",
    "this function in general is used to collect all produced files .",
    "that is why it performs ` cmd ` on the same computer as the preceding job ( the second 1 ; since the job name to stick to is an empty string , the last job name will be used ) .",
    "the job started by this function is successful if it is started by the server ( the fourth 1 , and the corresponding parameter is `` -2 '' ) .",
    "the job will not be restarted on failure ( the last 0 ) .",
    "the function ` \\wait(timeout ) ` :    .... \\function wait to ;   \\while\"\\let(r,\\_waitall(\\get(to)))\"ne\"\"do    \\message(\\get(r)\\ ( jobs are not finished ) )   \\loop \\end ....    suspends execution of the tm program until all jobs are completed .",
    "each `` ` timeout ` '' milliseconds the function reports the number of jobs which are not yet finished .",
    "these three functions can be used to organize a simple parallel session with proper synchronization . as an example , let us consider the following script ` runf ` , which is used to run form jobs in parallel after the form input has been produced in a folder ( see @xcite , p.  158 ) :    .... # ! diana",
    "-smp 1 -c runpar.tml \\startservers(phya25,phya26,phya27,phya28 ) \\system(echo >",
    "log.all )    \\repeat(n ) \\exec(form -d i=\\get(n ) do.frm > /tmp / log.\\get(n ) ) \\stick(cat /tmp / log.\\get(n ) > > log.all ) \\stick(rm /tmp / log.\\get(n ) ) \\endrepeat ( )    \\wait(2000 ) ....    the user enters : ` runf 186 200 ` , and the system executes : + ` diana -smp 1 -c runpar.tml runf 186 200 ` .",
    "the file ` runpar.tml ` ( see appendix [ runpar ] ) contains definitions of various tm functions and some settings ; in particular it redefines the comment character as ` # ` .",
    "the following is the structure of the file ` runpar.tml ` :    .... messages disable esc character = \\ comment character = # output file = \" \" debug off only interpret \\begin translate ....    _ definitions various functions and macros , in particular ` \\exec ( ) ` ,  ` \\wait ( ) ` , + ` \\repeat ( ) ` , ` \\endrepeat ( ) ` and ` \\startservers ( ) ` _    .... \\program \\- \\set(_cmdln)(\\cmdline(1 ) ) \\rmarg(1 ) \\{\\include(\\get(_cmdln))\\- \\setout(null ) \\ }",
    "\\end translate ....    the main program switches off the output ( by means of the directive ` \\- ` ) , switches off `` hash '' regime for arguments by means of the directive `` ` \\ { ` '' ( see below ) , stores the first command line argument(```\\set(_cmdln)(\\cmdline(1 ) ) ` '' ) , removes it ( `` ` \\rmarg(1 ) ` '' ) and includes the file the name of which is the first command line argument + ( `` ` \\include(\\get(_cmdln ) ) ` '' ) .    by default , diana provides for the function and operator arguments some special `` hash '' regime : all spaces and ends of line are ignored .",
    "the directive `` ` \\ { ` '' cancels this regime , the directive `` ` \\ } ` '' activates it again . without this directive",
    "all commands with spaces must be quoted by the quotation operator `` ` \\ ( ) ` '' which is not convenient for a script .",
    "the macro ` \\startservers(list ) ` checks if each server from ` list ` is working and if not starts the server by means of the ` ssh ` .",
    "for example , for the host phya26 the following command will be performed :    .... ssh phya26 cd cd ; diana -d 1 -q ....    where `` ` cd ` '' is a current directory , e.g. ` /home",
    "/ user / jobs ` .",
    "the operator ` \\system(echo > log.all ) ` is used to produce an empty file `` ` log.all ` '' .",
    "all the instructions between ` \\repeat(n ) ` ` ... ` ` \\endrepeat ( ) ` are cycled with ` n=186, ... ,200 ` .",
    "we assume that there is some folder file , say , ` tt.in ` with form input for each diagram .",
    "the form program ` do.frm ` evaluates a diagram by virtue of including a fold from the folder ` tt.in ` via an instruction like ` # include tt.in # n'i ' ` .",
    "the macro definition ` i ` comes from the command line ` form -d i=\\get(n ) do.frm ` , where ` \\get(n ) ` runs from 186 to 200 .",
    "each form job saves the result to the local directory , but the corresponding concatenation is performed by ` \\stick(cat ... ) ` on the same computer . at the end ,",
    "all results will be collected in the file ` log.all ` , and all intermediate files ` \\tmp\\log . # ` will be removed .",
    "after all jobs are queued , the function ` \\waitall(2000 ) ` will report every 2 seconds how many jobs are not yet completed .",
    "this example is available at + http://www.physik.uni-bielefeld.de/`~`tentukov/parallel_demo.tar.gz .    in the archive",
    "there are two directories : demo1 and demo2 .",
    "the example is situated in demo1 ; see the readme file for details of installation . for a more realistic ( and complicated ) example containing",
    "jobs controlling and monitoring facilities see demo2 .",
    "m.  tentukov is grateful for financial suuport by the dfg under project no .",
    "fl  241/4 - 2",
    "the following tcl / tk script is supposed to be placed into the executable file ` guidemo ` :    .... # ! /bin",
    "/ sh # \\ exec wish \" $ 0 \" \" $ @ \" -geometry + 200 + 300    # catches destroy window event : wm protocol .wm_delete_window { puts \" quit\";exit 0 }    label .title pack .title    # create relief canvas : frame .buttons -bd 10 -relief raised    # button \" run / stop \" : global checkb frame .buttons.run checkbutton .buttons.run.run",
    "-text \" run / stop\"\\    -command { puts \" $ checkb \" ; flush stdout;\\              .title configure -text [ gets stdin]}\\               -variable checkb pack .buttons.run.run pack .buttons.run",
    "-side left    # button \" quit \" frame .buttons.quit button .buttons.quit.quit -text \" quit \" -command\\    { puts \" quit\";exit 0 } pack .buttons.quit.quit pack .buttons.quit -side left pack .buttons    # read initial header : .title configure -text [ gets stdin ] # end : ....    the script creates a window with two buttons .",
    "the check button `` run / stop '' has two states , `` selected '' and `` deselected '' .",
    "the global variable ` checkb ` is set to indicate whether or not this button is selected .",
    "every time the user clicks the `` run / stop '' checkbutton , the script types to the standard output the value of ` checkb ` and reads the window header from the standard input .",
    "the `` quit '' button , when pressed , outputs the line `` ` quit ` '' to the standard output and exits from the script .",
    "the same occurs when the user closes the window .",
    "the following listing is typed in typewriter while comments are typed using _",
    "italic_.      l.  avdeev , j.  fleischer , m.  y. kalmykov , and m.  tentyukov , `` towards automatic analytic evaluation of massive feynman diagrams '' , _ nucl .",
    "instrum . meth .",
    "_ * a389 * ( 1997 ) 343 ; l.  v.  avdeev , j.  fleischer , m.  y.  kalmykov , and m.  n.  tentyukov , `` towards automatic analytic evaluation of diagrams with masses '' , _ comput .",
    "commun . _ * 107 * ( 1997 ) 155166 .",
    "j.  fleischer _ et al .",
    "_ , phys . lett .",
    "* b459 * ( 1999 ) 625 ; j.  fleischer , o.  v.  tarasov and m.  tentyukov , nucl .",
    "* 89 * ( 2000 ) 112 ; f.  jegerlehner , m.  y.  kalmykov and o.  veretin , nucl . phys .",
    "* b641 * ( 2002 ) 285 ; j.  fleischer _ et al .",
    "_ , hep - ph/0202109 ; a.  onishchenko and o.  veretin , hep - ph/0209010 and hep - ph/0211280 ; m.  awramik _ et al .",
    "_ , hep - ph/0209084 ."
  ],
  "abstract_text": [
    "<S> co - operation of the feynman diagram analyzer ( diana ) with the underlying operational system ( unix ) is presented . </S>",
    "<S> we discuss operators to run external commands and a recent development of parallel processing facilities and an extension in the spirit of a component model .    </S>",
    "<S> -2.0 cm -2.0 cm    = 10000    bi - tp 2003/17 + sfb / cpp-03 - 27     * parallel computation of feynman diagrams with diana *    m.  tentyukov@xmath0 and j.  fleischer@xmath1    _  a ) institut fr theoretische teilchenphysik , universitt karlsruhe , germany +  b)fakultt fr physik , universitt bielefeld , germany +  ) on leave from joint institute for nuclear research , dubna , russia +  ) supported by dfg under fl 241/4 - 2 _ </S>"
  ]
}