{
  "article_text": [
    "several tools for visualizing the execution of constraint programs have been developed in the last few years .",
    "these tools have been found very useful for debugging and improving constraint programs , and for teaching constraint programming .",
    "one can distinguish :    * _ post - mortem visualization _",
    "tools , these tools are used after execution of the program , the program is annotated with specifications of the information to trace .",
    "this approach is implemented for example in the chip or ciao systems , it allows using a wide variety of viewers , including both application oriented tools @xcite , and generic tools , for visualizing the search tree @xcite , finite domain variables @xcite , or constraint propagation @xcite . *",
    "_ dynamic visualization _ tools , these tools are connected to the constraint programming interpreter and realize a visualization on - line , possibly with animations @xcite .",
    "this approach is implemented in grace tool @xcite for finite domains visualization , and in opl studio @xcite for search tree and constraint propagation visualization . * _ dynamic visualization and control _ tools which allow interaction with a clp process through different visualizations .",
    "one example is the oz - explorer system @xcite where it is possible to jump to any previously encountered state by simply clicking on a node of the search tree , and restart computation from that state .",
    "user - guided search is implemented in oz - explorer using the first - class computation spaces of oz .",
    "recomputation is used to trade space for time in oz - explorer , and similarly in opl studio @xcite , the state restoration mechanisms in tree search are described in @xcite .    in this paper",
    "we propose to push forwards these ideas towards an open architecture for connecting a clp process with dynamic visualization and control tools . to our knowledge",
    ", the visualization of search trees in three dimensions has not been much investigated .",
    "we argue that the 3d representation of search trees proposed in this paper provides the most appropriate visualization of large search trees .",
    "our ambition is not to realize an _",
    "ad hoc _ tool limited to a particular constraint programming system , namely gnu - prolog @xcite , but a generic tool which can be ported to other constraint programming systems .",
    "the main reason for this is that a wide variety of viewers can be useful for debugging constraint programs and it is possible in this way to share developments .",
    "our approach relies on the generic trace format which is defined in the oadymppac consortium @xcite for post - mortem analysis .",
    "we propose to extend this format with a similar generic format for control , and to use these formats for connecting on - line the clp process to the gui process .",
    "our implementation of clpgui @xcite in gnu - prolog and java is depicted in figure [ schema ] .    in section [ console ] of this paper , we describe the client - server architecture of clpgui and the user console which facilitates the establishment of a connection with a clp server , and controls the execution of the clp program .",
    "section [ annotations ] describes annotations that can be added to a clp program , in order to give an external name to finite domain variables , to create buttons for posting constraints or goals from the clpgui console , and to define the level of granularity of the search tree which will be visualized .",
    "section [ finitedomains ] presents a dynamic 3d viewer for visualizing the evolution of finite domains variables over time .",
    "section [ searchtree ] describes the representation of the explored search space by partial csld derivation trees , presents different visualizations with 2d and 3d viewers , and discusses their use in clpgui .",
    "then in section [ 02/implementation ] we discuss the implementation of the interactive execution model and of the annotations , using the global variables of gnu - prolog .",
    "finally we provide some evaluation results , and conclude on the current limitations of the system and on some perspectives for future work .",
    "the graphical user interface of clpgui is a java application connected by sockets as a client to a server which executes clp goals .",
    "both processes can run on different machines and communicate over the network .",
    "this has been experienced with clpgui for visualizing the execution of clp programs on a workbench of virtual reality .",
    "the choice of the java language for implementing the gui is motivated by several reasons :    * its object - orientation , all 3d viewers presented in the following sections inherit from a single class for moving and projecting 3d figures ; * the encapsulation of events handling , that is preponderant in dynamic visualization ; * the threaded execution , which is mandatory for implementing communication with the clp process ; * its wide availability .    for efficiency reasons",
    ", we did not use the java-3d library for the viewers presented in this paper , as they can directly benefit from _",
    "ad hoc _ optimizations that speed - up their incremental display .",
    "nevertheless the architecture can support the use of the powerful java-3d library for developing complex application - oriented viewers .    during initialization ,",
    "the clp server starts an interpreter of the command lines received on the socket .",
    "the command lines may contain any clp goal .",
    "the gui java client opens a graphical console such as the one in figure [ consoleclpgui ] . that console is used for establishing a connection to the clp server , and for posting constraints or executing clp goals .",
    "the clp program may contain annotations for creating buttons for some constraints or for some prolog goals to execute in an interactive manner .",
    "these buttons for posting constraints or prolog goals then appear at the bottom in the clpgui console , see figure [ consoleclpgui ] .",
    "a click on the button posts the constraint or executes the goal associated to the button .",
    "other arbitrary goals can be executed by entering them in a text field .",
    "in addition , one button called `` backtrack '' continues the execution of the current goal up to the next success , or , if there are no more success , returns to the state of the previous interaction .",
    "another button called `` backtrack interaction '' forces backtracking to the state of the previous interaction .",
    "the menu bar of this console contains menus to select and activate the viewers of the search tree or of the finite domain variables .",
    "the clp program may contain annotations for giving an external name to clp(fd ) variables , for creating buttons for posting constraints or goals from the clpgui console , and for marking the goals to visualize in the search tree .",
    "the following predicates are part of the annotation library :    * varnames([v1, ... ,vn],[name1, ... ,namen ] ) and varnames([v1, ... ,vn ] ) give an external name to a list of clp variables .",
    "these external names are used in the graphical user interface and for the communication by sockets . *",
    "button(goal ) creates a button in the gui console for executing a goal or for posting a constraint . *",
    "bagof_buttons(goal , call ) creates a bag of buttons for each successful instance of the second argument . *",
    "trace_search(goal ) executes the goal and traces the execution of that goal , by creating nodes in the search tree .",
    "the goals and constraints posted from the graphical console are always traced .",
    "* show_domains updates the visualization of the current state of fd variables .",
    "annotations provide a simple mechanism for encapsulating communications towards the gui process @xcite .",
    "the advantages of this abstraction are :    * the flexibility for defining different levels of granularity concerning the information to visualize . *",
    "the easiness for making interactive already existing programs , * the portability of the gui to other constraint programming systems , as all communications with the gui are encapsulated in the implementation of annotation predicates .",
    "the limitations of annotations are well - known in standard programming environments : they may be difficult to maintain in large programs . in that case",
    ", one solution is to automatically generate annotations with a graphical editor of the program source , where spy points and trace options can be specified .",
    "nevertheless , one peculiarity of constraint logic programming is the conciseness of programs .",
    "clp(fd ) programs for solving combinatorial optimization problems on real - size data may compute with a huge amount of constraints and variables , but the program source for handling constraints and defining complex search strategy usually remains relatively concise .",
    "therefore in this context , the proposed annotations appear as a satisfactory solution .    in many clp systems however , the heuristic labeling procedures are built - in , and can not be precisely traced with a simple annotation . in these cases ,",
    "the annotations have to rely on the tracing facilities of the clp system in order to extract , and communicate to the gui , the relevant information .",
    "a simpler solution is to program the labeling heuristics in the host language , for making available in the host language the information coming from the constraint solvers that is relevant to the search heuristics . in that case",
    ", the effect of the search strategy can be visualized at different levels of granularity . in its simplest form , a predicate for tracing a labeling procedure can be defined with a trace_search annotation as follows :    .... trace_labeling ( [ ] ) .",
    "trace_labeling([x|l]):- trace_search(fd_labeling(x ) ) , trace_labeling(l ) . ....",
    "it is worth noting that even if the search strategy is implemented with a meta - interpreter , or constraint posting is combined with labeling , the relevant goals of the execution can still be traced with annotations .",
    "the same difficulty arises for tracing internal constraint propagation steps .",
    "this is not possible without access to the wakening events of the constraint solver .",
    "the annotations for tracing constraint propagation steps have thus to rely on the tracing facilities of the solver in order to extract and communicate constraint wakening events .    [ send.pl ]",
    "the following annotated gnu - prolog program solves the well known send+more = money puzzle in an interactive manner , by creating buttons for posting the constraints and for trying two labeling goals in this example :    .... sendmore(l):-           l=[s , e , n , d , m , o , r , y ] ,           varnames(l,['s','e','n','d','m','o','r','y ' ] ) ,           fd_domain(l,0,9 ) ,           button(fd_domain([s , m],1,9 ) ) ,           button(1000*s+100*e+10*n+d + 1000*m+100*o+10*r+e                   # = 10000*m+1000*o+100*n+10*e+y ) ,           button(fd_all_different(l ) ) ,           button(trace_labeling(l ) ) ,           reverse(l , l2 ) ,           button(trace_labeling(l2 ) ) . ....    this program generates the console in figure [ consoleclpgui ] .",
    "the evolution of the finite domain variables over time , after the posting of constraints and of the first labeling goal , is depicted in figure [ domainsclpgui ] .",
    "the visualization of the search tree for obtaining all solutions under the first labeling goal , and then under the second labeling goal executed after a backtracking command , is depicted in figure [ sendtreeclpgui ] . under the first",
    "ordering , the labeling is deterministic . under the second",
    "ordering , few backtracking steps occur on variable y when searching for other solutions . note that other labeling heuristics can be tried directly from the console . on such pedagogical examples , the advantage of immediately visualizing the effect of posting a constraint or trying a labeling , is clear for teaching purposes .",
    "epsfigfile = sendtreeclpgui.ps , width=8 cm , height=5 cm    [ queens.pl ] the following program solves the n queens problem by creating buttons for posting the constraints ( safe predicate ) and labeling goals for each variable ( fd_labeling predicate ) and for all variables ( trace_labeling predicate ) .",
    "queens(n , l):-          length(l , n ) ,          varnames(l ) ,          fd_domain(l,1,n ) ,          button(safe(l ) ) ,          bagof_buttons(fd_labeling(x),member(x , l ) ) ,           button(trace_labeling(l ) ) .      ....",
    "three visualizations of the search tree for the 8 queens problem are depicted in figures [ arbre2dclpgui ] , [ arbre3dclpgui ] and [ treemapclpgui ] .",
    "epsfigfile = domainsclpgui.ps , width=12 cm , height=8 cm    the evolution of finite domain variables is visualized in a three dimensional graph variable - domain - time , as proposed in the vifid / trifid tool @xcite . here",
    "the visualization is dynamic , the java process reads the stream of finite domains information and paints the figure in an incremental manner .",
    "domains are depicted by their size on the vertical axis , see figure [ domainsclpgui ] . according to options , that can be set in the clp program or in the gui , only the size , the interval or the complete domain of variables is visualized . but in any case only the sizes of the domains are memorized , therefore the extra information is lost when the figure is repaint . the time axis traces the interactions ( i.e.  the posting of constraints in the example ) , and the execution of traced goals ( i.e.  the labeling in the example ) .",
    "this view shows that the posting of constraints instantiate variables @xmath0 and that the first labeling step on variable e in fact instantiates all variables by constraint propagation .",
    "an option determines whether backtracked states are traced or erased .",
    "the figure can be moved , zoomed and rotated . for efficiency reasons ,",
    "the rotations are limited to a quadrant of a sphere which is not a real limitation for the user . in this way",
    "the visible faces are efficiently determined and the figure can be drawn incrementally .",
    "extra information on variables and executed goals can be obtained by moving the mouse on the position of a variable or on a time position .",
    "the 3d dynamic view of finite domain variables evolution is very useful for teaching constraint programming .",
    "the effect of constraints is immediately seen and many strategies can be tried step by step . on large set of variables ,",
    "the 3d view of domains can still be useful to get a view of the pruning power of different constraint modelings , and of the efficiency of different search heuristics , by comparing the general shape of domain reductions .",
    "epsfigfile = arbre2dclpgui.ps , width=12 cm , height=8 cm    epsfigfile = arbre3dclpgui.ps , width=12 cm , height=8 cm    epsfigfile = treemapclpgui.ps , width=12 cm , height=8 cm    the search tree considered in clpgui is a labeled tree defined as follows :    * a node is introduced for each call to a traced goal ( called a _ call node _ ) , and for each success to a traced goal ( called a _ success node _ ) , * the label of a call node is the called goal , * the label of a success node is the list of named variables with their value , * the arcs correspond to the operational clp transitions .",
    "this tree is a subtree of the csld derivation tree @xcite .",
    "it is thus a quite natural representation of the search tree for describing clp program execution .",
    "a branch represents a conjunction , and the different successors of a node represents a disjunction .",
    "a success node may have several successors if there is an untraced non - deterministic goal which is executed after the success , and before the next call to a traced goal .",
    "this is the main reason why success nodes are introduced in partial csld trees . in this way ,",
    "the non - determinism due to untraced goals can not be confused with the non - determinism of traced goals .",
    "one disadvantage of csld trees is that in the case of deterministic programs they are threadlike and thus space consuming in their standard representation . and - or trees provide a more compact representation , as the threadlike parts of the csld tree are compacted in the successors of a single and - node . for this reason , in the context of logic programs where most predicates are deterministic , and - or trees , and their variant aorta diagrams which indicate the status of resolution of the goals , have been preferred @xcite .",
    "nevertheless in the context of constraint logic programming over finite domains , the situation is quite different .",
    "the search tree to visualize is usually focused on the labeling predicates , or more generally on the branching procedure , which is highly non - deterministic ( at least during debugging ) .",
    "the representation of the deterministic part of the search tree with threadlike structures provides an immediate visualization of the pruning power of constraints .",
    "a naive solution for tracing constraint propagation steps in this approach is to add deterministic nodes for tracing constraint wakening events . for space limitation reasons , it is preferable however to aggregate constraint propagation information to the nodes of the search tree",
    "this is proposed in the `` christmas trees '' of opl studio @xcite .    for search engines not based on backtracking ,",
    "it is worth noting that a partial csld derivation tree can still provide a valid representation of the explored search space , as long as the explored states can be defined by their relation to some ancestor states .",
    "a formalization of an interactive constraint solver by transformations of csld derivation trees was done in @xcite .",
    "once the search tree is formally defined , it can still be visualized in many ways , and in some cases it can be interesting to use several visualizations at the same time .",
    "we have currently implemented several two - dimensional and three - dimensional viewers , but many more representations could be imagined and fruitfully used .",
    "in all the following representations , the labels of the nodes are visualized when the mouse is moved on them , and an option makes all nodes visible .",
    "the successes are materialized by a red cross .",
    "each view can be moved , zoomed and rotated .",
    "figure [ sendtreeclpgui ] uses a standard 2d representation of the search tree in a fixed width .",
    "figure [ arbre2dclpgui ] uses a dynamic 2d representation of the tree with a fixed spacing between leaves .",
    "this representation of the tree can be drawn incrementally and is thus appropriate for the dynamic visualization of large trees .    to our knowledge , the 3d visualization of search trees has not been much investigated .",
    "figure [ arbre3dclpgui ] shows a somewhat original 3d representation of the search tree with alternating planes of successors .",
    "one advantage of this 3d representation is that it is relatively compact , it helps visualizing rather large trees by playing with rotations , see figure [ bridgeclpgui ] for another example .",
    "our experience is that the 3d view is the most appropriate view to apprehend the shape of large search trees .",
    "it is interesting to note that one obtains a treemap representation of the tree by rotation of the 3d alternate tree up to its vertical projection , as done in figure [ treemapclpgui ] .",
    "treemap representations ( with colors for aggregating information ) are known to be particularly efficient to represent very large data @xcite and to visualize complex phenomenons such as correlations , patterns or symmetries .",
    "the interaction allowed in these views to restore a state is currently limited to user - guided backtracking and recomputation .",
    "the automatic recomputation of any state of the tree as described in @xcite is currently not implemented .",
    "epsfigfile = bridge2.ps , width=12 cm , height=8 cm    the branch and bound procedure is widely used in constraint programming to solve optimization problems .",
    "branch and bound optimization develops search trees in two parts .",
    "the first part corresponds to the enumeration of solutions with decreasing costs ( for minimization problems ) .",
    "the second part exhausts the search space to show that there does not exist a better solution than the last solution found .",
    "the second part of the search tree constitutes the proof of optimality .",
    "figure [ bridgeclpgui ] shows the search tree for the bridge problem @xcite , a medium size job - shop scheduling problem .",
    "the first descent corresponds to the search of the first solution of cost 108 .",
    "it contains 78 call nodes .",
    "the second descent ( after some hesitation ) corresponds to the search of the optimal solution of cost 104 .",
    "it contains 99 call nodes .",
    "the bottom part of the tree contains 3728 call nodes and corresponds to the proof of optimality .",
    "the 3d view is the most appropriate view of this search tree .",
    "it can be moved and rotated without difficulty .",
    "the interactive execution model of the clp process derives from a more general model for adding and removing constraints and goals described in @xcite . in clpgui ,",
    "constraints and goals can only be added to the current goal , the removing of constraints or goals occurs by backtracking .",
    "it is therefore possible on a success of the current goal :    * to add constraints or any goals to the current goal and continue resolution , * to backtrack to the next success ( command `` backtrack '' of section [ console ] ) , * or to backtrack to the last interaction ( command `` backtrack interaction '' ) .",
    "it is worth noting that such a top level is in fact very appropriate for standard prolog systems , where the capability of adding goals on a success of the current goal , and continue resolution , is usually missing .",
    "our current implementation uses the global variables of gnu - prolog @xcite to memorize global information , such as input and output sockets , variable names , and information used for backtracking .",
    "global variables make it possible to avoid adding parameters to many predicates and lead to a simple implementation of annotations .      in this section",
    "we describe the communication messages which are transmitted between the clp process and the gui process .",
    "the clp process produces the trace information specified by the annotations in the clp program , or asked from the gui .",
    "the messages emitted from the clp to the gui are the following :    * sends the list of fd variable names * asks the gui to create a button for posting the constraint or goal g * indicates backtracking on the creation of a button for g * traces a call to goal g * traces backtracking on the call to g * traces a success to g * traces backtracking on the success to g * indicates backtracking on the call to goal g * sends the domain sizes of fd variables * sends the current intervals of fd variables * sends the current finite domains of fd variables * ,",
    "< undo domainintervals > , < undo domainsizes > warns the gui that the finite domain variables are updated by backtracking . * indicates that the current derivation is a success * indicates return to top level .    in the other direction ,",
    "the messages emitted from the gui to the clp process are the following :    * ,",
    "< showinterval > , < showvalues > sets the information on finite domains that need be sent * asks to post constraint g or execute goal g * asks backtracking to the next success * forces backtracking to the last interaction * asks to abort the current execution .    the portability of clpgui to a new constraint programming system is determined by the ability of the constraint programming system to produce and interpret these communication messages .",
    "the messages of the first list are produced by the predicates of annotation library described in section [ annotations ] .",
    "the messages in the second list are interpreted by the interactive execution model described in the previous section .",
    "our experience of using clpgui for teaching constraint programming has been very positive .",
    "the dynamic visualization of clp programs really speeds - up the process of learning the basic concepts of domain filtering , constraint propagation and search trees .",
    "clpgui has also been fruitfully used to visualize the search tree of clp(r ) programs .    on real - size data , clpgui has shown satisfactory performance figures .",
    "we report in this section the timings on a pentium iii 600 mhz processor under linux .",
    "gnu - prolog solves the bridge problem mentioned in section [ optimization ] in 100 ms , including the proof of optimality .",
    "the solving together with the visualization of the search tree with 3905 call nodes takes 470 ms with clpgui .",
    "this overhead is due to the communication of messages by sockets .",
    "the overhead was reduced from 2600 ms to 470 ms by optimizing socket calls and by using simple data compression techniques for communication . moreover ,",
    "the drawing of the tree is immediate and the figure can be moved and rotated without difficulty .",
    "we have described an open architecture for visualizing and controlling the execution of constraint logic programs .",
    "communication by sockets between the clp process and the gui process has proved efficient enough for dynamic visualization and interactions .",
    "an important reduction of the overhead was obtained by optimizing socket calls and by using simple data compression techniques for communication .",
    "clpgui supports the use of different viewers .",
    "our experience has shown that a somewhat original 3d visualization of the search tree proposed in the paper , is often the preferred view to apprehend the shape of large search trees , as it is very compact .",
    "more work is needed however to parametrize the different viewers and invent novel visualizations of complex data . in this respect",
    "the flexibility of the architecture makes it possible to connect clpgui to external generic viewers , or to use powerful libraries like java 3d to develop application - oriented viewers .",
    "the most obvious limitation of our current implementation of clpgui is the absence of connection to a system for tracing constraint propagation , simply because such a tracer does not exist yet for gnu - prolog .",
    "nevertheless a generic trace format for finite domain constraint solvers has been defined in the oadymppac consortium @xcite , and we plan to use this format in future versions of clpgui .    finally , clpgui is not a visual programming tool as far as the capabilities of defining goals from the gui are extremely rudimentary . nevertheless the proposed architecture can support this kind of extension by adding the capability to define constraints and goals",
    "graphically , that is certainly worth investigating .",
    "i would like to thank all members of the oadymppac rntl project of the french ministry of research , and especially abderrahmane aggoun , thomas baudel , pierre deransart , jean - daniel fekete , ludovic langevine and mohammad gonhiem for interesting discussions on this topic .",
    "i am grateful also to anupam agarwal for optimizing communication by sockets , and to jean - michel leconte for his preliminary work along these lines on the workbench of virtual reality at inria .",
    "c.  bracchi , c.  gefflot , and f.  paulin . combining propagation information and search - tree visualization using opl studio . in a.  kusalik , m.  ducass , and g.  puebla , editors , _ proceedings of wlpe01 _ , pages 2739 , cyprus , dcembre 2001 .",
    "cyprus university .",
    "chiu  wo choi , m.  henz , and ka  boon ng .",
    "components for state restoration in tree search . in _ proceedings of the seventh international conference on principles and practice of constraint programming ( cp01 )",
    "_ , lecture notes in computer science , pages 240255 , cyprus , november 2001 .",
    "springer - verlag .",
    "m.  meier .",
    "debugging constraint programs . in _ proceedings of the first international conference on principles and practice of constraint programming ( cp95 )",
    "_ , number 976 in lecture notes in computer science , pages 204221 , cassis , france , 1995 .",
    "springer - verlag .",
    "c.  schulte .",
    "oz explorer : a visual constraint programming tool . in _ proceedings of the fourteenth international conference on logic programming ( iclp97 )",
    "_ , pages 286300 , leuven , juin 1997 . the mit press .",
    "g.  smedbck , m.  carro , and m.  hermenegildo .",
    "interfacing prolog and vrml and its application to constraint visualization . in _ the practical application of constraint technologies and logic programming _ , pages 453471 .",
    "the practical application company , 1999 ."
  ],
  "abstract_text": [
    "<S> clpgui is a graphical user interface for visualizing and interacting with constraint logic programs over finite domains . in clpgui </S>",
    "<S> , the user can control the execution of a clp program through several views of constraints , of finite domain variables and of the search tree . </S>",
    "<S> clpgui is intended to be used both for teaching purposes , and for debugging and improving complex programs of realworld scale . </S>",
    "<S> it is based on a client - server architecture for connecting the clp process to a java - based gui process . </S>",
    "<S> communication by message passing provides an open architecture which facilitates the reuse of graphical components and the porting to different constraint programming systems . </S>",
    "<S> arbitrary constraints and goals can be posted incrementally from the gui . </S>",
    "<S> we propose several dynamic 2d and 3d visualizations of the search tree and of the evolution of finite domain variables . </S>",
    "<S> we argue that the 3d representation of search trees proposed in this paper provides the most appropriate visualization of large search trees . </S>",
    "<S> we describe the current implementation of the annotations and of the interactive execution model in gnu - prolog , and report some evaluation results . </S>"
  ]
}