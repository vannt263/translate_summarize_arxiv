{
  "article_text": [
    "in this paper we identify a class of rules that naturally arise in the context of constraint programming represented by means of rule - based programming and study efficient schedulers for these rules .",
    "we call these rules _ propagation _ rules , in short _ prop _ rules",
    ". an important class of _ prop _ rules are the _ membership rules _ , introduced in @xcite .",
    "an example of a membership rule is @xmath0 informally , it should be read as follows : if the domain of @xmath1 is included in \\{3,4,8 } and the domain of @xmath2 is included in \\{1,2 } , then 2 is removed from the domain of @xmath3 .    in the computations of constraint programs",
    "the variable domains gradually shrink .",
    "so if the domain of @xmath1 is included in \\{3,4,8 } , then it will remain so during the computation . in turn , if 2 is removed from the domain of @xmath3 , then this removal operation does not need to be repeated .",
    "the _ prop _ rules generalize these observations to specific conditions on the rule condition and body .    in the resulting approach to constraint programming the computation process",
    "is limited to a repeated application of the _ prop _ rules intertwined with splitting ( labeling ) .",
    "so the viability of this approach crucially depends on the availability of efficient schedulers for such rules .",
    "this motivates the work here reported .",
    "we provide an abstract framework for such schedulers and use it as a basis for an implementation .    more precisely , to obtain appropriate schedulers for the _ prop _ rules we use the generic approach to constraint propagation algorithms introduced in @xcite and @xcite . in this framework one",
    "proceeds in two steps .",
    "first , a generic iteration algorithm on partial orderings is introduced and proved correct in an abstract setting",
    ". then it is instantiated with specific partial orderings and functions to obtain specific constraint propagation algorithms . in this paper , as in @xcite , we take into account information about the scheduled functions , which are here the _ prop _ rules .",
    "this yields a specific scheduler in the form of an algorithm called ` r ` .",
    "we then show by means of an implementation how this abstract framework can be used to obtain a scheduler for the membership rules .",
    "the relevance of the membership rules for constraint satisfaction problems ( csps ) with finite domains stems from the following observations made in @xcite :    * constraint propagation can be naturally achieved by repeated application of the membership rules ; * in particular the notions of arc consistency and hyper - arc consistency can be characterized in terms of the membership rules ; * for constraints explicitly defined on small finite domains all valid membership rules can be automatically generated ; ( for a more referent work on the subject of an automatic generation of such rules see @xcite . )",
    "* many rules of the ` chr ` language ( constraint handling rules ) of @xcite that are used in specific constraint solvers are in fact membership rules . in the logic programming approach to constraint programming ` chr ` is the language of choice to write constraint solvers .    the implementation is provided as an ecl@xmath4ps@xmath5 program that accepts a set of membership rules as input and constructs an ecl@xmath4ps@xmath5 program that is the instantiation of the ` r ` algorithm for this set of rules . since membership rules can be naturally represented as ` chr ` propagation rules , one can assess this implementation by comparing it with the performance of the standard implementation of membership rules in the `",
    "chr ` language . by means of various benchmarks we found that our implementation is considerably faster than ` chr ` .",
    "it is important to stress that this implementation was obtained by starting from `` first principles '' in the form of a generic iteration algorithm on an arbitrary partial ordering .",
    "this shows the practical benefits of studying the constraint propagation process on an abstract level .",
    "additionally , we clarify how to identify _ prop _ rules that are redundant for the considered computations and how to compute appropriately reduced sets of rules .",
    "the concept of redundancy is formalized here in a `` semantic '' sense that takes into account the type of computations performed by means of the considered rules .",
    "we provide a simple test for redundancy that leads to a natural way of computing minimal sets of rules in an appropriate sense .",
    "the computation of a specific minimal set for the membership rules is then implemented in ecl@xmath4ps@xmath5 .    `",
    "chr ` is available in a number of languages including the ecl@xmath4ps@xmath5 and the sicstus prolog systems . in both cases",
    "` chr ` programs are compiled into the host language , so either ecl@xmath4ps@xmath5 or the sicstus prolog .",
    "there is also a recent implementation in java , see @xcite . to make ` chr ` usable it is important that its implementation does not incur too much overhead . and",
    "indeed a great deal of effort was spent on implementing ` chr ` efficiently . for an account of the most recent implementation see @xcite .",
    "since , as already mentioned above , many ` chr ` rules are membership rules , our approach provides a better implementation of a subset of ` chr ` .",
    "this , hopefully , may lead to new insights into a design and implementation of languages appropriate for writing constraint solvers .",
    "the paper is organized as follows . in the next section",
    "we briefly recall the original generic iteration algorithm of @xcite and modify it successively to obtain the iteration algorithm ` r ` for _ prop _ rules .",
    "an important novelty is the preprocessing phase during which we analyze the mutual dependencies between the rules .",
    "this allows us to remove permanently some rules during the iteration process .",
    "this permanent removal of the scheduled rules is particularly beneficial in the context of constraint programming where it leads to accumulated savings when constraint propagation is intertwined with splitting .    in section  [ sec : concrete ] we recall the membership rules of @xcite and show that they are _ prop _ rules .",
    "then in section  [ sec : implementation ] we recall the relevant aspects of the ` chr ` language , discuss the implementation of the ` r ` algorithm and present several benchmarks .",
    "finally , in section  [ sec : redundancy ] we deal with the subject of redundancy of _ prop _ rules .",
    "let us begin our presentation by recalling the generic algorithm of @xcite .",
    "we slightly adjust the presentation to our purposes by assuming that the considered partial ordering also has the greatest element @xmath6 .",
    "so we consider a partial ordering @xmath7 with the least element @xmath8 and the greatest element @xmath6 , and a set of functions @xmath9 on @xmath10 .",
    "we are interested in functions that satisfy the following two properties .",
    "* @xmath11 is called _ inflationary _ if @xmath12 for all @xmath1 .",
    "* @xmath11 is called _ monotonic _ if @xmath13 implies @xmath14 for all @xmath15 .",
    "the following algorithm is used to compute the least common fixpoint of the functions from @xmath16 .",
    "generic iteration algorithm ( gi )    = @xmath17 ; + @xmath18 ; + @xmath19 * and * @xmath20 * do * + choose @xmath21 ; + @xmath22 ; + @xmath23 ; + @xmath24 +    where for all @xmath25 the set of functions @xmath26 from @xmath16 is such that    * a * : :    @xmath27 , * b * : :    @xmath28 implies that    @xmath29 , * c * : :    @xmath30 implies that    @xmath31 .    intuitively , assumption * a * states that @xmath26 contains at least all the functions from @xmath32 for which the `` old value '' , @xmath33 , is a fixpoint but the `` new value '' , @xmath34 , is not .",
    "so at each loop iteration such functions are added to the set @xmath35 . in turn , assumption * b * states that no functions are added to @xmath35 in case the value of @xmath33 did not change .",
    "assumption * c * provides information when @xmath36 is to be added back to @xmath35 as this information is not provided by * a*. on the whole , the idea is to keep in @xmath35 at least all functions @xmath11 for which the current value of @xmath33 is not a fixpoint .",
    "the use of the condition @xmath20 , absent in the original presentation , allows us to leave the * while * loop earlier .",
    "our interest in the gi algorithm is clarified by the following result .",
    "[ thm : gi ] suppose that all functions in @xmath16 are inflationary and monotonic and that @xmath7 is finite and has the least element @xmath8 and the greatest element @xmath6 .",
    "then every execution of the gi algorithm terminates and computes in @xmath33 the least common fixpoint of the functions from @xmath16 .    * proof .",
    "*  consider the predicate @xmath37 defined by : @xmath38 note that @xmath37 is established by the assignment @xmath18 .",
    "moreover , it is easy to check that by virtue of the assumptions * a * , * b * and * c * the predicate @xmath37 is preserved by each * while * loop iteration . thus @xmath37 is an invariant of the * while * loop of the algorithm .",
    "hence upon its termination @xmath39 holds , which implies @xmath40    this implies that the algorithm computes in @xmath33 a common fixpoint of the functions from @xmath16 .",
    "the rest of the proof is the same as in @xcite .",
    "so the fact that this is the least common fixpoint follows from the assumption that all functions are monotonic .    in turn",
    ", termination is established by considering the lexicographic ordering of the strict partial orderings @xmath41 and @xmath42 , defined on the elements of @xmath43 by @xmath44 then with each * while * loop iteration of the algorithm the pair @xmath45 , where @xmath46 is the cardinality of the set @xmath35 , strictly decreases in the ordering @xmath47 .",
    "we now revise the gi algorithm by modifying dynamically the set of functions that are being scheduled .",
    "the idea is that , whenever possible , we remove functions from the set @xmath16 .",
    "this will allow us to exit the loop earlier which speeds up the execution of the algorithm .",
    "to this end we assume that for each function @xmath48 and each element @xmath49 , two lists of functions from @xmath16 are given , @xmath50 and @xmath51 , to be instantiated below .",
    "we then modify the gi algorithm in such a way that each application of @xmath36 to @xmath33 will be immediately followed by the applications of all functions from @xmath50 and by a removal of the functions from @xmath50 and from @xmath51 from @xmath16 and @xmath35 .",
    "below we identify a condition , ( [ eq : stable ] ) , on @xmath50 and @xmath51 that ensures correctness of this scheduling strategy .",
    "informally , this condition states that after an application of all the functions from @xmath50 the functions from @xmath50 and from @xmath51 will not change anymore the subsequent values of @xmath33 .",
    "this modified algorithm has the following form .",
    "revised generic iteration algorithm ( rgi )    = @xmath17 ; + @xmath52 ; + @xmath18 ; + @xmath19 * and * @xmath20 * do * + choose @xmath21 ; + @xmath22 ; + @xmath53 ; + @xmath54 ; + @xmath35 = @xmath55 , + where @xmath56 $ ] and @xmath57 ; + @xmath58 +    we now formalize the condition under which the correctness theorem [ thm : gi ] holds with the gi algorithm replaced by the rgi algorithm . to this end we consider the following property .",
    "suppose @xmath49 and @xmath59 .",
    "we say that @xmath11 is _ stable above @xmath33 _ if @xmath60 implies @xmath61 .",
    "we then say that @xmath11 is _ stable _ if it is stable above @xmath62 , for all @xmath33",
    ".    that is , @xmath11 is stable if for all @xmath33 and @xmath63 , @xmath64 implies @xmath61 .",
    "so stability implies idempotence , which means that @xmath65 , for all @xmath33 .",
    "moreover , if @xmath33 and @xmath62 are comparable for all @xmath33 , then stability implies inflationarity .",
    "indeed , if d @xmath66@xmath62 , then the claim holds vacuously . and if @xmath67 , then by stability @xmath68 .",
    "consider now the following condition @xmath69 where @xmath56 $ ] .",
    "that is , for all elements @xmath33 , each function @xmath11 in is stable above @xmath70 , where @xmath50 is the list @xmath71 $ ] .",
    "the following result holds .",
    "suppose that all functions in @xmath16 are inflationary and monotonic and that @xmath7 is finite and has the least element @xmath8 and the greatest element @xmath6 .",
    "additionally , suppose that for each function @xmath48 and @xmath49 two lists of functions from @xmath16 are given , @xmath50 and @xmath51 such that condition ( [ eq : stable ] ) holds .",
    "then the correctness theorem [ thm : gi ] holds with the gi algorithm replaced by the rgi algorithm",
    ".    * proof . *  in view of condition ( [ eq : stable ] ) the following statement is an invariant of the * while * loop : @xmath72 so upon termination of the algorithm the conjunction of this invariant with the negation of the loop condition , i.e. , @xmath73 holds , which implies that @xmath74 .",
    "the rest of the proof is the same .      in what follows",
    "we consider the situation when the scheduled functions are of a specific form @xmath75 , where @xmath76 is a _ condition _ and @xmath36 a function , that we call a _ body_. we call such functions",
    "_ rules_.    first , we explain how rules are applied .",
    "given an element @xmath33 of @xmath10 a condition @xmath76 is evaluated in @xmath33 .",
    "the outcome is either _ true _ , that we denote by @xmath77 , or _",
    "false_.    given a rule @xmath75 we define then its application to @xmath33 as follows : @xmath78    we are interested in a specific type of conditions and rules .",
    "consider a partial ordering @xmath7 .",
    "* we say that a condition @xmath76 is _ monotonic _ if for all @xmath79 we have that @xmath77 and @xmath60 implies @xmath80 .",
    "* we say that a condition @xmath76 is _ precise _ if the least @xmath33 exists such that @xmath77 .",
    "we call then @xmath33 the _ witness _ for @xmath76 .",
    "* we call a rule @xmath75 a _ _ prop _ _ rule if @xmath76 is monotonic and precise and @xmath36 is stable .    to see how natural this class of rules is consider the following example .",
    "take a set @xmath81 and consider the partial ordering @xmath82 in this ordering the empty set @xmath83 is the least element and @xmath81 is the greatest element .",
    "we consider rules of the form @xmath84 where @xmath85 .    to clarify how they are applied to subsets of @xmath81",
    "we first stipulate for @xmath86 @xmath87 then we view a set @xmath35 as a function on @xmath88 by putting @xmath89 this determines the rule application of @xmath90 .",
    "it is straightforward to see that such rules are _ prop _ rules . in particular ,",
    "the element @xmath91 of @xmath88 is the witness for the condition @xmath91 . for the stability of @xmath35 take @xmath86 and suppose @xmath92 .",
    "then @xmath93 , so @xmath94 , which implies @xmath95 , i.e. , @xmath96 .",
    "such rules can be instantiated to many situations .",
    "for example , we can view the elements of the set @xmath81 as primitive constraints .",
    "then each rule @xmath90 is a natural operation on the constraint store : if all constraints in @xmath91 are present in the store , then add to it all constraints in @xmath35 .",
    "alternatively , we can view @xmath81 as a set of some atomic formulas and each rule @xmath90 as a proof rule , usually written as @xmath97 the minor difference with the usual proof - theoretic framework is that rules have then a single conclusion .",
    "an axiom is then a rule with the empty set @xmath83 as the condition .",
    "a closure under such a set of rules is then the set of all ( atomic ) theorems that can be proved using them .",
    "the algorithm presented below can in particular be used to compute efficiently the closure under such proof rules given a finite set of atomic formulas @xmath81 .",
    "we now modify the ` rgi ` algorithm for the case of _ prop _ rules . in the algorithm below we take into account that an application of a rule is a two step process : testing of the condition followed by a conditional application of the body .",
    "this will allow us to drop the parameter @xmath33 from the lists @xmath50 and @xmath51 and consequently to construct such lists before the execution of the algorithm .",
    "the list @xmath98 will be constructed in such a way that we shall not need to evaluate the conditions of its rules : they will all hold .",
    "the specific construction of the lists @xmath98 and @xmath99 that we use here will be provided in the second algorithm , called friends and obviated algorithm .",
    "rules algorithm ( r )    = @xmath17 ; + @xmath52 ; + @xmath18 ; + @xmath19 * and * @xmath20 * do * + choose @xmath100 ; suppose @xmath11 is @xmath75 ; + @xmath101 ; +   @xmath77 * then * + @xmath102 ; + @xmath103 ; + @xmath35 = @xmath55 , + where @xmath104 $ ] and @xmath105 ; + @xmath58 +   @xmath106 * then * + @xmath107 +   +    again , we are interested in identifying conditions under which the correctness theorem [ thm : gi ] holds with the gi algorithm replaced by the r algorithm . to this end , given a rule @xmath75 in @xmath16 and @xmath49 define as follows : @xmath108              &   \\mbox{otherwise } \\end{array } \\right .",
    "\\\\\\hspace*{-2.3em}\\mbox{and}\\\\ & { \\ensuremath{\\mathit{obviated}}}(b { \\ensuremath{\\rightarrow}}g , d )   & : = & \\left\\ { \\begin{array}{ll } { \\ensuremath{\\mathit{obviated}}}(b { \\ensuremath{\\rightarrow}}g ) &   \\mbox{if } { \\ensuremath{\\mathit{holds}({b},{d})}},\\\\ { } [ b { \\ensuremath{\\rightarrow}}g ]         &   \\mbox{if } \\forall e \\sqsupseteq d \\ ; \\neg{\\ensuremath{\\mathit{holds}({b},{e})}},\\\\ { } [ \\ ]               &   \\mbox{otherwise } \\end{array } \\right .",
    "\\end{array}\\ ] ]    we obtain the following counterpart of the correctness theorem [ thm : gi ] .    [ thm : r ] suppose that all functions in @xmath16 are _ prop _ rules of the form @xmath75 , where @xmath36 is inflationary and monotonic , and that @xmath7 is finite and has the least element @xmath8 and the greatest element @xmath6 .",
    "further , assume that for each rule @xmath75 the lists @xmath109 and @xmath110 defined as above satisfy condition  ( [ eq : stable ] ) and the following condition : @xmath111 then the correctness theorem [ thm : gi ] holds with the gi algorithm replaced by the r  algorithm .",
    "*  it suffices to show that the r algorithm is an instance of the rgi algorithm . on the account of condition ( [ eq : friends ] ) and the fact that the rule bodies are inflationary functions",
    ", @xmath77 implies that @xmath112 where @xmath113 $ ] .",
    "this takes care of the situation in which @xmath77 is true .    in turn",
    ", the definition of @xmath109 and @xmath110 and assumption * b * take care of the situation when @xmath114 .",
    "when the condition @xmath76 fails for all @xmath115 we can conclude that for all such @xmath63 we have @xmath116 .",
    "this allows us to remove at that point of the execution the rule @xmath75 from the set @xmath16 .",
    "this amounts to adding @xmath75 to the set @xmath117 at runtime .",
    "note that condition  ( [ eq : stable ] ) is then satisfied .",
    "we now provide an explicit construction of the lists @xmath118 and @xmath119 for a rule @xmath75 in the form of the following algorithm .",
    "@xmath120 stands here for the ` gi ` algorithm activated with @xmath8 replaced by @xmath33 and the considered set of rules as the set of functions @xmath16 .",
    "further , given an execution of @xmath121 , we call here a rule @xmath36 _ relevant _ if at some point @xmath122 holds after the `` choose @xmath21 '' action .    friends and obviated algorithm ( f & o )    = @xmath123 witness of @xmath76",
    "; + @xmath124 ; + @xmath125 list of the relevant rules @xmath126 in the execution of @xmath127 ; + @xmath128 $ ] ; + @xmath129 * do * + @xmath130  * or *   @xmath131 * then * + @xmath132 $ ] +   +    note that @xmath75 itself is not contained in @xmath133 as it is a _ prop _ rule , however it is in @xmath134 , since by the stability of @xmath36  @xmath28 holds .",
    "the following observation now shows the adequacy of the f & o algorithm for our purposes .    upon termination of the f & o algorithm conditions ( [ eq : stable ] ) and ( [ eq : friends ] ) hold , where the lists @xmath109 and @xmath110 are defined as before theorem [ thm : r ] .",
    "let us summarize now the findings of this section that culminated in the r algorithm .",
    "assume that all functions are of the form of the rules satisfying the conditions of the correctness theorem [ thm : r ] .",
    "then in the r algorithm , each time the evaluation of the condition @xmath76 of the selected rule @xmath75 succeeds ,    * the rules in the list @xmath133 are applied directly without testing the value of their conditions , * the rules in @xmath135 are permanently removed from the current set of functions @xmath35 and from @xmath16",
    ".      another important optimization takes place when the r algorithm is repeatedly applied to compute the least fixpoint .",
    "more specifically , consider the following sequence of actions :    * we compute the least common fixpoint @xmath33 of the functions from @xmath16 , * we move from @xmath33 to an element @xmath63 such that @xmath60 , * we compute the least common fixpoint above @xmath63 of the functions from @xmath16 .",
    "such a sequence of actions typically arises in the framework of csps , further studied in section  [ sec : concrete ] .",
    "the computation of the least common fixpoint @xmath33 of the functions from @xmath16 corresponds there to the constraint propagation process for a constraint @xmath136 .",
    "the moving from @xmath33 to @xmath63 such that @xmath60 corresponds to splitting or constraint propagation involving another constraint , and the computation of the least common fixpoint above @xmath63 of the functions from @xmath16 corresponds to another round of constraint propagation for @xmath136 .",
    "suppose now that we computed the least common fixpoint @xmath33 of the functions from @xmath16 using the rgi algorithm or its modification ` r ` for the rules .",
    "during its execution we permanently removed some functions from the set @xmath16 .",
    "these functions are then not needed for computing the least common fixpoint above @xmath63 of the functions from @xmath16 .",
    "the precise statement is provided in the following simple , yet crucial , theorem .",
    "[ thm : repeated ] suppose that all functions in @xmath16 are inflationary and monotonic and that @xmath7 is finite .",
    "suppose that the least common fixpoint @xmath137 of the functions from @xmath16 is computed by means of the rgi algorithm or the r algorithm .",
    "let @xmath138 be the final value of the variable @xmath16 upon termination of the rgi algorithm or of the r algorithm .",
    "suppose now that @xmath139 .",
    "then the least common fixpoint @xmath140 above @xmath63 of the functions from @xmath16 coincides with the least common fixpoint above @xmath63 of the functions from @xmath138 .    * proof .",
    "*  take a common fixpoint @xmath141 of the functions from @xmath138 such that @xmath142 .",
    "it suffices to prove that @xmath141 is common fixpoint of the functions from @xmath16 .",
    "so take @xmath143 .",
    "since condition ( [ eq : del ] ) is an invariant of the main * while * loop of the rgi algorithm and of the r algorithm , it holds upon termination and consequently @xmath11 is stable above @xmath137 . but",
    "@xmath139 and @xmath142 , so we conclude that @xmath144 .",
    "intuitively , this result means that if after splitting we relaunch the same constraint propagation process we can disregard the removed functions .    in the next section we instantiate",
    "the ` r ` algorithm by a set of rules that naturally arise in the context of constraint satisfaction problems with finite domains . in section  [ sec : implementation ] we assess the practical impact of the discussed optimizations .",
    "we now proceed with the main topic of this paper , the schedulers for the rules that naturally arise in the context of constraint satisfaction problems .",
    "first we recall briefly the necessary background on the constraint satisfaction problems .",
    "consider a sequence of variables @xmath145 where @xmath146 , with respective domains @xmath147 associated with them .",
    "so each variable @xmath148 ranges over the domain @xmath149 . by a _",
    "@xmath136 on @xmath150 we mean a subset of @xmath151 . given an element @xmath152 of @xmath153 and a subsequence @xmath154 of @xmath150 we denote by @xmath155 $ ] the sequence @xmath156 .",
    "in particular , for a variable @xmath148 from @xmath150 , @xmath157 $ ] denotes @xmath158 .",
    "recall that a _ constraint satisfaction problem _ , in short csp , consists of a finite sequence of variables @xmath150 with respective domains @xmath159 , together with a finite set @xmath160 of constraints , each on a subsequence of @xmath150 . we write it as @xmath161 , where @xmath145 and @xmath162 .    by a _ solution _ to @xmath161",
    "we mean an element @xmath163 such that for each constraint @xmath164 on a sequence of variables @xmath150 we have @xmath165 \\in c$ ] .",
    "we call a csp _ consistent _ if it has a solution",
    ". two csps with the same sequence of variables are called _ equivalent _ if they have the same set of solutions .      with each csp",
    "@xmath166 we associate now a specific partial ordering .",
    "initially we take the cartesian product of the partial orderings @xmath167 .",
    "so this ordering is of the form @xmath168 where we interpret @xmath169 as the cartesian product of the reversed subset ordering .",
    "the elements of this partial ordering are sequences @xmath170 of respective subsets of @xmath171 ordered by the component - wise reversed subset ordering .",
    "note that in this ordering @xmath171 is the least element while @xmath172 is the greatest element .",
    "however , we would like to identify with the greatest element all sequences that contain as an element the empty set .",
    "so we divide the above partial ordering by the equivalence relation @xmath173 according to which    @xmath174 iff = @xmath175 + or ( @xmath176 and @xmath177 ) .",
    "it is straightforward to see that @xmath173 is indeed an equivalence relation .    in the resulting quotient ordering",
    "there are two types of elements : the sequences @xmath170 that do not contain the empty set as an element , that we continue to present in the usual way with the understanding that now each of the listed sets is non - empty , and one `` special '' element equal to the equivalence class consisting of all sequences that contain the empty set as an element .",
    "this equivalence class is the greatest element in the resulting ordering , so we denote it by @xmath6 . in what follows",
    "we denote this partial ordering by @xmath178 .",
    "fix now a specific csp @xmath166 with finite domains .",
    "we recall the rules introduced in @xcite .",
    "they are called _ membership rules _ and are of the form @xmath179 where    * @xmath180 are pairwise different variables from the set @xmath181 and @xmath182 are subsets of the respective variable domains , * @xmath183 are variables from the set @xmath181 and @xmath184 are elements of the respective variable domains . and",
    "@xmath183 have no variable in common .",
    "we drop this condition so that we can combine the membership rules . ]",
    "note that we do not assume that the variables @xmath183 are pairwise different .",
    "the computational interpretation of such a rule is :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if for @xmath185 $ ] the current domain of the variable @xmath186 is included in the set @xmath187 , then for @xmath188 $ ] remove the element @xmath189 from the domain of @xmath190 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    when each set @xmath187 is a singleton , we call a membership rule an _ equality rule_.    let us mention here that in @xcite the interpretation of the conditions of an equality rule is slightly different , as it is stipulated that the current domain of the variable @xmath186 is to be equal to the singleton set @xmath187 . however , in the discussed algorithms the membership rules are applied only when all variable domains are non - empty and then both interpretations coincide",
    ".    let us reformulate this interpretation so that it fits the framework considered in the previous section . to this end",
    "we need to clarify how to    * evaluate the condition of a membership rule in an element of the considered partial ordering , * interpret the conclusion of a membership rule as a function on the considered partial ordering .",
    "let us start with the first item",
    ".    given a variable @xmath2 with the domain @xmath191 and @xmath192 we define @xmath193 and extend the definition to the elements of the considered ordering @xmath178 by putting @xmath194    furthermore we interpret a sequence of conditions as a conjunction , by putting @xmath195 .",
    "\\end{array}\\ ] ]    concerning the second item we proceed as follows .    given a variable @xmath3 with the domain @xmath196",
    "we interpret the atomic formula @xmath197 as a function on @xmath198 , defined by : @xmath199    then we extend this function to the elements of the considered ordering @xmath178 as follows :    * on the elements of the form @xmath170 we put @xmath200 where * * if @xmath201 , then @xmath202 , * * if @xmath203 , then @xmath204 .",
    "+ if the resulting sequence @xmath205 contains the empty set , we replace it by  @xmath6 , * on the element @xmath6 we put @xmath206    finally , we interpret a sequence @xmath207 of atomic formulas by interpreting each of them in turn .",
    "as an example take the csp @xmath208 and consider the membership rule @xmath209 then we have    @xmath210    in view of the correctness theorem [ thm : r ] the following observation allows us to apply the ` r ` algorithm when each function is a membership rule and when for each rule @xmath75 the lists @xmath133 and @xmath134 are constructed by the f  &  o algorithm .",
    "consider the partial ordering @xmath178 .    1 .",
    "each membership rule is a _ prop _ rule . 2 .",
    "each function @xmath207 on @xmath211 is * inflationary , * monotonic .    to be able to instantiate the algorithm",
    "` r ` with the membership rules we still need to define the set @xmath26 . in our implementation we chose the following simple definition : @xmath212    to illustrate the intuition behind the use of the lists @xmath133 and @xmath134 take the above csp @xmath208 and consider the membership rules @xmath213 then upon application of rule @xmath214 rule @xmath215 can be applied without evaluating its condition and subsequently rule @xmath216 can be deleted without applying it .",
    "so we can put rule @xmath215 into @xmath217 and rule @xmath216 into @xmath218 and this is in fact what the f & o algorithm does .",
    "in this section we discuss the implementation of the ` r ` algorithm for the membership rules and compare it by means of various benchmarks with the ` chr ` implementation in the ecl@xmath4ps@xmath5 system .",
    "following @xcite the membership rules are represented as ` chr ` propagation rules with one head .",
    "recall that the latter ones are of the form @xmath219 where    * @xmath220 , @xmath221 , * the atom @xmath222 of the _ head _ refers to the defined constraints , * the atoms of the _ guard _ @xmath223 refer to prolog relations or built - in constraints , * the atoms of the _ body _ @xmath224 are arbitrary atoms .",
    "further , recall that the chr propagation rules with one head are executed as follows .",
    "first , given a query ( that represents a csp ) the variables of the rule are renamed to avoid variable clashes .",
    "then an attempt is made to match the head of the rule against the first atom of the query .",
    "if it is successful and all guards of the instantiated version of the rule succeed , the instantiated version of the body of the rule is executed . otherwise the next rule is tried .",
    "finally , let us recall the representation of a membership rule as ` chr ` a propagation rule used in @xcite . consider the membership rule @xmath225 related to the constraint ` c ` on the variables @xmath226 .",
    "we represent its condition by starting initially with the atom @xmath227 as the head .",
    "each atomic condition of the form @xmath228 is processed by replacing in the atom @xmath229 the variable @xmath186 by @xmath230 . in turn , each atomic condition of the form @xmath231 , where @xmath187 is not a singleton , is processed by adding the atom @xmath232 to the guard of the propagation rule .",
    "the in/2 predicate is defined by @xmath233 so in(x , l ) holds if the current domain of the variable x ( yielded by the built - in dom of ecl@xmath4ps@xmath5 ) is included in the list l. in turn , @xmath234 is a list representation of the set @xmath187 .",
    "finally , each atomic conclusion @xmath235 translates to the atom @xmath190 ` # # ` @xmath189 of the body of the propagation rule .    as an example consider the membership rule @xmath236 in presence of a constraint @xmath237 on the variables",
    "it is represented by the following chr propagation rule : @xmath239 ) | z##2.+\\ ] ]    in ecl@xmath4ps@xmath5 the variables with singleton domains are automatically instantiated .",
    "so , assuming that the variable domains are non - empty , the condition of this membership rule holds iff the head of the renamed version of the above propagation rule matches the atom ` c(0,y , z ) ` _ and _ the current domain of the variable ` y ` is included in ` [ 1,2 ] ` .",
    "further , in both cases the execution of the body leads to the removal of the value 2 from the domain of ` z ` .",
    "so the execution of both rules has the same effect when the variable domains are non - empty .",
    "[ [ execution - of - chr . ] ] execution of chr .",
    "+ + + + + + + + + + + + + + + + +    in general , the application of a membership rule as defined in section  [ sec : concrete ] and the execution of its representation as a chr propagation rules coincide . moreover , by the semantics of ` chr ` , the ` chr ` rules are repeatedly applied until a fixpoint is reached .",
    "so a repeated application of a finite set of membership rules coincides with the execution of the ` chr ` program formed by the representations of these membership rules as propagation rules .",
    "an important point concerning the standard execution of a ` chr ` program is that , in contrast to the ` r ` algorithm , every change in the variable domains of a constraint causes the computation to restart .      in our approach the repeated application of a finite set of membership rules",
    "is realized by means of the ` r ` algorithm of section  [ sec : revised ] implemented in ecl@xmath4ps@xmath5 .",
    "the compiler consists of about 1500 lines of code .",
    "it accepts as input a set of membership rules , each represented as a ` chr ` propagation rule , and constructs an ecl@xmath4ps@xmath5 program that is the instantiation of the ` r ` algorithm for this set of rules . as in ` chr ` , for each constraint the set of rules that refer to it is scheduled separately .    in the benchmarks below for each considered csp we used the sets of all minimal valid membership and equality rules for the `` base '' constraints which were automatically generated using a program discussed in @xcite . in the first phase the compiler constructs for each rule @xmath36 the lists @xmath98 and @xmath99 .",
    "time spent on this construction is comparable with the time needed for the generation of the minimal valid equality and membership rules for a given constraint .",
    "for example , the medium - sized membership rule set for the ` rcc8 ` constraint , containing 912 rules , was generated in @xmath240  seconds while the construction of all @xmath118 and @xmath241 lists took @xmath242 seconds .    to see the impact of the accumulated savings obtained by permanent removal of the rules during the iteration process",
    ", we chose benchmarks that embody several successive propagation steps , i.e. , propagation interleaved with domain splitting or labelling .    in table",
    "[ tab : fixpoints ] we list the results for selected single constraints . for each such constraint ,",
    "say @xmath136 on a sequence of variables @xmath243 with respective domains",
    "@xmath147 , we consider the csp @xmath244 together with randomized labelling .",
    "that is , the choices of variable , value , and action ( assigning or removing the value ) , are all random .",
    "the computation of simply one or all solutions yields insignificant times , so the benchmark program computes and records also all intermediate non - solution fixpoints .",
    "backtracking occurs if a recorded fixpoint is encountered again .",
    "in essence , this benchmark computes implicitly all possible search trees .",
    "as this takes too much time for some constraints , we also impose a limit on the number of recorded fixpoints .    in turn ,",
    "in table [ tab : atpg ] we list the results for selected csps .",
    "we chose here csps that formalize sequential automatic test pattern generation for digital circuits ( atpg ) , see @xcite .",
    "these are rather large csps that employ the ` and ` constraints of table [ tab : fixpoints ] and a number of other constraints , most of which are implemented by rules .",
    "we measured the execution times for three rule schedulers : the standard ` chr ` representation of the rules , the generic chaotic iteration algorithm ` gi ` , and its improved derivative ` r ` .",
    "the codes of the latter two algorithms are both produced by our compiler and are structurally equal , hence allow a direct assessment of the improvements embodied in  ` r ` .",
    "l@ccccc + * constraint * & ` rcc8 ` & ` fork ` & ` and3 ` & ` and9 ` & ` and11 ` + membership + relative & 37% / 22% & 58% / 46% & 66% / 49% & 26% / 15% & 57% / 25% + absolute & 147/396/686 & 0.36/0.62/0.78 & 0.27/0.41/0.55 & 449/1727/2940 & + equality + relative & 97% / 100% & 98% / 94% & 92% / 59% & 95% / 100% & 96% / 101% + absolute & 359/368/359 & 21.6/21.9/22.9 & 0.36/0.39/0.61 & 386/407/385 & 342/355/338 +   +    l@cccc + * logic * & 3-valued & 9-valued & 11-valued + membership + relative & 61% / 44% & 65% / 29% & 73% / 29% + absolute & 1.37/2.23/3.09 & 111/172/385 & 713/982/2495 + equality + relative & 63% / 29% & 40% / 57% & 36% / 51% + absolute & 0.77/1.22/2.70 & 2.56/6.39/4.50 & 13.8/38.7/26.7 +   +    an important point in the implementations is the question of when to remove solved constraints from the constraint store .",
    "the standard ` chr ` representation of membership rules as generated by the algorithm of @xcite does so by containing , beside the propagation rules , one ` chr ` simplification rule for each tuple in the constraint definition .",
    "once its variables are assigned values that correspond to a tuple , the constraint is solved , and removed from the store by the corresponding simplification rule .",
    "this ` solved ' test takes place interleaved with propagation .",
    "the implementations of ` gi ` and ` r ` , on the other hand , check after closure under the propagation rules .",
    "the constraint is considered solved if all its variables are fixed , or , in the case of ` r ` , if the set @xmath16 of remaining rules is empty ( see the following subsection ) .",
    "interestingly , comparing ` chr ` and ` gi ` , the extra simplification rules sometimes constitute a substantial overhead while at other times their presence allows earlier termination .",
    "we mention briefly that our specific implementation deviates slightly from the description of ` r ` inside the ` else ` branch .",
    "the test @xmath106 in the case of a membership condition @xmath245 corresponds to testing whether the intersection @xmath246 is empty .",
    "performing this always turned out to be more costly than doing so only when @xmath191 is a singleton set .",
    "the platform for all benchmarks was a sun enterprise 450 with 4 ultrasparc - ii @xmath247mhz processors and @xmath248 gb memory under solaris , and ecl@xmath4ps@xmath5 5.5 ( non - parallel ) . in the tables we provide for each constraint or csp the ratio of the execution times in seconds between , first , ` r ` and ` gi ` , and second , ` r ` and ` chr ` .",
    "this is followed by the absolute times in the order ` r ` / ` gi ` / ` chr ` .",
    "recently , we have been experimenting with various ways of optimizing our implementation of the ` r ` algorithm . in particular",
    ", we considered a better embedding into the constraint - handling mechanism of ecl@xmath4ps@xmath5 , for instance by finer control of the waking conditions and a joint removal of the elements from the same domain . at this stage",
    "we succeeded in achieving an average speed - up by a factor of @xmath249 .",
    "this work is in progress but already shows that further improvements are possible .",
    "finally , let us illustrate the impact of the permanent removal of the rules during the least fixpoint computation , achieved here by the use of the lists @xmath98 and @xmath99 . given a set @xmath16 of rules",
    "call a rule @xmath48 _ solving _ if .",
    "take now as an example the equivalence relation @xmath250 from three valued logic of @xcite that consists of three values , @xmath251 ( true ) , @xmath252 ( false ) and @xmath253 ( unknown ) .",
    "it is defined by the truth table @xmath254 the program of @xcite generates for it 26 minimal valid membership rules . out of them 12 are solving rules . for the remaining rules the sizes of the set @xmath255 are : 17 ( for 8 rules ) , 14 ( for 4 rules ) , and 6 ( for 2 rules ) .    in the ` r ` algorithm a selection of a solving rule leads directly to the termination ( @xmath256 ) and to a reduction of the set @xmath16 to @xmath83 . for other rules ,",
    "also a considerable simplification in the computation takes place .",
    "for example , one of the 8 rules with 17 rules in the set @xmath257 is @xmath258 consider now the csp @xmath259 . in the ` r ` algorithm the selection of @xmath260 is followed by the application of the rules from @xmath118 and the removal of the rules from @xmath261 .",
    "this brings the number of the considered rules down to @xmath262 .",
    "the ` r ` algorithm subsequently discovers that none of these nine rules is applicable at this point , so this set @xmath16 remains upon termination .",
    "then in a subsequent constraint propagation phase , launched after splitting or after constraint propagation involving another constraint , the fixpoint computation by means of the ` r ` algorithm involves only these nine rules instead of the initial set of 26 rules . for solving rules",
    "this fixpoint computation immediately terminates .",
    "interestingly , as table  [ tab : solving ] shows , the solving rules occur quite frequently .",
    "we list there for each constraint and each type of rules the number of solving rules divided by the total number of rules , followed in a new line by the average number of rules in the set @xmath263 .",
    "l@ccccccc + * constraints * & ` and2 ` & ` and3 ` & ` and9 ` & ` and11 ` & ` fork ` & ` rcc8 ` & ` allen ` +   + equality & 6/6 & 13/16 & 113/134 & 129/153 & 9/12 & 183/183 & 498/498 + & 6 & 14 & 130 & 148 & 11 & 183 & 498 + membership & 6/6 & 4/13 & 72/1294 & 196/4656 & 0/24 & 0/912 & n.a./26446 + & 6 & 7 & 810 & 3156 & 9 & 556 & n.a . +    the `",
    "fork ` constraint is taken from the waltz language for the analysis of polyhedral scenes .",
    "the ` rcc8 ` is the composition table for the region connection calculus with 8 relations from @xcite .",
    "it is remarkable that all its 183 minimal valid equality rules are solving .",
    "while none of its 912 minimal valid membership rule for ` rcc8 ` is solving , on the average the set @xmath263 contains 556 membership rules .",
    "also all 498 minimal valid equality rules for the ` allen ` constraint , that represents the composition table for allen s qualitative temporal reasoning , are solving .",
    "the number of minimal valid membership rules exceeds 26,000 and consequently they are too costly to analyze .",
    "[ [ para : simplification - rules ] ] simplification rules .",
    "+ + + + + + + + + + + + + + + + + + + + +    the ` chr ` language supports besides propagation rules also so - called simplification rules . using them one can remove constraints from the constraint store ,",
    "so one can affect its form .",
    "in @xcite a method is discussed that allows one to automatically transform ` chr ` propagation rules into simplification rules that respects their semantics .",
    "it is based on identifying or constructing propagation rules that are solving .",
    "in contrast , our method captures the _ degree _ to which a rule is solving , by the ratio of the sizes of @xmath264 and the full rule set .",
    "if the sets are equal , then the ratio is @xmath265 and @xmath260 is a solving rule .",
    "consider now two non - solving rules @xmath266 , that means with @xmath267 and @xmath268 , but let also .",
    "suppose that during a fixpoint computation the conditions of both rules have succeeded , and their bodies have been applied .",
    "the ` r ` algorithm would now immediately detect that the constraint is solved , and consequently terminate . `",
    "chr ` , for which @xmath214 and @xmath215 are ordinary ( propagation ) rules , can not detect this possibility for immediate termination .",
    "the cost of a fixpoint computation by the ` gi ` algorithm or one of its derivatives depends on the number of functions involved , in particular in absence of a good strategy for selecting the functions , represented in the algorithms by the `` choose '' predicate .",
    "it is therefore important to identify functions or rules that are not needed for computing fixpoints . in the following",
    "we shall examine the issue of rule redundancy .",
    "we shall again start with arbitrary functions before moving on to ( _ prop _ ) rules .",
    "the redundancy concept we employ is based on fixpoints . in the following , for brevity ,",
    "we drop the word `` common '' when referring to common fixpoints of a set of functions .    *",
    "consider a set @xmath269 of functions on a partial ordering .",
    "a function @xmath11 is called _ redundant with respect to @xmath16 _ if the sets of fixpoints of @xmath16 and @xmath269 are equal . *",
    "a set of functions @xmath16 is called _ minimal with respect to redundancy _ ( or simply _ minimal _ ) , if no function @xmath59 is redundant with respect to @xmath270 .",
    "equivalently , we can say that a function @xmath11 is redundant w.r.t .",
    "@xmath16 if every fixpoint of @xmath16 is also a fixpoint of @xmath11 .",
    "we now focus on the subject of redundancy for _ prop _ rules .",
    "the following simple test is then useful .",
    "[ thm : redrule ] consider a set @xmath16 of _ prop _ rules and a _ prop _ rule @xmath271 with the witness @xmath272 for @xmath76 .",
    "let @xmath63 be the least fixpoint of @xmath16 greater than or equal to @xmath272 .",
    "if @xmath273 , then the rule @xmath260 is redundant with respect to @xmath16 .    * proof . *",
    "we show that @xmath273 implies that an arbitrary fixpoint @xmath33 of @xmath16 is a fixpoint of @xmath260 by a case condition .",
    "@xmath76 holds for @xmath33 : : :    we have @xmath274 since @xmath272 is the    witness for @xmath76 .",
    "also ,    @xmath275 since @xmath63 is    the least fixpoint of @xmath16 greater than or equal to    @xmath272 . from @xmath276 ,",
    "@xmath273 , and the stability of @xmath36 we    conclude @xmath28 .",
    "hence    @xmath277 .",
    "@xmath76 does not hold for @xmath33 : : :    then @xmath278 .",
    "this test is of interest to us since it allows us to compute only one fixpoint of @xmath16 instead of all fixpoints .",
    "it is effective if    * the witness can be computed , * the equality @xmath273 can be determined , and * the fixpoint computations are effective .    for the sake of fixpoint computations a rule @xmath279 with a body @xmath280 ( describing a function composition ) such that any two different @xmath281 commute can be identified with the collection @xmath282 of the rules , and vice versa .",
    "indeed , the respective fixpoints and the rule properties are the same .",
    "we consider here these two representations as equivalent .",
    "if a rule with such a `` compound '' body is not redundant it might be so in part .",
    "that is , some part of its body might be redundant or , in other words , some sub - rules of its decomposition might be .",
    "this is what we mean below by saying that a rule is _ partially _ redundant .",
    "let us consider now the task of computing minimal sets of _ prop _ rules .",
    "such sets can of course be generated by a simple bounded loop : select an untested rule , test whether it is redundant and , if so , remove it from the current set .",
    "in general , however , the obtained minimal sets depend on the selection order for testing ; see an example below . in our experiments",
    "we used a strategy that selects first the rules the execution of which is computationally expensive , for instance due to conditions on many variables . in this way",
    "we hope to obtain a set of computationally cheap rules .",
    "let us illustrate now a number of issues by means of an example .",
    "consider the constraint @xmath283 defined by @xmath284 the underlying domain for all its variables is @xmath285 .",
    "hence the induced corresponding partial order is @xmath286 the algorithm of @xcite generates eleven membership rules listed in figure  [ fig : cr ] . since the rule conditions are only equality tests , we use an alternative notation that should be self - explanatory .",
    "@xmath287    for example , rule ( 11 ) states that if @xmath288 , then it is correct to conclude from @xmath289 and @xmath290 that @xmath291 ( validity ) , and furthermore that neither @xmath289 nor @xmath290 suffices for this conclusion ( minimality ) .",
    "suppose we are interested in computing the smallest fixpoint greater than or equal to @xmath292 suppose rule ( 11 ) is considered .",
    "its application yields @xmath293 from where rule ( 4 ) leads to this is indeed a fixpoint since for each rule either its condition does not apply or the application of its body results again in @xmath294 .",
    "a second possible iteration from @xmath295 that stabilises in @xmath294 is by rule ( 5 ) followed by rule ( 10 ) .",
    "rule ( 11 ) can be applied at this point but its body does not change @xmath294 .",
    "indeed , @xmath294 is a fixpoint of all rules including rule ( 11 ) .",
    "we conclude that rule  ( 11 ) is redundant  we just performed the test of theorem  [ thm : redrule ] .",
    "the process of identifying redundant rules can then be continued for the rule set @xmath296 .",
    "one possible outcome is depicted in figure  [ fig : cr ] , where redundant parts of rules are underlined . from the 20 initial atomic conclusions 13",
    "remain , thus we find here a redundancy ratio of 35% .",
    "consider now the justification for the redundancy of rule ( 11 ) , and observe that rule ( 11 ) has no effect since rule ( 10 ) , which has the same body , was applied before .",
    "suppose now that the process of redundancy identification is started with rule ( 10 ) instead of rule ( 11 ) .",
    "this results in identifying rule ( 10 ) as redundant , with a relevant application of rule ( 11 ) .",
    "note moreover that one of the rules ( 10 ) , ( 11 ) must be present in _ any _ minimal set since their common body @xmath291 occurs in no other rule .",
    "it would seem difficult to find a criterion that prefers one rule over the other as their structure is the same .",
    "we implemented in ecl@xmath4ps@xmath5 an algorithm that computes minimal sets of membership rules .",
    "the results for some benchmark rule sets are listed in table  [ table : reduexp ] .",
    "l@ccccccc + & ` and11`@xmath297 & ` and11`@xmath298 & ` and3`@xmath297 & ` equ3`@xmath297 & ` fula2`@xmath298 & ` fork`@xmath298 & ` fork`@xmath297 +   + total & 4656 & 153 & 18 & 26 & 52 & 12 & 24 + & 4263 ( 2 ) & 0 ( 6 ) & 5 ( 0 ) & 8 ( 0 ) & 24 ( 0 ) & 0 ( 9 ) & 6 ( 6 ) + & 81% & 4% & 30% & 26% & 35% & 35% & 40%",
    "+   +    for each constraint the set of minimal membership or equality rules ( indicated respectively by the subscript `` @xmath297 '' or `` @xmath298 '' ) was computed by the rule generation algorithm of @xcite .",
    "the constraints are taken from the experiments discussed in table [ tab : fixpoints ] . additionally a 5-ary constraint ` fula ` ( standing for the well - known ` fulladder ` constraint ) is analyzed .",
    "the table shows the size of the rule set , the number of fully and , in parentheses , partially redundant rules .",
    "the redundancy ratio for the entire rule set shows the percentage of the atomic disequalities that are removed from the rule conclusions on the account of redundancy .",
    "computation times are negligible in so far as they are considerably smaller than the corresponding rule generation times .",
    "there is no simple connection between redundancy and the rule sets @xmath118 and @xmath119 of the ` r ` scheduler .",
    "for instance , it is _ not _ the case that a rule is redundant if it is contained in @xmath299 of every rule @xmath260 . nor is a redundant rule necessarily contained in @xmath299 of every rule @xmath260 . to examine this in an example , recall the rules in figure  [ fig : cr ] .",
    "all except ( 5 ) and ( 6 ) are solving rules , i.e. , each respective set @xmath300 is the complete set @xmath301 of rules , while for rules ( 5 ) and ( 6 ) this set is @xmath302 .",
    "further , neither ( 5 ) nor ( 6 ) is redundant with respect to all other rules , whereas ( 10 ) and ( 11 ) are .    [ [ benchmarks . ] ] benchmarks .",
    "+ + + + + + + + + + +    we reran the benchmarks from tables  [ tab : fixpoints ] and [ tab : atpg ] with all involved rule sets subjected to a removal of redundant rules and subsequent recomputation of the sets @xmath118 and @xmath119 .",
    "the results are reported in tables  [ tab : fixpoints : nr ] and [ tab : atpg : nr ] below .",
    "the rule sets of ` rcc8 ` were already minimal ; therefore this constraint is omitted .",
    "l@ccccc + * constraint * & ` fork ` & ` and3 ` & ` and9 ` & ` and11 ` + membership + relative & 60% / 46% & 69% / 48% & 28% / 18% & 50% / 29% + absolute & 0.32/0.53/0.70 & 0.27/0.39/0.56 & 167/589/924 & 157/316/543 + equality + relative & 97% / 93% & 97% / 64% & 96% / 101% & 96% / 101% + absolute & 21.6/22.2/23.2 & 0.37/0.38/0.58 & 386/404/384 & 341/353/339 +   +    l@cccc + * logic * & 3-valued & 9-valued & 11-valued + membership + relative & 66% / 46% & 62% / 33% & 68% / 35% + absolute & 1.32/2.00/3.05 & 37/59/114 & 70/103/199 + equality + relative & 61% / 26% & 40% / 58% & 33% / 48% + absolute & 0.72/1.18/2.73 & 2.57/6.41/4.46 & 13.8/41.0/28.6 +   +    when comparing the redundancy and non - redundancy benchmarks versions we observe that the absolute execution times are enormously reduced in the case of the constraints on higher - valued logics .",
    "this is in line with the much smaller sizes of the reduced rule sets .",
    "the ratios of the execution times , however , are barely affected .",
    "the type of a scheduler and minimality w.r.t .",
    "redundancy appear to be rather orthogonal issues .",
    "it is interesting to examine in one case the distribution of the solving degrees , i.e. , the ratios of the sizes of @xmath261 and the full rule set .",
    "recall that a ratio of @xmath265 means that the constraint is solved when the rule body has been executed .",
    "such a rule could be represented as a simplification rule in ` chr ` ( see section  [ para : simplification - rules ] ) .    in figure",
    "[ fig : solving - degree ] two membership rule sets for the constraint ` and9 ` are compared .",
    "one set contains redundant rules , the other set is minimal w.r.t .  redundancy .",
    "the rules in the minimal set are solving to a lesser degree .",
    "in particular , none is a proper solving rule .",
    "the good performance of the ` r ` algorithm in the benchmarks of tables  [ tab : fixpoints : nr],[tab : atpg : nr ] may thus be attributed not to distinguishing solving ( simplification ) rules and non - solving propagation rules , but to the _ accumulated _ effect of removing rules from the fixpoint computation .",
    "we thank christian holzbaur and eric monfroy for helpful discussions on the implementation and on an early version of this paper .",
    "the reviewers made useful comments which helped to improve the paper .",
    "\\2001 . using confluence to generate rule - based constraint solvers . in _ proceedings of the 3rd int .",
    "conf . on principles and practice of declarative programming ( ppdp 2001)_. acm , firenze , italy , 127135 .",
    "reasoning about binary topological relations . in _ proceedings of the 2nd international symposium on large spatial databases ( ssd ) _ , o.  gnther and h .- j .",
    "schek , eds .",
    "lecture notes in computer science , vol . 525 .",
    "springer - verlag , 143160 .",
    ", de  la banda , m.  g. , jeffery , d. , and stuckey , p.  j. 2001 . optimizing compilation of constraint handling rules . in _ proceedings of the 2001 international conference on logic",
    "programming_. lecture notes in computer science , vol .",
    "springer - verlag , 7489 ."
  ],
  "abstract_text": [
    "<S> we study here schedulers for a class of rules that naturally arise in the context of rule - based constraint programming . </S>",
    "<S> we systematically derive a scheduler for them from a generic iteration algorithm of @xcite . </S>",
    "<S> we apply this study to so - called membership rules of @xcite . </S>",
    "<S> this leads to an implementation that yields a considerably better performance for these rules than their execution as standard ` chr ` rules . </S>",
    "<S> finally , we show how redundant rules can be identified and how appropriately reduced sets of rules can be computed .    </S>",
    "<S> constraint programming , rule - based programming , constraint propagation </S>"
  ]
}