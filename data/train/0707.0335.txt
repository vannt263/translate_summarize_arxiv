{
  "article_text": [
    "stochastic shortest path ( ssp ) problems constitute a large class of markov decision processes and their accurate and efficient solution is important for numerous applications including mathematical finance , optimal resource allocation , design of discrete - time risk - sensitive controls , and controlled queuing in communication networks .",
    "our goal in this paper is to study the conditions under which an important subclass of ssps can be solved by efficient label - setting methods .    in ssp the current state of the system at the @xmath0th stage",
    "is @xmath1 , an element in a finite state space @xmath2 . at the next stage",
    ", @xmath3 is a random variable , whose probability distribution on @xmath4 depends on @xmath1 and on the decision made ( control value chosen ) at the previous stage .",
    "the process terminates upon reaching a special target state @xmath5 . at each stage",
    ", our choice of control determines the incurred cost and the overall goal is to minimize the `` value function '' ( i.e. , the expected value of the total accumulated cost up to the termination ) .",
    "we provide a formal description of ssp in section [ s : ssp_general ] ; here we simply note that the dynamic programming approach yields a system of @xmath6 coupled nonlinear equations for the value function . under mild technical assumptions",
    "this system has a solution , which can be found by `` value iteration '' .",
    "however , since these iterations are performed in @xmath7 , this can be quite costly , especially considering the fact that infinitely many steps are generally needed for convergence .",
    "on the other hand , ssps can be considered as a generalization of classical deterministic shortest path ( sp ) problems on directed graphs , for which there is a variety of well - understood efficient algorithms .",
    "in particular , non - iterative _ label - setting _ methods are applicable provided the transition - costs in the graph are non - negative . if a constant @xmath8 is an upper bound on outdegrees , dijkstra s method @xcite and dial s method @xcite solve the deterministic dynamic programming equations in @xmath9 and @xmath10 operations respectively .",
    "we provide a brief overview of these methods in section [ ss : ls_determ ] , but here we simply note that both methods hinge on the _ absolute causality _ present in a deterministic problem : the fact that the value function is decreasing along every optimal path to @xmath5 .    thus , to build similar methods for ssps , one needs to find similar causal properties in the stochastic problem .",
    "in fact , bertsekas showed that a dijkstra - like method will correctly compute the value function of an ssp if there exists a _ consistently improving optimal policy _",
    "ii , p.98 ) . in section [ ss : ls_general_ssp ]",
    "we define a similar notion of a _ consistently @xmath11-improving optimal policy _ , which guarantees the applicability of a dial - like method . unfortunately , both of these criteria are implicit since the existence of such optimal policies is generally not known a priori .",
    "the main contribution of this paper is the development of explicit conditions on transition cost function(s ) , which guarantee the existence of consistently improving and/or consistently @xmath11-improving optimal policies for a large class of _ multimode ssps_. the exact class of ssps that we consider is formally defined in section [ s : mssp ] , but generally our criteria apply provided    1 .",
    "each state @xmath12 has a collection of `` modes '' @xmath13  ( possibly overlapping ) subsets of @xmath4 ; 2 .",
    "each individual control is restricted to one of the modes ( i.e. , has non - zero transition probabilities only into the states available in that mode ) ; 3 .",
    "there exists an available control corresponding to each possible probability distribution over the states in each mode ; 4 .",
    "the control - cost is defined for each mode separately as a continuous function of the corresponding probability distribution over the states in that mode .    in this",
    "setting , it is natural to interpret the decision made at each stage as a deterministic choice among the modes of @xmath1 plus the choice of a desirable probability distribution for the transition to one of the states in that mode .",
    "this class obviously includes the classical sp problem ( when each mode contains only one possible successor - state ) .",
    "more interestingly , it includes the problem of selecting optimal randomized / mixed controls for deterministic shortest path problems , when such randomized / mixed controls might be available at a discount . in section [ ss : mssp_modeling ] we consider several representative examples and discuss the differences between _ explicitly causal _ problems ( where the causality stems from a particularly simple structure of transition probabilities ) and _ absolutely causal _ problems ( where the applicability of label - setting methods stems from certain properties of transition costs , as derived in section [ ss : cost_criteria ] ) .",
    "the multimode ssps also include ( but are not limited to ) the markov chain approximations of deterministic continuous optimal trajectory problems .",
    "( e.g. , consider a vehicle starting at some point @xmath14 inside the domain @xmath15 , which is controlled to minimize the time needed to reach the boundary @xmath16 . ) the value function for such problems is typically found as a viscosity solution of a static first - order hamilton - jacobi pde .",
    "it is well - known that semi - lagrangian discretizations of that pde ( similar to those in @xcite and @xcite ) can also be obtained from controlled markov processes on the underlying grids .",
    "this approach was pioneered by kushner and dupuis @xcite to design approximation schemes for deterministic and stochastic continuously - controlled processes .",
    "recent extensions include higher - order approximations @xcite and methods for stochastic differential games @xcite .",
    "the resulting systems of equations are typically treated iteratively , but relatively recently provably convergent label - setting algorithms were introduced for several important subclasses . for the isotropic case ( when the vehicle s speed depends only on its current position in @xmath17 and is independent of the chosen direction of motion ) , the corresponding pde is eikonal . in 1994",
    "tsitsiklis introduced the first dijkstra - like and dial - like methods for semi - lagrangian discretizations of this pde on a uniform cartesian grid @xcite .",
    "the family of dijkstra - like fast marching methods , introduced by sethian in @xcite and extended by sethian and co - authors in @xcite , was developed for eulerian upwind discretizations of the eikonal pde in the context of isotropic front propagation problems .",
    "a detailed discussion of similarities and differences of these approaches can be found in @xcite .",
    "more recently , another dial - like method for the eikonal pde on a uniform grid was introduced in @xcite . for the anisotropic case ,",
    "the resulting semi - lagrangian discretization typically does not have that causal property and the label - setting methods are not directly applicable .",
    "the label - setting ordered upwind methods @xcite circumvent this difficulty ; the key idea behind them can be interpreted as `` modifying the computational stencil on - the - fly to ensure the causality '' . in the appendix of @xcite we also demonstrated that the causality is present for the first - order semi - lagrangian discretizations of the eikonal pde on arbitrary acute meshes .    in all of the above cases the proofs of causality heavily relied on a geometric interpretation of the problem ( e.g. , a discretization of a particular pde on a specific grid or mesh in @xmath18 ) .",
    "in contrast , we first demonstrate that the applicability of label - setting methods to multimode ssps can be proven even if no geometric interpretation is available ( section [ s : mssp ] ) .",
    "we then show that the absolute causality of prior numerical methods for the eikonal pde can be easily re - derived from the more general criteria introduced in here .",
    "in addition , our formulation yields two new results for deterministic continuous optimal trajectory problems ( section [ s : hjb_discr ] ) : + @xmath19 a formula for the bucket - width in a dial - like method for eikonal pdes on acute meshes ; + @xmath19 an applicability criterion for the label - setting techniques in anisotropic optimal control problems .",
    "+ finally , in section [ s : conclusions ] we discuss the limitations of our approach and list several related open problems .",
    "typically ssp is described on a directed graph with nodes @xmath20 our exposition here closely follows the standard setting described in @xcite .    for each @xmath21",
    "the problem specifies a compact set of allowable controls @xmath22 .",
    "if @xmath21 is the current state of the process ( i.e. , if @xmath23 ) , then our choice of a control value @xmath24 determines the cost of the next transition @xmath25 as well as the probability of transition into each node @xmath26 : @xmath27 a class of problems where the transition cost @xmath28 also depends on the resulting successor node @xmath29 can also be handled in the same framework by defining @xmath30 it is assumed that the cost is accumulated until we reach the _ absorbing target _ @xmath5 , i.e. , @xmath31 and @xmath32 for @xmath33 .    consider the class of control mappings @xmath34 such that @xmath35 for all @xmath36 .",
    "policy _ is an infinite sequence of such mappings @xmath37 a _ stationary policy _ is a policy of the form @xmath38 and for the sake of brevity we will also refer to it as `` the stationary policy @xmath39 '' .",
    "if the process starts at @xmath12 ( i.e. , @xmath40 ) , the expected cost of using a policy @xmath41 is defined as @xmath42 the value function is then defined as usual @xmath43 , and a policy @xmath44 is called _ optimal _ provided @xmath45 for all @xmath36 .    if the value function @xmath46 is finite , it should satisfy the dynamic programming equations : @xmath47 and @xmath48    an operator @xmath49 is defined on @xmath7 component - wise by applying the right hand side of equation ( [ eq : markov_general ] ) ; i.e. , for any @xmath50 @xmath51 clearly , @xmath52 $ ] is a fixed point of @xmath49 and one hopes to recover @xmath53 by _ value iteration _ :    @xmath54    however , @xmath49 generally is not a contraction unless all stationary policies are known to be proper @xcite .    in @xcite bertsekas and",
    "tsitsiklis demonstrated the existence of a stationary optimal policy , the uniqueness of the fixed point of @xmath49 , and that @xmath55 for arbitrary @xmath56 under the following assumptions :    @xmath19 * ( a0 ) * all @xmath25 are lower - semicontinuous and all @xmath57 are continuous functions of controls @xmath58 .",
    "@xmath19 * ( a1 ) * there exists at least one _ proper policy _",
    "( i.e. , a policy , which reaches the target @xmath5 with probability 1 regardless of the initial state @xmath12 ) .",
    "@xmath19 * ( a2 ) * every improper policy @xmath59 will have cost @xmath60 for at least one node @xmath12 .    *",
    "( a0 ) * and the compactness of control sets @xmath61 allow us to replace `` @xmath62 '' with `` @xmath63 '' in formulas ( [ eq : markov_general ] ) and ( [ eq : generic_value_it_component ] ) . * ( a1 ) * corresponds to a graph connectivity assumption in the deterministic case while * ( a2 ) * is a stochastic analog of requiring all cycles to have positive cumulative penalty . * ( a2 ) * also follows automatically if @xmath64    the convergence of value iteration provides a way for computing @xmath53 , but generally that convergence does not occur after any finite number of iterations ( for a simple example , see figure [ fig:_infinite_vi ] ) .",
    "some error bounds are available , but typically in an implicit form only ( * ? ? ?",
    "i , section 7.2 ) . a recent work by bonet @xcite provides a polynomial upper bound on the number of value iterations required to achieve a prescribed accuracy for the case when the ratio @xmath65 is a priori known to be polynomially bounded .",
    "fast methods for deterministic discrete control problems ( e.g. , searching for a shortest path in a graph or a network ) can be found in all standard references ( e.g. , @xcite , @xcite ) and we provide a brief overview just for the sake of completeness .",
    "the dynamic programming equations are much simpler in this case : @xmath47 and @xmath66 where @xmath67 is the min - cost - to - exit starting from @xmath21 , @xmath68 is the set of nodes to which @xmath21 is connected , and @xmath69 is the cost of traversing the corresponding link . in the absence of negative cost cycles and if every @xmath70 is connected by some path to @xmath5 , the value function is finite and well - defined . value iteration ( [ eq : generic_value_it ] ) will converge to @xmath53 after at most @xmath6 iterations resulting in a @xmath71 computational cost .",
    "label - setting methods provide a better alternative if a suitable lower bound on the transition costs is available .",
    "these methods reorder the iterations over the nodes to guarantee that each @xmath72 is recomputed at most @xmath73 times , where the constant upper bound on outdegrees @xmath73 is assumed to be much smaller than the total number of nodes @xmath6 .",
    "for example , dijkstra s classical algorithm @xcite is a label - setting method for the deterministic case provided all @xmath74 .",
    "the idea is based on the causality of the system ( [ eq : optimality_determ ] ) : @xmath75 such an ordering is not known in advance and has to be obtained at run - time .",
    "the method subdivides @xmath4 into two classes : `` permanently labeled nodes '' @xmath76 and `` tentatively labeled nodes '' @xmath77 and the values for @xmath70 s in @xmath77 are successively re - evaluated using only the adjacent values already in @xmath76 : @xmath78 where @xmath79 .",
    "the algorithm is initialized by placing all nodes into @xmath77 and setting @xmath47 and @xmath80 for @xmath81 . at each stage",
    "the algorithm chooses the smallest of tentative labels @xmath82 , `` accepts ''",
    "@xmath83 ( i.e. , moves @xmath83 from @xmath77 to @xmath76 ) , and re - evaluates @xmath72 for each @xmath84 such that @xmath85 since @xmath83 is the only new element in @xmath86 , that re - evaluation can be more efficiently performed by setting @xmath87 the algorithm terminates once the list @xmath77 is empty , at which point the vector @xmath88 satisfies the system of equations ( [ eq : optimality_determ ] ) .",
    "the necessity to sort all ( finite ) temporary labels dictates the use of heap - sort data structures @xcite , usually resulting in the overall computational complexity of @xmath9 .",
    "in addition , if all @xmath89 , then dial s label - setting method is also applicable @xcite .",
    "the idea is to avoid sorting temporarily labeled nodes and instead place them into `` buckets '' of width @xmath90 based on their tentative values . if @xmath82 is the `` smallest '' of tentative labels and @xmath91 is currently in the same bucket , then even after @xmath83 is permanently labeled , it can not affect @xmath91 since @xmath92 thus , a typical stage of dial s method consists of `` accepting '' ( or declaring labels to be permanent ) for everything in the current bucket , recomputing all nodes in @xmath77 adjacent to those newly labeled permanent , switching them to other buckets if warranted by the new tentative labels , and then moving on to the next bucket . since inserting to and deleting from a bucket can be performed in @xmath93 time , the overall computational complexity of dial s method becomes @xmath10 .",
    "in addition , while dijkstra s approach is inherently sequential , dial s method is naturally parallelizable .",
    "many other enhancements of the above label - setting methods are available in the literature ( e.g. , see @xcite and references therein ) .",
    "most of those enhancements can be also used with the label - setting of ssp  provided the basic versions of the above algorithms are applicable .",
    "given a stationary policy @xmath39 for a general ssp , we can construct its directed _ dependency graph _",
    "@xmath94 using the nodes @xmath95 and connecting @xmath70 to @xmath29 if @xmath96 . assuming * ( a0 ) * , * ( a1 ) * and * ( a2 ) * , it is easy to show that the value iteration for this problem converges after at most @xmath6 iterations provided there exists an optimal stationary policy @xmath97 such that @xmath98 is acyclic .",
    "( see ( * ? ? ?",
    "ii , section 2.2.1 ) ) . we will refer to such ssps as _",
    "causal_.    [ rem : self_transition ]",
    "this condition seems to forbid any self - transitions ( e.g. , @xmath99 for @xmath100 ) , but an ssp with self - transitions can be converted into an ssp without them by setting @xmath101    [ rem : explicit_causality ] one obvious set of causal ssps consists of all problems where the dependency graph is acyclic for _ every _ stationary policy .",
    "the ssp belongs to this class if and only if , for @xmath102 , @xmath103 we will refer to such problems as _ explicitly causal _ ( see examples [ ex : aux1 ] and [ ex : multitask ] in the later sections ) .",
    "such explicit causality is independent of the cost function and can be determined based on the available controls and the transition probabilities alone .",
    "the above property imposes a partial ordering on @xmath4 ; using that partial ordering to go through the nodes , we will clearly have the value function computed correctly in a single sweep , yielding the computational complexity of @xmath10 .",
    "thus , the applicability of label - setting methods described below is only important for ssps which are causal , but not explicitly causal .",
    "this is similar to the fact that the original dijkstra s method is not needed to solve the deterministic sp problem on any acyclic digraph .",
    "according to the definition introduced by bertsekas in @xcite , an optimal stationary policy @xmath97 is _ consistently improving _ if @xmath104 this is a stochastic equivalent of the causality condition ( [ cond : causality_determ ] ) .",
    "thus , the existence of such @xmath97 not only guarantees that @xmath98 is acyclic , but also allows us to avoid the value iteration process altogether since @xmath72 s can be computed by a non - iterative dijkstra - like method instead .",
    "if a consistently improving optimal policy is known to exist , the new equivalent of the causal update equation ( [ eq : temp_labels_determ ] ) for each @xmath84 is now @xmath105 where @xmath106 is the set of controls , which make transition possible to permanently labeled nodes only , i.e. , @xmath107 .",
    "once @xmath83 is moved from @xmath77 to @xmath76 , each @xmath84 needs to be updated only if the set @xmath108 is not empty . finally , the new equivalent of the efficient update formula ( [ eq : temp_labels_local_determ ] ) is now @xmath109 if a constant @xmath8 is an upper bound on stochastic outdegrees ( i.e. , if for @xmath110 we have @xmath111 the total number of nodes @xmath29 for which @xmath112 such that @xmath113 ) , then a dijkstra - like algorithm described above will have a computational cost of @xmath9 .",
    "upon its termination , the resulting @xmath114 will satisfy the system of equations ( [ eq : markov_general ] ) .",
    "the proof of this fact is straight - forward and is listed as one of the exercises in @xcite .",
    "here we introduce a similar definition : + given @xmath115 , an optimal stationary policy @xmath97 is _ consistently @xmath11-improving _ if @xmath116 when @xmath117 , it is similarly easy to show that the existence of a consistently @xmath11-improving optimal policy guarantees the convergence of a dial - like method with buckets of width @xmath11 to the value function of the ssp . as in the deterministic case , for @xmath8",
    ", the resulting cost will be @xmath10 .",
    "every consistently @xmath11-improving policy is obviously also consistently improving ; when @xmath118 , this reduces to the previous definition .",
    "unfortunately , conditions ( [ def : improving ] ) and ( [ def : delta_improving ] ) are implicit since no optimal policy is a priori known .",
    "thus , for a general ssp applicability of label - setting methods is hard to check in advance .",
    "it is preferable ( and more practical ) to develop conditions based on functions @xmath119 and @xmath120 , which would guarantee that _ every optimal policy _ is consistently improving ( or @xmath11-improving ) .",
    "we will refer to such ssps as _",
    "absolutely @xmath11-causal _ ( or simply _ absolutely causal _ when @xmath121 ) . before developing such explicit conditions for a particular class of multimode - ssps in section [ s : mssp",
    "] , we make several remarks about the general case .",
    "+ [ rem : almost_improving ] comparing the deterministic causality condition ( [ cond : causality_determ ] ) with the condition ( [ def : improving ] ) , it might seem that a dijkstra - like method should work whenever there exists a `` consistently _ almost _ improving optimal policy '' , i.e. , an optimal @xmath97 such that @xmath122 a simple example in figure [ fig:_infinite_vi ] demonstrates that this is false .",
    "indeed , for this example a dijkstra - like method would terminate with @xmath123 even though the optimal policy is consistently almost improving and the correct value function is @xmath124 .",
    "+ [ rem : cost_lower_bound ] if @xmath97 is an optimal policy and @xmath125 , then @xmath126 this means that @xmath127 when @xmath97 is @xmath11-improving . thus , when building label - setting methods , the natural class of problems to focus on is an ssp with @xmath128 we note that * ( a2 ) * and the compactness of all @xmath61 s imply * ( a2)*.     + [ rem : reachable ] consider a reachable set @xmath129 consisting of all nodes @xmath12 such that there exists a policy @xmath59 leading from @xmath14 to @xmath5 with probability 1 . assumption * ( a1 ) * states that @xmath130 .",
    "if this is not the case , but the condition * ( a2 ) * holds , then @xmath131 for all @xmath132 .",
    "if a stationary policy @xmath97 is optimal , then * ( a2 ) * implies @xmath133 whenever @xmath134 and @xmath135 if @xmath97 also satisfies ( [ def : improving ] ) on @xmath129 , then a dijkstra - like method is still applicable . upon its termination , the value function will be computed correctly on @xmath129 and we will have @xmath136 for all @xmath137 .",
    "( this is analogous to using the original dijkstra s method on a digraph that does not contain directed paths to @xmath5 from every @xmath12 . )",
    "of course , an efficient implementation will terminate the method as soon as all nodes remaining in @xmath77 have a label of @xmath138 .",
    "+ [ rem : ls_prior_work ] it is natural to look for classes of ssps , for which either ( [ def : improving ] ) or ( [ def : delta_improving ] ) is automatically satisfied by every optimal policy .",
    "one simple example is the deterministic case : if for every @xmath139 and @xmath140 there exists @xmath141 such that @xmath142 , then every optimal policy is consistently improving due to * ( a2)*. tsitsiklis was the first to prove causality of two truly stochastic ssps @xcite , which he used to develop dijkstra - like and dial - like methods for two special discretizations of the eikonal pde on a uniform cartesian grid . for eikonal pdes",
    "discretized on arbitrary acute meshes , the equivalent of property ( [ def : improving ] ) for all optimal controls was proven in ( * ? ? ?",
    "* appendix ) .",
    "another implementation of a dial - like method for the eikonal pde was introduced in @xcite . for the optimal control of hybrid systems ,",
    "a similar property was used to build dijkstra - like methods in @xcite and @xcite .",
    "it is interesting to note that of all these papers only tsitsiklis work mentions the ssp interpretation of the discretizations , but even in @xcite the proof of causality is very problem - specific and relies on the properties of the pde and on a particular choice of the computational stencil . in section [ s : hjb_discr ]",
    "we use mssps to provide convergence criteria for dijkstra s method in the above cases as well as the bucket - width for dial s method whenever it applies .",
    "+ [ rem : lc_ssp ] whenever the value iteration converges after finitely many steps , _ label - correcting methods _",
    "become another viable alternative .",
    "their implementation for the deterministic case can be found in standard references ( e.g. , @xcite , @xcite ) .",
    "two such methods were introduced in @xcite for the ssp considered in @xcite . in a more recent work @xcite ,",
    "a similar method was applied to a finite element discretization of the hamilton - jacobi - bellman pde . in the latter case ,",
    "the label - setting is used to obtain convergence - up - to - specified - tolerance even though the equivalent of condition ( [ def : improving ] ) is not satisfied .",
    "label - setting methods have an optimal worst - case computational cost ; however , in practice label - correcting methods can outperform them on many problems .",
    "the exact conditions under which this happens are still a matter of debate even in deterministic problems . while clearly interesting , the comparison of their performance on ssps is outside the scope of the current paper .",
    "we will use @xmath143 to denote the set of possible barycentric coordinates in @xmath18 , i.e. , @xmath144 we will further define @xmath145 and use @xmath146 to denote the standard canonical basis in @xmath18 .",
    "finally , we will use @xmath147 to denote the non - negative orthant in @xmath18 , i.e. , @xmath148    we will assume the following    1 .   for every node @xmath139",
    "we are given a list of `` modes '' @xmath149 , where each mode @xmath150 is a non - empty subset of @xmath151 and @xmath152 2 .",
    "the nodes within each mode are ordered ; i.e. , @xmath153 , where @xmath154 if @xmath155 .",
    "all controls have a special structure @xmath156 and there exists an available control @xmath157 for all @xmath150 and all @xmath158 .",
    "the corresponding transition probability is @xmath159 5 .",
    "the transition costs are defined for each mode separately , i.e. , @xmath160 6 .   for @xmath161 and @xmath162",
    "the function @xmath163 is a positive continuous function of @xmath164 .",
    "there exists a constant upper bound @xmath73 on stochastic outdegrees ; + i.e. , @xmath165 for @xmath166    for these mssps it is natural to interpret the decision made at each stage as a deterministic choice of a mode @xmath167 plus the choice of a desirable probability distribution for the transition to one of the successor nodes in @xmath167 .",
    "we note that the above framework is sufficiently flexible : each node can have its own number of modes , each mode can have its own number of successor nodes , and different modes can have overlaps ( e.g. , @xmath168 can be the same as @xmath169 ) . the fully deterministic case is conveniently included when @xmath170 for each mode @xmath167 .",
    "the above assumptions imply * ( a0 ) * and * ( a2 ) * ; hence , the value iteration converges at least on the reachable subgraph @xmath129 ( see remarks [ rem : cost_lower_bound ] and [ rem : reachable ] ) .    the dynamic programming equations ( [ eq : markov_general ] ) can be now rewritten as @xmath171 before developing criteria for solvability of the above equations by label - setting methods ( subsections [ ss : mssp_causality ] and [ ss : cost_criteria ] ) we provide a number of representative examples to illustrate the mssp framework .      in this subsection",
    "we list several examples of discrete stochastic control problems , which are naturally modeled in the mssp framework .",
    "our goal is twofold : to explore the type of stochasticity present in mssps and to understand which types of mssps make the development of label - setting methods worthwhile .",
    "we begin by considering two very simple mssps , which illustrate the difference and relationship between explicit and absolute causalities .",
    "[ ex : aux1 ] for @xmath172 , suppose that each node has only one mode , and nodes @xmath173 have only one node @xmath5 in their modes .",
    "i.e. , the transition to @xmath5 is deterministic and costs @xmath174 for @xmath175 . the @xmath176 s only mode is @xmath177 .",
    "( see figure [ fig : mssp_elementary]a . )",
    "since the problem is so simple , it is clear that @xmath178    this ssp is obviously _ explicitly _ causal : @xmath179 will be computed correctly , provided it is computed after @xmath180 and @xmath181 ( see remark [ rem : explicit_causality ] ) .",
    "+ however , whether or not this ssp is _ absolutely _ causal depends on the cost function : + suppose @xmath182 is the unique minimizer of the above and @xmath183 is such that @xmath184 \\right )   + u_1 < u_3.\\ ] ] if @xmath185 , it is clear that the dijkstra - like method of section [ ss : ls_general_ssp ] would compute @xmath179 incorrectly ( since @xmath176 would be moved from @xmath77 to @xmath76 before @xmath186 ) .",
    "if label - setting methods were to be used here , we would need to find conditions on @xmath187 , which make the above scenario impossible for any choice of positive @xmath188 and @xmath189 .",
    "[ ex : circular_list ] for a somewhat more interesting example , consider a circular doubly linked list of @xmath6 nodes .",
    "( see figure [ fig : mssp_elementary]b for the case @xmath190 . )",
    "each @xmath70 has two modes : @xmath191 and @xmath192 .",
    "the applicability of label - setting methods seems harder to judge in this case , but it is clear that we do nt want @xmath70 moved from @xmath77 to @xmath76 before its neighbors if the optimal choice at @xmath70 involves a possible ( non - deterministic ) transition to one of them .",
    "for instance , @xmath193 and we note that this equation is provably absolutely causal if in example [ ex : aux1 ] a dijkstra - like method produces correct @xmath179 for all allowable @xmath188 and @xmath189 .",
    "in fact , if the same @xmath163 is used for each @xmath70 , the above condition is sufficient to show the absolute causality of the full problem .",
    "this idea is generalized in subsection [ ss : mssp_causality ] .    in practical terms ,",
    "whether or not the mssp in example [ ex : aux1 ] is absolutely causal is irrelevant since the value function can be easily computed directly ( see remark [ rem : explicit_causality ] ) .",
    "on the other hand , example [ ex : circular_list ] can be viewed as a variant of an optimal stopping problem , whose absolute causality would yield a more efficient alternative to the basic value iteration when @xmath6 is large .",
    "we continue by considering a number of interesting single - mode - for - each - node examples .",
    "in the opening act of tom stoppard s famous play @xcite , the title characters engage in statistical experimentation with supposedly fair coins . the fairness of their coins is highly suspect since they are observing a very long and uninterrupted run of `` heads '' .",
    "rosencrantz ( ros ) is bored by the game and would be glad to stop playing , but guildenstern ( guil ) insists on continuing .",
    "the following two examples are inspired by the above .",
    "[ ex : gr_1 ] suppose guil will agree to stop only after observing @xmath194 `` heads '' in a row .",
    "ros has to pay some fee for every toss of a coin and is interested in minimizing his expected total cost up to the termination . moreover , suppose that for each toss ros can request a coin with any probability distribution @xmath195 on possible outcomes ( `` heads '' vs. `` tails '' ) , but guil intends to charge him a different fee @xmath196 based on his request . the problem is to find an optimal @xmath197 $ ] that ros should request after observing @xmath198 `` heads '' in a row ( i.e. , in the state @xmath70 ) .",
    "figure [ fig : rosguil_1 ] ( left ) shows the graph representation of the game for @xmath199 . denoting @xmath200 , we set @xmath201 . since there is exactly one mode per node , and two successor - nodes only ( @xmath202 ) , the dynamic programming equations of this game can be re - written as @xmath203 }   \\left\\ {   c(p ) \\ , + \\ ,   p u_{i+1 } + ( 1-p ) u_0 \\right\\}. \\qquad \\text { for } i=0 , \\ldots , k-1.\\ ] ]    we note that the self - transition in the node @xmath204 can be dealt with in the spirit of remark [ rem : self_transition ] ; see figure [ fig : rosguil_1 ] ( right ) .",
    "this results in a deterministic transition to @xmath205 : @xmath206 } \\frac{c(p)}{p } = \\frac{c(p^*_0)}{p^*_0}.\\ ] ] after this simplification , the example satisfies all the assumptions listed for mssps ; therefore , the applicability of label - setting methods can be determined by checking if @xmath207 satisfies any of the criteria developed in section [ ss : cost_criteria ] .    even though this mssp is not explicitly causal , a simple structure of the graph makes it almost trivial for our purposes : + 1 .",
    "every ( eventually terminating ) path from @xmath70 leads through @xmath208 , which implies @xmath209 .",
    "thus , label - setting methods are only applicable if @xmath210 for all @xmath198 . + 2 . on the other hand , recursive relations similar to the one used above",
    "can be repeatedly employed to make this into a deterministic problem .",
    "for example , @xmath211 }   \\left\\ {   c(p ) \\ , + \\ ,   p u_2 + ( 1-p ) u_0 \\right\\ } = \\min\\limits_{p \\in [ 0,1 ] }   \\left\\ {   c(p ) \\ , + \\ ,   p u_2 + ( 1-p ) ( c_{01 } + u_1 ) \\right\\}\\\\ & = & \\min\\limits_{p \\in [ 0,1 ] }   \\left\\ {   \\left[c(p ) + ( 1-p ) c_{01}\\right ] \\ , + \\ ,   p u_2 + ( 1-p ) u_1 \\right\\ } = c_{12 } + u_2,\\end{aligned}\\ ] ] where @xmath212 } \\frac{c(p ) + ( 1-p ) c_{01}}{p } = \\frac{c(p^*_1 ) + ( 1-p^*_1 ) c_{01}}{p^*_1}.\\ ] ] repeating this procedure we can compute the value function in @xmath213 steps ( counting the above minimization as a single operation ) even if some of the @xmath214 s are less than one ( in which case the value iteration would not converge in a finite number of steps ) .",
    "[ rem : r_and_g_boring ]    [ ex : gr_2 ] now suppose that guil will agree to stop only after observing an uninterrupted run of @xmath215 `` heads '' or @xmath216 `` tails '' ; see figure [ fig : rosguil_2 ] .",
    "= [ draw , shape = circle , inner sep=0 mm , minimum size = 7 mm ]    ( x0 ) @xmath204 ; ( x1h ) [ above right of = x0 ] @xmath217 ; ( x2h ) [ right of = x1h ] @xmath218 ; ( x3h ) [ right of = x2h ] @xmath219 ; ( t ) [ below right of = x3h ] @xmath5 ; ( x1 t ) [ below right of = x0 ] @xmath220 ; ( x2 t ) [ right of = x1 t ] @xmath221 ;    ( x0 ) edge [ dashed ] node ( x1h ) ; ( x1h ) edge [ dashed ] node ( x2h ) ; ( x2h ) edge [ dashed ] node ( x3h ) ; ( x3h ) edge [ dashed ] node ( t ) ; ( x0 ) edge [ dotted ] node ( x1 t ) ; ( x1 t ) edge [ dotted ] node ( x2 t ) ; ( x2 t ) edge [ dotted ] node ( t ) ;    ( x1h ) edge [ dotted , bend left=10 ] node ( x1 t ) ; ( x2h ) edge [ dotted ] node ( x1 t ) ; ( x3h ) edge [ dotted ] node ( x1 t ) ;    ( x1 t ) edge [ dashed , bend left=10 ] node ( x1h ) ; ( x2 t ) edge [ dashed ] node ( x1h ) ;    identifying @xmath222 and @xmath223 , we can re - write the dynamic programming equations as @xmath224 }   \\left\\ {   c(p ) \\ , + \\ ,",
    "p u({{\\mbox{\\boldmath${x}$}}}^h_{i+1 } ) + ( 1-p ) u({{\\mbox{\\boldmath${x}$}}}^t_1 ) \\right\\ } ; \\qquad \\text { for } i=0 , \\ldots , k_h-1;\\\\ u({{\\mbox{\\boldmath${x}$}}}^t_i ) & = &   \\min\\limits_{p \\in [ 0,1 ] }   \\left\\ {   c(p ) \\",
    ", + \\ ,   p u({{\\mbox{\\boldmath${x}$}}}^h_1 ) + ( 1-p ) u({{\\mbox{\\boldmath${x}$}}}^t_{i+1 } ) \\right\\ } ; \\qquad \\text { for } i=0 , \\ldots , k_t-1.\\end{aligned}\\ ] ] since the remark [ rem : r_and_g_boring ] does not apply , in this case it is possible to have a non - trivial optimal strategy ( i.e. , @xmath225 ) , which might be computable by the label - setting methods .",
    "their applicability can be guaranteed by certain properties of the cost function as will be shown by theorems of section [ ss : cost_criteria ] .",
    "for example , this mssp is absolutely causal ( and thus efficiently computable using a dijkstra - like method regardless of specific values of @xmath215 and @xmath216 ) for @xmath226 ( recalling that @xmath227 and @xmath228 , it will be easy to check that theorems [ thm : concave ] , [ thm : homogen ] , and [ thm : second_deriv_bound ] apply to @xmath229 , @xmath230 , and @xmath231 respectively . )",
    "a similar analysis works when guil is allowed to use different prices depending on the current state of the game ( i.e. , with @xmath232 instead of @xmath196 ) or when the number of possible outcomes is higher ( e.g. , dice instead of coins , @xmath233 instead of @xmath234 . )    [ ex : multitask ] suppose a person is engaged in multi - tasking , dividing her attention between activities a and b. this allocation of resources is described by @xmath235 .",
    "we assume that + @xmath19 per every time - unit she reaches a new milestone in _",
    "exactly one _ of these activities ; + @xmath19 the probability of a milestone reached in a or b is proportional to the fraction of her attention invested in that activity ( @xmath236 or @xmath237 ) during that time - unit ; + @xmath19 the current state of the process @xmath238 reflects the number of milestones reached in both activities ; + @xmath19 the cost ( per time - unit ) of all possible resource allocations is specified by @xmath239 ; + @xmath19 the process terminates after at least @xmath240 milestones are reached in a or at least @xmath241 milestones reached in b ; + @xmath19 the goal is to minimize the total expected cost up to a termination . + a particular instance of this problem",
    "is illustrated in figure [ fig : miltitask ] .",
    "= [ draw , shape = circle , inner sep=0 mm , minimum size = 7 mm ]    ( -0.5,-0.5 ) - > ( 3.5,-0.5 ) node [ below ] a ; ( -0.5,-0.5 ) - > ( -0.5,2.5 ) node [ left ] b ;    ( x00 ) at ( 0,0 ) @xmath242 ; ( x01 ) at ( 0,1 ) @xmath243 ; ( x02 ) at ( 0,2 ) @xmath244 ; ( x10 ) at ( 1,0 ) @xmath245 ; ( x11 ) at ( 1,1 ) @xmath246 ; ( x12 ) at ( 1,2 ) @xmath247 ; ( x20 ) at ( 2,0 ) @xmath248 ; ( x21 ) at ( 2,1 ) @xmath249 ; ( x22 ) at ( 2,2 ) @xmath250 ; ( x30 ) at ( 3,0 ) @xmath251 ; ( x31 ) at ( 3,1 ) @xmath252 ;    \\(t ) at ( 3.5,2.5 ) @xmath5 ;    ( x00 ) edge [ dashed ] node ( x01 ) edge [ dotted ] node ( x10 ) ; ( x10 ) edge [ dashed ] node ( x11 ) edge [ dotted ] node ( x20 ) ; ( x20 ) edge [ dashed ] node ( x21 ) edge [ dotted ] node ( x30 ) ; ( x30 ) edge [ bend right=10 ] node ( t ) ;    ( x01 ) edge [ dashed ] node ( x02 ) edge [ dotted ] node ( x11 ) ; ( x11 ) edge [ dashed ] node ( x12 ) edge [ dotted ] node ( x21 ) ; ( x21 ) edge [ dashed ] node ( x22 ) edge [ dotted ] node ( x31 ) ; ( x31 ) edge [ ] node ( t ) ;    ( x02 ) edge [ bend left=30 ] node ( t ) ; ( x12 ) edge [ bend left=15 ] node ( t ) ; ( x22 ) edge [ ] node ( t ) ;    the above mssp is obviously explicitly causal since the number of milestones achieved in each activity can only increase as time goes on regardless of the chosen policy . as usual with explicitly causal ssps ,",
    "the causal ordering of the nodes is a priori known regardless of the cost functions and the label - setting methods are really not needed .",
    "however , a slight variation of the above is already computationally challenging :    [ ex : multitask_strong ] suppose the same person also dedicates a part of her attention to some distraction d and her resource allocation is now @xmath253 , where @xmath254 is the probability of getting completely distracted and inadvertently `` resetting '' the process ( i.e. , transition into @xmath242 ) .",
    "if the diversion is appealing ( i.e. , if @xmath239 is a decreasing function of @xmath254 ) , this problem is not explicitly causal and the applicability of label - setting methods becomes relevant . the possibility of self - transition in @xmath242 is again dealt with in the spirit of remark [ rem : self_transition ] and theorems from section [ ss : cost_criteria ] can be then used to test for the absolute causality .",
    "generalizations of this example ( to an arbitrary number of activities and/or partial resets due to a diversion ) can be handled similarly .",
    "we note that the mssps occupy a niche in between purely deterministic and generally stochastic shortest path problems .",
    "it is easy to see that in all of the above examples the stochastic aspect of the model is not due to some uncontrollable event ( after all , the deterministic / pure controls are always available in mssps ) , but rather due to our belief that a randomized / mixed control might carry a lower cost .",
    "+ [ rem : randomized_mixed ] in most deterministic discrete control problems mixed policies are considered unnecessary .",
    "but this is mainly due to the fact that the cost of implementing such mixed / randomized controls is usually modeled by a linear function , i.e. , @xmath255 ( more generally , theorem [ thm : concave ] will show that an optimal control can be found among the pure controls @xmath256 for any concave cost function . ) however , if the cost is non - concave , i.e. , if @xmath257 for at least some @xmath158 , then a mixed strategy is available `` at a discount '' and might be advantageous .",
    "the methods developed in this paper are therefore most useful for mssps that + @xmath19 are not explicitly causal ( otherwise direct methods are more efficient ) ; + @xmath19 but are absolutely causal due to ( possibly non - concave ) costs satisfying criteria in section [ ss : cost_criteria ] .",
    "additional examples ( stemming from discretizations of continuous optimal control problems ) are discussed in section [ s : hjb_discr ] .",
    "checking whether a given mssp is absolutely causal can be hard , although sufficient conditions can be developed hierarchically .",
    "this approach was already used in subsection [ ss : mssp_modeling ] to show the relationship between examples [ ex : aux1 ] and [ ex : circular_list ] .    in the general case ,",
    "if @xmath97 is an optimal policy and @xmath258 , then the formulas ( [ eq : mssp_dp ] - [ eq : mode_dp ] ) imply @xmath259 if @xmath97 is consistently @xmath11-improving , we have @xmath260    [ obs : implicit_causality ] for each mode @xmath167",
    "let @xmath261 be a set of all minimizers in formula ( [ eq : mode_dp ] ) .",
    "if @xmath262 then _ every _ optimal policy is consistently @xmath11-improving ( and this mssp is absolutely @xmath11-causal ) .    as a result",
    ", we can develop label - setting applicability conditions on a mode - per - mode basis . in the following",
    "we will focus on one @xmath263 and one mode @xmath264 to develop conditions on @xmath265 that guarantee causality for all possible values of @xmath266 s .",
    "since @xmath14 and @xmath167 are fixed , we will simplify the notation by using @xmath267 furthermore , interpreting @xmath164 and @xmath268 as column vectors in @xmath18 , we define @xmath269 as follows : @xmath270    the dynamic programming equation ( [ eq : mode_dp ] ) can be now rewritten as @xmath271    once the vector @xmath268 is specified , this also determines the set of minimizers @xmath272    [ def : mode_delta_causal ] the mode @xmath167 is _ absolutely @xmath11-causal _ if @xmath273 we will also refer to a mode as _ absolutely causal _ if the above holds at least with @xmath121 .    a simple way to interpret",
    "this definition is by considering an auxiliary single - mode mssp on the nodes @xmath274 with a single mode for each node ( see figure [ fig : auxiliary ] ) .",
    "let the transition from each @xmath275 to @xmath5 be deterministic with cost @xmath276 , and for @xmath14 let the mode be @xmath277 using the transition cost @xmath278 from the original problem .",
    "the mode @xmath167 is absolutely causal if a dijkstra - like method solves the auxiliary single - mode problem correctly for every vector @xmath279 the mode is absolutely @xmath11-causal if the same is true for a dial - like method with buckets of width @xmath11 .",
    "in fact , example [ ex : aux1 ] can be viewed as such auxiliary problem for the mode @xmath280 of example [ ex : circular_list ] .",
    "we emphasize that the absolute causality of auxiliary problems is desirable not because we intend to use label - setting on any of them ( after all , each auxiliary problem is explicitly causal , and a direct computation is efficient ; see remark [ rem : explicit_causality ] ) , but because the label - setting methods might be advantageous on the original mssp .",
    "the conditions on the mode @xmath167 in the definition [ def : mode_delta_causal ] are more restrictive then those in ( [ def : delta_improving_mssp ] ) since in the latter case the @xmath11-causality is needed for only one ( albeit unknown ) vector @xmath268 .",
    "thus , observation [ obs : implicit_causality ] yields the following sufficient condition for applicability of label - setting methods to mssps :    [ thm : ls_for_mssp ] for a general mssp , if every mode of every node is absolutely causal , then the mssp is also absolutely causal and a dijkstra - like method is applicable . if each mode @xmath167 is absolutely @xmath281-causal , then the mssp is absolutely @xmath90-causal with @xmath282 and a dial - like method is applicable if @xmath283 .",
    "we note that it is possible to have an absolutely causal mssp some of whose modes are not absolutely causal .",
    "this is reminiscent of the fact that the original dijkstra s method might be converging correctly even for some deterministic problems with negative transition penalties .",
    "consider a mode @xmath264 such that @xmath284 . in view of corollary",
    "[ thm : ls_for_mssp ] , it is important to find additional conditions on the transition cost function @xmath285 that guarantee @xmath167 s absolute @xmath11-causality .",
    "one obvious example is @xmath286 where all @xmath287 s are positive constants . in that case @xmath288 is linear and equation ( [ eq:1_mode_dp ] ) reduces to @xmath289 which is not different from the deterministic shortest path equation ( [ eq : optimality_determ ] ) .",
    "the same principle works for arbitrary concave costs .",
    "suppose @xmath290 then the mode @xmath167 is absolutely @xmath11-causal with @xmath291 moreover , @xmath292 can be more efficiently evaluated as @xmath293 [ thm : concave ]    since @xmath294 we know that the function @xmath295 is concave on @xmath143 .",
    "thus , if @xmath296 then @xmath297 hence the mode @xmath167 is absolutely @xmath11-causal .",
    "homogeneous cost functions naturally arise in many ssps .",
    "we recall that a function @xmath298 is absolutely homogeneous of degree @xmath299 if @xmath300 for all @xmath301 if @xmath77 is also smooth , by euler s homogeneous function theorem , it satisfies the equation @xmath302 .",
    "suppose the cost @xmath303 then for every @xmath304 we have @xmath305 [ lemma : homogen ]    for all @xmath306 the kuhn - tucker optimality conditions state that @xmath307 where @xmath308 is a lagrange multiplier .",
    "we recall that @xmath309 . multiplying ( [ eq : kt_1 ] ) by @xmath310 and summing over all",
    "@xmath306 we obtain @xmath311 thus , by euler s homogeneous function theorem , @xmath312 since @xmath182 is a minimizer , @xmath313 and it follows from ( [ eq : kt_1 ] ) that @xmath314    if @xmath315 satisfies * ( a4 ) * and @xmath316 then the mode is absolutely @xmath11-causal .",
    "[ thm : homogen ]    if @xmath317 and @xmath318 , the condition * ( a5 ) * and lemma [ lemma : homogen ] imply that @xmath319 .",
    "the case most frequently encountered in applications of ssps is the homogeneity of degree one .",
    "when @xmath320 , equation ( [ eq : kt_3 ] ) states that @xmath321 and the condition * ( a5 ) * becomes even simpler @xmath322 lemma [ lemma : homogen ] and theorem [ thm : homogen ] can be viewed as generalizations of the key idea in proofs of causality in @xcite and ( * ? ? ?",
    "* appendix ) .",
    "[ rem : homogen_one_common ]    if * ( a4 ) * holds and @xmath315 is strictly convex , then * ( a5 ) * is a necessary condition for the absolute @xmath11-causality of the mode . indeed , suppose * ( a5 ) * is violated for some @xmath323 and let @xmath324 .",
    "if for each @xmath325 we choose @xmath326 , this ensures that @xmath327 , @xmath328 , and @xmath329 , which implies @xmath330 even though @xmath331 .",
    "[ rem : sufficiency ]    suppose the cost @xmath332 then for every @xmath333 there exists a point @xmath334 on the straight line segment @xmath335 $ ] such that @xmath336 where @xmath337 is the hessian matrix of @xmath207 .",
    "[ lemma : non_homogen ]    if @xmath317 and @xmath306 , then the kuhn - tucker optimality conditions yield two different formulas ( [ eq : kt_1 ] ) and ( [ eq : kt_2 ] ) for the lagrange coefficient @xmath308 . combining these",
    "we see that @xmath338 by taylor s theorem there exists a point @xmath339 \\subset \\xi_n$ ] such that @xmath340 thus , @xmath341    consider an @xmath342 by @xmath343 matrix @xmath344 , whose columns form an orthonormal basis for the subspace orthogonal to @xmath345^t \\ , \\in { { \\mbox{\\boldmath${r}$}}}^n$ ] .",
    "suppose the cost @xmath315 satisfies * ( a6 ) * and @xmath346 is its projected hessian . if @xmath347 is the maximum eigenvalue of @xmath348 and @xmath349 then the mode is absolutely @xmath11-causal .",
    "[ thm : second_deriv_bound ]    first , we assume that @xmath350 ( the other case is already covered by theorem [ thm : concave ] ) .",
    "if @xmath317 and @xmath306 , then there exists @xmath351 such that @xmath352 .",
    "we note that @xmath353 since the lemma [ lemma : non_homogen ] applies , @xmath354    since the cost function is always evaluated on @xmath143 , the condition * ( a4 ) * is somewhat awkward : the cost can _ always _ be considered absolute homogeneous of degree one since @xmath207 can be replaced by @xmath355 , which has the same values as @xmath315 on @xmath143 .",
    "a more meaningful question is : supposing that @xmath315 is smooth and homogeneous of degree one , what additional conditions on @xmath315 and its directional derivatives inside @xmath143 are sufficient to guarantee * ( a5 ) * ?",
    "it is easy to see that * ( a7 ) * is an answer to that question since @xmath356 is the upper bound on the second derivative of @xmath315 restricted to any straight line in @xmath143 .",
    "[ rem : homogen_extend ]",
    "as already mentioned , mssps naturally arise in approximations of deterministic continuous optimal control problems . to illustrate this",
    ", we consider a class of time - optimal trajectory problems .",
    "many variants of these problems are studied in robotic navigation , optimal control , and front propagation literature ; a detailed discussion of the version presented here can be found in @xcite .",
    "suppose @xmath357 is the vehicle s position at the time @xmath358 and the vehicle starts at @xmath359 inside the domain @xmath17 .",
    "we are free to choose any direction of motion ( any vector in @xmath360 ) , but the speed will dependent on the chosen direction and on the current position of the vehicle .",
    "the vehicle s dynamics is governed by @xmath361 , where @xmath362 is a lipschitz - continuous speed function satisfying @xmath363 for all @xmath14 and @xmath58 .",
    "additional exit - time - penalty @xmath364 is incurred at the boundary ; we will assume that @xmath365 is non - negative and lipschitz - continuous .",
    "+ the goal is to cross the boundary @xmath16 as quickly as possible .",
    "the value function of this problem is @xmath366 ( the minimal - time - to - exit after starting from @xmath14 ) .",
    "it is well - known that @xmath366 is the unique viscosity solution @xcite of the following static hamilton - jacobi - bellman pde @xmath367 the optimal trajectories coincide with the characteristic curves of this pde . if the problem is _ isotropic _",
    "( i.e. , if @xmath368 , the above pde is equivalent to the usual eikonal equation @xmath369 and the optimal trajectories coincide with the gradient lines of @xmath366 .    for simplicity we will first assume that the domain @xmath17 is rectangular and that @xmath4 is a uniform cartesian grid on @xmath370 . concentrating on one particular gridpoint @xmath371",
    ", we will number all of its neighbors as in figure [ fig : two_stencils ] .",
    "suppose that the optimal initial direction of motion @xmath58 lies in the first quadrant and assume that the corresponding optimal trajectory remains a straight line until intersecting the segment @xmath372 at some point @xmath373 ( see figure [ fig : two_stencils]a ) .",
    "then it follows that @xmath374 let @xmath375 ; a linear approximation yields @xmath376 of course , since @xmath373 is not a priori known , we would have to minimize over all possible intersection points and all four quadrants .",
    "we will enumerate all quadrants as follows @xmath377 . for",
    "any @xmath378 and any @xmath379 we can similarly denote @xmath380 we can now state a semi - lagrangian discretization of the pde ( [ eq : hjb ] ) : @xmath381 this ( fully deterministic ) derivation is similar to the one used by gonzales and rofman in @xcite .",
    "on the other hand , it is easy to see that this system of equations also describes the value function for an mssp on @xmath382 :    * for the nodes @xmath383 , there is a single ( deterministic ) transition to @xmath5 with the cost @xmath384 ; * for the nodes @xmath371 , the set of quadrants @xmath385 can be interpreted as a set of modes and @xmath386    this interpretation is in the spirit of kushner s and dupuis approach of approximating continuous optimal control by controlled markov processes @xcite .    on a uniform cartesian grid and the stencil of figure [ fig : two_stencils]a",
    ", we can express @xmath387 , where @xmath388 is the grid size .",
    "if the problem is isotropic , the cost function becomes @xmath389 a similar construction in @xmath18 leads to modes containing @xmath342 neighbor - nodes each and the cost function @xmath390 this function is homogeneous of degree one in terms of @xmath164 ; moreover , @xmath391 which is positive if and only if @xmath392 . by the theorem [ thm : homogen ] , each mode is absolutely causal and a dijkstra - like method can be used to solve the problem .",
    "this is in fact the first of two methods introduced by tsitsiklis in @xcite .",
    "since this @xmath315 is also convex in @xmath164 , the remark [ rem : sufficiency ] shows that the modes are not absolutely @xmath11-causal for any @xmath117 ; hence , the dial s method is generally not applicable .",
    "another obvious computational stencil in @xmath393 uses all 8 neighboring gridpoints as shown in figure [ fig : two_stencils]b . here",
    "the optimal trajectory is still assumed to remain a straight line until the intersection with a segment , but the list of segments is different : @xmath394 the discretized equation ( [ eq : markov_aniso ] ) still holds , but the difference is that @xmath395 if the problem is isotropic , the cost function becomes @xmath396 theorem [ thm : second_deriv_bound ] is certainly applicable , but instead we re - write the above as a function homogeneous of degree one ( see remark [ rem : homogen_extend ] ) : @xmath397 we now note that @xmath398 since @xmath399 , we conclude that @xmath400 by the theorem [ thm : homogen ] , each mode is absolutely @xmath11-causal and a dial - like method can be used with buckets of width @xmath11 ( corresponding to the second method introduced in @xcite ) .    more generally , suppose that @xmath4 is a simplicial mesh on @xmath401 with the minimum edge - length of @xmath388 .",
    "let @xmath402 be the set of all simplexes in the mesh that use @xmath14 as one of the vertices .",
    "each such simplex @xmath403 corresponds to a single mode @xmath264 consisting of all other vertices of @xmath404 besides @xmath14 . for any mode @xmath277 and any @xmath405 we can similarly define @xmath406    since @xmath407",
    "we see that @xmath408 where @xmath409 is the angle between @xmath410 and @xmath411 .",
    "suppose @xmath412 is the maximum angle between a pair of vectors @xmath413 and @xmath414 maximizing over all @xmath415 furthermore , define @xmath416 since @xmath410 lies in the cone defined by @xmath417 , we know that @xmath418 therefore , @xmath419 the dynamic programming equations in this case become @xmath420 the cost function @xmath421 is homogeneous of degree one in @xmath164 .",
    "for the isotropic case , we see that @xmath422 thus , for the eikonal pde on any acute mesh ( i.e. , for @xmath423 ) , each mode of the discretization is absolutely causal by theorem [ thm : homogen ] and a dijkstra - like method is applicable ( this is a re - derivation of the result in ( * ? ? ? * appendix ) ) .",
    "moreover , if @xmath423 then @xmath424 this provides the optimal bucket - width @xmath11 to use in a dial - like method when solving the eikonal pde on any acute mesh .",
    "as far as we know , no general formula for @xmath11 has been derived elsewhere up till now .",
    "we note that the last result is applicable even in a more general situation , when the computational stencil @xmath402 does not correspond to a set of non - overlapping simplexes present in the mesh .",
    "e.g. , for the example in figure [ fig : two_stencils]b , @xmath425 and this yields the same @xmath11 as in ( [ eq : tsi2_delta ] ) .",
    "that leads to an interesting dilemma : including more nearby nodes into a computational stencil usually decreases @xmath426 and increases the bucket - width thus reducing the total number of `` bucket - acceptance '' steps until the termination of dial s algorithm .",
    "on the other hand , a larger @xmath402 increases both the computational complexity of a single step ( more tentative labels to update after each acceptance ) and the discretization error ( proportional to @xmath388 in the above examples ) . finding an optimal way for handling this trade - off , could further speed - up non - iterative methods for eikonal pdes on acute meshes .",
    "we note that @xmath427 remains the upper bound for @xmath11 and corresponds to the situation when the vehicle is allowed to move only along the directions @xmath411 .",
    "a much harder question is the applicability of label - setting methods to semi - lagrangian discretizations of anisotropic optimal control problems .",
    "it is well - known that equations ( [ eq : markov_aniso_mesh ] ) are generally not causal ; this issue is discussed in detail in @xcite . on uniform cartesian grids ,",
    "the criteria for applicability of a dijkstra - like method to anisotropic problems were previously provided in @xcite , @xcite , and more recently in @xcite .",
    "all of these criteria are grid - orientation dependent ; i.e. , given a hamilton - jacobi pde , its semi - lagrangian or eulerian discretization may or may not be computed correctly by a dijkstra - like method depending on whether the anisotropy in the pde is aligned with the grid directions . here",
    "we provide a criterion for applicability of a dijkstra - like method for discretizations based on arbitrary acute stencils . in the anisotropic case",
    ", @xmath428 suppose that there exists @xmath115 such that for @xmath429 @xmath430 } { \\tau^m(\\xi)}.\\ ] ] by the theorem [ thm : homogen ] , this implies that a dijkstra - like method will be applicable and a dial - like method will also be applicable if @xmath431 .",
    "building label - setting methods based on this sufficient condition could potentially yield algorithms outperforming the ordered upwind methods specially designed to restore the causality of anisotropic problems by dynamically extending the stencil @xcite .",
    "we intend to explore this approach in the future work .",
    "we defined a large class of multimode stochastic shortest path problems and derived a number of sufficient conditions to check the applicability of the label - setting methods .",
    "we illustrated the usefulness of our approach to the numerical analysis of first - order non - linear boundary value problems by reinterpreting previous label - setting methods for the eikonal pde on cartesian grids .",
    "for eikonal equation on arbitrary meshes , we re - interpreted the prior dijkstra - like method and derived the new formula of bucket - width for dial - like methods .",
    "we also developed a new sufficient condition for the applicability of label - setting methods to anisotropic hamilton - jacobi pdes on arbitrary stencils .    in practice",
    ", the applicability of label - setting methods to a particular ssp can be tested directly in @xmath10 operations : upon the method s termination , a single value iteration can be applied and , if it results in no changes , the value function was computed correctly .",
    "however , the sufficient conditions ( presented above for mssps ) allow to avoid these additional computations .",
    "unfortunately , the framework of mssps is not flexible enough to express many common discrete stochastic control problems , where not all possible probability distributions over successor nodes are available .",
    "nevertheless , we hope that the key idea of our approach ( splitting the original mssp into a number of absolutely causal auxiliary problems ) can be generalized to test the applicability of label - setting methods to other ssps .",
    "since ssps can be naturally extended to describe stochastic games on graphs @xcite , we also intend to investigate the applicability of our approach to the latter .",
    "if successful , this will potentially yield efficient numerical methods for a wide class of first and second order static hamilton - jacobi equations .    in dial - like methods",
    ", the bucket width can be sometimes adjusted on the fly based on the not - yet - accepted part of the problem only .",
    "we expect such extensions to be advantageous for problems , where the cost function @xmath315 has very different lower bounds for different nodes .",
    "another open question of practical importance is the use of label - setting methods to obtain an _ approximation _ of the value function for non - causal ssps .",
    "recently , a numerical method based on a related idea was introduced in @xcite for eikonal pdes : a dial - like method is used with buckets of width @xmath11 for a discretization that is not @xmath11-causal .",
    "this introduces additional errors ( analyzed in @xcite ) , but decreases the method s running time .",
    "k. alton & i. m. mitchell , _ fast marching methods for a class of anisotropic stationary hamilton - jacobi equations _",
    ", technical report tr-2006 - 27 , department of computer science , university of british columbia , 2007 .",
    "bertsekas , d.p . , _",
    "network optimization : continuous & discrete models _ ,",
    "athena scientific , boston , ma , 1998 ."
  ],
  "abstract_text": [
    "<S> stochastic shortest path ( ssp ) problems arise in a variety of discrete stochastic control contexts . </S>",
    "<S> an optimal solution to such a problem is typically computed using the value function , which can be found by solving the corresponding dynamic programming equations . in the deterministic case , these equations can be often solved by the highly efficient label - setting methods ( such as dijkstra s and dial s algorithms ) . in this paper </S>",
    "<S> we define and study a class of multimode stochastic shortest path problems and develop sufficient conditions for the applicability of label - setting methods . </S>",
    "<S> we illustrate our approach on a number of discrete stochastic control examples . </S>",
    "<S> we also discuss the relationship of ssps with discretizations of static hamilton - jacobi equations and provide an alternative derivation for several fast ( non - iterative ) numerical methods for these pdes . </S>"
  ]
}