{
  "article_text": [
    "with the advent of cloud computing , cloud servers offer to their clients various facilities that include delegation of huge amount of computation and outsourcing large amount of data ( say , in the order of terabytes ) .",
    "for example , a client ( cloud user ) having a smart phone with a low - performance processor or a limited amount of storage capacity can not accomplish this heavy computation on its own or can not store such a large volume of data in its own storage .",
    "the client can delegate her computation or storage to the cloud server .",
    "now , the client only has to download the result of the computation or has to read ( or update ) the required portion of the uploaded data .    in case of storage outsourcing",
    ", the cloud server stores a massive volume of data on behalf of its clients ( data owners ) .",
    "however , a malicious cloud server can delete some of the client s data ( that are not accessed frequently ) in order to save space .",
    "secure cloud storage ( scs ) protocols ( two - party protocols between the client and the server ) provide a mechanism to ensure that the client s data are stored untampered in the server . depending on the nature of the data to be outsourced ,",
    "secure cloud storage protocols are classified as : scs protocols for _ static _ data ( sscs )  @xcite and scs protocols for _ dynamic _ data ( dscs )  @xcite .",
    "for static data , the client can not change her data after the initial outsourcing ( suitable mostly for backup or archival data ) .",
    "dynamic data are more generic in that the client can modify her data as often as needed . in scs protocols ,",
    "the client can audit her data stored in the server without accessing the whole data file , and still , be able to detect an unwanted modification of the data done by a malicious server .",
    "the scs protocols are _ publicly verifiable _ if the audits can be performed by any third party auditor ( tpa ) with the knowledge of public parameters only ; they are _ privately verifiable _ if one needs some secret information of the client in order to perform an audit . in",
    "_ privacy - preserving _ audits ( for publicly verifiable scs protocols only ) , the tpa can not learn the actual content of any portion of the data file .    in a network coding protocol  @xcite ,",
    "every intermediate node ( all nodes except the source and target nodes ) in a communication network combines the incoming packets to output another packet .",
    "these protocols enjoy much improved throughput , efficiency and scalability compared to the conventional store - and - forward routing where an incoming packet is relayed as it is",
    ". however , these protocols are prone to _ pollution attacks _ caused by malicious intermediate nodes that inject invalid packets in the network .",
    "these invalid packets produce more such packets downstream . in the worst case",
    ", the target node can not decode the original file sent to it via the network .",
    "secure network coding ( snc ) protocols use cryptographic primitives in order to prevent these attacks . in an snc protocol , the source node authenticates each of the packets to be transmitted through the network by attaching a small tag to it .",
    "these authentication tags are generated using homomorphic message authentication codes ( macs )  @xcite or homomorphic signatures  @xcite . due to the homomorphic property of the tags ,",
    "every intermediate node can combine the incoming packets to output another packet along with its authentication tag .    in a recent work ,",
    "chen et al .",
    "@xcite show that , given a secure network coding ( snc ) protocol , one can construct a secure cloud storage ( sscs ) protocol for static data using the snc protocol",
    ". however , their construction does not handle ( more generic ) dynamic data that makes it insufficient in many cloud applications where a client needs to update ( insert , delete or modify ) her data efficiently .",
    "clearly , a naive way to update data in this scenario is to download the whole data file , perform the required updates and upload the file to the server again ; but this procedure is highly inefficient as it requires huge amount of communication bandwidth for every update .",
    "thus , further investigations are needed towards an efficient construction of a secure cloud storage ( dscs ) protocol for dynamic data using an snc protocol .",
    "in addition , there are various practical applications where _ append - only _ data need to be stored with a guarantee of retrievability ( e.g. , ledgers containing transactions , medical history of patients and different log data ) .",
    "therefore , a more efficient solution ( specifically for append - only data ) would be helpful in this scenario .    * our contribution*in this paper",
    ", we provide a construction of a secure cloud storage protocol from a secure network coding ( snc ) protocol .",
    "our construction handles dynamic data , that is , the client can efficiently perform updates ( insertion , deletion and modification ) on her data outsourced to the cloud server .",
    "our contributions are summarized as follows .    * we explore the possibility of providing a general construction of a dscs protocol from any snc protocol .",
    "we discuss about the challenges for such a general construction in details , and we identify some snc protocols such that efficient dscs protocols can be constructed using them .",
    "indeed , we provide a basic construction of a dscs protocol ( dscs i ) from such an snc protocol proposed by catalano et al .",
    "our construction is secure in the standard model and offers public verifiability .",
    "* as our scheme is publicly verifiable , the client can delegate the auditing task to a third party auditor .",
    "she may also prefer her sensitive data not to be disclosed to the auditor .",
    "we extend our basic dscs i construction in order to support privacy - preserving audits where the third party auditor can not gain knowledge of the actual content of the data file owned by the client . * in an enterprise setting , a group of users can share and update the outsourced data file . however , it is sometimes desirable to hide the identity of the user ( from the cloud server ) updating the data file .",
    "we extend dscs i in order to preserve user - anonymity where the cloud server can not distinguish the actual user in the group updating the file . *",
    "we analyze the efficiency of dscs i and compare it with other existing secure cloud storage protocols .",
    "we discuss about some limitations of an snc - based scs protocol ( for static or dynamic data ) .",
    "* we construct another publicly verifiable secure cloud storage protocol ( dscs ii ) for append - only data using an snc protocol proposed by boneh et al .  @xcite .",
    "this construction is secure in the random oracle model and overcomes some of the limitations of our earlier construction .",
    "the rest of the paper is organized as follows . in section  [ prelims ] , we discuss about the notations we use in this paper , and we briefly describe the secure network coding and the secure cloud storage protocols along with their respective security models .",
    "section  [ dscs ] begins with a detailed discussion on the general construction of a dscs protocol using an snc protocol .",
    "then , we describe our construction ( dscs i ) that is based on a secure network coding protocol . in section  [ security_dscsi ]",
    ", we analyze the security of dscs i and the probabilistic guarantees it offers . in section  [ ppa_scheme ] , we extend our basic dscs i scheme in order to support privacy - preserving audits .",
    "section  [ mediator ] describes a way in which dscs i can be modified to preserve the user - anonymity in an enterprise setting . in section  [ perform_ana ]",
    ", we analyze the efficiency of dscs i and compare its performance with the existing secure cloud storage schemes .",
    "section  [ append ] describes our second construction of a secure cloud storage ( dscs ii ) that deals with append - only data . in the concluding section  [ sec : conclusion ] , we summarize the work done in this paper .",
    "we take @xmath0 to be the security parameter .",
    "an algorithm @xmath1 is a probabilistic polynomial - time algorithm when its running time is polynomial in @xmath0 and its output @xmath2 is a random variable which depends on the internal coin tosses of @xmath3 .",
    "an element @xmath4 chosen uniformly at random from a set @xmath5 is denoted as @xmath6 .",
    "a function @xmath7 is called negligible in @xmath0 if for all positive integers @xmath8 and for all sufficiently large @xmath0 , we have @xmath9 . in general , @xmath10 is used to denote a finite field .",
    "the multiplication of a vector @xmath11 by a scalar @xmath12 is denoted by @xmath13 .",
    "the terms _ packet _ and _ vector _ are used interchangeably in this work .",
    "ahlswede et al .",
    "@xcite introduce network coding as a replacement of the conventional store - and - forward routing for networks . in network coding , intermediate nodes ( or routers ) encode the received packets to output another packet which increases the throughput of the network ( optimal in case of multicasting ) .",
    "linear network coding was proposed by li et al .",
    "@xcite . here",
    ", the file @xmath14 to be transmitted is divided into several ( say , @xmath15 ) packets ( or vectors ) @xmath16 each consisting of @xmath17 components ( or blocks ) , and each of these components is an element of a finite field @xmath10 .",
    "in other words , each @xmath18 for @xmath19 $ ] .",
    "then , the sender ( or source ) node augments each vector to form another vector @xmath20\\in\\f^{n+m}$ ] for @xmath19 $ ] , where @xmath21 is the @xmath15-dimensional unit vector containing 1 in the @xmath22-th position and 0 in others .",
    "thus , the collection of @xmath15 augmented vectors can be illustrated as @xmath23\\notag\\\\ & = \\left [ \\begin{array}{cccc|cccc }      v_{11 } & v_{12 } & \\cdots & v_{1n } & 1 & 0 & \\cdots   & 0 \\\\      v_{21 } & v_{22 } & \\cdots & v_{2n } & 0 & 1 & \\cdots   & 0 \\\\      \\vdots & \\vdots & \\ddots & \\vdots               & \\vdots & \\vdots & \\ddots & \\vdots \\\\",
    "v_{m1 } & v_{m2 } & \\cdots & v_{mn } & 0 & 0 & \\cdots   & 1\\\\ \\end{array } \\right].\\notag\\end{aligned}\\ ] ]    finally , the sender transmits these augmented vectors to the network .",
    "let @xmath24 be the linear subspace spanned by these augmented vectors @xmath25 .",
    "a random file identifier ` fid ` is associated with the file @xmath14 ( or @xmath26 ) .",
    "an intermediate node in the network outputs a linear combination of the received packets . in random ( linear ) network coding  @xcite ,",
    "the coefficients of these linear combinations are chosen uniformly at random from the field @xmath10 .",
    "an intermediate node in the network , upon receiving @xmath27 packets @xmath28 , chooses @xmath27 coefficients @xmath29 and outputs another packet @xmath30 such that @xmath31 ( here , summation refers to vector additions ) .",
    "thus , the output packet of each intermediate node is of the form @xmath32\\in v\\end{aligned}\\ ] ] for some @xmath33 , where @xmath34 for each @xmath35 $ ] . when the receiver ( or target ) node accumulates @xmath15 linearly independent vectors ( or packets ) , it solves a system of linear equations to obtain the file destined to it .",
    "a network coding protocol is vulnerable to pollution attacks , where a malicious intermediate node injects an invalid packet to the network and this invalid packet in turn pollutes multiple packets downstream . in a secure network coding ( snc )",
    "protocol , an authentication information ( or tag ) is attached to each packet .",
    "every node can combine the incoming packets linearly to output another packet along with its authentication tag .",
    "both the incoming packets and the output packet belong to the same linear subspace @xmath26 .",
    "the authentication tags are computed using homomorphic message authentication codes ( macs )  @xcite or homomorphic signatures  @xcite . in an snc protocol based on homomorphic signatures ,",
    "every node in the network can verify the authenticity of each of its incoming vectors . on the other hand , in case of snc protocols based on homomorphic macs , it requires the knowledge of the secret key to verify an incoming vector .",
    "the property of aggregating ( or combining ) the tags for the incoming packets into a tag for the outgoing packet is required for the construction of a secure cloud storage protocol , where the cloud server has to send an aggregated tag for the response ( see section  [ modified_scheme ] ) .",
    "so , we do not consider in our discussion snc protocols based on ( collision - resistant ) homomorphic hashing , where intermediate nodes do not produce signatures for the outgoing packets ( for example , @xcite ) .",
    "we define a secure network coding ( snc ) protocol below .",
    "the values @xmath15 , the dimension of the linear subspace @xmath24 to sign , and @xmath17 , the dimension of each vector @xmath11 ( before augmenting ) , are input to the procedures involved in the protocol .",
    "[ def : snc ] a secure network coding ( snc ) protocol consists of the following algorithms .    * _ _ snc.keygen__@xmath36 : this procedure generates a secret key - public key pair @xmath37 for the sender .",
    "* _ _ snc.taggen__@xmath38 : on input a linear subspace @xmath24 , the secret key @xmath39 and a random file identifier _ ` fid ` _ associated with @xmath26 , the sender runs this procedure to produce the authentication tag @xmath40 for @xmath26 . * _ _ snc.combine__@xmath41 : given @xmath27 incoming packets @xmath42 and their corresponding tags @xmath43 for a file associated with _ `",
    "fid ` _ , an intermediate node chooses @xmath27 random coefficients @xmath29 and runs this procedure .",
    "the procedure outputs another packet @xmath30 and its authentication tag @xmath40 such that @xmath44 . *",
    "_ _ snc.verify__@xmath45 : an intermediate node or the receiver node , on input a packet @xmath46 and its tag @xmath40 for a file associated with _ ` fid ` _ , executes this procedure which returns 1 if @xmath40 is authentic for the packet @xmath46 ; returns 0 , otherwise .    in some schemes ,",
    "the procedure snc.verify requires only the public key @xmath47  @xcite .",
    "the knowledge of the secret key @xmath39 is necessary to verify the incoming packets in other schemes  @xcite .",
    "the security of an snc protocol based on a homomorphic signature scheme is defined by the security game between a challenger and a probabilistic polynomial - time adversary @xmath3 as stated below  @xcite .    * * * setup**the adversary @xmath3 provides the values @xmath15 and @xmath17 of its choice to the challenger .",
    "the challenger runs snc.keygen@xmath36 to output @xmath37 and returns @xmath47 to @xmath3 . * * * queries**the adversary @xmath3 specifies a sequence ( adaptively chosen ) of vector spaces @xmath48 by respective augmented basis vectors @xmath49 and asks the challenger to authenticate the vector spaces . for each @xmath22 , the challenger chooses a random file identifier @xmath50 from a predefined space , generates an authentication tag @xmath51 by running snc.taggen@xmath52 and gives @xmath51 to @xmath3 . * * * forgery**the adversary @xmath3 outputs @xmath53 .    let the output vector @xmath54\\in \\f^{n+m}$ ] .",
    "then , the adversary @xmath3 wins the security game mentioned above if @xmath55\\in \\f^m$ ] is not the all - zero vector , snc.verify@xmath56 outputs 1 and one of the following conditions is satisfied : + 1 .",
    "@xmath57 for all @xmath22 ( _ type-1 forgery _ ) + 2 .",
    "@xmath58 for some @xmath22 , but @xmath59 ( _ type-2 forgery _ ) .    for a secure network coding ( snc )",
    "protocol , the probability that the adversary @xmath3 wins the security game is negligible in the security parameter @xmath0 .",
    "we note that the security game for an snc protocol based on homomorphic macs is exactly the same as the game described above , except that the procedure snc.keygen now produces a secret key only ( unknown to @xmath3 ) and the verification procedure snc.verify requires the knowledge of this secret key .",
    "clients ( cloud users ) may want to outsource their huge amount of data to the cloud storage server . as the cloud service provider ( possibly malicious ) might discard old data to save some space ,",
    "the clients need to be convinced that the outsourced data are stored untampered by the cloud server . a naive approach to ensure data integrity is that a client downloads the whole data from the server and verifies them individually segment by segment . however , this process is inefficient in terms of communication bandwidth required .",
    "researchers come up with _ proofs of storage _ in order to resolve the issue mentioned above .",
    "ateniese et al .",
    "@xcite introduce the concept of _ provable data possession _ ( pdp ) where the client computes an authentication tag ( for example , mac ) for each segment of her data ( or file ) , and uploads the file along with the authentication tags . during an audit protocol",
    ", the client samples a predefined number of random segment - indices ( challenge ) and sends them to the server .",
    "we denote the cardinality of the challenge set by @xmath27 which is typically taken to be @xmath60 .",
    "the server does some computations ( depending upon the challenge ) over the stored data , and sends a proof ( response ) to the client who verifies the integrity of her data based on this proof .",
    "this scheme also introduces the notion of public verifiability where the client ( data owner ) can delegate the auditing task to a third party auditor ( tpa ) .",
    "then , the tpa with the knowledge of the public key performs an audit . for privately verifiable schemes , only the client having knowledge of the secret key can verify the proof sent by the server .",
    "other schemes achieving pdp include  @xcite .",
    "the first paper introducing _ proofs of retrievability _",
    "( por ) for static data is by juels and kaliski  @xcite ( a similar idea is given for sublinear authenticators by naor and rothblum  @xcite ) .",
    "according to shacham and waters  @xcite , the underlying idea of a por scheme is to encode the original file with an erasure code  @xcite , authenticate the segments of the encoded file , and then upload them on the storage server . with this technique , the server has to delete or modify a considerable number of segments to actually delete or modify a data segment .",
    "this ensures that all segments of the file are retrievable from the responses of the server which passes an audit with some non - negligible probability .",
    "following the work by juels and kaliski , several por schemes have been proposed  @xcite .",
    "some of these schemes are designed for static data , and the rest allow the client to modify data after the initial outsourcing .",
    "as we deal with a single cloud server in this work , we only mention some secure cloud storage protocols in a distributed setting . some of them include the works by curtmola et al .",
    "@xcite ( using replication of data ) and bowers et al .",
    "@xcite ( using error - correcting codes and erasure codes ) .",
    "dimakis et al .",
    "@xcite introduce network coding in distributed storage systems where linear combinations of data segments are disseminated to multiple servers . in terms of repair bandwidth ( bandwidth required to repair a failed server",
    ") , this technique is more efficient than using the conventional erasure codes for distributing the segments .",
    "for such a distributed storage system , there are schemes for remote integrity checking  @xcite designed to achieve fast repair of a failed server .",
    "we define an scs protocol for dynamic data ( dscs ) below  @xcite",
    ". a dscs protocol can be privately verifiable if the verification algorithm of the protocol involves the secret key @xmath39 of the client ; it is publicly verifiable , otherwise . in general , the term _ verifier _ is used to denote an auditor for a secure cloud storage .",
    "the client ( for a privately verifiable protocol ) or a third party auditor ( for a publicly verifiable protocol ) can act as the verifier .",
    "[ def : dscs ] a secure cloud storage protocol for dynamic data ( dscs ) consists of the following procedures .",
    "* _ _ dscs.keygen__@xmath61 : this procedure generates a secret key - public key pair @xmath37 for the client . *",
    "_ _ dscs.outsource__@xmath62 : the client divides the file @xmath14 associated with the file identifier _ `",
    "fid ` _ into @xmath15 segments and computes authentication tags for these segments using her secret key @xmath39 .",
    "then , she constructs an authenticated data structure @xmath63 on the authentication tags ( for checking freshness of the data ) and computes some metadata @xmath64 for @xmath63 .",
    "finally , the client uploads the file @xmath65 ( the file @xmath14 and the authentication tags ) along with @xmath63 to the cloud storage server and stores @xmath64 ( and @xmath15 ) at her end . *",
    "_ _ dscs.initupdate__@xmath66 : the value of the variable _ ` updtype `",
    "_ indicates whether the update is an insertion after or a modification of or the deletion of the @xmath22-th segment . depending on the value of _ ` updtype ` _ , the client modifies @xmath67 at her end and asks the server to perform the required update on the file associated with _ `",
    "( related information specified in ` info ` ) . * _ _ dscs.performupdate__@xmath68 : the server performs the update on the file associated with _ ` fid ` _ and sends the client a proof @xmath69 . *",
    "_ _ dscs.verifyupdate__@xmath70 : on receiving the proof @xmath69 for the file associated with _ ` fid ` _ from the server , the client checks whether @xmath69 is a valid proof . * _ _ dscs.challenge__@xmath71 : during an audit , the verifier sends a challenge set @xmath72 of cardinality @xmath73 to the server .",
    "* _ _ dscs.prove__@xmath74 : the server , after receiving the challenge set @xmath72 , computes a proof of storage @xmath75 corresponding to @xmath72 and a proof of freshness @xmath69 .",
    "then , it sends @xmath76 to the verifier .",
    "* _ _ dscs.verify__@xmath77 : the verifier checks if @xmath75 is a valid proof of storage corresponding to the challenge set @xmath72 and @xmath69 is a valid proof of freshness .",
    "the verifier outputs 1 if both the proofs pass the verification ; she outputs 0 , otherwise .",
    "dscs protocols based on pdp guarantee the extraction of _ almost all _ the segments of the file @xmath14 . on the other hand , dscs protocols based on por ensure the extraction of _ all _ the segments of @xmath14 with the help of erasure codes .",
    "security of a dscs protocol is discussed in section  [ security_dscsi ] .",
    "chen et al .  @xcite propose a generic construction of a secure cloud storage protocol for static data from a secure network coding protocol .",
    "they consider the data file @xmath14 to be stored in the server to be a collection of @xmath15 vectors ( or packets ) each of which consists of @xmath17 blocks .",
    "the underlying idea is to store these vectors ( without augmenting them with unit vectors ) along with their authentication tags in the server . during an audit",
    ", the client sends an @xmath27-element subset of the set of indices @xmath78 to the server .",
    "the server augments those vectors with the corresponding unit vectors , combines them linearly in an authenticated fashion and sends the output vector along with its tag to the client . finally , the client verifies the authenticity of the received tag against the received vector .",
    "thus , the server acts as an intermediate node , and the client acts as both the sender and the receiver ( or the next intermediate router ) .",
    "we briefly discuss the algorithms involved in the general construction in appendix  [ app_sscs ] .    in a secure network coding protocol , the number of packets ( or vectors ) in the file to be transmitted through the network",
    "this is because the length of the coefficient vectors used to augment the original vectors has to be determined a priori .",
    "that is why , a general construction of a secure cloud storage protocol as discussed above is suitable for static data in general . on the other hand , in a secure cloud storage protocol for dynamic data , clients can modify their data after they upload them to the cloud server initially . in this section",
    ", we discuss whether we can provide a general framework for constructing an efficient and secure cloud storage protocol for dynamic data ( dscs ) from an snc protocol .      in a secure network coding ( snc )",
    "protocol , a tag is associated with each packet such that the integrity of a packet can be verified using its tag .",
    "the snc protocols found in the literature use homomorphic macs  @xcite or homomorphic signatures  @xcite . following are the challenges in constructing an _ efficient _ dscs protocol from these existing snc protocols .",
    "we exclude , in our discussion , the work of attrapadung and libert  @xcite as their scheme is not efficient due to its reliance on ( inefficient ) composite - order bilinear groups .    1 .",
    "_ the dscs protocol must handle the varying values of @xmath15 appropriately_. in the network coding protocols mentioned above , the sender divides the file in @xmath15 packets and augments them with unit coefficient vectors before sending them into the network .",
    "the length of these coefficient vectors is @xmath15 which remains constant during transmission . in a secure cloud storage for dynamic data ,",
    "the number of vectors may vary ( for insertion and deletion ) . if we follow a similar general construction for a dscs protocol as discussed above ( for static data )",
    ", we observe that the cloud server does not need to store the coefficient vectors . however , during an audit , the verifier selects a random @xmath27-element subset @xmath79 of @xmath80 $ ] and the server augments the vectors with unit coefficient vectors of dimension @xmath15 before generating the proof .",
    "therefore , the verifier and the server need to keep an updated value of @xmath15 . +",
    "this issue can be resolved in the following way .",
    "the client includes the value of @xmath15 in her public key and updates its value for each authenticated insertion or deletion .",
    "thus , its latest value is known to the verifier and the server .",
    "we assume that , for consistency , the client ( data owner ) does not update her data during an audit .",
    "the index of a vector should not be embedded in its authentication tag_. in an snc protocol , the file to be transmitted is divided into @xmath15 packets @xmath16 , where each @xmath18 for @xmath19 $ ] ( @xcite replaces @xmath10 by @xmath81 ) .",
    "the sender augments each vector to form another vector @xmath20\\in\\f^{n+m}$ ] for @xmath19 $ ] , where @xmath21 is the @xmath15-dimensional unit vector containing 1 in @xmath22-th position and 0 in others .",
    "let @xmath24 be the linear subspace spanned by these augmented basis vectors @xmath25 .",
    "the sender authenticates the subspace @xmath26 by authenticating these augmented vectors before transmitting them to the network  @xcite . in a scheme based on homomorphic macs  @xcite ,",
    "the sender generates a mac for the @xmath22-th basis vector @xmath82 and the index @xmath22 serves as an input to the mac algorithm ( for example , @xmath22 is an input to the pseudorandom function in  @xcite ) . on the other hand ,",
    "for the schemes based on homomorphic signatures , the sender generates a signature @xmath51 on the @xmath22-th basis vector @xmath82 . in some schemes based on homomorphic signatures , the index @xmath22 is embedded in the signature @xmath51 on the @xmath22-th augmented vector .",
    "for example , @xmath83 is embedded in @xmath51  @xcite , where ` fid ` is the file identifier and @xmath84 is a hash function modeled as a random oracle .",
    "section  [ snc_exmpl ] gives a brief overview of the scheme proposed by boneh et al .",
    "@xcite and shows how each @xmath51 includes the value @xmath83 ( see eqn .",
    "[ eqn_boneh ] ) .",
    "+ these schemes are not suitable for the construction of an _ efficient _ dscs protocol due to the following reason . for dynamic data , the client can insert a vector in a specified position or delete an existing vector from a specified location . in both cases ,",
    "the indices of the subsequent vectors are changed .",
    "therefore , the client has to download all these subsequent vectors and compute fresh authentication tags for them before uploading the new vector - tag pairs to the cloud server .",
    "this makes the dscs protocol inefficient .",
    "however , in a few schemes , instead of hashing vector indices as in  @xcite , there is a one - to - one mapping from the set of indices to some group  @xcite , and these group elements are made public .",
    "this increases the size of the public key of these schemes .",
    "however , an efficient dscs protocol can be constructed from them .",
    "in fact , we construct a dscs protocol ( described in section  [ modified_scheme ] ) based on the snc protocol proposed by catalano et al .",
    "we note that chen et al .",
    "@xcite construct an scs protocol from the same snc protocol , but for static data only .",
    "_ the freshness of data must be guaranteed_. the freshness of storage requires that the server is storing an up - to - date version of the data file . for dynamic data , the client can modify an existing vector .",
    "however , a malicious cloud server may discard this change and keep an old copy of the vector . as the old copy of the vector and its corresponding tag are valid , the client has no way to detect if the cloud server is storing the latest copy .",
    "+ we ensure the freshness of the client s data , in our dscs construction , using an _ authenticated data structure ( rank - based authenticated skip list ) on the authentication tags of all the vectors_. in other words , the authenticity of the vectors is maintained by their tags , and the integrity of the tags is in turn maintained by the skip list .",
    "the advantage of building the skip list on the tags ( over building it on the vectors ) is that the tags are much shorter than a vector , and this decreases the size of the proof sent by the server .",
    "when a vector is inserted ( or modified ) , its tag is also updated and sent to the server .",
    "the server updates the skip list accordingly . for deletion of a vector ,",
    "the server simply removes the corresponding tag from the skip list .",
    "finally , the server sends to the client a proof of performing the required update properly .",
    "we briefly discuss , in section  [ skip_list ] , about rank - based authenticated skip lists that we use in our construction described in section  [ modified_scheme ] .",
    "in addition to the requirements mentioned above , it is often desired that a dscs protocol ( an scs protocol , in general ) satisfies the following properties .    1 .   _ _ public verifiability__for a publicly verifiable dscs protocol , the auditing task can be delegated to a third party auditor ( tpa ) . in a secure network coding protocol built on homomorphic macs , the secret key ( for example",
    ", the secret keys of the pseudorandom generator and the pseudorandom function in  @xcite ) is needed to verify the authenticity of an incoming packet .",
    "this property restricts the secure cloud storage protocol built on such an snc protocol to be privately verifiable only . 2 .",
    "_ _ privacy - preserving audits__in privacy - preserving audits ( for a publicly verifiable dscs protocol ) , the tpa can not gain the knowledge of the challenged vectors .      for dynamic data , we need some authenticated data structures like merkle hash trees  @xcite , rank - based authenticated skip lists  @xcite and rank - based rsa trees  @xcite to verify the freshness of each of the vectors .",
    "erway et al .",
    "@xcite propose rank - based authenticated skip lists based on labeled skip lists  @xcite .",
    "we give a brief introduction to the procedures of rank - based authenticated skip lists stored remotely in a server as follows .",
    "* @xmath85 : let @xmath86 be an ordered list of @xmath15 elements on which a rank - based authenticated skip list @xmath63 is to be built . these elements are kept in the bottom - level nodes of the skip list in an ordered fashion . for each node @xmath87 of the skip list : @xmath88 and @xmath89 are two pointers to the successors of @xmath87 , @xmath90 is the number of bottom - level nodes reachable from @xmath87 ( including @xmath87 if @xmath87 itself is a bottom - level node ) , @xmath91 and @xmath92 are the indices of the leftmost and rightmost bottom - level nodes reachable from @xmath87 , @xmath93 is the label associated with the node @xmath87 , and @xmath94 is the level of @xmath87 ( @xmath95 for a bottom - level node @xmath87 ) . + initially , all these information ( except the label ) are computed for each node in the skip list . in addition , the @xmath22-th bottom - level node @xmath87 contains @xmath96 $ ] . finally ,",
    "for each node @xmath87 , the label @xmath93 is computed using a _ collision - resistant _ hash function @xmath97 as @xmath98 where @xmath99 and @xmath100 . fig .  [",
    "fig : rbasl ] illustrates a rank - based authenticated skip list for an ordered list @xmath101 .",
    "+ the skip list along with all the associated information are stored in the server .",
    "the client only stores the value of @xmath15 and the label of the root node @xmath102 ( i.e. , @xmath103 ) as the metadata @xmath64 .",
    "the root node of the skip list is @xmath102 .",
    "the @xmath104 of each node in the list is written inside it .",
    "the elements are in the bottom - level ( level 0 ) nodes , and the root node @xmath102 resides in the highest level ( level 3 ) .",
    "the search path for the third element @xmath105 and the verification path for the fifth element @xmath106 are shown . ] * @xmath107 : when the client wants to read the @xmath22-th element @xmath51 , the server sends the requested element along with a proof @xmath108 to the client .",
    "let the verification path of the @xmath22-th element be a sequence of nodes @xmath109 , where @xmath110 is the bottom - level node storing the @xmath22-th element and @xmath111 is the root node of the skip list ( see fig .  [",
    "fig : rbasl ] ) .",
    "then , the proof @xmath108 is of the form @xmath112 where @xmath113 . here , @xmath94 is the level of the node @xmath87 , @xmath114 is 0 ( or 1 ) if @xmath89 ( or @xmath88 ) points to the previous node of @xmath87 in the sequence , and @xmath115 and @xmath116 are the rank and label ( respectively ) of the successor node of @xmath87 that is not present on the verification path .",
    "* @xmath117 : upon receiving the proof @xmath118 from the server , the client checks if the proof corresponds to the latest metadata @xmath64 stored at her end .",
    "the client outputs 1 if the proof matches with the metadata ; she outputs 0 , otherwise .",
    "+ due to the collision - resistance property of the hash function @xmath97 that is used to generate the labels of the nodes of the skip list , the server can not pass the verification without storing the element @xmath51 properly , except with some probability negligible in the security parameter @xmath0 .",
    "* @xmath119 : an update can be an insertion after or a modification of or the deletion of the @xmath22-th bottom - level node .",
    "the type of the update is stored in a variable ` updtype ` .",
    "the client defines @xmath120 ( for an insertion or modification ) or @xmath121 ( for a deletion ) .",
    "she calls @xmath122 for the existing skip list @xmath63 and verifies the response sent by the server by calling @xmath123 . if the proof does not match with the metadata @xmath64 ( the label of the root node of the existing skip list @xmath63 ) , she aborts",
    "otherwise , she updates the value of @xmath15 , computes the new metadata @xmath124 using the proof and stores it at her end temporarily . then , the client asks the server to perform the update specifying the location @xmath22 , ` updtype ` ( insertion , deletion or modification ) and the new element @xmath125 ( ` null ` for deletion ) . *",
    "@xmath126 : depending on the value of ` updtype ` , the server performs the update asked by the client , computes a proof @xmath69 similar to the one generated during @xmath127 and sends @xmath69 to the client .",
    "* @xmath128 : on receiving the proofs from the server , the client verifies the proof @xmath69 and computes the new metadata @xmath129 based on @xmath69 . if @xmath130 and @xmath69 is a valid proof , the client sets @xmath131 , deletes the temporary value @xmath124 and outputs 1 .",
    "otherwise , she changes @xmath15 to its previous value , deletes @xmath124 and outputs 0 .    _",
    "_ note__one limitation of using dynamic versions of merkle hash trees ( for example , authenticated red - black trees ) instead of rank - based authenticated skip lists is that a series of insertions after a particular location makes the tree imbalanced and increases the height of the tree by the number of insertions . in the two - party model as in our case , no efficient rebalancing techniques ( for updating the authentication information of the affected nodes efficiently ) for such a tree have been studied  @xcite . on the other hand , due to the properties of a skip list  @xcite ,",
    "the number of levels in a skip list is logarithmic in @xmath15 with high probability .",
    "for this reason , the size of a proof , the computation time for the server and the verification time for the client are @xmath132 with high probability .      following the work of chen et al .",
    "@xcite , we construct a secure cloud storage protocol for dynamic data ( dscs i ) from the secure network coding ( snc ) protocol proposed by catalano et al .",
    "@xcite which is secure in the standard model .",
    "this basic construction exploits a rank - based authenticated skip list ( discussed in section  [ skip_list ] ) to ensure the freshness of the dynamic data .",
    "dscs i consists of the following procedures . let @xmath97 be the _ collision - resistant _ hash function used in the rank - based authenticated skip list we use in our construction .",
    "we assume that the file @xmath14 to be outsourced to the server is a collection of @xmath15 vectors where each of the vectors consists of @xmath17 blocks .",
    "we note that the procedures keygen , outsource , prove and verify in dscs i call the procedures snc.keygen , snc.taggen , snc.combine and snc.verify ( respectively ) of the underlying snc protocol  @xcite along with performing some other operations related to the authenticated data structure . here",
    ", we provide a detailed description .",
    "* @xmath133 : the client selects two random safe primes , where @xmath134 is also a prime . ] @xmath135 of length @xmath136 bits each and takes @xmath137 .",
    "the client chooses another random prime @xmath138 of length @xmath139 ( in bits ) and sets the file identifier ` fid ` to be equal to @xmath138 .",
    "she selects @xmath140 .",
    "the secret key @xmath39 is @xmath141 , and the public key @xmath47 consists of @xmath142 .",
    "initially , @xmath64 is ` null ` .",
    "let @xmath37 .",
    "* @xmath143 : the file @xmath14 ( associated with the identifier ` fid ` ) consists of @xmath15 vectors each of them having @xmath17 blocks .",
    "we assume that each of these blocks is an element of @xmath144 .",
    "then , for each @xmath145 , the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f_e^n$ ] . for each vector @xmath146",
    ", the client selects a random element @xmath148 and computes @xmath149 such that @xmath150 now , @xmath151 acts as an authentication tag for the vector @xmath146 .",
    "the client constructs a rank - based authenticated skip list @xmath63 on the authentication tags @xmath152 and computes the metadata @xmath64 ( the label of the root node of @xmath63 ) .",
    "finally , the client updates @xmath64 in the public key and uploads the file @xmath153 along with @xmath63 to the cloud server . *",
    "@xmath154 : the value of the variable ` updtype ` indicates whether the update is an insertion after or a modification of or the deletion of the @xmath22-th vector .",
    "the client performs one of the following operations depending on the value of ` updtype ` .",
    "if ` updtype ` is insertion , the client selects @xmath155 and generates the new vector - tag pair @xmath156 .",
    "she runs listinitupdate on @xmath157 and sends @xmath158 to the server .",
    "if ` updtype ` is modification , the client generates the new vector - tag pair @xmath156 .",
    "then , the client runs @xmath159 and sends @xmath160 to the server .",
    "if ` updtype ` is deletion , the client runs the procedure listinitupdate on @xmath157 , where @xmath161 is ` null ` . + the client stores the value of the new metadata @xmath124 temporarily at her end .",
    "* @xmath162 : we assume that , for efficiency , the server keeps a local copy of the ordered list of @xmath163 values for @xmath164 . based on the value of ` updtype ` , the server performs one of the following operations . 1 .",
    "if ` updtype ` is insertion , the server sets @xmath165 , inserts @xmath166 in the @xmath167-th position in the list of @xmath163 values ( for @xmath164 ) and inserts @xmath160 after the @xmath22-th vector .",
    "the server runs listperformupdate on the input @xmath168 .",
    "if ` updtype ` is modification ( @xmath166 is ` null ` ) , the server modifies the @xmath22-th vector to @xmath160 and runs the procedure listperformupdate on @xmath168 .",
    "if ` updtype ` is deletion ( @xmath169 and @xmath161 are ` null ` ) , the server sets @xmath170 , deletes the particular @xmath171 value from the list of @xmath163 values ( @xmath172 $ ] ) and runs listperformupdate@xmath173 .",
    "* @xmath174 : after receiving the proof from the server , the client performs @xmath175 .",
    "if the output of listverifyupdate is 1 , the client outputs 1 and updates her public key ( the latest values of @xmath176 and @xmath163 for @xmath172 $ ] ) accordingly . otherwise , the client outputs 0 . *",
    "@xmath177 : during an audit , the verifier selects @xmath79 , a random @xmath27-element subset of @xmath80 $ ] .",
    "then , she generates a challenge set @xmath178 , where each @xmath179 .",
    "the verifier sends the challenge set @xmath72 to the cloud server . *",
    "@xmath180 : the cloud server , after receiving the challenge set @xmath178 , computes @xmath181 and @xmath182 .",
    "the server , for each @xmath183 , forms @xmath20\\in\\f_e^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "then , it computes @xmath184 , @xmath185 and @xmath186 let @xmath187 be the first @xmath17 entries of @xmath188 and @xmath189 .",
    "the server sends @xmath190 as a proof of storage corresponding to the challenge set @xmath72 , where @xmath191 and @xmath192 . *",
    "@xmath193 : using @xmath178 and @xmath194 sent by the server , the verifier constructs a vector @xmath195\\in\\f_e^{n+m}$ ] , where the first @xmath17 entries of @xmath188 are the same as those of @xmath196 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) .",
    "then , the verifier checks whether @xmath200 she also verifies if , for each @xmath183 , @xmath108 is a valid proof ( with respect to @xmath64 ) for @xmath51 .",
    "the verifier outputs 1 if the proof passes all the verifications ; she outputs 0 , otherwise .",
    "the dscs protocol described above is publicly verifiable as only the knowledge of the public key of the client ( data owner ) enables one to perform an audit ( see the footnote in section  [ scs ] ) .",
    "a secure dscs protocol must satisfy the following properties  @xcite .",
    "a formal security model is described in section  [ security_model ] .    1 .   * * authenticity**the authenticity of storage requires that the cloud server can not produce a valid proof of storage @xmath201 ( corresponding to the challenge set @xmath72 ) without storing the challenged segments and their respective authentication information untampered , except with a probability negligible in @xmath0 .",
    "* freshness**the freshness of storage guarantees that the server is storing an up - to - date version of the file @xmath14 .",
    "* extractability**the extractability ( or retrievability ) of data requires that , given a probabilistic polynomial - time adversary @xmath3 that can respond correctly to a challenge @xmath72 with some non - negligible probability , there exists a polynomial - time extractor algorithm @xmath202 that can extract ( at least ) the challenged segments ( except with negligible probability ) by challenging @xmath3 for a polynomial ( in @xmath0 ) number of times and verifying the responses sent by @xmath3 .",
    "the algorithm @xmath202 has a non - black - box access to @xmath3 .",
    "thus , @xmath202 can rewind @xmath3 , if required .",
    "the dscs i protocol offers the guarantee of dynamic provable data possession ( dpdp )  @xcite .",
    "we describe the data possession game of dpdp between the challenger ( acting as the client ) and the adversary ( acting as the cloud server ) as follows .    *",
    "the challenger generates a key pair @xmath203 and gives @xmath47 to the adversary . *",
    "the adversary selects a file @xmath14 associated with the identifier ` fid ` to store .",
    "the challenger processes the file to form another file @xmath65 with the help of @xmath39 and returns @xmath65 to the adversary .",
    "the challenger stores only some metadata to verify the updates to be performed by the adversary later .",
    "the adversary chooses a sequence of updates ( of its choice ) defined by @xmath204 for @xmath205 ( @xmath206 is polynomial in the security parameter @xmath0 ) and asks the challenger to initiate the update . for each update , the challenger runs @xmath207 and stores the latest metadata at her end .",
    "the adversary sends a proof after executing @xmath208 . the challenger verifies this proof by running @xmath209 and updates her metadata if and only if the proof passes the verification .",
    "the adversary is notified about the output of @xmath209 for each update .",
    "* let @xmath210 be the final state of the file after @xmath206 updates .",
    "the challenger has the latest metadata for the file @xmath210 .",
    "now , she challenges the adversary with a random challenge set @xmath72 , and the adversary returns a proof @xmath190 to the challenger .",
    "the adversary wins the game if the proof passes the verification .",
    "the challenger can challenge the adversary @xmath211 ( polynomial in @xmath0 ) number of times in an attempt to extract ( at least ) the challenged vectors of @xmath210 .",
    "[ def : security_dpdp ] a dynamic provable data possession scheme is secure if , given any probabilistic polynomial - time adversary @xmath3 who can win the data possession game mentioned above with some non - negligible probability , there exists a polynomial - time extractor algorithm @xmath202 that can extract ( at least ) the challenged vectors of the file by interacting ( via challenge - response ) with @xmath3 polynomially many times .",
    "we state and prove the following theorem in order to analyze the security of dscs i.    [ theorem_dscsi ] given that the hash function used to construct the rank - based authenticated skip list is collision - resistant and the underlying network coding scheme is secure , the dscs i protocol described in section  [ modified_scheme ] is secure in the standard model according to definition  [ def : security_dpdp ] .",
    "we use the following claims in order to prove theorem  [ theorem_dscsi ] .",
    "[ claim_freshness ] given that the hash function used to construct the rank - based authenticated skip list is collision - resistant , the freshness of the data file is guaranteed in the dscs i protocol .",
    "the freshness of storage requires that the cloud server must store an up - to - date version of the data file outsourced by the client .",
    "in dscs i , the hash function @xmath97 ( see section  [ skip_list ] ) used to compute the labels of the nodes in the rank - based authenticated skip list @xmath63 is collision - resistant . for each update ,",
    "freshness of data is guaranteed using the procedure verifyupdate ( by computing @xmath129 from @xmath69 and checking if @xmath212 ) during the data possession game .",
    "moreover , for each challenge @xmath72 , freshness of data is guaranteed by checking the validity of the proof @xmath192 with respect to the latest metadata @xmath64 ( in the procedure verify ) during the data possession game and the extraction phase .",
    "if the adversary is able to forge a skip list proof with respect to the latest value of @xmath64 ( i.e. , if it makes the output of some execution of verifyupdate or verify to be 1 without storing the latest authentication tags ) , then it must have found a collision for the hash function @xmath97 in some level of the rank - based authenticated skip list .",
    "this event occurs with a negligible probability as @xmath97 is taken to be collision - resistant .    [ claim_authenticity ] given that the underlying network coding scheme is secure in the standard model , the authenticity of the data file is guaranteed in dscs i.    the authenticity of storage demands that the cloud server , without storing the challenged vectors and their respective authentication tags appropriately , can not produce a valid response @xmath213 for a challenge set @xmath178 during the data possession game ( and during the extraction phase ) .",
    "the data file @xmath14 with a random ( but unique ) ` fid ` is identified by the augmented vectors @xmath20\\in\\f_e^{n+m}$ ] for @xmath19 $ ] .",
    "let @xmath214 be the response computed honestly ; thus , verify@xmath215 .",
    "let @xmath195\\in\\f_e^{n+m}$ ] , where the first @xmath17 entries of @xmath188 are the same as those of @xmath196 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) .",
    "now , if possible , we assume that the adversary produces another valid response @xmath213 for the same @xmath72 such that verify@xmath216 , where @xmath217 .",
    "let @xmath218\\in\\f_e^{n+m}$ ] , where the first @xmath17 entries of @xmath219 are the same as those of @xmath220 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) . clearly , @xmath221 .",
    "we observe that the procedure verify executes the procedure snc.verify . as",
    "verify@xmath222 outputs 1 , it follows that snc.verify@xmath223 .",
    "we also note that , for a particular challenge @xmath72 , the set of indices @xmath79 and the corresponding coefficients @xmath198 ( for @xmath183 ) are randomly chosen by the challenger ( data possession game ) or by the extractor ( extraction phase ) . as the basis vectors @xmath224 for the particular data file @xmath14 ( identified by ` fid ` ) are unique , their linear combination using fixed coefficients ( @xmath22-th coefficient is @xmath198 or 0 depending on whether @xmath183 or @xmath199 ) is also unique .",
    "this unique linear combination is @xmath188 .",
    "therefore , @xmath225 .    to sum up",
    ", we find a pair @xmath226 for a file with identifier ` fid ` such that @xmath227\\in \\f_e^m$ ] is not the all - zero vector , snc.verify@xmath228 outputs 1 and @xmath225 ( _ type-2 forgery _ as mentioned in section  [ snc ] ) .",
    "however , since the network coding protocol  @xcite we use in dscs i is secure in the standard model , the adversary can not produce such a response @xmath229 , except with some probability negligible in the security parameter .",
    "we define a polynomial - time extractor algorithm @xmath202 that can extract ( at least ) the challenged vectors ( except with negligible probability ) by interacting with an adversary @xmath3 that wins the data possession game mentioned above with some non - negligible probability . as dscs",
    "i satisfies the _ authenticity _ and _ freshness _ properties mentioned above , @xmath3 can not produce a proof @xmath190 for a given challenge set @xmath178 without storing the challenged blocks and their corresponding tags properly , except with some negligible probability .",
    "this means that if the output of the procedure verify is 1 during the extraction phase , the vector @xmath196 in the proof is the linear combination of the original data vectors @xmath146 for @xmath183 using coefficients @xmath230 .",
    "suppose that the extractor @xmath202 wants to extract @xmath27 blocks indexed by @xmath231 .",
    "it challenges @xmath3 with @xmath232 .",
    "if the proof is valid ( checked using verify ) , @xmath202 initializes a matrix @xmath233 as @xmath234_{i\\in j}$ ] , where @xmath235 for each @xmath236 .",
    "the extractor challenges @xmath3 for the same @xmath231 but with different random coefficients .",
    "if the procedure verify outputs 1 and the vector of coefficients is linearly independent to the existing rows of @xmath233 , then @xmath202 appends this vector to @xmath233 as a row .",
    "the extractor @xmath202 runs this procedure until the matrix @xmath233 has @xmath27 linearly independent rows .",
    "so , the final form of the full - rank matrix @xmath233 is @xmath237_{j\\in[1,l ] , i\\in j}$ ] .",
    "therefore , the challenged blocks can be extracted with the help of gaussian elimination .",
    "this completes the proof of theorem  [ theorem_dscsi ] .",
    "if the server has corrupted a constant fraction ( say , @xmath238 ) of vectors in a file , then the server passes an audit with probability @xmath239 , where @xmath27 is the cardinality of @xmath72 .",
    "the probability @xmath240 is very small for large values of @xmath27 .",
    "typically , @xmath27 is taken to be @xmath60 in order to make the probability @xmath240 negligible in @xmath0 .",
    "thus , the verifier detects a malicious server corrupting @xmath238-fraction of the file with probability @xmath241 , and it guarantees the integrity of _ almost all _ vectors of the file .",
    "the basic dscs i protocol described in section  [ modified_scheme ] is publicly verifiable , that is , a third party auditor ( tpa ) having the knowledge of the public parameters can perform an audit .",
    "chen et al .",
    "@xcite construct a secure cloud storage protocol for _ static _ data using the same snc protocol  @xcite .",
    "they note that , in order to make an audit privacy - preserving , the server adds a random linear combination of some random vectors to the computed value of @xmath196 to form the final response . due to the addition of this random component to the resulting vector @xmath196 ,",
    "the third party auditor ( tpa ) can not gain knowledge ( by solving a set of linear equations ) of the challenged vectors .",
    "accordingly , we modify our basic dscs i protocol in order to support privacy - preserving audits in the following way .",
    "we change two procedures , outsource and prove , from the basic protocol .",
    "the rest of the procedures involved in the protocol are the same as in the basic protocol .    * @xmath143 : the file @xmath14 ( associated with the identifier ` fid ` ) consists of @xmath15 vectors each of them having @xmath17 blocks .",
    "we assume that each of these blocks is an element of @xmath144 .",
    "then , for each @xmath145 , the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f_e^n$ ] . for each vector @xmath146",
    ", the client selects a random element @xmath148 and computes @xmath149 such that @xmath242 now , @xmath151 acts as an authentication tag for the vector @xmath146 .",
    "the client constructs a rank - based authenticated skip list @xmath63 on the authentication tags @xmath152 and computes the metadata @xmath64 ( the label of the root node of @xmath63 ) .",
    "finally , the client updates @xmath64 in the public key and uploads the file @xmath153 along with @xmath63 to the cloud server .",
    "the client also uploads , to the server , a set @xmath243 of @xmath244 vectors ( along with their authentication tags ) generated as follows . for each @xmath245 $ ] , @xmath246 $ ] , where @xmath247 for each @xmath35 $ ] and @xmath248 for each @xmath249 $ ] . for each vector @xmath250",
    ", the client selects a random element @xmath251 and computes @xmath252 such that @xmath253 then , the client uploads the set @xmath254 along with the tags @xmath255}$ ] to the cloud server . *",
    "@xmath180 : the cloud server , after receiving the challenge set @xmath178 , selects a set @xmath256 , where @xmath257 for each @xmath258 .",
    "then , it computes @xmath259 and @xmath260 . the server , for each @xmath183 , forms @xmath20\\in\\f_e^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21",
    ". then , it computes @xmath261 , @xmath262 and @xmath263 let @xmath187 be the first @xmath17 entries of @xmath188 and @xmath189 .",
    "the server sends @xmath190 as a proof of storage corresponding to the challenge set @xmath72 , where @xmath191 and @xmath192 .",
    "thus , during an audit , the server randomizes the linear combination of the challenged vectors with the help of a random linear combination of some predefined vectors prohibiting the tpa from gaining knowledge of the challenged vectors .",
    "in a follow - up work of  @xcite , chen et al .  @xcite extend their scs protocol for static data to a group setting where the users belonging to a group share the outsourced data ( or file ) and modify the same . in this scenario , the users in the group delegate the work of generating authentication tags for the vectors ( of the file to be outsourced ) to a security - mediator  @xcite .",
    "as the tags are generated by the mediator using the same secret key for all users , the cloud server can not distinguish the users uploading ( or updating ) the file .",
    "the secret key is kept with the mediator only ; thus , the users do not have the knowledge of the same .",
    "moreover , a user obtains a tag corresponding to a vector @xmath188 from the mediator in such a way that the mediator can not gain knowledge of the content of @xmath188 . a user outsources ( or updates ) the file using an anonymous channel  @xcite .",
    "finally , every user in the group can perform an audit on the file kept in the cloud server .",
    "dscs i can be extended to support anonymity for shared dynamic data as well .",
    "the procedures involved are described below .",
    "* @xmath133 : the mediator selects two random safe primes @xmath135 of length @xmath136 bits each and takes @xmath137 .",
    "it chooses another random prime @xmath138 of length @xmath139 ( in bits ) and sets the file identifier ` fid ` to be equal to @xmath138 .",
    "the mediator selects @xmath140 .",
    "the secret key @xmath39 is @xmath141 , and the public key @xmath47 consists of @xmath142 .",
    "initially , @xmath64 is ` null ` .",
    "let @xmath37 .",
    "we assume that every user in the group can update the public key efficiently . *",
    "@xmath264 : a user randomly selects vectors @xmath265 and @xmath266 such that @xmath267 . the user send the vectors @xmath265 to the mediator for their respective authentication tags .",
    "the mediator sends the tags @xmath268 to the user . *",
    "@xmath269 : due to the homomorphic property of the underlying signature scheme , the user computes the authentication tag @xmath40 corresponding to the vector @xmath188 in the same way as discussed in section  [ modified_scheme ] ( see the procedure prove ) . *",
    "@xmath143 : let the initial file @xmath14 ( associated with the identifier ` fid ` ) consist of @xmath15 vectors each of them having @xmath17 blocks .",
    "we assume that each of these blocks is an element of @xmath144 .",
    "then , for each @xmath145 , the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f_e^n$ ] . for each vector @xmath146",
    ", a user obtains the corresponding authentication tag @xmath151 from the security - mediator ( using the procedures blind and unblind described above ) such that @xmath148 and @xmath270 the user constructs a rank - based authenticated skip list @xmath63 on the authentication tags @xmath152 and computes the metadata @xmath64 ( the label of the root node of @xmath63 ) .",
    "finally , the user updates @xmath64 in the public key and uploads the file @xmath153 along with @xmath63 to the cloud server . *",
    "@xmath271 : the value of the variable ` updtype ` indicates whether the update is an insertion after or a modification of or the deletion of the @xmath22-th vector .",
    "the user performs one of the following operations depending on the value of ` updtype ` .",
    "if ` updtype ` is insertion , the user selects @xmath155 and generates the new vector - tag pair @xmath156 using the procedures blind and unblind ( with the help of the mediator ) .",
    "she runs listinitupdate on @xmath157 and sends @xmath158 to the server .",
    "if ` updtype ` is modification , the user generates the new vector - tag pair @xmath156 using the procedures blind and unblind .",
    "then , she runs @xmath159 and sends @xmath160 to the server .",
    "if ` updtype ` is deletion , the user runs the procedure listinitupdate on @xmath157 , where @xmath161 is ` null ` .",
    "+ the user stores the value of the new metadata @xmath124 temporarily at her end . *",
    "@xmath162 : we assume that , for efficiency , the server keeps a local copy of the ordered list of @xmath163 values for @xmath164 . based on the value of ` updtype `",
    ", the server performs one of the following operations . 1 .",
    "if ` updtype ` is insertion , the server sets @xmath165 , inserts @xmath166 in the @xmath167-th position in the list of @xmath163 values ( for @xmath164 ) and inserts @xmath160 after the @xmath22-th vector .",
    "the server runs listperformupdate on the input @xmath168 .",
    "if ` updtype ` is modification ( @xmath166 is ` null ` ) , the server modifies the @xmath22-th vector to @xmath160 and runs the procedure listperformupdate on @xmath168 .",
    "3 .   if ` updtype ` is deletion ( @xmath169 and @xmath161 are ` null ` ) , the server sets @xmath170 , deletes the particular @xmath171 value from the list of @xmath163 values ( @xmath172 $ ] ) and runs listperformupdate@xmath173 .",
    "* @xmath174 : after receiving the proof from the server , the user performs @xmath175 .",
    "if the output of listverifyupdate is 1 , the user outputs 1 and updates the public key ( the latest values of @xmath176 and @xmath163 for @xmath172 $ ] ) accordingly . otherwise , the user outputs 0 . *",
    "@xmath177 : a user performing an audit selects @xmath79 , a random @xmath27-element subset of @xmath80 $ ] .",
    "then , she generates a challenge set @xmath178 , where each @xmath179 .",
    "the user sends the challenge set @xmath72 to the cloud server .",
    "* @xmath180 : the cloud server , after receiving the challenge set @xmath178 , computes @xmath181 and @xmath182 .",
    "the server , for each @xmath183 , forms @xmath20\\in\\f_e^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "then , it computes @xmath184 , @xmath185 and @xmath272 let @xmath187 be the first @xmath17 entries of @xmath188 and @xmath189 .",
    "the server sends @xmath190 as a proof of storage corresponding to the challenge set @xmath72 , where @xmath191 and @xmath192 . *",
    "@xmath193 : using @xmath178 and @xmath194 sent by the server , the user performing the audit constructs a vector @xmath195\\in\\f_e^{n+m}$ ] , where the first @xmath17 entries of @xmath188 are the same as those of @xmath196 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) .",
    "then , the user checks whether @xmath273 she also verifies if , for each @xmath183 , @xmath108 is a valid proof ( with respect to @xmath64 ) for @xmath51 .",
    "the user outputs 1 if the proof passes all the verifications ; she outputs 0 , otherwise .",
    "we have modified our basic dscs i protocol ( described in section  [ modified_scheme ] ) to handle a group of users sharing their data without disclosing their identity to the cloud server . if we require a third party auditor ( other than the users in the group ) to audit on behalf of the group in a privacy - preserving fashion , it is not hard to see that the same changes ( discussed in section  [ ppa_scheme ] ) can be applied in the group setting as well .",
    "if we consider a procedure update to be the triplet of the procedures ( initupdate , performupdate , verifyupdate ) , such an procedure update must be performed atomically .",
    "additionally , an update and an audit must not coincide in order to maintain the consistency of the outsourced data .",
    "in this section , we discuss about the efficiency of our dscs i protocol ( described in section  [ modified_scheme ] ) and compare this scheme with other existing scs protocols achieving provable data possession guarantees .",
    "we also identify some limitations of an snc - based scs scheme ( for static or dynamic data ) compared to the dpdp i scheme ( described in appendix  [ dpdpi ] ) .    [",
    "cols=\"^,^,^,^,^,^,^,^ \" , ]     [ tab : comparison_pdp ]    for simplicity , we exclude the security parameter @xmath0 from complexity parameters ( for an audit ) .",
    "the value @xmath274 denotes the number of segments the data file is divided in ( such that an authentication tag is associated with each segment ) .",
    "for example , @xmath275 in our dscs ( i and ii ) schemes , where @xmath15 denotes the number of vectors .",
    "the term @xmath276 is added implicitly to each complexity parameter , where @xmath277 is the size of each segment .",
    "for example , @xmath278 in dscs i and ii , where a vector having @xmath17 blocks is considered to be a segment . for all the schemes , the storage at the verifier side is @xmath279 , and the storage at the server side is @xmath280 where @xmath65 is the outsourced file . if @xmath27 is the cardinality of the challenge set and the server corrupts @xmath238 fraction of the file , the detection probability @xmath281 for all the schemes ( except , in dpdp ii , @xmath282 ) .",
    "@xmath283 ro denotes the random oracle model  @xcite .",
    "@xmath284 scalable pdp scheme supports deletion , modification and append only for a predefined number of times ; insertion is not supported in this scheme .",
    "@xmath285 a small change ( making the latest values of @xmath286 and @xmath274 public ) is required in the original scheme ( see section  [ dpdpi ] ) .",
    "@xmath287 @xmath288 is a constant such that @xmath289 .",
    "@xmath290 in the preliminary version of this paper  @xcite , we modify dpdp i  @xcite to make its audits privacy - preserving . the modified dpdp i scheme is described in appendix  [ pp_dpdp ] .",
    "@xmath291 dscs ii supports only append and modification ; arbitrary insertion ( or deletion ) is not supported .      the computational cost of the procedures in dscs i is dominated by the cost of exponentiations ( modulo @xmath292 ) . to generate the value @xmath293 in an authentication tag for each vector ( in the procedure outsource ) , the client has to perform a multi - exponentiation in a finite group is to multiply the results of the individual exponentiations .",
    "there are better algorithms for computing such a multi - exponentiation  @xcite . ] and calculate the @xmath138-th root of the result ( see eqn .",
    "[ netcod : eqn1 ] ) .",
    "the server requires two multi - exponentiations to calculate the value of @xmath293 ( see eqn .  [",
    "netcod : eqn2 ] in the procedure prove ) . to verify a proof using the procedure verify",
    ", the verifier has to perform a multi - exponentiation and a single exponentiation ( see eqn .",
    "[ netcod : eqn3 ] ) .    as mentioned in section  [ skip_list ] , due to the properties of a skip list  @xcite , the size of each proof @xmath69 ( related to the rank - based authenticated skip list ) , the time required to generate @xmath69 and the time required to verify @xmath69 are @xmath132 with high probability .",
    "as dscs i protocol provides provable data possession ( pdp ) guarantees , we compare our scheme with some other pdp schemes found in the literature .",
    "the comparison shown in table  [ tab : comparison_pdp ] is done based on different parameters related to an audit . in section  [ append ] , we propose a more efficient scheme suitable for append - only data that we mention as dscs ii in table  [ tab : comparison_pdp ] .    now",
    ", we discuss about a few limitations of our dscs i protocol compared to dpdp i ( specifically ) , since both of them are secure in the _ standard model _ , handle _ dynamic _ data and offer _",
    "public verifiability_. in dscs i , the audits are privacy - preserving , that is , a third party auditor ( tpa ) can not gain knowledge of the data actually stored in the cloud server . although the original dpdp i scheme does not offer privacy - preserving audits , this scheme can be modified to support the same ( see appendix  [ pp_dpdp ] ) .",
    "the issues of our scheme compared to the modified dpdp i scheme are mentioned below .    1 .",
    "the size of the public key is @xmath294 in dscs i. on the other hand , the size of the public key in the modified dpdp i scheme is constant .",
    "2 .   the authentication tags in dscs i are of the form @xmath295 , where @xmath296 and @xmath297 .",
    "an authentication tag in the modified dpdp i scheme is an element of @xmath298 .",
    "thus , the size of a tag in dscs i is larger than that in the modified dpdp i scheme by @xmath139 bits ( as @xmath138 is a @xmath299-bit prime ) .",
    "3 .   in dscs",
    "i , the value of @xmath300 and the @xmath171 values in the public key must be changed for each insertion or deletion ( only change in @xmath64 is required for modification ) , whereas only the value of @xmath301 needs to be changed in the modified dpdp i scheme .",
    "however , if the server keeps a local copy of the public key ( an ordered list containing @xmath171 values for @xmath302 $ ] ) , then small changes are required at the server side .",
    "the server inserts the new @xmath97 value ( sent by the client ) in @xmath167-th position in the list ( for insertion ) or discards the @xmath22-th @xmath97 value ( for deletion ) .",
    "thus , the proposed dscs i scheme suffers from the limitations mentioned above .",
    "we note that the existing scs protocol for static data  @xcite based on the same snc protocol  @xcite also suffers from the first two of these limitations .",
    "however , in this work , we explore if a secure cloud storage protocol for dynamic data can be constructed from a secure network coding protocol .",
    "a more efficient ( in terms of the size of the public key or the size of an authentication tag ) snc protocol can lead us to the construction of a more efficient dscs protocol in future . in the following section",
    ", we propose another secure cloud storage protocol ( dscs ii ) for append - only data that is much more efficient than dscs i.",
    "although generic dynamic data are useful , append - only data find numerous applications as well .",
    "these primarily include archival data from different sources where data are appended to the existing datasets .",
    "for example , data obtained from closed circuit television ( cctv ) camera , monetary transactions in banks , medical history of patients  all must be kept intact with append being the only possible update . on the other hand ,",
    "various cloud service providers like amazon web services ( aws ) use hadoop distributed file system ( hdfs  @xcite ) to store large volume of data . in hdfs",
    ", data blocks are added by an application to a new file .",
    "after closing the file , the blocks can not be removed or modified further ; blocks can only be appended by reopening the file .",
    "append - only data are also useful for maintaining log structures ( e.g. , certificates are stored using append - only log structures in certificate transparency schemes  @xcite ) .    in this section , we construct a more efficient dscs scheme ( dscs ii ) for append - only data using the snc protocol proposed by boneh et al .  @xcite that is not suitable for constructing a dscs scheme for generic dynamic data ( see section  [ chal_dscs ] ) .",
    "first , we give a brief overview of the snc protocol and discuss a key property of it that allows us to construct dscs ii based on the protocol .",
    "then , we provide the construction of the dscs ii scheme .      boneh et al .  @xcite propose a homomorphic network coding signature scheme secure in the random oracle model  @xcite under the co - computational diffie hellman ( co - cdh ) assumption .",
    "we briefly describe the procedures involved in this scheme .",
    "the notations are the same as those discussed in section  2.2 .",
    "* keygen@xmath36 : let @xmath303 be a bilinear group tuple , where @xmath304 and @xmath305 are multiplicative cyclic groups of prime order @xmath306 , and the functions @xmath307 ( bilinear map ) and @xmath308 are efficiently computable .",
    "choose @xmath309 , @xmath310 and @xmath311 .",
    "take @xmath312 .",
    "let @xmath313 be a hash function considered to be a random oracle .",
    "the public key is @xmath314 , and the private key is @xmath315 .",
    "* taggen@xmath316 : given the secret key @xmath39 , a linear subspace @xmath317 spanned by the augmented vectors @xmath25 and a random file identifier ` fid ` @xmath318 , the sender outputs the signature @xmath319 for the @xmath22-th basis vector @xmath320\\in\\f_p^{n+m}$ ] for each @xmath19 $ ] . *",
    "combine@xmath321 : given the public key @xmath47 , the file identifier ` fid ` and @xmath27 tuples ( each consisting of a vector @xmath322 , a coefficient @xmath323 and a signature @xmath51 ) , an intermediate node outputs the signature @xmath324 for another vector @xmath325 . *",
    "verify@xmath326 : given the public key @xmath47 , the unique file identifier ` fid ` , a signature @xmath40 and a vector @xmath327\\in\\f_p^{n+m}$ ] , an intermediate node or the receiver node checks whether @xmath328 if the equality holds , it outputs 1 ; it outputs 0 , otherwise .",
    "we recall that in a secure cloud storage protocol ( using secure network coding ) , the client divides the file @xmath14 associated with ` fid ` into @xmath15 vectors each of them having @xmath17 blocks .",
    "the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f^n,\\forall i\\in[1,m]$ ] . for each vector @xmath146 , the client forms @xmath20\\in\\f^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "if we use the current snc protocol  @xcite , the client runs @xmath329 to produce , for each @xmath19 $ ] , a signature ( authentication tag ) @xmath330 for the vector @xmath82 .",
    "we observe that the vector index @xmath22 is embedded in the tag corresponding to the @xmath22-th vector .",
    "therefore , the scheme is not suitable for construction of a secure cloud storage for dynamic ( in generic sense ) data as mentioned in section  [ chal_dscs ] .      from the previous section",
    ", we note that the authentication tags in the snc protocol  @xcite are independent of the value @xmath15 ( see eqn .",
    "[ eqn_boneh ] ) .",
    "the size of the public key also does not depend on @xmath15 .",
    "this makes the snc protocol suitable for constructing a more efficient dscs scheme .",
    "however , as each authentication tag embeds the index of the respective vector , we can not insert or delete at arbitrary positions of the data file .",
    "since the value of the index @xmath22 of the vector to be inserted only increases for append - only data , the snc protocol provides an efficient dscs protocol ( dscs ii ) .",
    "we observe that , for the same reason , the snc protocol proposed by gennaro et al .",
    "@xcite can also be used for such a construction .",
    "although we construct dscs ii to handle append - only data , it supports modifications of existing vectors trivially .",
    "dscs ii consists of the following procedures .    * @xmath133 : let @xmath303 be a bilinear group tuple , where @xmath304 and @xmath305 are multiplicative cyclic groups of prime order @xmath306 , and the functions @xmath307 ( bilinear map ) and @xmath308 are efficiently computable .",
    "the client selects @xmath309 , @xmath310 and @xmath311 .",
    "she takes @xmath312 and chooses a random file identifier ` fid ` @xmath318 .",
    "let @xmath313 be a hash function considered to be a random oracle .",
    "the public key is @xmath331 , and the private key is @xmath315 .",
    "initially , @xmath64 is ` null ` .",
    "let @xmath37 .",
    "* @xmath143 : the file @xmath14 ( associated with the identifier ` fid ` ) consists of @xmath15 vectors each of them having @xmath17 blocks .",
    "we assume that each of these blocks is an element of @xmath332 .",
    "then , for each @xmath145 , the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f_p^n$ ] . for each vector @xmath146",
    ", the client computes the authentication tag @xmath333 as shown in eqn .",
    "[ eqn_boneh ] .",
    "the client constructs a rank - based authenticated skip list @xmath63 on the authentication tags @xmath152 and computes the metadata @xmath64 ( the label of the root node of @xmath63 ) .",
    "finally , the client updates @xmath64 in the public key and uploads the file @xmath153 along with @xmath63 to the cloud server . *",
    "@xmath154 : the value of the variable ` updtype ` indicates whether the update is a modification of the @xmath22-th vector or an append at the end of the file .",
    "the client performs one of the following operations depending on the value of ` updtype ` .",
    "if ` updtype ` is append , the client generates the new vector - tag pair @xmath156 and sets ` updtype ` to be insertion .",
    "she runs listinitupdate on @xmath334 and sends @xmath160 to the server .",
    "if ` updtype ` is modification , the client generates the new vector - tag pair @xmath156 .",
    "then , the client runs @xmath159 and sends @xmath160 to the server . + the client stores the value of the new metadata @xmath124 temporarily at her end .",
    "* @xmath162 : based on the value of ` updtype ` , the server performs one of the following operations . 1 .",
    "if ` updtype ` is append , the server inserts @xmath160 after the @xmath15-th vector and sets ` updtype ` to be insertion .",
    "the server runs listperformupdate on the input @xmath335 and sets @xmath165 .",
    "if ` updtype ` is modification , the server modifies the @xmath22-th vector to @xmath160 and runs the procedure listperformupdate on @xmath168 .",
    "* @xmath174 : after receiving the proof from the server , the client performs one of the following operations based on the value of ` updtype ` .",
    "if ` updtype ` is append , the client sets ` updtype ` to be insertion and executes the procedure listverifyupdate on @xmath336 .",
    "if ` updtype ` is modification , the client executes @xmath175 .",
    "+ if the output of listverifyupdate is 1 , the client outputs 1 and updates her public key ( the latest values of @xmath15 and @xmath64 ) accordingly . otherwise , the client outputs 0 . *",
    "@xmath177 : during an audit , the verifier selects @xmath79 , a random @xmath27-element subset of @xmath80 $ ] .",
    "then , she generates a challenge set @xmath178 , where each @xmath337 .",
    "the verifier sends the challenge set @xmath72 to the cloud server . *",
    "@xmath180 : upon receiving the challenge set @xmath178 , the cloud server , for each @xmath183 , forms @xmath20\\in\\f_p^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "then , it computes the authentication tag @xmath338 for another vector @xmath339 .",
    "let @xmath340 be the first @xmath17 entries of @xmath188 .",
    "the server sends @xmath190 as a proof of storage corresponding to the challenge set @xmath72 , where @xmath191 and @xmath192 . *",
    "@xmath193 : using @xmath178 and @xmath194 sent by the server , the verifier constructs a vector @xmath195\\in\\f_p^{n+m}$ ] , where the first @xmath17 entries of @xmath188 are the same as those of @xmath196 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) .",
    "then , the verifier checks whether @xmath341 she also verifies if , for each @xmath183 , @xmath108 is a valid proof ( with respect to @xmath64 ) for @xmath51 .",
    "the verifier outputs 1 if the proof passes all the verifications ; she outputs 0 , otherwise .",
    "the secure cloud storage scheme ( dscs ii ) described above supports only append at the end of the data file and modification of any existing vector in the file .",
    "the scheme is publicly verifiable in that anyone with the knowledge of the public key can perform an audit .",
    "the scheme is secure in the random oracle model ( according to definition  [ def : security_dpdp ] in section  [ security_dscsi ] ) .",
    "the security proof of dscs ii is the same as that of our dscs i protocol ( see theorem  [ theorem_dscsi ] ) except that the guarantee of authenticity comes from the security of the underlying snc protocol  @xcite that is secure in the random oracle model .",
    "moreover , the audits in this scheme can be made privacy - preserving in the same way as discussed in section  [ ppa_scheme ] .      in the procedure",
    "outsource , the client has to perform a multi - exponentiation to generate the value of an authentication tag for each vector @xmath40 ( see eqn .  [ eqn_ap1 ] ) .",
    "the server requires one multi - exponentiation to calculate the value of @xmath40 ( see eqn .",
    "[ eqn_ap2 ] in the procedure prove ) .",
    "the verifier has to perform two multi - exponentiations and two pairing operations ( see eqn .",
    "[ eqn_ap3 ] ) to verify a proof using the procedure verify . due to the properties of a skip list  @xcite , the size of each proof @xmath69 ( related to the rank - based authenticated skip list ) , the time required to generate @xmath69 and the time required to verify @xmath69 are @xmath132 with high probability .",
    "different parameters of the scheme ( dscs ii ) related to an audit are shown in table  [ tab : comparison_pdp ] ( section  [ comparison ] ) .",
    "an authentication tag @xmath40 in dscs ii belongs to @xmath342 , and thus , is of size @xmath343 bits for type 2 pairings  @xcite .",
    "the dscs ii scheme for append - only data overcomes some of the limitations of our dscs i protocol described in section  [ modified_scheme ] as follows .    1 .   in dscs ii ,",
    "the size of the public key is @xmath344 ( which is @xmath294 in dscs i ) , where @xmath17 ( @xmath345 ) is fixed during the setup and kept unchanged during the execution of the protocol .",
    "2 .   in dscs ii ,",
    "only the value of @xmath300 needs to be changed for an append operation that is similar to dpdp i  @xcite . on the other hand ,",
    "the @xmath171 values in the public key , in addition to the value of @xmath300 , need to be changed for each insertion or deletion in dscs i.",
    "in this work , we have proposed a dscs protocol ( dscs i ) based on an snc protocol . to the best of our knowledge ,",
    "this is the first snc - based dscs protocol that is secure in the standard model and enjoys public verifiability .",
    "we have also discussed about some challenges while constructing , in general , an efficient dscs protocol from an snc protocol .",
    "we have shown that dscs i can be extended to support privacy - preserving audits and to preserve anonymity for shared data where the cloud server can not distinguish the users in a group updating the shared data .",
    "we have analyzed the efficiency of our dscs construction and compare it with other existing secure cloud storage protocols achieving the guarantees of provable data possession .",
    "we have also identified some limitations of an snc - based secure cloud storage protocol .",
    "however , some of these limitations follow from the underlying snc protocols used .",
    "a more efficient snc protocol can give us a dscs protocol with a better efficiency .",
    "finally , we have constructed another dscs ii scheme for append - only data that overcomes some of the limitations of dscs i.    10    agrawal , s. , boneh , d. : homomorphic macs : mac - based integrity for network coding . in : applied cryptography and network security - acns 2009 .",
    "( 2009 ) 292305    ahlswede , r. , cai , n. , li , s.r . ,",
    "yeung , r.w . : network information flow .",
    "transactions on information theory * 46*(4 ) ( 2000 ) 12041216    armknecht , f. , bohli , j. , karame , g.o . , liu , z. , reuter , c.a . :",
    "outsourced proofs of retrievability . in : acm conference on computer and communications security ,",
    "( 2014 ) 831843    ateniese , g. , burns , r.c .",
    ", curtmola , r. , herring , j. , kissner , l. , peterson , z.n.j . , song , d.x . :",
    "provable data possession at untrusted stores . in : acm conference on computer and communications security , ccs 2007 .",
    "( 2007 ) 598609    ateniese , g. , pietro , r.d . , mancini , l.v .",
    ", tsudik , g. : scalable and efficient provable data possession . in : international conference on security and privacy in communication networks , securecomm 2008 .",
    "( 2008 )  9    attrapadung , n. , libert , b. : homomorphic network coding signatures in the standard model . in : public key cryptography - pkc 2011 .",
    "( 2011 ) 1734    bellare , m. , rogaway , p. : random oracles are practical : a paradigm for designing efficient protocols . in : acm conference on computer and communications security , ccs 1993 .",
    "( 1993 ) 6273    boneh , d. , freeman , d.m . , katz , j. , waters , b. : signing a linear subspace : signature schemes for network coding . in : public key cryptography - pkc 2009 .",
    "( 2009 ) 6887    bowers , k.d . ,",
    "juels , a. , oprea , a. : : a high - availability and integrity layer for cloud storage . in : acm conference on computer and communications security , ccs 2009 .",
    "( 2009 ) 187198    bowers , k.d . ,",
    "juels , a. , oprea , a. : proofs of retrievability : theory and implementation . in : acm cloud computing security workshop , ccsw 2009 .",
    "( 2009 ) 4354    cash , d. , kp , a. , wichs , d. : dynamic proofs of retrievability via oblivious ram . in : advances in cryptology - eurocrypt 2013 , springer berlin heidelberg ( 2013 ) 279295    catalano , d. , fiore , d. , warinschi , b. : efficient network coding signatures in the standard model . in : public key cryptography - pkc 2012 .",
    "( 2012 ) 680696    chandran , n. , kanukurthi , b. , ostrovsky , r. : locally updatable and locally decodable codes . in : theory of cryptography conference , tcc 2014 .",
    "( 2014 ) 489514    charles , d.x . , jain , k. , lauter , k.e .",
    ": signatures for network coding .",
    "international journal of information and coding theory * 1*(1 ) ( 2009 ) 314    chen , b. , curtmola , r. , ateniese , g. , burns , r.c . : remote data checking for network coding - based distributed storage systems . in : acm cloud computing security workshop , ccsw 2010 .",
    "( 2010 ) 3142    chen , f. , xiang , t. , yang , y. , chow , s.s.m .",
    ": secure cloud storage meets with secure network coding . in : ieee conference on computer communications , infocom 2014 .",
    "( 2014 ) 673681    chen , f. , xiang , t. , yang , y. , chow , s.s.m . :",
    "secure cloud storage meets with secure network coding .",
    "transactions on computers * 65*(6 ) ( 2016 ) 19361948    curtmola , r. , khan , o. , burns , r.c . ,",
    "ateniese , g. : : multiple - replica provable data possession . in : ieee international conference on distributed computing systems , icdcs 2008 .",
    "( 2008 ) 411420    dimakis , a.g . ,",
    "godfrey , b. , wu , y. , wainwright , m.j . , ramchandran , k. : network coding for distributed storage systems .",
    "transactions on information theory * 56*(9 ) ( 2010 ) 45394551    dodis , y. , vadhan , s.p . ,",
    "wichs , d. : proofs of retrievability via hardness amplification . in : theory of cryptography conference , tcc 2009 .",
    "( 2009 ) 109127    erway , c.c .",
    ", kp , a. , papamanthou , c. , tamassia , r. : dynamic provable data possession . in",
    ": acm conference on computer and communications security , ccs 2009 .",
    "( 2009 ) 213222    erway , c.c . ,",
    "kp , a. , papamanthou , c. , tamassia , r. : dynamic provable data possession .",
    "transactions on information and system security * 17*(4 ) ( 2015 )  15    esiner , e. , kp , a. , zkasap , . : analysis and optimization on flexdpdp : a practical solution for dynamic provable data possession . in : intelligent cloud computing - first international conference , icc 2014 .",
    "( 2014 ) 6583    foundation , t.a.s .",
    ": apache hadoop ( june 2016 )    galbraith , s.d . ,",
    "paterson , k.g . , smart , n.p . : pairings for cryptographers .",
    "discrete applied mathematics * 156*(16 ) (",
    "september 2008 ) 31133121    gennaro , r. , katz , j. , krawczyk , h. , rabin , t. : secure network coding over the integers . in : public key cryptography - pkc 2010 .",
    "( 2010 ) 142160    goodrich , m.t . , tamassia , r. , schwerin , a. : implementation of an authenticated dictionary with skip lists and commutative hashing . in : darpa information survivability conference and exposition ( discex ) ii .",
    "( 2001 ) 6882    ho , t. , koetter , r. , mdard , m. , karger , d.r . , effros , m. : the benefits of coding over routing in a randomized setting . in : ieee international symposium on information theory - isit 2003 .",
    "( 2003 ) 442    ho , t. , mdard , m. , koetter , r. , karger , d.r . , effros , m. , shi , j. , leong , b. : a random linear network coding approach to multicast .",
    "transactions on information theory * 52*(10 ) ( 2006 ) 44134430    ishai , y. , kushilevitz , e. , ostrovsky , r. , sahai , a. : cryptography from anonymity . in : ieee symposium on foundations of computer science - focs 2006 .",
    "( 2006 ) 239248    juels , a. , kaliski , jr .",
    ": s : proofs of retrievability for large files . in : acm conference on computer and communications security , ccs 2007 .",
    "( 2007 ) 584597    krohn , m.n . ,",
    "freedman , m.j . ,",
    "mazires , d. : on - the - fly verification of rateless erasure codes for efficient content distribution . in :",
    "ieee symposium on security and privacy - s&p 2004 .",
    "( 2004 ) 226240    kp , a. : official arbitration with secure cloud storage application . the computer journal * 58*(4 ) ( 2015 ) 831852    laurie , b. , langley , a. , kasper , e. : certificate transparency ( june 2013 )    le , a. , markopoulou , a. : -audit : auditing for network coding storage . in : international symposium on network coding ,",
    "netcod 2012 .",
    "( 2012 ) 155160    li , s.r . ,",
    "yeung , r.w . ,",
    "cai , n. : linear network coding .",
    "transactions on information theory * 49*(2 ) ( 2003 ) 371381    macwilliams , f.j . , sloane , n.j.a .",
    ": the theory of error - correcting codes .",
    "north - holland publishing company ( 1977 )    merkle , r.c . : a digital signature based on a conventional encryption function .",
    "in : advances in cryptology - crypto 1987 .",
    "( 1987 ) 369378    mller , b. : algorithms for multi - exponentiation . in : selected areas in cryptography - sac 2001 .",
    "( 2001 ) 165180    naor , m. , rothblum , g.n . :",
    "the complexity of online memory checking .",
    "journal of the acm * 56*(1 ) ( february 2009 ) 2:12:46    omote , k. , phuong , t.t .",
    ": : dynamic operations and direct repair in network coding - based proof of retrievability . in : computing and combinatorics - 21st international conference , cocoon 2015 .",
    "( 2015 ) 713730    papamanthou , c. , tamassia , r. , triandopoulos , n. : authenticated hash tables . in : acm conference on computer and communications security , ccs 2008 .",
    "( 2008 ) 437448    pugh , w. : skip lists : a probabilistic alternative to balanced trees .",
    "communications of the acm * 33*(6 ) ( 1990 ) 668676    reed , i.s . ,",
    "solomon , g. : polynomial codes over certain finite fields .",
    "journal of the society for industrial and applied mathematics * 8*(2 ) ( 1960 ) 300304    ryan , m.d . : enhanced certificate transparency and end - to - end encrypted mail . in : 21st annual network and distributed system security symposium - ndss 2014 .",
    "( 2014 )    sengupta , b. , ruj , s. : publicly verifiable secure cloud storage for dynamic data using secure network coding . in :",
    "acm asia conference on computer and communications security , asiaccs 2016 .",
    "( 2016 ) 107118    shacham , h. , waters , b. : compact proofs of retrievability . journal of cryptology * 26*(3 ) ( 2013 ) 442483    shi , e. , stefanov , e. , papamanthou , c. : practical dynamic proofs of retrievability . in : acm conference on computer and communications security , ccs 2013 .",
    "( 2013 ) 325336    stefanov , e. , van dijk , m. , juels , a. , oprea , a. : iris : a scalable cloud file system with efficient integrity checks . in :",
    "annual computer security applications conference , acsac 2012 .",
    "( 2012 ) 229238    wang , b. , chow , s.s.m .",
    ", li , m. , li , h. : storing shared data on the cloud via security - mediator . in : international conference on distributed computing systems , icdcs 2013 .",
    "( 2013 ) 124133    wang , c. , chow , s.s.m .",
    ", wang , q. , ren , k. , lou , w. : privacy - preserving public auditing for secure cloud storage . transactions on computers * 62*(2 ) ( 2013 ) 362375    wang , q. , wang , c. , ren , k. , lou , w. , li , j. : enabling public auditability and data dynamics for storage security in cloud computing . transactions on parallel and distributed systems * 22*(5 ) ( 2011 ) 847859",
    "chen et al .  @xcite propose a generic construction of a secure cloud storage protocol for static data from a secure network coding protocol .",
    "they consider the data file @xmath14 to be stored in the server to be a collection of @xmath15 vectors ( or packets ) each of which consists of @xmath17 blocks .",
    "the underlying idea is to store these vectors ( without augmenting them with unit vectors ) along with their authentication tags in the server . during an audit",
    ", the client sends an @xmath27-element subset of the set of indices @xmath78 to the server .",
    "the server augments those vectors with the corresponding unit vectors , combines them linearly in an authenticated fashion and sends the output vector along with its tag to the client . finally , the client verifies the authenticity of the received tag against the received vector .",
    "thus , the server acts as an intermediate node , and the client acts as both the sender and the receiver ( or the next intermediate router ) .",
    "we briefly discuss the procedures involved in the general construction below .",
    "* @xmath346 : initially , the client executes @xmath347 to generate a secret key - public key pair @xmath37 . * @xmath348 : the file @xmath14 associated with a random file identifier ` fid ` consists of @xmath15 vectors each of them having @xmath17 blocks .",
    "we assume that each of these blocks is an element of @xmath10 .",
    "then , for each @xmath145 , the @xmath22-th vector @xmath146 is of the form @xmath147\\in\\f^n$ ] . for each vector @xmath146 , the client forms @xmath20\\in\\f^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "let @xmath24 be the linear subspace spanned by @xmath25 .",
    "the client runs @xmath349 to produce an authentication tag @xmath51 for the @xmath22-th vector @xmath82 for each @xmath145 .",
    "finally , the client uploads the file @xmath153 to the server .",
    "* @xmath350 : during an audit , the verifier selects @xmath79 , a random @xmath27-element subset of @xmath80 $ ] .",
    "then , she generates a challenge set @xmath178 , where each @xmath351 .",
    "the verifier sends the challenge set @xmath72 to the server . *",
    "@xmath352 : upon receiving the challenge set @xmath178 for the file identifier ` fid ` , the cloud server , for each @xmath183 , forms @xmath20\\in\\f^{n+m}$ ] by augmenting the vector @xmath146 with the unit coefficient vector @xmath21 .",
    "then , the cloud server runs @xmath353 to produce another vector @xmath30 ( along with its authentication tag @xmath40 ) such that @xmath354 .",
    "let @xmath355 be the first @xmath17 entries of @xmath188 .",
    "the server sends @xmath194 to the verifier as a proof of storage corresponding to the challenge set @xmath72 . *",
    "@xmath356 : the verifier uses @xmath178 and @xmath194 to reconstruct the vector @xmath30 , where the first @xmath17 entries of @xmath188 are the same as those of @xmath196 and the @xmath197-th entry is @xmath198 if @xmath183 ( 0 if @xmath199 ) .",
    "the verifier runs @xmath357 and returns the output of the procedure snc.verify .",
    "erway et al .  @xcite propose two efficient and fully dynamic provable data possession schemes : dpdp i ( based on rank - based authenticated skip lists ) and dpdp ii ( based on rank - based rsa trees ) .",
    "we consider only the dpdp i scheme here .",
    "let there be a key generation procedure keygen that produces a public key @xmath358 , where @xmath137 is a product of two large primes and @xmath359 is an element of @xmath298 with large order .",
    "suppose the initial data file consists of @xmath274 segments @xmath360 . for each segment @xmath361 , the client computes a tag @xmath362 .",
    "now , the client builds a rank - based authenticated skip list @xmath363 on the tags of the segments and uploads the data , tags and the skip list to the cloud server .",
    "the insertion , deletion and modification operations are performed in a similar fashion as discussed in section  [ ppa_scheme ] .",
    "there is no secret key involved in the dpdp i scheme . although erway et al .",
    "do not claim explicitly the public verifiability of the dpdp i scheme , we observe that the scheme can be made publicly verifiable by simply making the metadata @xmath286 of the up - to - date skip list and the value @xmath274 public ( see the footnote in section  [ scs ] ) .    during an audit",
    ", the verifier selects @xmath79 , a random @xmath27-element subset of @xmath364 , and generates a challenge set @xmath178 , where each @xmath198 is a random value .",
    "the verifier sends the challenge set @xmath72 to the server .",
    "the server computes an aggregated segment @xmath365 and sends @xmath366 , @xmath367 and proofs @xmath368 ( see section  [ skip_list ] ) to the verifier .",
    "the verifier computes @xmath369 .",
    "finally , the verifier accepts the proof if and only if the following two conditions hold : @xmath108 is a valid proof for each @xmath183 and @xmath370 .",
    "the secure cloud storage scheme for dynamic data discussed in section  [ ppa_scheme ] offers privacy - preserving audits where a third party auditor ( tpa ) can not learn about the actual data while auditing .",
    "let us investigate whether the dpdp i scheme provides this facility .    as in the original scheme ( see appendix  [ dpdpi ] )",
    ", the server sends the aggregated segment @xmath365 to the verifier ( or tpa ) where @xmath371 .",
    "now , a tpa can obtain the @xmath372 values by solving a system of linear equations .",
    "therefore , the audits in the original scheme are not privacy - preserving .",
    "however , it is not hard to make these audits privacy - preserving .",
    "we modify the procedures involved in an audit as follows . as before , the verifier sends the challenge set @xmath178 to the server .",
    "the server computes an aggregated segment @xmath365 .",
    "now , the server chooses a random value @xmath102 , and it computes @xmath373 and @xmath374 .",
    "the server sends @xmath366 , @xmath375 , @xmath376 and proofs @xmath368 to the verifier .",
    "the verifier computes @xmath377 .",
    "finally , the verifier accepts the proof if and only if the following two conditions hold : @xmath108 is a valid proof for each @xmath183 and @xmath378 .    as discussed in appendix  [ dpdpi ] , in order to make the scheme publicly verifiable , the client includes the pair @xmath301 in her public key and updates it after every authenticated update on the outsourced data .",
    "the modified dpdp i scheme satisfies the authenticity and freshness properties as described in section  [ security_dscsi ] ( this directly follows from the same guarantees provided by the original dpdp i ) . given a probabilistic polynomial - time adversary @xmath3 that wins the data possession game with some non - negligible probability , there exists a polynomial - time extractor algorithm @xmath202 for the original dpdp i which can extract the challenged vectors ( except with negligible probability ) by interacting with @xmath3 .",
    "now , the extractor algorithm @xmath379 for the modified dpdp i challenges the adversary with two different challenge sets @xmath178 and @xmath380 on the same commitment @xmath102 , where each @xmath198 ( or @xmath381 ) is a random value .",
    "then , @xmath379 gets two responses of the form @xmath382 and @xmath383 , and the extractor now forms another @xmath384 where @xmath385 for each @xmath183 .",
    "we note that @xmath384 is similar to a response from the adversary in the original dpdp i scheme described in appendix  [ dpdpi ] .",
    "thus , @xmath379 can extract ( at least ) the challenged vectors in a similar fashion as done by @xmath202 .",
    "we observe that the tpa does not have an access to the value of @xmath367 . to get the value of @xmath367",
    ", the tpa has to solve either @xmath367 from @xmath386 , or @xmath102 from @xmath374 , both of which are infeasible for any probabilistic polynomial - time adversary @xmath3 , except with some probability negligible in @xmath0 .",
    "thus , the audits are privacy - preserving in this modified scheme ."
  ],
  "abstract_text": [
    "<S> in the age of cloud computing , cloud users with a limited amount of storage can outsource their data to remote servers . </S>",
    "<S> the cloud servers , in lieu of monetary benefits , offer retrievability of their clients data at any point of time . </S>",
    "<S> secure cloud storage protocols ensure the integrity of the outsourced data that can be dynamic ( or static ) in nature depending on whether the client can ( or can not ) update the uploaded data as needed . in this work , </S>",
    "<S> we explore the possibility of constructing a secure cloud storage for dynamic data by leveraging the idea of secure network coding . </S>",
    "<S> specifically , we fail to provide a general construction of an _ efficient _ secure cloud storage protocol for dynamic data from an arbitrary secure network coding protocol . </S>",
    "<S> however , we show that some of the secure network coding schemes with some properties can be used to construct secure cloud storage protocols for dynamic data , and we indeed construct a publicly verifiable secure cloud storage protocol based on a secure network coding protocol . to the best of our knowledge , </S>",
    "<S> our scheme is the first secure cloud storage protocol for dynamic data that is based on a secure network coding protocol and that is secure in the standard model .    in a publicly verifiable setting </S>",
    "<S> , auditing task is often delegated to a third party auditor that audits the outsourced data on behalf of a client . </S>",
    "<S> it is desirable that the auditor gains no knowledge about the actual content of the client s data which may be sensitive . </S>",
    "<S> we extend our scheme in order to provide privacy - preserving audits where the content of the client s data is protected from the third party auditor . </S>",
    "<S> furthermore , we extend our scheme in order to offer anonymity of a user updating shared data in an enterprise setting . in this </S>",
    "<S> setting , the cloud server can not distinguish the user ( belonging to a group ) updating the data shared among the users of that group . </S>",
    "<S> we compare the performance of our secure cloud storage protocol with that of other secure cloud storage schemes and discuss some limitations of our scheme . </S>",
    "<S> finally , we provide another construction of a secure cloud storage protocol that is specialized for append - only data and that overcomes some of the limitations of our earlier scheme . </S>"
  ]
}