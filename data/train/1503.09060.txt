{
  "article_text": [
    "the @xmath0-calculus can be called the _ smallest universal programming language in the world_. the @xmath0-calculus consists of a single transformation rule ( variable substitution , also called @xmath1-conversion ) and a single function definition scheme .",
    "it was introduced in the 1930s by alonzo church as a way of formalizing the concept of effective computability .",
    "the @xmath0-calculus is universal in the sense that any computable function can be expressed and evaluated using this formalism .",
    "it is thus equivalent to turing machines .",
    "however , the @xmath0-calculus emphasizes the use of symbolic transformation rules and does not care about the actual machine implementation .",
    "it is an approach more related to software than to hardware .",
    "the central concept in @xmath0-calculus is that of `` expression '' .",
    "a `` name '' is an identifier which , for our purposes , can be any of the letters @xmath2 , etc .",
    "an expression can be just a name or can be a function .",
    "functions use the greek letter @xmath0 to mark the name of the function s arguments .",
    "the `` body '' of the function specifies how the arguments are to be rearranged .",
    "the identity function , for example , is represented by the string @xmath3 .",
    "the fragment `` @xmath4 '' tell us that the function s argument is @xmath5 , which is returned unchanged as `` @xmath5 '' by the function .",
    "functions can be applied to other functions .",
    "the function a , for example , applied to the function b , would be written as ab . in this tutorial ,",
    "capital letters are used to represent functions .",
    "in fact , anything of interest in @xmath0-calculus is a function . even numbers or logical values will be represented by functions that can act on one another in order to transform a string of symbols into another string .",
    "there are no types in @xmath0-calculus : any function can act on any other .",
    "the programmer is responsible for keeping the computations sensible .",
    "an expression is defined recursively as follows : @xmath6    an expression can be surrounded by parenthesis for clarity , that is , if e is an expression , ( e ) is the same expression .",
    "otherwise , the only keywords used in the language are @xmath0 and the dot . in order to avoid cluttering expressions with parenthesis",
    ", we adopt the convention that function application associates from the left , that is , the composite expression @xmath7 is evaluated applying the successive expressions as follows @xmath8 as can be seen from the definition of @xmath0-expressions , a well - formed example of a function is the previously mentioned string , enclosed or not in parentheses : @xmath9 we use the equivalence symbol `` @xmath10 '' to indicate that when @xmath11 , @xmath12 is just a synonym for @xmath13 . as explained above , the name right after the @xmath0 is the identifier of the argument of this function .",
    "the expression after the point ( in this case a single @xmath5 ) is called the `` body '' of the function s definition .",
    "functions can be applied to expressions .",
    "a simple example of an application is @xmath14 this is the identity function applied to the variable @xmath15 .",
    "parenthesis help to avoid ambiguity .",
    "function applications are evaluated by substituting the `` value '' of the argument @xmath5 ( in this case the @xmath15 being processed ) in the body of the function definition .",
    "[ fig1 ] shows how the variable @xmath15 is `` absorbed '' by the function ( red line ) , and also shows where it is used as a replacement for @xmath5 ( green line ) .",
    "the result is a reduction , represented by the right arrow , with the final result @xmath15 .    ,",
    "title=\"fig:\",width=151],title=\"fig:\",width=151 ]    since we can not always have pictures , as in fig .",
    "[ fig1 ] , the notation @xmath16 $ ] is used to indicate that all occurrences of @xmath5 are substituted by @xmath15 in the function s body .",
    "we write , for example , @xmath17x \\rightarrow y$ ] .",
    "the names of the arguments in function definitions do not carry any meaning by themselves .",
    "they are just `` place holders '' , that is , they are used to indicate how to rearrange the arguments of the function when it is evaluated .",
    "therefore all the strings below represent the same function : @xmath18 this kind of purely alphabetical substitution is also called @xmath19-reduction .      if we only had pictures of the plumbing of @xmath0-expressions , we would not have to care about the names of variables .",
    "since we are using letters as symbols , we have to be careful if we repeat them , as shown in this section .    in @xmath0-calculus",
    "all names are local to definitions ( like in most programming languages ) . in the function",
    "@xmath20 we say that @xmath5 is `` bound '' since its occurrence in the body of the definition is preceded by @xmath4 .",
    "a name not preceded by a @xmath0 is called a `` free variable '' . in the expression",
    "@xmath21 the @xmath5 in the body of the first expression from the left is bound to the first @xmath0 .",
    "the @xmath15 in the body of the second expression is bound to the second @xmath0 , and the following @xmath5 is free .",
    "bound variables are shown in bold face .",
    "it is very important to notice that this @xmath5 in the second expression is totally independent of the @xmath5 in the first expression .",
    "this can be more easily seen if we draw the `` plumbing '' of the function application and the consequent reduction , as shown in fig .",
    "[ fig2 ] .    ,",
    "width=264 ]    in fig .",
    "[ fig2 ] we see how the symbolic expression ( first row ) can be interpreted as a kind of circuit , where the bound argument is moved to a new position inside the body of the function .",
    "the first function ( the identity function ) `` consumes '' the second one .",
    "the symbol @xmath5 in the second function has no connections with the rest of the expression , it is floating free inside the function definition .",
    "formally , we say that a variable @xmath22name@xmath23 is free in an expression if one of the following three cases holds :    * @xmath22name@xmath23 is free in @xmath22name@xmath23 .",
    "+ ( example : @xmath24 is free in @xmath24 ) .",
    "* @xmath22name@xmath23 is free in @xmath0@xmath22name@xmath25 . @xmath22exp@xmath23 if the identifier @xmath22name@xmath26@xmath22name@xmath25 and @xmath22name@xmath23 is free in @xmath22exp@xmath23 .",
    "+ ( example : @xmath15 is free in @xmath27 ) .",
    "* @xmath22name@xmath23 is free in @xmath28 if @xmath22name@xmath23 is free in @xmath29 or if it is free in @xmath30 .",
    "+ ( example : @xmath5 is free in @xmath31 ) .",
    "a variable @xmath22name@xmath23 is bound if one of two cases holds :    * @xmath22name@xmath23 is bound in @xmath0 @xmath22name@xmath25 . @xmath22exp@xmath23 if the identifier @xmath22name@xmath32@xmath22name@xmath25 or if @xmath22name@xmath23 is bound in @xmath22exp@xmath23 .",
    "+ ( example : @xmath5 is bound in @xmath33 ) .",
    "* @xmath22name@xmath23 is bound in @xmath28 if @xmath22name@xmath23 is bound in @xmath29 or if it is bound in @xmath30 .",
    "+ ( example : @xmath5 is bound in @xmath34 .",
    "it should be emphasized that the same identifier can occur free and bound in the same expression . in the expression @xmath35 the first @xmath15 is free in the parenthesized subexpression to the left , but it is bound in the subexpression to the right .",
    "therefore , it occurs free as well as bound in the whole expression ( the bound variables are shown in bold face ) .      the more confusing part of standard @xmath0-calculus , when first approaching it , is the fact that we do not give names to functions .",
    "any time we want to apply a function , we just write the complete function s definition and then proceed to evaluate it . to simplify the notation , however , we will use capital letters , digits and other symbols ( san serif ) as synonyms for some functions . the identity function , for example , can be denoted by the letter i , using it as shorthand for @xmath3 .",
    "the identity function applied to itself is the application @xmath36 in this expression , the first @xmath5 in the body of the first function in parenthesis is independent of the @xmath5 in the body of the second function ( remember that the `` plumbing '' is local ) .",
    "just to emphasize the difference we can in fact rewrite the above expression as @xmath37 the identity function applied to itself @xmath38 yields therefore @xmath39x\\rightarrow\\lambda z.z \\equiv{\\sf i},\\ ] ] that is , the identity function again .",
    ", width=377 ]    when performing substitutions , we should be careful to avoid mixing up free occurrences of an identifier with bound ones . in the expression @xmath40",
    "the function on the left contains a bound @xmath15 , whereas the @xmath15 on the right is free .",
    "an incorrect substitution would mix the two identifiers in the erroneous result @xmath41 simply by renaming the bound @xmath15 to @xmath42 we obtain @xmath43 which is a completely different result but nevertheless the correct one .",
    "therefore , if the function @xmath44 is applied to @xmath45 , we substitute all _ free _ occurrences of @xmath5 in @xmath46 with @xmath45 . if the substitution would bring a free variable of @xmath45 in an expression where this variable occurs bound , we rename the bound variable before performing the substitution . for example , in the expression @xmath47 we associate the first @xmath5 with @xmath15 . in the body",
    "@xmath48 only the first @xmath5 is free and can be substituted . before substituting though",
    ", we have to rename the variable @xmath15 to avoid mixing its bound with its free occurrence : @xmath49\\left(\\lambda t.(x(\\lambda x.xt))\\right ) \\rightarrow \\left(\\lambda t(y(\\lambda x.xt))\\right)\\ ] ] in normal order reduction we reduce always the left most expression of a series of applications first . we continue until no further reductions are possible .",
    "a programming language should be capable of specifying arithmetical calculations .",
    "numbers can be represented in the @xmath0-calculus starting from zero and writing `` successor of zero '' , that is `` suc(zero ) '' , to represent 1 , `` suc(suc(zero ) ) '' to represent 2 , and so on . since in @xmath0-calculus",
    "we can only define new functions , numbers will be defined as functions using the following approach : zero can be defined as @xmath50 this is a function of two arguments @xmath51 and @xmath52 .",
    "we will abbreviate such expressions with more than one argument as @xmath53 it is understood here that @xmath51 is the first argument to be substituted during the evaluation and @xmath52 the second . using this notation , the first natural numbers can be defined as @xmath54 and so on .",
    "the big advantage of defining numbers in this way is that we can now apply a function @xmath55 to an argument @xmath24 any number of times .",
    "for example , if we want to apply @xmath55 to @xmath24 three times we apply the function 3 to the arguments @xmath55 and @xmath24 yielding : @xmath56 this way of defining numbers provides us with a language construct similar to an instruction such as `` for i=1 to 3 '' in other languages .",
    "the number zero applied to the arguments @xmath55 and @xmath24 yields @xmath57 .",
    "that is , applying the function @xmath55 to the argument @xmath24 _ zero times _ leaves the argument @xmath24 unchanged .",
    "our first interesting function , after having defined the natural numbers , is the successor function .",
    "this can be defined as @xmath58 the definition looks awkward but it works .",
    "for example , the successor function applied to our representation for zero is the expression : @xmath59 in the body of the first expression we substitute the occurrence of @xmath60 with @xmath61 and this produces the reduced expression : @xmath62 that is , the result is the representation of the number 1 ( remember that bound variable names are `` dummies '' and can be changed ) .",
    "successor applied to 1 yields : @xmath63 notice that the only purpose of applying the number @xmath64 to the arguments @xmath24 and @xmath65 is to `` rename '' the variables used internally in the definition of our number .",
    "addition can be obtained immediately by noting that the body @xmath66 of our definition of the number 1 , for example , can be interpreted as the application of the function @xmath51 on @xmath52 .",
    "if we want to add say 2 and 3 , we just apply the successor function two times to 3 .",
    "let us try the following in order to compute 2 + 3 : @xmath67    in general @xmath68 plus @xmath60 can be computed by the expression @xmath69 .",
    "the multiplication of two numbers @xmath5 and @xmath15 can be computed using the following function : @xmath70 the product of 3 by 3 is then @xmath71 which reduces to @xmath72 using the definition of the number 3 , we further reduce the above expression to @xmath73 in order to understand why this function really computes the product of 3 by 3 , let us look at some diagrams . the first application @xmath74 is computed on the left of fig .",
    "[ mult1 ] .",
    "notice that the application of @xmath75 to @xmath24 has the effect of producing a new function which applies @xmath24 three times to the function s argument .",
    "produces a new function .",
    "right : the plumbing of the function 3 applied to 3a , and the result to @xmath65.[mult1],width=491 ]    now , applying the function @xmath75 to the result of @xmath74 produces three copies of the function obtained in fig .",
    "[ mult1 ] , concatenated as shown on the right in fig .",
    "[ mult1 ] ( where the result has been applied to @xmath65 for clarity ) .",
    "notice that we have a `` tower '' of three times the same function , each one absorbing the lower one as argument for the application of the function @xmath24 three times , for a total of nine applications .",
    "we introduce the following two functions which we call the values `` true '' @xmath76 and `` false ''",
    "@xmath77 the first function takes two arguments and returns the first one .",
    "the second function returns the second of two arguments .",
    "it is now possible to define logical operations using this representation of the truth values .",
    "the and function of two arguments can be defined as @xmath78 this definition works because given that @xmath5 is true , the truth value of the and operation depends on the truth value of @xmath15 . if @xmath5 is false ( and selects thus the second argument in @xmath79 ) the complete and is false , regardless of the value of @xmath15 .    the or function of two arguments can be defined as @xmath80 here , if @xmath5 is true , the or is true . if @xmath5 is false , it picks the second argument @xmath15 and the value of the or function depends now on the value of @xmath15 .",
    "negation of one argument can be defined as @xmath81    for example , the negation function applied to `` true '' is @xmath82 which reduces to @xmath83 that is , the truth value `` false '' .",
    "armed with this three logic functions we can encode any other logic function and reproduce any given circuit without feedback ( we look at feedback when we deal with recursion ) .",
    "it is very convenient in a programming language to have a function which is true if a number is zero and false otherwise .",
    "the following function z fulfills this role : @xmath84 to understand how this function works , remember that @xmath85 that is , the function @xmath55 applied zero times to the argument @xmath24 yields @xmath24 . on the other hand",
    ", @xmath86 applied to any argument yields the identity function @xmath87 we can now test if the function z works correctly .",
    "the function applied to zero yields @xmath88 because f applied 0 times to @xmath89 yields @xmath89 .",
    "the function z applied to any other number n yields @xmath90 the function f is then applied n times to @xmath89 . but f applied to anything is the identity ( as shown before ) , so that the above expression reduces , for any number n greater than zero , to @xmath91      we can now define the predecessor function combining some of the functions introduced above .",
    "when looking for the predecessor of @xmath60 , the general strategy will be to create a pair @xmath92 and then pick the second element of the pair as the result .",
    "a pair @xmath93 can be represented in @xmath0-calculus using the function @xmath94 we can extract the first element of the pair from the expression applying this function to t @xmath95 and the second applying the function to f @xmath96 the following function generates from the pair @xmath92 ( which is the argument @xmath97 in the function ) the pair @xmath98 : @xmath99 the subexpression @xmath100 extracts the first element from the pair @xmath97 .",
    "a new pair is formed using this element , which is incremented for the first position of the new pair and just copied for the second position of the new pair .",
    "the predecessor of a number @xmath60 is obtained by applying @xmath60 times the function @xmath101 to the pair @xmath102 and then selecting the second member of the new pair : @xmath103 notice that using this approach the predecessor of zero is zero .",
    "this property is useful for the definition of other functions .      with the predecessor function as the building block",
    ", we can now define a function which tests if a number @xmath5 is greater than or equal to a number @xmath15 : @xmath104 if the predecessor function applied @xmath5 times to @xmath15 yields zero , then it is true that @xmath105 .    if @xmath105 and @xmath106 , then @xmath107 .",
    "this leads to the following definition of the function e which tests if two numbers are equal : @xmath108 in a similar manner we can define functions to test whether @xmath109 , @xmath110 or @xmath111 .",
    "recursive functions can be defined in the @xmath0-calculus using a function which calls a function @xmath15 and then regenerates itself .",
    "this can be better understood by considering the following function y : @xmath112 this function applied to a function r yields : @xmath113 which further reduced yields @xmath114 but this means that @xmath115 , that is , the function r is evaluated using the recursive call yr as the first argument .",
    "an infinite loop , for example , can be programmed as yi , since this reduces to i(yi ) , then to yi and so ad infinitum .",
    "a more useful function is one which adds the first @xmath60 natural numbers .",
    "we can use a recursive definition , since @xmath116 .",
    "let us use the following definition for r : @xmath117 this definition tells us that the number @xmath60 is tested : if it is zero the result of the sum is zero",
    ". in @xmath60 is not zero , then the successor function is applied @xmath60 times to the recursive call ( the argument @xmath118 ) of the function applied to the predecessor of @xmath60 .    how do we know that @xmath118 in the expression above is the recursive call to r , since functions in @xmath0-calculus do not have names ?",
    "we do not know and that is precisely why we have to use the recursion operator y. assume for example that we want to add the numbers from 0 to 3 .",
    "the necessary operations are performed by the call : @xmath119 since 3 is not equal to zero , the evaluation is equivalent to @xmath120 that is , the sum of the numbers from 0 to 3 is equal to 3 plus the sum of the numbers from 0 to the predecessor of 3 ( that is , two ) .",
    "successive recursive evaluations of yr will lead to the correct final result .",
    "notice that in the function defined above the recursion will be stopped when the argument becomes 0 .",
    "the final result will be @xmath121 that is , the number 6 .",
    "1 .   define the functions `` less than '' and `` greater than '' of two numerical arguments . 2 .",
    "define the positive and negative integers using pairs of natural numbers .",
    "define addition and subtraction of integers .",
    "4 .   define the division of positive integers recursively .",
    "define the function @xmath122 recursively .",
    "define the rational numbers as pairs of integers .",
    "define functions for the addition , subtraction , multiplication and division of rationals .",
    "define a data structure to represent a list of numbers .",
    "define a function which extracts the first element from a list .",
    "define a recursive function which counts the number of elements in a list .",
    "can you simulate a turing machine using @xmath0-calculus ?",
    "x p.m. kogge , _ the architecture of symbolic computers _ , mcgraw - hill , new york 1991 , chapter 4 .",
    "g.  michaelson , _ an introduction to functional programming through @xmath0-calculus _ , addison - wesley , wokingham , 1988 .",
    "g. revesz , _ lambda - calculus combinators and functional programming _ , cambridge university press , cambridge , 1988 , chapters 1 - 3 ."
  ],
  "abstract_text": [
    "<S> this paper is a concise and painless introduction to the @xmath0-calculus . </S>",
    "<S> this formalism was developed by alonzo church as a tool for studying the mathematical properties of effectively computable functions . </S>",
    "<S> the formalism became popular and has provided a strong theoretical foundation for the family of functional programming languages . </S>",
    "<S> this tutorial shows how to perform arithmetical and logical computations using the @xmath0-calculus and how to define recursive functions , even though @xmath0-calculus functions are unnamed and thus can not refer explicitly to themselves . </S>"
  ]
}