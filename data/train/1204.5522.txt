{
  "article_text": [
    "large - scale , high - resolution computer simulations dominate many areas of theoretical and computational science .",
    "the demand for such simulations has expanded steadily over the past decade , and is likely to continue to grow in coming years due to the increase in the volume , precision , and dynamic range of experimental data , as well as the widening spectral coverage of observations and laboratory experiments .",
    "simulations are often used to mine and understand large observational and experimental datasets , and the quality of these simulations must keep pace with the increasingly high quality of experimental data .    in our own specialized discipline of computational astrophysics ,",
    "numerical simulations have increased dramatically in both scope and scale over the past four decades . in the 1970s and 1980s , large - scale astrophysical simulations",
    "generally incorporated `` mono - physics '' solutions  in our case , the sub - disciplines of stellar evolution @xcite , gas dynamics @xcite , and gravitational dynamics @xcite .",
    "a decade later , it became common to study phenomena combining a few different physics solvers @xcite . today",
    "s simulation environments incorporate multiple physical domains , and their nominal dynamic range often exceeds the standard numerical precision of available compilers and hardware @xcite .",
    "recent developments in hardware  in particular the rapidly increasing availability of multi - core architectures  have led to a surge in computer performance @xcite . with the volume and quality of experimental data continuously improving , simulations expanding in scope and scale , and raw computational speed growing more rapidly than ever before",
    ", one might expect commensurate returns in the scientific results returned .",
    "however , a major bottleneck in modern computer modeling lies in the software , the growing complexity of which is evident in the increase in the number of code lines , the lengthening lists of input parameters , the number of underlying ( and often undocumented ) assumptions , and the expanding range of initial and boundary conditions .",
    "simulation environments have grown substantially in recent years by incorporating more detailed interactions among constituent systems , resulting in the need to incorporate very different physical solvers into the simulations , but the fundamental design of the underlying codes has remained largely unchanged since the introduction of object - oriented programming @xcite and patterns @xcite . as a result , maintaining and extending existing large - scale , multi - physics solvers has become a major undertaking .",
    "the legacy of design choices made long ago can hamper further development and expansion of a code , prevent scaling on large parallel computers , and render maintenance almost impossible .",
    "even configuring , compiling , and running such a code has become a complex endeavor , not for the faint of heart .",
    "it has become increasingly difficult to reproduce simulation results , and independent code verification and validation are rarely performed , even though all researchers agree that computer experiments require the same degree of reproducibility as is customary in laboratory settings .",
    "we suggest that the root cause of much of this code complexity lies in the traditional approach to incorporating multi - physics components into a simulation  namely , solving the equations appropriate to all components in a single monolithic software suite , often written by a single researcher or research group .",
    "such a solution may seem desirable from the standpoint of consistency and performance , but the resulting software generally suffers from all of the fundamental problems just described . in addition , integration of new components often requires sweeping redesign and redevelopment of the code . writing a general multi - physics application from scratch is a major undertaking , and the stringent requirements of high - quality , fault - tolerant scientific simulation software render such code development by a single author almost impossible .",
    "but why reinvent or re - engineer a monolithic suite of coupled mono - physics solvers when well - tested applications already exist to perform many or all of the necessary individual tasks ?",
    "in many scientific communities there is a rich tradition of sharing scientific software .",
    "many of these programs have been written by experts who have spent careers developing these codes and using them to conduct a wide range of numerical experiments .",
    "these packages are generally developed and maintained independently of one another .",
    "we refer to them collectively as `` community '' software .",
    "the term is intended to encompass both `` legacy '' codes that are still maintained but are no longer under active development , and new codes still under development to address physical problems of current interest .",
    "together , community codes represent an invaluable , if incoherent , resource for computational science .",
    "coupling community codes raises new issues not found in monolithic applications . aside from the wide range of physical processes , underlying equations , and numerical solvers",
    "they represent , these independent codes generally also employ a wide variety of units , input and output methods , file formats , numerical assumptions , and boundary conditions .",
    "their originality and independence are strengths , but the lack of uniformity can also significantly reduce the `` shelf life '' of the software . in addition , directly coupling the very dissimilar algorithms and data representations used in different community codes can be a difficult task  almost as complex as rewriting the codes themselves .",
    "but whatever the internal workings of the codes , they are designed to represent a given domain of physics , and different codes may ( and do in practice ) implement alternate descriptions of the same physical processes .",
    "this suggests that integrating community codes should be possible using interfaces based on physical principles .",
    "in this paper we present a comprehensive solution to many of the problems mentioned above , in the form of a software framework that combines remote function calls with physically based interfaces , and implements an object oriented data model , automatic conversion of units , and a state handling model for the component solvers , including error recovery mechanisms .",
    "communication between the various solvers is realized via a centralized message passing framework , under the overall control of a high - level user interface . in ",
    "[ sect : framework ] , we name our framework muse , the multi - physics software environment .",
    "an example of the muse framework is presented in ",
    "[ sect : example ] . in ",
    "[ sect : advancedmuse ] we describe a production implementation of amuse , the astrophysics muse environment , which supports a wide range of programming languages and physical environments .",
    "the basic concepts of muse are rooted in the earliest development of multi - scale software in computational astrophysics .",
    "the idea of combining codes within a flexible framework began with the nemo project in 1986 at the institute for advanced study ( ias ) in princeton @xcite .",
    "nemo was ( and still is ) aimed primarily at collisionless galactic dynamics .",
    "it used a uniform file structure to communicate data among its component programs .",
    "the starlab package @xcite , begun in 1993 ( again at ias ) , adopted the nemo toolbox approach , but used pipes instead of files for communication among modules .",
    "the goal of the project was to combine dynamics and stellar and binary evolution for studies of collisional systems , such as star clusters .",
    "the stellar / binary evolution code seba was combined with a high - performance gravitational stellar dynamics simulator .",
    "because of the heterogeneous nature of the data , not all tools were aware of all data types ( for example , the stellar evolution tools generally had no inherent knowledge of large - scale gravitational dynamics ) .",
    "as a result , the package used an xml - like tagged data format to ensure that no information was lost in the production pipeline ",
    "unknown particle data were simply passed unchanged from input to output .    the intellectual parent of ( a)muse is the modest initiative , begun in 2002 at a workshop at the american museum of natural history in new york . the goal of that workshop was to formalize some of the ideas of modular software frameworks then circulating in the community into a coherent system for simulating dense stellar systems .",
    "originally , modest stood for modeling dense stellar systems ( star clusters and galactic nuclei ) .",
    "the name was later expanded , at the suggestion of giampolo piotto ( padova ) to modeling and observing dense stellar systems .",
    "the modest web page can be found at http://www.manybody.org/modest . since then , modest has gone on to provide a lively and long - lived forum for discussion of many topics in astrophysics .",
    "( a)muse is in many ways the software component of the modest community .",
    "an early example of muse - like code can be found in the proceedings of the modest-1 meeting @xcite .",
    "subsequent modest meetings discussed many new ideas for modular multiphysics applications ( e.g. * ? ? ? * ) .",
    "the basic muse architecture , as described in this paper , was conceived during the 2005 modest-6a workshop in lund ( sweden , * ? ? ?",
    "the muse name , and the first lines of muse code , were created during modest-6e in amsterdam in 2006 , and expanded upon over the next 12 years .",
    "the `` noah s ark '' milestone ( meeting our initial goal of having two independent modules for solving each particular type of physics ) was realized in 2007 , during modest-7f in amsterdam and modest-7a in split ( croatia * ? ? ?",
    "the amuse project , short for for astrophysics multi - purpose software environment , a re - engineered version of muse``muse 2.0 , '' building on the lessons learned during the previous 3 years  began at leiden observatory in 2009 .",
    "each of the problems discussed in  [ sect : introduction ] could in principle be addressed by designing an entirely new suite of programs from scratch .",
    "however , this idealized approach fails to capitalize on the existing strengths of the field by ignoring the wealth of highly capable scientific software that has been developed over the last four or five decades .",
    "we will argue that it is more practical , and considerably easier , to introduce a generalized interface that connects existing solvers to a homogeneous and easily extensible framework .    at first sight",
    ", the approach of assimilating existing software into a larger framework would appear to be a difficult undertaking , particularly since community software may be written in a wide variety of languages , such as fortran , c , and c++ , and exhibits an enormous diversity of internal units and data structures . on the other hand , such a framework ,",
    "if properly designed , could be relatively easy to use , since learning one simulation package is considerably easier than mastering the idiosyncrasies of many separate programs .",
    "the use of standard calling procedures can enable even novice researchers quickly to become acquainted with the environment , and to perform relatively complicated simulations using it .",
    "to this end , we propose the multi - physics software environment , or muse . within muse ,",
    "a user writes a relatively simple script with a standardized calling sequence to each of the underlying community codes .",
    "instructions are communicated through a message - passing interface to any of a number of spawned community modules , which respond by performing operations and transferring data back through the interface to the user script .    as illustrated in fig.[fig : muse_structure ] , the two top - level components of muse :    * the _ user script _ , which implements a specific physical problem or set of problems , in the form of system - provided or user - written scripts that serve as the user interface onto the muse framework .",
    "the coupling between community codes is implemented in this layer , with the help of support classes provided by the _ manager_. * the _ community module _ , comprising three key elements : 1 .",
    "the _ manager _ , which provides an object - oriented interface onto the _ communication _ layer via a suite of system - provided utility functions .",
    "this layer handles unit conversion , as discussed below , and also contains the state engine and the associated data repository , both of which are required to guarantee consistency of data across modules .",
    "the role of this layer is generic  it is not specific to any particular problem or to any single physical domain . in ",
    "[ sect : implementation ] we discuss an actual implementation of the _ manager _ for astrophysical problems . 2 .   the _ communication _ layer , which realizes the bi - directional communication between the _ manager _ and the community code layer .",
    "this is implemented via a proxy and an associated partner , which together provide the connection to the community code .",
    "3 .   the _ community code _ layer , which contains the actual community codes and implements control and data management operations on them . each piece of code in this layer is domain - specific , although the code may be designed to be very general within its particular physical domain .",
    "we have adopted as the implementation language for the muse framework and high - level management functions , including the bindings to the communication interface . this choice is motivated by s broad acceptance in the scientific community , its object oriented design , and its ability to allow rapid prototyping , which shortens the software development cycle and enables easy access to the community code in the community module , albeit at the cost of slightly reduced performance . however , the entire muse framework is organized in such a way that relatively little computer time is actually spent in the framework itself , as most time is spent in the community code .",
    "the overhead from compared to a compiled high - level language is @xmath0% , and often much less ( see  [ sect : discussion ] ) .    as discussed further in ",
    "[ sect : communication ] , our implementation of the communication layer in muse uses the standard message passing interface protocol @xcite , although we also have an operational implementation using smartsockets @xcite via the ibis framework @xcite ( see @xcite for an actual implementation ) .",
    "normally mpi is used for communication between compute nodes on parallel distributed - memory systems . however , here it is used as the communication channel between _ all _ processes , whether or not they reside on the same node as the control script , and whether or not they are themselves parallel .",
    "the proxy side of the message - passing framework in the communication layer is implemented in , but the partner side is normally written in the language used in the community code .",
    "thus our only real restriction on supported languages is the requirement that the community code is written in a language with standard mpi bindings , such as c , c++ , or a member of the fortran family .",
    "the community module consists of the actual community code and the bi - directional communication layer enabling low - level mpi communication between the proxy and the partner .",
    "each community module contains a class of functions dedicated to communication with the community code .",
    "direct use of this low - level class from within a user script is not trivial , because it requires considerable replication of code dealing with data models , unit conversion , and exception handling , and is discouraged .",
    "instead , the muse framework provides the manager layer above the community module layer to manage the bookkeeping needed to maintain the interface with the low - level class .",
    "community applications may be programmed in any computer language that has bindings to the mpi protocol . in practice , these codes exhibit a wide variety of structural properties , model diverse physical domains , and span broad ranges of temporal and spatial scales . in our astrophysical",
    "amuse implementation ( see  [ sect : implementation ] ) , this diversity is exemplified by a suite of community programs ranging from toy codes to production - quality high - precision dedicated solvers .",
    "a user script can be developed quickly using toy codes until the production and data analysis pipelines are fully developed , then easily switched to production quality implementations of the physical solvers for actual large - scale simulations .    in principle , each of the community modules can be used stand alone , but the main strength of muse is in the coupling between them .",
    "many of the codes incorporated in our practical implementation are not written by us , but are publicly available and are amply described in the literature .",
    "bi - directional communication between a running community process and the manager can in principle be realized using any protocol for remote interprocess communication . our main reasons for choosing mpi are similar to those for adopting widespread acceptance in the computational science community and broad support in many programming languages and on most computing platforms .",
    "the communication layer consists of two main parts , a proxy on the manager side of the framework and a partner on the community code side .",
    "the proxy converts commands into mpi messages , transmits them to the partner , then waits for a response .",
    "the partner waits for and decodes mpi messages from the proxy into community code commands , executes them , then sends a reply .",
    "the mpi interface allows the user script and community modules to operate asynchronously and independently . as a practical matter , the detailed coding , decoding , and communications operations in the proxy and the partner are never hand - coded .",
    "rather , they are automatically generated as part of the muse build process , from a high - level description of the community module interface .",
    "we note that other solutions to linking high - level languages within exist  e.g . swig and f2py , and in fact both were used in earlier implementations of the muse framework @xcite .",
    "however , despite their generality , these solutions can not maintain name space independence between community modules , and in addition are incapable of accommodating high - performance parallel community codes .",
    "for these reasons , we have abandoned the standard solutions in favor of our customized , high - performance mpi alternative .",
    "the use of mpi may seem like overkill in the case of serial operation on a single computing node ( as might well be the case ) , but it imposes negligible overhead , and even here it offers significant practical advantages .",
    "it rigorously separates all community processes in memory , guaranteeing that multiple instances of a community module are independent and explicitly avoiding name space conflicts .",
    "it also ensures that the framework remains thread - safe when using older community codes that may not have been written with that concept in mind .    despite the initial threshold for its implementation and use",
    ", the relative simplicity of the message - passing framework allows us to easily couple multiple independent community codes as community modules , or multiple copies of the same community module , if desired ( see fig.[fig : muse_structure ] ) .",
    "an example of the latter might be to simulate simultaneously two separate objects of the same type , or the same physics on different scales , or with different boundary conditions , without having to modify the data structures in the community code .    as a bonus",
    ", the framework naturally accommodates inherently parallel community modules and allows simultaneous execution of independent modules from the user script .",
    "individual community modules can be offloaded to other processors , in a cluster or on the grid , and can be run concurrently without requiring any changes in the user script .",
    "this makes the muse framework well suited for distributed computing with a wide diversity of hardware architectures ( see  [ sect : discussion ] ) .      between the user script and the communication layer",
    "we introduce the manager , part of the community module .",
    "this part of the code is visible to the script - writing user and guarantees that all accessible data are up to date , have the proper format , and are expressed in the correct units .",
    "the manager layer constructs data models ( such as particle sets or tessellated grids ) on top of all functions in the low - level communication class and checks the error codes they return . to allow different modules to work in their preferred systems of units ,",
    "the manager incorporates a unit transformation protocol ( see  [ sect : intermoduletransfer ] ) .",
    "it also includes a state engine to ensure that functions are called in a controlled way , as many community codes are written with specific assumptions about calling procedures .",
    "in addition , a data repository is introduced to guarantee that at least one self - consistent copy of the simulation data always exists at any given time .",
    "this repository can be structured in one or more native formats , such as particles , grids , tessellation , etc , depending on the topology of the data adopted in the community code .",
    "each community code has its own internal data , needed for modeling operations but not routinely exposed to the user script .",
    "however , some of these data may be needed by other parts of the framework . to share data effectively , and to minimize the bookkeeping required to manage data coherency , the most fundamental parts of the community data are replicated in the structured repository in the manager .",
    "the internal data structures differ , but the repository imposes a standard format .",
    "the repository allows the user to access community module data from the user script without having to make individual ( and often idiosyncratic ) calls to individual community modules .",
    "the repository is updated from the community module on demand , and is considered to be authoritative within the script .",
    "the separation of the manager from the community module realizes a flexibility that allows the user to swap modules and recompute the same problem using different physics solvers , providing an independent check of the implementation , validation of the model , and verification of the results , simply by rerunning the same initial state using another community module .",
    "potentially even more interesting is the possibility of solving some parts of a problem with one solver and others with a different solver of the same type , combining the results at a later stage to complete the solution . while studying the general behavior of a simulation , perhaps to test a hypothesis or guide our physical intuition",
    ", we may elect to use computationally cheaper physics solvers , then switch to more robust , but computationally more expensive , modules in a production run .",
    "alternatively , we might choose adopt less accurate solvers for physical domains that are not deemed crucial to capturing the correct overall behavior .",
    "another advantage of separating of the manager from the community module is the possibility of combining existing community modules into new community modules which can themselves be coupled via the manager , building a hierarchical environment for simulating complex physical systems with multiple components .",
    "the muse framework is controlled by the user via scripts ( see  [ sect : example ] and  [ sect : implementation ] ) .",
    "the main tasks of these scripts are to identify and spawn community modules , control their calling sequences , and manage the data flow among them .",
    "the user script and the spawned community code are connected by a communication channel embedded in the community module and maintained by the manager . since the community modules do not communicate directly with one another , the only communication channels are between modules and the user script .",
    "the number of community modules controlled by a user script is effectively unlimited , and multiple instances of identical modules can be spawned .",
    "the main objective of the user script is to read in or generate an input model , process these initial conditions through one or more simulation modules , and subsequently mine and analyze the resultant data . in practice",
    "the user script will itself be composed of a series of scripts , each performing one specific functionality .",
    "computer scientists tend to attribute types to parameters and variables , and generally impose strict rules for the conversion from one type to another . in physics ,",
    "data types are almost never important , but units are crucial for validating and checking the consistency of a calculation or simulation . the lack of coherent unit handling in programming environments is notorious , and can cause significant problems in multi - physics simulations , particularly for inexperienced researchers",
    ".    in many cases , a researcher can define a set of dimensionless variables applicable to a specific simulation , within the confines of a set of rather strict assumptions . for a mono - physics simulation ,",
    "the consistent use of such variables is generally clear to most users .",
    "however , as soon as an expert from another field attempts to interpret the results , or when the output of one simulation is used by another program , units must be restored and the data converted to another physical system for further processing and interpretation .",
    "the absence of units in scientific software raises two important problems .",
    "the first is the loss of an independent consistency check for theoretical calculations .",
    "the second is the expert knowledge and intuition required to manage dimensionless variables or otherwise unfamiliar units .",
    "few would recognize @xmath1 as the radius of the sun in units of the planck length , even though it is not completely inconceivable that an astronomer might use such units in a simulation . to address these issues",
    ", muse incorporates a unit - conversion module as part of the manager ( see  [ sect : manager ] ) to guarantee that all communications within the top - level user script are performed in the proper units . in order to prevent unit checking and conversion from becoming a performance bottleneck ,",
    "we adopt lazy evaluation , performing unit conversion only when explicitly required .",
    "the above description of muse is somewhat abstract . here",
    "we present a simple example  the calculation of the orbital period of a binary star in a circular orbit .",
    "this is a straightforward astrophysical calculation that serves to illustrate the basic operation of the framework .",
    "the community code that calculates the orbital period is presented in fig.[source : community.c ] .",
    "# include `` community.h '' # include `` math.h ''    int orbital_period(double orbital_separation , double total_mass , double * orbital_period ) if ( total_mass < = 0.0 ) return -1 ; * orbital_period = sqrt(pow(orbital_separation , 3.)/total_mass ) ; return 0 ;    [ 8 ]    the partner requires the definitions of all interface functions in the community code , which are included from the community.h header file , presented in fig.[source : community.h ] .",
    "( note that , as mentioned earlier , in a practical implementation the communication code is actually machine generated .",
    "the code here is hand - written , for purposes of exposition . )",
    "int orbital_period(double orbital_separation , double total_mass , double * orbital_period ) ;    the user script that initializes the required parameters ( orbital separation , total mass of the binary ) and computes the orbital period is presented in fig.[source : script.py ] .",
    "because of the simplicity of this example we do not include unit conversion here ; we tacitly assume that the total binary mass is in units of the mass of the sun , and the orbital separation in astronomical units ; the average orbital separation of earth around the sun . the output orbital period is expressed in years .",
    "this example illustrates how a set of units can be convenient within the implicit choices of a community code , but counterintuitive for researchers from other disciplines .",
    "calls to the community code are initiated by the user script , sent to the proxy , received by the partner , and executed by the community code .",
    "the interaction between these muse components is illustrated in fig.[fig : amuse_message_passing ] .",
    "import proxy from optparse import optionparser    def new_option_parser ( ) : arguments = optionparser ( ) arguments.add_option(``-a '' , dest=``a'',type=``float'',default=1.0 ) arguments.add_option(``-m '' , dest=``m'',type=``float'',default=1.0 ) return arguments    def main(a=1.0 , m=1.0 ) : community_code = proxy.codeproxy ( ) print `` orbital period : '' , community_code.orbital_period(a , m ) , `` years '' community_code.stop ( )    if _ _ name _ _ = = __main__ : arguments , options = new_option_parser().parse_args ( ) main(**arguments.__dict _ _ )    the class takes care of setting up the community code , encoding the arguments , sending the message , and decoding the results . in an actual muse",
    "implementation the proxy is split into two parts , one to translate the arguments into a generic message object ( and translate the returned message into return parameters ) , and one to send the message using the communication library ( mpi ) .",
    "the source code listing in fig.[source : proxy.py ] presents a working example of a proxy .    from mpi4py import mpi import numpy    class codeproxy(object ) : def _ _ init__(self ) : self.intercomm = mpi.comm_self.spawn(./community_code )    def send_function_id(self , function_id ) : self.intercomm.send([function_id , mpi.character ] , tag=997 )    def send_arguments(self , arguments ) : self.intercomm.send([arguments , mpi.double ] , tag=998 )    def recv_error_message(self ) : errorcode_array = numpy.empty(1 , dtype=int32 ) self.intercomm.recv([errorcode_array , mpi.int ] , tag = 999 ) errorcode = errorcode_array[0 ]    if errorcode = = -1000 : raise exception(``unknown function i d received by partner '' ) elif errorcode < 0 : raise exception(``partner , errorcode is 0''.format(errorcode ) )    def recv_answer(self , number_of_answers = 1 ) : answer_array = numpy.empty(number_of_answers , dtype=float64 ) self.intercomm.recv([answer_array , mpi.double ] , tag = 996 ) return answer_array    def orbital_period(self , orbital_separation , total_mass ) : arguments = numpy.array([orbital_separation , total_mass ] ) self.send_function_id(p ) self.send_arguments(arguments ) self.recv_error_message ( ) answer = self.recv_answer(1 ) return answer[0 ]    def stop(self ) : self.send_function_id(q ) self.recv_error_message ( ) self.intercomm.disconnect ( )    [ 8 ]    messages sent via mpi are received by the partner code , which decodes them and executes the actual function calls in the community code .",
    "subsequently it encodes and returns the results in a message to the proxy .",
    "the partner code is generally written in the same language as the community code , in this case c++ . in the source code",
    "listing in fig.[source : partner.c ] we present a working example of a partner .",
    "fig.[fig : amuse_message_passing ] and",
    "the associated source listing fig.[source : partner.c ] might seem at first glance to be a rather complicated way to perform some rather simple message passing .",
    "however , this procedure allows us to encapsulate existing code , rendering it largely independent of the rest of the framework , allowing the implementation of parallel internal architecture , and opening the possibility of launching a particular application on a remote computer .",
    "also , if one of these encapsulated codes stops prematurely , the framework remains operational , and simply detects the unscheduled termination of a particular application .",
    "a complete crash of one of the community modules , however , will likely still cause the framework to break .",
    "# include `` community.h '' # include `` mpi.h '' # include < mpi.h >    void event_loop ( )    mpi::intercomm intercomm = mpi::comm_world.get_parent ( ) ; int rank = mpi::comm_world.get_rank ( ) ; bool continue_run = true ;    while ( continue_run )    char function_id ; int errorcode = 0 ; intercomm.recv(&function_id , 1 , mpi::character , 0 , 997 ) ;    switch ( function_id ) case p : double args[2 ] ; double answer ; intercomm.recv(args , 2 , mpi::double , 0 , 998 ) ; errorcode = orbital_period(args[0 ] , args[1 ] , & answer ) ; if ( rank = = 0 ) intercomm.send(&errorcode , 1 , mpi::int , 0 , 999 ) ; if(errorcode = = 0 ) intercomm.send(&answer , 1 , mpi::double , 0 , 996 ) ; break ; case q : intercomm.send(&errorcode , 1 , mpi::int , 0 , 999 ) ; intercomm.disconnect ( ) ; continue_run = false ; break ; default : errorcode = -1000 ; intercomm.send(&errorcode , 1 , mpi::int , 0 , 999 ) ; break ;    int main(int argc , char * argv [ ] ) mpi::init(argc , argv ) ; event_loop ( ) ; mpi::finalize ( ) ;",
    "the simple example described in  [ sect : example ] does not demonstrate the full potential of a muse framework , and specifically the wide range of possibilities that arise from coupling community codes .",
    "many problems in astrophysics encompass a wide variety of physics . as a practical demonstration of muse ,",
    "we present here an open - source production environment in an astrophysics context , implemented by coupling community codes designed for gravitational dynamics , stellar evolution , hydrodynamics , and radiative transfer , the most common physical domains encountered in astrophysical simulations .",
    "we call this implementation amuse , the astrophysics multiphysics software environment @xcite .",
    "amuse is a complete implementation of muse , with a fully functional interface including automated unit conversion , a structured data repository ( see  [ sect : manager ] ) , multi - stepping via operator splitting ( see  [ sect : bridge ] ) , and ( limited ) ability to recover from fatal errors ( see  [ sect : failurerecovery ] ) .",
    "a wide variety of community codes is available , including multiple modules for each of the core domains listed above , and the framework is currently used in a variety of production simulations .",
    "amuse is designed for use by researchers in many fields of astrophysics , targeted at a wide variety of problems , but it is currently also used for educational purposes , in particular for training msc . and ph.d . students .",
    "the development of a muse sprang from our desire to simulate a multi - physics system within a single conceptual framework . the fundamental design stems from our earlier endeavour in the development of the starlab software environment @xcite in which we combined stellar evolution and gravitational dynamics",
    "the drawback with starlab was rigid coupling between domains , which made the framework inflexible and less applicable than desired to a wider range of practical problems .",
    "the amuse framework provides us with a general solution to the problem , allowing us to hierarchically combine numerical solvers within a single environment to create new and more capable community modules .",
    "examples in amuse include coupling a direct n - body algorithm with a hierarchical tree - code , and combining a smoothed - particle hydrodynamics solver with a larger - scale grid - based hydrodynamics solver .",
    "such dynamic coupling has practical applications in resolving short time scale shocks using a grid - based hydrodynamics solver within a low - resolution smoothed - particles hydrodynamics environment , or in changing the evolutionary prescription of a star at run - time  for example when two stars collide and the standard `` lookup '' description of their evolution must be replaced by `` live '' integration of the merger product .",
    "the validation and verification of coupled solvers remain a delicate issue .",
    "it may well be that the effective strength of the coupling can only be determined at run - time , and it may require a thorough study for each application to identify the range of parameters within which the coupled solver can be applied .",
    "adding new community modules is straightforward .",
    "the environment runs efficiently on a single pc , on multi - core architectures , on supercomputers , and on distributed computers @xcite .",
    "given our experience with amuse , we are confident that it can be relatively easily adapted as the basis for a muse implementation in another research field , coupling a different suite of numerical solvers .",
    "the amuse source code is freely available from the amuse website .",
    "we have applied amuse to a number of interesting problems incorporating stellar evolution and gravitational dynamics @xcite , and to the combination of stellar evolution and the dynamics of stars and gas @xcite .",
    "the former reference provides an explanation for the formation of the binary millisecond pulsar j1903 + 0327 ; the latter explores the consequences of early mass loss from stars in young star clusters by means of stellar winds and supernovae . in fig.[fig : ppz ] we present three - dimensional renderings of several snapshots of the latter calculation .",
    "real - world simulation codes crash .",
    "crashes are inevitable , but restarting and continuing a simulation afterwards can be a very delicate procedure , and there is a fine line between science and nonsense in the resulting data . in many cases catastrophic failure",
    "is caused by numerical instabilities that are either not understood , in which case a researcher would like to study them further , or are part of a natural phenomenon that can not be modeled in sufficient detail by the current community code . recognizing and understanding code failure is a time consuming but essential part of the gritty reality of working with simulation environments .    in many cases ,",
    "simulation codes are developed with the implicit assumption that a user has some level of expert knowledge , in lieu of providing user - friendly error messages , debugging assistance , and exception handling .",
    "however , for a framework like amuse , such an assumption may pose problems for the run - time behavior and stability of the system , as well as being confusing and frustrating for the user .    to some degree",
    ", code fatalities can be handled gracefully by the muse manager .",
    "the failure of a particular community module does not necessarily result in the failure of the entire framework .",
    "as a response , the framework can return a meaningful error message , or , more usefully , continuing the simulation using another community code written for the same problem .",
    "the approach is analogous to fault - tolerant computing , in which a management process detects node failure and redirects the processes running on the failed node .      in the amuse framework",
    "we recognize six distinct strategies for coupling community modules .",
    "some can be programmed easily by hand , although they can be labour intensive , while others are enabled by our implementation of the amuse framework .",
    "the examples presented below are drawn taken from the public version of amuse .    1 input / output coupling",
    ": : :    the loosest type of coupling occurs when the result of code a    generates the initial conditions for code b. for example , a henyey    stellar evolution code might generate mass , density and temperature    profiles for a subsequent 3-dimensional hydrodynamical representation    of a star . 2 one - way coupling",
    ": : :    system a interacts with ( sub)system b , but the back - coupling from b to    a is negligible .",
    "for example , stellar mass loss due to internal    nuclear evolution is often important for the global dynamics of a star    cluster , but the dynamics of the cluster usually does not affect the    evolution of individual stars ( except in the rare case of an physical    stellar collision ) . 3 hierarchical coupling : : :    subsystems a1 and a2 ( and possibly more ) are embedded in parent system    b , which affects their evolution , but the subsystems do not affect the    parent or each other .",
    "for example , the evolution of cometary oort    clouds are strongly influenced by , but are irrelevant to , the larger    galactic potential .",
    "4 serial coupling : : :    a system evolves through distinct regimes which need different codes    a , b , c , etc . , applied subsequently in an interleaved way , to model    them .",
    "for example , a collision between two stars in a dense star    cluster may be resolved using one or more specialized hydrodynamics    solvers , after which the collision product is reinserted into the    gravitational dynamics code .",
    "5 interaction coupling : : :    this type of coupling occurs when there is neither a clear temporal or    spatial separation between systems a and b. for example , in the    interaction between the interstellar medium and the gravitational    dynamics of an embedded star cluster , both the stellar and the gas    dynamics must incorporate the combined gravitational potential of the    gas and the stars .",
    "6 intrinsic coupling : : :    this may occur where the physics of the problem necessitates a solver    that encompasses several types of physics simultaneously , and does not    allow for temporal or spatial separation .",
    "an example is    magnetohydrodynamics , where the gas dynamics and the electrodynamics    are so tightly coupled that they can not be separated .    with the exception of the last",
    ", all types of coupling can be efficiently implemented in amuse using single - component solvers .",
    "many of the coupling strategies are straightforward in amuse , with the exception of the interaction and intrinsic coupling types",
    ". for interaction coupling , the symplectic multi - physics time - stepping approach originally described in @xcite usually works very well . for intricate intrinsic coupled codes",
    "it may still be more efficient to write a monolithic framework in a single language , rather than adopt the method proposed here .",
    "the relative independence of the various community modules in amuse allows us to combine them in the user script by calling them consecutively .",
    "this is adequate for many applications , but in other situations such rigid time stepping is known to have disastrous consequences for the stability of stiff systems , preventing convergence of non - linear phenomena @xcite .    in some circumstances there is no alternative to simply alternating between modules in subsequent time steps .",
    "but in others we can write down the hamiltonian of the combined solution and integrate this iteratively , using robust numerical integration schemes .",
    "this operator splitting approach been demonstrated to work effectively and efficiently by @xcite , who adopted the verlet - leapfrog algorithm to combine two independent gravitational n - body solvers .",
    "it has been incorporated into amuse for resolving interactions between gravitational and hydrodynamical community modules , and is called `` bridge '' after the introducing paper @xcite .",
    "the classical bridge scheme @xcite considers a star cluster orbiting a parent galaxy .",
    "the cluster is integrated using accurate direct summation of the gravitational forces among all stars .",
    "interactions among the stars in the galaxy , and between galactic and cluster stars , are computed using a hierarchical tree force evaluation method @xcite .    in bridge ,",
    "the hamiltonian of the entire system is divided into two parts : @xmath2 where @xmath3 is the potential energy of the gravitational interactions between galaxy particles and the star cluster ( @xmath4 ) : @xmath5 and @xmath6 is the sum of the total kinetic energy of all particles ( @xmath7 ) and the potential energy of the star cluster particles ( @xmath8 ) and the galaxy ( @xmath9 ) @xmath10    the time evolution of any quantity @xmath11 under this hamiltonian can then be written approximately ( because we have truncated the formal solution to just the second - order terms ) as : @xmath12 where the operators @xmath13 and @xmath14 are defined by @xmath15 , @xmath16 , and @xmath17 is a poisson bracket . the evolution operator @xmath18 splits into two independent parts because @xmath6 consists of two parts without cross terms",
    "this is the familiar second - order leapfrog algorithm .",
    "the evolution can be implemented as a kick - drift - kick scheme , as illustrated in fig.[fig : bridge ] .",
    "the performance of the amuse framework depends on the codes used , the problem size , the choice of initial conditions and the interactions among the component parts as defined in the user script .",
    "it is therefore not possible to present a general account of the overhead of the framework , or the timing of the individual modules used .",
    "however , in order to provide some understanding of the time spent in the framework , as opposed to the community modules , we present the results of two independent performance analysis , one using a suite of 9 gravitational n - body solvers ( figs.[fig : museperformance ] and[fig : museoverhead ] ) on three of which we report in more detail in fig.[fig : codeefficiency ] , and analysis of a coupled hydrodynamics and gravitational dynamics solver in several framework solutions ( tab.[tab : timings ] ) .      in fig.[fig : museperformance ] we compare the performance of several n - body solvers in amuse .",
    "some of these solvers are gpu accelerated ( ph4 and bonsai @xcite ) , others run on multiple cores ( fi ) , but most were run on a single processor even though they could have been run in parallel . each calculation was run using standard parameters ( double precision , time step of @xmath19 or an adaptive time step determined by the community code , an opening angle of @xmath20 for tree - codes , and @xmath21 softening length ) .",
    "the initial conditions were selected from a plummer @xcite sphere in n - body units in which all particles had the same mass .",
    "the runs were performed for 10  n - body time units @xcite and include framework overhead and analysis of the data , but not the generation of the initial conditions or spawning the community code .    for small @xmath22 ( @xmath0 ) the performance of all codes saturates , mainly due to the start - up cost of the amuse framework , the construction of a tree for only a few particles , or communication with the gpu ( which is particularly notable for bonsai ) . for large @xmath22 ,",
    "the performance of the direct n - body codes ( dashed curves ) scales @xmath23 .",
    "the wall - clock time of the tree codes ( solid curves ) scale @xmath24 , as expected , but with a rather wide range in start - up time for small n depending on the particulars of the implementation .",
    "the largest offset is measured for bonsai ; because of its relatively large start - up time of 0.2s , its timing remains roughly constant until @xmath25 , after which it performs considerably better than the other ( tree)codes , which have a smaller offset but reach their terminal speed at relatively small @xmath22 .",
    "it is in particular due to the use of the gpu that the start - up times for bonsai ( and also octgrav , not shown ) dominate until quite large @xmath22 , and terminal speed is not reached until @xmath26 .",
    "these codes require large @xmath22 to fully benefit from the massive parallelism of the gpu .    in fig.[fig :",
    "museoverhead ] we present the fraction of the wall clock time ( in fig.[fig : museperformance ] ) spent in the amuse framework .",
    "this figure gives a different perspective from fig.[fig : museperformance ] .",
    "the tree codes perform generally worse in terms of efficiency , mainly because of the relatively small amount of calculation time spent in the n - body engine compared to the much more expensive direct n - body codes ; this is particularly notable in fi and bonsai .",
    "eventually , each code reaches a terminal efficiency , the value of which depends on the details of the implementation .",
    "direct n - body codes tend to converge to an average overhead of @xmath27% of the runtime , whereas tree codes reach something like @xmath28% for the fastest code ( bonsai ) .",
    "the particular shape of the various curves depends on the scaling with @xmath22 of the work done by the community code and the framework .",
    "we can draw a distinction between generating the initial conditions ( @xmath29 ) , starting up the community module ( @xmath30 ) , committing the particle data to the code ( @xmath29 ) , analyzing the data , and the actual work done in the community code .",
    "the scaling with @xmath22 of these last two tasks depends on the implementation  @xmath31 for the direct codes and @xmath32 for the tree codes .    in fig.[fig :",
    "codeefficiency ] we present a break down of the wall - clock times for three quite different community codes , but otherwise identical amuse scripts : the barnes - hut tree code bonsai , and the direct code ph4 with and without gpu support .",
    "we separated the costs for running the community code , committing data to the code , and data analysis ; the last two we call the framework overhead .",
    "note that , in practice , the computationally intensive parts of the analysis calculations are performed by the modules , and not by the python framework .",
    "therefore , the measurements of the framework overhead presented in fig.[fig : codeefficiency ] should be considered as upper limits .",
    "we ignored the cost for start - up ( spawning the community code ) and generating the initial conditions , because these are generally performed only once per run , even though they may have a time complexity similar to the underlying community code . for short runs with few particles",
    "these costs may be substantial , but for production simulations they result in negligible overhead .",
    "the tree code ( top panel in fig.[fig : codeefficiency ] ) has @xmath33 time complexity ( see fig.[fig : museperformance ] ) whereas analysis has an @xmath22 dependency . for small @xmath22 the framework cost may be quite substantial , but for larger simulations",
    "these costs become negligible ( @xmath34% ) . in the limit of large @xmath22 , committing the particles has a time complexity similar to a tree code , but with a much smaller coefficient . for bonsai , committing the particles limits the efficiency of the community code to about 99.6% .",
    "the direct n - body code ( bottom panel in fig.[fig : codeefficiency ] ) has @xmath35 time complexity ( see fig.[fig : museperformance ] ) and running large @xmath22 in the framework is even more favorable in terms of efficiency than running a tree code .",
    "the analysis and commit parts still have the same scaling with @xmath22 , and for large @xmath22 less than 1% of the wall - clock time is spent in the framework .",
    "the difference between the gpu and cpu versions of the direct code is most evident in committing the data to the code , which is relatively slow for the gpu enabled code , and particularly severe for small @xmath22 .",
    "one of the main advantages of amuse is the possibility of running different codes concurrently , with interactions among them , as discussed in  [ sect : bridge ] . to explore the additional overhead generated in such cases , we present in tab.[tab : timings ] timings for a series of simulations combining gravitational dynamics and hydrodynamics .",
    "the timings listed in the table are determined using three different codes : the treesph code fi , the direct gravitational n - body code phigpu @xcite , and an analytic static background potential ( identified as `` field '' in the top row of the table ) .",
    "the treesph code is implemented in fortran90 , the direct gravitational @xmath22-body code is in fortran77 , and the analytic tidal field is implemented in .",
    "the simulations were performed for n stars , each of one solar mass , in a cluster with a plummer @xcite initial density profile and a characteristic radius of 1pc .",
    "we simulated the orbits of cluster stars within a cloud of gas having 9 times as much mass as in stars , and the same initial density distribution .",
    "the gas content was simulated using 10 @xmath22 gas particles . to treat the direct gravitational n - body solver phigpu in the same way as the tree - code fi for solving the inter - particle gravity",
    ", we adopted a softening length of 0.01pc for the stars . when employing fi as an sph code we adopted a smoothing length of 0.05pc for the gas particles .",
    "the n - body time step was 0.01n - body time units @xcite , and the interactions between the stellar- and fluid - dynamical codes were resolved using a bridge time step of 0.125n - body time units ( see  [ sect : bridge ] , but for more details about the simulation see @xcite ) .",
    "the first column in tab.[tab : timings ] gives the number of stars in the simulation .",
    "subsequent columns give the fraction of the wall - clock time spent in the amuse framework relative to the time spend in the two production codes . in the second column",
    ", we used fi for the stars as well as for the gas particles .",
    "no bridge was used in this case ; rather , the stars were implemented as `` massive dark particles '' in the sph code . for the simulations presented in the third column we used bridge to couple the massive dark particles and the sph particles , but both the gas dynamics and the gravitational stellar dynamics",
    "were again calculated using fi as a gravitational tree - code . not surprisingly , the amuse overhead using bridge is larger than when all calculations are performed entirely within fi ( compare the second and third columns in tab.[tab : timings ] ) , but for @xmath36 , the overhead in amuse becomes negligible .",
    "for @xmath37 the simulation lasted 769.1s when using only fi , whereas when we adopted bridge the wall - clock time was 897.7s . in production simulations",
    "the number of particles will generally greatly exceed 1000 , and we consider the additional cost associated with the flexibility of using bridge time well spent .",
    ".[tab : timings ] relative timing measurements of amuse in various configurations .",
    "the first column gives the number of star particles used in the simulations .",
    "subsequent columns give the fraction of time spent in the amuse interface , rather than in the module(s ) .",
    "the relative timings in the second columns are performed using fi as a stand alone module for both the gravity and the sph inside amuse . for the other simulations we adopted a bridge ( see  [ sect : bridge ] )",
    "interface using two codes , for which we adopted fi , phigpu , and a simple analytic tidal potential ( field ) . [ cols=\"^,>,^,^,^,^,^,^,^,^,^,^ \" , ]     for small @xmath22 ( @xmath38 ) , a considerable fraction ( up to 83% ) of the wall - clock time is spent in the amuse framework .",
    "this fraction is high , particularly for the combination of phigpu and the analytic field , because of the small wall - clock time ( less than 10 seconds ) of these simulations .",
    "the complexity of both codes , @xmath31 for phigpu and @xmath29 for the analytic external field introduces a relatively large overhead in the layer compared to the gravity solver , in particular since the gravitational interactions are calculated using a graphical processing unit , which for a relatively small number of particles introduces a rather severe communication bottleneck .",
    "this combination of unfavorable circumstances cause even the @xmath39 runs with phigpu and the tidal field to spend more than 50% of the total wall - clock time in the amuse framework .",
    "however , we do not consider this a serious drawback , since such calculations are generally only performed for test purposes . in this case",
    "it demonstrates that amuse has a range of parameters within which it is efficient , but that there is also a regime for which amuse does not provide optimal performance .",
    "we have described muse , a general software framework incorporating a broad palette of domain - specific solvers , within which scientists can perform detailed simulations combining different component solvers , within which scientists can perform detailed simulations using different component solvers , and amuse , an astrophysical implementation of the concept .",
    "the design goal of the environment is that it be easy to learn and use , and enable combinations and comparisons of different numerical solvers without the need to make major changes in the underlying codes .",
    "one of the hardest , and only partly solved , problems in ( a)muse is a general way to convert data structures from one type to another . in some cases",
    "such conversion can be realized by simply changing the units , or reorganizing a grid , but in more complex cases , for example , converting particle distributions to a tessellated grid , and vice versa , the solution is less clear .",
    "standard procedures exist for some such conversions , but it is generally not guaranteed that the solution in unique .",
    "some drawbacks of realizing the inter - community module communication using mpi are the relatively slow response of spawning processes , the limited flexibility of the communication interface , and the replication of large data sets in multiple realizations of the same community module . although it is straightforward to spawn multiple instances of the same code , these processes do not ( by design ) share data storage , aside from the data repository in the manager . for codes that require large data storage , for example look - up tables for opacities or other common physical constants ,",
    "the data are reproduced as many times as the process is spawned .",
    "this limitation may be overcome by the use of shared data structures on multi - core machines , or by allowing inter - community module communication via `` tunneling , '' where data moves directly between community modules , rather than being channeled through the manager .",
    "the programming environment is not known for speed , although this is generally not a problem in amuse , since little time is spent in the user script and the underlying codes are highly optimized , allowing good overall performance .",
    "typical monolithic software environments lose performance by unnecessary calls among domains ; in muse this is prevented by the loose coupling between community modules .",
    "we have experimented with a range of possible ways to couple the various community modules , and can roughly quantify the degree to which community modules are coupled .",
    "muse , as described here , is best suited for problems in which the different physical solvers are relatively weakly coupled . weak and strong coupling may be distinguished by the ratio of the time intervals on which different community modules are called ( see also  [ sect : advancedmuse ] ) . for time step ratios",
    "@xmath40 , the amuse implementation gives excellent performance , but if the ratio approaches unity the muse approach becomes progressively more expensive .",
    "it is , however , not clear to what extent a monolithic solver will give better performance in these strongly coupled cases .",
    "the upshot is that there is a range of problems for which our implementation works well , but there are surely other interesting multi - physics problems in astrophysics and elsewhere for which this separation in scales is not optimal .",
    "however , we have experimented with more strongly coupled community modules , and have not yet found it to be a limiting factor in the system design .",
    "we are grateful to jeroen bdorf , niels drost , michiko fujii , evghenii gaburov , stefan harfst , piet hut , masaki iwasawa , jun makino , maarten van meersbergen , and alf whitehead for useful discussions and for contributing their codes .",
    "spz and smcm thank sverre aarseth and peter eggleton for their discussion at iau symposium 246 on the possible assimilation of each other s production software , which started us thinking seriously about ( a)muse . this work was supported by nwo ( grants vici [ # 639.073.803 ] , amuse [ # 614.061.608 ] and lgm [ # 612.071.503 ] ) , nova and the lkbf in the netherlands , and by nsf grant ast-0708299 and nasa nnx07ag95 g in the u.s ."
  ],
  "abstract_text": [
    "<S> we introduce a general - purpose framework for interconnecting scientific simulation programs using a homogeneous , unified interface . </S>",
    "<S> our framework is intrinsically parallel , and conveniently separates all component numerical modules in memory . </S>",
    "<S> this strict separation allows automatic unit conversion , distributed execution of modules on different cores within a cluster or grid , and orderly recovery from errors . </S>",
    "<S> the framework can be efficiently implemented and incurs an acceptable overhead . in practice </S>",
    "<S> , we measure the time spent in the framework to be less than 1% of the wall - clock time . </S>",
    "<S> due to the unified structure of the interface , incorporating multiple modules addressing the same physics in different ways is relatively straightforward . </S>",
    "<S> different modules may be advanced serially or in parallel . despite initial concerns , </S>",
    "<S> we have encountered relatively few problems with this strict separation between modules , and the results of our simulations are consistent with earlier results using more traditional monolithic approaches . </S>",
    "<S> this framework provides a platform to combine existing simulation codes or develop new physical solver codes within a rich `` ecosystem '' of interchangeable modules .    </S>",
    "<S> computer applications : physical sciences and engineering : astronomy ; computing methodologies : simulation , modeling , and visualization : distributed computing </S>"
  ]
}