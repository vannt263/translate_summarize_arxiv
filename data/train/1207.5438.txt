{
  "article_text": [
    "key establishment protocols are one of the most important cryptographic primitives that have been used in our society . the first unauthenticated key agreement protocol based on asymmetric cryptographic techniques were proposed by diffie and hellman @xcite . since this seminal result ,",
    "many authenticated key agreement protocols have been proposed and the security properties of key agreement protocols have been extensively studied . in order to implement these authenticated key agreement protocols , one needs to get the corresponding party s authenticated public key .",
    "for example , in order for alice and bob to execute the nist recommended mqv key agreement protocol @xcite , alice needs to get an authenticated public key @xmath0 for bob and bob needs to get an authenticated public key @xmath1 for alice first , where @xmath2 and @xmath3 are alice and bob s private keys respectively .",
    "one potential approach for implementing these schemes is to deploy a public key infrastructure ( pki ) system , which has proven to be difficult .",
    "thus it is preferred to design easy to deploy authenticated key agreement systems .",
    "identity based key agreement system is such an example .    in 1984 , shamir @xcite proposed identity based cryptosystems where user s identities ( such as email address , phone numbers , office locations , etc . )",
    "could be used as the public keys .",
    "several identity based key agreement protocols ( see , e.g. , @xcite ) have been proposed since then .",
    "most of them are not practical or do not have all required security properties .",
    "joux @xcite proposed a one - round tripartite non - identity based key agreement protocol using weil pairing .",
    "then feasible identity based encryption schemes based on weil or tate paring were introduced by sakai , ohgishi , and kasahara @xcite and later by boneh and franklin @xcite independently .",
    "based on weil and tate pairing techniques , smart @xcite , chen - kudla @xcite , scott @xcite , shim @xcite , and mccullagh - barreto @xcite designed identity based and authenticated key agreement protocols .",
    "chen - kudla @xcite showed that smart s protocol is not secure in several aspects .",
    "cheng et al .",
    "@xcite pointed out that chen - kudla s protocol is not secure againt unknown key share attacks .",
    "scott s protocol is not secure against man in the middle attacks .",
    "sun and hsieh @xcite showed that shim s protocol is insecure against key compromise impersonation attacks or man in the middle attacks .",
    "choo @xcite showed that mccullagh and barreto s protocol is insecure against key revealing attacks .",
    "mccullagh and barreto @xcite revised their protocol .",
    "but the revised protocol does not achieve weak perfect forward secrecy property . in this paper",
    ", we propose an efficient identity based and authenticated key agreement protocol achieving all security properties that an authenticated key agreement protocol should have .",
    "the advantage of identity based key agreement is that non - pki system is required .",
    "the only prerequisite for executing identity based key agreement protocols is the deployment of authenticated system - wide parameters .",
    "thus , it is easy to implement these protocols in relatively closed environments such as government organizations and commercial entities .",
    "the remainder of this paper is organized as follows . in  [ bilinear ]",
    "we briefly describe bilinear maps , bilinear diffie - hellman problem , and its variants . in  [ idakprotocol ] , we describe our identity based and authenticated key agreement protocol idak .  [ securitymodel ] describes a security model for identity based key agreement . in section  [ securityproof ] , we prove the security of idak key agreement protocol . in sections  [ pfsidak ] and  [ kcridak ] , we discuss key compromise impersonation resilience and perfect forward secrecy properties of idak key agreement protocol .",
    "in the following , we briefly describe the bilinear maps and bilinear map groups . the details could be found in joux @xcite and boneh and franklin @xcite .",
    "1 .   @xmath4 and @xmath5 are two ( multiplicative ) cyclic groups of prime order @xmath6 .",
    "2 .   @xmath7 is a generator of @xmath4 .",
    "3 .   @xmath8 is a bilinear map .",
    "a bilinear map is a map @xmath8 with the following properties :    1 .",
    "bilinear : for all @xmath9 , and @xmath10 , we have @xmath11 .",
    "non - degenerate : @xmath12 .",
    "we say that @xmath4 is a bilinear group if the group action in @xmath4 can be computed efficiently and there exists a group @xmath5 and an efficiently computable bilinear map @xmath8 as above .",
    "concrete examples of bilinear groups are given in @xcite .",
    "for convenience , throughout the paper , we view both @xmath4 and @xmath5 as multiplicative groups though the concrete implementation of @xmath4 could be additive elliptic curve groups .    throughout the paper _ efficient _",
    "means probabilistic polynomial - time , _ negligible _ refers to a function @xmath13 which is smaller than @xmath14 for all @xmath15 and sufficiently large @xmath16 , and _ overwhelming _ refers to a function @xmath17 for some negligible @xmath13 .",
    "consequently , a function @xmath18 is _ non - negligible _ if there exists a constant @xmath19 and there are infinitely many @xmath16 such that @xmath20 .",
    "we first formally define the notion of a bilinear group family and computational indistinguishable distributions ( some of our terminologies are adapted from boneh @xcite ) .",
    "* bilinear group families * a _ bilinear group family _ @xmath21 is a set @xmath22 of bilinear groups @xmath23 where",
    "@xmath24 ranges over an infinite index set , @xmath4 and @xmath5 are two groups of prime order @xmath25 , and @xmath26 is a bilinear map .",
    "we denote by @xmath27 the length of the binary representation of @xmath24 .",
    "we assume that group and bilinear operations in @xmath23 are efficient in @xmath27 .",
    "unless specified otherwise , we will abuse our notations by using @xmath6 as the group order instead of @xmath25 in the remaining part of this paper .",
    "* instance generator * an _ instance generator _ , @xmath28 , for a bilinear group family @xmath21 is a randomized algorithm that given an integer @xmath16 ( in unary , that is , @xmath29 ) , runs in polynomial - time in @xmath16 and outputs some random index @xmath24 for @xmath23 , and a generator @xmath7 of @xmath4 , where @xmath4 and @xmath5 are groups of prime order @xmath6 .",
    "note that for each @xmath16 , the instance generator induces a distribution on the set of indices @xmath24 .",
    "the following bilinear diffie - hellman assumption ( bdh ) has been used by boneh and franklin @xcite to show security of their identity - based encryption scheme .",
    "* bilinear diffie - hellman problem * let @xmath22 be a bilinear group family and @xmath7 be a generator for @xmath4 , where @xmath23 .",
    "the bdh problem in @xmath21 is as follows : given @xmath30 for some @xmath31 , compute @xmath32 .",
    "a cbdh algorithm @xmath33 for @xmath21 is a probabilistic polynomial - time algorithm that can compute the function @xmath34 in @xmath35 with a non - negligible probability .",
    "that is , for some fixed @xmath36 we have @xmath37\\ge \\frac{1}{k^{c}}\\ ] ] where the probability is over the random choices of @xmath38 in @xmath39 , the index @xmath24 , the random choice of @xmath40 , and the random bits of @xmath41 .",
    "* cbdh assumption*. the bilinear group family @xmath22 _ satisfies _ the cbdh - assumption if there is no cbdh algorithm for @xmath21 .",
    "a perfect - cbdh algorithm @xmath33 for @xmath21 is a probabilistic polynomial - time algorithm that can compute the function @xmath34 in @xmath35 with overwhelming probability .",
    "@xmath21 _ satisfies _ the perfect - cbdh - assumption if there is no perfect - cbdh algorithm for @xmath21 .",
    "[ perfectcbdh ] a bilinear group family @xmath21 satisfies the cbdh - assumption if and only if it satisfies the perfect - cbdh - assumption .    * proof . *",
    "see appendix .",
    "@xmath42    consider joux s tripartite key agreement protocol @xcite : alice , bob , and carol fix a bilinear group @xmath43 .",
    "they select @xmath44 and exchange @xmath45 , @xmath46 , and @xmath47 .",
    "their shared secret is @xmath48 . to _",
    "totally break _",
    "the protocol a passive eavesdropper , eve , must compute the bdh function : @xmath34 .",
    "cbdh - assumption by itself is not sufficient to prove that joux s protocol is useful for practical cryptographic purposes . even though eve may be unable to recover the entire secret",
    ", she may still be able to predict quite a few bits ( less than @xmath49 bits for some constant @xmath19 ; otherwise , cbdh assumption is violated ) of information for @xmath48 with some confidence .",
    "if @xmath50 is to be the basis of a shared secret key , one must bound the amount of information eve is able to deduce about it , given @xmath45 , @xmath46 , and @xmath47 .",
    "this is formally captured by the , much stronger , decisional bilinear diffie - hellman assumption ( dbdh - assumption )    [ dis ] let @xmath51 and @xmath52 be two ensembles of probability distributions , where for each @xmath24 both @xmath53 and @xmath54 are defined over the same domain .",
    "we say that the two ensembles are _ computationally indistinguishable _ if for any probabilistic polynomial - time algorithm @xmath55 , and any @xmath15 we have @xmath56- { { \\rm pr}}\\left[{\\mathcal{d}}\\left({\\mathcal{y}}_{\\mathcal{\\rho}}\\right)=1\\right ] \\right|<\\frac{1}{k^{c}}\\ ] ] for all sufficiently large @xmath16 , where the probability is taken over all @xmath53 , @xmath54 , and internal coin tosses of @xmath55 .    in the remainder of the paper",
    ", we will say in short that the two distributions @xmath53 and @xmath54 are computationally indistinguishable .",
    "let @xmath22 be a bilinear group family .",
    "we consider the following two ensembles of distributions :    * @xmath51 of random tuples @xmath57 , where @xmath7 is a random generator of @xmath4 ( @xmath23 ) and @xmath58 .",
    "* @xmath52 of tuples @xmath59 , where @xmath7 is a random generator of @xmath4 and @xmath60 .",
    "an algorithm that solves the bilinear diffie - hellman decision problem is a polynomial time probabilistic algorithm that can effectively distinguish these two distributions .",
    "that is , given a tuple coming from one of the two distributions , it should output 0 or 1 , and there should be a non - negligible difference between ( a ) the probability that it outputs a 1 given an input from @xmath51 , and ( b ) the probability that it outputs a 1 given an input from @xmath52 .",
    "the bilinear group family @xmath21 _ satisfies the dbdh - assumption _ if the two distributions are computationally indistinguishable .",
    "* the dbdh - assumption is implied by a slightly weaker assumption : _ perfect_-dbdh - assumption .",
    "a perfect - dbdh statistical test for @xmath21 distinguishes the inputs from the above @xmath51 and @xmath52 with overwhelming probability .",
    "the bilinear group family @xmath21 _ satisfies the perfect - dbdh - assumption _ if there is no such probabilistic polynomial - time statistical test .",
    "in this section , we describe our identity - based and authenticated key agreement scheme idak .",
    "let @xmath16 be the security parameter given to the setup algorithm and @xmath28 be a bilinear group parameter generator .",
    "we present the scheme by describing the three algorithms : * setup * , * extract * , and * exchange*.    * setup * : for the input @xmath61 , the algorithm proceeds as follows :    1 .",
    "run @xmath28 on @xmath16 to generate a bilinear group @xmath62 and the prime order @xmath6 of the two groups @xmath4 and @xmath5 .",
    "2 .   pick a random master secret @xmath63 .",
    "3 .   choose cryptographic hash functions @xmath64 and @xmath65 .",
    "in the security analysis , we view @xmath66 and @xmath67 as random oracles . in practice , we take @xmath67 as a random oracle ( secure hash function ) from @xmath68 to @xmath69 ( see appendix for details ) .",
    "the system parameter is @xmath70 and the master secret key is @xmath71 .    *",
    "extract * : for a given identification string @xmath72 , the algorithm computes a generator @xmath73 , and sets the private key @xmath74 where @xmath71 is the master secret key .    * exchange * : for two participants alice and bob whose identification strings are @xmath75 and @xmath76 respectively , the algorithm proceeds as follows .    1",
    ".   alice selects @xmath77 , computes @xmath78 , and sends it to bob .",
    "2 .   bob selects @xmath79 , computes @xmath80 , and sends it to alice .",
    "alice computes @xmath81 , @xmath82 , and the shared secret @xmath83 as @xmath84 4 .",
    "bob computes @xmath81 , @xmath82 , and the shared secret @xmath85 as @xmath86    in the next section , we will show that idak protocol is secure in bellare and rogaway @xcite model with random oracle plus dbdh - assumption .",
    "we conclude this section with a theorem which says that the shared secret established by the idak key agreement protocol is computationally indistinguishable from a random value .",
    "[ passiverandom ] let @xmath22 be a bilinear group family , @xmath23 , and @xmath87 be random generators of @xmath4 .",
    "assume that dbdh - assumption holds for @xmath21 .",
    "then the distributions @xmath88 , @xmath89 , @xmath90 and @xmath91 are computationally indistinguishable , where @xmath92 are selected from @xmath93 uniformly .",
    "before we give a proof for theorem [ passiverandom ] , we first prove two lemmas that will be used in the proof of the theorem .",
    "[ firstlemma ] ( naor and reingold @xcite ) let @xmath22 be a bilinear group family , @xmath23 , @xmath94 be a constant , @xmath7 be a random generator of @xmath4 , and @xmath95 .",
    "assume that the dbdh - assumption holds for @xmath35 .",
    "then the two distributions @xmath96 and @xmath97 are computationally indistinguishable . here",
    "@xmath98 denotes the tuple @xmath99 and @xmath100 .",
    "* proof . * using a random reduction , naor and reingold ( * ? ? ?",
    "* lemma 4.4 ) ( see also shoup @xcite showed that the two distributions @xmath101 and @xmath102 are computationally indistinguishable . the proof can be directly modified to obtain a proof for this lemma .",
    "the details are omitted .",
    "@xmath42    [ secondlemma ]",
    "let @xmath22 be a bilinear group family , @xmath23 , @xmath7 be a random generator of @xmath4 , @xmath95 , and @xmath103 and @xmath104 be two polynomial - time computable functions . if the two distributions @xmath105 and @xmath106 are computationally indistinguishable , then the two distributions @xmath107 and @xmath108 are computationally indistinguishable , where @xmath109 , @xmath110 , and @xmath111 .    * proof .",
    "* see appendix .",
    "@xmath42    * proof of theorem [ passiverandom ] * let @xmath112by lemma [ firstlemma ] , the two distributions @xmath113 are computationally indistinguishable assuming that dbdh - assumption holds for @xmath21 , where @xmath7 is a random generator of @xmath35 and @xmath114 , @xmath115 , @xmath116 , @xmath117 , @xmath118 . since @xmath67 is a fixed function from @xmath4 to @xmath39 and @xmath6 is a prime , it is straightforward to verify that for any @xmath119 , @xmath120 , @xmath121 , and @xmath122 are uniformly ( and independently of each other ) distributed over @xmath5 .",
    "it follows that the distribution @xmath123 is computationally indistinguishable from the distribution @xmath124 , where @xmath125 .",
    "thus @xmath126 and @xmath127 are computationally indistinguishable .",
    "the theorem now follows from lemma [ secondlemma ] .",
    "our security model is based on bellare and rogaway @xcite security models for key agreement protocols with several modifications . in our model",
    ", we assume that we have at most @xmath128 protocol participants ( principals ) : @xmath129 , where @xmath16 is the security parameter .",
    "the protocol determines how principals behave in response to input signals from their environment .",
    "each principal may execute the protocol multiple times with the same or different partners .",
    "this is modelled by allowing each principal to have different instances that execute the protocol .",
    "an oracle @xmath130 models the behavior of the principal @xmath131 carrying out a protocol session in the belief that it is communicating with the principal @xmath132 for the @xmath133th time .",
    "one given instance is used only for one time .",
    "each @xmath130 maintains a variable _ view _ ( or _ transcript _ ) consisting of the protocol run transcripts so far .",
    "the adversary is modelled by a probabilistic polynomial time turing machine that is assumed to have complete control over all communication links in the network and to interact with the principals via oracle accesses to @xmath130 .",
    "the adversary is allowed to execute any of the following queries :    * @xmath134 .",
    "this allows the adversary to get the long term private key for a new principal whose identity string is @xmath135 . *",
    "this sends message @xmath137 to the oracle @xmath130 .",
    "the output of @xmath130 is given to the adversary .",
    "the adversary can ask the principal @xmath131 to initiate a session with @xmath132 by a query @xmath138 where @xmath139 is the empty string . * @xmath140 .",
    "this asks the oracle to reveal whatever session key it currently holds .",
    "* @xmath141 .",
    "this asks @xmath131 to reveal the long term private key @xmath142 .",
    "the difference between the queries * extract * and * corrupt * is that the adversary can use * extract * to get the private key for an identity string of her choice while * corrupt * can only be used to get the private key of existing principals .",
    "let @xmath143 be an initiator oracle ( that is , it has received a @xmath139 message at the beginning ) and @xmath144 be a responder oracle . if every message that @xmath143 sends out is subsequently delivered to @xmath144 , with the response to this message being returned to @xmath143 as the next message on its transcript , then we say the oracle @xmath144 matches @xmath143 .",
    "similarly , if every message that @xmath144 receives was previously generated by @xmath143 , and each message that @xmath144 sends out is subsequently delivered to @xmath143 , with the response to this message being returned to @xmath144 as the next message on its transcript , then we say the oracle @xmath143 matches @xmath144 .",
    "the details for an exact definition of matching oracles could be found in @xcite .    for the definition of matching oracles",
    ", the reader should be aware the following scenarios : even though the oracle @xmath143 thinks that its matching oracle is @xmath144 , the real matching oracle for @xmath143 could be @xmath145 .",
    "for example , if @xmath143 sends a message @xmath137 to @xmath144 and @xmath144 replies with @xmath146 .",
    "the adversary decides not to forward the message @xmath146 to @xmath143 .",
    "instead , the adversary sends the message @xmath137 to initiate another oracle @xmath145 and @xmath131 does not know the existence of this new oracle @xmath145 .",
    "the oracle @xmath145 replies with @xmath147 and the adversary forwards this @xmath147 to @xmath143 as the responding message for @xmath137 . in this case , the transcript of @xmath143 matches the transcript of @xmath145 .",
    "thus we consider @xmath143 and @xmath145 as matching oracles . in another word ,",
    "the matching oracles are mainly based the message transcripts .    in order to define the notion of a secure session key exchange ,",
    "the adversary is given an additional experiment .",
    "that is , in addition to the above regular queries , the adversary can choose , at any time during its run , a @xmath148 query to a completed oracle @xmath130 with the following properties :    * the adversary has never issued , at any time during its run , the query @xmath149 or @xmath150 .",
    "* the adversary has never issued , at any time during its run , the query @xmath141 or @xmath151 . *",
    "the adversary has never issued , at any time during its run , the query @xmath140 . *",
    "the adversary has never issued , at any time during its run , the query @xmath152 if the matching oracle @xmath153 for @xmath130 exists ( note that such an oracle may not exist if the adversary is impersonating the @xmath132 to the oracle @xmath130 ) .",
    "the value of @xmath133 may be different from the value of @xmath154 since the adversary may run fake sessions to impersonate any principals without victims knowledge .",
    "let @xmath155 be the value of the session key held by the oracle @xmath130 that has been established between @xmath131 and @xmath132 .",
    "the oracle @xmath130 tosses a coin @xmath156 . if @xmath157 , the adversary is given @xmath155 .",
    "otherwise , the adversary is given a value @xmath158 randomly chosen from the probability distribution of keys generated by the protocol . in the end",
    ", the attacker outputs a bit @xmath159 .",
    "the advantage that the adversary has for the above guess is defined as @xmath160-\\frac{1}{2}\\right|.\\ ] ] now we are ready to give the exact definition for a secure key agreement protocol .",
    "[ keysecuredef ] a key agreement protocol @xmath161 is br - secure if the following conditions are satisfied for any adversary :    1 .   if two uncorrupted oracles @xmath143 and @xmath144 have matching conversations ( e.g. , the adversary is passive ) and both of them are complete according to the protocol @xmath161 , then both oracles will always accept and hold the same session key which is uniformly distributed over the key space .",
    "@xmath162 is negligible .    in the following ,",
    "we briefly discuss the attributes that a br - secure key agreement protocol achieves .    *",
    "* known session keys*. the adversary may use * reveal*@xmath163 query before or after the query * test*@xmath164 .",
    "thus in a secure key agreement model , the adversary learns zero information about a fresh key for session @xmath133 even if she has learnt keys for other sessions @xmath154 . *",
    "* impersonation attack*. if the adversary impersonates @xmath132 to @xmath131 , then she still learns zero information about the session key that the oracle @xmath143 holds for this impersonated @xmath132 since there is no matching oracle for @xmath143 in this scenario .",
    "thus @xmath41 can use * test * query to test this session key that @xmath143 holds . * * unknown key share*. if @xmath131 establishes a session key with @xmath165 though he believes that he is talking to @xmath132 , then there is an oracle @xmath143 that holds this session key @xmath166 . at the same time",
    ", there is an oracle @xmath167 that holds this session key @xmath166 , for some @xmath168 ( normally @xmath169 ) . during an unknown key share attack ,",
    "the user @xmath132 may not know this session key .",
    "since @xmath143 and @xmath167 are not matching oracles , the adversary can make the query @xmath170 to learn this session key before the query @xmath171 .",
    "thus the adversary will succeed for this * test * query challenge if the unknown key share attack is possible .",
    "however , the following important security properties that a secure key agreement scheme should have are not implied from the original br - security model .    *",
    "* perfect forward secrecy*. this property requires that previously agreed session keys should remain secret , even if both parties long - term private key materials are compromised .",
    "bellare - rogaway model does not capture this property .",
    "canetti and krawczyk s model @xcite use the session - key expiration primitive to capture this property .",
    "similar modification to bellare - rogaway model are required to capture this property also .",
    "we will give a separate proof that the idak key agreement protocol achieves weak perfect forward secrecy .",
    "note that as pointed out in @xcite , no two - message key - exchange protocol authenticated with public keys and with no secure shared state can achieve perfect forward secrecy .",
    "* * key compromise impersonation resilience*. if the entity @xmath172 s long term private key is compromised , then the adversary could impersonate @xmath172 to others , but it should not be able to impersonate others to @xmath172 .",
    "similar to wpfs property , bellare - rogaway model does not capture this property .",
    "we will give a separate proof that the idak key agreement protocol has this property .",
    "before we present the security proof for the idak key agreement protocol , we first prove some preliminary results that will be used in the security proof .",
    "[ feedbackbdh ] let @xmath22 be a bilinear group family , @xmath23 , @xmath7 be a random generator of @xmath4 , and @xmath173 be a random oracle .",
    "assume dbdh - assumption holds for @xmath21 and let @xmath126 and @xmath124 be two distributions defined as @xmath174 then we have    1 .",
    "the two distributions @xmath126 and @xmath124 are computationally indistinguishable if @xmath98 is defined as @xmath175 @xmath176 are chosen from @xmath39 uniformly , @xmath177 or @xmath158 is either chosen from @xmath39 uniformly , @xmath178 and @xmath179 are chosen from @xmath4 within polynomial time according to a fixed distribution given the view @xmath180 without violating dbdh - assumption .",
    "2 .   for any constant @xmath128 ,",
    "the two distributions @xmath126 and @xmath124 are computationally indistinguishable if @xmath98 is defined as : @xmath181 where @xmath182 are uniformly chosen from @xmath39 , @xmath183 are either chosen from @xmath39 uniformly or @xmath184 , and @xmath185 is chosen within polynomial time according to a fixed distribution given the view @xmath186 , @xmath187 , @xmath188 , @xmath189 without violating dbdh - assumption .",
    "3 .   for any constant @xmath128 ,",
    "the two distributions @xmath126 and @xmath124 are computationally indistinguishable if @xmath190 , where @xmath191 is defined as the @xmath98 in the item 2 , and @xmath192 is defined as : @xmath193 where @xmath183 are either chosen from @xmath39 uniformly or @xmath184 , @xmath194 and @xmath185 are chosen within polynomial time according to a fixed distribution given the view @xmath186 , @xmath187 , @xmath188 , @xmath195 without violating dbdh - assumption and with the condition that `` @xmath196 or @xmath197 '' .",
    "note that @xmath194 and @xmath185 could have different distributions .",
    "* proof . *",
    "see appendix.@xmath42    [ securityprooftheorem ] suppose that the functions @xmath66 and @xmath67 are random oracles and the bilinear group family @xmath21 satisfies dbdh - assumption . then the idak scheme is a br - secure key agreement protocol .",
    "* proof . *",
    "in this section , we show that the protocol idak achieves weak perfect forward secrecy property . perfect forward secrecy property requires that even if alice and bob lose their private keys @xmath198 and @xmath199 , the session keys established by alice and bob in the previous sessions are still secure .",
    "krawczyk @xcite pointed out that no two - message key - exchange protocol authenticated with public keys and with no secure shared state can achieve perfect forward secrecy .",
    "weak perfect forward secrecy ( wpfs ) property for key agreement protocols sates as follows @xcite : any session key established by uncorrupted parties without active intervention by the adversary is guaranteed to remain secure even if the parties to the exchange are corrupted after the session key was erased from the parties memory ( for a formal definition , the reader is referred to @xcite ) .    in the following ,",
    "we show the idak achieves wpfs property . using the similar primitive of `` session - key expiration '' as in canetti and",
    "krawczyk s model @xcite , we can revise bellare - rogaway model so that wpfs property is provable also . in bellare - rogaway model",
    ", the @xmath148 query is allowed only if the four properties in section [ securitymodel ] are satisfied . we can replace the property `` the adversary has never issued , at any time during its run , the query @xmath141 or @xmath151 '' with the property `` the adversary has never issued , before the session @xmath130 is complete , the query @xmath141 or @xmath151 '' .",
    "we call this model the wpfsbr model . in the final version of this paper",
    ", we will show that the protocol idak is secure in the wpfsbr model .",
    "thus idak achieves wpfs property . in the following , we present the essential technique used in the proof",
    "it is essentially sufficient to show that the two distributions @xmath200 and @xmath201 are computationally indistinguishable for @xmath202 and uniform at random chosen @xmath203 , @xmath204 , @xmath205 .",
    "consequently , it is sufficient to prove the following theorem .",
    "[ pfsthm ] let @xmath22 be a bilinear group family , @xmath23 .",
    "assume that dbdh - assumption holds for @xmath21 .",
    "then the two distributions @xmath206 are computationally indistinguishable for random chosen @xmath207 .",
    "* we use a random reduction . for a contradiction ,",
    "assume that there is a polynomial time probabilistic algorithm @xmath55 that distinguishes @xmath126 and @xmath124 with a non - negligible probability @xmath18 .",
    "we construct a polynomial time probabilistic algorithm @xmath41 that distinguishes @xmath208 and @xmath209 with @xmath18 , where @xmath210 and @xmath211 are uniformly at random in @xmath212 .",
    "let the input of @xmath41 be @xmath213 , where @xmath214 is either @xmath215 or uniformly at random in @xmath212 .",
    "we construct @xmath41 as follows .",
    "@xmath41 chooses random @xmath216 and sets @xmath217 , @xmath218 , @xmath219 , @xmath220 , @xmath221 , @xmath222 , and @xmath223 .",
    "let @xmath224 note that if @xmath225 , then @xmath226 are uniform in @xmath212 ( and independent of each other and of @xmath227 ) and @xmath228 .",
    "otherwise , @xmath226 are uniform in @xmath212 and independent of each other and of @xmath227 .",
    "therefore , by the definitions , @xmath229 = \\pr\\left[{\\mathcal{d}}({\\mathcal{x}})=1\\right]\\\\ \\mbox{and}\\quad\\quad&\\pr\\left[{\\mathcal{a}}\\left({\\mathcal{r}},{\\hat{e}}(g , g)^{t}\\right)=1\\right ] = \\pr\\left[{\\mathcal{d}}({\\mathcal{y}})=1\\right ] \\end{array}\\ ] ] thus @xmath41 distinguishes @xmath230 and @xmath231 with @xmath18 .",
    "this is a contradiction .",
    "though theorem [ pfsthm ] shows that the protocol idak achieves weak perfect forward secrecy even if both participating parties long term private keys were corrupted , idak does not have perfect forward secrecy when the master secret @xmath71 were leaked .",
    "the perfect forward secrecy against the corruption of @xmath71 could be achieved by requiring bob ( the responder in the idak protocol ) to send @xmath232 in addition to the value @xmath233 and by requiring both parties to compute the shared secret as @xmath234 where @xmath83 is the shared secret established by the idak protocol .",
    "in this section , we informally show that the protocol idak has the key compromise impersonation resilience property .",
    "that is , if alice loses her private key @xmath235 , then the adversary still could not impersonate bob to alice . for a formaly proof of kci",
    ", we still need to consider the information obtained by the adversary by * reveal * , * extract * , * send * , * corrupt * queries in other sessions .",
    "this will be done in the final version of this paper .    in order to show kci for idak ,",
    "it is ( informally ) sufficient to show that the two distributions @xmath236 and @xmath200 are computationally indistinguishable for @xmath237 , where @xmath238 are chosen uniform at random , and @xmath239 is chosen according to some probabilistic polynomial time distribution . since the value @xmath240 is known , it is sufficient to prove the following theorem .",
    "[ kcrthm ] let @xmath22 be a bilinear group family , @xmath23 .",
    "assume that dbdh - assumption holds for @xmath21 .",
    "then the two distributions @xmath241 are computationally indistinguishable for random chosen @xmath242 , where @xmath239 is chosen according to some probabilistic polynomial time distribution .",
    "* proof . * since @xmath243 is chosen uniform at random , and @xmath67 is a random oracle , we may assume that @xmath244 is uniformly distributed over @xmath4 when @xmath239 is chosen according to any probabilistic polynomial time distribution .",
    "thus the proof is similar to the proof of theorem [ pfsthm ] and the details are omitted .",
    "the theorem could also be proved using the splitting lemma @xcite which was used to prove the fork lemma .",
    "briefly , the splitting lemma translates the fact that when a subset @xmath172 is `` large '' in a product space @xmath245 , it has many large sections . using the splitting lemma",
    ", one can show that if @xmath55 can distinguish @xmath126 and @xmath124 , then by replaying @xmath55 with different random oracle @xmath67 , one can get sufficient many tuples @xmath246 such that ( 1 ) @xmath247 ; ( 2 ) @xmath55 distinguishes @xmath248 and @xmath124 ( respectively @xmath249 and @xmath124 ) when @xmath250 is uniformly chosen but other values takes the values from the above tuple with @xmath251 ( respectively @xmath252 ) . since @xmath253 .",
    "thus , for the above tuple , we can distinguish @xmath254 from @xmath255 for random chosen @xmath250 .",
    "this is a contradiction with the dbdh - assumption .",
    "@xmath42    99 m.  bellare , r.  canetti , and h.  krawczyk .",
    "keying hash functions for message authentication . in : _ advances in cryptology ,",
    "crypto 96 _ , pages 115 , 1996 .",
    "m.  bellare , r.  canetti , and h.  krawczyk . a modular approach to the design and analysis of authentication and key exchange protocols . in : _",
    "30th annual acm symposium on theory of computing _ , 1998 .",
    "m.  bellare and p.  rogaway .",
    "random oracles are practical : a paradigms for designing efficient protocols . in : _ proc .",
    "1st acm conference on computer communication security _ , pages 6273 , acm press , 1993 .",
    "m.  bellare and p.  rogaway . entity authentication and key distribution . in : _ advances in cryptology ,",
    "crypto 93 _ , lncs 773 ( 1993 ) , 232249 .",
    "m.  blum and s.micali . how to generate cryptographically strong sequence of pseudo - random bits .",
    "_ siam j. comput . _ * 13*:850864 , 1984 .    d.  boneh .",
    "the decision diffie - hellman problem . in : _ ants - iii _ , lncs 1423 ( 1998 ) , 4863 .",
    "d.  boneh and m.  franklin .",
    "identity - based encryption from the weil pairing .",
    "_ siam j. computing _ * 32*(3):586615 , 2003 .",
    "r.  canetti .",
    "universally composable security : a new paradigm for cryptographic protocols . in : _",
    "42nd focs _ , 2001 .",
    "r.  canetti and h.  krawczyk .",
    "analysis of key - exchange protocols and their use for building secure channels . in : _ advances in cryptology ,",
    "eurocrypt 01 _ , lncs 2045 ( 2001 ) , 453474 .",
    "full version available from cryptology eprint archive 2001 - 040 ( http://eprint.iacr.org/ ) .",
    "r.  canetti and h.  krawczyk .",
    "universally composable notions of key exchange and secure channels . in : _",
    "eurocrypt 02_.",
    "l.  chen and c.  kudla .",
    "identity based authenticated key agreement protocols from pairing . in : _",
    "16th ieee security foundations workshop _ , pages 219233 .",
    "ieee computer society press , 2003 .",
    "z.  cheng and l.  chen . on the security proof of mccullagh - barreto s key agreement protocol and its variants .",
    "http://eprint.iacr.org/2005/201.pdf    z.  cheng , m.  nistazakis , r.  comley , and l.  vasiu .",
    "on indistinguishability - based security model of key agreement protocols - simple cases . in _ proc . of acns 04",
    "_ , june 2004 .",
    "k.  choo .",
    "revisit of mccullagh - barreto two party id - based authentication key agreement protocols .",
    "w.  diffie and m.  hellman .",
    "new directions in cryptography . _ ieee transactions on information theory _ , *",
    "6*(1976 ) , 644654 .",
    "a.  fiat and a.  shamir .",
    "how to prove yourself : practical solutions of identification and signature problems . in : _ advances in cryptology ,",
    "crypto 86 _ , lncs 263 ( 1987 ) , 186194 .",
    "m.  girault and j.  pailles .",
    "an identity - based scheme providing zero - knowledge authentication and authenticated key exchange . in : _ proc .",
    "esorics 90 _ , pages 173184 .",
    "a.  joux .",
    "a one round protocol for tripartite diffie - hellman . in : _",
    "algorithmic number theory symposium , ants - iv _ , lncs 1838 , pages 385394 , 2000 .",
    "h.  krawczyk .",
    "hmqv : a high - performance secure diffie - hellman protocol . in : _ proc .",
    "crypto 05 _ , springer , 2005 .",
    "l.  law , a.  menezes , m.  qu , j.  solinas , and s.  vanstone .",
    "an efficient protocol for authenticated key agreement .",
    "_ designs , codes and cryptography _ , * 28*(2):119134 .",
    "s.  li , q.  yuan , and j.  li . towards security two - part authenticated key agreement protocols .",
    "http://eprint.iacr.org/2005/300.pdf .",
    "p.  mccullagh and p.  barreto .",
    "a new two - party identity - based authenticated key agreement .",
    "_ proc . of ct - rsa 2005",
    "_ , pages 262 - 274 , lncs 3376 , springer verlag , 2005 .",
    "p.  mccullagh and p.  barreto . a new two - party identity - based authenticated key agreement .",
    "m.  naor and o.  reingold .",
    "number - theoretic constructions of efficient pseudo - random functions . in : _",
    "38th annual symposium on foundations of computer science _ , ieee press , 1998 .",
    "v.  nechaev .",
    "complexity of a determinate algorithm for the discrete logarithm .",
    "_ mathematical notes _ , * 55*(1994 ) , 165172 .",
    "nist special publication 800 - 56 : recommendation on key establishment schemes , draft 2.0 , 2003 .",
    "http://csrc.nist.gov/cryptotoolkit/kms/keyschemes-jan03.pdf .",
    "e.  okamoto .",
    "proposal for identity - based key distribution system . _ electronics letters _ * 22*:12831284 , 1986 .",
    "d.  pointcheval and j.  stern .",
    "security arguments for digital signatures and blind signatures .",
    "_ j. cryptology _ * 13*(3):361396 , 2000 .",
    "e.  ryu , e.  yoon , and k.  yoo .",
    "an efficient id - based authenticated key agreement protocol from pairing . in : _ networking 2004 _ , pages 14581463 , lncs 3042 , springer verlag , 2004 .",
    "r.  sakai , k.  ohgishi , and m.  kasahara .",
    "cryptosystems based on pairing . in : _ 2000 symp . on cryptography and information security ( scis 2000 ) _ , okinawa , japan 2000 .",
    "m.  scott .",
    "authenticated id - based key exchange and remote log - in with insecure token and pin number .",
    "http://eprint.iacr.org/2002/164.pdf    a.  shamir .",
    "identity - based cryptosystems and signature schemes . in : _ advances in cryptology ,",
    "crypto 84 _ , lncs 196 , pages 4753 , springer verlag 1984 .",
    "k.  shim .",
    "efficient id - based authenticated key agreement protocol based on the weil pairing .",
    "_ electronics letters _",
    "* 39*(8):653654 , 2003 .",
    "v.  shoup .",
    "lower bounds for discrete logarithms and related problems . in : _ advances in cryptology ,",
    "eurocrypt 97 _ , lncs 1233 ( 1997 ) , 256266 .    v.  shoup . on formal models for secure key exchange .",
    "ibm technical report rz 3120 , 1999 .",
    "n.  p.  smart .",
    "identity - based authenticated key agreement protocol based on weil pairing .",
    "_ electronics letters _",
    "* 38*(13):630632 , 2002 .",
    "s.  sun and b.  hsieh .",
    "security analysis of shim s authenticated key agreement protocols from pairing . http://eprint.iacr.org/2003/113.pdf    k.  tanaka and e.  okamoto .",
    "key distribution system for mail systems using id - related information directory .",
    "_ computers and security _ * 10*:2533 , 1991 .",
    "cryptanalysis of noel mccullagh and paulo s. l. m. barreto s two - party identity - based key agreemenet .",
    "http://eprint.iacr.org/2004/308.pdf    g.  xie .",
    "an id - based key agreement scheme from pairing .",
    "the fact that the cbdh - assumption implies the perfect - cbdh - assumption is trivial .",
    "the converse is proved by the self - random - reduction technique ( see @xcite ) .",
    "let @xmath256 be a cbdh oracle .",
    "that is , there exists a @xmath15 such that ( [ cbdhe ] ) holds with @xmath33 replaced with @xmath256 .",
    "we construct a perfect - cbdh algorithm @xmath33 which makes use of the oracle @xmath256 .",
    "given @xmath257 , algorithm @xmath33 must compute @xmath48 with overwhelming probability .",
    "consider the following algorithm : select @xmath258 ( unless stated explicitly , we use @xmath259 to denote that @xmath260 is randomly chosen from @xmath137 in the remainder of this paper ) and output @xmath261 one can easily verify that if @xmath262 , then @xmath263 . consequently , standard amplification techniques can be used to construct the algorithm @xmath33 .",
    "the details are omitted .      for",
    "a contradiction , assume that there is a probabilistic polynomial - time algorithm @xmath55 that distinguishes the two distributions @xmath249 and @xmath264 with non - negligible probability @xmath18 .",
    "in the following we construct a probabilistic polynomial - time algorithm @xmath265 to distinguish the two distributions @xmath248 and @xmath266 .",
    "@xmath265 is defined by letting @xmath267 for all @xmath98 , and @xmath268 . by this definition",
    ", we have @xmath269   = { { \\rm pr}}\\left[{\\mathcal{d}}_r({\\mathcal{x}}_2)=1|{\\mathcal{r}},r\\right]$ ] , for any fixed internal coin tosses @xmath158 of @xmath55 and @xmath265 .",
    "let @xmath270 . by definition of @xmath265",
    ", we have @xmath271 it follows that @xmath272 and @xmath273   = { |d_{{\\mathcal{r}},r}^{{\\mathcal{d}}^\\prime}|}/{q^2 } = { |d_{{\\mathcal{r}},r}^{{\\mathcal{d}}}|}/{q }   = { { \\rm pr}}\\left[{\\mathcal{d}}_r({\\mathcal{y}}_2)=1|{\\mathcal{r}},r\\right]$ ] .",
    "thus we have @xmath274 -{{\\rm pr}}\\left[{\\mathcal{d}}^\\prime({\\mathcal{y}}_1)=1\\right]\\right|\\\\ = & \\left|\\sum_{{\\mathcal{r}},r}{{\\rm pr}}[{\\mathcal{r}},r]\\cdot\\left ( { { \\rm pr}}\\left[{\\mathcal{d}}^\\prime_r({\\mathcal{x}}_1)=1|{\\mathcal{r}},r\\right]- { { \\rm pr}}\\left[{\\mathcal{d}}^\\prime_r({\\mathcal{y}}_1)=1|{\\mathcal{r}},r\\right]\\right)\\right|\\\\ = & \\left|\\sum_{{\\mathcal{r}},r}{{\\rm pr}}[{\\mathcal{r}},r]\\cdot\\left ( { { \\rm pr}}\\left[{\\mathcal{d}}_r({\\mathcal{x}}_2)=1|{\\mathcal{r}},r\\right]- { { \\rm pr}}\\left[{\\mathcal{d}}_r({\\mathcal{y}}_2)=1|{\\mathcal{r}},r\\right]\\right)\\right|\\\\ = & \\left|{{\\rm pr}}\\left[{\\mathcal{d}}({\\mathcal{x}}_2)=1\\right]- { { \\rm pr}}\\left[{\\mathcal{d}}({\\mathcal{y}}_2)=1\\right]\\right|\\\\ > & \\delta_k .",
    "\\end{array}\\ ] ] hence , @xmath265 distinguishes the distributions @xmath248 and @xmath266 with non - negligible probability @xmath18 .",
    "this contradicts the assumption of the lemma .",
    "the lemma could be proved using complicated version of the splitting lemma by pointcheval - stern @xcite ( see the proof of theorem [ kcridak ] ) . in the following ,",
    "we use the random reduction to prove the lemma .    \\1 . for",
    "a contradiction , assume that there is a polynomial time probabilistic algorithm @xmath55 that distinguishes @xmath126 and @xmath124 .",
    "we construct a polynomial time probabilistic algorithm @xmath41 that distinguishes @xmath275 , @xmath276 and @xmath277 with @xmath18 , where @xmath278 are uniformly at random in @xmath212 .",
    "let the input of @xmath41 be @xmath279 , where @xmath280 is either @xmath215 or uniformly at random in @xmath212 .",
    "@xmath41 chooses uniformly at random @xmath281 , sets @xmath282 , @xmath283 , @xmath284 , chooses uniformly at random @xmath285 or lets @xmath286 , chooses @xmath287 within polynomial time according to any distribution given the view @xmath288 ( the distributions for @xmath289 and @xmath179 could be different ) . since @xmath45 and @xmath290 are uniformly chosen from @xmath4 , we may assume that the values of @xmath291 and @xmath292 are unknown yet .",
    "without loss of generality , we may assume that @xmath293 and @xmath294 take values @xmath295 and @xmath296 respectively , where @xmath295 and @xmath296 are uniformly chosen from @xmath212 .",
    "in a summary , the value of @xmath98 could be computed from @xmath297 efficiently .",
    "@xmath41 then sets @xmath298 @xmath41 can compute @xmath299 using the values of @xmath300 , @xmath301 , @xmath302 , @xmath296 .",
    "let @xmath303 , where @xmath304 is obtained from @xmath124 by replacing @xmath305 with @xmath214 and taking the remaining values as defined above .    note that if @xmath306 , then @xmath307 , and @xmath304 is distributed according to the distribution @xmath126 .",
    "that is , @xmath308 are uniform in @xmath212 and independent of each other and of @xmath309 , ( @xmath158 , @xmath178 , @xmath179 ) is chosen according to the specified distributions without violating dbdh - assumption .",
    "otherwise , @xmath304 is distributed according to the distribution @xmath126 , and @xmath214 is uniform in @xmath212 and independent of @xmath310 .",
    "therefore , by definitions , @xmath311 = \\pr\\left[{\\mathcal{d}}({\\mathcal{x}})=1\\right]\\\\ \\mbox{and}\\quad\\quad & \\pr\\left[{\\mathcal{a}}\\left(g , g^u , g^v , g^w,{\\hat{e}}(g , g)^{a}\\right)=1\\right ] = \\pr\\left[{\\mathcal{d}}({\\mathcal{y}})=1\\right ] \\end{array}\\ ] ] thus @xmath41 distinguishes @xmath312 and @xmath277 with @xmath18 , where @xmath2 is uniform at random in @xmath212 .",
    "this is a contradiction .",
    "this part of the lemma could be proved in the same way .",
    "the details are omitted .",
    "\\3 . since `` @xmath196 or @xmath197 ''",
    ", we may assume that the values of @xmath313 and @xmath314 are unknown yet . by the random oracle property of @xmath67 , this part of the lemma",
    "could be proved in the same way as in item 1 .",
    "the details are omitted .",
    "* proof . * by theorem [ passiverandom ] , the condition 1 in the definition [ keysecuredef ] is satisfied for the idak key agreement protocol . in the following , we show that the condition 2 is also satisfied .",
    "for a contradiction , assume that the adversary @xmath41 has non - negligible advantage @xmath315 in guessing the value of @xmath3 after the * test * query .",
    "we show how to construct a simulator @xmath316 that uses @xmath41 as an oracle to distinguish the distributions @xmath126 and @xmath124 in the item 3 of lemma [ feedbackbdh ] with non - negligible advantage @xmath317 , where @xmath318 denotes the number of distinct @xmath66-*queries * that the algorithm @xmath41 has made .",
    "the game between the challenger and the simulator @xmath316 starts with the challenger first generating bilinear groups @xmath23 by running the algorithm * instance generator*. the challenger then chooses @xmath319 and @xmath320 .",
    "the challenger gives the tuple @xmath321 to the algorithm @xmath316 where @xmath322 if @xmath157 and @xmath323 otherwise . during the simulation",
    ", the algorithm @xmath316 can ask the challenger to provide randomly chosen @xmath324 .",
    "@xmath316 may then choose ( with the help of @xmath41 perhaps ) @xmath185 within polynomial time according to any distribution given the view @xmath325 and sends @xmath185 to the challenger .",
    "the challenger responds with @xmath326 . at the end of the simulation ,",
    "the algorithm @xmath316 is supposed to output its guess @xmath327 for @xmath3 .",
    "it should be noted that if @xmath157 , then the output of the challenger together with the values @xmath185 selected by the simulator @xmath316 is the tuple @xmath126 of lemma [ feedbackbdh ] , and is the tuple @xmath124 of lemma [ feedbackbdh ] if @xmath328 .",
    "thus the simulator @xmath316 could be used to distinguish @xmath126 and @xmath124 of lemma [ feedbackbdh ] .",
    "the algorithm @xmath316 selects two integers @xmath329 randomly and works by interacting with @xmath41 as follows :    * setup : * algorithm @xmath316 gives @xmath41 the idak system parameters @xmath330 where @xmath331 are parameters from the challenger , @xmath66 and @xmath67 are random oracles controlled by @xmath316 as follows .",
    "@xmath66-*queries * : at any time algorithm @xmath41 can query the random oracle @xmath66 using the queries @xmath149 or @xmath332 . to respond to these queries",
    "algorithm @xmath316 maintains an @xmath333 that contains a list of tuples @xmath334 .",
    "the list is initially empty .",
    "when @xmath41 queries the oracle @xmath66 at a point @xmath131 , @xmath316 responds as follows :    1 .",
    "if the query @xmath131 appears on the @xmath333 in a tuple @xmath334 , then @xmath316 responds with @xmath335 .",
    "2 .   otherwise , if this is the @xmath336-th new query of the random oracle @xmath66 , @xmath316 responds with @xmath337 , and adds the tuple @xmath338 to the @xmath333 .",
    "if this is the @xmath339-th new query of the random oracle , @xmath316 responds with @xmath340 , and adds the tuple @xmath341 to the @xmath333 .",
    "3 .   in the remaining case",
    ", @xmath316 selects a random @xmath342 , responds with @xmath343 , and adds the tuple @xmath344 to the @xmath333 .",
    "@xmath67-*queries * : at any time the challenger , the algorithm @xmath41 , and the algorithm @xmath316 can query the random oracle @xmath67 . to respond to these queries",
    "algorithm @xmath316 maintains a @xmath345 that contains a list of tuples @xmath346 .",
    "the list is initially empty .",
    "when @xmath41 queries the oracle @xmath67 at a point @xmath347 , @xmath316 responds as follows : if the query @xmath347 appears on the @xmath345 in a tuple @xmath348 , then @xmath316 responds with @xmath349 .",
    "otherwise , @xmath316 selects a random @xmath350 , responds with @xmath351 , and adds the tuple @xmath352 to the @xmath345 .",
    "technically , the random oracle @xmath67 could be held by an independent third party to avoid the confusion that the challenger also needs to access this random oracle also .",
    "* query phase : * @xmath316 responds to @xmath41 s queries as follows .    for a @xmath353 query , @xmath316 runs the @xmath66-*queries * to obtain a @xmath354 such that @xmath335 , and responds with @xmath354 .    for an @xmath149 query for the long term private key , if @xmath355 or @xmath356 , then @xmath316 reports failure and terminates",
    "otherwise , @xmath316 runs the @xmath66-*queries * to obtain @xmath343 , and responds @xmath357 .    for a @xmath136 query ,",
    "we distinguish the following three cases :    1 .   @xmath358 .",
    "if @xmath355 or @xmath339 , @xmath316 asks the challenger for a random @xmath359 ( note that @xmath316 does not know the discrete logarithm of @xmath360 with base @xmath354 ) , otherwise @xmath316 chooses a random @xmath361 and sets @xmath362 .",
    "@xmath316 lets @xmath363 reply with @xmath360 .",
    "that is , we assume that @xmath131 is carrying out an idak key agreement protocol with @xmath132 and @xmath131 sends the first message @xmath360 to @xmath132 .",
    "2 .   @xmath364 and the transcript of the oracle",
    "@xmath130 is empty . in this case",
    ", @xmath130 is the responder to the protocol and has not sent out any message yet .",
    "if @xmath355 or @xmath339 , @xmath316 asks the challenger for a random @xmath359 , otherwise @xmath316 chooses a random @xmath361 and sets @xmath362 .",
    "@xmath316 lets @xmath363 reply with @xmath360 and marks the oracle @xmath130 as completed .",
    "3 .   @xmath364 and the transcript of the oracle @xmath130 is not empty . in this case , @xmath130 is the protocol initiator and should have sent out the first message already .",
    "thus @xmath130 does not need to respond anything .",
    "after processing the query @xmath136 , @xmath316 marks the oracle @xmath130 as completed .    for a @xmath140 query ,",
    "if @xmath365 and @xmath366 , @xmath316 computes the session key @xmath367 , @xmath368 and responds with @xmath166 , here @xmath369 is the message received by @xmath130 .",
    "note that the message @xmath369 may not necessarily be sent by the oracle @xmath153 for some @xmath154 since it could have been a bogus message from @xmath41 . otherwise , @xmath355 or @xmath356 . without loss of generality , we assume that @xmath355 . in this case , the oracle @xmath370 dose not know its private key @xmath371 .",
    "thus it needs help from the challenger to compute the shared session key .",
    "let @xmath372 and @xmath369 be the messages that @xmath370 has sent out and received respectively .",
    "@xmath370 gives these two values to the challenger and the challenger computes the shared session key @xmath373 .",
    "@xmath370 then responds with @xmath374 .    for a @xmath141 query , if @xmath355 or @xmath356 , then @xmath316 reports failure and terminates",
    "otherwise , @xmath316 responds with @xmath375 .    for the * test*@xmath164 query , if @xmath376 or @xmath377 , then @xmath316 reports failure and terminates .",
    "otherwise , assume that @xmath355 and @xmath378 .",
    "let @xmath379 be the message that @xmath130 sends out ( note that the challenger generated this message ) and @xmath380 be the message that @xmath130 receives ( note that @xmath381 could be the message that the challenger generated or could be generated by the algorithm @xmath41 ) .",
    "@xmath316 gives the messages @xmath372 and @xmath381 to the challenger .",
    "the challenger computes @xmath382 and gives @xmath137 to @xmath316 .",
    "@xmath316 responds with @xmath137 .",
    "note that if @xmath307 , then @xmath137 is the session key . otherwise , @xmath137 is a uniformly distributed group element .    * guess : * after the * test*@xmath164 query , the algorithm @xmath41 may issue other queries before finally outputs its guess @xmath327 .",
    "algorithm @xmath316 outputs @xmath159 as its guess to the challenger .",
    "* claim : * if @xmath316 does not abort during the simulation then @xmath41 s view is identical to its view in the real attack . furthermore ,",
    "if @xmath316 does not abort , then @xmath383-\\frac{1}{2}\\right| > \\delta_k$ ] , where the probability is over all random coins used by @xmath316 and @xmath41 .",
    "_ proof of claim : _ the responses to @xmath66-*queries * and @xmath67-*queries * are the same as in the real attack since the response is uniformly distributed .",
    "all responses to the getid queries , private key extract queries , message delivery queries , reveal queries , and corrupt queries are valid .",
    "it remains to show that the response to the test query is valid also .",
    "when @xmath214 is uniformly distributed over @xmath212 , then theorem [ passiverandom ] shows that @xmath382 is uniformly distributed over @xmath4 and is computationally indistinguishable from a random value before @xmath41 s view .",
    "therefore , by definition of the algorithm @xmath41 , we have @xmath383-\\frac{1}{2}\\right|>\\delta_k$ ] .",
    "@xmath42    suppose @xmath41 makes a total of @xmath318 @xmath66-queries .",
    "we next calculate the probability that @xmath316 does not abort during the simulation .",
    "the probability that @xmath316 does not abort for * extract * queries is @xmath384 .",
    "the probability that @xmath316 does not abort for * corrupt * queries is @xmath384 .",
    "the probability that @xmath316 does not abort for * test * queries is @xmath385 .",
    "therefore , the probability that @xmath316 does not abort during the simulation is @xmath386 .",
    "this shows that @xmath316 s advantage in distinguishing the distributions @xmath126 and @xmath124 in lemma [ feedbackbdh ] is at least @xmath317 which is non - negligible .    to complete the proof of theorem [ securityprooftheorem ]",
    ", it remains to show that the communications between @xmath316 and the challenger are carried out according to the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ] . for a @xmath387 query ,",
    "the challenger outputs @xmath388 to the algorithm @xmath316 .",
    "let @xmath389 , @xmath390 , and @xmath391 .",
    "then @xmath260 is chosen uniform at random from @xmath212 , @xmath158 is chosen uniform at random from @xmath39 when @xmath392 or @xmath393 when @xmath378 , and the value of @xmath178 is chosen by the algorithm @xmath41 or by the algorithm @xmath316 or by the challenger in probabilistic polynomial time according to the current views .",
    "for example , if @xmath178 is chosen by the algorithm @xmath41 , then @xmath41 may generate @xmath178 as the combination ( e.g. , multiplication ) of some previously observed messages / values or generate it randomly .",
    "thus the communication between the challenger and the algorithm @xmath316 during @xmath387 queries is carried out according to the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ] . the case for @xmath394 queries",
    "is the same .",
    "for the * test*@xmath395 query , the challenger outputs @xmath382 to the algorithm @xmath316 , where @xmath396 and @xmath397 .",
    "let @xmath398 and @xmath399 .",
    "then @xmath301 is chosen uniform at random from @xmath212 and the value of @xmath179 is chosen by the algorithm @xmath41 or by the challenger in probabilistic polynomial time according to the current views .",
    "similarly , @xmath41 may choose @xmath179 as the combination ( e.g. , multiplication ) of some previously observed messages / values .",
    "the communication between the challenger and the algorithm @xmath316 during the @xmath400 query is carried out according to the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ] .",
    "it should be noted that after the * test*@xmath395 query , the adversary may create bogus oracles for the participants @xmath401 and @xmath402 and send bogus messages that may depend on all existing communicated messages ( including messages held by the oracle @xmath403 ) and then reveal session keys from these oracles .",
    "in particular , the adversary may play a man in the middle attack by modifying the messages sent from @xmath403 to @xmath404 and modifying the messages sent from @xmath404 to @xmath403 .",
    "then the oracles @xmath404 and @xmath403 are not matching oracles .",
    "thus @xmath41 can reveal the session key held by the oracle @xmath404 before the guess . in the @xmath192 part in the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ]",
    ", we have the condition `` @xmath405 or @xmath197 '' ( this condition holds since the algorithm @xmath41 has not revealed the matching oracles for @xmath403 ) .",
    "if both @xmath405 and @xmath197 , then the oracle @xmath404 is a matching oracle for @xmath403 and @xmath41 is not allowed to reveal the session key held by the oracle @xmath404 .",
    "thus the communication between the challenger and the algorithm @xmath316 during these @xmath400 query is carried out according to the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ] .    in the summary ,",
    "all communications between the challenger and @xmath316 are carried out according to the distributions @xmath126 and @xmath124 of lemma [ feedbackbdh ] .",
    "this completes the proof of the theorem .",
    "* @xmath67 is a random oracle ( secure hash function ) from @xmath68 to @xmath406 ( e.g. , @xmath407 ) . *",
    "if @xmath408 are points on an elliptic curve , then let @xmath409 where @xmath410 .",
    "that is , @xmath411 is the exclusive - or of the second half parts of the first coordinates of the elliptic curve points @xmath412 and @xmath413 .",
    "* @xmath67 is a random oracle that the output only depends on the the first input variable or any of the above function restricted in such a way that the output only depends on the the first input variable . in another word , @xmath414 .",
    "it should be noted any @xmath67 function , for which lemma [ feedbackbdh ] holds , can be used in the idak protocol .",
    "though we do not know whether lemma [ feedbackbdh ] holds for @xmath67 functions that we have listed above , we have strong evidence that this is true .",
    "first , if we assume that the group @xmath415 is a generic group in the sense of nechaev @xcite and shoup @xcite . then we can prove that lemma [ feedbackbdh ] holds for the above @xmath67 functions .",
    "secondly , if the distribution @xmath416 in lemma [ feedbackbdh ] is restricted to the distribution : @xmath417 then we can prove that lemma [ feedbackbdh ] holds for the above @xmath67 functions .",
    "we may conjecture that the adversary algorithm @xmath41 can only generate @xmath178 and @xmath179 according to the above distribution unless cdh - assumption fails for @xmath4 .",
    "thus , under this conjecture ( without the condition that @xmath415 is a generic group ) , the above list of @xmath67 functions can be used in idak protocol securely .",
    "our analysis in this section will be based on the assumption that @xmath67 is a random oracle ( secure hash function ) from @xmath68 to @xmath69 . since the computational cost for alice is the same as that for bob . in the following",
    ", we will only analyze alice s computation .",
    "first , alice needs to choose a random number @xmath260 and compute @xmath418 in the group @xmath4 .",
    "in order for alice to compute @xmath419 , she needs to do @xmath420 exponentiation in @xmath4 , one multiplication in @xmath4 , and one pairing .",
    "thus in total , she needs to do @xmath421 exponentiation in @xmath4 , one multiplication in @xmath4 , and one pairing .",
    "alternatively , alice can compute the shared secret as @xmath422 .",
    "thus for the entire idak protocol , alice needs to do @xmath420 exponentiation in @xmath4 ( one for @xmath418 and @xmath423 for @xmath424 ) , one multiplication in @xmath4 , one pairing , and one exponentiation in @xmath5 .",
    "the idak protocol could be sped up by letting each participant do some pre - computation .",
    "for example , alice can compute the values of @xmath418 and @xmath425 before the protocol session . during the idak session",
    ", alice can compute the shared secret as @xmath426 which needs @xmath427 exponentiation in @xmath4 ( @xmath423 for @xmath424 and @xmath423 for @xmath428 ) , @xmath429 multiplications in @xmath4 , and one pairing .",
    "alternatively , alice can compute the shared secret as @xmath430 which needs @xmath423 exponentiation in @xmath4 , one multiplication in @xmath4 , one pairing , and one exponentiation in @xmath5 . in a summary ,",
    "figure [ performancefigure ] lists the computational cost for alice ( an analysis of all other identity based key agreement protocols shows idak is the most efficient one , details will be given in the final version of this paper ) ."
  ],
  "abstract_text": [
    "<S> several identity based and implicitly authenticated key agreement protocols have been proposed in recent years and none of them has achieved all required security properties . in this paper , we propose an efficient identity - based and authenticated key agreement protocol idak using weil / tate pairing . </S>",
    "<S> the security of idak is proved in bellare - rogaway model . </S>",
    "<S> several required properties for key agreement protocols are not implied by the bellare - rogaway model . </S>",
    "<S> we proved these properties for idak separately . </S>"
  ]
}