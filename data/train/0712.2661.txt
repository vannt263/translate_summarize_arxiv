{
  "article_text": [
    "a set @xmath0 of vertices of an acyclic digraph @xmath1 is _ convex _ if @xmath13 and there is no directed path between vertices of @xmath0 which contains a vertex not in @xmath0 .",
    "a set @xmath0 is _ connected _ if @xmath13 and the underlying undirected graph of the subgraph of @xmath1 induced by @xmath0 is connected .",
    "a set is _ connected convex _ ( a _ cc - set _ ) if it is both connected and convex .    in section [ ccsec ] , we introduce and study an algorithm @xmath3 for generating all connected convex sets of a connected acyclic digraph @xmath1 of order @xmath4 .",
    "the running time of @xmath3 is @xmath5 , where @xmath6 is the number of connected convex sets in @xmath1 .",
    "thus , the algorithm is ( almost ) optimal with respect to its time complexity .",
    "interestingly , to generate only @xmath14 cc - sets using @xmath3 we need @xmath15 time . in section [ expersec ] ,",
    "we give experimental results demonstrating that the algorithm is practical on reasonably large data dependency graphs for basic blocks generated from target code produced by trimaran  @xcite and simplescalar  @xcite .",
    "our experiments show that @xmath3 is better than the state - of - the - art algorithm of chen , maskell and sun @xcite .",
    "moreover , unlike the algorithm in @xcite , our algorithm has a provable ( almost ) optimal worst time complexity .",
    "although such algorithms are of less importance in our application area because of wider scheduling issues , there also exist algorithms that enumerate all of the convex sets of an acyclic graph . until recently the algorithm of choice for this problem was that of atasu , pozzi and ienne  @xcite",
    ", however the cms algorithm  @xcite ( run in general mode ) outperforms the api algorithm in most cases . in section",
    "[ all ] , we give a different algorithm , for enumeration of all the convex sets of an acyclic digraph , which significantly outperforms the cms and api algorithms and which has a ( optimal ) runtime performance of the order of the sum of the sizes of the convex sets .",
    "avis and fukuda @xcite designed an algorithm for generating all connected sets in a connected graph @xmath7 of order @xmath4 and size @xmath12 with time complexity @xmath11 and space complexity @xmath16 , where @xmath9 is the number of connected sets in @xmath7 .",
    "observe that when @xmath7 is bipartite there is an orientation @xmath1 of @xmath7 such that every connected set of @xmath7 corresponds to a cc - set of @xmath1 and vice versa . to obtain @xmath1 orient every edge of @xmath7 from @xmath0 to @xmath17 , where @xmath0 and @xmath17 are the partition classes of @xmath7 .",
    "the algorithm of avis and fukuda is based on a so - called reverse search . applying the approach used to design the algorithm @xmath3 to connected set enumeration , in section [ consec ]",
    ", we describe an algorithm @xmath18 for generating all connected sets in a connected graph @xmath7 of order @xmath4 with much better time complexity , @xmath19 .",
    "this demonstrates that our approach can be applied with success to various vertex set / subgraph enumeration problems .",
    "the space complexity of our algorithm matches that of the algorithm of avis and fukuda .",
    "there is an immediate application for @xmath3 in the field of so - called _ custom computing _ in which central processor architectures are parameterized for particular applications .",
    "an embedded or _",
    "application specific _ computing system only ever executes a single application .",
    "examples include automobile engine management systems , satellite and aerospace control systems and the signal processing parts of mobile cellular phones .",
    "significant improvements in the price - performance ratio of such systems can be achieved if the instruction set of the application specific processor is specifically tuned to the application .",
    "this approach has become practical because many modern integrated circuit implementations are based on field programmable gate arrays ( fpga ) .",
    "an fpga comprises an array of logic elements and a programmable routing system , which allows detailed design of logic interconnection to be performed directly by the customer , rather than a complete ( and very high cost ) custom integrated circuit having to be produced for each application . in extreme cases ,",
    "the internal logic of the fpga can even be modified whilst in operation .",
    "suppliers of embedded processor architectures are now delivering _",
    "extensible _ versions of their general purpose processors .",
    "examples include the arm optimode  @xcite , the mips pro series  @xcite and the tensilica xtensa  @xcite .",
    "the intention is that these architectures be implemented either as traditional logic with an accompanying fpga containing the hardware for extension instructions , or be completely implemented within a large fpga . by this",
    "means , hardware development has achieved a new level of flexibility , but sophisticated design tools are required to exploit its potential .    the goal of such tools is the identification of time critical or commonly occurring patterns of computation that could be directly implemented in custom hardware , giving both faster execution and reduced program size , because a sequence of base machine instructions is being replaced by a single custom _ extension _ instruction .",
    "for example , a program solving simultaneous linear equations may find it useful to have a single instruction to perform matrix inversion on a set of values held in registers .",
    "the approach proceeds by first locating the _ basic blocks _ of the program , regions of sequential computation with no control transfers into them . for each basic block",
    "we construct a _ data dependency graph _ ( ddg ) which contains vertices for each base ( unextended ) instruction in the block , along with a vertex for each initial input datum .",
    "figure  [ ddg ] shows an example of a ddg .",
    "there is an arc to the vertex for the instruction @xmath20 from each vertex whose instruction computes an input operand of @xmath20 .",
    "ddg s are acyclic because execution within a basic block is by definition sequential .",
    "( 88,66)(0,0 ) ( 2,62)(11,4)[cc]var : a ( 17,62)(11,4)[cc]var : c ( 32,62)(11,4)[cc]int:4 ( 61,62)(11,4)[cc]var : b ( 70,26)(11,4)[cc]root ( 15,27)(11,4)[cc]int:2 ( 10,53)(9,4)[cc]mul ( 22,45)(9,4)[cc]mul ( 10,11)(9,4)[cc]mul ( 53,34)(9,4)[cc]sub ( 70,47)(9,4)[cc]mul ( 66,11)(9,4)[cc]add ( 41,26)(9,4)[cc]neg ( 36,0)(9,4)[cc]dvi ( 13,57)(4,-3)0(7,62)(.04026846,-.03355705)149(1,0).04026846 ( 16,57)(-4,-3)0(23,62)(-.04697987,-.03355705)149(-1,0).04697987 ( 25,49)(3,-1)0(14,53)(.09243697,-.03361345)119(1,0).09243697 ( 28,49)(-2,-3)0(37,62)(-.033707865,-.048689139)267(0,-1).048689139 ( 13,15)(1,-4)0(7,62)(.03370787,-.26404494)178(0,-1).26404494 ( 42,4)(-4,-1)0(71,11)(-.13942308,-.03365385)208(-1,0).13942308 ( 39,4)(4,-1)0(14,11)(.12019231,-.03365385)208(1,0).12019231 ( 76,51)(0,-1)0(67,62)(76.5,59.5)(76,51 ) ( 72,51)(1,-1)0(67,62)(66.5,55.5)(72,51 ) ( 58,38)(-2,-1)0(75,47)(-.063670412,-.033707865)267(-1,0).063670412 ( 27,45)(4,-1)28 ( 75,30)(4,-1)0(58,34)(.14285714,-.03361345)119(1,0).14285714 ( 72,15)(-1,-3)0(76,26)(-.03361345,-.09243697)119(0,-1).09243697 ( 69,15)(2,-1)0(46,26)(.070336391,-.033639144)327(1,0).070336391 ( 46,30)(-2,-3)0(67,62)(-.033707865,-.051364366)623(0,-1).051364366 ( 16,15)(-1,-2)0(21,27)(-.03355705,-.08053691)149(0,-1).08053691 ( 66,22)(19,33)[cc ] ( 65.93,21.93)(.95,0)21    ' '' ''    ( 65.93,54.93)(.95,0)21    ' '' ''    ( 65.93,54.93)(0,-.97059)35    ' '' ''    ( 84.93,54.93)(0,-.97059)35    ' '' ''    ( 6,7)(73,12)[cc ] ( 5.93,6.93)(.98649,0)75    ' '' ''    ( 5.93,18.93)(.98649,0)75    ' '' ''    ( 5.93,18.93)(0,-.9231)14    ' '' ''    ( 78.93,18.93)(0,-.9231)14    ' '' ''    ( 6,43)(29,16)[cc ] ( 5.93,42.93)(.9667,0)31    ' '' ''    ( 5.93,58.93)(.9667,0)31    ' '' ''    ( 5.93,58.93)(0,-.9412)18    ' '' ''    ( 34.93,58.93)(0,-.9412)18    ' '' ''    ( 4,55)(0,0)[cc]*a * ( 88,51)(0,0)[cc]*c * ( 4,15)(0,0)[cc]*b *    extension instructions are combinations of base machine instructions and are represented by sets of the ddg . in figure",
    "[ ddg ] , sections a and b are convex sets that represent candidate extension instructions .",
    "however , section b is not connected .",
    "if such a region were implemented as a single extension instruction we should have separate independent hardware units within the instruction .",
    "although this presents no special difficulties , and in section  [ all ] we give an optimal algorithm for constructing all such sets , present engineering practice is to restrict the search to connected convex components on the grounds that unconnected convex components are composed of connected ones , and that the system s code scheduler will perform better if it is allowed to arrange the independent computations in different ways at different points in the program .    unlike connectivity however , convexity is not optional .",
    "an extension instruction can not perform computations that depend on instructions external to the extension instruction .",
    "this means that there can be no data flows out of and then back into the extension instruction : the set corresponding to an extension instruction must be convex .",
    "thus section c in figure  [ ddg ] does not represent a candidate extension instruction since it breaches the ` no external computation rule ' because it is non - convex : there is a path _ via _ the sub node that is not in the set .",
    "ideally we would like to fully consider all possible candidate instructions and select the combination which results in the most efficient implementation . in practice",
    "this is unlikely to be feasible as , in worst case , the number of candidates will be exponential in the number of original program instructions .",
    "however , it is useful to have a process which can find all the potential instructions , even if the set of instructions used for final consideration has to be restricted . in this work we only deal with generation of a set of possible candidate instructions .",
    "interested readers can refer to  @xcite .",
    "many other algorithms for special vertex set / subgraph generation have been studied in the literature .",
    "kreher and stinson @xcite describe an algorithm for generating all cliques in a graph @xmath7 of order @xmath4 with running time @xmath21 , where @xmath22 is the number of cliques in @xmath10    several algorithms have been suggested for the generation of all spanning trees in a connected graph @xmath7 of order @xmath4 and size @xmath12 .",
    "let @xmath23 be the number of spanning trees in @xmath7 .",
    "the first spanning trees generating algorithms @xcite used backtracking which is useful for enumerating various kinds of subgraphs such as paths and cycles . using the algorithms from @xcite , gabow and myers @xcite suggested an algorithm with time complexity @xmath24 and space complexity @xmath16 .",
    "if we output all spanning trees by their edges , this algorithm is optimal in terms of time and space complexities .",
    "later algorithms of a different type were developed ; these algorithms ( see , e.g. , @xcite ) find a new spanning tree by exchanging a pair of edges . as a result ,",
    "the algorithms of kapoor and ramesh @xcite and shioura and tamura @xcite require only @xmath25 time and @xmath26 space .",
    "the algorithm of shioura , tamura and uno @xcite is of the same optimal running time , but also of optimal space : @xmath27    an out - tree is an orientation of a tree such that all vertices but one are of in - degree 1 .",
    "kapoor , kumar and ramesh @xcite presented an algorithm for enumerating all spanning out - trees of a digraph with @xmath4 vertices , @xmath12 arcs and @xmath23 spanning out - trees .",
    "the algorithm takes @xmath28 time per spanning tree ; more precisely , it runs in @xmath29 , where @xmath30 is the inverse ackermann function .",
    "it first outputs a single spanning out - tree and then a list of arc swaps ; each spanning out - tree can be generated from the first spanning out - tree by applying a prefix of this sequence of arc swaps .",
    "let @xmath1 be a digraph .",
    "if @xmath31 is an arc of @xmath1 ( @xmath32 ) , we say that @xmath33 is an _ out - neighbor _ of @xmath34 and @xmath34 is an _ in - neighbor _ of @xmath33 .",
    "the set of out - neighbors of @xmath34 is denoted by @xmath35 and the set of in - neighbors of @xmath34 is denoted by @xmath36 . for a set @xmath0 of vertices of @xmath1 , its _ out - neighborhood _ ( resp .  _ in - neighborhood _ ) is @xmath37 ( resp .",
    "@xmath38 ) .",
    "a digraph @xmath39 is called the _ transitive closure _ of @xmath1 if @xmath40 and a vertex @xmath34 is an in - neighbor of a vertex @xmath33 in @xmath39 if and only if there is a path from @xmath34 to @xmath33 in @xmath41    let @xmath42 be a non - empty set of vertices of a digraph @xmath1 . a directed path @xmath43 of @xmath1 is an @xmath42-_path _ if @xmath43 has at least three vertices , its initial and terminal vertices are in @xmath42 and the rest of the vertices are not in @xmath44 for a digraph @xmath1 , @xmath45 ( @xmath46 ) denotes the collection of cc - sets ( convex sets ) in @xmath47 @xmath48 and @xmath49 an ordering @xmath50 of vertices of an acyclic digraph @xmath1 is called _ acyclic _ if for every arc @xmath51 of @xmath1 we have @xmath52 .    [ lemma_transitive ]",
    "let @xmath1 be a connected acyclic digraph and let @xmath42 be a vertex set in @xmath1 .",
    "then @xmath42 is a cc - set in @xmath1 if and only if it is a cc - set in @xmath39 .",
    "let @xmath42 be a set of vertices of @xmath1 .",
    "we will first prove that there is an @xmath42-path in @xmath1 if and only if there is an @xmath42-path in @xmath53 since all arcs of @xmath1 are in @xmath39 , every @xmath42-path in @xmath1 is an @xmath42-path in @xmath53 let @xmath54 be an @xmath42-path in @xmath39 .",
    "then there are paths @xmath55 such that @xmath56 is a path in @xmath1 ( @xmath57 must be a path since @xmath1 is acyclic ) .",
    "since @xmath58 and @xmath59 belong to @xmath42 and @xmath60 does not belong to @xmath42 , there is a subpath of @xmath57 which is an @xmath42-path .",
    "if @xmath42 is connected in @xmath1 then it is clearly connected in @xmath39 , which implies that if @xmath42 is a cc - set in @xmath1 then it is a cc - set in @xmath39 .",
    "now let @xmath42 be a cc - set in @xmath39 .",
    "assume that @xmath61 $ ] is not connected and let @xmath34 and @xmath33 be vertices in different connected components in @xmath61 $ ] , but which are connected by an arc in @xmath39 . without loss of generality",
    "@xmath31 is the arc in @xmath39 and @xmath62 is a path from @xmath34 to @xmath33 in @xmath1 .",
    "however as @xmath42 is convex all vertices in @xmath62 also belong to @xmath42 and therefore @xmath34 and @xmath33 belong to the same connected component in @xmath61 $ ] , a contradiction .",
    "it is well - known ( see , e.g. , the paper @xcite by fisher and meyer , or @xcite by furman ) that the transitive closure problem and the matrix multiplication problem are closely related : there exists an @xmath63-algorithm , with @xmath64 , to compute the transitive closure of a digraph of order @xmath4 if and only if the product of two boolean @xmath65 matrices can be computed in @xmath63 time .",
    "coppersmith and winograd @xcite showed that there exists an @xmath66-algorithm for the matrix multiplication .",
    "thus , we have the following :    [ remtr ] the transitive closure of a digraph of order @xmath4 can be found in @xmath66 time .",
    "we will need the following two results proved in @xcite .",
    "[ lower_bound ] for every connected acyclic digraph @xmath1 of order @xmath4 , @xmath67 . if an acyclic digraph @xmath1 of order @xmath4 has a hamiltonian path , then @xmath68 .    [ upper_bound ]",
    "let @xmath69 , where @xmath70 for every even @xmath4 and @xmath71 for every odd @xmath4 .",
    "for every connected acyclic digraph @xmath1 of order @xmath4 , @xmath72 let @xmath73 denote the digraph obtained from the complete bipartite graph @xmath74 by orienting every edge from the partite set of cardinality @xmath75 to the partite set of cardinality @xmath76 we have @xmath77 provided @xmath78 .",
    "in this section @xmath1 denotes a connected acyclic digraph of order @xmath4 and size @xmath12 .",
    "now we describe the main algorithm of this paper ; we denote it by @xmath79 .",
    "the input of @xmath79 is @xmath1 and @xmath80 outputs all cc - sets of @xmath1 . the formal description of @xmath79 is followed by an example and proofs of correctness of @xmath79 and its complexity . finally , we show that to produce @xmath14 cc - sets @xmath3 requires @xmath81 time .",
    "the algorithm works as follows .",
    "given a digraph @xmath1 on @xmath4 vertices , it considers an acyclic ordering @xmath82 of the transitive closure of @xmath1 . for each vertex",
    "@xmath83 we consider the sets @xmath84 and @xmath85 and call the subroutine @xmath86 which finds all cc - sets @xmath42 in @xmath1 such that @xmath87 . at each step , if possible @xmath86 removes an element @xmath88 from @xmath17 and adds it to @xmath0 .",
    "if @xmath0 has out - neighbors we choose @xmath88 to be the ` largest ' out - neighbor in the acyclic ordering(line 3 ) , otherwise if @xmath0 has in - neighbors we choose @xmath88 to be the ` smallest ' in - neighbor ( line 8) .",
    "then we find the other vertices required to maintain convexity ( line 4 or line 9 ) . if there are no in- or out - neighbors we output @xmath0 , otherwise we find find all the cc - sets such that @xmath89 and @xmath90 ( line 12 ) and then all the cc - sets such that @xmath91 and @xmath92 ( line 13 ) .",
    "step 1 : : :    find the transitive closure of @xmath1 and set    @xmath93 step 2 : : :    find an acyclic ordering @xmath94 of    @xmath1 .",
    "step 3 : : :    for each @xmath95 do the following . set    @xmath96 ,    @xmath97 and",
    "call    @xmath86 .",
    "step 4 subroutine @xmath86 : : :     +    before proving the correctness of @xmath3 , we consider an example .",
    "let @xmath1 be the graph on the left below    in step 1 , we find @xmath98 ( above right ) .",
    "observe that @xmath99 is an acyclic ordering .",
    "we may assume that this is the ordering found in step 2 .",
    "for @xmath100 in step 3 , we have @xmath101 and @xmath102 , and we call @xmath103",
    ". then in step 4 , line 1 , we compute @xmath104 and then , lines 3 and 4 , obtain @xmath105 , @xmath106 and @xmath107 .",
    "then , at line 12 , we make a recursive call to @xmath108 . in this call",
    "we have @xmath109 so , at line 10 , the set @xmath110 is output and the recursive call returns , to line 13 of @xmath111 , where we make a call to @xmath112 .",
    "we are now effectively looking at the graph @xmath113 below .    in step 4 , lines 1 - 4 ,",
    "we compute @xmath114 and obtain @xmath115 , @xmath116 and @xmath117 . at lines 12 and 13",
    "we make recursive calls to @xmath118 and @xmath119 respectively .    in the call to @xmath120 ,",
    "lines 1 - 4 , we obtain @xmath121 and @xmath122 .",
    "this in turn generates calls to @xmath123 , which just outputs @xmath124 and returns , and @xmath125 .",
    "the latter call generates calls to @xmath126 and @xmath127 , which output @xmath128 and @xmath129 , respectively .    in the call to @xmath119 ,",
    "where we are effectively looking at @xmath130 above , we obtain @xmath121 and @xmath122 .",
    "this in turn generates calls to @xmath131 , which just outputs @xmath132 and returns , and @xmath133 ( graph @xmath134 above ) .",
    "the latter call generates calls to @xmath135 and @xmath136 , which output @xmath137 and @xmath138 , respectively .",
    "this completes the case @xmath100 in step 3 , and all the cc - sets containing @xmath139 have been output .",
    "now we perform step 3 with @xmath140 , effectively looking at the graph @xmath141 .",
    "the call to @xmath142 generates further recursive calls in the following order + @xmath143 + @xmath144 , output @xmath145 + @xmath146 , output @xmath147 + @xmath148 + @xmath149 , output @xmath150 + @xmath151 , output @xmath152 .",
    "+ thus all the cc - sets containing @xmath153 but not @xmath139 are output .",
    "performing step 3 again with @xmath154 , effectively looking at the graph @xmath155 above , the call to @xmath156 , generates the following recursive calls + @xmath157 + @xmath158 , output @xmath159 + @xmath160 , output @xmath161 + @xmath162 , output @xmath163 + which ouput all the cc - sets containing @xmath164 but not @xmath139 or @xmath153 .    for the case @xmath165 in step 3",
    "we get the following calls + @xmath166 + @xmath167 , output @xmath168 + @xmath169 , output @xmath170 + and for @xmath171 we get + @xmath172 , output @xmath173 + after which @xmath3 terminates .    [ corlem ] algorithm @xmath3 correctly outputs all cc - sets of @xmath1 .",
    "recall , the convex ( connected ) sets of @xmath1 are precisely the convex ( connected ) sets of @xmath39 .",
    "we prove the result for @xmath39 .",
    "firstly we show that all the sets @xmath0 output by @xmath3 are in @xmath174 .",
    "we will show that within @xmath3 , for any call @xmath86 we have that @xmath175 , @xmath176 is convex and @xmath0 is a cc - set .",
    "this is clearly sufficient as @xmath0 is the only set output .",
    "these properties hold for step 3 when @xmath177 is called as we have chosen an acyclic ordering of the vertices .",
    "thus we assume that the properties hold for the sets @xmath0 , @xmath17 and consider the pairs of sets @xmath178 , @xmath179 and @xmath0 , @xmath180 constructed in @xmath86 . in both cases",
    "clearly the intersections are empty , and since @xmath181 , @xmath178 is connected .",
    "now we will prove that @xmath178 is convex .",
    "suppose that there is a path @xmath182 where @xmath183 .",
    "note that if there exists an @xmath184-path then by transitivity of @xmath39 there exists an @xmath184-path of length two . by convexity of @xmath176",
    "we have @xmath185 . also , @xmath186 as we have chosen @xmath88 to be either the maximal element of @xmath187 or the minimal element of @xmath188 , and @xmath39 is transitive and thus the presence of the arcs @xmath189 and @xmath190 implies the presence of the arc @xmath191 assume that @xmath192 . then @xmath193 .",
    "since @xmath194 and the arc @xmath189 exists , the transitivity of @xmath39 implies that @xmath195 . since @xmath0 is convex it follows that not both vertices @xmath196 can be in @xmath0 and that there is no arc from @xmath187 to @xmath0 .",
    "thus @xmath197 and so @xmath198 . by the transitivity of @xmath39 and",
    "the fact that @xmath190 exists and that @xmath199 we have @xmath200 and thus @xmath201 . similarly if @xmath202 then @xmath203 and by the transitivity of @xmath39 and since @xmath204 we have @xmath205 and thus @xmath206 .",
    "secondly we show that if @xmath207 is cc then @xmath0 is output by @xmath3 . if @xmath42 is a cc - set and @xmath208 then @xmath209 .",
    "thus it is sufficient to show that if @xmath42 is cc and @xmath210 then @xmath86 outputs @xmath42 .",
    "we prove this by induction on @xmath211 .    if @xmath212 then , since @xmath42 is connected , @xmath213 and @xmath86 outputs @xmath0 at line 10 .",
    "this proves the result for @xmath214 , and for @xmath215 we may assume that @xmath216 .    if @xmath92 then we have @xmath217 and @xmath218 , so by induction the call to @xmath219 at line 13 outputs @xmath42 . if @xmath220 , we have arcs @xmath221 and @xmath222 , for some @xmath223 . thus , if @xmath90 , by convexity of @xmath42 we have @xmath224 . then , since @xmath225 , the call to @xmath226 at line 12 outputs @xmath42 .    [ runtlem ] the running time of @xmath3 is @xmath227    note that by theorem [ lower_bound ] and the fact that @xmath1 is connected we have @xmath228 .",
    "therefore the transitive closure of @xmath1 can be found in @xmath229 time , by theorem [ remtr ] .",
    "it is well - known that an acyclic ordering can be found in time @xmath16 , see , e.g. , @xcite , and clearly the sets @xmath230 and @xmath231 can be computed at the start of the algorithm in @xmath232 time , for each @xmath233 .",
    "we will now show that @xmath86 runs in time @xmath234 , where @xmath235 is the number of cc - sets @xmath42 such that @xmath87 and @xmath236 is the sum of the sizes of the sets @xmath42 .",
    "note that @xmath237 returns at line 10 or makes two recursive calls to @xmath237 ( lines 12,13 ) .",
    "if @xmath237 returns at line 10 then we call this a _ leaf _ call otherwise the function call is an _ internal _ call .",
    "all function calls can be viewed as nodes of a binary tree ( every node is a leaf or has two children ) whose leaves and internal nodes correspond to calls to @xmath238 .",
    "it is easy to see , by induction , that the number of internal nodes equals the number of leaves minus one .",
    "it is easy to see , by induction on the depth of the call tree , that @xmath237 outputs each set @xmath42 only once ( @xmath226 and @xmath219 output those that contain @xmath88 and do not contain @xmath88 , respectively ) .",
    "thus we have @xmath235 leaf calls and @xmath239 internal calls .",
    "we assume that the set implementation allows us to find the size of a set and the largest and smallest elements of the set in unit time . then the time taken by a call @xmath86 depends on the time taken to calculate the sets @xmath240 , @xmath241 and @xmath242 .",
    "since @xmath243 , the time to compute @xmath242 is at most @xmath244 .",
    "if we implement @xmath245 so that @xmath246 and @xmath188 are passed in as parameters then the time taken to calculate @xmath240 and @xmath241 is at most @xmath244 . by definition of @xmath242",
    "we have that @xmath247 and @xmath248 provided @xmath249 , and @xmath250 and @xmath251 provided @xmath202 ( and @xmath252 ) .",
    "since @xmath253 , these sets can be computed in @xmath244 time .",
    "if @xmath86 calls @xmath254 then @xmath255 thus a call to @xmath237 at an internal node takes at most @xmath244 time , and a call at a leaf node takes at most @xmath256 time , giving the desired total time bound of @xmath257 .",
    "we let @xmath258 denote the sum of the sizes of all the cc - sets @xmath42 such that @xmath259 , and observe that @xmath260 .    finally , by step 3 , we conclude that the total running time is @xmath261    [ maint ] algorithm @xmath3 is correct and its time and space complexities are @xmath262 and @xmath263 , respectively .",
    "the correctness and time complexity follows from the two lemmas above .",
    "the space complexity is dominated by the space complexity of step 1 , @xmath264    since @xmath6 may well be exponential , we may wish to generate only a restricted number @xmath14 of cc - sets .",
    "theorem [ kccsets ] can be viewed as a result in fixed - parameter algorithmics @xcite with @xmath14 being a parameter .",
    "[ kccsets ] to output @xmath14 cc - sets the algorithm @xmath3 requires @xmath81 time .",
    "we may assume that @xmath14 is at most the number of cc - sets containing vertex @xmath139 since otherwise the proof is analogous .",
    "we consider the binary tree @xmath265 introduced in the proof of lemma [ runtlem ] and prove our claim by induction on @xmath14 .",
    "it takes @xmath66 time to perform steps 1,2 and 3 .",
    "it takes @xmath232 internal nodes of @xmath265 to reach the first leaf of @xmath265 and , thus , for @xmath266 we obtain @xmath267 time .",
    "assume that @xmath268 .",
    "let @xmath34 be the first leaf of @xmath265 reached by @xmath3 , let @xmath33 be the parent of @xmath34 on @xmath265 , let @xmath269 be another child of @xmath33 on @xmath265 and let @xmath20 be the parent of @xmath33 .",
    "observe that after deleting the nodes @xmath34 and @xmath33 and adding an edge between @xmath20 and @xmath269 , we obtain a new binary tree @xmath270 . by induction hypothesis , to reach the first @xmath271 leaves in @xmath270 , we need @xmath272 time . to reach the first @xmath14 leaves in @xmath265",
    ", we need to reach @xmath34 and the first @xmath271 leaves in @xmath270 .",
    "thus , we need to add to @xmath272 the time required to visit @xmath34 and @xmath33 only , which is @xmath273 thus , we have proved the desired bound @xmath81 .",
    "it is not hard to modify @xmath3 such that the new algorithm will generate all convex sets of an acyclic digraph @xmath1 in time @xmath274 , where @xmath275 is the number of convex sets in @xmath1 .",
    "however , a faster algorithm is possible and we present one in this section .    to obtain all convex sets of @xmath1 ( and @xmath276 , which is not convex by definition ) , we call the following recursive procedure with the original digraph @xmath1 and with @xmath277 .",
    "this call yields an algorithm whose properties are studied below .",
    "a vertex @xmath34 is a _ source _ ( _ sink _ ) if it has no in - neighbors ( out - neighbors ) . in general , the procedure @xmath278   takes as input an acyclic digraph @xmath279 and a set @xmath280 and outputs all convex sets of @xmath1 which contain @xmath281 .",
    "the procedure @xmath278  outputs @xmath282 and then considers all sources and sinks of the graph that are not in @xmath281 . for each such source or sink @xmath283",
    ", we call @xmath278@xmath284 and then add @xmath283 to @xmath281 . thus ,",
    "for each sink or source @xmath285 we consider all sets that contain @xmath283 and all sets that do not contain @xmath283 .",
    "proposition [ prop : convex ] and theorem [ prop : unique ] imply that the procedure @xmath278  is correct .",
    "we first show that all sets generated in line 1 are , in fact , convex sets . to this end , we use the following lemma .",
    "[ lem : delete ] let @xmath1 be an acyclic graph , let @xmath0 be a convex set of @xmath1 , and let @xmath286 be a source or sink of @xmath287 $ ] . then @xmath288 is a convex set of @xmath1 .",
    "suppose that @xmath288 is not convex in @xmath1 .",
    "then there exist two vertices @xmath289 and a directed path @xmath43 from @xmath20 to @xmath88 which contains a vertex not in @xmath288 .",
    "since @xmath0 is convex , @xmath43 only uses vertices of @xmath0 and in particular @xmath290 .",
    "thus , there is a subpath @xmath291 of @xmath43 with @xmath292 .",
    "but since @xmath283 is a source or a sink in @xmath287 $ ] such a subpath can not exist , a contradiction .",
    "now we can prove the following proposition .",
    "[ prop : convex ] let @xmath279 be an acyclic digraph and let @xmath280 .",
    "then every set output by @xmath278(@xmath293 ) is convex .",
    "we prove the result by induction on the number of vertices of the outputted set .",
    "the entire vertex set @xmath282 is convex and is outputted by the procedure .",
    "now assume all sets of size @xmath294 that are outputted by the procedure are convex .",
    "we will show that all sets of size @xmath295 that are outputted are also convex .",
    "when a set @xmath296 is outputted the procedure @xmath278@xmath297,f')$ ] was called for some set @xmath298 .",
    "the only way @xmath278@xmath297,f')$ ] can be invoked is that there exist a set @xmath299 and a source or sink @xmath300 of @xmath301 $ ] with @xmath302 .",
    "moreover @xmath303 will be outputted by the procedure and , thus , by our assumption is convex .",
    "the result now follows from lemma  [ lem : delete ] .",
    "[ prop : unique ] let @xmath279 be an acyclic digraph and let @xmath280",
    ". then every convex set of @xmath1 containing @xmath281 is outputted exactly once by @xmath278@xmath304 .",
    "let @xmath296 be a convex set of @xmath1 containing @xmath281 .",
    "we first claim that there exist vertices @xmath305 with @xmath306 and @xmath307 is a source or sink of @xmath308 $ ] for all @xmath309 . to prove the claim we will show that for every convex set @xmath310 with @xmath311 , there exists a source or sink @xmath312 of the digraph @xmath313 $ ] .",
    "this will prove our claim as by lemma  [ lem : delete ] @xmath314 is a convex set of @xmath1 and we can repeatedly apply the claim .",
    "if there exists no arc from a vertex of @xmath296 to a vertex of @xmath315 $ ] then any source of @xmath316 is a source of @xmath313 $ ] .",
    "note that @xmath315 $ ] is an acyclic digraph and , thus , has at least one source ( and sink ) .",
    "thus we may assume that there is an arc from a vertex @xmath20 of @xmath296 to a vertex @xmath88 of @xmath316 .",
    "consider a longest path @xmath317 in @xmath315 $ ] leaving @xmath88 .",
    "observe that @xmath318 is a sink of @xmath315 $ ] and , moreover , there is no arc from @xmath318 to any vertex of @xmath296 since otherwise there would be a directed path from @xmath319 to a vertex in @xmath296 containing vertices in @xmath316 which is impossible as @xmath296 is convex .",
    "hence @xmath318 is a sink of @xmath313 $ ] and the claim is shown .    next note that a sink or source remains a sink or source when vertices are deleted .",
    "thus when @xmath278@xmath304 is executed and a source or sink @xmath283 is considered , then we distinguish the cases when @xmath320 for some @xmath321 or when this is not the case .",
    "if @xmath320 and we currently consider the digraph @xmath322 and the fixed set @xmath323 , then we follow the execution path calling @xmath278@xmath324 .",
    "otherwise we follow the execution path that adds @xmath283 to the fixed set .",
    "when the last @xmath307 is deleted , we call @xmath278@xmath297,f'')$ ] for some @xmath325 and the set @xmath296 is outputed . it remains to show that there is a unique execution path yielding @xmath296 . to see this , note that when we consider a source or sink @xmath283 then either it is deleted of moved to the fixed set @xmath281 .",
    "thus every vertex is considered at most once and then deleted or fixed .",
    "therefore each time we consider a source or sink there is a unique decision that finally yields @xmath296 .",
    "we assume that the input acyclic digraph @xmath279 is given by the two adjacency lists for each vertex , and the number of in - neighbors and out - neighbors is stored for each vertex .",
    "one can obtain this information at the beginning in @xmath16 time , where @xmath4 ( @xmath12 ) is the number of vertices ( arcs ) of the input connected acyclic digraph @xmath1 .",
    "observe that we output the vertex set of @xmath1 as one convex set .",
    "thus , it suffices to show that the running time of @xmath278@xmath304 without the recursive calls is @xmath326 .",
    "this will yield the running time @xmath327 of @xmath278  by theorem  [ prop : unique ] .",
    "since we have stored the number of in - neighbors and out - neighbors for every vertex @xmath328 , we can determine _ all _ sources and sinks in @xmath326 time .",
    "for the recursive calls of @xmath278  we delete one vertex and have to update the number of in- respectively out - neighbors of all neighbors of the deleted vertex @xmath283 .",
    "the vertex @xmath283 has at most @xmath329 neighbors and we can charge the cost of the updating information to the call of @xmath278@xmath284 . moreover we store the neighbours of @xmath283 so that we can reintroduce them after the call of @xmath278@xmath284 . moving the sinks and sources to @xmath281",
    "needs constant time for each source or sink and thus we obtain @xmath326 time in total .    in summary",
    "we initially need @xmath16 time , and then each call of @xmath278@xmath304 is charged with @xmath326 before it is called and then additionally with @xmath326 time during its execution . since we output a convex set of size @xmath326 , the total running time is @xmath330 .",
    "since @xmath331 by theorem [ lower_bound ] , the running time of @xmath278   is @xmath327 .",
    "in order to test our algorithms @xmath3 and @xmath278 for practicality we have implemented and run them on several instances of ddg s of basic blocks .",
    "we have compared our algorithm with the state - of - the - art algorithm of chen , maskell and sun @xcite ( the cms algorithm ) using their own implementation , but with the code for i / o constraint checking removed so as to ensure that their algorithm was not disadvantaged . for completeness we have also compared @xmath278  to atasu , pozzi and ienne s algorithm  @xcite ( the api06 algorithm ) .",
    "all the algorithms were coded in c++ and all experiments were carried out on a 2 x dual core amd opteron 265 1.8ghz processor with 4 gb ram , running suse linux 10.2 ( 64 bit ) .",
    "our first set of tests is based on c and c++ programs taken from the benchmark suites of mibench  @xcite and trimaran  @xcite .",
    "we compiled these benchmarks for both the trimaran ( a , b , c , d , e ) and simplescalar  @xcite ( f , g , h , i ) architectures .",
    "from here we examined the control - flow graph for each program to select a basic block within a critical loop of the program ( often this block had been unrolled to some degree to increase the potential for efficiency improvements ) .",
    "we considered basic blocks , ranging from 20 to 45 lines of low level , intermediate , code , for which we generated the ddgs .",
    "we then selected , from these ddgs , the non - trivial connected components on which to run our algorithms .",
    "we give some preference to benchmarks which suite the intended application of the research taking our test cases from security applications including benchmarks for the advanced encryption standard ( b , c ) and safety - critical software ( a , e ) .",
    "we also include a basic example from the trimaran benchmark suite : hyper ( d ) , an algorithm that performs quick sort ( f ) , part of a jpeg algorithm ( g ) , and an example from the fft benchmark in mibench containing c source code for performing discrete fast fourier transforms ( h ) . the final example is taken from the standard blowfish benchmark , an encryption algorithm .",
    "the results we have obtained are given in table  [ ri : basic ] .",
    "in the following tables nv denotes the number of vertices , ns denotes the number of generated sets , na number of arcs , ct denotes clock time in @xmath332 cpu seconds , and for the benchmark data i d identifies the benchmark .",
    "& 35 & 38 & 139,190 & 170 & 96b & 42 & 45 & 4,484,110 & 5,546 & 3,246c & 26&28&5,891&6&4d & 39&94&3,968,036&4,346&2,710e & 45&44&1,466,961&1,750&1,156f & 24&22&46,694&60&30 g & 20&19&397&0&0h & 20&21&1,916&0&0i & 43&47&10,329,762&13,146&7,210    for examples g and h both algorithms ran in almost 0 time .",
    "for the other examples , the above results demonstrate that our algorithm @xmath333 outperforms the cms algorithm .",
    "we also consider examples with worst - case numbers of cc - sets .",
    "let , as in theorem [ upper_bound ] , @xmath73 denote the digraph obtained from the complete bipartite graph @xmath74 by orienting every edge from the partite set of cardinality @xmath75 to the partite set of cardinality @xmath76 by theorem [ upper_bound ] the digraphs @xmath334 with @xmath78 have the maximum possible number of cc - sets .",
    "our experimental results for digraphs @xmath334 with @xmath78 are given in table  [ ri : max ] .",
    "again we see that @xmath333 outperforms the cms algorithm .",
    "32,400 & 30&1616 & 64 & 65,041 & 56&2317 & 72 & 130,322 & 114&6018 & 81 & 261,139 & 240&11319 & 90 & 522,722 & 540&25320 & 100 & 1,046,549 & 1,080&51321 & 110 & 2,094,102 & 2,166&1,04822 & 121 & 4,190,231 & 4,086&2,156    we have compared algorithm @xmath278  with both cms running in ` unconnected ' mode and with api06 .",
    "the examples used are the same as in table 1 , however we do not give results for examples b , d , e and i as these graphs produce an extremely large number of convex sets and as a result , do not terminate in reasonable time .",
    "the results are shown in table  [ ri : basicb ] .",
    "we can see that although cms generally out - performs api06 , there are two cases where api06 is marginally better .",
    "however , @xmath278  is consistantly three to five times faster than either of the other algorithms .",
    "( ct)&@xmath278  ( ct)a & 35 & 38 & 1,123,851 & 2,560 & 1,390 & 270c & 26&28&120,411&250&120&40f & 24&22&3,782,820&3,250&3,630&860 g & 20&19&122,111&70&120&30h & 20&21&55,083&110&110&20    for interest we have also compared api06 , cms and @xmath278  on the digraphs that have maximal numbers of cc - sets . the results are shown in table  [ ri : maxb ] . again , while cms and api06 are roughly comparable , @xmath278  is a least twice as fast as both of them .",
    "( ct)&@xmath278  ( ct)15 & 56 & 32,768 & 40&40&1016 & 64 & 65,536 & 70&70&3017 & 72 & 131,072 & 140&130&6018 & 81 & 261,144 & 320&320&13019 & 90 & 524,288 & 720&700&32020 & 100 & 1,046,575 & 1,590&1,500&71021 & 110 & 2,097,152 & 3,320&3,010&1,50022 & 121 & 4,194,304 & 7,140&6,310&3,120",
    "let @xmath7 be a connected ( undirected ) graph with vertex set @xmath335 and let @xmath7 have @xmath12 edges . for a vertex @xmath336 and a set @xmath337 , let @xmath338 and @xmath339 the following is an algorithm , @xmath18 , for generating all connected sets of @xmath7 .",
    "step 1 : : :    for each @xmath95 do the following . set    @xmath96 and    @xmath97 .",
    "initiate the set    @xmath340 as @xmath341 .",
    "step 2 ( subroutine @xmath342 ) : : :    _ comment : @xmath343 finds all connected sets    @xmath62 in @xmath1 such that    @xmath344_.    +    ( 2a ) : ; ;      if @xmath345 then return the connected set      @xmath0 ( and stop ) .",
    "( 2b ) : ; ;      if @xmath346 , then let      @xmath347 be arbitrary .",
    "( 2c ) : ; ;      _ comment : in this step we will find all connected sets      @xmath42 such that      @xmath348_. +      set @xmath349 , @xmath350 and      @xmath351 . remove @xmath88 from @xmath17      and @xmath340 , and add it to @xmath0 . for",
    "every      @xmath352 check whether @xmath20 has      an edge to @xmath88 and if it does then add it to      @xmath340 .",
    "+      make a recursive call to subroutine @xmath342",
    ".      _ comment : we consider the new @xmath0 and @xmath17_.      +      change @xmath340 , @xmath0 , and @xmath17 back      to their original state by setting @xmath353 ,      @xmath354 , and @xmath355 .",
    "( 2d ) : ; ;      _ comment : in this step we will find all connected sets      @xmath42 such that      @xmath356 and @xmath357_. remove @xmath88 from @xmath17 and remove      @xmath88 from @xmath340 .",
    "+      make a recursive call to subroutine @xmath342 .      +      change @xmath17 back to its original state by adding      @xmath88 back to @xmath17",
    ". also change      @xmath340 back to its original state by adding      @xmath88 to it .",
    "similarly to theorem [ maint ] , one can prove the following :    let @xmath9 be the number of connected sets of a connected graph @xmath7 .",
    "algorithm @xmath18 is correct and its time and space complexities are @xmath19 and @xmath16 , respectively .",
    "our computational experiments show that @xmath3 performs well and is of definite practical interest .",
    "we have tried various heuristic approaches to speed up the algorithm in practice , but all approaches were beneficial for some instances and inferior to the original algorithm for some other instances . moreover",
    ", no approach could significantly change the running time .",
    "the algorithm was developed independently from the cms algorithm .",
    "however , the two algorithms are closely related , and work continues to isolate the implementation effects that give the performance differences .    * acknowledgements .",
    "* we are grateful to the authors of @xcite for helpful discussions and for giving us access to their code allowing us to benchmark our algorithm against theirs .",
    "research of gregory gutin and anders yeo was supported in part by an epsrc grant .",
    "research of gutin was also supported in part by the ist programme of the european community , under the pascal network of excellence , ist-2002 - 506778 .",
    "m. r. guthaus , j. s. ringenberg , d. ernst , t. m. austin , t. mudge and r. b. brown , mibench : a free , commercially representative embedded benchmark suite , in _ proceedings of the wwc-4 , 2001 ieee international workshop on workload characterization _ , ( 2001 ) , 314 .",
    "l. pozzi , k. atasu and p ienne , exact and approximate algorithms for the extension of embedded processor instruction sets .",
    "_ ieee trans .",
    "on cad of integrated circuits and systems _ , * 25 * ( 2006 ) , 12091229 .",
    "p. yu and t. mitra , satisfying real - time constraints with custom instructions .",
    "_ codes+isss 05 : proceedings of the 3rd ieee / acm / ifip international conference on hardware / software codesign and system synthesis _ , acm , new york ( 2005 ) , 166171 ."
  ],
  "abstract_text": [
    "<S> a set @xmath0 of vertices of an acyclic digraph @xmath1 is convex if @xmath2 and there is no directed path between vertices of @xmath0 which contains a vertex not in @xmath0 . </S>",
    "<S> a set @xmath0 is connected if @xmath2 and the underlying undirected graph of the subgraph of @xmath1 induced by @xmath0 is connected . </S>",
    "<S> connected convex sets and convex sets of acyclic digraphs are of interest in the area of modern embedded processor technology . </S>",
    "<S> we construct an algorithm @xmath3 for enumeration of all connected convex sets of an acyclic digraph @xmath1 of order @xmath4 . </S>",
    "<S> the time complexity of @xmath3 is @xmath5 , where @xmath6 is the number of connected convex sets in @xmath1 . </S>",
    "<S> we also give an optimal algorithm for enumeration of all ( not just connected ) convex sets of an acyclic digraph @xmath1 of order @xmath4 . in computational experiments </S>",
    "<S> we demonstrate that our algorithms outperform the best algorithms in the literature .    using the same approach as for @xmath3 </S>",
    "<S> , we design an algorithm for generating all connected sets of a connected undirected graph @xmath7 . </S>",
    "<S> the complexity of the algorithm is @xmath8 where @xmath4 is the order of @xmath7 and @xmath9 is the number of connected sets of @xmath10 the previously reported algorithm for connected set enumeration is of running time @xmath11 , where @xmath12 is the number of edges in @xmath10 </S>"
  ]
}