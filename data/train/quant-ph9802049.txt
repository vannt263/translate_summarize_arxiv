{
  "article_text": [
    "the _ black - box _ model of computation arises when one is given a black - box containing an @xmath4-tuple of boolean variables @xmath5 .",
    "the box is equipped to output @xmath6 on input @xmath7 .",
    "we wish to determine some property of @xmath8 , accessing the @xmath6 only through the black - box .",
    "such a black - box access is called a _ query_.",
    "a property of @xmath8 is any boolean function that depends on @xmath8 , i.e.  a property is a function @xmath9 .",
    "we want to compute such properties using as few queries as possible .",
    "consider , for example , the case where the goal is to determine whether or not @xmath8 contains at least one 1 , so we want to compute the property @xmath10 .",
    "it is well known that the number of queries required to compute @xmath11 by any _ classical _ ( deterministic or probabilistic ) algorithm is @xmath12 .",
    "grover  @xcite discovered a remarkable _ quantum _ algorithm that , making queries in superposition , can be used to compute @xmath11 with small error probability using only @xmath13 queries .",
    "this number of queries was shown to be asymptotically optimal  .",
    "many other quantum algorithms can be naturally expressed in the black - box model , such as an algorithm due to simon  @xcite , in which one is given a function @xmath14 , which , technically , can also be viewed as a black - box @xmath15 with @xmath16 . the black - box @xmath8 satisfies a particular promise , and the goal is to determine whether or not @xmath8 satisfies some other property ( the details of the promise and properties are explained in  @xcite ) .",
    "simon s quantum algorithm is proven to yield an _ exponential _ speed - up over classical algorithms in that it makes @xmath17 queries , whereas every classical randomized algorithm for the same function must make @xmath18 queries .",
    "the promise means that the function @xmath9 is _ partial _ ; it is not defined on all @xmath19 .",
    "( in the previous example of or , the function is _ total _ ; however , the quantum speed - up is only quadratic . ) some other quantum algorithms that are naturally expressed in the black - box model are described in  .",
    "of course , _ upper bounds _ in the black - box model immediately yield upper bounds for the _ circuit description _ model in which the function @xmath8 is succinctly described as a @xmath17-sized circuit computing @xmath6 from @xmath7 . on the other hand , _ lower bounds _ in the black - box model do not imply lower bounds in the circuit model , though they can provide useful guidance , indicating what certain algorithmic approaches are capable of accomplishing .",
    "it is noteworthy that , at present , there is no known algorithm for computing @xmath11 ( i.e.  satisfiability ) in the circuit model that is significantly more efficient than using the circuit solely to make queries ( though , _ proving _ that no better algorithm exists is likely to be difficult , as it would imply @xmath20 ) .",
    "it should also be noted that the black - box complexity of a function only considers the number of queries ; it does not capture the complexity of the _ auxiliary _ computational steps that have to be performed in addition to the queries . in cases such as or , parity , majority , this auxiliary work is not significantly larger than the number of queries ; however , in some cases it may be much larger .",
    "for example , consider the case of factoring n - bit integers . the best known algorithms for this involve @xmath12 queries to determine the integer , followed by @xmath21 operations in the classical case but only @xmath22 operations in the quantum case  @xcite .",
    "thus , the number of queries is apparently not of primary importance in the case of factoring .    in this paper",
    ", we analyze the black - box complexity of several functions and classes of functions in the quantum computation setting .",
    "in particular , we show that the kind of exponential quantum speed - up that simon s algorithm achieves for a partial function can not be obtained by any quantum algorithm for any total function : at most a polynomial speed - up is possible .",
    "we also tightly characterize the quantum black - box complexity of all symmetric functions , and obtain exact bounds for functions such as and , or , parity , and majority for various error models : exact , zero - error , bounded - error .",
    "an important ingredient of our approach is a reduction that translates quantum algorithms that make @xmath0 queries into multilinear polynomials over the @xmath4 variables of degree at most @xmath23 .",
    "this is a quantum extension of the so - called polynomial method , which has been successfully applied in classical complexity theory ( see  @xcite for an overview ) .",
    "also , our polynomial relationship between the quantum and the classical complexity is analogous to earlier results by nisan  , who proved a polynomial relationship between randomized and deterministic decision tree complexity .",
    "we consider three different settings for computing @xmath2 on @xmath1 in the black - box model . in the _ exact",
    "_ setting , an algorithm is required to return @xmath24 with certainty for every @xmath8 . in the _ zero - error _",
    "setting , for every @xmath8 , an algorithm may return `` inconclusive '' with probability at most @xmath25 , but _",
    "if _ it returns an answer , this must be the correct value of @xmath24 ( algorithms in this setting are sometimes called _",
    "las vegas _",
    "algorithms ) . finally , in the _ two - sided bounded - error _ setting",
    ", for every @xmath8 , an algorithm must correctly return the answer with probability at least @xmath26 ( algorithms in this setting are sometimes called _",
    "monte carlo _ algorithms ; the @xmath26 is arbitrary ) .",
    "our main results are : to @xmath27 and @xmath28 to @xmath29 . ) also , our results remain valid if we consider _ mixed _ rather than only pure states . ]    1 .   in the black - box model ,",
    "the quantum speed - up for _ any _ total function can not be more than by a sixth - root . more specifically ,",
    "if a quantum algorithm computes @xmath2 with bounded - error probability by making @xmath0 queries , then there is a classical deterministic algorithm that computes @xmath2 exactly making at most @xmath3 queries . if @xmath2 is _ monotone _ then the classical algorithm needs at most @xmath30 queries , and if @xmath2 is _ symmetric _ then it needs at most @xmath31 queries .",
    "+ as a by - product , we also improve the polynomial relation between the _ decision tree complexity @xmath32 _ and the _ approximate degree _",
    "@xmath33 of   from @xmath34 to @xmath35 .",
    "we tightly characterize the black - box complexity of all non - constant symmetric functions as follows . in the exact or zero - error settings",
    "@xmath12 queries are necessary and sufficient , and in the bounded - error setting @xmath36 queries are necessary and sufficient , where @xmath37 @xmath2 flips value if the hamming weight of the input changes from @xmath38 to @xmath39 ( this @xmath40 is a number that is low if @xmath2 flips for inputs with hamming weight close to @xmath41  @xcite ) .",
    "this should be compared with the _ classical _ bounded - error query complexity of such functions , which is @xmath12 .",
    "thus , @xmath40 characterizes the speed - up that quantum algorithms give .",
    "+ an interesting example is the threshold@xmath42 function which is 1 iff its input @xmath8 contains at least @xmath43 1s .",
    "this has query complexity @xmath44 .",
    "3 .   for or , and , parity , majority",
    ", we obtain the bounds in the table below ( all given numbers are both necessary and sufficient ) .",
    "+ .some quantum complexities [ cols=\"<,^,^,^,^\",options=\"header \" , ]    + these results are all new , with the exception of the @xmath45-bounds for or and and in the bounded - error setting , which appear in  .",
    "the new bounds improve by polylog(@xmath4 ) factors previous lower bound results from  @xcite , which were obtained through a reduction from communication complexity .",
    "the new bounds for parity were independently obtained by farhi _",
    "et al . _",
    "+ note that lower bounds for or imply lower bounds for _ database search _",
    "( where we want to find an @xmath7 such that @xmath46 , if one exists ) , so exact or zero - error quantum search requires @xmath4 queries , in contrast to @xmath45 queries for the bounded - error case .",
    "our main goal in this paper is to find the number of queries a quantum algorithm needs to compute some boolean function by relating such networks to polynomials . in this section",
    "we give some basic definitions and properties of multilinear polynomials and boolean functions , and describe our quantum setting .",
    "we assume the following setting , mainly adapted from  .",
    "we have a vector of @xmath4 boolean variables @xmath15 , and we want to compute a boolean function @xmath47 of @xmath8 . unless explicitly stated otherwise , @xmath2 will always be total .",
    "the hamming weight ( number of 1s ) of @xmath8 is denoted by @xmath48 . for convenience",
    "we will assume @xmath4 even , unless explicitly stated otherwise .",
    "we can represent boolean functions using @xmath4-variate polynomials @xmath49 .",
    "since @xmath50 whenever @xmath51 , we can restrict attention to _ multilinear _ @xmath52 .",
    "if @xmath53 for all @xmath54 , then we say @xmath52 _ represents _ @xmath2 .",
    "we use @xmath55 to denote the degree of a minimum - degree @xmath52 that represents @xmath2 ( actually such a @xmath52 is unique ) . if @xmath56 for all @xmath54 , we say @xmath52 _ approximates _",
    "@xmath2 , and @xmath33 denotes the degree of a minimum - degree @xmath52 that approximates @xmath2 . for example , @xmath57 is a multilinear polynomial of degree @xmath4 that represents the and - function .",
    "similarly , @xmath58 represents or .",
    "the polynomial @xmath59 approximates but does not represent and on 2 variables .",
    "nisan and szegedy   proved a general lower bound on the degree of any boolean function that depends on @xmath4 variables :    [ thdeglogn ] if @xmath2 is a boolean function that depends on @xmath4 variables , then @xmath60 .",
    "let @xmath49 be a polynomial . if @xmath61 is some permutation and @xmath15 , then @xmath62 .",
    "let @xmath63 be the set of all @xmath64 permutations .",
    "the _ symmetrization _",
    "@xmath65 of @xmath52 averages over all permutations of the input , and is defined as : @xmath66 note that @xmath65 is a polynomial of degree at most the degree of @xmath52 .",
    "symmetrizing may actually lower the degree : if @xmath67 , then @xmath68 .",
    "the following lemma , originally due to  , allows us to reduce an @xmath4-variate polynomial to a single - variate one .",
    "[ lemsym ] if @xmath69 is a multilinear polynomial , then there exists a polynomial @xmath70 , of degree at most the degree of @xmath52 , such that @xmath71 for all @xmath54 .",
    "let @xmath72 be the degree of @xmath65 , which is at most the degree of @xmath52 .",
    "let @xmath73 denote the sum of all @xmath74 products of @xmath75 different variables , so @xmath76 , @xmath77 , etc .",
    "since @xmath65 is symmetrical , it can be written as @xmath78 for some @xmath79 .",
    "note that @xmath73 assumes value @xmath80 on @xmath8 , which is a polynomial of degree @xmath75 of @xmath48 .",
    "therefore the single - variate polynomial @xmath81 defined by @xmath82 satisfies the lemma .",
    "a boolean function @xmath2 is _ symmetric _ if permuting the input does not change the function value ( i.e. ,  @xmath24 only depends on @xmath48 ) .",
    "paturi has proved a powerful theorem that characterizes @xmath33 for symmetric @xmath2 . for such @xmath2 ,",
    "let @xmath83 for @xmath84 , and define @xmath85 @xmath40 is low if @xmath86 `` jumps '' near the middle ( i.e. ,  for some @xmath87 ) . now  ( * ? ? ?",
    "* theorem  1 ) gives :    [ thappdegreesym ] if @xmath2 is a non - constant symmetric boolean function on @xmath1 , then @xmath88 .    for functions like or and and",
    ", we have @xmath89 and hence @xmath90 . for parity ( which is",
    "1 iff @xmath48 is odd ) and majority ( which is 1 iff @xmath91 ) , we have @xmath92 and @xmath93 .      our goal is to compute some boolean function @xmath2 of @xmath15 , where @xmath8 is given as a black - box : calling the black - box on @xmath7 returns the value of @xmath6 .",
    "we want to use as few queries as possible .    a classical algorithm that computes @xmath2 by using ( adaptive ) black - box queries to @xmath8",
    "is called a _ decision tree _ , since it can be pictured as a binary tree where each node is a query , each node has the two outcomes of the query as children , and the leaves give answer @xmath94 or @xmath95 .",
    "the _ cost _ of such an algorithm is the number of queries made on the worst - case @xmath8 , so the cost is the depth of the tree .",
    "the _ decision tree complexity _",
    "@xmath32 of @xmath2 is the cost of the best decision tree that computes @xmath2 .",
    "similarly we can define @xmath96 as the expected number of queries on the worst - case @xmath8 for _ randomized _ algorithms that compute @xmath2 with bounded - error .",
    "a _ quantum network _ with @xmath0 queries is the quantum analogue to a classical decision tree with @xmath0 queries , where queries and other operations can now be made in quantum superposition .",
    "such a network can be represented as a sequence of unitary transformations : @xmath97 where the @xmath98 are arbitrary unitary transformations , and the @xmath99 are unitary transformations which correspond to queries to @xmath8 .",
    "the computation ends with some measurement or observation of the final state .",
    "we assume each transformation acts on @xmath100 qubits and each qubit has basis states @xmath101 and @xmath102 , so there are @xmath103 basis states for each stage of the computation .",
    "it will be convenient to represent each basis state as a binary string of length @xmath100 or as the corresponding natural number , so we have basis states @xmath104 .",
    "let @xmath105 be the index set @xmath106 . with some abuse of notation",
    ", we will sometimes identify a set of numbers with the corresponding set of basis states .",
    "every state @xmath107 of the network can be uniquely written as @xmath108 , where the @xmath109 are complex numbers such that @xmath110 .",
    "when @xmath107 is measured in the above basis , the probability of observing @xmath111 is @xmath112 .",
    "since we want to compute a function of @xmath8 , which is given as a black - box , the initial state of the network is not very important and we will disregard it hereafter ( we may assume the initial state to be @xmath101 always ) .",
    "the queries are implemented using the unitary transformations @xmath99 in the following standard way .",
    "the transformation @xmath99 only affects the leftmost part of a basis state : it maps basis state @xmath113 to @xmath114 ( @xmath115 denotes xor ) .",
    "here @xmath7 has length @xmath116 bits , @xmath117 is one bit , and @xmath118 is an arbitrary string of @xmath119 bits .",
    "note that the @xmath99 are all equal .",
    "how does a quantum network compute a boolean function @xmath2 of @xmath8 ?",
    "let us designate the rightmost bit of the final state of the network as the output bit .",
    "more precisely , the output of the computation is defined to be the value we observe if we measure the rightmost bit of the final state .",
    "if this output equals @xmath24 with certainty , for every @xmath8 , then the network computes @xmath2 _",
    "exactly_. if the output equals @xmath24 with probability at least @xmath26 , for every @xmath8 , then the network computes @xmath2 with bounded error probability at most @xmath120 . to define the zero - error setting ,",
    "the output is obtained by observing the _ two _ rightmost bits of the final state .",
    "if the first of these bits is 0 , the network claims ignorance ( `` inconclusive '' ) , otherwise the second bit should contain @xmath24 with certainty . for every @xmath8 , the probability of getting `` inconclusive '' should be less than @xmath25 .",
    "we use @xmath121 , @xmath122 and @xmath123 to denote the minimum number of queries required by a quantum network to compute @xmath2 in the exact , zero - error and bounded - error settings , respectively .",
    "note that @xmath124 .",
    "in this section we will provide some general lower bounds on the number of queries required to compute a boolean function @xmath2 on a quantum network , either exactly or with zero- or bounded - error probability .",
    "the next lemmas relate quantum networks to polynomials ; they are the key to most of our results .",
    "[ lemamplpol ] let @xmath125 be a quantum network that makes @xmath0 queries to a black - box @xmath8 . then there exist complex - valued @xmath4-variate multilinear polynomials @xmath126 , each of degree at most @xmath0 , such that the final state of the network is the superposition @xmath127 for any black - box @xmath8 .",
    "let @xmath128 be the state of the network ( using some black - box @xmath8 ) just before the @xmath7th query .",
    "note that @xmath129 .",
    "the amplitudes in @xmath130 depend on the initial state and on @xmath131 but not on @xmath8 , so they are polynomials of @xmath8 of degree 0 .",
    "a query maps basis state @xmath113 to @xmath114 .",
    "hence if the amplitude of @xmath132 in @xmath130 is @xmath133 and the amplitude of @xmath134 is @xmath135 , then the amplitude of @xmath132 _ after _ the query becomes @xmath136 and the amplitude of @xmath134 becomes @xmath137 , which are polynomials of degree @xmath138 .",
    "( in general , if the amplitudes before a query are polynomials of degree @xmath139 , then the amplitudes after the query will be polynomials of degree @xmath140 . ) between the first and the second query lies the unitary transformation @xmath141",
    ". however , the amplitudes after applying @xmath141 are just linear combinations of the amplitudes before applying @xmath141 , so the amplitudes in @xmath142 are polynomials of degree at most @xmath138 . continuing in this manner ,",
    "the amplitudes of the final states are found to be polynomials of degree at most @xmath0 .",
    "we can make these polynomials multilinear without affecting their values on @xmath19 , by replacing all @xmath143 by @xmath6",
    ".    note that we have not used the assumption that the @xmath144 are unitary , but only their linearity .",
    "the next lemma is also implicit in the combination of some proofs in  .",
    "[ lemprobpol ] let @xmath125 be a quantum network that makes @xmath0 queries to a black - box @xmath8 , and @xmath145 be a set of basis states .",
    "then there exists a real - valued multilinear polynomial @xmath146 of degree at most @xmath23 , which equals the probability that observing the final state of the network with black - box @xmath8 yields a state from @xmath145 .    by the previous lemma ,",
    "we can write the final state of the network as @xmath127 for any @xmath8 , where the @xmath147 are complex - valued polynomials of degree @xmath148 . the probability of observing a state in @xmath145 is @xmath149 if we split @xmath147 into its real and imaginary parts as @xmath150 , where @xmath151 and @xmath152 are real - valued polynomials of degree @xmath148 , then @xmath153 , which is a real - valued polynomial of degree at most @xmath23 .",
    "hence @xmath154 is also a real - valued polynomial of degree at most @xmath23 , which we can make multilinear without affecting its values on @xmath19 .",
    "letting @xmath145 be the set of states that have 1 as rightmost bit , it follows that we can write the acceptance probability of a network as a degree-@xmath23 polynomial @xmath146 of @xmath8 . in the case of exact computation of @xmath2",
    "we must have @xmath155 for all @xmath8 , so @xmath154 represents @xmath2 and we obtain @xmath156 .",
    "[ thexactpol ] if @xmath2 is a boolean function , then @xmath157 .    combining this with theorem  [ thdeglogn ]",
    ", we obtain a general lower bound :    if @xmath2 depends on @xmath4 variables , then @xmath158 .    for _ symmetric _",
    "@xmath2 we can prove a much stronger bound .",
    "firstly for the zero - error setting :    [ thsymzero ] if @xmath2 is non - constant and symmetric , then @xmath159 .",
    "we assume @xmath94 for at least @xmath160 different hamming weights of @xmath8 ; the proof is similar if @xmath95 for at least @xmath160 different hamming weights .",
    "consider a network that uses @xmath161 queries to compute @xmath2 with zero - error .",
    "let @xmath145 be the set of basis states that have @xmath162 as rightmost bits .",
    "by lemma  [ lemprobpol ] , there is a real - valued multilinear polynomial @xmath154 of degree @xmath163 , such that for all @xmath8 , @xmath146 equals the probability that the output of the network is @xmath162 ( i.e. ,  that the network answers 1 ) .",
    "since the network computes @xmath2 with zero - error and @xmath2 is non - constant , @xmath146 is non - constant and equals 0 on at least @xmath160 different hamming weights ( namely the hamming weights for which @xmath94 ) .",
    "let @xmath81 be the single - variate polynomial of degree @xmath163 obtained from symmetrizing @xmath154 ( lemma  [ lemsym ] ) .",
    "this @xmath81 is non - constant and has at least @xmath160 zeroes , hence degree at least @xmath160 , and the result follows .",
    "thus functions like or , and , parity , threshold functions etc .",
    ", all require at least @xmath164 queries to be computed exactly or with zero - error on a quantum network .",
    "since @xmath4 queries always suffice , even classically , we have @xmath165 and @xmath166 for non - constant symmetric @xmath2 .",
    "secondly , for the exact setting , we can use results by von zur gathen and roche  :    if @xmath2 is non - constant and symmetric , then @xmath167 . if , in addition , @xmath168 is prime , then @xmath169 .    if @xmath2 is non - constant and symmetric , then @xmath170 . if , in addition , @xmath168 is prime , then @xmath171 .    in section  [ secpartfns ]",
    "we give more precise bounds for some particular functions .",
    "in particular , this will show that the @xmath41 lower bound is tight , as it can be met for parity .",
    "here we use similar techniques to get bounds on the number of queries required for _ bounded - error _ computation of some function . consider the acceptance probability of a @xmath0-query network that computes @xmath2 with bounded - error , written as a polynomial @xmath146 of degree @xmath163 .",
    "if @xmath94 then we should have @xmath172 , and if @xmath95 then @xmath173 .",
    "hence @xmath154 approximates @xmath2 , and we get :    [ thapprpol ] if @xmath2 is a boolean function , then @xmath174 .",
    "this result implies that a quantum algorithm that computes @xmath2 with bounded error probability can be at most polynomially more efficient ( in terms of number of queries ) than a classical deterministic algorithm : nisan and szegedy proved that @xmath34 , which together with the previous theorem implies @xmath175 . the fact that there is a polynomial relation between the classical and the quantum complexity is also implicit in the generic oracle - constructions of fortnow and rogers  . in section  [ secpolrel ]",
    "we will prove the stronger result @xmath176 .",
    "combining theorem  [ thapprpol ] with paturi s theorem  [ thappdegreesym ] gives a lower bound for _ symmetric _ functions in the bounded - error setting : if @xmath2 is non - constant and symmetric , then @xmath177 . we can in fact prove a matching upper bound , using the following result , which follows immediately from  @xcite as noted by mosca  @xcite .",
    "it shows that we can _ count _ the number of 1s in @xmath8 exactly , with bounded error probability :    [ thqcount ] there exists a quantum algorithm that returns @xmath178 with probability at least @xmath179 using expected time @xmath180 , for all @xmath54 .",
    "actually , the algorithms given in @xcite are classical algorithms which use some quantum networks as subroutines ; the notion of _ expected _ time for such algorithms is the same as for classical ones .",
    "this counting - result allows us to prove the matching upper bound :    [ thcountsym ] if @xmath2 is non - constant and symmetric , then @xmath181 .",
    "let @xmath2 be some non - constant boolean function .",
    "we will sketch a strategy that computes @xmath2 with bounded error probability @xmath182 .",
    "let @xmath83 for @xmath8 with @xmath84 .",
    "first note that since @xmath183 , @xmath86 must be identically 0 or 1 for @xmath184 . consider some @xmath8 with @xmath185 . in order to be able to compute @xmath24 , it is sufficient to know @xmath186 exactly if @xmath187 or @xmath188 , or to _ know _ that @xmath189 otherwise .",
    "run the counting algorithm for @xmath190 steps to count the number of 1s in @xmath8 . if @xmath187 or @xmath188 , then with high probability the algorithm will have terminated and will have returned @xmath186 . if it has not terminated after @xmath190 steps , then we know @xmath191 with high probability .    from this application of the counting algorithm ,",
    "we now have obtained the following with bounded error probability :    * if @xmath187 or @xmath188 , then the counting algorithm gave us an exact count of @xmath186 . *",
    "if @xmath189 , then we know this , and we also know that @xmath192 is identically 0 or 1 for all such @xmath186 .    thus with bounded error probability we have obtained sufficient information to compute @xmath193 , using only @xmath194 queries . repeating this procedure some constant number of times , we can limit the probability of error to at most @xmath120 .",
    "we can implement this strategy in a quantum network with @xmath194 queries to compute @xmath2 .",
    "this implies that the above - stated result about quantum counting ( theorem  [ thqcount ] ) is optimal , since a better upper bound for counting would give a better upper bound on @xmath123 for symmetric @xmath2 , whereas we already know that theorem  [ thcountsym ] is tight .",
    "in contrast to theorem  [ thcountsym ] , it can be shown that a randomized classical strategy needs @xmath12 queries to compute any non - constant symmetric @xmath2 with bounded - error .",
    "after reading a first version of this paper , where we proved that most functions can not be computed exactly using significantly fewer than @xmath4 ( i.e. ,  @xmath195 ) queries , andris ambainis  @xcite extended this to the bounded - error case : _ most _ functions can not be computed with bounded - error using significantly fewer than @xmath4 queries",
    ".    on the other hand , wim van dam  @xcite recently proved that with good probability we can learn all @xmath4 variables in the black - box using only @xmath196 queries .",
    "this implies the general upper bound @xmath197 for _ any _ @xmath2 .",
    "this bound is almost tight , as we will show later on that @xmath198 for @xmath199 parity .",
    "above we gave lower bounds on the number of queries used , in terms of degrees of polynomials that represent or approximate the function @xmath2 that is to be computed .",
    "here we give lower bounds in terms of the _ block sensitivity _ of @xmath2 .",
    "let @xmath47 be a function , @xmath54 , and @xmath200 a set of indices .",
    "let @xmath201 denote the vector obtained from @xmath8 by flipping the variables in @xmath145 .",
    "we say that @xmath2 is _ sensitive _ to @xmath145 on @xmath8 if @xmath202 .",
    "the _ block sensitivity _ @xmath203 of @xmath2 _ on @xmath8 _ is the maximum number @xmath186 for which there exist @xmath186 disjoint sets of indices @xmath204 such that @xmath2 is sensitive to each @xmath205 on @xmath8 .",
    "the _ block sensitivity _ @xmath206 of @xmath2 is the maximum of @xmath203 over all @xmath54 .",
    "for example , @xmath207 , because if we take @xmath208 and @xmath209 , then flipping @xmath205 in @xmath8 flips the value of the or - function from 0 to 1 .",
    "we can adapt the proof of   on lower bounds of polynomials to get lower bounds on the number of queries in a quantum network in terms of block sensitivity .",
    "the proof uses a theorem from  :    let @xmath210 be a polynomial such that @xmath211 for every integer @xmath212 , and @xmath213 for some real @xmath214",
    ". then @xmath215 .",
    "[ thtbs ] if @xmath2 is a boolean function , then @xmath216 and @xmath217 .",
    "we will prove the theorem for bounded - error computation , the case of exact computation is completely analogous but slightly easier .",
    "consider a network using @xmath218 queries that computes @xmath2 with error probability @xmath182 .",
    "let @xmath154 be the polynomial of degree @xmath163 that approximates @xmath2 , obtained as for theorem  [ thapprpol ] .",
    "note that @xmath219 $ ] for all @xmath54 , because @xmath154 represents a probability .",
    "let @xmath220 , and @xmath8 and @xmath221 be the input and sets which achieve the block sensitivity .",
    "we assume without loss of generality that @xmath94 .",
    "consider variable @xmath222 .",
    "define @xmath223 as : @xmath224 if @xmath225 and @xmath226 , @xmath227",
    "if @xmath228 and @xmath226 , and @xmath229 if @xmath230 ( the @xmath231 are fixed ) . note that if @xmath232 then @xmath233 , and if @xmath234 has @xmath235 and @xmath236 for @xmath237 then @xmath238 .",
    "now @xmath239 is a @xmath117-variate polynomial of degree @xmath163 , such that    * @xmath240 $ ] for all @xmath241 ( because @xmath154 gives a probability ) .",
    "* @xmath242 , so @xmath243 . * @xmath244 if @xmath234 has @xmath235 and @xmath236 for @xmath237 . +",
    "hence @xmath245 if @xmath246 .",
    "let @xmath247 be the single - variate polynomial of degree @xmath163 obtained from symmetrizing @xmath81 over @xmath248 ( lemma  [ lemsym ] ) .",
    "note that @xmath249 for every integer @xmath250 , and for some @xmath251 $ ] we have @xmath252 because @xmath253 and @xmath254 . applying the previous theorem",
    "we get @xmath255 , hence @xmath256 .",
    "we can generalize this result to the computation of _ partial _ boolean functions , which only work on a domain @xmath257 of inputs that satisfy some promise , by generalizing the definition of block sensitivity to partial functions in the obvious way .",
    "here we will compare the classical complexities @xmath32 and @xmath96 with the quantum complexities . some separations : as we show in the next section , if @xmath199 parity then @xmath198 while @xmath258 ; if @xmath199 or then @xmath259 by grover s algorithm , while @xmath260 and @xmath258 , so we have a quadratic gap between @xmath123 on the one hand and @xmath96 and @xmath32 on the other . and @xmath96 .",
    "the best known separation is for complete binary and / or - trees , where @xmath258 and @xmath261 , and it has been conjectured that this is the best separation possible .",
    "this holds both for zero - error randomized trees   and for bounded - error trees  @xcite . ]    by a well - known result , the best randomized decision tree can be at most polynomially more efficient than the best deterministic decision tree : @xmath262 . as mentioned in section  [ secbounds ] , we can prove that also the _ quantum _ complexity can be at most polynomially better than the best deterministic tree : @xmath175 .",
    "here we give the stronger result that @xmath176 .",
    "in other words , if we can compute some function quantumly with bounded - error using @xmath0 queries , we can compute it classically error - free with @xmath3 queries .    to start",
    ", we define the _ certificate complexity _ of @xmath2 :    let @xmath47 be a function .",
    "@xmath138-certificate _ is an assignment @xmath263 of values to some subset @xmath264 of the @xmath4 variables , such that @xmath95 whenever @xmath8 is consistent with @xmath265 .",
    "the _ size _ of @xmath265 is @xmath266 .",
    "similarly we define a @xmath267-certificate .",
    "the _ certificate complexity _",
    "@xmath268 of @xmath2 _ on @xmath8 _ is the size of a smallest @xmath24-certificate that agrees with @xmath8 .",
    "the _ certificate complexity _",
    "@xmath269 of @xmath2 is the maximum of @xmath268 over all @xmath8 .",
    "the _ @xmath138-certificate complexity _",
    "@xmath270 of @xmath2 is the maximum of @xmath268 over all @xmath8 for which @xmath95 .",
    "for example , if @xmath2 is the or - function , then the certificate complexity on @xmath271 is 1 , because the assignment @xmath272 already forces the or to 1 .",
    "the same holds for the other @xmath8 for which @xmath95 , so @xmath273 . on the other hand ,",
    "the certificate complexity on @xmath274 is @xmath4 , so @xmath275 .",
    "the first inequality in the next lemma is obvious from the definitions , the second inequality is .",
    "we give the proof for completeness .",
    "@xmath276 .",
    "consider an input @xmath19 and let @xmath277 be disjoint _",
    "minimal _ sets of variables that achieve the block sensitivity @xmath278",
    ". we will show that @xmath279 which sets variables according to @xmath8 , is a certificate for @xmath8 of size @xmath280 .",
    "firstly , if @xmath265 were not an @xmath24-certificate then let @xmath281 be an input that agrees with @xmath265 , such that @xmath282 .",
    "let @xmath283 .",
    "now @xmath2 is sensitive to @xmath284 on @xmath8 and @xmath284 is disjoint from @xmath277 , which contradicts @xmath285 .",
    "hence @xmath265 is an @xmath24-certificate .",
    "secondly , note that for @xmath286 we must have @xmath287 : if we flip one of the @xmath205-variables in @xmath288 then the function value must flip from @xmath289 to @xmath24 ( otherwise @xmath205 would not be minimal ) , so every @xmath205-variable forms a sensitive set for @xmath2 on input @xmath288 .",
    "hence the size of @xmath265 is @xmath290 .",
    "the crucial lemma is the following , which we prove along the lines of  .",
    "[ lembounddf ] @xmath291 .",
    "the following describes an algorithm to compute @xmath24 , querying at most @xmath292 variables of @xmath8 ( in the algorithm , by a `` consistent '' certificate @xmath265 or input @xmath234 at some point we mean a @xmath265 or @xmath234 that agrees with the values of all variables queried up to that point ) .    1 .",
    "repeat the following at most @xmath206 times : + pick a consistent @xmath138-certificate @xmath265 and query those of its variables whose @xmath8-values are still unknown ( if there is no such @xmath265 , then return 0 and stop ) ; if the queried values agree with @xmath265 then return 1 and stop .",
    "2 .   pick a consistent @xmath293 and return @xmath294 .",
    "the nondeterministic `` pick a @xmath265 '' and `` pick a @xmath234 '' can easily be made deterministic by choosing the first @xmath265 resp .",
    "@xmath234 in some fixed order .",
    "call this algorithm @xmath295 . since @xmath295 runs for at most @xmath206 stages and each stage queries at most @xmath270 variables , @xmath295 queries at most @xmath292 variables .",
    "it remains to show that @xmath295 always returns the right answer .",
    "if it returns an answer in step  1 , this is either because there are no consistent @xmath138-certificates left ( and hence @xmath24 must be 0 ) or because @xmath8 is found to agree with a particular @xmath138-certificate @xmath265 ; in both cases @xmath295 gives the right answer .    now consider the case where @xmath295 returns an answer in step  2 .",
    "we will show that all consistent @xmath234 must have the same @xmath2-value .",
    "suppose not .",
    "then there are consistent @xmath296 with @xmath297 and @xmath298 .",
    "@xmath295 has queried @xmath220 @xmath138-certificates @xmath299 .",
    "furthermore , @xmath300 contains a consistent @xmath138-certificate @xmath301 .",
    "we will derive from these @xmath302 disjoint sets @xmath205 such that @xmath2 is sensitive to each @xmath205 on @xmath234 .",
    "for every @xmath303 , define @xmath205 as the set of variables on which @xmath234 and @xmath302 disagree .",
    "clearly , each @xmath205 is non - empty .",
    "note that @xmath304 agrees with @xmath302 , so @xmath305 which shows that @xmath2 is sensitive to each @xmath205 on @xmath234 .",
    "let @xmath306 be a variable in some @xmath205 ( @xmath286 ) , then @xmath307 .",
    "now for @xmath308 , @xmath309 has been chosen consistent with all variables queried up to that point ( including @xmath306 ) , so we can not have @xmath310 , hence @xmath311 .",
    "this shows that all @xmath205 and @xmath312 are disjoint .",
    "but then @xmath2 is sensitive to @xmath313 disjoint sets on @xmath234 , which is a contradiction .",
    "accordingly , all consistent @xmath234 in step  2 must have the same @xmath2-value , and @xmath295 returns the right value @xmath314 in step  2 , because @xmath8 is one of those consistent @xmath234 .",
    "the inequality of the previous lemma is tight , because if @xmath199 or , then @xmath258 , @xmath273 , @xmath315 .",
    "the previous two lemmas imply @xmath316 . combining this with theorem  [ thtbs ] ( @xmath317 )",
    ", we obtain the main result :    [ thdoq6 ] if @xmath2 is a boolean function , then @xmath318 .",
    "we do not know if the @xmath319-relation is tight , and suspect that it is not .",
    "the best separation we know is for or and similar functions , where @xmath258 and @xmath259 .",
    "however , for such symmetric boolean function we can do no better than a quadratic separation : @xmath320 always holds , and we have @xmath321 by theorem  [ thcountsym ] , hence @xmath322 for symmetric @xmath2 . for _ monotone _ boolean functions , where the function value either increases or decreases monotonically if we set more input bits to 1 , we can use ( @xmath323 ) to prove @xmath324 . for the case of exact computation we can also give a better result : nisan and smolensky ( unpublished  @xcite ) proved @xmath325 for any @xmath2 , which together with our theorem  [ thexactpol ] yields @xmath326 .    as a by - product , we improve the polynomial relation between @xmath32 and @xmath33 .",
    "nisan and szegedy   proved @xmath327 using our result @xmath316 and nisan and szegedy s @xmath328 we get    @xmath329",
    "first we will consider the or - function , which is related to database search . by grover s well - known search algorithm  @xcite ,",
    "if at least one @xmath6 equals 1 , we can find an index @xmath7 such that @xmath46 with high probability of success in @xmath13 queries .",
    "this implies that we can also compute the or - function with high success probability in @xmath13 : let grover s algorithm generate an index @xmath7 , and return @xmath6 .",
    "since @xmath207 , theorem  [ thtbs ] gives us a lower bound of @xmath330 on computing the or with bounded error probability , lower bound on search is actually quite well known  , and is given in a tighter form in  @xcite , but the way we obtained it here is rather different from existing proofs .",
    "] so we have @xmath331 , where classically we require @xmath12 queries .",
    "now suppose we want to get rid of the probability of error : can we compute the or exactly or with zero - error using @xmath13 queries ? if not , can quantum computation give us at least _",
    "some _ advantage over the classical deterministic case ? both questions have a negative answer :    [ prorzero ] @xmath332 .",
    "consider a network that computes or with zero - error using @xmath333 queries . by lemma  [ lemamplpol ] , there are complex - valued polynomials @xmath147 of degree at most @xmath0 , such that the final state of the network on black - box @xmath8 is @xmath334 let @xmath145 be the set of all basis states ending in @xmath335 ( i.e. ,  where the output is the answer 0 ) .",
    "then for every @xmath336 we must have @xmath337 if @xmath338 , otherwise the probability of getting the incorrect answer @xmath267 on @xmath339 would be non - zero .",
    "on the other hand , there must be at least one @xmath340 such that @xmath341 , since the probability of getting the correct answer 0 on @xmath342 must be non - zero .",
    "let @xmath343 be the real part of @xmath344 .",
    "this polynomial @xmath52 has degree at most @xmath0 and represents or .",
    "but then @xmath52 must have degree at least @xmath345 , so @xmath346 .",
    "[ corexsearchn ] a quantum network for exact or zero - error search requires @xmath4 queries .    under the promise that the number of solutions is either 0 or @xmath105 , for",
    "some fixed known @xmath105 , exact search can be done in @xmath347 queries  @xcite . a partial block sensitivity argument ( see the comment following theorem  [ thtbs ] ) shows that this is optimal up to a multiplicative constant .    like the or - function",
    ", parity has @xmath169 , so by theorem  [ thexactpol ] exact computation requires at least @xmath41 queries .",
    "this is also sufficient .",
    "it is well known that the xor of 2 variables can be computed using only one query  @xcite .",
    "we can group the @xmath4 variables of @xmath8 as @xmath41 pairs : @xmath348 , and compute the xor of all @xmath41 pairs using @xmath41 queries .",
    "the parity of @xmath8 is the parity of these @xmath41 xor values , which can be computed without any further queries .",
    "if we allow bounded - error , then @xmath41 queries of course still suffice .",
    "it follows from theorem  [ thapprpol ] that this can not be improved , because @xmath349  :    [ lemapproxparity ] @xmath349 .",
    "let @xmath2 be parity on @xmath4 variables .",
    "let @xmath52 be a polynomial of degree @xmath33 that approximates @xmath2 .",
    "since @xmath52 approximates @xmath2 , its symmetrization @xmath65 also approximates @xmath2 . by lemma  [ lemsym ]",
    ", there is a polynomial @xmath81 , of degree at most @xmath33 , such that @xmath350 for all inputs .",
    "thus we must have @xmath351 , so    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath352 , @xmath353 ,  , @xmath354 , @xmath355 ( assuming @xmath4 even ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we see that the polynomial @xmath356 must have at least @xmath4 zeroes , hence @xmath81 has degree at least @xmath4 and @xmath357 .    if @xmath2 is parity on @xmath1 , then @xmath358 .    for _ classical _ deterministic or randomized methods ,",
    "@xmath4 queries are necessary in both the exact and the zero - error setting .",
    "( @xmath359 because for @xmath96 we count _ expected _ number of queries . ) note that while computing parity on a quantum network is much harder than or in the _ bounded - error _ setting ( @xmath41 versus @xmath45 ) , in the _ exact _ setting parity is actually easier ( @xmath41 versus @xmath4 ) .",
    "the upper bound on parity uses the fact that the xor connective can be computed with only one query . using polynomial arguments",
    ", it turns out that xor and its negation are the _ only _ examples among all @xmath360 connectives where quantum gives an advantage over classical computation .",
    "since the and of @xmath4 variables can be reduced to majority on @xmath361 variables ( if we set the first @xmath362 variables to 0 , then the majority of all variables equals the and of the last @xmath4 variables ) and and , like or , requires @xmath4 queries to be computed exactly or with zero - error , majority takes at least @xmath160 queries .",
    "van melkebeek  @xcite and hayes and kutin independently found an exact quantum algorithm that uses at most @xmath363 queries , where @xmath364 is the number of 1s in the binary representation of @xmath4 ; this can save up to @xmath365 queries .",
    "for the zero - error case , the @xmath160 lower bound applies ; van melkebeek , hayes and kutin have found an algorithm that works in roughly @xmath366 queries .",
    "for the bounded - error case , we can apply theorem  [ thcountsym ] : if @xmath199 majority , then @xmath92 , so we need @xmath12 queries .",
    "the best upper bound we have here is @xmath196 , which follows from  @xcite .",
    "we would like to thank lance fortnow for stimulating discussions on many of the topics treated here ; alain tapp for sending us a preliminary version of  @xcite and subsequent discussions about quantum counting ; andris ambainis for sending us his proof that most functions can not be computed with bounded - error using significantly fewer than @xmath4 queries ; noam nisan for sending us his proof that @xmath325 ; dieter van melkebeek , tom hayes , and sandy kutin for their algorithms for majority ; and hayes and kutin for the reference to  . r.c .  and m.m .",
    "gratefully acknowledge the hospitality of the cwi , where much of this research took place . m.m .",
    "thanks cesg for their support .",
    "d.  boneh and r.  j. lipton .",
    "quantum cryptanalysis of hidden linear functions ( extended abstract ) . in _ advances in cryptology ( crypto95 ) _ , volume 963 of _ lecture notes in computer science _ , pages 424437 .",
    "springer , 1995 .",
    "g.  brassard and p.  hyer .",
    "an exact quantum polynomial - time algorithm for simon s problem . in _ proceedings of the 5th israeli symposium on theory of computing and systems ( istcs97 ) _ , pages 1223 , 1997 .",
    "quant - ph/9704027 .",
    "m.  mosca and a.  ekert . the hidden subgroup problem and eigenvalue estimation on a quantum computer . in _ proceedings of nasa qcqc conference",
    ", volume 1509 of _ lecture notes in computer science_. springer , 1998 ."
  ],
  "abstract_text": [
    "<S> we examine the number @xmath0 of queries that a quantum network requires to compute several boolean functions on @xmath1 in the _ black - box _ model . </S>",
    "<S> we show that , in the black - box model , the exponential quantum speed - up obtained for _ partial _ functions ( i.e.  problems involving a promise on the input ) by deutsch and jozsa and by simon can not be obtained for any _ total _ function : if a quantum algorithm computes some total boolean function @xmath2 with bounded - error using @xmath0 black - box queries then there is a classical deterministic algorithm that computes @xmath2 exactly with @xmath3 queries . </S>",
    "<S> we also give asymptotically tight characterizations of @xmath0 for all symmetric @xmath2 in the exact , zero - error , and bounded - error settings . </S>",
    "<S> finally , we give new precise bounds for and , or , and parity . </S>",
    "<S> our results are a quantum extension of the so - called polynomial method , which has been successfully applied in classical complexity theory , and also a quantum extension of results by nisan about a polynomial relationship between randomized and deterministic decision tree complexity .    </S>",
    "<S> 1\\{0,1 } [ section ] [ definition]theorem [ definition]proposition [ definition]lemma [ definition]corollary </S>"
  ]
}