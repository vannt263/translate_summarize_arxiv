{
  "article_text": [
    "by outsourcing and consolidating the control over multiple data - plane elements to a centralized software program , software - defined networks  ( sdns ) introduce flexibilities and optimization opportunities .",
    "however , while a logically centralized control is appealing , an sdn still needs to be regarded as a distributed system , posing non - trivial challenges  @xcite . in particular , the communication channel between switches and controller exhibits non - negligible and varying delays  @xcite , which may introduce inconsistencies during _",
    "network updates_.    over the last years , the problem of how to consistently update routes in a  ( software - defined ) network has received much attention , both in the systems as well as in the theory community  @xcite . while in the seminal work by reitblatt et al .",
    "@xcite , protocols providing strong , per - packet consistency guarantees were presented  ( using some kind of 2-phase commit approach ) , it was later observed that weaker , but transiently consistent guarantees can be implemented more efficiently . in particular , mahajan and",
    "wattenhofer  @xcite proposed a first algorithm to update routes in a network in a transiently loop - free manner .",
    "their approach is appealing as it does not require packet tagging  ( which comes with overheads in terms of header space and also introduces challenges in the presence of middleboxes  @xcite or multiple controllers  @xcite ) or additional tcam entries  @xcite  ( which is problematic given the fast table growth both in the internet as well as in the highly virtualized datacenter  @xcite ) .",
    "moreover , this approach also allows  ( parts of the ) paths to become available sooner  @xcite .",
    "concretely , to update a network in a transiently loop - free manner , the approach proceeds _ in rounds _",
    "@xcite : in each round , a `` safe subset '' of  ( so - called openflow ) switches is updated , such that , independently of the times and order in which the updates of this round take effect , the network is always consistent . the scheme can be implemented as follows : after the switches of round  @xmath0 have confirmed the successful update  ( e.g. , using acknowledgments  @xcite ) , the next subset of switches for round  @xmath1 is scheduled .",
    "it is easy to see that a simple update schedule always exists : we can update switches one - by - one , proceeding from the destination toward the source of a route . in practice",
    ", however , it is desirable that updates are fast and new routes become available quickly : ideally , in order to be able to use as many new links as possible , one aims to maximize the number of concurrently updated switches  @xcite .",
    "we will refer to this approach as the _",
    "approach_.    this paper revisits the problem of updating a maximum number of switches in a transiently loop - free manner . in particular , we consider the two different notions of loop - freedom introduced in  @xcite : _ strong loop - freedom _ and _ relaxed loop - freedom_. the first variant guarantees loop - freedom in a very strict , topological sense : no single packet will ever loop . the second variant is less strict , and allows for a small constant number of packets to loop during the update ; however , at no point in time should newly arriving packets be pushed into a loop .",
    "it is known that by relaxing loop - freedom , in principle many more switches can be updated simultaneously .    * our contributions .",
    "* we rigorously prove that computing the maximum set of switches which can be updated simultaneously , without introducing a loop , is np - hard , both regarding strong and relaxed loop - freedom .",
    "this result may be somewhat suprising , given the very simple graph induced by our network update problem .",
    "the result also has implications for the classic maximum acyclic subgraph problem  ( masp ) , a.k.a .",
    "the dual feedback arc set problem  ( dfasp ) : the problem of computing a maximum set of switches which can be updated simultaneously , corresponds to the dfasp , on special graphs essentially describing two routes  ( the old and the new one ) .",
    "our np - hardness result shows that masp / dfasp are hard even on such graphs . on the positive side ,",
    "we identify network update problems which allow for optimal or almost optimal  ( with a provable approximation factor less than 2 ) polynomial - time algorithms , e.g. , problem instances where the number of leaves is bounded or problem instances with bounded underlying undirected tree - width .",
    "we are given a network and two policies resp .",
    "_ routes _ @xmath2  ( the _ old policy _ ) and  @xmath3  ( the _ new policy _ ) . both  @xmath2 and  @xmath3",
    "are simple directed paths ( _ digraphs _ ) .",
    "initially , packets are forwarded  ( using the _ old rules _ , henceforth also called _ old edges _ ) along  @xmath2 , and eventually they should be forwarded according to the new rules of  @xmath3 . packets should never be delayed or dropped at a switch , henceforth also called _ node _",
    ": whenever a packet arrives at a node , a matching forwarding rule should be present . without loss of generality ,",
    "we assume that  @xmath2 and  @xmath3 lead from a source  @xmath4 to a destination  @xmath5 .",
    "we assume that the network is managed by a controller which sends out forwarding rule updates to the nodes . as the individual node updates occur in an asynchronous manner",
    ", we require the controller to send out simultaneous updates only to a `` safe '' subset of nodes . only after these updates have been confirmed ( _ _",
    "ack__ed ) , the next subset is updated .",
    "we observe that nodes appearing only in one or none of the two paths are trivially updatable , therefore we focus on the network  @xmath6 induced by the nodes  @xmath7 which are part of _ both _ policies  @xmath2 _ and _",
    "@xmath3 , i.e. ,  @xmath8 .",
    "we can represent the policies as @xmath9 and  @xmath10 , for some permutation  @xmath11 and some number  @xmath12 .",
    "in fact , we can represent policies in an even more compact way : we are actually only concerned about the nodes  @xmath13 which need to be updated .",
    "let , for each node  @xmath14 ,  @xmath15  ( resp .",
    "@xmath16 ) denote the outgoing  ( resp .",
    "incoming ) edge according to policy  @xmath2 , and  @xmath17  ( resp .",
    "@xmath18 ) denote the outgoing  ( resp .",
    "incoming ) edge according to policy  @xmath3 .",
    "moreover , let us extend these definitions for entire node sets  @xmath19 , i.e. ,  @xmath20 , for @xmath21 , and analogously , for  @xmath22 .",
    "we    define  @xmath4 to be the first node  ( say , on  @xmath2 ) with  @xmath23 , and  @xmath5 to be the last node with  @xmath24 .",
    "we are interested in the set of to - be - updated nodes  @xmath25 , and define  @xmath26 .",
    "given this reduction , in the following , we will assume that  @xmath7 only consists of interesting nodes  ( @xmath27 ) .",
    "we require that paths be loop - free  @xcite , and distinguish between _ strong loop - freedom _  ( @xmath28 ) and _ relaxed loop - freedom _  ( @xmath29 )  @xcite .    * strong loop - freedom .",
    "* we want to find an _ update schedule _",
    "@xmath30 , i.e. , a sequence of subsets  @xmath31 where the subsets form a partition of  @xmath32  ( i.e. ,  @xmath33 ) , with the property that for any round  @xmath0 , given that the updates  @xmath34 for  @xmath35 have been made , all updates  @xmath36 can be performed `` asynchronously '' , that is , in an arbitrary order without violating loop - freedom . thus , consistent paths will be maintained for any subset of updated nodes , independently of how long individual updates may take .",
    "more formally , let  @xmath37 denote the set of nodes which have already been updated before round  @xmath0 , and let  @xmath38 ,  @xmath39 etc .",
    "be defined analogously .",
    "since updates during round  @xmath0 occur asynchronously , an arbitrary subset of nodes  @xmath40 may already have been updated while the nodes  @xmath41 still use the old rules , resulting in a temporary forwarding graph  @xmath42 over nodes  @xmath32 , where  @xmath43 .",
    "we require that the update schedule  @xmath30 fulfills the property that for all  @xmath0 and for any  @xmath44 ,  @xmath42 is loop - free .    in the following we will call an edge  @xmath45 of the new policy @xmath3 _ forward _ , if  @xmath46 is closer  ( with respect to  @xmath2 ) to the destination , resp .",
    "_ backward _ , if  @xmath47 is closer to the destination .",
    "it is also convenient to name nodes after their outgoing edges w.r.t .",
    "policy @xmath3  ( e.g. , _ forward _ or _ backward _ ) ; similarly , it is sometimes convenient to say that we _ update an edge _ when we update the corresponding node .    while the initial network configuration consists of two paths , in later rounds , the already updated solid edges may no longer form a line from left to right , but rather an arbitrary directed tree , with tree edges directed towards the destination  @xmath5 .",
    "we will use the terms _ forward _ and _ backward _ also in the context of the tree : they are defined with respect to the direction of the tree root .",
    "however , there also emerges a third kind of edges : _ horizontal edges _ in - between two different branches of the tree .",
    "* relaxed loop - freedom . * _ relaxed loop - freedom _  ( @xmath29 )",
    "is motivated by the practical observation that transient loops are not very harmful if they do not occur between the source  @xmath4 and the destination  @xmath5 .",
    "if relaxed loop - freedom is preserved , only a constant number of packets can loop : we will never push new packets into a loop `` at line rate '' .",
    "in other words , even if switches acknowledge new updates late  ( or never ) , new packets will not enter loops . concretely , and",
    "similar to the definition of  @xmath28 , we require the update schedule to fulfill the property that for all rounds  @xmath0 and for any subset  @xmath48 , the temporary forwarding graph  @xmath49 is loop - free .",
    "the difference is that we only care about the subset  @xmath50 of  @xmath51 consisting of edges _",
    "reachable from the source _",
    "@xmath4 .",
    "* the greedy approach .",
    "* our objective is to update simultaneously as many nodes  ( or equivalently , edges ) as possible : a greedy approach  @xcite .",
    "note that in the first round , computing a maximum update set is trivial : all forward edges can be updated simultaneously , as they will never introduce a cycle ; at the same time , no backward edge can be updated in the first round , as it can always induce a cycle . also observe that since all nodes lie on the path from source to destination , this holds for both strong and relaxed loop - freedom .",
    "however , as we will show in this paper , already in the second round , a computationally hard problem can arise .",
    "interestingly , although the underlying graphs are very simple , and originate from just two ( legal ) paths , we now prove that the loop - free network update problem is np - hard .",
    "[ thm : greedyhard ] the greedy network update problem is np - hard .    our reduction is from the np - hard _ minimum hitting set _ problem .",
    "this proof is similar for both consistency models : strong and relaxed loop - freedom , and we can present the two variants together .",
    "the inputs to the hitting set problem are :    1 .   a universe of  @xmath52 elements  @xmath53 .",
    "2 .   a set @xmath54 of  @xmath55 subsets  @xmath56 .    the objective is to find a subset  @xmath57 of minimal size , such that each set  @xmath58 includes at least one element from  @xmath59 :  @xmath60 . in the following",
    ", we will assume that elements are unique and can be ordered  @xmath61 .",
    "the idea of the reduction is to create , in polynomial time , a legal network update instance where the problem of choosing a maximum set of nodes which can be updated concurrently is equivalent to choosing a minimum hitting set .",
    "while in the initial network configuration , essentially describing two paths from  @xmath4 to  @xmath5 , a maximum update set can be chosen in polynomial time ( simply update all forwarding edges but no backward edges ) , we show in the following that already in the second round , the problem can be computationally hard .",
    "[ ht ]     +    more concretely , based on a hitting set instance , we aim to construct a network update instance of the following form , see figure  [ fig : overview - pic ] . for each element @xmath62",
    ", we create a pair of branches  @xmath63 and  @xmath64 , i.e. ,  @xmath65 branches in total . to model the relaxed loop - free case , in addition to the  @xmath66 branches , we add a source - destination branch , from  @xmath4 to  @xmath5 , depicted on the right in the figure .",
    "we will introduce the following to - be - updated new edges :    1 .",
    "* set edges  ( ses ) : * the first type of edges models sets .",
    "let us refer to the  ( ordered ) elements in a given set  @xmath58 by @xmath67 .",
    "for each set  @xmath68 , we now create  @xmath69 edges from each  @xmath70 to  @xmath71 , in a modulo fashion .",
    "that is , we also introduce  @xmath69 edges from the last element to the first element of the set .",
    "these edges start at the  @xmath72 branch of the smaller index and end at the @xmath73 branch of the larger index .",
    "there are no requirements on how the edges of different sets are placed with respect to each other , as long as they are not mixed .",
    "moreover , only one instance of multiple equivalent ses arising in multiple sets must be kept .",
    "* anti - selector edges  ( aes ) : * these  @xmath52 edges constitute the decision problem of whether an element should be included in the minimum hitting set .",
    "aes are created as follows : from the top of each  @xmath73 branch we create a _ single _ edge to the bottom of the corresponding  @xmath72 branch .",
    "that is , we ensure that an update of the edge from  @xmath74 to  @xmath75 is equivalent to @xmath76 , or , equivalently , every  @xmath77 will not be included in the update set .",
    "* relaxed edges  ( wes ) : * these edges are only needed for the relaxed loop - free case . they connect the  @xmath4-@xmath5 branch to the other branches in such a way that no loops are missed . in other words ,",
    "the edges aim to emulate a strong loop - free scenario by introducing artificial sources at the bottom of each branch . to achieve this , we create a certain number of edges from the  @xmath4-branch to the bottom of every  @xmath73 branch",
    ". the precise amount will be explained at the detailed construction part of creating parallel edges .",
    "see figure  [ fig : overview - pic ]  _ bottom - left _ for an example .",
    "the rational is as follows . if no _ anti - selector edges _",
    "( aes ) are updated , all _ relaxed edges _",
    "( wes ) as well as all _ set edges _  ( ses ) can be updated simultaneously , without introducing a loop . however , since there are in total exactly  @xmath52 aes but each set of ses are  @xmath69 edges  ( hence they will all be updated ) , we can conclude that the problem boils down to selecting a maximum number of element aes which do not introduce a loop .",
    "the set of non - updated aes constitutes the selected sets , the hitting set : there must be at least one element for which there is an ae , preventing the loop . by maximizing the number of chosen aes  ( maximum update set )",
    "we minimize the hitting set .",
    "let us consider an example : in figure  [ fig : overview - pic ]  _ bottom - right _",
    ", if for a set @xmath58 every ae of  @xmath78 is updated , a cycle is created : updating edges  @xmath79 and  @xmath80 results in a cycle with the  @xmath69 edges from  @xmath81 and  @xmath82 .",
    "note that the resulting network update instance is of polynomial size  ( and can also be derived in polynomial time ) . in the remainder of the proof , we show that the described network update instance is indeed legal , e.g. , we have a single path from source to destination , and this instance can actually be obtained after one update round .",
    "before we describe the details of the construction , we first make some fundamental observations regarding greedy updates .",
    "* introducing forwarding edges and branches : * first , a delayer concept is required to establish forwarding edges for the second round .",
    "observe that every forwarding edge  @xmath83 , with  @xmath84 , is always updated by a greedy algorithm in the first round .",
    "a delayer is used to construct a forward edge  @xmath83 , with  @xmath84 , that is created in the second round .",
    "delayer _ for edge  @xmath83 consists of two edges : an edge pointing backwards to  @xmath85 from  @xmath86 with  @xmath87 , plus an edge pointing from there to  @xmath88 .",
    "the forward edge  @xmath89 will be updated in the first round , which yields an edge  @xmath83 due to merging  ( see figure  [ fig : delayer - pic ] ) .",
    "[ ht ]     can be created in round 2 using a helper node  @xmath85.,title=\"fig : \" ] +    we next describe how to create the  @xmath73 and  @xmath72 branches as well as the  @xmath4 branch pointing to the destination @xmath5 ( recall figure  [ fig : overview - pic ] ) .",
    "this can be achieved as follows : from a node close to the source  @xmath4 , we create a path of forward edges which ends at the destination .",
    "each of these forward edges will be updated in the first round , and hence merged with its respective successor , which will be the destination for the very last forward edge .",
    "the nodes belonging to these forward edges will be called _",
    "branching nodes_. every node in - between two _ branching nodes _ will be part of a new branch pointing to the destination .",
    "see figure  [ fig : branching - pic ] for an example .",
    "the rightmost node before the _ branching node _ on the line will also be the topmost node on the branch after the first round update  ( as long as it has an outgoing backward edge , hence not being updated in the first round ) .",
    "we will use the terms right and high ( rightmost - topmost ) and left - low for the first and second round interchangeably .",
    "[ ht ]     +    * introducing special segments : * in our construction , we split the line  ( old path ) into disjoint segments which will become independent branches at the beginning of the second round .",
    "in addition to these segments , there will be two special segments , one at the beginning and one at the end .",
    "the first will not even become an independent branch at the beginning of the second round , but is merely used to realize the delayer edges . behind the very last segment  ( @xmath79 ) and just before  @xmath5",
    ", there is a second special segment , which we call _ relaxed _ : it is needed to create the branch with the source  @xmath4 at the bottom and its connections to the other  @xmath74 branches .    in our construction ,",
    "ses come in groups of  @xmath69 edges .",
    "these edges must eventually be part of a legal network update path , and must be connected in a loop - free manner . in other words , to create the desired problem instance , we need to find a way to connect two branches  @xmath90 and  @xmath91 with  @xmath69 edges , such that there is a single complete path from  @xmath4 to  @xmath5 .",
    "furthermore , these edges should not form a loop .    * creating parallel edges : * parallel edges can be constructed as follows , henceforth called the _ zigzag - approach _",
    "( figure  [ fig : nconnection - pic ] ) : split the branch  @xmath91 into two different parts .",
    "the first part  @xmath92 on the left side  ( respectively bottom of the branch ) will be used to complete the path but can only be reached over backward edges .",
    "the second part  @xmath93 will receive the incoming edges from the other branch ,  @xmath90 .",
    "start at a node , say  @xmath94 on  @xmath90 . here",
    "create an edge to a node of  @xmath93 , say  @xmath95 and from there a backward edge to a node of  @xmath92 , say  @xmath96 . afterwards use a delayed edge to connect to  @xmath94 s right  ( respective to the line ) neighbor , @xmath97 . from here",
    "create the next edge to  @xmath95 s right neighbor ,  @xmath98 and the backward edge to  @xmath99 on  @xmath92 again .",
    "repeat this procedure  @xmath69 times .",
    "this zigzag construction indeed ensures loop - freedom . to see this , note that all incoming edges from the  @xmath100 branch will always connect to the  @xmath93 part of  @xmath91 . from here the way back to  @xmath90  ( or potentially any other branch that connects with  @xmath93 )",
    "can only be completed if any of the backward edges from  @xmath93 to @xmath92 has been updated .",
    "this can not be true for the strong loop freedom definition , since no backward edge can ever be updated and the edge is backward in the first and the second round .",
    "for relaxed loop freedom it also can not be updated in the first round since it would create a loop on the  @xmath101 path , which is a line of all nodes in the first round . in the second round it will not be included since we make sure that a maximum update always includes the wes which will be incoming at the very left side of @xmath93 , and hence can not be updated in the same round with any backward edge on this branch .    in order to ensure that all the wes will always be included",
    ", we will create  @xmath102 wes to every _ in _ branch .",
    "this is always more than the amount of backward edges on a single branch  @xmath91 since they are only created as a path completion for the ses .",
    "we will have at most  @xmath103 ses incoming in a case where this node is connected to every other node  ( but itself ) .",
    "choosing the wes will immediately force that none of the backward edges from  @xmath93 to  @xmath92 will be included , as they might cause a cycle on a path that might be in - between  @xmath4 and  @xmath5 .",
    "the  @xmath104 wes to a branch  @xmath88 are simple to create . here , we do not need to take care about other branches reached from the _ relaxed _ branch .",
    "hence we can create the way back to the _ relaxed _ branch without the detour over the  @xmath105 part .",
    "this is because the wes will always be the incoming edges on the leftmost part of  @xmath106 without the possibility of any other parallel edges making use of them .",
    "[ ht ]     +      given these gadgets , we are able to complete the construction of our problem instance .    * realizing the delayer : * the first created segment , _ temp _ , serves for edges that are created using the _ delayer _ concept .",
    "this is due to our construction : every node that will be created in this interval in our construction will be a forward node and therefore updated in the first greedy round .",
    "the _ temp _ segment will be located right after the source  @xmath4 on the line .    * realizing the branches : * we create two segments for each  @xmath62 , one  @xmath72 and one  @xmath73 , and sort them in descending global order  ( and depict them from left to right ) w.r.t .",
    "@xmath62 , with the  @xmath72 segment closer to  @xmath4 than the  @xmath73 segment for each  @xmath107 , i.e. @xmath108  @xmath109 .",
    "[ ht ]     +    * connecting the path : * we will now create the new path from the source  @xmath4 to the destination  @xmath5 through all the different segments .",
    "this path requires additional edges .",
    "we will ensure that these edges can always be updated and hence do not violate the selector properties .",
    "moreover , we ensure that they do not introduce a loop . in order to create a branch with  @xmath4 at the bottom ( to ensure that the proof will also hold for relaxed loop - freedom ) , we start our path from the source  @xmath4 to a node  @xmath110 on the very left part of the _ relaxed _ segment . from here",
    "we need to create the  @xmath104 connections to every other @xmath74 branch , more precisely to the very left of the top part of this branch  @xmath111 : the relaxed edges  ( wes ) . starting from  @xmath110",
    ", we create the  @xmath104 zigzag edges we postulated earlier  ( see section  [ sec : concepts ] ) to the  @xmath79 segment .",
    "once this is done , we repeat this process for the remaining @xmath74 connecting them in the same order blockwise , as they are ordered on the line .",
    "see figure  [ fig : relaxedbranch - pic ] .",
    "[ ht ]     connections to each  @xmath74 segment of the line , as shown in section  [ sec : concepts ] .",
    "the  @xmath104 connections are visualized as a single edge in the first round to enhance visibility.,title=\"fig : \" ] +    at the beginning of the second round , we will now have a branch with the source  @xmath4 at the bottom and @xmath69 edges to each of the  @xmath74 branches .",
    "the next step is to connect the out branches with the in branches  ( the set edges ) . for each set  @xmath112 and each pair  @xmath113 with no  @xmath114",
    ", we create  @xmath69 edges from  @xmath75 to @xmath115 , more precisely to the top part  @xmath116 somewhere above the wes .",
    "each pair @xmath117 only needs to connect once with the  @xmath69 edges , even if it occurs in several different sets of  @xmath19 .",
    "the last element  @xmath118 of a set  @xmath119 will additionally need to be connected to the first element of the set  ( the modulo edges ) .",
    "after the  @xmath69 connections to  @xmath80 , the path returns at the right most  ( or highest in the  @xmath120-branch ) node in the _ relaxed _ segment . from here",
    "we create a backward edge to the left part of  @xmath81 . here , we create  @xmath69 connections to every @xmath74 , which is the next larger element in any of the sets .",
    "an example is shown in figure  [ fig : connectbranches - pic ] .",
    "[ ht ]     branch with the branches  @xmath121 , @xmath122 ,  @xmath80 .",
    "this scenario would be created for the sets :  @xmath123,@xmath124 ,  @xmath125 .",
    "the densely dashed black edges show the outgoing edges from  @xmath81 .",
    "the loosely dashed black edges are the backward edges from the top part of a branch @xmath74 to its bottom part  ( @xmath111 to  @xmath126 ) .",
    "the densely dashed grey edges are the way back from @xmath74 to  @xmath81 and are needed to complete the path.,title=\"fig : \" ] +    to complete the  @xmath69 connections for every pair , we proceed as follows : we connect the  @xmath81 branch to all required in - branches , then add the edge from @xmath81 to the  @xmath127 branch , then add the edges from the  @xmath127 branch to all required in - branches , etc . generally , we interleave adding the edges from the  @xmath75 branch to all required in - branches and then add the  @xmath128-out to  @xmath129-out edge . until the path arrives at the end of the last out branch ,  @xmath82 :    * _",
    "step a - create the  @xmath69 set specific edges : _ here we create  @xmath69 connections to every successor in the respective sets  ( at most once per pair ) .",
    "if this element is the largest element in a set , it needs to be connected to the in part of the smallest element of this set again . here",
    "the delayer concept needs to be used for the modulo edges . *",
    "_ step b - connecting the out branches : _ in order to create the next  @xmath69 connections from the next out segment  @xmath130 , we need to connect it from our current out segment @xmath75 .",
    "the edge therefore needs to point to the rightmost part of  @xmath130 .",
    "since this edge is always a backward edge in the first round  ( we start closer to the destination and move backward towards the source ) , it will turn out to be an edge which points to the very top of  @xmath130 at the beginning of the second round .",
    "this assures that there are no loops created , since the only way is going directly towards the destination .",
    "from here we create an edge pointing to the very left side of  @xmath130  ( evolving to a backward rule from top to bottom of the branch in the second round , hence not being part of the update set in the first nor the second round ) .    [ ht ]    , shown in densely dashed black .",
    "the edges shown in desnely dashed grey are needed to keep the path complete and the backward edges in loosely dashed black are needed to ensure that only the destination can be reached from that point in the second round.,title=\"fig : \" ] +    to finish the construction , we need to add the anti - selector edges  ( aes ) , and connect the in and out branches of every single  @xmath118 with each other .",
    "the goal is to create , for each given  @xmath128 , an edge from the top of each  @xmath74 to the bottom of each  @xmath75 . this way ,",
    "if this edge is included in the update , a loop may be formed : as every incoming edge to  @xmath74 arrives below the aes start point and every outgoing edge on  @xmath75 is above ae s destination . the decision to not include one of these edges is equivalent to  @xmath131 in the minimum hitting set problem . in order to keep the path connected",
    "we will also need to include edges from  @xmath75 to  @xmath132 , compare figure  [ fig : hittingedges - pic ] .",
    "these edges will point to the top of  @xmath132 and therefore do not create loops , since the only way is going directly to the destination . from here",
    "we create another backward edge to its left neighbor such that there is no possible other way than traversing towards  @xmath5 from this point . without this backward edge loops",
    "may be created , since it introduces connections between branches which are not both in a set  @xmath58 of the hitting set problem .",
    "therefore , an update of one of the additional connector edges will never lead to a loop , and the edges can all be included in the update set of the round 2 .",
    "the construction of these edges is straightforward . from the end of the current path which is located on the  @xmath82 segment",
    ", we create a delayed edge  ( over _ temp _ ) to the very right part of the  @xmath79 segment . from here",
    "we construct the path as described with a short backward edge to its left neighbor and then to the very left part of the @xmath75 segment and again to the very right part of the  @xmath132 segment afterwards , until we arrive at the very left part of the  @xmath82 segment .",
    "it remains to create the segments and branches for the second round . from  @xmath82",
    ", we create a backward edge to the _ temp _ part . from here",
    "we use the branching concept and connect all horizontal nodes in - between the single parts that we created on the line  ( see figure  [ fig : finalstep - pic ] ) .",
    "[ ht ]     +    in summary , we ensured that already after a single greedy first update round , we end up in a situation where choosing the maximum set of updateable nodes is equivalent to choosing the minimum hitting set .",
    "while the computational hardness is disappointing , we can show that there exist several interesting specialized and approximative algorithms .",
    "* optimal algorithms .",
    "* there are settings where an optimal solution can be computed quickly . for instance , it is easy to see that in the first round , in a configuration with two paths , updating all forward edges is optimal : forward edges never introduce any loop , and at the same time we know that backward edges can never be updated in the first round , as any backward edge edge alone  ( i.e. , taking effect in the first round ) , will immediately introduce a loop . in the following ,",
    "we first present an optimal algorithm for  @xmath28 , for trees with only two leaves .",
    "we will then extend this algorithm to  @xmath29 .",
    "[ lem : stronglf ] a maximum  @xmath28 update set can be computed in polynomial - time in trees with two leaves .",
    "recall that there are three types of new edges in the graph  ( see also figure  [ fig : edges ] ) : forward edges  ( @xmath133 ) , backward edges  ( @xmath134 ) and horizontal edges  ( @xmath135 ) , hence  @xmath136 .",
    "moreover , recall that forward edges can always be updated while backward edges can never be updated in  @xmath28 .",
    "thus , the problem boils down to selecting a maximum subset of  @xmath135 , pointing from one branch to the other . if there is a simple loop @xmath137 such that  @xmath138 , then  @xmath139 and we say that the two edges  @xmath140 cross each other , written @xmath141 .    we observe that the different edge types can be computed efficiently . for illustration ,",
    "suppose the policy graph  @xmath142  ( the union of old and new policy edges ) is given as a straight line drawing  @xmath143 in the 2-dimensional euclidean plane , such that the old edges of the 2-branch tree form two disjoint segments which meet at the root of the tree  ( the destination ) , and such that each node is mapped to a unique location .",
    "given the graph , such a drawing  ( including crossings ) in the plane can be computed efficiently . also note that there could be other edges which intersect w.r.t .",
    "the drawing  @xmath143 , but those are not important for us .",
    "now create an auxiliary graph  @xmath144 where  @xmath145 , @xmath146 .",
    "the graph  @xmath147 is bipartite , and therefore finding a minimum vertex cover @xmath148 is equivalent to finding maximum matching , which can be done in polynomial time .",
    "let  @xmath149 , then the set  @xmath150 is a minimum size subset of  @xmath135 which is not updatable .",
    "therefore the set  @xmath151 is the maximum size subset of  @xmath135 which we can update in a  @xmath28 manner .",
    "we conclude the proof by observing that all these algorithmic steps can be computed in polynomial time .",
    "[ ht ]     and  @xmath152 are crossing each other .",
    "the backward edge  @xmath153 is shown in loosely dashed black and the forward edges in densely dashed grey .",
    "note that @xmath4 does not necessarily have to be a leaf.,title=\"fig : \" ] +    [ lemma : weaklf ] a maximum  @xmath29 update set can be computed in polynomial - time in trees with two leaves .",
    "we prove the lemma by presenting a polynomial - time reduction to the strong loop - free case .",
    "let us fix the path  ( i.e. , branch ) in the tree consisting of the currently active edges which includes both the source and the destination :  @xmath154 .",
    "note that in the branch which contains  @xmath155 there may exist some vertices which have a path to @xmath4 : those vertices are irrelevant for our construction and we just consider the path  @xmath156 of the old policy starting at  @xmath4 .",
    "let us refer to the entire path in the other branch by @xmath157 , omitting the vertex  @xmath5 . here ,",
    "node @xmath158 is the node with the lowest  @xmath159-coordinate in the drawing  @xmath143 ( for definition of @xmath143 see the proof of lemma  [ lem : stronglf ] ) . in this case",
    ", we can update  @xmath134 edges as long as they are not in any path from  @xmath4 to  @xmath5 .",
    "therefore , the objective is to find the maximum subset  @xmath160 which is not part of any loop reachable from  @xmath4 .    without loss of generality",
    ", we can assume that there is no  @xmath134 edge which connects two vertices of the path  @xmath161 : we can not update those edges anyway , and hence we can ignore them . if we simulate  @xmath134 edges with  @xmath135 edges , then the problem becomes equivalent to  @xmath28 which is in  @xmath162 . to see this ,",
    "suppose @xmath163 , create a new graph  @xmath147 out of  @xmath6 by adding  @xmath55 vertices @xmath164 to  @xmath165 to obtain  @xmath166 , and a set of edges  @xmath167 , where the tail of an edge  @xmath168 is  @xmath47 .",
    "after that , we delete all edges in  @xmath134 . we can now find the maximum set of the horizontal edges in @xmath147 which can be updated using the same algorithm as we had for  @xmath28 .",
    "if any edge  @xmath169 has been chosen in the algorithm for  @xmath28 in the  @xmath147 , we choose @xmath170 for the update as well . these edges together with all forward edges and the chosen edges from the set  @xmath135 in  @xmath147 give us the maximum set of edges  @xmath171 which can safely be updated in the  @xmath29 model in  @xmath6 .",
    "let  @xmath172 .",
    "notice that there is no loop reachable from  @xmath4 which uses only edges in  @xmath173 in @xmath174 , by the construction of  @xmath147 .",
    "moreover , there is no loop in  @xmath175 which uses edges in  @xmath134 and which is reachable from  @xmath4 . to see the correctness of the second claim , suppose an edge  @xmath176 is chosen such that there is a path  @xmath162 which goes through an edge  @xmath177 and connects  @xmath4 to @xmath47",
    "then , in  @xmath147 there was an edge  @xmath178 . but at least one of the edges  @xmath179 and  @xmath180 has been eliminated for the update in  @xmath147 then , by the construction of the algorithm , either there is no edge like  @xmath181 , or there is no path like  @xmath162 which goes through  @xmath179 .",
    "we proved that the solution is valid .",
    "for the optimality , we just note that there is a one - to - one relationship between simple loops of  @xmath6 which are reachable from  @xmath4 , and loops of  @xmath147 .",
    "this means that if we make @xmath147 loop - free , we transfer  @xmath6 to the graph which has no loop reachable from  @xmath4 .",
    "so any optimal solution for  @xmath147 is an optimal solution for  @xmath6",
    ".    * approximation algorithms . * even in scenarios for which there is no optimal polynomial time scheduling algorithm , there can exist good approximations .",
    "it is easy to observe that there is a reduction to the maximum acyclic subgraph problem  ( _ masp _ ) which ensures that both @xmath29 and @xmath28 can be approximated at least as well as masp .",
    "it is also easy to see that the problem for strong loop - freedom  ( for  @xmath28 ) is @xmath182-approximable in general , as the problem boils down to finding a maximum subset of @xmath135 edges which are safe to update , and at least half of the  @xmath135 edges are pointing out to the left resp .",
    "right , and we can take the majority .",
    "similarly for : let @xmath133 be the set of vertices where every @xmath183 appears along a walk between source and destination .",
    "similar to , at least half of the edges of @xmath133 are safe to update , and we can find these edges quickly .",
    "also every @xmath184 , where @xmath185 or @xmath186 , is safe to update .",
    "so we have at least a @xmath182-approximation .    however , for a small number of leaves , even better approximations are possible .",
    "the following lemma can be proven by an approximation preserving reduction to the hitting set problem .",
    "[ lem : apx ] the optimal  @xmath28 schedule is @xmath187-approximable in polynomial time in scenarios with exactly three leaves . for scenarios with four leaves , there exists a polynomial - time @xmath188-approximation algorithm .",
    "we use an approximation preserving reduction to the  @xmath5-hitting set problem which is  @xmath189-approximable  @xcite , and particularly , we use a  @xmath190-hitting set which gives us a  @xmath187-approximation algorithm .",
    "let  @xmath142 be the update graph with at most three leaves and let  @xmath135 be the set of the horizontal edges .",
    "for every closed simple loop  @xmath191 we have  @xmath192 .",
    "furthermore  @xmath193 . given these observations ,",
    "we construct our hitting set as follows .",
    "let  @xmath194 and let  @xmath133 be a one - to - one mapping  @xmath195 $ ] .",
    "for each simple loop  @xmath196 let  @xmath197 =  @xmath198 , and create a subset  @xmath199 . note that if  @xmath200 then we have a subset  @xmath58 of size  @xmath201 .",
    "there are at most  @xmath202 simple loops , as choosing any set of size at most  three edges from  @xmath203 forces at most one simple loop .",
    "so we have @xmath204 loops with  @xmath190 edges in  @xmath135 and  @xmath205 loops with two edges in  @xmath135 .",
    "furthermore the hitting set for  @xmath206 gives a minimum set of update edges to be removed ; on the other hand , every subset  @xmath58 is of cardinality at most  @xmath190 . this gives a  @xmath207-approximation on the size of subset  @xmath208 , which we do not update .",
    "on the other hand , in the optimal solution  @xmath209 we have  @xmath210 resp .",
    "@xmath211 , so the approximation factor will be at least  @xmath212 : this is a  @xmath187-approximation , as claimed . for four leaves , a similar argument works , and we omit the proof .",
    "in their seminal work , reitblatt et al .  @xcite initiated the study of network updates providing strong , per - packet consistency guarantees , and the authors also presented a 2-phase commit protocol .",
    "this protocol also forms the basis of the distributed control plane implementation in  @xcite .",
    "mahajan and wattenhofer  @xcite started investigating a hierarchy of transient consistency properties  in particular also  ( strong ) loop - freedom but for example also bandwidth - aware updates  @xcite  for destination - based routing policies .",
    "the measurement studies in  @xcite and  @xcite provide empirical evidence for the non - negligible time and high variance of switch updates , further motivating their and our work .",
    "in their paper , mahajan and wattenhofer proposed an algorithm to `` greedily '' select a maximum number of edges which can be used early during the policy installation process .",
    "this study was recently refined in  @xcite , a parallel work to ours , where the authors also establish a hardness result for destination based routing ( single- and multi - destination ) .",
    "our work builds upon  @xcite and complements the results in  @xcite : we consider the scheduling complexity of updating _ arbitrary routes _ which are not necessarily destination - based .",
    "interestingly , our results ( using a different reduction ) show that even with the requirement that the initial and the final routes are simple paths , the problem is np - hard .",
    "moreover , our results hold for both the strong @xmath28 and the relaxed @xmath29 loop - free problem variants introduced in  @xcite ( this distinction does not exist in  @xcite ) .",
    "the @xmath28 can be seen as a special variant of the dual feedback arc set problem  ( fasp ) resp .",
    "maximum acyclic subgraph problem  ( masp ) : important classic problems in approximation theory  @xcite .",
    "in particular , it is known that dual - fasp / masp can be @xmath213 approximated on general graphs  ( for arbitrary small @xmath214 ) .",
    "the results presented in this paper also imply that better approximation algorithms and even optimal polynomial - time algorithms exist for special graph families , namely graph families describing network update problems ; this may be of independent interest .",
    "the  @xmath29 variant is a new optimization problem , and to the best of our knowledge , existing bounds are not applicable to this problem .",
    "we should note that fasp is in fpt  @xcite , and the hitting set problem is w[2]-hard  @xcite . in our hardness construction",
    "we actually find a reduction from hitting set to fasp for particular graph classes .",
    "but the reduction is not parameter preserving , so the w - hierarchy does not collapse .",
    "finally , our model is orthogonal to the network update problems aiming to minimizing the number of interactions with the controller ( the so - called _ rounds _ ) , which we have recently studied for single  @xcite and multiple  @xcite policies , also including additional properties , beyond loop - freedom , such as waypointing  @xcite .",
    "the two objectives conflict  @xcite , a good approximation for the number of update edges yields a bad approximation for the number of rounds , and vice versa .",
    "we conclude our contribution with some remarks .",
    "first , it is easy to observe that there is a reduction to the maximum acyclic subgraph problem  ( _ masp _ ) which ensures that both @xmath29 and @xmath28 can be approximated at least as well as masp .",
    "it is also interesting to study the hardness of the problem on some special graph classes . by @xmath215",
    "we denote the underlying undirected graph of a graph @xmath6 which is obtained by replacing directed edges with undirected edges , and deleting parallel edges .",
    "we have the following lemma for bounded @xmath216  @xcite scenarios .",
    "thanks to courcelle s theorem  @xcite , we can solve the feedback arc set problem in bounded @xmath216 digraphs in polynomial time .",
    "this directly gives a solution for slf .",
    "for , we find all vertices which are on a walk between source and destination , and we apply courcelle theorem to the subgraph of @xmath6 induced by these vertices .    unfortunately the undirected width measures are not very useful in directed graphs .",
    "analogously to @xmath216 which is defined for undirected graphs , there exists a directed @xmath216 notion for directed graphs , introduced by johnson et al .",
    "we refer the reader to the provided reference for the definition .",
    "an interesting question regards whether @xmath29 and , and more generally masp , are polynomial - time solvable in digraphs of bounded directed treewidth and bounded degree .",
    "there are two negative results related to this question .",
    "first , it has been shown that the feedback arc set problem  ( fasp ) is already np - complete  @xcite in digraphs of directed tree width at most  @xmath217 .",
    "their hardness construction is based on a graph which has a bounded degree in all vertices except for one vertex .",
    "it seems that with binarization one can easily adapt their proof to show that the fasp problem still remains hard in digraphs of bounded degree and bounded directed treewidth .",
    "but on bounded degree graphs , vertex cover problems  @xcite are np - complete , and a simple construction for vertex cover yields an np - hardness result for fasp in those graphs as well .",
    "this suggests that directed tree - width can not be exploited in our problem .",
    "however , another kind of directed width measure may be more useful : the _ directed path width _ is defined very similarly to the directed treewidth ; intutively the graph looks like a `` thick directed path '' .",
    "none of the negative results for bounded degree graphs on graphs of bounded directed tree - width can be extended to digraphs of bounded directed path - width with bounded degree .",
    "we claim the following : there is a function @xmath218 such that for a digraph @xmath6 of directed path - width @xmath55 and maximum degree @xmath5 , there is an algorithm which runs in time and space @xmath219 and finds an optimal solution to fasp .",
    "* acknowledgments .",
    "* the research of saeed amiri has been supported by the european research council ( erc ) under the european union s horizon 2020 research and innovation programme ( erc consolidator grant distruct , agreement no 648527 ) .",
    "szymon dudycz , arne ludwig , and stefan schmid . ca nt touch this : consistent network updates for multiple policies . in _ proc .",
    "46th ieee / ifip international conference on dependable systems and networks ( dsn ) _",
    ", 2016 .",
    "rong - chii duh and martin frer .",
    "approximation of k - set cover by semi - local optimization . in _ proc .",
    "29th annual acm symposium on theory of computing ( stoc ) _ , stoc 97 , pages 256264 , new york , ny , usa , 1997 .",
    "acm .",
    "xin jin , hongqiang liu , rohan gandhi , srikanth kandula , ratul mahajan , jennifer rexford , roger wattenhofer , and ming zhang .",
    "dionysus : dynamic scheduling of network updates . in _ proc .",
    "acm sigcomm _ , 2014 .",
    "arne ludwig , matthias rost , damien foucard , and stefan schmid .",
    "good network updates for bad packets : waypoint enforcement beyond destination - based routing policies . in _ proc .",
    "acm workshop on hot topics in networks ( hotnets ) _ , 2014 .",
    "oded padon , neil immerman , aleksandr karbyshev , ori lahav , mooly sagiv , and sharon shoham . decentralizing sdn policies . in _ proc .",
    "42nd annual acm sigplan - sigact symposium on principles of programming languages ( popl ) _ , pages 663676 , 2015 .",
    "wenxuan zhou , dong  ( kevin ) jin , jason croft , matthew caesar , and philip  brighten godfrey .",
    "enforcing customizable consistency properties in software - defined networks . in _ proc .",
    "12th usenix symposium on networked systems design and implementation ( nsdi ) _ , pages 7385 , 2015 ."
  ],
  "abstract_text": [
    "<S> the software - defined networking paradigm introduces interesting opportunities to operate networks in a more flexible , optimized , yet formally verifiable manner . despite the logically centralized control , however , a software - defined network  ( sdn ) is still a distributed system , with inherent delays between the switches and the controller . </S>",
    "<S> especially the problem of changing network configurations in a consistent manner , also known as the consistent network update problem , has received much attention over the last years . in particular </S>",
    "<S> , it has been shown that there exists an inherent tradeoff between update consistency and speed . </S>",
    "<S> this paper revisits the problem of updating an sdn in a transiently consistent , loop - free manner . </S>",
    "<S> first , we rigorously prove that computing a maximum ( `` greedy '' ) loop - free network update is generally np - hard ; this result has implications for the classic maximum acyclic subgraph problem ( the dual feedback arc set problem ) as well . </S>",
    "<S> second , we show that for special problem instances , fast and good approximation algorithms exist . </S>"
  ]
}