{
  "article_text": [
    "we are interested in large scale high - performance scientific parallel visualization with real - time interaction .",
    "more precisely , we want to support the interactive extraction of insight from large sets of data .",
    "also , in order not to miss important details in the data , we would like to develop high resolution visualization .",
    "our interest is motivated by today s technological advances , which stimulate and facilitate the development of increasingly complicated mathematical models .",
    "visualization with real - time interaction is essential for better analysis and understanding of the masses of data produced by such models , or by devices such as magnetic resonance imaging ( mri ) and laser - microscope scanners .",
    "some of the applications that we are interested in and work on are given on figure [ applications ] .",
    "others come from high - energy physics , climate modeling , etc .",
    "currently the size of the data sets that we are dealing with is around @xmath0 gb .",
    "x @xmath1 x @xmath1 grid ; middle : fluid flow isosurface visualization ; right : material micro - geometry studies : crushed rock volume visualization on a @xmath2 x @xmath2 x @xmath1 grid .",
    "the three examples are rendered in parallel on a display composed of @xmath3 tiles.,title=\"fig:\",width=163 ]   x @xmath1 x @xmath1 grid ; middle : fluid flow isosurface visualization ; right : material micro - geometry studies : crushed rock volume visualization on a @xmath2 x @xmath2 x @xmath1 grid .",
    "the three examples are rendered in parallel on a display composed of @xmath3 tiles.,title=\"fig:\",width=184 ]   x @xmath1 x @xmath1 grid ; middle : fluid flow isosurface visualization ; right : material micro - geometry studies : crushed rock volume visualization on a @xmath2 x @xmath2 x @xmath1 grid .",
    "the three examples are rendered in parallel on a display composed of @xmath3 tiles.,title=\"fig:\",width=163 ]    we develop an inexpensive and , as the results show , efficient application .",
    "the approach is as follows :    * do remote parallel rendering to a large tiled display ( see for example figure [ applications ] where we show displays composed of @xmath3 tiles ) .",
    "* use commodity - based clusters connected with high speed network . * extend and combine already existing apis such as chromium , open inventor , vtk , etc .",
    "the apis considered are open source .",
    "open inventor ( see @xcite ) is a library of c++ objects and methods for building interactive 3d graphics applications , vtk ( see @xcite ) is another widely used api for visualization and image processing , and chromium ( see @xcite ) is an opengl @xcite interface for cluster visualization to a tiled display .",
    "chromium is based on wiregl @xcite and provides a scalable display technology .",
    "the latest chromium paper @xcite reports on the implementation of components ( stream processing units , or spus ) that can be used in sort - last parallel graphics applications .",
    "more on the sort - last parallel rendering approach can be found in @xcite and @xcite .",
    "there are feasible alternatives to our approach .",
    "for example , the tiled display can be replaced with a high resolution flat panel driven by a single workstation , the visualization clusters can be replaced with fast sequential machines , and the process of extending and combining already existing apis can be replaced with building the entire visualization system from scratch . the ibm s t221 display with its maximum resolution of @xmath4 brings to the scientist s desktop a resolution that is high enough for many applications . for such cases",
    "this is a preferred alternative and we have it as an option in our implementation .",
    "similarly , for `` small '' data sets we prefer sequential processing . extending and combining visualization apis is a popular and in many cases preferred development approach since one can easily leverage already existing and powerful apis .",
    "examples are the extension of vtk to paraview ( see @xcite ) and parallel vtk ( see @xcite ) , visit ( see @xcite ) , etc",
    ". building an entire visualization system from scratch may be efficient for very specific requirements , but in general is expensive and time consuming ( see for example nasa s long term project parvox @xcite ) . our goals ,",
    "apart from developing the application outlined above , also include studying and identifying the singularities of the chromium api .",
    "we concentrate on chromium s sort - first rendering , a model inherited , and further developed from the wiregl api .    the parallel model that we consider is mimd ( multiple instructions  multiple data ) .",
    "mimd parallel models are common in the design of parallel visualization software for clusters of workstations .",
    "a fundamental framework is when cluster nodes process separate parts of a global scene and their output is composited and rendered to a tiled display .",
    "providing mimd model visualization systems with efficient user interaction has become a task of great interest .",
    "see for example @xcite .",
    "the continuous interest also prompted the development of a new cluster rendering utility toolkit ( crut ) which was reported in @xcite .",
    "crut is a glu - like toolkit that will facilitate the development of user interaction within chromium , and hence the development of applications and visualization api extensions like the one that we developed .",
    "we pursue a master / slave paradigm : we declare one of the cluster nodes as gui master , use the master to intercept the sequential user input , and broadcast that input in a user defined protocol to the other nodes ( here called slave nodes ) .",
    "this yields a system where the gui master sends to the slave nodes instructions of `` how and when '' to redraw their part of the scene .",
    "the user interface in this case is part of the visualization software .",
    "another implementation is to have the gui master separate from the visualization software .",
    "the interaction in this case would be through a gui window that will simulate a `` parallel interaction device '' that takes a sequential user input and broadcasts it to the cluster nodes ( through sockets ) .",
    "the details are given in the following sections .",
    "the article is organized as follows . in section [ model ]",
    "we describe our model framework and its implementation in extending open inventor and vtk .",
    "next ( in section [ results ] ) we discuss issues that are important for the development of high performance visualization on clusters of workstations . also , we provide some of our performance results . the last section ( section [ conclusions ] ) summarizes the results of this work .",
    "parallel gui for a mimd parallel visualization model requires the presence of a master node that will synchronize with the other nodes the redrawing of the consecutive scenes according to a sequential user input .",
    "we consider two variations of parallel gui . both have similar visualization pipelines ( see figure [ pipeline ] ) .",
    "the parallel gui ( paramouse ) gets the sequential user input ( through mouse , keyboard , etc . ) and broadcasts it to the opengl applications through sockets .",
    "every application is visualizing a separate part of a global scene .",
    "the applications are bound together by mpi communications .",
    "the opengl calls that the applications make are intercepted by chromium and sent through the network to the visualization servers , which composite the input and render it to a tiled display .",
    "chromium s parallelization model ( denoted in the article by cpm ) is represented with the pseudo - code :    ....      glxmakecurrent(getdisplay ( ) , getnormalwindow ( ) ,                    getnormalcontext ( ) ) ;    if ( clearflag )      glclear(gl_color_buffer_bit | gl_depth_buffer_bit ) ;    glbarrierexeccr(master_barrier ) ;      do sequential opengl rendering of the local scene      glbarrierexeccr(master_barrier ) ;    if ( swapflag )      glxswapbuffers(getdisplay ( ) , getnormalwindow ( ) ) ;    else      glxswapbuffers(getdisplay ( ) , cr_suppress_swap_bit ) ; ....    where the display obtained is * composited * if clearflag is @xmath0 for all processors , swapflag is @xmath0 for processor with rank @xmath5 , and @xmath5 for the rest , and * tiled * if clearflag and swapflag are @xmath0 only for processor with rank @xmath5 .    to extend open inventor and vtk ( or any api ) to support interactive cluster visualization within the above framework we did the following :    *",
    "apply the cpm to the apis rendering method(s ) .",
    "* implement the paramouse parallel gui or extend the api s gui using the master - slave concept .    to implement the first step for open inventor we extended the soxtrenderarea::redraw ( ) method . for vtk",
    "this step is implemented by david thompson , sandia national laboratory @xcite .",
    "we implemented in open inventor the master - slave concept by extending the gui that ivview provides .",
    "function main in ivview was extended by implementing the pseudo - code :    ....      declare processor with rank 0 as master ;    if ( master )      run gui as implemented in ivview ;    else      listen for instructions from the master ; ....    we extended the callback functions triggered by the devices that open inventor s gui handles ( mouse , keyboard , etc ) .",
    "the callback functions responding to user input have mpi_isend of the invoked user input in the master node to the slave nodes .",
    "the slave nodes are in `` listening '' mode ( mpi_recv or mpi_irecv while animating ) , which is given with the pseudo - code below , and upon receiving data , representing instructions in an internally defined protocol , they call the action for the invoked input and redraw their part of the global scene ( if necessary ) .    ....",
    "// initialize inventor    sodb::init ( ) ;    sonodekit::init ( ) ;    sointeraction::init ( ) ;          // build the inventor 's objects and scene graphs     soseparator * root = new soseparator ;    root->ref ( ) ;        readscene(root , files ) ;         // create a slave node examinerviewer    soexaminerviewer * viewer = new soexaminerviewer(crrank ) ;    viewer->setscenegraph(root ) ;      //",
    "chromium initialization        crctx = crcreatecontextcr(0x0 , visual ) ;    crmakecurrentcr(crwindow , crctx ) ;    glbarriercreatecr ( master_barrier , crsize ) ;      glenable(gl_depth_test ) ;    viewer->mainloop ( ) ; ....    the soexaminerviewer class is based on the open inventor s soxtexaminerviewer class .",
    "the difference is that soexaminerviewer does not have xt window interface function calls and the rendering is with the cpm .",
    "the user interface is through the ivview window ( see figure [ interface ] , left ) , which is blank and used only for the user input .",
    "the scene is drawn in separate windows / tiles .",
    "the example from figure [ interface ] ( right ) shows a display with @xmath3 tiles .",
    "there are @xmath3 applications running , each of which visualize a sphere .         in vtk",
    "s master - slave model we extend the vtkxrenderwindowinteractor class by :    * implementing `` pure '' x windows gui ( no gl calls ) . * adding mpi send / receive calls for mouse and keyboard events .    for the paramouse interface we added in vtk a new interactor style , + called vtkinteractorstylepmouse .",
    "we did our implementation and testing on a beowulf cluster with @xmath3 nodes , each node with @xmath6 pentium iii processors , running at 1 ghz .",
    "every node has quadro2 pro graphics card .",
    "the nodes are connected into a local area network with communications running through @xmath7 mbit / sec fast ethernet or @xmath0 gbit / sec fiber optic network .",
    "more about the general performance of this particular machine can be found in @xcite .",
    "the experience that we had in developing interactive parallel visualization is summarized as follows :    1 .   for the parallel model considered performance is problem and interaction specific .",
    "+ for example , depending on the data and the user interaction , the entire global scene may be mapped to a single tile of the display .",
    "also , the chromium bucketing strategy @xcite will not work for scenes composited of non - localized consecutive polygons .",
    "the gui communications time is negligible compared to the visualization time , which leads us to the scalability results reported in @xcite .",
    "this statement is supported by our next observation .",
    "3 .   we can send approximately @xmath8 `` small '' ( less then 100 bytes ) messages / sec ( see @xcite ) .",
    "chromium automatically minimizes data flow , except for geometry flow ( see below ) .",
    "it is advisable to keep small static scenes in display lists ( see below ) .",
    "the network data flow is usually the bottleneck in the visualization pipeline that we consider .",
    "chromium provides several techniques to minimize it .",
    "they are : simplified network protocol , bucketing , and state tracking ( see @xcite ) .",
    "none of these techniques however are intended for the automatic minimization of the geometry flow , which usually is the most expensive component .",
    "for example in animation the same objects are drawn without ( or with minimal ) change from frame to frame .",
    "nevertheless the scene is transmitted over the network for every frame , creating an enormous bottleneck , as shown in the next example .",
    "data flow minimization techniques that exploit spacial or temporal coherence of consecutive frames ( see for example @xcite ) are not supported within the current framework .",
    "the following example illustrates items @xmath3 and @xmath9 from the above observations .",
    "we use a small static scene composed of spheres with spikes , as the ones shown on figure [ interface ] , right . each sphere",
    "is composed of @xmath10 triangles .",
    "sequentially , one sphere is drawn by the open inventor at a rate of @xmath11 frames / sec , i.e. @xmath12 triangles / sec . for @xmath6 spheres",
    "the rate is @xmath13 frames / sec or @xmath14 triangles / sec , etc .",
    "the speed of visualizing @xmath6 spheres on @xmath6 processors ( @xmath6 tiles ) is approximately @xmath15 frames / sec .",
    "the composited visualization ( @xmath6 processors , @xmath0 tile ) is approximately @xmath16 frames / sec",
    ". runs with various problem sizes and parallel visualization configurations give similar results in favor of the sequential execution .",
    "the enormous difference is due to the fact that in the first case the scene resides in the graphics card memory , while in the second the same scene is transmitted over the network for every frame .",
    "table @xmath0 gives more results related to the network s bandwidth bottleneck and the overall performance of the system .",
    "the results are for different applications using the @xmath7 mbit and the @xmath0 gbit network . the first one , mouse brain , comes from medical science and is a 3d surface of a mouse brain .",
    "the size of the data is @xmath17 mb .",
    "the @xmath7 mbit network gets saturated and the frame rate of @xmath18 frames / second is expected , since the data traffic , although dependent on user interaction and locality of the scene polygons , is proportional to the data size .",
    "the @xmath18 frames / second translates to @xmath19 seconds per frame .",
    "the network transfer takes @xmath20 seconds . the next application , fluid flow ,",
    "is an isosurface extracted from a fluid flow simulation data .",
    "the beetle head is also an isosurface .",
    "it was extracted from the x - ray computed microtomography data of an alaskan spruce bark beetle . with performance mainly depending on the data size we observe that doubling the data size reduces the frame rate two times .",
    "another application type that we tested is ray tracing volume visualization .",
    "we applied it to x - ray computed microtomography data of a rock sample of size @xmath0 gb .",
    "this is an example where a substantial part of the visualization is done in the cpu and only the result , in terms of opengl primitives , is sent through the network . on the @xmath7 mbit network",
    "we get @xmath21 seconds per frame .",
    "@xmath22 seconds are spent in the ray tracing algorithm ( run on @xmath3 cluster nodes with dual processor on each node ) and @xmath23 seconds in transfer and rendering of the opengl commands issued in the ray tracing algorithm .    switching to the @xmath0 gbit network approximately",
    "doubles the performance results .",
    "similar improvement was observed in @xcite for various numerical analysis applications .",
    "the ray casting relies mostly on the cpu s performance and switching to the @xmath0 bbit network did not show any speed up .",
    "[ cols=\"^,^,^,^ \" , ]      dependence of the visualization speed on the data size and the network bandwidth for different applications .",
    "the global scene is split into @xmath3 and rendered by @xmath3 chromium rendering spus to @xmath3 tiles display .",
    "[ table1 ]    we used sgi s pmchart to monitor the network traffic for the different applications described above and in table @xmath0 .",
    "the network gets saturated for the applications discussed .",
    "the network traffic in and out of every cluster node looks like the one given on figure [ network ] .",
    "we show the traffic for one of the @xmath3 cluster nodes over the @xmath0 gbit network",
    ". left : traffic in in bytes ; middle : traffic out in bytes ; right : network utilization.,title=\"fig:\",width=172 ]   mb ) .",
    "we show the traffic for one of the @xmath3 cluster nodes over the @xmath0 gbit network .",
    "left : traffic in in bytes ; middle : traffic out in bytes ; right : network utilization.,title=\"fig:\",width=172 ]   mb ) .",
    "we show the traffic for one of the @xmath3 cluster nodes over the @xmath0 gbit network .",
    "left : traffic in in bytes ; middle : traffic out in bytes ; right : network utilization.,title=\"fig:\",width=172 ]    the non - automatic mechanism that chromium provides for acceleration ( minimization ) of the geometry flow is display lists .",
    "they are supported by sending the lists to each rendering server , and thus guaranteeing their presence on the server when they are called .",
    "display lists in open inventor are created for the parts of the scene that have as root soseparator nodes with field rendercaching turned on or auto ( for more information see @xcite , pages @xmath24-@xmath25 ) . using display lists we get a speed of @xmath26 frames / sec for visualizing @xmath6 spheres by @xmath6 processors on composited display , and @xmath27 frames / sec on tiled display .",
    "different parallel and display configurations illustrate the same order of improvement .",
    "these results are comparable to the sequential ones .",
    "the trade - offs are that the process is not automatic and that the display lists are broadcast to all rendering servers and thus replicating the scene in each node .",
    "work on the automatic optimization of the geometry data flow can be found in @xcite .",
    "we developed an application for interactive parallel visualization on tiled displays for commodity - based clusters .",
    "we used chromium s parallel rendering and extended popular visualization apis , such as open inventor and vtk .",
    "the most original part of this work is the combined use of open inventor and chromium .",
    "we gave implementation details and described our experience in the combined use of the chromium s rendering technology with open inventor and vtk .",
    "a general conclusion is that fast sequential visualization often relies on graphics acceleration hardware , data sampling methods , static scenes , and data size within the hardware limitations , while the visualization developed does not require expensive graphics hardware , provides high resolution , facilitates well the visualization of time - varying scenes , and can handle large data sets .",
    "we demonstrated a low cost ( time , money , effort , etc . ) of development .",
    "our benchmarks quantitatively demonstrated the bottleneck that the network s bandwidth presents in the sort - first rendering architecture .",
    "this bottleneck makes the sort - first architecture more appealing for time - varying data sets , commodity - based clusters with slow ( or no ) graphics acceleration , and visualization algorithms that rely on the cpu s speed , such as ray casting .    .",
    "we would like to thank beverly tomov from cold spring harbor laboratory , ny , for her attentive editing and remarks .",
    "we thank the anonymous referees whose constructive remarks improved the presentation .",
    "we also thank keith jones from the bnl s environmental research and technology division for providing the data produced by the synchrotron - based computed microtomography at the brookhaven national synchrotron light source .",
    "99 j.ahrens , c.law , k.martin , m.papka , w.schroeder , _ a parallel approach for efficiently visualizing extremely large , time - varying data sets _ , technical report # laur-00 - 1620 ( los alamos national laboratory , nm , usa , 2000 ) .",
    "e.brugger , _ visit : a component - based , parallel visualization package _ , doe , computer graphics forum 2001 , internet address ( accessed on 08/2002 ) : + http://www.emsl.pnl.gov:2080/docs/doecgf2001/abstractlist.html                greg humphreys , mike houston , ren ng , randall frank , sean ahern , peter d. kirchner , james t. klosowski , _ chromium : a stream - processing framework for interactive rendering on clusters _ , proceedings of siggraph 2002 ( san antonio ,",
    "tx , usa ) 693 - 712 .",
    "david thompson and gary templet , _ cplant , vizclusters , vtk , chromium _ , doe computer graphics forum - april , 2002 ( montauk , ny ) , internet address ( accessed on 08/2002 ) : + http://www.ccd.bnl.gov/visualization/doecgf_2002/"
  ],
  "abstract_text": [
    "<S> we present an efficient and inexpensive to develop application for interactive high - performance parallel visualization . </S>",
    "<S> we extend popular apis such as open inventor and vtk to support commodity - based cluster visualization . </S>",
    "<S> our implementation follows a standard master / slave concept : the general idea is to have a `` master '' node , which will intercept a sequential graphical user interface ( gui ) and broadcast it to the `` slave '' nodes . </S>",
    "<S> the interactions between the nodes are implemented using mpi . the parallel remote rendering uses chromium . </S>",
    "<S> this paper is mainly the report of our implementation experiences . </S>",
    "<S> we present in detail the proposed model and key aspects of its implementation . also , </S>",
    "<S> we present performance measurements , we benchmark and quantitatively demonstrate the dependence of the visualization speed on the data size and the network bandwidth , and we identify the singularities and draw conclusions on chromium s sort - first rendering architecture . </S>",
    "<S> the most original part of this work is the combined use of open inventor and chromium .    ,    ,    ,    ,    ,    interactive visualization , visualization apis , commodity - based cluster visualization , parallel visualization , remote rendering , chromium , open inventor , vtk , mpi . </S>",
    "<S> + _ computers & graphics key words : _ computer graphics applications : scientific visualization - physics , engineering ; computer graphics methodologies : fundamentals of computer graphics - hardware architecture ( parallel processing ) , methodology and techniques ( interaction techniques ) , graphics utilities ( graphics packages ) . </S>"
  ]
}