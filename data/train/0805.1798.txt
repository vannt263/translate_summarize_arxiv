{
  "article_text": [
    "one of the main aims of game theory is to understand how agents reason .",
    "psychologists  @xcite would say agents are human and tries to answer the question of _ how _ human agents reason . in this paper , we take a radically different view ; for us , agents are ideal abstract entities with unlimited formal deduction power and we attempt to answer the question of _ what _ a full reasoning can be . for",
    "that we decided to analyze the process in full detail on a mechanical device , namely a proof assistant run on a computer which performs at the extreme level of detail all the steps of reasoning .",
    "this way , we hope to be able to highlight concepts and deductions that are necessary and that a human would do more or less . among the possible concepts involved in a reasoning , we claim that some are forgotten whereas irrelevant others are considered . in the first class",
    "is temporal reasoning ( `` always '' , `` eventually '' ) , in the second is the use of `` excluded middle '' or `` double negation '' .",
    "our experiments have shown that far from easy deductions are used , in particular with infinite games .",
    "this complexity may explain why human reasoning departs from what is expected .    among the parts of game theory that have been overlooked ,",
    "is this of infinite games , on which formal reasoning is rather subtle . in this paper",
    "we report research about the concepts underlying infinite games and experiments on the proof assistant coq  @xcite to make formal reasoning effective .    in this paper",
    ", we are presenting mechanical reasoning that is deductions that , unlike human ones , are based on the fundamental principles of logic .",
    "this means that every piece of reasoning has to be justified by a rule of logic and therefore the whole process can be checked by a machine , i.e. , a computer , the coq software in our case .",
    "the domain of experience is this of _ games in extensive form _",
    "( @xcite chap .",
    "5 ) , that are sequential games were each situation are owned by a player , whose turn comes one after the others .",
    "more specifically , we focus on infinite such games , where there may be infinitely many situations .",
    "around 1980 a new concept called _ curry - howard correspondence _ emerged .",
    "it relies on type theory and lambda - calculus  @xcite and says basically that _ proofs are programs_. in this theory , all objects have a type , that is an annotation that limits its use .",
    "for instance , an object @xmath0 of type @xmath1 , written @xmath2 represents a function and can only be applied to an object of type @xmath3 to produce an object of type @xmath4 . in our development",
    "we will write , for instance , @xmath5 to say that @xmath6 is an _ agent _ and @xmath7 to say that @xmath8 is an infinite strategy . in",
    "what follows , a node ( written _ inode _ ) in a infinite strategy is something that takes an agent , a choice , a finite strategy and an infinite strategy and produces an infinite strategy has a type , in more precise words it has the type , @xmath9 the curry - howard correspondence says also that _ types are propositions _ and insists essentially on the computational content of proofs and establishes the bases of the so - called constructive logic .",
    "indeed since a proof works as a computation , an object can be taken into consideration only if it can be constructed and an existential proof is accepted if it allows constructing the object it claims the existence of .",
    "for instance , in an infinite extensive game we assert that there exists a utility for an agent @xmath6 that can be associated with an infinite strategy , but this works if we prove it exists , i.e. , provide a way to construct this utility , since assuming the existence without the construction is not enough .",
    "the following formal development in coq has been built in this framework and checked on a computer and is attached to proof scripts available on the web site of the author . in this article",
    "we try to describe and comment the content of the scripts without entering in their full technicality , but the reader is anyway strongly encouraged to have a look at the scripts to convince himself of the materiality of the proofs and moreover , if he has access to a coq implementation , he should try to run them on a computer .",
    "the proof systems we describe is based on natural deduction , which is one of the main system to formalize logic .",
    "natural deduction has been formalized by gerhard gentzen  @xcite in 1935 ( see also  @xcite ) .",
    "its adjective `` natural '' comes form the fact that its creators considered that it is just the natural way to formalize logic .",
    "it is based on the fact that to conduct a proof , one works under hypotheses and one tries to draw a conclusion .",
    "one considers that a theorem has been proved when all the hypotheses have been discharged .",
    "the basic concept of natural deduction is this of _ sequent_. a sequent is a pair of a context @xmath10 and a proposition @xmath11 , which is written @xmath12 and which means that @xmath11 is a logical consequence of the set of hypotheses @xmath10 .",
    "a context is a set of propositions and when we write @xmath13 we mean that the sequent @xmath10 is enriched by the proposition @xmath11 , in other terms this is a notation for the union of sets of propositions . in this calculus",
    "there is one axiom and several rules .",
    "the axiom is @xmath14 there are two kinds of rules for each connector , namely _ introduction rule _ and _ elimination rule_. for instance , for the implication @xmath15 , the introduction rule is @xmath16 whereas the elimination rule is @xmath17 also known as the _ modus ponens_. we are now giving only the rule for the universal quantifier , the introduction rule @xmath18 and the elimination rule : @xmath19    through the curry - howard correspondence , natural deduction is strongly connected to type theory and computation .      in this paper",
    "we are not describing all the details of the proof assistant coq and the book  @xcite is excellent source of information . basically in coq , proofs are mathematical objects in natural deduction and are considered as first class citizen that can be printed , be exchanged as objects between people , and overall be checked by a proof checker ( a specific software ) that examines it in full detail . as building proofs is a tedious process , the software coq offers tools to build them . basically a coq development is made of several not fully separated phases : the user defines data structures ( in our case : games and strategies ) , then he defines predicates , relations and functions on those structures ( in our case : conversion , utilities and equilibria ) and finally he proves theorems about those structures and predicates ( in our case : a theorem that says that subgame perfect equilibria are nash equilibria ) .",
    "typically a script presents a set of sections in which a subdevelopment is presented , this section may invoke other sections ; it is a sequence of declaration of variables , axioms , or hypothesis , followed by definitions and theorems with their proofs . to check that a script is correct , it is highly recommended to run it on a coq implementation .",
    "_ induction _ is a tool to reason over infinite sets of objects , provided those objects are finitely based . on the opposite ,",
    "_ coinduction _",
    "@xcite has been designed to reason on infinite objects , like games with infinite paths .",
    "however infinite objects may have parts that are finite like finite paths in infinite games and induction can also be used on infinite objects , specifically on their finite subparts . in particular ,",
    "if the paths are finite , one can compute the utility . moreover in infinite games we can define finite relations , called _",
    "convertibility_. therefore finite concepts are interleaved with infinite ones .    beside games",
    ", we can define other finite or infinite objects , further we consider the following _ inductive _ ( finite ) objects : 1 ) finite games , 2 ) finite strategies ( or strategy profiles ) , 3 ) the predicate _ eventually right _ that says when applied to a path of a game that the path in question goes eventually to the right , 4 ) the two convertibility congruences among strategies , namely among finite strategies , but also among infinitely strategy ( we indeed claim this latter congruence can be described finitely provided we restrict it to appropriate strategies ) .",
    "5 ) nash equilibrium on finite games , 6 ) backward induction predicate and 7 ) nash equilibrium on infinite games are also finite inductive concepts .    in this paper the archetype of a _ coinductive _ object is an infinite game .",
    "obviously the associated concept of infinite strategy is coinductive .",
    "the function that associates a utility with a strategy is also coinductive since the infinite strategies are . the predicate which tells whether an infinite strategy is a _ subgame perfect equilibrium _ is a coinductive object since the strategy is . in",
    "what follows we will define predicates that say that a property is `` always '' satisfied along a path , those properties on infinite objects are coinductively defined .    roughly speaking inductive definitions",
    "are like equations and correspond to define the concept as _ least fixed points _ and the properties of this concept are derived of this minimality . on another hand , coinductive definitions correspond to _ greatest fixed points _ and the properties of this concept are derived from the maximality . handling infinite objects ( actual infinity vs potential infinity ) is tricky and the coq user does not escape this rule .",
    "notice that coq offers tools to verify along a proof that the one one builds will be accepted by the checker .",
    "in this paper , we analyze _ games in extensive form_. informally such games are presented as trees .",
    "each node of the tree is a situation in the game where a player has to take a decision .",
    "for reason of simplicity , following vestergaard  @xcite , we studied _ binary games _ where the players have only two choices .",
    "this seems a reasonable design decision , since we can reduce a choice among @xmath20 to a binary choice between the @xmath21 and the set @xmath22 followed by the binary choice between the @xmath23 and the set @xmath24 etc ... we do not loose any generality in term of modeling , and in term of abstraction this is the same as @xmath20 choices at each node . a reader interested by an implementation based on more than two choices , i.e. , on polyadic trees ,",
    "is advised to consult stphane le  roux phd  @xcite . by considering binary games ,",
    "we hope to be more didactic .",
    "first we will consider _ finite binary games_. those games are somewhat connected with games with _",
    "finite horizon _ , but in addition to offer choices to a finite depth , they are also finitely branching . such a game is either a leaf , that is a game which ends and attributes the utilities , or a node where an agent has to take a decision .",
    "this leads typically to an inductive description . like a natural is either @xmath25 or",
    "the successor of a natural , or a binary tree is either a leaf with a content or a node made of two binary subtrees , a finite game is either a leaf with a function that associates a utility to each agent or a node with an agent and two subgames , namely a left subgame and a right subgame . with a finite game , we associate strategies .",
    "a  strategy has the same structure as the game it is associated with , except that to each ( internal ) node we give a direction _ left _ or _ right _ , which corresponds to the choice made by the agent in this particular situation . in other words , a strategy is either a leaf associated with a utility , exactly like for games , or a node with an agent , a choice ( left or right ) , and two substrategies .",
    "the main goal of the study presented in this paper is infinite games , more specifically we describe deductions and formal reasoning on those games .",
    "again for reason of simplicity , we study infinite games that looks like `` centipedes '' , in other words binary games with a unique infinite path .",
    "the basic concept of those games is a node made of three components : an agent , a left subgames which is itself an infinite subgame , and a right subgame which is a finite subgame .",
    "this means that we `` recycle '' the formal development made for finite subgames for the right branch . since the game is infinite its formalization relies no more on induction , but on coinduction .",
    "like for finite binary games , the attached concept of strategy relies on a node with four components : an agent , a choice ( left or right ) , an infinite left substrategy , and a finite right strategy .",
    "as an introduction to the coq development , let us study equilibria on _",
    "finite games_.      first we set two basic concepts namely and . in coq , this is done by the following declaration :    : . : .",
    "in addition we set a as a binary relation on and we make this a preorder , which we write @xmath26 , is the type of the _ utility functions _ , in other words the type of the objects belonging to @xmath27 .      a finite binary game , which we call a , in coq , is built by induction , this means that this is either a _ leaf _ or this is a game with two subgames that are themselves binary games , we encapsulate these three items under the label _ gnode_. in coq , such a data structure will be written :    : : =| : @xmath27 | : @xmath27 @xmath27 @xmath27 .    where is the key word to introduce any inductive definition . is a data structure , but elsewhere the same keyword will be used to define a predicate .",
    "an inductive definition creates a deduction rule that allows us to reason by induction , namely in the case of , the term is created by coq :    @xmath28 : @xmath27 , ( @xmath28 u : , ( ) ) @xmath27 ( @xmath28 ( : ) ( :) , @xmath27 @xmath28 : , @xmath27 ( a ) )    @xmath27 @xmath28 : ,    it can be written as the rule @xmath29 \\ensuremath{\\rightarrow }   \\ensuremath{\\forall } \\coqdocid{a } : \\coqdocid{agent } , \\coqdocid{p}\\ ( \\coqdocid{gnode}\\ a\\ \\coqdocid{f0}\\ \\coqdocid{f1 } )    \\justifies \\ensuremath{\\forall } \\coqdocid{f } : \\coqdocid{fingame } , \\coqdocid{p}\\ \\coqdocid{f }    \\endprooftree\\ ] ] in other words , to prove that some properties holds for all the finite binary games , one has to prove it to hold for leaves and to prove that if it holds for two games then it holds for the game obtained by pairing those two games under the `` control '' of an agent .",
    "as we said , a finite strategy has a structure which is very similar to a finite game , the only difference is that we add a `` choice '' at each node .",
    ": : =| : @xmath27 | : @xmath27 @xmath27 @xmath27 @xmath27 .    with a strategy we provide a function that associates with every strategy a utility function .",
    "the coq keyword to define such a function is .",
    "a syntactic construction called allows using a pattern matching mechanism .",
    "( :) : : = | ( ) @xmath30 | ( ) @xmath30 ( ) | ( ) @xmath30 ( ) .",
    "this reads as    * if the strategy is a leaf , i.e. , ( where is a utility function ) , then one returns , * otherwise one returns the utility function associated with the left substrategy , if the choice is _ left _ , or the right substrategy if the choice is .",
    "now we define on finite strategies a relation , which we call -_convertibility _ , and which we write . labeled with @xmath6 , it is associated with the agent and says that    * two leaves associated with the same utility function are -convertible , * two s , ( ) and ( ) , associated with the same agent are -convertible if and .",
    "notice that and do not have to be the same , * two s , ( ) and ( ) , associated with another agent are -convertible if and .",
    "notice that in this case has to be the same .",
    "we prove in coq ( a first interesting exercise ) that the -convertibility is an equivalence relation i.e. , it is reflexive , symmetric and transitive .",
    "we are now equipped to define the predicate _",
    "nash equilibrium _ on _ finite strategy _",
    "( in coq the predicate on ):    : @xmath27 : = | : @xmath28 ( :) , ( @xmath28 ( :) ( :) , @xmath27 ( @xmath26 ) ) @xmath27 .",
    "it says that is a nash equilibrium if for all strategy that is -convertible to ,    @xmath26 ,    in other words , the utility for computed for is less than the utility for computed for .",
    "this is nothing more than the traditional definition of nash equilibrium for extensive game , written in the formalism of coq .    beside the predicate _",
    "nash equilibrium _",
    ", we define the predicate _ bi _ which says whether the strategy can be obtained by the so - called _",
    "backward induction_. in coq , it is written :    : @xmath27 : =| : @xmath28 : , ( ) | : @xmath28 ( :) ( : ) , @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) | : @xmath28 ( :) ( : ) , @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) .",
    "in other words ,    * _ bi _ holds for leaves , * if _ bi _ holds for and and @xmath26 then _ bi _ holds for ( principle ) , * the principle is symmetric , it says , that if _ bi _ holds for and for and @xmath26 then is _ bi _ holds for .",
    "this is the formalization of backward induction for finite horizon games as described in textbooks  @xcite .",
    "then we are able to prove in coq the theorem :    : @xmath28 , @xmath27 .",
    "the theorem relies on the following fact : the inductive definition of _ bi _ is a somewhat equational definition that says that _ bi _ is the least fixed point of that equation . therefore if we can prove that if is another fixed point , this other fixed point is implied by _",
    "bi _ and we are set .",
    "this can be done by three lemmas .",
    "@xmath31 satisfies the statement given by :    : @xmath28 ( :) , ( ) .",
    "@xmath31 satisfies the statement given by :    : @xmath28 ( :) ( : ) , @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) .",
    "@xmath31 satisfies the statement given by :    : @xmath28 ( :) ( : ) , @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) .",
    "then we conclude than satisfies the same equation as .",
    "since is the least fixed point , implies .",
    "coinduction is the partner of induction , but whereas the induction defines objects or predicates as the least fixed point of some equations and therefore specifies finite objects and presents them from basic objects , coinduction defines infinite objects or infinite finite objects as greatest fixed point of some equation .",
    "if one has in mind to define infinite objects only , there is no need to specify basic objects ( i.e. , objects meant to be the basis on which to define finite object ) .",
    "the typical infinite object is    : : =| : @xmath27 @xmath27 @xmath27 .    in other words ,",
    "an infinite binary game is made of an agent , an infinite binary subgame , and a finite binary subgame .",
    "on the same model as for finite binary games , we define infinite strategies the same way , i.e. , as a coinductive :    : : =| : @xmath27 @xmath27 @xmath27 @xmath27 .",
    "since the strategies are infinite we can define total functions ( which gives the agent at the root of the game ) , ( the infinite game on the left ) and ( the finite game on the right ) with the lemma :    : @xmath28 ( :) , ( ) ( ) ( ) = .",
    "that says that a game can be uniquely decomposed into an agent , a left subgame and a right subgame .      in classical extensive game theory ,",
    "the concept of backward induction relies on this of _ finite horizon _ , our experience in mechanizing the proof has shown us that finite horizon is not exactly the right notion , we prefer the notion of _ limited horizon _ , which means that the horizon of the agents is not bounded by a number , but that however it can not go to infinity . in the frame of binary games , this means that we forbid paths that go always to the left , we want to consider the paths that eventually go to the right so that one can compute the utility of each agent .    since the games are now infinite , a _ total function _ that associates , by computation , a utility to a strategy can no more be defined , one can only define a _ relation _ between a strategy and a utility .",
    "if the path of the choice goes always to the left ( on the backbone ) the utility can not be defined , but if the path goes _ `` eventually to the right '' _ , the utility of a strategy makes sense .",
    "we therefore define a predicate which says whether the path of the given strategy goes eventually to the right .",
    "the basic case for this predicate is that it holds for the game .",
    "the induction case says that if then ( ) .",
    "the predicate is typical of an inductive predicate .",
    "we get two lemmas which show the existence and the uniqueness of a utility for a strategy that goes eventually to the right , therefore in that case , the association of the utility to the strategy is functional .",
    "since most of the time we want this functional association , we require the predicate `` eventually right '' to hold .",
    ": @xmath28 ( :) ( :) , @xmath27 @xmath32 : , .    : @xmath28 ( :) ( :) ( :) , @xmath27 @xmath27 @xmath27 = .",
    "going eventually to the right is not enough . in some cases ,",
    "when dealing with subgames , more specifically with subgame perfect equilibria , one wants to be able to compute utilities in subgames .",
    "therefore one wants to be sure that even further in subgames one will go eventually to the right .",
    "hence we define another predicate that ensures that we will always go eventually to the right .",
    "this predicate reminds us the same kind of predicate defined in the frame of temporal logic ( see @xcite chap.13 and  @xcite ) .",
    "since has to traverse the whole infinite game , it has to be coinductive .",
    "it says that ( ) holds , if and hold , in other words , a strategy goes always eventually to the right if its left substrategy goes always eventually to the right and if its right substrategy ( which is finite ) goes eventually to the right .",
    "the definition of the convertibility @xmath33 @xmath34 of two strategies and is inductive .",
    "its base case is the reflexivity of the convertibility . in other words , @xmath33 @xmath34 if :    * = , or * if @xmath33 @xmath34 and and is and is ( may be different , but has to be the same ) , or * if @xmath33 @xmath34 and and is and is ( different agents , but same ) .      to define nash equilibria on infinite games , one must be able to compare utilities . for that , one must be able to compute those utilities .",
    "hence one restricts to strategies that go eventually to the right .    :",
    "@xmath27 : = | : @xmath28 (: ) , @xmath27 ( @xmath28 ( :) ( :) ( : ) , @xmath27 @xmath33 @xmath34 @xmath27 ( ) @xmath27 ( ) @xmath27 ( @xmath26 ) ) @xmath27 .",
    "on infinite strategies one defines a predicate _ subgame perfect equilibrium_. because one has to be able to compute utilities on subgames , the subgame perfect equilibrium predicate , written , is defined on strategies which go always eventually to the right .",
    "notice that subgame perfect equilibria are defined on a smaller class of strategies than nash equilibria , but also that the definition of is coinductive , since its definition requires to traverse the whole infinite subgame .    :",
    "@xmath27 : =| : @xmath28 ( : ) ( : ) (: ) (: ) , @xmath27 @xmath27 @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) | : @xmath28 ( :) ( :) (: ) (: ) , @xmath27 @xmath27 @xmath27 @xmath27 ( @xmath26 ) @xmath27 ( ) .    one can show that is a fixed point of this definition . to prove the lemma @xmath27 , one needs to perform a proof by induction , this can not be an induction on the definition which is coinductive . to enable a proof by induction",
    ", we impose an additional requirement , namely that somewhere in the game a maximal utility is reached for all agents .",
    "we give a statement of this requirement through the following predicate :    : @xmath27 : =| : @xmath28 ( :) , ( @xmath28 ( :) ( : ) (: ) , @xmath33 @xmath34 @xmath27 @xmath27 @xmath27 ( @xmath26 ) ) @xmath27 | : @xmath28 ( : ) ( : ) (: ) ( : ) , @xmath27 ( ) .",
    "it has two parts .    *",
    "the game fulfills the maximal utility requirement for every agent , * the left subgame does",
    ".    then we can set and prove the main theorem :    : @xmath28 : , @xmath27 @xmath27 .",
    "if every agent reaches a maximal utility somewhere in the game , then a subgame perfect equilibrium is a nash equilibrium .",
    "now we may want to apply those general results on a specific infinite subgame . consider the following game proposed by shubik  @xcite .",
    "recall its principle .",
    "two agents _ alice _ and _ bob _ compete in an auction for an object of a value , say @xmath35 , in this statement .",
    "the two agents bid @xmath35 , one after the other .",
    "if one agent gives up , the highest bidder gets the object , but the second bidder pays also for his bid . as shubik noted this game may never cease .",
    "let us take as the utility ordering , the order @xmath36 on the _ nat _ ( the natural numbers or non negative integers ) , in other words , if _",
    "u _ and _ v _ are two utilities , _ u _ and _ v _ are of type and _ u _ @xmath26__v _ _ means @xmath37 , i.e. , the larger the bid , the smaller the utility .",
    "let us consider the function on strategies , that takes a strategy and returns another one and that can be described by the following picture , where the thick arrows give the choice at each node .",
    "@xmath38    & { \\ovalnode{a}{alice } }    & { \\ovalnode{b}{bob } }    & [ name = c ]     & \\\\    & [ name = e ] { \\scriptstyle 2n+1 , 2n }    & [ name = f ] { \\scriptstyle 2n+1 , 2n+2 }    & [ name = g ] \\phantom{\\scriptstyle 2n+1 , 2n+2 }      \\ncarc[arrows=->,linewidth=.1]{a}{b }      \\ncarc[arrows=->,linewidth=.1]{b}{c }      \\ncarc[arrows=->]{a}{e }      \\ncarc[arrows=->]{b}{f }      \\pspolygon*[linecolor = lightgray](-.7,0)(-.7,2.1)(5,2.1 )    \\end{psmatrix } $ ]    we define the strategy _ never give up _ ( in short _ ngu _ ) as the strategy where the agents always keep bidding .",
    "it requires to define first a strategy that starts with the value _",
    "n _ as the solution of    _ ngu n = enlarge left left ( ngu ( s n ) ) . _    _ ngu n _ is an infinite strategy and we can prove that for _",
    "n _ , _ ( ngu n ) _ is not a nash equilibrium . in this proof",
    ", reasoning has a flavor of _ temporal logic_.      here we consider the function on strategies .",
    "@xmath39    & { \\ovalnode{a}{alice } } & { \\ovalnode{b}{bob } } & [ name = c ] & \\\\    & [ name = e ] { \\scriptstyle 2n+1 , 2n } & [ name = f ] { \\scriptstyle 2n+1 , 2n+2 } & [ name = g ] \\phantom{\\scriptstyle 2n+1 , 2n+2 }     \\ncarc[arrows=->]{a}{b } \\ncarc[arrows=->]{b}{c }    \\ncarc[arrows=->,linewidth=.1]{a}{e } \\ncarc[arrows=->,linewidth=.1]{b}{f }     \\pspolygon*[linecolor = lightgray](-.7,0)(-.7,2.1)(5,2.1 ) \\end{psmatrix } $ ]    again _ agu n _ is an infinite strategy and we can prove the lemma :    : @xmath28 ( :) , ( ) .    which says that that this strategy is a _ subgame perfect equilibrium . _",
    "the experiment presented in this paper is in a very stage .",
    "its goal is to make clear that , in games , especially in infinite games , the reasoning can be mechanized despite it is not obvious ; it evidences with no surprise some subtlety . to mimic it , humans elaborate rather complex deductions .",
    "one of the main statement we can make is that true _",
    "classical logic is never used_. more specifically , we noticed no use of the excluded middle or proofs by double negations .",
    "we hope this experiment opens a discussion and shows how far humans are from the somewhat ideal mechanized reasoning .",
    "we wish to pursue this research by trying other modelings and concepts and going further in the proofs , for instance finding other conditions for @xmath27 and deeper results on the example of `` illogic conflict of escalation '' .",
    "bruno barras , samuel boutin , cristina cornes , judical courant , yann coscoy , david delahaye , daniel de  rauglaudre , jean - christophe fillitre , eduardo gimnez , hugo herbelin , grard huet , henri laulhre , csar muoz , chetan murthy , catherine parent - vigouroux , patrick loiseleur , christine paulin - mohring , amokrane sabi , and benjamin werner . .",
    "inria , version 6.3.11 edition , may 2000 ."
  ],
  "abstract_text": [
    "<S> in order to better understand reasoning involved in analyzing infinite games in extensive form , we performed the experiments in proof assistant coq that are reported here . </S>"
  ]
}