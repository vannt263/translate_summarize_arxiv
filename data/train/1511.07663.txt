{
  "article_text": [
    "probabilistic inference on large and uncertain data sets is increasingly being used in a wide range of applications .",
    "it is well - known that probabilistic inference is polynomially inter - reducible to model counting  @xcite . in a recent line of work",
    ", it has been shown  @xcite that one can strike a fine balance between performance and approximation guarantees for propositional model counting , using @xmath1-universal hash functions  @xcite on boolean domains .",
    "this has propelled the model - counting formulation to emerge as a promising `` assembly language ''  @xcite for inferencing in probabilistic graphical models .    in a large class of probabilistic inference problems ,",
    "an important case being lifted inference on first order representations  @xcite , the values of variables come from finite but large ( exponential in the size of the representation ) domains .",
    "data values coming from such domains are naturally encoded as fixed - width words , where the width is logarithmic in the size of the domain .",
    "conditions on observed values are , in turn , encoded as word - level constraints , and the corresponding model - counting problem asks one to count the number of solutions of a word - level constraint .",
    "it is therefore natural to ask if the success of approximate propositional model counters can be replicated at the word - level .",
    "the balance between efficiency and strong guarantees of hashing - based algorithms for approximate propositional model counting crucially depends on two factors : ( i )  use of xor - based @xmath1-universal bit - level hash functions , and ( ii )  use of state - of - the - art propositional satisfiability solvers , viz .",
    "cryptominisat  @xcite , that can efficiently reason about formulas that combine disjunctive clauses with xor clauses .",
    "in recent years , the performance of @xmath0 ( satisfiability modulo theories ) solvers has witnessed spectacular improvements  @xcite .",
    "indeed , several highly optimized @xmath0solvers for fixed - width words are now available in the public domain  @xcite .",
    "nevertheless , @xmath1-universal hash functions for fixed - width words that are also amenable to efficient reasoning by @xmath0 solvers have hitherto not been studied .",
    "the reasoning power of @xmath0solvers for fixed - width words has therefore remained untapped for word - level model counting .",
    "thus , it is not surprising that all existing work on probabilistic inference using model counting ( viz .",
    "@xcite ) effectively reduce the problem to propositional model counting .",
    "such approaches are similar to `` bit blasting '' in smt solvers  @xcite .",
    "the primary contribution of this paper is an efficient word - level approximate model counting algorithm @xmath2 that can be employed to answer inference queries over high - dimensional discrete domains .",
    "our algorithm uses a new class of word - level hash functions that are @xmath1-universal and can be solved by word - level @xmath0 solvers capable of reasoning about linear equalities on words .",
    "therefore , unlike previous works , @xmath2 is able to leverage the power of sophisticated @xmath0 solvers .    to illustrate the practical utility of @xmath2",
    ", we implemented a prototype and evaluated it on a suite of benchmarks .",
    "our experiments demonstrate that @xmath2 can significantly outperform the prevalent approach of bit - blasting a word - level constraint and using an approximate propositional model counter that employs xor - based hash functions .",
    "our proposed word - level hash functions embed the domain of all variables in a large enough finite domain .",
    "thus , one would not expect our approach to work well for constraints that exhibit a hugely heterogeneous mix of word widths , or for problems that are difficult for word - level @xmath0 solvers .",
    "indeed , our experiments suggest that the use of word - level hash functions provides significant benefits when the original word - level constraint is such that ( i )  the words appearing in it have long and similar widths , and ( ii )  the @xmath0solver can reason about the constraint at the word - level , without extensive bit - blasting .",
    "a _ word _ ( or _ bit - vector _ ) is an array of bits .",
    "the size of the array is called the _ width _ of the word .",
    "we consider here _ fixed - width _ words , whose width is a constant .",
    "it is easy to see that a word of width @xmath3 can be used to represent elements of a set of size @xmath4 .",
    "the first - order theory of fixed - width words has been extensively studied ( see  @xcite for an overview ) .",
    "the vocabulary of this theory includes interpreted predicates and functions , whose semantics are defined over words interpreted as signed integers , unsigned integers , or vectors of propositional constants ( depending on the function or predicate ) . when a word of width @xmath3 is treated as a vector , we assume that the component bits are indexed from @xmath5 through @xmath6 , where index @xmath5 corresponds to the rightmost bit . a _ term _",
    "is either a word - level variable or constant , or is obtained by applying functions in the vocabulary to a term .",
    "every term has an associated width that is uniquely defined by the widths of word - level variables and constants in the term , and by the semantics of functions used to build the term . for purposes of this paper , given terms @xmath7 and @xmath8",
    ", we use @xmath9 ( resp .",
    "@xmath10 to denote the sum ( resp .",
    "product ) of @xmath7 and @xmath8 , interpreted as unsigned integers . given a positive integer @xmath11",
    ", we use @xmath12 to denote the remainder after dividing @xmath7 by @xmath11 . furthermore ,",
    "if @xmath7 has width @xmath3 , and @xmath13 and @xmath14 are integers such that @xmath15 , we use @xmath16 to denote the slice of @xmath7 ( interpreted as a vector ) between indices @xmath13 and @xmath14 , inclusively .",
    "let @xmath17 be a formula in the theory of fixed - width words .",
    "the _ support _ of @xmath17 , denoted @xmath18 , is the set of word - level variables that appear in @xmath17 .",
    "a _ model _ or _",
    "solution _ of @xmath17 is an assignment of word - level constants to variables in @xmath18 such that @xmath17 evaluates to @xmath19 .",
    "we use @xmath20 to denote the set of _ models _ of @xmath17 .",
    "the model - counting problem requires us to compute @xmath21 . for simplicity of exposition ,",
    "we assume henceforth that all words in @xmath18 have the same width .",
    "note that this is without loss of generality , since if @xmath3 is the maximum width of all words in @xmath18 , we can construct a formula @xmath22 such that the following hold : ( i )  latexmath:[$|\\mathsf{sup}(f)| =    @xmath22 have width @xmath3 , and ( iii )  @xmath24 .",
    "the formula @xmath22 is obtained by replacing every occurrence of word - level variable @xmath25 having width @xmath26 in @xmath17 with @xmath27 , where @xmath28 is a new variable of width @xmath3 .",
    "we write @xmath29 $ ] for the probability of outcome @xmath30 when sampling from a probability space @xmath31 . for brevity , we omit @xmath31 when it is clear from the context . given a word - level formula @xmath17 , an _ exact model counter _ returns @xmath21 .",
    "an _ approximate model counter _ relaxes this requirement to some extent : given a _",
    "tolerance _ @xmath32 and _ confidence _",
    "@xmath33 $ ] , the value @xmath34 returned by the counter satisfies @xmath35 \\ge 1-\\delta$ ] .",
    "our model - counting algorithm belongs to the class of approximate model counters .",
    "special classes of hash functions , called _ @xmath1-wise independent universal _ hash functions play a crucial role in our work .",
    "let @xmath36 , where each @xmath37 is a word of width @xmath3 .",
    "the space of all assignments of words in @xmath18 is @xmath38 .",
    "we use hash functions that map elements of @xmath39 to @xmath11 bins labeled @xmath40 , where @xmath41 .",
    "let @xmath42 denote @xmath43 and let @xmath44 denote a family of hash functions mapping @xmath38 to @xmath42 .",
    "we use @xmath45 to denote the probability space obtained by choosing a hash function @xmath46 uniformly at random from @xmath44 .",
    "we say that @xmath44 is a @xmath1-wise independent universal hash family if for all @xmath47 and for all distinct @xmath48 , @xmath49 = 1/p^2 $ ] .",
    "the connection between probabilistic inference and model counting has been extensively studied by several authors  @xcite , and it is known that the two problems are inter - reducible .",
    "propositional model counting was shown to be # p - complete by valiant  @xcite .",
    "it follows easily that the model counting problem for fixed - width words is also # p - complete .",
    "it is therefore unlikely that efficient exact algorithms exist for this problem .",
    "@xcite showed that a closely related problem , that of almost uniform sampling from propositional constraints , can be solved in probabilistic polynomial time using an @xmath50 oracle .",
    "subsequently ,  @xcite showed that approximate model counting is polynomially inter - reducible to almost uniform sampling . while this shows that approximate model counting is solvable in probabilstic polynomial time relative to an @xmath50 oracle , the algorithms resulting from this largely theoretical body of work are highly inefficient in practice  @xcite . building on the work of bellare , goldreich and petrank  , chakraborty , meel and vardi   proposed the first scalable approximate model counting algorithm for propositional formulas , called @xmath51 .",
    "their technique is based on the use of a family of @xmath1-universal bit - level hash functions that compute xor of randomly chosen propositional variables .",
    "similar bit - level hashing techniques were also used in  @xcite for weighted model counting .",
    "all of these works leverage the significant advances made in propositional satisfiability solving in the recent past  @xcite . over the last two decades",
    ", there has been tremendous progress in the development of decision procedures , called satisfiability modulo theories ( or @xmath0 ) solvers , for combinations of first - order theories , including the theory of fixed - width words  @xcite .",
    "an @xmath0 solver uses a core propositional reasoning engine and decision procedures for individual theories , to determine the satisfiability of a formula in the combination of theories .",
    "it is now folklore that a well - engineered word - level @xmath0 solver can significantly outperform the naive approach of _ blasting _ words into component bits and then using a propositional satisfiability solver  @xcite .",
    "the power of word - level @xmath0 solvers stems from their ability to reason about words directly ( e.g. @xmath52 for every word @xmath13 , @xmath14 , @xmath53 ) , instead of _ blasting _ words into component bits and using propositional reasoning .",
    "the work of  @xcite tried to extend @xmath51",
    "@xcite to non - propositional domains .",
    "a crucial step in their approach is to propositionalize the solution space ( e.g. bounded integers are equated to tuples of propositions ) and then use xor - based bit - level hash functions .",
    "unfortunately , such propositionalization can significantly reduce the effectiveness of theory - specific reasoning in an @xmath0 solver .",
    "the work of  @xcite used bit - level hash functions with the propositional abstraction of an @xmath0 formula to solve the problem of _ weighted model integration_. this approach also fails to harness the power of theory - specific reasoning in @xmath0 solvers .",
    "recently ,  @xcite proposed @xmath54 , an algorithm that generalizes @xmath0 solving to do lifted inferencing and model counting ( among other things ) modulo background theories ( denoted @xmath55 ) .",
    "a fixed - width word model counter , like the one proposed in this paper , can serve as a theory - specific solver in the @xmath54 framework .",
    "in addition , it can also serve as an alernative to @xmath54 when the overall problem is simply to count models in the theory @xmath55 of fixed - width words , there have also been other attempts to exploit the power of @xmath0 solvers in machine learning . for example ,  @xcite used optimizing @xmath0 solvers for structured relational learning using support vector machines .",
    "this is unrelated to our approach of harnessing the power of @xmath0 solvers for probabilistic inference via model counting .",
    "the performance of hashing - based techniques for approximate model counting depends crucially on the underlying family of hash functions used to partition the solution space .",
    "a popular family of hash functions used in propositional model counting is @xmath56 , defined as the family of functions obtained by xor - ing a random subset of propositional variables , and equating the result to either @xmath5 or @xmath57 , chosen randomly .",
    "the family @xmath56 enjoys important properties like @xmath1-independence and easy implementability , which make it ideal for use in practical model counters for propositional formulas  @xcite .",
    "unfortunately , word - level universal hash families that are @xmath1-independent , easily implementable and amenable to word - level reasoning by @xmath0 solvers , have not been studied thus far . in this section ,",
    "we present @xmath58 , a family of word - level hash functions that fills this gap .",
    "as discussed earlier , let @xmath36 , where each @xmath37 is a word of width @xmath3 .",
    "we use @xmath59 to denote the @xmath60-dimensional vector @xmath61 .",
    "the space of all assignments to words in @xmath59 is @xmath62 .",
    "let @xmath11 be a prime number such that @xmath63 .",
    "consider a family @xmath44 of hash functions mapping @xmath62 to @xmath42 , where each hash function is of the form @xmath64 , and the @xmath65 s and @xmath14 are elements of @xmath42 , represented as words of width @xmath66 .",
    "observe that every @xmath67 partitions @xmath62 into @xmath11 bins ( or cells ) .",
    "moreover , for every @xmath68 and @xmath69 , @xmath70 = p^{-1}$ ] . for a hash function chosen uniformly at random from @xmath44 , the expected number of elements per cell is @xmath71 .",
    "since @xmath72 , every cell has at least @xmath57 element in expectation .",
    "since @xmath73 , for every word @xmath37 of width @xmath3 , we also have @xmath74 .",
    "thus , distinct words are not aliased ( or made to behave similarly ) because of modular arithmetic in the hash function .",
    "suppose now we wish to partition @xmath75 into @xmath76 cells , where @xmath77 and @xmath78 . to achieve this",
    ", we need to define hash functions that map elements in @xmath62 to a tuple in @xmath79 . a simple way to achieve this is to take a @xmath53-tuple of hash functions , each of which maps @xmath62 to @xmath42 .",
    "therefore , the desired family of hash functions is simply the iterated cartesian product @xmath80 , where the product is taken @xmath53 times .",
    "note that every hash function in this family is a @xmath53-tuple of hash functions . for a hash function chosen uniformly at random from this family ,",
    "the expected number of elements per cell is @xmath81 .",
    "an important consideration in hashing - based techniques for approximate model counting is the choice of a hash function that yields cells that are neither too large nor too small in their expected sizes . since increasing @xmath53 by @xmath57 reduces the expected size of each cell by a factor of @xmath11 , it may be difficult to satisfy the above requirement if the value of @xmath11 is large . at the same time",
    ", it is desirable to have @xmath82 to prevent aliasing of two distinct words of width @xmath3 .",
    "this motivates us to consider more general classes of word - level hash functions , in which each word @xmath37 can be split into thinner slices , effectively reducing the width @xmath3 of words , and allowing us to use smaller values of @xmath11 .",
    "we describe this in more detail below .",
    "assume for the sake of simplicity that @xmath3 is a power of @xmath1 , and let @xmath83 be @xmath84 . for every @xmath85 and for every @xmath86 , define @xmath87 to be the @xmath88-dimensional vector of slices of the word @xmath37 , where each slice is of width @xmath89 .",
    "for example , the two slices in @xmath90 are @xmath91 and @xmath92 .",
    "let @xmath93 denote the @xmath94-dimensional vector @xmath95 .",
    "it is easy to see that the @xmath96 component of @xmath93 , denoted @xmath97 , is @xmath98 , where @xmath99 , @xmath100 and @xmath101 .",
    "let @xmath102 denote the smallest prime larger than or equal to @xmath103 .",
    "note that this implies @xmath104 for all @xmath105 . in order to obtain a family of hash functions that maps @xmath62 to @xmath106 , we split each word @xmath37 into slices of width @xmath89 , treat these slices as words of reduced width , and use a technique similar to the one used above to map @xmath62 to @xmath107 .",
    "specifically , the family @xmath108 maps @xmath62 to @xmath106 , where the values of @xmath109 and @xmath110 are chosen from @xmath106 , and represented as @xmath111-bit words .    in general , we may wish to define a family of hash functions that maps @xmath62 to @xmath112 , where @xmath112 is given by @xmath113 and @xmath114 . to achieve this",
    ", we first consider the iterated cartesian product of @xmath115 with itself @xmath116 times , and denote it by @xmath117 , for every @xmath85 .",
    "finally , the desired family of hash functions is obtained as @xmath118 .",
    "observe that every hash function @xmath46 in this family is a @xmath119-tuple of hash functions .",
    "specifically , the @xmath120 component of @xmath46 , for @xmath121 , is given by @xmath122 , where @xmath123 , and the @xmath109s and @xmath110 are elements of @xmath106 .",
    "the case when @xmath3 is not a power of @xmath1 is handled by splitting the words @xmath37 into slices of size @xmath124 , @xmath125 and so on .",
    "note that the family of hash functions defined above depends only on @xmath60 , @xmath3 and the vector @xmath126 , where @xmath127 .",
    "hence , we call this family @xmath128 . note also that by setting @xmath129 to @xmath130 for all @xmath131 , and @xmath129 to @xmath132 for @xmath133 reduces @xmath58 to the family @xmath56 of xor - based bit - wise hash functions mapping @xmath62 to @xmath134 .",
    "therefore , @xmath135 strictly generalizes @xmath56 .",
    "we summarize below important properties of the @xmath136 class .",
    "all proofs are available in full version ..    [ lm : universal ] for every @xmath137 and every @xmath138 , @xmath139 = \\prod_{j=0}^{|c|-1}{p_j}^{-c_j}$ ]    [ th - universal ] for every @xmath140 and every distinct @xmath141 , @xmath142 = \\prod_{j=0}^{|c|-1}({p_j})^{-2.c_j}$ ] .",
    "therefore , @xmath143 is pairwise independent .",
    "[ [ gaussian - elimination ] ] gaussian elimination + + + + + + + + + + + + + + + + + + + +    the practical success of xor - based bit - level hashing techniques for propositional model counting owes a lot to solvers like cryptominisat  @xcite that use gaussian elimination to efficiently reason about xor constraints .",
    "it is significant that the constraints arising from @xmath58 are linear modular equalities that also lend themselves to efficient gaussian elimination .",
    "we believe that integration of gaussian elimination engines in @xmath0 solvers will significantly improve the performance of hashing - based word - level model counters .",
    "we now present @xmath2 , a word - level hashing - based approximate model counting algorithm .",
    "@xmath2 takes as inputs a formula @xmath17 in the theory of fixed - width words , a tolerance @xmath144 , and a confidence @xmath145 $ ] .",
    "it returns an estimate of @xmath21 within the tolerance @xmath146 , with confidence @xmath147 .",
    "the formula @xmath17 is assumed to have @xmath60 variables , each of width @xmath3 , in its support .",
    "the central idea of @xmath2 is to randomly partition the solution space of @xmath17 into  small \" cells of roughly the same size , using word - level hash functions from @xmath128 , where @xmath148 is incrementally computed .",
    "the check for `` small''-ness of cells is done using a word - level @xmath0 solver .",
    "the use of word - level hash functions and a word - level @xmath0 solver allows us to directly harness the power of @xmath0 solving in model counting .",
    "the pseudocode for @xmath2 is presented in algorithm  [ alg : smtmc ] .",
    "lines  [ line : weightmc - init - start]  [ line : weightmc - init - end ] initialize the different parameters .",
    "specifically , @xmath149 determines the maximum size of a `` small '' cell as a function of @xmath146 , and @xmath150 determines the number of times @xmath151 must be invoked , as a function of @xmath152 .",
    "the value of @xmath150 is determined by technical arguments in the proofs of our theoretical guarantees , and is not based on experimental observations algorithm @xmath151 lies at the heart of @xmath2 .",
    "each invocation of @xmath151 either returns an approximate model count of @xmath17 , or @xmath153 ( indicating a failure ) . in the former case , we collect the returned value , @xmath154 , in a list @xmath155 in line  [ line : weightmc - loop - core - update ] . finally , we compute the median of the approximate counts in @xmath155 , and return this as @xmath156 .",
    "@xmath157 [ line : weightmc - init - start ] @xmath158 ; @xmath159 ; [ line : weightmc - init - end ] [ line : weightmc - loop - start ] @xmath160 ; [ line : weightmc - loop - core - invokation ] @xmath161 ; @xmath162 ; [ line : weightmc - loop - core - update ] [ line : weightmc - loop - end ] @xmath163 ; [ line : weightmc - median ] @xmath156 ; [ line : weightmc - return ]    the pseudocode for @xmath151 is shown in algorithm  [ alg : smtmccore ] .",
    "this algorithm takes as inputs a word - level @xmath0 formula @xmath17 , a threshold @xmath149 , and the width @xmath3 of words in @xmath18 .",
    "we assume access to a subroutine @xmath164 that accepts a word - level @xmath0 formula @xmath165 and a threshold @xmath149 as inputs , and returns @xmath166 solutions of @xmath165 if @xmath167 ; otherwise it returns @xmath168 . in lines  [ line : smtmccore - small - check - init]  [ line : smtmccore - small - check - end ] of algorithm  [ alg :",
    "smtmccore ] , we return the exact count if @xmath169 .",
    "otherwise , we initialize @xmath148 by setting @xmath170 $ ] to @xmath5 and @xmath171 $ ] to @xmath57 , where @xmath172 $ ] in the pseudocode refers to @xmath129 in the previous section s discussion .",
    "this choice of initialization is motivated by our experimental observations .",
    "we also count the number of cells generated by an arbitrary hash function from @xmath136 in @xmath173 .",
    "the loop in lines  [ line : smtmccore - loop - start][line : smtmccore - loop - end ] iteratively partitions @xmath174 into cells using randomly chosen hash functions from @xmath128 .",
    "the value of @xmath175 in each iteration indicates the extent to which words in the support of @xmath17 are sliced when defining hash functions in @xmath128  specifically , slices that are @xmath176-bits or more wide are used .",
    "the iterative partitioning of @xmath174 continues until a randomly chosen cell is found to be `` small '' ( i.e. has @xmath177 and @xmath178 solutions ) , or the number of cells exceeds @xmath179 , rendering further partitioning meaningless .",
    "the random choice of @xmath46 and @xmath180 in lines  [ line : smtmccore - choose - hash ] and  [ line : smtmccore - choose - alpha ] ensures that we pick a random cell .",
    "the call to @xmath164 returns at most @xmath166 solutions of @xmath17 within the chosen cell in the set @xmath181 .",
    "if @xmath182 , the cell is deemed to be large , and the algorithm partitions each cell further into @xmath183 parts .",
    "this is done by incrementing @xmath172 $ ] in line  [ line : smtmccore - increase - c - i ] , so that the hash function chosen from @xmath136 in the next iteration of the loop generates @xmath183 times more cells than in the current iteration . on the other hand ,",
    "if @xmath181 is empty and @xmath184 , the cells are too small ( and too many ) , and the algorithm reduces the number of cells by a factor of @xmath185 ( recall @xmath186 ) by setting the values of @xmath172 $ ] and @xmath187 $ ] accordingly ( see lines[line : smtmccore - refine - c - i - start ] [line : smtmccore - refine - c - i - end ] ) .",
    "if @xmath181 is non - empty and has no more than @xmath149 solutions , the cells are of the right size , and we return the estimate @xmath188 . in all other cases , @xmath189 fails and returns @xmath153 .",
    "@xmath190 ; [ line : smtmccore - small - check - init ] @xmath191 ; [ line : smtmccore - small - check - end ] @xmath192 ; @xmath170 \\gets 0",
    "$ ] ; @xmath171 \\gets 1 $ ] ; @xmath193 ;   @xmath194 ;    [ line : smtmccore - loop - start ] choose @xmath46 at random from @xmath136 ; [ line : smtmccore - choose - hash ] choose @xmath180 at random from @xmath195}$ ] ; [ line : smtmccore - choose - alpha ] @xmath196 ; [ line : smtmccore - call - boundedweightsat ] [ line : smtmccore - cell - comparison ] @xmath172 \\gets c[i]+1$];[line : smtmccore - increase - c - i ] @xmath197 ; @xmath172 \\gets c[i]-1 $ ] ; [ line : smtmccore - refine - c - i - start ] @xmath198 ; @xmath172 \\gets 1 $ ] ; @xmath199 ; [ line : smtmccore - refine - c - i - end ] break ; [ line : smtmccore - break ] [ line : smtmccore - loop - end ] @xmath153 ;  @xmath200 ; [ line : smtmccore - return ]    similar to the analysis of @xmath51  @xcite , the current theoretical analysis of @xmath2 assumes that for some @xmath148 during the execution of @xmath189 , @xmath201 .",
    "we leave analysis of @xmath2 without above assumption to future work .",
    "the following theorems concern the correctness and performance of @xmath2 .",
    "[ thm : guarantees ] suppose an invocation of @xmath2@xmath202 returns @xmath156 .",
    "then @xmath203 \\geq 1-\\delta$ ]    [ thm : complexity ] @xmath2@xmath202 runs in time polynomial in @xmath204 , @xmath205 and @xmath206 relative to an @xmath50-oracle .",
    "the proofs of theorem  [ thm : guarantees ] and  [ thm : complexity ] can be found in full version ..",
    "[ cols=\"^,^,^,^,^,^\",options=\"header \" , ]            squaring27 & 59 & \\{1 : 11 , 16 : 3 } & 10 &  & 2998.97 + 1159708 & 64 & \\{8 : 4 , 32 : 1 } & 12 & 14793.93 &  + 1159472 & 64 & \\{8 : 4 , 32 : 1 } & 8 & 16308.82 &  + 1159115 & 64 & \\{8 : 4 , 32 : 1 } & 12 & 23984.55 &  + 1159520 & 64 & \\{8 : 4 , 32 : 1 } & 1388 & 114.53 & 155.09 + 1160300 & 64 & \\{8 : 4 , 32 : 1 } & 1183 & 44.02 & 71.16 + 1159005 & 64 & \\{8 : 4 , 32 : 1 } & 213 & 28.88 & 105.6 + 1159751 & 64 & \\{8 : 4 , 32 : 1 } & 681 & 143.32 & 193.84 + 1159391 & 64 & \\{8 : 4 , 32 : 1 } & 681 & 57.03 & 91.62 + case1 & 17 & \\{1 : 13 , 4 : 1 } & 13 & 17.89 & 65.12 + 1159870 & 64 & \\{8 : 4 , 32 : 1 } & 164 & 17834.09 & 9152.65 + 1160321 & 64 & \\{8 : 4 , 32 : 1 } & 10 & 117.99 & 265.67 + 1159914 & 64 & \\{8 : 4 , 32 : 1 } & 8 & 230.06 & 276.74 + 1159064 & 64 & \\{8 : 4 , 32 : 1 } & 10 & 69.58 & 192.36 + 1160493 & 64 & \\{8 : 4 , 32 : 1 } & 8 & 317.31 & 330.47 + 1159197 & 64 & \\{8 : 4 , 32 : 1 } & 8 & 83.22 & 176.23 + 1160487 & 64 & \\{8 : 4 , 32 : 1 } & 10 & 74.92 & 149.44 + 1159606 & 64 & \\{8 : 4 , 32 : 1 } & 686 & 431.23 & 287.85 + case100 & 22 & \\{1 : 6 , 16 : 1 } & 8 & 32.62 & 89.69 + 1160397 & 64 & \\{8 : 4 , 32 : 1 } & 70 & 126.08 & 172.24 + 1160475 & 64 & \\{8 : 4 , 32 : 1 } & 67 & 265.58 & 211.16 + case108 & 24 & \\{1 : 20 , 4 : 1 } & 7 & 37.33 & 100.2 + case101 & 22 & \\{1 : 6 , 16 : 1 } & 12 & 44.74 & 90 + 1159244 & 64 & \\{8 : 4 , 32 : 1 } & 1474 & 408.63 & 273.57 + case46 & 20 & \\{1 : 8 , 4 : 3 } & 12 & 16.95 & 76.4 + case44 & 20 & \\{1 : 8 , 4 : 3 } & 8 & 13.69 & 72.05 + case134 & 19 & \\{1 : 3 , 16 : 1 } & 8 & 5.36 & 54.22 + case137 & 19 & \\{1 : 3 , 16 : 1 } & 9 & 10.98 & 56.12 + case68 & 26 & \\{8 : 3 , 1 : 2 } & 7 & 34.9 & 67.48 + case54 & 20 & \\{1 : 16 , 4 : 1 } & 8 & 50.73 & 103.91 + 1160365 & 64 & \\{8 : 4 , 32 : 1 } & 286 & 98.38 & 99.74 + 1159418 & 32 & \\{8 : 2 , 16 : 1 } & 7 & 3.73 & 43.68 + 1160877 & 32 & \\{8 : 2 , 16 : 1 } & 8 & 2.57 & 44.01 + 1160988 & 32 & \\{8 : 2 , 16 : 1 } & 8 & 4.4 & 44.64 + 1160521 & 32 & \\{8 : 2 , 16 : 1 } & 7 & 4.96 & 44.52 + 1159789 & 32 & \\{8 : 2 , 16 : 1 } & 13 & 6.35 & 43.09 + 1159117 & 32 & \\{8 : 2 , 16 : 1 } & 13 & 5.55 & 43.18 + 1159915 & 32 & \\{8 : 2 , 16 : 1 } & 11 & 7.02 & 45.62 + 1160332 & 32 & \\{8 : 2 , 16 : 1 } & 12 & 3.94 & 44.35 + 1159582 & 32 & \\{8 : 2 , 16 : 1 } & 8 & 5.37 & 43.98 + 1160530 & 32 & \\{8 : 2 , 16 : 1 } & 12 & 2.01 & 43.28 + 1160482 & 64 & \\{8 : 4 , 32 : 1 } & 36 & 153.99 & 120.55 + 1159564 & 32 & \\{8 : 2 , 16 : 1 } & 12 & 7.36 & 41.77 + 1159990 & 64 & \\{8 : 4 , 32 : 1 } & 34 & 71.17 & 97.25 + case7 & 18 & \\{1 : 10 , 8 : 1 } & 12 & 17.93 & 51.96 + case56 & 20 & \\{1 : 16 , 4 : 1 } & 12 & 41.54 & 109.3 + case43 & 15 & \\{1 : 11 , 4 : 1 } & 12 & 8.6 & 37.63 + case45 & 15 & \\{1 : 11 , 4 : 1 } & 12 & 9.3 & 35.77 + case53 & 19 & \\{1 : 7 , 8 : 1 , 4 : 1 } & 9 & 53.66 & 69.96 + case4 & 16 & \\{1 : 12 , 4 : 1 } & 12 & 8.42 & 35.49 + 1160438 & 64 & \\{8 : 4 , 32 : 1 } & 2366 & 199.08 & 141.84 + case109 & 29 & \\{1 : 21 , 4 : 2 } & 12 & 171.51 & 179.98 + case38 & 13 & \\{1 : 9 , 4 : 1 } & 7 & 6.21 & 30.27 + case11 & 15 & \\{1 : 11 , 4 : 1 } & 8 & 7.26 & 33.75 + 1158973 & 64 & \\{8 : 4 , 32 : 1 } & 94 & 366.6 & 270.17 + case22 & 14 & \\{1 : 10 , 4 : 1 } & 12 & 5.46 & 26.03 + case21 & 14 & \\{1 : 10 , 4 : 1 } & 12 & 5.57 & 24.59 + case52 & 19 & \\{1 : 7 , 8 : 1 , 4 : 1 } & 9 & 45.1 & 70.72 + case23 & 12 & \\{1 : 8 , 4 : 1 } & 11 & 2.29 & 12.84 + case51 & 19 & \\{1 : 7 , 8 : 1 , 4 : 1 } & 12 & 40 & 67.22 + case17 & 12 & \\{1 : 8 , 4 : 1 } & 12 & 2.75 & 11.09 + case33 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.7 & 9.66 + case30 & 13 & \\{1 : 5 , 4 : 2 } & 13 & 1.41 & 8.69 + case28 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.66 & 8.73 + case25 & 13 & \\{1 : 5 , 4 : 2 } & 12 & 1.39 & 8.27 + case27 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.69 & 8.57 + case26 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.68 & 8.35 + case32 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.46 & 8.16 + case31 & 11 & \\{1 : 7 , 4 : 1 } & 12 & 1.64 & 7.64 + case29 & 12 & \\{1 : 4 , 4 : 2 } & 8 & 0.67 & 5.16 + case24 & 12 & \\{1 : 4 , 4 : 2 } & 12 & 0.77 & 4.94 + 1160335 & 64 & \\{8 : 4 , 32 : 1 } & 216 & 0.31 & 0.54 + 1159940 & 64 & \\{8 : 4 , 32 : 1 } & 94 & 0.17 & 0.04 + 1159690 & 32 & \\{8 : 2 , 16 : 1 } & 8 & 0.12 & 0.04 + 1160481 & 32 & \\{8 : 2 , 16 : 1 } & 12 & 0.13 & 0.03 + 1159611 & 64 & \\{8 : 4 , 32 : 1 } & 73 & 0.2 & 0.09 + 1161180 & 32 & \\{8 : 2 , 16 : 1 } & 12 & 0.11 & 0.04 + 1160849 & 32 & \\{8 : 2 , 16 : 1 } & 7 & 0.1 & 0.03 + 1159790 & 64 & \\{8 : 4 , 32 : 1 } & 113 & 0.15 & 0.04 + 1160315 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.17 & 0.04 + 1159720 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.17 & 0.05 + 1159881 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.16 & 0.04 + 1159766 & 64 & \\{8 : 4 , 32 : 1 } & 73 & 0.15 & 0.03 + 1160220 & 64 & \\{8 : 4 , 32 : 1 } & 681 & 0.17 & 0.03 + 1159353 & 64 & \\{8 : 4 , 32 : 1 } & 113 & 0.16 & 0.04 + 1160223 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.17 & 0.04 + 1159683 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.17 & 0.03 + 1159702 & 64 & \\{8 : 4 , 32 : 1 } & 102 & 0.19 & 0.04 + 1160378 & 64 & \\{8 : 4 , 32 : 1 } & 476 & 0.17 & 0.04 + 1159183 & 64 & \\{8 : 4 , 32 : 1 } & 172 & 0.17 & 0.03 + 1159747 & 64 & \\{8 : 4 , 32 : 1 } & 322 & 0.18 & 0.03 + 1159808 & 64 & \\{8 : 4 , 32 : 1 } & 539 & 0.17 & 0.03 + 1159849 & 64 & \\{8 : 4 , 32 : 1 } & 322 & 0.18 & 0.03 + 1159449 & 64 & \\{8 : 4 , 32 : 1 } & 540 & 0.3 & 0.05 + case47 & 26 & \\{1 : 6 , 8 : 2 , 4 : 1 } & 11 & 81.5 & 80.25 + case2 & 24 & \\{1 : 20 , 4 : 1 } & 10 & 273.91 & 194.33 +    1159239 & 64 & \\{8 : 4 , 32 : 1 } & 238 & 1159.32 & 449.21 + case8 & 24 & \\{1 : 12 , 8 : 1 , 4 : 1 } & 8 & 433.2 & 147.35 + 1159936 & 64 & \\{8 : 4 , 32 : 1 } & 238 & 5835.35 & 1359.9 + squaring51 & 40 & \\{1 : 32 , 4 : 2 } & 7 & 3285.52 & 607.22 + 1159431 & 64 & \\{8 : 4 , 32 : 1 } & 12 & 36406.4 &  + 1160191 & 64 & \\{8 : 4 , 32 : 1 } & 12 & 40166.1 & "
  ],
  "abstract_text": [
    "<S> hashing - based model counting has emerged as a promising approach for large - scale probabilistic inference on graphical models . </S>",
    "<S> a key component of these techniques is the use of xor - based 2-universal hash functions that operate over boolean domains . </S>",
    "<S> many counting problems arising in probabilistic inference are , however , naturally encoded over finite discrete domains . </S>",
    "<S> techniques based on bit - level ( or boolean ) hash functions require these problems to be propositionalized , making it impossible to leverage the remarkable progress made in @xmath0 ( satisfiability modulo theory ) solvers that can reason directly over words ( or bit - vectors ) . in this work , </S>",
    "<S> we present the first approximate model counter that uses word - level hashing functions , and can directly leverage the power of sophisticated @xmath0 solvers . empirical evaluation over an extensive suite of benchmarks demonstrates the promise of the approach . </S>"
  ]
}