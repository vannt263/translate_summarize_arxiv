{
  "article_text": [
    "a lexical analyzer , also called lexer or scanner , is a piece of software that processes an input string conforming to a language specification and produces a sequence of the tokens or terminal symbols found in it .",
    "the obtained sequence of tokens is then usually fed to a parser or syntactic analyzer as the next step of a data translation , compilation or interpretation procedure .",
    "sometimes , lexical ambiguities may show up in a language specification .",
    "lexical ambiguities occur when an input string simultaneously corresponds to several token sequences @xcite .    the traditional way of choosing a sequence amongst potential alternatives @xcite involves assigning an unique priority to each token .",
    "this causes that , when the regular expressions associated to two different tokens match the same fragment of the input string , only the one with the greater priority will be considered .",
    "however , the language developer may want similar substrings to be recognized as different sequences of tokens depending on their context .",
    "this can not be achieved with the unique priority approximation .",
    "statistical lexical analyzers also exist @xcite .",
    "although statistical models may perform well in context - sensitive scenarios , they require intensive training and , as token types are actually guessed , they do not formally guarantee that the obtained token sequence will be what the developer intended .    when it comes to programming languages , data specification languages , or limited natural languages scenarios , the syntactic rules are clear as to what should be accepted .",
    "the usage of statistical models introduces an unpredictable possibility of error during token recognition that would render scanning and parsing theoretically and pragmatically unfeasible .    our proposal , lamb ( standing for _ lexical ambiguity _ ) , performs a lexical analysis that efficiently captures all the possible sequences of tokens and generates a lexical analysis graph that describes them all .",
    "a subsequent parsing process discards any sequence of tokens that does not provide a valid syntactic sentence conforming to the syntactic rule set of the language specification .",
    "this solves the lexical ambiguity problem with formal correctness .",
    "therefore , lamb allows language developers to specify more complex languages than traditional techniques .",
    "token priorities are still supported but their usage is optional .",
    "several tokens may be set to share the same priority if the developer wants ambiguities involving them to be considered .",
    "as research in lexical analyzers sets the basis for the application of parsers , it inherits their application fields : the compilation or interpretation of source code written in programming languages @xcite , the interpretation and integration of data in data mining applications @xcite , and natural language processing @xcite .",
    "the ieee posix p1003.2 standard describes the requirements of the _ lex _ and _ yacc _ tools @xcite , which are a traditional lexical analyzer generator and a traditional syntactic analyzer generator , respectively .",
    "implementations of these tools are typically used in conjunction :    * _ lex _ generates a lexer that takes as input a set of token types , associated regular expressions @xcite , and the string to be scanned ; and produces the sequence of tokens found in the string . *",
    "_ yacc _ generates a parser that takes as input the sequence of tokens and a syntactic rule set ; and produces a parse tree .",
    "regarding ambiguities , _ lex _ enforces the assignment of unique priorities to each token .",
    "indeed , tokens are tried and matched in the very same order they have been specified .",
    "the order of efficiency of a _",
    "lex_-generated lexical analyzer is @xmath0 , being @xmath1 the input string length .",
    "the example _ lex _ specification in figure [ fig : lexspecification1 ] shows an example of implicitly reserved words , as the words `` true '' , `` false '' , `` if '' , or `` while '' will not be considered identifiers , because they will match _ boolean _ , _ if _ , or _ while _",
    "tokens before reaching the regular expression for _ identifier_. therefore , it is not possible for _ lex _ to consider these words as identifiers in some contexts , even if syntactic rules make clear whether occurrences of these words should be considered as identifiers or not .",
    "statistical models as hidden markov models @xcite , hierarchical hidden markov models @xcite , or maximum entropy markov models @xcite consider the existence of implicit relationships between words , symbols , or characters that are close together in strings .",
    "these models need intensive corpus - based training and they produce results with associated implicit probabilities .",
    "it should be noted that , even though they can perform well in natural language processing , their training requirement is impractical for programming or data representation languages , especially when the syntactic rules provide all the needed context information to unequivocally identify tokens .",
    "furthermore , the results are prone to interpretation errors that would render the analysis unusable .",
    "the semi - syntactic lexical analyzer proposed in @xcite brings some of the context information found in the syntactic rule set to the deterministic finite automaton that perform the lexical analysis .",
    "although this technique considers context information found in syntactic rules , it is not able to capture syntactic ambiguities for its further consideration , since the minimal automaton needed to do this is a non - deterministic finite automaton , which would have increased complexity of the algorithm .",
    "therefore , if the lexical ambiguities may cause syntactic ambiguities or , in other words , there are several syntactic interpretations of the input string due to lexical ambiguities , a shyu - like lexer would be unable to find them .",
    "in contrast to the aforementioned techniques , lamb is able to recognize and capture lexical ambiguities .",
    "our proposed algorithm takes as input the string to be scanned and a list of tokens associated to their corresponding regular expressions .",
    "it produces , as output , a lexical analysis graph , in which each token is connected to its following and preceding tokens in the input sequence .",
    "our algorithm consists of two steps : the scanning step , which recognizes all the possible tokens in the input string ; and the graph generation step , which computes the sets of preceding and following tokens for each token and builds the resulting lexical analysis graph .",
    "the pseudocode for the scanning step is shown in figure [ fig : codescan ] .    ....",
    "if            return(if ) ; while         return(while ) ; true|false    return(boolean ) ; [ _ a - za - z]+    return(identifier ) ; ....    .... for i in 0 .. input.length()-1 :    prio = -1    for each matcher m in matcherlist :      if ( prio > = m.prio || prio = = -1 ) & &          ( prio ! = 0 & & next[j ] < i ) :        match = m.match(input,i )        if match ! = null :          priority = matcher.priority          if m.isignore==false :            t = new token (                 i d = i d ,                 type   = matcher.type ,                 text   = match ,                 start = i ,                 end    = i+match.length()-1               )            tokenlist.add(t )            id++          min = i+match.length()-1          for each matcher n in matcherlist :            if n.next < = min & & n.next > = i :              min = n.next            if n.next > m.next :              n.next = i+match.length()-1          if i > = min :            min = i          m.next = min          for each matcher n in matcherlist :            if n.prio > m.prio :              n.next = min ....    our algorithm receives an input string called _ input _ and a list of matchers called",
    "each matcher consists of a regular expression and its corresponding _ match _ method , a _ priority _ value , and a _ next _ value .",
    "the _ match _ method tries to perform a match given the input string and a starting position in it .",
    "the _ priority _ value specifies the matcher priority .",
    "the value 0 is reserved for ignored patterns , which are patterns that represent text that does not correspond to tokens .",
    "then , priority values for relevant token start at 1 , being the lower the value , the higher the priority .",
    "if two tokens share the same priority value , the lexer will capture both of them if they overlap due to lexical ambiguities .",
    "if two tokens have distinct priority values and they start at the same position in the input string , only the greater priority token will be considered .",
    "the _ next _ value specifies the position before the next string position a matcher will be tried at .",
    "it defaults to -1 , so every matcher will be tried at the 0 position .    the _ prio _ variable represents the last priority that has been matched in the current input position .",
    "its value is -1 if no match has been made , 0 if an ignored element match has been made , and a higher value if any token of that specific priority has been identified .",
    "the _ min _ variable is computed in order to determine the next position the current matcher will be tried at , and its value is the minimum of either the ending position of the found token or the ending position of any tokens that end before it .",
    "this algorithm step has a theoretical order of efficiency of @xmath2 , being @xmath1 the input string length and @xmath3 the number of matchers in the lexer .",
    "the algorithm pictured in figure [ fig : codegraph ] goes through the identified token list in reverse order and efficiently computes the sets of preceding and following tokens for every token .",
    ".... for i in tokenlist.size()-1..0 :    t = tokenlist[i ]    for j in i+1 .. tokenlist.size()-1 :      tc = tokenlist[j ]      if ( tc.start > t.end & &          ( tc.prevstart==tc.start ||           ( tc.prevstart<tc.start & &            tc.prevstart<t.end ) ) ) :        t.addfollowing(tc )        tc.addpreceding(t )        tc.prevstart = min(t.start ,                             tc.prevstart ) ....    the sets of preceding and following tokens of the token @xmath4 are defined in equation [ eq : nextprev ] , being @xmath5 tokens and @xmath6 and @xmath7 the starting and ending positions of the token @xmath4 in the input string .",
    "@xmath8    the _ prevstart _ variable in the pseudocode avoids the need of iterating through the token list to find out if there is any token between two particular tokens , because it represent the starting position values of preceding tokens , given a certain token .",
    "after the following and preceding sets have been computed for every token , any token whose preceding set is empty is added to the start token set of the lexical analysis graph .",
    "the graph generation has a theoretical order of efficiency of @xmath9 , being @xmath10 the number of tokens found .",
    "as @xmath11 , the theoretical order of efficiency of this step is @xmath12 .",
    "both scanning and graph generation steps together have an order of efficiency of @xmath12 .",
    "in order to perform a formal comparison of traditional techniques and lamb , we have implemented a simple ( and inefficient ) proof of concept parser that supports ambiguities and allows a lexical analysis guided by a syntactic rule set .",
    "this parser returns as many parse trees as they can be obtained by applying a set of syntactic rules to a lexical analysis graph .",
    "its pseudocode is shown in figure [ fig : codeparser ] .",
    "it iteratively tries to match every rule starting from every existing token and following any possible token path , and it adds the newly found tokens to the list until no new tokens have been found in an iteration .    .... do :    flag = false    for each rule r in rules :      for each token t in tokenlist :        matches = r.match(t )        if matches.size ( ) ! = 0 :          for each match m in matches :            if !",
    "tokenlist.contains(m ) :              tokenlist.add(m )              if m is start symbol                start.add(m )              flag = true while flag = true ....                        given a language specification that describes the tokens listed in figure [ fig : tokens ] , the input string `` & 5.2 & /25.20/ '' can correspond to the four different lexical analysis alternatives enumerated in figure [ fig : analysis ] , depending on whether the sequences of digits separated by points are considered real numbers or integer numbers separated by points .",
    "( -|\\+)?[0 - 9]+               integer     ( -|\\+)?[0 - 9]+\\.[0 - 9]+       real     \\.",
    "point     \\/                          slash     \\ &                          ampersand ....    * ` ampersand integer point integer ampersand slash integer point integer slash ` * ` ampersand integer point integer ampersand slash real slash ` * ` ampersand real ampersand slash integer point integer slash ` * ` ampersand real ampersand slash real slash `    .... e : : = a b a : : = ampersand real ampersand b : : = slash integer point integer slash ....    the syntactic rules shown in figure [ fig : srules ] illustrate a scenario of lexical ambiguity sensitivity . depending on the surrounding tokens , which may be either _ ampersand _ tokens or _ slash _ tokens , the sequences of digits separated by points should be considered either _",
    "real _ tokens or _ integer point integer",
    "_ token sequences .",
    "the expected results of analyzing the input string `` & 5.2 & /25.20/ '' is shown in figure [ fig : e4 ] .    in order to resolve the ambiguities when using a _",
    "lex_-alike lexer , the developer can assign the _ integer _ token a greater priority than the _ real _ token . in that case",
    ", the only valid interpretation would be the one shown in figure [ fig : e3 ] .",
    "the developer can also assign the _",
    "real _ token a greater priority than the _ integer _ token . in that case , the only valid interpretation would be the one shown in figure [ fig : e2 ] .",
    "therefore , _",
    "lex_-alike lexers can not produce the token sequence that is needed to parse strings that belong to our language with lexical ambiguities .",
    "nonetheless , as lamb is able to capture all the possible token sequences in the form of a lexical analysis graph , as shown in figure [ fig : e1 ] , the later application of a parser supporting lexical ambiguities will produce the only possible valid sentence , which , in turn , is based on the only valid lexical analysis possible .",
    "both of them are shown in figure [ fig : e5 ] .",
    "even though statistical models as hidden markov models may produce correct results in similar situations , they can not be used for this kind of language specifications , where the specification states how each token is to be recognized . besides",
    ", their results may not be always accurate , which difficults formally proving their correctness in a well - defined setting .",
    "we have presented a lexical analyzer , lamb , that supports lexical ambiguities .",
    "it performs a lexical analysis that efficiently captures all the possible sequences of tokens for lexically - ambiguous languages and it generates a lexical analysis graph that describes them all .",
    "lamb supports assigning priorities to tokens as traditional techniques do but , in contrast to them , it does not enforce these priorities to be set and it allows for priority values to be shared .",
    "tokens with shared priorities are considered valid alternatives instead of mutually - exclusive options .",
    "the lexical graph can be then fed as input to a parser , which will discard any sequence of tokens that does not produce a valid syntactic analysis . in summary ,",
    "our proposal performs a context - sensitive lexical analysis guided by syntactic rules and supports lexically - ambiguous language specifications ."
  ],
  "abstract_text": [
    "<S> lexical ambiguities naturally arise in languages . </S>",
    "<S> we present lamb , a lexical analyzer that produces a lexical analysis graph describing all the possible sequences of tokens that can be found within the input string . </S>",
    "<S> parsers can process such lexical analysis graphs and discard any sequence of tokens that does not produce a valid syntactic sentence , therefore performing , together with lamb , a context - sensitive lexical analysis in lexically - ambiguous language specifications . </S>"
  ]
}