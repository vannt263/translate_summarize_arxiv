{
  "article_text": [
    "the _ suffix array _ ( ) , the _ longest common prefix array _ ( ) and the _ burrows - wheeler transform _",
    "( ) are data structures with many important applications in stringology @xcite .",
    "the   array of a string contains the lengths of the longest common prefixes of the suffixes pointed to by adjacent elements of the suffix array of the string @xcite .",
    "the most immediate utility of the  is to speed up suffix array algorithms and to simulate the more powerful , but more resource consuming , suffix tree .",
    "indeed , the   array , combined with  or , simplifies the algorithms for some applications such as the rapid search for maximal exact matches , shortest unique substrings and shortest absent words @xcite .",
    "real world situations may present us with datasets that are not a single string but a large collection of strings , examples being corpora of web pages or the data coming from `` next - generation '' dna sequencing ( ngs ) technologies .",
    "it is common for the latter in particular to generate aggregations of hundreds of millions of dna strings ( sometimes called `` reads '' ) , leading to a need for algorithms that deal not only with the collective nature of the data but also with its large overall size . in this paper",
    "we give an algorithm for the construction of  array that addresses both these requirements .",
    "the importance of the  array has meant that its construction has been well - studied in the literature .",
    "for instance , there are algorithms that work in linear time and in internal memory ( cf .",
    "@xcite ) . other algorithms work in semi - external memory ( see for instance @xcite ) or directly via  ( see @xcite ) . in @xcite , the first algorithm establishing that  array can be computed in @xmath0 complexity in the external memory model ( i.e.",
    ", the complexity of sorting @xmath1 integers in external memory ) is presented .",
    "recently , in @xcite an external memory algorithm to construct the suffix array of a string based on the induced sorting principle is provided .",
    "such an algorithm can be augmented to also construct the  array .",
    "the overhead in time and i / o operations for this extended algorithm over plain suffix array construction is roughly two . in another recent paper @xcite",
    ", the authors introduced an external memory  array construction algorithm for a string .",
    "the main idea in @xcite is to divide the string into blocks that are small enough to fit in ram and then scan the rest of the string once for each block .",
    "such a strategy needs @xmath2 bytes of disk space , where @xmath1 is the length of the string .",
    "one s initial strategy for building the  array of a collection might therefore be to concatenate its members into a single string and then apply one of the above methods .",
    "however , some stumbling blocks become apparent , and it is not immediate how these single - string approaches can be adapted to circumvent them .",
    "first , many existing algorithms for computing the  array require data structures of size proportional to the input data to be held in ram , which has made it impractical to compute the  array of a very large string .",
    "moreover , by definition , the values in  array should not exceed the lengths of the strings , so one would ideally employ distinct end - marker symbols to act as separators between the strings of the collection",
    ". however , assigning a different end - marker to each string is not feasible when the number of strings in the collection is very large . on the other hand",
    ", the use of the same end - marker symbol throughout the collection could give rise to  values with the undesirable properties of sometimes exceeding the lengths of the strings and having dependencies on the order in which the strings are concatenated .",
    "in the literature , the problem of the computation of  array for a collection of strings has been considered in @xcite and in @xcite . moreover , a preliminary version of the results presented in this paper is in @xcite . in particular , this paper includes full proofs of theorems from @xcite and more detailed examples .",
    "furthermore , additional experimental results are also described .",
    "finally , in this paper we introduce a simple solution for dealing with strings having different lengths , allowing  to work on any collection of strings .    defining @xmath3 and @xmath4 as the sum of the lengths of all strings and the length of the longest string in the collection respectively",
    ", the approach in @xcite requires @xmath5 time , but the @xmath6 bits of internal memory needed to store the collection and its  in internal memory prevents the method from scaling to massive data .",
    "the external memory algorithm ( called ) in @xcite builds both suffix and  arrays for a collection of strings .",
    "such interesting strategy has an overhead in working disk space , so it seems that  can not be used for huge collections of strings .",
    "the methodology presented in this paper attempts to overcome the above mentioned limitations .",
    "in fact , the aim of our paper is to design a lightweight algorithm for the computation , at the same time , of the longest common prefix array and the burrows - wheeler transform of a very large collection of strings having different or same length .",
    "the computation is realized by performing disk data accesses only via sequential scans .",
    "the total disk space usage never needs more than twice the output size , excluding the disk space required for the input .    in our approach , we directly compute both data structures , without needing to concatenate the strings of the collection and without requiring pre - computed auxiliary information such as the suffix array of the collection .    in order to do this ,",
    "our algorithm is built upon the approach introduced in @xcite related to an extension of the _ burrows - wheeler transform _ to a collection of strings defined in @xcite .",
    "in particular , our algorithm ( called ) adds to the strategy in @xcite ( called ) some lightweight data structures , and allows the simultaneous computation of both the longest common prefix and the burrows - wheeler transform of a collection of @xmath7 strings .",
    "such a computation is performed in @xmath8 bits of memory , with a worst - case time complexity of @xmath9 , where @xmath10 is the time taken to sort @xmath7 integers , @xmath11 is the size of the alphabet , @xmath3 is the sum of the lengths of all strings and @xmath4 is the length of the longest string .",
    "note that  needs at most @xmath12 bits of disk space and requires @xmath13 disk i / o operations , where @xmath14 is the disk block size .",
    "the low memory requirement enables our algorithm to scale to the size of dataset encountered in human whole genome sequencing datasets : in our experiments , we compute the  and  of collections as large as @xmath15 million strings having length @xmath16 .",
    "moreover ,  allows to compute also the suffix array of the strings of a collection ( called _ generalized suffix array _ ) .",
    "such a further computation increases the number of i / o operations , but it does not need further data structures in internal memory .    section  [ sec : prel ] gives preliminaries that we will use throughout the paper , in section  [ sec : ads_collection ] we define the main data structures for a collection of strings , section  [ bcrstrategy ] describes an incremental strategy for computing the  of a collection of strings of any length .",
    "section  [ sec : algorithm ] shows the sequential computation of the  array for the collection .",
    "we present details on the efficient implementation of the algorithm and its complexity in sections  [ sec : implementation ] and [ sec : bcrlcp_complexity ] , respectively .",
    "computational results on real data are described in section [ sec : experiments ] .",
    "section [ sec : conclusion ] is devoted to some conclusions .",
    "let @xmath17 be a finite ordered alphabet with @xmath18 , where @xmath19 denotes the standard lexicographic order .",
    "we append to a finite string @xmath20 an end - marker symbol @xmath21 that satisfies @xmath22 .",
    "we denote its characters by @xmath23 , w[2],\\ldots , w[k]$ ] , where @xmath24 is the _ length _ of @xmath25 , denoted by @xmath26 .",
    "note that , for @xmath27 , @xmath28\\in \\sigma$ ] and @xmath29=\\$ \\notin \\sigma$ ] .",
    "a _ substring _ of a string @xmath25 is written as @xmath30 = w[i ] \\cdots w[j]$ ] , with a substring @xmath31 $ ] being called a _ prefix _ , while a substring @xmath32 $ ] is referred to as a _",
    "suffix_. a range is delimited by a square bracket if the correspondent endpoint is included , whereas the parenthesis means that the endpoint of the range is excluded .",
    "we denote by @xmath33 the collection of @xmath7 strings of length at most @xmath4 .",
    "we suppose that to each string @xmath34 is appended an end - marker symbol @xmath35 smaller than @xmath36 , and @xmath37 if @xmath38 .",
    "let us denote by @xmath3 the sum of the lengths of all strings in @xmath39 .    for @xmath40",
    ", we refer to the suffix @xmath41 $ ] of a string @xmath34 as its _",
    "@xmath42-suffix _ ; the _ 0-suffix _ of @xmath34 contains @xmath35 alone .",
    "the length of a @xmath42-suffix is equal to @xmath42 ( up to considering the end - marker ) .",
    "let us denote by @xmath43 the collection of the @xmath42-suffixes of all the strings of @xmath39 .",
    "in our algorithm presented in this paper we use a unique end - marker @xmath44 for all strings in @xmath39 , because we set @xmath45 < w_t[|w_t|]$ ] if and only if @xmath46 , so that if two strings @xmath47 and @xmath48 share the @xmath42-suffix , then @xmath49 < w_t[|w_t|-j,|w_t|]$ ] if and only if @xmath46 .",
    "however , to ease the presentation distinct end - markers are shown .",
    "we say that the symbol @xmath50 $ ] is _ associated with _",
    "the @xmath42-suffix of @xmath34 for @xmath51 , because @xmath50 $ ] precedes the @xmath42-suffix of @xmath34 , i.e. the suffix @xmath41 $ ] .",
    "moreover , we assume that @xmath52=\\$_i$ ] is associated with the @xmath53-suffix of @xmath34 , i.e. @xmath54 $ ] .",
    "suffix array , longest common prefix array and burrows - wheeler transform are all commonly defined with reference to a single string .",
    "this section describes the extension of such notions to a collection of strings .",
    "the _ suffix array _  of a string @xmath25 is an array containing the permutation of the integers @xmath55 that arranges the starting positions of the suffixes of @xmath25 into lexicographical order .",
    "there exist some natural extensions of the suffix array to a collection of strings ( see @xcite ) .",
    "we define the _ generalized suffix array _ @xmath56 of the collection @xmath33 as the array of @xmath3 pairs of integers @xmath57 , corresponding to the lexicographically sorted suffixes @xmath58 $ ] , where @xmath59 and @xmath60 .",
    "in particular , @xmath61=(t , j)$ ] is the pair corresponding to the @xmath62-th smallest suffix of the strings in @xmath39 , i.e. to the suffix @xmath58 $ ] .",
    "the _ longest common prefix array _ of a string contains the lengths of the longest common prefixes of the suffixes pointed to by adjacent elements of  of the string @xcite .",
    "the _ longest common prefix array _  of a collection @xmath39 of strings , denoted by @xmath63 , is an array storing the length of the longest common prefixes between two consecutive suffixes of @xmath39 in the lexicographic order . for every @xmath64 ,",
    "if @xmath65=(p_1,p_2)$ ] and @xmath66=(q_1,q_2)$ ] , @xmath67 $ ] is the length of the longest common prefix of suffixes starting at positions @xmath68 and @xmath69 of the words @xmath70 and @xmath71 , respectively .",
    "we set @xmath72=0 $ ] .    for @xmath73 , a _ range minimum query _",
    "@xmath74 on the interval @xmath75 $ ] in the  array returns an index @xmath24 such that @xmath76 = \\min \\{lcp[l ] : i \\leq l \\leq j\\}$ ] . if @xmath77=(p_1,p_2)$ ] and @xmath78=(q_1,q_2)$ ] , it is not difficult to show that the length of the longest common prefix between the suffixes starting at positions @xmath68 and @xmath69 of the words @xmath70 and @xmath71 corresponds to @xmath79 $ ] .",
    "the suffix array of a string is related to the _ burrows - wheeler transform _ introduced in @xcite .",
    "the original burrows and wheeler transform ( ) on a string is described as follows : given a word @xmath20 , the output of  is the pair @xmath80 obtained by lexicographically sorting the list of the conjugates of @xmath25 . in particular , @xmath81 is the word obtained by concatenating the last symbol of each conjugate in the sorted list and @xmath82 is the position of @xmath25 in such a list .",
    "for instance , if @xmath83 then @xmath84 is not appended to the input string @xmath25 .",
    "] .    actually , in several implementations of the , in order to improve the efficiency of the computation , one can consider a variant of the  by the sorting the suffixes of @xmath85 rather than the conjugates of @xmath25 . to ensure the reversibility of the transform",
    ", one needs to append the symbol @xmath21 at the end of the input string @xmath86\\cdots w[k-1]$ ] , where @xmath28 \\in \\sigma$ ] , @xmath87 and @xmath88 .",
    "hence the @xmath21 symbol is at the position @xmath24 of @xmath25 , so that @xmath86\\cdots w[k-1 ] w[k]$ ] . in this variant ,",
    "the output @xmath89 is a permutation of @xmath25 , obtained as concatenation of the letters that ( circularly ) precede the first symbol of the suffix in the lexicographically sorted list of its suffixes : for @xmath90 , @xmath91=w[sa[i]-1]$ ] ; when @xmath92=1 $ ] , then @xmath91=\\$$ ] ( it wraps around ) . in other words , the @xmath93-th symbol of",
    "the  is the symbol just before the @xmath93-th suffix .",
    "for instance , if @xmath94 then @xmath95 . note that , in this case , the second output of the  ( the index @xmath82 ) is not useful , because one can use the position of the @xmath21-symbol for recovering the input string .    the burrows - wheeler transform can be extended to a collection of strings . in its original definition @xcite",
    "( see also @xcite ) , such a reversible transformation ( called ) produces a string that is a permutation of the characters of all strings in @xmath39 and it does not make use of any end - marker . the  of a collection @xmath39 is a word ( denoted by @xmath96 ) ) obtained by letter permutation of the words in @xmath39 together a set of indexes ( denoted by @xmath97 ) used to recover the original collection . in particular , @xmath96 is obtained by concatenating the last symbol of each element in the sorted list of the conjugates of the words in @xmath39 .",
    "the sorting exploits an order relation defined by using lexicographic order between infinite words .",
    "for instance , if @xmath98 , the output of   of @xmath39 is the couple @xmath99 .    in this paper we use a more efficient variant of   of a collection of strings , that needs to append a different end - marker to each string of @xmath39 . in this case the word obtained as output , denoted by @xmath100 , is obtained by concatenating the symbols just preceding each suffix of the list of the suffixes of the words in @xmath39 in according with the lexicographic order .",
    "the output @xmath100 can be also defined in terms of the generalized suffix array of @xmath39 . in particular , if @xmath101=(t , j)$ ] then @xmath102 = w_j[(t-1)]$ ] ; when @xmath103 , then @xmath102=\\$_j$ ] . by using the above example , @xmath104 .",
    "the external memory methods for computing the output @xmath100 are given in @xcite .",
    "furthermore , in practice , such methods use a unique end - marker rather than @xmath7 different end - markers . note that @xmath100 differs , for at least @xmath7 symbols , from @xmath105 applied to the string obtained by concatenating all strings in @xmath39 .",
    "our approach for computing the  array is built upon the  algorithm introduced in @xcite to compute @xmath100 , where @xmath39 is a collection of strings .",
    "note that  in @xcite is described for collections of strings of fixed length . in this section",
    "we focus on the description of  on collections of strings of any length .",
    "the  algorithm @xcite computes the @xmath100 of the collection of strings @xmath106 without concatenating the strings . in the sequel",
    ", we assume that @xmath107 .",
    "note that we consider the symbol @xmath35 appended to each string @xmath34 .",
    "we suppose that @xmath4 is the maximal length ( including the end - markers ) of the strings in @xmath39 and @xmath3 the sum of their lengths ( including the end - markers ) .",
    "we assume that @xmath108 .    in subsection [ subsec : bcr_algo ]",
    "we describe how the algorithm works on a collection of strings of any length , subsection [ subsec : bcr_ds ] is devoted to detail the involved data structures needed to allow a lightweight implementation and to reduce the i / o operations .",
    "the basic idea of the  algorithm is to scan all the strings @xmath109 in the collection @xmath39 from right to left at the same time .",
    "this means that , at each iteration , it considers a `` slice '' of ( at most ) @xmath7 characters from the strings in the collection",
    ".  builds incrementally , via @xmath4 iterations , the burrows - wheeler transform of @xmath39 by simulating , step by step , the insertion of all suffixes having the same length in the list of sorted suffixes .    at the end of each iteration @xmath110 ,",
    "algorithm builds a partial @xmath100 ( denoted by @xmath111 ) .",
    "it is referred to as partial , because if one inserts the @xmath21-characters in their correct position ( rather than the symbols that precede the @xmath42-suffixes ) , then one immediately obtains the @xmath112 of all @xmath42-suffixes of @xmath39 ( if the length of some string is greater than @xmath42 ) .",
    "for instance , if @xmath113 ( including the distinct end - markers ) , @xmath114 corresponds to the computation of @xmath115 when the end - markers are inserted .",
    "the key point of this strategy is to establish the positions where the new symbols associated with the @xmath42-suffixes must be inserted in @xmath116 in order to obtain @xmath111 . in other words",
    ", we have to find the position of each @xmath42-suffix in the list of sorted @xmath117-suffixes with @xmath118 , without explicitly computing such a list .    in particular , at the step @xmath119",
    ", we have to consider the symbols associated with the @xmath120-suffixes and establish how they must be concatenated in order to obtain @xmath121 . since we use ( implicit ) distinct end - markers and @xmath122 if @xmath38 , then it is easy to verify that @xmath121 is obtained by considering the last symbol of each string @xmath34 and by concatenating them in the same order as the strings appear in the collection : @xmath123w_1[|w_1| - 1 ] \\cdots w_{m-1}[|w_{m-1}| - 1]$ ] .    at the iteration @xmath124",
    ", we need to retain @xmath116 , keep track of the positions within it of the symbols @xmath125 $ ] associated with the @xmath126-suffixes of @xmath39 and build @xmath111 by inserting at most @xmath7 new symbols into @xmath116 , i.e. @xmath50 $ ] for @xmath127 or @xmath21 for @xmath128 .",
    "such operations simulate the insertion of the @xmath42-suffixes into the list of sorted suffixes computed in the previous step . note that if @xmath129 then the string @xmath34 is not considered .",
    "the process ends at the step @xmath130 , when  considers the @xmath42-suffixes of the strings @xmath34 with @xmath131 and inserts the end - markers of such strings into @xmath132 , in order to obtain @xmath133 , i.e. the @xmath100 .    in order to find , at each step @xmath134 , the positions where the new ( at most ) @xmath7 symbols must be inserted into @xmath116 , we use the notions related to backward search , such as the table @xmath135 and the @xmath136 function that have been extensively used in fm - index ( see @xcite ) .",
    "formally , given a string @xmath25 , @xmath137 $ ] is a table of @xmath11 integers that , for each character @xmath138 , contains the number of occurrences of lexicographically smaller characters in the string @xmath25 .",
    "moreover , given a symbol @xmath139 , an integer @xmath140 and a string @xmath25 , the function @xmath141 returns the number of occurrences of character @xmath139 in the prefix @xmath142 $ ] .    in our context",
    "we suppose that , at the step @xmath143 , we have inserted the symbol @xmath144 $ ] at the position @xmath140 of @xmath116 . at the step @xmath134 , for each @xmath93 with @xmath145 ,",
    "the position @xmath146 , where we have to insert the new symbol associated with the @xmath42-suffix @xmath147 $ ] into @xmath116 , is computed in the following way : @xmath148 + \\rank(x , r , \\bwts{j-1 } ) + 1.\\ ] ]    note that such a formula corresponds to the computation of the so - called @xmath149-mapping , a fundamental operation of the fm - index .",
    "in order to decrease the i / o operations ,  does not use the table @xmath135 and computes the  function on segments of @xmath116 rather than on the entire @xmath116 .",
    "more precisely ,  considers @xmath111 as the concatenation of @xmath150 segments @xmath151 , where the symbols in @xmath152 are the characters preceding the lexicographically sorted @xmath120-suffixes of @xmath43 ( such suffixes consist in only the end - marker symbols ) and the symbols in @xmath153 , with @xmath154 , are the characters preceding the lexicographically sorted suffixes of @xmath43 starting with @xmath155 .",
    "it is easy to see that , @xmath156 and the segments @xmath157 ( for @xmath158 ) does not contain any symbols .    now , we can omit the table @xmath135 , because it is only useful for determining the segment where the suffix must be inserted .",
    "indeed , the table @xmath135 simply allows us to establish that if the @xmath42-suffix starts with the symbol @xmath159 $ ] then it is larger than the suffixes starting with a symbol smaller than @xmath160 .",
    "this is equivalent to say that the @xmath42-suffix must be inserted in the block containing the suffixes starting with the symbol @xmath160 , i.e. in @xmath161 .",
    "one can verify that the position @xmath140 in @xmath116 corresponds to a position @xmath162 in @xmath163 where @xmath164 is the first symbol of @xmath126-suffix of @xmath34 , i.e @xmath165 $ ] .",
    "now , the new symbol @xmath50 $ ] ( or the end - marker @xmath21 for the last step ) must be inserted in the position @xmath140 of @xmath161 , where @xmath140 is obtained by computing the number of occurrences of @xmath166 $ ] in @xmath167 and in @xmath168 $ ] . moreover",
    ", the computation of @xmath168 $ ] corresponds to the computation of the function @xmath169 .",
    "note that , in order to compute the occurrences in @xmath167 , a table of @xmath170 bits of memory can be used .",
    "we remark that for each step @xmath42 , our strategy computes , for each @xmath42-suffix @xmath171 , its definitive position in the sorted list of the elements of @xmath43 , regardless of the fact that some @xmath42-suffixes lexicographically smaller than @xmath171 have not been considered yet in the current step @xmath42 .",
    "actually , this means that the algorithm computes the definitive position ( called _ absolute position _ ) of the symbol associated to @xmath171 in the correspondent segment @xmath172 .    during each iteration @xmath42",
    ", we use the arrays @xmath173 , @xmath3 , @xmath174 , @xmath175 containing at most @xmath7 elements each .",
    "the values in such arrays are updated during each step .",
    "for ease of presentation we denote by @xmath176 , @xmath177 , @xmath178 , @xmath179 the arrays at the step @xmath42 , described as follows . for each @xmath180 :    * @xmath181 is an array that stores all the symbols , if they exist , located at the position @xmath182 from the right .",
    "more formally , @xmath183=w_q[|w_q|-j-1]$ ] if @xmath184 , @xmath183=\\$_q$ ] if @xmath185 , @xmath183=\\#$ ] if @xmath186 . note that @xmath187 is a symbol that does not appear in any string of the collection and it is not involved in the computation of @xmath111 .",
    "the array @xmath181 takes @xmath188 bits of workspace .",
    "* @xmath189 is an array of integers such that @xmath190=i$ ] if the @xmath42-suffix of the string @xmath191 ( with @xmath192 ) is the @xmath62-th @xmath42-suffix in the lexicographic order .",
    "it uses @xmath193 bits of workspace .",
    "* @xmath194 is an array of integers such that @xmath195 $ ] is the absolute position of the symbol @xmath196 $ ] ( or the end - marker @xmath35 ) , associated with the @xmath42-suffix of @xmath34 ( with @xmath192 ) , in @xmath161 , where @xmath197 $ ] and @xmath160 is the first symbol of the @xmath42-suffix of @xmath34 , i.e. @xmath198 $ ] .",
    "it needs @xmath199 bits of workspace . *",
    "@xmath200 is an array of integers such that @xmath201 $ ] stores the index @xmath202 where @xmath166 $ ] where @xmath190=i$ ] , i.e. the first symbol of the @xmath42-suffix of @xmath34 ( with @xmath192 ) .",
    "it uses @xmath188 bits of workspace .",
    "note that , at each step @xmath42 ranging from @xmath120 to @xmath130 , the algorithm considers only the first @xmath117 values of arrays @xmath178 , @xmath179 and @xmath177 where @xmath117 is the number of the strings of the collection having length greater than or equal to @xmath42 .    at the start of the iteration @xmath42 ,",
    "we compute the new values in @xmath200 , @xmath194 , @xmath177 in the following way .",
    "we suppose that the @xmath126-suffix of @xmath34 is the @xmath117-th @xmath126-suffix in lexicographic order , i.e. @xmath203 $ ] .",
    "hence , we know that the first symbol of the @xmath42-suffix of @xmath34 is @xmath198 $ ] and has been inserted in the position @xmath204=s$ ] in @xmath163 , where @xmath205=v$ ] and @xmath164 is the first symbol of @xmath126-suffix of @xmath34 , i.e @xmath206 $ ] .",
    "the position @xmath140 of the new symbol @xmath50 $ ] ( or the end - marker @xmath35 for @xmath207 ) that must be inserted in @xmath161 is obtained by computing the number of occurrences of @xmath166 $ ] in @xmath167 and in @xmath168 $ ] , where @xmath208 $ ] is the position of @xmath160 in @xmath163 .    note",
    "that during the iteration @xmath42 , we store the values in @xmath178 , @xmath179 , @xmath177 and @xmath176 by replacing the corresponding values in @xmath209 , @xmath210 , @xmath211 and @xmath212 , so @xmath213=z$ ] , @xmath214=r$ ] and @xmath215=i$ ] .",
    "finally , we sort @xmath200 , @xmath194 , @xmath177 where the first and the second keys of the sorting are the values in @xmath179 and @xmath178 , respectively .",
    "so that we can insert , in sequential way , the symbols @xmath216 $ ] ( for @xmath217 ) , into each segment @xmath218 for @xmath219 .",
    "[ ex : ebwt ] we suppose that @xmath220 ( including the distinct end - markers ) .",
    "the algorithm starts , at the step @xmath119 , by computing the @xmath121 .",
    "the @xmath120-suffixes are @xmath221 , and the new symbols that we have to insert in @xmath222 ( the segment associated with the suffixes starting with the end - marker ) are @xmath135 and @xmath135 .",
    "we set @xmath223 $ ] , @xmath224 $ ] and @xmath225 $ ] .",
    "since , we use ( implicit ) distinct end - markers and @xmath226 , we set @xmath227 $ ] .",
    "so , @xmath228",
    ".    then , we consider @xmath229 $ ] .",
    "both symbols in @xmath230 should be inserted into @xmath231 because both the associated suffixes ( @xmath232 and @xmath233 ) start with the symbol @xmath135 .",
    "so , we set @xmath234 $ ] and @xmath235 $ ] . the position in @xmath231 of the symbol @xmath236 associated with",
    "the @xmath237-suffix of @xmath238 is equal to @xmath237 in the segment @xmath231 , indeed @xmath232 is the smallest suffix in @xmath239 starting with the letter @xmath135 .",
    "the position in @xmath231 of the symbol @xmath240 associated with the @xmath237-suffix of @xmath241 is equal to @xmath242 in the segment @xmath231 , because the symbol @xmath135 associated with @xmath243 follows the symbol @xmath135 associated with @xmath244 .",
    "so we set @xmath245 $ ] and obtain @xmath231 by inserting @xmath236 and @xmath240",
    ". then @xmath246 .    during the third step , the array @xmath247 $ ]",
    "is considered .",
    "since the last inserted symbol of @xmath238 is @xmath236 then the new symbol @xmath236 associated with @xmath248 must be inserted in the segment @xmath249 , whereas since the last inserted symbol of @xmath241 is @xmath240 then the new symbol @xmath135 associated with @xmath250 must be inserted in the segment @xmath251 .",
    "so we set @xmath252 $ ] , @xmath253 $ ] .",
    "since the number of occurrences of @xmath236 in @xmath254 and in @xmath255 $ ] is @xmath237 then we have to insert the symbol @xmath236 at the position @xmath237 in @xmath249 .",
    "since the number of occurrences of @xmath240 in @xmath254 and in @xmath256 $ ] is @xmath237 then we have to insert the symbol @xmath135 at the position @xmath237 in @xmath251 .",
    "since @xmath248 and @xmath250 are the smallest suffixes starting with @xmath236 and @xmath240 respectively , we set @xmath257 $ ] .    the first three iterations are depicted in figure [ fig : threeiterations ] .",
    "the process continues via left extensions of suffixes until all symbols have been inserted .",
    "the main goal of this section consists in the description of the strategy for computing , by using the , the  array of a massive collection of strings via sequential scans of the disk data .",
    "in particular , the main theorem of the section enables the simultaneous computation of both  and  of a string collection @xmath33 of maximum length @xmath4 .",
    "we recall that the last symbol of each string @xmath34 is the ( implicit ) end - marker @xmath35 .",
    "our method follows the  algorithm in the sense that it scans all the strings from right - to - left in @xmath4 steps and simulates , at the step @xmath42 , the insertion of suffixes of length @xmath42 into the sorted list of suffixes .",
    "this time , however , we wish to compute both the  and .",
    "so , at the step @xmath42 , the longest common prefix array ( denoted by @xmath259 ) of the collection @xmath43 of the suffixes having length at most @xmath42 is computed alongside @xmath111 . as well as computing an  value for the inserted suffix",
    ", we must also modify the  value for the suffix that comes after it to reflect the longest prefix common to it and the inserted suffix .",
    "our goal in this section is to frame these calculations in terms of @xmath260s on sets of intervals within @xmath259 , serving as a preliminary to the next section , where we show how these computations may be arranged to proceed via sequential scans of the data .",
    "it is easy to see that when @xmath261 , @xmath259 coincides with @xmath63 , the  array of @xmath39 .",
    "since all @xmath7 end - markers are considered distinct , the longest common prefix of any pair of @xmath120-suffixes is @xmath120 , so the first @xmath7 positions into @xmath259 are @xmath120 for any @xmath262 .    the general idea behind our method",
    "is described in the following and depicted in figure [ fig : idealcp ] . at each step",
    "@xmath263 , the value of a generic element @xmath264 $ ] ( with @xmath265 ) have to be computed by taking into account the @xmath42-suffix @xmath171 that is placed at the position @xmath140 of the sorted suffixes of @xmath43 .",
    "such a value depends on the @xmath266-suffix @xmath267 placed at the position @xmath268 in the sorted list and , moreover , could lead an updating of the value @xmath269 $ ] ( if it exists ) corresponding to the @xmath270-suffix @xmath271 , as shown in figure [ fig : idealcp ] . by using our method ,",
    "the computation of @xmath264 $ ] can be realized by using the values of the arrays @xmath272 and @xmath116 .",
    "in fact , if @xmath273 ( where @xmath274 is a symbol and @xmath275 is the @xmath126-suffix placed at a certain position @xmath117 in the sorted list of the suffixes of @xmath276 ) , then @xmath277 $ ] .",
    "let us denote @xmath278 and @xmath279 , where @xmath280 and @xmath281 are symbols and @xmath282 and @xmath283 are , respectively , the @xmath284-suffix and the @xmath285-suffix of @xmath276 placed at the positions @xmath286 and @xmath287 .",
    "one can see that @xmath264 $ ] is equal to @xmath120 if @xmath288 , otherwise it is equal to @xmath237 plus the longest common prefix between @xmath282 and @xmath275 computed in the array @xmath272 .",
    "moreover @xmath269 $ ] is equal to @xmath120 if @xmath289 , otherwise it is equal to @xmath237 plus the longest common prefix between @xmath275 and @xmath283 computed in the array @xmath272 . in this section",
    "we show how such a computation can be sequentially performed .",
    "@xmath290    note that @xmath259 can be considered the concatenation of @xmath150 arrays @xmath291 where , for @xmath158 , the array @xmath292 contains the values corresponding to the lengths of the longest common prefix of the suffixes of @xmath43 that start with @xmath155 , while @xmath293 ( corresponding to the @xmath120-suffixes ) is an array of @xmath7 zeroes .",
    "it is easy to see that @xmath294 and that @xmath295 is empty for @xmath296 .",
    "we note that , for each @xmath297 , @xmath298=0 $ ] and @xmath299\\geq 1 $ ] for @xmath300 , because the suffixes associated with such values share at the least the symbol @xmath155 .",
    "as shown in section [ bcrstrategy ] , @xmath111 can be partitioned in an analogous way into segments @xmath151 . given the segments @xmath153 and @xmath292 , @xmath219 , for the symbol @xmath139 occurring at position @xmath140 of @xmath153 we define the @xmath301__-lcp current interval _ _ of @xmath139 in @xmath140 ( denoted by @xmath302 ) as the range @xmath303 $ ] in @xmath304 ( so we set @xmath305 $ ] ) , where @xmath286 is the greatest position smaller than @xmath140 of the symbol @xmath139 in @xmath218 , if such a position exists .",
    "if such a position does not exist , we define @xmath306 $ ] .",
    "analogously , we define for the symbol @xmath139 the @xmath301__-lcp successive interval _ _ of @xmath139 in @xmath140 ( denoted by @xmath307 ) as the range @xmath308 $ ] in @xmath304 ( so we set @xmath309 $ ] ) , where @xmath287 is the smallest position greater than @xmath140 of the symbol @xmath139 in @xmath218 , if it exists .",
    "if such a position does not exist we define @xmath310 $ ] .    in order to compute the values @xmath286 and @xmath287 we use the function @xmath311 that together with @xmath136 function",
    "play a fundamental role in fm - index .",
    "in particular , @xmath312 takes in input a symbol @xmath274 , an integer @xmath140 and a string @xmath81 and finds the position of the @xmath140-th occurrence of @xmath274 in @xmath81 .    in our context ,",
    "if @xmath286 and @xmath287 exist , then @xmath313 \\neq x$ ] for @xmath314 and for @xmath315 , so it is easy to verify that @xmath316 and @xmath317 .",
    "we observe that the computation of the minimum value into @xmath302 and @xmath307 is equivalent to the computation of @xmath318 and @xmath319 , respectively .",
    "we can not directly compute these values , because we build each @xmath153 and @xmath292 in sequential way , so we do not know the left extreme of @xmath302 and the right extreme of @xmath307 of all symbols that we have to insert in each @xmath153 , @xmath158 .    the following theorem , related to ( * ? ? ?",
    "* lemma 4.1 ) , shows how to compute the segments @xmath292 , with @xmath320 , by using @xmath321 and @xmath322 for any @xmath323 .",
    "[ th : lcp_case_allsuffix ] let @xmath324 be the set of the positions where the symbols associated with the @xmath42-suffixes starting with the letter @xmath160 must be inserted into @xmath325 . for each position @xmath326 ( @xmath327 ) , @xmath328=\\left\\{\\begin{array}{ll }                       0 & \\mbox { if $ r_b=1 $ } \\\\                       1 & \\mbox { if $ r_b>1 $ and $ lci_{j-1}^v(c_z , t)=l_{j-1}(v)[t]$ } \\\\                       \\min lci_{j-1}^v(c_z , t ) + 1 & \\mbox{otherwise }                     \\end{array}\\right.\\ ] ] where @xmath164 is the first character of the @xmath126-suffix of @xmath34 , and @xmath117 is the position in @xmath163 of symbol @xmath160 preceding the @xmath126-suffix of @xmath34 . + for each position @xmath329 ( where @xmath326 and @xmath327 ) , then @xmath330=\\left\\{\\begin{array}{ll }                       1 & \\mbox { if $ lsi_{j-1}^v(c_z , t)=l_{j-1}(v)[t]$ } \\\\                       \\min lsi_{j-1}^v(c_z , t ) + 1 & \\mbox{otherwise }                     \\end{array}\\right.\\ ] ]    for each position @xmath162 , where @xmath331 ( for @xmath332 ) , @xmath333 ( for @xmath334 ) , @xmath335 ( for @xmath336 ) then @xmath337=l_j(z)[s - b]\\ ] ]    we consider a generic position @xmath338 corresponding to the position where the new symbol @xmath50 $ ] ( or @xmath52=\\$_i$ ] ) must be inserted into @xmath161 and the corresponding value must be inserted into @xmath339 . the new symbol @xmath50 $ ] precedes the @xmath42-suffix @xmath41 $ ] .",
    "such a suffix is obtained by concatenating the symbol @xmath166 $ ] with its @xmath126-suffix .",
    "let us suppose that the symbol @xmath160 associated with @xmath126-suffix starting with the symbol @xmath164 is in position @xmath117 in @xmath163 .",
    "hence , @xmath117 is also the position of the @xmath126-suffix in the lexicographic order among the suffixes of @xmath39 of length at most @xmath126 starting with @xmath164 .    in order to find @xmath340 $ ]",
    ", we have to distinguish two cases .    in the first case",
    ", the @xmath42-suffix is the smallest suffix ( in the lexicographic order ) of length at most @xmath42 starting with the symbol @xmath160 , i.e. @xmath341 .",
    "this means that @xmath160 does not exist in any segment @xmath322 , @xmath342 and there does not exist in @xmath343 $ ] . in this case",
    "@xmath344 $ ] and @xmath345=0 $ ] .    in the second case",
    ", there exists some suffix starting with @xmath160 of length at most @xmath42 that is lexicographically smaller than the @xmath42-suffix , i.e. @xmath346 . recall that @xmath340 $ ] represents the length of the longest common prefix between the @xmath42-suffix and a @xmath266-suffix of a string @xmath347 ( for some @xmath348 ) , with @xmath349 , starting with the symbol @xmath160 , that immediately precedes the @xmath42-suffix in the lexicographic order .",
    "if the longest common prefix between the @xmath266-suffix of @xmath350 and the @xmath42-suffix of @xmath34 is @xmath160 then @xmath344 $ ] and @xmath346 , so @xmath340=1 $ ] .",
    "this means that the symbol @xmath160 associated to the @xmath284-suffix of @xmath347 is not contained in the segment @xmath163 , but it is contained in some @xmath322 , @xmath342 .",
    "if the longest common prefix between the @xmath266-suffix of @xmath350 and the @xmath42-suffix of @xmath34 is longer than @xmath160 then both the @xmath284-suffix of @xmath347 and the @xmath126-suffix of @xmath34 start with the same symbol @xmath164 .",
    "so , we can suppose that the symbol associated with the @xmath284-suffix of @xmath350 is at the position @xmath286 in the segment @xmath163 .",
    "remark that symbols in position @xmath286 and @xmath117 are equal to @xmath160 . then @xmath351 $ ] and @xmath340 = \\min ( lci_{j-1}^v(c_z , t ) ) + 1 $ ] .",
    "recall that @xmath352 $ ] represents the length of the longest common prefix between the @xmath42-suffix and a @xmath270-suffix of a string @xmath353 ( for some @xmath354 ) , with @xmath355 , starting with the symbol @xmath160 , that immediately follows the @xmath42-suffix in the lexicographic order .",
    "if the longest common prefix between the @xmath42-suffix of @xmath34 and @xmath270-suffix of @xmath356 is @xmath160 then @xmath357 $ ] , so @xmath352=1 $ ] .",
    "this means that the symbol @xmath160 associated to the @xmath285-suffix of @xmath353 is not contained in the segment @xmath163 ( but it is contained in some @xmath322 , @xmath358 ) .",
    "if the longest common prefix between the @xmath42-suffix of @xmath34 and the @xmath270-suffix of @xmath356 is longer than @xmath160 then both the @xmath126-suffix of @xmath34 and the @xmath285-suffix of @xmath353 start with the same symbol @xmath164 .",
    "so , we can suppose that the symbol associated with the @xmath285-suffix of @xmath356 is at the position @xmath287 in the segment @xmath163 .",
    "remark that symbols in position @xmath140 and @xmath287 are equal to @xmath160 . then @xmath359 $ ] and @xmath352 = \\min(lsi_{j-1}^v(c_z , t ) ) + 1 $ ] .",
    "note that the position @xmath360 in @xmath339 does not exist when the the @xmath42-suffix is the greatest suffix ( in the lexicographic order ) of length at most @xmath42 starting with the symbol @xmath160 .",
    "the suffix that , eventually , immediately follows the @xmath42-suffix in lexicographic order is involved in a segment @xmath218 , for some @xmath361 , hence such suffix starts with a symbol greater than @xmath160 .",
    "a consequence of the theorem is that the segments @xmath362 and @xmath363 can be constructed sequentially and stored in external files .",
    "this fact will be used in the next section .",
    "based on the strategy described in the previous section , here we propose an algorithm ( named ) that simultaneously computes the  and the  of a collection of strings @xmath39 .",
    "memory use is minimized by reading data sequentially from files held in external memory : only a small proportion of the symbols of @xmath39 need to be held in internal memory .",
    "we could also add the computation of the generalized suffix array of @xmath39 without adding further data structures .",
    "as in the previous sections , we assume that the collection @xmath39 comprises @xmath7 strings of length at most @xmath4 , that @xmath364 , @xmath365 , @xmath366 , that @xmath367 and @xmath368 . when @xmath261 , @xmath369 and @xmath370 .",
    "we also assume that @xmath371 .",
    "note that , at each iteration @xmath42 , both the segments @xmath362 and @xmath363 , initially empty , are stored in different external files that replace the files used in the previous iteration .",
    "consequently , both @xmath111 and @xmath259 are updated accordingly .",
    "the main part of the algorithm  consists of @xmath4 consecutive iterations . at iteration @xmath42",
    ", we consider all the @xmath42-suffixes of @xmath39 and simulate their insertion in the sorted suffixes list .",
    "for each symbol associated with the @xmath42-suffix that we have to insert at the position @xmath140 into @xmath153 , we also have to insert the new values related to the longest common prefix at position @xmath140 and @xmath360 into @xmath292 , where @xmath372 is the first symbol of the considered @xmath42-suffix .    in order to compute @xmath111 and @xmath259 ,",
    "the algorithm   needs to hold six arrays of @xmath7 integers in internal memory .",
    "four of these ( @xmath174 , @xmath175 , @xmath3 and @xmath173 ) are as employed by the algorithm  ( see section [ bcrstrategy ] ) and further two arrays ( @xmath135 and @xmath373 ) are needed to compute and update the values of the longest common prefixes at each iteration . as for @xmath174 , @xmath175 , @xmath3 and @xmath173 arrays ( see section [ bcrstrategy ] ) , for ease of presentation we denote by @xmath374 and @xmath375 the arrays at the @xmath42-th iteration .",
    "they contain exactly one integer for each string , i.e. they use @xmath376 bits of workspace .",
    "they are sequentially computed by using other auxiliary data structures described in subsection [ subsec : bcrlcp_ds ] .    more formally , if @xmath377 $ ] then @xmath378 $ ] stores the length of the longest common prefix between the @xmath42-suffix of @xmath34 and the previous suffix ( if it exists ) in the list of sorted suffixes with respect to the lexicographic order of all the suffixes of @xmath39 of length at most @xmath42 , whereas @xmath379 $ ] contains the length of the longest common prefix between the @xmath42-suffix of @xmath34 and the successive suffix @xmath171 in the list of sorted suffixes ( if it exists ) . such values will be computed at the iteration @xmath380 according to theorem [ th : lcp_case_allsuffix ] .",
    "note that @xmath381 $ ] is used when the suffix @xmath171 exists and @xmath195 + 1 \\neq p_{j}[q+1]$ ] .",
    "example [ exlcp ] provides an idea of the running of the algorithm  and shows how the involved arrays are used .",
    "[ exlcp ] figure [ fig : compute ] illustrates an execution of our method on the collection @xmath220 at two consecutive iterations .",
    "note that we have appended different end - marker to each string ( @xmath244 and @xmath243 , respectively ) .",
    "in particular , we suppose that at the iteration @xmath382 , we have computed the arrays @xmath383 , @xmath384 and @xmath385 .",
    "we recall that we have computed @xmath386 and @xmath387 in the previous iteration . at the end of the first phase of the iteration @xmath388 we have @xmath389 $ ] ,",
    "@xmath390 $ ] , @xmath391 $ ] , @xmath392 $ ] , @xmath393 $ ] , @xmath394 $ ] .",
    "note that they are sorted by using the first and the second keys the values in @xmath384 and @xmath383 respectively . in this way the new @xmath395-segments ( on the left in the figure )",
    "have been constructed by adding the bold characters .",
    "we can compute @xmath396 and @xmath397 and @xmath398 and @xmath399 useful to terminate the iteration @xmath388 .",
    "we obtain that @xmath396 corresponds to the range @xmath400 $ ] in @xmath401 .",
    "so the minimum value is @xmath242 and the value in @xmath402 associated with the @xmath403-suffix @xmath171 ( i.e. @xmath404 ) of @xmath241 is @xmath405 ( this value is stored into @xmath406 ) .",
    "now we have to compute the value of the longest common prefix between the suffix @xmath171 and the suffix that immediately follows @xmath171 in the lexicographic order and to store this value into @xmath407 .",
    "since the symbol @xmath408 does not appear in the range @xmath409 $ ] , it means that there are not suffixes starting with @xmath410 lexicographically greater than @xmath171 , so such value will be less than @xmath242 . because the symbol @xmath408 does appear at least once in @xmath395 with @xmath411 ( in this case @xmath412=g$ ] ) ,",
    "it means that there exists at least a suffix starting with @xmath408 lexicographically greater than @xmath171 ( in this case the suffix @xmath413 ) .",
    "so the value in @xmath414 of the suffix that follows @xmath171 must be updated to @xmath237 ( i.e. we store this value in @xmath407 ) .",
    "similarly , since @xmath415 $ ] , the minimum value is @xmath237 and so the value in @xmath402 for the @xmath403-suffix @xmath416 ( i.e. @xmath417 ) of @xmath238 is @xmath242 ( i.e. we insert this value in @xmath406 ) .",
    "moreover , @xmath418 $ ] , the minimum value is @xmath242 and hence the value in @xmath402 of the suffix that follows @xmath416 must be updated to @xmath405 ( i.e. we insert this value in @xmath407 ) .    at the iteration @xmath419 , we compute the arrays @xmath420 , @xmath421 and @xmath422 , whereas the arrays @xmath406 and @xmath407 have been computed in the previous iteration .",
    "so we have @xmath423 $ ] , @xmath424 $ ] , @xmath425 $ ] , @xmath426 $ ] , @xmath427 $ ] , @xmath428 $ ] .",
    "while the new @xmath429-segments ( on the right in the figure ) are being constructed , we can sequentially insert and update the new values in @xmath430 and @xmath414 and compute the new values @xmath431 and @xmath432 .",
    "@xmath433      in this subsection we show how , at the generic iteration @xmath42 of the algorithm , @xmath259 is sequentially computed and updated by using the data structures previously described . at the first iteration ,",
    "@xmath434=0 $ ] and @xmath435=0 $ ] for each @xmath371 , because the @xmath7 end - markers are considered distinct .",
    "moreover , the algorithm initializes the segments @xmath436 and @xmath437 in the following way : @xmath438w_1[|w_1|-1]\\cdots w_{m-1}[|w_{m-1}|-1]$ ] and @xmath439=0 $ ] , for each @xmath62 . consequently , the arrays are initialized by setting @xmath440=q-1 $ ] , @xmath441=q$ ] , @xmath442=0 $ ] , @xmath443=1 $ ] and @xmath444=1 $ ] , for each @xmath62 .",
    "each iteration @xmath263 can be divided into two consecutive phases .    during the first phase we only read the segments @xmath445 in order to compute the arrays @xmath178 , @xmath179 @xmath177 and @xmath176 . then we sort @xmath200 , @xmath194 , @xmath177 , @xmath446 , @xmath375 , where the first and the second keys of the sorting are the values in @xmath179 and @xmath178 respectively .",
    "we omit the description of the first phase , because it can be found in section [ bcrstrategy ] , so we focus on the second phase .    in the second phase , the segments @xmath445 and @xmath447 are read once sequentially both for the construction of new segments @xmath362 and @xmath363 and for the computation of the arrays @xmath448 and @xmath449 , as they will be used in the next iteration . moreover , the computation of the segments @xmath450 is performed by using the arrays @xmath446 and @xmath451 constructed during the previous step .",
    "since the identical elements in @xmath179 are consecutive , we open the pair files @xmath322 and @xmath321 ( for @xmath219 ) at most once .",
    "each of these files can be sequentially read , because the positions in @xmath178 are sorted in according with @xmath179 .    in the sequel ,",
    "we focus on a single segment @xmath325 , for @xmath452 , by assuming that @xmath453=z$ ] for each @xmath454 , with @xmath455 and @xmath456 , i.e. we are considering the elements in @xmath325 and @xmath457 associated with the suffixes starting with @xmath160 .",
    "since @xmath458 <   \\ldots < p_{j}[l']$ ] , we can sequentially build @xmath325 and @xmath457 by copying the old values from @xmath459 and @xmath460 respectively , by inserting each new symbol @xmath461 $ ] into @xmath462 $ ] and @xmath463 $ ] into @xmath464 $ ] and by updating the value @xmath465 + 1]$ ] with the value @xmath466 $ ] , if the position @xmath467",
    "+ 1\\neq p_{j}[p+1]$ ] exists .",
    "the crucial point consists in computing , at the same time , each value @xmath468 $ ] and @xmath469 $ ] ( required for the next iteration ) related to the @xmath470-suffix of all string @xmath34 , with @xmath471 $ ] and @xmath192 , without knowing the left extreme @xmath286 of @xmath302 and the right extreme @xmath287 of @xmath307 , where @xmath472 $ ] and @xmath473 $ ] for each @xmath146 . in the sequel , we say that the left extreme is the _ opening position _ and the right extreme is the _ closing position _ of some symbol @xmath139 .    a pseudo - code that realizes the second phase of a generic iteration @xmath263 of the algorithm  can be found in figure [ algo : cs_computation ] and it uses the following additional arrays of @xmath11 elements , defined as follows :    * isminlciop and isminlsiop are arrays of flags , where isminlciop@xmath474 $ ] and isminlsiop@xmath474 $ ] indicate the opening of the @xmath475 and @xmath476 associated with @xmath164 , respectively . *",
    "minlci and minlsi are arrays of integers , where minlci@xmath474 $ ] and minlsi@xmath474 $ ] store the minimum value among the values in @xmath457 from the opening position of the intervals associated with @xmath164 and the current position @xmath162 .",
    "* minlsinseq is an array of integers , where minlsinseq@xmath474 $ ] contains the index @xmath270 of the position in which minlsi@xmath474 $ ] will be stored in @xmath449 .",
    "this is useful , because when we close the @xmath476 associated with the symbol @xmath164 at some position @xmath162 , we have to store minlsi@xmath474 $ ] in some position @xmath270 of @xmath449 , such that @xmath477<s$ ] .",
    "the routines insertnewsymbol , updatelci and updatelsi are described in figure [ algo : insertnewsymbol ] and figure [ algo : updatemin ] .",
    "insertnewsymbol(@xmath139 ) routine inserts at position @xmath478 $ ] in @xmath325 each new symbol @xmath479 $ ] . by theorem [ th : lcp_case_allsuffix ] , it follows that @xmath464=0 $ ] if @xmath467=1 $ ] or @xmath464=c_j[p]$ ] otherwise .",
    "moreover , the position @xmath480 $ ] is surely :    * the closing position of @xmath481)$ ] .",
    "if isminlciop@xmath474=0 $ ] , then @xmath482 $ ] is the position of the first occurrence of @xmath164 in @xmath161 , hence @xmath481)=l_j(z)[p_j[p]]$ ] and we set @xmath468=1 $ ] according to theorem [ th : lcp_case_allsuffix ] .",
    "otherwise , isminlciop@xmath474 $ ] has been set to @xmath237 in some position @xmath483 $ ] , so @xmath484)=l_j(z)(d_1,p_j[p]]$ ] and we set @xmath468 = \\min(lci_{j}^z(c_v , p_j[p]))+1 $ ] .",
    "such minimum value is stored into minlci@xmath474 $ ] .",
    "moreover , we set isminlciop@xmath474 = 0 $ ] .",
    "* the opening position of @xmath485)$ ] .",
    "so , we set isminlsiop@xmath474=1 $ ] , the value minlsi@xmath474 $ ] is updated and minlsinseq@xmath474 = p$ ] .",
    "we observe that if the position @xmath482 $ ] is the last occurrence of @xmath164 in @xmath161 ( this fact is discovered when the end of the file is reached ) , it means that @xmath485 ) = l_j(z)[p_j[p]]$ ] , i.e. we set @xmath469=1 $ ] .    note that in order to compute the values @xmath468 $ ] and @xmath469 $ ] for each @xmath146 , we do not need to know the exact opening position @xmath286 of @xmath486,p_{j}[p])$ ] and the exact closing position @xmath287 of @xmath487,p_{j}[p])$ ] , but we only need to compute the minimum values in these ranges .    when at any position @xmath162 in @xmath325 we insert the symbol @xmath164 ( from @xmath176 or from @xmath459 ) , then the position @xmath162 is assumed to be :    * the opening position of @xmath488 , if another occurrence of @xmath164 will be inserted , as new symbol , at some next position @xmath489 $ ] , for some @xmath266 such that @xmath490>s$ ] .",
    "so , we set isminlciop@xmath474 = 1 $ ] and the value minlci@xmath474 $ ] is updated ( see updatelci(@xmath139 ) routine in figure [ algo : updatemin ] ) .",
    "* the closing position of @xmath491)$ ] , if another occurrence of @xmath164 has been inserted , as new symbol , at some previous position @xmath492 $ ] , for some @xmath270 such that @xmath492 < s$ ] . in this case ,",
    "@xmath491)=l_j(z)(p_j[g ] , s]$ ] ( because minlsinseq@xmath474=g$ ] ) and we set @xmath493 = \\min ( lsi_{j}^z(c_v , p_j[g]))+1 $ ] according to theorem  [ th : lcp_case_allsuffix ] .",
    "such a minimum value is stored into minlsi@xmath474 $ ] .",
    "we set isminlsiop@xmath474 = 0 $ ] ( see updatelsi(@xmath139 ) routine in figure [ algo : updatemin ] ) .    when @xmath325 is entirely built , the closing position of some @xmath491)$ ] for some @xmath494 could remain not found .",
    "so , we could have some value in isminlsiop equal to @xmath237 . for each @xmath164",
    "such that isminlsiop@xmath474=1 $ ] , the last occurrence of @xmath164 appears at position @xmath492 $ ] ( we recall that we have set minlsinseq@xmath474 $ ] to @xmath270 ) . in this case ,",
    "@xmath491)=l_j(z)[p_j[g]]$ ] and we set @xmath493 = 1 $ ] according to theorem  [ th : lcp_case_allsuffix ] ( see the for loop in figure [ algo : cs_computation ] )",
    ".    one can verify that these steps work in a sequential way .",
    "moreover , one can deduce that , while the same segment is considered , for each symbol @xmath495 at most one @xmath496)$ ] for some @xmath497 and at most one @xmath498)$ ] for some @xmath494 will have not their closing position .",
    "the complexity of  algorithm depends mainly on @xmath4 , i.e. the length of the longest string in the collection , because the algorithm works in @xmath4 passes and for each step it needs to build @xmath325 and @xmath457 from @xmath459 and @xmath460 for each @xmath499 . at each step",
    "@xmath42 , the used internal memory depends on the number of strings in @xmath39 of length greater than @xmath42 .",
    "such a value is upper bounded by @xmath7 for each step .",
    "note that , at each step , the total size of @xmath500 files containing the partial @xmath100 is increased by at most @xmath7 symbols .",
    "analogously the total size of @xmath500 files containing the partial @xmath63 is increased by at most @xmath7 values .",
    "so , the used disk space mainly depends on @xmath7 for each step .    since our algorithm accesses disk data only by sequential scans , we analyze it counting the number of disk passes as in the standard external memory model ( see @xcite ) .",
    "we denote by @xmath14 the disk block size and we assume that both the ram size and @xmath14 are measured in units of @xmath501-bit words .    from the size of the data structures and from the description of the phases of the  algorithm given in previous sections , we can state the following theorem .    given a collection @xmath39 of @xmath7 strings over an alphabet of size @xmath11 where @xmath4 is the maximal length ( including the end - markers ) and @xmath3 is the sum of their length , _ _ algorithm simultaneously compute the  and the  array of @xmath39 by using @xmath13 disk i / o operations and @xmath8 bits of ram in @xmath502 cpu time , where @xmath10 is the time taken to sort @xmath7 integers in internal memory .",
    "moreover , _ _ needs at most @xmath12 bits of disk space .    at each iteration @xmath42 ,",
    "the main data structures used by  are @xmath176 of size @xmath503 bits , @xmath179 of size at most @xmath503 bits , @xmath177 of size at most @xmath504 bits , @xmath178 of size at most @xmath505 bits , @xmath374 and @xmath375 of size at most @xmath506 bits .",
    "moreover , we need @xmath507 bits for computing the number of occurrences of each symbol in each segment @xmath153 , for @xmath158 . the additional arrays take @xmath508 ( assuming that @xmath108 ) .",
    "so , the workspace is @xmath8 bits .",
    "as we sort @xmath200 , @xmath194 , @xmath177 , @xmath446 , @xmath375 where the first and the second keys of the sorting are the values in @xmath179 and @xmath178 , we need @xmath509 cpu time , where @xmath10 is the time taken to sort @xmath7 integers in internal memory .",
    "the total cpu time is @xmath502 .",
    "we observe that the input is split into @xmath4 files , so that each file contains @xmath7 symbols , one for each string . at each step , such symbols will read and store into @xmath176 array .",
    "the amount of i / o operations for handling the input file is @xmath510 . during the first phase of each iteration @xmath263",
    ", we need to read at most @xmath511 bits for computing @xmath179 , @xmath178 , @xmath177 arrays . in the second phase",
    "we need to read at most @xmath511 bits from @xmath445 and @xmath447 segments in order to obtain @xmath448 , @xmath449 arrays and @xmath362 and @xmath363 segments by writing @xmath512 bits of disk space .",
    "the disk i / o operations for obtaining the output of each iteration is @xmath513 .",
    "the total number of i / o operations is @xmath514 .",
    "the internal memory of  can be reduced significantly by observing that rather than storing @xmath174 , @xmath175 , @xmath3 and @xmath135 to internal memory , they could reside on disk because these arrays are sequentially processed . in this way , the algorithm needs to store in internal memory the array @xmath373 , isminlciop , isminlsiop , minlci , minlsi and minlsinseq that require random accesses .",
    "clearly in this case one should use an external memory sorting algorithm .",
    "[ rm : gsa ] it is easy to verify that the algorithm  can be also adapted for computing the generalized suffix array of @xmath39 together the .",
    "such further computation increases the number of i / o operations , but one do not need of further data structures in internal memory .",
    "note that , for each @xmath93 , @xmath61=(t , j)$ ] is the pair corresponding to the @xmath62-th smallest suffix of the strings in @xmath39 , i.e. to the suffix @xmath58 $ ] . since we know at each iteration of  the values @xmath117 and @xmath42 , because they are store into @xmath178 and @xmath177 arrays respectively , it is enough to modify the  code by adding the instructions for storing such values in external memory .",
    "our algorithm  represents the first lightweight method that simultaneously computes , via sequential scans , the  array and the  of a vast collection of strings .",
    "we developed an implementation of the algorithm described in section  [ sec : implementation ] , which is available upon request from the authors .",
    "our primary goal has been to analyze the additional overhead in runtime and memory consumption of simultaneously computing both  and  via  compared with the cost of using  ( cf .",
    "@xcite ) to compute only the . for this goal",
    ", we used a publicly available collection of human genome strings from the sequence read archive @xcite at ftp://ftp.sra.ebi.ac.uk/vol1/era015/era015743/srf/ and created subsets containing @xmath16 , @xmath515 and @xmath15 million reads , each read being 100 bases in length on the alphabet @xmath516 .",
    ".the input string collections were generated on an illumina gaiix sequencer , all strings are @xmath16 bases long .",
    "size is the input size in gib , wall clock time  the amount of time that elapsed from the start to the completion of the instance  is given as microseconds per input base , and memory denotes the maximal amount of memory ( in gib ) used during execution .",
    "the efficiency column states the cpu efficiency values , i.e. the proportion of time for which the cpu was occupied and not waiting for i / o operations to finish , as taken from the output of the `",
    "/usr / bin / time ` command . [ cols=\"<,>,<,<,<,<,<\",options=\"header \" , ]     actually , we were not able to compare the performance of  and  on very large datasets",
    ". indeed , current implementation of  shows an overhead in disk space usage that prevented us to make tests on very large string collections .",
    "for instance , for a collection of @xmath517 millions of strings of length @xmath16  needs @xmath518 bytes per symbol , whereas  uses @xmath519 byte per symbol .",
    "so , the datasets in table [ tab : inputinstances ] are too demanding to be managed .",
    "however , experiments have been conducted using smaller real collections ( see table [ tab : datasets ] ) : the dataset @xmath520 ( long jump library of human chromosome 14 ) , the datasets @xmath521 and @xmath522 ( human genome sequences from sequence read archive ) are collections of dna strings on the alphabet @xmath516 . moreover , in order to evaluate  and  when the dataset contains strings over alphabets with more than five symbols , we have created a new collection of proteins ( called @xmath523 ) , obtained from uniprotkb / trembl dataset , by truncating the strings longer than @xmath16 aminoacids , so that it has the same maximum string length as the datasets @xmath520 , @xmath521 , @xmath522 .    for each dataset ,",
    "is compared with  using two different values of : an higher value is comparable with the size of memory required from the data structures used by ; a lower value have been chosen to produce a number of subsets less than @xmath524 .",
    "we have not set other parameters of  code .",
    "the results of our tests are described in table [ tab : compare_egsa ] .",
    "the first three experiments , in which we consider strings over the same alphabet , show that the bigger the string collection is , the better is the overall performance of  with respect to .",
    "in fact , the wall clock time values of  and  become comparable , but the total disk usage for  significantly increases .",
    "however , the fourth experiment in table [ tab : compare_egsa ] shows that the alphabet size is a parameter that seems to have a significant impact on the wall clock time value for   rather than for .",
    "finally , we observe that , as pointed in remark [ rm : gsa ] ,  could produce as additional output the generalized suffix array .",
    "although our algorithm is not optimized for this purpose , our tests have shown that the wall clock time is about twice because the i / o operations are doubled .",
    "however , the computation of the gsa does not produce an increase in the internal memory .",
    "in this paper , we proposed  which is a lightweight algorithm to construct , at the same time , the  array and the  of a collection of strings .    actually , the   and  are two of the three data structures needed to build a compressed suffix tree ( cst ) @xcite of a string .",
    "the strategy proposed in this paper could enable the lightweight construction of csts of string collections for comparing , indexing and assembling vast datasets of strings when memory is the main bottleneck .",
    "the algorithm  is a tool parameter - free designed for very large collection , indeed table [ tab : inputinstances ] shows that it also works with collections of @xmath525gib and tables [ tab : varlenres ] and [ tab : compare_egsa ] show that it can be also used on large collections with varying string lengths .",
    "the experimental results show that our algorithm is a competitive tool for the lightweight simultaneous computation of  and  on string collections .",
    "our current prototype can be further optimized in terms of memory by performing the sorting step in external memory .",
    "further saving of the working space could be obtained if we embody our strategy in or ( see @xcite ) .",
    "these methods , although slower than , need to store only a constant and ( for the dna alphabet ) negligibly small number of integers in ram regardless of the size of the input data .",
    "g. rosone and m. sciortino are partially supported by the project miur - sir cmacbioseq ( `` combinatorial methods for analysis and compression of biological sequences '' ) grant n.  rbsi146r5l and by `` gruppo nazionale per il calcolo scientifico ( gncs - indam ) '' .",
    "j. cox is an employee of illumina cambridge ltd .",
    "+ the authors are very grateful to the anonymous referees for their helpful remarks and constructive comments .",
    "louza , _ um algoritmo para a construo de vetores de sufixo generalizados em memria externa _ , master s dissertation in cincias de computao e matemtica computacional , so carlos .",
    "instituto de cincias matemticas e de computao , university of so paulo , 2013 .",
    "louza , g.p .",
    "telles , and c.d.a ciferri , _ external memory generalized suffix and lcp arrays construction _ , cpm ( johannes fischer and peter sanders , eds . ) , lcns , vol .",
    "7922 , springer berlin heidelberg , 2013 , pp ."
  ],
  "abstract_text": [
    "<S> the longest common prefix array is a very advantageous data structure that , combined with the suffix array and the burrows - wheeler transform , allows to efficiently compute some combinatorial properties of a string useful in several applications , especially in biological contexts . </S>",
    "<S> nowadays , the input data for many problems are big collections of strings , for instance the data coming from `` next - generation '' dna sequencing ( ngs ) technologies . in this paper </S>",
    "<S> we present the first lightweight algorithm ( called ` extlcp ` ) for the simultaneous computation of the longest common prefix array and the burrows - wheeler transform of a very large collection of strings having any length . </S>",
    "<S> the computation is realized by performing disk data accesses only via sequential scans , and the total disk space usage never needs more than twice the output size , excluding the disk space required for the input . moreover , ` extlcp ` allows to compute also the suffix array of the strings of the collection , without any other further data structure is needed . </S>",
    "<S> finally , we test our algorithm on real data and compare our results with another tool capable to work in external memory on large collections of strings .        </S>",
    "<S> ( # 1)`bwt`(#1 ) ( # 1)`c - ebwt`(#1 ) ( # 1)`bwt`(#1 )    # 1_#1 ( ) # 1_#1 ( ) # 1_#1 ( ) # 1_#1(w ) # 1_#1(w ) # 1(#1 ) </S>"
  ]
}