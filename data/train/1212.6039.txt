{
  "article_text": [
    "given a simple polygon @xmath8 of @xmath5 vertices in the plane , two points in @xmath8 are _ visible _ to each other if the line segment joining them lies in @xmath8 .",
    "for a line segment @xmath2 in @xmath8 , a point @xmath9 is _ weakly visible _ ( or _ visible _ for short ) to @xmath2 if @xmath2 has at least one point that is visible to @xmath9 .",
    "the _ weak visibility polygon _ ( or _ visibility polygon _ for short ) of @xmath2 , denoted by @xmath10 , is the set of all points in @xmath8 that are visible to @xmath2 .",
    "the _ weak visibility query problem _ is to build a data structure for @xmath8 such that @xmath10 can be computed efficiently for any query line segment @xmath2 in @xmath8 .",
    "this problem has been studied before .",
    "@xcite built a data structure of @xmath6 size in @xmath11 time that can compute @xmath10 in @xmath3 time for any query , where @xmath4 is the size of @xmath10 . throughout this paper",
    ", we always let @xmath4 denote the size of @xmath10 for any query line segment @xmath2 .",
    "bygi and ghodsi @xcite gave an improved data structure with the same size and preprocessing time as that in @xcite but its query time is @xmath7 .",
    "@xcite proposed a smaller data structure of @xmath12 size with @xmath13 preprocessing time and @xmath14 query time .",
    "table [ tab:10 ] gives a summary .",
    "if the problem is to compute @xmath10 for a single segment ( not queries ) , then there is an @xmath1 time algorithm @xcite .",
    "0.70llll data structure   & preprocessing time   & size & query time + @xcite & @xmath11 & @xmath6 & @xmath3 + @xcite & @xmath11 & @xmath6 & @xmath7 + @xcite & @xmath13 & @xmath12   & @xmath14 + our result 1 & @xmath1 & @xmath1 & @xmath3 + our result 2 & @xmath6 & @xmath6 & @xmath7 +      in this paper , we present two new data structures whose performances are also given in table [ tab:10 ] .",
    "our first data structure , which is built in @xmath1 time and @xmath1 space , can compute @xmath10 in @xmath3 time for any query segment @xmath2 . comparing with the data structure in @xcite ,",
    "our data structure reduces the query time by a logarithmic factor and uses much less preprocessing time and space . the preprocessing time and size of our second data structure are both @xmath6 , and each query takes @xmath7 time .",
    "comparing with the result in @xcite , our data structure has less preprocessing time .",
    "in addition , our solution , which is based on the approach in @xcite , is much simpler than that in @xcite .",
    "further , our techniques explore many geometric observations on the problem that may be useful elsewhere .",
    "for example , we prove a tight combinatorial bound for the  zone \" in a line segment arrangement contained in a simple polygon , as follows , which is interesting in its own right",
    ".    let @xmath15 be a set of line segments in a simple polygon @xmath8 such that both endpoints of each segment of @xmath15 are on @xmath16 ( i.e. , the boundary of @xmath8 ) .",
    "let @xmath17 be the arrangement formed by the segments in @xmath15 and the edges of @xmath16 .",
    "for any line segment @xmath2 in @xmath8 ( the endpoints of @xmath2 need not be on @xmath16 ) , the _ zone _ of @xmath2 , denoted by @xmath18 , is defined to be the set of all faces of @xmath17 that @xmath2 intersects . for each edge of any face in @xmath17 , it either lies on a segment of @xmath15 or lies on @xmath16",
    ". let @xmath19 be the number of edges of the faces in @xmath18 each of which lies on a segment of @xmath15 .",
    "we want to find a good upper bound for @xmath19 . by using the zone theorem for the general line segment arrangement @xcite",
    ", we can easily obtain @xmath20 , where @xmath21 is the functional inverse of ackermann s function @xcite . in this paper",
    ", we prove a tight bound @xmath22 , where @xmath23 is the number of segments in @xmath15 each of which contains at least one edge of the faces in @xmath18 .",
    "an immediate application of this result is that we obtain an efficient query algorithm for our second data structure .",
    "since combinatorial bounds on arrangements are fundamental , this result may find other applications as well .",
    "the rest of this paper is organized as follows . in section",
    "[ sec : pre ] , we review some geometric structures and a query algorithmic scheme that will be used by the query algorithms of both our data structures . we will also give a `` ray - rotating '' data structure in section [ sec : pre ] , which is needed by our first data structure in section [ sec : first ] . in sections",
    "[ sec : first ] and [ sec : second ] , we present our first and second data structures , respectively . as a by - product of our second data structure ,",
    "the combinatorial bound of the zone mentioned above is also given in section [ sec : second ] .",
    "section [ sec : conclusions ] concludes the paper .",
    "in this section , we review some geometric structures and discuss an algorithmic scheme that will be used by the query algorithms of both our data structures given in sections [ sec : first ] and [ sec : second ]",
    ". we will also give a `` ray - rotating '' data structure in section [ sec : rayrotate ] , which is needed by our first data structure in section [ sec : first ] .",
    "for simplicity of discussion , we assume no three vertices of @xmath8 are collinear ; we also assume for any query segment @xmath2 , @xmath2 is not collinear with any vertex of @xmath8 and each endpoint of @xmath2 is not collinear with any two vertices of @xmath8 . as in @xcite",
    ", our approaches can be easily extended to the general situation .",
    "denote by @xmath16 the boundary of @xmath8 .",
    "the visibility graph of @xmath8 is a graph whose vertex set consists of all vertices of @xmath8 and whose edge set consists of edges defined by all visible pairs of vertices of @xmath8 . here",
    ", two adjacent vertices on @xmath16 are considered visible to each other . in this paper",
    ", we always use @xmath24 to denote the size of the visibility graph of @xmath8 .",
    "note that @xmath25 and @xmath26 . the visibility graph can be computed in @xmath27 time @xcite .",
    "we introduce the _ visibility decomposition _ of @xmath8 @xcite .",
    "consider a point @xmath9 in @xmath8 and a vertex @xmath28 of @xmath8 .",
    "suppose the line segment @xmath29 is in @xmath8 , i.e. , @xmath9 is visible to @xmath28 .",
    "we extend @xmath29 along the direction from @xmath9 to @xmath28 and suppose we stay inside @xmath8 ( when this happens , @xmath28 must be a reflex vertex ) .",
    "let @xmath30 be the point on the boundary of @xmath8 that is hit first by our above extension of @xmath29 ( e.g. , see fig .",
    "[ fig : window ] ) .",
    "we call the line segment @xmath31 the _ window _ of @xmath9 .",
    "the point @xmath9 is called the _ defining point _ of the window and the vertex @xmath28 is called the _",
    "anchor vertex _ of the window .",
    "it is well known that the boundary of the visibility polygon of the point @xmath9 consists of parts of @xmath16 and the windows of @xmath9 @xcite .",
    "if the point @xmath9 is a vertex of @xmath8 , then the window @xmath31 is called a _ critical constraint _ of @xmath8 and @xmath9 is called the _ defining vertex _ of the critical constraint .",
    "for example , in fig .",
    "[ fig : subproblem ] , the two critical constraints @xmath32 and @xmath33 are both defined by @xmath34 and @xmath28 ; for @xmath32 , its anchor vertex is @xmath34 and its defining vertex is @xmath28 , and for @xmath33 , its anchor vertex is @xmath28 and defining vertex is @xmath34 .",
    "it is easy to see that the total number of critical constraints is @xmath27 because each critical constraint corresponds to a visible vertex pair of @xmath8 and a visible vertex pair corresponds to at most two critical constraints .     and @xmath32 defined by the two mutually visible vertices @xmath34 and @xmath28 . ]     and @xmath32 defined by the two mutually visible vertices @xmath34 and @xmath28 . ]    as in @xcite",
    ", we represent the visibility polygon @xmath10 of a segment @xmath2 by a cyclic list of the vertices and edges of @xmath8 in the order in which they appear on the boundary of @xmath10 , and we call such a list the _ combinatorial representation _ of @xmath10 @xcite . with the combinatorial representation , @xmath10 can be explicitly determined in linear time in terms of the size of @xmath10 .",
    "our query algorithms given later always report the combinatorial representation of @xmath10",
    ".    the critical constraints of @xmath8 partition @xmath8 into cells , called the _ visibility decomposition _ of @xmath8 and denoted by @xmath35 .",
    "the visibility decomposition @xmath35 has a property that for any two points @xmath9 and @xmath36 in the same cell of @xmath35 , the two visibility polygons @xmath37 and @xmath38 have the same combinatorial representation .",
    "also , the combinatorial representations of the visibility polygons of two adjacent cells in @xmath35 have only @xmath39 differences .",
    "the visibility decomposition has been used for computing visibility polygons of query points ( not line segments ) @xcite .    consider a query segment @xmath2 in @xmath8 . in the following ,",
    "we discuss an algorithmic scheme for computing @xmath10 .",
    "denote by @xmath40 and @xmath41 the two endpoints of @xmath2 .",
    "suppose we move a point @xmath9 on @xmath2 from @xmath40 to @xmath41 .",
    "we want to capture the combinatorial representation changes of @xmath37 of the point @xmath9 during its movement .",
    "initially , @xmath9 is at @xmath40 and we have @xmath42 . as @xmath9 moves , the combinatorial representation of @xmath37 changes if and only if @xmath9 crosses a critical constraint of @xmath8 @xcite .",
    "@xmath10 is the union of all such visibility polygons as @xmath9 moves from @xmath40 to @xmath41 .",
    "therefore , to compute @xmath10 , as in @xcite , we use the following approach .",
    "initially , let @xmath43 . as @xmath9 moves from @xmath40 to @xmath41 , when @xmath9 crosses a critical constraint , either @xmath9 sees one more vertex / edge , or @xmath9 sees one less vertex / edge .",
    "if @xmath9 sees one more vertex / edge , then we update @xmath10 in constant time by inserting the new vertex / edge to the appropriate position of the combinatorial representation of @xmath10 . otherwise , we do nothing ( because even though a vertex / edge is not visible to @xmath9 any more , it is visible to @xmath2 and thus should be kept ; refer to @xcite for details ) .",
    "the above algorithm has two remaining issues .",
    "the first one is how to compute @xmath44 of the point @xmath40 .",
    "the second issue is how to determine the next critical constraint that will be crossed by @xmath9 as @xmath9 moves .",
    "each of our two data structures given in sections [ sec : first ] and [ sec : second ] does some preprocessing such that the corresponding query algorithm can resolve the above two issues efficiently .",
    "our first data structure in section [ sec : first ] needs the following _ ray - rotating _ queries .",
    "given any ray @xmath45 whose origin @xmath46 is in @xmath8 , the ray - rotating query asks for the first vertex of @xmath8 visible to @xmath46 that will be hit by @xmath45 when we rotate @xmath45 clockwise ( or counterclockwise ) around @xmath46 ( e.g. , see fig .",
    "[ fig : rayrotate ] ) . by making use of the ray - shooting data structures @xcite and the two - point shortest path query data structure @xcite",
    ", we obtain the following result .    :",
    "the two dotted paths are shortest paths from @xmath46 to @xmath47 and @xmath48 , respectively . ]    : the two dotted paths are shortest paths from @xmath46 to @xmath47 and @xmath48 , respectively . ]",
    "[ lem : rayrotate ] a data structure can be built in @xmath1 time and @xmath1 space such that each ray - rotating query can be answered in @xmath49 time .",
    "consider any ray @xmath45 whose origin @xmath46 is in @xmath8 . without loss of generality , assume @xmath45 is horizontally rightwards . let @xmath50 be the sought vertex for the ray - rotating query on @xmath45 , i.e. , @xmath50 is the first vertex of @xmath8 visible to @xmath46 that will be hit by @xmath45 when we rotate @xmath45 clockwise around @xmath46 ( the case of counterclockwise rotation can be done similarly ) .    in the preprocessing , we compute a ray - shooting data structure @xcite in @xmath1 time and space , such that given any ray with the origin in @xmath8 , the first point on the boundary of @xmath8 hit by the ray",
    "can be found in @xmath49 time .",
    "we also compute a two - point shortest path query data structure @xcite in @xmath1 time and space , such that given any two points @xmath9 and @xmath36 in @xmath8 , the shortest path length between @xmath9 and @xmath36 can be computed in @xmath49 time and the path itself can be found in additional time proportional to the number of turns along it .    our query algorithm for finding @xmath50 works as follows .",
    "first , we use the ray - shooting data structure to find in @xmath49 time the first point @xmath51 on the boundary of @xmath8 hit by @xmath45 ; the edge of @xmath8 containing @xmath51 is also known immediately from the ray - shooting query . if @xmath51 is a vertex of @xmath8 , then @xmath52 and we are done ; otherwise , let the end vertices of the edge of @xmath8 containing @xmath51 be @xmath47 and @xmath48 ( e.g. , see fig .",
    "[ fig : funnel ] ) .",
    "let @xmath53 be the shortest path in @xmath8 from @xmath46 to @xmath47 , and similarly , let @xmath54 be the shortest path from @xmath46 to @xmath48 .",
    "since @xmath46 is visible to @xmath51 on @xmath55 , the region bounded by @xmath53 , @xmath54 , and @xmath55 is a funnel @xcite , with @xmath46 as the apex ( e.g. , see fig .",
    "[ fig : funnel ] ) . recall that @xmath45 is horizontally rightwards ; one vertex of @xmath47 and @xmath48 must be below the line containing @xmath45 . without loss of generality ,",
    "let @xmath47 be below the line containing @xmath45 .",
    "let @xmath28 be the vertex on @xmath53 that is connected to @xmath46 by a line segment on @xmath53 , i.e. , @xmath56 is the first edge of @xmath53 ( e.g. , see fig .  [",
    "fig : funnel ] ) . note that @xmath57 is possible , in which case @xmath53 is the line segment @xmath58 .",
    "an easy observation is that the sought vertex @xmath50 is exactly the vertex @xmath28 . by using the two - point shortest path data structure @xcite on @xmath46 and @xmath47 ,",
    "the vertex @xmath28 can be easily found in @xmath49 time because @xmath56 is the first edge of @xmath53 .",
    "therefore , the sought vertex @xmath50 for the ray - rotating query on @xmath45 can be found in @xmath49 time .",
    "the lemma thus follows .",
    "our goal is to compute @xmath10 for any query segment @xmath2 . again , let @xmath59 . as discussed before , we need to resolve two issues .",
    "the first issue is to compute @xmath44 . for this , as discussed in @xcite , by using the ray - shooting data structure @xcite , with @xmath1 time preprocessing , we can compute @xmath44 in @xmath60 time , where @xmath61 is the size of @xmath44 . note that it might be easier to compute @xmath61 by using both the ray - shooting data structure and our ray - rotating data structure in lemma [ lem : rayrotate ] .",
    "the second issue is how to determine the next critical constraint of @xmath8 that will be crossed by the point @xmath9 as @xmath9 moves from @xmath40 to @xmath41 .",
    "suppose at the moment we know @xmath37 ( initially , @xmath62 ) .",
    "let @xmath63 be the critical constraint that is crossed next by @xmath9 . to determine @xmath63 , we first sketch an observation given in @xcite .    denote by @xmath64 the shortest path tree rooted at @xmath9 , which is the union of the shortest paths in @xmath8 from @xmath9 to all vertices of @xmath8 .",
    "a vertex of @xmath8 is in @xmath37 if and only if it is a child of @xmath9 in @xmath64 . for any child @xmath28 of @xmath9 in the tree @xmath64 ,",
    "define the _ principal child _ of @xmath28 to be the vertex @xmath30 among the children of @xmath28 in @xmath64 such that the angle formed by the rays @xmath65 and @xmath66 is the smallest among all such angles ( see fig .",
    "[ fig : principal ] ) .",
    "in other words , if we go from @xmath9 to any child of @xmath28 along the shortest path and we turn to the left ( resp . , right ) , then @xmath30 is the first child of @xmath28 that is hit by rotating counterclockwise ( resp . , clockwise ) the line containing @xmath29 around @xmath28 .    to determine the next critical constraint @xmath63 ,",
    "the following observation was shown in @xcite .",
    "two children of @xmath9 in @xmath64 are _ consecutive _ if there is no other child of @xmath9 between them in the cyclic order around @xmath9 .     of @xmath28 in @xmath64 .",
    "]    [ obser:10]_@xcite _ the next critical constraint @xmath63 is defined by two vertices of @xmath8 that are either two consecutive children of @xmath9 or one , say @xmath28 , is a child of @xmath9 and the other is the principal child of @xmath28 .    based on observation [ obser:10 ] , aronov _ et al .",
    "_ @xcite maintained @xmath64 as @xmath9 moves and used the balanced triangulation of @xmath8 to determine the principal children .",
    "their query algorithm takes @xmath67 time , where @xmath68 , and the preprocessing time and space of their data structure @xcite are @xmath13 and @xmath12 , respectively .",
    "here , we take a different approach , although we still use observation [ obser:10 ] .",
    "our data structure consists of the following : the ray - shooting data structure @xcite , the ray - rotating data structure in lemma [ lem : rayrotate ] , and a priority queue @xmath69 .",
    "we assume @xmath44 has been computed .",
    "we use the ray - rotating data structure to determine the principal children of all children of @xmath9 , as follows .",
    "first of all , since we already know @xmath37 ( initially @xmath70 ) , we have all @xmath9 s children in @xmath64 , sorted cyclically around @xmath9 . note that we need not store the entire tree @xmath64 .",
    "consider any child @xmath28 of @xmath9 in @xmath64 ( i.e. , @xmath28 is visible to @xmath9 ) .",
    "let @xmath30 be the principal child of @xmath28 that we are looking for . consider the ray @xmath71 originating from @xmath28 with the direction from @xmath9 to @xmath28 . by the definition of principle children , @xmath30 is the first vertex of @xmath8 visible to @xmath28 that will be hit by the ray @xmath71 if we rotate @xmath71 around @xmath28 along the direction that is consistent with the turning direction of the shortest paths from @xmath9 to the children of @xmath28 in @xmath64 .",
    "it is easy to see that once we know the above rotation direction , we can obtain @xmath30 in @xmath49 time by our ray - rotating data structure in lemma [ lem : rayrotate ] .    to determine the above rotation direction , we only need to look at the relationship between the line containing @xmath71 and the two edges of @xmath8 adjacent to @xmath28",
    "specifically , assume the line containing @xmath71 has the same direction as @xmath71 .",
    "for example , if the two adjacent edges of @xmath28 both lie to the left of this line ( e.g. , see fig .",
    "[ fig : principal ] ) , then we should rotate @xmath71 counterclockwise to determine @xmath30 .",
    "the other cases can be determined in a similar manner . in summary",
    ", we can obtain the principle child of @xmath28 in @xmath49 time .",
    "initially , @xmath70 and we determine the principle children of all children of @xmath40 in @xmath72 in @xmath60 time since @xmath40 has @xmath73 children in @xmath72 .",
    "we use the priority queue @xmath69 to store the critical constraints specified in observation [ obser:10 ] that intersect the line segment @xmath2 , where the key of each such critical constraint used in the priority queue @xmath69 is the position of its intersection with @xmath2 .",
    "initially when @xmath70 , we compute the critical constraints defined by all pairs of consecutive children of @xmath9 in @xmath64 .",
    "similarly , for each child @xmath28 of @xmath64 , we compute the critical constraint defined by @xmath28 and its principal child .",
    "note that the total number of these critical constraints is @xmath73 . for each such critical constraint",
    ", we check whether it intersects @xmath2 , which can be done in @xmath49 time with the help of a ray - shooting query ( we omit the details ) . if the critical constraint intersects @xmath2 , we insert it into @xmath69 ; otherwise , we do nothing .",
    "then , the first critical constraint in @xmath69 is the next critical constraint that @xmath9 will cross as it moves . in general , after @xmath9 crosses a critical constraint , @xmath9 either sees one more vertex or sees one less vertex of @xmath8 . in either case , there are only a constant number of insertion or deletion operations on @xmath69 .",
    "specifically , consider the case when @xmath9 sees one more vertex @xmath34 ( and an adjacent edge of @xmath34 ) . by the implementation given in @xcite",
    ", we can update the combinatorial representation of @xmath37 in constant time ( i.e. , insert @xmath34 and the adjacent edge to the appropriate positions of the cyclic list of @xmath37 ) .",
    "after this , @xmath34 becomes a child of @xmath9 in the new tree @xmath64 , and we can determine @xmath9 s two other children , say , @xmath47 and @xmath48 , which are cyclic neighbors of @xmath34 , in constant time . then , for @xmath47 , we check whether the critical constraint defined by @xmath34 and @xmath47 intersects @xmath2 , and if so , we insert it into @xmath69 . for @xmath48 , we do the same thing .",
    "further , we compute the principal child of @xmath34 in @xmath64 , in @xmath49 time , by the approach discussed above . for the other case where @xmath9 sees one less vertex",
    "after it crosses the critical constraint , we perform similar processing .",
    "after @xmath9 arrives at the other endpoint @xmath41 of @xmath2 , we obtain the combinatorial representation of @xmath10 .",
    "we claim that the above algorithm takes @xmath74 time ( with @xmath68 ) .",
    "indeed , the initialization takes @xmath60 time . clearly , @xmath75 since each vertex of @xmath8 that is in @xmath44 also appears in @xmath10 .",
    "if we consider every time when @xmath9 crosses a critical constraint as an _ event _ , then each event takes @xmath49 time .",
    "it has been shown in @xcite that the total number of events as @xmath9 moves from @xmath40 to @xmath41 is @xmath76 .",
    "hence , the overall running time for computing @xmath10 is @xmath3 .    for the preprocessing ,",
    "the ray - shooting data structure and the ray - rotating data structure both need @xmath1 time and space to build .",
    "further , in our query algorithm , the space used in the priority queue @xmath69 is always bounded by @xmath76 .",
    "we conclude this section with the following result .",
    "[ theo:10 ] for any simple polygon @xmath8 , a data structure can be built in @xmath1 time and @xmath1 space , such that the visibility polygon @xmath10 can be computed in @xmath77 time for any query line segment @xmath2 in @xmath8 .",
    "in general , the preprocessing of our second data structure is very similar to that in @xcite , and we make it faster by using better tools . our improvement on the query algorithm is based on a number of new observations , e.g. , a combinatorial bound of the  zone \" of the line segment arrangements in simple polygons . for completeness , we first briefly discuss the approach in @xcite .",
    "the preprocessing in @xcite has several steps , whose running time is @xmath11 and is dominated by the first two steps .",
    "the other steps together take @xmath6 time .",
    "we show below that the first two steps can be implemented in @xmath6 time .",
    "the preprocessing in @xcite first computes the visibility decomposition @xmath35 of @xmath8 .",
    "although there may be @xmath78 critical constraints in @xmath8 , it has been shown @xcite that any line segment in @xmath8 can intersect only @xmath1 critical constraints , which implies that the size of @xmath35 is @xmath6 instead of @xmath79 .",
    "all critical constraints of @xmath8 can be computed in @xmath12 time , e.g. , by the algorithm in @xcite .",
    "after that , to compute @xmath35 , we can use chazelle and edelsbrunner s algorithm @xcite , which computes the planar subdivision induced by a set of @xmath80 line segments in @xmath81 time , where @xmath82 is the number of intersections of the line segments . in our problem",
    ", we have @xmath12 critical constraints each of which is a line segment and the boundary of @xmath8 has @xmath5 edges .",
    "therefore , by using the algorithm in @xcite , we can compute @xmath35 in @xmath6 time .",
    "alternatively , an approach mentioned in @xcite can also be used to compute @xmath35 in @xmath6 time , and we omit the details .",
    "the second step of the preprocessing in @xcite is to build a planar point location data structure on @xmath35 in @xmath83 time . by the approaches in @xcite or @xcite",
    ", we can build such a point location data structure in @xmath6 time .",
    "the remaining steps of our preprocessing algorithm are the same as those in @xcite , which together take @xmath6 time .",
    "hence , the total preprocessing time is @xmath6 . with the preprocessing , for each query point @xmath36 in @xmath8",
    ", we can compute the visibility polygon @xmath38 of @xmath36 in @xmath84 time .    for a query segment @xmath59 , the query algorithm in @xcite first computes @xmath44 . then , again , let a point @xmath9 move on @xmath2 from @xmath40 to @xmath41 .",
    "the algorithm maintains @xmath37 as @xmath9 moves on @xmath2 , initially with @xmath62 .",
    "again , whenever @xmath9 crosses a critical constraint , the combinatorial representation of @xmath37 changes . unlike our first data structure in section [ sec : first ] , here we have @xmath35 explicitly .",
    "therefore , we can determine the next critical constraint in a much easier way .",
    "specifically , the algorithm in @xcite uses the following approach .",
    "suppose @xmath9 is currently in a cell of @xmath35 ; then the next critical constraint crossed by @xmath9 must be on the boundary of that cell .",
    "since each cell is convex , we can determine this critical constraint in @xmath49 time .",
    "the algorithm stops when @xmath9 arrives at @xmath41 .",
    "the total running time of the query algorithm is @xmath3 , where @xmath68 .",
    "we propose a new and simpler query algorithm .",
    "we follow the previous query algorithmic scheme .",
    "the only difference is when we determine the next critical constraint that will be crossed by @xmath9 , we simply check each edge on the boundary of the current cell that contains @xmath9 , and the running time is linear in terms of the number of edges of the cell .",
    "therefore , the total running time of finding all critical constraints crossed by @xmath9 as it moves on @xmath2 is proportional to the total number of edges on all faces of @xmath35 that intersect @xmath2 , and we denote by @xmath85 the set of such faces of @xmath35 .",
    "let @xmath86 denote the set of edges of the faces in @xmath85 .",
    "then the total time of finding all critical constraints crossed by @xmath9 is @xmath87 .",
    "note that the time of the overall query algorithm is the sum of the time for computing @xmath44 and the time for finding all critical constraints crossed by @xmath9 . since @xmath44 can be found in @xmath88 time",
    ", the running time of the query algorithm is @xmath89 . recall that @xmath75 . in lemma  [ lem:10 ]",
    "below , we will prove @xmath90 .",
    "consequently , the query algorithm takes @xmath91 time and theorem [ theo:20 ] below thus follows .",
    "[ lem:10 ] the size of the set @xmath86 is @xmath76 .",
    "[ theo:20 ] for any simple polygon @xmath8 , we can build a data structure of size @xmath6 in @xmath6 time that can compute @xmath10 in @xmath92 time for each query segment @xmath2 in @xmath8 .",
    "it remains to prove lemma [ lem:10 ] .",
    "note that each edge of @xmath86 lies either on @xmath16 or on a critical constraint .",
    "we partition the set @xmath86 into two subsets @xmath93 and @xmath94 . for each edge of @xmath86 , if it lies on @xmath16 , then it is in @xmath93 ; otherwise , it is in @xmath94 .",
    "we will show that both @xmath95 and @xmath96 hold .",
    "denote by @xmath97 the set of all critical constraints each of which contains at least one edge of @xmath86 .",
    "[ lem:20 ] the size of the set @xmath97 is @xmath76 .",
    "denote by @xmath98 the set of vertices of @xmath8 visible to @xmath2 .",
    "clearly , @xmath99 .",
    "consider an arbitrary critical constraint @xmath100 . to prove the lemma",
    ", we will charge @xmath101 to a vertex of @xmath98 .",
    "we will show that each vertex of @xmath98 will be charged at most a constant number of times , which will lead to the lemma .",
    "assume the defining vertex of @xmath101 is @xmath34 and the anchor vertex of @xmath101 is @xmath28 . by the definition of @xmath97 , @xmath101 contains at least one edge of @xmath86 . depending on whether @xmath101 intersects @xmath2",
    ", there are two cases .    1 .",
    "if @xmath101 intersects @xmath2 , then the defining vertex @xmath34 of @xmath101 must be visible to @xmath2 ( see fig .",
    "[ fig : intersect ] ) . to see this ,",
    "let @xmath36 be the intersection of @xmath101 and @xmath2 .",
    "hence , @xmath36 is visible to @xmath28 .",
    "one may consider that the visibility between @xmath36 and @xmath34 is blocked by @xmath28 .",
    "due to our assumption that each endpoint of @xmath2 is not collinear with two vertices of @xmath8 , @xmath36 is not an endpoint of @xmath2 .",
    "hence , there is always a point on @xmath2 infinitely close to @xmath36 that is visible to @xmath34 , and thus @xmath34 is visible to @xmath2 .",
    "we charge @xmath101 to its defining vertex @xmath34 .",
    "+   does not intersect @xmath2 . ]",
    "+   does not intersect @xmath2 . ]",
    "2 .   if @xmath101 does not intersect @xmath2 ( see fig .",
    "[ fig : nonintersect ] ) , then we show below that the anchor vertex @xmath28 of @xmath101 must be visible to @xmath2 , and further , there are at most two critical constraints in @xmath97 such that they do not intersect @xmath2 and their anchor vertices are @xmath28 .",
    "we will charge @xmath101 to @xmath28 .",
    "+ we first prove that @xmath28 is visible to @xmath2 .",
    "since @xmath101 contains at least one edge of @xmath86 , there must be a face @xmath102 of @xmath35 intersecting @xmath2 and the boundary of @xmath102 has an edge @xmath103 contained in @xmath101 .",
    "let @xmath104 be an arbitrary interior point of @xmath103 and let @xmath105 be an arbitrary point on @xmath2 that is contained in @xmath102 ( see fig .",
    "[ fig : nonintersect ] ) . since @xmath102 is convex , @xmath106",
    "is contained in @xmath102 , i.e. , @xmath104 is visible to @xmath105 and @xmath106 does not intersect any other critical constraint of @xmath8 than @xmath101 ( at @xmath104 ) . to prove @xmath105 is visible to the vertex @xmath28 ,",
    "consider a point @xmath36 on @xmath106 moving from @xmath104 to @xmath105 .",
    "we claim that @xmath28 is always visible to @xmath36 as @xmath36 moves .",
    "indeed , initially @xmath36 is at @xmath104 , and @xmath28 is visible to @xmath104 because @xmath104 is on the critical constraint @xmath101 and @xmath28 is the anchor vertex of @xmath101 .",
    "suppose to the contrary @xmath28 is not visible to @xmath36 at some moment as @xmath36 moves .",
    "then , at some moment , @xmath107 must encounter a vertex of @xmath8 , say , @xmath30 .",
    "in other words , @xmath30 is on @xmath107 .",
    "then , the two vertices @xmath28 and @xmath30 define a critical constraint with @xmath28 as the defining vertex and @xmath30 as the anchor vertex , and the critical constraint intersects @xmath106 at @xmath36 . note that this critical constraint is not @xmath101 because @xmath28 is the anchor vertex of @xmath101 .",
    "hence , we obtain a contradiction because @xmath101 is the only critical constraint that intersects @xmath106 .",
    "therefore , we conclude that @xmath28 is visible to @xmath105 . + next , we prove that there are at most two critical constraints in @xmath97 such that they do not intersect @xmath2 and their anchor vertices are @xmath28 .",
    "let @xmath108 denote the set of all critical constraints each of which has @xmath28 as its anchor vertex and does not intersect @xmath2 .",
    "our goal is to prove that @xmath108 has at most two critical constraints in @xmath97 .",
    "note that each critical constraint in @xmath108 has @xmath28 as an endpoint and its other endpoint is on @xmath109 .",
    "hence , the critical constraints of @xmath108 partition @xmath8 into @xmath110 interior - disjoint regions and one region contains @xmath2 ( see fig .  [",
    "fig : partition ] ) .",
    "let @xmath111 be the region containing @xmath2 . clearly , @xmath111 has at most two critical constraints of @xmath108 , say @xmath112 and @xmath113 , on its boundary .",
    "we claim that for any critical constraint @xmath114 , @xmath115 can not contain an edge of @xmath86 .",
    "indeed , assume to the contrary @xmath115 contains an edge of @xmath86 .",
    "then , as discussed before , we can always find such two points @xmath104 and @xmath105 as in fig .",
    "[ fig : nonintersect ] . recall that @xmath106 is in @xmath8 and @xmath106 does not intersect any other critical constraint of @xmath8 than @xmath115 . since @xmath115 is outside @xmath111",
    ", @xmath116 is outside @xmath111 .",
    "however , due to @xmath117 and @xmath118 , @xmath106 must intersect either @xmath112 or @xmath113 , which contradicts with that @xmath106 does not intersect any other critical constraint of @xmath8 than @xmath115 .",
    "hence , @xmath115 can not contain an edge of @xmath86 and @xmath119 .",
    "therefore , we obtain that @xmath108 has at most two critical constraints in @xmath97 . +   as their anchor vertex that do not intersect @xmath2 . ]    according to our discussion above , in the first case ( i.e. , @xmath101 intersects @xmath2 ) , we charge @xmath101 to its defining vertex @xmath34 , which is in @xmath98 . in the second case ( i.e. , @xmath101 does not intersect @xmath2 )",
    ", we charge @xmath101 to its anchor vertex @xmath28 , which is also in @xmath98 .",
    "an observation in @xcite shows that for any line segment in @xmath8 , for any vertex @xmath34 of @xmath8 , the line segment intersects at most two critical constraints with @xmath34 as their defining vertex .",
    "therefore , for any vertex @xmath34 of @xmath8 , @xmath34 can be charged at most twice as a defining vertex . on the other hand ,",
    "we have shown that , as an anchor vertex , @xmath28 has at most two critical constraints in @xmath97 that do not intersect @xmath101 .",
    "therefore , for any vertex @xmath28 of @xmath8 , @xmath28 can be charged at most twice as an anchor vertex .",
    "hence , any vertex in @xmath98 can be charged at most four times , twice as an anchor vertex and twice as a defining vertex . in other words , @xmath120 .",
    "the lemma thus follows .    in the next lemma , we bound the size of the subset @xmath93 .",
    "[ lem:30 ] the size of the set @xmath93 is @xmath76 .",
    "denote by @xmath98 the set of vertices of @xmath8 visible to @xmath2 .",
    "clearly , @xmath99 .",
    "consider an edge @xmath103 in @xmath93 . to prove the lemma",
    ", we will charge @xmath103 either to a vertex of @xmath98 or to a critical constraint of @xmath97 .",
    "we will also show that each vertex of @xmath98 will be charged at most twice and each critical constraint of @xmath97 will be charged at most four times .",
    "consequently , due to @xmath99 and @xmath121 ( by lemma [ lem:20 ] ) , the lemma follows .    by the definition of @xmath93 , @xmath103 is on an edge of @xmath8 .",
    "if @xmath103 has an endpoint that is a vertex of @xmath8 , say @xmath34 , then clearly @xmath34 is visible to @xmath2 .",
    "we charge @xmath103 to @xmath34 .",
    "otherwise , both endpoints of @xmath103 are endpoints of some critical constraints , and we charge @xmath103 to an arbitrary one of the two such critical constraints .    for each vertex of @xmath8 , it has two adjacent edges in @xmath8 , and therefore , it has at most two adjacent edges in @xmath93 . hence , each vertex of @xmath98 can be charged at most twice . on the other hand ,",
    "each critical constraint has two endpoints , and each endpoint is adjacent to at most two edges in @xmath93 .",
    "therefore , each critical constraint of @xmath97 can be charged at most four times .    to prove lemma [ lem:10 ] ,",
    "it remains to show @xmath96 . to this end",
    ", we discuss a more general problem , in the following .",
    "assume we have a set @xmath15 of line segments in @xmath8 such that the endpoints of each such segment are on @xmath16 .",
    "let @xmath17 be the arrangement formed by the line segments of @xmath15 and the edges of @xmath16 .",
    "for any line segment @xmath2 in @xmath8 ( the endpoints of @xmath2 need not be on @xmath16 ) , the _ zone _ of @xmath2 is defined to be the set of all faces of @xmath17 that @xmath2 intersects .",
    "denote by @xmath18 the zone of @xmath2 .",
    "for each edge of a face in @xmath17 , it either lies on a line segment of @xmath15 or lies on @xmath16 ; if it is the former case , we call the edge an _ @xmath15-edge_. we define the _ complexity _ of @xmath18 as the number of @xmath15-edges of the faces in @xmath18 ( namely , the edges on @xmath16 are not considered ) , denoted by @xmath19 .",
    "our goal is to find a good upper bound for @xmath19 . by using the zone theorem for the general line segment arrangement @xcite",
    ", we can easily obtain @xmath20 , where @xmath21 is the functional inverse of ackermann s function @xcite .",
    "denote by @xmath122 the set of line segments in @xmath15 that intersect @xmath18 , i.e. , each segment in @xmath122 contains at least one @xmath15-edge of @xmath18 .",
    "let @xmath123 ( note that @xmath23 ) . by using the property that each segment in @xmath15 has both endpoints on @xmath16",
    ", we show @xmath22 in theorem [ theo : zone ] below , which we call the _ zone theorem_. the proof of theorem [ theo : zone ] is given in section [ sec : zone ] .",
    "[ theo : zone ] the complexity of @xmath18 is @xmath124 .",
    "now consider our original problem of proving @xmath96 . by using the zone theorem",
    ", we have the following corollary .    [ cor:10 ]",
    "the size of the set @xmath94 is @xmath76 .",
    "the set @xmath94 consists of all edges of @xmath86 that lie on the critical constraints .",
    "recall that each critical constraint is a line segment in @xmath8 with both endpoints on @xmath16 .",
    "consider the arrangement formed by all critical constraints of @xmath8 and @xmath16 .",
    "the complexity of the zone @xmath18 of the query segment @xmath2 in this arrangement is exactly @xmath125 .",
    "let @xmath126 be the set of critical constraints of @xmath8 each of which contains at least one edge in @xmath94 .",
    "then , by the zone theorem ( theorem [ theo : zone ] ) , we have @xmath127 .",
    "note that @xmath128 . due to @xmath121 ( lemma [ lem:20 ] )",
    ", we have @xmath96 .",
    "the corollary thus follows .",
    "lemma [ lem:30 ] and corollary [ cor:10 ] together lead to lemma [ lem:10 ] .",
    "this subsection is devoted entirely to proving the zone theorem , i.e. , theorem [ theo : zone ] .",
    "all notations here are the same as defined before .",
    "we partition the set @xmath122 into two subsets : @xmath129 and @xmath130 . for each segment in @xmath122 , if it does not intersect the interior of @xmath2 , then it is in @xmath129 ; otherwise , it is in @xmath130 .",
    "let @xmath131 and @xmath132 .",
    "hence , @xmath133 .",
    "consider the arrangement formed by the line segments in @xmath129 and @xmath16 .",
    "since no segment in @xmath129 intersects the interior of @xmath2 , @xmath2 must be contained in a single face of the above arrangement and we denote by @xmath134 that face .",
    "for each edge of @xmath134 , if it lies on a segment of @xmath15 , we also call it an @xmath15-edge .",
    "note that the edges of @xmath134 that are not @xmath15-edges are all on @xmath16 .    [ lem:40 ] the number of @xmath15-edges of the face @xmath134 is @xmath135 ; the shortest path in @xmath8 between any two points in @xmath134 is contained in @xmath134 .    for each segment @xmath136 in @xmath129 , since both endpoints of @xmath136 are on @xmath16 , @xmath136 partitions @xmath8 into two simple polygons and one of them contains @xmath2 , which we denote by @xmath137 .",
    "it is easy to see that the face @xmath134 is the common intersection of @xmath137 s for all @xmath136 in @xmath129 . to prove the lemma , it is sufficient to show that each segment @xmath136 in @xmath129 has at most one ( maximal ) continuous portion on the boundary of @xmath134 , as follows .",
    "for any two points @xmath9 and @xmath36 in @xmath8 , denote by @xmath138 the shortest path between @xmath9 and @xmath36 in @xmath8 .",
    "note that since @xmath8 is a simple polygon , @xmath138 is unique .",
    "we claim that for any two points @xmath9 and @xmath36 in the face @xmath134 , @xmath138 is contained in @xmath134 . indeed , suppose to the contrary @xmath138 is not contained in @xmath134 .",
    "then , @xmath138 must cross the boundary of @xmath134 .",
    "since @xmath138 can not cross the boundary of @xmath8 , @xmath138 must cross an @xmath15-edge of @xmath134 , and we assume @xmath136 is the segment in @xmath129 that contains such an @xmath15-edge .",
    "this implies that @xmath138 is also not contained in the polygon @xmath137 .",
    "recall that the line segment @xmath136 partitions @xmath8 into two simple polygons and one of them is @xmath137 .",
    "it is easy to show that for any two points in @xmath137 , their shortest path in @xmath8 must be contained in @xmath137 .",
    "therefore , we obtain a contradiction . hence , our above claim is true .",
    "now assume to the contrary that a segment @xmath136 in @xmath129 has two disjoint maximal continuous portions on the boundary of @xmath134 .",
    "let @xmath9 and @xmath36 be two points on these two portions of @xmath136 , respectively .",
    "thus , both @xmath9 and @xmath36 are in @xmath134 .",
    "since these are two discontinuous portions of @xmath136 on the boundary of @xmath134 , the line segment @xmath139 is not contained in @xmath134 .",
    "since @xmath139 is on @xmath136 , the shortest path @xmath138 is @xmath139 . but",
    "this means @xmath138 is not contained in @xmath134 , which incurs a contradiction with our previous claim that @xmath138 must be contained in @xmath134 .",
    "hence , we obtain that each segment @xmath136 in @xmath129 has at most one continuous portion on the boundary of @xmath134 , and consequently , the number of @xmath15-edges of the face @xmath134 is @xmath135 .",
    "lemma [ lem:50 ] below shows a property of the face @xmath134 .",
    "[ lem:50 ] for any line segment @xmath136 in @xmath8 with both endpoints on @xmath16 , @xmath136 has at most one ( maximal ) continuous portion intersecting @xmath134 ; consequently , @xmath136 intersects the interior of at most two edges of @xmath134 .",
    "assume to the contrary that @xmath136 has two disjoint maximal continuous portions intersecting @xmath134 .",
    "let @xmath9 and @xmath36 be two points on these two portions of @xmath136 , respectively .",
    "thus , both @xmath9 and @xmath36 are in @xmath134 .",
    "clearly , the line segment @xmath139 is not contained in @xmath134 . since @xmath139 is on @xmath136",
    ", @xmath139 is the shortest path @xmath138 between @xmath9 and @xmath36 in @xmath8 . but",
    "this means @xmath138 is not contained in @xmath134 , which incurs a contradiction with lemma [ lem:40 ] .",
    "hence , the lemma holds .    for each @xmath15-edge of @xmath18",
    ", it lies either on a segment in @xmath129 or on a segment in @xmath130 ; we call it an @xmath129-edge if it lies on a segment in @xmath129 and an @xmath130-edge otherwise . due to @xmath133 ,",
    "our zone theorem is an immediate consequence of lemma [ lem:60 ] below .",
    "note that we can obtain the zone @xmath18 of @xmath2 by adding the segments of @xmath130 to @xmath134 . to prove lemma [ lem:60 ] , we use induction on @xmath140 , i.e. , @xmath141 .",
    "the approach is very similar to that in @xcite used for line arrangements . here ,",
    "although we have line segments instead of lines , the property that each line segment has both endpoints on @xmath16 makes the approach in @xcite applicable with some modifications .",
    "[ lem:60 ] there are @xmath142 @xmath130-edges and @xmath143 @xmath129-edges in the zone @xmath18",
    ".    without loss of generality , assume the segment @xmath2 is horizontal .",
    "it is easy to see that each @xmath129-edge bounds one face of @xmath18 and each @xmath130-edge bounds two faces of @xmath18 ( one lies on its right and the other lies on its left ) . for each @xmath130-edge , we say it is a _ left bounding @xmath130-edge _ for the face lying on the right of it and a _",
    "right bounding @xmath130-edge _ for the face lying on the left of it .",
    "below we will prove that the number of left bounding @xmath130-edges of the faces in @xmath18 is @xmath142 .",
    "analogously , the number of right bounding @xmath130-edges of the faces in @xmath18 is also @xmath142 .",
    "in addition , we will also show that the number of @xmath129-edges of @xmath18 is @xmath144 .",
    "our proof is by induction on @xmath140 .",
    "consider the base case with @xmath145 .",
    "denote by @xmath136 the only segment in @xmath130 .",
    "note that the face @xmath134 has no @xmath130-edges on its boundary and has @xmath135 @xmath129-edges by lemma [ lem:40 ] . in light of lemma [ lem:50 ]",
    ", @xmath136 has at most one maximal continuous portion intersecting the face @xmath134 and @xmath136 intersects the interior of at most two @xmath129-edges of @xmath134 .",
    "therefore , after we add @xmath136 to @xmath134 , the number of @xmath129-edges of @xmath18 increases by at most two and the number of left bounding @xmath130-edges increases by at most one .    , which is not in the zone of @xmath2 .",
    "]    consider the general case of @xmath146 .",
    "let @xmath136 be the segment in @xmath130 that intersects @xmath2 at the rightmost position among all segments in @xmath130 .",
    "we first consider the case when this segment @xmath136 is unique . by induction",
    ", the zone of @xmath2 has @xmath147 left bounding @xmath148-edges and @xmath149 @xmath129-edges , for some constant @xmath101 , without considering the segment @xmath136 .",
    "now consider adding @xmath136 .",
    "first , by lemma [ lem:50 ] , @xmath136 has at most one maximal continuous portion intersecting the face @xmath134 and @xmath136 intersects the interior of at most two @xmath129-edges of the zone @xmath18 ; therefore , the number of @xmath129-edges increases by at most @xmath150 .",
    "second , the number of left bounding @xmath130-edges increases in two ways : there are new left bounding @xmath130-edges on @xmath136 and there are old left bounding @xmath130-edges that are split by @xmath136 . let @xmath28 be the first intersection point of @xmath136 with another segment in @xmath130 above @xmath2 , and let @xmath30 be the first intersection point of @xmath136 with another segment in @xmath130 below @xmath2 ( e.g. , see fig .",
    "[ fig : arrangement ] ) .",
    "we assume both @xmath28 and @xmath30 exist since otherwise the analysis is even simpler .",
    "the segment @xmath31 on @xmath136 becomes a new left bounding @xmath130-edge .",
    "in addition , @xmath136 splits a left bounding @xmath130-edge at @xmath28 and at @xmath30 , respectively .",
    "hence , the number of the left bounding @xmath130-edges increases by three . we claim that there is no other increase for the number of left bounding @xmath130-edges .",
    "indeed , consider the part of @xmath136 above @xmath28 .",
    "let @xmath151 be the segment in @xmath130 that intersects @xmath136 at @xmath28 .",
    "let @xmath152 be the endpoint of @xmath136 above @xmath28 and @xmath153 be the endpoint of @xmath151 above @xmath28 .",
    "note that both @xmath152 and @xmath153 are on @xmath16 .",
    "consider the region @xmath154 above @xmath28 enclosed by @xmath155 , @xmath156 , and the portion of @xmath16 between @xmath152 and @xmath153 ( e.g. , see fig .",
    "[ fig : arrangement ] ) . clearly , the region @xmath154 is not in the zone of @xmath2 .",
    "further , @xmath154 lies on the right of @xmath155 , and thus @xmath155 can not contribute any left bounding @xmath130-edges to @xmath18 .",
    "in addition , if a left bounding @xmath130-edge @xmath103 that was in the zone @xmath18 ( before @xmath136 is added ) is intersected by @xmath136 somewhere above @xmath28 , then the part of @xmath103 to the right of @xmath136 ( i.e. , the part of @xmath103 in the region @xmath154 ) is not in the zone @xmath18 any more after @xmath136 is added .",
    "hence , there is no increase in the number of left bounding @xmath130-edges due to such an intersection .    in a similar way",
    ", we can show that the part of @xmath2 below @xmath30 does not increase the number of left bounding @xmath130-edges in the zone @xmath18 .",
    "therefore , after @xmath136 is added , the total increase of the number of left bounding @xmath130-edges is at most three .",
    "we discuss above the case when @xmath136 is the only segment in @xmath130 through the rightmost intersection on @xmath2 .",
    "if there is more than one such segment , then we take an arbitrary such segment as @xmath136 . by a similar analysis as that above and that in @xcite",
    ", we can show that the total increase in the number of left bounding @xmath130-edges is at most five .",
    "we omit the details .",
    "we conclude that there are @xmath142 @xmath130-edges and @xmath143 @xmath129-edges in the zone @xmath18 .",
    "the lemma thus follows .",
    "in this paper , we propose two new data structures for the weak visibility query problem on a simple polygon , which improve upon the previous work @xcite .",
    "some results ( e.g. , the ray - rotating data structure and the zone theorem ) may be of independent interest .    for the @xmath3 time queries , our first data structure is clearly optimal . for the @xmath7 time query",
    ", however , an open question is whether a data structure of sub - cubic preprocessing time and space is possible ."
  ],
  "abstract_text": [
    "<S> given a simple polygon @xmath0 in the plane , we present new algorithms and data structures for computing the weak visibility polygon from any query line segment in @xmath0 . </S>",
    "<S> we build a data structure in @xmath1 time and @xmath1 space that can compute the visibility polygon for any query line segment @xmath2 in @xmath3 time , where @xmath4 is the size of the visibility polygon of @xmath2 and @xmath5 is the number of vertices of @xmath0 . </S>",
    "<S> alternatively , we build a data structure in @xmath6 time and @xmath6 space that can compute the visibility polygon for any query line segment in @xmath7 time . </S>"
  ]
}