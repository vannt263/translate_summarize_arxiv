{
  "article_text": [
    "the total value of any ( consumer ) product can be roughly classified into three parts : physical value , emotional value , and social value @xcite . with the fast development of economy , the basic physical needs of",
    "more and more consumers are easily met .",
    "consequently , people increasingly shift their attention to emotional and social values when they consider whether to buy a product .",
    "in particular , the social value , whose amount is not determined by what a consumer consumes alone or how she personally enjoys it , but by the comparisons with what other people around her consume , is becoming a more and more crucial ingredient for both consumer purchase and therefore seller marketing . for many products , whether they will be welcome depends mainly on how much social value they can provide to the consumers .",
    "this is especially true for fashionable and luxury goods , where the products often exhibit _ negative _ ( _ consumption _ )",
    "_ externalities _  they become less valuable as more people use them @xcite .    the comparison that a consumer makes , for calculating the social value of a product ,",
    "is naturally restricted to her neighbors in the social network . for a consumer ,",
    "the social value of a product with negative externality is often proportional to the number of her neighbors who do not consume this product @xcite . in the market",
    ", the purchase decisions of a consumer often depend on the values of the products at the time they are promoted  the product of larger value will be selected .",
    "in contrast to the physical and emotional values , which are relatively fixed , the social values of products vary with different marketing schedules .",
    "the goal of this paper is to design good marketing schedules for promoting products with negative externalities in social networks .",
    "* motivation and related work*our study is motivated by the practical marketing problem concerning how to bring the products to consumers attention over time . among a large literature on diffusion of competing products or opinions in social networks ( see e.g. , @xcite and references therein ) , chierichetti , kleinberg and pancones @xcite recently studied the scheduling aspect of the diffusion problem on two products  finding an order of consumer purchase decision making to maximize the adoption of one product . in their model , the two competing products both have positive ( consumption ) externalities and every consumer follows the majority of her social network neighbors when the externalities outweigh her own internal preference .",
    "the authors @xcite provided an algorithm that ensures an expected linear number of favorable decisions .",
    "the network - related consumption externalities have been classified into four categories @xcite .",
    "comparing to the other three , the negative cross - consumer externality , as considered in this paper , has been far less studied @xcite , and was emphasized for its importance in management and marketing nowdays @xcite .    the model studied in this paper",
    "can also be taken as an extension of one side of _ the fashion game _ , which was formulated by jackson @xcite .",
    "very interestingly , people often have quite different , in fact almost opposite , opinions on what is fashionable , e.g. , `` lady gaga is godness of fashion '' vs `` this year s fashion color is black '' .",
    "following jackson , we call consumers holding the former `` personality reflection '' idea of fashion _ rebels _ and the latter `` prevailing style '' idea _ conformists_. more generally , a consumer behaves like a rebel ( conformist ) if the product , from her point of view , has negative ( positive ) externality . in an era emphasizing personal identities , more and more consumers would like to be rebels . for example , they would prefer asian - style pants , when seeing many friends and colleagues ( their social network neighbors ) wearing european - style .",
    "however , the rebel social network is still under - researched in comparison with vast literature on conformist social networks . for a market",
    "where all the consumers are rebels , as considered in this paper , it has been previously studied by several papers under the term of anti - coordination @xcite .",
    "* model formulation*the market is represented by a social network @xmath0 , an undirected graph with node set @xmath1 consisting of @xmath2 consumers and link set @xmath3 of @xmath4 connections between consumers .",
    "a seller has two ( types of ) products @xmath5 and @xmath6 with similar functions . we abuse notations by using @xmath5 and @xmath6 to denote both types and products .",
    "the marketing is done sequentially : the seller is able to ask the consumers one by one whether they are more interested in @xmath5 or in @xmath6 .",
    "each consumer buys ( chooses ) exactly one of @xmath5 and @xmath6 , whichever provides her a larger total value , only at the time she is asked .",
    "this is a simplification of the so called _ precision marketing _ @xcite . for every consumer ,",
    "a product of type @xmath7 provides her with total value @xmath8 , where @xmath9 is the sum of physical and emotional values , and @xmath10 is the social value determined by decreasing function @xmath11 and the number @xmath12 of her neighbors who have bought product @xmath13 .",
    "we assume that @xmath5 is very similar to @xmath6 with @xmath14 and the externality outweighs the physical and emotional difference , i.e. , for any permutation @xmath15 of @xmath16 and any nonnegative integers @xmath17 ( @xmath18 ) we have @xmath19 .",
    "actually , the above model can be summarized as the following scheduling problems on rebel social networks .",
    "_ at her turn to choose from @xmath20 , will buy the product different from the one currently possessed by the majority of her neighbors .",
    "if there are equal numbers of neighbors having bought @xmath5 and @xmath6 respectively , the consumer will always buy @xmath5 .    _",
    "scheduling._a ( marketing ) _ schedule _",
    "@xmath21 , for network @xmath22 is an ordering of consumers in @xmath1 which specifies the order @xmath23 of consumer @xmath24 being asked to buy ( choose ) @xmath5 or @xmath6 , or `` being scheduled '' for short .",
    "we refer to the problem of finding a schedule for a rebel social network as the _ rebel scheduling problem_. given schedule @xmath21 , the choice ( purchase _ decision _ ) of each consumer @xmath25 under @xmath21 is uniquely determined , and we denote it by @xmath26 $ ] , which belongs to @xmath20 .",
    "the decisions of all consumers form the marketing _ outcome _",
    "v)$ ] of @xmath21 .",
    "the basic goal of the rebel scheduling problem is to find a schedule whose outcome contains @xmath5 ( resp .",
    "@xmath6 ) decisions as many as possible because @xmath5 ( resp .",
    "@xmath6 ) is more profitable for the seller .",
    "_ equilibrium._as seen above , the value of a product changes as the marketing proceeds .",
    "every schedule corresponds to a dynamic game among consumers .",
    "we assume that consumers behave naively without predictions .",
    "a natural question is : can these simple behaviors ( or equivalently , a schedule ) eventually lead to a nash equilibrium  a state where no consumer regrets her previous decision ?",
    "this question is of both theoretical and practical interests .",
    "schedules that lead to nash equilibria are called _ regret - proof _ ; they guarantee high consumer satisfaction , which is beneficial to the seller s future marketing .    *",
    "results and contribution*we prove that it is np - hard to find a marketing schedule that maximizes the number of @xmath5 ( resp .",
    "@xmath6 ) decisions .",
    "complementary to the np - hardness , we design @xmath28-time algorithms for finding schedules that guarantee at least @xmath29 decisions of @xmath5 , and at least @xmath30 decisions of @xmath6 , respectively . the numbers @xmath29 and @xmath30 are best possible for any algorithm .",
    "let @xmath31 denote the size of maximum independent set of @xmath22 .",
    "we show that regret - proof schedules that guarantee at least @xmath29 decisions of @xmath5 and at least @xmath32 decisions of @xmath6 , respectively , can be found in time @xmath33 .",
    "in contrast , decentralized consumer choices without a schedule might result in an arbitrarily worse outcome .",
    "this can be seen from the star network , where in the worst case only one consumer chooses the product consistent with the seller s objective .    to the best of our knowledge",
    ", this paper is the first attempt to address the scheduling problems for marketing products with negative externalities ( i.e marketing in rebel social networks ) . our algorithms for maximizing the number of @xmath5 decisions",
    "can be extended to deal with the case of promoting one product where @xmath5 and @xmath34 are interpreted as buying and not buying , respectively .",
    "we study the rebel scheduling problem to maximize seller s profits in subsections [ sec : maxy ] and [ sec : maxn ] , respectively , for the cases of @xmath5 and @xmath6 having higher net profits .    throughout",
    "we consider @xmath0 a connected rebel social network for which we have @xmath35 .",
    "all results can be extended to any network without isolated nodes .",
    "let @xmath21 be a schedule for @xmath22 , and @xmath36 .",
    "we say that @xmath21 schedules @xmath24 with decision @xmath26\\in\\{\\mathcal y,\\mathcal n\\}$ ] , and @xmath21 schedules @xmath37 before @xmath25 if @xmath38 .",
    "it is desirable to find an optimal schedule that maximizes the number of consumers purchasing @xmath5 .",
    "although this turns out to be a very hard task ( theorem [ yhard ] ) , we can guarantee that at least half of the consumers choose @xmath5 ( theorem [ lem ] ) .",
    "[ yhard ] the rebel scheduling problem for maximizing the number of @xmath5 decisions is np - hard .",
    "we prove by reduction from the _ maximum independent set problem_. given any instance of the maximum independent set problem on connected graph @xmath39 , by adding some pendant nodes to @xmath40 we construct in polynomial time a network @xmath22 ( an instance of the rebel scheduling problem ) : for each node @xmath41 with degree @xmath42 in @xmath40 , we add a set @xmath43 of @xmath42 nodes , and connect each of them to @xmath37 .",
    "the resulting network @xmath0 is specified by @xmath44 and @xmath45 , where each node in @xmath46 is _ pendant _ , and each node @xmath41 is _ non - pendant _ and has exactly @xmath47 neighbors : half of them are non - pendant nodes in @xmath48 and the other half are the @xmath42 pendant nodes in @xmath49 .",
    "we associate every schedule @xmath50 for @xmath22 with an integer @xmath51 , equal to the number of pendant nodes which are scheduled ( by @xmath50 ) after their unique neighbors . clearly @xmath52    [ clm1 ] for any @xmath41 and any schedule @xmath21 of @xmath22 , if @xmath21 schedules all nodes in @xmath53 with @xmath5 , then ( all the @xmath42 pendant neighbors of @xmath37 in @xmath43 have to be scheduled before @xmath37 with decisions @xmath5 , therefore ) all the @xmath42 non - pendant neighbors of @xmath37 have to be scheduled with @xmath6 before @xmath37 is scheduled .",
    "consider @xmath21 being an optimal schedule for @xmath22 .",
    "if @xmath54 , then @xmath21 schedules all pendant nodes before their neighbors , and hence all of these pendant nodes choose @xmath5 .",
    "it follows from claim [ clm1 ] that @xmath55=\\mathcal y\\}$ ] is an independent set of @xmath40 .",
    "since @xmath21 is optimal , the independence set is maximum in @xmath40 .",
    "thus , in view of ( [ theta ] ) , to prove the theorem , it suffices to show the following .",
    "[ clm2 ] given an optimal schedule @xmath21 for @xmath22 with @xmath56 , another optimal schedule @xmath57 for @xmath22 with @xmath58 can be found in polynomial time .    since @xmath59",
    ", we can take @xmath60 to be the _",
    "last _ non - pendant node scheduled by @xmath21 earlier than some of its pendant neighbors . under @xmath21 ,",
    "let @xmath61 ( @xmath62 ) be the set of all pendant neighbors of @xmath63 that are scheduled after @xmath63 , let @xmath64 be the set of non - pendant nodes scheduled after @xmath63 , and let @xmath65 be the set of the pendant nodes whose ( non - pendant ) neighbors belong to @xmath64 ( possibly @xmath66 ) .",
    "the choice of @xmath63 implies that @xmath21 schedules every node in @xmath65 before its neighbor . without loss of generality",
    "we may assume that under  @xmath21 ,    * ( pendant ) nodes in @xmath65 are scheduled before all other nodes ( with @xmath5 ) .",
    "* ( pendant ) nodes in @xmath61 are scheduled immediately after @xmath63 one by one . *",
    "( non - pendant ) nodes in @xmath64 are scheduled at last .    if @xmath21 schedules @xmath63 with @xmath6 , then at later time it schedules all pendant nodes in @xmath67 with @xmath5 .",
    "another optimal schedule @xmath57 ( for @xmath22 ) with the same outcome as @xmath21 can be constructed as follows : @xmath57 schedules nodes in @xmath67 first , and then schedules other nodes of @xmath1 in a relative order the same as @xmath21 .",
    "clearly , @xmath57 with @xmath68 is the desired schedule .",
    "it remains to consider the case where @xmath21 schedules @xmath63 with @xmath69=\\mathcal y.   \\end{gathered}\\ ] ] it follows that @xmath70=\\mathcal n$ ] for all @xmath71 .",
    "let @xmath57 be the schedule that first schedules nodes of @xmath72 in a relative order the same as @xmath21 , and schedules @xmath63 finally .",
    "it is clear that @xmath68 and @xmath73=\\mathcal y$ ] for all @xmath71 .",
    "we only need to show that @xmath57 is optimal .",
    "observe that @xmath57 first schedules every @xmath24 satisfying @xmath74 with the same decision as in @xmath21 ( particularly , all nodes in @xmath65 are scheduled with @xmath5 ) .",
    "subsequently , @xmath57 schedules nodes in @xmath61 and @xmath75 in the same relative order as @xmath21 finally @xmath57 schedules @xmath63 .",
    "since all pendant nodes in @xmath76 ( @xmath77 ) are scheduled by @xmath57 with @xmath5 , and by @xmath21 with @xmath6 the optimality of @xmath57 would follow if @xmath57 schedules every node of @xmath64 with the same decision as @xmath21 .",
    "suppose it were not the case .",
    "let @xmath78 be the earliest node in @xmath64 scheduled by @xmath57 with a decision @xmath79 $ ] different from @xmath80 $ ] .",
    "it must be the case that @xmath63 is a non - pendant neighbor of @xmath37 and @xmath81\\ne\\pi[u]$ ] . at the time @xmath57",
    "schedules @xmath37 , all pendant neighbors of @xmath37 in @xmath82 have been scheduled with @xmath5 and the non - pendant neighbor @xmath63 has not been scheduled , it follows from claim [ clm1 ] that @xmath79=\\mathcal n$ ] . as @xmath80\\ne\\pi'[u]$ ] and @xmath81\\ne\\pi[u]$ ] , we have @xmath81=\\pi'[u]=\\mathcal n$ ] , a contradiction to ( [ y ] ) .",
    "the optimality of @xmath57 is established , which proves claim  [ clm2 ] and therefore theorem  [ yhard ] .",
    "we next design an algorithm for finding a schedule that ensures at least @xmath29 decisions of @xmath5 .",
    "the algorithm iteratively constructs a node set @xmath83 for which there exist two schedules @xmath57 and @xmath84 scheduling each node in @xmath83 with different decisions . in the end , at least half nodes of @xmath83 can be scheduled by either @xmath57 or @xmath84 with @xmath5 decisions .",
    "subsequently , the nodes outside @xmath83 , which form an independent set , will all choose @xmath5 ( in an arbitrary order ) .",
    "[ al1 ] _ input _ : network @xmath0 .",
    "_ output _ : partial schedule @xmath21 for @xmath22 .    ' '' ''    1 .",
    "initial setting : @xmath85 , @xmath86 a null schedule 2 .",
    "* while * @xmath87 @xmath88 which has different numbers of neighbors in @xmath83 choosing @xmath5 and @xmath6 respectively under @xmath57 * do * [ findnode ] 3 .",
    "@xmath89 , @xmath90;[schedulenode ] + @xmath91 , @xmath92 4 .   * end - while*[endnode ] 5 .   *",
    "if * @xmath87 @xmath93 with @xmath94 [ findedge ] + @xmath95;[scheduleedge ] + @xmath96 , @xmath97 ; + go back to step [ findnode ] .",
    "let @xmath21 be @xmath57 or @xmath84 whichever schedules more nodes with @xmath5 ( break tie arbitrarily ) [ takebetter ] +    ' '' ''    for convenience , we reserve symbol `` schedule '' for the scheduling ( constructing @xmath21 and @xmath84 ) as conducted at steps [ schedulenode ] and [ scheduleedge ] in algorithm [ al1 ] .",
    "similarly , we also say `` schedule a node '' and `` schedule an edge '' with the implicit understanding that the node and the edge satisfy the conditions in step [ findnode ] and step [ findedge ] of algorithm  [ al1 ] .",
    "[ clm3 ] @xmath98=\\mathcal y$ ] if and only if @xmath99=\\mathcal n$ ] for all @xmath100 .",
    "the algorithm enlarges @xmath83 gradually at steps [ schedulenode ] and [ scheduleedge ] , producing a sequence of node sets @xmath101 , @xmath102 ,  , @xmath103 .",
    "we prove by induction on @xmath104 that @xmath105 if and only if @xmath106 for all @xmath107 , @xmath108 . the base case of @xmath109 is trivial .",
    "suppose that @xmath110 and the statement is true for @xmath111 . in case of @xmath112 being produced at step [ findnode ] , suppose @xmath63 has @xmath113 ( resp .",
    "@xmath114 ) neighbors in @xmath111 choosing @xmath5 ( resp .",
    "@xmath6 ) under @xmath57 . by hypothesis",
    ", @xmath63 has @xmath113 ( resp .",
    "@xmath114 ) neighbors in @xmath111 choosing @xmath6 ( resp .",
    "@xmath5 ) under @xmath84 . since @xmath115",
    ", we see that @xmath116=\\mathcal y$ ] if and only if @xmath117=\\mathcal n$ ] . in case of @xmath112 being produced at step [ scheduleedge ] ,",
    "both @xmath37 and @xmath25 have equal number of neighbors in @xmath111 choosing @xmath5 and @xmath6 , respectively , under @xmath57 , due to the implementation of the while - loop at steps [ findnode][endnode ] . by hypothesis",
    "both @xmath37 and @xmath25 have equal number of neighbors in @xmath111 choosing @xmath5 and @xmath6 , respectively , under @xmath84 .",
    "it follows from @xmath93 that @xmath79=\\pi''[v]=\\mathcal y$ ] and @xmath98=\\pi''[u]=\\mathcal n$ ] . in either case , the statement is true for @xmath112 , proving the claim .",
    "[ ind ]    at least half nodes of @xmath83 are scheduled by @xmath21 with @xmath5 ( by step [ takebetter ] ) .    the nodes in @xmath118 ( if any ) form an independent set of @xmath22 ( by step [ findedge ] ) .",
    "each node in @xmath118 has an equal number of neighbors in @xmath83 choosing @xmath119 and @xmath6 , respectively , under @xmath57 ( by steps [ findnode][endnode ] ) , and under @xmath84 ( by claim [ clm3 ] ) , and hence under @xmath21 ( by step [ takebetter ] ) .",
    "[ lem ] a schedule that ensures at least @xmath29 decisions of @xmath5 can be found in @xmath28 time .",
    "it follows from claim [ ind](ii ) and ( iii ) that @xmath21 can be extended to a schedule for @xmath22 such that all node in @xmath118 choose @xmath5 . by claim [ ind](i )",
    ", the outcome contains at least @xmath29 decisions of @xmath5 .",
    "next we show the time complexity .",
    "algorithm [ al1 ] keeps an @xmath120 array @xmath121 $ ] , @xmath24 , where @xmath122 represents the difference between the numbers of neighbors of node @xmath25 in @xmath83 choosing @xmath5 and @xmath6 , and @xmath123 represents the number of neighbors of node @xmath25 in @xmath118 .",
    "the initial setting of the array @xmath121=[0,$ ] the degree of @xmath25 in @xmath124 $ ] , @xmath24 , takes @xmath28 time .",
    "step 1 is to find a node @xmath125 with @xmath126 by visiting @xmath122 , @xmath127 .",
    "step [ findedge ] is to find a node @xmath128 with @xmath129 and then find a neighbor @xmath128 of @xmath25 .",
    "the search in both steps [ findnode ] and [ findedge ] takes @xmath130 time .",
    "each time algorithm [ al1 ] adds a node @xmath25 to @xmath83 , the algorithm updates the entries of @xmath25 s neighbors in the array , which takes @xmath130 time .",
    "since we can add at most @xmath2 nodes to @xmath83 , algorithm [ al1 ] terminates in @xmath28 time .",
    "the tightness of @xmath29 in the above theorem can be seen from the case where the network @xmath22 is a complete graph .",
    "moreover , the theorem implies that algorithm  [ al1 ] is a 2-approximation algorithm for the rebel scheduling problem for maximizing @xmath5 decisions .",
    "[ rm ] it is worth noting that algorithm  [ al1 ] can be used to solve the scheduling problem when only one product is promoted , where a consumer buys the product only if at least a half of her neighbors do not have the product . given a schedule @xmath21 output by algorithm [ al1 ]",
    ", @xmath21 specifies an order of consumers who choose @xmath5 .",
    "all these consumers will buy the product if the seller promotes the product to them according to this order .",
    "a wheel is graph obtained from a cycle by adding a node and joining it with all other nodes .",
    "the approximation ratio of algorithm [ al1 ] is @xmath131 .",
    "let @xmath22 be a wheel on @xmath2 @xmath132 nodes .",
    "algorithm [ al1 ] might outputs a scheduling with at least @xmath133 @xmath6 decisions .",
    "the optimal schedule produces only two @xmath6 decisions .",
    "the conclusion follows from lemma  [ lem ] .    for wheel @xmath134 on @xmath2 nodes , running algorithm [ al1 ] @xmath6 times with different choices of @xmath135 at step 2 finds an optimal solution .",
    "but the situation will be more complicated , if we consider the following graph @xmath22 .",
    "suppose @xmath136 is an odd number .",
    "let @xmath22 be obtained from @xmath137 disjoint copies of @xmath138 ( whose rim are ordered cyclicly ) by joining the first and second vertices of the @xmath104-th copy of @xmath138 with the @xmath139-th vertex of the @xmath140-th copy of @xmath138 , @xmath141 .",
    "* @xmath142 .",
    "* how can we prevent algorithm [ al1 ] from outputting a schedule with the number of @xmath5 decision far from @xmath143 ?",
    "it seems that we have to take specific graphical structure into account .",
    "we call a graph with all odd degrees an _ odd _ graph .",
    "the number of vertices in a graph is the order of the graph .",
    "given graph @xmath22 , let @xmath144 denote the independence number of @xmath22 , and let @xmath145 denote the maximum order of the induced odd subgraphs of @xmath22 .",
    "scott @xcite showed that @xmath146 provided @xmath22 is connected .",
    "for any connected graph @xmath0 on @xmath2 nodes , there is a schedule of @xmath22 which makes at least @xmath147 nodes select @xmath6 .",
    "suppose algorithm [ al1 ] ends with @xmath83 of @xmath104 vertices . in case of @xmath148 ,",
    "we are done by choosing either @xmath21 or @xmath57 . in case of @xmath149",
    ", we see that @xmath118 is an independent set of size at least @xmath150 and therefore @xmath151 .",
    "let @xmath40 be an induced odd subgraph of @xmath22 of order @xmath145 .",
    "since @xmath40 is odd , algorithm [ al1 ] can schedule vertices in @xmath40 before all other vertices ( in @xmath152 ) and end with @xmath153 .",
    "again @xmath154 implies the result .      in this subsection ,",
    "the marketing scheduling is to maximize the number of @xmath155 decisions . by reduction from the _",
    "bounded occurrence max-2sat _ problem ( see appendix [ ap : a ] ) , we obtain the following np - hardness .",
    "[ maxn ] the rebel scheduling problem for maximizing the number of @xmath6 decisions is np - hard .",
    "next , we design a @xmath156-approximation algorithm for finding in @xmath28 time a schedule which ensures at least @xmath30 decisions of @xmath6 .",
    "this is accomplished by a refinement of algorithm [ al1 ] with some preprocessing .",
    "the following terminologies will be used in our discussion . given a graph @xmath40 with node set @xmath64 ,",
    "let @xmath157 be two node subsets .",
    "we say that @xmath158 _ dominates _",
    "@xmath159 if every node in @xmath159 has at least a neighbor in @xmath158 .",
    "we use @xmath160 to denote the graph obtained from @xmath40 by deleting all nodes in @xmath158 ( as well as their incident links ) .",
    "thus @xmath160 is the subgraph of @xmath40 induced by @xmath161 , which we also denote as @xmath162 $ ] .    [",
    "[ preprocessing . ] ] preprocessing .",
    "+ + + + + + + + + + + + + +    given a connected social network @xmath0 , let @xmath163 be any maximal independent set of @xmath22 .",
    "it is clear that    * @xmath163 and @xmath164 are disjoint node sets dominating each other .",
    "we will partition @xmath163 into @xmath165 and @xmath166 into @xmath167 for some positive integer @xmath168 such that algorithm [ al1 ] schedules @xmath169 before @xmath170 for all @xmath171 .    *",
    "set @xmath172 and @xmath173 .",
    "find @xmath174 such that @xmath175 is a _",
    "minimal _ set that dominates @xmath176 ( @xmath177 ) in graph @xmath178 . *",
    "set graph @xmath179 $ ] .",
    "the minimality of @xmath175 implies that in graph @xmath180 every node in @xmath175 is adjacent to at least one pendant node in @xmath176 .",
    "* let @xmath181 consist of all pendant nodes of @xmath180 contained in @xmath176 .    if @xmath182 , then @xmath175 still dominates @xmath183 , and we repeat the above process with @xmath184 , @xmath176 , @xmath175 in place of @xmath178 , @xmath163 , @xmath166 , respectively , and produce @xmath185 , @xmath186 , @xmath187 in place of @xmath188 , @xmath184 , @xmath189 .",
    "inductively , for @xmath190 , given graph @xmath191 $ ] , where @xmath192 is a minimal set dominating @xmath193 , and @xmath194 the set of all pendant nodes of @xmath195 contained in @xmath196 , when @xmath197 , we can    * find @xmath198 such that @xmath199 is a _",
    "minimal _ set that dominates @xmath200 in graph @xmath195 . *",
    "set graph @xmath201 $ ] .",
    "* let @xmath202 consist of all pendant nodes of @xmath203 that are contained in @xmath204 .",
    "the procedure terminates at @xmath205 for which we have @xmath206 , and    @xmath207 $ ] for @xmath208 ; in particular @xmath172 .",
    "note that @xmath209 for @xmath210 , @xmath175 is the disjoint union of @xmath211 , and @xmath163 is the disjoint union of @xmath212 .",
    "the minimality of @xmath213 implies that in graph @xmath214 every node in @xmath215 is adjacent to at least one pendant node in @xmath194 .",
    "[ clm7 ] for any @xmath210 , in the subgraph @xmath195 , all nodes in @xmath216 are pendant , and every node in @xmath217 is adjacent to at least one node in @xmath194 .",
    "[ [ refinement . ] ] refinement .",
    "+ + + + + + + + + + +    next we show that algorithm [ al1 ] can be implemented in a way that all nodes of subgraph @xmath184 are scheduled .",
    "if the implementation has led to at least @xmath30 decisions of @xmath6 , we are done ; otherwise , due to the maximality of the independent set @xmath163 , we can easily find another schedule that makes at least @xmath30 nodes choose @xmath6 .",
    "[ al2 ] _ input _ : network @xmath0 together with @xmath218 , @xmath219 .",
    "_ output _ : partial schedule @xmath21 for @xmath22 .    ' '' ''    1 .",
    "initial setting : @xmath220 2 .   * for * @xmath205 * downto * 0 * do * 3 .",
    "* while * in the subgraph @xmath195 , @xmath87 @xmath221 which has different numbers + of neighbors in @xmath83 choosing @xmath5 and @xmath6 respectively * do * [ stp2 ] 4 .   ; @xmath222[schedulew ] 5 .    6 .    7 .   ; @xmath96 ; go back to step [ stp2].[stp3 ] 8 .",
    "* end - for * 9 .",
    "let @xmath21 be a schedule for @xmath223 $ ] that schedules at least @xmath224 nodes with @xmath6[output ] +    ' '' ''    the validity of step [ output ] is guaranteed by claim [ clm3 ] .",
    "since @xmath225 , the following claim implies @xmath226 .",
    "[ contain ] @xmath227 .",
    "we only need to show that each node @xmath228 @xmath229 is selected to @xmath83 when @xmath230 in algorithm [ al2 ] .    in case of @xmath231 ,",
    "it is pendant and has only one neighbor @xmath37 in subgraph @xmath232 .",
    "if @xmath233 when @xmath63 is checked at step [ stp2 ] , then @xmath63 is selected to @xmath83 at step [ schedulew ] ; otherwise , @xmath63 and @xmath37 will be selected to @xmath83 at the same time in step [ stp3 ] .    in case of @xmath234 , by claim",
    "[ clm7 ] , @xmath63 is adjacent to a pendant node @xmath235 of @xmath232 . if , when checked at step [ stp2 ] , @xmath63 has different numbers of neighbors in @xmath83 choosing @xmath5 and @xmath6 , then it is selected to @xmath83 at step [ schedulew ] ; otherwise , node @xmath25 must have not been selected to @xmath83 , and subsequently @xmath63 and @xmath25 are put into @xmath83 together at step  [ stp3 ] .    if @xmath236 , then , by extending partial schedule @xmath21 output by algorithm [ al2 ] , we obtain a schedule which makes at least @xmath30 nodes choose @xmath6",
    "otherwise , @xmath237 , and all nodes in @xmath118 can be scheduled with @xmath6 as follows : schedule firstly the nodes in the maximal independent set @xmath163 ( all of them choose @xmath5 ) ; secondly the nodes in @xmath118 , and finally all the other nodes .",
    "recall that @xmath163 dominates every node in @xmath238 .",
    "it follows from claim [ contain ] that @xmath163 dominates @xmath118 . as @xmath118 is an independent set in @xmath22 ( by claim [ ind](ii ) ) , the decisions of all nodes in @xmath118 are @xmath239 .",
    "we show in appendix [ ap : b ] that algorithm [ al2 ] runs in square time , which implies the following .",
    "a schedule that ensures at least @xmath30 decisions of @xmath6 can be found in @xmath28 time.[th4 ]    the tightness of @xmath30 can be seen from a number of disjoint triangles linked by a path , where each triangle has exactly two nodes of degree two .",
    "we are to find regret - proof schedules , where every consumer , given the choices of other consumers in the outcome of the schedule , would prefer the product she bought to the other . using link cuts as a tool , we design algorithms for finding regret - proof schedules that ensure at least @xmath29 decisions of @xmath5 and at least @xmath240 decisions of @xmath6 , respectively .      given @xmath0 , let @xmath158 and @xmath159 be two disjoint subsets of @xmath1 .",
    "we use @xmath241 $ ] to denote the set of links ( in @xmath3 ) with one end in @xmath158 and the other in @xmath159 .",
    "if @xmath242 , we call @xmath241 $ ] a _ link cut _ or simply a _ cut_. for a node @xmath24 , we use @xmath243 to denote the number of neighbors of @xmath25 contained in @xmath159 .",
    "_ each schedule @xmath21 for @xmath22 is associated with a cut @xmath244 $ ] of @xmath22 _ defined by its outcome : @xmath245 ( resp .",
    "@xmath246 ) is the set of consumers scheduled with @xmath5 ( resp .",
    "@xmath6 ) .",
    "a schedule @xmath21 is _ regret - proof _ if and only if its associated cut @xmath244 $ ] is _ stable _ , i.e. , satisfies the following conditions : @xmath247 note that @xmath245 and @xmath246 are asymmetric . for clarity ,",
    "we call @xmath245 the _ leading set _ of cut @xmath244 $ ] .",
    "any node that violates ( [ stable ] ) is called _ violating _ ( w.r.t .",
    "@xmath244 $ ] ) .",
    "a basic operation in our algorithms is `` enlarging '' unstable cuts by moving `` violating '' nodes from one side to the other .",
    "let @xmath244 $ ] be an unstable cut of @xmath22 for which some @xmath248 ( @xmath249 or 2 ) is violating .",
    "we define _",
    "type_-@xmath250 _ move _ of @xmath25 ( from @xmath251 to @xmath252 ) to be the setting : @xmath253 , @xmath254 , which changes the cut .",
    "the violation of ( [ stable ] ) implies    type-@xmath255 move increases the cut size , and downsizes the leading set ;    type-@xmath131 move does not decrease the cut size , and enlarges the leading set .",
    "both types of moves are collectively called _ moves_. note that moves are only defined for violating nodes , and the cut size @xmath256|$ ] is nondecreasing under moves . to find a stable cut , our algorithms work with a cut @xmath244 $ ] of @xmath22 and change it by moves sequentially . by ( m1 ) and ( m2 ) , the number @xmath257 of type-@xmath255 moves is @xmath258 .",
    "moreover , we have the following observation .    [ movement ]    from any given cut of size @xmath259",
    ", @xmath260 moves produce a stable cut ( i.e. , a cut without violating nodes ) of of size at least @xmath261 .",
    "if the leading set of the stable cut produced is smaller than that of the given cut , then the number of type-2 moves is smaller than that of type-1 moves .    as a byproduct of ( m1 ) and ( m2 ) , one can easily deduce that the rebel game on a network , where each rebel switches between two choices in favor of the minority choice of her neighbors , is a potential game and thus possesses a nash equilibrium .",
    "the potential function is defined as the size of the cut between the rebels holding different choices .",
    "the following data structure is employed for efficiently identifying violations as well as verifying the stability of the cut . for given cut @xmath244 $ ] ,",
    "we create in @xmath258 time a @xmath131-dimensional array @xmath262 , @xmath24 , of length @xmath2 , where @xmath263 is the set index satisfying @xmath264 , and @xmath265 together with @xmath266 is the indicator of whether @xmath25 is violating .",
    "a node @xmath25 is violating if and only if @xmath267 when @xmath268 or @xmath269 when @xmath270 .",
    "therefore , in @xmath130 time we can find a violating node @xmath25 ( if any ) and move it . after the move",
    ", we update the array ( to be the one for the current cut ) in @xmath130 time by modifying the entries corresponding to @xmath25 and its neighbors . without consideration of the @xmath258 time creation of the array",
    ", we have the following lemma .    [ timen ] in @xmath130 time",
    ", either the current cut is verified to be stable , or a move is found and    the following procedure , as a subroutine of our algorithm , finds a stable cut whose leading set contains at least half nodes of @xmath22 .",
    "[ proc:2 ] _ input _ : cut @xmath244 $ ] of @xmath22 .",
    "_ output _ : stable cut @xmath271:=\\text{\\sc prc\\ref{proc:2}}(s_1,s_2)$ ]    ' '' ''    1 .",
    "* repeat * 2 .",
    "@xmath272 * then * @xmath244\\leftarrow [ s_2,s_1]$ ] [ swap ] 3 .",
    "* while * @xmath87 violating node @xmath273 w.r.t .",
    "@xmath244 $ ] * do * move @xmath25[findviolation ] [ while ] 4 .   * until * @xmath274 [ until ] 5 .",
    "return @xmath271\\leftarrow [ s_1,s_2]$ ] +    ' '' ''    [ lem2 ] procedure [ proc:2 ] produces in @xmath275 time a stable cut @xmath271 $ ] of @xmath22 such that @xmath276 , where @xmath277| - |[s_1,s_2]|\\ge0 $ ] .",
    "it follows from lemma [ movement](i ) that there are a number @xmath278 ( @xmath279 ) of type-1 moves in total , and @xmath280|\\ge|[s_1,s_2]|+m'_1 $ ] . by lemma [ timen ]",
    ", it suffices to show that there are a total of @xmath281 moves .",
    "observe from step [ swap ] that each ( implementation ) of the while - loop at step [ while ] starts with a cut whose leading set has at least @xmath29 nodes .",
    "if this while - loop ends with a smaller leading set , by lemma [ movement](ii ) it must be the case that the while - loop conducts type-1 moves more times than conducting type-2 moves . therefore after @xmath282 moves , the procedure either terminates , or implements a while - loop that ends with a leading set @xmath245 not smaller than one at the beginning of the while - loop . in the latter case ,",
    "the until - condition at step  [ until ] is satisfied , and the procedure terminates .",
    "the number of moves conducted by the last while - loop is @xmath281 as implied by lemma  [ movement](i ) .",
    "when @xmath5 is more profitable , the basic idea behind our algorithms for finding regret - proof schedules goes as follows : given a stable cut @xmath244 $ ] , we try to schedule nodes in @xmath245 with @xmath5 and nodes in @xmath246 with @xmath6 whenever possible .",
    "if not all nodes can be scheduled this way , we obtain another stable cut of larger size , from which we repeat the process . in the following pseudo - code description ,",
    "scheduling an _ unscheduled _ node changes the node to be _",
    "scheduled_.    [ al4 ] _ input _ : cut @xmath283 $ ] of network @xmath22 .",
    "_ output _ : a schedule for @xmath22    ' '' ''    1 .",
    "initial setting : @xmath284 , @xmath285 ; @xmath286 , @xmath287 ( @xmath288 ) 2 .   * repeat * 3 .",
    "[ s1s2 ] 4 .   set all nodes of @xmath22 to be unscheduled 5 .   *",
    "while * @xmath87 unscheduled @xmath289 ( @xmath290 ) whose decision is @xmath291 * do * schedule @xmath25[sv ] 6 .",
    "[ ti ] 7 .",
    "* until * @xmath292 [ untils ] 8 .",
    "output the final schedule for @xmath22 +    ' '' ''    note that cuts @xmath244 $ ] returned by procedure [ proc:2 ] at step [ s1s2 ] are stable . at the end of step [ ti ] , if @xmath292 , then @xmath293 ( otherwise , every node @xmath294 satisfies @xmath295 , saying that @xmath244 $ ] is not stable . ) thus the condition in step [ untils ] is equivalent to saying `` until all nodes of @xmath22 are scheduled '' .",
    "[ the ] algorithm [ al4 ] finds in @xmath33 time a regret - proof schedule with at least @xmath29 decisions of @xmath5 .",
    "consider step [ ti ] setting @xmath296 . since nodes in @xmath297 can not be scheduled , we have @xmath298 for every @xmath299 and @xmath300 for any @xmath301 , which gives @xmath302|-|[s'_1,t_2]|)+(|[s'_2,t_2]|-|[s'_2,t_1]|)\\\\ & = & |[s'_1\\cup t_2,s'_2\\cup",
    "t_1]|-|[s_1'\\cup t_1,s_2'\\cup t_2]|.\\end{aligned}\\ ] ] thus cut @xmath303 $ ] has its size @xmath304|=|[s_1,s_2]|$ ] .",
    "subsequently , at step [ s1s2 ] , with input @xmath303 $ ] , procedure  [ proc:2 ] returns a new cut @xmath244 $ ] , of size at least @xmath137 , which is larger than the old one .",
    "it follows that the repeat - loop can only repeat a number @xmath305 ( @xmath279 ) of times . by lemma [ lem2 ] , for @xmath306",
    ", we assume that procedure [ proc:2 ] in the @xmath250-th repetition ( of steps [ s1s2][ti ] ) returns in @xmath307 time a cut whose size is @xmath308 larger than the size of its input .",
    "then @xmath309 , and overall step [ s1s2 ] takes @xmath310 time .",
    "the overall running time follows from the fact that @xmath28 time is enough for finishing a whole while - loop at step [ sv ] .",
    "note from lemma [ lem2 ] that the final cut @xmath244 $ ] produced by procedure [ proc:2 ] is stable and satisfies @xmath274 .",
    "since @xmath244 $ ] is the cut associated with the final schedule output , the theorem is proved .",
    "similar to remark [ rm ] , the output of algorithm  [ al4 ] specifies a regret - proof schedule for marketing one product such that at least a half of consumers buy the product .      the goal of this subsection is to design an algorithm for finding a regret - proof schedule with as many @xmath6 decisions as possible . in the following algorithm [ al5 ] , we work on a dynamically changing cut @xmath244 $ ] of @xmath22 whose size keeps nondecreasing .",
    "our algorithm consists of 2-layer nested repeat - loops .    *",
    "_ inner loop _ : from any @xmath244 $ ] , by moving violating nodes , we make it stable .",
    "then we try to schedule nodes in @xmath245 with @xmath5 and nodes in @xmath246 with @xmath6 whenever possible .",
    "if not all nodes can be scheduled , we reset @xmath244 $ ] to be a larger cut , and repeat ; otherwise we obtain a schedule with associated cut @xmath244 $ ] . * _ outer loop _ :",
    "after obtaining a schedule , we swap @xmath245 and @xmath246 , and repeat . * _ termination _ : we stop when we obtain ( consecutively ) two schedules whose associated cuts have equal size . * _ output _ : among the obtained schedules , we output the best one with a maximum number of @xmath6 decisions    in the following pseudo - code , we use @xmath311 and @xmath259 to denote the sizes of cuts associated with the two schedules we find consecutively . we use @xmath312 to denote the largest number of @xmath6 decisions we currently achieve by some schedule .    [ al5 ] _ input _ : network @xmath22 . : a regret - proof schedule for @xmath22 .    ' '' ''    1 .",
    "@xmath313 , @xmath285 ; @xmath244\\leftarrow$ ] any cut of @xmath22 ; @xmath314 ; @xmath315 2 .",
    "* repeat * 3 .",
    "@xmath316 ; @xmath244\\leftarrow[s_2,s_1]$ ] [ swp ] 4 .",
    "[ inner ] 5 .",
    "* while * @xmath87 violating node @xmath25 w.r.t .",
    "@xmath244 $ ] * do * move @xmath25 [ nonstable ] 6 .   set all nodes of @xmath22 to be unscheduled [ uns ] 7 .   * while * @xmath87 unscheduled @xmath289 ( @xmath290 ) whose decision is @xmath291 * do * schedule  @xmath25[schedulev ] 8 .   [ tis ] 9 .   * if * @xmath317 * then * @xmath244\\leftarrow[s'_1\\cup t_2,s_2'\\cup t_1]$ ] [ reset ] 10 .",
    "@xmath292 [ untilempty ] 11 .",
    "* if * @xmath318 * then * @xmath319 the current schedule , @xmath320[record ] 12 .",
    "@xmath321|$ ] 13 .",
    "* until * @xmath322 [ terminate ] 14 .",
    "+    ' '' ''    throughout the algorithm , the size of @xmath244 $ ] keeps nondecreasing , and may increase at step  [ nonstable ] ( see lemma [ movement ] ) and step [ reset ] .",
    "note that steps [ schedulev ] and [ tis ] are exactly steps [ sv ] and [ ti ] of algorithm [ al4 ] .",
    "so , as shown in the proof of theorem [ the ] , the resetting of @xmath244 $ ] at step [ reset ] increases the cut size .",
    "[ run ] algorithm [ al5 ] runs in @xmath33 time .",
    "an implementation of the inner repeat - loop executes steps [ nonstable]-[reset ] at most @xmath4 times . from the termination condition at step [ terminate ]",
    ", we see that the outer repeat - loop runs @xmath258 times .",
    "furthermore , we may assume that the algorithm implements steps [ nonstable]-[reset ] for a number of @xmath323 times , where the @xmath250-th implementation of step [ nonstable ] ( resp .",
    "step [ reset ] ) increases the cut size by @xmath324 ( resp .",
    "@xmath325 ) , @xmath326 , such that @xmath327 for @xmath328 and @xmath329 . since @xmath330",
    ", we have @xmath331 and @xmath332 . by claim [ movement](i ) , all implementations of step [ nonstable ] perform @xmath333 moves , and thus , by claim [ timen ] , take @xmath33 time . clearly",
    "all implementations of steps [ uns][reset ] finish in @xmath334 time .",
    "the overall implementation time of other steps is @xmath335 .",
    "[ [ performance . ] ] performance .",
    "+ + + + + + + + + + + +    let @xmath336 denote the final common value of @xmath311 and @xmath259 in algorithm  [ al5 ] .",
    "it is easy to see that the algorithm implements step [ nonstable ] at least twice ( as otherwise , @xmath337 ) .",
    "let @xmath338 ( resp .",
    "@xmath339 ) denote the second - last ( resp .",
    "last ) implementation of ( the while - loop at ) step [ nonstable ] .",
    "let @xmath340 $ ] and @xmath341 $ ] denote the cuts @xmath244 $ ] at the end of @xmath338 and @xmath339 , respectively .",
    "it follows that both @xmath340 $ ] and @xmath341 $ ] are stable , and @xmath342|\\le|[l_1,l_2]|=r^*$ ] .",
    "therefore @xmath340|=|[l_1,l_2]|=r^*$ ] , implying that between @xmath338 and @xmath339 , no implementation of step [ reset ] increases the cut size .",
    "after @xmath338 , the algorithm does not change the cut @xmath244=[k_1,k_2]$ ] ( i.e. , it schedules all nodes of @xmath343 with @xmath5 , and all nodes of @xmath344 with @xmath6 ) until it swaps @xmath245 and @xmath246 at step [ swp ] .",
    "subsequently , @xmath345 starts with @xmath346=[k_2,k_1],\\text { where } [ s_2,s_1]=[k_1,k_2]\\text { is stable.}\\end{gathered}\\ ] ] since @xmath339 does not increase the cut size , any violating node @xmath25 satisfies @xmath347 at the time it is moved .",
    "therefore , recalling ( [ stable ] ) , the moves conducted by @xmath345 ( if any ) are type-2 ones , which move nodes from @xmath246 to @xmath245 .",
    "let @xmath348 ( @xmath349 ) denote the set of all these nodes moved .",
    "it is clear that @xmath1 is the disjoint union of @xmath344 , @xmath350 and @xmath348 such that @xmath351=[k_2,l_2\\cup t]$ and $ [ l_1,l_2]=[k_2\\cup t , l_2]$.}\\label{switch}\\end{gathered}\\ ] ] after @xmath345 , the algorithm schedules all nodes of @xmath352 with @xmath5 and all nodes of @xmath350 with @xmath6 , finishing the last run of the inner repeat - loop .",
    "[ transfer ] if @xmath353 , then @xmath348 is an independent set of graph @xmath22 , and @xmath354 holds for every @xmath355 .",
    "suppose on the contrary that two nodes @xmath356 are adjacent , and the while - loop @xmath345 moves @xmath357 earlier than moving @xmath358 ( from @xmath246 to @xmath245 ) . by ( [ start ] )",
    ", at the beginning of @xmath345 , cut @xmath359 $ ] is stable .",
    "therefore @xmath360 holds for all @xmath361 at any time of this while - loop . at the time @xmath345 considers @xmath358 , node @xmath357 has been moved to @xmath245 and @xmath362 .",
    "the adjacency of @xmath357 and @xmath358 implies that @xmath363 and @xmath364 hold before @xmath357 is removed from @xmath246 , which is a contradiction .",
    "so @xmath348 is an independent set .",
    "it follows that throughout the while - loop , @xmath347 holds for any @xmath355 .",
    "moreover , @xmath365 for any @xmath355 follows from the fact that @xmath22 is connected , and @xmath348 is independent .    [ per ] algorithm [ al5 ] finds a regret - proof schedule of @xmath22 that ensures at least @xmath366 decisions of @xmath6 , where @xmath31 is the independence number of @xmath22 .",
    "note that the schedule output by the algorithm has its associated cut stable .",
    "thus the algorithm does output a regret - proof schedule .",
    "suppose the output schedule ensures a number of @xmath104 decisions of @xmath6 . since the algorithm has scheduled all nodes of @xmath344 ( resp .",
    "@xmath350 ) with @xmath6 , step [ record ] guarantees that @xmath367 as @xmath1 is the disjoint union of @xmath368 , and @xmath348 is either empty or an independent set of @xmath22 . it remains to prove @xmath369 .",
    "suppose on the contrary that @xmath370 , saying @xmath371 and @xmath372 .",
    "it follows that @xmath373|\\le|k_2|\\cdot|l_2|\\le \\lambda^2 $ ] and @xmath374 .",
    "notice from claim [ transfer ] that each node of @xmath348 is adjacent to at least one node of @xmath350 , implying @xmath375\\ge|t|>n-2\\lambda$ ] . by ( [ start ] ) and ( [ switch ] )",
    ", the stability of @xmath340=[l_2\\cup t , k_2]$ ] implies that every node @xmath376 satisfies @xmath377 , giving @xmath378\\ge [ t , l_2]$ ] .",
    "hence @xmath379 , implying @xmath380 , a contradiction .",
    "in this paper , we have studied , from an algorithmic point of view , the marketing schedule problem for promoting products with negative externalities , aiming at profit maximization ( from the seller s perspective ) and regret - free decisions ( from the consumers perspective ) .",
    "we have shown that the problem of finding a schedule with maximum profit is np - hard and admits constant approximation .",
    "we find in strongly polynomial time schedules that lead to regret - free decisions .",
    "these regret - proof schedules have satisfactory performance in terms of profit maximization , while it is left open whether both regret - proof - ness and constant profit approximation can be guaranteed in case of product @xmath6 being more profitable .",
    "our model and results apply to marketing one or two ( types of ) products with negative externalities in undirected social networks .",
    "an interesting question is what happens when marketing three or more ( types of ) products and/or the network is directed .",
    "[ [ acknowledgments . ] ] acknowledgments .",
    "+ + + + + + + + + + + + + + + +    the authors are indebted to professor xiaodong hu for stimulating and helpful discussions .",
    "99 t. adachi , third - degree price discrimination , consumption externalities and social welfare , _ economica _ 72 ( 2005 ) 171 - 178 .",
    "k. apt , e. markakis , diffusion in social networks with competing products , in _ proc .",
    "4th international conference on algorithmic game theory _",
    ", pp.212 - 223 , 2011 a. borodin , y. filmus , and j. oren , threshold models for competitive influence in social networks , in _ proc .",
    "6th international workshop on internet and network economics _ , pp.539 - 550 , 2010 y. bramoulle , anti - coordination and social interactions . games and economic behavior , 58 ( 2007 ) 30 - 49 .",
    "z. cao , x. yang , a note on anti - coordination and social interactions , journal of combinatorial optimization .",
    "2012 , online first , doi : 10.1007/s10878 - 012 - 9486 - 7 d.m .",
    "chiang , c. teng , consumption externalities : review and future research opportunities , _ electroinic commerce studies _ 3 ( 2005 ) 15 - 38 .",
    "f. chierichetti , j. kleinberg , a. panconesi , how to schedule a cascade in an arbitrary graph , in _ proc .",
    "13th acm conference on electronic commerce _ , pp.355 - 368 , 2012 s. goyal , m. kearns , competitive contagion in networks , in _ proc .",
    "44th symposium on theory of computing _ , pp.759 - 774 , 2012 .",
    "holcombe , r.s .",
    "sobel , consumption externalities and economic welfare , _ eastern economic journal _ 26 ( 2000)157 - 170 .",
    "jackson , social and economic networks .",
    "princeton university press , princeton , nj , 2008 .",
    "n. van nes , understanding replacement behaviour and exploring design solutions , in _ longer lasting products : alternatives to the throwaway society _ , t. cooper ( ed ) , 2010 .",
    "papadimitriou , m. yannakakis , optimization , approximation , and complexity classes , _ journal of computer and system science _ 43 ( 1991 ) 425 - 440 .",
    "j. zabin , g. brebach .",
    "precision marketing : the new rules for attracting , retaining and leveraging profitable customers .",
    "john wiley & sons , inc . ,",
    "hoboken , 2004 .",
    "we prove the np - hardness of maximizing the number of @xmath6 decisions by reduction from the _ 3-occ - max-2sat _ problem .",
    "it is a restriction of the max-2sat problem , which , given a collection of disjunctive clauses of literals , each clause having at most two literals , and each literal occurring in at most three clauses , is to find a truth assignment to satisfy as many clauses as possible .",
    "it is known that 3-occ - max-2sat is np - hard @xcite .",
    "[ [ construction . ] ] construction .",
    "+ + + + + + + + + + + + +    consider any instance @xmath381 of the 3-occ - max-2sat problem : @xmath48 boolean variables @xmath382 @xmath383 and @xmath384 clauses @xmath385 , @xmath386 , where @xmath387 , @xmath386 .",
    "we construct an instance @xmath0 of the rebel scheduling problem in polynomial time as follows .",
    "* create a pair of _ literal nodes _ @xmath388 and @xmath389 representing , respectively , variable @xmath388 and its negation , @xmath390 ; * create a _ clause node _",
    "@xmath391 representing clause @xmath391 , @xmath386 ; * link literal node @xmath357 with clause node @xmath358 iff literal @xmath357 occurs in clause @xmath358 ; * create a _",
    "@xmath195 for each pair of literal nodes @xmath388 and",
    "@xmath389 , @xmath390 ( see fig .",
    "[ f1 ] ) as follows : let @xmath392 , * * add four groups of nodes , @xmath393 , @xmath394 , @xmath395 , @xmath396 ; * * link @xmath388 and @xmath389 with all @xmath397 nodes in @xmath398 ; * * link @xmath399 and @xmath400 with all nodes in @xmath401 ; * * link @xmath402 with all nodes in @xmath403 for @xmath404 , where @xmath405 .    clearly , @xmath406 .",
    "clause nodes are not contained in any gadget .",
    "each literal node is contained in a unique gadget @xmath195 ; it has exactly @xmath397 neighbors in @xmath195 , and at most 3 neighbors outside @xmath195 , which correspond to the clauses containing it .",
    "each node in @xmath407 has exactly two neighbors @xmath388 and @xmath389 .",
    "each @xmath401 induces a cycle .",
    "all nodes in @xmath408 are pendant .",
    "let @xmath409 denote the optimal value for the 3-occ - max-2sat instance @xmath381 .",
    "let @xmath410 denote the maximum number of @xmath6 decisions contained in the outcome of a schedule for @xmath22 .",
    "we will prove in lemmas [ cl ] and [ ok ] that @xmath411 , which establishes theorem [ maxn ] . under the optimality",
    ", we will show that the literal nodes with @xmath5 decisions in an optimal schedule correspond to true literals in an optimal truth assignment .",
    "the gadget @xmath195 is used to guarantee that exactly one of @xmath388 and @xmath389 chooses @xmath5 .",
    ".,title=\"fig:\",width=415 ] +    [ [ schedule . ] ] schedule .",
    "+ + + + + + + + +    we construct a schedule @xmath21 for @xmath22 under which @xmath409 clause nodes , @xmath48 literal nodes and all @xmath412 nodes in @xmath413 choose @xmath6 , which proves the following lemma .",
    "@xmath414 [ cl ]    let @xmath348 be the set of true literals in an optimal truth assignment of @xmath381 .",
    "then @xmath348 is an independent set of literal nodes in @xmath22 such that for each @xmath390 , exactly one of @xmath388 and @xmath389 is contained in @xmath348 .",
    "the schedule @xmath21 proceeds in two stages .    in the first stage ,",
    "@xmath21 schedules the ( literal ) nodes in @xmath348 and then the @xmath384 clause nodes .",
    "since @xmath348 is independent , all its nodes choose @xmath5 .",
    "therefore , the @xmath409 clause nodes ( which correspond to the satisfied clauses ) all choose @xmath6 . in the second stage ,",
    "@xmath21 schedules gadgets one after another in an arbitrary order . for each gadget @xmath195 ,",
    "let @xmath357 be @xmath388 or @xmath389 whichever belongs to @xmath348 and thus has chosen @xmath5 .",
    "within subnetwork @xmath195 , schedule @xmath21 proceeds in five steps .",
    "( 1 ) @xmath21 schedules the nodes in the independent set @xmath415 first ; obviously these nodes all choose @xmath6 due to their common neighbor @xmath357 .",
    "( 2 ) then @xmath21 schedules @xmath416 , @xmath417 , @xmath418 , @xmath419 in this order .",
    "when @xmath416 is scheduled , she has exactly one neighbor choosing @xmath5 , i.e. , @xmath357 , and two neighbors choosing @xmath6 , i.e. , @xmath420 . therefore @xmath416 chooses @xmath5 .",
    "inductively , for @xmath421 , given @xmath422=\\mathcal y$ ] , when @xmath21 schedules @xmath402 , the node @xmath402 has exactly two neighbors choosing @xmath5 ( i.e. , @xmath423 ) and exactly two neighbors choosing @xmath6 ( i.e. , @xmath420 ) , which implies @xmath424=\\mathcal y$ ] .",
    "( 3 ) next , @xmath21 schedules @xmath425 . at that time",
    ", inside @xmath195 node @xmath425 has exactly @xmath426 neighbors choosing @xmath6 and @xmath427 neighbors choosing @xmath5 ; outside @xmath195 , node @xmath425 has at most 3 neighbors .",
    "it follows that @xmath425 chooses @xmath6 .",
    "( 4 ) now @xmath21 schedules @xmath428 . at this time",
    "@xmath428 has exactly three neighbors choosing @xmath5 ( i.e. , @xmath357 , @xmath419 , @xmath416 ) and exactly three neighbors choosing @xmath6 ( i.e. , @xmath429 ) .",
    "therefore @xmath428 chooses @xmath5 as all other nodes of @xmath401 do .",
    "( 5 ) in the last step , @xmath21 schedules the nodes in @xmath408 , all with decisions @xmath6 .    since @xmath21 schedules each @xmath195 with @xmath430 decisions of @xmath6",
    ", it follows that @xmath21 schedules @xmath22 with @xmath431 decisions of @xmath6 , establishing the lemma .",
    "[ [ assignment . ] ] assignment .",
    "+ + + + + + + + + + +    let @xmath432 be a schedule for @xmath22 that leads to a maximum number @xmath410 of @xmath6 decisions . to establish the reverse inequality of the one in lemma  [ cl ]",
    ", we will construct a truth assignment for @xmath381 based on @xmath432 s schedule of literal node .",
    "notice from lemma [ cl ] , @xmath433 and @xmath434 that @xmath435 .",
    "[ sy ] @xmath432 schedules all @xmath436 nodes in @xmath437 with decision @xmath5 , and therefore ( by the maximality of @xmath410 ) schedules all nodes in @xmath438 after @xmath439 with @xmath6 decisions for any @xmath390 and @xmath404 .    if @xmath432 schedules some @xmath440 with decision @xmath6 , then all the @xmath441 nodes @xmath442 choose @xmath5 under @xmath432 , a contradiction to @xmath443 .",
    "let @xmath444 be the set of literal nodes who choose @xmath5 under @xmath432 .",
    "for each @xmath390 , at most one of @xmath388 and @xmath389 is contained in @xmath444.[ce ]    suppose that @xmath432 schedules some literal node @xmath445 with decision @xmath5 for some @xmath446 .",
    "note that @xmath357 has at most @xmath447 neighbors ; 9 of them belong to @xmath401 and are scheduled by @xmath432 with decisions @xmath5 ( see claim [ sy ] ) .",
    "it must be the case that @xmath432 schedules @xmath357 before the last scheduled node @xmath448 . at the time @xmath432 schedules @xmath449 , by claim [ sy ] , @xmath449 has exactly two neighbors in @xmath401 choosing @xmath5 , and has no neighbor in @xmath408 that has been scheduled .",
    "the other four neighbors of @xmath449 are @xmath450 .",
    "it follows from @xmath451=\\mathcal y$ ] and @xmath452=\\mathcal y$ ] that @xmath432 schedules @xmath425 , @xmath453 and @xmath454 before @xmath449 with decision @xmath6",
    ".    @xmath455 .",
    "[ ok ]    by claim [ ce ] , @xmath456 is the disjoint union of two sets @xmath343 and @xmath457 such that @xmath432 schedules exactly one of @xmath388 and @xmath389 with @xmath6 for every @xmath458 , and schedules @xmath388 and @xmath389 with @xmath6 for every @xmath459 .",
    "note that @xmath460 , @xmath461 and @xmath432 schedules all nodes in @xmath462 with @xmath5 .",
    "define a truth assignment of @xmath381 by setting a literal to be true if and only if it belongs to @xmath463 .",
    "note that any clause node @xmath358 with decision @xmath464=\\mathcal n$ ] must have a neighbor ( which is a literal node ) choosing @xmath5 under @xmath432 .",
    "this neighbor thus belongs to @xmath444 .",
    "thus clause @xmath358 is satisfied by the truth assignment .",
    "it follows that @xmath432 schedules at most @xmath409 clause nodes with @xmath6 . from claim [ sy ]",
    "we deduce that @xmath465 it follows from @xmath466 that @xmath467 .      in appendix",
    "[ ap : a ] , we prove the np - hardness of maximizing the @xmath6 decision in biased rebels scheduling by reduction from the 3-occ - max-2sat problem . in this problem",
    ", each clause has exactly two literals , and each literal occurs in at most three clauses .",
    "it is known that the 3-occ - max-2sat is np - hard @xcite .",
    "this problem is stated formally as follows .",
    "note that for any boolean variable @xmath357 , we use @xmath425 to denote its negation .",
    "( 1,0)335    the 3-occ - max-2sat problem    * input .",
    "* @xmath6 boolean variables : @xmath468 , and @xmath4 clauses , each having two literals : @xmath469 , where @xmath470 , @xmath471 . for each literal @xmath357",
    ", it occurs in at most three clauses",
    ".    * output . * a truth assignment of the @xmath2 variables .",
    "* objective . * maximizing the number of true clauses .",
    "( 1,0)335 +    for any instance @xmath381 of the 3-occ - max-2sat problem @xmath472 , where @xmath473 , @xmath474 , @xmath475 , we construct an instance @xmath476 of the biased scheduling of maximizing @xmath6 problem as follows .",
    "there are @xmath477  key \" nodes , each representing a clause or a literal .",
    "we call the clause nodes @xmath478 , and denote the literal nodes still as @xmath479 .",
    "a clause node is linked with a literal node if and only if the corresponding literal occurs in the corresponding clause .",
    "there are no other links between key nodes .",
    ".,title=\"fig:\",width=453 ] +    the gadget for each pair of @xmath388 and @xmath389 is described in figure [ f1 ] . besides @xmath388 and @xmath389 , there are still four groups of nodes , @xmath480 , @xmath420 , @xmath481 , @xmath482 , @xmath483 .",
    "[ cl ]    to prove the above claim , we show that there exists a schedule satisfying the lower bound .",
    "the schedule proceeds in two stages . in the first stage ,",
    "we schedule the nodes in @xmath348 and then the clause nodes .",
    "since nodes in @xmath348 are independent , they must all choose @xmath5 .",
    "in the second stage , we schedule gadget one by one ( in an arbitrary order ) . for each gadget @xmath195",
    ", we suppose w.l.o.g . that @xmath484 ( otherwise , we can swipe the positions of @xmath388 and @xmath389 , because they are symmetric due to our construction ) . in each gadget",
    ", there are five steps .",
    "( 1 ) we schedule the  a \" nodes and the  b \" nodes first , and obviously they all choose @xmath6 .",
    "( 2 ) then we schedule @xmath485 , @xmath486 , @xmath487 , @xmath488 , and @xmath489 ( in the order as we write ) .",
    "since @xmath485 is neighboring exactly to one @xmath5 ( from @xmath388 ) , and two @xmath6 ( from the two  b \" nodes ) when she makes decision , she will choose @xmath5 .",
    "for @xmath490 , @xmath491 is neighboring exactly to two @xmath5 ( from @xmath388 and @xmath492 ) , and two n ( from the two  b \" nodes ) when she makes decision , we know that she chooses @xmath5 too .",
    "( 3 ) next , we schedule @xmath389 . since for this time she is linked to @xmath312 @xmath6 and @xmath493 @xmath5 , it must choose @xmath6 ( due to the definition of 3-occ - max-2sat and our construction , node @xmath389 has at most three @xmath6 neighbors from the clause nodes ) .",
    "( 4 ) we turn back to the only  c \" node , @xmath494 . because now she has three @xmath6 neighbors ( @xmath399 , @xmath400 and @xmath389 ) and three @xmath5 ones ( @xmath388 , @xmath489 and @xmath485 ) , she will choose @xmath5 too , as all the other  c \" nodes .",
    "( 5 ) in the last step , we schedule all the  d \" nodes , in an arbitrary order . obviously",
    ", they all choose @xmath6 .",
    "it can be calculated that the above schedule has an objective value of at least @xmath495 .",
    "suppose @xmath432 is an optimal schedule to @xmath476 , and @xmath496 is the subset of the literal nodes that choose @xmath5 .",
    "we shall prove the following critical claim .    for each @xmath497 , exactly one of @xmath388 and @xmath389",
    "is contained in @xmath444.[ce ]    using claim [ cl ] , the following two observations can be easily to be true ( note that @xmath312 and @xmath441 are both large ) .",
    "all the  a \" nodes must choose @xmath6 in @xmath432 , and consequently at least one of @xmath388 and @xmath389 chooses @xmath5 .",
    "all the  d \" nodes must choose @xmath6 in @xmath432 , and consequently all the  c \" nodes must choose @xmath5 .",
    "suppose w.l.o.g .",
    "that @xmath388 chooses @xmath5 in @xmath432 .",
    "let @xmath498 be the last  c \" node making decision in schedule @xmath432 .",
    "note first that @xmath499>\\pi^*[c_{i_0}]$ ] can not be true , because otherwise @xmath388 is not able to choose @xmath5 .",
    "so we have @xmath499<\\pi^*[c_{i_0}]$ ] .",
    "now , when @xmath498 makes decision , she has three @xmath5 neighbors ( @xmath388 , @xmath500 and @xmath501 ) , so @xmath389 must make decision before this time and choose @xmath6 .",
    "this justifies claim [ ce ] .",
    "so based on claim [ ce ] , the following claim is obvious and completes the whole proof .",
    "[ [ preprocessing.-1 ] ] preprocessing . + + + + + + + + + + + + + +      to find @xmath503 , @xmath504",
    ", we will modify @xmath40 step by step via removing some nodes ( together with their incident links ) . at any step ,",
    "we call a node of @xmath40 an @xmath163-node ( resp . a @xmath166 node ) if this node belongs to @xmath163 ( resp .",
    "@xmath166 ) . in @xmath40 ,",
    "a @xmath166-node is _ critical _ if it is adjacent to a pendant @xmath163-node .",
    "any single non - critical node can be removed from @xmath40 without destroying the @xmath166-node domination of @xmath163-nodes .",
    "next we show that all the above @xmath509 stages finish in @xmath258 time . at the initiation step , in @xmath258 time we find the set of pendant @xmath163-nodes , and the set of non - critical @xmath166-nodes of @xmath40 , where @xmath510 .      * updating the degrees of all @xmath163-nodes ; * updating the set of pendant @xmath163-nodes ( using the degrees updated ) ; * updating the set of non - critical @xmath166-nodes ( using the pendant @xmath163-nodes created ) .",
    "these can be done in @xmath511 time , where @xmath512 is the degree of @xmath25 in @xmath22 .",
    "thus in the whole process , the removals of @xmath166-nodes and their corresponding update in ( i ) take @xmath513 time .      * updating the set of pendant @xmath163-nodes ( i.e. , setting it to be empty ) ; * updating the set of non - critical @xmath166-nodes ( i.e. , enlarging it by the unique @xmath166-neighbors of the removed @xmath163-nodes ) .      since throughout the process",
    ", we have an updated set of non - critical @xmath166-nodes at hand , at any time , finding a non - critical node of @xmath40 takes @xmath515 time .",
    "the overall running time of ( i ) is @xmath258 , so is that of ( iii ) .",
    "note that all @xmath503 , @xmath516 , are mutually disjoint .",
    "hence , overall , ( ii ) takes @xmath130 time .",
    "recall that @xmath173 .",
    "we have the following results ."
  ],
  "abstract_text": [
    "<S> in marketing products with negative externalities , a schedule which specifies an order of consumer purchase decisions is crucial , since in the social network of consumers , the decision of each consumer is negatively affected by the choices of her neighbors . in this paper , we study the problems of finding a marketing schedule for two asymmetric products with negative externalites . </S>",
    "<S> the goals are two - fold : maximizing the sale of one product and ensuring regret - free purchase decisions . </S>",
    "<S> we show that the maximization is np - hard , and provide efficient algorithms with satisfactory performance guarantees . </S>",
    "<S> two of these algorithms give regret - proof schedules , i.e. they reach nash equilibria where no consumers regret their previous decisions . </S>",
    "<S> our work is the first attempt to address these marketing problems from an algorithmic point of view .    </S>",
    "<S> * keywords : * negative externality , social network , nash equilibrium , efficient algorithm , marketing schedule </S>"
  ]
}