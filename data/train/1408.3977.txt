{
  "article_text": [
    "enumeration of sets satisfying specific properties is a fascinating problem in the field of computing and it has attracted many researchers in the past .",
    "properties looked at in the literature are spanning trees @xcite , minimal vertex separators @xcite , cycles @xcite , maximal independent sets @xcite , etc .",
    "interestingly , these problems find applications in computer networks and circuit analysis @xcite . in this paper",
    ", we revisit enumeration of spanning trees restricted to 2-trees .",
    "the algorithms available in the literature either follow back - tracking approach to list all spanning trees or list spanning trees using fundamental cycles @xcite .",
    "as far as enumeration problems are concerned , asking for a polynomial - time algorithm to enumerate all desired sets is quite unlikely as the number of such sets is exponential in the input size .",
    "interestingly , the results reported in the literature list all spanning trees with polynomial delay between consecutive spanning trees and this is the best possible for enumeration problems . having highlighted the inherent difficulty of enumeration problems , a natural approach to speed up enumeration is to design parallel algorithms wherein more than one tree is listed at a time .",
    "although parallel algorithms have received much attention in the past for other combinatorial problems such as sorting @xcite , planarity testing @xcite , connectivity augmentation @xcite , surprisingly , no parallel algorithm exists for enumeration problems .",
    "most importantly , effective parallelism can be achieved for enumeration problems compared to other combinatorial optimization problems with the help of parallel algorithmics . to the best of our knowledge",
    ", this paper presents the first parallel algorithm for enumeration of spanning trees in 2-trees .",
    "we first present a new sequential algorithm for listing all spanning trees of a 2-tree .",
    "our novel approach is iterative in nature in which spanning trees of @xmath2-vertex 2-tree is generated using spanning trees of @xmath3 vertex 2-tree .",
    "this approach is fundamentally different from the results reported in @xcite .",
    "most importantly , the overall structure of our sequential algorithm can be easily extended to design parallel algorithm for listing all spanning trees of a 2-tree .",
    "in particular , using crew pram model and with the help of @xmath5 processors , we present a parallel algorithm to list all spanning trees in a 2-tree .",
    "we actually present a framework and we believe that this can be extended to @xmath6-trees , chordal graphs and other graphs which have vertex elimination orderings .",
    "our sequential approach looks at enumeration as a two stage process wherein stage-1 enumerates all spanning trees of @xmath2 vertex 2-tree with @xmath7 vertex being a leaf and in stage-2 , it generates all spanning trees where @xmath7 vertex is a non - leaf .",
    "we also highlight that this two stage process naturally yields tight parallelism and we believe that this is the main contribution of this paper .",
    "further , each processor incurs @xmath8 time , linear in the input size to output a tree .",
    "as far as bounds are concerned , cayley s formula @xcite shows that the number of spanning trees of an @xmath2-vertex graph is upper bounded by @xmath9 and this bound is tight for complete graphs .",
    "alternately , we can also get the number using kirchoff s matrix tree theorem @xcite . in this paper , for 2-trees we present a recurrence relation to capture the number of spanning trees of an @xmath2-vertex 2-tree .",
    "our initial motivation was to check whether 2-trees has polynomial number of spanning trees ; however , we show that there are @xmath10 spanning trees in any @xmath2-vertex 2-tree .",
    "moreover , it is this bound that helped us to fix the number of processors while designing parallel algorithms . + * road map : * in section [ sequential ] , we present a new sequential algorithm to list all spanning trees of a 2-tree . our two stage algorithm along with combinatorics is presented in section [ sequential ] . in section",
    "[ parallel ] , we design and analyze parallel algorithm for spanning tree enumeration restricted to 2-trees .",
    "+      notation and definitions are as per @xcite .",
    "let @xmath11 be an undirected connected graph where @xmath12 is the set of vertices and @xmath13 , @xmath14",
    ". for @xmath15 , @xmath16 and @xmath17 refers to the degree of @xmath18 in @xmath1 . for @xmath19 ,",
    "@xmath20 $ ] denotes the graph induced on the set @xmath0 and @xmath21 is the induced graph on the vertex set @xmath22 .",
    "a vertex separator of a graph @xmath1 is a set @xmath23 such that @xmath21 has more than one connected component and @xmath0 is minimal if there does not exist @xmath24 such that @xmath25 is also a vertex separator .",
    "a minimum vertex separator is a minimal vertex separator of least size .",
    "a cycle is a connected graph in which the degree of each vertex is two .",
    "a tree is a connected and an acyclic graph .",
    "a set @xmath23 is a clique if for all @xmath26 and @xmath0 is maximal if there is no clique @xmath27 .",
    "a graph @xmath1 is a 2-tree if every maximal clique in @xmath1 is of size three and every minimal vertex separator in @xmath1 is of size two .",
    "2-trees can be defined iteratively as follows : a clique on 3-vertices ( 3-clique ) is a 2-tree and if @xmath28 is a 2-tree , then the graph @xmath29 obtained from @xmath28 by adding @xmath18 such that @xmath30 is an edge ( 2-clique ) in @xmath28 is also a 2-tree .",
    "an example is shown in figure [ 2tree ] .",
    "a 2-tree @xmath1 also has a vertex elimination ordering which is an ordering @xmath31 such that for any @xmath32 , @xmath33 in the subgraph @xmath28 induced on the set @xmath34 is a 2-clique .",
    "we call such @xmath32 as 2-simplicial and the associated ordering , a 2-simplicial ordering of @xmath1 .",
    "this is a special case of perfect elimination ordering ( peo ) which is an ordering @xmath31 such that for any @xmath32 , @xmath33 in the subgraph @xmath28 induced on the set @xmath34 is a clique .",
    "a graph is chordal if every cycle @xmath35 of length at least 4 has a chord in @xmath35 , an edge joining a pair of non - consecutive vertices in @xmath35 of @xmath1 .",
    "it is well known that chordal graphs have perfect elimination ordering .",
    "we call @xmath33 as the _ higher neighbourhood _ of @xmath32 . note that for a 2-tree , for any @xmath32 , the higher neighbourhood is always a 2-clique ( edge ) . a 2-tree and its 2-simplicial ordering",
    "is illustrated in figure [ 2tree ] .          in this paper",
    ", we work with parallel random access machine ( pram ) model @xcite .",
    "it consists of a set of @xmath2 processors all connected to a shared memory .",
    "the time complexity of a parallel algorithm is measured using @xmath36number of processors @xmath37 time for each processor@xmath38 .",
    "this is also known as processor - time product .",
    "access policy must be enforced when two processors are trying to read / write into a cell .",
    "this can be resolved using one of the following strategies :    * exclusive read and exclusive write ( erew ) : only one processor is allowed to read / write into a cell * concurrent read and exclusive write ( crew ) : more than one processor can read a cell but only one is allowed to write at a time * concurrent read and concurrent write ( crcw ) : all processors can read and write into a cell at a time .    in our work , we restrict our attention to crew pram model . for a problem @xmath39 with input size @xmath40 and @xmath41 processors ,",
    "the speed - up is defined as @xmath42 , where @xmath43 is the time taken by the parallel algorithm on a problem size @xmath40 with @xmath41 ( @xmath44 ) processors and @xmath45 is the time taken by the fastest sequential algorithm ( in this case @xmath46 ) to solve @xmath39 .",
    "the efficiency is defined as @xmath47 .",
    "in this section , we present a new sequential approach for the enumeration of all spanning trees in 2-trees . our new sequential algorithm is iterative in nature and has got three phases . in phase-1 , we obtain a vertex elimination ordering by removing all the 2-simplicial vertices of the 2-tree one by one until we are left with a 3-clique , which is considered to be our base graph .",
    "this will give us the 2-simplicial ordering .",
    "in phase-2 , we construct the spanning trees for our base graph .",
    "since our base graph is a 3-clique , we will get three spanning trees . using these three spanning trees , and with the help of 2-simplicial ordering , in phase-3",
    ", we construct all the other spanning trees iteratively .",
    "in particular , we first consider the last four vertices of the ordering , namely , @xmath48 and enumerate all spanning trees for this set .",
    "using this set and in the next iteration , we generate all spanning trees of the set @xmath49 and so on . in phase-3 , at the beginning of @xmath50 iteration , we have all spanning trees of the 2-tree induced on the set @xmath51 and using this set , we first generate spanning trees of @xmath52-vertex 2-tree with @xmath32 being a leaf , followed by generation of spanning trees where @xmath32 is a non - leaf . an illustration is given in figure [ algotrace ] . +",
    "* trace of algorithm [ mainalgo ] : * fig:1a of figure [ algotrace ] shows a 2-tree on 5-vertices .",
    "the base 2-tree consists of 3-vertices and there are 3-different spanning trees for the base graph which are shown in fig : 2a-2c ; this task is done by line 5 of algorithm [ mainalgo ] .",
    "lines 8 - 11 of algorithm [ mainalgo ] generate the sequence of spanning trees with @xmath53 as a leaf , which are illustrated in fig : 3a-3f .",
    "subsequently , spanning trees with @xmath53 as a non - leaf are generated by lines 12 - 18 , which are illustrated in fig : 4a-4b . in the next iteration , we first generate spanning trees with @xmath54 as a leaf , which are shown in fig : 5a-5p .",
    "finally , fig : 6a-6e illustrate the set of spanning trees in which @xmath54 is a non - leaf .        for a 2-tree @xmath1 , algorithm [ mainalgo ]",
    "lists all spanning trees of @xmath1 .",
    "we present a proof by mathematical induction on @xmath55 .",
    "_ base : _ @xmath56 .",
    "the only 2-tree on 3-vertices is a clique on 3-vertices .",
    "there are exactly three spanning trees and algorithm [ basegraph ] correctly outputs all three spanning trees of @xmath1 .",
    "therefore , the claim is true for base case . _",
    "hypothesis : _ assume that our claim is true for 2-trees with less than @xmath2 vertices ( @xmath57 ) .",
    "_ induction step : _ let @xmath1 be a 2-tree on @xmath4 vertices . consider the 2-simplicial ordering @xmath58 of @xmath1 .",
    "clearly the higher neighbourhood @xmath59 of @xmath60 is a 2-clique .",
    "consider the graph @xmath61 obtained from @xmath1 by removing @xmath60 .",
    "i.e. , @xmath62 and @xmath63 .",
    "clearly @xmath61 has less than @xmath2 vertices and by our induction hypothesis , algorithm [ mainalgo ] correctly outputs all spanning trees of @xmath61 .",
    "we now argue that our algorithm indeed enumerates all spanning trees for @xmath1 as well .",
    "we observe that in the set @xmath64 ( the set of all spanning trees of @xmath1 ) , @xmath60 appears as a leaf or a non - leaf .",
    "based on this observation , we consider two cases to complete our induction . _ case 1 : _",
    "@xmath60 is a leaf .",
    "note that the lines 8 - 11 of algorithm [ mainalgo ] considers each spanning tree on @xmath3 vertices ( @xmath4 ) and augments either the edge @xmath65 or @xmath66 to get a spanning tree on @xmath2 vertices ( @xmath4 ) and in either augmentation , @xmath60 is a leaf node .",
    "_ case 2 : _",
    "@xmath60 is a non - leaf .",
    "lines 12 - 17 of algorithm [ mainalgo ] handle case 2 . for each spanning tree @xmath67 in @xmath64",
    "where @xmath68 , we augment @xmath60 to @xmath67 .",
    "this creates a cycle @xmath35 in the associated graph and to get a spanning tree with @xmath60 as a non - leaf , algorithm [ mainalgo ] removes an edge from @xmath35 other than the edges incident on @xmath60 to get a new spanning tree of @xmath1 . to ensure that @xmath60 is non - leaf ,",
    "the edges incident on @xmath60 are not removed by the algorithm",
    ". moreover , there are @xmath69 more spanning trees constructed out of @xmath67 with @xmath60 as the non - leaf .",
    "further , the above observation is true for each @xmath67 in @xmath64 .",
    "lines 12 - 17 of the algorithm identifies all such spanning trees by considering each @xmath67 in @xmath64 . note that in @xmath64 , @xmath67 with @xmath70 is not considered for discussion as the spanning trees generated by @xmath67 is taken care by case 2 itself , i.e. when @xmath60 is augmented to such @xmath67 , it creates a cycle of length three with the set @xmath71 and to get a spanning tree @xmath72 with @xmath60 as the non - leaf , remove the edge @xmath59 .",
    "we observe that the spanning tree @xmath72 with @xmath60 as non - leaf is already generated by our algorithm during case 2 .",
    "this completes our induction and therefore , our claim follows .",
    "our initial motivation was to study whether 2-trees have polynomial number of spanning trees .",
    "interestingly , we observed that in any 2-tree , the number of spanning trees is @xmath10 .",
    "further , we will also present the exact bound using recurrence relations .",
    "we also highlight that the spanning trees generated by lines 8 - 11 of our algorithm are without repetition and repetition is due to lines 12 - 17 of our algorithm .",
    "nevertheless , for any 2-tree , all spanning trees are generated by algorithm [ mainalgo ] .",
    "the lower bound presented in the next observation helped us in fixing the number of processors in parallel algorithmics .",
    "[ lb ] let @xmath1 be a 2-tree .",
    "the number of spanning trees is @xmath10 .",
    "we present a proof using counting argument .",
    "let @xmath73 denote the number of spanning trees on @xmath2-vertex 2-trees .",
    "note that @xmath74 , which is the number of spanning trees of a 3-clique . at every iteration @xmath52 , @xmath75",
    ", the vertex @xmath32 is adjacent to either @xmath76 or @xmath77 , where @xmath59 is the higher neighbourhood of @xmath32 with respect to the 2-simplicial ordering .",
    "this implies that for each spanning tree on @xmath78 vertices , the addition of @xmath32 creates at least two more spanning trees and in particular , two spanning trees with @xmath32 as the leaf node .",
    "therefore , we conclude that @xmath79 , @xmath4 and @xmath74 . solving this recurrence relation ,",
    "we get @xmath80 .",
    "the next theorem presents an upper bound on the number of spanning trees generated by our algorithm .    for a 2-tree @xmath1 , the number of spanning trees is @xmath81 , where @xmath82 denotes the length of the cycle created during iteration @xmath2 and @xmath4 , @xmath74 .    from theorem [ lb",
    "] , we know that the number of spanning trees in which @xmath7 vertex appears as a leaf is @xmath83 . note that during @xmath50 iteration , when @xmath32 is augmented as a non - leaf to a tree @xmath67 in @xmath64 , a cycle @xmath84 is created and the removal of any edge in @xmath84 other than the edges incident on @xmath32 creates a new spanning tree .",
    "this shows that for each spanning tree on @xmath78 vertices in the set @xmath64 , our algorithm constructs @xmath85 more spanning trees on @xmath52 vertices . from the previous theorem ,",
    "we know that there are @xmath83 spanning trees with @xmath60 as a leaf",
    ". therefore , the claim follows .      in this section",
    ", we describe the data structures used to implement our algorithm and using which we also analyze the time complexity of our algorithm . from the input 2-tree ,",
    "the first task is to get a 2-simplicial ordering . towards this end , we maintain a hash table @xmath86 indexed by vertex label and to the cell @xmath32 corresponding to vertex @xmath32 in @xmath86 , we store the higher neighbourhood of @xmath32 .",
    "we also maintain a stack @xmath87 to store the 2-simplicial ordering .",
    "we populate both @xmath87 and @xmath86 during algorithm [ ordering ] ; while removing a 2-simplicial vertex @xmath18 , it is pushed into @xmath87 and its higher neighbourhood is stored in @xmath86 .",
    "identification of 2-simplicial vertex can be done in @xmath8 time and population of @xmath87 and @xmath86 incurs @xmath88 time .",
    "therefore , the overall effort for @xmath2-iterations is @xmath89 . at iteration @xmath52",
    ", the top of @xmath87 contains the vertex @xmath32 which can be fetched in @xmath88 time .",
    "+ we maintain two dynamic queues @xmath90 and @xmath91 to keep track of the trees generated .",
    "both queues contain a list of pointers and each pointer points to a tree .",
    "initially @xmath90 is populated with three pointers corresponding to spanning trees of the base graph and each pointer points to a list of edges of the respective tree .",
    "i.e. , @xmath90 contains three pointers namely @xmath92 and @xmath93 points to a list @xmath94 of edges .",
    "we only maintain a list of edge labels with each tree pointer .",
    "spanning trees for the next iteration are generated using these three spanning trees and newly created spanning trees are stored in @xmath91 .",
    "@xmath91 will also contain a list of pointers and each tree pointer points to the list of edge labels of the tree .",
    "using @xmath91 , we generate the next set of spanning trees and that would be stored in @xmath90 . in each iteration",
    ", we make use of @xmath95 to generate the next set of spanning trees which would be stored in @xmath96 . at the end , either @xmath95 contains the set of spanning trees of the given 2-tree .",
    "+ during @xmath50 iteration , for a tree @xmath67 in @xmath95 , creating a new tree from @xmath67 with @xmath32 as a leaf incurs @xmath8 time .",
    "this is true because , using @xmath86 , we can get the higher neighbourhood of @xmath32 in constant time . since the size of the higher neighbourhood is two , @xmath67 creates two more spanning trees with @xmath32 as a leaf .",
    "since we are adding an edge label to the already existing list of @xmath67 , this task requires @xmath8 time and is pushed into @xmath96 . while creating a new tree from @xmath67 with @xmath32 as a non - leaf , algorithm [ mainalgo ] first checks whether the higher neighbourhood of @xmath32 is non - adjacent in @xmath67 , which can be done in @xmath8-time .",
    "further , algorithm [ mainalgo ] creates a graph @xmath28 in which there exists a cycle with @xmath32 .",
    "cycle detection can be done using standard depth first search algorithm in @xmath8 time .",
    "moreover , we get @xmath69 more spanning trees from @xmath67 which would be pushed into @xmath96 , where @xmath97 denotes the length of cycle in the graph @xmath28 . the above task can be done in @xmath8 time .",
    "therefore , the overall time complexity of our algorithm is @xmath98 , where @xmath64 is the set of spanning trees generated by our algorithm for a 2-tree .",
    "the overall structure of our sequential algorithm naturally gives a parallel algorithm to enumerate all spanning trees in 2-trees . towards this end , we make use of @xmath5 processors and our implementation is based on crew pram .",
    "we first generate 2-simplicial ordering of a 2-tree using @xmath8 processors .",
    "each processor incurs @xmath88 time to check whether a vertex is simplicial or not . following this , we generate all spanning trees iteratively starting from the base graph . in each iteration @xmath52",
    ", we make use of @xmath99 processors and each processor incurs @xmath8 time in this enumeration process .",
    "the implementation of algorithm [ parallelenumeration ] is similar to the implementation discussed in section [ implementation ] and using which , we see that each processor incurs @xmath8 time effort in the enumeration process .",
    "overall , there are @xmath5 processors being used by our algorithm .",
    "in the earlier section , as part of enumeration process , we presented an algorithm to list 2-simplicial ordering of a 2-tree .",
    "it is easy to observe that for a 2-tree , there is more than one 2-simplicial ordering . having looked at enumeration problem in this paper , it is natural to think of enumeration of 2-simplicial ordering of a 2-tree .",
    "in fact , in this section , we look at this question in larger dimension . towards this end , we consider listing all perfect elimination orderings of a chordal graph .",
    "we reiterate the fact that 2-trees are a subclass of chordal graphs .",
    "it is well - known that in any non - complete chordal graph , there exist at least two non - adjacent simplicial vertices @xcite .",
    "this shows that the number of peos is at least + @xmath100 , where @xmath73 denotes the number of peos on @xmath2-vertex chordal graph , @xmath101 + solving for @xmath73 gives @xmath102 . + for a complete chordal graph , every vertex is simplicial and therefore , the number of peos is just the number of permutations of the vertex set which is @xmath103 .",
    "* implementation details : * given a chordal graph @xmath1 , both algorithm [ peoenumeration ] and algorithm [ parallelpeoenumeration ] list all perfect elimination orderings of @xmath1 .",
    "this is true because , in both the algorithms , we first find a set @xmath104 of simplicial vertices in @xmath1 and using which we recursively list all peos .",
    "we make use of _ tree _ data structure to store all peos .",
    "the root of tree @xmath67 is labelled with @xmath1 and its neighbours are @xmath105 , where @xmath106 corresponds to the graph obtained from @xmath1 by removing the simplicial vertex @xmath32 and the edges in @xmath67 store the labels of simplicial vertices being removed at that recursion .",
    "similarly , for the node in @xmath67 corresponding to @xmath106 , its neighbours are graphs @xmath107 where @xmath106 contains @xmath6 simplicial vertices and @xmath108 corresponds to the graph obtained from @xmath106 by removing the simplicial vertex @xmath109 .",
    "when the recursion bottoms out , the paths from the root to leaves precisely give all peos .",
    "for parallel algorithm , we make use of @xmath5 processors as the lower bound on the number of peos is @xmath10 .",
    "in this paper , we have presented a novel approach to enumerate spanning trees of a 2-tree from both sequential and parallel perspective .",
    "our parallel approach can be implemented using @xmath5 processors .",
    "a natural extension of this approach would be to enumerate spanning trees of chordal graphs using peo as a tool .",
    "we have also looked at the enumeration of peos of chordal graphs both from sequential and parallel perspective .",
    "the iterative approach proposed here naturally yields a parallel algorithm and we believe that this technique can be used to discover parallel algorithms for other enumeration problems such as maximal independent set , minimal vertex separator , etc .",
    "4 akiyoshi shioura , akihisa tamura , and takeaki uno , an optimal algorithm for scanning all spanning trees of undirected graphs , siam journal of computing , 26 ( 3 ) , pp .",
    "678 - 692 , 1997 .",
    "r.c.read and r.e.tarjan , bounds on backtrack algorithms for listing cycles , paths , and spanning trees , networks , 5 , 237 - 252 , 1975 .",
    "t. kloks and d. kratsch , listing all minimal separators of a graph , proceedings of 11th annual symposium on theoretical aspects of computer science , lncs , 775 , pp . 759 - 768 .",
    "david s.johnson , m.yannakakis , and christos h. papadimitriou , on generating all maximal independent sets , information processing letters , 27 , 119 - 123 , 1988 .",
    "g.j.minty , a simple algorithm for listing all trees of a graph , ieee transactions on circuit theory , ct-12 , pp.120 , 1965 .",
    "h.n.gabow and e.w.myers , finding all spanning trees of directed and undirected graphs , siam journal of computing , 7(3 ) , 1978 . c. kruskal , searching , merging , and sorting in parallel computation , ieee transactions on computers , c-32 , 942 - 946 , 1983 .",
    "joseph ja ja and janos simon , parallel algorithms in graph theory : planarity testing , siam journal of computing , 11 , 314 - 328 , 1982 . t.s.hsu and v.ramachandran , on finding a smallest augmentation to biconnect a graph .",
    "siam journal of computing , 22 , 889 - 912 1993 douglas b. west : introduction to graph theory , 2nd edition , 2000 .",
    "m.c.golumbic : algorithmic graph theory and perfect graphs , academic press , 1980 .",
    "joseph ja ja , an introduction to parallel algorithms , addison wesley , 1992 ."
  ],
  "abstract_text": [
    "<S> for a connected graph , a vertex separator is a set of vertices whose removal creates at least two components . </S>",
    "<S> a vertex separator @xmath0 is minimal if it contains no other separator as a strict subset and a minimum vertex separator is a minimal vertex separator of least cardinality . </S>",
    "<S> a _ </S>",
    "<S> clique _ is a set of mutually adjacent vertices . </S>",
    "<S> a 2-tree is a connected graph in which every maximal clique is of size three and every minimal vertex separator is of size two . </S>",
    "<S> a spanning tree of a graph @xmath1 is a connected and an acyclic subgraph of @xmath1 . in this paper , we focus our attention on two enumeration problems , both from sequential and parallel perspective . in particular , we consider listing all possible spanning trees of a 2-tree and listing all perfect elimination orderings of a chordal graph . as far as enumeration of spanning trees </S>",
    "<S> is concerned , our approach is incremental in nature and towards this end , we work with the construction order of the 2-tree , i.e. enumeration of @xmath2-vertex trees are from @xmath3 vertex trees , @xmath4 . </S>",
    "<S> further , we also present a parallel algorithm for spanning tree enumeration using @xmath5 processors . to our knowledge </S>",
    "<S> , this paper makes the first attempt in designing a parallel algorithm for this problem . </S>",
    "<S> we conclude this paper by presenting a sequential and parallel algorithm for enumerating all perfect elimination orderings of a chordal graph . </S>"
  ]
}