{
  "article_text": [
    "the performance of machine learning methods is heavily dependent on the choice of data representation ( or features ) on which they are applied .",
    "for that reason , much of the actual effort in deploying machine learning algorithms goes into the design of preprocessing pipelines and data transformations that result in a representation of the data that can support effective machine learning .",
    "such feature engineering is important but labor - intensive and highlights the weakness of current learning algorithms : their inability to extract and organize the discriminative information from the data .",
    "feature engineering is a way to take advantage of human ingenuity and prior knowledge to compensate for that weakness . in order to expand the scope and ease of applicability of machine learning",
    ", it would be highly desirable to make learning algorithms less dependent on feature engineering , so that novel applications could be constructed faster , and more importantly , to make progress towards artificial intelligence ( ai ) .",
    "an ai must fundamentally _ understand the world around us _ , and we argue that this can only be achieved if it can learn to identify and disentangle the underlying explanatory factors hidden in the observed milieu of low - level sensory data .    this paper is about _ representation learning _",
    ", i.e. , learning representations of the data that make it easier to extract useful information when building classifiers or other predictors . in the case of probabilistic models , a good representation is often one that captures the posterior distribution of the underlying explanatory factors for the observed input .",
    "a good representation is also one that is useful as input to a supervised predictor . among the various ways of learning representations ,",
    "this paper focuses on deep learning methods : those that are formed by the composition of multiple non - linear transformations , with the goal of yielding more abstract  and ultimately more useful  representations . here",
    "we survey this rapidly developing area with special emphasis on recent progress .",
    "we consider some of the fundamental questions that have been driving research in this area .",
    "specifically , what makes one representation better than another ?",
    "given an example , how should we compute its representation , i.e. perform feature extraction ? also , what are appropriate objectives for learning good representations ?",
    "representation learning has become a field in itself in the machine learning community , with regular workshops at the leading conferences such as nips and icml , and a new conference dedicated to it , iclr , sometimes under the header of _ deep learning _ or _",
    "feature learning_. although depth is an important part of the story , many other priors are interesting and can be conveniently captured when the problem is cast as one of learning a representation , as discussed in the next section .",
    "the rapid increase in scientific activity on representation learning has been accompanied and nourished by a remarkable string of empirical successes both in academia and in industry .",
    "below , we briefly highlight some of these high points .",
    "* speech recognition and signal processing *    speech was one of the early applications of neural networks , in particular convolutional ( or time - delay ) neural networks .",
    "the recent revival of interest in neural networks , deep learning , and representation learning has had a strong impact in the area of speech recognition , with breakthrough results  @xcite obtained by several academics as well as researchers at industrial labs bringing these algorithms to a larger scale and into products .",
    "for example , microsoft has released in 2012 a new version of their mavis ( microsoft audio video indexing service ) speech system based on deep learning  @xcite .",
    "these authors managed to reduce the word error rate on four major benchmarks by about 30% ( e.g. from 27.4% to 18.5% on rt03s ) compared to state - of - the - art models based on gaussian mixtures for the acoustic modeling and trained on the same amount of data ( 309 hours of speech ) .",
    "the relative improvement in error rate obtained by @xcite on a smaller large - vocabulary speech recognition benchmark ( bing mobile business search dataset , with 40 hours of speech ) is between 16% and 23% .",
    "representation - learning algorithms have also been applied to music , substantially beating the state - of - the - art in polyphonic transcription  @xcite , with relative error improvement between 5% and 30% on a standard benchmark of 4 datasets .",
    "deep learning also helped to win mirex ( music information retrieval ) competitions , e.g. in 2011 on audio tagging  @xcite .",
    "* object recognition *    the beginnings of deep learning in 2006 have focused on the mnist digit image classification problem  @xcite , breaking the supremacy of svms ( 1.4% error ) on this dataset .",
    "the latest records are still held by deep networks :  @xcite currently claims the title of state - of - the - art for the unconstrained version of the task ( e.g. , using a convolutional architecture ) , with 0.27% error , and  @xcite is state - of - the - art for the knowledge - free version of mnist , with 0.81% error .    in the last few years , deep",
    "learning has moved from digits to object recognition in natural images , and the latest breakthrough has been achieved on the imagenet dataset bringing down the state - of - the - art error rate from 26.1% to 15.3%  @xcite .    * natural language processing *    besides speech recognition , there are many other natural language processing ( nlp ) applications of representation learning . _ distributed representations _ for symbolic data were introduced by  @xcite , and first developed in the context of statistical language modeling by  @xcite in so - called _ neural net language models _",
    "they are all based on learning a distributed representation for each word , called a _",
    "word embedding_. adding a convolutional architecture ,  @xcite developed the senna system that shares representations across the tasks of language modeling , part - of - speech tagging , chunking , named entity recognition , semantic role labeling and syntactic parsing .",
    "senna approaches or surpasses the state - of - the - art on these tasks but is simpler and much faster than traditional predictors .",
    "learning word embeddings can be combined with learning image representations in a way that allow to associate text and images .",
    "this approach has been used successfully to build google s image search , exploiting huge quantities of data to map images and queries in the same space  @xcite and it has recently been extended to deeper multi - modal representations  @xcite .",
    "the neural net language model was also improved by adding recurrence to the hidden layers  @xcite , allowing it to beat the state - of - the - art ( smoothed n - gram models ) not only in terms of perplexity ( exponential of the average negative log - likelihood of predicting the right next word , going down from 140 to 102 ) but also in terms of word error rate in speech recognition ( since the language model is an important component of a speech recognition system ) , decreasing it from 17.2% ( kn5 baseline ) or 16.9% ( discriminative language model ) to 14.4% on the wall street journal benchmark task .",
    "similar models have been applied in statistical machine translation  @xcite , improving perplexity and bleu scores .",
    "recursive auto - encoders ( which generalize recurrent networks ) have also been used to beat the state - of - the - art in full sentence paraphrase detection  @xcite almost doubling the f1 score for paraphrase detection .",
    "representation learning can also be used to perform word sense disambiguation  @xcite , bringing up the accuracy from 67.8% to 70.2% on the subset of senseval-3 where the system could be applied ( with subject - verb - object sentences ) .",
    "finally , it has also been successfully used to surpass the state - of - the - art in sentiment analysis  @xcite .",
    "* multi - task and transfer learning , domain adaptation *    transfer learning is the ability of a learning algorithm to exploit commonalities between different learning tasks in order to share statistical strength , and _ transfer knowledge _ across tasks . as discussed below",
    ", we hypothesize that representation learning algorithms have an advantage for such tasks because they learn representations that capture underlying factors , a subset of which may be relevant for each particular task , as illustrated in figure  [ fig : multi - task ] .",
    "this hypothesis seems confirmed by a number of empirical results showing the strengths of representation learning algorithms in transfer learning scenarios .        .",
    "most impressive are the two transfer learning challenges held in 2011 and won by representation learning algorithms .",
    "first , the transfer learning challenge , presented at an icml 2011 workshop of the same name , was won using unsupervised layer - wise pre - training  @xcite .",
    "a second transfer learning challenge was held the same year and won by  @xcite .",
    "results were presented at nips 2011 s challenges in learning hierarchical models workshop .",
    "see section  [ sec : transfer ] for a longer discussion and more pointers to other related results showing off the natural ability of representation learning algorithms to generalize to new classes , tasks , and domains . in the related _ domain adaptation _",
    "setup , the target remains the same but the input distribution changes  @xcite . in the _ multi - task learning _",
    "setup , representation learning has also been found advantageous  @xcite , because of shared factors across tasks .",
    "in  @xcite , one of us introduced the notion of ai - tasks , which are challenging for current machine learning algorithms , and involve complex but highly structured dependencies .",
    "one reason why explicitly dealing with representations is interesting is because they can be convenient to express many general priors about the world around us , i.e. , priors that are not task - specific but would be likely to be useful for a learning machine to solve ai - tasks . examples of such general - purpose priors are the following : + @xmath22 * smoothness * : assumes the function to be learned @xmath23 is s.t .",
    "@xmath24 generally implies @xmath25 .",
    "this most basic prior is present in most machine learning , but is insufficient to get around the curse of dimensionality , see section [ sec : smoothness ] .",
    "+ @xmath22 * multiple explanatory factors * : the data generating distribution is generated by different underlying factors , and for the most part what one learns about one factor generalizes in many configurations of the other factors .",
    "the objective to recover or at least disentangle these underlying factors of variation is discussed in section  [ sec : disentangling ] .",
    "this assumption is behind the idea of * distributed representations * , discussed in section [ sec : distributed ] below .",
    "+ @xmath22 * a hierarchical organization of explanatory factors * : the concepts that are useful for describing the world around us can be defined in terms of other concepts , in a hierarchy , with more * abstract * concepts higher in the hierarchy , defined in terms of less abstract ones .",
    "this assumption is exploited with * deep representations * , elaborated in section [ sec : depth ] below .",
    "* semi - supervised learning * : with inputs @xmath26 and target @xmath27 to predict , a subset of the factors explaining @xmath26 s distribution explain much of @xmath27 , given @xmath26 .",
    "hence representations that are useful for @xmath28 tend to be useful when learning @xmath29 , allowing sharing of statistical strength between the unsupervised and supervised learning tasks , see section  [ sec : stacking ] .",
    "+ @xmath22 * shared factors across tasks * : with many @xmath27 s of interest or many learning tasks in general , tasks ( e.g. , the corresponding @xmath30 ) are explained by factors that are shared with other tasks , allowing sharing of statistical strengths across tasks , as discussed in the previous section ( multi - task and transfer learning , domain adaptation ) .",
    "+ @xmath22 * manifolds * : probability mass concentrates near regions that have a much smaller dimensionality than the original space where the data lives .",
    "this is explicitly exploited in some of the auto - encoder algorithms and other manifold - inspired algorithms described respectively in sections [ sec : ae ] and [ sec : manifold ] .",
    "+ @xmath22 * natural clustering * : different values of categorical variables such as object classes are associated with separate manifolds .",
    "more precisely , the local variations on the manifold tend to preserve the value of a category , and a linear interpolation between examples of different classes in general involves going through a low density region , i.e. , @xmath31 for different @xmath32 tend to be well separated and not overlap much .",
    "for example , this is exploited in the manifold tangent classifier discussed in section  [ sec : leveraging - manifold ] .",
    "this hypothesis is consistent with the idea that humans have _ named _ categories and classes because of such statistical structure ( discovered by their brain and propagated by their culture ) , and machine learning tasks often involves predicting such categorical variables .",
    "+ @xmath22 * temporal and spatial coherence * : consecutive ( from a sequence ) or spatially nearby observations tend to be associated with the same value of relevant categorical concepts , or result in a small move on the surface of the high - density manifold . more generally , different factors change at different temporal and spatial scales , and many categorical concepts of interest change slowly . when attempting to capture such categorical variables , this prior can be enforced by making the associated representations slowly changing , i.e. , penalizing changes in values over time or space .",
    "this prior was introduced in  @xcite and is discussed in section  [ sec : slowness ] .",
    "+ @xmath22 * sparsity * : for any given observation @xmath33 , only a small fraction of the possible factors are relevant . in terms of representation , this could be represented by features that are often zero ( as initially proposed by  @xcite ) , or by the fact that most of the extracted features are _ insensitive _ to small variations of @xmath33 .",
    "this can be achieved with certain forms of priors on latent variables ( peaked at 0 ) , or by using a non - linearity whose value is often flat at 0 ( i.e. , 0 and with a 0 derivative ) , or simply by penalizing the magnitude of the jacobian matrix ( of derivatives ) of the function mapping input to representation .",
    "this is discussed in sections  [ sec : sparse - coding ] and  [ sec : ae ] .",
    "+ @xmath22 * simplicity of factor dependencies * : in good high - level representations , the factors are related to each other through simple , typically linear dependencies .",
    "this can be seen in many laws of physics , and is assumed when plugging a linear predictor on top of a learned representation .",
    "we can view many of the above priors as ways to help the learner discover and * disentangle * some of the underlying ( and a priori unknown ) factors of variation that the data may reveal .",
    "this idea is pursued further in sections  [ sec : disentangling ] and  [ sec : disentangling - algorithms ] .      for ai - tasks , such as vision and nlp",
    ", it seems hopeless to rely only on simple parametric models ( such as linear models ) because they can not capture enough of the complexity of interest unless provided with the appropriate feature space .",
    "conversely , machine learning researchers have sought flexibility in _ local _ depends mostly on training examples @xmath2 s close to @xmath33 ] _ non - parametric _ learners such as kernel machines with a fixed generic local - response kernel ( such as the gaussian kernel ) .",
    "unfortunately , as argued at length by @xcite , most of these algorithms only exploit the principle of _ local generalization",
    "_ , i.e. , the assumption that the target function ( to be learned ) is smooth enough , so they rely on examples to _ explicitly map out the wrinkles of the target function_. generalization is mostly achieved by a form of local interpolation between neighboring training examples .",
    "although smoothness can be a useful assumption , it is insufficient to deal with the _ curse of dimensionality _ , because the number of such wrinkles ( ups and downs of the target function ) may grow exponentially with the number of relevant interacting factors , when the data are represented in raw input space .",
    "we advocate learning algorithms that are flexible and non - parametric but do not rely exclusively on the smoothness assumption .",
    "instead , we propose to incorporate generic priors such as those enumerated above into representation - learning algorithms .",
    "smoothness - based learners ( such as kernel machines ) and linear models can still be useful on top of such learned representations .",
    "in fact , the combination of learning a representation and kernel machine is equivalent to _ learning the kernel _ , i.e. , the feature space . kernel machines are useful , but they depend on a prior definition of a suitable similarity metric , or a feature space in which naive similarity metrics suffice .",
    "we would like to use the data , along with very generic priors , to discover those features , or equivalently , a similarity function .",
    "good representations are _ expressive _ , meaning that a reasonably - sized learned representation can capture a huge number of possible input configurations .",
    "a simple counting argument helps us to assess the expressiveness of a model producing a representation : how many parameters does it require compared to the number of input regions ( or configurations ) it can distinguish ? learners of one - hot representations , such as traditional clustering algorithms , gaussian mixtures , nearest - neighbor algorithms , decision trees , or gaussian",
    "svms all require @xmath35 parameters ( and/or @xmath35 examples ) to distinguish @xmath35 input regions .",
    "one could naively believe that one can not do better .",
    "however , rbms , sparse coding , auto - encoders or multi - layer neural networks can all represent up to @xmath36 input regions using only @xmath35 parameters ( with @xmath37 the number of non - zero elements in a sparse representation , and @xmath38 in non - sparse rbms and other dense representations ) .",
    "these are all _ distributed _ out of @xmath39 representation elements or feature values can be independently varied , e.g. , they are not mutually exclusive . each concept",
    "is represented by having @xmath37 features being turned on or active , while each feature is involved in representing many concepts . ] or sparse . ]",
    "the generalization of clustering to distributed representations is _ multi - clustering _",
    ", where either several clusterings take place in parallel or the same clustering is applied on different parts of the input , such as in the very popular hierarchical feature extraction for object recognition based on a histogram of cluster categories detected in different patches of an image  @xcite . the exponential gain from",
    "distributed or sparse representations is discussed further in section 3.2 ( and figure 3.2 ) of  @xcite .",
    "it comes about because each parameter ( e.g. the parameters of one of the units in a sparse code , or one of the units in a restricted boltzmann machine ) can be re - used in many examples that are not simply near neighbors of each other , whereas with local generalization , different regions in input space are basically associated with their own private set of parameters , e.g. , as in decision trees , nearest - neighbors , gaussian svms , etc . in a distributed representation ,",
    "an exponentially large number of possible _ subsets _ of features or hidden units can be activated in response to a given input . in a single - layer model ,",
    "each feature is typically associated with a preferred input direction , corresponding to a hyperplane in input space , and the _ code _ or representation associated with that input is precisely the pattern of activation ( which features respond to the input , and how much ) .",
    "this is in contrast with a non - distributed representation such as the one learned by most clustering algorithms , e.g. , k - means , in which the representation of a given input vector is a one - hot code identifying which one of a small number of cluster centroids best represents the input  .",
    "depth is a key aspect to representation learning strategies we consider in this paper .",
    "as we will discuss , deep architectures are often challenging to train effectively and this has been the subject of much recent research and progress .",
    "however , despite these challenges , they carry two significant advantages that motivate our long - term interest in discovering successful training strategies for deep architectures .",
    "these advantages are : ( 1 ) deep architectures promote the _ re - use _ of features , and ( 2 ) deep architectures can potentially lead to progressively more _ abstract _ features at higher layers of representations ( more removed from the data ) .    * feature re - use . *",
    "the notion of re - use , which explains the power of distributed representations , is also at the heart of the theoretical advantages behind _ deep learning _ , i.e. , constructing multiple levels of representation or learning a hierarchy of features . the depth of a circuit is the length of the longest path from an input node of the circuit to an output node of the circuit .",
    "the crucial property of a deep circuit is that its number of paths , i.e. , _ ways to re - use different parts _ , can grow exponentially with its depth .",
    "formally , one can change the depth of a given circuit by changing the definition of what each node can compute , but only by a constant factor .",
    "the typical computations we allow in each node include : weighted sum , product , artificial neuron model ( such as a monotone non - linearity on top of an affine transformation ) , computation of a kernel , or logic gates .",
    "theoretical results clearly show families of functions where a deep representation can be exponentially more efficient than one that is insufficiently deep @xcite .",
    "if the same family of functions can be represented with fewer parameters ( or more precisely with a smaller vc - dimension ) , learning theory would suggest that it can be learned with fewer examples , yielding improvements in both _",
    "computational _ efficiency ( less nodes to visit ) and _ statistical _ efficiency ( less parameters to learn , and re - use of these parameters over many different kinds of inputs ) .    *",
    "abstraction and invariance .",
    "* deep architectures can lead to abstract representations because more abstract concepts can often be constructed in terms of less abstract ones . in some cases , such as in the convolutional neural network  @xcite , we build this abstraction in explicitly via a pooling mechanism ( see section  [ sec : convol ] ) .",
    "more abstract concepts are generally _ invariant _ to most local changes of the input . that makes the representations that capture these concepts generally highly non - linear functions of the raw input .",
    "this is obviously true of categorical concepts , where more abstract representations detect categories that cover more varied phenomena ( e.g. larger manifolds with more wrinkles ) and thus they potentially have greater predictive power .",
    "abstraction can also appear in high - level continuous - valued attributes that are only sensitive to some very specific types of changes in the input .",
    "learning these sorts of invariant features has been a long - standing goal in pattern recognition .      beyond being _ distributed _ and _ invariant _ , we would like our representations to _ disentangle the factors of variation_. different explanatory factors of the data tend to change independently of each other in the input distribution , and only a few at a time tend to change when one considers a sequence of consecutive real - world inputs .",
    "complex data arise from the rich interaction of many sources .",
    "these factors interact in a complex web that can complicate ai - related tasks such as object classification .",
    "for example , an image is composed of the interaction between one or more light sources , the object shapes and the material properties of the various surfaces present in the image .",
    "shadows from objects in the scene can fall on each other in complex patterns , creating the illusion of object boundaries where there are none and dramatically effect the perceived object shape .",
    "how can we cope with these complex interactions ?",
    "how can we _",
    "disentangle _ the objects and their shadows ? ultimately , we believe the approach we adopt for overcoming these challenges must leverage the data itself , using vast quantities of unlabeled examples , to learn representations that separate the various explanatory sources .",
    "doing so should give rise to a representation significantly more robust to the complex and richly structured variations extant in natural data sources for ai - related tasks .",
    "it is important to distinguish between the related but distinct goals of learning invariant features and learning to disentangle explanatory factors .",
    "the central difference is the preservation of information .",
    "invariant features , by definition , have reduced sensitivity in the direction of invariance .",
    "this is the goal of building features that are insensitive to variation in the data that are uninformative to the task at hand .",
    "unfortunately , it is often difficult to determine _ a priori _ which set of features and variations will ultimately be relevant to the task at hand .",
    "further , as is often the case in the context of deep learning methods , the feature set being trained may be destined to be used in multiple tasks that may have distinct subsets of relevant features .",
    "considerations such as these lead us to the conclusion that the most robust approach to feature learning is _ to disentangle as many factors as possible , discarding as little information about the data as is practical_. if some form of dimensionality reduction is desirable , then we hypothesize that the local directions of variation least represented in the training data should be first to be pruned out ( as in pca , for example , which does it globally instead of around each example )",
    ".      one of the challenges of representation learning that distinguishes it from other machine learning tasks such as classification is the difficulty in establishing a clear objective , or target for training . in the case of classification , the objective is ( at least conceptually ) obvious , we want to minimize the number of misclassifications on the training dataset . in the case of representation learning , our objective is far - removed from the ultimate objective , which is typically learning a classifier or some other predictor .",
    "our problem is reminiscent of the credit assignment problem encountered in reinforcement learning .",
    "we have proposed that a good representation is one that disentangles the underlying factors of variation , but how do we translate that into appropriate training criteria ?",
    "is it even necessary to do anything but maximize likelihood under a good model or can we introduce priors such as those enumerated above ( possibly _ data - dependent _ ones ) that help the representation better do this disentangling ?",
    "this question remains clearly open but is discussed in more detail in sections  [ sec : disentangling ] and  [ sec : disentangling - algorithms ] .",
    "in 2006 , a breakthrough in feature learning and deep learning was initiated by geoff hinton and quickly followed up in the same year  @xcite , and soon after by @xcite and many more later .",
    "it has been extensively reviewed and discussed in  @xcite .",
    "a central idea , referred to as _ greedy layerwise unsupervised pre - training _",
    ", was to learn a hierarchy of features one level at a time , using unsupervised feature learning to learn a new transformation at each level to be composed with the previously learned transformations ; essentially , each iteration of unsupervised feature learning adds one layer of weights to a deep neural network .",
    "finally , the set of layers could be combined to initialize a deep supervised predictor , such as a neural network classifier , or a deep generative model , such as a deep boltzmann machine  @xcite .",
    "this paper is mostly about feature learning algorithms that can be used to form deep architectures . in particular , it was empirically observed that layerwise _ stacking _ of feature extraction often yielded better representations , e.g. , in terms of classification error  @xcite , quality of the samples generated by a probabilistic model  @xcite or in terms of the _ invariance _ properties of the learned features  @xcite . whereas this section focuses on the idea of stacking single - layer models , section  [ sec : global ] follows up with a discussion on joint training of all the layers .",
    "after greedy layerwise unsuperivsed pre - training , the resulting deep features can be used either as input to a standard supervised machine learning predictor ( such as an svm ) or as initialization for a deep supervised neural network ( e.g. , by appending a logistic regression layer or purely supervised layers of a multi - layer neural network ) .",
    "the layerwise procedure can also be applied in a purely _ supervised _ setting , called the _ greedy layerwise supervised pre - training _  @xcite .",
    "for example , after the first one - hidden - layer mlp is trained , its output layer is discarded and another one - hidden - layer mlp can be stacked on top of it , etc .",
    "although results reported in  @xcite were not as good as for unsupervised pre - training , they were nonetheless better than without pre - training at all .",
    "alternatively , the _ outputs _ of the previous layer can be fed as _ extra inputs _ for the next layer ( in addition to the raw input ) , as successfully done in  @xcite .",
    "another variant  @xcite pre - trains in a supervised way all the previously added layers at each step of the iteration , and in their experiments this discriminant variant yielded better results than unsupervised pre - training .",
    "whereas combining single layers into a supervised model is straightforward , it is less clear how layers pre - trained by unsupervised learning should be combined to form a better _ unsupervised _ model .",
    "we cover here some of the approaches to do so , but no clear winner emerges and much work has to be done to validate existing proposals or improve them .",
    "the first proposal was to stack pre - trained rbms into a deep belief network  @xcite or dbn , where the top layer is interpreted as an rbm and the lower layers as a directed sigmoid belief network .",
    "however , it is not clear how to approximate maximum likelihood training to further optimize this generative model .",
    "one option is the wake - sleep algorithm  @xcite but more work should be done to assess the efficiency of this procedure in terms of improving the generative model .",
    "the second approach that has been put forward is to combine the rbm parameters into a deep boltzmann machine ( dbm ) , by basically halving the rbm weights to obtain the dbm weights  @xcite .",
    "the dbm can then be trained by approximate maximum likelihood as discussed in more details later ( section  [ sec : dbm ] ) .",
    "this joint training has brought substantial improvements , both in terms of likelihood and in terms of classification performance of the resulting deep feature learner  @xcite .",
    "another early approach was to stack rbms or auto - encoders into a _ deep auto - encoder _",
    "if we have a series of encoder - decoder pairs @xmath40 , then the overall encoder is the composition of the encoders , @xmath41 , and the overall decoder is its `` transpose '' ( often with transposed weight matrices as well ) , @xmath42 . the deep auto - encoder ( or its regularized version , as discussed in section  [ sec : ae ] )",
    "can then be jointly trained , with all the parameters optimized with respect to a global reconstruction error criterion .",
    "more work on this avenue clearly needs to be done , and it was probably avoided by fear of the challenges in training deep feedforward networks , discussed in the section  [ sec : global ] along with very encouraging recent results .",
    "yet another recently proposed approach to training deep architectures  @xcite is to consider the iterative construction of a _ free energy function _",
    "( i.e. , with no explicit latent variables , except possibly for a top - level layer of hidden units ) for a deep architecture as the composition of transformations associated with lower layers , followed by top - level hidden units .",
    "the question is then how to train a model defined by an arbitrary parametrized ( free ) energy function . @xcite",
    "have used hybrid monte carlo  @xcite , but other options include contrastive divergence  @xcite , score matching  @xcite , denoising score matching  @xcite , ratio - matching  @xcite and noise - contrastive estimation  @xcite .",
    "within the community of researchers interested in representation learning , there has developed two broad parallel lines of inquiry : one rooted in probabilistic graphical models and one rooted in neural networks .",
    "fundamentally , the difference between these two paradigms is whether the layered architecture of a deep learning model is to be interpreted as describing a probabilistic graphical model or as describing a computation graph . in short , are hidden units considered latent random variables or as computational nodes ?    to date , the dichotomy between these two paradigms has remained in the background , perhaps because they appear to have more characteristics in common than separating them .",
    "we suggest that this is likely a function of the fact that much recent progress in both of these areas has focused on _ single - layer greedy learning modules _ and the similarities between the types of single - layer models that have been explored : mainly , the restricted boltzmann machine ( rbm ) on the probabilistic side , and the auto - encoder variants on the neural network side .",
    "indeed , as shown by one of us  @xcite and others  @xcite , in the case of the restricted boltzmann machine , training the model via an inductive principle known as score matching  @xcite ( to be discussed in sec .",
    "[ sec : pseudolike ] ) is essentially identical to applying a regularized reconstruction objective to an auto - encoder .",
    "another strong link between pairs of models on both sides of this divide is when the computational graph for computing representation in the neural network model corresponds exactly to the computational graph that corresponds to inference in the probabilistic model , and this happens to also correspond to the structure of graphical model itself ( e.g. , as in the rbm ) .",
    "the connection between these two paradigms becomes more tenuous when we consider deeper models where , in the case of a probabilistic model , exact inference typically becomes intractable . in the case of deep models ,",
    "the computational graph diverges from the structure of the model .",
    "for example , in the case of a deep boltzmann machine , unrolling variational ( approximate ) inference into a computational graph results in a recurrent graph structure .",
    "we have performed preliminary exploration  @xcite of deterministic variants of deep auto - encoders whose computational graph is similar to that of a deep boltzmann machine ( in fact very close to the mean - field variational approximations associated with the boltzmann machine ) , and that is one interesting intermediate point to explore ( between the deterministic approaches and the graphical model approaches ) .    in the next few sections we will review the major developments in single - layer training modules used to support feature learning and particularly deep learning .",
    "we divide these sections between ( section  [ sec : prob - models ] ) the probabilistic models , with inference and training schemes that directly parametrize the generative  or _ decoding _  pathway and ( section  [ sec : direct ] ) the typically neural network - based models that directly parametrize the _ encoding _ pathway .",
    "interestingly , some models , like predictive sparse decomposition ( psd ) @xcite inherit both properties , and will also be discussed ( section  [ sec : psd ] ) .",
    "we then present a different view of representation learning , based on the associated geometry and the manifold assumption , in section  [ sec : manifold ] .",
    "first , let us consider an unsupervised single - layer representation learning algorithm spaning all three views : probabilistic , auto - encoder , and manifold learning .",
    "* principal components analysis *    we will use probably the oldest feature extraction algorithm , principal components analysis ( pca ) , to illustrate the probabilistic , auto - encoder and manifold views of representation - learning .",
    "pca learns a linear transformation @xmath43 of input @xmath44 , where the columns of @xmath45 matrix @xmath5 form an orthogonal basis for the @xmath1 orthogonal directions of greatest variance in the training data .",
    "the result is @xmath1 features ( the components of representation @xmath46 ) that are decorrelated .",
    "the three interpretations of pca are the following : a ) it is related to _ probabilistic models _",
    "( section [ sec : prob - models ] ) such as probabilistic pca , factor analysis and the traditional multivariate gaussian distribution ( the leading eigenvectors of the covariance matrix are the principal components ) ; b ) the representation it learns is essentially the same as that learned by a basic linear _ auto - encoder _ ( section [ sec : ae ] ) ; and c ) it can be viewed as a simple linear form of linear _ manifold learning _ ( section [ sec : manifold ] ) , i.e. , characterizing a lower - dimensional region in input space near which the data density is peaked .",
    "thus , pca may be in the back of the reader s mind as a common thread relating these various viewpoints .",
    "unfortunately the expressive power of linear features is very limited : they can not be stacked to form deeper , more abstract representations since the composition of linear operations yields another linear operation .",
    "here , we focus on recent algorithms that have been developed to extract _ non - linear _ features , which can be stacked in the construction of deep networks , although some authors simply insert a non - linearity between learned single - layer linear projections  @xcite .",
    "another rich family of feature extraction techniques that this review does not cover in any detail due to space constraints is independent component analysis or ica @xcite .",
    "instead , we refer the reader to  @xcite .",
    "note that , while in the simplest case ( complete , noise - free ) ica yields linear features , in the more general case it can be equated with a _ linear generative model _ with non - gaussian independent latent variables , similar to sparse coding ( section  [ sec : sparse - coding ] ) , which result in _ non - linear features_. therefore , ica and its variants like independent and topographic ica  @xcite can and have been used to build deep networks  @xcite : see section  [ sec : convol ] .",
    "the notion of obtaining independent components also appears similar to our stated goal of disentangling underlying explanatory factors through deep networks .",
    "however , for complex real - world distributions , it is doubtful that the relationship between truly independent underlying factors and the observed high - dimensional data can be adequately characterized by a linear transformation .",
    "from the probabilistic modeling perspective , the question of feature learning can be interpreted as an attempt to recover a parsimonious set of latent random variables that describe a distribution over the observed data .",
    "we can express as @xmath47 a probabilistic model over the joint space of the latent variables , @xmath46 , and observed data or visible variables @xmath33 .",
    "feature values are conceived as the result of an inference process to determine the probability distribution of the latent variables given the data , i.e. @xmath48 , often referred to as the _ posterior _ probability .",
    "learning is conceived in term of estimating a set of model parameters that ( locally ) maximizes the regularized likelihood of the training data .",
    "the probabilistic graphical model formalism gives us two possible modeling paradigms in which we can consider the question of inferring latent variables , directed and undirected graphical models , which differ in their parametrization of the joint distribution @xmath47 , yielding major impact on the nature and computational costs of both inference and learning .",
    "_ directed latent factor models _ separately parametrize the conditional likelihood @xmath49 and the _ prior _ @xmath50 to construct the joint distribution , @xmath51 .",
    "examples of this decomposition include : principal components analysis ( pca )  @xcite , sparse coding  @xcite , sigmoid belief networks  @xcite and the newly introduced spike - and - slab sparse coding model  @xcite .",
    "directed models often leads to one important property : _ explaining away _ , i.e. , _ a priori _ independent causes of an event can become non - independent given the observation of the event .",
    "latent factor models can generally be interpreted as latent _ cause _ models , where the @xmath46 activations cause the observed @xmath33 .",
    "this renders the _ a priori _ independent @xmath46 to be non - independent . as a consequence , recovering the posterior distribution of @xmath46 , @xmath48 ( which we use as a basis for feature representation ) , is often computationally challenging and can be entirely intractable , especially when @xmath46 is discrete .    a classic example that illustrates the phenomenon is to imagine you are on vacation away from home and you receive a phone call from the security system company , telling you that the alarm has been activated .",
    "you begin worrying your home has been burglarized , but then you hear on the radio that a minor earthquake has been reported in the area of your home .",
    "if you happen to know from prior experience that earthquakes sometimes cause your home alarm system to activate , then suddenly you relax , confident that your home has very likely not been burglarized .",
    "the example illustrates how the * alarm activation * rendered two otherwise entirely independent causes , * burglarized * and * earthquake * , to become dependent  in this case , the dependency is one of mutual exclusivity . since both * burglarized * and * earthquake * are very rare events and both can cause * alarm activation * , the observation of one _ explains away _ the other . despite the computational obstacles we face when attempting to recover the posterior over @xmath46 , explaining away promises to provide a parsimonious @xmath48 , which can be an extremely useful characteristic of a feature encoding scheme .",
    "if one thinks of a representation as being composed of various feature detectors and estimated attributes of the observed input , it is useful to allow the different features to compete and collaborate with each other to explain the input .",
    "this is naturally achieved with directed graphical models , but can also be achieved with undirected models ( see section  [ sec : undirected ] ) such as boltzmann machines if there are _ lateral connections _ between the corresponding units or corresponding _ interaction terms _ in the energy function that defines the probability model .",
    "pca can be given a natural probabilistic interpretation  @xcite as _ factor analysis _ :",
    "@xmath52    where @xmath53 , @xmath54 , @xmath55 is the multivariate normal density of @xmath56 with mean @xmath57 and covariance @xmath58 , and columns of @xmath5 span the same space as leading @xmath1 principal components , but are not constrained to be orthonormal .",
    "* sparse coding .",
    "* [ sec : sparse - coding ] like pca , sparse coding has both a probabilistic and non - probabilistic interpretation .",
    "sparse coding also relates a latent representation @xmath46 ( either a vector of random variables or a feature vector , depending on the interpretation ) to the data @xmath33 through a linear mapping @xmath5 , which we refer to as the _ dictionary_. the difference between sparse coding and pca is that sparse coding includes a penalty to ensure a _ sparse _ activation of @xmath46 is used to encode each input @xmath33 . from a non - probabilistic perspective , sparse coding can be seen as recovering the code or feature vector associated with a new input @xmath33 via :    @xmath59 learning the dictionary @xmath5 can be accomplished by optimizing the following training criterion with respect to @xmath5 :    @xmath60 where @xmath2 is the @xmath61-th example and @xmath62 is the corresponding sparse code determined by eq .",
    "[ eq : sparse - coding - map ] .",
    "@xmath5 is usually constrained to have unit - norm columns ( because one can arbitrarily exchange scaling of column @xmath32 with scaling of @xmath63 , such a constraint is necessary for the l1 penalty to have any effect ) .",
    "the probabilistic interpretation of sparse coding differs from that of pca , in that instead of a gaussian prior on the latent random variable @xmath46 , we use a sparsity inducing laplace prior ( corresponding to an l1 penalty ) : @xmath64    in the case of sparse coding , because we will seek a sparse representation ( i.e. , one with many features set to exactly zero ) , we will be interested in recovering the map ( maximum _ a posteriori _ value of @xmath46 : i.e. @xmath65 rather than its expected value @xmath66 } $ ] . under this interpretation ,",
    "dictionary learning proceeds as maximizing the likelihood of the data _ given these map values of @xmath67 _ : subject to the norm constraint on @xmath5 .",
    "note that this parameter learning scheme , subject to the map values of the latent @xmath46 , is not standard practice in the probabilistic graphical model literature .",
    "typically the likelihood of the data is maximized directly . in the presence of latent variables , expectation maximization",
    "is employed where the parameters are optimized with respect to the marginal likelihood , i.e. , summing or integrating the joint log - likelihood over the all values of the latent variables under their posterior @xmath68 , rather than considering only the single map value of @xmath46 .",
    "the theoretical properties of this form of parameter learning are not yet well understood but seem to work well in practice ( e.g. k - means vs gaussian mixture models and viterbi training for hmms ) .",
    "note also that the interpretation of sparse coding as a map estimation can be questioned  @xcite , because even though the interpretation of the l1 penalty as a log - prior is a possible interpretation , there can be other bayesian interpretations compatible with the training criterion .",
    "sparse coding is an excellent example of the power of explaining away . even with a very overcomplete dictionary than dimensions of @xmath33 .",
    "] , the map inference process used in sparse coding to find @xmath67 can pick out the most appropriate bases and zero the others , despite them having a high degree of correlation with the input .",
    "this property arises naturally in directed graphical models such as sparse coding and is entirely owing to the explaining away effect .",
    "it is not seen in commonly used undirected probabilistic models such as the rbm , nor is it seen in parametric feature encoding methods such as auto - encoders .",
    "the trade - off is that , compared to methods such as rbms and auto - encoders , inference in sparse coding involves an extra inner - loop of optimization to find @xmath67 with a corresponding increase in the computational cost of feature extraction .",
    "compared to auto - encoders and rbms , the code in sparse coding is a free variable for each example , and in that sense the implicit encoder is non - parametric .",
    "one might expect that the parsimony of the sparse coding representation and its explaining away effect would be advantageous and indeed it seems to be the case .",
    "@xcite demonstrated on the cifar-10 object classification task  @xcite with a patch - base feature extraction pipeline , that in the regime with few ( @xmath69 ) labeled training examples per class , the sparse coding representation significantly outperformed other highly competitive encoding schemes .",
    "possibly because of these properties , and because of the very computationally efficient algorithms that have been proposed for it ( in comparison with the general case of inference in the presence of explaining away ) , sparse coding enjoys considerable popularity as a feature learning and encoding paradigm .",
    "there are numerous examples of its successful application as a feature representation scheme , including natural image modeling  @xcite , audio classification  @xcite , nlp  @xcite , as well as being a very successful model of the early visual cortex  @xcite .",
    "sparsity criteria can also be generalized successfully to yield groups of features that prefer to all be zero , but if one or a few of them are active then the penalty for activating others in the group is small .",
    "different _ group sparsity _ patterns can incorporate different forms of prior knowledge  @xcite .",
    "* spike - and - slab sparse coding . * spike - and - slab sparse coding ( s3c ) is one example of a promising variation on sparse coding for feature learning  @xcite .",
    "the s3c model possesses a set of latent binary _ spike _ variables together with a a set of latent real - valued _ slab _ variables .",
    "the activation of the spike variables dictates the sparsity pattern .",
    "s3c has been applied to the cifar-10 and cifar-100 object classification tasks  @xcite , and shows the same pattern as sparse coding of superior performance in the regime of relatively few ( @xmath69 ) labeled examples per class  @xcite .",
    "in fact , in both the cifar-100 dataset ( with 500 examples per class ) and the cifar-10 dataset ( when the number of examples is reduced to a similar range ) , the s3c representation actually outperforms sparse coding representations .",
    "this advantage was revealed clearly with s3c winning the nips2011 transfer learning challenge  @xcite .",
    "undirected graphical models , also called markov random fields ( mrfs ) , parametrize the joint @xmath47 through a product of unnormalized non - negative _ clique potentials _ :    @xmath70 where @xmath71 , @xmath72 and @xmath73 are the clique potentials describing the interactions between the visible elements , between the hidden variables , and those interaction between the visible and hidden variables respectively .",
    "the partition function @xmath11 ensures that the distribution is normalized . within the context of unsupervised feature learning ,",
    "we generally see a particular form of markov random field called a boltzmann distribution with clique potentials constrained to be positive :    @xmath74 where @xmath75 is the energy function and contains the interactions described by the mrf clique potentials and @xmath4 are the model parameters that characterize these interactions .",
    "the boltzmann machine was originally defined as a network of symmetrically - coupled binary random variables or units .",
    "these stochastic units can be divided into two groups : ( 1 ) the _ visible _ units @xmath76 that represent the data , and ( 2 ) the _ hidden _ or latent units @xmath77 that mediate dependencies between the visible units through their mutual interactions .",
    "the pattern of interaction is specified through the energy function :    @xmath78    where @xmath79 are the model parameters which respectively encode the visible - to - visible interactions , the hidden - to - hidden interactions , the visible - to - hidden interactions , the visible self - connections , and the hidden self - connections ( called biases ) . to avoid over - parametrization ,",
    "the diagonals of @xmath80 and @xmath81 are set to zero .",
    "the boltzmann machine energy function specifies the probability distribution over @xmath82 $ ] , via the boltzmann distribution , eq .",
    "[ eq : bm_p(x , h ) ] , with the partition function @xmath11 given by :    @xmath83 this joint probability distribution gives rise to the set of conditional distributions of the form :    @xmath84 in general , inference in the boltzmann machine is intractable . for example , computing the conditional probability of @xmath85 given the visibles , @xmath86 , requires marginalizing over the rest of the hiddens , which implies evaluating a sum with @xmath87 terms :    @xmath88 however with some judicious choices in the pattern of interactions between the visible and hidden units , more tractable subsets of the model family are possible , as we discuss next .    * restricted boltzmann machines ( rbms ) . * [ sec : rbm ] the rbm is likely the most popular subclass of boltzmann machine  @xcite .",
    "it is defined by restricting the interactions in the boltzmann energy function , in eq .",
    "[ eq : boltzmann_energy ] , to only those between @xmath46 and @xmath33 , i.e. @xmath89 is @xmath90 with @xmath91 and @xmath92 . as such",
    ", the rbm can be said to form a _ bipartite _",
    "graph with the visibles and the hiddens forming two layers of vertices in the graph ( and no connection between units of the same layer ) . with this restriction",
    ", the rbm possesses the useful property that the conditional distribution over the hidden units factorizes given the visibles :    @xmath93 likewise , the conditional distribution over the visible units given the hiddens also factorizes :    @xmath94 this makes inferences readily tractable in rbms .",
    "for example , the rbm feature representation is taken to be the set of posterior marginals @xmath95 , which , given the conditional independence described in eq .",
    "[ eq : rbm_p(h|x ) ] , are immediately available .",
    "note that this is in stark contrast to the situation with popular directed graphical models for unsupervised feature extraction , where computing the posterior probability is intractable .",
    "importantly , the tractability of the rbm does not extend to its partition function , which still involves summing an exponential number of terms .",
    "it does imply however that we can limit the number of terms to @xmath96 .",
    "usually this is still an unmanageable number of terms and therefore we must resort to approximate methods to deal with its estimation .",
    "it is difficult to overstate the impact the rbm has had to the fields of unsupervised feature learning and deep learning .",
    "it has been used in a truly impressive variety of applications , including fmri image classification @xcite , motion and spatial transformations  @xcite , collaborative filtering @xcite and natural image modeling @xcite .",
    "important progress has been made in the last few years in defining generalizations of the rbm that better capture real - valued data , in particular real - valued image data , by better modeling the conditional covariance of the input pixels .",
    "the standard rbm , as discussed above , is defined with both binary visible variables @xmath97 and binary latent variables @xmath98 .",
    "the tractability of inference and learning in the rbm has inspired many authors to extend it , via modifications of its energy function , to model other kinds of data distributions .",
    "in particular , there has been multiple attempts to develop rbm - type models of real - valued data , where @xmath99 .",
    "the most straightforward approach to modeling real - valued observations within the rbm framework is the so - called _ gaussian rbm _ ( grbm ) where the only change in the rbm energy function is to the visible units biases , by adding a bias term that is quadratic in the visible units @xmath33 .",
    "while it probably remains the most popular way to model real - valued data within the rbm framework , @xcite suggest that the grbm has proved to be a somewhat unsatisfactory model of natural images .",
    "the trained features typically do not represent sharp edges that occur at object boundaries and lead to latent representations that are not particularly useful features for classification tasks .",
    "@xcite argue that the failure of the grbm to adequately capture the statistical structure of natural images stems from the exclusive use of the model capacity to capture the conditional mean at the expense of the conditional covariance .",
    "natural images , they argue , are chiefly characterized by the covariance of the pixel values , not by their absolute values .",
    "this point is supported by the common use of preprocessing methods that standardize the global scaling of the pixel values across images in a dataset or across the pixel values within each image .",
    "these kinds of concerns about the ability of the grbm to model natural image data has lead to the development of alternative rbm - based models that each attempt to take on this objective of _ better modeling non - diagonal conditional covariances_.  @xcite introduced the _ mean and covariance rbm _ ( mcrbm ) .",
    "like the grbm , the mcrbm is a 2-layer boltzmann machine that explicitly models the visible units as gaussian distributed quantities .",
    "however unlike the grbm , the mcrbm uses its hidden layer to independently parametrize both the mean and covariance of the data through two sets of hidden units .",
    "the mcrbm is a combination of the covariance rbm ( crbm ) @xcite , that models the conditional covariance , with the grbm that captures the conditional mean .",
    "while the grbm has shown considerable potential as the basis of a highly successful phoneme recognition system @xcite , it seems that due to difficulties in training the mcrbm , the model has been largely superseded by the mpot model . the mpot model ( _ mean - product of student s t - distributions model _ )  @xcite is a combination of the grbm and the product of student s t - distributions model  @xcite .",
    "it is an energy - based model where the conditional distribution over the visible units conditioned on the hidden variables is a multivariate gaussian ( non - diagonal covariance ) and the complementary conditional distribution over the hidden variables given the visibles are a set of independent gamma distributions .",
    "the pot model has recently been generalized to the mpot model  @xcite to include nonzero gaussian means by the addition of grbm - like hidden units , similarly to how the mcrbm generalizes the crbm .",
    "the mpot model has been used to synthesize large - scale natural images @xcite that show large - scale features and shadowing structure .",
    "it has been used to model natural textures  @xcite in a _ tiled - convolution _ configuration ( see section  [ sec : convol ] ) .",
    "another recently introduced rbm - based model with the objective of having the hidden units encode both the mean and covariance information is the _ spike - and - slab _ restricted boltzmann machine ( ssrbm )  @xcite .",
    "the ssrbm is defined as having both a real - valued `` slab '' variable and a binary `` spike '' variable associated with each unit in the hidden layer .",
    "the ssrbm has been demonstrated as a feature learning and extraction scheme in the context of cifar-10 object classification  @xcite from natural images and has performed well in the role  @xcite . when trained",
    "_ convolutionally _ ( see section  [ sec : convol ] ) on full cifar-10 natural images , the model demonstrated the ability to generate natural image samples that seem to capture the broad statistical structure of natural images better than previous parametric generative models , as illustrated with the samples of figure  [ fig : ssrbm - samples ] .",
    "the mcrbm , mpot and ssrbm each set out to model real - valued data such that the hidden units encode not only the conditional mean of the data but also its conditional covariance .",
    "other than differences in the training schemes , the most significant difference between these models is how they encode their conditional covariance .",
    "while the mcrbm and the mpot use the activation of the hidden units to enforce constraints on the covariance of @xmath33 , the ssrbm uses the hidden unit to pinch the precision matrix along the direction specified by the corresponding weight vector .",
    "these two ways of modeling conditional covariance diverge when the dimensionality of the hidden layer is significantly different from that of the input . in the overcomplete",
    "setting , sparse activation with the ssrbm parametrization permits variance only in the select directions of the sparsely activated hidden units .",
    "this is a property the ssrbm shares with sparse coding models  @xcite . on the other hand , in the case of the mpot or mcrbm ,",
    "an overcomplete set of constraints on the covariance implies that capturing arbitrary covariance along a particular direction of the input requires decreasing potentially all constraints with positive projection in that direction .",
    "this perspective would suggest that the mpot and mcrbm do not appear to be well suited to provide a sparse representation in the overcomplete setting .",
    "many of the rbm training methods we discuss here are applicable to more general undirected graphical models , but are particularly practical in the rbm setting .",
    "@xcite proposed a learning algorithm for harmoniums ( rbms ) based on projection pursuit .",
    "contrastive divergence  @xcite has been used most often to train rbms , and many recent papers use stochastic maximum likelihood  @xcite .    as discussed in sec .",
    "[ sec : directed ] , in training probabilistic models parameters are typically adapted in order to maximize the _ likelihood of the training data _ ( or equivalently the log - likelihood , or its penalized version , which adds a regularization term ) . with @xmath100 training examples , the log likelihood is given by :    @xmath101    gradient - based optimization requires its gradient , which for boltzmann machines , is given by :    @xmath102 } \\nonumber \\\\    & & +        \\sum_{t=1}^{t } { { \\mathbb{e}}_{p(x , h)}\\left [ {       \\frac{\\partial}{\\partial\\theta_{i}}\\energy_\\theta^{\\mathrm{bm}}(x , h)}\\right ] } , \\label{eq : bm_llgrad } \\vse\\end{aligned}\\ ] ] where we have the expectations with respect to @xmath103 in the `` clamped '' condition ( also called the positive phase ) , and over the full joint @xmath47 in the `` unclamped '' condition ( also called the negative phase ) .",
    "intuitively , the gradient acts to locally move the model distribution ( the negative phase distribution ) toward the data distribution ( positive phase distribution ) , by pushing down the energy of @xmath104 pairs ( for @xmath105 ) while pushing up the energy of @xmath106 pairs ( for @xmath107 ) until the two forces are in equilibrium , at which point the sufficient statistics ( gradient of the energy function ) have equal expectations with @xmath33 sampled from the training distribution or with @xmath33 sampled from the model .",
    "the rbm conditional independence properties imply that the expectation in the positive phase of eq .",
    "[ eq : bm_llgrad ] is tractable .",
    "the negative phase term  arising from the partition function",
    "s contribution to the log - likelihood gradient  is more problematic because the computation of the expectation over the joint is not tractable .",
    "the various ways of dealing with the partition function s contribution to the gradient have brought about a number of different training algorithms , many trying to approximate the log - likelihood gradient .    to approximate the expectation of the joint distribution in the negative phase contribution to the gradient",
    ", it is natural to again consider exploiting the conditional independence of the rbm in order to specify a monte carlo approximation of the expectation over the joint :    @xmath108 }     \\approx     \\frac{1}{l}\\sum_{l=1}^{l}\\frac{\\partial}{\\partial\\theta_{i}}\\energy_\\theta^{\\mathrm{rbm}}(\\tilde{x}^{(l)},\\tilde{h}^{(l ) } ) , \\label{eq : mc_dz } \\vsc\\ ] ]    with the samples @xmath109 drawn by a block gibbs mcmc ( markov chain monte carlo ) sampling procedure :    @xmath110    naively , for each gradient update step , one would start a gibbs sampling chain , wait until the chain converges to the equilibrium distribution and then draw a sufficient number of samples to approximate the expected gradient with respect to the model ( joint ) distribution in eq .",
    "[ eq : mc_dz ] . then restart the process for the next step of approximate gradient ascent on the log - likelihood .",
    "this procedure has the obvious flaw that waiting for the gibbs chain to `` burn - in '' and reach equilibrium anew for each gradient update can not form the basis of a practical training algorithm .",
    "contrastive divergence  @xcite , stochastic maximum likelihood  @xcite and fast - weights persistent contrastive divergence or fpcd  @xcite are all ways to avoid or reduce the need for burn - in .",
    "contrastive divergence ( cd ) estimation  @xcite estimates the negative phase expectation ( eq .",
    "[ eq : bm_llgrad ] ) with a very short gibbs chain ( often just one step ) initialized _ at the training data used in the positive phase_. this reduces the variance of the gradient estimator and still moves in a direction that pulls the negative chain samples towards the associated positive chain samples .",
    "much has been written about the properties and alternative interpretations of cd and its similarity to auto - encoder training , e.g. @xcite .",
    "the stochastic maximum likelihood ( sml ) algorithm ( also known as persistent contrastive divergence or pcd )  @xcite is an alternative way to sidestep an extended burn - in of the negative phase gibbs sampler . at each gradient update , rather than initializing the gibbs chain at the positive phase sample as in cd , sml initializes the chain at the last state of the chain used for the previous update . in other words , sml uses a continually running gibbs chain ( or often a number of gibbs chains run in parallel ) from which samples are drawn to estimate the negative phase expectation . despite the model parameters changing between updates",
    ", these changes should be small enough that only a few steps of gibbs ( in practice , often one step is used ) are required to maintain samples from the equilibrium distribution of the gibbs chain , i.e. the model distribution .",
    "a troublesome aspect of sml is that it relies on the gibbs chain to mix well ( especially between modes ) for learning to succeed . typically ,",
    "as learning progresses and the weights of the rbm grow , the ergodicity of the gibbs sample begins to break down .",
    "if the learning rate @xmath111 associated with gradient ascent @xmath112 ( with @xmath113\\approx\\frac{\\partial \\log p_\\theta(x)}{\\partial \\theta}$ ] ) is not reduced to compensate , then the gibbs sampler will diverge from the model distribution and learning will fail .",
    "@xcite have all considered various forms of tempered transitions to address the failure of gibbs chain mixing , and convincing solutions have not yet been clearly demonstrated .",
    "a recently introduced promising avenue relies on depth itself , showing that mixing between modes is much easier on deeper layers  @xcite ( sec.[sec : sampling - challenge ] ) .",
    "@xcite have proposed quite a different approach to addressing potential mixing problems of sml with their fast - weights persistent contrastive divergence ( fpcd ) , and it has also been exploited to train deep boltzmann machines  @xcite and construct a pure sampling algorithm for rbms  @xcite .",
    "fpcd builds on the surprising but robust tendency of gibbs chains to mix better during sml learning than when the model parameters are fixed .",
    "the phenomenon is rooted in the form of the likelihood gradient itself ( eq .  [ eq : bm_llgrad ] ) .",
    "the samples drawn from the sml gibbs chain are used in the negative phase of the gradient , which implies that the learning update will slightly increase the energy ( decrease the probability ) of those samples , making the region in the neighborhood of those samples less likely to be resampled and therefore making it more likely that the samples will move somewhere else ( typically going near another mode ) . rather than drawing samples from the distribution of the current model ( with parameters @xmath4 )",
    ", fpcd exaggerates this effect by drawing samples from a local perturbation of the model with parameters @xmath114 and an update    @xmath115 where @xmath116 is the relatively large fast - weight learning rate ( @xmath117 ) and @xmath118 ( but near 1 ) is a forgetting factor that keeps the perturbed model close to the current model . unlike tempering",
    ", fpcd does not converge to the model distribution as @xmath111 and @xmath119 go to 0 , and further work is necessary to characterize the nature of its approximation to the model distribution .",
    "nevertheless , fpcd is a popular and apparently effective means of drawing approximate samples from the model distribution that faithfully represent its diversity , at the price of sometimes generating spurious samples _ in between two modes _ ( because the fast weights roughly correspond to a smoothed view of the current model s energy function ) .",
    "it has been applied in a variety of applications  @xcite and it has been transformed into a sampling algorithm  @xcite that also shares this fast mixing property with _ herding _",
    "@xcite , for the same reason , i.e. , introducing _ negative correlations _ between consecutive samples of the chain in order to promote faster mixing .",
    "[ sec : pseudolike ] while cd , sml and fpcd are by far the most popular methods for training rbms and rbm - based models , all of these methods are perhaps most naturally described as offering different approximations to maximum likelihood training .",
    "there exist other inductive principles that are alternatives to maximum likelihood that can also be used to train rbms .",
    "in particular , these include pseudo - likelihood  @xcite and ratio - matching  @xcite .",
    "both of these inductive principles attempt to avoid explicitly dealing with the partition function , and their asymptotic efficiency has been analyzed  @xcite .",
    "pseudo - likelihood seeks to maximize the product of all one - dimensional conditional distributions of the form @xmath120 , while ratio - matching can be interpreted as an extension of score matching  @xcite to discrete data types .",
    "both methods amount to weighted differences of the gradient of the rbm free energy is the energy associated with the data marginal probability , @xmath121 and is tractable for the rbm . ]",
    "evaluated at a data point and at neighboring points .",
    "one potential drawback of these methods is that depending on the parametrization of the energy function , their computational requirements may scale up to @xmath122 worse than cd , sml , fpcd , or _ denoising score matching _",
    "@xcite , discussed below .",
    "@xcite empirically compared all of these methods ( except denoising score matching ) on a range of classification , reconstruction and density modeling tasks and found that , in general , sml provided the best combination of overall performance and computational tractability . however , in a later study , the same authors  @xcite found denoising score matching to be a competitive inductive principle both in terms of classification performance ( with respect to sml ) and in terms of computational efficiency ( with respect to analytically obtained score matching ) .",
    "denoising score matching is a special case of the denoising auto - encoder training criterion ( section  [ sec : dae ] ) when the reconstruction error residual equals a gradient , i.e. , the score function associated with an energy function , as shown in  @xcite .    in the spirit of the boltzmann machine gradient",
    "( eq .  [ eq : bm_llgrad ] )",
    "several approaches have been proposed to train energy - based models .",
    "one is _ noise - contrastive estimation _",
    "@xcite , in which the training criterion is transformed into a _ probabilistic classification problem _ : distinguish between ( positive ) training examples and ( negative ) noise samples generated by a broad distribution ( such as the gaussian ) .",
    "another family of approaches , more in the spirit of contrastive divergence , relies on distinguishing positive examples ( of the training distribution ) and negative examples obtained by perturbations of the positive examples  @xcite .",
    "within the framework of probabilistic models adopted in section  [ sec : prob - models ] , the learned representation is always associated with latent variables , specifically with their posterior distribution given an observed input @xmath33 .",
    "unfortunately , this posterior distribution tends to become very complicated and intractable if the model has more than a couple of interconnected layers , whether in the directed or undirected graphical model frameworks .",
    "it then becomes necessary to resort to sampling or approximate inference techniques , and to pay the associated computational and approximation error price .",
    "if the true posterior has a large number of modes that matter then current inference techniques may face an unsurmountable challenge or endure a potentially serious approximation .",
    "this is in addition to the difficulties raised by the intractable partition function in undirected graphical models .",
    "moreover a posterior _ distribution _ over latent variables is not yet a simple usable _ feature vector _ that can for example be fed to a classifier .",
    "so actual feature values are typically _ derived _ from that distribution , taking the latent variable s expectation ( as is typically done with rbms ) , their marginal probability , or finding their most likely value ( as in sparse coding ) .",
    "if we are to extract stable deterministic numerical feature values in the end anyway , an alternative ( apparently ) non - probabilistic feature learning paradigm that focuses on carrying out this part of the computation , very efficiently , is that of auto - encoders and other directly parametrized feature or representation functions .",
    "the commonality between these methods is that they _ learn a direct encoding , i.e. , a parametric map from inputs to their representation_.    regularized auto - encoders , discussed next , also involve learning a decoding function that maps back from representation to input space .",
    "sections  [ sec : neighbors ] and  [ sec : slowness ] discuss direct encoding methods that do not require a decoder , such as semi - supervised embedding  @xcite and slow feature analysis  @xcite .      in the auto - encoder framework @xcite ,",
    "one starts by explicitly defining a feature - extracting function in a specific parametrized closed form .",
    "this function , that we will denote @xmath8 , is called the * encoder * and will allow the straightforward and efficient computation of a feature vector @xmath123 from an input @xmath33 . for each example @xmath2 from a data set @xmath124 , we define    @xmath125    where @xmath3 is the _ feature - vector _ or _ representation _ or _ code _ computed from @xmath2 .",
    "another closed form parametrized function @xmath9 , called the * decoder * , maps from feature space back into input space , producing a * reconstruction * @xmath126 . whereas probabilistic models are defined from an explicit probability function and are trained to maximize ( often approximately ) the data likelihood ( or a proxy ) , auto - encoders are parametrized through their encoder and decoder and are trained using a different training principle .",
    "the set of parameters @xmath4 of the encoder and decoder are learned simultaneously on the task of reconstructing as well as possible the original input , i.e. attempting to incur the lowest possible * reconstruction error * @xmath127  a measure of the discrepancy between @xmath33 and its reconstruction @xmath128  _ over training examples_. good generalization means low reconstruction error at test examples , while having high reconstruction error for most other @xmath33 configurations . to capture the structure of the data - generating distribution",
    ", it is therefore important that something in the training criterion or the parametrization prevents the auto - encoder from learning the identity function , which has zero reconstruction error everywhere .",
    "this is achieved through various means in the different forms of auto - encoders , as described below in more detail , and we call these _ regularized auto - encoders_. a particular form of regularization consists in constraining the code to have a low dimension , and this is what the classical auto - encoder or pca do .    in summary ,",
    "basic auto - encoder training consists in finding a value of parameter vector @xmath4 minimizing reconstruction error    @xmath129    where @xmath2 is a training example .",
    "this minimization is usually carried out by stochastic gradient descent as in the training of multi - layer - perceptrons ( mlps ) .",
    "since auto - encoders were primarily developed as mlps predicting their input , the most commonly used forms for the encoder and decoder are affine mappings , optionally followed by a non - linearity :    @xmath130    where @xmath131 and @xmath132 are the encoder and decoder activation functions ( typically the element - wise sigmoid or hyperbolic tangent non - linearity , or the identity function if staying linear ) .",
    "the set of parameters of such a model is @xmath133 where @xmath6 and @xmath134 are called encoder and decoder bias vectors , and @xmath5 and @xmath135 are the encoder and decoder weight matrices .",
    "the choice of @xmath132 and @xmath14 depends largely on the input domain range and nature , and are usually chosen so that @xmath14 returns a negative log - likelihood for the observed value of @xmath33 . a natural choice for an unbounded domain is a linear decoder with a squared reconstruction error , i.e. @xmath136 and @xmath137 . if inputs are bounded between @xmath138 and @xmath139 however , ensuring a similarly - bounded reconstruction can be achieved by using @xmath140 .",
    "in addition if the inputs are of a binary nature , a binary cross - entropy loss ] is sometimes used .",
    "if both encoder and decoder use a sigmoid non - linearity , then @xmath141 and @xmath142 have the exact _ same form _ as the conditionals @xmath143 and @xmath144 of binary rbms ( see section [ sec : rbm ] ) .",
    "this similarity motivated an initial study  @xcite of the possibility of replacing rbms with auto - encoders as the basic pre - training strategy for building deep networks , as well as the comparative analysis of auto - encoder reconstruction error gradient and contrastive divergence updates  @xcite .",
    "one notable difference in the parametrization is that rbms use a single weight matrix , which follows naturally from their energy function , whereas the auto - encoder framework allows for a different matrix in the encoder and decoder . in practice",
    "however , _",
    "weight - tying _ in which one defines @xmath145 may be ( and is most often ) used , rendering the parametrizations identical .",
    "the usual training procedures however differ greatly between the two approaches .",
    "a practical advantage of training auto - encoder variants is that _ they define a simple tractable optimization objective that can be used to monitor progress_.    in the case of a linear auto - encoder ( linear encoder and decoder ) with squared reconstruction error , minimizing eq .",
    "[ eq : reconstruction - error ] learns the same _ _ subspace _ _ as pca .",
    "this is also true when using a sigmoid nonlinearity in the encoder  @xcite , but not if the weights @xmath5 and @xmath135 are tied ( @xmath145 ) , because @xmath5 can not be forced into being small and @xmath135 large to achieve a linear encoder .",
    "similarly , @xcite recently showed that adding a regularization term of the form @xmath146 to a linear auto - encoder with tied weights , where @xmath147 is a nonlinear convex function , yields an efficient algorithm for learning _",
    "linear ica_.      like pca , auto - encoders were originally seen as a dimensionality reduction technique and thus used a _ bottleneck _ , i.e. @xmath148 . on the other hand , successful uses of sparse coding and rbm approaches tend to favour _ overcomplete _ representations , i.e. @xmath149 .",
    "this can allow the auto - encoder to simply duplicate the input in the features , with perfect reconstruction without having extracted more meaningful features .",
    "recent research has demonstrated very successful alternative ways , called _ regulrized auto - encoders _ , to `` constrain '' the representation , even when it is overcomplete .",
    "the effect of a bottleneck or of this regularization is that the auto - encoder can not reconstruct well everything , it is trained to reconstruct well the training examples and generalization means that reconstruction error is also small on test examples .",
    "an interesting justification  @xcite for the sparsity penalty ( or any penalty that restricts in a soft way the volume of hidden configurations easily accessible by the learner ) is that it acts in spirit like the partition function of rbms , by making sure that only few input configurations can have a low reconstruction error .",
    "alternatively , one can view the objective of the regularization applied to an auto - encoder as making the representation as `` constant '' ( insensitive ) as possible with respect to changes in input .",
    "this view immediately justifies two variants of regularized auto - encoders described below : contractive auto - encoders reduce the number of effective degrees of freedom of the representation ( around each point ) by making the encoder contractive , i.e. , making the derivative of the encoder small ( thus making the hidden units saturate ) , while the denoising auto - encoder makes the whole mapping `` robust '' , i.e. , insensitive to small random perturbations , or contractive , making sure that the reconstruction can not stay good when moving in most directions around a training example .      the earliest uses of single - layer auto - encoders for building deep architectures by stacking them  @xcite considered the idea of _ tying _ the encoder weights and decoder weights to restrict capacity as well as the idea of introducing a form of _ sparsity regularization _  @xcite .",
    "sparsity in the representation can be achieved by penalizing the hidden unit biases ( making these additive offset parameters more negative )  @xcite or by directly penalizing the output of the hidden unit activations ( making them closer to their saturating value at 0 )  @xcite . penalizing the bias runs the danger that the weights could compensate for the bias , which could hurt numerical optimization .",
    "when directly penalizing the hidden unit outputs , several variants can be found in the literature , but a clear comparative analysis is still lacking . although the l1 penalty ( i.e. , simply the sum of output elements @xmath150 in the case of sigmoid non - linearity ) would seem the most natural ( because of its use in sparse coding ) , it is used in few papers involving sparse auto - encoders .",
    "a close cousin of the l1 penalty is the student - t penalty ( @xmath151 ) , originally proposed for sparse coding  @xcite .",
    "several papers penalize the _ average _ output @xmath152 ( e.g. over a minibatch ) , and instead of pushing it to 0 , encourage it to approach a fixed target , either through a mean - square error penalty , or maybe more sensibly ( because @xmath150 behaves like a probability ) , a kullback - liebler divergence with respect to the binomial distribution with probability @xmath153 : @xmath154constant , e.g. , with @xmath155 .",
    "@xcite proposed altering the training objective in eq .",
    "[ eq : reconstruction - error ] from mere reconstruction to that of _ denoising _ an artificially corrupted input , i.e. learning to reconstruct the clean input from a corrupted version . learning",
    "the identity is no longer enough : the learner must capture the structure of the input distribution in order to optimally undo the effect of the corruption process , with the reconstruction essentially being a nearby but higher density point than the corrupted input .",
    "figure  [ fig : dae ] illustrates that the denoising auto - encoder ( dae ) is learning a reconstruction function that corresponds to a vector field pointing towards high - density regions ( the manifold where examples concentrate ) .        .",
    "formally , the objective optimized by a dae is :    @xmath156 } \\label{eq : dae } \\vsg\\end{aligned}\\ ] ]    where @xmath157 } $ ] averages over corrupted examples @xmath158 drawn from corruption process @xmath159 . in practice",
    "this is optimized by stochastic gradient descent , where the stochastic gradient is estimated by drawing one or a few corrupted versions of @xmath2 each time @xmath2 is considered .",
    "corruptions considered in  @xcite include additive isotropic gaussian noise , salt and pepper noise for gray - scale images , and masking noise ( salt or pepper only ) , e.g. , setting some randomly chosen inputs to 0 ( independently per example ) . masking noise has been used in most of the simulations .",
    "qualitatively better features are reported with denoising , resulting in improved classification , and dae features performed similarly or better than rbm features .",
    "@xcite show that a simpler alternative with a closed form solution can be obtained when restricting to a _ linear _ auto - encoder and have successfully applied it to domain adaptation .",
    "@xcite relates daes to energy - based probabilistic models : daes basically learn in @xmath160 a vector pointing in the direction of the estimated _ score _ @xmath161 ( figure  [ fig : dae ] ) . in the special case of linear reconstruction and squared error , @xcite shows that training an affine - sigmoid - affine dae amounts to learning an energy - based model , whose energy function is very close to that of a grbm .",
    "training uses a regularized variant of the _ score matching _",
    "parameter estimation technique  @xcite termed _ denoising score matching _",
    "@xcite had shown that training grbms with _ score matching _ is equivalent to training a regular auto - encoder with an additional regularization term , while , following up on the theoretical results in  @xcite , @xcite showed the practical advantage of denoising to implement score matching efficiently .",
    "finally  @xcite generalize @xcite and prove that daes of arbitrary parametrization with small gaussian corruption noise are general estimators of the score .",
    "contractive auto - encoders ( cae ) , proposed by  @xcite , follow up on denoising auto - encoders ( dae ) and share a similar motivation of learning robust representations .",
    "caes achieve this by adding an analytic _ contractive penalty _ to eq .",
    "[ eq : reconstruction - error ] : the frobenius norm of the encoder s jacobian , and results in penalizing the _ sensitivity _ of learned features to infinitesimal input variations .",
    "let @xmath162 the jacobian matrix of the encoder at @xmath33 . the cae s training objective is    @xmath163    where @xmath12 is a hyper - parameter controlling the strength of the regularization .",
    "for an affine sigmoid encoder , the contractive penalty term is easy to compute :    @xmath164    there are at least three notable differences with daes , which may be partly responsible for the better performance that cae features seem to empirically demonstrate : ( a ) the sensitivity of the _ features _ is penalized rather than that of the _ reconstruction _ ; ( b ) the penalty is analytic rather than stochastic : an efficiently computable expression replaces what might otherwise require @xmath0 corrupted samples to size up ( i.e. the sensitivity in @xmath0 directions ) ; ( c ) a hyper - parameter @xmath12 allows a fine control of the trade - off between reconstruction and robustness ( while the two are mingled in a dae ) .",
    "note however that there is a tight connection between the dae and the cae : as shown in  @xcite a dae with small corruption noise can be seen ( through a taylor expansion ) as a type of contractive auto - encoder where the contractive penalty is on the whole reconstruction function rather than just on the encoder .",
    "a potential disadvantage of the cae s analytic penalty is that it amounts to only encouraging robustness to _ infinitesimal _ input variations .",
    "this is remedied in @xcite with the cae+h , that penalizes all higher order derivatives , in an efficient stochastic manner , by adding a term that encourages @xmath165 and @xmath166 to be close :    @xmath167 } \\label{eq : cae+h } \\vsd\\end{aligned}\\ ] ] where @xmath168 , and @xmath169 is the associated regularization strength hyper - parameter .",
    "the dae and cae have been successfully used to win the final phase of the unsupervised and transfer learning challenge  @xcite .",
    "the representation learned by the cae tends to be _ saturated rather than sparse _",
    ", i.e. , most hidden units are near the extremes of their range ( e.g. 0 or 1 ) , and their derivative @xmath170 is near 0 .",
    "the non - saturated units are few and sensitive to the inputs , with their associated filters ( weight vectors ) together forming a basis explaining the local changes around @xmath33 , as discussed in section  [ sec : manifold - coding ] .",
    "another way to get saturated ( nearly binary ) units is _ semantic hashing _  @xcite .",
    "sparse coding  @xcite may be viewed as a kind of auto - encoder that uses a linear decoder with a squared reconstruction error , but whose non - parametric _ encoder _",
    "@xmath8 performs the comparatively non - trivial and relatively costly iterative minimization of eq .",
    "[ eq : sparse - coding - map ] . a practically successful variant of sparse coding and auto - encoders , named _ predictive sparse decomposition _ or psd  @xcite replaces that costly and highly non - linear encoding step by a fast non - iterative approximation during recognition ( computing the learned features ) .",
    "psd has been applied to object recognition in images and video  @xcite , but also to audio  @xcite , mostly within the framework of multi - stage convolutional deep architectures ( section  [ sec : convol ] ) .",
    "the main idea can be summarized by the following equation for the training criterion , which is simultaneously optimized with respect to hidden codes ( representation ) @xmath3 and with respect to parameters @xmath171 :    @xmath172 where @xmath2 is the input vector for example @xmath61 , @xmath3 is the optimized hidden code for that example , and @xmath173 is the encoding function , the simplest variant being    @xmath174    where encoding weights are the transpose of decoding weights .",
    "many variants have been proposed , including the use of a shrinkage operation instead of the hyperbolic tangent  @xcite .",
    "note how the l1 penalty on @xmath46 tends to make them sparse , and how this is the same criterion as sparse coding with dictionary learning ( eq .  [ eq : sparse - coding - cost ] ) except for the additional constraint that one should be able to approximate the sparse codes @xmath46 with a parametrized encoder @xmath175 .",
    "one can thus view psd as an approximation to sparse coding , where we obtain a fast approximate encoder .",
    "once psd is trained , object representations @xmath175 are used to feed a classifier .",
    "they are computed quickly and can be further fine - tuned : the encoder can be viewed as one stage or one layer of a trainable multi - stage system such as a feedforward neural network .",
    "psd can also be seen as a kind of auto - encoder where the codes @xmath46 are given some freedom that can help to further improve reconstruction .",
    "one can also view the encoding penalty added on top of sparse coding as a kind of regularizer that forces the sparse codes to be nearly computable by a smooth and efficient encoder .",
    "this is in contrast with the codes obtained by complete optimization of the sparse coding criterion , which are highly non - smooth or even non - differentiable , a problem that motivated other approaches to smooth the inferred codes of sparse coding  @xcite , so a sparse coding stage could be jointly optimized along with following stages of a deep architecture .",
    "another important perspective on representation learning is based on the geometric notion of manifold .",
    "its premise is the _ manifold hypothesis _ , according to which real - world data presented in high dimensional spaces are expected to concentrate in the vicinity of a manifold @xmath176 of much lower dimensionality @xmath177 , embedded in high dimensional input space @xmath178 .",
    "this prior seems particularly well suited for ai tasks such as those involving images , sounds or text , for which most uniformly sampled input configurations are unlike natural stimuli .",
    "as soon as there is a notion of `` representation '' then one can think of a manifold by considering the _ variations _ in input space , which are captured by or reflected ( by corresponding changes ) in the learned representation .",
    "to first approximation , some directions are well preserved ( the tangent directions of the manifold ) while others are nt ( directions orthogonal to the manifolds ) . with this perspective",
    ", the primary unsupervised learning task is then seen as modeling the structure of the data - supporting manifold .",
    "the associated _ representation _ being learned can be associated with an intrinsic coordinate system on the embedded manifold .",
    "the archetypal manifold modeling algorithm is , not surprisingly , also the archetypal low dimensional representation learning algorithm : principal component analysis , which models a _ linear _ manifold .",
    "it was initially devised with the objective of finding the closest linear manifold to a cloud of data points .",
    "the principal components , i.e. the _ representation _ @xmath141 that pca yields for an input point @xmath33 , uniquely locates its projection on that manifold : it corresponds to intrinsic coordinates on the manifold .",
    "data manifold for complex real world domains are however expected to be _ strongly non - linear_. their modeling is sometimes approached as patchworks of locally linear tangent spaces  @xcite .",
    "the large majority of algorithms built on this geometric perspective adopt a non - parametric approach , based on a training set nearest neighbor graph  @xcite . in these non - parametric approaches ,",
    "each high - dimensional training point has its own set of free low - dimensional _ embedding _ coordinates , which are optimized so that certain properties of the neighborhood graph computed in original high dimensional input space are best preserved .",
    "these methods however do not directly learn a parametrized feature extraction function @xmath141 applicable to new test points , which seriously limits their use as feature extractors , except in a transductive setting .",
    "comparatively few non - linear manifold learning methods have been proposed , that learn a _ parametric map _ that can directly compute a representation for new points ; we will focus on these .",
    "some of the above non - parametric manifold learning algorithms can be modified to learn a _ parametric mapping _ @xmath8 ,",
    "i.e. , applicable to new points : instead of having _ free _ low - dimensional embedding coordinate `` parameters '' for each training point , these coordinates are obtained through an explicitly parametrized function , as with the parametric variant  @xcite of t - sne  @xcite .",
    "instead , semi - supervised embedding  @xcite learns a direct encoding while taking into account the manifold hypothesis through a neighborhood graph .",
    "a parametrized neural network architecture simultaneously learns a manifold embedding and a classifier .",
    "the training criterion encourages training set neigbhors to have similar representations .    the reduced and tightly controlled number of free parameters in such parametric methods , compared to their pure non - parametric counterparts , forces models to generalize the manifold shape non - locally  @xcite , which can translate into better features and final performance  @xcite .",
    "however , basing the modeling of manifolds on training set neighborhood relationships might be risky statistically in high dimensional spaces ( sparsely populated due to the curse of dimensionality ) as e.g. most euclidean nearest neighbors risk having too little in common semantically .",
    "the nearest neighbor graph is simply not enough densely populated to map out satisfyingly the wrinkles of the target manifold  @xcite .",
    "it can also become problematic computationally to consider all pairs of data points , which scales quadratically with training set size .",
    "unsupervised feature learning .",
    "also efficient parametrized extensions of non - parametric manifold learning techniques , such as parametric t - sne  @xcite , could similarly be used for unsupervised feature learning .",
    "a precursor in this respect , is non - local manifold parzen windows  @xcite , which modifies its non - parametric parent manifold parzen windows , by having a neural network learn to predict the tangent space at each point ( instead of basing it solely on a pca of the neighborhood ) .",
    "many embedding in principle , gradient updates on the free embedding coordinates of non - parametric approaches can that computes the embedding coordinates , instead of it is possible to use a similar neighborhood graph ( typically derived from pairwise euclidean distance ) as is used in the previously mentioned non - parametric manifold learning methods , but to instead learn a _ parametrized mapping _ @xmath8 , i.e. , applicable to new points .",
    "an early example of this approach is @xcite , a parametric extension of non - parametric where a parametric function leans to model the tangent space ( rather than compute an embedding ) is @xcite , a parametrized function @xmath8 ( an mlp ) was trained to predict the tangent space associated to any given point @xmath33 .",
    "compared to local non - parametric methods , the more reduced and tightly controlled number of free parameters force such models to generalize the manifold shape non - locally .",
    "the semi - supervised embedding approach of @xcite , builds a deep parametrized neural network architecture that simultaneously learns a manifold embedding and a classifier . while optimizing the supervised classification cost , the training criterion also uses trainset - neighbors of each training example to encourage intermediate layers of representation to be _ invariant _ when changing the training example for a neighbor .",
    "also efficient parametrized extensions of non - parametric manifold learning techniques , such as parametric t - sne  @xcite , could similarly be used for unsupervised feature learning .",
    "can we learn a manifold without requiring nearest neighbor searches ?",
    "yes , for example , with regularized auto - encoders or pca .",
    "in pca , the sensitivity of the extracted components ( the code ) to input changes is the same regardless of position @xmath33 .",
    "the tangent space is the same everywhere along the linear manifold .",
    "by contrast , for a _ non - linear manifold _ , the tangent of the manifold changes as we move on the manifold , as illustrated in figure  [ fig : manifold - sampling ] .",
    "in non - linear representation - learning algorithms it is convenient to think about the _ local variations _ in the representation as the input @xmath33 is varied _ on the manifold _ , i.e. , as we move among high - probability configurations . as we discuss below , the first derivative of the encoder therefore specifies the shape of the manifold ( its tangent plane ) around an example @xmath33 lying on it .",
    "if the density was really concentrated on the manifold , and the encoder had captured that , we would find the encoder derivatives to be non - zero only in the directions spanned by the tangent plane .",
    "let us consider sparse coding in this light : parameter matrix @xmath5 may be interpreted as a dictionary of input directions from which a _ different subset _ will be picked to model the local tangent space at an @xmath33 on the manifold .",
    "that subset corresponds to the active , i.e. non - zero , features for input @xmath33 .",
    "non - zero component @xmath85 will be sensitive to small changes of the input in the direction of the associated weight vector @xmath179 , whereas inactive features are more likely to be stuck at 0 until a significant displacement has taken place in input space .",
    "the _ local coordinate coding _ ( lcc ) algorithm  @xcite is very similar to sparse coding , but is explicitly derived from a manifold perspective . using the same notation as that of sparse coding in eq .",
    "[ eq : sparse - coding - map ] , lcc replaces regularization term @xmath180 yielding objective    @xmath181    this is identical to sparse coding when @xmath182 , but with larger @xmath183 it encourages the active _ anchor points _ for @xmath2 ( i.e. the codebook vectors @xmath184 with non - negligible @xmath185 that are combined to reconstruct @xmath2 ) to be not too far from @xmath2 , hence the _ local _ aspect of the algorithm .",
    "an important theoretical contribution of  @xcite is to show that that any lipschitz - smooth function @xmath186 defined on a smooth nonlinear manifold @xmath176 embedded in @xmath178 can be well approximated by a globally _ linear function _ with respect to the resulting coding scheme ( i.e. linear in @xmath46 ) , where the accuracy of the approximation and required number @xmath1 of anchor points depend on @xmath177 rather than @xmath0 .",
    "this result has been further extended with the use of local tangent directions  @xcite , as well as to multiple layers  @xcite .",
    "let us now consider the efficient non - iterative `` feed - forward '' encoders @xmath8 , used by psd and the auto - encoders reviewed in section  [ sec : ae ] , that are in the form of eq .",
    "[ eq : ae ] or [ eq : psdenc].the computed representation for @xmath33 will be only significantly sensitive to input space directions associated with non - saturated hidden units ( see e.g. eq .  [ eq : jacobian ] for the jacobian of a sigmoid layer ) .",
    "these directions to which the representation is significantly sensitive , like in the case of pca or sparse coding , may be viewed as spanning the tangent space of the manifold at training point @xmath33 .        .",
    "@xcite empirically analyze in this light the singular value spectrum of the jacobian ( derivatives of representation vector with respect to input vector ) of a trained cae . here",
    "the svd provides an ordered orthonormal basis of most sensitive directions .",
    "the spectrum is sharply decreasing , indicating a relatively small number of significantly sensitive directions .",
    "this is taken as empirical evidence that the cae indeed modeled the tangent space of a low - dimensional manifold .",
    "the leading singular vectors form a basis for the tangent plane of the estimated manifold , as illustrated in figure  [ fig : tangent - vectors ] .",
    "the cae criterion is believed to achieve this thanks to its two opposing terms : the isotropic contractive penalty , that encourages the representation to be equally insensitive to changes in any input directions , and the reconstruction term , that pushes different training points ( in particular neighbors ) to have a different representation ( so they may be reconstructed accurately ) , thus counteracting the isotropic contractive pressure only in directions tangent to the manifold .    analyzing learned representations through the lens of the spectrum of the jacobian and relating it to",
    "the notion of tangent space of a manifold is feasible , whenever the mapping is differentiable , and regardless of how it was learned , whether as direct encoding ( as in auto - encoder variants ) , or derived from latent variable inference ( as in sparse coding or rbms ) .",
    "exact low dimensional manifold models ( like pca ) would yield non - zero singular values associated to directions along the manifold , and exact zeros for directions orthogonal to the manifold . but in smooth models like the cae or the rbm we will instead have large versus relatively small singular values ( as opposed to non - zero versus exactly zero ) .      the local tangent space , at a point along the manifold ,",
    "can be thought of capturing _ locally _ valid transformations that were prominent in the training data .",
    "for example @xcite examine the tangent directions extracted with an svd of the jacobian of caes trained on digits , images , or text - document data : they appear to correspond to small translations or rotations for images or digits , and to substitutions of words within a same theme for documents .",
    "such very local transformations along a data manifold are not expected to change class identity . to build their manifold tangent classifier ( mtc ) , @xcite then apply techniques such as _ tangent distance _  @xcite and _ tangent propagation",
    "_  @xcite , that were initially developed to build classifiers that are insensitive to input deformations provided as prior domain knowledge .",
    "now these techniques are applied using the local leading tangent directions extracted by a cae , i.e. not using _ any _ prior domain knowledge ( except the broad prior about the existence of a manifold ) .",
    "this approach set a new record for mnist digit classification among prior - knowledge free approaches .",
    "the standard likelihood framework for probabilistic models decomposes the training criterion for models with parameters @xmath4 in two parts : the log - likelihood @xmath187 ( or @xmath188 with latent variables @xmath46 ) , and the prior @xmath189 ( or @xmath190 with latent variables ) .      in the case of the psd algorithm",
    ", a connection can be made between the above standard probabilistic view and the direct encoding computation graph .",
    "the probabilistic model of psd is the same directed generative model @xmath191 of sparse coding ( section  [ sec : sparse - coding ] ) , which only accounts for the decoder .",
    "the encoder is viewed as an approximate inference mechanism to guess @xmath192 and initialize a map iterative inference ( where the sparse prior @xmath193 is taken into account ) .",
    "however , in psd , the encoder is _ trained jointly with the decoder _ , rather than simply taking the end result of iterative inference as a target to approximate .",
    "an interesting view to reconcile these facts is that the encoder is a _",
    "parametric approximation for the map solution of a variational lower bound on the joint log - likelihood_. when map learning is viewed as a special case of variational learning ( where the approximation of the joint log - likelihood is with a dirac distribution located at the map solution ) , the variational recipe tells us to simultaneously improve the likelihood ( reduce reconstruction error ) and improve the variational approximation ( reduce the discrepancy between the encoder output and the latent variable value ) .",
    "hence psd sits at the intersection of probabilistic models ( with latent variables ) and direct encoding methods ( which directly parametrize the mapping from input to representation ) .",
    "rbms also sit at the intersection because their particular parametrization includes an explicit mapping from input to representation , thanks to the restricted connectivity between hidden units .",
    "however , this nice property does not extend to their natural deep generalizations , i.e. , deep boltzmann machines , discussed in section  [ sec : dbm ] .",
    "can we also say something about the probabilistic interpretation of regularized auto - encoders ?",
    "their training criterion does not fit the standard likelihood framework because this would involve a _ data - dependent _ `` prior '' .",
    "an interesting hypothesis emerges to answer that question , out of recent theoretical results  @xcite : the training criterion of regularized auto - encoders , instead of being a form of maximum likelihood , corresponds to a different inductive principle , such as _ score matching_. the score matching connection is discussed in section  [ sec : dae ] and has been shown for a particular parametrization of dae and equivalent gaussian rbm  @xcite .",
    "the work in  @xcite generalizes this idea to a broader class of parametrizations ( arbitrary encoders and decoders ) , and shows that by regularizing the auto - encoder so that it be contractive , one obtains that the reconstruction function and its derivative _ estimate first and second derivatives _ of the underlying data - generative density .",
    "this view can be exploited to successfully _ sample _ from auto - encoders , as shown in  @xcite .",
    "the proposed sampling algorithms are mcmcs similar to langevin mcmc , using not just the estimated first derivative of the density but also the estimated manifold tangents so as to stay close to manifolds of high density .",
    "( green ) learned by a high - capacity autoencoder on 1-dimensional input , minimizing reconstruction error _ at training examples _ @xmath2 ( @xmath194 in red ) while trying to be as constant as possible otherwise .",
    "the dotted line is the identity reconstruction ( which might be obtained without the regularizer ) .",
    "the blue arrows shows the vector field of @xmath195 pointing towards high density peaks estimated by the model , and estimating the score ( log - density derivative ) . ]    .",
    "this interpretation connects well with the geometric perspective introduced in section  [ sec : manifold ] .",
    "the regularization effects ( e.g. , due to a sparsity regularizer , a contractive regularizer , or the denoising criterion ) asks the learned representation to be as insensitive as possible to the input , while minimizing reconstruction error on the training examples forces the representation to contain just enough information to distinguish them .",
    "the solution is that variations along the high - density manifolds are preserved while other variations are compressed : the reconstruction function should be as constant as possible while reproducing training examples , i.e. , points near a training example should be mapped to that training example ( figure  [ fig:1d - autoencoder ] ) .",
    "the reconstruction function should map an input towards the nearest point manifold , i.e. , the difference between reconstruction and input is a vector aligned with the estimated score ( the derivative of the log - density with respect to the input ) .",
    "the score can be zero on the manifold ( where reconstruction error is also zero ) , at local maxima of the log - density , but it can also be zero at local minima .",
    "it means that we can not equate low reconstruction error with high estimated probability .",
    "the second derivatives of the log - density corresponds to the first derivatives of the reconstruction function , and on the manifold ( where the first derivative is 0 ) , they indicate the tangent directions of the manifold ( where the first derivative remains near 0 ) .",
    "the noise @xmath196 mostly in the directions of the estimated manifold tangent plane @xmath197 and projects back towards the manifold ( high - density regions ) by performing a reconstruction step . ]    .    as illustrated in figure",
    "[ fig : manifold - sampling ] , the basic idea of the auto - encoder sampling algorithms in  @xcite is to make mcmc moves where one ( a ) moves toward the manifold by following the density gradient ( i.e. , applying a reconstruction ) and ( b ) adds noise in the directions of the leading singular vectors of the reconstruction ( or encoder ) jacobian , corresponding to those associated with smallest second derivative of the log - density .",
    "let us now consider from closer how a representation is computed in probabilistic models with latent variables , when iterative inference is required .",
    "there is a computation graph ( possibly with random number generation in some of the nodes , in the case of mcmc ) that maps inputs to representation , and in the case of deterministic inference ( e.g. , map inference or variational inference ) , that function could be optimized directly .",
    "this is a way to generalize psd that has been explored in recent work on probabilistic models at the intersection of inference and learning  @xcite , where a central idea is that instead of using a _",
    "generic _ inference mechanism , one can use one that is _ learned _ and is more efficient , taking advantage of the specifics of the type of data on which it is applied .",
    "a troubling challenge with many probabilistic models with latent variables like most boltzmann machine variants is that good mcmc sampling is required as part of the learning procedure , but that _ sampling becomes extremely inefficient _ ( or unreliable ) as training progresses because the modes of the learned distribution become sharper , making _ mixing between modes very slow_. whereas initially during training a learner assigns mass almost uniformly , as training progresses , its entropy decreases , approaching the entropy of the target distribution as more examples and more computation are provided .",
    "according to our manifold and natural clustering priors of section  [ sec : priors ] , the target distribution has sharp modes ( manifolds ) separated by extremely low density areas .",
    "mixing then becomes more difficult because mcmc methods , by their very nature , tend to make small steps to nearby high - probability configurations .",
    "this is illustrated in figure  [ fig : mixing - issue ] .        .",
    "@xcite suggest that deep representations could help mixing between such well separated modes , based on both theoretical arguments and on empirical evidence .",
    "the idea is that if higher - level representations disentangle better the underlying abstract factors , then small steps in this abstract space ( e.g. , swapping from one category to another ) can easily be done by mcmc .",
    "the high - level representations can then be mapped back to the input space in order to obtain input - level samples , as in the deep belief networks ( dbn ) sampling algorithm  @xcite .",
    "this has been demonstrated both with dbns and with the newly proposed algorithm for sampling from contracting and denoising auto - encoders  @xcite .",
    "this observation alone does not suffice to solve the problem of training a dbn or a dbm , but it may provide a crucial ingredient , and it makes it possible to consider successfully sampling from deep models trained by procedures that do not require an mcmc , like the stacked regularized auto - encoders used in  @xcite .",
    "it is always possible to evaluate a feature learning algorithm in terms of its usefulness with respect to a particular task ( e.g. object classification ) , with a predictor that is fed or initialized with the learned features . in practice",
    ", we do this by saving the features learned ( e.g. at regular intervals during training , to perform early stopping ) and training a cheap classifier on top ( such as a linear classifier ) .",
    "however , training the final classifier can be a substantial computational overhead ( e.g. , supervised fine - tuning a deep neural network takes usually more training iterations than the feature learning itself ) , so we may want to avoid having to train a classifier for every training iteration of the unsupervised learner and every hyper - parameter setting . more importantly",
    "this may give an incomplete evaluation of the features ( what would happen for other tasks ? ) .",
    "all these issues motivate the use of methods to monitor and evaluate purely unsupervised performance .",
    "this is rather easy with all the auto - encoder variants ( with some caution outlined below ) and rather difficult with the undirected graphical models such as the rbm and boltzmann machines .    for auto - encoder and sparse coding variants ,",
    "test set reconstruction error can readily be computed , but by itself may be misleading because _ larger capacity _",
    "( e.g. , more features , more training time ) tends to systematically lead to lower reconstruction error , even on the test set .",
    "hence it can not be used reliably for selecting most hyper - parameters . on the other hand , _ denoising _",
    "reconstruction error is clearly immune to this problem , so that solves the problem for daes .",
    "based on the connection between daes and caes uncovered in  @xcite , this immunity can be extended to daes , but not to the hyper - parameter controlling the amount of noise or of contraction .    for rbms and some ( not too deep ) boltzmann machines ,",
    "one option is the use of annealed importance sampling  @xcite in order to estimate the partition function ( and thus the test log - likelihood ) .",
    "note that this estimator can have high variance and that it becomes less reliable ( variance becomes too large ) as the model becomes more interesting , with larger weights , more non - linearity , sharper modes and a sharper probability density function ( see our previous discussion in section  [ sec : sampling - challenge ] ) .",
    "another interesting and recently proposed option for rbms is to _ track _ the partition function during training  @xcite , which could be useful for early stopping and reducing the cost of ordinary ais . for toy rbms ( e.g. ,",
    "25 hidden units or less , or 25 inputs or less ) , the exact log - likelihood can also be computed analytically , and this can be a good way to debug and verify some properties of interest .",
    "one of the most interesting challenges raised by deep architectures is : _ how should we jointly train all the levels _ ? in the previous section and in section  [ sec : stacking ] we have only discussed how single - layer models could be combined to form a deep model .",
    "here we consider joint training of all the levels and the difficulties that may arise .",
    "higher - level abstraction means more non - linearity .",
    "it means that two nearby input configurations may be interpreted very differently because a few surface details change the underlying semantics , whereas most other changes in the surface details would not change the underlying semantics .",
    "the representations associated with input manifolds may be complex because the mapping from input to representation may have to unfold and distort input manifolds that generally have complicated shapes into spaces where distributions are much simpler , where relations between factors are simpler , maybe even linear or involving many ( conditional ) independencies .",
    "our expectation is that modeling the joint distribution between high - level abstractions and concepts should be much easier in the sense of requiring much less data to learn .",
    "the hard part is learning a good representation that does this unfolding and disentangling .",
    "this may be at the price of a more difficult training problem , possibly involving ill - conditioning and local minima .",
    "it is only since 2006 that researchers have seriously investigated ways to train deep architectures , to the exception of the convolutional networks  @xcite .",
    "the first realization ( section  [ sec : stacking ] ) was that unsupervised or supervised layer - wise training was easier , and that this could be taken advantage of by stacking single - layer models into deeper ones .",
    "it is interesting to ask _ why does the layerwise unsupervised pre - training procedure sometimes help a supervised learner _",
    "there seems to be a more general principle at play   of _ guiding the training of intermediate representations _",
    ", which may be easier than trying to learn it all in one go .",
    "this is nicely related to the curriculum learning idea  @xcite , that it may be much easier to learn simpler concepts first and then build higher - level ones on top of simpler ones .",
    "this is also coherent with the success of several deep learning algorithms that provide some such guidance for intermediate representations , like semi - supervised embedding  @xcite .",
    "unfortunately , it appears that it is sometimes not enough to perform stochastic gradient descent in deep architectures , and therefore the important sub - question is _ why is it sometimes challenging to train deep architectures _ ? and this begs the question : _ why is the greedy layerwise unsupervised pre - training procedure helping at all ? _",
    "although many papers have shown the advantages of incorporating unsupervised training to guide intermediate layers  @xcite ,    the question of why unsupervised pre - training could be helpful was extensively studied  @xcite , trying to dissect the answer into a _ regularization effect _ and an _ optimization effect_. the regularization effect is clear from the experiments where the stacked rbms or denoising auto - encoders are used to initialize a supervised classification neural network  @xcite .",
    "it may simply come from the use of unsupervised learning to bias the learning dynamics and initialize it in the _ basin of attraction _ of a `` good '' local minimum ( of the training criterion ) , where `` good '' is in terms of generalization error .",
    "the underlying hypothesis exploited by this procedure is that some of the features or latent factors that are good at capturing the leading variations in the input distribution are also good at capturing the variations in the target output random variables of interest ( e.g. , classes ) .",
    "the optimization effect is more difficult to tease out because the top two layers of a deep neural net can just overfit the training set whether the lower layers compute useful features or not , but there are several indications that optimizing the lower levels with respect to a supervised training criterion can be challenging .",
    "one such indication is that changing the numerical conditions of the optimization procedure can have a profound impact on the joint training of a deep architecture , for example by changing the initialization range and changing the type of non - linearity used  @xcite , much more so than with shallow architectures .",
    "one hypothesis to explain some of the difficulty in the optimization of deep architectures is centered on the singular values of the jacobian matrix associated with the transformation from the features at one level into the features at the next level  @xcite .",
    "if these singular values are all small ( less than 1 ) , then the mapping is contractive in every direction and _ gradients would vanish _ when propagated backwards through many layers .",
    "this is a problem already discussed for _ recurrent neural networks _",
    "@xcite , which can be seen as very deep networks with shared parameters at each layer , when unfolded in time .",
    "this optimization difficulty has motivated the exploration of second - order methods for deep architectures and recurrent networks , in particular hessian - free second - order methods  @xcite .",
    "unsupervised pre - training has also been proposed to help training recurrent networks and temporal rbms  @xcite , i.e. , at each time step there is a local signal to guide the discovery of good features to capture in the state variables : model with the current state ( as hidden units ) the joint distribution of the previous state and the current input .",
    "natural gradient  @xcite methods that can be applied to networks with millions of parameters ( i.e. with good scaling properties ) have also been proposed  @xcite .",
    "@xcite proposes to use adaptive learning rates for rbm training , along with a novel and interesting idea for a gradient estimator that takes into account the invariance of the model to flipping hidden unit bits and inverting signs of corresponding weight vectors .",
    "at least one study indicates that the choice of initialization ( to make the jacobian of each layer closer to 1 across all its singular values ) could substantially reduce the training difficulty of deep networks  @xcite and this is coherent with the success of the initialization procedure of echo state networks  @xcite , as recently studied by  @xcite .",
    "there are also several experimental results  @xcite showing that the choice of hidden units non - linearity could influence both training and generalization performance , with particularly interesting results obtained with sparse rectifying units  @xcite .",
    "an old idea regarding the ill - conditioning issue with neural networks is that of _ symmetry breaking _ : part of the slowness of convergence may be due to many units moving together ( like sheep ) and all trying to reduce the output error for the same examples . by initializing with sparse weights  @xcite or by using often saturated non - linearities ( such as rectifiers as max - pooling units ) ,",
    "gradients only flow along a few paths , which may help hidden units to specialize more quickly . another promising idea to improve",
    "the conditioning of neural network training is to nullify the average value and slope of each hidden unit output  @xcite , and possibly locally normalize magnitude as well  @xcite .",
    "the debate still rages between using online methods such as stochastic gradient descent and using second - order methods on large minibatches ( of several thousand examples )  @xcite , with a variant of stochastic gradient descent recently winning an optimization challenge  .",
    "finally , several recent results exploiting _ large quantities of labeled data _ suggest that with proper initialization and choice of non - linearity , very deep purely supervised networks can be trained successfully without any layerwise pre - training  @xcite .",
    "researchers report than in such conditions , layerwise unsupervised pre - training brought little or no improvement over pure supervised learning from scratch when training for long enough .",
    "this reinforces the hypothesis that unsupervised pre - training acts as a prior , which may be less necessary when very large quantities of labeled data are available , but begs the question of why this had not been discovered earlier .",
    "the latest results reported in this respect  @xcite are particularly interesting because they allowed to drastically reduce the error rate of object recognition on a benchmark ( the 1000-class imagenet task ) where many more traditional computer vision approaches had been evaluated ( http://www.image-net.org/challenges/lsvrc/2012/results.html ) .",
    "the main techniques that allowed this success include the following : _ efficient gpu training allowing one to train longer _",
    "( more than 100 million visits of examples ) , an aspect first reported by @xcite , _ large number of labeled examples _ , _ artificially transformed examples _ ( see section  [ sec : deformations ] ) , _ a large number of tasks _ ( 1000 or 10000 classes for imagenet ) , _ convolutional architecture _ with max - pooling ( see section  [ sec : prior - knowledge ] for these latter two techniques ) , _ rectifying non - linearities _ ( discussed above ) , _ careful initialization _ ( discussed above ) , _ careful parameter update and adaptive learning rate heuristics _ , _ layerwise feature normalization _ ( across features ) , and a new _ dropout _ trick based on injecting strong binary multiplicative noise on hidden units .",
    "this trick is similar to the binary noise injection used at each layer of a stack of denoising auto - encoders .",
    "future work is hopefully going to help identify which of these elements matter most , how to generalize them across a large variety of tasks and architectures , and in particular contexts where most examples are unlabeled , i.e. , including an unsupervised component in the training criterion .",
    "we now consider the problem of joint training of all layers of a specific unsupervised model , the deep boltzmann machine ( dbm ) . whereas much progress ( albeit with many unanswered questions ) has been made on jointly training all the layers of deep architectures using back - propagated gradients ( i.e. , mostly in the supervised setting ) , much less work has been done on their purely unsupervised counterpart , e.g. with dbms .",
    "note however that one could hope that the successful techniques described in the previous section could be applied to unsupervised learning algorithms .        like the rbm",
    ", the dbm is another particular subset of the boltzmann machine family of models where the units are again arranged in layers .",
    "however unlike the rbm , the dbm possesses multiple layers of hidden units , with units in odd - numbered layers being conditionally independent given even - numbered layers , and vice - versa . with respect to the boltzmann energy function of eq .",
    "[ eq : boltzmann_energy ] , the dbm corresponds to setting @xmath198 and a sparse connectivity structure in both @xmath81 and @xmath5 .",
    "we can make the structure of the dbm more explicit by specifying its energy function . for the model with two hidden layers it is given as :    @xmath199    with @xmath200 .",
    "the dbm can also be characterized as a bipartite graph between two sets of vertices , formed by odd and even - numbered layers ( with @xmath201 ) .",
    "a key point of departure from the rbm is that the posterior distribution over the hidden units ( given the visibles ) is no longer tractable , due to the interactions between the hidden units .",
    "@xcite resort to a mean - field approximation to the posterior .",
    "specifically , in the case of a model with two hidden layers , we wish to approximate @xmath202 with the factored distribution @xmath203 , such that the kl divergence @xmath204 is minimized or equivalently , that a lower bound to the log likelihood is maximized :    @xmath205    maximizing this lower - bound with respect to the mean - field distribution @xmath206 ( by setting derivatives to zero ) yields the following mean field update equations :    @xmath207    note how the above equations ostensibly look like a _ fixed point recurrent neural network _ ,",
    "i.e. , with constant input . in the same way that an rbm can be associated with a simple auto - encoder ,",
    "the above mean - field update equations for the dbm can be associated with a _ recurrent auto - encoder_. in that case the training criterion involves the reconstruction error at the last or at consecutive time steps .",
    "this type of model has been explored by  @xcite and  @xcite and shown to do a better job at denoising than ordinary auto - encoders .",
    "iterating eq .",
    "( [ eq : mf1]-[eq : mf2 ] ) until convergence yields the @xmath208 parameters of the `` variational positive phase '' of eq .",
    "[ eq : variational_gradient ] :    @xmath209 } \\nonumber \\\\ = & { { \\mathbb{e}}_{q_v}\\left [ {       - \\energy_\\theta^{\\mathrm{dbm}}(v , h^{(1)},h^{(2 ) } )       - \\log q_v(h^{(1)},h^{(2 ) } ) } \\right ] } \\nonumber \\\\ &     - \\log z_\\theta \\nonumber \\\\ \\label{eq : variational_gradient } \\frac{\\partial \\mathcal{l}(q_{v } ) } { \\partial \\theta } & =       - { { \\mathbb{e}}_{q_v}\\left [ {      \\frac{\\partial \\energy_\\theta^{\\mathrm{dbm}}(v , h^{(1)},h^{(2)})}{\\partial \\theta }       } \\right ] } \\nonumber \\\\ & \\hspace*{4 mm }     + { { \\mathbb{e}}_{p}\\left [ {     \\frac{\\partial \\energy_\\theta^{\\mathrm{dbm}}(v , h^{(1)},h^{(2)})}{\\partial \\theta}}\\right ] } \\vsd\\end{aligned}\\ ] ]    this variational learning procedure leaves the `` negative phase '' untouched , which can thus be estimated through sml or contrastive divergence @xcite as in the rbm case .      the major difference between training a dbm and",
    "an rbm is that instead of maximizing the likelihood directly , we instead choose parameters to maximize the lower - bound on the likelihood given in eq .",
    "[ eq : variational_lower_bound ] .",
    "the sml - based algorithm for maximizing this lower - bound is as follows :    1 .",
    "clamp the visible units to a training example .",
    "2 .   iterate over eq .",
    "( [ eq : mf1]-[eq : mf2 ] ) until convergence .",
    "3 .   generate negative phase samples @xmath210 , @xmath211 and @xmath212 through sml .",
    "4 .   compute @xmath213 using the values obtained in steps 2 - 3 .",
    "5 .   finally , update the model parameters with a step of approximate stochastic gradient ascent .",
    "while the above procedure appears to be a simple extension of the highly effective sml scheme for training rbms , as we demonstrate in  @xcite , this procedure seems vulnerable to falling in poor local minima which leave many hidden units effectively dead ( not significantly different from its random initialization with small norm ) .",
    "the failure of the sml joint training strategy was noted by @xcite .",
    "as an alternative , they proposed a greedy layer - wise training strategy .",
    "this procedure consists in pre - training the layers of the dbm , in much the same way as the deep belief network : i.e. by stacking rbms and training each layer to independently model the output of the previous layer .",
    "a final joint `` fine - tuning '' is done following the above sml - based procedure .",
    "[ sec : prior - knowledge ] it is well understood that incorporating prior domain knowledge helps machine learning . exploring good strategies for doing so",
    "is a very important research avenue .",
    "however , if we are to advance our understanding of core machine learning principles , it is important that we keep comparisons between predictors fair and maintain a clear awareness of the prior domain knowledge used by different learning algorithms , especially when comparing their performance on benchmark problems .",
    "we have so far only presented algorithms that exploited only generic inductive biases for high dimensional problems , thus making them potentially applicable to any high dimensional problem .",
    "the most prevalent approach to incorporating prior knowledge is to hand - design better features to feed a generic classifier , and has been used extensively in computer vision ( e.g. @xcite ) . here ,",
    "we rather focus on how _ basic _ domain knowledge of the input , in particular its topological structure ( e.g. bitmap images having a 2d structure ) , may be used to _ learn _ better features .",
    "generalization performance is usually improved by providing a larger quantity of representative data .",
    "this can be achieved by generating new examples by applying small random deformations to the original training examples , using deformations that are known not to change the target variables of interest , e.g. , an object class is invariant to small transformations of images such as translations , rotations , scaling , or shearing .",
    "this old approach  @xcite has been recently applied with great success in the work of  @xcite who used an efficient gpu implementation ( @xmath214 speedup ) to train a standard but large deep multilayer perceptron on deformed mnist digits . using both affine and elastic deformations  @xcite , with plain old stochastic gradient descent",
    ", they reach a record 0.32% classification error rate .",
    "another powerful approach is based on even more basic knowledge of merely the _ topological structure _ of the input dimensions . by this we mean e.g. , the 2d layout of pixels in images or audio spectrograms , the 3d structure of videos , the 1d sequential structure of text or of temporal sequences in general .",
    "based on such structure , one can define _ local receptive fields _",
    "@xcite , so that each low - level feature will be computed from only a subset of the input : a neighborhood in the topology ( e.g. a sub - image at a given position ) .",
    "this topological locality constraint corresponds to a layer having a very sparse weight matrix with non - zeros only allowed for topologically local connections .",
    "computing the associated matrix products can of course be made much more efficient than having to handle a dense matrix , in addition to the statistical gain from a much smaller number of free parameters . in domains with such topological structure , similar input patterns are likely to appear at different positions , and nearby values ( e.g. consecutive frames or nearby pixels ) are likely to have stronger dependencies that are also important to model the data .",
    "in fact these dependencies can be exploited to _ discover _ the topology  @xcite , i.e. recover a regular grid of pixels out of a set of vectors without any order information , e.g. after the elements have been arbitrarily shuffled in the same way for all examples .",
    "thus a same local feature computation is likely to be relevant at all translated positions of the receptive field .",
    "hence the idea of sweeping such a local feature extractor over the topology : this corresponds to a _ convolution _ , and transforms an input into a similarly shaped _",
    "feature map_. equivalently to sweeping , this may be seen as static but differently positioned replicated feature extractors that all share the same parameters .",
    "this is at the heart of convolutional networks  @xcite which have been applied both to object recognition and to image segmentation  @xcite .",
    "another hallmark of the convolutional architecture is that values computed by the same feature detector applied at several neighboring input locations are then summarized through a pooling operation , typically taking their max or their sum .",
    "this confers the resulting pooled feature layer some degree of invariance to input translations , and this style of architecture ( alternating selective feature extraction and invariance - creating pooling ) has been the basis of convolutional networks , the neocognitron  @xcite and hmax  @xcite models , and argued to be the architecture used by mammalian brains for object recognition  @xcite .",
    "the output of a pooling unit will be the same irrespective of where a specific feature is located inside its pooling region . empirically the use of pooling seems to contribute significantly to improved classification accuracy in object classification tasks",
    "a successful variant of pooling connected to sparse coding is l2 pooling  @xcite , for which the pool output is the square root of the possibly weighted sum of squares of filter outputs .",
    "ideally , we would like to generalize feature - pooling so as to _ learn what features should be pooled together _ , e.g. as successfully done in several papers  @xcite . in this way , the pool output learns to be _ invariant _ to the variations captured by the span of the features pooled .",
    "the simplest approach for learning a convolutional layer in an _ unsupervised _ fashion is _ patch - based training _ : simply feeding a generic unsupervised feature learning algorithm with local patches extracted at random positions of the inputs .",
    "the resulting feature extractor can then be swiped over the input to produce the convolutional feature maps .",
    "that map may be used as a new input for the next layer , and the operation repeated to thus learn and stack several layers .",
    "such an approach was recently used with independent subspace analysis  @xcite on 3d video blocks , reaching the state - of - the - art on hollywood2 , ucf , kth and youtube action recognition datasets .",
    "similarly @xcite compared several feature learners with patch - based training and reached state - of - the - art results on several classification benchmarks .",
    "interestingly , in this work performance was almost as good with very simple k - means clustering as with more sophisticated feature learners .",
    "we however conjecture that this is the case only because patches are rather low dimensional ( compared to the dimension of a whole image ) .",
    "a large dataset might provide sufficient coverage of the space of e.g. edges prevalent in @xmath215 patches , so that a distributed representation is not absolutely necessary .",
    "another plausible explanation for this success is that the clusters identified in each image patch are then _ pooled _ into a histogram of cluster counts associated with a larger sub - image . whereas the output of a regular clustering is a one - hot non - distributed code ,",
    "this histogram is itself a distributed representation , and the `` soft '' k - means @xcite representation allows not only the nearest filter but also its neighbors to be active .",
    "it is possible to directly train large convolutional layers using an unsupervised criterion .",
    "an early approach  @xcite trained a standard but deep convolutional mlp on the task of denoising images , i.e. as a deep , convolutional , denoising _ auto - encoder_. convolutional versions of the rbm or its extensions have also been developed  @xcite as well as a _",
    "probabilistic max - pooling _ operation built into convolutional deep networks  @xcite .",
    "other unsupervised feature learning approaches that were adapted to the convolutional setting include psd  @xcite , a convolutional version of sparse coding called deconvolutional networks  @xcite , topographic ica  @xcite , and mpot that  @xcite applied to modeling natural textures .",
    "@xcite also demonstrated the technique of tiled - convolution , where parameters are shared only between feature extractors whose receptive fields are @xmath37 steps away ( so the ones looking at immediate neighbor locations are not shared ) .",
    "this allows pooling units to be invariant to more than just translations , and is a hybrid between convolutional networks and earlier neural networks with local connections but no weight sharing  @xcite .",
    "alternatively , one can also use explicit knowledge of the expected invariants expressed mathematically to define transformations that are _ robust _ to a known family of input deformations , using so - called _ scattering operators _",
    "@xcite , which can be computed in a way interestingly analogous to deep convolutional networks and wavelets . like convolutional networks , the scattering operators alternate two types of operations : convolution and pooling ( as a norm ) .",
    "unlike convolutional networks , the proposed approach keeps at each level all of the information about the input ( in a way that can be inverted ) , and automatically yields a very sparse ( but very high - dimensional ) representation .",
    "another difference is that the filters are not learned but instead set so as to guarantee that a priori specified invariances are robustly achieved .",
    "just a few levels were sufficient to achieve impressive results on several benchmark datasets .      the principle of identifying slowly moving / changing factors in temporal / spatial data has been investigated by many  @xcite as a principle for finding useful representations . in particular",
    "this idea has been applied to image sequences and as an explanation for why v1 simple and complex cells behave the way they do .",
    "a good overview can be found in  @xcite .",
    "more recently , temporal coherence has been successfully exploited in deep architectures to model video  @xcite .",
    "it was also found that temporal coherence discovered visual features similar to those obtained by ordinary unsupervised feature learning  @xcite , and a temporal coherence penalty has been _ combined _ with a training criterion for unsupervised feature learning  @xcite , sparse auto - encoders with l1 regularization , in this case , yielding improved classification performance .",
    "the temporal coherence prior can be expressed in several ways , the simplest being the squared difference between feature values at times @xmath61 and @xmath216 .",
    "other plausible temporal coherence priors include the following .",
    "first , instead of penalizing the squared change , penalizing the absolute value ( or a similar sparsity penalty ) would state that most of the time the change should be exactly 0 , which would intuitively make sense for the real - life factors that surround us .",
    "second , one would expect that instead of just being slowly changing , different factors could be associated with their own different time scale .",
    "the specificity of their time scale could thus become a hint to disentangle explanatory factors .",
    "third , one would expect that some factors should really be represented by a _ group of numbers _",
    "( such as @xmath33 , @xmath217 , and @xmath218 position of some object in space and the pose parameters of  @xcite ) rather than by a single scalar , and that these groups tend to move together",
    ". structured sparsity penalties  @xcite could be used for this purpose .",
    "the goal of building invariant features is to remove sensitivity of the representation to directions of variance in the data that are uninformative to the task at hand .",
    "however it is often the case that the goal of feature extraction is the _ disentangling _ or separation of many distinct but informative factors in the data , e.g. , in a video of people : subject identity , action performed , subject pose relative to the camera , etc . in this situation ,",
    "the methods of generating invariant features , such as feature - pooling , may be inadequate .",
    "the process of building invariant features can be seen as consisting of two steps .",
    "first , low - level features are recovered that account for the data .",
    "second , subsets of these low level features are pooled together to form higher - level invariant features , exemplified by the pooling and subsampling layers of convolutional neural networks . the invariant representation formed by the pooling",
    "features offers an incomplete window on the data as the detailed representation of the lower - level features is abstracted away in the pooling procedure . while we would like higher - level features to be more abstract and exhibit greater invariance , we have little control over what information is lost through pooling .",
    "what we really would like is for a particular feature set to be invariant to the irrelevant features and disentangle the relevant features .",
    "unfortunately , it is often difficult to determine _ a priori _ which set of features will ultimately be relevant to the task at hand .",
    "an interesting approach to taking advantage of some of the factors of variation known to exist in the data is the _ transforming auto - encoder _",
    "@xcite : instead of a scalar pattern detector ( e.g , .",
    "corresponding to the probability of presence of a particular form in the input ) one can think of the features as organized in groups that include both a pattern detector and _ pose parameters _ that specify attributes of the detected pattern . in  @xcite",
    ", what is assumed a priori is that pairs of examples ( or consecutive ones ) are observed with an _ associated value for the corresponding change in the pose parameters_. for example , an animal that controls its eyes _ knows _ what changes to its ocular motor system were applied when going from one image on its retina to the next . in that work",
    ", it is also assumed that the pose changes are the same for all the pattern detectors , and this makes sense for global changes such as image translation and camera geometry changes .",
    "instead , we would like to _ discover _ the pose parameters and attributes that should be associated with each feature detector , without having to specify ahead of time what they should be , force them to be the same for all features , and having to necessarily observe the changes in all of the pose parameters or attributes .",
    "the approach taken recently in the manifold tangent classifier , discussed in section  [ sec : leveraging - manifold ] , is interesting in this respect . without any supervision or prior knowledge",
    ", it finds prominent local _ factors of variation _ ( tangent vectors to the manifold , extracted from a cae , interpreted as locally valid input `` deformations '' ) .",
    "higher - level features are subsequently encouraged to be _ invariant _ to these factors of variation , so that they must depend on other characteristics . in a sense",
    "this approach is disentangling valid local deformations along the data manifold from other , more drastic changes , associated to other factors of variation such as those that affect class identity .",
    "one solution to the problem of information loss that would fit within the feature - pooling paradigm , is to consider many overlapping pools of features based on the same low - level feature set .",
    "such a structure would have the potential to learn a redundant set of invariant features that may not cause significant loss of information .",
    "however it is not obvious what learning principle could be applied that can ensure that the features are invariant while maintaining as much information as possible . while a deep belief network or a deep boltzmann machine ( as discussed in sections [ sec : stacking ] and [ sec : dbm ] respectively ) with two hidden layers would , in principle , be able to preserve information into the `` pooling '' second hidden layer , there is no guarantee that the second layer features are more invariant than the `` low - level '' first layer features .",
    "however , there is some empirical evidence that the second layer of the dbn tends to display more invariance than the first layer @xcite .",
    "a second issue with this approach is that it could nullify one of the major motivations for pooling features : to reduce the size of the representation .",
    "a pooling arrangement with a large number of overlapping pools could lead to as many pooling features as low - level features  a situation that is both computationally and statistically undesirable .",
    "a more principled approach , from the perspective of ensuring a more robust compact feature representation , can be conceived by reconsidering the disentangling of features through the lens of its generative equivalent  feature composition . since many unsupervised learning algorithms have a generative interpretation ( or a way to _ reconstruct _ inputs from their high - level representation )",
    ", the generative perspective can provide insight into how to think about disentangling factors .",
    "the majority of the models currently used to construct invariant features have the interpretation that their low - level features linearly combine to construct the data .",
    "this is a fairly rudimentary form of feature composition with significant limitations .",
    "for example , it is not possible to linearly combine a feature with a generic transformation ( such as translation ) to generate a transformed version of the feature . nor can we even consider a generic color feature being linearly combined with a gray - scale stimulus pattern to generate a colored pattern .",
    "it would seem that if we are to take the notion of disentangling seriously we require a richer interaction of features than that offered by simple linear combinations .",
    "because one can have a different type of representation - learning model at each layer , and because each of these learning algorithms has several hyper - parameters , there is a huge number of possible configurations and choices one can make in designing a particular model for a particular dataset .",
    "there are two approaches that practitioners of machine learning typically employ to deal with hyper - parameters .",
    "one is manual trial and error , i.e. , a human - guided search , which is highly dependent on the prior experience and skill of the expert .",
    "the other is a grid search , i.e. , choosing a set of values for each hyper - parameter and training and evaluating a model for each combination of values for all the hyper - parameters .",
    "both work well when the number of hyper - parameters is small ( e.g. 2 or 3 ) but break down when there are many more : experts can handle many hyper - parameters , but results become even less reproducible and algorithms less accessible to non - experts .",
    "more systematic approaches are needed .",
    "an approach that we have found to scale better is based on random search and greedy exploration .",
    "the idea of random search  @xcite is simple and can advantageously replace grid search . instead of forming a regular grid by choosing a small set of values for each hyper - parameter , one defines a distribution from which to sample values for each hyper - parameter , e.g. , the log of the learning rate could be taken as uniform between @xmath219 and @xmath220 , or the log of the number of hidden units or principal components could be taken as uniform between @xmath221 and @xmath222 . the main advantage of random ( or quasi - random )",
    "search over a grid is that when some hyper - parameters have little or no influence , random search does not waste any computation , whereas grid search will redo experiments that are equivalent and do not bring any new information ( because many of them have the same value for hyper - parameters that matter and different values for hyper - parameters that do not ) . instead , with random search , every experiment is different , thus bringing more information .",
    "in addition , random search is convenient because even if some jobs are not finished , one can draw conclusions from the jobs that are finished .",
    "in fact , one can use the results on subsets of the experiments to establish confidence intervals ( the experiments are now all iid ) , and draw a curve ( with confidence intervals ) showing how performance improves as we do more exploration .",
    "of course , it would be even better to perform a sequential optimization  @xcite ( such as bayesian optimization  @xcite ) in order to take advantage of results of training experiments as they are obtained and sample in more promising regions of configuration space , but more research needs to be done towards this .",
    "on the other hand , random search is very easy and does not introduce additional hyper - hyper - parameters ( one still need to define reasonable ranges for the hyper - parameters , of course ) .",
    "one of the weaknesses of rbms , auto - encoders and other such models that reconstruct or resample inputs during training is that they do not readily exploit sparsity in the input , and this is particularly important for very high - dimensional sparse input vectors , as often constructed in natural language processing and web applications . in the case of a traditional feedforward neural network ,",
    "the computation of the first layer of features can be done efficiently , by considering only the non - zeros in the input , and similarly in the back - propagation phase , only the gradient on the weights associated with a non - zero input needs to be computed . instead",
    ", rbms , boltzmann machines in general , as well as all the auto - encoder and sparse coding variants require some form of reconstruction or computation associated with each of the elements of the input vector _ whether its value is zero or not_. when only dozens of input elements are non - zero out of hundreds of thousands , this is a major computational increase over more traditional feedforward supervised neural network methods , or over semi - supervised embedding  @xcite .",
    "a solution has recently been proposed in the case of auto - encoder variants , using an importance sampling strategy  @xcite .",
    "the idea is to compute the reconstruction ( and its gradient ) for each example on a small randomly sampled set of input units , such that in average ( over samples of subsets , and examples ) the correct criterion is still minimized . to make the choice of that subsample efficient ( yielding a small variance estimator ) , the authors propose to always include the non - zeros of the original input , as well as an identical number of uniformly sampled zeros . by appropriately weighing the error ( and its gradient ) , the expected gradient remains unchanged .",
    "a particularly appealing use of representation learning is in the case where _ labels for the task of interest are not available at the time of learning the representation_. one may wish to learn the representation either in a purely unsupervised way , or using _ labeled examples for other tasks_. this type of setup has been called self - taught learning  @xcite but also falls in the areas of transfer learning , domain adaptation , and multi - task learning ( where typically one also has labels for the task of interest ) and is related to semi - supervised learning ( where one has many unlabeled examples and a few labeled ones ) . in an unsupervised representation - learning phase , one may have access to examples of only some of the classes or tasks , and the hypothesis is that the representation learned could be useful for other classes or tasks .",
    "one therefore assumes that _ some _ of the factors that explain the input distribution @xmath223 for @xmath27 in the training classes , and that will be captured by the learned representation , will be useful to model data from other classes or in the context of other tasks .",
    "the simplest setting is _ multi - task learning _  @xcite and it has been shown in many instances  @xcite how a representation can be successfully shared across several tasks , with the prediction error gradients associated with each task putting pressure on the shared representation so that it caters to the demands from all the tasks . this would of course be a wasted effort if there were no common underlying factors .",
    "deep learning has also been particularly successful in _ transfer learning _",
    "@xcite , where examples of the classes found in the test set are not even provided in the representation - learning phase .",
    "another example where this approach is useful is when the test domain is very different from the training domain , or _",
    "domain adaptation _",
    "the target classes are the same in the different domains ( e.g. predict user sentiment from their online comment ) but expressed in different ways in different domains ( e.g. , book comments , movie comments , etc . ) . in this case",
    ", the success of unsupervised deep learning  @xcite presumably comes because it can extract _ higher - level abstractions _ , that are more likely to be applicable across a large number of domains .",
    "this will happen naturally when the unsupervised learning takes place on a variety of training domains in the first place , and is particularly interesting when there are domains for which very few labels are available .",
    "the success of these approaches has been demonstrated by winning two international machine learning competitions in 2011 , the unsupervised and transfer learning challenge  @xcite , and the transfer learning challenge  @xcite",
    "this review of representation learning and deep learning has covered three major and apparently disconnected approaches : the probabilistic models ( both the directed kind such as sparse coding and the undirected kind such as boltzmann machines ) , the reconstruction - based algorithms related to auto - encoders , and the geometrically motivated manifold - learning approaches .",
    "drawing connections between these approaches is currently a very active area of research and is likely to continue to produce models and methods that take advantage of the relative strengths of each paradigm . * practical concerns and guidelines .",
    "* one of the criticisms addressed to artificial neural networks and deep learning algorithms is that they have many hyper - parameters and variants and that exploring their configurations and architectures is an art .",
    "this has motivated an earlier book on the `` tricks of the trade ''  @xcite of which  @xcite is still relevant for training deep architectures , in particular what concerns initialization , ill - conditioning and stochastic gradient descent .",
    "a good and more modern compendium of good training practice , particularly adapted to training rbms , is provided in  @xcite , while a similar guide oriented more towards deep neural networks can be found in  @xcite , both of which are part of a novel version of the above book .",
    "recent work on automating hyper - parameter search  @xcite is also making it more convenient , efficient and reproducible .",
    "* incorporating generic ai - level priors .",
    "* we have covered many high - level generic priors that we believe could bring machine learning closer to ai by improving representation learning .",
    "many of these priors relate to the assumed existence of multiple underlying factors of variation , whose variations are in some sense orthogonal to each other .",
    "they are expected to be organized at multiple levels of abstraction , hence the need for deep architectures , which also have statistical advantages because they allow to _ re - use _ parameters in a combinatorially efficient way .",
    "only a few of these factors would typically be relevant for any particular example , justifying sparsity of representation .",
    "these factors are expected to be related to simple ( e.g. , linear ) dependencies , with subsets of these explaining different random variables of interest ( inputs , tasks ) and varying in structured ways in time and space ( temporal and spatial coherence ) .",
    "we expect future successful applications of representation learning to refine and increase that list of priors , and to incorporate most of them instead of focusing on only one .",
    "research in training criteria that better take these priors into account are likely to move us closer to the long - term objective of discovering learning algorithms that can _ disentangle _ the underlying explanatory factors",
    ".    * inference .",
    "* we anticipate that methods based on directly parametrizing a representation function will incorporate more and more of the iterative type of computation one finds in the inference procedures of probabilistic latent - variable models .",
    "there is already movement in the other direction , with probabilistic latent - variable models exploiting approximate inference mechanisms that are themselves learned ( i.e. , producing a parametric description of the representation function ) .",
    "a major appeal of probabilistic models is that the semantics of the latent variables are clear and this allows a clean separation of the problems of modeling ( choose the energy function ) , inference ( estimating @xmath192 ) , and learning ( optimizing the parameters ) , using generic tools in each case . on the other hand , doing approximate inference and not taking that approximation into account explicitly in the approximate optimization for learning could have detrimental effects , hence the appeal of learning approximate inference .",
    "more fundamentally , there is the question of the multimodality of the posterior @xmath192 .",
    "if there are exponentially many probable configurations of values of the factors @xmath85 that can explain @xmath33 , then we seem to be stuck with very poor inference , either focusing on a single mode ( map inference ) , assuming some kind of strong factorization ( as in variational inference ) or using an mcmc that can not visit enough modes of @xmath192 .",
    "what we propose as food for thought is the idea of dropping the requirement of an _ explicit _ representation of the posterior and settle for an _ implicit _ representation that exploits potential structure in @xmath192 in order to represent it compactly : even though @xmath192 may have an exponential number of modes , it may be possible to represent it with a small set of numbers .",
    "for example , consider computing a deterministic feature representation @xmath224 that implicitly captures the information about a highly multi - modal @xmath192 , in the sense that all the questions ( e.g. making some prediction about some target concept ) that can be asked from @xmath192 can also be answered from @xmath224 .",
    "* optimization .",
    "* much remains to be done to better understand the successes and failures of training deep architectures , both in the supervised case ( with many recent successes ) and the unsupervised case ( where much more work needs to be done ) .",
    "although regularization effects can be important on small datasets , the effects that persist on very large datasets suggest some optimization issues are involved .",
    "are they more due to local minima ( we now know there are huge numbers of them ) and the dynamics of the training procedure ? or are they due mostly to ill - conditioning and may be handled by approximate second - order methods ?",
    "these basic questions remain unanswered and deserve much more study .",
    "[ ] yoshua bengio is full professor of the department of computer science and operations research and head of the machine learning laboratory ( lisa ) at the university of montreal , cifar fellow in the neural computation and adaptive perception program , canada research chair in statistical learning algorithms , and he also holds the nserc - ubisoft industrial chair . his main research ambition is to understand principles of learning that yield intelligence .    [ ] aaron courville is an assistant professor of the department of computer science and operations research at the university of montreal .",
    "his recent research interests have focused on the development of deep learning models and methods .",
    "he is particularly interested in developing probabilistic models and novel inference methods .",
    "[ ] pascal vincent is an associate professor of the department of computer science and operations research at the university of montreal , and cifar associate in the neural computation and adaptive perception program .",
    "his recent research has focused on novel principles for learning direct encodings of representations .",
    "he is also interested in developing alternative parameter estimation techniques for probabilistic models ."
  ],
  "abstract_text": [
    "<S> the success of machine learning algorithms generally depends on data representation , and we hypothesize that this is because different representations can entangle and hide more or less the different explanatory factors of variation behind the data . although specific domain knowledge can be used to help design representations , learning with generic priors can also be used , and the quest for ai is motivating the design of more powerful representation - learning algorithms implementing such priors . </S>",
    "<S> this paper reviews recent work in the area of unsupervised feature learning and deep learning , covering advances in probabilistic models , auto - encoders , manifold learning , and deep networks . </S>",
    "<S> this motivates longer - term unanswered questions about the appropriate objectives for learning good representations , for computing representations ( i.e. , inference ) , and the geometrical connections between representation learning , density estimation and manifold learning .    </S>",
    "<S> deep learning , representation learning , feature learning , unsupervised learning , boltzmann machine , autoencoder , neural nets    .... notation : please add your own here * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ....    @xmath0 input dimensionality .    </S>",
    "<S> @xmath1 dimensionality of learned feature vector </S>",
    "<S> .    @xmath2 = t - th example input    @xmath3 = representation of @xmath2    @xmath4 = parameters    @xmath5 = dictionary or first layer weights    @xmath6 = hidden units biases    @xmath7 = input units biases    @xmath8 = encoder    @xmath9 = decoder    @xmath10 or @xmath11 = partition function    @xmath12 = regularization coefficient    @xmath13 = training criterion    @xmath14 = loss function ( e.g. reconstruction error )    @xmath15 = transpose ( by opposition to @xmath16 which can be confusing )    @xmath17 = energy function    @xmath18 = generic random variable for observed data    @xmath19 = logistic sigmoid function    @xmath20 = reals    @xmath21 } $ ] = expectation    .... * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ....    \\1 . </S>",
    "<S> introduction    \\2 . </S>",
    "<S> motivation ( new ) : recent successes of feature learning methods . </S>",
    "<S> speech recognition activity recognition object recognition use this to introduce ideas that we will see later . such as conv - nets etc .    </S>",
    "<S> \\3 . what makes a good representation ? </S>",
    "<S> try to string together a story out of the recent successes . </S>",
    "<S> ( 1 ) abstraction helps / invariance helps . </S>",
    "<S> ( 2 ) depth helps because depth leads to abstraction . </S>",
    "<S> ( this point is fuzzy to me , i m not sure of the evidence here . ) </S>",
    "<S> ( 3 ) regularization ( pretraining ) helps when there is a small number of examples .    </S>",
    "<S> \\4 . </S>",
    "<S> what is a deep architecture ? ( 1 ) multiple layers of learned features . </S>",
    "<S> ( 2 ) typically made up of layerwise learning modules that are trained greedily ( 3 ) ( possible exceptions of the layerwise learning could be considered and could be interesting but are current difficult to train . )    \\5 . </S>",
    "<S> what are these layerwise learning modules ? </S>",
    "<S> ( 1 ) they come in two basic flavors probabilistic and deterministic . </S>",
    "<S> ( 2 ) strengths and weaknesses of each . </S>",
    "<S> semantic units versus computational units . </S>",
    "<S> ( 3 ) this distinction is simplistic and is often problematic ( eg . </S>",
    "<S> sparse coding ) , jepada would go here .    </S>",
    "<S> \\6 . </S>",
    "<S> probabilistic models . </S>",
    "<S> ( 1 ) directed models ( 2 ) undirected models ( 3 ) severely restricted section on real - valued data modeling ( cut down to a paragraph ) .    </S>",
    "<S> . deterministic models . </S>",
    "<S> ( 1 ) autoencoders ( 2 ) manifold methods / interpretations    \\8 </S>",
    "<S> . connections between probabilistic and deterministic models ( there are here and not above because they rely a bit on the details of the previous two sections . ) </S>",
    "<S> ( 1 ) lots of resent work has gone into describing the connections between them . </S>",
    "<S> pascal s work ( 2 ) merging these is popular now : einser s and bagnell s approaches , i.e. building a probabilistic model and then unrolling the computational graph and learning on it .    </S>",
    "<S> \\9 . </S>",
    "<S> building in invariance : ( 1 ) domain knowledge invariance , i.e. conv - nets etc . </S>",
    "<S> ( 2 ) domain knowledge disentangling , i.e. transforming autoencoder , deconvolutional network , etc . ( 3 ) learning to disentangle .    </S>",
    "<S> \\10 . </S>",
    "<S> practical considerations . </S>"
  ]
}