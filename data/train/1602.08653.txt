{
  "article_text": [
    "structured programming was one of the main topics in computer science in the years around 1970 .",
    "it can be viewed as a method for the development and description of algorithms and programs . basically , it consists of a top - down formulation of the algorithm , breaking it into blocks or modules .",
    "the blocks are stepwise refined , possibly generating new , smaller blocks , until refinements no longer exist .",
    "the technique constraints the description of the modules to contain only three basic control structures : _ sequence _ , _ selection _ and _ iteration_. the first of them corresponds to sequential statements of the algorithm ; the second refers to comparisons leading to different outcomes ; the last one corresponds to sets of actions performed repeatedly in the algorithm .",
    "one of the early papers about structured programming was the article by dijkstra `` go - to statement considered harmful ''  @xcite , which brought the idea that the unrestricted use of go - to statements is incompatible with well structured algorithms .",
    "that paper was soon followed by a discussion in the literature about go - to s , as in the papers by knuth and floyd  @xcite , wulf  @xcite and knuth  @xcite .",
    "other classical papers are those by dahl and hoare  @xcite , hoare  @xcite and wirth  @xcite , among others . guidelines of structured programming were established in an article by dijkstra  @xcite .",
    "the early development of programming languages containing blocks , such as algol ( wirth  @xcite ) and pascal ( naur  @xcite ) , was an important reason for structured programming s widespread adoption .",
    "this concept has been then further developed in papers by kosaroju  @xcite , describing the idea of reducibility among flowcharts . moreover ,",
    "@xcite has introduced and characterized the class of _ d - charts _ , which in fact are graphs properly containing all those which originate from structured programming . williams  @xcite also describes variations of different forms of structuredness , including the basic definitions by dijkstra , as well as d - charts .",
    "the different forms of unstructuredness were described in papers by williams  @xcite and mccabe  @xcite .",
    "the conversion of a unstructured flow diagram into a structured one has been considered by williams and ossher  @xcite , and oulsnam  @xcite .",
    "formal aspects of structured programming include the papers by bhm and jacopini  @xcite , harel  @xcite , and kozen and tseng  @xcite .",
    "a mathematical theory for modeling structuredness , designed for flow graphs , in general , has been described by fenton , whitty and kaposi  @xcite . the actual influence of the concept of structured programming in the development of algorithms for solving various problems in different areas occurred right from the start ,",
    "either explicitly , as in the papers by henderson and snow  @xcite , and knuth and szwarcfiter  @xcite , or implicitly as in the various graph algorithms by tarjan , e.g.  @xcite .    a natural question regarding structured programming is to recognize whether a given program is structured . to our knowledge ,",
    "such a question has not been solved neither in the early stages of structured programming , nor later .",
    "that is the main purpose of the present paper .",
    "we formulate an algorithm for recognizing whether a given program is structured , according to dijkstra s concept of structured programming .",
    "note that the input comprises the binary code , not the source code .",
    "a well - known representation that comes in handy is that of the _ control graph _ ( cfg ) of a program , employed by the majority of reverse - engineering tools to perform data - flow analysis and optimizations .",
    "a cfg represents the intraprocedural computation of a function by depicting the existing links across its basic blocks .",
    "each basic block represents a straight line in the program s instructions , ending ( possibly ) with a branch .",
    "an edge @xmath1 ( from the exit of block a to the start of block b ) represents the program flowing from a to b at runtime .",
    "we are then interested in the version of the recognition problem which takes as input a control flow graph of the program  @xcite : a directed graph representing the possible sequences of basic blocks along the execution of the program .",
    "our problem thus becomes graph - theoretic : given a control flow graph , decide whether it has been produced by a structured program .",
    "we apply a reducibility method , whose reduction operations iteratively obtain smaller and smaller control flow graphs .    in this paper",
    ", we first define the class of graphs which correspond to structured programs , as considered by dijkstra in  @xcite .",
    "such a class has then been named as _ dijkstra graphs_. we describe a characterization that leads to a greedy @xmath0 time recognition algorithm for a dijkstra graph with @xmath2 vertices . among the potential direct applications of the proposed algorithm , we can mention software watermarking via control flow graph modifications  @xcite .",
    "additionally , we formulate an isomorphism algorithm for the class of dijkstra graphs .",
    "the method consists of defining a convenient code for a graph of the class , which consists of a string of integers .",
    "such a code uniquely identifies the graph , and it is shown that two dijkstra graphs are isomorphic if and only if their codes are the same .",
    "the code itself has size @xmath0 and the time complexity of the isomorphism algorithm is also @xmath0 . in case",
    "the given graphs are isomorphic , the algorithm exhibits the isomorphism function between the graphs .",
    "applications of isomorphism include code similarity analysis  @xcite , since the method can determine whether apparently distinct control flow graphs ( of structured programs ) are actually structurally identical , with potential implications in digital rights management .",
    "in this paper , all graphs are finite and directed . for a graph @xmath3 , we denote its vertex and edge sets by @xmath4 and @xmath5 , respectively , with @xmath6 , @xmath7 . for @xmath8 , an edge from @xmath9 to @xmath10",
    "is written as @xmath11 .",
    "we say @xmath11 is an _ out - edge _ of @xmath9 and an _ in - edge _ of @xmath10 , with @xmath10 an _ out - neighbor _ of @xmath9 , and @xmath9 an _ in - neighbor _ of @xmath10 .",
    "we denote by @xmath12 and @xmath13 the sets of out - neighbors and in - neighbors of @xmath9 , respectively",
    ". we may drop the subscript when the graph is clear from the context . also , we write @xmath14 meaning @xmath15 . for @xmath8 , @xmath9 _ reaches _ @xmath10 when there is a path in @xmath3 from @xmath9 to @xmath10 .",
    "a _ source _ of @xmath3 is a vertex that reaches all other vertices in @xmath3 , while a _ sink _ is one which reaches no vertex , except itself .",
    "denote by @xmath16 and @xmath17 , respectively , a source and a sink of @xmath3 .",
    "a _ ( control ) flow _ graph @xmath3 is one which contains a distinguished source @xmath16 .",
    "a _ source - sink _ graph contains both a distinguished source @xmath16 and distinguished sink @xmath17 .",
    "a _ trivial _",
    "graph contains a single vertex .",
    "a graph with no directed cycles is called _ acyclic_. in an acyclic graph if there is a path from vertex @xmath9 to vertex @xmath10 , then @xmath9 is an ancestor of @xmath10 , and the latter a descendant of @xmath9 .",
    "additionally , if @xmath18 are distinct then @xmath9 is a it proper ancestor , and @xmath10 a _",
    "proper descendant_. let @xmath3 be a flow graph with source @xmath16 , and @xmath19 a cycle of @xmath3 .",
    "the cycle @xmath19 is called a _ single - entry cycle _ if it contains a vertex @xmath20 that separates @xmath16 from the vertices of @xmath21 a flow graph in which each of its cycles is a single - entry cycle is called _",
    "reducible_. reducible graphs were characterized by hecht and ullman  @xcite .",
    "an efficient recognition algorithm for this class has been described by tarjan  @xcite .    in a _ depth - first search ( dfs ) _ of a directed graph , in each step a vertex is inserted in a stack , or removed from it .",
    "every vertex is inserted and removed from the stack exactly once .",
    "an edge @xmath22 , such that @xmath9 is inserted in the stack after @xmath10 , and before the removal of @xmath10 , is called a _",
    "cycle edge_. let @xmath19 be the set of cycle edges of a graph , relative to some dfs . clearly , the graph @xmath23 is acyclic .",
    "the following characterization if reducible flow graphs is relevant for our purposes .",
    "@xcite a flow graph @xmath3 is reducible if and only if , for any depth - first search of @xmath3 starting from @xmath16 , the set of cycle edges is invariant .    in a flow graph graph @xmath3 , we may write dfs of @xmath3 , as to mean a dfs of @xmath3 staring from @xmath16 .",
    "in addition , if @xmath3 is also reducible , based of the above theorem , we may use the terms _ ancestor _ or descendant of @xmath3 , as to mean _ ancestor _ or descendant of @xmath24 , where @xmath19 is the ( unique ) set of cycle edges of @xmath3 .",
    "a _ topological sort _ of a graph @xmath3 is a sequence @xmath25 of its vertices , such that @xmath26 implies @xmath27 .",
    "it is well known that @xmath3 admits a topological sort if and only if @xmath3 is acyclic .",
    "finally , two graphs @xmath28 are _ isomorphic _ when there is a one - to - one correspondence @xmath29 such that @xmath30 if and only if @xmath31 . in this case , write @xmath32 , and call @xmath33 an _ isomorphism function _ between @xmath34 , with @xmath35 being the _ image _ of @xmath9 under @xmath33 .",
    "in this section , we describe the graphs of structured programming , as established by dijkstra in  @xcite , leading to the definition of _ dijkstra graphs_. first , we introduce a family of graphs directly related to dijkstra s concepts of structured programming .    a _ statement graph _ is defined as being one of the following :    a.   _ trivial _ graph b.   _ sequence _",
    "graph c.   _ if _ graph d.   _ if - then - else _",
    "graph e.   _ p - case _ graph , @xmath36 f.   _ while _ graph g.   _ repeat _ graph    for our purposes , it is convenient to assign labels to the vertices of statement graphs as follows .",
    "each vertex is either an _ expansible vertex _ , labeled @xmath37 , or a _ regular vertex _ , labelled @xmath38 .",
    "see figures  [ statementgraphs1 ] and  [ statementgraphs2 ] , where the statement graphs are depicted with the corresponding vertex labels .",
    "all statement graphs are source - sink .",
    "vertex @xmath9 denotes the source of the graph in each case .",
    "[ statementgraphs1 ]     [ statementgraphs2 ]     let @xmath3 be an unlabeled reducible graph , and @xmath39 a subgraph of @xmath3 , having source @xmath40 and sink @xmath41 .",
    "we say @xmath39 is _ closed _",
    "when    * @xmath42 ; * @xmath43 ; and * @xmath44 is a cycle edge @xmath45 .    in this case , @xmath40 is the only vertex of @xmath39 having possible in - neighbors outside @xmath39 , and @xmath41 the only one possibly having out - neighbors outside @xmath39 .",
    "the following concepts are central to our purposes .",
    "let @xmath39 be an induced subgraph of @xmath3 .",
    "we say @xmath39 is _ prime _",
    "when    * @xmath39 is isomorphic to some non - trivial statement graph , and * @xmath39 is closed .",
    "it should be noted that the while and repeat graphs , respectively , ( f ) and ( g ) of figure  [ statementgraphs2 ] , are not isomorphic in the context of flow reducible graphs .",
    "in fact , the cycle edge turns them distinguishable .",
    "the sources of such graphs are the entry vertices of the cycle edge , respectively .",
    "then the sink is an out - neighbor of the source in ( f ) , but not in ( g ) .",
    "next , let @xmath46 be two graphs , @xmath47 , @xmath39 source - sink , @xmath48 .",
    "the _ expansion _ of @xmath9 into a source - sink graph @xmath39 ( figure  [ expansion ] ) consists of replacing @xmath9 by @xmath39 , in @xmath3 , such that    * @xmath49 ; * @xmath50 ; and * the remaining adjacencies are unchanged .",
    "now let @xmath3 be a graph , and @xmath39 a prime subgraph of @xmath3 .",
    "the _ contraction _ of @xmath39 into a single vertex ( figure  [ contraction ] ) is the operation defined by the following steps :    1 .",
    "identify ( coalesce ) the vertices of @xmath39 into the source @xmath40 of @xmath39 .",
    "2 .   remove all parallel edges and loops .",
    "we finally have the elements to define the class of dijkstra graphs .",
    "the concepts of structured programming and top - down refinement  @xcite lead naturally to the following definition .    a _ dijkstra graph ( dg ) _ has vertices labeled @xmath37 or @xmath38 recursively defined as :    1 .   a trivial statement graph is a dg .",
    "any graph obtained from a dg by expanding some @xmath37-vertex into a non - trivial statement graph is also a dg .",
    "furthermore , after expanding an @xmath37-labeled vertex @xmath9 into a statement graph @xmath39 , vertex @xmath40 is labeled as @xmath38 .",
    "an example is given in figure  [ dgexample ] .",
    "the above definition leads directly to a method for constructing dijkstra graphs , as follows . find a sequence of graphs @xmath51 , such that    * @xmath52 is the trivial graph , with the vertex labeled @xmath37 ; * @xmath53 is obtained from @xmath54 , @xmath55 , by expanding some x - vertex @xmath9 of it into a statement graph @xmath39 .",
    "the above construction does not imply a polynomial - time algorithm for recognizing graphs of the class . in the next section ,",
    "we describe another characterization which leads to such an algorithm .",
    "it is relevant to emphasize that the labels are used merely for constructing the graphs . for the actual recognition process",
    ", we are interested in the problem of deciding whether a given _ unlabeled _ flow graph is actually a dijkstra graph .",
    "in this section , we describe an algorithm for recognizing dijkstra graphs . for the recognition process",
    ", the hypothesis is that we are given an arbitrary flow graph @xmath3 , with no labels , and the aim is to decide whether or not @xmath3 is a dg .",
    "first , we introduce some notation and describe the propositions which form the basis of the algorithm .",
    "the following lemma states some basic properties of dijkstra graphs .    [ basic ]",
    "if @xmath3 is a dijkstra graph , then    a.   @xmath3 contains some prime subgraph ; b.   @xmath3 is a source - sink graph ; and c.   @xmath3 is reducible .    by definition , there is a sequence of graphs @xmath51 , where @xmath52 is trivial , @xmath56 and @xmath53 is obtained from @xmath54 by expanding some @xmath37-vertex @xmath57 into a statement graph @xmath58 .",
    "then no vertex @xmath59 , except @xmath60 has in - neighbors outside @xmath61 , and also no vertex @xmath59 , except @xmath62 , has out - neighbors outside @xmath61 . furthermore",
    ", if @xmath61 contains any cycle then @xmath61 is necessarily a while graph or a repeat graph .",
    "the latter implies that such a cycle is @xmath63 , where @xmath64 .",
    "therefore @xmath61 is prime in @xmath53 meaning that @xmath65 holds . to show @xmath66 and @xmath67 ,",
    "first observe that any statement graph is single - source and reducible .",
    "next , apply induction . for @xmath52",
    ", there is nothing to prove .",
    "assume it holds for @xmath53 , @xmath68 .",
    "let @xmath57 be the vertex that expanded into the subgraph @xmath58 .",
    "then the external neighborhoods of @xmath61 coincide with the neighborhoods of @xmath69 , respectively .",
    "consequently , @xmath53 is single - source .",
    "now , let @xmath70 be any cycle of @xmath53 , if existing . if @xmath71 then @xmath70 is single - entry , since @xmath54 is reducible",
    "otherwise , if @xmath72 the same is valid , since any statement graph is reducible . finally ,",
    "if @xmath73 , then @xmath69 is contained in a single - entry cycle @xmath74 of @xmath54 .",
    "then @xmath70 has been formed by @xmath74 , replacing @xmath69 by a path contained in @xmath61 .",
    "since @xmath74 is single - entry , it follows that @xmath70 must be so .",
    "denote by @xmath75 the set of non - trivial prime graphs of @xmath3 .",
    "let @xmath76 .",
    "call @xmath77 _ independent _ when    * @xmath78 , or *",
    "@xmath79 , where @xmath80 or @xmath81 .",
    "the following lemma assures that any pair of distinct , non - trivial prime subgraphs of a graph consists of independent subgraphs .",
    "[ independent ] let @xmath82 .",
    "it holds that @xmath77 are independent .    if @xmath78 the lemma holds",
    "otherwise , let @xmath83 .",
    "the alternatives @xmath84 , @xmath85 , @xmath86 or @xmath87 do not occur because they imply @xmath88 or @xmath89 not to be closed .",
    "next , let @xmath90 , @xmath91 . in this situation , examine the alternative where @xmath92 and @xmath93 .",
    "the latter implies that exactly one of @xmath88 or @xmath89 , say @xmath89 , is a while graph or a repeat graph .",
    "then there is a cycle edge @xmath94 , satisfying @xmath95 and @xmath96 .",
    "consequently , @xmath97 , contradicting @xmath88 to be closed .",
    "the only remaining alternative is @xmath98 , with @xmath99 or @xmath93 . then @xmath100 are indeed independent ( see figure  [ f : independent ] ) .        next , we introduce a concepts which central for the characterization .",
    "let @xmath3 be a graph , @xmath75 the set of non - trivial prime subgraphs of @xmath3 , and @xmath101 .",
    "denote by @xmath102 the graph obtained from @xmath3 by contracting @xmath39 . for @xmath48 ,",
    "the _ image _ of @xmath9 in @xmath103 , denoted @xmath104 , is    @xmath105    for @xmath106 , define the ( _ subset _ ) _ image _ of @xmath107 in @xmath103 , as @xmath108 .",
    "similarly , for @xmath109 , the ( _ subgraph _ ) _ image _ of @xmath110 in @xmath103 , denoted by @xmath111 , is the subgraph induced in @xmath103 by the subset of vertices @xmath112 .",
    "the following lemmas are employed in the ensuing characterization .",
    "the first shows that any prime subgraph @xmath113 is preserved under contractions of different primes .",
    "let @xmath3 be an arbitrary flow graph , @xmath114 , @xmath115 .",
    "[ prime - preservation ] @xmath116 .    let @xmath3 be a graph , @xmath114 , @xmath115",
    ". by lemma  [ independent ] , @xmath77 are independent .",
    "if @xmath77 are disjoint the contraction of @xmath39 does not affect @xmath110 , and the lemma holds .",
    "otherwise , by the independence condition , it follows that @xmath79 , where @xmath80 or @xmath117 .",
    "examine the first of these alternatives . by contracting @xmath39 , all neighborhoods of the vertices of @xmath111",
    "remain unchanged , except that of @xmath118 , since its in - neighborhood becomes equal to @xmath119 . on the other hand ,",
    "the contraction of @xmath39 into @xmath9 can not introduce new cycles in @xmath110 .",
    "consequently , @xmath110 preserves in @xmath103 its property of being a non - trivial and closed statement graph , moreover , prime .",
    "finally , suppose @xmath120 .",
    "again , the neighborhoods of the vertices of @xmath121 are preserved , except possibly the out - neighborhoods of the vertices of @xmath122 , which become @xmath123 , after possibly removing self - loops . consequently , @xmath124 .    next we prove prove a commutative law for the order of contractions .",
    "[ commutative - law ] if @xmath114 , then @xmath125    let @xmath126 and @xmath127 .",
    "by lemma  [ independent ] , @xmath77 are independent .",
    "first , suppose @xmath77 are disjoint .",
    "then @xmath128 and @xmath129 .",
    "it follows that , in both graphs @xmath130 and @xmath131 , the subgraphs @xmath39 and @xmath110 are respectively replaced by a pair of non - adjacent vertices , whose in - neighborhoods are @xmath119 and @xmath132 , and out - neighborhoods @xmath123 and @xmath133 , respectively . then @xmath134 . in the second alternatives ,",
    "suppose @xmath77 are not disjoint .",
    "then @xmath79 , where @xmath80 , or @xmath81 . in both cases , and in both graphs @xmath130 and @xmath131 , the subgraphs @xmath39 and @xmath110 are contracted into a common vertex @xmath10 .",
    "when @xmath80 , it follows @xmath135 and @xmath136 . finally , when @xmath81 , we have @xmath137 , while @xmath138 . consequently , @xmath134 in any situation . @xmath139      a sequence of graphs @xmath51 is a _ contractile sequence _ for a graph @xmath3 , when    * @xmath140 , and * @xmath141 , for some @xmath142 , @xmath143 .",
    "call @xmath61 the _ contracting prime _ of @xmath53 .",
    "we say @xmath51 is _ maximal _ when @xmath144 .",
    "in particular , if @xmath145 is the trivial graph then @xmath146 is maximal .",
    "+ let @xmath51 , be a contractile sequence of @xmath3 , and @xmath147 the contracting prime of @xmath148 .",
    "that is , @xmath149 ) , @xmath150 . for @xmath151 and @xmath152 , the _ iterated image _ of @xmath153 in @xmath154",
    "is recursively defined as    @xmath155    finally , we describe the characterization in which the recognition algorithm for dijkstra graphs is based .    [ main - characterization ] let @xmath3 be an arbitrary flow graph , with @xmath51 and @xmath156 two contractile sequences of @xmath3 . then @xmath157",
    "furthermore , @xmath158 .",
    "let @xmath51 and @xmath159 be two contractile sequences , denoted respectively by @xmath160 and @xmath161 of a graph @xmath3 .",
    "let @xmath147 and @xmath162 be the contracting primes of @xmath148 and @xmath163 , respectively .",
    "that is , @xmath164 and @xmath165 , @xmath166 and @xmath167 .",
    "without loss of generality , assume @xmath168 .",
    "let @xmath169 be the least index , such that @xmath170 , @xmath171 .",
    "such an index exists since @xmath172 . if @xmath173 then @xmath157 , implying @xmath158 and the theorem holds",
    "otherwise , @xmath143 , @xmath174 and @xmath175 .",
    "since @xmath174 , it follows @xmath176 . by lemma  [ prime - preservation ] ,",
    "the iterated image @xmath177 , of @xmath61 in @xmath178 is preserved as a prime subgraph for all @xmath178 , as long as it does not become the contracting prime of @xmath179 .",
    "since @xmath180 has no prime subgraph , it follows there exists some index @xmath181 , @xmath182 , such that @xmath183 , where @xmath184 represents the iterated image of @xmath61 in @xmath185 .",
    "let @xmath186 be the iterated image of @xmath61 in @xmath187 .",
    "clearly , @xmath188 , and by lemma  [ independent ] , @xmath189 and @xmath186 are independent in @xmath187 . since @xmath190 , by lemma  [ prime - preservation ] , it follows that @xmath191 , where @xmath192 represents the image of @xmath189 in @xmath193 .",
    "consequently , we have exchanged the positions in @xmath161 of two contracting primes , respectively at indices @xmath194 and @xmath181 , while preserving all graphs @xmath178 , for @xmath195 and @xmath196 .",
    "in particular , preserving the graph @xmath197 and all graphs lying after @xmath197 in @xmath161 , together with their corresponding contracting primes .",
    "finally , apply the above operation iteratively , until eventually the iterated image of @xmath61 becomes the contracting prime of @xmath198 . in the latter situation ,",
    "the two sequences coincide up to index @xmath199 , while preserving the original graphs @xmath145 and @xmath180 . again , applying iteratively such an argument , we eventually obtain that the two sequences turned coincident , preserving the original graphs @xmath145 and @xmath180 .",
    "consequently , @xmath157 and @xmath158 .",
    "we start with a bound for the number @xmath200 of edges of dijkstra graphs .    [ bound ] let @xmath3 be a dg graph",
    ". then @xmath201 .    :",
    "if @xmath3 is a dg graph there is a sequence of graphs @xmath202 , where @xmath52 is the trivial graph , @xmath203 and @xmath53 is obtained from @xmath54 by expanding an @xmath37-vertex of @xmath54 into a statement graph .",
    "apply induction on the number of expansions employed in the construction of @xmath3 . if @xmath204 then @xmath3 is a trivial graph , which satisfies the lemma . for @xmath205 ,",
    "suppose the lemma true for any graph @xmath206 , @xmath143 .",
    "in particular , let @xmath207 .",
    "let @xmath208 and @xmath209 be the number of vertices and edges of @xmath210 , respectively .",
    "then @xmath211 .",
    "we know that @xmath145 has been obtained by expanding a vertex of @xmath212 into a statement graph @xmath39 .",
    "discuss the alternatives for @xmath39 . if @xmath39 is the trivial graph then @xmath213 and @xmath214 . if @xmath39 is a sequence graph then @xmath215 and @xmath216 .",
    "if @xmath39 is an if graph , a while graph or repeat graph then @xmath217 and @xmath218 . if @xmath39 is an if then else graph or a @xmath181-case graph then @xmath219 and @xmath220 , where @xmath181 is the outdegree of the source of @xmath39 . in any of these alternatives , a simple calculation implies @xmath221 .",
    "we can describe an algorithm for recognizing dijkstra graphs based on theorem  [ main - characterization ] .",
    "we recall that the input is a unlabeled flow graph with no labels .",
    "furthermore , for a while , assume that @xmath3 is reducible , otherwise by lemma  [ basic ] it is surely not a dijkstra graph .",
    "let @xmath3 be a flow reducible graph . to apply theorem  [ main - characterization ]",
    ", we construct a contractile sequence @xmath51 of @xmath3 .",
    "that is , find iteratively a non - trivial prime subgraph @xmath61 of the @xmath53 and contract it , until either the graph becomes trivial or otherwise no such subgraph exists .",
    "in the first case the graph is a dg , while in the second it is not .",
    "recall from lemma  [ prime - preservation ] that whenever @xmath53 contains another prime @xmath222 then the iterated image of @xmath147 is preserved , as long as it does not become the contracting prime in some later iteration . on the other hand , the contraction @xmath223 may generate a new prime @xmath224 , as shown in figure  [ fig : generator ] .",
    "however , the generation of new primes obeys a rule , described by the lemma below .     [",
    "fig : generator ]    [ lem : generator - generated ] let @xmath3 be reducible graph , @xmath101 , @xmath225 .",
    "then @xmath40 is a proper descendant of @xmath226 in @xmath103 .",
    "the above lemma suggests us to consider special contractile sequences , as below .",
    "let @xmath3 be a reducible graph , @xmath51 a contractile sequence @xmath227 of @xmath3 , @xmath61 the contracting prime of @xmath53 , @xmath228 .",
    "say that @xmath227 is a _ bottom - up ( contractile ) sequence _ of @xmath3 when each contracting prime @xmath61 satisfies : @xmath60 is not a descendant of @xmath40 , for any prime @xmath229 of @xmath53 .",
    "the idea of the recognition algorithm then becomes as follows .",
    "let @xmath3 be a reducible graph .",
    "iteratively , find a lowest vertex @xmath9 of @xmath3 , s.t .",
    "@xmath9 is the source of a prime subgraph @xmath39 of @xmath3 . then contract @xmath39 .",
    "stop when noprimes exist any more .",
    "a complete description of the algorithm is below detailed .",
    "the algorithm answers yes or no , according to respectively @xmath3 is a dijkstra graph or not .",
    "@xmath3 , arbitrary flow graph ( no labels ) + count the number @xmath200 of edges of @xmath3 . if @xmath230 then * return * no + @xmath231 , set of cycle edges of a dfs of @xmath3 , starting at @xmath16 + @xmath25 , topological sorting of @xmath232 + @xmath233 + * while * @xmath55 * do * + @xmath3 is the trivial graph + yes , * stop * + if @xmath234 is the source of a prime subgraph @xmath39 of @xmath3 + @xmath235 + @xmath236 + * return * no    the correctness of algorithm  [ alg : recognition ] follows basically from theorem  [ main - characterization ] and lemma  [ lem : generator - generated ] .",
    "however , the latter relies on the fact that @xmath3 is a reducible graph , whereas the proposed algorithm considers as input an arbitrary graph .",
    "the lemma below justifies that can we avoid the step of recognizing reducible graphs .    [",
    "lem : avoid - rec - reducible ] let @xmath3 be an arbitrary flow graph input to algorithm  [ alg : recognition ] .",
    "if @xmath3 is not a reducible graph then the algorithm would correctly answer no .",
    "if @xmath3 is not a reducible graph let @xmath231 be the set of cycle edges , relative to some dfs startingate @xmath16 .",
    "then @xmath3 contains some cycle @xmath19 , such that @xmath10 does not separate @xmath16 from @xmath9 , where @xmath237 is the cycle edge of @xmath19 . without loss of generality , consider the inner most of these cycles .",
    "the only way in which the edge @xmath11 , or any of its possible images , can be contracted is in context the of a while or repeat prime subgraph @xmath39 , in which the cycle would be contracted into vertex @xmath10 , or a possible iterated image of it .",
    "however there is no possibility for @xmath39 to be identified as such , because the edge entering the cycle from outside prevents the subgraph to be closed .",
    "consequently , the algorithm necessarily would answer no .    as for the complexity",
    ", first observe that to decide whether the graph contains a non - trivial prime subgraph whose source is a given vertex @xmath48 , we need @xmath238 steps . therefore ,",
    "when considering all vertices of @xmath3 we require @xmath239 time",
    ". there can be @xmath0 prime subgraphs altogether , and each time some prime @xmath39 is identified , it is contracted , and the size of the graph decreases by @xmath240 .",
    "the number of steps required to contract a @xmath39 is @xmath241 .",
    "hence each edge is examined at most a constant number of times during the entire process . finding a topological sorting of a graph",
    "can be done in @xmath239 .",
    "thus , the time complexity is @xmath239 , that is , @xmath0 , by lemma  [ bound ] .",
    "in this section , we describe a linear time algorithm for the isomorphism of dijkstra graphs .    given a dijkstra graph @xmath3 , the general idea consists of defining a code @xmath242 for @xmath3 , having the following property . for any two dijkstra graphs",
    "@xmath34 , @xmath32 if and only if @xmath243 .    as in the recognition algorithm ,",
    "the codes are obtained by constructing a bottom - up contractile sequence of each graph .",
    "the codes refer explicitly to the statement graphs having source @xmath9 as depicted in figures  [ statementgraphs1 ] and  [ statementgraphs2 ] , and consist of ( linear ) strings . for a dijkstra graph @xmath3 , the string @xmath242 that will be coding @xmath3",
    "is constructed over an alphabet of symbols containing integers in the range @xmath244 , where @xmath245 is the maximum cardinality among the out - neighborhoods of @xmath3 .",
    "let , @xmath246 be a pair of strings .",
    "the concatenation of @xmath130 and @xmath131 , denoted @xmath247 , is the string formed by @xmath130 , immediately followed by @xmath131 .    in order to define the code @xmath242 for a dijkstra graph @xmath3",
    ", we assign an integer , named @xmath248 , for each statement graph @xmath39 , a code @xmath249 for each vertex @xmath48 , and a code @xmath250 for each prime subgraph @xmath39 of a bottom - up contractile sequence of @xmath3 .",
    "the code @xmath242 of the graph @xmath3 is defined as being that of the source of @xmath3 . for a subset @xmath106 , the code @xmath251 of @xmath107 is the set of strings @xmath252 .",
    "write @xmath253 whenever @xmath254 and @xmath255 is lexicographically not greater than @xmath256 .",
    ".statement graph types and codes @xmath250 of prime subgraphs",
    "@xmath39 [ cols=\"^,^ , < \" , ]     next , we describe how to obtain the actual codes .",
    "the types of the the different statement graphs are shown in the second column of table  [ t : types - primes ] . for a vertex @xmath48 ,",
    "the code @xmath249 is initially set to 1 .",
    "subsequently , if @xmath9 becomes the source of a prime graph @xmath39 , the string @xmath249 is updated by implicitly assigning @xmath257 where @xmath250 is given by the third column of the table .",
    "such an operation is called the _ expansion _ of @xmath9 .",
    "it follows that @xmath250 is written in terms of @xmath248 and the codes of the vertices of @xmath39 , and so on iteratively . a possible expansion of some other vertex @xmath258 could imply in an expansion of @xmath9 , and so iteratively .",
    "observe that when @xmath39 is an if - then - else or a @xmath181-case graph , we have chosen to place the codes of the out - neighbors of @xmath40 in lexicographic ordering .",
    "for the remaining statement graphs @xmath39 , the ordering of the codes of the out - neighbors of @xmath40 is also unique and implicitly imposed by @xmath39 .",
    "when all primes associated to @xmath249 have been expanded , @xmath249 has reached its final value ,      next , we describe the actual formulation of the algortithm .",
    "let @xmath3 be a dg .",
    "algorithm  [ alg : isomorphism ] constructs the encoding @xmath242 for @xmath3 .",
    "@xmath3 , dg ; @xmath231 , set of cycle edges of @xmath3 + find a topological sorting @xmath25 of @xmath259 + * for * @xmath260 * do * + @xmath261 + @xmath234 is the source of a prime subgraph @xmath39 * then * + @xmath262 @xmath263    an example is given in figure  [ f : spexalg ] .",
    "[ thm : isomorphism ] let @xmath264 de dijkstra graphs , and @xmath265 their codes , respectively",
    ". then @xmath266 are isomorphic if and only if @xmath267 .    by hypothesis , @xmath264 are isomorphic .",
    "we show that it implies @xmath267 .",
    "following the isomorphism algorithm , observe that the number of 1 s in the strings @xmath265 represents the number of vertices of @xmath266 , respectively , whereas each integer @xmath268 in the strings , represents the contraction of a prime subgraph .",
    "furthermore , each prime subgraph @xmath39 , which is initially contained in the input graph @xmath3 , corresponds in @xmath242 , to a substring formed by the integer @xmath248 followed by one 1 , if @xmath269 ; or two 1 s , if @xmath270 ; or three 1 s , if @xmath271 ; or @xmath272 1 s , if @xmath273 ; respectively .",
    "clearly , the same holds for the graph @xmath210 and its code @xmath274 .",
    "the proof is by induction on the number @xmath275 of contractions needed to reduce both @xmath3 and @xmath210 to a trivial vertex . by theorem  [ main - characterization ]",
    ", @xmath275 is invariant and applies for both graphs @xmath3 and @xmath210 . if @xmath204 then both @xmath3 and @xmath210 are trivial graphs , and the theorem holds , since @xmath276 .",
    "when @xmath277 , assume that if @xmath278 and @xmath279 are isomorphic dg graphs which require less than @xmath275 contractions for reduction then @xmath280 .",
    "furthermore , assume also by the induction hypothesis , that if @xmath281 are vertices of @xmath282 , corresponding to 1 s at the same relative positions in @xmath242 and @xmath283 , respectively , then @xmath284 , where @xmath33 is the isomorphism function between @xmath278 and @xmath279 .",
    "now , consider the graphs @xmath3 and @xmath210 . choose a prime subgraph @xmath39 of @xmath3 , and",
    "let @xmath285 .",
    "let @xmath284 be a vertex of @xmath210 corresponding to @xmath9 by the isomorphism .",
    "since @xmath286 , it follows that @xmath287 is the source of a prime subgraph @xmath110 of @xmath210 .",
    "moreover @xmath288 .",
    "consider the contractions @xmath103 and @xmath289 , leading to graphs @xmath278 and @xmath279 , respectively .",
    "let @xmath290 and @xmath291 be the strings obtained from @xmath242 and @xmath274 , respectively by contracting the substrings corresponding to @xmath39 and @xmath110 , as above .",
    "that is , all the 1 s of @xmath250 and @xmath292 are compressed into the positions of @xmath293 and @xmath294 , respectively , while the integers @xmath248 and @xmath295 become 1 , maitaining their original positions .",
    "it follows that @xmath296 and @xmath297 . by the induction hypothesis @xmath280 and",
    "the 1 s corresponding to @xmath9 and @xmath287 lie in the same relative positions in the strings .",
    "consequently , by replacing the latter 1 s for the substrings which originally represented @xmath39 and @xmath110 , we conclude that indeed @xmath267 , and moreover the induction hypothesis is still verified .",
    "the converse is similar .",
    "the corollaries below are direct consequences of theorem  [ thm : isomorphism ] .",
    "[ cor : unique ] let @xmath3 be a dg .",
    "the following affirmatives hold .    1 .",
    "there is a one - to - one correspondence between the 1 s of @xmath242 and the vertices of @xmath3 .",
    "the code @xmath242 of g is unique and is a representation of @xmath3 .",
    "[ cor:1 - 1 ] let @xmath266 be dgs and @xmath298 their corresponding codes , satisfying @xmath267 .",
    "then an isomorphism function @xmath33 between @xmath3 and @xmath210 can be determined as follows .",
    "let @xmath48 and @xmath299 correspond to 1 s at identical relative positions in @xmath242 and @xmath274 , respectively .",
    "define @xmath300 .",
    "finally , consider the complexity of the isomorphism algorithm .",
    "[ lem : length ] let @xmath3 be a dijkstra graph , and @xmath242 its code",
    ". then @xmath301 , where @xmath2 is the number of vertices of @xmath3 and @xmath275 the number of contractions needed to reduce it to a trivial vertex .",
    "the encoding @xmath242 consists of exactly @xmath2 1 s , together with elements of a multiset @xmath302 .",
    "we know that @xmath242 starts and ends with an 1 , and it contains no two consecutive elements of @xmath303 .",
    "therefore @xmath304 .",
    "when @xmath3 consists of the induced path @xmath305 , it follows @xmath306 , attaining the bound .",
    "[ thm : complexity - iso ] the isomorphism algorithm terminates within @xmath0 time .",
    "recall that @xmath307 , by lemma  [ bound ] .",
    "the construction of a bottom - up contractile sequence requires @xmath0 steps . for each @xmath48 , following the isomorphism algorithm , @xmath249 can be constructed in time @xmath308 .",
    "we remark that lexicographic ordering takes linear time on the total length of the strings to be sorted .",
    "it follows that the algorithm requires no more than @xmath0 time to construct the code @xmath242 of @xmath3 .",
    "the analysis of control flow graphs and different forms of structuring have been considered in various papers . to our knowledge , no full characterization and no recognition algorithm for control flow graphs of structured programs have been described before .",
    "there are some related classes for which characterizations and efficient recognition algorithms do exist , e.g.  the classes of reducible graphs and d - charts . however , both contain and are much larger than dijkstra graphs .",
    "an important question solved in this paper is that of recognizing whether two control flow graphs ( of structured programs ) are syntactically equivalent , i.e. , isomorphic .",
    "such question fits in the area of _ code similarity analysis _",
    ", with applications in clone detection , plagiarism and software forensics .",
    "since the establishment of structured programming , some new statements have been proposed to add to the original structures which forms the classical structured programming , enlarging the collection of allowed statements . some of such relevant statements are depicted in figures  [ fig : gdg ] .",
    "a.   _ break - while _ : allows an early exit from a while statement ; b.   _ continue - while _ : allows a while statement to proceed , after its original termination ; c.   _ break - repeat _ : allows an early exit from a repeat statement ; d.   _ continue - repeat _ : allows a repeat statement to proceed , after its original termination ; e.   _ divergent - if - then - else _ : a selection statement , similar to the standard _ if - then - else _ , except that the comparisons do not converge afterwords to a same point , but lead to disjoint structures .",
    "note that the corresponding graph has no longer a ( unique ) sink .",
    "in fact , the inclusion of some of the above additional control blocks in structured programming has been already predicted in some papers , as  @xcite .",
    "the basic ideas and techniques described in the present work can be generalized , so as to efficiently recognize graphs that incorporate the above statements , in addition to those of dijkstra graphs .",
    "similarly , for the isomorphism algorithm .",
    "the authors are grateful to victor campos for the helpful discussions and comments during the french - brazilian workshop of graphs and optimizations , in redonda , ce , brazil , 2016 .",
    "he pointed out the possibility of decreasing the complexity of the recognition algorithm from @xmath309 to @xmath0 .",
    "50 f. e. allen and j. cocke , a program data flow analysis procedure , _ comm",
    ". acm _ 19 ( 1976 ) , 137147 .",
    "a. v. aho and j. d. ullman , node listings for reducible flow graphs , _ j. of computer and systems scien.ces_ 13 ( 1976 ) 286 - 299 l. m. s. bento , d. r. boccardo , r. c. s. machado , v. g. pereira de s and j. l. szwarcfiter , towards a provably resilient scheme for graph - based watermarking , _ proc .",
    "39th intl .",
    "workshop on graph - theoretic concepts in comp .",
    "( wg13 ) , lncs _ 8165 ( 2013 ) , 5063 .",
    "c. bhm and g. jacopini , flow diagrams , turing machines and languages with only two formation rules , _ comm .",
    "of the acm _ 9 ( 1966 ) , 366 - 371 n. chapin and s. p. denniston , characteristics of a structured program , _ acm sigplan notices _ 13 ( 1978 ) , 3645 . c. collberg , s. kobourov , e. carter and c. thomborson , error - correcting graphs for software watermarking ,",
    "_ 29th workshop on graph - theoretic concepts in computer science , ( wg03 ) , lecture notes in computer science _ 2880 ( 2003 ) , 156167 .",
    "collberg , c. and j. nagra , _ surreptitious software : obfuscation , watermarking , and tamperproofing for software protection_. addison wesley ( 2010 ) .",
    "e. w. dijkstra , go - to statement considered harmful , _ comm .",
    "acm _ 11 ( 1968 ) , 174186 .",
    "j . dahl and c. a. hoare , hierarchical program structures , in _ structured programming _",
    ", academic press , 1972 , 175 - 220 .",
    "e. w. dijkstra , notes on structured programming , in _ structured programming _ ( 1972 ) , 182 , acad . press .",
    "n.e.fenton , r. w. whitty and a. a. kaposi , a generalized mathematical theory of structured programming , _ theoretical computer science _ 36 ( 1985 ) , 145 - 171 d. harel , on folk theorems , _ comm . of the acm _ 23 ( 1980 ) , 379 - 389 m. s. hecht and j. d. ullman , flow graph reducibility , _",
    "siam j. on comp .",
    "_ 1 ( 1972 ) , 188 - 202 . m. s. hecht and j. d. ullman , characterizations of reducible flow graphs , _",
    "j. acm _ 21 ( 1974 ) , 367374 .",
    "p. henderson and r. snow , an experiment in structured programming , _ bit _ 12 ( 1972 ) , 3853 . c. a. r. hoare , notes on data structuring , in _ structured programming _ , academic press , 1972 , 83 - 174 .",
    "d. e. knuth , structured programming with go - to statements , _ acm comp .",
    "surveys _ 6 ( 1974 ) 261301 .",
    "d. e. knuth and r. w. floyd , notes on avoinding go to statements , _ inf .",
    "_ 1 ( 1971 ) , 2331 .",
    "d. knuth and j. l. szwarcfiter , a structured program to generate all topological sort arrangements , _ inf .",
    "_ 2 ( 1974 ) , 153157 .",
    "s. r. kosaroju , , analysis of structured programs , _ j. of computer and systems sciences _ 9 ( 1974 ) 232 - 255 d. kozen and w .- l .",
    "d. tseng , the bhm - jacopini theorem is false , propositionally , _",
    "mathematics of program construction ( mpc 08 ) _ , cirm , marseille , france , _ lecture notes in computer science _ 5133 ( 2008 ) , 177 - 192",
    "t. j. mccabe , a complexity measure , _ ieee transactions on software engineering _ se-2 ( 1976 ) , 308 - 320 .",
    "p. naur , ed .",
    "report on the algorithmic language algol 60 , _ comm .",
    "acm _ 3 ( 1960 ) , 299 - 314 .",
    "g. oulsnam , unravelling unstructured programs , _ the computer journal _ 25 ( 1982 ) , 379 - 387 .",
    "r. e. tarjan , depth - first search and linear graph algorithms , _ siam j. comp . _ 1 ( 1972 ) , 146 - 160 .",
    "r. e. tarjan , finding dominators in directed graphs , _ siam j. comp . _ 3 ( 1974 ) , 6289 .",
    "r. e. tarjan , testing flow graph reducibility , _ j. comp",
    ".  sys .",
    "sci . _ 9(1974 ) , 355 - 365 n. wirth , program development by stepwise refinement , _ comm .",
    "acm _ 14 ( 1971 ) , 221 - 227 .",
    "n. wirth , the programming language pascal , _",
    "acta informatica _ 1 ( 1971 ) , 35 - 63 . n. wirth , on the composition of well structured programs , _ acm comp .",
    "6 ( 1974 ) , 247 - 259 .",
    "m. h. williams , generating flow diagrams : the nature of unstructuredness , _ computer journal _ 20 ( 1977 ) , 45 - 50 m. h. williams , flowchart schemata and the problem of nomenclature , _ computer journal _ 26 ( 1983 ) , 270 - 276 m. h. williams and h. l. ossher , conversion of unstructured flow diagrams to structured form _ computer journal _ 21 ( 1978 ) , 101 - 107 .",
    "w. a. wulf , a case against the go - to , _ proc . of the acm ann .",
    "conf . _ , 1972 , 791 - 791 ."
  ],
  "abstract_text": [
    "<S> we revisit a concept that has been central in some early stages of computer science , that of _ structured programming _ : a set of rules that an algorithm must follow in order to acquire a structure that is desirable in many aspects . </S>",
    "<S> while much has been written about structured programming , an important issue has been left unanswered : given an arbitrary , compiled program , describe an algorithm to decide whether or not it is _ structured _ , that is , whether it conforms to the stated principles of structured programming . </S>",
    "<S> we refer to the classical concept of structured programming , as described by dijkstra . by employing a graph model and graph - theoretic techniques , </S>",
    "<S> we formulate an efficient algorithm for answering this question . to do so </S>",
    "<S> , we first introduce the class of graphs which correspond to structured programs , which we call _ dijkstra graphs_. our problem then becomes the recognition of such graphs , for which we present a greedy @xmath0-time algorithm . </S>",
    "<S> furthermore , we describe an isomorphism algorithm for dijkstra graphs , whose complexity is also linear in the number of vertices of the graph . both the recognition and isomorphism algorithms have potential important applications , such as in code similarity analysis . </S>"
  ]
}