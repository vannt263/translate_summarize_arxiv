{
  "article_text": [
    "the results presented in this paper are motivated by the task of enhancing the resolution of reconstructed tomographic images obtained from binary objects representing , for instance , crystalline structures , nanoparticles or two - phase samples @xcite .",
    "the reconstructed tomographic image might contain several gray levels , which , depending on the accuracy of the reconstruction , result from the fact that low - resolution pixels may cover different numbers of black high - resolution pixels .",
    "for turning the grayscale image into a higher - resolution binary image we utilize the gray levels and two additional higher - resolution projections , which may have been acquired by different imaging techniques or modalities ( e.g. , via scanning transmission electron microscopy @xcite ) .",
    "more precisely , we study the task of reconstructing binary @xmath2-images from row and column sums and additional constraints , so - called _ block constraints _ , on the number of black pixels to be contained in the @xmath3-blocks resulting from a subdivision of each pixel in the @xmath4 low - resolution image .",
    "we remark that we do not require that the x - ray data is taken from orthogonal directions . in our context",
    "it suffices that the x - ray data has been taken with double - resolution according to the discretization of the lower - resolution image .",
    "figure  [ fig : process ] illustrates the process .",
    "the example given in this figure also shows that the block - constraints can help to narrow down the solution space .",
    "in fact , the solution shown in this figure is uniquely determined by the input ( the row and column sums and block constraints ) .",
    "the row and column sums alone do not determine the solution uniquely ( and , of course , neither do the block constraints ) .",
    "apart from super - resolution imaging @xcite , and its particular applications @xcite in discrete tomography @xcite , the tasks discussed in this paper are also relevant in other contexts .    from a combinatorial point of view , they can be viewed as reconstructing binary matrices from given row and column sums and some additional constraints .",
    "unexpected complexity jumps based on the results of the present paper are discussed in  @xcite .",
    "background information on such problems involving different kinds of additional constraints can be found in ( * ? ? ?",
    "* sect .  4 ) .",
    "other applications belong to the realm of _ dynamic discrete tomography _ @xcite .",
    "for instance , in plasma particle tracking , some particles are reconstructed at time  @xmath5 between  @xmath6 and the next time step  @xmath7 the particles may have moved to other positions .",
    "the task is to reconstruct their new positions , again from few projections .",
    "one way of incorporating additional prior knowledge about the movement leads to block constraints of the kind discussed in this paper ; see @xcite .    as the task of reconstructing a binary matrix from its row and column sums",
    "can be formulated as the task of finding a @xmath8-matching in a bipartite graph , we remark that our results can also be seen as results on finding @xmath8-matchings that are subject to specific additional constraints . for related ( but intrinsically quite different ) results on matchings subject to so - called budget constraints ; see , e.g. , @xcite .",
    "the two main contributions of this paper are as follows . on the one hand , we show that reliable bimodal information can be utilized efficiently , i.e. , the resolution can be doubled in polynomial time if the gray levels of the low resolution image have been determined precisely ( theorem  [ thm : main1 ] ) . on the other hand ,",
    "the task becomes already intractable ( unless @xmath9 ) if the gray levels of some pixels come with some small error of @xmath1 ( theorem  [ thm : main2 ] and corollary  [ cor : largebox ] ) .",
    "this proves that noise does not only affect the quality of the reconstructed image but also the algorithmic tractability of the inverse problem itself .",
    "hence the possibility of compensating noisy imaging by including bimodal information may in practice be jeopardized by its algorithmic complexity .",
    "let @xmath10 @xmath11 and @xmath12 denote the set of integers , natural numbers , and non - negative integers , respectively",
    ". for @xmath13 set @xmath14 @xmath15:=\\{1,\\dots , k\\},$ ] and @xmath15_0:=\\{0,\\dots , k\\}.$ ] with @xmath16 we denote the all - ones vector of the corresponding dimension .",
    "the cardinality of a finite set @xmath17 is denoted by  @xmath18    in this paper we use cartesian coordinates ( rather than matrix notation ) to represent pixels in an image . in particular , the two numbers @xmath19 and @xmath20 in a pair @xmath21 denote the @xmath22- and @xmath23-coordinate of a point , respectively . in the following",
    "we consider grids @xmath24\\times[n].$ ] the set @xmath25 $ ] and @xmath24\\times\\{j\\}$ ] is called _ column  @xmath19 _ and _ row  @xmath26 _ respectively .",
    "let , in the following @xmath27 any set @xmath28 $ ] is a _",
    "vertical strip ( of width  @xmath29)_. a _ horizontal strip ( of width  @xmath29 ) _ is a set of the form @xmath24\\times\\{(j-1)k+1,\\dots , jk\\}.$ ]    sets of the form @xmath30\\times[c , d])\\cap\\mathbb{z}^2,$ ] with @xmath31 and @xmath32 @xmath33 are called _ boxes . _ for @xmath34 let @xmath35_0 ^ 2.$ ] defining for any @xmath36 and @xmath37 the set of _ ( lower - left ) corner points _ @xmath38\\times",
    "[ n])\\cap(k\\mathbb{n}_0 + 1)^2,$ ] we call any box @xmath39 with @xmath40 a _ block_. the blocks form a partition of @xmath24\\times[n],$ ] i.e. , @xmath41\\times[n].$ ]    for @xmath42 with @xmath43 we define the task of ( noisy ) super - resolution    nsr@xmath44 +    @xmath45 & & & & & & & & & \\textnormal{\\hspace*{1ex}gray value measurem.)}\\\\ & & & \\omit \\rlap{$\\displaystyle v(i , j)\\in[k^2]_0,$ } & & & & ( i , j)\\in c(m , n , k ) , & &   \\textnormal{(gray value measurem.)}\\\\[1.2ex ] & \\textnormal{task:}\\quad & & \\omit \\rlap{find   $ \\xi_{p , q}\\in\\{0,1\\},$ \\:$(p , q)\\in[m]\\times[n],$ with } \\\\",
    "\\displaystyle & & & \\sum_{\\mathclap{p\\in[m ] } } \\xi_{p , q}&&=r_q , & &   q\\in[n ] , & & \\textnormal{(row sums ) } \\\\",
    "\\displaystyle & & & \\sum_{q\\in[n ] } \\xi_{p , q}&&=s_p , & & p \\in [ m ] , & & \\textnormal{(column sums)}\\\\    \\displaystyle & & & \\sum_{\\mathclap{(p , q)\\in b_k(i , j)}}\\xi_{p , q}&&=v(i , j ) , & & ( i , j)\\in r , & & \\textnormal{(block constraints)}\\\\ \\displaystyle & & & \\sum_{\\mathclap{(p , q)\\in b_k(i , j)}}\\xi_{p , q}&&\\in v(i , j)+[-\\varepsilon,\\varepsilon ] , & \\hspace*{3ex } & ( i , j)\\in c(m , n , k)\\setminus r,\\:\\:&&\\textnormal{(noisy block constraints)}\\\\ & & & \\omit \\rlap{or decide that no such solution exists.}\\\\\\end{aligned}\\ ] ]    the numbers @xmath46 and @xmath47 are the row and column sum measurements of the higher - resolution binary @xmath2 image , @xmath48_0 $ ] corresponds to the gray value of the low - resolution @xmath3-pixel at  @xmath21 of the low - resolution @xmath4 grayscale image , and @xmath49 is the set of low - resolution pixel locations for which we assume that the gray values have been determined reliably , i.e. , without error .",
    "the number @xmath50 is an error bound for the remaining blocks .",
    "the task is to find a binary high - resolution image satisfying the row and column sums such that the number of black pixels in each block adds up to a gray value for the corresponding @xmath3-pixel in the lower - resolution image that lies in the specified interval .",
    "clearly , a necessary ( and easily verified ) condition for feasibility is that @xmath51}r_q=\\sum_{p\\in[m]}c_p.\\ ] ] in the following we will assume without loss of generality that this is always the case .",
    "our special focus is on double - resolution imaging , i.e. , on the case @xmath52 for @xmath53 we define ndr@xmath54nsr@xmath55 in the reliable situation , i.e. , for @xmath56 we simply speak of _ double - resolution _ and set dr@xmath57nsr@xmath58 ( then , of course , the set  @xmath49 can be omitted from the input . )    in the present paper , we show that the resolution of any reliable grayscale image can in fact be doubled in each dimension in polynomial - time if x - ray data is provided from two viewing angles at double resolution . in other words ,",
    "we show    [ thm : main1 ] @xmath59    figures  [ fig : drexample2 ] and  [ fig : drexample1 ] illustrate the performance of the algorithm for dr applied to two phantoms .",
    "the results have been obtained within a fraction of a second on a standard pc .    in figure",
    "[ fig : drexample2 ] , the original phantom is a binary @xmath60 image of a crystalline sample taken from  @xcite .",
    "it is assumed that the half - resolution grayscale image shown in figure  [ fig : drexample2](a ) has been obtained by some imaging method and that double - resolution x - ray information in the two standard directions is also available .",
    "application of the algorithm yields the binary image shown in figure  [ fig : drexample2](c ) .    in figure",
    "[ fig : drexample1 ] , the original phantom is a binary @xmath61 image , for which the half - resolution grayscale image shown in figure  [ fig : drexample1](a ) is available . from this image and the row and column sums ( counting the black pixels ) of the original phantom",
    "the algorithm returns the binary image shown in figure  [ fig : drexample1](b ) .",
    "the results shown in figures  [ fig : drexample2 ] and  [ fig : drexample1 ] satisfy , of course , the row and column sums and block constraints .",
    "however , in both cases the solutions are still not unique .",
    "this can also be detected in polynomial time .",
    "[ main : unique ] for every instance of dr it can be decided in polynomial time whether the instance admits a unique solution .",
    "while the additional x - ray information ( at double resolution ) does in general reduce the ambiguity , typically it will still not lead to uniqueness . of course , a standard way of dealing with non - uniqueness in practice is regularization @xcite . to illustrate the possibility of adapting a regularization scheme to our context , we show in figure  [ fig : drexample1](c ) a binary solution minimizing the _ total variation ( tv ) .",
    "_ in fact , the solution is obtained from figure  [ fig : drexample1](a ) by applying  @xmath62 so - called local switches , each of which are strictly decreasing the value of the total variation functional @xmath63}\\sum_{q\\in[n]}||(\\nabla x_{p , q}^{(1)},\\nabla x_{p , q}^{(2)})^t||_2,\\ ] ] where @xmath64 and @xmath65 denotes the euclidean norm .",
    "see , e.g. , @xcite for some background information .",
    "of course , we obtain the same results for other  @xmath66-norms ( including the @xmath67-norm ) , because our images are binary .",
    "we now turn to the task @xmath68 where small `` occasional '' uncertainties in the gray levels are allowed .",
    "first observe that a constant number of uncertainties does not increase the complexity .",
    "however , if we allow a ( as we will see , comparably small but ) not constant number of uncertainties the problem becomes hard .",
    "[ thm : main2 ] ndr@xmath69 is @xmath0-hard for any @xmath70    as it turns out , the problem remains @xmath0-hard for larger block sizes .",
    "[ cor : largebox ] nsr@xmath44 is @xmath0-hard for any @xmath43 and @xmath70    in other words , noise does not only affect the reconstruction quality .",
    "it also affects the algorithmic tractability of the inverse problem .",
    "( for background material on complexity theory , see , e.g. , @xcite . )    the present paper is organized as follows .",
    "we deal with the case of reliable data in section  [ sect:3 ] .",
    "results on ndr@xmath69 and nsr@xmath44 involving noisy data are contained in section  [ sect:4 ] .",
    "section  [ sect:5 ] concludes with some additional remarks on certain extensions and an open problem .",
    "in this section we discuss the task dr , i.e. , @xmath71 and @xmath72 we remark that , in the following , our emphasis is on providing brief and concise arguments for polynomial - time solvability rather than to focus on computationally or practically most efficient algorithms .",
    "recall , however , our comments on the computational performance of our algorithms and the effect of the additional information for the example images depicted in figures  [ fig : drexample2 ] and  [ fig : drexample1 ] .",
    "the main result of this section is theorem  [ thm : main1 ] . in its proof",
    "we show that dr decomposes into five problems that can be solved independently .",
    "the five problems are single - graylevel versions of dr where each block is required to contain the same number @xmath73_0 $ ] of ones .",
    "moreover , we allow for restricted problem instances ( and in particular row and column sums ) that are defined only on subsets @xmath74\\times[n]\\ ] ] of the grid @xmath24\\times[n]$ ] defined by means of some @xmath75 let @xmath76:\\exists j\\in[n]:(i , j)\\in i\\}\\ ] ] and @xmath77:\\exists i \\in [ n]:(i , j)\\in i\\}.\\ ] ] then we define for @xmath73_0:$ ]    dr@xmath78 +    @xmath79 & \\textnormal{task:}\\quad & & \\omit \\rlap{find   $ \\xi_{p , q}\\in\\{0,1\\ } , \\:(p , q)\\in g(i)$ with } \\\\",
    "\\displaystyle & & & \\sum_{\\mathclap{p:(p , j)\\in g(i)}}\\xi_{p , j+l}&&=r_{j+l } , & &   j\\in \\pi_y(i ) , \\:\\ : l\\in \\{0,1\\}&&\\textnormal{(row sums ) } \\\\",
    "\\displaystyle & & & \\sum_{\\mathclap{q:(i , q)\\in g(i)}}\\xi_{i+l , q}&&=c_{i+l } , & &   i\\in \\pi_x(i ) , \\:\\ : l\\in \\{0,1\\}&&\\textnormal{(column sums)}\\\\   \\displaystyle & & & \\sum_{\\mathclap{(p , q)\\in b(i , j)}}\\xi_{p , q}&&=\\nu,&\\:\\ : & ( i , j)\\in i , & \\:\\:&\\textnormal{(block constraints)}\\\\ & & & \\omit \\rlap{or decide that no such solution exists.}\\end{aligned}\\ ] ]    of course , the tasks dr@xmath80 @xmath81 are trivial .",
    "in fact , the only potential solution satisfying the block constraints is given by @xmath82 @xmath83 and it is checked easily and in polynomial time whether this satisfies the row and column sums .",
    "the next lemma and corollary deal with @xmath84 , @xmath85 its statement and proof uses the notation @xmath86 and @xmath87 for the number of blocks in the same vertical strip as but below @xmath88 or in the same horizontal strip as but left of @xmath89 respectively .",
    "more precisely , let @xmath90)\\cap i|\\qquad \\textnormal{and}\\qquad \\rho_j(i):=|([i]\\times\\{j\\})\\cap i|\\ ] ] for @xmath91    [ lemma : mono ]    a.   [ mono2 ] an instance @xmath92 of dr@xmath93 is feasible if , and only if , for every @xmath94 we have @xmath95 b.   [ mono3 ] the solution of a feasible instance of dr@xmath93 is unique if , and only if , for every @xmath94 we have @xmath96 c.   [ mono1 ] dr@xmath97    clearly , for the feasibility of a given instance of dr@xmath93 the conditions @xmath98 are necessary .",
    "now , suppose that the conditions are satisfied .",
    "for every @xmath94 and @xmath99 we set @xmath100 figure  [ fig : example1 ] gives an illustration .     with @xmath101 in gray color .",
    "( right ) solution defined by  .,scaledwidth=45.0% ]    by this definition we have satisfied all block constraints .",
    "a simple counting argument shows that the row and columns sums are also as required .",
    "in fact , for @xmath102 and @xmath103 we have @xmath104 this concludes the proof of  ( [ mono2 ] ) .    to show  ( [ mono3 ] ) , we consider a solution @xmath105 to @xmath106 suppose that @xmath107 and @xmath108 for some @xmath109 then , there exist @xmath110 $ ] with @xmath111 by the block constraints we have @xmath112 applying a switch to @xmath113 @xmath114 @xmath115 and @xmath116 i.e. , setting @xmath117 @xmath118 and @xmath119 otherwise , yields thus another solution . as the same argument holds also for the column sums we have shown that the condition in  ( [ mono3 ] ) is necessary .",
    "the condition is , on the other hand , also sufficient since the 0-values of the row and column sums leave only a single position @xmath120 in each block @xmath89 @xmath121 for which @xmath122 can take on a non - zero value ( in fact , the value needs to be  1 to satisfy the block constraints ) .",
    "we now turn to  ( [ mono1 ] ) .",
    "the algorithm checks the condition  ( [ mono2 ] ) .",
    "if it is violated , it reports infeasibility ; otherwise , a solution is constructed through   clearly , all steps can be performed in polynomial time .",
    "[ cor : mono3 ]    a.   [ cormono2 ] an instance @xmath92 of dr@xmath123 is feasible if , and only if , for every @xmath94 we have @xmath124 b.   [ cormono3 ] the solution of a feasible instance of dr@xmath123 is unique if , and only if , for every @xmath94 we have @xmath125 c.   [ cormono1 ] dr@xmath126    the results follow directly from the results for @xmath127 in lemma  [ lemma : mono ] as the former are obtained from the latter by inversion and vice versa , i.e. , by replacing @xmath128 by @xmath129 and @xmath130 by @xmath131 @xmath121 @xmath132 and , in the solutions , all @xmath67 s by @xmath133 s and @xmath133 s by @xmath67 s .",
    "next we prove polynomial - time solvability of @xmath134 to this end we need two lemmas . the first can be viewed as dealing with a certain `` two - color version '' of discrete tomography .",
    "the second deals with specific switches or interchanges ( in the sense of @xcite ) .",
    "[ lem : unimod2 ] the problem , given @xmath135 @xmath136 and @xmath137 @xmath121 decide whether there exist non - negative integers @xmath138 @xmath139 @xmath140 such that @xmath141 and , if so , determine a solution , can be solved in polynomial time .",
    "we assemble the variables @xmath138 @xmath142 for @xmath143 into an @xmath144-dimensional vector and rephrase the constraints in matrix form @xmath145 @xmath146 and @xmath147 where @xmath148 contains the @xmath149 s , @xmath150 contains the @xmath151 s , and @xmath152 denotes the @xmath153-identity matrix .",
    "the problem is then to determine an integer solution of @xmath154 where @xmath155 the submatrix @xmath156 is totally unimodular as it is the node - edge incidence matrix of a bipartite graph ( one of the two parts of the partition is the set of the last @xmath144 rows of  @xmath157 ) .",
    "but then  @xmath158 is also totally unimodular as it results from appending a subset of rows of  @xmath159 to the totally unimodular matrix  @xmath160 in other words , @xmath161 is an integral polyhedron , i.e. , it coincides with the convex hull of its integral vectors .",
    "hence , a vertex of this polyhedron can be found in polynomial time by linear programming .",
    "see  ( * ? ? ?",
    "16&19 ) for background material .    in a solution of dr",
    "we can have  16 different block types .",
    "they are shown in figure  [ fig : types:1 ] .",
    "several of them have the same label as they can not be distinguished by the row sums .",
    "we introduce now the concept of local switches . for this",
    "we remark that if we consider a horizontal strip with a block labeled @xmath162 and a block labeled @xmath163 ( labeling as in figure  [ fig : types:1 ] ) , we can perform a switch that turns the blocks into blocks labeled @xmath164 and @xmath165 , respectively .",
    "we call such a switch a _ horizontal local switch of class  @xmath166 _ in a similar way we define the _ horizontal local switches of class @xmath167-@xmath168 _ see table  [ table : switchesexample ] , column  1 - 3 , and column  4 for an illustration . note that the illustration does not show all horizontal local switches but rather gives a typical example .",
    "ccclc@cclass & turns & into & & illustration&illustration + & & & & ( horizontal local switch ) & ( vertical local switch ) + ( 1 ) & @xmath169&@xmath170 & &        &         + & & & & & + ( 2 ) & @xmath171&@xmath172 & &        &         + & & & & & + ( 3 ) & @xmath173&@xmath174 & &        &         + & & & & & + ( 4 ) & @xmath175&@xmath176 & &        &         + & & & & & + ( 5 ) & @xmath177&@xmath178 & &        &         + & & & & & + ( 6 ) & @xmath165&@xmath165 & &        &         + & & & & & + ( 7 ) & @xmath179&@xmath180 & &        &         +   +    let @xmath181 denote the coordinate transformation @xmath182 a switch in a solution  @xmath105 is called a _ vertical local switch of class  @xmath183 @xmath184,$ ] _ if it is a horizontal local switch of class  @xmath185 in @xmath186 see table  [ table : switchesexample ] , column  5 , for an illustration .",
    "a switch is called _ local _ if it is a horizontal or vertical local switch of some class  @xmath183 @xmath184.$ ] a solution is called _ reduced _ if no local switch of any class  @xmath183 @xmath184,$ ] can be applied .",
    "[ lem : reduction ]    a.   [ red1 ] the set of solutions of a given instance of dr is invariant under local switches .",
    "+ b.   [ red2 ] if an instance of @xmath187 has a solution , then there is also a reduced solution .    to prove  ( i ) just observe that the local switches do neither change the row and column sums nor the number of ones contained in each block .",
    "let us now turn to  ( ii ) .",
    "suppose the instance has a solution .",
    "the local switches of class  @xmath183 @xmath188,$ ] increase the number of blocks @xmath88 with @xmath189 the process of applying local switches of class  @xmath183 @xmath188,$ ] thus needs to terminate since the number of blocks in each problem instance is finite . further , note that local switches of class  @xmath190 applied in horizontal strips increase the number of blocks labeled @xmath191 the vertically applied switches of that class do not decrease the number of such blocks , but increase the number of blocks containing at least a one in the rightmost column of the block .",
    "[ lem : dr2 ] @xmath192    our general strategy is as follows .",
    "first we show that a given instance is feasible if , and only if , there exists a specific reduced solution that contains only three block types .",
    "then we give a polynomial - time algorithm that finds such a solution or determines infeasibility .    in the following",
    "we will again use the notational convention that specific settings of variables and parameters are signified by a superscript @xmath193    by possibly rearranging the rows and columns , we assume that @xmath194    now , suppose that the given instance has a solution . by lemma  [ lem : reduction ] there",
    "exists a reduced solution . in the following ,",
    "we consider such a reduced solution .",
    "the potential block types , and corresponding variables @xmath195 @xmath196 and @xmath165 counting the number of occurrences of the respective block types in the strip @xmath24\\times\\{j , j+1\\}$ ] of a reduced solution , are shown in figure  [ fig : types:1](b ) .",
    "block types counted by the same variable have equal row sums .",
    "consider now for fixed @xmath101 the blocks in @xmath197\\times\\{j , j+1\\}).$ ] counting the block types , any solution needs to satisfy @xmath198 which implies @xmath199 as the solution is @xmath123-reduced we need to have @xmath200 or @xmath201 this , together with @xmath202 and  , implies @xmath203    the same argument applies to the other horizontal strips , and a similar argument holds for the vertical strips .",
    "hence , we conclude that @xmath204 amounts to the task of assigning one of the three block types shown in figure  [ fig : types:2 ] to each of the blocks @xmath89 @xmath121 in such a way that the number of type  1 and type  2 blocks in each horizontal and vertical strip , respectively , equals some prescribed numbers .",
    "instances considered in the proof of lemma  [ lem : dr2 ] . value  @xmath67 and @xmath133 are indicated in black and white , respectively.,scaledwidth=25.0% ]    now , we introduce @xmath205-variables @xmath138 @xmath139 @xmath121 that should be interpreted as follows : @xmath206 and @xmath207 if , and only if , @xmath88 is of type  1 ; @xmath208 and @xmath209 if , and only if , @xmath88 is of type  2 , and @xmath210 if , and only if , @xmath88 is of type  3 . then we ask for @xmath205-solutions that satisfy @xmath211 such solutions can be found in polynomial time by lemma  [ lem : unimod2 ] .    now",
    "with these preliminary results we can turn to the proof of theorem  [ thm : main1 ] .",
    "we show that the task of finding a solution to a given problem instance can be decomposed into five independent subtasks of solving instances of @xmath212 @xmath213 the subtasks are then polynomial time solvable by lemma  [ lemma : mono ] , corollary  [ cor : mono3 ] and  [ lem : dr2 ] ( and trivially for @xmath214 and @xmath215 ) .",
    "the key step in our proof is to deduce from the data the row and column sums for the particular subtasks .",
    "this deduction is possible for reduced solutions .",
    "their existence for feasible problem instances is guaranteed by lemma  [ lem : reduction ] .",
    "further , we will , if needed apply some preprocessing . first",
    ", if the problem instance contains block constraints of the form @xmath216 @xmath81 we need to have @xmath217 in this case , we fix the values of these variables , reduce the row and column - sums accordingly , and consider only the remaining blocks . for notational convenience , we assume from now on that our instance does not contain such block constraints .",
    "second , by possibly rearranging the rows and columns , we assume that @xmath218    suppose now that the problem instance has a solution .    considering a horizontal strip @xmath24\\times \\{j , j+1\\}$ ] with @xmath219\\cap(2\\mathbb{n}_0 + 1),$ ] we compute @xmath220\\cap(2\\mathbb{n}_0 + 1):v(i , j)=1\\}|,\\\\ b_j:=|\\{i\\in [ m]\\cap(2\\mathbb{n}_0 + 1):v(i , j)=2\\}|,\\\\ c_j:=|\\{i\\in [ m]\\cap(2\\mathbb{n}_0 + 1):v(i , j)=3\\}|.\\end{aligned}\\ ] ] a count of the block types of the solution in that strip ( the variables for the block types are indicated in figure  [ fig : types:1 ] ) , yields    @xmath221    from the system we obtain @xmath222    by lemma  [ lem : reduction ] there is a reduced solution ; the corresponding variable setting will be signified by the superscript @xmath193 suppose now in such a reduced solution we have @xmath223 as we can not apply any further local switch of class  @xmath185 , @xmath224 we need to have @xmath225 hence by   and   @xmath226 and @xmath227 using   and   we obtain @xmath228 which imply @xmath229 a contradiction to  .",
    "hence , we have  @xmath230    in the following we distinguish three cases .",
    "first , suppose that in every reduced solution we have @xmath231 as we can not apply any further local switch of class  @xmath183 @xmath232 we must have @xmath233 hence @xmath234 and @xmath235 eq .   implies @xmath236 as @xmath237 we thus have @xmath238 further , all values of the variables are determined since   yields @xmath239    for the second case , suppose that there is a reduced solution with @xmath240 and in any such solution we have @xmath241 then , @xmath242 and as we can not apply any further local switch of class  @xmath243 we need to have @xmath244 hence @xmath235 eq",
    ".   implies @xmath245 as @xmath246 we thus have @xmath247 further , all values of the variables are determined since   yields @xmath248    finally , for the third case , suppose that there is a solution with @xmath249 then @xmath250 and @xmath251 .",
    ".   implies @xmath252 as @xmath253 we thus have @xmath254 further , all values of the variables are determined since   yields @xmath255    since , by assumption , the given instance has a solution and , hence a reduced one , exactly one of the three cases above must occur .",
    "which one it is , can be determined from the data , simply by testing whether we have @xmath256    in all three cases we know the particular values of the @xmath257 @xmath258 @xmath259 @xmath260 @xmath261 @xmath262 and @xmath263 therefore we know for each @xmath264 $ ] the row sums @xmath265 and @xmath266 where @xmath267 denotes the set @xmath268 in particular , we have @xmath269 a similar argument applies to the vertical strips . we can therefore decompose the reconstruction problem into the three independent subproblems @xmath212 @xmath264,$ ] which , by lemma  [ lemma : mono ] , corollary  [ cor : mono3 ] , and lemma  [ lem : dr2 ] , are solvable in polynomial time .",
    "note that the above proof is constructive , fully detailing the steps of a polynomial - time algorithm for solving  dr . we also remark that the solutions returned by the proposed algorithm are always reduced solutions .",
    "this is easily seen by  ( i ) verifying that the values @xmath257",
    "@xmath258 @xmath259 @xmath260 @xmath261 @xmath262 and @xmath270 @xmath219,$ ] in each of the three cases in   ( and correspondingly for the variables in the vertical strips ) do not allow an application of any of the local switches of class  @xmath183 @xmath184\\setminus\\{6\\},$ ] because for each of the local switches there is always a corresponding variable of value zero ; and  ( ii ) by noting that the proposed algorithm for @xmath204 returns , by definition , only solutions where no local switch of class  @xmath271 can be applied .",
    "now we turn to uniqueness .    by theorem  [ thm : main1 ] ,",
    "infeasibility is detected or a solution of an instance is determined in polynomial time .",
    "we can thus assume that the problem instance has a solution .    clearly , a solution is unique if , and only if  ( i ) there is only one reduced solution , and  ( ii ) every solution is a reduced solution .",
    "the solution returned by the algorithm is a reduced solution .",
    "any two reduced solutions define the same instances of the subproblems @xmath212 @xmath264,$ ] because the problem instances are defined by means of  , i.e. , the definition depends only on the particular values of the @xmath272 and @xmath273 hence , there is only one reduced solution if , and only if , the solution to each of the subproblems @xmath212 @xmath264,$ ] is unique .    the conditions in lemma  [ lemma : mono]([mono3 ] ) and corollary  [ cor : mono3]([cormono3 ] ) , and hence uniqueness for the instances of @xmath127 and @xmath274 can be checked in polynomial time . for @xmath204 we have by lemma  [ lem : unimod2 ] , a vertex solution @xmath275 of the linear program at our disposal .",
    "now we minimize the linear objective function @xmath276 over the same feasible region , which again can be done in polynomial time .",
    "the solution @xmath275 is unique if , and only if , @xmath277 hence uniqueness for @xmath204 , and therefore  ( i ) , can be checked in polynomial time .",
    "suppose now that the reduced solution  @xmath105 returned by the algorithm is unique among all reduced solutions , i.e. ,  ( i ) is satisfied .",
    "we have shown in lemma  [ lem : reduction ] that every solution can be reduced by applying a sequence of local switches .",
    "reversing the sequence and the local switches ( the _ reversed local switch _ of the local switch that changes @xmath278 into @xmath279 is the switch that reverts these changes ) , we thus see that  ( ii ) holds if , and only if , there is no reversed local switch that can be applied to @xmath280 there are @xmath281 possible tuples @xmath278 that need to be checked whether they form a reversed local switch , hence  ( ii ) can also be checked in polynomial time .",
    "in the proof of theorem  [ thm : main2 ] we use a transformation from the following @xmath0-hard problem ( see  @xcite )    1-in-3-sat +    [ cols= \" < , < \" , ]     for a given instance of 1-in-3-sat we will construct a circuit board that contains an initializer , several connectors , and clause chips .",
    "a truth assignment is transmitted through the circuit board , the clause chips ensure that the clauses are satisfied .",
    "the structure of our proof is in some ways similar to the proof from  @xcite that establishes the @xmath0-hardness of the task of reconstructing lattice sets from x - rays taken in three or more directions .",
    "however , we need to deviate from @xcite in several key aspects , because the block constraints do not give a direct way of controlling points over large distances , and the elimination of `` unwanted solutions '' inside individual blocks seems also problematic . a fundamental difference",
    "to  @xcite is , for instance , that we encode the boolean values for the variables by specific types of blocks , and the satisfiability of the clauses is verified via row and column sums . at first glance",
    "it seems that part of the variable assignment information is lost after verification , but it turns out that we can recover it from `` redundant '' information in our encoding .",
    "_ key ideas of the proof of theorem  [ thm : main2 ] .",
    "_ before we start with the detailed proof , we illustrate the general ideas by means of an example .",
    "suppose , the instance @xmath92 of 1-in-3-sat is given by @xmath282 we will define an instance @xmath283 of ndr@xmath69 such that there is a solution for @xmath283 if , and only if , there is one for @xmath284 to this end , we construct a circuit board contained in the box @xmath285\\times[34].$ ] with each @xmath286\\times[34]$ ] we associate a variable @xmath287    the circuit board consists of three major types of components : an _ initializer _ , _ connectors _ , and _",
    "clause chips_. the initializer and the connectors are rather similar .",
    "the initializer contains for every variable @xmath288 @xmath289,$ ] a so - called _",
    "@xmath290-chip _ , the connectors contain for every variable a _",
    "@xmath291-chip . _ the clause chips are more complex as they consist of two _ collectors _ , two _ verifiers _ , and a _ transmitter_.    figure  [ fig : p2example](a ) shows the circuit board for our instance .",
    "the gray areas indicate blocks that are set to zero via block constraints . by setting to zero suitable row and column sums",
    "we make sure that non - zero components @xmath292 are only possible in the white bold - framed boxes .",
    "the non - zero row and column sums are shown on the top and on the right of the figure .",
    "the bold - framed @xmath293 boxes are _ boolean chips _ , which are , according to their position on the circuit board ,",
    "further classified into  @xmath290 and  @xmath291-chips , @xmath294.$ ] in these chips we will encode the respective boolean values for the variables @xmath290 and  @xmath291 , @xmath294.$ ] all blocks , except for those set to zero , are allowed to contain at most two ones .",
    "the blocks containing the @xmath291-chips are required to contain precisely two ones .    in each clause chip",
    "there are two strips playing a special role .",
    "one is a horizontal strip containing a so - called _ horizontal verifier _ , the other is a vertical strip containing a so - called _ vertical verifier _ ( see rows  25 and  26 , and columns  9 and  10 in figure  [ fig : p2example](a ) ) .",
    "a key property of our construction is that the truth assignments will be in 1-to-1 correspondence with the solutions of the ndr@xmath69 instance if the row and column sum constraints related to the verifiers are left unspecified .",
    "the row and column sums constraints related to the verifiers will ensure that the truth assignments are in fact satisfying truth assignments .",
    "we can already begin to see how a truth assignment for our particular instance @xmath92 will provide a solution for @xmath295 utilizing the type  1 and type  2 blocks shown in figure  [ fig : p2types ] , we set each @xmath290-chip , @xmath289,$ ] of the initializer to type  1 if @xmath296 otherwise we set it to type  2 .    - and",
    "@xmath297-chips , @xmath289.$ ] in @xmath290-chips , the types  1 and  2 represent the boolean values true and false , respectively .",
    ", scaledwidth=35.0% ]    let us first consider @xmath298 and the sequence of boolean chips marked a , b , c , d , and e. see also figure  [ fig : transmission ] .",
    "the chips  a and  b lie in the same vertical strip , and since  a is of type  1 ,  b needs to be of type  2 to satisfy the column sums in the vertical strip .",
    "chip  c needs to be of type  1 to satisfy the row sums in the horizontal strip .",
    "then , the remaining points in the two vertical strips intersecting chip  c are uniquely determined by the column sums .",
    "as chip  d needs to contain two ones ( since the vertical strip containing chip  d contains four ones , two of which need to be contained in chip  e via block constraints ) we conclude from the row sums that  d is of type  1 .",
    "considering now the vertical strip intersecting  d we deduce that chip  e is of type  2 , and therefore , together with chip  a , satisfies the row sums in the horizontal strip .",
    "thus , the @xmath299-chips are consistently of type  1 , the @xmath300-chips are of type  2 .",
    "note that we have satisfied all row and column sums for the strips intersecting one of the chips a , b , c , d , and e. moreover , the block constraints in these chips are also satisfied .    .",
    ", scaledwidth=45.0% ]    turning to the boolean chips for @xmath301 we conclude with a similar reasoning that the @xmath302- and @xmath303-chips are consistently of type  1 and type  2 , respectively .",
    "we have now satisfied the block constraints for the @xmath302- and @xmath303-chips , additionally , we satisfied the row and column sums for the strips intersecting one of these chips .",
    "clearly , we have not violated any of the previously satisfied constraints as there is no row or column that intersects both a boolean chip for @xmath298 and @xmath304    we say that we have deduced the types of the boolean chips for  @xmath305 by _ vertical transmission _ , because in our previous chain of arguments we started by considering the vertical strip containing the respective boolean chip of the initializer ( see also figure  [ fig : transmission ] ) .",
    "note that such a vertical transmission does not directly work for the assignment false of the variables  @xmath306 @xmath307 since the column sums do not allow us to deduce a unique solution for the respective @xmath291-chip . hence for the boolean chips for @xmath308 we resort to _ horizontal transmission _ to deduce the types of the respective @xmath290- and @xmath291-chips . in this way",
    "we conclude that the @xmath290- and @xmath291-chips are consistently type  2 and type  1 , respectively .",
    "figure  [ fig : p2example](b ) shows the solution that we obtain by the previous arguments .",
    "all constraints , in particular also the row and column sums in the verifiers , are satisfied .",
    "we will later see in general that there is a single one in each of the two verifiers of the @xmath309-clause chip , @xmath310 if , and only if , exactly one of the three literals appearing in the @xmath309-th clause is true .",
    "now , consider the reverse direction for the proof , i.e. , suppose a solution @xmath105 to our instance @xmath283 of figure  [ fig : p2example](a ) is given . note that if we can ensure that the types of the boolean chips in the initializer are either  1 or  2 then by the previous arguments we have a satisfying truth assignment for @xmath92 by setting @xmath311 @xmath294,$ ] if , and only if , the corresponding @xmath290-chip of the initializer is of type  1 .",
    "the respective block , row and column sum constraints allow only the four possible types of blocks for the boolean chips of the initializer shown in figure  [ fig : p2types ] .",
    "the types  3 and  4 , however , are ruled out by the following `` global '' argument : suppose , for some @xmath289,$ ] the @xmath290-chip of the initializer is of type  @xmath312 by horizontal transmission , we then conclude that the @xmath291-chips need to be of type  1 ( by transmitting , as before in a unique way , through each clause chip ) . by vertical transmission , however , we conclude that the @xmath291-chips are of type  2 , which is a contradiction .",
    "we remark that effectively we utilize the noisy block constraints at three different places in our construction .",
    "they are needed , because we can not prescribe the exact number of ones in the @xmath290-chips of the horizontal and vertical collectors , and in the @xmath313-configurations that are introduced later ( see also figures  [ fig : p2collectors ] ,  [ fig : p2collectorfilled1 ] , and  [ fig : p2collectorfilledx ] ) .",
    "having illustrated the key ideas behind the construction , we now turn to the formal proof .",
    "let in the following @xmath314 denote an instance of 1-in-3-sat .",
    "we will define an instance @xmath283 of ndr@xmath69 such that there is a solution for @xmath283 if , and only if , there is one for @xmath284 the circuit board will be contained in the box @xmath315\\times[n]:=[s(6t+2)+2t]^2.\\ ] ] with each @xmath316\\times[n]$ ] we associate a variable @xmath287 figure  [ fig : p2layout ] illustrates the general layout of the construction .    ) .",
    "non - zero components @xmath292 of a solution will be possible only for those @xmath120 contained in the white area.,scaledwidth=43.0% ]    we define the instance @xmath317 of ndr@xmath69 by specifying the row sums @xmath272 the column sums @xmath318 and the block constraints . for notational convenience",
    "we define the block constraints via a function @xmath319 in this notation , @xmath320 @xmath321 denotes the block constraint @xmath322 while @xmath323 signifies the block constraint @xmath324\\cap \\mathbb{z}).\\ ] ] the set @xmath49 of reliable block constraints for @xmath283 is then @xmath325    the different components of the circuit board are placed at specific positions . for a more compact definition of these positions we set @xmath326_0.\\ ] ]    turning to the definition of the initializer , we remark that the initializer is contained inside the box @xmath327_0 ^ 2.$ ] we will specify the row and column sums when the corresponding connectors are introduced . in terms of the block constraints we define for every @xmath328_0 ^ 2:$ ] @xmath329 the block @xmath330 @xmath289,$ ] will be called _ @xmath331-chip ( of the initializer)_. for an illustration of an initializer , see the bottom right @xmath332\\times[8]$]-box in figure  [ fig : p2example](a ) .",
    "we define @xmath333 connectors .",
    "each connector is contained inside a box @xmath334_0 ^ 2 $ ] with @xmath335_0.$ ] in terms of block constrains we define for every @xmath336_0 $ ] and @xmath337_0 ^ 2:$ ] @xmath338 for the row and column sums we define for every @xmath336_0 $ ] and @xmath339_0:$ ] @xmath340 the block @xmath341 @xmath342_0,$ ] @xmath289,$ ] will be called _ @xmath343-chip ( of the @xmath309-th connector)_. for an illustration of a connector ,",
    "see the bottom left @xmath332\\times[8]$]-box in figure  [ fig : p2example](a ) .",
    "next we define the @xmath344 clause chips .",
    "each clause chip is contained in a box @xmath345_0 ^ 2 $ ] with @xmath346_0.$ ] the box @xmath347_0\\times[4t-1]_0 $ ] is a _ ( vertical )",
    "collector _ , the box @xmath348_0\\times[4t-1]_0 $ ] is a _",
    "( vertical ) verifier _ , the box @xmath349_0 ^ 2 $ ] is a _ transmitter _ , the box @xmath350_0\\times[1]_0 $ ] is a _ ( horizontal ) verifier _ , and the box @xmath351_0\\times[2t-1]_0 $ ] is a _ ( horizontal ) collector_. for an illustration of a clause chip , see the top left @xmath352\\times[26]$]-box in figure  [ fig : p2example](a ) .    for @xmath353_0 $ ]",
    "we define the row and column sums for the verifiers ( we will call these row and column sums _ verifier sums _ ) by @xmath354 the remaining row and columns sums for the transmitters , i.e. , for @xmath353_0 $ ] and @xmath355_0 $ ] are defined by @xmath356 note that sums for the rows and columns meeting the collectors are already defined as there is a corresponding connector in the same row or , respectively , column ( see also figure  [ fig : p2layout ] ) .",
    "we have thus completed our definition of the row and column sums of our instance and continue now with the remaining block constraints .    for the vertical collector , we define for every @xmath353_0 $ ] and @xmath328_0 ^ 2:$ ] @xmath357 the box @xmath358_0\\times[1]_0,$ ] @xmath359_0,$ ] will be called _",
    "@xmath290-chip ( of the @xmath360-th vertical collector)_.    for the horizontal collector we define similarly for every @xmath353_0 $ ] and @xmath361_0 ^ 2:$ ] @xmath362 the box @xmath363_0\\times[1]_0,$ ] @xmath359_0,$ ] will be called _",
    "@xmath290-chip ( of the @xmath360-th horizontal collector)_.    note that the @xmath290-chips , @xmath289,$ ] of the collectors are not contained in blocks .",
    "in fact , each such @xmath290-chip intersects two blocks ( which , in turn , are allowed to contain at most two ones ) . for any @xmath289 $ ] we will also refer to the @xmath290- and @xmath291-chips on the circuit board as _ boolean chips . _",
    "for the empty space above the vertical connector , i.e. , for @xmath353_0 $ ] and @xmath364_0 ^ 2,$ ] we define @xmath365    now we turn to the block constraints for the clause - dependent part of chip , i.e. , the verifiers and the transmitters .    with @xmath366 and @xmath367 @xmath368,$ ]",
    "we denote the indices of the variables that appear unnegated and , respectively , negated in the @xmath309-th clause .",
    "for instance , for @xmath369 ( regarded as the first clause ) we have @xmath370 and @xmath371    for the vertical verifiers we define for every @xmath335,$ ] @xmath294 , $ ] and @xmath372:$ ] @xmath373    similarly , for the horizontal verifiers we define for every @xmath335,$ ] @xmath294,$ ] and @xmath374:$ ] @xmath375    for the transmitters we define for every @xmath335 $ ] and @xmath376:$ ] @xmath377 the remaining block constraints in the transmitter",
    "are set to zero , i.e. , for every @xmath335,$ ] @xmath378_0 ^ 2 $ ] with @xmath379 we set @xmath380    for @xmath368 $ ] and @xmath381 $ ] we refer to the sets of points @xmath382 as _ @xmath313-configuration_. figure  [ fig : p2collectors ] gives an illustration .",
    "outside the initializer , connectors , and clause chips we set everything to zero , i.e. , for every @xmath383\\times[n])\\cap c(m , n,2)$ ] with @xmath384_0 ^ 2)\\cup\\bigcup_{s\\in[s-1]_0}\\left(((a_s , a_s)+[2(t-1)]_0 ^ 2)\\cup ( ( a_s , a_s+2t)+[6t+1]_0 ^ 2))\\right)\\ ] ] we set @xmath385    this concludes the formal definition of the instance @xmath295 we shall now show that @xmath283 admits a solution if , and only if , the 1-in-3-sat instance @xmath92 admits a solution .",
    "let @xmath386\\times[n]$ ] denote the set of points of the boolean chips and @xmath313-configurations , @xmath387\\times[t].$ ]    * claim 1 : * in any solution @xmath105 of @xmath283 we have @xmath388 for every @xmath389\\times[n])\\setminus \\mathcal{g}.$ ]    to see this , we first remark that the claim holds for all points outside each clause chip since the only blocks there that are not set to zero are the boolean chips of the initializer and connectors .",
    "for the points inside a clause chip , we need to distinguish three cases since there are three differently structured @xmath313-configurations , in which different blocks are set to zero .",
    "they are shown in figure  [ fig : p2collectors ] .",
    "the figure shows , however , that in all three cases it holds that the points outside the corresponding boolean chips and the @xmath313-configuration are either set to zero by block constraints or by zeros of suitable row or column sums .",
    "this shows the claim .",
    "* claim 2 : * in any solution @xmath105 of @xmath283 every @xmath290- and @xmath291-chip , @xmath289,$ ] is of one of the types  @xmath390 shown in figure  [ fig : p2types ] .    for this , consider a fixed index @xmath381.$ ] each @xmath290-chip is contained in a horizontal or vertical strip that contains , except for a @xmath291-chip , no other points of @xmath391 since we required via block constraints that each @xmath291-chip contains two ones and since the respective row or column sums in the strip sum up to four there need to be exactly two ones also in each @xmath290-chip .",
    "there are four possibilities to place two ones into a @xmath293 box if it is required ( as is the case via our row and column sums ) that no two ones are in the rightmost column and upper row of the box .",
    "the four possibilities are shown in figure  [ fig : p2types ] .",
    "* claim 3 : * in any solution @xmath105 of @xmath283 it holds that for every @xmath294 $ ] the @xmath290-chips are either all of type  1 or type  2 .    to show this , consider again a fixed index @xmath381.$ ] let @xmath392 denote the sequence with ( i )  @xmath393 is the @xmath290-chip of the initializer , ( ii )  @xmath394 is the @xmath291-chip of the @xmath395-th connector , @xmath396,$ ] ( iii )  @xmath397 is the @xmath290-chip of the @xmath309-th vertical collector , @xmath368,$ ] ( iv )  @xmath398 is the @xmath313-configuration of the @xmath309-th clause , @xmath368,$ ] and ( v )  @xmath399 is the @xmath290-chip of the @xmath309-th horizontal collector , @xmath368.$ ]    by vertical transmission ( see figure  [ fig : p2collectorfilled1 ] ) and claim  2 , we have the following implication : if a @xmath290-chip of @xmath400 @xmath401,$ ] is of type  1 , 3 or @xmath402 then the @xmath290-chip of @xmath403 is of type  1 , and the points of @xmath404 are also uniquely determined ( here , @xmath405 ) .     block .",
    "( a , b , c ) transmission through the three differently structured @xmath313-configurations .",
    "( d , e ) transmission through a connector.,scaledwidth=90.0% ]    by horizontal transmission ( see figure  [ fig : p2collectorfilledx ] ) and claim  2 , we have the following implication : if a @xmath290-chip of @xmath400 @xmath401,$ ] is of type  2 , 3 or @xmath402 then the @xmath290-chip of @xmath406 is of type  2 , and the points of @xmath407 are also uniquely determined ( here , @xmath408 )",
    ".     block .",
    "( a , b , c ) transmission through the three differently structured @xmath313-configurations .",
    "( d , e ) transmission through a connector.,scaledwidth=90.0% ]    since @xmath409 we have proved claim  3 , and , in particular , we have ruled out that any @xmath290-chip is of type  3 and  4 .",
    "the types  1 and  2 can be associated with boolean values . in @xmath290-chips , and in particular those of the initializer",
    ", we associate with type  1 the value true and with type  2 the value false .    * claim 4 : * there is a 1-to-1 correspondence between the ( not - necessarily satisfying ) truth - assignments for @xmath92 and the solutions  @xmath105 to the @xmath410-variant of @xmath283 that allows violation of the verifier sums .    by construction , there is neither a horizontal nor a vertical strip that intersects the boolean chips for two variables @xmath411 @xmath412 with @xmath413 the arguments from claim  3 are thus independently valid for each @xmath289.$ ] we can hence consider an arbitrary ( not - necessarily satisfying ) truth - assignment for @xmath414 fill in the corresponding types in the initializer and extend them to yield a solution to the @xmath410-variant of @xmath283 with unspecified verifier sums .",
    "vice versa , by reading off the chip types in the initializer of a solution to @xmath410 yields a truth - assignment for  @xmath284 we have already seen in the proof of claim  3 that the type of each @xmath290-chip , @xmath289,$ ] in the initializer determines all ones in the corresponding @xmath291-chips and @xmath313-configurations , @xmath335.$ ] hence , the correspondence is indeed 1-to-1 .    *",
    "claim 5 : * the satisfying truth - assignments of @xmath92 are in 1-to-1 correspondence with the solutions of @xmath295    this can now be seen by taking into account that the @xmath290-chip , @xmath289,$ ] of the @xmath309-th horizontal and vertical verifier , @xmath368,$ ] contributes a one to the horizontal and , respectively , vertical verifier in the @xmath309-th clause chip if , and only if , the @xmath290-chip is true ( is of type  1 ) with @xmath415 or the @xmath290-chip is false ( is of type",
    "2 ) with @xmath416 ; see figures  [ fig : p2collectors ] , [ fig : p2collectorfilled1](a , b , c ) , and  [ fig : p2collectorfilledx](a , b , c ) .",
    "the verifier sums thus ensure that exactly one literal in the @xmath309-th clause is true .",
    "this , together with claim  4 , proves the claim .    by claim  5",
    "it holds that @xmath283 admits a solution if , and only if , @xmath92 admits a solution .",
    "finally , we note that the transformation runs in polynomial time .",
    "in section  [ sect : notation ] we remarked that @xmath68 can be viewed as version of @xmath187 where small `` occasional '' uncertainties in the gray levels are allowed .",
    "reviewing our proof of theorem  [ thm : main2 ] , the term `` occasional '' can be quantified as meaning `` of the order of the square root of the number of blocks . ''",
    "let us further remark that the arguments in the above proof do not rely on the particular value of @xmath53 in the noisy block constraints .",
    "these constraints can be replaced by any other types of block constraints as long as they allow for 0 , 1 , and 2 ones to be contained in each of the corresponding blocks . by this observation",
    "it is possible to adapt our proof to several other contexts where the reconstruction task involves other types or combinations of block constraints ; see @xcite .",
    "finally , note that the transformation in the proof of theorem  [ thm : main2 ] is parsimonious ( see claim  5 in the above proof ) .",
    "hence the problem of deciding whether a given solution of an instance of ndr@xmath69 with @xmath53 has a non - unique solution is @xmath0-complete ; for an @xmath0-hardness proof of @xmath417 see ( * ? ? ?",
    "* lemma  4.2 ) .",
    "we use a transformation from ndr@xmath418 let @xmath419 denote an instance of ndr@xmath418    we set @xmath420 and @xmath421 for @xmath422\\times[n])\\cap c(m , n,2)$ ] and @xmath423 $ ] we define @xmath424,\\\\ 0&:&\\textnormal{otherwise,}\\end{array}\\right.\\\\ c'_{\\frac{k}{2}(i-1)+l}&:=\\left\\{\\begin{array}{lll}c_{i+l}&:&l\\in[2],\\\\ 0&:&\\textnormal{otherwise,}\\end{array}\\right.\\\\ v'(k(i-1)/2 + 1,k(j-1)/2 + 1))&:=v(i , j),\\end{aligned}\\ ] ] and @xmath425    this defines an instance @xmath426 of nsr@xmath427 clearly , the instance  @xmath92 of ndr@xmath69 admits a solution if , and only if ,  @xmath283 of nsr@xmath44 admits a solution ( by filling / extracting the @xmath428-blocks of @xmath92 into / from the @xmath3-blocks of @xmath283 ) .",
    "this is a polynomial - time transformation , proving the theorem .",
    "recall that in the proof of theorem  [ thm : main1 ] we have made extensive use of the concept of local switches .",
    "each such switch involves four points .",
    "figure  [ fig : largeswitchingcomp ] shows , on the other hand , two solutions of a dr instance that differ by  @xmath429 pixels , and for which it is easily checked that they are the only two solutions for that instance ( such a structure has been utilized in the proof of theorem  [ thm : main2 ] ) . in this case there is thus no sequence of small switches transforming one solution into the other .",
    "the existence of such large irreducible switches is well - known for the @xmath0-hard reconstruction problem from more than two directions @xcite ( and would follow independently from @xmath430 ) .",
    "the problem @xmath431 however , admits large switches albeit is polynomial - time solvable .",
    "in addition to the block constraints our computational tasks rely only on row and column sums , i.e. , projection data from two viewing angles . for more than two viewing directions",
    "we obtain the @xmath0-hardness of nsr@xmath44 for any @xmath43 and @xmath53 directly from the construction in  @xcite .",
    "the @xmath0-hardness of the corresponding variants of nsr@xmath432 for @xmath433 can also be derived from the construction in  @xcite .",
    "first the construction is thinned out so as to make sure that each block contains at most one element of the grid of candidate points .",
    "then , a second copy with inverted colors is interwoven by applying a translation by @xmath434 or @xmath435 this ensures that each non - empty block contains exactly one one .",
    "g.  van gompel , k.  j. batenburg , e.  van de  casteele , w.  van aarle , and j.  sijbers . a discrete tomography approach for superresolution micro - ct images : application to bone . in _ 2010 ieee intern .",
    "biomedical imaging : from nano to macro _ , pages 816819 , 2010 .",
    "p.  gritzmann . on the reconstruction of finite lattice sets from their x - rays . in _ discrete geometry for computer imagery ( eds .",
    ": e.  ahronovitz and c.  fiorio ) , dcgi97 , lecture notes on computer science 1347 , springer _ , pages 1932 , 1997 .              c.  kisielowski ,",
    "p.  schwander , f.  h. baumann , m.  seibt , y.  kim , and a.  ourmazd .",
    "an approach to quantitative high - resolution transmission electron microscopy of crystalline materials .",
    ", 58(2):131155 , 1995 .",
    "p.  schwander , c.  kisielowski , f.  h. baumann , y.  kim , and a.  ourmazd .",
    "mapping projected potential , interfacial roughness , and composition in general crystalline solids by quantitative transmission electron microscopy .",
    ", 71(25):41504153 , 1993 .",
    "j.  zhu , j.  gao , a.  ehn , m.  aldn , z.  li , d.  moseev , y.  kusano , m.  salewski , a.  alpers , p.  gritzmann , and m.  schwenk . measurements of 3d slip velocities and plasma column lengths of a gliding arc discharge . , 106(4):04410114 , 2015 ."
  ],
  "abstract_text": [
    "<S> super - resolution imaging aims at improving the resolution of an image by enhancing it with other images or data that might have been acquired using different imaging techniques or modalities . in this paper </S>",
    "<S> we consider the task of doubling the resolution of tomographic grayscale images of binary objects by fusion with double - resolution tomographic data that has been acquired from two viewing angles . we show that this task is polynomial - time solvable if the gray levels have been reliably determined . </S>",
    "<S> the task becomes @xmath0-hard if the gray levels of some pixels come with an error of @xmath1 or larger . </S>",
    "<S> the @xmath0-hardness persists for any larger resolution enhancement factor . </S>",
    "<S> this means that noise does not only affect the quality of a reconstructed image but , less expectedly , also the algorithmic tractability of the inverse problem itself .    </S>",
    "<S> = 1 </S>"
  ]
}