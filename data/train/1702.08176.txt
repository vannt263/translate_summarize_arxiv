{
  "article_text": [
    "the `` one - shot '' terracotta tablets introduced and used at sumer about 3030 bc  @xcite , and the `` multi - shot '' palimpsests used in the middle - age , can be considered as ancestors of the _ read / write register _",
    "such an object provides its users with a write operation which defines a new value of the register , and a read operation which returns its value . when considering sequential computing , read / write registers are universal in the sense that they are assumed to allow solving any problem that can be solved  @xcite .",
    "[ [ on - the - variety - of - readwrite - registers - and - their - distributed - implementation ] ] on the variety of read / write registers and their distributed implementation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in a shared read / write memory system , the registers are given for free .",
    "the situation is different in a message - passing system , where the computing entities ( processes ) communicate by sending and receiving messages transmitted through a communication network .",
    "hence , in such a distributed context , a register is not given for free , but constitutes a communication abstraction which must be built by a distributed algorithm with the help of the local memories of the processes and the communication network .",
    "several types of registers have been proposed .",
    "they differ according to ( a ) their size ( from binary registers which contain a single bit , to bounded and unbounded registers ) ; ( b ) their behavior in the presence of concurrency ( safe , regular , atomic  @xcite ) ; ( c ) the number of processes which are allowed to read them ( single - reader -sr- vs multi - reader -mr- register ) ; and ( d ) the number of processes which are allowed to write them ( single - writer -sr- vs multi - writer -mr- register ) , which gives four possible combinations from swsr to mwmr .",
    "there are algorithms building mwmr atomic ( bounded and unbounded ) registers from swsr binary safe registers  @xcite ( see  @xcite for surveys of such algorithms ) .",
    "as far as a read / write register is concerned , _ atomicity _ means that ( a ) each read or write operation appears as if it had been executed instantaneously at a single point of the time line , ( b ) this point appears between its start event and its end event , ( c ) no two operations appear at the same point of the time line , and ( d ) a read returns the value written by the closest preceding write operation ( or the initial value of the register if there is no preceding write )  @xcite . _",
    "linearizability _ is atomicity extended to any object defined from a sequential specification on total operations  @xcite . in the following , we consider the terms atomicity and linearizability as synonyms .",
    "hence , a sequence of read and write operations satisfying atomicity is said to be linearizable , and is called a linearization .",
    "the point of the time line at which an operation appears to have been executed is called its linearization point .",
    "many distributed algorithms have been proposed , which build a read / write register on top of a message - passing system , be it failure - free or failure - prone . in the failure - prone case ,",
    "the addressed failure models are the process crash failure model , and the byzantine process failure model ( see textbooks , e.g. ,  @xcite ) .",
    "when considering process crash failures ( the one considered in this paper ) , the most famous of these algorithms was proposed by h. attiya , a. bar - noy , and d. dolev in  @xcite .",
    "this algorithm , usually called abd according to the names of its authors , considers an @xmath0-process asynchronous system in which up to @xmath1 processes may crash . as",
    "@xmath1 is an upper bound of the number of process crashes which can be tolerated ( see  @xcite ) , this algorithm is @xmath2-resilient optimal .",
    "its instances implementing swmr or mwmr atomic read / write registers rely on ( a ) quorums  @xcite , and ( b ) a classical broadcast / reply communication pattern .",
    "this communication pattern is used twice in a read operation , and once ( twice ) in a write operation for an swmr ( mwmr ) atomic read / write register .    other algorithms each with its own properties implementing atomic read / write registers on top of crash - prone asynchronous message - passing systems can be found in the literature ( @xcite to cite a few ; see also the analytic presentation given in  @xcite ) .",
    "[ [ from - registers - to - snapshot - objects ] ] from registers to snapshot objects + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the snapshot object was introduced in  @xcite .",
    "a snapshot object is an array @xmath3 $ ] of atomic read / write registers which provides the processes with two operations , denoted @xmath4 and @xmath5 .",
    "if the base registers are swmr the snapshot is called swmr snapshot ( and we have then @xmath6 ) . in this case , the invocation of @xmath7 by a process @xmath8 assigns @xmath9 to @xmath10 $ ] , and the invocation of @xmath5 by a process @xmath8 returns the value of the full array as if the operation had been executed instantaneously .",
    "if the base registers are mwmr , the snapshot is called mwmr snapshot .",
    "the invocation of @xmath11 , where @xmath12 , by a process @xmath8 assigns @xmath9 to @xmath13 $ ] , and @xmath5 is defined as before . said another way , the operations @xmath4 and @xmath5 are atomic , i.e. , in any execution of an swmr ( or mwmr ) snapshot object , its operations @xmath4 and @xmath5 are linearizable .",
    "implementations of both swmr and mwmr snapshot objects on top of read / write atomic registers have been proposed ( e.g. ,  @xcite ) .",
    "the `` hardness '' to build snapshot objects in read / write systems and associated lower bounds are presented in the survey  @xcite . the best algorithm known to implement an swmr snapshot requires @xmath14 read /",
    "write on the base swmr registers for both the @xmath4 and @xmath5 operations  @xcite . as far as mwmr snapshot objects are concerned",
    ", there are implementations where each operation has an @xmath15 cost .    as far as the construction of an swmr ( or mwmr ) snapshot object in crash - prone asynchronous message - passing systems where @xmath16 is concerned",
    ", it is possible to stack two constructions : first an algorithm implementing swmr ( or mwmr ) atomic read / write registers ( such as abd ) , and , on top of it , an algorithm implementing an swmr ( or mwmr ) snapshot object .",
    "this stacking approach provides objects whose operation cost is @xmath17 messages for swmr snapshot , and @xmath18 messages for mwmr snapshot .",
    "an algorithm based on the same communication pattern as abd , which builds an atomic swmr snapshot object `` directly '' ( i.e. , without stacking algorithms ) was recently presented in  @xcite ( the aim of this algorithm is to perform better that the stacking approach in concurrency - free executions ) .",
    "[ [ another - look - at - the - implementation - of - readwrite - registers - and - snapshot - objects ] ] another look at the implementation of read / write registers and snapshot objects + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in sequential computing , there are `` natural '' pairings linking data structures and control structures .",
    "the most simple examples are the pair `` array and * for * loop '' , and the pair `` tree and recursion '' .",
    "when we look at the implementation of a causal read / write register  @xcite on top of a ( crash - free or crash - prone ) message - passing system , the causal message delivery broadcast abstraction  @xcite is the appropriate communication abstraction .",
    "namely , given this abstraction for free , the algorithms implementing the read and write operations build on top of it , become very simple , need only a few lines , and are easy to understand and to prove correct .",
    "of course , this is due to the fact that the causal broadcast abstraction captures and abstracts the causality relation needed to implement a causal read / write register .",
    "similarly , total order broadcast is the communication abstraction associated with the consensus object  @xcite .",
    "this is summarized in table  [ table1 ] .",
    ".associating objects and communication abstractions in a wait - free model [ cols=\"^,^\",options=\"header \" , ]     as already said , all the algorithms we know which implement atomic read / write registers , and ( by stacking transitivity or directly ) swmr or mwmr snapshots objects , on top of crash - prone asynchronous message - passing systems , are based on a broadcast / reply pattern plus the use of intersecting quorums .",
    "hence , the following question naturally arises : is this approach the `` only '' way to implement a snapshot object ( or an atomic register ) , or is there a _ specific communication abstraction which captures the essence and simplifies the implementation of snapshot objects ( and atomic read / write registers ) _ ?",
    "[ [ content - of - the - paper ] ] content of the paper + + + + + + + + + + + + + + + + + + + +    informatics in general ( and distributed computing in particular ) is a science of abstractions , and this paper is _ distributed programming abstraction_-oriented .",
    "it strives to address a `` desired level of abstraction and generality ",
    "one that is broad enough to encompass interesting new situations yet specific enough to address the crucial issues '' as expressed in  @xcite .",
    "more precisely , it answers the previous question in a positive way . to this end",
    ", it presents a simple broadcast abstraction which matches and therefore captures the essence of snapshot objects ( and atomic read / write registers ) .",
    "we call it _ set - constrained delivery broadcast _ ( in short scd - broadcast ) .",
    "given this communication abstraction , it is possible to quorum - free build snapshot objects , and vice versa .",
    "hence , similarly to consensus and total order broadcast , scd - broadcast and snapshot objects have the same computational power ( table  [ table1 ] ) .",
    "the scd - broadcast communication abstraction allows a process to broadcast messages , and to deliver sets of messages ( instead of single messages ) in such a way that , if a process @xmath8 delivers a message set @xmath19 containing a message @xmath20 , and later delivers a message set @xmath21 containing a message @xmath22 , then no process @xmath23 can deliver first a set containing @xmath22 and later another set containing @xmath20 .",
    "let us notice that @xmath23 is not prevented from delivering @xmath20 and @xmath22 in the same set .",
    "the implementation of an instance of scd - broadcast costs @xmath18 messages .",
    "it follows that the cost of a snapshot operation ( or a read / write register operation ) on top of a message - passing asynchronous system , where any minority of processes may crash , is also @xmath18 for both swmr and mwmr snapshot objects ( i.e. , better than the stacking approach for swmr snapshot objects ) .",
    "additionally , be the snapshot objects that are built swmr or mwmr , their implementation differ only in the fact that their underling read / write registers are swmr or mwmr .",
    "this provides us with a noteworthy genericity - related design simplicity .    of course , there is rarely something for free .",
    "the algorithms implementing the snapshot and write operations are simple because the scd - broadcast abstraction hides enough `` implementation details '' and provides consequently a high level abstraction ( much higher than the simple broadcast used in abd - like algorithms ) .",
    "its main interest lies in its capture of the _ high level message communication abstraction _ that , despite asynchrony and process failures , allows simple message - passing implementations of shared memory objects such as snapshot objects and atomic read / write registers .    [ [ roadmap ] ] roadmap + + + + + + +    the paper is composed of  [ sec : conclusion ] sections .",
    "section  [ sec : models ] presents the two base computation models concerned in this paper , ( read / write and message - passing ) .",
    "section  [ sec : scd - broadcast ] presents the scd - broadcast communication abstraction .",
    "then , section  [ sec : from - scd - to - snapshot ] presents a simple algorithm which implements a snapshot object on top of an asynchronous system enriched with scd - broadcast , in which any number of processes may crash .",
    "section  [ sec : from - snapshot - to - scd ] addresses the other direction , namely , it presents an algorithm building the scd - broadcast abstraction on top of an asynchronous system enriched with snapshot objects and where any number of processes may crash .",
    "section  [ sec : conclusion ] concludes the paper . a noteworthy feature of the algorithms that are presented lies in their simplicity , which is a first class property",
    ".    appendix  [ sec : algo - for - sc ] describes an implementation of scd - broadcast suited to asynchronous message - passing systems where any minority of processes may crash .",
    "hence , being implementable in the weakest from the point of view of the maximal number of process crashes that can be tolerated , assuming failures are independent .",
    "] message - passing system model in which a read / write register can be built , scd - broadcast is not `` yet another oracle '' which makes things simpler to understand but can not be implemented .",
    "appendix  [ sec : from - scd - to - swmr - mwmr ] presents simplified scd - based algorithms which build atomic and sequentially consistent read / write registers .",
    "this section presents two basic computation models . in both cases ,",
    "the process model is the same .",
    "the computing model is composed of a set of @xmath0 asynchronous sequential processes , denoted @xmath24 , ... , @xmath25 .",
    "`` asynchronous '' means that each process proceeds at its own speed , which can be arbitrary and always remains unknown to the other processes .",
    "a process may halt prematurely ( crash failure ) , but it executes its local algorithm correctly until its possible crash .",
    "the model parameter @xmath2 denotes the maximal number of processes that may crash in a run . a process that crashes in a run is said to be _",
    "faulty_. otherwise , it is _ non - faulty_. hence a faulty process behaves as a non - faulty process until it crashes .",
    "[ [ atomic - readwrite - register ] ] atomic read / write register + + + + + + + + + + + + + + + + + + + + + + + + + +    the notion of an atomic read / write register has been formalized in  @xcite .",
    "an mwmr _ atomic _ register ( say @xmath26 ) is a concurrent object which provides each process with an operation denoted @xmath27 , and an operation denoted @xmath28 . when a process invokes @xmath29 it defines @xmath9 as being the new value of @xmath26 .",
    "an mwmr atomic register is defined by the following set of properties .",
    "* liveness .",
    "an invocation of an operation by a non - faulty process terminates .",
    "* consistency ( safety ) .",
    "all the operations invoked by the processes , except possibly for each faulty process the last operation it invoked , appear as if they have been executed sequentially and this sequence of operations is such that : * * each read returns the value written by the closest write that precedes it ( or the initial value of @xmath26 if there is no preceding write ) , * * if an operation @xmath30 terminates before an operation @xmath31 starts , then @xmath30 appears before @xmath31 in the sequence .",
    "this set of properties states that , from an external observer point of view , the read / write register appears as if it is accessed sequentially by the processes , and this sequence ( a ) respects the real - time access order , and ( b ) belongs to the sequential specification of a register .",
    "[ [ notation ] ] notation + + + + + + + +    the previous computation model is denoted @xmath32 $ ] ( @xmath33rash @xmath34synchronous @xmath35ead-@xmath36rite ) .",
    "this basic read / write model is also called _ wait - free _ read / write model .",
    "the symbol @xmath37 means there is no specific constraint on @xmath2 , which is equivalent to @xmath38 , as it is always assumed that not all processes crash .",
    "[ [ snapshot - object ] ] snapshot object + + + + + + + + + + + + + + +    this object was defined in the introduction .",
    "as we have seen , snapshot objects can be built in @xmath32 $ ] .",
    "as we have seen there are two types of snapshot objects .",
    "swmr snapshot objects ( whose base registers are swmr ) , and mwmr snapshot objects ( whose base registers are mwmr ) . in the following we consider mwmr snapshot objects , but",
    "the algorithms can be trivially adapted to work with swmr snapshot objects .",
    "@xmath32 $ ] enriched with snapshot objects is denoted @xmath39}$ ] . as a snapshot object can be built in @xmath32 $ ] this model has the same computational power as @xmath32 $ ] .",
    "it only offers a higher abstraction level .",
    "[ [ communication ] ] communication + + + + + + + + + + + + +    each pair of processes communicate by sending and receiving messages through two uni - directional channels , one in each direction .",
    "hence , the communication network is a complete network : any process @xmath8 can directly send a message to any process @xmath23 ( including itself ) .",
    "a process @xmath8 invokes the operation `` @xmath40 type(@xmath20 ) @xmath41 @xmath23 '' to send to @xmath23 the message @xmath20 , whose type is type .",
    "the operation `` @xmath42 type ( ) @xmath43 @xmath23 '' allows @xmath8 to receive from @xmath23 a message whose type is type .",
    "each channel is reliable ( no loss , corruption , nor creation of messages ) , not necessarily first - in / first - out , and asynchronous ( while the transit time of each message is finite , there is no upper bound on message transit times ) .",
    "let us notice that , due to process and message asynchrony , no process can know if another process crashed or is only very slow .    [",
    "[ notation - and - necessary - and - sufficient - condition ] ] notation and necessary and sufficient condition + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this computation model is denoted @xmath44 $ ] ( @xmath33rash @xmath34synchronous @xmath45essage-@xmath46assing ) .",
    "the constraint @xmath47 is a necessary and sufficient condition to implement an atomic read / write register in @xmath44 $ ]  @xcite .",
    "hence , the model @xmath44 $ ] whose runs are constrained by @xmath16 is denoted @xmath48 $ ] .",
    "[ [ definition ] ] definition + + + + + + + + + +    the set - constrained broadcast abstraction ( scd - broadcast ) provides the processes with two operations , denoted @xmath49 and @xmath50 .",
    "the first operation takes a message to broadcast as input parameter .",
    "the second one returns a non - empty set of messages to the process that invoked it . using a classical terminology ,",
    "when a process invokes @xmath51 , we say that it `` scd - broadcasts a message @xmath20 '' .",
    "similarly , when it invokes @xmath50 and obtains a set of messages @xmath19 , we say that it `` scd - delivers a set of messages @xmath19 '' . by a slight abuse of language",
    ", we also say that a process `` scd - delivers a message @xmath20 '' when it delivers a message @xmath52 .",
    "scd - broadcast is defined by the following set of properties , where we assume without loss of generality that all the messages that are scd - broadcast are different .    *",
    "if a process scd - delivers a set containing a message @xmath20 , then @xmath20 was scd - broadcast by some process .",
    "* integrity .",
    "a message is scd - delivered at most once by each process . *",
    "ms - ordering . if a process @xmath8 scd - delivers first a message @xmath20 belonging to a set @xmath53 and later a message @xmath22 belonging to a set @xmath54 , then no process scd - delivers first the message @xmath22 in some scd - delivered set @xmath55 and later the message @xmath20 in some scd - delivered set @xmath56 .",
    "* termination-1 .",
    "if a non - faulty process scd - broadcasts a message @xmath20 , it terminates its scd - broadcast invocation and scd - delivers a message set containing @xmath20 .",
    "* termination-2 .",
    "if a non - faulty process scd - delivers a message @xmath20 , every non - faulty process scd - delivers a message set containing @xmath20 .",
    "termination-1 and termination-2 are classical liveness properties ( found for example in uniform reliable broadcast ) .",
    "the other ones are safety properties .",
    "validity and integrity are classical communication - related properties .",
    "the first states that there is neither message creation nor message corruption , while the second states that there is no message duplication .",
    "the ms - ordering property is new , and characterizes scd - broadcast .",
    "it states that the contents of the sets of messages scd - delivered at any two processes are not totally independent : the sequence of sets scd - delivered at a process @xmath8 and the sequence of sets scd - delivered at a process @xmath23 must be mutually consistent in the sense that a process @xmath8 can not scd - deliver first @xmath57 and later @xmath58 , while another process @xmath23 scd - delivers first @xmath59 and later @xmath60 .",
    "let us nevertheless observe that if @xmath8 scd - delivers first @xmath57 and later @xmath61 , @xmath23 may scd - deliver @xmath20 and @xmath22 in the same set of messages .",
    "[ [ an - example ] ] an example + + + + + + + + + +    let @xmath62 , @xmath63 , @xmath64 , @xmath65 , @xmath66 , @xmath67 , @xmath68 , @xmath69 , ... be messages that have been scd - broadcast by different processes .",
    "the following scd - deliveries of message sets by @xmath24 , @xmath70 and @xmath71 respect the definition of scd - broadcast :    * at @xmath24 : @xmath72 , @xmath73 , @xmath74 , @xmath75 .",
    "* at @xmath70 : @xmath76 , @xmath77 , @xmath78 , @xmath79 , @xmath80 . * at @xmath71 : @xmath81 , @xmath78 , @xmath79 , @xmath80 .    differently , due to the scd - deliveries of the sets including @xmath63 and @xmath64",
    ", the following scd - deliveries by @xmath24 and @xmath70 do not satisfy the ms - broadcast property :    * at @xmath24 : @xmath72 , @xmath73 , ... * at @xmath70 : @xmath82 , @xmath83 , ...    [ [ a - containment - property ] ] a containment property + + + + + + + + + + + + + + + + + + + + + +    let @xmath84 be the @xmath85-th message set scd - delivered by @xmath8 .",
    "hence , at some time , @xmath8 scd - delivered the sequence of message sets @xmath86 .",
    "let @xmath87 .",
    "the following property follows directly from the ms - ordering and termination-2 properties :    * containment .",
    "@xmath88 : @xmath89 .",
    "[ [ remark-1-weakening - scd - broadcast ] ] remark 1 : weakening scd - broadcast + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    if the messages in a message set are delivered one at a time , and the ms - ordering property is suppressed , scd - broadcast boils down to _",
    "reliable broadcast_.    [ [ remark-2-on - the - partial - order - created - by - the - message - sets ] ] remark 2 : on the partial order created by the message sets + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the ms - ordering and integrity properties establish a partial order on the set of all the messages , defined as follows .",
    "let @xmath90 be the local message delivery order at a process @xmath8 defined as follows : @xmath91 if @xmath8 scd - delivers the set containing @xmath20 before the set containing @xmath22 .",
    "as no message is scd - delivered twice , it is easy to see that @xmath92 is a partial order ( locally know by @xmath8 ) .",
    "the reader can check that there is a total order ( which remains unknown to the processes ) on the whole set of messages , that complies with the partial order @xmath93 .",
    "this is where scd - broadcast can be seen as a weakening of total order broadcast .",
    "let @xmath94 $ ] denote @xmath95 $ ] enriched with the scd - broadcast abstraction .",
    "hence , this abstraction is given for free .",
    "this section presents and proves correct a simple algorithm building an mwmr snapshot object on top of @xmath94 $ ] . the same algorithm with very few simple modifications",
    "can be used to build swmr or mwmr atomic registers in @xmath94 $ ] ( see appendix  [ sec : from - scd - to - swmr - mwmr ] ) .",
    "let @xmath3 $ ] denote the mwmr snapshot object that is built .",
    "[ [ local - representation - of - mathitreg - at - a - process - p_i ] ] local representation of @xmath26 at a process @xmath8 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    at each register @xmath8 , @xmath3 $ ] is represented by three local variables @xmath96 $ ] ( data part ) , plus @xmath97 $ ] and @xmath98 ( control part ) .",
    "* @xmath99 is a boolean variable . *",
    "@xmath100 $ ] contains the current value of @xmath3 $ ] , as known by @xmath8 . *",
    "@xmath97 $ ] is an array of timestamps associated with the values stored in @xmath100 $ ] .",
    "a timestamp is a pair made of a local clock value and a process identity .",
    "its initial value is @xmath101 .",
    "the fields associated with @xmath102 $ ] are denoted @xmath103.date , tsa_i[r].proc \\rangle$ ] .",
    "[ [ timestamp - based - order - relation ] ] timestamp - based order relation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we consider the classical lexicographical total order relation on timestamps , denoted @xmath104 .",
    "let @xmath105 and @xmath106 .",
    "we have @xmath107    [ [ algorithmalgosnapshot - from - scd - snapshot - operation ] ] algorithm  [ algo : snapshot - from - scd ] : snapshot operation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ( lines  [ snap - from - sc-01]-[snap - from - sc-04 ] ) when @xmath8 invokes @xmath108 , it first sets @xmath99 to @xmath109 , and invokes @xmath110 @xmath111 .",
    "( ) is a synchronization message , whose aim is to entail the refreshment of the value of @xmath100 $ ] ( lines  [ snap - from - sc-11]-[snap - from - sc-17 ] ) which occurs before the setting of @xmath99 to @xmath112 ( line  [ snap - from - sc-18 ] ) . when this happens , @xmath8 returns the value of its local variable @xmath100 $ ] and terminates its snapshot invocation .",
    "[ [ algorithmalgosnapshot - from - scd - write - operation ] ] algorithm  [ algo : snapshot - from - scd ] : write operation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ( lines  [ snap - from - sc-05]-[snap - from - sc-10 ] ) when a process @xmath8 wants to assign a value @xmath9 to @xmath13 $ ] , it invokes @xmath113 .",
    "this operation is made up of two parts .",
    "first @xmath8 executes a re - synchronization ( lines  [ snap - from - sc-05]-[snap - from - sc-07 ] , exactly as in the snapshot operation ) whose side effect is here to provide @xmath8 with an up - to - date value of @xmath114.date$ ] . in the second part , @xmath8 associates the timestamp @xmath115.date+1,i\\rangle$ ] with @xmath9 , and invokes @xmath110 @xmath116.date+1,i\\rangle)$ ] ( line  [ snap - from - sc-09 ] ) .",
    "in addition to informing the other processes on its write of @xmath13 $ ] , this message @xmath117 acts as a re - synchronization message , exactly as a message @xmath111 . when this synchronization terminates ( i.e. , when the boolean @xmath99 is set to @xmath118 ) , @xmath8 returns from the write operation ( line  [ snap - from - sc-10 ] ) .",
    "[ [ algorithmalgosnapshot - from - scd - scd - delivery - of - a - set - of - messages ] ] algorithm  [ algo : snapshot - from - scd ] : scd - delivery of a set of messages + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when @xmath8 scd - delivers a message set , namely , +    @xmath119  @xmath120 @xmath121 @xmath122 @xmath123     + it first looks if there are messages @xmath117 .",
    "if it is the case , for each register @xmath13 $ ] for which there are messages @xmath124 ( line  [ snap - from - sc-11 ] ) , @xmath8 computes the maximal timestamp carried by these messages ( line  [ snap - from - sc-12 ] ) , and updates accordingly its local representation of @xmath13 $ ] ( lines  [ snap - from - sc-13]-[snap - from - sc-15 ] ) . finally , if @xmath8 is the sender of one of these messages ( @xmath117 or @xmath117 ) , @xmath98 is set to @xmath112 , which terminates @xmath8 s re - synchronization ( line  [ snap - from - sc-18 ] ) .",
    "[ [ message - cost ] ] message cost + + + + + + + + + + + +    an invocation of @xmath5 involves one invocation of @xmath49 , and an invocation of @xmath4 involves two such invocations .",
    "it is shown in appendix  [ sec : algo - for - sc ] that , in a message - passing system , @xmath49 costs @xmath18 protocol messages .",
    "it follows that , in such systems , the message cost of both operations of a snapshot object is @xmath18 .",
    "( this remains true for swmr snapshot objects , see appendix  [ sec : from - scd - to - swmr - mwmr ] . )",
    "as they are implicitly used in the proofs that follow , let us recall the properties of the scd - broadcast abstraction .",
    "the non - faulty processes scd - deliver the same messages ( exactly one each ) , and each of them was scd - broadcast .",
    "as a faulty process behaves correctly until it crashes , it scd - delivers a subset of the messages scd - delivered by the non - faulty processes .    without loss of generality",
    ", we assume that there is an initial write operation issued by a non - faulty process . moreover ,",
    "if a process crashes in a snapshot operation , its snapshot is not considered ; if a process crashes in a write operation , its write is considered only if the message ( ) it sent at line  [ snap - from - sc-09 ] is scd - delivered to at least one non - faulty process ( and by the termination-2 property , at least to all non - faulty processes ) .",
    "let us notice that a message ( ) scd - broadcast by a process @xmath8 does not modify the local variables of the other processes .",
    "[ lemma : snapshot - liveness ] if a non - faulty process invokes an operation , it returns from its invocation .",
    "let @xmath8 be a non - faulty process that invokes a read or write operation . by the termination-1 property of scd - broadcast",
    ", it eventually receives a message set containing the message ( ) or ( ) it sends at line [ snap - from - sc-02 ] , [ snap - from - sc-06 ] or [ snap - from - sc-09 ] .",
    "as all the statements associated with the scd - delivery of a message set ( lines  [ snap - from - sc-11]-[snap - from - sc-18 ] ) terminate , it follows that the synchronization boolean @xmath99 is eventually set to @xmath112 .",
    "consequently , @xmath8 returns from the invocation of its operation .",
    "[ [ extension - of - the - relation-_ts ] ] extension of the relation @xmath125 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the relation @xmath125 is extended to a partial order on arrays of timestamps , denoted @xmath126 , defined as follows : @xmath127 \\le_{{\\mathit{tsa } } } tsa2[1 .. m ] \\stackrel{\\mathit{def}}{= } \\forall r : ( { \\mathit{tsa}}1[r ] = { \\mathit{tsa}}2[r ] \\lor { \\mathit{tsa}}1[r ] { { ~<_{ts}~}}\\ tsa2[r])$ ] .",
    "moreover , @xmath128 < _ { { \\mathit{tsa } } } { \\mathit{tsa}}2[1 .. m ] \\stackrel{\\mathit{def}}{= } ( { \\mathit{tsa}}1[1 .. m ] \\le_{tsa } { \\mathit{tsa}}2[1 .. m])\\wedge ( { \\mathit{tsa}}1[1 .. m ] \\neq tsa2[1 .. m])$ ] .",
    "[ [ definition-1 ] ] definition + + + + + + + + + +    let @xmath129 be the set of the array values taken by @xmath130 $ ] at line  [ snap - from - sc-18 ] ( end of the processing of a message set by process @xmath8 ) .",
    "let @xmath131 .",
    "[ lemma : clock - ordering ] the order @xmath132 is total on @xmath133 .",
    "let us first observe that , for any @xmath134 , all values in @xmath129 are totally ordered ( this comes from @xmath130 $ ] whose entries can only increase , lines  [ snap - from - sc-13 ] and  [ snap - from - sc-15 ] ) . hence , let @xmath128 $ ] be an array value of @xmath129 , and @xmath135 $ ] an array value of @xmath136 , where @xmath137 .",
    "let us assume , by contradiction , that @xmath138 and @xmath139 .",
    "as @xmath140 , there is a registers @xmath141 such that @xmath142 < { \\mathit{tsa}}1[r]$ ] . according to lines  [ snap - from - sc-13 ] and  [ snap - from - sc-15 ]",
    ", there is a message @xmath143)$ ] received by @xmath8 when @xmath144 and not received by @xmath23 when @xmath145 ( because @xmath142 < { \\mathit{tsa}}1[r]$ ] ) .",
    "similarly , there is a message @xmath146)$ ] received by @xmath23 when @xmath145 and not received by @xmath8 when @xmath144 .",
    "this situation contradicts the ms - ordering property , from which we conclude that either @xmath147 or @xmath148 .",
    "[ [ definitions ] ] definitions + + + + + + + + + + +    let us associate a timestamp @xmath149 with each write operation as follows .",
    "let @xmath8 be the invoking process ; @xmath150 is the timestamp of @xmath9 as defined by @xmath8 at line  [ snap - from - sc-09 ] , i.e. , @xmath151.date+1 , i\\rangle$ ] .",
    "let @xmath152 and @xmath153 be any two operations .",
    "the relation @xmath154 on the whole set of operations is defined as follows : @xmath155 if @xmath152 terminated before @xmath153 started .",
    "it is easy to see that @xmath154 is a real - time - compliant partial order on all the operations .",
    "[ lemma : snapshot - write - ordering ] no two distinct write operations on the same register @xmath156 and @xmath157 have the same timestamp , and @xmath158 @xmath159 @xmath160 .",
    "let @xmath161 and @xmath162 be the timestamp of @xmath156 and @xmath157 , respectively . if @xmath137 , @xmath156 and @xmath157 have been produced by different processes , and their timestamp differ at least in their process identity .",
    "so , let us consider that the operations have been issued by the same process @xmath8 , with @xmath156 first . as @xmath156 precedes @xmath157 ,",
    "@xmath8 first invoked @xmath110 @xmath163 ( line  [ snap - from - sc-09 ] ) and later @xmath164 .",
    "it follows that these scd - broadcast invocations are separated by a local reset of the boolean @xmath98 at line  [ snap - from - sc-16 ] .",
    "moreover , before the reset of @xmath99 due to the scd - delivery of the message @xmath165@xmath166 , we have @xmath114.date_i\\geq date1 $ ] ( lines  [ snap - from - sc-12]-[snap - from - sc-16 ] ) .",
    "hence , we have @xmath114.date\\geq date1 $ ] before the reset of @xmath99 ( line  [ snap - from - sc-18 ] ) .",
    "then , due to the `` @xmath167 '' at line  [ snap - from - sc-09 ] , @xmath164 is such that @xmath168 , which concludes the proof of the first part of the lemma .",
    "let us now consider that @xmath169 . if @xmath156 and @xmath157 have been produced by the same process we have @xmath170 from the previous reasoning .",
    "so let us assume that they have been produced by different processes @xmath8 and @xmath23 .",
    "before terminating @xmath156 ( when the boolean @xmath99 is set @xmath112 at line  [ snap - from - sc-18 ] ) , @xmath8 received a message set @xmath171 containing the message @xmath163 .",
    "when @xmath23 executes @xmath157 , it first invokes @xmath110 @xmath172 at line  [ snap - from - sc-06 ] . because @xmath156 terminated before @xmath157 started",
    ", this message @xmath172 can not belong to @xmath171 .    due to integrity and termination-2 of scd - broadcast",
    ", @xmath23 eventually scd - delivers exactly one message set @xmath173 containing @xmath163 .",
    "moreover , it also scd - delivers exactly one message set @xmath174 containing its own message @xmath172 . on the the other side ,",
    "@xmath8 scd - delivers exactly one message set @xmath175 containing the message @xmath172 .",
    "it follows from the ms - ordering property that , if @xmath176 , @xmath23 can not scd - deliver @xmath174 before @xmath173 . then , whatever the case ( @xmath177 or @xmath173 is scd - delivered at @xmath23 before @xmath174 ) , it follows from the fact that the messages @xmath117 are processed ( lines  [ snap - from - sc-11]-[snap - from - sc-17 ] ) before the messages @xmath172 ( line  [ snap - from - sc-18 ] ) , that we have @xmath178\\geq \\langle date1,i\\rangle$ ] when @xmath179 is set to @xmath112 .",
    "it then follows from line  [ snap - from - sc-09 ] that @xmath168 , which concludes the proof of the lemma .",
    "[ [ associating - timestamp - arrays - with - operations ] ] associating timestamp arrays with operations + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let us associate a timestamp array @xmath180 $ ] with each operation @xmath181 as follows .",
    "* case @xmath182 .",
    "let @xmath8 be the invoking process ; @xmath183 is the value of @xmath184 $ ] when @xmath8 returns from the snapshot operation ( line  [ snap - from - sc-04 ] )",
    ". * case @xmath185 .",
    "let @xmath186 , where @xmath187 is a set of array values , denote the smallest array value of @xmath187 according to @xmath188 .",
    "let @xmath189 \\in { \\mathit{tsa}}\\mbox { such   that } ts({{\\sf op } } ) \\leq_{ts } { \\mathit{tsa}}[r]\\})$ ] .",
    "hence , @xmath183 is the first @xmath190 $ ] of @xmath133 , that reports the operation @xmath185 .",
    "[ lemma : snapshot - clock - ordering ] let @xmath191 and @xmath192 be two distinct operations such that @xmath193 .",
    "we have @xmath194 .",
    "moreover , if @xmath192 is a write operation , we have @xmath195 .",
    "let @xmath8 and @xmath23 be the processes that performed @xmath191 and @xmath192 , respectively .",
    "let @xmath196 be the @xmath172 message sent by @xmath23 ( at line  [ snap - from - sc-02 ] or  [ snap - from - sc-06 ] ) during the execution of @xmath192 .",
    "let @xmath197 be the value of @xmath184 $ ] when @xmath191 terminates ( line  [ snap - from - sc-04 ] or  [ snap - from - sc-10 ] ) , and @xmath198 the value of @xmath199 $ ] when @xmath200 becomes true for the first time after @xmath23 sent @xmath196 ( line  [ snap - from - sc-03 ] or  [ snap - from - sc-07 ] ) .",
    "let us notice that @xmath197 and @xmath198 are elements of the set @xmath133 .    according to lines",
    "[ snap - from - sc-13 ] and  [ snap - from - sc-15 ] , for all @xmath141 , @xmath114 $ ] is the largest timestamp carried by a message @xmath201 received by @xmath8 in a message set before @xmath191 terminates .",
    "let @xmath20 be a message such that there is a set @xmath202 scd - delivered by @xmath8 before it terminated @xmath191 .",
    "as @xmath23 sent @xmath196 after @xmath8 terminated , @xmath8 did not receive any set containing @xmath196 before it terminated @xmath191 . by the properties",
    "termination-2 and ms - ordering , @xmath23 received message @xmath20 in the same set as @xmath196 or in a message set @xmath203 received before the set containing @xmath196 .",
    "therefore , we have @xmath204 .    if @xmath191 is a snapshot operation , then @xmath205 . otherwise , @xmath185 .",
    "as @xmath8 has to wait until it processes a set of messages including its ( ) message ( and executes line  [ snap - from - sc-18 ] ) , we have @xmath206 $ ] . finally , due to the fact that @xmath207 and lemma  [ lemma : clock - ordering ] , we have @xmath208 .    if @xmath192 is a snapshot operation , then @xmath209 ( line  [ snap - from - sc-04 ] ) .",
    "otherwise , @xmath185 and thanks to the @xmath167 in line  [ snap - from - sc-09 ] , @xmath210 $ ] is strictly smaller than @xmath211 $ ] which , due to lemma  [ lemma : clock - ordering ] , implies @xmath212 .",
    "it follows that , in all cases , we have @xmath213 and if @xmath192 is a write operation , we have @xmath214 , which concludes the proof of the lemma .",
    "the previous lemmas allow the operations to be linearized ( i.e. , totally ordered in an order compliant with both the sequential specification of a register , and their real - time occurrence order ) according to a total order extension of the reflexive and transitive closure of the @xmath215 relation defined thereafter .",
    "let @xmath216 be two operations .",
    "we define the @xmath215 relation by @xmath217 if one of the following properties holds :    * @xmath218 , * @xmath219 , * @xmath220 , @xmath221 is a write operation and @xmath192 is a snapshot operation , * @xmath220 , @xmath191 and @xmath192 are two write operations on the same register and @xmath222 ,    [ lemma : snapshot - safety ] the snapshot object built by algorithm  _ [ algo : snapshot - from - scd ] _ is linearizable .",
    "we recall the definition of the @xmath215 relation : @xmath217 if one of the following properties holds :    * @xmath218 , * @xmath219 , * @xmath220 , @xmath221 is a write operation and @xmath192 is a snapshot operation , * @xmath220 , @xmath191 and @xmath192 are two write operations on the same register and @xmath222 ,    we define the @xmath223 relation as the reflexive and transitive closure of the @xmath215 relation .",
    "let us prove that the @xmath223 relation is a partial order on all operations .",
    "transitivity and reflexivity are given by construction .",
    "let us prove antisymmetry .",
    "suppose there are @xmath224 such that @xmath225 and @xmath226 for all @xmath227 . by lemma  [ lemma : snapshot - clock - ordering ] , for all @xmath227 ,",
    "we have @xmath228 , and @xmath229 , so the timestamp array of all operations are the same . moreover ,",
    "if @xmath230 is a snapshot operation , then @xmath231 is the only possible case ( @xmath232 stands for `` modulo '' ) , and by lemma  [ lemma : snapshot - clock - ordering ] again , @xmath233 is a snapshot operation .",
    "therefore , only two cases are possible .",
    "* let us suppose that all the @xmath230 are snapshot operations and for all @xmath134 , @xmath234 . as @xmath154 is a partial order relation , it is antisymmetric , so all the @xmath230 are the same operation . * otherwise , all the @xmath230 are write operations . by lemma  [ lemma : snapshot - clock - ordering ] , for all @xmath235 . the operations @xmath230 and @xmath236 are ordered by the fourth point , so they are write operations on the same register and @xmath237 . by antisymmetry of the @xmath125 relation ,",
    "all the @xmath230 have the same timestamp , so by lemma  [ lemma : snapshot - write - ordering ] , they are the same operation , which proves antisymmetry .    let @xmath238 be a total order extension of @xmath223 .",
    "relation @xmath238 is real - time compliant because @xmath223 contains @xmath154 .",
    "let us consider a snapshot operation @xmath191 and a register @xmath141 such that @xmath239 = \\langle date1 , i \\rangle$ ] .",
    "according to line  [ snap - from - sc-10 ] , it is associated to the value @xmath9 that is returned by @xmath240 for @xmath141 , and comes from a @xmath241 message sent by a write operation @xmath242 . by definition of @xmath243 , we have @xmath244 ( lemma  [ lemma : snapshot - clock - ordering ] ) , and therefore @xmath245 .",
    "moreover , for any different write operation @xmath246 on @xmath141 , by lemma  [ lemma : snapshot - write - ordering ] , @xmath247 .",
    "if @xmath248 , then @xmath249",
    ". otherwise , @xmath250 , and ( due to the first item of the definition of @xmath215 ) we have @xmath251 . in both cases ,",
    "the value written by @xmath252 is the last value written on @xmath141 before @xmath191 , according to @xmath238 .    [",
    "theorem : proof - snapshot ] algorithm  _ [ algo : snapshot - from - scd ] _ builds an _",
    "snapshot object in the system model @xmath253 $ ] .",
    "the proof follows from lemmas  [ lemma : snapshot - liveness]-[lemma : snapshot - safety ] .",
    "this section presents an algorithm which builds the scd - broadcast abstraction in @xmath39}$ ] .",
    "this algorithm completes the computational equivalence of snapshot and scd - broadcast .",
    "( swmr snapshot objects can be easily implemented in @xmath254}$ ] by instantiating algorithm  [ algo : snapshot - from - scd ] with @xmath6 , and only allowing @xmath8 to invoke @xmath255 . )      [ [ shared - objects ] ] shared objects + + + + + + + + + + + + + +    the shared memory is composed of two swmr snapshot objects ( as defined above ) .",
    "let @xmath256 denote the empty sequence .",
    "* @xmath257 $ ] : is a snapshot object , initialized to @xmath258 $ ] , such that @xmath259 $ ] contains the messages scd - broadcast by @xmath8 . *",
    "@xmath260 $ ] : is a snapshot object , initialized to @xmath261 $ ] , such that @xmath262 $ ] contains the sequence of the sets of messages scd - delivered by @xmath8 .",
    "the notation @xmath263 is used for the concatenation of a message set at the end of a sequence of message sets .",
    "[ [ local - objects ] ] local objects + + + + + + + + + + + + +    each process @xmath8manages the following local objects .",
    "* @xmath264 is a local copy of the snapshot object @xmath265 .",
    "* @xmath266 is a local copy of the snapshot object @xmath267 .",
    "* @xmath268 is an auxiliary variable whose aim is to contain the next message set that @xmath8 has to scd - deliver .",
    "the function @xmath269 returns the set of all the messages contained in @xmath270 .",
    "[ [ description - of - algorithmalgosc - broadcast - from - snapshot ] ] description of algorithm  [ algo : sc - broadcast - from - snapshot ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath8 invokes @xmath51 , it adds @xmath20 to @xmath271 $ ] and @xmath259 $ ] to inform all the processes on the scd - broadcast of @xmath20 .",
    "it then invokes the internal procedure @xmath272 from which it exits once it has a set containing @xmath20 ( line  [ nrw-01 ] ) .",
    "a background task @xmath273 ensures that all messages will be scd - delivered ( line  [ nrw-02 ] ) .",
    "this task invokes repeatedly the internal procedure @xmath272 . as , locally , both the application process and the underlying task @xmath273 can invoke @xmath272 , which accesses the local variables of @xmath8 , those variables are protected by a local fair mutual exclusion algorithm providing the operations @xmath274 and @xmath275 ( lines  [ nrw-03 ] and  [ nrw-11 ] ) .    the procedure @xmath272 first invokes the internal procedure @xmath276 , whose aim is to allow @xmath8 to scd - deliver sets of messages which have been scd - broadcast and not yet locally scd - delivered .    to this end , @xmath276 works as follows ( lines  [ nrw-12]-[nrw-17 ] ) .",
    "process @xmath8 first obtains a snapshot of @xmath267 , and saves it in @xmath266 ( line  [ nrw-12 ] ) .",
    "this allows @xmath8 to know which message sets have been scd - delivered by all the processes ; @xmath8 then enters a `` while '' loop to scd - deliver as many message sets as possible according to what was scd - delivered by the other processes . for each process",
    "@xmath23 that has scd - delivered a message set @xmath277 containing messages not yet scd - delivered by @xmath8 ( predicate of line  [ nrw-13 ] ) , @xmath8 builds a set @xmath278 containing the messages in @xmath277 that it has not yet scd - delivered ( line  [ nrw-14 ] ) , and locally scd - delivers it ( line  [ nrw-16 ] ) .",
    "this local scd - delivery needs to update accordingly both @xmath279 $ ] ( local update ) and @xmath262 $ ] ( global update ) .",
    "when it returns from @xmath276 , @xmath8 strives to scd - deliver messages not yet scd - delivered by the other processes . to this end",
    ", it first obtains a snapshot of @xmath265 , which it stores in @xmath264 ( line  [ nrw-05 ] ) .",
    "if there are messages that can be scd - delivered ( computation of @xmath278 at line  [ nrw-06 ] , and predicate at line  [ nrw-07 ] ) , @xmath8 scd - delivers them and updates @xmath279 $ ] and @xmath262 $ ] ( lines  [ nrw-07]-[nrw-09 ] ) accordingly .",
    "[ lemma - broadcast - validity-2 ] if a process scd - delivers a set containing a message @xmath20 , some process invoked @xmath51 .",
    "the proof follows directly from the text of the algorithm , which copies messages from @xmath265 to @xmath267 , without creating new messages .",
    "[ lemma - broadcast - integrity-2 ] no process scd - delivers the same message twice .",
    "let us first observe that , due to lines [ nrw-07 ] and  [ nrw-15 ] , all messages that are scd - delivered at a process @xmath8 have been added to @xmath279 $ ] .",
    "the proof then follows directly from ( a ) this observation , ( b ) the fact that ( due to the local mutual exclusion at each process ) @xmath279 $ ] is updated consistently , and ( c ) lines [ nrw-06 ] and  [ nrw-14 ] , which state that a message already scd - delivered ( i.e. , a message belonging to @xmath279 $ ] ) can not be added to @xmath278 .",
    "[ lemma - broadcast - termination1-a2 ] any invocation of @xmath49 by a non - faulty process @xmath8 terminates .",
    "the proof consists in showing that the internal procedure @xmath272 terminates . as the mutex algorithm is assumed to be fair , process @xmath8 can not block forever at line  [ nrw-03 ] .",
    "hence , @xmath8 invokes the internal procedure @xmath276 .",
    "it then issues first a snapshot invocation on @xmath267 and stores the value it obtains the value of @xmath266 .",
    "there is consequently a finite number of message sets in @xmath266 .",
    "hence , the `` while '' of lines  [ nrw-13]-[nrw-17 ] can be executed only a finite number of times , and it follows that any invocation of @xmath276 by a non - faulty process terminates .",
    "the same reasoning ( replacing @xmath267 by @xmath265 ) shows that process @xmath8 can not block forever when it executes the lines  [ nrw-05]-[nrw-10 ] of the procedure @xmath272 .",
    "[ lemma - broadcast - termination1-b2 ] if a non - faulty process scd - broadcasts a message @xmath20 , it scd - delivers a message set containing @xmath20 .",
    "let @xmath8 be a non - faulty process that scd - broadcasts a message @xmath20 . as it is non - faulty",
    ", @xmath8 adds @xmath20 to @xmath259 $ ] and then invokes @xmath272 ( line  [ nrw-01 ] ) . as @xmath280 , it is eventually added to @xmath268 if not yet scd - delivered ( line  [ nrw-06 ] ) , and scd - delivered at line  [ nrw-09 ] , which concludes the proof of the lemma .",
    "[ lemma - broadcast - termination2 - 2 ] if a non - faulty process scd - delivers a message @xmath20 , every non - faulty process scd - delivers a message set containing @xmath20 .",
    "let us assume that a process scd - delivers a message set containing a message @xmath20 .",
    "it follows that the process that invoked @xmath51 added @xmath20 to @xmath265 ( otherwise no process could scd - deliver @xmath20 ) .",
    "let @xmath8 be a correct process .",
    "it invokes @xmath272 infinitely often ( line  [ nrw-02 ] ) .",
    "hence , there is a first execution of @xmath272 such that @xmath281 contains @xmath20 ( line  [ nrw-05 ] ) .",
    "if then follows from line  [ nrw-06 ] that @xmath20 will be added to @xmath278 ( if not yet scd - delivered ) .",
    "if follows that @xmath8 will scd - deliver a set of messages containing @xmath20 at line  [ nrw-09 ] .",
    "[ lemma - broadcast - sc - ordering-2 ] let @xmath8 be a process that scd - delivers a set @xmath53 containing a message @xmath20 and later scd - delivers a set @xmath282 containing a message @xmath22 .",
    "no process @xmath23 scd - delivers first a set @xmath55 containing @xmath22 and later a set @xmath283 containing @xmath20 .",
    "let us consider two messages @xmath20 and @xmath22 .",
    "due to total order property on the operations on the snapshot object @xmath265 , it is possible to order the write operations of @xmath20 and @xmath22 into @xmath265 . without loss of generality ,",
    "let us assume that @xmath20 is added to @xmath265 before @xmath22 .",
    "we show that no process scd - delivers @xmath22 before @xmath20 .",
    "let us consider a process @xmath8 that scd - delivers the message @xmath22 .",
    "there are two cases .",
    "* @xmath8 scd - delivers the message @xmath22 at line  [ nrw-09 ] .",
    "hence , @xmath8 obtained @xmath22 from the snapshot object @xmath265 ( lines  [ nrw-05]-[nrw-06 ] ) .",
    "as @xmath20 was written in @xmath265 before @xmath22 , we conclude that @xmath265 contains @xmath20 .",
    "it then follows from line  [ nrw-06 ] that , if @xmath8 has not scd - delivered @xmath20 before ( i.e. , @xmath20 is not in @xmath279 $ ] ) , then @xmath8 scd - delivers it in the same set as @xmath22 .",
    "* @xmath8 scd - delivers the message @xmath22 at line  [ nrw-16 ] . due to the predicate used at line  [ nrw-13 ] to build a set of message to scd - deliver",
    ", this means that there is a process @xmath23 that has previously scd - delivered a set of messages containing @xmath22 .",
    "+ moreover , let us observe that the first time the message @xmath22 is copied from @xmath265 to some @xmath284 $ ] occurs at line  [ nrw-08 ] . as @xmath20 was written in @xmath265 before @xmath22 , the corresponding process @xmath285 can not see @xmath22 and not @xmath20 .",
    "it follows from the previous item that @xmath285 has scd - delivered @xmath20 in the same message set ( as the one including @xmath22 ) , or in a previous message set .",
    "it then follows from the predicate of line  [ nrw-13 ] that @xmath8 can not scd - delivers @xmath22 before @xmath20 .",
    "+ to summarize , the scd - deliveries of message sets in the procedure @xmath276 can not violate the ms - ordering property , which is established at lines  [ nrw-06]-[nrw-10 ] .    [ theorem : sc - broadcast - from - rw ] algorithm  _ [ algo : sc - broadcast - from - snapshot ] _ implements the _ scd - broadcast _ abstraction in the system model @xmath286 $ ] .",
    "the proof follows from lemma  [ lemma - broadcast - validity-2 ] ( validity ) , lemma  [ lemma - broadcast - integrity-2 ] ( integrity ) , lemmas  [ lemma - broadcast - termination1-a2 ] and  [ lemma - broadcast - termination1-b2 ] ( termination-1 ) , lemma  [ lemma - broadcast - termination2 - 2 ] ( termination-2 ) , and lemma  [ lemma - broadcast - sc - ordering-2 ] ( ms - ordering ) .",
    "this paper has introduced a new communication abstraction ( scd - broadcast ) providing processes with an abstraction level between reliable broadcast and total order broadcast ( which captures the necessary and sufficient constraint on message deliveries which allows consensus objects to be implemented in asynchronous crash - prone message - passing systems ) .",
    "more precisely , scd - broadcast captures the abstraction level which is `` necessary and sufficient '' to implement read / write registers and snapshot objects on top of asynchronous message - passing systems prone to process failures .",
    "`` sufficient '' means here that no other notion or object is needed to build a register or a snapshot object at the abstraction level provided by scd - broadcast , while `` necessary '' means that the objects that are built ( registers and snapshot objects ) are the weakest from a shared memory computational point of view .",
    "as announced in the introduction , an algorithm implementing scd - broadcast in an asynchronous message - passing system where any minority of processes may crash is described in appendix  [ sec : algo - for - sc ] .",
    "this algorithm requires @xmath18 protocol messages per invocation of @xmath49 .",
    "it follows that the scd - broadcast - based mwmr snapshot algorithm presented in the paper requires @xmath18 protocol messages per invocation of @xmath5 or @xmath4 operation .",
    "this is the best read / write snapshot algorithm we know in the context of asynchronous message - passing systems .",
    "this work has been partially supported by the franco - german dfg - anr project 40300781 discmat ( devoted to connections between mathematics and distributed computing ) , and the french anr project descartes ( devoted to layered and modular structures in distributed computing ) . the authors want to thank faith ellen for fruitful exchanges on shared memory snapshot .    99    afek y. , attiya h. , dolev d. , gafni e. , merritt m. and shavit n. , atomic snapshots of shared memory . _ journal of the acm _ , 40(4):873 - 890 ( 1993 )    ahamad m. , neiger g. , burns j.e .",
    ", hutto p.w . , and kohli p. causal memory : definitions , implementation and programming .",
    "_ distributed computing _ , 9:37 - 49 ( 1995 )    anderson j. , multi - writer composite registers .",
    "_ distributed computing _ , 7(4):175 - 195 ( 1994 )    attiya h. , efficient and robust sharing of memory in message - passing systems .",
    "_ journal of algorithms _",
    ", 34:109 - 127 ( 2000 )    attiya h. , bar - noy a. and dolev d. , sharing memory robustly in message passing systems .",
    "_ journal of the acm _ , 42(1):121 - 132 ( 1995 )    attiya h. and rachmann o. , atomic snapshots in @xmath287 operations .",
    "_ siam journal of computing _ , 27(2):319 - 340 ( 1998 )    attiya h. and welch j.l . , sequential consistency versus linearizability . _",
    "acm transactions on computer systems _",
    ", 12(2):91 - 12 ( 1994 )    attiya h. and welch j.l .",
    ", _ distributed computing : fundamentals , simulations and advanced topics _ , ( 2d edition ) , wiley - interscience , 414 pages ( 2004 )    birman k. and joseph t. reliable communication in the presence of failures . _",
    "acm transactions on computer systems _ , 5(1):4776 ( 1987 )    chandra t. and toueg s. , unreliable failure detectors for reliable distributed systems .",
    "_ journal of the acm _",
    ", 43(2):225 - 267 ( 1996 )    delporte - gallet c. , fauconnier h. , rajsbaum s. , and raynal m. , implementing snapshot objects on top of crash - prone asynchronous message - passing systems .",
    "16th intl conference on algorithms and architectures for parallel processing ( ica3pp16 ) _ , springer lncs 10048 , pp .",
    "341355 ( 2016 )    dutta p. , guerraoui r. , levy r. , and vukolic m. , fast access to distributed atomic memory",
    ". _ siam journal of computing _ , 39(8):3752 - 3783 ( 2010 )    ellen f. , how hard is it to take a snapshot ? _ proc .",
    "31th conference on current trends in theory and practice of computer science ( sofsem05 ) _ , springer 3381 , pp .",
    "27 - 35 ( 2005 )    ellen f. , fatourou p. , and ruppert e. , time lower bounds for implementations of multi - writer snapshots .",
    "_ journal of the acm _ , 54(6 ) , 30 pages ( 2007 )    fischer m.j . , lynch n.a . and paterson m.s .",
    ", impossibility of distributed consensus with one faulty process . _ journal of the acm _ , 32(2):374 - 382 ( 1985 )    fischer m.j . and",
    "merritt m. , appraising two decades of distributed computing theory research .",
    "_ distributed computing _ , 16(2 - 3):239 - 247 ( 2003 )    hadjistasi th . , nicolaou n. , and schwarzmann a.a .",
    ", oh - ram ! one and a half round read / write atomic memory . _",
    "brief announcement .",
    "35th acm symposium on principles of distributed computing ( podc16 ) _ , acm press , pp .",
    "353 - 355 ( 2016 )    herlihy m. p. and wing j. m. , linearizability : a correctness condition for concurrent objects .",
    "_ acm transactions on programming languages and systems _ , 12(3):463 - 492 ( 1990 )    imbs d. and raynal m. , help when needed , but no more : efficient read / write partial snapshot . _",
    "journal of parallel and distributed computing _ , 72(1):1 - 12 ( 2012 )    inoue i. , chen w. , masuzawa t. and tokura n. , linear time snapshots using multi - writer multi - reader registers . _",
    "8th intl workshop on distributed algorithms ( wdag94 ) _ , springer lncs 857 , pp",
    ".  130 - 140 ( 1994 )    jayanti p. , an optimal multiwriter snapshot algorithm .",
    "37th acm symposium on theory of computing ( stoc05 ) _ , acm press , pp .",
    "723 - 732 ( 2005 )    jimnez e. , fernndez a. , and cholvi v. , a parameterized algorithm that implements sequential , causal , and cache memory consistencies . _",
    "journal of systems and software _",
    ", 81(1):120 - 131 ( 2008 )    kramer s. n. , _ history begins at sumer : thirty - nine firsts in man s",
    "recorded history_. university of pennsylvania press , 416 pages , isbn 978 - 0 - 8122 - 1276 - 1 ( 1956 )    lamport l. , how to make a multiprocessor computer that correctly executes multiprocess programs .",
    "_ ieee transactions on computers _ , c28(9):690691 ( 1979 )    lamport l. , on interprocess communication , part i : basic formalism .",
    "_ distributed computing _ , 1(2):77 - 85 ( 1986 )    lynch n. a. , _ distributed algorithms_. morgan kaufmann pub . , san francisco ( ca ) , 872 pages , isbn 1 - 55860 - 384 - 4 ( 1996 )    misra j. , axioms for memory access in asynchronous hardware systems . _",
    "acm transactions on programming languages and systems _",
    ", 8(1):142 - 153 ( 1986 )    mostfaoui a. , ptrolia m. , raynal m. , and jard cl .",
    ", atomic read / write memory in signature - free byzantine asynchronous message - passing systems . _",
    "springer theory of computing systems _ ( 2017 ) doi : 10.1007/s00224 - 016 - 9699 - 8    mostfaoui a. and raynal m. , two - bit messages are sufficient to implement atomic read / write registers in crash - prone systems .",
    "35th acm symposium on principles of distributed computing ( podc16 ) _ , acm press , pp .",
    "381 - 390 ( 2016 )    perrin m. , mostfaoui a. , ptrolia m. , and jard cl .",
    ", on composition and implementation of sequential consistency",
    "30th intl symposium on distributed computing ( disc16 ) _ , springer lncs 9888 , pp .",
    "284 - 297 ( 2017 )    raynal m. , sequential consistency as lazy linearizability .",
    "_ brief announcement .",
    "14th acm symposium on parallel algorithms and architectures ( spaa02 ) _ , acm press , pp .",
    "151 - 152 , ( 2002 )    raynal m. , _ communication and agreement abstractions for fault - tolerant asynchronous distributed systems .",
    "morgan & claypool publishers , 251 pages , isbn 978 - 1 - 60845 - 293 - 4 ( 2010 )    raynal m. , _ distributed algorithms for message - passing systems_. springer , 510 pages , isbn 978 - 3 - 642 - 38122 - 5 ( 2013 )    raynal m. , _ concurrent programming : algorithms , principles and foundations_. springer , 515 pages , isbn 978 - 3 - 642 - 32026 - 2 ( 2013 )    raynal m. , schiper a. , and toueg s. , the causal ordering abstraction and a simple way to implement it . _",
    "information processing letters _ , 39:343 - 351 ( 1991 )    ruppert e. , implementing shared registers in asynchronous message - passing systems . _ springer encyclopedia of algorithms _ , pp .  400 - 403 ( 2008 )    turing a.m. , on computable numbers with an application to the entscheidungsproblem .",
    "_ proc . of the london mathematical society _",
    ", 42:230 - 265 ( 1936 )    vukolic m. , _ quorum systems , with applications to storage and consensus_. morgan & claypool publishers , 132 pages , isbn 978 - 1 - 60845 - 683 - 3 ( 2012 )",
    "this section shows that the scd - broadcast communication abstraction is not an oracle - like object which allows us to extend our understanding of computing , but can not be implemented .",
    "it describes an implementation of scd - broadcast in @xmath288 $ ] , which is the weakest assumption on process failures that allows a read / write register to be built on top of an asynchronous message - passing system  @xcite ( see footnote  [ footnote1 ] ) .    to simplify the presentation , and without loss of generality , we consider that the communication channels are fifo .",
    "the associated communication operations are denoted @xmath289 and @xmath290 .",
    "[ [ local - variables - at - a - process - p_i ] ] local variables at a process @xmath8 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each process @xmath8 manages the following local variables .",
    "* @xmath291 : buffer where are stored the messages not yet scd - delivered in a message set . *",
    "@xmath268 : next set of messages to be scd - delivered .",
    "* @xmath292 : local sequence number ( initialized to @xmath293 ) , which measures the local progress of @xmath8 . * @xmath294 $ ] : array of sequence numbers .",
    "$ ] is the greatest sequence number @xmath296 such that the application message identified by @xmath297 was in a message set scd - delivered by @xmath8 .",
    "[ [ operation - sf - scd_broadcast ] ] operation @xmath49 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when @xmath8 invokes @xmath51 , where @xmath20 is an application message , it sends the message @xmath298 to itself ( this simplifies the writing of the algorithm ) , and waits until it has no more message from itself pending in @xmath299 , which means it has scd - delivered a set containing @xmath20 .",
    "a protocol message @xmath117 ( line  [ scd - from - mp-01 ] ) is made up of five fields : the associated application message @xmath20 , and two pairs , each made up of a sequence number and a process identity .",
    "the first pair ( @xmath300 is the identity of the application message , while the second one @xmath301 is the local progress ( @xmath302 ) of the forwarder process @xmath303 when it forwards this protocol message .",
    "[ [ reception - of - msdmathitsn_sdfmathitsn_f ] ] reception of @xmath304 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a process @xmath8 receives such a protocol message , it first invokes @xmath305 to participate in the reliable broadcast of this message ( line  [ scd - from - mp-03 ] ) , and then invokes @xmath306 to see if a message set can be scd - delivered ( line  [ scd - from - mp-04 ] ) .    [ [ procedure - sf - forward ] ] procedure @xmath307 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this procedure can be seen as an enrichment ( with the fields @xmath308 and @xmath302 ) of the reliable broadcast implemented by the messages @xmath309 .",
    "considering such a message @xmath304 , @xmath20 was scd - broadcast by @xmath310 at its local time @xmath311 , and relayed by the forwarding process @xmath312 at its local time @xmath302 .",
    "if @xmath313 $ ] , @xmath8 has already scd - delivered a message set containing @xmath20 ( see lines  [ scd - from - mp-18 ] and [ scd - from - mp-20 ] ) .",
    "if @xmath314 $ ] , there are two cases .",
    "* the message @xmath20 is not in @xmath291 . in this case",
    ", @xmath8 creates a quadruplet @xmath315 , and adds it to @xmath291 ( lines  [ scd - from - mp-08]-[scd - from - mp-10 ] ) .",
    "this quadruplet @xmath316 is such that * * the field @xmath317 contains the application message @xmath20 , * * the field @xmath318 contains the i d of the sender of this application message , * * the field @xmath319 contains the local date associated with @xmath20 by its sender , * * the field @xmath320 is an array of size @xmath0 , such that @xmath321 $ ] = sequence number ( initially @xmath322 ) associated with @xmath20 by @xmath285 when it broadcast @xmath323 .",
    "this last field is crucial in the scd - delivery of a message set containing @xmath20 .",
    "+ after the quadruplet @xmath315 has been built , @xmath8 first adds it to @xmath291 ( line  [ scd - from - mp-10 ] ) , and invokes ( line  [ scd - from - mp-11 ] ) @xmath324  @xmath325 to implement the reliable broadcast of @xmath20 identified by @xmath326 . finally , @xmath8 records its progress by increasing @xmath292 ( line  [ scd - from - mp-12 ] ) .",
    "* there is a quadruplet @xmath315 in @xmath291 associated with @xmath20 , i.e. , @xmath327 ( predicate of line  [ scd - from - mp-06 ] ) . in this case , @xmath8 assigns @xmath302 to @xmath328 $ ] ( line  [ scd - from - mp-07 ] ) , thereby indicating that @xmath20 was known and forwarded by @xmath329 at its local time @xmath302 .",
    "[ [ procedure - sf - try_deliver ] ] procedure @xmath306 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when it executes @xmath306 , @xmath8 first computes the set @xmath268 of the quadruplets @xmath315 containing application messages @xmath20 which have been seen by a majority of processes ( line  [ scd - from - mp-15 ] ) . from @xmath8 s point of view , a message has been seen by a process @xmath329 if @xmath328 $ ] has been set to a finite value ( line  [ scd - from - mp-07 ] ) .",
    "if a majority of processes received first a message @xmath330 and later another message @xmath331 , it might be that some process @xmath23 scd - delivered a set containing @xmath22 before scd - delivering a set containing @xmath20 .",
    "therefore , @xmath8 must avoid scd - delivering a set containing @xmath20 before scd - delivering a set containing @xmath22 .",
    "this is done at line  [ scd - from - mp-16 ] , where @xmath8 withdraws the quadruplet @xmath315 corresponding to @xmath20 if it has not enough information to deliver @xmath22 ( i.e. the corresponding @xmath332 is not in @xmath278 ) or it does not have the proof that the situation can not happen , i.e. no majority of processes saw the message corresponding to @xmath315 before the message corresponding to @xmath332 .    if @xmath268 is not empty after it has been purged ( lines  [ scd - from - mp-16]-[scd - from - mp-17 ] ) , @xmath8 computes a message set to scd - deliver .",
    "this set @xmath19 contains all the application messages in the quadruplets of @xmath268 ( line  [ scd - from - mp-20 ] ) .",
    "these quadruplets are withdrawn from @xmath291 ( line  [ scd - from - mp-18 ] ) . moreover , before this scd - delivery , @xmath8 needs to updates @xmath333 $ ] for all the entries such that @xmath334 where @xmath335 ( line  [ scd - from - mp-18 ] ) .",
    "this update is needed to ensure that the future uses of the predicate of line  [ scd - from - mp-17 ] are correct .",
    "[ lemma - broadcast - validity ] if a process scd - delivers a set containing @xmath20 , some process invoked @xmath51 .",
    "if process @xmath8 scd - delivers a set containing a message @xmath20 , it has previously added into @xmath291 a quadruplet @xmath315 such that @xmath336 ( line [ scd - from - mp-10 ] ) , for which it has fifo - received at least @xmath337 @xmath331 messages .",
    "the first of these messages ever sent was sent after a process invoked @xmath51 .",
    "[ lemma - broadcast - integrity ] no process scd - delivers the same message twice .    after a message @xmath20 scd - broadcast by @xmath310 with a sequence number",
    "@xmath311 is scd - delivered by @xmath8 , @xmath338 \\ge { { \\mathit{sn_{sd}}}}$ ] thanks to line [ scd - from - mp-18 ] and there is no @xmath339 with @xmath340 and @xmath341 , as it was removed on line [ scd - from - mp-19 ] .",
    "thanks to line [ scd - from - mp-05 ] , no such @xmath332 will be added again in @xmath291 . as @xmath268 is defined as a subset of @xmath291 on line [ scd - from - mp-15 ] , @xmath20 will never be scd - delivered by @xmath8 again .",
    "[ lemma : broadcast ] if a message @xmath342 is broadcast by a non - faulty process @xmath8 , then each non - faulty process @xmath23 broadcasts a single message @xmath343 .",
    "first , we prove that @xmath23 broadcasts a message @xmath344 .",
    "as @xmath8 is non - faulty , @xmath23 will eventually receive the message sent by @xmath8 . at that time , if @xmath345 $ ] , after the condition on line  [ scd - from - mp-06 ] and whatever its result , @xmath299 contains a value @xmath315 with @xmath346 and @xmath347 . that @xmath315 was inserted at line  [ scd - from - mp-10 ] ( possibly after the reception of a different message ) , just before @xmath23 sent a message @xmath348 at line  [ scd - from - mp-11 ] .",
    "otherwise , @xmath349 $ ] was incremented on line  [ scd - from - mp-18 ] , when validating some @xmath332 added to @xmath350 after @xmath23 received a ( first ) message @xmath351)$ ] from @xmath312 . because the messages @xmath117 are fifo - broadcast ( hence they are delivered in their sending order ) , @xmath310 sent message @xmath352 before @xmath353 ,   sd , clock_j[sd])$ ] , and all other processes only forward messages , @xmath23 received a message @xmath354 from @xmath312 before the message @xmath353,-,-)$ ] . at that time ,",
    "@xmath345 $ ] , so the previous case applies .",
    "after @xmath23 broadcasts its message @xmath343 on line  [ scd - from - mp-11 ] , there is a @xmath355 with @xmath356 , until it is removed on line  [ scd - from - mp-16 ] and @xmath349 \\ge { { \\mathit{sn_{sd}}}}$ ] .",
    "therefore , one of the conditions at lines  [ scd - from - mp-05 ] and  [ scd - from - mp-06 ] will stay false for the stamp @xmath357 and @xmath23 will never execute line  [ scd - from - mp-11 ] with the same stamp @xmath358 later .",
    "[ lemma - broadcast - sc - ordering ] let @xmath8 be a process that scd - delivers a set @xmath53 containing a message @xmath20 and later scd - delivers a set @xmath282 containing a message @xmath22 .",
    "no process @xmath23 scd - delivers first a set @xmath55 containing @xmath22 and later a set @xmath283 containing @xmath20 .",
    "let us suppose there are two messages @xmath20 and @xmath22 and two processes @xmath8 and @xmath23 such that @xmath8 scd - delivers a set @xmath53 containing @xmath20 and later scd - delivers a set @xmath282 containing @xmath22 and @xmath23 scd - delivers a set @xmath55 containing @xmath22 and later scd - delivers a set @xmath283 containing @xmath20 .",
    "when @xmath20 is delivered by @xmath8 , there is an element @xmath359 such that @xmath360 and because of line [ scd - from - mp-15 ] , @xmath8 has received a message @xmath331 from more than @xmath337 processes .    *",
    "if there is no element @xmath361 such that @xmath362 , since @xmath22 has not been delivered by @xmath8 yet , @xmath8 has not received a message @xmath330 from any process ( lines [ scd - from - mp-10 ] and [ scd - from - mp-19 ] ) .",
    "therefore , because the communication channels are fifo , more than @xmath337 processes have sent a message @xmath331 before sending a message @xmath330 . * otherwise , @xmath363 after line  [ scd - from - mp-16 ] .",
    "as the communication channels are fifo , more than @xmath337 processes have sent a message @xmath331 before a message @xmath330 .    using the same reasoning",
    ", it follows that when @xmath22 is delivered by @xmath23 , more than @xmath337 processes have sent a message @xmath330 before sending a message @xmath331 .",
    "there exists a process @xmath364 in the intersection of the two majorities , that has both sent a message @xmath330 before sending @xmath331 and sent a message @xmath330 before sending @xmath331 .",
    "however , by lemma  [ lemma : broadcast ] , @xmath364 can only send one message @xmath330 and one message @xmath331 , which leads to a contradiction .",
    "( 0,0 ) node[left]@xmath8  ( 11,0 ) ; ( 0,1.5 ) node[left]@xmath312  ( 11,1.5 ) ;    ( 2.75,2.1 ) node@xmath365 ; ( 3.4,0.75 ) node[left]@xmath366 ; ( 10.2,0.75 ) node[right]@xmath367 ;    ( 2,1.2 ) rectangle ( 3.5,1.8 ) ; ( 2.1,1.5 ) node@xmath368 ; ( 2.3,1.5 ) to[out=0,in=120,distance=20 ] ( 3.8,0.1 ) ; ( 2.2,1.6 ) to[out=60,in=120,distance=5 ] ( 2.5,1.6 ) ;    ( 4.8,1.2 ) rectangle ( 7.5,1.8 ) ; ( 4.9,1.5 ) node@xmath368 ; ( 5,1.4 )  ( 6,0.1 ) ; ( 5,1.6 ) to[out=60,in=120,distance=5 ] ( 5.3,1.6 ) ;    ( 7.8,1.2 ) rectangle ( 9.5,1.8 ) ; ( 7.9,1.5 ) node@xmath368 ; ( 8,1.4 )  ( 9,0.1 ) ; ( 8,1.6 ) to[out=60,in=120,distance=5 ] ( 8.3,1.6 ) ;    ( 5.5,0.75 ) node[right]@xmath369 ; ( 8.5,0.75 ) node[right]@xmath370 ;    ( 4.8,-0.3 )  ( 5.8,-0.3 ) ; ( 5.9,-0.3 ) node@xmath371 ; ( 6.1,-0.3 )  ( 8.8,-0.3 ) ; ( 8.9,-0.3 ) node@xmath371 ; ( 8.8,-0.6 )  ( 4.8,-0.6 ) ; ( 4.7,-0.6 ) node@xmath371 ;    ( 1.5,-0.9 ) node[below]@xmath309 ; ( 4,-1.3 ) node[below]@xmath309 ; ( 1.5,-0.9 )  ( 1.8,-0.1 ) ; ( 4,-1.3 )  ( 4.2,1.4 ) ; ( 4.3,1.4 )  ( 4.7,0.1 ) ; ( 4.3,1.6 ) to[out=60,in=120,distance=5 ] ( 4.6,1.6 ) ;    ( 7.1,2.5 ) node[above]@xmath372 ; ( 7.0,2.5 )  ( 7.2,1.55 ) ; ( 7.1,2.5 )  ( 7.3,1.55 ) ; ( 7.2,2.5 )  ( 7.4,1.55 ) ; ( 7.2,1.45 )  ( 7.4,0.05 ) ; ( 7.3,1.45 )  ( 7.5,0.05 ) ; ( 7.4,1.45 )  ( 7.6,0.05 ) ;    [ lemma : liveness ] if a message @xmath342 is fifo - broadcast by a non - faulty process @xmath8 , this process scd - delivers a set containing @xmath20 .",
    "let @xmath8 be a non - faulty process .",
    "for any pair of messages @xmath315 and @xmath332 ever inserted in @xmath291 , let @xmath373 and @xmath374 .",
    "let @xmath375 be the dependency relation defined as follows : @xmath376 < msg.cl[j ]    \\}| \\le \\frac{n}{2}$ ] ( i.e. the dependency does not exist if @xmath8 knows that a majority of processes have seen the first update due to @xmath332 before the second due to @xmath315 ) .",
    "let @xmath377 denote the transitive closure of @xmath375 .",
    "let us suppose ( by contradiction ) that the timestamp @xmath378 associated with the message @xmath20 ( carried by the protocol message @xmath342 fifo - broadcast by @xmath8 ) , has an infinity of predecessors according to @xmath377 .",
    "as the number of processes is finite , an infinity of these predecessors have been generated by the same process , let us say @xmath312 .",
    "let @xmath379 be the infinite sequence of the timestamps associated with the invocations of the @xmath49 issued by @xmath312 .",
    "the situation is depicted by figure  [ fig : lemma : liveness ] .",
    "as @xmath8 is non - faulty , @xmath312 eventually receives a message @xmath380 , which means @xmath312 broadcast an infinity of messages @xmath381 after @xmath382 .",
    "let @xmath383 and @xmath384 be the timestamps associated with the next two messages sent by @xmath312 , with @xmath385 . by hypothesis , we have @xmath386 . moreover , all processes received their first message @xmath387 before their first message @xmath388 , so @xmath389 .",
    "let us express the path @xmath390 : + @xmath391 .    in the time interval starting when @xmath312 sent the message @xmath392 and finishing when it sent the the message @xmath393 , the waiting condition of line  [ scd - from - mp-02 ] became true ,",
    "so @xmath312 scd - delivered a set containing the message @xmath394 , and according to lemma  [ lemma - broadcast - validity ] , no set containing the message @xmath395 .",
    "therefore , there is an index @xmath396 such that process @xmath312 delivered sets containing messages associated with a timestamp @xmath397 for all @xmath398 but not for @xmath399 .",
    "because the channels are fifo and thanks to lines  [ scd - from - mp-15 ] and  [ scd - from - mp-16 ] , it means that a majority of processes have sent a message @xmath400 before a message @xmath401 , which contradicts the fact that @xmath402 .",
    "let us suppose a non - faulty process @xmath8 has fifo - broadcast a message @xmath342 ( line  [ scd - from - mp-10 ] ) .",
    "it inserted a quadruplet @xmath315 with timestamp @xmath358 on line  [ scd - from - mp-09 ] and by what precedes , @xmath358 has a finite number of predecessors @xmath403 according to @xmath377 . as @xmath8 is non - faulty , according to lemma  [ lemma : broadcast ] , it eventually receives a message @xmath404 for all @xmath405 and from all non - faulty processes , which are in majority .",
    "let @xmath406 be the set of all quadruplets @xmath332 such that @xmath407 .",
    "let us consider the moment when @xmath8 receives the last message @xmath408 sent by a correct process @xmath312 .",
    "for all @xmath409 , either @xmath410 has already been delivered or @xmath332 is inserted @xmath278 on line  [ scd - from - mp-15 ] .",
    "moreover , no @xmath409 will be removed from @xmath278 , on line  [ scd - from - mp-16 ] , as the removal condition is the same as the definition of @xmath375 . in particular for @xmath411 , either @xmath20 has already been scd - delivered or @xmath20 is present in @xmath278 on line  [ scd - from - mp-17 ] and will be scd - delivered on line  [ scd - from - mp-20 ] .",
    "[ lemma - broadcast - termination1 ] if a non - faulty process scd - broadcasts a message @xmath20 , it scd - delivers a message set containing @xmath20 .",
    "if a non - faulty process scd - broadcasts a message @xmath20 , it sends a message @xmath412 on line  [ scd - from - mp-11 ] , so it scd - delivers a message set containing @xmath20 by lemma  [ lemma : liveness ] .",
    "[ lemma - broadcast - termination2 ] if a non - faulty process scd - delivers a message @xmath20 , every non - faulty process scd - delivers a message set containing @xmath20 .",
    "suppose a non - faulty process @xmath8 scd - delivers a message @xmath20 .",
    "at line  [ scd - from - mp-20 ] , there is @xmath413 such that @xmath360 . at line  [",
    "scd - from - mp-15 ] , @xmath339 , and @xmath315 was inserted in @xmath299 at line  [ scd - from - mp-10 ] , just before @xmath8 sent message @xmath342 . by lemma  [ lemma :",
    "broadcast ] , every non - faulty process @xmath23 sends a message @xmath343 , so by lemma  [ lemma : liveness ] , @xmath23 scd - delivers a message set containing @xmath20 .",
    "[ theorem : scd ] algorithm  _ [ algo : sc - broadcast - in - rw ] _ implements the _ scd - broadcast _ communication abstraction in @xmath288 $ ] .",
    "moreover , it requires @xmath18 messages per invocation of @xmath49 .",
    "the proof follows from lemma  [ lemma - broadcast - validity ] ( validity ) , lemma  [ lemma - broadcast - integrity ] ( integrity ) , lemma  [ lemma - broadcast - sc - ordering ] ( ms - ordering ) , lemma  [ lemma - broadcast - termination1 ] ( termination-1 ) , and lemma  [ lemma - broadcast - termination2 ] ( termination-2 ) .",
    "the @xmath18 message complexity comes from the fact that , due to the predicates of line  [ scd - from - mp-05 ] and  [ scd - from - mp-06 ] , each application message @xmath20 is forwarded at most once by each process ( line  [ scd - from - mp-11 ] ) .",
    "the next corollary follows from ( i ) theorems  [ theorem : proof - snapshot ] and  [ theorem : scd ] , and ( ii ) the fact that the constraint @xmath47 is an upper bound on the number of faulty processes to build a read / write register ( or snapshot object )  @xcite .",
    "[ coro : sc - optimal ] algorithm  _ [ algo : sc - broadcast - in - rw ] _ is resiliency optimal .",
    "this appendix shows the genericity dimension of algorithm  [ algo : snapshot - from - scd ] .",
    "it presents trivial simplifications of it , which build mwmr atomic registers and mwmr sequentially consistent registers .",
    "let @xmath26 denote the mwmr atomic read / write register that is built .",
    "the algorithm that builds it is a trivial simplification of the snapshot algorithm  [ algo : snapshot - from - scd ] , namely its projection on a single mwmr atomic register .",
    "@xmath26 is now locally represented by a local variable @xmath414 and the associated timestamp @xmath415 initialized to @xmath101 .",
    "the message sent at line  [ snap - from - sc-09 ] is now @xmath416 , and the predicate of line  [ snap - from - sc-11 ] simplifies to `` there are messages ( ) ) '' .",
    "the proof is a simplified version of the proof of theorem  [ theorem : proof - snapshot ] . for self - completeness , we give here its full proof even if some parts of it are `` cut - and - paste '' of parts of proofs given in section  [ sec : proof - snapshot ] . as in that section ,",
    "let us associate a timestamp @xmath417 with each operation @xmath181 as follows ( this is the place where the proof is simplified with respect to a snapshot object ) .",
    "* case @xmath418 .",
    "let @xmath8 be the invoking process ; @xmath417 is the timestamp of @xmath9 as defined by @xmath8 at line  [ snap - from - sc-09 ] , i.e. , @xmath419",
    ". * case @xmath420 .",
    "let @xmath421 be the value returned by the read ; @xmath417 is then the timestamp associated with @xmath421 at line  [ snap - from - sc-15 ] by its writer .",
    "let @xmath152 and @xmath153 be any two operations .",
    "the relation @xmath154 on the whole set of operations is defined as follows : @xmath155 if @xmath152 terminated before @xmath153 started .",
    "it is easy to see that @xmath154 is a real - time - compliant partial order on all the operations .",
    "the reader can easily check that the statement and the proof of lemma  [ lemma : snapshot - liveness ] ( applied to the termination of read and write operations ) , and lemma  [ lemma : snapshot - write - ordering ] ( applied to the total order on the write operations , compliant with both the sequential specification of a register , and their real - time occurrence order ) remain valid for the algorithm suited to an mwmr atomic read / write register .",
    "the next lemma addresses the read operations ( which are simpler to manage than snapshot operations ) .",
    "let @xmath240 be a read operation whose timestamp is @xmath422 .",
    "this operation is inserted just after the write operation @xmath423 that has the same timestamp ( this write wrote the value read by @xmath240 ) .",
    "let us remark that , as @xmath240 obtained the value timestamped @xmath422 , it did not terminate before @xmath423 started .",
    "it follows that the insertion of @xmath240 into the total order can not violate the real - time order between @xmath423 and @xmath240 .",
    "let us consider the operation @xmath424 that follows @xmath423 in the write total order . if @xmath425 , the placement of @xmath240 in the total order is real - time - compliant . if @xmath426 , due to the timestamp obtained by @xmath240 , we can not have @xmath427 .",
    "it follows that in this case also , the placement of @xmath240 in the total order is real - time - compliant .    finally , let us consider two read operations @xmath240 and @xmath428 which have the same timestamp @xmath429 ( hence , they read from the same write operation , say @xmath423 ) .",
    "both are inserted after @xmath423 in the order of their invocations ( if @xmath240 and @xmath428 started simultaneously , they are inserted according to the order on the identities of the processes that invoked them ) .",
    "hence , the read and write operations are linearizable , which concludes the proof of the lemma .",
    "when the register @xmath26 can be written by a single process ( say @xmath364 ) , the algorithm simplifies .",
    "the timestamps disappear at all processes , and as only the writer @xmath364 can invoke @xmath430 , it manages a simple date @xmath431 ( which is actually a sequence number ) .",
    "the modifications are :    * line  [ snap - from - sc-09 ] becomes : @xmath432 ; @xmath110 @xmath433 . * the lines  [ snap - from - sc-11]-[snap - from - sc-17 ] become : + aaaaaaaaaaaaaaaaaaaaaaaaa= + = ( there are messages ( ) ) + * let * @xmath434 be the maximal date in the messages ( ) received ; + @xmath435 the value associated with @xmath434 + .",
    "as indicated in the introduction , sequential consistency was introduced in  @xcite .",
    "it is atomicity minus the requirement stating that `` if an operation @xmath30 terminates before an operation @xmath31 starts , then @xmath30 must appear before @xmath31 in the sequence of the read and write operations '' .",
    "as noticed in  @xcite , sequential consistency can be seen as a weakened form of atomicity , namely lazy linearizability .",
    "the composition of sequentially consistent registers is investigated in  @xcite .",
    "the algorithm for sequential consistency presented in  @xcite and algorithm [ algo : sc - broadcast - in - rw ] are based on similar principles .",
    "the constraint @xmath47 is also a necessary and sufficient condition to implement a sequentially consistent read / write register in @xmath44 $ ] .",
    "the reader can check that an algorithm building a a sequentially consistent mwmr read / write register can easily be obtained from algorithm  [ algo : snapshot - from - scd ] as simplified in section  [ sec : swmr - rw ] .",
    "one only needs to suppress the synchronization messages ( ) which ensure the compliance with respect to real - time .",
    "the concerned lines are lines  [ snap - from - sc-01]-[snap - from - sc-03 ] ( read synchronization ) , and lines  [ snap - from - sc-05]-[snap - from - sc-07 ] ( write synchronization ) . in a simple way , this shows the versatility dimension of algorithm  [ algo : snapshot - from - scd ] .      given a sequentially consistent snapshot object , algorithm  [ algo : sc - broadcast - from - snapshot ] builds the scd - broadcast communication abstration .",
    "( as the reader can check , this follows from the fact that , when looking at its proof , this algorithm relies only on the fact that the operations on the snapshot object can be totally ordered . ) hence , using on top of it the scd - broadcast - based algorithm  [ algo : snapshot - from - scd ] , we obtain an atomic snapshot object .",
    "it follows that , thanks to scd - broadcast , the algorithms presented in the paper allow a sequentially consistent snapshot object to be transformed into an atomic snapshot object ( and it is known that differently from sequential consistent objects atomic objects are composable for free  @xcite ) ."
  ],
  "abstract_text": [
    "<S> `` yet another paper on '' the implementation of read / write registers in crash - prone asynchronous message - passing systems ! </S>",
    "<S> yes ... </S>",
    "<S> , but , differently from its predecessors , this paper looks for a communication abstraction which captures the essence of such an implementation in the same sense that total order broadcast can be associated with consensus , or message causal delivery can be associated with causal read / write registers . to this end </S>",
    "<S> , the paper introduces a new communication abstraction , named scd - broadcast ( scd  standing for `` set constrained delivery '' ) , which , instead of a single message , delivers to processes sets of messages ( whose size can be arbitrary ) , such that the sequences of message sets delivered to any two processes satisfies some constraints . </S>",
    "<S> the paper then shows that : ( a ) scd - broadcast allows for a very simple implementation of a snapshot object ( and consequently also of atomic read / write registers ) in crash - prone asynchronous message - passing systems ; ( b ) scd - broadcast can be built from snapshot objects ( hence scd - broadcast and snapshot objects or read / write registers are `` computationally equivalent '' ) ; ( c ) scd - broadcast can be built in message - passing systems where any minority of processes may crash ( which is the weakest assumption on the number of possible process crashes needed to implement a read / write register ) .     +   + * </S>",
    "<S> keywords * : asynchronous system , atomicity , communication abstraction , linearizability , message - passing system , process crash , read / write atomic register , snapshot object . </S>"
  ]
}