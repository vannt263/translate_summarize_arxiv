{
  "article_text": [
    "in many practical applications a number of centrally controlled objects need to be moved in a given environment in order to complete some task .",
    "problems of this kind often occur in robot motion planning where we seek to move a set of robots from their starting position to a set of ending positions such that a certain property is satisfied .",
    "for example , if the robots are equipped with a short range communication device we might want to move them so that a message originating from one of the robots can be routed to all the others . if the robots goal is to monitor a certain area we might want to move them so that they are not too close to each other .",
    "other interesting problems include gathering ( placing robots next to each other ) , monitoring of traffic between two locations , building interference - free networks , and so on . to make things harder , objects to be moved are often equipped with a limited supply of energy . preserving energy is a critical problem in ad - hoc networking , and movements are expensive . to prolong the lifetime of the objects we seek to minimize the energy consumed during movements and thus the distance travelled . sometimes , instead , movements are cheap but before and/or after an object moves it needs to perform expensive operations . in this scenario",
    "we might be interested in moving the minimum number of objects needed to reach the goal .    in this paper , we assume the underlying environment is actually a _ network _ , which can be modelled as an undirected graph @xmath0 , and the moving objects are centrally controlled _ pebbles _ that are initially placed on vertices of @xmath0 , and that can be moved to other vertices by traversing the graph edges . to this respect ,",
    "we study several movement planning problems that arise by various combinations of final positioning goals and movement optimization measures .",
    "in particular , we focus our study on the scenarios where we want the pebbles to be moved to a _ connected subgraph _ ( @xmath1 ) , an _",
    "independent set _",
    "( @xmath2 ) , or a _ clique _ ( @xmath3 ) of @xmath0 , while minimizing either the _ overall movement _ ( @xmath4 ) , the _ maximum movement _ ( @xmath5 ) , or the _ number of moved pebbles _ ( @xmath6 ) .",
    "we also give some preliminary results on the problem of moving the pebbles to an _ s - t - cut _",
    ", i.e. , a set of vertices whose removal makes two given vertices @xmath7 disconnected ( @xmath8 ) while minimizing the above measures .",
    "we will denote each of the above problems with @xmath9-@xmath10 , where @xmath9 represents the goal to be achieved and @xmath10 the measure to be minimized . for a more rigorous definition of the problems we refer the reader to section [ sec : formal_definition ] .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    although movement problems were deeply investigated in a distributed setting ( see @xcite for a survey ) , quite surprisingly the centralized counterpart has received attention from the scientific community only in the last few years .    the first paper which defines and studies these problems in this latter setting is @xcite . in their work ,",
    "the authors study the problem of moving the pebbles on a graph @xmath0 of @xmath11 vertices so that their final positions form a _ connected component _",
    ", a _ path _ ( directed or undirected ) _ between two specified nodes _ , an _",
    "independent set _ , or a _ matching _ ( two pebbles are matched together if their distance is exactly @xmath12 ) .    regarding connectivity problems , in @xcite",
    "the authors show that all the variants are hard and that the approximation ratio of @xmath13-@xmath14 is between @xmath15 and @xmath16 , where @xmath17 is the number of pebbles and @xmath18 denotes the measure of an optimal solution .",
    "this result has been improved in @xcite , where the authors show that @xmath13-@xmath14 can be approximated within a constant factor . in @xcite",
    "it is also shown that @xmath13-@xmath19 and @xmath13-@xmath20 are not approximable within @xmath21 ( for any positive @xmath22 ) and @xmath23 , respectively , while they admit approximation algorithms with ratios of @xmath24 and @xmath25 , respectively . moreover",
    ", the authors also provide an exact polynomial - time algorithm for @xmath13-@xmath14 on trees .",
    "concerning independency problems , in @xcite the authors remark that it is @xmath26-hard even to find any feasible solution on general graphs since it would require to find an independent set of size at least @xmath17 .",
    "this clearly holds for all three objective functions . for this reason",
    ", they study an euclidean variant of these problems where pebbles have to be moved on a plane so that their pairwise distances are strictly greater than @xmath12 . in this case , the authors provide an approximation algorithm that guarantees an additive error of at most @xmath27 for @xmath28-@xmath14 , and a polynomial time approximation scheme for @xmath28-@xmath20 .",
    "more recently , in @xcite , a variant of the classical facility location problem has been studied .",
    "this variant , called _ mobile facility location _",
    ", can be modelled as a movement problem and is approximable within @xmath29 ( for any constant @xmath30 ) if we seek to minimize the total movement @xcite , while the variant where the maximum movement has to be minimized admits a tight @xmath15-approximation @xcite .",
    "moreover , as it is frequent in the practice to have a small number of pebbles compared to the size of the environment ( i.e. , the vertices of the graph ) , the authors of  @xcite turn to study fixed - parameter tractability .",
    "they show a relation between the complexity of the problems and their _ minimal configurations _ ( sets of final positions of the pebbles that correspond to feasible solutions , such that any removal of an edge makes them unacceptable ) .",
    "finally , we mention that in @xcite it was considered a set of vertex - to - vertex motion planning problems in a simple polygon , with the aim of forming final configurations enjoying some sort of _ visual connectivity _ among the pebbles .",
    "[ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + +    we start by studying connectivity motions problems in the case where pebbles move on a tree , and we devise two polynomial - time dynamic programming algorithms for @xmath13-@xmath19 and @xmath13-@xmath20 .",
    "these algorithms complement the already known polynomial - time algorithm for @xmath13-@xmath14 on trees shown in @xcite .",
    "then , we study independency motion problems on graphs where a _ maximum independent set _ ( and thus a feasible solution for the corresponding motion problem ) can be computed in polynomial time .",
    "this class of graphs includes , for example , perfect and claw - free graphs .",
    "more precisely , we show that @xmath28-@xmath14 and @xmath28-@xmath19 are @xmath26-hard even on bipartite graphs ( which are known to be perfect graphs @xcite ) .",
    "moreover , we devise three exact polynomial - time algorithms : one for solving @xmath28-@xmath14 on paths , and the other two for solving @xmath28-@xmath19 and @xmath28-@xmath20 on trees , respectively .",
    "moreover , we devise a polynomial - time approximation algorithm for @xmath28-@xmath14 which is optimal unless an additive term of @xmath12 ( this is clearly tight ) .",
    "concerning the problem of moving pebbles towards a clique of a general graph , we prove that all the three variants are @xmath26-hard .",
    "then , we provide an approximation algorithm for @xmath31-@xmath14 which is optimal unless an additive term of @xmath12 ( this result is clearly tight ) .",
    "moreover , we show that both @xmath31-@xmath19 and @xmath31-@xmath20 are approximable within a factor of @xmath15 , but they are not approximable within a factor better than @xmath32 , unless @xmath33 . if the _",
    "unique game conjecture _ @xcite is true , then both problems are not approximable within a factor better than @xmath15 and the provided approximation algorithms are tight .",
    "these results are obtained by showing a non - trivial relation with the _ minimum vertex cover _ problem .",
    "we also show that an exact solution for @xmath31-@xmath20 can be computed in polynomial time on every class of graphs for which finding a _ maximum - weight clique _ requires polynomial time ( these classes of graphs also include perfect and claw - free graphs ) .",
    "finally , we present a strong inapproximability results of @xmath34 ( for any @xmath30 ) for @xmath35-@xmath14 and @xmath35-@xmath19 , unless @xmath33 , along with two approximation algorithms .",
    "the approximation algorithm for @xmath35-@xmath14 is essentially tight , while we show that any constant - factor approximation for @xmath35-@xmath20 would imply a tight approximation for @xmath35-@xmath19 .",
    "the paper is organized as follows : in section  [ sec : formal_definition ] we provide a formal definition of our problems , while in sections  [ sec : con][sec : stcut ] we give our results for @xmath1 , @xmath2 , @xmath3 , and @xmath8 , respectively ( for a summary of the state of the art of the studied problems , along with the results presented in this paper , see table [ table : results ] ) .",
    "finally , section  [ sec : concl ] concludes the paper .",
    "@xmath19 & @xmath20 + @xmath13 &",
    "g : @xmath36 @xcite t : polynomial @xcite & g : @xmath37 @xcite @xmath38 @xcite * t : polynomial * & g : @xmath39 @xcite @xmath40 @xcite * t : polynomial * + @xmath28 & g : @xmath26-hard @xcite * is : * @xmath41 * * , * * @xmath42",
    "* b : * @xmath43 * p : polynomial * & g : @xmath26-hard @xcite * b : @xmath26-hard * * t : polynomial * & g : @xmath26-hard @xcite * t : polynomial * + @xmath31 & * g : @xmath26-hard * & * g : * @xmath44 & * g : * @xmath44 * mwc : polynomial * + @xmath35 & * g : * @xmath37 & * g : * @xmath37 & * g : * * @xmath45-apx @xmath46-apx for @xmath35-@xmath19 * +     +   + [ table : results ]",
    "a pebble motion problem , denoted by @xmath9-@xmath10 , is an optimization problem whose instances consist of a loop - free connected undirected graph @xmath47 on @xmath11 nodes , a set @xmath48=\\{1,\\dots , k\\}$ ] of _ pebbles _ , a function @xmath49 that assigns each pebble to a _",
    "start vertex _ of @xmath0 , and a boolean predicate @xmath50 that assigns a truth value to every possible subset of vertices of @xmath0 .",
    "a ( feasible ) solution is a function @xmath51 that maps each pebble to an _ end vertex _ of @xmath0 ( in other words , _ moves _ a pebble from its start to its end position ) such that @xmath52)$ ] is true , where @xmath53 $ ] denotes the image of @xmath54 under @xmath55 .",
    "notice that , in general , it is not required for @xmath56 or @xmath55 to be injective and thus we allow more than one pebble to be placed on the same vertex . in the rest of the paper , we will assume that a pebble moving from a vertex @xmath57 to a vertex @xmath58 always uses a _",
    "shortest path _ in @xmath0 between @xmath57 and @xmath58 , say @xmath59 .",
    "moreover we denote by @xmath60 the length of such a path . finally , @xmath61 is a measure function that assigns a non - negative integer to each feasible solution ( i.e. , to each set of moves ) .",
    "a solution @xmath62 that minimizes @xmath10 is said to be _",
    "optimal_.    in the following , we will study some of the movement problems that arise from the different choices of predicates and measures .",
    "in particular , we will consider the following predicates :    _ connectivity : _ : :    @xmath63 is true if and only if    the subgraph of @xmath0 induced by the set of vertices    @xmath64 is connected ; _ independency : _ : :    @xmath65 is true if and only if    @xmath64 is an independent set of    @xmath0 of size @xmath17 , i.e. , there is at most one    pebble per vertex and no two pebbles are on adjacent vertices ; _ clique : _ : :    @xmath66 is true if and only if    @xmath67 induces a clique in @xmath0 ,    i.e. , for each pair @xmath68 of distinct vertices in    @xmath69 there exists the edge @xmath70 ; _ @xmath71-@xmath72-cut : _ : :    given @xmath73 with @xmath74 , then    @xmath75 is true    if and only if @xmath76 , @xmath77    and @xmath67 is an _",
    "s - t_-cut ( i.e. , there    exists no path between @xmath71 and @xmath72 in the    graph induced by the vertices in @xmath78 ) ;    and the following measures :    _ overall movement : _ : :    the sum of the distances travelled by pebbles has to be minimized :    every pebble @xmath79 moves from its starting vertex    @xmath80 to his end vertex @xmath81 , so the    overall distance is    @xmath82 ; _ maximum movement : _ : :    we want to minimize the maximum distance travelled by a pebble , i.e. ,    the measure    @xmath83 ; _ number of moved pebbles : _ : :    we aim to minimize the number of pebbles that need to be moved from    their starting positions . the associated measure is    @xmath84 .",
    "in this section we describe two polynomial - time algorithms for solving on trees @xmath13-@xmath19 and @xmath13-@xmath20 , respectively . in this way we complement the result provided in @xcite for @xmath13-@xmath14 on trees .",
    "our dynamic - programming algorithm relies on the following property of optimal solutions :    [ lemma : sum_tree_no_crossing ] in any optimal solution @xmath62 for an instance of @xmath13-@xmath19 on trees , there exists no edge that is traversed in opposite directions by pebbles .",
    "let @xmath59 denote a shortest path in @xmath0 between the vertices @xmath57 and @xmath58 .",
    "suppose by contradiction that there exists an optimal solution @xmath62 , an edge @xmath85 , and two pebbles @xmath86 such that @xmath87 moves through the path @xmath88 and @xmath89 moves through the path @xmath90 .",
    "consider the solution @xmath91 obtained from @xmath62 by swapping the final positions for @xmath87 and @xmath89 , i.e. , @xmath92 and @xmath93 .",
    "clearly @xmath94=\\mu^*[p]$ ] , therefore @xmath91 is feasible .",
    "moreover @xmath95 as we can move @xmath87 through the path @xmath96 and @xmath89 through the path @xmath97 , thus saving @xmath15 .",
    "the algorithm first guesses a vertex @xmath98 such that there exists an optimal solution that places a pebble on @xmath99 , then roots the tree @xmath0 at @xmath99 to obtain a rooted tree @xmath100 , and finally considers all the subtrees of @xmath100 in a bottom - up fashion .    for",
    "a given subtree @xmath101 of @xmath100 rooted at the vertex @xmath57 , let us denote by @xmath102 the number of pebbles placed on @xmath103 w.r.t .",
    "@xmath56 . when the subtree @xmath101 is examined , we consider an auxiliary problem . in this problem",
    "we want to place exactly @xmath104 of the pebbles on the vertices of @xmath101 in order to satisfy the following properties :    1 .",
    "[ it : con_p1 ] the subgraph of @xmath101 induced by the final positions of the pebbles must be connected ; 2 .",
    "[ it : con_p2 ] if @xmath105 then at least one pebble must be placed on @xmath57 .",
    "moreover , if @xmath106 we want to move the @xmath107 exceeding pebbles to the parent of @xmath57 ( and thus outside @xmath101 ) . in a similar manner ,",
    "if @xmath108 then the @xmath109 missing pebbles are to be moved into @xmath101 from the parent of @xmath57 , where we assume they are initially placed .",
    "we point out that , by lemma [ lemma : sum_tree_no_crossing ] , we do not need to consider the case where some pebbles move into @xmath101 while others move out of @xmath101 .    -@xmath19 and its optimal solution . a single pebble is placed on each black vertex while the optimal movements are denoted by arrows .",
    "right : the auxiliary problems corresponding to the optimal solution which are considered by the dynamic - programming algorithm . ]",
    "we will denote by @xmath110 $ ] the cost of the optimal movement for this auxiliary problem .",
    "notice that , in @xmath110 $ ] , we are accounting for the cost of traversing all the edges of @xmath101 plus the edge from @xmath57 to its parent . to solve the original problem we need to find a solution corresponding to @xmath111 $ ] . clearly as @xmath112",
    "we do not have exceeding or missing pebbles , in this case .",
    "we now show how to combine these auxiliary problems .    if @xmath57 is a leaf of @xmath100 then @xmath110=|\\eta(u ) - j|$ ] . otherwise ,",
    "if @xmath57 is not a leaf , we can distinguish two cases : @xmath113 and @xmath114 .",
    "if @xmath113 then no pebble can be placed on @xmath57 or in any descendant of @xmath57 , therefore all the pebbles must first be moved towards @xmath57 and then to the parent of @xmath57 .",
    "let @xmath115 be the set of children of @xmath57 in @xmath100 , we have : @xmath116 = \\eta(u ) + \\sum_{i=1}^\\ell { \\ensuremath{\\texttt{opt}}}[v_i , 0]$ ] .    otherwise ,",
    "if @xmath114 , we can move any number of pebbles between @xmath12 and @xmath117 to @xmath57 , and place the remaining pebbles on the subtrees rooted at the children of @xmath57 .",
    "therefore we have : @xmath118 = |\\eta(u)-j| + \\min _ { \\substack{0 \\le j_1 , \\dots , j_\\ell <",
    "j \\\\ \\sum_{i=1}^{\\ell } j_i < j } } \\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}[v_i , j_i ] \\right\\ } \\mbox{.}\\ ] ]    notice that the minimum considers all the possible ways for distributing less than @xmath117 pebbles on the subtrees , i.e. , all the vectors @xmath119 of @xmath120 elements whose sum is less than @xmath117 .",
    "we now argue on the fact that , despite the number of such vectors can be exponential on @xmath117 , the minimum can be found in polynomial time .",
    "this can again be done by using dynamic programming : let @xmath121 $ ] denote the minimum cost of placing @xmath122 pebbles in the first @xmath123 subtrees .",
    "clearly when @xmath124 we have @xmath125 = { \\ensuremath{\\texttt{opt}}}[v_1 , h]$ ] , while for @xmath126 the following holds : @xmath127 = \\min_{0 \\le z \\le h } \\left\\ { { \\ensuremath{\\texttt{min}}}[i-1 , z ] + { \\ensuremath{\\texttt{opt}}}[v_i , h - z ] \\right\\ } \\mbox{.}\\ ] ]    therefore , the equation for @xmath110 $ ] can be rewritten as : @xmath118 = |\\eta(u)-j| + \\min_{0 \\le i < j } { \\ensuremath{\\texttt{min}}}[\\ell , i ] \\mbox{.}\\ ] ]    notice how this way of distributing the pebbles is general and does not depend on the specific movement problem : in fact , it can be used every time we are interested in minimizing the cost of distributing a number of items in a set of bins if , for each bin , we incur a cost that depends on the number of items placed therein .",
    "an example of an optimal decomposition into subproblems along with the corresponding optimal solution is shown in figure  [ fig : mov_con_sum ] .",
    "regarding the complexity of the algorithm , the time required to compute a specific @xmath110 $ ] is @xmath128 . as the sum of the @xmath120-values over all the vertices is @xmath129 , the time needed to compute @xmath130 $ ] for a fixed @xmath117 and all @xmath131 is @xmath132 .",
    "it follows that all the possible subproblems can be solved in time @xmath133 .",
    "as we have to guess the vertex @xmath99 , a nave strategy would be repeating the above procedure @xmath11 times , one for each vertex of @xmath0 .",
    "this would require an overall time of @xmath134 .",
    "we can do better by using a more sophisticated approach : consider a _ _ centroid _ _ @xmath58 of @xmath0 , and notice that either there exists an optimal solution that places a pebble on @xmath58 , or every optimal solution places all the pebbles on a single connected component of @xmath135 .",
    "we first apply the above algorithm using @xmath58 as the root and then we proceed recursively on the trees of the forest @xmath135 ( each of which has at most half of the vertices ) . more precisely , for every subtree @xmath136 of @xmath135 , rooted at @xmath137 , we recursively solve an instance consisting of the tree @xmath136 where all the pebbles in @xmath138 are left unmoved and all pebbles not in @xmath138 have been moved to @xmath137 .",
    "this movement cost , i.e. , @xmath139 , is then added to the measure of the solution returned by the recursive call . among all the computed solutions we choose the cheapest one .    by doing so",
    ", we are able to reduce the computational complexity to @xmath140 . indeed , the recurrence relation describing the running time of the algorithm is @xmath141 , where @xmath142 denotes the number of vertices of the @xmath117-th subtree of @xmath135 . clearly , the depth of the recursion is @xmath143 while the amount of work on each level of the recursion - tree is @xmath133 .",
    "once the value of the optimal solution @xmath62 has been found , it is not too hard to see that the optimal solution itself can be reconstructed by proceeding in a bottom - up fashion , while keeping track of both the pebbles that move out of each subtree and the position where missing pebbles are to be placed .",
    "to summarize , we have the following :    [ thm : con_sum_trees ] @xmath13-@xmath19 on trees can be solved in @xmath140 time .",
    "the algorithm is similar to the one for @xmath13-@xmath19 : we guess a vertex @xmath98 such that there exists an optimal solution that places a pebble on @xmath99 , then we root the tree @xmath0 at @xmath99 ( call @xmath100 the rooted tree ) and we consider all the subtrees of @xmath100 in a bottom - up fashion .",
    "let @xmath144 be the number of pebbles whose initial position is the vertex @xmath145 .    as before , when the subtree @xmath101 ( rooted at the vertex @xmath57 ) of @xmath100 is examined , we consider an auxiliary problem where we want to place exactly @xmath104 pebbles on the vertices of @xmath101 in order to satisfy the properties [ it : con_p1 ] and [ it : con_p2 ] .",
    "we will measure the cost of a solution for this auxiliary problem by examining the number of pebbles placed on each vertex of @xmath101 .",
    "removing pebbles from a vertex costs nothing , while placing a pebble on a vertex costs @xmath12 if it comes from a different vertex . a way to visualize",
    "this auxiliary problem is to imagine the tree @xmath101 where no pebbles have been placed and a pool of @xmath117 pebbles to be distributed on its vertices .",
    "each vertex @xmath58 of @xmath101 can hold up to @xmath146 pebbles for free , while each additional pebble placed on @xmath58 increases the overall cost by @xmath12",
    ".    we will denote by @xmath110 $ ] the cost of the optimal movement for this auxiliary problem . to solve the original problem we need to find a solution corresponding to @xmath111 $ ] .",
    "we now show how to combine these auxiliary problems .",
    "if @xmath57 is a leaf of @xmath100 then we have : @xmath118 =          \\begin{cases }              0        & \\mbox{if } j \\le \\varphi(u ) ; \\\\",
    "j-\\varphi(u )     & \\mbox{if } j >",
    "\\varphi(u ) .          \\end{cases}\\ ] ]    otherwise , if @xmath57 is not a leaf , we can either place some pebbles on @xmath57 and the others on the subtrees rooted at its children ( @xmath105 ) , or place no pebble at all in the whole subtree rooted at @xmath57 ( @xmath113 ) .",
    "we call @xmath147 the number of pebbles that are to be placed on @xmath57 .    if @xmath113 we have @xmath110 = 0 $ ] , otherwise : @xmath118 = \\min_{1 \\le z \\le j}\\left\\ { \\max \\{z-\\varphi(u ) , 0\\ } + \\min_{\\substack{0 \\le j_1 , \\dots , j_{\\ell } \\le j - z \\\\",
    "\\sum_{i=1}^{\\ell } j_i =",
    "j - z } } \\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}[v_i , j_i ] \\right\\ } \\right\\}\\ ] ] where @xmath115 are the children of @xmath57 in @xmath100 .    as before , using the already shown dynamic - programming approach to optimally distributing the pebbles on the subtrees , we can find the values of @xmath110 $ ] for a fixed @xmath117 and all @xmath131 , in @xmath132 time .",
    "therefore the time required to compute all @xmath148 values for a single root @xmath99 is @xmath133 and the measure of the best solution is found in @xmath149 $ ] . as for @xmath13-@xmath19 ,",
    "it is not necessary to run the algorithm for all roots @xmath98 but we can choose a centroid @xmath58 of @xmath0 as starting root and then proceed recursively on the trees of @xmath135 .",
    "to summarize , we have the following :    [ thm : con_num_trees ] @xmath13-@xmath20 on trees can be solved in @xmath140 time .",
    "in this section we focus on independency motion problems .",
    "first , we give a better characterization of the hardness of @xmath28-@xmath14 and @xmath28-@xmath19 ( depending on the input graph ) , and then we show some positive results for our considered variants on paths and trees . since if @xmath150 there is no feasible solution , we will consider only instances where @xmath151 .",
    "as we already pointed out , for independency problems on general graphs it is @xmath26-hard even to find any feasible solution since it would require to find an independent set of size at least @xmath17 .",
    "nevertheless , one may wonder whether independency motion problems are tractable on instances on which a maximum independent set can be found in polynomial time .",
    "we provide a negative answer to this question , at least for @xmath28-@xmath14 and @xmath28-@xmath19 , by showing the following    -@xmath14 and of @xmath28-@xmath19 corresponding to the formula @xmath152 .",
    "pebbles are placed on black vertices . ]",
    "[ thm : ind_max_sum_hard_bipartite ] @xmath28-@xmath14 and @xmath28-@xmath19 are @xmath26-hard on bipartite graphs .",
    "we will show a polynomial reduction from @xmath153 to the decisional versions of @xmath28-@xmath14 and @xmath28-@xmath19 . recall that @xmath153 is the problem of deciding whether a formula @xmath154 in conjunctive normal form with three literals per clause is satisfiable .",
    "let @xmath155 be the set containing the variables of @xmath154 , and let @xmath156 be the number of clauses .",
    "we will denote the @xmath123-th literal of the @xmath117-th clause with @xmath157 .",
    "given an instance @xmath154 for @xmath153 we construct an instance for @xmath28-@xmath14 and for @xmath28-@xmath19 in the following manner :    * for each variable @xmath158 create a star with @xmath159 leaves labelled @xmath160 and label the internal node @xmath161 .",
    "place one pebble on @xmath162 and one on @xmath161 .",
    "* for each clause @xmath163 create a star with @xmath164 leaves labelled @xmath165 and label the internal node @xmath166 .",
    "place one pebble on @xmath167 and one on @xmath166 .",
    "* for each literal @xmath157 of @xmath154 let @xmath168 be the corresponding variable ; then , if @xmath157 is asserted add an edge between the two nodes labelled @xmath157 and @xmath169 , otherwise add an edge between the two nodes labelled @xmath157 and @xmath168 .",
    "let @xmath0 be the resulting graph , @xmath54 the set containing the @xmath170 placed pebbles , and @xmath56 the function that maps each pebble to its starting position ( see figure [ fig : mov_ind_max ] ) .",
    "notice that @xmath0 is bipartite as we can partition the vertices into two sets @xmath171 and @xmath172 such that no edge of @xmath0 has both its endpoints in the same set .",
    "we claim that there exists an assignment that satisfies @xmath154 if and only if the optimal solution @xmath55 for the instance of @xmath28-@xmath14 ( resp . , @xmath28-@xmath19 ) has measure at most @xmath12 ( resp . , @xmath173 ) .",
    "suppose the existence of an assignment @xmath174 that satisfies @xmath154 .",
    "then we move a pebble starting on vertex @xmath161 to the vertex labelled @xmath175 if @xmath176 , or to the vertex labelled @xmath177 if @xmath178 .",
    "moreover , for each clause @xmath163 of @xmath154 at least one literal @xmath157 must be true w.r.t .",
    "this implies that the vertex labelled @xmath157 is adjacent only to @xmath166 and to a vertex @xmath168 where no pebble has been placed .",
    "we then move the pebble initially placed on vertex @xmath166 to the vertex @xmath157 .",
    "the resulting configuration of pebbles is an independent set for @xmath0 and each pebble has been moved to a node adjacent to its starting position .",
    "this implies that the maximum movement is @xmath12 and that the overall distance travelled by pebbles is @xmath173 .",
    "conversely , suppose the existence of an optimal solution @xmath62 for the instance of @xmath28-@xmath14 ( resp .",
    ", @xmath28-@xmath19 ) that has measure equal to @xmath12 ( resp . ,",
    "@xmath180 ) .",
    "notice that for every pebble @xmath87 initially placed on a vertex labelled @xmath161 , @xmath181 must hold , otherwise either @xmath62 would be unfeasible or @xmath182 would be greater than @xmath12 ( resp .",
    ", @xmath180 , since @xmath180 pebbles need to be moved ) .",
    "similarly for every pebble @xmath87 initially placed on a vertex labelled @xmath166 , @xmath183 must hold .",
    "we construct an assignment @xmath184 for the variables in the following manner : if there is a pebble on the vertex labelled @xmath175 we set @xmath185 , otherwise there must be a pebble on @xmath177 and we set @xmath186 .",
    "we now show that @xmath184 is , indeed , an assignment that satisfies @xmath154 . for each clause @xmath163 the pebble placed on @xmath166 has been moved to a vertex @xmath157 corresponding to one of the three literals .",
    "this implies that no pebble has been moved to the unique vertex in @xmath187 that is adjacent to vertex @xmath157 .",
    "the above implies that the variable corresponding to literal @xmath188 has been set to the value that satisfies @xmath188 and thus the whole clause is satisfied .",
    "apparently , the above technique can not be straightforwardly adapted to @xmath28-@xmath20 , and so we leave this as an interesting open problem .",
    "actually , as shown in theorem [ thm : ind_max_sum_hard_bipartite ] , @xmath28-@xmath14 is hard already when the cost of an optimal solution is 1 .",
    "this immediately implies the following :    [ cor : ind_max_2-inapx ] @xmath28-@xmath14 on bipartite graphs is not approximable in polynomial time within a factor of @xmath189 for any positive @xmath22 , unless @xmath33 .",
    "we now show that this bound is tight , by providing a polynomial - time solution , which is optimal unless an additive term of @xmath12 , to @xmath28-@xmath14 on any class of graphs where a maximum independent set can be found in polynomial time , e.g. , perfect graphs ( which include bipartite graphs ) , interval graphs , and claw - free graphs .    given a graph @xmath190 and a subset of vertices",
    "@xmath191 we will denote the open neighbourhood of @xmath192 by @xmath193 .",
    "moreover we will denote the closed neighbourhood of @xmath192 by @xmath194=a \\cup n_h(a)$ ] .",
    "let @xmath195 be a maximum independent set of @xmath0 , the following lemma holds :    [ lemma : independent_set_neighborhood ] for each independent set @xmath69 of @xmath0 it is true that @xmath196| \\ge |u|$ ] .    by contradiction ,",
    "let @xmath196| < |u|$ ] then @xmath197 \\right ) \\cup u = \\left ( u^ * \\setminus \\left ( u^ * \\cap n_g[u ] \\right ) \\right ) \\cup u$ ] is an independent set of @xmath0 and @xmath198 .    to prove the next lemma we use the following well known result :    [ thm : hall_s_matching ]",
    "let @xmath199 be a bipartite graph .",
    "there exists a matching of size @xmath200 on @xmath190 iff @xmath201 .",
    "[ lemma : injective_function ] for each independent set @xmath69 of @xmath0 , there exists an injective function @xmath202 such that @xmath203 .",
    "construct the bipartite graph @xmath204 where all vertices of @xmath69 are considered to be distinct from the ones in @xmath195 and @xmath205 \\}$ ] .",
    "notice that , by construction , if two vertices @xmath68 are adjacent in @xmath190 either they are the same vertex or they are adjacent in @xmath0 , i.e. , @xmath206 .",
    "now , lemma [ lemma : independent_set_neighborhood ] implies that , for every @xmath207 , we have @xmath208| \\ge |a|$ ] .",
    "hence , from hall s matching theorem , there is a matching of size @xmath209 on @xmath190 ( and thus the function @xmath154 exists ) .",
    "we are now ready to prove :    [ thm : mov_ind_max_opt_plus_one ] there exists a polynomial - time algorithm for @xmath28-@xmath14 which , for every class of graphs where the maximum independent set can be found in polynomial time , computes a solution @xmath210 such that @xmath211 where @xmath18 is the measure of an optimal solution .",
    "the algorithm computes a maximum independent set @xmath195 of @xmath0 then , if @xmath212 it reports infeasibility , otherwise it optimally moves the pebbles towards ( a subset of ) the vertices of @xmath195 . to do that",
    ", it proceeds as follows : for every value of @xmath147 from @xmath213 to @xmath129 , it computes a solution @xmath214 for the maximum matching problem on the auxiliary bipartite graph @xmath215 , where each vertex in @xmath192 is associated with a pebble , and @xmath216 if and only if @xmath217 .",
    "let @xmath218 be the first value of @xmath147 such that @xmath219 , i.e. , all the pebbles have been matched . for every pebble @xmath79 set @xmath220 , where @xmath58 is the only vertex such that @xmath221 , and return @xmath210 .",
    "clearly @xmath222 .",
    "let @xmath62 be an optimal solution to @xmath28-@xmath14 and let @xmath223 $ ] .",
    "by lemma [ lemma : injective_function ] there exists an injective function @xmath154 that maps every vertex of the independent set @xmath69 to an adjacent vertex of @xmath195 .",
    "thus , for every @xmath79 we have @xmath224 , and therefore there exists a way to place all the pebbles on vertices of @xmath195 while travelling a maximum distance of at most @xmath225 .",
    "this implies @xmath226 .",
    "concerning independency motion problems on trees , we are able to devise two dynamic - programming algorithms for @xmath28-@xmath19 and @xmath28-@xmath20 , respectively . we note that it remains open to establish whether @xmath28-@xmath14 on trees can be solved in polynomial time .",
    "we will , however , devise an efficient algorithm for solving @xmath28-@xmath14 on paths .",
    "the details of these algorithm are presented in the following subsections .",
    "our dynamic - programming algorithm relies on the property of optimal solutions shown by lemma [ lemma : sum_tree_no_crossing ] that is valid also for @xmath28-@xmath19 .",
    "the algorithm first roots the tree @xmath0 at an arbitrary vertex @xmath98 to obtain the rooted tree @xmath100 , then considers all the subtrees of @xmath100 in a bottom - up fashion .    here",
    ", the auxiliary problem we consider when a subtree @xmath101 of @xmath0 rooted at vertex @xmath57 is examined is that of placing exactly @xmath104 pebbles on the vertices of @xmath101 such that their final positions induce an independent set of @xmath0 ( and each pebble is placed on different vertex ) .",
    "remind that @xmath102 denotes the number of pebbles placed on @xmath103 . as for the connectivity problems , if @xmath106 we want to move the @xmath107 exceeding pebbles to the parent of @xmath57 ( and thus outside @xmath101 ) . in a similar manner ,",
    "if @xmath108 , then the @xmath109 missing pebbles are to be moved into @xmath101 from the parent of @xmath57 , where we assume they are initially placed .",
    "we will denote by @xmath110 $ ] the cost of the optimal movement for this auxiliary problem .",
    "notice that , in @xmath110 $ ] , we are accounting for the cost of traversing all the edges of @xmath101 plus the edge from @xmath57 to its parent . to solve the original problem we need to find a solution corresponding to @xmath111 $ ] . clearly as @xmath112",
    "we do not have exceeding or missing pebbles , in this case .",
    "we now show how to combine these auxiliary problems .",
    "let @xmath227 $ ] ( resp .",
    ", @xmath228 $ ] ) with @xmath145 and @xmath229 be the value of an optimal solution to the auxiliary problem where exactly one pebble must be placed on @xmath57 ( resp .",
    ", no pebble can be placed on @xmath57 ) .",
    "notice that @xmath110 = \\min \\ { { \\ensuremath{\\texttt{opt}}}^+[u , j ] , { \\ensuremath{\\texttt{opt}}}^-[u , j ] \\}$ ] .",
    "we will say that infeasible solutions have cost @xmath230 .    if @xmath57 is a leaf we clearly have : @xmath231 =              \\begin{cases }                  |\\eta(u ) - 1| & \\mbox{if } j = 1 ; \\\\",
    "+ \\infty & \\mbox{if } j=0 \\mbox { or } j \\ge 2 . \\\\",
    "\\end{cases }               \\quad \\enskip                 { \\ensuremath{\\texttt{opt}}}^-[u , j ] =              \\begin{cases }                  \\eta(u ) & \\mbox{if } j = 0 ; \\\\                  + \\infty & \\mbox{if } j \\ge 1 .",
    "\\end{cases}\\ ] ]    if @xmath57 is not a leaf then we can either place a pebble on @xmath57 or not .",
    "if we do place it , the corresponding optimal value is : @xmath231 =          \\begin{cases }              + \\infty & \\mbox{if } j=0 ; \\\\",
    "|\\eta(u ) - j| + { \\displaystyle \\min_{\\substack{0 \\le j_1 , \\dots , j_{\\ell } < j \\\\ \\sum_{i=1}^{\\ell } j_i = j-1 } } } \\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}^-[v_i , j_i ] \\right\\ } & \\mbox{if } j \\ge 1 ,          \\end{cases}\\ ] ] where @xmath115 is the set of children of @xmath57 in @xmath100 . if @xmath117 is at least @xmath12 we place a pebble on @xmath57 and then consider all the possible ways of placing a total of @xmath232 pebbles on the subtrees rooted at the children of @xmath57 , but not on the children themselves .    if we do not place a pebble on @xmath57 ,",
    "then the optimal value is : @xmath233 = |\\eta(u ) - j| + { \\displaystyle \\min_{\\substack{0 \\le j_1 , \\dots , j_{\\ell } \\le j \\\\ \\sum_{i=1}^{\\ell } j_i = j } } }",
    "\\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}[v_i , j_i ] \\right\\}.\\ ] ]    this corresponds to the optimal way of placing @xmath117 pebbles on the subtrees rooted at the children of @xmath57 .",
    "as we have previously shown , the optimal assignment to @xmath234 can be found in @xmath235 time by using dynamic programming .",
    "the value of the optimal solution is stored in @xmath149 $ ] and the solution itself can be reconstructed by proceeding backwards as shown in section [ sec : con_sum_trees ] for @xmath13-@xmath19 .",
    "as we can compute the values @xmath110 $ ] , for a fixed @xmath117 and all @xmath131 , in @xmath132 time ( the @xmath120-values sum up to @xmath129 ) , the total time required by the algorithm is @xmath133 .",
    "the above discussion , immediately leads to the following :    [ thm : ind_sum_trees ] @xmath28-@xmath19 on trees can be solved in @xmath236 time .",
    "the algorithm is similar to the one for @xmath28-@xmath19 : we root the tree @xmath0 at an arbitrary vertex @xmath98 to obtain the rooted tree @xmath100 , then we consider all the subtrees of @xmath100 in a bottom - up fashion .",
    "let @xmath237 be @xmath12 if at least one pebble is initially placed on the vertex @xmath145 , and @xmath213 otherwise .",
    "as before , when the subtree @xmath101 , rooted at the vertex @xmath57 , of @xmath100 is examined , we consider an auxiliary problem where we want to place exactly @xmath104 pebbles on the vertices of @xmath101 such that their final positions induce an independent set of @xmath0 ( and each pebble is placed on a different vertex ) .",
    "we will measure the cost of a solution for this auxiliary problem by examining the number of pebbles placed on each vertex of @xmath101 .",
    "removing pebbles from a vertex costs nothing , while placing a pebble on a vertex costs @xmath12 if it comes from a different vertex .",
    "a way to visualize this auxiliary problem is to imagine the tree @xmath101 where no pebbles have been placed , and a pool of @xmath117 pebbles to be distributed on its vertices . if a vertex @xmath58 is such that @xmath238 then it can hold a single pebble for free , otherwise placing a pebble on @xmath58 will increase the overall cost by @xmath12 .",
    "we will denote by @xmath110 $ ] the cost of the optimal movement for this auxiliary problem . to solve the original problem we need to find a solution corresponding to @xmath111 $ ] .",
    "we now show how to combine these auxiliary problems .",
    "let @xmath227 $ ] ( resp .",
    ", @xmath228 $ ] ) with @xmath145 and @xmath229 be the value of an optimal solution to the auxiliary problem where exactly one pebble must be placed on @xmath57 ( resp .",
    ", no pebbles can be placed on @xmath57 ) .",
    "notice that @xmath110 = \\min \\ { { \\ensuremath{\\texttt{opt}}}^+[u , j ] , { \\ensuremath{\\texttt{opt}}}^-[u , j ] \\}$ ] .",
    "we will say that infeasible solutions have cost @xmath230 .",
    "if @xmath57 is a leaf of @xmath100 then we have : @xmath231 =          \\begin{cases }              + \\infty & \\mbox{if } j=0 \\mbox { or } j \\ge 2 ; \\\\              1-\\gamma(u ) & \\mbox{if } j=1 .",
    "\\end{cases } \\quad \\quad          { \\ensuremath{\\texttt{opt}}}^-[u , j ] =          \\begin{cases }              0        & \\mbox{if } j=0 ; \\\\              + \\infty & \\mbox{if } j \\ge 1 .",
    "\\end{cases}\\ ] ]    if @xmath57 is not a leaf then , with a reasoning similar to that we did for @xmath28-@xmath19 we have : @xmath231 =          \\begin{cases }              + \\infty & \\mbox{if } j=0 ; \\\\              1-\\gamma(u ) + { \\displaystyle \\min_{\\substack{0 \\le j_1 , \\dots , j_{\\ell } < j \\\\ \\sum_{i=1}^{\\ell } j_i = j-1 } } } \\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}^-[v_i , j_i ] \\right\\ } & \\mbox{if } j \\ge 1 ,          \\end{cases}\\ ] ] and @xmath233 =           \\min _ { \\substack{0 \\le j_1 , \\dots , j_{\\ell } \\le j \\\\ \\sum_{i=1}^{\\ell } j_i = j } } \\left\\ { \\sum_{i=1}^{\\ell } { \\ensuremath{\\texttt{opt}}}[v_i , j_i ] \\right\\},\\ ] ] where @xmath239 are the children of @xmath57 in @xmath100 .",
    "again , the optimal assignment to @xmath240 can be found in @xmath235 time by using dynamic programming .",
    "the value of the optimal solution is stored in @xmath149 $ ] and the solution itself can be reconstructed by proceeding backwards .",
    "as we can compute the values @xmath110 $ ] , for a fixed @xmath117 and all @xmath131 , in @xmath132 time ( the @xmath120-values sum up to @xmath129 ) , the total time required by the algorithm is @xmath133 .",
    "the above discussion immediately leads to the following :    [ thm : ind_num_trees ] @xmath28-@xmath20 on trees can be solved in @xmath236 time .      in this section",
    "we concentrate on @xmath28-@xmath14 , and we devise an efficient algorithm for solving @xmath28-@xmath14 on the special case where @xmath0 is a path . we start by proving the following :    [ lemma : swap ] let @xmath241 where @xmath242 and @xmath243 , we have @xmath244 .",
    "suppose that @xmath245 . if @xmath246 then @xmath247 , else if @xmath248 then @xmath249 .    in a similar manner",
    "suppose @xmath250 . if @xmath251 then @xmath252 , else if @xmath253 then @xmath254 .",
    "let @xmath99 be any endpoint of @xmath0 , with a little abuse of notation we will identify the vertices of @xmath0 by their distance from @xmath99 : the vertex @xmath123 with @xmath255 will be the unique vertex @xmath57 such that @xmath256 .",
    "let @xmath257 be an ordering of the pebbles such that @xmath258 for @xmath259 .",
    "the following lemma shows that there exists an optimal solution where the ordering of pebbles is preserved , i.e. , no edge of @xmath0 is traversed by two pebbles going in opposite directions .",
    "is a tree : take the tree @xmath136 with vertex set @xmath260 and edge set @xmath261 , place @xmath15 pebbles on vertex @xmath12 and one pebble on each vertex in @xmath262 .",
    "it is easy to see that any optimal solution has cost @xmath159 and that at least one edge must be traversed in opposite directions . ]",
    "[ lemma : no_crossing ] if there exists a feasible solution @xmath55 for @xmath28-@xmath14 on paths then there also exists a solution @xmath91 such that @xmath263 for every @xmath259 and @xmath264 .",
    "let @xmath55 be a feasible solution .",
    "we will show that whenever there are two pebbles @xmath265 and @xmath266 such that @xmath267 , they can be swapped without increasing the cost of @xmath55 to obtain another feasible solution .",
    "is clearly impossible . ]",
    "if needed , the procedure can be repeated until all the pebbles are placed in the right order .    in order to prove the above , consider a new solution @xmath91 where @xmath268 , @xmath269 , and @xmath270 for every @xmath271 .",
    "clearly @xmath91 is feasible ( as we only swapped two pebbles ) and requires at most the same maximum movement as @xmath55 , because : @xmath272 where every distance @xmath60 between two vertices @xmath57 and @xmath58 can be rewritten as @xmath273 and lemma [ lemma : swap ] holds .",
    "the algorithm takes as input an instance of @xmath28-@xmath14 plus a non - negative integer @xmath147 and exploits the previous property to compute a solution of cost at most @xmath147 , if it exists .",
    "the idea is simple : the pebbles are moved towards the endpoint @xmath99 of the path as most as possible while preserving the feasibility of the solution and the constraint on the cost .",
    "the pseudocode is given below .",
    "@xmath274 pebbles sorted by distance from @xmath99    @xmath275 @xmath55    [ lemma : alg1_correctness ] algorithm [ alg : indmax ] correctly returns a solution with maximum movement at most @xmath147 , if such a solution exists , or reports infeasibility if there is no such solution .",
    "first notice that all solutions returned by the algorithm are feasible as no two pebbles can be placed on adjacent vertices and , by construction , no pebble travels a distance greater than @xmath147 .",
    "this implies that if there is not a feasible solution , the algorithm correctly reports infeasibility .",
    "now we will prove that the algorithm correctly computes a solution when this exists .",
    "let @xmath62 be a solution with maximum movement at most @xmath147 that preserves the ordering of the pebbles ( by lemma [ lemma : no_crossing ] such a solution always exists ) .",
    "we will prove by induction that at the end of the @xmath117-th loop the first @xmath117 pebbles are correctly placed ( they are on an independent set ) , and that for the @xmath117-th pebble @xmath276 holds .    base case : the first pebble is placed on the first reachable node from @xmath99 , thus @xmath277 must hold .",
    "inductive step : suppose that the property is true for the first @xmath105 pebbles , we will prove that it is also true also for the @xmath278-th pebble .",
    "if the pebble @xmath279 is placed on vertex @xmath280 then the property holds , since this is the vertex with the smallest distance from @xmath99 that is reachable by @xmath279 .",
    "otherwise @xmath281 , and we have @xmath282 .",
    "we are ready to give the following :    [ thm : ind_max_paths ] @xmath28-@xmath14 on paths can be solved in @xmath283 time .    from lemma [ lemma : alg1_correctness ]",
    "it follows that @xmath28-@xmath14 on paths can be solved as follows : if @xmath284 then there is no solution , otherwise we can perform a binary search using algorithm [ alg : indmax ] to find the optimal value of @xmath17 ( or report infeasibility ) .",
    "as far as the time complexity is concerned , each invocation of the algorithm requires time @xmath285 and at most @xmath143 invocations are required . for algorithm [ alg : indmax ] to work , vertices and pebbles must be sorted w.r.t .",
    "their distance from @xmath99 , and this needs to be done only once and requires @xmath286 time .",
    "the whole procedure then takes @xmath287 time .",
    "in this section we prove that the problems @xmath31-@xmath14 , @xmath31-@xmath19 , and @xmath31-@xmath20 are @xmath26-hard .",
    "then , we give a tight approximation algorithm for @xmath31-@xmath14 that computes a solution that costs at most one more than the optimal solution . as of @xmath31-@xmath19 and @xmath31-@xmath20 , we show that the problems are not approximable within any factor smaller than @xmath288 , unless @xmath33 , and we devise two @xmath15-approximation algorithms .",
    "actually , we will show that any approximation for @xmath31-@xmath19 or @xmath31-@xmath20 implies an approximation with the same ratio for the _ minimum vertex cover _ problem , which is known to be not approximable under @xmath288 , unless @xmath33 @xcite . moreover , if the unique game conjecture @xcite is true , then both approximation algorithms are tight as the corresponding problems are not approximable within any constant factor better than @xmath15 @xcite .",
    "finally , we show that for classes of graphs where we can find a _ maximum - weight clique _ in polynomial time , we can also solve @xmath31-@xmath20 in polynomial time .",
    "we prove the following :    @xmath31-@xmath14 is @xmath26-hard .",
    "we show a reduction from the problem of determining if there exists a _ dominating clique _ in a graph @xmath190 , which is known to be @xmath26-complete @xcite .",
    "a dominating clique is a subset of vertices @xmath289 such that @xmath290 is both a clique and a dominating set for @xmath190 .",
    "we construct an instance of @xmath31-@xmath14 by setting @xmath291 and placing a pebble on each vertex of @xmath0 .",
    "we claim that there exists a dominating clique in @xmath190 if and only if the optimal solution for @xmath31-@xmath14 has measure @xmath18 at most @xmath12 .",
    "suppose that there exists a dominating clique @xmath290 in @xmath190 . by definition",
    ", @xmath290 is also a dominating set of @xmath0 .",
    "we define @xmath55 so that every pebble initially placed on a vertex @xmath292 is moved to a vertex @xmath293 such that @xmath70 ( notice that such a vertex always exists ) . after their movement the pebbles are placed on a clique of @xmath0 and each pebble has travelled a distance of at most @xmath12 .",
    "now suppose that there exists a solution @xmath55 for @xmath31-@xmath14 such that @xmath294 .",
    "clearly @xmath53 $ ] is a clique , and it is also a dominating set , since for each vertex @xmath295 $ ] , there exists a vertex @xmath296 $ ] such that @xmath297 .    on the positive side",
    ", we have :    it is possible to compute a solution @xmath210 for @xmath31-@xmath14 such that @xmath211 in polynomial time , where @xmath18 is the measure of an optimal solution .    consider the following algorithm : for each vertex @xmath145 construct a solution @xmath298 that moves all the pebbles to @xmath57 ( i.e. , set @xmath299 ) and compute @xmath300 . among the @xmath11 possible solutions choose the one of minimum cost and call it @xmath210 .",
    "now , let @xmath62 be an optimal solution and recall that , by definition , @xmath301 .",
    "let @xmath302 $ ] be the clique where pebbles have been placed by @xmath62 , and notice that when the above algorithm considers a node @xmath303 we have : @xmath304 , thus @xmath305 .",
    "the claim follows .",
    "we prove the following :    [ thm:2-apx - mov - clique - num ] @xmath31-@xmath20 is @xmath15-approximable and is not approximable within any constant factor smaller than @xmath288 , unless @xmath33 .",
    "let @xmath306 be an instance of @xmath31-@xmath20 and let @xmath307 be the number of pebbles that are initially placed on vertex @xmath308 .",
    "let us assume that @xmath309 for every @xmath308 , i.e. , no two pebbles are placed on the same vertex .",
    "we will show later that this assumption is not restrictive .",
    "call @xmath190 the graph induced by the vertices @xmath57 with @xmath310 .",
    "let @xmath311 be the complement graph of @xmath190 w.r.t .",
    "the edge set , that is the graph such that @xmath312 and @xmath313 .",
    "we will show that there exists a vertex cover @xmath314 for @xmath311 if and only if there exists a solution for the instance @xmath306 of @xmath31-@xmath20 of cost @xmath315 .",
    "let @xmath314 be a vertex cover for @xmath311 , this implies that @xmath316 is an independent set for @xmath311 , and therefore a clique for @xmath190 and @xmath0 .",
    "we construct a solution @xmath55 for @xmath31-@xmath20 by moving the @xmath315 pebbles that are not yet placed on vertices in @xmath317 to one of such vertices . now let @xmath55 be a solution for the instance @xmath306 of @xmath31-@xmath20 and",
    "let @xmath318 .",
    "notice that the cost of @xmath55 is exactly @xmath319 .",
    "clearly @xmath320 $ ] is a clique for @xmath0 and @xmath190 , therefore it is also an independent set for @xmath311 .",
    "this implies that @xmath321 is a vertex cover for @xmath311 .    from the above",
    "it follows that the cost of an optimal solution is equal to the size of the minimum vertex cover for @xmath311 . to approximate @xmath31-@xmath20",
    "we construct the graph @xmath311 , we compute a @xmath15-approximate minimum vertex cover @xmath322 , and then we reconstruct the solution @xmath55 as shown .",
    "if the previous assumption is not met , i.e. , there exists at least a vertex on which two or more pebbles are placed by @xmath56 , a slight modification to the instance is needed before we can apply the previous approach .",
    "we modify the graph @xmath0 by replacing each vertex @xmath57 such that @xmath323 with a clique of size @xmath324 .",
    "each edge @xmath325 incident to @xmath57 is replaced by @xmath324 edges connecting every vertex of the clique to the other endpoint of @xmath325 .",
    "then , we modify the function @xmath56 so that the @xmath324 pebbles that were placed on @xmath57 are assigned to each of the @xmath324 vertices of the corresponding clique .",
    "after the modifications , the cost of an optimal solution has not changed , moreover every solution for the modified instance can be easily reconverted to a solution for the original instance without increasing its cost .",
    "hence , we have designed a @xmath15-approximation algorithm for @xmath31-@xmath20 .    concerning the inapproximability result , we prove it by contradiction : we show that if there exists an algorithm that approximates @xmath31-@xmath20 with a ratio better than @xmath288 , then this would allow to approximate minimum vertex cover with the same approximation ratio .",
    "indeed , let @xmath311 be the instance of minimum vertex cover .",
    "now , add an isolated vertex @xmath57 and call @xmath0 the complement of such a graph w.r.t . the edge set",
    "then , let @xmath326 $ ] , and let @xmath56 be a function that places a single pebble on each vertex of @xmath0 except @xmath57",
    ". we can now compute an approximate solution for the instance @xmath306 of @xmath31-@xmath20 and reconstruct a solution with the same cost for minimum vertex cover , as shown before .",
    "is only instrumental to guarantee that @xmath0 is connected . ]",
    "we close this section by proving that @xmath31-@xmath20 can be solved in polynomial time whenever we are able to solve the maximum - weight clique problem on a weighted variant of @xmath0 .",
    "we remark that this is known to be the case of several classes of graphs , including perfect graphs .",
    "we refer the interested reader to @xcite for a survey .",
    "an exact solution to @xmath31-@xmath20 can be found in polynomial time on every class of graphs where a maximum - weight clique can be found in polynomial time .",
    "for every @xmath131 let @xmath146 be the number of pebbles starting on vertex @xmath58 , i.e. , @xmath327 .",
    "we consider a graph @xmath328 that is a copy of @xmath0 where each vertex @xmath131 has a weight @xmath146 .",
    "then , we compute a maximum - weight clique @xmath317 of @xmath190 and construct a solution @xmath55 for @xmath31-@xmath20 by moving every pebble starting on a vertex in @xmath329 to an arbitrary vertex of @xmath317 . contains no vertices of weight @xmath213 .",
    "] it is now easy to see that this is an optimal solution , since for every other solution @xmath91 , we have : @xmath330 } \\varphi(v ) =              k-\\sum_{v \\in \\mu^\\prime[p ] } \\varphi(v ) \\ge",
    "k-\\sum_{v \\in q } \\varphi(v ) =              \\sum_{v \\not\\in \\mu[p ] } \\varphi(v ) = c(\\mu).\\ ] ]      we prove the following :    @xmath31-@xmath19 is @xmath15-approximable and is not approximable within any constant factor better than @xmath288 , unless @xmath33 .",
    "let @xmath62 be an optimal solution to @xmath31-@xmath19 .",
    "if @xmath62 moves all the pebbles ( i.e. , @xmath331 ) then we can compute a @xmath15-approximate solution @xmath210 by guessing a vertex @xmath332 $ ] and moving all the pebbles to @xmath57 ( i.e. , setting @xmath333 ) .",
    "indeed , we have : @xmath334 where we used the fact that @xmath335 , and that @xmath336 , for every pebble @xmath79 .    on the other hand , if there exists at least one pebble @xmath337 such that @xmath338 , then we guess its starting vertex @xmath339 .",
    "we call @xmath340 the set of pebbles whose starting vertex is @xmath57 , @xmath341 the set of pebbles whose starting vertex is adjacent to @xmath57 , and @xmath342 the set of pebbles that are initially placed on a vertex at distance @xmath15 or more from @xmath57 .",
    "we then set @xmath343 if @xmath344 or @xmath345 . with a reasoning similar to the one of the previous case we can show that : @xmath346 concerning @xmath341 , assume @xmath347 , and so we need to compute @xmath210 for the pebbles in @xmath341 . to do that ,",
    "consider the instance @xmath348 of @xmath31-@xmath20 where @xmath190 is the subgraph of @xmath0 induced by the vertices initially occupied by pebbles in @xmath349 , and compute a @xmath15-approximate solution @xmath91 as shown in theorem [ thm:2-apx - mov - clique - num ] .",
    "set @xmath350 for every pebble @xmath351 such that @xmath352 , and set @xmath343 for the remaining pebbles in @xmath341 .",
    "clearly @xmath353 $ ] is a clique for @xmath0 as the vertices in @xmath354 $ ] are a clique for @xmath0 , @xmath57 is adjacent to every vertex in @xmath354 $ ] , and @xmath353 \\subseteq \\mu^\\prime[p_1 ] \\cup \\ { u \\}$ ] .",
    "notice that the cost of moving the pebbles in @xmath341 w.r.t .",
    "@xmath62 is greater than or equal to the cost of the optimal solution for the instance @xmath348 of @xmath31-@xmath20 .",
    "moreover , the cost of moving the pebbles in @xmath341 w.r.t .",
    "@xmath210 is equal to the cost of @xmath91 . from the above",
    "it follows that : @xmath355    therefore , the overall cost of this approximated solution is : @xmath356    concerning the inapproximability result , take a graph @xmath357 and construct the graph @xmath0 by complementing @xmath190 w.r.t .",
    "the edge set and adding an additional vertex @xmath358 adjacent to every other vertex .",
    "let @xmath359 $ ] and let @xmath56 be a function that places one pebble on each vertex of @xmath0 except @xmath358 .",
    "we will show that , given any solution for @xmath31-@xmath19 , it is possible to construct a vertex cover of @xmath190 having the same cost , and vice versa .",
    "this implies that any approximation algorithm for @xmath31-@xmath19 converts into an approximation algorithm for minimum vertex cover with the same approximation ratio , therefore no approximation algorithm with an approximation ratio less than @xmath288 can exist for @xmath31-@xmath19 @xcite , unless @xmath33 .",
    "let @xmath314 be a vertex cover for @xmath190 , then @xmath360 is an independent set for @xmath190 and a clique for @xmath0 .",
    "the solution that moves all the pebble of @xmath314 to @xmath358 and leaves the others on their starting position is feasible and has a cost of @xmath314 .",
    "now let @xmath55 be a solution for the instance of @xmath31-@xmath19 .",
    "we modify @xmath55 in such a way that every pebble that moves at least by @xmath12 is now moving to @xmath358 .",
    "this modification can not increase the cost of @xmath55 . then , let @xmath361 \\setminus \\ { v_0 \\}$ ] , and let @xmath362 .",
    "the cost of @xmath55 is @xmath363 , and @xmath320 $ ] is a clique for @xmath0 .",
    "therefore @xmath317 is also an independent set for @xmath190 , and @xmath314 is a vertex cover for @xmath190 .",
    "in this section we discuss ( in)approximability results for @xmath35-@xmath14 and @xmath35-@xmath19 . among the others , we provide an essentially tight approximation algorithm for @xmath35-@xmath14 . regarding @xmath35-@xmath20 , establishing its",
    "tractability remains open , but we will show that approximating such a problem can be useful to approximate @xmath35-@xmath19 , as well .",
    "we start by proving the following :    -@xmath14 corresponding to the formula @xmath364 .",
    "pebbles are placed on black vertices .",
    "all the edges not incident to a black vertex represent paths of length @xmath122 between their endpoints . ]    [ thm : cut_max_sum_hard_bipartite ] @xmath35-@xmath14 and @xmath35-@xmath19 are @xmath26-hard even if @xmath0 is a bipartite graph .",
    "we will show a reduction from the decision version of @xmath153 .",
    "let @xmath365 be the set of variables of the given formula @xmath154 , and let @xmath156 be the number of clauses .",
    "start with an empty graph @xmath0 and a set @xmath54 of @xmath366 pebbles , then construct an instance for @xmath35-@xmath14 and @xmath35-@xmath19 as follows ( see figure [ fig : cut_max_hard ] for an example ) :    * add the two vertices @xmath71 and @xmath72 .",
    "* for each variable @xmath158 add a path of three vertices to @xmath0 . label the middle node @xmath162 and the two endpoints @xmath175 and @xmath177 , respectively . place a pebble on @xmath162 .",
    "* for each clause @xmath163 create a path of five vertices labelled , from one endpoint to another , @xmath367 . place a pebble on @xmath368 and one on @xmath369 . * for each literal @xmath157 of @xmath154 , let @xmath168 be the corresponding variable .",
    "if @xmath157 is asserted add a new `` long '' path of length @xmath370 between the vertices labelled @xmath157 and @xmath168 ( so that @xmath371 ) . otherwise add a new `` long '' path between the vertices labelled @xmath157 and @xmath169 . *",
    "connect @xmath71 to every vertex @xmath175 and to every vertex @xmath177 with a new `` long '' path of length @xmath122 .",
    "* connect @xmath72 to every vertex @xmath188 with a new `` long '' path of length @xmath122 .",
    "notice that @xmath0 is bipartite as every cycle in @xmath0 must pass trough an even number of long paths ( paths of length @xmath122 ) and an even number of other edges .",
    "we will show that there exists a truth assignment satisfying @xmath154 if and only if an optimal solution for @xmath35-@xmath14 ( resp",
    ". , @xmath35-@xmath19 ) has cost at most @xmath12 ( resp . , @xmath17 ) .",
    "suppose that there exists a truth assignment @xmath372 that satisfies @xmath154 .",
    "then , for each @xmath158 we move the pebble placed on @xmath162 to @xmath175 if @xmath176 , and to @xmath177 if @xmath178 .",
    "moreover , for each clause @xmath163 there are at most @xmath15 literals whose truth values are false w.r.t .",
    "we move one or two of the pebbles placed on @xmath368 and @xmath373 to the nodes of @xmath0 corresponding to the those literals .",
    "notice that in this way each pebble travels at most a distance of @xmath12 ( so the sum of the distances is at most @xmath17 ) . to prove that the new positions of the pebbles induce an _",
    "s - t_-cut in @xmath0 , consider any path @xmath374 in @xmath0 between @xmath71 and @xmath72 .",
    "we will show that @xmath374 has been `` blocked '' , i.e , there exists at least one pebble that has been moved on some vertex of @xmath374 .",
    "the path @xmath374 must contain ( as subpath ) at least one path of length @xmath122 that connects a vertex @xmath375 for ( some @xmath123 ) to a vertex @xmath376 ( for some @xmath117 ) .",
    "if a pebble has been placed on @xmath377 then @xmath374 is blocked .",
    "otherwise the literal represented by @xmath120 must be false and , by construction , a pebble has been placed on @xmath120 .",
    "now suppose that an optimal solution for @xmath35-@xmath14 ( resp . , @xmath35-@xmath19 ) has cost at most @xmath12 ( resp . , @xmath17 ) .",
    "notice that every pebble must have travelled a distance of at most @xmath12 .",
    "this is trivial for @xmath35-@xmath14 , while for @xmath35-@xmath19 it suffices to note that placing a pebble on an internal vertex of the paths of length @xmath122 blocks at most the same set of paths that are blocked by placing it on one of the endpoints .",
    "moreover no pebble can traverse a whole path as @xmath378 .",
    "we define @xmath379 if a pebble has been placed on @xmath175 , and @xmath380 otherwise . for each clause @xmath163 there exists at least one vertex @xmath381 such that no pebble has been moved to @xmath120 .",
    "let @xmath175 be the variable associated with @xmath382 , and let @xmath377 be the vertex labelled @xmath175 if @xmath383 , or the vertex labelled @xmath177 if @xmath384 .",
    "the pebble placed on @xmath162 must have been moved to @xmath377 , otherwise there would exist a path from @xmath71 to @xmath72 passing through @xmath377 and @xmath120 , and therefore the clause is satisfied .",
    "we now show that @xmath35-@xmath14 and @xmath35-@xmath19 are actually very hard to approximate :    @xmath35-@xmath14 and @xmath35-@xmath19 are not approximable within a factor of @xmath385 for every @xmath30 , unless @xmath33 .",
    "this also holds for bipartite graphs .    as shown in the proof of theorem [ thm : cut_max_sum_hard_bipartite ] , it is possible to construct instances of @xmath35-@xmath14 ( and @xmath35-@xmath19 ) such that the optimal solution has measure at most @xmath12 ( resp . , @xmath386 ) if and only if a boolean formula in conjunctive normal form with three literals per clause , @xmath387 variables , and @xmath156 clauses is satisfiable .",
    "moreover , any solution with cost @xmath147 such that @xmath388 ( recall that @xmath122 is the length of the `` long '' paths ) can be easily transformed into a solution of cost at most @xmath366 by moving every pebble @xmath87 that has been placed on one long path to an appropriate endpoint ( i.e. , the one adjacent to @xmath80 ) .",
    "this implies that if @xmath154 is satisfiable , the measure @xmath389 of an optimal solution is at most @xmath17 for both the problems , while if @xmath154 is not satisfiable , @xmath389 is at least @xmath122 .",
    "then , given a formula @xmath154 , construct an instance for @xmath35-@xmath14 ( and @xmath35-@xmath19 ) as in the proof of theorem [ thm : cut_max_sum_hard_bipartite ] , and suppose that there exists a polynomial - time algorithm that approximates the optimal solution within a factor of @xmath385 , for some positive @xmath390 .",
    "let @xmath391 be the measure of such an approximate solution .",
    "observe that it is possible to upper bound the number of vertices @xmath11 of the instance with the quantity @xmath392 .",
    "if @xmath154 is satisfiable , we have @xmath393 , while if @xmath154 is not satisfiable we have @xmath394 .",
    "if @xmath395 holds then it is possible to decide @xmath153 by running the approximation algorithm and looking the measure of the approximate solution .",
    "this can be guaranteed by choosing @xmath396 , as we have @xmath397 , which implies @xmath398 .    by moving all the pebbles on a minimum @xmath71-@xmath72-cut of",
    "@xmath0 we can show that the inapproximability result provided above is essentially tight for @xmath35-@xmath14 :    @xmath35-@xmath14 is @xmath399-approximable in polynomial time , where @xmath400 is the diameter of @xmath0 , while @xmath35-@xmath19 is @xmath401-approximable in polynomial time .",
    "the approximation algorithm is as follows : if the initial position of the pebbles already makes @xmath71 and @xmath72 disconnected , then we are done . otherwise , compute ( in linear time ) a minimum @xmath71-@xmath72-cut of @xmath0 , say @xmath290 .",
    "if @xmath402 this implies that both problems have no solution , otherwise move the pebbles on the vertices of @xmath290 .",
    "the optimal measure must be at least @xmath12 , while each of the @xmath17 pebbles travels a distance of at most @xmath399 .",
    "we close this section proving a theorem which is useful in linking the approximability of @xmath35-@xmath20 to that of @xmath35-@xmath19 :    if there exists a @xmath45-approximation algorithm for @xmath35-@xmath20 then there exists a @xmath403-approximation algorithm for @xmath35-@xmath19 , where @xmath400 is the diameter of @xmath0 .",
    "consider an instance of @xmath35-@xmath19 an let @xmath18 be the measure of an optimal solution . if @xmath404 is the measure of the optimal solution on @xmath35-@xmath20 , then @xmath405 . if @xmath406 the claim is trivial , therefore we consider @xmath407 .",
    "then , a @xmath45-approximate solution for @xmath35-@xmath20 is a @xmath408-approximate solution for @xmath35-@xmath19 , as each pebble travels a distance of at most @xmath399 , and @xmath409 .",
    "in this paper we have been concerned with the emerging field of ( centralized ) pebble motion problems . in particular , we have provided approximability and inapproximability results most of which were tight for several relevant variants studied in the literature . among the issues we left open ,",
    "the most prominent are those of establishing whether @xmath28-@xmath14 on trees can be solved in polynomial time , and of settling the computational complexity of @xmath35-@xmath20 .",
    "motion planning of devices in a constrained environment deserves a further deep investigation in several respects .",
    "here we have limited our attention to vertex - to - vertex motion on unweighted , undirected graphs , and with the objective of achieving very basic configurations , but it is easy to imagine more challenging scenarios .",
    "for instance , pebbles could be deployed on a 2-dimensional environment , or even on a terrain . in this case , the planning task could become substantially more difficult , because of the setting in the continuum . on the other hand ,",
    "a simplifying yet very interesting scenario is that in which the given graph is a 2-dimensional grid . at an intermediate stage ,",
    "an intriguing variant is that in which the underlying graph is weighted .",
    "we also plan to look at other goal configurations , e.g. , reaching a set of vertices inducing a 2-edge - connected subgraph , or connected subgraph with a bounded diameter , just to mention few .",
    "we would like to thank feliciano colella and simone galanti for insightful discussions on computational tractability of some of the problems studied in this paper .",
    "ahmadian , s. , friggstad , z. , swamy , c. : local - search based approximation algorithms for mobile facility location problems .",
    "_ proceedings of the 24th annual acm - siam symposium on discrete algorithms ( soda13 ) _ , siam , 16071621 , 2013 .",
    "bil , d. , disser , y. , gual , l. , mihalak , m. , proietti , g. , widmayer , p. : polygon - constrained motion planning problems .",
    "_ proceedings of the 9th international symposium on algorithms and experiments for sensor systems , wireless networks and distributed robotics ( algosensors13 ) _ , lncs 8243 , springer , 6782 , 2013 .",
    "berman , p. , demaine , e.d . ,",
    "zadimoghaddam , m. : @xmath410-approximations for maximum movement problems .",
    "_ proocedings of the 14th international workshop on approximation algorithms for combinatorial optimization problems and of the the 15th international workshop on randomization and computation ( approx - random11 ) _ , lncs 6845 , springer , 6274 , 2011 .",
    "demaine , e.d . ,",
    "hajiaghayi , m. , marx , d. : minimizing movement : fixed - parameter tractability .",
    "_ proceedings of the 17th annual european symposium on algorithms ( esa09 ) _ , lncs 5757 , springer , 718729 , 2009 .",
    "prencipe , g. , santoro , n. : distributed algorithms for autonomous mobile robots .",
    "_ proceedings of the 4th international conference on theoretical computer science ( ifip - tcs06 ) _ , ifip 209 , springer , 4762 , 2006 ."
  ],
  "abstract_text": [
    "<S> when a large collection of objects ( e.g. , robots , sensors , etc . ) has to be deployed in a given environment , it is often required to plan a coordinated motion of the objects from their initial position to a final configuration enjoying some global property . </S>",
    "<S> in such a scenario , the problem of minimizing some function of the distance travelled , and therefore energy consumption , is of vital importance . in this paper we study several motion planning problems that arise when </S>",
    "<S> the objects must be moved on a graph , in order to reach certain goals which are of interest for several network applications . among the others , </S>",
    "<S> these goals include broadcasting messages and forming connected or interference - free networks . </S>",
    "<S> we study these problems with the aim of minimizing a number of natural measures such as the average / overall distance travelled , the maximum distance travelled , or the number of objects that need to be moved . to this respect , </S>",
    "<S> we provide several approximability and inapproximability results , most of which are tight . </S>"
  ]
}