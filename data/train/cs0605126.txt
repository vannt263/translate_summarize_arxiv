{
  "article_text": [
    "power consumption is becoming a major issue in computer systems .",
    "this is most obvious for battery - powered systems such as laptops because processor power consumption has been growing much more quickly than battery capacity .",
    "even systems that do not rely on batteries have to deal with power consumption since nearly all the energy consumed by a processor is released as heat .",
    "the heat generated by modern processors is becoming harder to dissipate and is particularly problematic when large numbers of them are in close proximity , such as in a supercomputer or a server farm .",
    "the importance of the power problem has led to a great deal of research on reducing processor power consumption ; see overviews by mudge  @xcite , brooks et al .",
    "@xcite , and tiwari et al .",
    "we focus on the technique _",
    "dynamic voltage scaling _ , which allows the processor to enter low - voltage states .",
    "reducing the voltage reduces power consumption , but also forces a reduction in clock frequency so the processor runs more slowly .",
    "for this reason , dynamic voltage scaling is also called _",
    "frequency scaling _ and _ speed scaling_.    this paper considers how to schedule processors with dynamic voltage scaling so that the scheduling algorithm determines how fast to run the processor in addition to choosing a job to run . in classical scheduling problems ,",
    "the input is a series of @xmath0 jobs @xmath1 .",
    "each job @xmath2 has a _ release time _",
    "@xmath3 , the earliest time it can run , and a _ processing time _",
    "@xmath4 , the amount of time it takes to complete . with dynamic voltage scaling ,",
    "the processing time is not known until the schedule is constructed so instead each job @xmath2 comes with a _ work requirement _ @xmath5 .",
    "a processor running continuously at speed @xmath6 completes @xmath6 units of work per unit of time so job @xmath2 would have processing time @xmath7 . in general , a processor s speed is a function of time and the amount of work it completes is the integral of this function over time .",
    "this paper considers _ offline _ scheduling , meaning the algorithm receives all the input together .",
    "this is in constrast to _ online _ scheduling , where the algorithm learns about each job at its release time .    to calculate the energy consumed by a schedule , we need a function relating speed to power ; the energy consumption is then the integral of power over time .",
    "actual implementations of dynamic voltage scaling give a list of speeds at which the processor can run . for example , the amd athlon 64 can run at 2000mhz , 1800mhz , or 800mhz  @xcite .",
    "since the first work on power - aware scheduling algorithms  @xcite , however , researchers have assumed that the processor can run at an arbitrary speed within some range .",
    "the justification for allowing a continuous range of speeds is twofold .",
    "first , choosing the speed from a continuous range is an approximation for a processor with a large number of possible speeds .",
    "second , a continuous range of possible clock speeds is observed by individuals who use special motherboards to overclock their computers .",
    "most power - aware scheduling algorithms use the model proposed by yao et al .",
    "@xcite , in which the processor can run at any non - negative speed and @xmath8 for some constant @xmath9 . in this model , the energy required to run job @xmath2 at speed @xmath6 is @xmath10 since the running time is @xmath11 .",
    "this relationship between power and speed comes from an approximation of a system s switching loss , the energy consumed by logic gates switching values .    most of our results do not assume a specific relationship between power and speed .",
    "except where otherwise stated , we just assume that power is a continuous , strictly - convex function of processor speed .",
    "formally , strict convexity means that the line segment between any two points on the power / speed curve lies above the curve except at its endpoints .",
    "more intuitively , strict convexity means that power increases super - linearly with speed .",
    "the power function is strictly convex when @xmath12 if @xmath8 .",
    "to measure schedule quality , we use two classic metrics .",
    "let @xmath13 and @xmath14 denote the start and completion times of job @xmath2 in schedule @xmath15 .",
    "most of the paper focuses on minimizing the schedule s _ makespan _ , @xmath16 , the completion time of the last job .",
    "we also consider _ total flow _ , the sum over all jobs of @xmath17 , the time between the release and completion times of job @xmath2 .",
    "either of these metrics can be improved by using more energy to speed up the last job so the goals of low energy consumption and high schedule quality are in opposition .",
    "thus , power - aware scheduling is a bicriteria optimization problem and our goal becomes finding _ non - dominated schedules _ , those such that no schedule can be both better and use less energy .",
    "a common approach to bicriteria problems is to fix one of the parameters . in power - aware scheduling",
    ", this gives two interesting special cases .",
    "if we fix energy , we get the _ laptop problem _ , which asks `` what is the best schedule achievable using a particular energy budget ? '' .",
    "fixing schedule quality gives the _ server problem _",
    ", which asks `` what is the least energy required to achieve a desired level of performance ? '' .",
    "this paper considers both uniprocessor and multiprocessor scheduling . in the multiprocessor setting , we assume that the processors have a shared energy supply .",
    "this corresponds to scheduling a laptop with a multi - core processor or a server farm concerned only about total energy consumption and not the consumption of each machine separately .",
    "[ [ results ] ] results + + + + + + +    our results in power - aware scheduling are the following :    * for uniprocessor makespan , we give an algorithm to find all non - dominated schedules .",
    "its running time is linear once the jobs are sorted by arrival time .",
    "* we show that there is no exact algorithm for uniprocessor total flow using arithmetic operations and the extraction of @xmath18 roots .",
    "this holds even with equal - work jobs . * for a large class of `` reasonable '' scheduling metrics , we show how to extend uniprocessor algorithms to the multiprocessor setting with equal - work jobs . using this technique",
    ", we give an exact algorithm for multiprocessor makespan of equal - work jobs and an arbitrarily - good approximation for multiprocessor total flow of equal - work jobs .",
    "* we prove that multiprocessor makespan is np - hard if jobs require different amounts of work , even when all jobs arrive immediately .",
    "the rest of the paper is organized as follows .",
    "section  [ background - section ] describes related work .",
    "section  [ makespan - uni - section ] gives the uniprocessor algorithm for makespan .",
    "section  [ impossibility - section ] shows that total flow can not be exactly minimized .",
    "section  [ multi - section ] extends the uniprocessor results to give multiprocessor algorithms for equal - work jobs and shows that general multiprocessor makespan is np - hard .",
    "finally , section  [ conc - section ] discusses future work .",
    "the work most closely related to ours is due to uysal - biyikoglu , prabhakar , and el gamal  @xcite , who consider the problem of minimizing the energy of wireless transmissions .",
    "this application has a totally different power function from those occurring in dynamic voltage scaling , but their algorithms only rely on the power function being continuous and strictly convex . they give a quadratic - time algorithm for the server version of makespan .",
    "thus , our algorithm runs faster and also finds all non - dominated schedules rather than just solving the server problem .",
    "el gamal et al .",
    "@xcite consider the wireless transmission problem when the packets have different power functions , giving an iterative algorithm that converges to an optimal solution .",
    "they also show how to extend their algorithm to handle the case when the buffer used to store active packets has bounded size and the case when packets have individual deadlines .",
    "their algorithm can also be extended to schedule multiple transmitters , but this does not correspond to a processor scheduling problem .",
    "pruhs , van stee , and uthaisombut  @xcite consider the laptop problem version of minimizing makespan for jobs having precedence constraints where all jobs are released immediately and @xmath8 .",
    "their main observation , which they call the _ power equality _ , is that the sum of the powers of the machines is constant over time in the optimal schedule .",
    "they use binary search to determine this value and then reduce the problem to scheduling on related fixed - speed machines .",
    "previously - known  @xcite approximations for the related fixed - speed machine problem then give an @xmath19-approximation for power - aware makespan .",
    "this technique can not be applied in our setting because the power equality does not hold for jobs with release dates .    minimizing the makespan of tasks with precedence constraints has also been studied in the context of project management .",
    "speed scaling is possible when additional resources can be used to shorten some of the tasks .",
    "pinedo  @xcite gives heuristics for some variations of this problem .",
    "the only previous power - aware algorithm to minimize total flow is by pruhs , uthaisombut , and woeginger  @xcite , who consider scheduling equal - work jobs on a uniprocessor . in this setting",
    ", they observe that jobs can be run in order of release time and then prove the following relationships between the speed of each job in the optimal solution :    [ flow - relationship - theorem ] let @xmath1 be equal - work jobs ordered by release time . in the schedule",
    "@xmath20 minimizing total flow for a given energy budget where @xmath8 , the speed @xmath21 of job @xmath2 ( for @xmath22 ) obeys the following :    * if @xmath23 , then @xmath24 .",
    "* if @xmath25 , then @xmath26 . * if @xmath27 , then @xmath28 .    these relationships , together with observations about when the optimal schedule changes configuration , give an algorithm based on binary search that finds an arbitrarily - good approximation for either the laptop or the server problem",
    "in fact , they can plot the exact tradeoff between total flow and energy consumption for optimal schedules in which the third relationship of theorem  [ flow - relationship - theorem ] does not occur .",
    "our impossibility result in section  [ impossibility - section ] shows that the difficulty caused by the third relationship can not be avoided .",
    "the idea of power - aware scheduling was proposed by weiser et al .",
    "@xcite , who use trace - based simulations to estimate how much energy could be saved by slowing the processor to remove idle time .",
    "yao et al .",
    "@xcite formalize this problem by assuming each job has a deadline and seeking the minimum - energy schedule that satisfies all deadlines .",
    "they give an optimal offline algorithm and propose two online algorithms .",
    "they show one is @xmath29-competitive , i.e. it uses at most @xmath30 times the optimal energy .",
    "bansal et al .",
    "@xcite analyze the other , showing it is @xmath31-competitive .",
    "bansal et al .",
    "@xcite also give another algorithm that is @xmath32-competitive .",
    "power - aware scheduling of jobs with deadlines has also been considered with the goal of minimizing the cpu s maximum temperature .",
    "bansal et al .",
    "@xcite propose this problem and give an offline solution based on convex programming .",
    "bansal and pruhs  @xcite analyze the online algorithms discussed above in the context of minimizing maximum temperature .",
    "a different variation is to assume that the processor can only choose between discrete speeds .",
    "chen et al .",
    "@xcite show that minimizing energy consumption in this setting while meeting all deadlines is np - hard , but give approximations for some special cases .",
    "another algorithmic approach to power management is to identify times when the processor or parts of it can be partially or completely powered down .",
    "irani and pruhs  @xcite survey work along these lines as well as approaches based on speed scaling .",
    "our first result is an algorithm to find all non - dominated schedules for uniprocessor power - aware makespan .",
    "we begin by solving the laptop problem for an energy budget @xmath33 .",
    "let @xmath20 be an optimal schedule for this problem , i.e. @xmath20 has minimum makespan among schedules using energy @xmath33 .      to find @xmath20 , we establish properties it must satisfy .",
    "( we omit formal proofs for most of the properties and merely describe the relevant ideas . )",
    "our first property is due to yao , demers , and shenker  @xcite , who observed that the speed does not change during a job or energy could be saved by running that job at its average speed .",
    "[ job - const - speed - lemma ] [ first - property - lemma ] each job runs at a single speed in @xmath20 .",
    "we use @xmath34 to denote the speed of job @xmath2 in schedule @xmath15 , omitting the schedule when it is clear from context .",
    "the second property allows us to fix the order in which jobs are run .",
    "[ fifo - lemma ] without loss of generality , @xmath20 runs jobs in order of their release times .",
    "lemma  [ fifo - lemma ] holds because reordering jobs ( without changing their speeds ) so that a job runs before jobs released after it produces a legal schedule . to simplify notation",
    ", we assume the jobs are indexed so @xmath35 .",
    "the third property is that @xmath20 is not idle between the release of the first job and the completion of the last job .",
    "[ no - idle - lemma ] @xmath20 is not idle between the release of job @xmath36 and the completion of job @xmath37    lemma  [ no - idle - lemma ] holds because slowing down the job running before a period of idle time saves energy , which can then be used to speed up the last job and reduce the makespan .    stating the next property requires a definition .",
    "block _ is a maximal substring of jobs such that each job except the last finishes after the arrival of its successor . for brevity , we denote a block with the indices of its first and last jobs .",
    "thus , the block with jobs @xmath38 is block @xmath39 .",
    "the fourth property is the analog of lemma  [ job - const - speed - lemma ] for blocks .",
    "[ block - const - speed - lemma ] in @xmath20 , jobs in the same block run at the same speed .",
    "if the lemma does not hold , we can find two adjacent jobs @xmath2 and @xmath40 in the same block of @xmath20 with @xmath41 .",
    "let @xmath42 be a positive number less than the amount of work remaining in job @xmath2 at time @xmath43 .",
    "consider changing the schedule by running @xmath42 work of @xmath2 at speed @xmath44 and @xmath42 work of @xmath40 at speed @xmath21 .",
    "since the block contains the same amount of work at each speed , the makespan is unchanged and the same amount of energy is used . by construction , this change does not cause the schedule to violate any release times .",
    "job @xmath2 does not run at a constant speed , however , contradicting lemma  [ job - const - speed - lemma ] .",
    "lemma  [ block - const - speed - lemma ] shows that speed is a property of blocks .",
    "in fact , if we know how @xmath20 is broken into blocks , we can compute the speed of each block .",
    "the definition of a block and lemma  [ no - idle - lemma ] mean that block @xmath39 starts at time @xmath3 .",
    "similarly , block @xmath39 completes at time @xmath45 unless it is the last block .",
    "thus , any block @xmath39 other than the last runs at speed @xmath46 . to compute the speed of the last block , we subtract the energy used by all the other blocks from the energy budget @xmath33 .",
    "we choose the speed of the last block to exactly use the remaining energy .    using the first four properties , an @xmath47-time dynamic programming algorithm can find the best way to divide the jobs into blocks . to improve on this ,",
    "we establish the following restriction on allowable block speeds :    [ optimal - blocks - increasing - lemma ] [ last - property - lemma ] the block speeds in @xmath20 are non - decreasing .",
    "suppose to the contrary that @xmath20 runs a block @xmath39 faster than block @xmath48 .",
    "let @xmath49 be less than the amount of work in either block .",
    "we modify the schedule by running @xmath42 of the work in each block at the other block s speed .",
    "this does not change when the pair of blocks complete or how much energy they consume since the same amount of work is run at each speed .",
    "the modified schedule is valid since no job starts earlier than in @xmath20 .",
    "thus , we have created another optimal schedule , but it runs block @xmath39 at two speeds , contradicting either lemma  [ job - const - speed - lemma ] or lemma  [ block - const - speed - lemma ] .",
    "it turns out that @xmath20 is the only schedule having all the properties given by lemmas  [ first - property - lemma][last - property - lemma ] .",
    "[ blocks - increasing - uniqueness - lemma ] for any energy budget , there is a unique schedule having the following properties :    1 .",
    "each job runs at a single speed 2 .",
    "jobs are run in order of release time 3 .",
    "it is not idle between the release of job @xmath36 and the completion of job @xmath37 4 .",
    "jobs in the same block run at the same speed 5 .",
    "the blocks speeds are non - decreasing    suppose to the contrary that @xmath15 and @xmath50 are different schedules obeying all five properties and consuming the same amount of energy .",
    "since each schedule is determined by its blocks , @xmath15 and @xmath50 must have different blocks .",
    "without loss of generality , suppose the first difference occurs when job @xmath2 is the last job in its block for schedule @xmath15 but not for schedule @xmath50 .",
    "we claim that every job indexed at least @xmath51 runs slower in schedule @xmath50 than in schedule @xmath15 .",
    "since energy consumption increases with speed , this implies that schedule @xmath50 uses less energy than schedule @xmath15 , a contradiction .",
    "in fact , we prove the strengthened claim that every job indexed at least @xmath51 runs slower and finishes later in schedule @xmath50 than in schedule @xmath15 . first , we show this holds for job @xmath2 .",
    "job @xmath2 ends its block in schedule @xmath15 but not in schedule @xmath50",
    "so @xmath52 .",
    "since each schedule begins the block containing job @xmath2 at the same time and runs the same jobs before job @xmath2 , job @xmath2 runs slower in schedule @xmath50 than schedule @xmath15 .",
    "now we assume that the strengthened claim holds for jobs indexed below @xmath53 and consider job @xmath54 .",
    "since each job @xmath55 finishes no earlier than its successor s release time in schedule @xmath15 , each finishes after its successor s release time in schedule @xmath50 .",
    "thus , none of these jobs ends a block in schedule @xmath50 and schedule @xmath50 places jobs @xmath2 and @xmath54 in the same block , which implies @xmath56 .",
    "speed is non - decreasing in schedule @xmath15",
    "so @xmath57 . therefore , @xmath58 so job @xmath54 runs slower in schedule @xmath50 than in schedule @xmath15 .",
    "job @xmath54 also finishes later because job @xmath59 finishing later implies that job @xmath54 starts later .    because only @xmath20 has all five properties",
    ", we can solve the laptop problem by finding a schedule with the properties .",
    "for this task , we propose an algorithm @xmath60 .",
    "this algorithm maintains a tentative list of blocks , initially empty .",
    "each block knows its speed , calculated as described above from the release time of the next job ( including jobs not yet added to the schedule ) or the energy budget .",
    "jobs are added to the schedule one at a time in order of their release times .",
    "when a new job is added , it starts in its own block .",
    "then , while the last block runs slower than its predecessor , the last two blocks are merged . assuming the input is already sorted by release time",
    ", @xmath60  runs in @xmath61 time since each job ceases to be the first job of a block once .",
    "a slight modification of @xmath60  finds all non - dominated schedules .",
    "intuitively , the modified algorithm enumerates all optimal configurations ( i.e. ways to break the jobs into blocks ) by starting with an `` infinite '' energy budget and gradually lowering it . to start this process , run @xmath60  as above , but omit the merging step for the last job , essentially assuming the energy budget is large enough that the last job runs faster than its predecessor",
    "to find each subsequent configuration change , calculate the energy budget at which the last two blocks merge . until this value , only the last block changes speed .",
    "thus , we can easily find the relationship between makespan and energy consumption for a single configuration and the curve of all non - dominated schedules is constructed by combining these .",
    "the curve for an instance with three jobs and @xmath62 is plotted in figure  [ makespan - energy - fig ] .",
    "the configuration changes occur at energy 8 and 17 , but they are not readily identifiable from the figure because the makespan / energy curve is always continuous and has a continuous first derivative for this power function .",
    "higher derivatives are discontinuous at the configuration changes",
    ". figures  [ dmakespan - energy - fig ] and [ ddmakespan - energy - fig ] show the first and second derivatives .",
    "we have completely solved uniprocessor power - aware makespan by showing how to compute all non - dominated schedules , forming a curve such as figure  [ makespan - energy - fig ] .",
    "the previous work on power - aware scheduling for total flow  @xcite includes a similar figure , but that figure omits parts of the curve where the optimal schedule finishes one job exactly as another is released .",
    "we now show that these gaps can not be filled exactly .",
    "[ impossible - theorem ] if @xmath62 , there is no exact algorithm to minimize total flow for a given energy budget using operations @xmath63 , @xmath64 , @xmath65 , @xmath66 , and the extraction of roots , even on a uniprocessor with equal - work jobs .",
    "we show that a particular instance can not be solved exactly .",
    "let jobs @xmath36 and @xmath67 arrive at time 0 and job @xmath68 arrive at time 1 , each requiring one unit of work .",
    "we seek the minimum - flow schedule using 9 units of energy .",
    "again we use @xmath21 to denote the speed of job @xmath2 .",
    "thus , @xmath69 for energy budgets between approximately 8.43 and approximately 11.54 , the optimal solution finishes job @xmath67 at time 1 .",
    "therefore , @xmath70 and theorem  [ flow - relationship - theorem ] gives us that @xmath71 substituting equation ( [ irreduc2-eqn ] ) into equations ( [ irreduc1-eqn ] ) and ( [ irreduc3-eqn ] ) , followed by algebraic manipulation gives @xmath72{}\\\\ -1026{\\sigma}_2 ^ 5 - 5940{\\sigma}_2 ^ 4 + 12150{\\sigma}_2 ^ 3 - 10449{\\sigma}_2 ^ 2 + 4374{\\sigma}_2 - 729 & = & 0.\\end{aligned}\\ ] ] according to the gap system  @xcite , the galois group of this polynomial is not solvable .",
    "this implies the theorem by a standard result in galois theory ( cf .",
    "we owe the idea for this type of argument to bajaj  @xcite .    since an arbitrarily - good approximation algorithm is known for total flow , one interpretation of theorem  [ impossible - theorem ]",
    "is that exact solutions do not have a nice representation . for most applications ,",
    "the approximation is sufficient since finite precision is the normal state of affairs in computer science .",
    "certainly , it could be used to draw an approximate curve for the gaps in the flow analog of figure  [ makespan - energy - fig ] . only an exact algorithm such as @xmath60",
    "can give closed - form solutions suitable for symbolic computation , however .",
    "now we consider multiprocessor power - aware scheduling . in a non - dominated schedule , the processors are related by the following observations :    1 .   for makespan",
    ", each processor must finish its last job at the same time or slowing the processors that finish early would save energy .",
    "2 .   for total flow ,",
    "each processor s last job runs at the same speed or running them at the average speed would save energy .    using these observations , slight modifications of @xmath60  and the total flow algorithm of pruhs et al .",
    "@xcite can solve multiprocessor problems once the assignment of jobs to processors is known .",
    "we show how to assign equal - work jobs to processors for scheduling metrics with two properties .",
    "a metric is _ symmetric _ if it is not changed by permuting the job completion times .",
    "a metric is _ non - decreasing _ if it does not decrease when any job s completion time increases .",
    "both makespan and total flow have these properties , but some metrics do not .",
    "one example is total weighted flow , which is not symmetric .    to prove our results , we need some notation . for schedule @xmath15 and job @xmath2 ,",
    "let @xmath73 denote the index of the processor running job @xmath2 and @xmath74 denote the index of the job run after @xmath2 on processor @xmath73 .",
    "also , let @xmath75 denote the portion of the schedule running on processor @xmath73 after the completion of job @xmath2 , i.e. the jobs running after job @xmath2 together with their start and completion times .",
    "we omit the superscript when the schedule is clear from context .",
    "we begin by observing that job start times and completion times occur in the same order .",
    "[ start - completion - order - lemma ] if @xmath20 is an optimal schedule for equal - work jobs under a symmetric non - decreasing metric , then @xmath76 implies @xmath77 .",
    "suppose to the contrary that @xmath76 and @xmath78 .",
    "clearly , jobs @xmath2 and @xmath54 must run on different machines .",
    "we create a new schedule @xmath79 from @xmath20 . all jobs on machines other than @xmath80 and @xmath81",
    "are scheduled exactly the same , as are those that run before jobs @xmath2 and @xmath54 .",
    "we set the completion time of job @xmath2 in @xmath79 to @xmath82 and the completion time of job @xmath54 in @xmath79 to @xmath83 .",
    "we also switch the suffixes of jobs following these two , i.e. run @xmath84 on processor @xmath81 and run @xmath85 on processor @xmath80 .",
    "job @xmath2 still has positive processing time since @xmath86 .",
    "( the processing time of job @xmath54 increases so it is also positive . )",
    "thus , @xmath79 is a valid schedule .",
    "the metric values for @xmath20 and @xmath79 are the same since this change only swaps the completion times of jobs @xmath2 and @xmath54 .",
    "we complete the proof by showing that @xmath79 uses less energy than @xmath20 .",
    "since the power function is strictly convex , it suffices to show that both jobs have longer processing time in @xmath79 than job @xmath54 did in @xmath20 .",
    "job @xmath54 ends later so its processing time is clearly longer .",
    "job @xmath2 also has longer processing time since runs throughout the time @xmath20 runs job @xmath54 , but starts earlier .    using lemma  [ start - completion - order - lemma ] , we prove that an optimal solution exists with the jobs distributed in _ cyclic order _ , i.e. job @xmath2 runs on processor @xmath87 .",
    "[ cyclic - theorem ] there is an optimal solution for equal - work jobs under any symmetric non - decreasing metric with the jobs distributed in cyclic order .",
    "suppose to the contrary that no optimal schedule distributes the jobs in cyclic order .",
    "let @xmath51 be the smallest value such that no optimal schedule distributes jobs @xmath88 in cyclic order and let @xmath20 be an optimal schedule that distributes the first @xmath89 jobs in cyclic order . to simplify notation",
    ", we create dummy jobs @xmath90 , @xmath91 ,  , @xmath92 , with job @xmath93 assigned to processor @xmath51 . by assumption , @xmath94 .",
    "let @xmath95 be the job such that @xmath96 , i.e. the job preceeding job @xmath2 . since the first @xmath89 jobs are distributed in cyclic order , if we assume ( without loss of generality ) that jobs starting at the same time finish in order of increasing index , then lemma  [ start - completion - order - lemma ] implies that @xmath97 .",
    "( details omitted . )    to complete the proof , we consider 3 cases . in each",
    ", we use @xmath20 to create an optimal schedule assigning job @xmath2 to processor @xmath87 , contradicting the definition of @xmath51 .",
    "case 1 : suppose no job follows job @xmath98 .",
    "we modify the schedule by moving @xmath99 to follow @xmath98 on processor @xmath87 .",
    "since @xmath97 and @xmath99 was able to follow job @xmath95 , it can also follow job @xmath98 .",
    "the resulting schedule has the same metric value and uses the same energy so it is also optimal .",
    "case 2 : suppose @xmath98 is not the last job assigned to processor @xmath100 and @xmath101 .",
    "we extend the cyclic order by swapping @xmath99 and @xmath102 .",
    "this does not change the amount of energy used . to show that it gives a valid schedule , we need to show that jobs @xmath95 and @xmath98 complete before @xmath102 and @xmath99 . job @xmath95 ends by time @xmath103 by the assumption that @xmath101 .",
    "job @xmath98 ends by time @xmath104 since @xmath97 .",
    "case 3 : suppose @xmath98 is not the last job assigned to processor @xmath100 and @xmath105 .",
    "in this case , we swap the jobs @xmath106 and @xmath107 , but leave the schedules the same . in other words , we run job @xmath106 from time @xmath104 to time @xmath108 on processor @xmath109 and we run job @xmath110 from time @xmath103 to time @xmath111 on processor @xmath100 .",
    "the schedules have the same metric value and each uses the same amount of energy . to show that we have created a valid schedule , we need to show that jobs @xmath106 and @xmath110 are each released by the start time of the other .",
    "job @xmath106 was released by time @xmath104 since @xmath105 . since a job with index greater than @xmath51 follows job @xmath98 , @xmath112 and job @xmath110",
    "was released by time @xmath103 .",
    "a simpler proof suffices if we specify the makespan metric since then @xmath20 has no idle time .",
    "thus , @xmath113 and case 2 is eliminated .",
    "theorem  [ cyclic - theorem ] allows us to solve multiprocessor makespan for equal - work jobs .",
    "unfortunately , the general problem is np - hard .",
    "nonpreemptive power - aware multiprocessor makespan is np - hard , even when all jobs arrive immediately .",
    "we give a reduction from partition  @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ partition : given a multiset @xmath114 , does there exist a partition of @xmath15 into @xmath115 and @xmath116 such that @xmath117 ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    let @xmath118 .",
    "we assume @xmath50 is even since otherwise no partition exists .",
    "we create a scheduling problem from an instance of partition by creating a job @xmath2 for each @xmath119 with @xmath120 and @xmath121 .",
    "then we ask whether a 2-processor schedule exists with makespan @xmath122 and a power budget allowing work @xmath50 to run at speed 1 .    from a partition",
    ", we can create a schedule where each processor runs the jobs corresponding to one of the @xmath123 at speed 1 .",
    "for the other direction , the convexity of the power function implies that all jobs run at speed 1 so the work must be partitioned between the processors .",
    "pruhs et al .",
    "@xcite observed that the special case of all jobs arriving immediately has a ptas based on load balancing work by alon et al .",
    "@xcite on minimizing the @xmath124 norm of loads .",
    "the study of power - aware scheduling algorithms is just beginning so there are many possible directions for future work .",
    "we consider the most important to be finding online algorithms with performance guarantees for makespan or total flow .",
    "no such algorithms are currently known , but many scheduling applications occur in the online setting . our results on the structure of optimal solutions may help with this task , but the problem seems quite difficult .",
    "if the algorithm can not know when the last job has arrived , it must balance the need to run quickly to minimize makespan if no other jobs arrive against the need to conserve energy in case more jobs do arrive .",
    "we would also like to see theoretical research using models that more closely resemble real systems . with this objective",
    ", we have been investigating actual implementations of dynamic voltage scaling .",
    "the most obvious feature of real systems differing from the standard model is that the speed has discrete settings rather than being a continuous variable .",
    "imposing minimum and/or maximum speeds is one way to partially incorporate this aspect of real systems without going all the way to the discrete case .",
    "another feature of real systems is that slowing down the processor has less effect on memory - bound sections of code since part of the running time is caused by memory latency .",
    "there is already some simulation - based work attempting to exploit this phenomenon  @xcite .",
    "finally , real systems incur overhead to switch speeds because the processor must stop while the voltage is changing .",
    "this overhead is fairly small , but discourages algorithms requiring frequent speed changes .",
    "we have begun considering models incorporating some of these changes in the hope of finding one that more closely reflects real systems while remaining mathematically tractable .",
    "we thank jeff erickson for introducing us to the work of bajaj  @xcite on using galois theory to prove hardness results .",
    "we also thank the anonymous referees for pointing out an error in our discussion of related work and acknowledge various helpful comments from dan cranston , erin chambers , and sariel har - peled .",
    "advanced micro devices , inc . , oct 2004 .",
    "http://www.amd.com/us-en/assets/content_type/    white_papers_and_tech_docs/30430.pdf[http://www.amd.com / us - en / assets / content_type/    white_papers_and_tech_docs/30430.pdf ] .",
    "brooks , p.  bose , s.e .",
    "schuster , h.  jacobson , p.n .",
    "kudva , a.  buyuktosunoglu , j .- d .",
    "wellman , v.  zyuban , m.  gupta , and p.w .",
    "power - aware microarchitecture : design and modeling challenges for next - generation microprocessors . , 20(6):2644 , 2000 .",
    "chen , t .- w .",
    "kuo , and h .-",
    "power - saving scheduling for weakly dynamic voltage scaling devices . in _ proc .",
    "9th workshop on algorithms and data structures _",
    ", number 3608 in lncs , pages 338349 , 2005 .",
    "chudak and d.b .",
    "approximation algorithms for precedence - constrained scheduling problems on parallel machines that run at different speeds . in _ proc .",
    "8th annual acm - siam symp . discrete algorithms _ , pages 581590 , 1997 .",
    "f.  xie , m.  martonosi , and s.  malik .",
    "compile - time dynamic voltage scaling settings : opportunities and limits . in _ proc .",
    "2005 acm sigplan conf . on programming language design and implementation _ ,",
    "pages 4962 , 2003 ."
  ],
  "abstract_text": [
    "<S> we consider offline scheduling algorithms that incorporate speed scaling to address the bicriteria problem of minimizing energy consumption and a scheduling metric . for makespan , </S>",
    "<S> we give linear - time algorithms to compute all non - dominated solutions for the general uniprocessor problem and for the multiprocessor problem when every job requires the same amount of work . </S>",
    "<S> we also show that the multiprocessor problem becomes np - hard when jobs can require different amounts of work .    for total flow , </S>",
    "<S> we show that the optimal flow corresponding to a particular energy budget can not be exactly computed on a machine supporting arithmetic and the extraction of roots . </S>",
    "<S> this hardness result holds even when scheduling equal - work jobs on a uniprocessor . </S>",
    "<S> we do , however , extend previous work by pruhs et al . to give an arbitrarily - good approximation for scheduling equal - work jobs on a multiprocessor . </S>"
  ]
}