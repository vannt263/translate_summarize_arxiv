{
  "article_text": [
    "the min - cut max - flow theorem by ford and fulkerson @xcite is one of the most important theorems in graph theory .",
    "it catches a min - max relation between two fundamental graph problems .",
    "this theorem leads to many effective algorithms and much theory for flow problems as well as graph cut problems . due to the great applications of it , researchers have interests to seek more similar min - max formulas in various kinds of flow and cut problems . in this paper",
    ", we consider the _ maximum multiterminal flow problem _ , a generalization of the basic maximum flow problem .    in the maximum flow problem , we are given two terminals ( source and sink ) and asked to find a maximum flow between the two terminals .",
    "a natural generalization of the maximum flow problem is the famous _ maximum multicommodity flow problem _ , in which , a list of pairs of source and sink for the commodities is given and the objective is to maximize the sum of the simultaneous flows in all the source - sink pairs subject to the standard capacity and flow conservation requirements .",
    "the maximum multiterminal flow problem is one of the most important special cases of the maximum multicommodity flow problem . in it , a set @xmath3 of more than one terminal",
    "is given and the list of source - sink pairs is given by all pairs of terminals in @xmath3 .",
    "the extensions of the maximum flow problem have been extensively studied in the history .",
    "readers are referred to a survey  @xcite .",
    "a dual problem of the maximum multiterminal flow problem is the _ minimum multiterminal cut problem _ , in which we are asked to find a minimum set of edges whose removal disconnects each pair of terminals in the graph .",
    "the minimum multiterminal cut problem is a generalization of the minimum cut problem .",
    "when there are only two terminals , the min - cut max - flow theorem shows that the value of the maximum flow equals to the value of the minimum cut in the graph .",
    "however , when there are more than two terminals , the equivalence may not hold . consider a star with three leaves .",
    "each leaf is a terminal and each of the three edges has capacity @xmath4 .",
    "the flow value of a maximum multiterminal flow is @xmath5 ( a flow of size @xmath6 routed between every pair of the three terminal pairs ) , whereas the size of a minimum multiterminal cut is @xmath7 .",
    "in fact , cunningham  @xcite has proved a min - max theory for the pair of problems : the size of a minimum multiterminal cut is at most @xmath8 times of the flow value of a maximum multiterminal flow .",
    "a similar min - max theory for the maximum multicommodity flow problem and its dual problem is presented in @xcite .    in the maximum multiterminal flow problem , each edge is assigned a nonnegative capacity and a flow routed between a terminal pair is allowed to take any feasible fraction , whereas in the _ integral multiterminal flow problem _ , a flow is allowed to take a nonnegative integer and we are asked to find a maximum flow under this restriction .",
    "clearly , we can simply assume that all edge capacities of the integral multiterminal flow problem are nonnegative integers .",
    "the integral multiterminal flow problem is different from the maximum multiterminal flow problem .",
    "we can see in the above example , the flow value of a maximum integral multiterminal flow is @xmath4 .",
    "the special case of the integral multiterminal flow problem where all edges have unit capacities is also known as the _ @xmath3-path problem _ , in which we are asked to find the maximum number of edge - disjointed paths between different terminal pairs .    in this paper",
    ", we study the maximum multiterminal flow problem in trees and give linear - time algorithms for both fractional and integer versions , which improve the best previous algorithms by a factor of @xmath2  @xcite .",
    "note that the maximum ( integral ) multicommodity flow problem in trees is np - hard and there is a @xmath9-approximation algorithm for it  @xcite .",
    "the rest of the paper is organized as follows",
    ". section  [ pre1 ] introduces basic notations on flows and cuts , and reviews important min - max theorems for fractional and integer versions of maximum multiterminal flow problem .",
    "section  [ sec : tree - instance ] discusses instances with rooted trees , and introduces notations necessary to build a dynamic programming method over the set of @xmath0 instances of rooted subtrees of a given instance .",
    "informally `` a blocking flow '' in a rooted tree instance is defined to be a flow in the tree currently pushing maximal flows among terminals except for the terminal designated as the root .",
    "section  [ sec : basic ] shows several properties of blocking flows , and presents a representation of flow values of blocking flows .",
    "section  [ sec : main_lemma ] provides a main technical lemma that tells how to compute the representation of flow values of blocking flows and how to construct a maximum flow from the representations .",
    "based on the lemma , section  [ sec : algorithm ] gives a description of a linear - time algorithm for computing the representations of flow values of blocking flows and constructing a maximum flow from the representations .",
    "finally section  [ conclusions ] makes some concluding remarks .",
    "this section introduces basic notations on flows and cuts , and reviews important min - max theorems for fractional and integer versions of maximum multiterminal flow problem .",
    "let @xmath10 denote the set of nonnegative reals , and @xmath11 denote the set of nonnegative integers .",
    "* graphs and instances * + we may denote by @xmath12 and @xmath13 the sets of vertices and edges of an undirected graph @xmath14 , respectively .",
    "let @xmath15 denote a simple undirected graph with a vertex set @xmath16 and an edge set @xmath17 , and let @xmath1 and @xmath18 denote the number of vertices and edges in a given graph .",
    "let @xmath19 be a subset of vertices in @xmath14 .",
    "let @xmath20 denote the set of edges with one end - vertex in @xmath21 and the other in @xmath22 , where @xmath23 for a vertex @xmath24 is denoted by @xmath25 .",
    "let @xmath26 denote the graph obtained from @xmath14 by removing the vertices in @xmath21 together with the edges in @xmath27 .",
    "for a vertex subset @xmath3 , let @xmath28 be the set of all paths @xmath29 with end - vertices @xmath30 with @xmath31 .",
    "an instance @xmath32 of a maximum flow problem consists of a graph @xmath14 , a set @xmath3 of vertices called terminals , and a capacity function @xmath33 .",
    "* flows * + for a function @xmath34 , @xmath35 for a subset @xmath19 is denoted by @xmath36 .",
    "a function @xmath37 is called a _ flow _ in an instance @xmath38 if there is a function @xmath39 such that @xmath40 where @xmath41 is the flow value sent along path @xmath42 , and such a function @xmath43 is called a _ decomposition _ of a flow @xmath44 .",
    "a flow @xmath44 is called _ integer _ if it admits a decomposition @xmath43 such that @xmath45 for all paths @xmath46 ( note that @xmath44 may not be integer even if @xmath47 for all edges @xmath48 ) .    a flow @xmath44 is called _ feasible _ if @xmath49 for all edges @xmath48 .",
    "the _ flow value _",
    "@xmath50 is defined to be @xmath51 , and a feasible flow @xmath44 that maximizes @xmath50 is called _ maximum_.    * cut - systems * + a subset @xmath21 of vertices is called a _ terminal set _ ( or a _ @xmath52-set _ ) if @xmath53 and @xmath21 induces a connected subgraph from @xmath14 .",
    "cut - system _ of @xmath3 is defined to be a collection @xmath54 of disjoint @xmath55 terminal sets @xmath56 , @xmath57 , where @xmath54 is not required to be a partition of @xmath16 . for a cut - system @xmath54 of @xmath3 , let @xmath58 . for any pair of a feasible flow @xmath44 and a cut - system @xmath54 of @xmath3 in @xmath38 , it holds @xmath59 cherkasskii  @xcite proved the next result .",
    "ibaraki _ et al . _",
    "@xcite proposed an @xmath60-time algorithm for computing a maximum flow @xmath44 in a graph @xmath14 with @xmath1 vertices and @xmath18 edges .",
    "@xcite proved a characterization of the maximum multiterminal flow problem and gave an @xmath61-time algorithm for the maximum multiterminal flow problem in bounded treewidth graphs , where @xmath62 is an exponential function of the number @xmath55 of terminals .",
    "this algorithm runs in linear time only when @xmath55 is restricted to a constant .",
    "an integer version of the multiterminal flow problem is defined as follows .",
    "let @xmath63 have integer capacities @xmath64 , @xmath48 . recall that an integral flow @xmath44 is a flow which can be decomposed into integer individual flows @xmath43 , i.e. , @xmath65 .",
    "an instance @xmath38 is called _ inner - eulerian _",
    "if all edge capacities @xmath66 , @xmath48 are integers and @xmath67 is an even integer for each non - terminal vertex @xmath68 .",
    "it is known that any inner - eulerian instance admits a pair of a maximum integral flow @xmath44 and a cut - system @xmath54 with @xmath69  @xcite . in general",
    ", there is no pair of an integral flow @xmath44 and a cut - system @xmath54 with @xmath69 even for trees .",
    "we review a min - max theorem on the integer version as follows .",
    "assume that @xmath64 , @xmath48 .",
    "a component @xmath70 in the graph @xmath71 is called an _",
    "odd set _ in @xmath54 if @xmath72 is odd .",
    "let @xmath73 denote the number of odd sets in @xmath71 .",
    "for each odd set @xmath74 , at least one unit of capacity from @xmath72 can not be used by any feasible integral flow @xmath75 .",
    "hence since each path in @xmath28 goes through edges in @xmath76 of a @xmath52-set for exactly two terminals @xmath57 , we see that , for any decomposition @xmath43 of @xmath44 , @xmath77 mader @xcite proved the next result .    for trees with @xmath1 vertices , an @xmath78-time algorithm for computing a maximum integral flow @xmath44",
    "is proposed @xcite , while no strongly - polynomial time algorithm is known to general graphs ( e.g. , see @xcite ) .",
    "in the rest of this paper , we assume that a given instance @xmath79 consists of a tree @xmath15 , a terminal set @xmath3 and an integer capacity @xmath64 for each @xmath48",
    ". we simply call an integral flow a _ flow_.    this section discusses instances with rooted trees , and introduces notations necessary to build a dynamic programming method over the set of @xmath0 instances of rooted subtrees of a given instance",
    ".    if a vertex @xmath80 is not a leaf of @xmath14 , i.e. , @xmath81 is of degree @xmath82 , then we can split the instance at the cut - vertex @xmath81 into @xmath83 instances , and it suffices to find a maximum flow in each of these instances . also we can split a vertex @xmath68 of degree @xmath84 into @xmath85 vertices that induce a tree with edges of capacity sufficiently larger without losing the feasibility and optimality of the instance . in the rest of paper , we assume that @xmath3 is the set of leaves of @xmath14 , and the degree of each non - leaf is 3 , and @xmath86 for all edges @xmath48 , as shown in fig .  [",
    "fig : instance_integer1 ] .    for a leaf @xmath24 in @xmath14 ,",
    "let @xmath87 denote the edge incidenet to @xmath81 . for two vertices @xmath88 ,",
    "let @xmath89 denote the path connecting @xmath90 and @xmath81 in the tree @xmath14 .",
    "for a subset @xmath91 of vertices , let @xmath92 denote the set of all paths @xmath93 with @xmath94 .    in a tree instance",
    "@xmath38 , a _ flow _ admits a function @xmath95 such that @xmath96 where @xmath97 is the flow value sent along path @xmath29 . for a flow @xmath44 , a path @xmath46",
    "is called a _ positive - path _ if @xmath44 admits a decomposition @xmath43 such that @xmath98 .    for a path @xmath42 in @xmath14 , and an integer @xmath99 ( possibly @xmath100 , the function @xmath101 obtained from @xmath102 by setting @xmath103 for all edges @xmath104 and @xmath105 for all edges @xmath106",
    "is denoted by @xmath107 .",
    "such that the degree of each internal vertex is 3 and all capacities are positive integers , where terminal @xmath108 is chosen as the root . ]",
    "* rooted tree * + choose a terminal @xmath109 , and regard @xmath14 as a tree rooted at @xmath108 , which defines a parent - child relationship among the vertices in @xmath14 . in a rooted tree @xmath14 , we write an edge @xmath110 such that @xmath90 is the parent of @xmath81 by an ordered pair @xmath111 . for an edge @xmath112 , any edge @xmath113",
    "is called a _ child - edge _ of @xmath114 , and @xmath114 is called the _ parent - edge _ of @xmath115 .",
    "let @xmath116 be a subset of vertices in @xmath117 such that @xmath116 induces a connected subgraph from @xmath14 .",
    "then there is exactly one edge @xmath118 such that @xmath119 and @xmath90 is the parent of @xmath81 , and we call the edge @xmath120 the _ parent - edge _ of @xmath116 while any other edge in @xmath121 is called a _ child - edge _ of @xmath116 . for an edge @xmath122 ,",
    "let @xmath123 denote the set of vertex @xmath90 and all the descendants of @xmath81 including @xmath81 itself , @xmath124 denote the graph induced from @xmath14 by @xmath125 , and let @xmath126 , where we remark that @xmath127 .",
    "let @xmath128 denote an instance @xmath129 induced from @xmath38 by the vertex subset @xmath125 , where we remark that @xmath90 is included as a terminal in the instance @xmath128 .",
    "* blocking flows * + informally `` a blocking flow '' in a rooted tree instance is defined to be a flow in the tree currently pushing maximal flows among terminals except for the terminal designated as the root .",
    "let @xmath54 be a cut - system of @xmath130 in @xmath128 for some edge @xmath112 .",
    "an odd set @xmath74 in @xmath131 is called an _",
    "odd set _ of a terminal set @xmath132 if the parent - edge of @xmath74 is a child - edge of @xmath21 , where @xmath133 implies @xmath134 . for each terminal",
    "set @xmath135 , let @xmath136 denote the family of odd sets of @xmath21 , i.e. , @xmath74 of @xmath54 whose parent - edge @xmath137 is a child - edge of @xmath21 .",
    "[ fig : odd_set ] illustrates a cut - system @xmath54 and the family @xmath138 .     and",
    "the family @xmath138 for a terminal set @xmath139 . ]    for a function @xmath140 , let @xmath141 $ ] denote the set of edges @xmath48 such that @xmath142 .",
    "let @xmath44 be a feasible flow of @xmath128 for an edge @xmath112 .",
    "we call a terminal set @xmath135 with @xmath143 _ blocked _ ( or _ blocked by @xmath44 _ ) if @xmath144 and call @xmath54 _ blocked _ ( or _ blocked by @xmath44 _ )",
    "if all terminal sets in it are blocked by @xmath44 .    for each vertex @xmath145 , we define @xmath146 to be the set of vertices @xmath147 reachable from @xmath148 by a path @xmath149 from @xmath148 to the common ancestor @xmath150 of @xmath148 and @xmath151 using edges in @xmath152 $ ] and by a path @xmath153 from @xmath150 to @xmath151 using edges in @xmath154 $ ] . in other words",
    ", we travel an edge @xmath115 upward if @xmath155 and downward if @xmath156 from @xmath148 to @xmath151 . by the definition of @xmath146",
    ", we can see that @xmath146 induces a connected subgraph , the parent - edge @xmath115 of @xmath146 satisfies @xmath157 , and any child - edge @xmath115 of @xmath146 satisfies @xmath158 .",
    "we call @xmath44 _ blocking _ if @xmath159 is a cut - system of @xmath130 blocked by @xmath44",
    ". let @xmath160 denote the set of integers @xmath161 such that @xmath128 has a blocking flow @xmath162 .    * interval computation * + our dynamic programming approach to compute the maximum flow value updates the set of flow values of blocking flows recursively .",
    "as it will be shown in section  [ sec : basic ] , such a set of flow values always is given by an interval that consists of consecutive odd or even integers , and we here introduce a special operation on such types of intervals .",
    "for two reals @xmath163 with @xmath164 , let @xmath165 $ ] denote the set of reals @xmath148 with @xmath166 .    for two integers @xmath167 , the set @xmath168 of consecutive odd or even integers",
    "is denoted by @xmath169 , where @xmath170 . for two sets @xmath171 of nonnegative integers , let @xmath172 denote the set of nonnegative integers",
    "@xmath173 over all @xmath174 and @xmath175 . in particular , for sets @xmath176 and @xmath177 , we observe that @xmath178    given an integer @xmath179 , we can find in @xmath180 time three integers @xmath181 , @xmath182 and @xmath183 $ ] such that @xmath184 . to see this ,",
    "assume that @xmath185 without loss of generality , and let @xmath186 be the minimum element in @xmath187 with @xmath188 , where @xmath189 .",
    "observe that @xmath190 and @xmath191 . hence if @xmath192 then let @xmath193 and @xmath194 ; otherwise @xmath195 , @xmath196 and @xmath197 .",
    "this section shows several properties of blocking flows , and presents a representation of flow values of blocking flows .",
    "we first observe two lemmas on some properties of blocking flows .",
    "the next lemma tells how to obtain a maximum flow and a minimum cut - system in an instance @xmath128 .",
    "we prove that all edges @xmath48 satisfies the following conditions ( a ) and ( b ) by an induction of depth of edges .",
    "+ * ( a ) * @xmath160 is given by @xmath198 with some integers @xmath199 and @xmath200 such that    1 .",
    "for each leaf - edge @xmath114 , it holds @xmath201 ; 2 .   for each non - leaf - edge @xmath114 with two child - edges @xmath202 and @xmath203 , it holds @xmath204 ) \\cup \\{c(e)\\}.\\ ] ] that is , for @xmath205 , where @xmath206 and @xmath207 where edge @xmath202 ( resp .",
    ", @xmath208 is called _ dominating _ if @xmath209 ( resp . , @xmath210 )",
    ", it holds that @xmath211    * ( b ) * if @xmath112 has a dominating child - edge @xmath113 , then there is a terminal @xmath212 such that @xmath213 holds for any decomposition @xmath43 of a blocking flow @xmath44 to @xmath128 and @xmath214 consists of dominating edges .",
    "+ a path consisting of dominating edges is called a _ dominating path_. fig .  [",
    "fig : instance_integer2 ] shows the pairs @xmath215 and @xmath216 for all edges @xmath48 in the instance @xmath32 in fig .",
    "[ fig : instance_integer1 ] computed according to ( [ eq : update-1 ] ) and ( [ eq : update-2 ] ) .     and @xmath217 in ( [ eq : update-1 ] ) and @xmath218 in ( [ eq : update-2 ] ) for each edge @xmath48 in the instance @xmath32 in fig .",
    "[ fig : instance_integer1 ] , where each pair of @xmath199 and @xmath200 is depicted in bold while that of @xmath219 and @xmath217 in gray .",
    "the dominating edges are depicted in thick lines . ]    assuming that each edge with depth at least @xmath83 satisfies conditions ( a ) and ( b ) , we prove that any edge @xmath114 with depth @xmath220 satisfies the statements in the next lemma , which indicates not only conditions ( a ) and ( b ) for the edge @xmath114 but also how to construct a blocking flow in @xmath128 from blocking flows in @xmath221 and @xmath222 of the child - edges @xmath202 and @xmath203 of @xmath114 .",
    "this section provides a main technical lemma that tells how to compute the representation of flow values of blocking flows given by conditions ( a ) and ( b ) , and how to construct a maximum flow from the representations .",
    "based on , this section gives a description of a linear - time algorithm for computing the representations of flow values of blocking flows and constructing a maximum flow from the representations .    by ( ii ) and ( iv ) , we see by induction that every edge in @xmath17 satisfies conditions ( a ) and ( b ) . by ( iii ) and ( v ) , we know how to construct a blocking flow in @xmath128 for some edge @xmath114 from blocking flows in @xmath221 and @xmath222 of the child - edges @xmath202 and @xmath203 of @xmath114 . by , it suffices to construct a blocking flow in @xmath223 with @xmath224 . for this , we first compute the integers @xmath219 , @xmath217 , @xmath199 and @xmath200 for each edge @xmath48 according to ( [ eq : update-1 ] ) and ( [ eq : update-2 ] ) selecting edges in @xmath17 in a non - increasing order of depth , and identify all the dominating edges in @xmath17 .",
    "next we apply ( iii ) and ( v ) repeatedly from edge @xmath225 to descendants of the edge in a top - down manner to construct a blocking flow in @xmath223 with @xmath224 . to implement the algorithm to run in linear time ,",
    "we avoid reducing flow values repeatedly along part of a dominating path .",
    "we let @xmath226 to store the total amount of decrements over each dominating edge @xmath114 , i.e. , @xmath226 is the summation of @xmath227 in ( v ) over all dominating edges @xmath115 that are ancestors of @xmath114 . an entire algorithm is given by the following compact and succinct description .     with @xmath224 in the instance @xmath32 in fig .",
    "[ fig : instance_integer1 ] such that @xmath228 , where the pair of flow value @xmath229 and capacity @xmath66 for each edge is indicated by @xmath230 beside the line segment for edge @xmath114 .",
    "the non - zero values for @xmath231 and @xmath226 are indicated beside the corresponding edge @xmath114 . ]    an instance @xmath63 rooted at a terminal @xmath109 . + a maximum flow @xmath44 in @xmath32 .",
    "+ compute the integers @xmath219 , @xmath217 , @xmath199 and @xmath200 for each edge @xmath48 according to ( [ eq : update-1 ] ) and ( [ eq : update-2 ] ) selecting edges in @xmath17 in a non - increasing order of depth ; + @xmath232 ; @xmath233 ; + @xmath234 ; + / * denote by @xmath202 and @xmath203 the child - edges of @xmath114 * / choose integers @xmath235 and @xmath236 such that + @xmath237 for some integer and @xmath183 $ ] ; + @xmath238 ;   @xmath239 ; + @xmath240 and @xmath241 for @xmath242 @xmath243 + / * @xmath244 , where @xmath245 is dominating , and exactly one of @xmath202 and @xmath203 is + dominating ; assume that @xmath202 is dominating without loss of generality .",
    "* / + @xmath246 ;   @xmath247 ;   @xmath248 ; + @xmath249 ;   @xmath250 +     for the blocking flow @xmath44 in fig .",
    "[ fig : instance_integer3 ] , where the set @xmath251 induces from @xmath14 two odd sets @xmath252 and @xmath253 , and it holds that @xmath254 . ]",
    "the algorithm runs in linear time , because it executes an @xmath180-time procedure to each edge in @xmath17 in constant time .",
    "[ fig : instance_integer3 ] illustrates a result obtained from the instance @xmath32 in fig .",
    "[ fig : instance_integer1 ] by applying the algorithm .    after a maximum flow @xmath44",
    "is constructed , a minimum cut - system @xmath54 to a given instance can be constructed in linear time by .",
    "[ fig : instance_integer4 ] illustrates the cut - system @xmath255 for the blocking flow @xmath44 in fig .",
    "[ fig : instance_integer3 ] , which indicates that the flow @xmath44 is maximum because @xmath256 holds .    from the above argument , the next theorem is established .",
    "[ th : main ] given a tree instance @xmath38 , a feasible integral multiflow @xmath44 and a cut - system @xmath257 with @xmath258 can be found in @xmath0 time and space , where @xmath44 is a maximum integral multiflow .",
    "in this paper , we revealed a recursive formula among flow values of blocking flows in rooted instances and designed a linear - time dynamic programming algorithm for computing a maximum integral flow in a tree instance .",
    "the optimality of flows is ensured by the property of the formula , by which we can always construct the corresponding dual object , i.e. , a minimum cut - system that satisfies ( [ ingeter - min - max ] ) by equality ."
  ],
  "abstract_text": [
    "<S> in this paper , we study the problem of finding an integral multiflow which maximizes the sum of flow values between every two terminals in an undirected tree with a nonnegative integer edge capacity and a set of terminals . in general , it is known that the flow value of an integral multiflow is bounded by the cut value of a cut - system which consists of disjoint subsets each of which contains exactly one terminal or has an odd cut value , and there exists a pair of an integral multiflow and a cut - system whose flow value and cut value are equal ; i.e. , a pair of a maximum integral multiflow and a minimum cut . in this paper </S>",
    "<S> , we propose an @xmath0-time algorithm that finds such a pair of an integral multiflow and a cut - system in a given tree instance with @xmath1 vertices . </S>",
    "<S> this improves the best previous results by a factor of @xmath2 . regarding a given tree in an instance as a rooted tree , we define @xmath0 rooted tree instances taking each vertex as a root , and establish a recursive formula on maximum integral multiflow values of these instances to design a dynamic programming that computes the maximum integral multiflow values of all @xmath0 rooted instances in linear time </S>",
    "<S> . we can prove that the algorithm implicitly maintains a cut - system so that not only a maximum integral multiflow but also a minimum cut - system can be constructed in linear time for any rooted instance whenever it is necessary . </S>",
    "<S> the resulting algorithm is rather compact and succinct . </S>"
  ]
}