{
  "article_text": [
    "the lhcb @xcite experiment is one of the four main experiments that will be performed using the large hadron collider ( lhc ) , presently under construction at the european organization for nuclear research ( cern ) in geneva , switzerland .",
    "the experiment is devoted to the precision measurements of cp violation in the b meson system .",
    "the simulation applications are of major importance both for the studies during the construction phase as well as during the running of the detector .",
    "the assumption is that they produce data ( `` digits '' ) that would normally be available from the electronics of the detector .",
    "this simulated data is then fed , in the same way as the real data would be , into the reconstruction and further on into the analysis applications .",
    "the lhcb collaboration is moving to a complete chain of object - oriented event processing software . with the new reconstruction and analysis applications already used in production",
    ", the simulation one is getting close to that stage as well .",
    "the new object - oriented lhcb detector simulation application ( gauss ) is based on the geant4 @xcite toolkit and is currently entering its final phase of development .",
    "it is built within the lhcb software framework ( gaudi ) @xcite which is also used by the rest of the lhcb event - processing software .",
    "the existence of the common underlying framework allows sharing of many basic services such as persistency , interactivity , histograming , etc .",
    "in addition , it provides a natural way of having common sources of data such as the detector geometry , the magnetic field map , or the particle properties .",
    "the actual interfacing of geant4 toolkit to the gaudi framework is done by giga ( gaudi interface to geant4 application ) @xcite .",
    "the organization of this paper is the following .",
    "we will start with a brief presentation of the general structure of the gaudi framework followed by a description of the structure of gauss application itself .",
    "after that , we will discuss a few selected aspects of giga which are particularly relevant as the functional design of gauss is concerned . finally we will briefly present a few results of our physics validation and we will formulate some conclusions .",
    "the philosophy of the gaudi framework is that each application consists of a set of `` algorithms '' which represent some self - contained functional parts of the programme .",
    "those algorithms behave like pluggable components .",
    "they can be easily added , removed , executed in series or separately .",
    "the job configuration , i.e. specification of the sequence of algorithms to be executed , setting of their options , defining input and output files , etc , is done via job options files , which are simply text files , read at the beginning of each job execution .    on the other hand ,",
    "the existence of the so - called transient data stores which are used for the communication between the algorithms , guarantees the lack of mutual dependence between them .",
    "for instance , if an algorithm uses as an input mchits to produce mcdigits , the only thing it requires is that there are some mchits available in the transient store .",
    "it does not care whether those mchits come from a simulation algorithm which was executed beforehead or from a data file which was used to populate the transient store .",
    "moreover , if at the moment when the algorithm requested the mchits from the transient store they were not there yet , it will be the framework who will take care of reading the appropriate file ( if available of course ) in order to populate the store . from the point of view of the algorithm",
    ", it will be a completely transparent procedure , and in particular the implementation of the algorithm will not depend in any way on the persistent technology used .",
    "such an architecture allows a modular structure of the whole simulation programme , introducing less coupling between different stages of the simulation job .",
    "the existence of the transient stores , provides also natural `` communication channels '' with other sets of algorithms such as the reconstruction algorithms or the visualization algorithms . in some sense ,",
    "an `` application '' becomes a less well - defined entity , since one is able to combine any collection of algorithms into one executable sequence .",
    "one can imagine , for instance , running the simulation algorithms together with the visualization ones , providing a display of each simulated event .",
    "it is useful to stress here once again , that those different algorithms can be developed completely independently without implementing any specific interfaces between them ( apart from the ones defined by the framework to communicate with the transient stores ) .",
    "the gauss simulation application consists of three major blocks responsible for the event generation , detector response simulation and digitization ( see figure  [ figgauss ] ) .",
    "these three blocks are completely independent and , using the features of the underlying framework described in the previous section , can be executed separately reading ( saving ) the data from ( to ) the persistent stores .",
    "the format used to store the generated event ( the output from the mc generators ) is the hepmc event record @xcite . as far as the simulated event ( the output from the detector simulation )",
    "is concerned , gauss uses the lhcb event format @xcite , which is then used as the input format for the reconstruction applications .",
    "as mentioned before , due to the existence of the underlying software framework , providing in particular the persistency service , the simulation application is fully independent from the underlying persistent technology . at the present moment , for instance",
    ", we are using the root @xcite file format to save the information on the disk , but this could be changed at any time , without affecting the actual simulation application .",
    "we will now go a little bit more into details and describe the first two blocks from figure  [ figgauss ] , i.e. the event generation and the interfacing to the simulation toolkit .",
    "the third block , being the digitization , is very detector - specific and therefore we will not discuss it here .      the main event generator for gauss is pythia @xcite . it is used to produce both the minimum - bias as well as the signal events .",
    "the actual decays of the b - hadrons are performed , however , using a dedicated decay package called evtgen @xcite .",
    "both pythia , as well as evtgen are wrapped inside special gaudi algorithms ( called pythiaalg and evtdecayalg , respectively ) which make them to behave like pluggable components ( callable and controllable ) in the gaudi framework .",
    "the configuration of those mc generators can , therefore , be done via the gaudi job options interface .        as mentioned before ,",
    "the generated events are stored in the hepmc event record , which also serves to communicate between different generators ( decay packages ) .",
    "the entire sequence of the event generation is shown on figure  [ figgener ] .",
    "first pythia is called to generate the primary event",
    ". the settings of pythia are such that most of the physical particles ( those known to geant4 ) are declared stable , and therefore the generated event consists , at this stage , of one physical vertex ( store in the transient store in the hepmc format ) .",
    "such an approach seems to be natural from the point of view of the detector response simulation which is performed afterwards .",
    "the exception , however , are the decays of the b - hadrons .",
    "those are the most important in our simulation , and we want to have full control over them in order to be able to explicitly generate particular decay channels . in order to do so , the selection algorithm ( setdecayalg ) is called , which marks particles ( normally b - hadrons ) that should be decayed by the specialized package ( the others will be left to be decayed by geant4 ) .",
    "once that selection is performed , the evtdecayalg is executed .",
    "it calls evtgen for each particle marked beforehead and adds the decay products to the hepmc tree .",
    "geant4 will later on use that information in the context of the forced decay channel mechanism .",
    "the final step in the event generation sequence is to call an additional algorithm which simulates the smearing of the position of the primary vertex ( due to the size of the colliding beams ) .",
    "it generates the spread in the x , y and z directions according to distributions specific for the lhc beams , which are then used to shift the position of all the vertices in the event .",
    "such an architecture is very flexible and can be easily extended .",
    "it is very easy to add other ( replace ) event generators , without any change to the code of the remaining simulation chain . having more than one event generator implemented ( wrapped ) in the form of the gaudi algorithm",
    ", one can run different configurations ( replacing , for example pythia with some other primary generator ) without any recompilation but simply with different job options .",
    "the detailed description of the technical aspects of the gaudi interface to geant4 application ( giga ) can be found in @xcite and therefore we will not repeat it here . we will rather concentrate on a few selected aspects of giga which are particularly interesting from the point of view of the overall simulation application .    as mentioned before",
    ", one of the advantages of building the simulation application on top of the common software framework is that it allows us to use sources of detector data , i.e. geometry description , magnetic field map , etc , shared with other applications such as the reconstruction or the visualization .",
    "the conversion of the lhcb geometry model to the geant4 geometry tree is done at the beginning of each simulation job by a specialized geometry conversion service .",
    "it is worth noting that the actual geometry configuration can be also changed via the job options , without any need for recompilation .",
    "the specification of `` sensitive volumes '' is done via simple declarations of the corresponding sensitive detectors class names in the persistent description of the shared geometry data ( for which we use the xml format ) .",
    "one can add , remove or change sensitive detectors by simply editing the geometry description file .",
    "those changes are then taken into account at the runtime and the instantiation of the required sensitive detectors is done using the abstract factory approach .",
    "the overall structure of the way geant4 is interfaced to the gaudi environment is shown in figure  [ figgiga ] .",
    "as we can see there , the actual geant4 engine is put behind a faade pattern which provides a unified high level abstract interface .",
    "a set of abstract interfaces implemented within giga allows loading from the gaudi transient stores into geant4 , detector geometry , primary event data , etc .",
    "it also makes it possible to use standard gaudi services such as magnetic field service or job options service to be used by the geant4 application .",
    "let us mention as well that giga , through the existence of a specialized class called gigarunmanager , provides internal access to the geant4 event loop .",
    "the standard g4runmanager::beamon method is never used in the context of giga .",
    "the construction of the primary events is done via direct calls to g4event::addprimaryvertex method and the simulation is triggered by direct calls to the g4eventmanager::processoneevent method .",
    "this gives us more control over the each simulation run and provides us an extra flexibility as far as the construction of the primary events is concerned .",
    "probably the most interesting feature of giga as the interface to the underlying framework is that all the `` actions '' such as event action , tracking action , etc , are instantiated using the abstract factory approach and therefore can be loaded at the runtime .",
    "such a design insures a very flexible structure of the simulation program and allows running different configuration by changing only the job options .",
    "as far as the physics lists are concerned , they are implemented in the form of geant4 modular physics list and also are instantiated via the abstract factories .",
    "this again makes the architecture flexible , facilitating validation of different physics lists without a need of recompilation .",
    "let us illustrate the interplay between the underlying framework and the geant4 toolkit on the concrete example of the sensitive detectors and hit creation .",
    "figure  [ sensdet ] shows the whole chain starting from the sensitive volume declaration and ending with the creation of the lhcb event model hits .",
    "once geant4 is aware of the given sensitive detector ( instantiated using an abstract factory , as described at the beginning of this section ) , it will follow the standard procedure of calling the processhit method every time there is a particle passing by the volume associate to it .",
    "the possible result of that ( if the required conditions are satisfied , like the non - zero charge of the passing particle , etc . ) will be the creation of geant4 hits , stored in the geant4 hit collections .",
    "the last part of the chain will be the conversion of all the created geant4 hits during the given event , into the lhcb event model hits stored afterwards in the gaudi transient data store ( and available for the other algorithms like digitization , or for the serialization ) .",
    "such a conversion is performed by a specialized giga converted at the end of each event .    from this example",
    "we can see that the user does nt actually deal directly with the `` geant4 world '' .",
    "he declares the sensitive volumes in the `` gaudi world '' and he gets the final output ( simulated hits and particles ) back in the gaudi transient store .",
    "the physics validation of the new lhcb simulation program is done in two ways : by comparing with the test beam data and by comparing with the geant3 simulation results .",
    "the former approach is used to validate particular processes like the rayleigh scattering or the cherenkov radiation in the material of the ring imaging cherenkov counters ( rich ) , or hadronic interaction models for the calorimeter .",
    "the later approach is used more to test the overall simulation chain , together with the event generation phase .",
    "what we will briefly present in this section is a few comparison plots between the geant3 and geant4 results for the tracker - like devices in the lhcb .",
    "the vertex locator ( velo ) is the lhcb subdetector inside which the interaction point is placed .",
    "it consists of a series of silicon sensors and its purpose is to perform precise measurements of tracks close to the interaction region .",
    "those measurements are essential for the reconstruction of production and decay vertices of the beauty- and charm - hadrons .",
    "we have examined several different histograms ( multiplicities , distributions in space , energy depositions , time of flight , etc ) produced using simulated data and they all show a good agreement between the geant3 and geant4 based applications . in the figures  [ velomult ] and [ veloenergy ] we see for instance",
    "the multiplicity of simulated velo hits and the energy deposition in the silicon of sensors .            in some cases , like for example for the time of flight distribution shown on figure  [ tofvel ]",
    ", we see that geant4 plot looks actually `` smoother '' for the lower values , which is probably due to the higher precision compared to geant3 .          the outer tracking detector in lhcb consist of drift cells with straw - tube geometry . in the configuration of the tracking stations the emphasis is on tracking precision in the ( x , z ) magnet bending plane .",
    "in order to validate the new simulation program , we have again compared a number of different distributions . in most of the cases ,",
    "as we can see for instance for the momentum distribution of particles creating hits shown in figure  [ otmomentum ] , we have not observed any significant discrepancies between the events simulated by geant4 and geant3 .",
    "the only clearly visible difference was in the time of flight distribution , which we can see in figure  [ ottof ] .",
    "it seems that in the geant3 simulation there are more particles with longer time of flights ( and less with shorter ones , since the overall multiplicity seems to be the same ) than in the geant4 simulation .",
    "this result is not yet understood and we are currently investigating any possible cause of that difference .",
    "over the last year the geant4 based simulation application for the lhcb experiment has evolved from a set individual components to a fully functional program .",
    "its major parts such as the interfaces to monte - carlo generators , the interface to the geant4 toolkit , as well as different sensitive detectors are , to a large extend , implemented . due to the underlying software framework ,",
    "many of the components , such as the detector description , are shared between the simulation as well as the other applications like the reconstruction or the visualization . the interface between geant4 and that framework extensively uses the concept of abstract factories which makes the simulation environment very flexible and easily configurable .",
    "the lhcb is now testing its new simulation application .",
    "with most of the results being positive , the move to the geant4 based simulation is being prepared .",
    "the lhcb is planing to start extensive test productions in the summer 2003 and to move definitely to the geant4-based simulation application at the beginning of the year 2004 .",
    "9 i. belyaev et al . , `` integration of geant4 with the gaudi framework '' , chep2001 proceedings m. dobbs , j.b .",
    "hansen , `` the hepmc c++ monte carlo event record for high energy physics '' , computer physics communications , vol . 134",
    "( 2001 ) 41 - 46 , atl - soft-2000 - 001 ( atl - com - soft-2000 - 001 ) t. sjostrand , p. eden , c. friberg , l. lonnblad , g. miu , s. mrenna and e. norrbin , computer physics commun . 135 ( 2001 )"
  ],
  "abstract_text": [
    "<S> we describe the lhcb detector simulation application ( gauss ) based on the geant4 toolkit . the application is built using the gaudi software framework , which is used for all event - processing applications in the lhcb experiment . </S>",
    "<S> the existence of an underlying framework allows several common basic services such as persistency , interactivity , as well as detector geometry description or particle data to be shared between simulation , reconstruction and analysis applications . </S>",
    "<S> the main benefits of such common services are coherence between different event - processing stages as well as reduced development effort . </S>",
    "<S> the interfacing to geant4 toolkit is realized through a faade ( giga ) which minimizes the coupling to the simulation engine and provides a set of abstract interfaces for configuration and event - by - event communication . </S>",
    "<S> the gauss application is composed of three main blocks , i.e. event generation , detector response simulation and digitization which reflect the different stages performed during the simulation job . </S>",
    "<S> we describe the overall design as well as the details of gauss application with a special emphasis on the configuration and control of the underlying simulation engine . </S>",
    "<S> we also briefly mention the validation strategy and the planing for the lhcb experiment simulation . </S>"
  ]
}