{
  "article_text": [
    "of the steps reconstructing events in the cms detector , tracking is the most computationally complex , most sensitive to activity in the detector , and least amenable to parallelization .",
    "the speed of online reconstruction has a direct impact on how effectively interesting data can be selected from the 40 mhz collisions rate , while the speed of the offline reconstruction limits how much data can be processed for physics analyses .",
    "the large time spent in tracking will become even more important in the hl - lhc era of the large hadron collider .",
    "the increase in event rate will increase the detector occupancy ( `` pile - up '' , pu ) , leading to the exponential gain in time taken to perform track reconstruction illustrated in figure  [ fig : eff_tracking_pileup]@xcite .        at the same time , due to power density and physical scaling limits , the performance of single cpus has slowed , with advances in performance increasingly relying on multi - core or highly parallel architectures . in order to sustain the higher hl - lhc processing requirements without compromising physics performance and timeliness of results , the lhc experiments must make full use of highly parallel architectures . as a potential solution",
    ", we are investigating adapting the existing cms track finding algorithms and data structures@xcite to make efficient use of highly parallel architectures , such as intel s xeon phi and nvidia gpus . in this paper",
    "we provide an update to results most recently reported at chep2015@xcite and connecting the dots 2016@xcite , including our first results using intel threaded building blocks ( tbb ) instead of openmp for multi - threading support .",
    "our targets for parallel processing are track reconstruction and fitting algorithms based on the kalman filter@xcite ( kf ) .",
    "kf - based tracking algorithms are widely used to incorporate estimates of multiple scattering directly into the trajectory of the particle .",
    "other algorithms , such as hough transforms@xcite and cellular automata adapted from image processing applications , are more naturally parallelized .",
    "however , these are not the main algorithms in use at the lhc today .",
    "the lhc experiments have an extensive understanding of the physics performance of kf algorithms ; they have proven to be robust and perform well in the difficult experimental environment of the lhc .",
    "kf tracking proceeds in three main stages : seeding , building , and fitting .",
    "seeding provides the initial estimate of the track parameters based on a few hits in the innermost regions of the detector .",
    "realistic seeding is currently under development and will not be reported here .",
    "track building projects the track candidate outwards to collects additional hits , using the kf to estimate which hits represent the most likely continuation of the track candidate .",
    "track building is by far the most time consuming step of tracking , as it requires branching to explore multiple candidate tracks per seed after finding compatible hits on a given layer . when a complete track has been reconstructed , a final fit using the kf is performed to provide the best estimate of the track s parameters .",
    "to take full advantage of parallel architectures , we need to exploit two types of parallelism : vectorization and parallelization .",
    "vector operations perform a single instruction on multiple data at the same time , in lockstep . in tracking , branching to explore multiple candidates per seed can interfere with lock - step single - instruction synchronization .",
    "multi - thread parallelization aims to perform different instructions at the same time on different data .",
    "the challenge to tracking is workload balancing across different threads , as track occupancy in a detector is not uniformly distributed on a per event basis .",
    "past work by our group has shown progress in porting sub - stages of kf tracking to support parallelism in simplified detectors ( see , e.g. our presentations at acat2014@xcite and chep2015@xcite ) .",
    "as the hit collection is completely determined after track building , track fitting can repeatedly apply the kf algorithm without branching , making this a simpler case for both vectorization and parallelization ; first results in porting kf tracking to xeon and xeon phi were shown at acat2014@xcite .",
    "the implementation of a kf - based tracking algorithm consists of a sequence of operations on matrices of sizes from @xmath0 up to @xmath1 . in order to optimize efficient vector operations on small matrices , and to decouple the computational details from the high level algorithm ,",
    "we have developed a new matrix library .",
    "the _ matriplex _",
    "memory layout uses a matrix - major representation optimized for loading vector registers for simd operations on small matrices , using the native vector - unit width on processors with small vector units or very large vector widths on gpus .",
    "matriplex includes a code generator for defining optimized matrix operations , with support for symmetric matrices and on - the - fly matrix transposition .",
    "patterns of elements that are known by construction to be zero or one can be specified , and the resulting code will be optimized to eliminate unnecessary register loads and arithmetic operations .",
    "the generated code can be either standard c++ or macros that map to architecture - specific intrinsic functions .      in order to study parallelization with minimal distractions",
    ", we developed a standalone kf - based tracking code using a simplified ideal barrel geometry with a uniform longitudinal magnetic field , gaussian - smeared hit positions , a particle gun simulation with flat transverse momentum distribution between 0.5 and 10 gev , no material interaction , and no correlation between particles nor decays .",
    "this simplified configuration was used to study vector and parallel performance and to study the performance of different choices of coordinate system and handling of kf - updates .",
    "these studies led to the use of a hybrid coordinate system , using global cartesian coordinates for spatial positions and polar coordinates for the momentum vector .",
    "recently we have begun work on using a more realistic cms detector geometry .",
    "event data from the full cms simulation suite is translated into a simplified form that can be processed by our standalone tracking code . for track building ,",
    "track propagation is performed in two steps , an initial propagation to the average radius of the barrel or average z of the endcap disk , followed by a second propagation to the exact hit position for each candidate hit .",
    "kf updates are performed on the plane tangent to the hit radius .",
    "these choices make it possible to use a simplified form of the cms geometry , avoiding the complexities of the full detector description .",
    "achieving acceptable vector and multi - thread parallel performance requires careful attention to detail .",
    "regular profiling with intel vtune amplifier and attention to the compiler optimization reports helped identify many obstacles , some relatively subtle .",
    "we found that references to unaligned locations in aligned data structures may force the compiler into unaligned accesses , reducing vector performance ; prefetching , scatter / gather instructions and other intrinsics need to be used in an organized , systematic fashion ; unwanted conversions from float to double can reduce effective vector width ; variables should be declared in the smallest scope possible , and use `` const '' wherever possible .        for multi - thread parallelism ,",
    "the two most critical issues we found were memory management and workload balancing . to avoid memory stalls and cache conflicts , we reduced our data structures to the minimum necessary for the algorithm , optimized our data structures for efficient vector operations , and minimized object instantiations and dynamic memory allocations .",
    "workload balancing for track building is complicated by the uncertain distribution of track candidates and hits , which can result in large tail effects for a naive static partitioning scheme .",
    "we found that using intel threaded building blocks tasks , with smaller units of work and dynamic `` work - stealing '' , let us naturally express thread - parallelism in a way that allowed more dynamic allocation of resources and reduced the tail effects from uneven workloads .",
    "figure  [ fig : tbb - vtune ] illustrates the difference in tail effects between our initial openmp implementation with static workload partitioning compared to dynamic partitioning using tbb .",
    "the primary platforms discussed are a xeon phi 7120p `` knights corner '' ( knc ) processor and xeon e5 - 2620 `` sandy bridge '' ( snb ) system , with brief discussion of preliminary results on a xeon phi 72xx `` knights landing '' ( knl ) processor and the nvidia tesla k20/k40 and pascal p100 .",
    "scaling on the more traditional xeon architecture is in most cases near optimal , so the discussion primarily focus on the more highly parallel architectures .",
    "vector and multi - thread absolute performance and scaling improved mostly from our chep2015 results , with vectorization scaling showing the most improvement , shown in figure  [ fig : fit - compare ] .",
    "this result is somewhat deceptive , as there are significantly more operations performed in the latest results due to the change of momentum to polar coordinates ( from global cartesian coordinates ) .",
    "the change of coordinate system results in significantly more complicated off - diagonal terms in the propagation matrix .",
    "the cost of these additional calculations was nearly exactly canceled by improvements to the memory and cache usage , and better vectorization .",
    "on knc , we achieve a vector speedup of nearly eight times , approximately half the theoretical maximum with a vector width of 16 .",
    "multi - thread scaling is near ideal up to 61 threads , reaching nearly 100x speedup with 200 threads .",
    "the knc processor used has 61 physical cores , but must alternate between hyper - threads to fill all the available instruction slots , so ideal scaling would be a speedup by a factor of 122 .",
    "the `` knee '' in the scaling curve indicates that with two threads per core we are not achieving full utilization , possibly due to remaining memory bandwidth or cache effects .",
    "the change in coordinate system and other improvements significantly improved kf update stability , resulting in the much improved track parameter resolution and hit finding efficiency , shown in figure  [ fig : physics - perf ] .",
    "the absolute time for single - thread track building was reduced by  90% due to the performance tuning discussed in section  [ sec : tuning ] .",
    "however , effective vectorization of the track building remains a challenge , as shown in figure  [ fig : build - vector ] .",
    "the combinatorial nature of the track building algorithm , which examines and adds a variable number of hit candidates in each layer , results in many branching operations that impede vectorization , as well as adding frequent repacking operations to keep the full vector width utilized .",
    "the larger and more complicated data structures used for selecting hit candidates also results in poorer data locality and higher bandwidth requirements .",
    "we are continuing to investigate possible strategies for improving the track building vector performance .",
    "compared to our previous results , as shown in figure  [ fig : build - parallel ] , multi - thread track scaling has improved significantly , scaling within 15% of ideal up to 61 threads and reaching approximately 80x speedup with 200 threads .",
    "this result is very similar to the multi - thread scaling of the much simpler track fitting task .",
    "combining the improvements to the single - thread track finding efficiency and multi - thread scaling , track building with 200 threads is nearly 100 times faster than our chep2015 result .",
    "these improvements illustrate the results of careful performance tuning combined with the more flexible workload balancing enabled by the switch to tbb for multi - threading .",
    "preliminary results for track building using the simplified cms geometry discussed in section  [ sec : scenarios ] are shown in figure  [ fig : cms - scaling ] .",
    "these results show better vector scaling , which we believe is due to the two - step propagation , first to the average radius and then to the hit radius .",
    "the propagation routine vectorizes well , so the additional computation results in more time spent in routines with good vector register utilization .",
    "multi - thread scaling is significantly worse than our `` toy '' setup . for this test",
    "we use seeds from the first step of the cms iterative tracker , which yields around 500 seed tracks per event , compared to 20,000 monte carlo `` truth '' seeds in our toy tests .",
    "repeating our tests with the idealized scenario with 500 tracks per event shows scaling similar to the cms geometry tests .",
    "this is not surprising , as with only one event being processed at a time we need @xmath2 seeds to fill the vector registers of 200 threads .",
    "we are currently working on processing multiple events at a time in a way that allows us to use seeds from multiple events in the same matriplex so that we can fully use the vector registers .",
    "we have run very preliminary , untuned tests of our track building on a knl system , with the results shown in figure  [ fig : knl - perf ] .",
    "on knl we see better vectorization than knc , and similar multi - thread scaling .",
    "we find it encouraging that our track building algorithms show decent scaling performance on snb , knc and knl without significant platform - specific scaling beyond simply matching the platforms vector register width .",
    "we have also implemented the track fitting algorithms and a simpler ( non - combinatoric ) version of the track building on nvidia gpus using the cuda toolkit .",
    "the gpu version uses a templated gplex structure that matches the interfaces and layout of the matriplex class , allowing substantial code sharing of the kf routines , while the higher - level `` steering '' routines are somewhat different due to different setup and memory management requirements of the different platforms .",
    "the gpu implementations show good scaling of the kf routines but the total time tends to be dominated by setup times copying data structures to the gpu .",
    "preliminary tests with a pascal p100 gpu , shown in figure  [ fig : gpu - perf ] , show better scaling with simpler memory management .",
    "we have made significant progress in parallelized and vectorized kalman filter - based end - to - end tracking r&d on xeon and xeon phi architectures , with some initial work on gpus . through the use of a variety of tools",
    "we have developed a good understanding of bottlenecks and limitations of our implementation which has led to further improvements . through the use of our own matriplex package and intel threaded building blocks ( tbb ) ,",
    "we can achieve good utilization of unconventional highly parallel vector architectures .",
    "we are currently focusing on processing fully realistic data , with encouraging preliminary results .",
    "this work is supported by the u.s",
    ". national science foundation , under the grants phy-1520969 , phy-1521042 , phy-1520942 and phy-1120138 , and by the u.s .",
    "department of energy .",
    "9 cerati g 2015 _ pos vertex _ * 2014 * 037 the cms collaboration 2014 _ jinst _ * 9 * p10009 cerati g _ et al . _ 2015 _ jop : conf . series _ * 664 * 072008 cerati g _ et al .",
    "_ 2016 _ epj web conf . _ * 127 * 00010 fruehwirth r 1987 _ nim _ a * 262 * 444 - 450 halyo v , legresley p , lujan p , karpusenko v and vladimirov a 2014 _ jinst _ * 9 * p04005 cerati g _ et al .",
    "_ 2014 _ jop : conf . series _",
    "* 608 * 012057"
  ],
  "abstract_text": [
    "<S> limits on power dissipation have pushed cpus to grow in parallel processing capabilities rather than clock rate , leading to the rise of `` manycore '' or gpu - like processors . in order to achieve the best performance </S>",
    "<S> , applications must be able to take full advantage of vector units across multiple cores , or some analogous arrangement on an accelerator card . </S>",
    "<S> such parallel performance is becoming a critical requirement for methods to reconstruct the tracks of charged particles at the large hadron collider and , in the future , at the high luminosity lhc . </S>",
    "<S> this is because the steady increase in luminosity is causing an exponential growth in the overall event reconstruction time , and tracking is by far the most demanding task for both online and offline processing . </S>",
    "<S> many past and present collider experiments adopted kalman filter - based algorithms for tracking because of their robustness and their excellent physics performance , especially for solid state detectors where material interactions play a significant role . </S>",
    "<S> we report on the progress of our studies towards a kalman filter track reconstruction algorithm with optimal performance on manycore architectures . </S>",
    "<S> the combinatorial structure of these algorithms is not immediately compatible with an efficient simd ( or simt ) implementation ; the challenge for us is to recast the existing software so it can readily generate hundreds of shared - memory threads that exploit the underlying instruction set of modern processors . </S>",
    "<S> we show how the data and associated tasks can be organized in a way that is conducive to both multithreading and vectorization . </S>",
    "<S> we demonstrate very good performance on intel xeon and xeon phi architectures , as well as promising first results on nvidia gpus . </S>"
  ]
}