{
  "article_text": [
    "in 1948 , shannon published his seminal paper on _ information theory _ @xcite . in shannon s model",
    ", there is a sender , a receiver , and a ( probably noisy ) channel , or pipe .",
    "the sender transmits strings of bits over the channel , and the receiver records them on arrival . to let the receiver know when to stop listening",
    ", the message must have a certain pre - arranged structure .",
    "the message may end with a binary equivalent of `` over and out , '' or perhaps the length of the message is sent first .",
    "what matters is that as soon as the last bit is sent , the reciever can calculate that that bit was the end of the message ; such structures are known as _",
    "instantaneous codes_.    not all instantaneous codes are created equal : some can send the same information with far fewer bits than others .",
    "the sender and receiver can agree on a _ dictionary _ that associates common strings with short encodings and infrequent strings with longer ones .",
    "if the message is typical , this will save considerably on the message size . if the message is atypical , there s more information in it , more that is unexpected .",
    "the shortest possible message size is related to the amount of information the string contains relative to the chosen dictionary , the string s _",
    "complexity_.    in the mid-1960 s , kolmogorov @xcite , solomonoff @xcite , and chaitin @xcite independently proposed the idea of using programs to describe the complexity of strings .",
    "this gave birth to the field of _ algorithmic information theory _",
    "( ait ) @xcite .",
    "the kolmogorov complexity @xmath1 of a string @xmath2 is the length of the shortest program in the programming language @xmath3 whose output is @xmath2 .",
    "solomonoff proposed a weighted sum over the programs , but it was dominated by the shortest program , so his approach and kolmogorov s are roughly equivalent .",
    "chaitin added the restriction that the programs themselves must be codewords in an instantaneous code , giving rise to _ prefix - free ait_. in this model , complexities become true probabilities , and shannon s information theory applies directly .",
    "given a prefix - free domain , there is the natural distribution @xmath4 , where @xmath5 is the length of @xmath6 in bits .",
    "one can then ask the question , `` what is the probability , given this distribution of inputs , that a program will output _ some _ string and halt ? ''",
    "chaitin discovered that the bits of this `` halting probability '' , after an initial computable prefix , are pure information @xcite : the length of the shortest program that computes the first @xmath7 bits of the halting probability and stops is at least @xmath8 bits long . to calculate one more bit , you have to add at least one more bit to your program ; there is no description of the strings of bits shorter than the strings themselves , modulo some fixed constant .",
    "the bits also contain all the information about whether each program will halt or not ; chaitin called this halting probability an omega number .    with the advent of accessible computers , chaitin proposed studying _ concrete _ ait  theorems about specific programming languages , with positive integers as error terms rather than the phrase `` some fixed constant . ''",
    "to study concrete prefix - free ait , chaitin proposed two universal languages , or machines : one was a variant of lisp @xcite ; the other an 11-instruction `` register machine '' @xcite .",
    "we know of no other universal chaitin machines in the literature .",
    "lisp is a complex language , and the register machine , while small , is far from minimal . to foster the study of concrete ait , we propose a few new minimalist chaitin machines .",
    "fix an alphabet @xmath9 .",
    "the set of all finite strings of elements of @xmath9 is denoted @xmath10 .",
    "a turing machine @xmath11 is a partial recursive function @xmath12 , where `` partial '' means that @xmath11 may be undefined on some inputs ; this handles the cases where the program runs forever .    a turing machine @xmath11",
    "is called a _ chaitin machine _ if its domain @xmath13 is prefix - free , i.e. for all @xmath14 , either @xmath6 is a prefix of @xmath15 , @xmath15 is a prefix of @xmath6 , or @xmath6 is identical to @xmath15 .    for any @xmath16 and chaitin machine @xmath11 ,",
    "the program - size complexity of @xmath6 with respect to @xmath11 is defined as @xmath17    a chaitin machine @xmath3 is called _ universal _ with respect to a set of machines @xmath18 if @xmath19 for any @xmath16 and for any @xmath20 .",
    "it is helpful to consider a chaitin machine in shannon s original sender - pipe - receiver model .",
    "borrowing terminology from concurrent programming , the pipe is a shared resource .",
    "the input to the machine is held by the sender , a producer .",
    "the sender tries to put its bits into the pipe ; it blocks if there are more bits to send and the pipe is full . when there are no more bits to send , the sender halts .",
    "the chaitin machine is the receiver , a consumer . from time to time it tries to get bits out of the pipe , and blocks if the pipe is empty .",
    "the entire computation is said to halt if the sender halts , the chaitin machine halts , and the pipe is empty . _",
    "codewords _ are those inputs @xmath6 for which the computation halts , _ i.e. _ @xmath21 .",
    "this model makes it easy to see why the domain of a chaitin machine is prefix - free : any extension of a codeword would cause the sender to block , a condition called _ overflow _ ; any prefix of it would cause the chaitin machine to block , a condition called _",
    "underflow_. a universal chaitin machine usually reads in a self - delimiting program description , the _ prefix _ , and then simulates that program acting on the remainder of the input .",
    "if the input does not contain a proper program description , the universal machine blocks ; we call this condition a _ syntax error_.    a _ blank - endmarker machine _ ( bem ) @xmath22 is a chaitin machine in which one symbol of @xmath9the blank endmarker , hereafter denoted @xmath23is reserved .",
    "all but the last symbol of the codeword are taken from the alphabet @xmath24 , and the codeword is terminated with @xmath23 .",
    "@xmath22 will request input until it reads the symbol @xmath23 , after which no more input will be requested .",
    "it is this blank endmarker that allows the codewords to be prefix - free : removing the endmarker will cause an underflow ; any symbols following an endmarker will cause an overflow .",
    "we may construct a bem @xmath25 from an arbitrary turing machine @xmath11 defined on the alphabet @xmath9 as follows .",
    "first , define the alphabet @xmath26 over which @xmath25 operates .",
    "next , define @xmath27 , i.e. we append the symbol @xmath23 to each string on which @xmath11 halts .",
    "no prefix or extension of a codeword is in the domain of @xmath25 , since every codeword in the domain has exactly one @xmath23 as the last symbol .",
    "a _ universal bem _ is a bem defined on the alphabet @xmath28 that is universal with respect to all such bems .    a universal bem @xmath29 exists",
    ".    let @xmath30 denote the concatenation of @xmath7 0 symbols .",
    "then @xmath29 can read in in the self - delimiting prefix @xmath31 and simulate @xmath32 on the remainder of the input .",
    "[ bemnotuniv]no bem is universal with respect to all chaitin machines defined on @xmath28 .    for a bem to be universal over a set @xmath33 , it must be able to represent the domain of machines in @xmath33 with only a constant increase in the length of the codewords .",
    "however , this is impossible .    consider the following chaitin machine @xmath34 : inputs are concatenations of a self - delimiting program @xmath35 and a string @xmath36 .",
    "the program @xmath35 , when executed , outputs the length of the string , @xmath37 .",
    "the machine @xmath34 first reads @xmath35 , then executes it to get @xmath7 , and then reads @xmath6 .",
    "finally , @xmath34 outputs the string @xmath6 .",
    "the number of @xmath7-symbol strings @xmath38 . on the other hand ,",
    "the number of @xmath39-symbol strings available to a bem is only @xmath40 , because it may only use the symbol @xmath23 once at the end of the codeword .",
    "since @xmath41 grows faster than @xmath40 , there is no constant @xmath42 such that @xmath43 for all @xmath7 .",
    "we define the relation `` universal - with - respect - to '' and denote it @xmath44 .",
    "let @xmath45 and @xmath46 .",
    "for all @xmath47 we have the following :    let @xmath48 be chaitin machine that is universal with respect to all chaitin machines defined over @xmath49 , @xmath32 be a bem that is universal with respect to all bems defined over @xmath50 , and @xmath51 be a chaitin machine that is universal with respect to all chaitin machines defined over @xmath50",
    ". then    1 .",
    "@xmath52 , but [ cba ] 2 .",
    "@xmath53 [ bc ] 3 .   and @xmath54 .",
    "[ ab ]    the first part of ( [ cba ] ) holds because bems are chaitin machines and @xmath51 was chosen to be universal with respect to that set .",
    "the second part of ( [ cba ] ) holds because @xmath32 can simulate @xmath55 , the bem constructed from @xmath48 : it reads a self - delimiting program for @xmath48 and begins simulating it .",
    "if the program requests an input and @xmath32 reads @xmath23 , then @xmath32 loops forever , simulating the underflow condition .",
    "if the program halts , then @xmath32 reads one more symbol , @xmath6 ; if @xmath56 , then @xmath32 loops forever , simulating overflow .",
    "if the program loops forever on its own , then so does @xmath32 .",
    "thus the domain of @xmath32 is the same as that of @xmath48 modulo the final @xmath23 .",
    "item ( [ bc ] ) is theorem [ bemnotuniv ] .",
    "finally , ( [ ab ] ) holds because @xmath48 is not allowed to use @xmath23 .",
    "it must use a self - delimiting description of the input string , and the shortest self - delimiting version of a string @xmath6 grows like @xmath57 @xcite , which violates the error bound for universality .",
    "in this section , we review four languages that greatly influenced our designs , and point out why these are not universal chaitin machines .      lambda calculus formed the basis of church s 1936 negative answer @xcite to hilbert s _ entscheidungsproblem _ ( decision problem ) : is there an algorithm for deciding whether first - order statements are universally valid ?",
    "he showed first that stating the equivalence of two lambda terms was a first - order predicate , and then that there is no recursive ( or computable ) function that can compute whether two terms are equivalent . turing independently proved the same result the same year @xcite , and when he heard of church s result , was quickly able to show that his machines compute the same class of functions as church s lambda terms .",
    "everything in lambda calculus is a function ; there are no built - in types , data structures , branching instructions , or constants , and the only operation is functional composition , or _",
    "application_. functions take functions as input and return functions as output . to denote his functions , church used a slightly different notation than most mathematicians are used to : rather than @xmath58 church wrote @xmath59 application is denoted by concatenation or parentheses , and is left - associative : @xmath60 is the same as @xmath61 .",
    "there is a _ universal basis _ consisting of the two functions ( or _ combinators _ ) @xmath62 that is , the function represented by a lambda term may also be represented by a combination of these combinators .",
    "for example , the identity function @xmath63 : @xmath64 in fact , there is an algorithm called _ lambda abstraction _ that reduces any lambda term to a combination of @xmath33 and @xmath65 , and @xmath66 combinators is included merely for convenience ; it can , of course , be replaced by @xmath67 . ]",
    "that eliminates the need for any variables . to abstract away all the variables in a term , begin with the innermost variable @xmath68 and apply the following rules ,",
    "then repeat for the remaining variables .",
    "1 .   @xmath69 2 .",
    "@xmath70 3 .",
    "if a term @xmath71 does not depend on @xmath68 , then @xmath72    for example , the reverse - application combinator is @xmath73 .",
    "abstracting @xmath74 yeilds @xmath75 ; abstracting @xmath76 yeilds @xmath77 .",
    "a term is said to be in _ normal form _ if the variable to be applied has not been bound to a value .",
    "for example , @xmath78 is a normal form , but @xmath79 gets reduced to the normal form @xmath80 , and @xmath81 gets reduced to the normal form @xmath65 .",
    "reducing a term to normal form is equivalent to a turing machine reaching a halting state .",
    "some lambda terms do not have normal forms ; these correspond to computations that never finish .",
    "for example , the term @xmath82 reduces to itself ; it is the lambda - calculus equivalent of an infinite loop .",
    "the output of a lambda calculus computation is the normal form of the term , if it exists . since",
    "normal forms can be enumerated @xmath83 @xmath84 gdel , there are bijections from normal forms to natural numbers and to binary strings . for the purposes of this paper , where we define machines to be partial recursive functions from binary strings to binary strings , it is convenient to choose the latter .",
    "lambda calculus alphabet consists of parentheses , the symbols for the lambda operator and the dot , and symbols for variables .",
    "though one rarely needs more than twenty - six variables , the formalism allows for subscripts ; therefore , digits for subscripts and an end - of - subscript marker are also included .",
    "let @xmath85 be the number of symbols in the alphabet .",
    "since there infinitely many chaitin machines that halt on each string @xmath6 , lambda calculus needs to be able to encode an arbitrary string with only a constant overhead in order to be a universal chaitin machine . when a bit string increases by one symbol , the number of representable strings increases by a factor of @xmath85 .",
    "however , because of the well - formedness requirement that parentheses balance in a lambda term , the number of codewords with one more symbol increases by a smaller factor .",
    "any encoding of strings necessarily suffers from a slight expansion , and so lambda calculus fails to reach the constant overhead bound .",
    "there are more requirements for a well - formed lambda term that we are ignoring here .",
    "we perform an exact analysis of a less restrictive case where we have only one parenthesis symbol and one combinator in the next section ; we ll see that it , too , fails to be a universal chaitin machine .",
    "iota @xcite is a minimalist language created by chris barker .",
    "the universal basis @xmath86 suffices to produce every lambda term , but it is not necessary .",
    "there are one - combinator bases , known as _",
    "universal combinators_. iota is a very simple universal combinator , @xmath87 , denoted @xmath88 . to make iota unambiguous",
    ", there is a prefix operator , @xmath89 , for application .",
    "valid programs are preorder traversals of full binary trees . in the tables that follow",
    ", brackets @xmath90 $ ] denote taking the semantics of the argument .",
    "l|l syntax & semantics +   + @xmath91 & @xmath92([f_1])$ ] + @xmath93 & @xmath87 +    fokker @xcite proposed a different universal combinator , @xmath94 , which is slightly larger , but recovers @xmath33 and @xmath65 with fewer applications .    like lambda calculus",
    ", there will be a normal form of the iota term if the program halts .",
    "as before , because normal forms are denumerable , we can make a bijection between binary strings and normal forms , ordering both lexically , and output the matching string .",
    "another alternative , advocated by ben rudiak - gould @xcite , is to restrict the output to a subset of normal forms , such as lists of booleans .",
    "any program whose normal form is not in this subset is defined to output the empty string , while the list of booleans is converted directly to a binary string .",
    "we illustrate the execution of two simple iota programs below :    @xmath95    notice that at step ( [ internal ] ) we performed an application within an internal branch .",
    "iota is confluent : it does not matter in which order the applications are carried out , because there are no side - effects .",
    "iota is not quite a universal chaitin machine because of the requirement that codewords be preorder traversals of a full binary tree .",
    "there are @xmath51 full binary trees with @xmath96 leaves , where @xmath51 is the @xmath7th catalan number , giving a codeword of length @xmath97 ; asymptotically , @xmath98 .",
    "thus , if we increase the length of a codeword by two bits , the number of representable strings only increases by @xmath99 bits .",
    "it is asymptotically close to being a universal chaitin machine , but does nt quite make it . again , any encoding of strings within iota will necessarily suffer from a slight expansion , and will not satisfy the @xmath0 error requirement .",
    "zot @xcite is a continuized form of iota . here , @xmath89 is a combinator rather than an operator ; in barker s words , it is treated `` lexically '' rather than `` syncategoremically . ''",
    "the initial continuation is the trivial one , and the current continuation is applied to each combinator in turn .",
    "this allows the program to get access to each bit of input individually .",
    "it also makes zot a nice g del numbering , since every blank - terminated binary string is a valid zot codeword and every computable function is represented .",
    "l|l syntax & semantics +   + @xmath100 & @xmath101([b])$ ] + @xmath102 & @xmath103 + @xmath104 & @xmath105 + @xmath106 & @xmath107 + @xmath108 & @xmath109 , where @xmath110 + & and @xmath111 is an output monad .",
    "+    barker also includes an operator which i have denoted @xmath112 , which allows the program to interact with an output monad . it is not strictly necessary : we can ignore the @xmath112 operator and , like iota , consider the normal form of the current continuation to be the output .",
    "zot is a bem , and therefore not a universal chaitin machine .",
    "binary lambda calculus ( blc ) @xcite is a language created by john tromp in resonse to chaitin s claim @xcite that `` lambda calculus is even simpler and more elegant than lisp , but it s unusable .",
    "pure lambda calculus with combinators @xmath33 and @xmath65 , it s beautifully elegant , but you ca nt really run programs that way , they re too slow . ''",
    "tromp noted that `` there is however nothing intrinsic to @xmath113 calculus or cl that is slow ; only such choices as church numerals for arithmetic can be said to be slow , but one is free to do arithmetic in binary rather than in unary , '' and proposed blc specifically for studying concrete ait .",
    "rather than follow church s original notation , tromp used de bruijn @xcite notation , which eliminates the need to use the variable name in the both lambda prefix and in the body of a term .",
    "instead , @xmath7 refers to the variable bound by the @xmath7th enclosing @xmath113 .",
    "l|l syntax & semantics +   + @xmath114 & @xmath92([f_1])$ ] + @xmath115 & @xmath116 $ ] + @xmath117 & @xmath7 +    any remaining bits are converted to a @xmath118-terminated list of combinators @xmath65 and @xmath119 to which the program is applied .",
    "the list is constructed using the pairing cobinator @xmath120 , which has the property that @xmath121 and @xmath122 .",
    "thus @xmath65 and @xmath119 behave like booleans with respect to @xmath111 .",
    "tromp explicitly states that the normal form of the resulting blc term is the output .",
    "prefix - free blc uses a rather nonstandard approach . instead of defining a computer",
    "whose domain is prefix - free , tromp redefines the way output is handled : a program is prefix free if and only if @xmath123 where @xmath124 is a lambda term encoding a list whose first few members are the bit string @xmath35 , followed by the tail @xmath125 , where @xmath125 may be infinite . since @xmath125 is potentially infinite and is arbitrary , @xmath3 can not output @xmath125 without processing all of the bits of @xmath35 and returning @xmath125 as part of the output .",
    "this guarantees that no prefix or extension of @xmath35 has the right form , and thus the set of such @xmath35 is prefix - free .",
    "normal blc is a bem , and therefore not a universal chaitin machine ; prefix - free blc is a bem combined with the definition ( * ) , but does not define a chaitin machine whose domain matches the set @xmath126 .",
    "we would like to construct universal chaitin machines from universal bems .",
    "the first step is to get rid of the blank endmarker . in the next section",
    ", we describe an algorithm to extract the ( possibly empty ) subset of the domain of a bem that does not depend on reading the blank endmarker to know when to halt .",
    "some bems have the property that their behavior after the final read request does not depend on the result of that request . in a bem @xmath22 ,",
    "the last request is always for the @xmath23 symbol , but in these cases , the program does not need the @xmath23 to know when to halt .",
    "we can use this property to define a chaitin machine whose domain is a prefix - free set of programs such that if @xmath127 , then @xmath128 .",
    "we construct @xmath34 in the following way :    1 .",
    "@xmath34 simulates @xmath22 up to the point where the first read request is made ; if no read requests are made , then @xmath34 loops forever . after a read request , no read is actually performed ; rather , 2 .   [ read ] @xmath34 simulates the behavior of @xmath22 for all the possibilites for that symbol up to the point where one of the branches is about to halt or make another read request .",
    "3 .   at that point",
    ", the read for the previous symbol is actually performed ; if there are no more symbols , then @xmath34 blocks ; otherwise the @xmath34 selects the appropriate branch and the abandons other branches simulations .",
    "4 .   @xmath34 continues executing that branch until it halts or makes a read request . if the selected branch halts , then @xmath34 halts ( although if there are symbols remaining in the pipe , the sender will block and the computation will fail to halt ) . if the selected branch performs a read request , @xmath34 goes to step ( [ read ] ) .    in this way",
    ", @xmath34 only needs to simulate @xmath129 concurrent branches at a time , and if @xmath22 does not need to read @xmath23 to know when to halt , then that read is never actually performed by @xmath34 .",
    "the domain of @xmath34 is prefix free , since @xmath34 would underflow on any string more than one symbol shorter than a codeword of @xmath22 and overflow on any extension of a codeword of @xmath34 .",
    "a chaitin machine constructed in this way is universal if it can simulate either of the universal machines that chaitin proposed with only an additive constant increase in the size of the input .",
    "the machine constructed in this way from blc is universal .",
    "in this section , we take a small aside to introduce a concept used in one of the proposed chaitin machines below , as well as to introduce a bit of new notation .    church s lambda operator can be seen as an interpreter .",
    "it reads three self - delimiting parameters from the input stream@xmath130 , @xmath131 , and @xmath132builds data structures representing the application of the functions and operators that those parameters describe , and performs alpha and beta reduction on the data structures , calling itself recursively .",
    "if the process of alpha- and beta - reduction reaches a point where it can not continue , it decodes the data structure into the normal form of the lambda term and outputs it as a string of symbols .",
    "since an interpreter is merely a function , we can curry it : the function @xmath113 takes an input @xmath130 and returns a new function @xmath133 ; likewise , the function @xmath133 takes a single input @xmath131 and returns a function @xmath134 ; the function @xmath134 applied to the input @xmath132 yeilds the normal form , if one exists .    since curried functions",
    "take exactly one input , the application operator becomes strictly binary , and the tree of applications is a full binary tree .",
    "programs may be written as preorder traversals of the tree to avoid parentheses .",
    "we adopt the backtick (  ) as a prefix application operator throughout the rest of the paper , which behaves identically to iota s @xmath89 operator ; for example , the lambda term @xmath135 will be written    ",
    " @xmath76   @xmath74   @xmath136   @xmath6 @xmath125 ",
    "@xmath15 @xmath125 +    in appendix [ lc2js ] , we include the javascript source code for a source - to - source filter from this dialect of lambda calculus to javascript .",
    "it supports lazy evaluation and can be trivially modified to work with any eager language with first - class functions , such as perl .",
    "below , we present a chaitin - universal combinator for use in iota .",
    "input requests @xmath137 go via a monad that binds the requests together in lazy - evaluation order .",
    "@xmath137 reads a bit and evaluates to @xmath65 or ` @xmath65 @xmath66 if the bit is @xmath88 or @xmath89 , respectively .",
    "the definition of the combinator is optimized , like fokker s , for the number of applications to recover @xmath138 , and @xmath137 .",
    "codewords are concatenations of programs ( preorder traversals of the application tree ) and ( possibly empty ) input .",
    "rl @xmath139 & =  @xmath65  @xmath65 @xmath137 + @xmath22 & =  @xmath65",
    " @xmath65  @xmath65  @xmath65  @xmath65 ",
    "@xmath65  @xmath65 @xmath65 + @xmath34 & =  ",
    "@xmath113 @xmath6  @xmath6 @xmath22 + @xmath88 & =  ",
    "@xmath6     @xmath6",
    "@xmath34 @xmath139 ",
    "@xmath65 @xmath66 @xmath33 +   + @xmath140 & = @xmath65 + @xmath141 & = @xmath33 + @xmath142 & = @xmath137 +    [ cols= \" < , < \" , ]     this modification of keraia is a universal chaitin machine , since every lisp s - expression has an equivalent lambda term that is directly encodable , and the @xmath137 operator behaves identically to chaitin s @xmath143 operator .",
    "algorithmic information theory has much to say both about physics and philosophy",
    ". it would be nice to experiment with tiny concrete models , but until now , there were only two programming languages that were universal chaitin machines .",
    "we have given examples of two new universal chaitin machines , a modification to universal combinators that allows them to be chaitin - universal , and an algorithm for constructing a chaitin machine from a bem by removing the blank - endmarker and extracting the prefix - free subset of those words .",
    "the complexity of @xmath7 bits of a chaitin omega number is @xmath8 ; calude _ et al .",
    "_ @xcite computed the first 64 bits of an omega number , the halting probability of chaitin s register machine . we know , now , that @xmath42 for that machine is at least 64 .",
    "the machines proposed above are ideally suited for similar computations .",
    "chaitin published an exponential diophantine equation with one parameter @xmath7 which has infinitely many solutions if and only if the @xmath7th bit of @xmath144 ( i.e. the halting probability of a particular universal chaitin machine @xmath34 ) is one @xcite .",
    "these machines should make it possible to producing a smaller instance .",
    "the author would like to thank gregory chaitin and john tromp for helpful discussion , and especially cristian calude for his many comments on an early draft of this paper .",
    "99    barker , c. `` iota and jot : the simplest languages ? '' 2001 .",
    "http://ling.ucsd.edu/~barker/iota/    barker , c. `` zot . ''",
    "http://ling.ucsd.edu/~barker/iota/zot.html    calude , c.  s. _ information and randomness - an algorithmic perspective .",
    "_ 2nd edition , revised and extended , springer - verlag , berlin , 2002 .",
    ", 104    calude , c. , dinneen , m.  j. , and shu , c .- k .",
    "`` computing a glimpse of randomness , '' _ experimental mathematics _ , 2 ( 2002 ) , 369378    chaitin , g.  j. `` on the lengths of programs for computing binary sequences . ''",
    "_ j. assoc .",
    "_ 13 , 549569",
    ". 1966 .",
    "chaitin , g.  j. `` a theory of program size formally identical to information theory , '' _ journal of the acm _ 22 ( 1975 ) , pp",
    ". 329340 .",
    "http://www.cs.auckland.ac.nz/cdmtcs/chaitin/acm75.pdf    chaitin , g.  j. `` algorithmic information theory . ''",
    "_ ibm journal of research and development _ 21 ( 1977 ) , pp .",
    "350359 , 496 .",
    "chaitin , g.  j. _ algorithmic information theory . _ cambridge university press , cambridge , 1987 .",
    "chaitin , g.  j. `` an invitation to algorithmic information theory , '' _",
    "dmtcs96 proceedings _ , springer verlag , singapore , 1997 , pp .",
    "http://www.cs.auckland.ac.nz/cdmtcs/chaitin/inv.html    chaitin , g.  j. `` elegant lisp programs , '' _ people and ideas in theoretical computer science , _ c. calude , ed .",
    "springer - verlag singapore , 1999 , pp .",
    "http://www.cs.auckland.ac.nz/cdmtcs/chaitin/lisp.html    church , a. `` an unsolvable problem of elementary number theory , '' _ american journal of mathematics _ , 58 ( 1936 ) , pp .",
    "345363 .",
    "church , a. `` a note on the _ entscheidungsproblem _ , '' _ journal of symbolic logic _ , 1 ( 1936 ) , pp .",
    "de bruijn , n.  g. `` lambda calculus notation with nameless dummies , a tool for automatic formula manipulation , '' _ indagationes mathematicae _ 34 , 381392 , 1972 .",
    "fokker , j. `` the systematic construction of a one - combinator basis for lambda - terms , '' _ formal aspects of computing _ 4:776780 .",
    "http://www.cs.uu.nl/people/jeroen/article/combinat/combinat.ps    kolmogorov , a.  n. `` three approaches to the quantitative definition of information . '' _ prob .",
    "47 . 1965 .",
    "rudiak - gould , b. `` lazy - k . '' http://homepages.cwi.nl/~tromp/cl/lazy-k.html    shannon , c.  e. `` a mathematical theory of communication , '' _ bell system technical journal _ , vol .",
    "27 , pp . 379423 and 623656 , july and october , 1948 .",
    "http://cm.bell-labs.com/cm/ms/what/shannonday/paper.html    solomonoff , r.  j. `` a formal theory of inductive inferrence i , ii . '' _ inform .",
    "control _ 7 , 122 , 224254 .",
    "tromp , j. `` binary lambda calculus and combinatory logic . ''",
    "sep 14 , 2004 .",
    "http://homepages.cwi.nl/~tromp/cl/lc.pdf    turing , a. `` on computable numbers , with an application to the _ entscheidungsproblem_,''_proceedings of the london mathematical society _ , series 2 , 42 ( 1936 ) , pp 230265 .",
    "errata appeared in series 2 , 43 ( 1937 ) , pp 544546 ."
  ],
  "abstract_text": [
    "<S> in 1975 , chaitin introduced his celebrated omega number , the halting probability of a universal chaitin machine , a universal turing machine with a prefix - free domain . </S>",
    "<S> the omega number s bits are _ algorithmically random_there is no reason the bits should be the way they are , if we define `` reason '' to be a computable explanation smaller than the data itself . since that time , only _ two _ explicit universal chaitin machines have been proposed , both by chaitin himself .    </S>",
    "<S> concrete algorithmic information theory involves the study of particular universal turing machines , about which one can state theorems with specific numerical bounds , rather than include terms like @xmath0 . </S>",
    "<S> we present several new tiny chaitin machines ( those with a prefix - free domain ) suitable for the study of concrete algorithmic information theory . </S>",
    "<S> one of the machines , which we call keraia , is a binary encoding of lambda calculus based on a curried lambda operator . </S>",
    "<S> source code is included in the appendices .    </S>",
    "<S> we also give an algorithm for restricting the domain of blank - endmarker machines to a prefix - free domain over an alphabet that does not include the endmarker ; this allows one to take many universal turing machines and construct universal chaitin machines from them . </S>"
  ]
}