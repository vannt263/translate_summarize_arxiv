{
  "article_text": [
    "consider a distributed system composed of a team of mobile computational entities , called _ robots _ , moving and operating in the euclidean plane @xmath10 , initially each at a distinct point .",
    "each robot can move freely in the plane , and operates in _ look_-_compute_-_move_cycles . during a cycle",
    ", a robot determines the position ( in its own coordinate system ) of the other robots ( _ look _ ) ; it executes a protocol ( which is deterministic and it is the same for all robots ) to determine a destination point ( _ compute _ ) ; and moves towards the computed destination ( _ move _ ) . after each cycle",
    ", a robot may be inactive for an arbitrary but finite amount of time .",
    "the robots are anonymous , without a central control , and oblivious ( i.e. , at the beginning of a cycle , a robot has no memory of any observation or computation performed in its previous cycles ) .",
    "what is computable by such entities has been the object of extensive research within distributed computing ; e.g. , see  @xcite ; for a recent review see  @xcite .",
    "vision and mobility provide the robots with _ stigmergy _ , enabling the robots to communicate and coordinate their actions by moving and sensing their relative positions ; they are otherwise assumed to lack any means of explicit direct communication .",
    "this restriction could enable deployment in extremely harsh environments where communication is impossible or can be jammed .",
    "nevertheless , in many other situations it is possible to assume the availability of some sort of direct communication .",
    "the theoretical interest is obviously for weak communication capabilities .",
    "a model employing a weak explicit communication mechanism is that of _ robots with lights _ , or _ luminous robots _ , initially suggested by peleg  @xcite . in this model , each robot is provided with a local externally - visible _ light _ , which can assume colors from a fixed set .",
    "the robots explicitly communicate with each other using these lights .",
    "the lights are persistent ( i.e. , the color is not erased at the end of a cycle ) , but otherwise the robots are oblivious  @xcite .",
    "notice that a light with only one possible color is the same as no light ; hence the luminous robots model generalizes the classical one .    both in the classical model and in that with lights , depending on the assumptions on the activation schedule and the duration of the cycles , different settings are identified . in the synchronous",
    "setting , the robots operate in rounds , and all the robots that are activated in a round perform their cycle in perfect synchrony . in this case ,",
    "the system is _ fully synchronous _ ( or fsynch ) if all robots are activated at all rounds , and it is _ semi - synchronous _ ( or ssynch ) otherwise . in the _ asynchronous _ setting ( or asynch )",
    ", there is no common notion of time , and no assumption is made on the timing and duration of each computation and movement , other than that it is finite .",
    "( for the ssynchand asynchmodels there are bland fairness assumptions that prevent robots from remaining inactive forever , which are discussed in section  [ s : robotmodels ] ) .",
    "the choice of when a robot is activated ( in ssynch ) and the duration of an activity within a cycle ( in asynch ) is made under the control of an _ adversary _ , or _",
    "scheduler_. similarly , the choices of the initial location of each robot and of its private coordinate system are made under adversarial conditions .",
    "a crucial distinction is whether or not the adversary has also the power to stop a moving robot before it reaches its destination .",
    "if so , the moves are said to be _ non - rigid_. the only constraint is that , if interrupted before reaching its destination , the robot moves at least a minimum distance @xmath11 ( otherwise , the adversary would be able to prevent robots from reaching any destination , in any amount of cycles ) .",
    "if the adversary does not have such a power , the moves are said to be _",
    "rigid_. the model with rigid moves is referred to as rigid , and the other one is called non - rigid .    in the rest of the paper , with abuse of terminology , we will often refer to fsynch , ssynch , or asynchrobots or schedulers ( as opposed to systems ) , and to rigidor non - rigidrobots or schedulers ( as opposed to models ) .",
    "the classical model and the more recent model of robots with lights share a common assumption : that three or more collinear robots are mutually visible .",
    "it can be easily argued against such an assumption , and for the importance of investigating computability when visibility is _ obstructed _ by the presence of other robots : that is , if two robots @xmath12 and @xmath13 are located at @xmath14 and @xmath15 at time @xmath2 , they can see each other if and only if no other robot lies on the segment @xmath16 at that time .",
    "very little is known on computing with obstructed visibility .",
    "in fact , the few studies on obstructed visibility have been carried out in other models : the model of robots in the _ one - dimensional _ space @xmath17  @xcite ; and the so - called _ fat robots _",
    "model , where robots are not geometric points but occupy unit disks , and collisions are allowed and can be used as an explicit computational tool ( e.g. ,  @xcite ) . in our model , collisions can create unbreakable symmetries : since robots are oblivious and anonymous and execute the same protocol , if @xmath18 ( a collision ) , then the activation adversary can force @xmath19 for all @xmath20 if the two robots do not have lights or their lights have the same color . thus , unless this is the intended outcome , collision avoidance is always a requirement for all algorithms in the model considered here .",
    "in this paper we focus on luminous robots in the presence of obstructed visibility , and investigate computing in such a setting .",
    "clearly , obstructed visibility increases the difficulty of solving problems without the use of additional assumptions .",
    "for example , with unobstructed visibility , every active robot can determine the total number @xmath21 of robots at each activity cycle .",
    "with obstructed visibility , unless a robot has a - priori knowledge of @xmath21 and this knowledge is persistently stored , the robot might be unable to decide if it sees all the robots ; hence it might be unable to determine the value @xmath21 .",
    "the main problem we investigate , called mutual visibility , is perhaps the most basic in a situation of obstructed visibility : starting from arbitrary distinct positions in the plane , within finite time the robots must reach a configuration in which they are in distinct locations , they can all see each other , and they no longer move . this problem is clearly at the basis of any subsequent task requiring complete visibility .",
    "notice that this problem does not exist under unobstructed visibility , and has never been investigated before .    among the configurations that achieve mutual visibility ,",
    "a special class is that where all robots are in a strictly convex position ; within that class , of particular interest are those where the robots are on the perimeter of a circle , possibly equally spaced .",
    "the problems of forming such configurations ( respectively called convex formationand circle formation ) have been extensively studied both directly ( e.g. ,  @xcite ) and as part of the more general pattern formationproblem ( e.g. ,  @xcite ) .",
    "unfortunately , none of these investigations consider obstructed visibility , and those algorithms do not work in the setting considered here .",
    "note that a requirement of the mutual visibilityproblem is that robots stop moving after they have reached a configuration in which they all see each other . to this end , we will grant robots the ability to perform a special operation called _ termination _ , after which they can no longer be activated by the scheduler .",
    "the termination operation is especially useful in practice when the robots have to perform several tasks in succession .",
    "of course , even if this operation is not directly available , it can still be simulated via the addition of an extra color , which can be used by a robot to indicate ( to the other robots , as well as to itself ) that it has terminated .",
    "moreover , if the termination operation is removed from the algorithms presented in this paper ( and some straightforward adjustments are made , which do not require extra colors ) , then a weaker form of the mutual visibilityproblem is solved , in which the robots get to permanently see each other , but they never stop moving .",
    "that is , all obstructions are permanently removed , but the termination condition is not met . in some cases , removing the termination operation will even allow us to successfully apply our algorithms to different problems , such as circle formationand near gathering , as discussed in section  [ s : extra ] .      in this paper",
    "we investigate under what conditions luminous robots can solve mutual visibilityand at what cost ( i.e. , with how many colors ) .",
    "we establish a spectrum of results , depending on the power of the adversary , on the number @xmath5 of colors , and on the a - priori knowledge the robots have about the systems .",
    "we first consider the case when the adversary can choose the activation schedule ( in ssynch ) and the duration of each robot s operations ( in asynch ) , but can not interrupt the movements of the robots ; that is , movements are rigid . in this case , we show the following .    [",
    "t : sum1 ] mutual visibilityis solvable without collisions by rigidrobots    * with _ no _ colors in ssynch , if the robots know their number , @xmath21 ; * with @xmath22 colors in ssynch , always ; * with @xmath23 colors in asynch , always .",
    "we then consider the case when the adversary has also the power to interrupt the movements of the robots ; that is , movements are non - rigid .",
    "the only restriction is that there exists a constant absolute length @xmath11 such that , even if a robot s move is interrupted before it reaches the destination , it travels at least a length @xmath24 towards it ( otherwise it many never be able to reach any destination ) . in the case of non - rigid movements , we prove the following .    [",
    "t : sum2 ] mutual visibilityis solvable without collisions by non - rigidrobots    * with _ no _ colors in ssynch , if the robots know @xmath24 and their number , @xmath21 ; * with @xmath22 colors in ssynch , if the robots know @xmath24 ; * with @xmath23 colors in ssynch , always ; * with @xmath23 colors in asynch ,",
    "if the robots agree on the direction of one coordinate axis .",
    "all these results are established constructively .",
    "we present and analyze two protocols , algorithm  [ alg1 ] ( _ shrink _ ) and algorithm  [ alg2 ] ( _ contain _ ) , whose goal is to allow the robots to position themselves at the vertices of a convex polygon , solving convex formation , and thus mutual visibility .",
    "these two algorithms are based on different strategies , and are tailored for different situations . protocol _",
    "shrink _ uses two colors and requires rigid movements , while protocol _",
    "contain _ uses more colors but operates also with non - rigid movements .",
    "we prove their correctness for ssynchrobots ( sections  [ s : ssynch ] and  [ s : ssynch2 ] ) .",
    "we then show how , directly or with simple expansions and modifications of these two algorithms , all the claimed results follow ( sections  [ s : asynch ] and  [ s : extra ] ) . finally , we propose some open problems ( section  [ s : conclusions ] ) .",
    "let us point out that , to prove the correctness of _ shrink _ , we solve a seemingly unrelated problem , communicating vessels , which is interesting in its own right .    as a byproduct of our solutions ,",
    "we provide the first obstructed - visibility solution to a classical problem for oblivious robots : _ collision - less convergence to a point _ ( near - gathering ) ( see  @xcite ) , indeed , if the robots continue to follow algorithm _ shrink _ once they reach full visibility , the convex hull of their positions converges to a point , and the robots approach it without colliding , thus solving near - gathering(section  [ s : nearg ] ) .",
    "this algorithm has an interesting fault - tolerance property : if a single robot is faulty and becomes unable to move , the robots will still solve near - gathering , converging to the faulty robot s location ( section  [ s : fault ] ) .    additionally , both protocols can be modified so that the robots can position themselves on the perimeter of a circle , thus providing an obstructed - visibility solution to the classical problem of circle formation . the problem can be solved with @xmath22 colors in rigid  ssynch , with @xmath23 colors in non - rigid  ssynch , and with @xmath25 colors in rigid  asynch , and non - rigid  asynchwith agreement on one axis ( section  [ s : circle ] ) .",
    "we mostly follow the terminology and definitions of the standard model of oblivious mobile robots ( e.g. , see  @xcite ) .    by @xmath26",
    "we denote a set of oblivious mobile computational entities , called _ robots _ , operating in the euclidean plane , and initially placed at distinct points .",
    "each robot is provided with its own local coordinate system centered in itself , and its own notion of unit distance and handedness .",
    "we denote by @xmath27 the position occupied by robot @xmath28 at time @xmath2 ; these positions are expressed here in a global coordinate system , which is used for description purposes , but is unknown to the robots .",
    "two robots @xmath12 and @xmath13 are said to _ collide _ at time @xmath2 if @xmath18 .",
    "a robot @xmath12 can _ see _ another robot @xmath13 ( equivalently , @xmath13 is _ visible _ to @xmath12 ) at time @xmath2 if and only if no other robot lies in the segment @xmath16 at that time .",
    "the robots are luminous : each robot @xmath12 has a persistent state variable , called _ light _ , which may assume any value in a finite set @xmath29 of _ colors_. the color of @xmath12 at time @xmath2 can be seen by all robots that can see @xmath12 at that time .",
    "the robots are autonomous ( i.e. , without any external control ) , anonymous ( i.e. , without internal identifiers ) , indistinguishable ( i.e. , without external markings ) , without any direct means of communication , other than their lights . at any time",
    ", robots can be performing a variety of operations , but initially ( i.e. , at time @xmath30 ) they are all still and idle .    when activated , a robot performs a _",
    "look - compute - move _ sequence of operations : it first obtains a snapshot of the positions , expressed in its local coordinate system , of all visible robots , along with their respective colors ( _ look _ phase ) ; using the last obtained snapshot as an input , the robot executes a deterministic algorithm , which is the same for all robots , to compute a destination point @xmath31 ( expressed in its local coordinate system ) and a color @xmath32 , and it sets its light to @xmath5 ( _ compute _ phase ) ; finally , it moves towards @xmath33 ( _ move _ phase ) .",
    "it then starts a new cycle , whenever the scheduler ( which is an abstract entity controlling to some extent the behavior of the robots ) decides to activate it again . in the _",
    "compute _ phase , a robot may also decide to terminate its execution .",
    "when a robot has terminated , it remains still forever , and its light remains the same color that it was at the moment of termination .",
    "the robots are _ oblivious _ in the sense that , when a robot transitions from one cycle to the next , all its local memory , except for the light , is reset . in other words ,",
    "a robot has no memory of past computations and snapshots , except for the light .    with regards to the activation and timing of the robots , there are two basic settings : _ semi - synchronous _ ( ssynch ) and _ asynchronous _ ( asynch ) . in ssynch ,",
    "the time is discrete ; at each time instant @xmath34 ( called a _ round _ or a _ turn _ ) a subset of the robots is activated by the scheduler and performs a whole _",
    "look - compute - move _ cycle atomically and instantly . at",
    "any given round , any subset of robots may be activated , from the empty set to all of @xmath35 . in particular ,",
    "if all robots are activated at every round , the setting is called _ fully synchronous _ ( fsynch ) .",
    "there is a bland _ fairness _ constraint on the choices that the scheduler can make : every robot must be activated infinitely many times ( unless it terminates ) . in asynch , there is no common notion of time : each robot executes its cycles independently , the _ look _ operation is instantaneous , but the _ compute _ and _ move _ operation can take an unpredictable ( but finite ) amount of time , unknown to the robot . in a _ move _ phase",
    "there are no constraints on the speed of a robot , as long as it always moves directly towards its destination point at non - negative speed .",
    "the scheduler that controls the activations ( in ssynch ) and the durations of the operations ( in asynch ) can be thought of as an _ adversary _ , whose purpose is to prevent the robots from doing their task .",
    "other than acting as a scheduler , the adversary also determines the initial position of the robots and their local coordinate systems ; in particular , the coordinate system of a robot might not be preserved over time and might be modified by the adversary between one cycle and the next . in the simplest model , the robots do not necessarily agree on the orientation of the coordinate axes , on the unit distance , and on the clockwise direction ( i.e. , the handedness of the system ) .",
    "however , in section  [ sec : axis ] , we will discuss the special model in which all the robots agree on the direction of one axis , and the adversary is unable to change it .",
    "the adversary might or might not have the power to interrupt the movement of a robot before it reaches its destination in the _ move _ operation .",
    "if it does , the system is said to be non - rigid .",
    "the only constraint on the adversary is that there exists a constant @xmath11 such that , if interrupted before reaching its destination , a robot moves at least a distance @xmath24 .",
    "the value of @xmath24 is decided by the scheduler once and for all , and typically it is not known by the robots , which therefore can not use it in their computations ( we will discuss the scenario in which the robots know the value of @xmath24 in section  [ s : delta ] ) .",
    "notice that , without this constraint , the adversary would be able to prevent a robot from reaching any given destination in a finite number of turns .",
    "if movements are not under the control of the adversary , and every robot reaches its destination at every turn , the system is said to be rigid .",
    "the mutual visibilityproblem requires @xmath21 robots to form a configuration in which they occupy @xmath21 distinct locations , and no three of them are collinear .",
    "subsequently , the robots have to terminate .",
    "a protocol @xmath36 is a solution of mutual visibilityif it allows the robots to solve mutual visibilitystarting from any initial configuration in which their positions are all distinct , and regardless of the decisions of the adversary ( including the activation schedule , the local coordinate systems of the robots , and the value of @xmath24 ) .",
    "let us stress that , since robots are oblivious and anonymous and execute the same protocol , if @xmath18 ( a collision ) , then the adversary can force @xmath19 for all @xmath20 if the two robots do not have lights or their lights have the same color . hence the two robots will never again occupy distinct locations , and will no longer be able to solve mutual visibility . thus , collision avoidance of robots with the same color is a requirement for any solution protocol .    among the configurations that solve the mutual visibilityproblem",
    ", a special class is that in which all robots are in a strictly convex position . within this class , of particular interest",
    "are the configurations in which the robots lie on the perimeter of a circle . among these , there are the notable configurations in which the robots occupy the vertices of a regular @xmath21-gon .",
    "the problems of forming such configurations are called convex formation , circle formation , and uniform circle formation , respectively .",
    "a finite set of points @xmath37 is said to be _ convex _ if all the points of @xmath38 lie on the perimeter of the convex hull of @xmath38 .",
    "if a point @xmath1 of a convex set @xmath38 lies in the relative interior of an edge of the convex hull of @xmath38 , then @xmath1 is said to be a _ degenerate _ vertex of the convex hull .",
    "if none of the points of a convex set @xmath38 is a degenerate vertex of the convex hull , then @xmath38 is said to be a _",
    "strictly convex _ set . on the other hand",
    ", we will say that a polygon is _ degenerate _ if its area is zero .",
    "these two notions of degeneracy are used in different contexts ( one refers to vertices , the other refers to whole polygons ) , hence they can hardly be confused .",
    "let @xmath39 denote the convex hull of @xmath40 at time @xmath2 .",
    "the robots lying on its boundary are called _ external robots _ at time @xmath2 , while the ones lying in its interior are the _ internal robots _ at time @xmath2 .",
    "observe that a robot may not know where the convex hull s vertices are located , because its view may be obstructed by other robots .",
    "however , it can easily determine whether it is an external or an internal robot .",
    "in fact , a robot @xmath41 is external at time @xmath2 if and only if there is a half - plane bounded by a straight line through @xmath14 whose interior contains no robots at time @xmath2 . in other words , @xmath12 is external if and only if it lies on the boundary of the convex hull of the robots that it can currently see .",
    "note also that the neighbors of an external robot on its visible convex hull are indeed its neighbors on the actual convex hull .",
    "if , in addition , @xmath12 lies at a non - degenerate vertex of the ( visible ) convex hull , it is said to be a _",
    "vertex _ robot .",
    "moreover , a robot is able to tell if @xmath42 is a line segment , i.e. , if all the robots are collinear . in particular",
    ", if a robot can see only one other robot , it understands that it is an _",
    "endpoint robot_. conversely , non - endpoint robots can always see more than one other robot .",
    "the points of @xmath10 are treated like vectors , and as such they can be added , subtracted , multiplied by scalars , etc .",
    "the dot product between vectors @xmath43 and @xmath44 will be indicated by the expression @xmath45 .",
    "in this section we consider the mutual visibilityproblem in the rigid   ssynchsetting .",
    "we present and analyze a protocol , algorithm  [ alg1 ] ( _ shrink _ ) , and we prove it solves mutual visibilityin such a setting using only two colors .      the main idea of algorithm  [ alg1 ] is to make only the external robots move , so as to shrink the convex hull .",
    "when a former internal robot becomes external , it starts moving as well .",
    "eventually , all the robots reach a strictly convex configuration , and at this point they all see each other and they can terminate .",
    "[ alg1 ]    @xmath46 myself @xmath47 @xmath48 convex hull of @xmath49    if an active robot @xmath50 , located at @xmath1 , realizes that it is not a vertex robot , it does not move .",
    "otherwise , it locates its clockwise and counterclockwise neighbors ( in its own coordinate system ) on the convex hull s boundary , say located at @xmath43 and @xmath44 , which are necessarily visible .",
    "then , @xmath50 attempts to move somewhere in the triangle @xmath51 , in such a way to shrink the convex hull , and possibly make one more robot become a vertex robot . to avoid collisions with other robots that may be moving at the same time , @xmath50 s movements are restricted to a smaller triangle , shaded in gray in figure  [ fig1 ] . moreover , to avoid becoming a non - vertex robot , @xmath50 does not cross any line parallel to @xmath52 that passes through another robot , and it carefully positions itself on the closest of such lines , as shown in figure  [ fig1:a ] . in particular ,",
    "if no such line intersects the gray area , @xmath50 makes a _ default move _ , and it moves halfway toward the midpoint of the segment @xmath52 , as indicated in figure  [ fig1:b ] .    in order to recognize that the mutual visibilityproblem has been solved , and to correctly terminate , the robots carry visible lights of two possible colors : namely , @xmath53 .",
    "all robots lights are initially set to _",
    "if an active robot realizes that it is a vertex of the convex hull , it sets its light to the other value , _",
    "vertex_. hence , when a robot sees only robots whose lights are set to _",
    "vertex _ , it knows it can see all the robots in the swarm , and hence it terminates .",
    "the above rules are sufficient to solve the mutual visibilityproblem in most cases , but there are some exceptions .",
    "it is easy to see that there are configurations in which mutual visibilityis never solved until an internal robot moves , regardless of the algorithm employed .",
    "for instance , suppose that the configuration is centrally symmetric , with one robot lying at the center .",
    "let the local coordinate systems of any two symmetric robots be oriented symmetrically and have the same unit distance , and assume that the scheduler chooses to activate all robots at every turn .",
    "then , every two symmetric robots have symmetric views , and therefore they move symmetrically . if the central robot  which is an internal robot  never moves , then the configuration remains centrally symmetric , and the central robot always obstructs all pairs of symmetric robots .",
    "hence mutual visibilityis never solved , no matter what algorithm is executed .",
    "it turns out that our rules can be fixed in a simple way to resolve also this special case : whenever an internal robot sees only robots whose lights are set to _",
    "( except its own light ) , it moves to the midpoint of any edge of the convex hull .",
    "finally , the configurations in which all the robots are collinear need special handling . in this case",
    "it is impossible to solve mutual visibilityunless some robots leave the current convex hull .",
    "suppose that a robot @xmath12 realizes that all robots lie on a line , and that it is not an endpoint ( i.e. , @xmath12 can see only two other robots , which are collinear with it ) .",
    "then , @xmath12 moves by any positive amount , orthogonally to the line formed by the other two visible robots .",
    "when this is done , the previous rules apply .        in the following we discuss some basic invariants , which will serve to prove the correctness of algorithm  [ alg1 ] .",
    "suppose that , for some @xmath54 , @xmath55 is not a line segment : the situation is illustrated in figure  [ fig2 ] .",
    "if a vertex robot is activated , it is bound to remain in the corresponding gray triangle , called _ movement region _ of the robot .",
    "more precisely , the movement region consists of the interior of the gray triangle , plus the vertex where the robot currently is , plus the interior of the edge that is opposite to the robot .",
    "hence all movement regions are disjoint .",
    "moreover , if there is only one internal robot and it sees only robots whose light is set to _",
    ", it moves to the midpoint of an edge of @xmath39 , which does not lie in any movement region .",
    "it follows that , no matter which robots are activated at time @xmath2 , they will not collide at time @xmath56 .",
    "also , @xmath57 .",
    "recall that a robot @xmath58 is a vertex robot if an only if it lies at the vertex of a reflex angle whose interior does not contain any robots .",
    "now , referring to figure  [ fig1 ] , it is clear that a vertex robot will remain a vertex robot after a move",
    ". additionally , if no new vertex robots are acquired between time @xmath2 and @xmath56 , then the ordering of the vertex robots around the convex hull is preserved from time @xmath2 to time @xmath56 . this easily follows from the fact that every robot remains in its own movement region ( cf .  figure  [ fig2 ] ) .",
    "we seek to prove that algorithm  [ alg1 ] makes every robot eventually become a vertex robot . as it will be apparent in the proof of theorem  [ t : correctness ] ,",
    "the crux of the problem is the situation in which only default moves are made ( cf .  figure  [ fig1:b ] ) .",
    "we first prove that , if all robots perform only default moves , then they all converge to the same point ( see lemma  [ l : default ] below ) .",
    "since we are assuming that only the vertex robots move , and that their movements depend only on the positions of other visible vertex robots , we may as well assume that all robots are vertex robots , and that their indices follow their order around the convex hull .",
    "indeed , by the invariants observed in section  [ s : invariants ] , all robots will remain vertex robots throughout the execution , and their ordering around the convex hull will remain the same .",
    "so , let @xmath59 , @xmath50 , @xmath60 be three vertex robots , which appear on the boundary of @xmath55 consecutively in this order .",
    "let @xmath50 perform a default move at time @xmath2 .",
    "then , the new position of @xmath50 is a convex combination of the current positions of these three robots , and precisely @xmath61 in general , as different sets of vertex robots are activated in several rounds , and nothing but default moves are made , the new location of each robot is always a convex combination of the _ original _ positions of all the robots , obtained by applying   to the set of active robots , at every round . in formulas ,",
    "@xmath62 with @xmath63 and @xmath64 , assuming that the robots start making only default moves at time @xmath65 .",
    "let @xmath66 .",
    "we fix @xmath67 , and we let @xmath68 , where indices are taken modulo @xmath21 . we claim that @xmath69 if such a claim is true ( for all @xmath67 ) , it implies that the robots get arbitrarily close to each other , as @xmath2 grows .",
    "this , paired with the fact that @xmath70 for every @xmath2 , as observed in section  [ s : invariants ] , allows us to conclude that the robots converge to the same limit point .",
    "a proof of this statement can be obtained using the theory of convergence of asynchronous algorithms in the book  @xcite .",
    "indeed , the update rule   corresponds to performing time stepping on a markov chain with circulant transition matrix @xmath71 it is proven in a statement on  @xcite that the time - stepping iteration converges even when performed asynchronously , under a model that generalizes our ssynch .",
    "nevertheless , we give here an alternative self - contained proof .",
    "first we reformulate the problem in the following terms .",
    "[ [ section ] ]    suppose that @xmath21 vessels containing water are arranged in a circle , and there is a pipe between each pair of adjacent vessels , regulated by a valve . at every second , some of the valves are opened and others are closed , in such a way that each of the @xmath21 valves stays open for infinitely many seconds , in total . if a valve between two adjacent vessels stays open between seconds @xmath2 and @xmath56 , then @xmath72 of the surplus of water , measured at second @xmath2 , flows from the fuller vessel to the emptier one .",
    "our claim is that the amount of water converges to the same limit in all vessels , no matter how the valves are opened and closed .",
    "we call this problem communicating vessels",
    ".    in this formulation , the amount of water in the @xmath73-th vessel at time @xmath54 would be our previous @xmath74 .",
    "however , here we somewhat abstract from the mutual visibilityproblem , and we consider a slightly more general initial configuration , in which the @xmath75 s are arbitrary real numbers .    this problem is a special case of a diffusion model on a simple circular graph . to solve it , we shall introduce a quadratic energy functional @xmath76 , and prove that it is decreasing .",
    "the use of such an energy functional in this class of problems is well known in the literature ( see for instance  @xcite ) , but the fact that the iteration is performed semi - synchronously on each node separately is less standard , so we need to do a little more work .",
    "we set @xmath77 if the valve between the @xmath73-th and the @xmath78-th vessel is open between time @xmath2 and @xmath56 ( indices are taken modulo @xmath21 ) , and @xmath79 otherwise .",
    "it is easy to verify that activating robot @xmath50 at time @xmath2 in our previous discussion corresponds to setting @xmath77 in the communicating vesselsformulation .",
    "let us denote by @xmath80 the vector whose @xmath73-th entry is @xmath74 , and let @xmath81 .",
    "we first prove an inequality on the euclidean norms of the vectors @xmath80 .",
    "note that the inequality holds regardless of what assumptions are made on the opening pattern of the valves .",
    "[ l : main ] for every @xmath54 , @xmath82    for brevity , let @xmath83 , @xmath84 , @xmath85 ; hence , @xmath86 and @xmath87 .",
    "suppose first that @xmath88 , i.e. , both valves connecting the @xmath73-th vessel with its neighbors are open .",
    "then , @xmath89 . we have @xmath90 which can be obtained by dropping the term @xmath91 from the algebraic identity @xmath92 now , suppose instead that @xmath93 and @xmath79",
    ". then we have @xmath94 , and @xmath95 where the first equality comes from the identity @xmath96 if @xmath97 and @xmath77 , an analogous argument gives @xmath98 finally , if @xmath99 , @xmath100 , and trivially @xmath101 we sum for each @xmath102 the relevant inequality among , , , , depending on the value of @xmath103 and @xmath104 . each of the terms @xmath105 appears twice if and only if @xmath77 , and the coefficients of the terms in @xmath106 sum to 1 for every @xmath73 , hence we get  .    from the previous lemma",
    ", it immediately follows that the sequence @xmath107 is non - increasing .",
    "since it is also bounded below by @xmath108 , it converges to a limit , which we call @xmath109 .",
    "let @xmath110 and @xmath111 .",
    "observe that each entry of @xmath112 is a convex combination of entries of @xmath80 , hence @xmath113 is non - increasing and @xmath114 is non - decreasing .",
    "therefore they both converge , and we let @xmath115 and @xmath116 .",
    "[ c : limits ] @xmath117    for every @xmath54 , we have @xmath118 which proves the second inequality . as for the first inequality , for every @xmath119 and large - enough @xmath2",
    ", we have @xmath120 .    for the next lemma ,",
    "we let @xmath121 .",
    "[ l : vessels ] suppose that @xmath122 for at least @xmath123 distinct values of @xmath102 .",
    "then , @xmath124    due to corollary  [ c : limits ] , it is enough to prove that @xmath125 . by contradiction ,",
    "assume @xmath126 , and let @xmath127 .",
    "we have @xmath128 hence there exists @xmath129 such that @xmath130 for every @xmath131 . by lemma",
    "[ l : main ] , @xmath132 for every @xmath131 and every @xmath73 such that @xmath77 .",
    "this implies @xmath133 , that is , a necessary condition for the valve between the @xmath73-th and the @xmath78-th vessel to be open at time @xmath131 is that @xmath134 .",
    "consider now the @xmath135 open intervals @xmath136 each of width @xmath24 .",
    "since @xmath137 and @xmath138 , there are @xmath139 s above and below all these intervals . moreover , by the pigeonhole principle , at least one of the intervals contains no @xmath139 s , for any @xmath102 . in other words",
    ", we can find a partition @xmath140 , with @xmath141 and @xmath142 both non - empty , and a threshold value @xmath143 such that @xmath144 for every @xmath145 , and @xmath146 for every @xmath147 .",
    "hence , at time @xmath148 , only valves between entries of @xmath80 whose indices belong to the same @xmath149 can be open .",
    "it is now easy to prove by induction on @xmath131 the following facts :    * @xmath150 , * @xmath151 , * @xmath79 whenever @xmath73 and @xmath152 belong to two different classes of the partition .",
    "since @xmath141 and @xmath142 are non - empty , there must be at least two distinct indices @xmath153 and @xmath154 such that @xmath155 and @xmath156 ( where indices are taken modulo @xmath21 ) .",
    "it follows that the @xmath157-th and @xmath158-th valve are never open for @xmath131 , and this contradicts the hypothesis that @xmath159 for at most one choice of @xmath102 .",
    "this solves the communicating vesselsproblem .",
    "[ c : vessels ] under the hypotheses of lemma  [ l : vessels ] , for every @xmath102 , @xmath160    by lemma  [ l : vessels ] , since @xmath161 , all the limits coincide . moreover",
    ", the sum of the @xmath74 s does not depend on @xmath2 ; hence their average , taken at any time , must be equal to the joint limit .",
    "let us return to the mutual visibilityproblem , to prove our final lemma .",
    "[ l : default ] if , at every round , each robot makes a default move ( cf .",
    "figure  [ fig1:b ] ) or stays still , all external robots have their lights set to _",
    "vertex _ , and",
    "no new robots become vertex robots or terminate , then all robots locations converge to the same limit point .    as discussed at the beginning of section  [ s : convergence ] , this is implied by  . recall that @xmath162 , and hence @xmath163 .",
    "then ,   follows immediately from corollary  [ c : vessels ] .",
    "we are now ready to prove our main theorem .",
    "[ t : correctness ] algorithm  [ alg1 ] solves mutual visibilityfor rigid  ssynchrobots with 2-colored lights .",
    "if the initial convex hull is a line segment , it becomes a non - degenerate polygon as soon as one or more of the non - vertex robots are activated .",
    "it is also easy to observe ( cf .",
    "figure  [ fig2 ] ) that , from this configuration , the convex hull may never become a line segment .",
    "so the invariants discussed in section  [ s : invariants ] apply , possibly after a few initial rounds : no two robots will ever collide , and a vertex robot will never become a non - vertex robot .",
    "assume by contradiction that the execution never terminates .",
    "note that a robot terminates if and only if all robots terminate .",
    "indeed , if there are any non - vertex robots ( whose lights are still set to _ off _ ) , then each vertex robot can see at least one of them .",
    "hence we are assuming that all robots execute the algorithm forever .    at some point ,",
    "the set of vertex robots reaches a maximum @xmath164 , and as soon as all of these robots have been activated , they permanently set their lights to _ vertex_. let @xmath165 be a time at which all the robots in @xmath166 have their lights set to _",
    "suppose that there are external robots that are not vertex robots after time @xmath148 , and let @xmath12 be one such robot that is adjacent to a vertex robot @xmath167 .",
    "then , after @xmath167 is activated and moves , @xmath12 becomes a vertex robot as well , contradicting the maximality of @xmath166 .",
    "hence the external robots are exactly the robots in @xmath166 , and no other robot may become external after time @xmath148 .",
    "if there is only one internal robot at time @xmath131 , it becomes external as soon as it is activated , due to line  23 of the algorithm , which is impossible , as argued in the previous paragraph .",
    "therefore there are at least two internal robots at every time @xmath131 . on the other hand ,",
    "if a vertex robot makes a non - default move at any time @xmath131 , a new robot becomes external at time @xmath56 .",
    "indeed , referring to figure  [ fig1:a ] , the line @xmath168 passes through @xmath169 and @xmath170 , and no robot lies above this line at time @xmath56 .",
    "hence @xmath5 becomes a new external robot , which again is impossible .    as a consequence ,",
    "only default moves are made after time @xmath148 .",
    "moreover , no robot becomes external or becomes a vertex robot after time @xmath148 , and no robot ever terminates . therefore lemma  [ l : default ] applies , and the robots converge to the same limit point .",
    "but since there are at least two internal robots , this means that at least one of them has to move , implying that it becomes a vertex robot at some point ( by the above assumptions , only vertex robots can move ) , a contradiction",
    ".    hence the execution terminates , meaning that at some point one of the robots sees only vertex robots .",
    "this implies that there are no non - vertex robots , hence the configuration is strictly convex , all robots can see each other , and they all terminate without moving as soon as they are activated , thus solving the mutual visibilityproblem .",
    "here we give a protocol , algorithm  [ alg2 ] ( _ contain _ ) , for the mutual visibilityproblem that works for non - rigidrobots and the ssynchscheduler .",
    "recall that , in the non - rigidmodel , the robots make unreliable moves , that is , the scheduler can stop them before they reach their destination point , but not before they have moved by at least a constant @xmath11 .",
    "since these robots are weaker than the ones considered in section  [ s : ssynch ] , they will require lights of three possible colors , as opposed to two .",
    "our goal is also to design an algorithm that can be applied to robots in the rigid  asynchmodel , as well as the non - rigid  ssynchone .",
    "this model will be discussed in section  [ s : rasynch ] . in order to do this , we introduce a couple of extra technical subtleties into algorithm  [ alg2 ] , which are irrelevant here , but will turn out to be necessary in section  [ s : rasynch ] .",
    "algorithm  [ alg2 ] consists of three phases , to be executed in succession : a _ segment breaking _ phase , an _ interior depletion _ phase , and a _ vertex adjustments _ phase .",
    "the first phase deals with the special configuration in which the robots are all collinear , and makes them not collinear .",
    "if the robots are not initially collinear , this phase is skipped . in the second phase , the internal robots move toward the boundary of the convex hull , thus forming a convex configuration , perhaps with some degenerate vertices . in the third phase the robots ( which are now all external ) make small movements to finally reach a strictly convex configuration .",
    "three colors are used by the robots : @xmath171 .",
    "initially , all robots lights are set to _",
    "off_.    for added clarity , in the algorithm the line numbers of instructions belonging logically to different phases are typeset in different colors , according to the following table .",
    "[ cols= \" > , < \" , ]     [ alg2 ]    @xmath46 myself @xmath47 @xmath48 convex hull of @xmath49 @xmath172 boundary of @xmath42    recall that we denote by @xmath39 the convex hull of the positions of all the robots at time @xmath173 . in this section",
    "we also denote by @xmath174 the convex hull of the positions of the internal robots at time @xmath173 .",
    "note that the `` global '' notions of @xmath42 and @xmath175 may differ from the ones computed by the robots executing algorithm  [ alg2 ] , because a robot may be unable to see the positions of all the other robots in the swarm . in the following discussion ,",
    "when referring to @xmath42 and @xmath175 , we will typically mean the `` global '' ones , unless we explicitly state otherwise .",
    "we first describe the interior depletion phase , starting from a non - collinear initial configuration . to begin with",
    ", all the robots lights are set to _ off_. as soon as an external robot is activated , it sets its own light to _ external _ ( lines  34 , 35 ) and does not move as long as it can still see robots whose light is _ off _ ( lines  26 , 27 ) .",
    "note that a robot @xmath12 that occupies a vertex of @xmath175 eventually becomes aware of it , by looking at the convex hull of the visible robots whose lights are _",
    "off_. these may not all be internal robots , because perhaps not all external robots have been activated yet , but eventually @xmath12 gets to see a good - enough approximation of a `` neighborhood '' of @xmath175 , and it realizes it occupies one of its vertices .",
    "so , when a robot understands that it lies on a vertex of @xmath175 , it moves toward the boundary of @xmath42 , part of which is also identifiable by @xmath12 .",
    "we distinguish three cases .    1 .",
    "if @xmath12 realizes it is the only internal robot , it moves toward the midpoint of an edge of the convex hull ( line  41 ) .",
    "to avoid bouncing back and forth at different turns , it always chooses the closest of such midpoints .",
    "2 .   if @xmath12 realizes that @xmath175 is a line segment and it occupies one endpoint of it , it moves like in figure  [ fig3:a ] .",
    "that is , it moves to the boundary of @xmath42 , while remaining within a right angle oriented away from @xmath175 ( lines  4345 ) .",
    "finally , if @xmath12 `` believes '' that @xmath175 is a non - degenerate polygon and that it lies on one of its vertices , it moves as in figure  [ fig3:b ] ( lines  4754 ) . remember that @xmath12 may believe so even if @xmath175 is actually degenerate , because some external robots may still be _",
    "off_. however , @xmath12 gets an approximation of @xmath175 , which we call @xmath176 , and it knows it lies on a vertex of @xmath176 , implying that it also lies on a vertex of the `` real '' @xmath175 .",
    "now , if the internal angle of @xmath176 at @xmath14 is acute , @xmath12 moves as the robot in @xmath1 in figure  [ fig3:b ] : it moves to the boundary of @xmath42 while remaining between the extensions of its two incident edges of @xmath176 .",
    "otherwise , if the angle is not acute , @xmath12 moves as the robot in @xmath3 in figure  [ fig3:b ] : it moves to the boundary of @xmath42 while staying between the two perpendiculars to its incident edges of @xmath176 .",
    "moreover , @xmath12 actually performs the move only if it is sure that its destination point lies on the boundary of the `` real '' @xmath42 . for this reason",
    ", it has to check if the destination point computed as described above lies on a completely - visible edge of the observed convex hull whose endpoints are both set to _ external _ ( line  53 ) .",
    "for instance , in figure  [ fig13 ] , the robot in @xmath1 can not move to the gray area even if the robots in @xmath43 and @xmath44 are set to _",
    "external _ , because the robot in @xmath3 prevents the one in @xmath1 from seeing the whole edge @xmath52 . on the other hand",
    ", the robot in @xmath3 can move to its own gray area , provided that @xmath43 and @xmath44 are set to _",
    "external_. indeed , the robot in @xmath3 can see all of @xmath52 , and it is therefore sure that it is an edge of the `` real '' convex hull",
    ".     can not move even if @xmath43 and @xmath44 are set to _",
    "external _ , because @xmath3 may be hiding some other external robots , and @xmath52 may not be an edge of the convex hull ]    now to the vertex adjustments phase .",
    "when a robot lies at a vertex of @xmath42 and it sees only robots whose light is set to _ external _ , it makes the `` default move '' of figure  [ fig1:b ] , where @xmath43 and @xmath44 are the locations of its two neighbors on @xmath42 ( line  29 ) .",
    "moreover , while doing so it also sets its light to the third value , _ adjusting _ , as a `` self - reminder '' ( line  28 ) .",
    "so , when it is activated again , it knows it has already adjusted its position , and it terminates , after reverting its light to _ external _ ( lines  2025 ) . this way we make sure that each vertex robot adjusts its position exactly once , and we ensure termination .",
    "when the adjustment is done , the robots at @xmath43 and @xmath44 are guaranteed to occupy vertices of @xmath42 , instead of lying in the middle of an edge .",
    "so , each external robot becomes a vertex robot at some point , then it adjusts its position while remaining a vertex , possibly making its adjacent robots become vertices as well , and it terminates .",
    "when all robots have terminated , the configuration is strictly convex , and therefore mutual visibilityis solved .",
    "finally , the segment breaking phase deals with the special case in which all robots are initially collinear .",
    "let robots @xmath12 and @xmath13 be the two endpoints of @xmath42 : as soon as one of them is activated ( possibly both ) , it sets its light to _ adjusting _ , moves orthogonally to @xmath42 , and then waits ( lines  11 , 12 ) .",
    "meanwhile , the other robots do not do anything until some conditions are met ( lines  3134 ) .",
    "if only @xmath12 moves , @xmath13 realizes it ( line  32 ) and sets its own light to _ external _ ( and vice versa ) .",
    "if both @xmath12 and @xmath13 move together , some other robot realizes that it is a non - degenerate vertex of the convex hull and that it can see both @xmath12 and @xmath13 set to _ adjusting _ ( line  33 ) : in this case , it sets itself to _",
    "external_. when @xmath12 or @xmath13 sees some robots set to _",
    "external _ , it finally sets itself to _ external _ , as well ( lines  22 , 23 ) .",
    "additionally , it may terminate , provided that neither of its neighboring robots on the convex hull s boundary has still its light set to _ off _",
    "( line  24 ) and that it recognizes no robots as internal ( line  25 ) .",
    "this is to force @xmath12 and @xmath13 to make at least one default move in the unfortunate case that a third external robot is found between them after their initial move , or gets there during the interior depletion phase ( refer to the complete discussion in section  [ s : segbreak ] ) .",
    "after this is done , the execution transitions seamlessly into one of the general cases .    if @xmath177 this is not sufficient .",
    "suppose first that @xmath178 .",
    "then , @xmath12 and @xmath13 may move in such a way that the configuration remains centrally symmetric , with the middle robot @xmath3 obstructing @xmath12 and @xmath13 .",
    "however , after moving once , @xmath12 and @xmath13 become _ external _ and terminate ( lines  8 , 9 )",
    ". meanwhile @xmath3 waits until it sees both @xmath12 and @xmath13 set to _ external _ , and finally it moves orthogonally to @xmath42 ( lines  1316 ) , thus solving mutual visibilityalso in this special case .",
    "if @xmath179 , each robot moves once ( lines  11 , 12 ) , and then it detects a situation in which it can safely terminate ( lines  69 ) .",
    "we first prove that no collisions occur during the interior depletion phase , and then that the phase itself eventually terminates , with all the robots becoming external . in this section",
    "we will assume that the robots are not initially collinear .",
    "the collinear case will be discussed in section  [ s : segbreak ] , and it will be shown that is seamlessly transitions into one of the other cases .",
    "it is easy to observe that , during the interior depletion phase , all external robots keep seeing ( internal ) robots whose lights are set to _ off _ , and therefore none of them moves . on the other hand , no internal robot moves outside of the convex hull .",
    "[ obs : depletion ] if there are internal robots at time @xmath2 , no external robot moves , and @xmath180 .",
    "[ l : coll1 ] if @xmath12 and @xmath13 are two internal robots at time @xmath2 , then @xmath181    if @xmath12 is not activated at time @xmath2 , or it is activated but it does not move , then the left - hand side is zero , and therefore the inequality holds .",
    "suppose now that @xmath12 moves by a positive amount , so @xmath182 is not the null vector . let @xmath109 be the line through @xmath14 that is orthogonal to the segment @xmath183 . by construction ,",
    "@xmath12 moves in such a way that @xmath184 lies in the open half - plane bounded by @xmath109 that does not contain @xmath174 ( note that this holds _ a fortiori _ also if some external robots have not set their lights to _ external _ yet , and therefore the @xmath175 computed by @xmath12 is larger than the real one ) .",
    "since @xmath185 , @xmath15 lies on @xmath109 or in the half - plane bounded by @xmath109 that does not contain @xmath184 .",
    "this is equivalent to saying that the dot product between @xmath182 and @xmath186 is not positive .",
    "[ l : coll2 ] as long as there are internal robots , no collisions occur .",
    "if there are internal robots , every external robot sees robots whose light is set to _ off _ , and hence it does not move . by construction ,",
    "the internal robots avoid moving on top of external robots , and therefore there can be no collision involving external robots .",
    "suppose by contradiction that two robots @xmath12 and @xmath13 that are internal at time @xmath2 collide for the first time at @xmath56 , and therefore @xmath187 .",
    "by lemma  [ l : coll1 ] applied to @xmath12 and @xmath13 , we have @xmath188 applying lemma  [ l : coll1 ] again with @xmath12 and @xmath13 inverted , we also have @xmath189 adding  [ eq : coll1 ] and  [ eq : coll2 ] together and doing some algebraic manipulations , we obtain @xmath190 @xmath191 @xmath192 the latter is equivalent to @xmath193 , implying that @xmath18 .",
    "this contradicts the fact that @xmath12 and @xmath13 collide for the first time at @xmath56 .",
    "we still have to prove that the interior depletion phase terminates , that is , eventually all robots become external .",
    "due to observation  [ obs : depletion ] , when a robot becomes external , it stops moving and remains external , at least as long as there are other internal robots .",
    "thus , if by contradiction this phase does not terminate , the set of internal robots reaches a non - empty minimum , and from that time on no new robot becomes external .",
    "after possibly some more turns , say at time @xmath194 , all external robots have been activated and have set their lights to _ external _ , and hence no robot changes its light any more .    in the following lemmas , we will show that these assumptions on @xmath148 yield a contradiction .",
    "we will prove that , if @xmath195 is a non - degenerate polygon , then either its area or its diameter will grow unboundedly . therefore , at some point in time , @xmath175 will not be a subset of @xmath42 any more .",
    "( the analysis when @xmath195 is a degenerate polygon is easy , and it will be carried out in the proof of lemma  [ l : intfinal ] . )",
    "recall that , due to line  50 of algorithm  [ alg2 ] , when a robot computes its destination , it remains within the extensions of its incident edges of @xmath174 .",
    "hence , referring to figure  [ fig4 ] , it is easy to observe the following .",
    "[ o : edges ] let robots @xmath12 and @xmath13 lie at adjacent vertices of @xmath174 at time @xmath131 , and let the area of @xmath174 be positive . then , @xmath184 and @xmath196 lie on the same side of the line through @xmath14 and @xmath15 ( or possibly on the line itself ) .",
    "[ l : intgrow ] if @xmath131 and the area of @xmath174 is positive , then @xmath197 .",
    "let @xmath198 be the set of robots that lie at vertices of @xmath174 , at time @xmath131 .",
    "let @xmath49 be the polygon ( illustrated in figure  [ fig4 ] as a thick dashed polygon ) whose vertices are the locations at time @xmath56 of the robots of @xmath199 , taken in the same order as they appear around the boundary of @xmath175 .",
    "note that , since the robots are non - rigidand not all of them are necessarily activated at time @xmath2 , @xmath49 is not necessarily a convex polygon .",
    "because the property stated in observation  [ o : edges ] holds for all the edges of @xmath174 and @xmath49 , we have that @xmath200 .",
    "but , by definition of @xmath148 , none of the robots of @xmath199 ever becomes external , and hence @xmath201 is the convex hull of @xmath49 .",
    "we conclude that @xmath202 .",
    "[ c : areadiameter ] for @xmath131 , the area of @xmath174 and the diameter of @xmath174 do not decrease as @xmath2 increases .    by lemma",
    "[ l : intgrow ] , if @xmath203 , then @xmath204 .",
    "hence the area of @xmath205 can not be greater than the area of @xmath206 , and the diameter of @xmath205 can not be greater than the diameter of @xmath206 .",
    "[ c : intint ] if @xmath12 is an internal robot at time @xmath131 , and @xmath14 is not a non - degenerate vertex of @xmath174 , then @xmath12 is internal at any time @xmath207 , and @xmath208 is not a non - degenerate vertex of @xmath209 .    by lemma  [ l : intgrow ] , if @xmath207 , then @xmath210 .",
    "moreover , according to line  46 of algorithm  [ alg2 ] , an internal robot that does not lie at a degenerate vertex of @xmath175 does not move .",
    "it follows that , after time @xmath2 , robot @xmath12 will not move , hence it will remain internal , and it will never lie at a non - degenerate vertex of @xmath175 .",
    "recall that , due to line  53 of algorithm  [ alg2 ] , a robot on the perimeter of @xmath175 is able to move only if it completely sees an entire edge of @xmath42 .",
    "next we prove that , after time @xmath148 , there exists at least one robot that is able to move .",
    "[ l : canmove ] at any time after @xmath148 , there is a robot that , if activated , makes a non - null movement .",
    "suppose for a contradiction that no robot is able to move , and let @xmath211 be a non - degenerate vertex of @xmath175 .",
    "if @xmath212 is the internal angle of @xmath175 at @xmath211 , we let @xmath213 be the point at which the bisector of @xmath214 intersects the perimeter of @xmath42 , as figure  [ fig16 ] shows .    , @xmath215 , @xmath216 , @xmath217 are unable to move ; the one in @xmath218 is able to move ]    let @xmath52 be an edge of @xmath42 such that @xmath219 ( note that @xmath213 may coincide with either @xmath43 or @xmath44 ) .",
    "since @xmath42 and @xmath175 are convex , either the segment @xmath220 is completely visible to @xmath211 , or the segment @xmath221 is . without loss of generality ,",
    "let @xmath220 be completely visible to @xmath211 , i.e. , @xmath222 . by definition of @xmath148 , both robots in @xmath43 and",
    "@xmath44 have their lights let to _ external_. also , note that @xmath213 lies within @xmath223 , as computed by the robot in @xmath211 executing line  52 of algorithm  [ alg2 ] .",
    "hence , by line  53 , the robot in @xmath211 can move , provided that @xmath224 .",
    "but by assumption no robot can move , and therefore there must be one robot occupying a non - degenerate vertex of @xmath175 neighboring @xmath211 , say @xmath215 , such that the ray from @xmath211 through @xmath215 intersects the segment @xmath52 , say in @xmath225 .",
    "observe that @xmath215 is strictly closer to the line @xmath52 than @xmath211 . by the convexity of @xmath175 , the bisector of the explementary of the internal angle at @xmath215 intersects the segment @xmath52 ,",
    "say in @xmath226 .",
    "in fact , @xmath226 lies between @xmath213 and @xmath225 ( refer to figure  [ fig16 ] ) .",
    "also , @xmath215 can see all the points in the segment @xmath227 . as we argued for @xmath211 in the previous paragraph",
    ", there must be another vertex @xmath228 of @xmath175 , closer to the line @xmath52 , that prevents @xmath215 from seeing the entire segment @xmath52 .",
    "proceeding in this fashion , we obtain a sequence @xmath211 , @xmath215 , @xmath228 , @xmath229 , @xmath216 of vertices of @xmath175 , which get closer and closer to the line @xmath52 .",
    "since these vertices must be all distinct , and there are only finitely many robots in the swarm , there must be one last element of the sequence , @xmath218 .",
    "it follows that @xmath218 can see all of @xmath52 , and the corresponding angle bisector intersects @xmath52 as well , say in @xmath230 .",
    "this implies that the robot in @xmath218 can actually move to a neighborhood of @xmath230 , contradicting our assumption .    as a consequence of corollary  [ c : intint ] ,",
    "no new robot becomes a non - degenerate vertex of @xmath175 after time @xmath148 , but some robots may indeed cease to be non - degenerate vertices of @xmath175 , and stop moving forever .",
    "hence , at some time @xmath231 , the set of robots that lie at non - degenerate vertices of @xmath175 reaches a minimum @xmath232 . by lemma  [ l : intgrow ] ,",
    "the area of @xmath175 is positive at every time @xmath233 , and hence @xmath234 .    in the next lemma",
    "we prove two fundamental properties of @xmath175 that hold after time @xmath235 .",
    "[ l : intmisc ] after time @xmath235 , the following statements hold .    *",
    "the cyclic order of the robots of @xmath166 around @xmath175 is preserved . *",
    "the length of the shortest edge of @xmath174 does not decrease as @xmath2 increases .    similarly to section  [ s : ssynch ] , we call the gray regions in figures  [ fig3 ] and  [ fig4 ] the _ movement regions _ of the respective robots",
    ".    let @xmath233 , and consider the polygon @xmath49 as defined in the proof of lemma  [ l : intgrow ] . by our assumptions on @xmath166 , @xmath49 is a convex polygon , or else some robot would cease to occupy a vertex of @xmath175 .",
    "hence @xmath236 and , by lemma  [ l : intgrow ] , @xmath237 .",
    "let @xmath238 occupy two adjacent edges of @xmath175 at time @xmath2 , and let @xmath109 be the axis of the segment @xmath16 .",
    "it follows from algorithm  [ alg2 ] that @xmath109 separates the movement regions of @xmath12 and @xmath13 at time @xmath2 ( cf .",
    "figure  [ fig4 ] ) .",
    "this , paired with the fact that the movement region of a robot of @xmath166 at time @xmath2 does not intersect the interior of @xmath175 , implies  ( a ) .",
    "now , to prove  ( b ) , it is sufficient to note that , with the previous paragraph s notation , the distance between the movement regions of @xmath12 and @xmath13 at time @xmath2 is precisely the distance between @xmath14 and @xmath15 ( see figure  [ fig4 ] ) .",
    "therefore , the segment @xmath239 is not shorter than @xmath16 , implying that the length of the shortest edge of @xmath175 can not decrease .",
    "we need one last geometric observation .",
    "is not @xmath52 ]    [ l : diameter ] if the internal angle at vertex @xmath241 of a convex polygon has measure less than @xmath242 , then the diameter of the polygon is the distance between @xmath241 and another vertex .",
    "the diameter of a polygon is the longest distance between two of its vertices .",
    "suppose for a contradiction that vertices @xmath43 and @xmath44 have the maximum distance , with @xmath243 , as in figure  [ fig14 ] .",
    "then , since the polygon is convex , the angle @xmath244 is containted in the internal angle at @xmath241 , and therefore its measure is less than @xmath242 .",
    "since the sum of the internal angles of a triangle is @xmath245 , it follows that either @xmath246 or @xmath247 . by the law of sines , in the first case @xmath248",
    "is longer than @xmath52 , and in the second case @xmath249 is longer than @xmath52 . in both cases , @xmath52 is not the longest segment joining two vertices of the polygon , which is a contradiction .",
    "we are finally ready to prove the termination , and therefore the correctness , of the interior depletion phase .",
    "[ l : intfinal ] if algorithm  [ alg2 ] is executed from a non - collinear configuration , after finitely many turns all robots become external , no robot s light is set to _ adjusting _ , and no two robots collide .    the non - collision part has already been proven in lemma  [ l : coll2 ] , so we need to prove that eventually all robots become external .    by assumption @xmath42",
    "has positive area , and we have to show that all robots become external in finitely many turns . if there is just one internal robot , it keeps moving somewhere within @xmath42 , until it either becomes external , or all external robots have been activated . when all external robots have their lights set to _",
    ", if there is still a single internal robot , it keeps moving toward the same edge of @xmath42 , until it finally reaches it .    if there there are exactly two internal robots , they move as shown in figure  [ fig3:a ] .",
    "it is easy to see that , each time at least one of the two internal robots moves ( by at least @xmath11 ) , their distance increases by more than @xmath250 .",
    "therefore , after finitely many turns , at least one of the two internal robots becomes external , and at most one internal robot remains .",
    "suppose now that there are at least three internal robots , but @xmath175 has null area , that is , all the internal robots are collinear .",
    "then , according to algorithm  [ alg2 ] , only the two endpoint robots of @xmath175 are allowed to move , as figure  [ fig3:a ] shows .",
    "if they move in such a way that the internal robots keep remaining collinear , eventually one of them reaches the boundary of @xmath42 , and there is one less internal robot .",
    "otherwise , they reach a situation in which @xmath175 has strictly positive area .",
    "therefore we may assume that @xmath175 has positive area , and we suppose for a contradiction that some internal robots never become external .",
    "by the previous lemmas and observations , we know that at some time @xmath235 the situation becomes `` stable '' .",
    "specifically , @xmath42 never changes , the set @xmath166 of robots that occupy non - degenerate vertices of @xmath175 keeps remaining the same , and these robots positions preserve their order around @xmath175 , by lemma  [ l : intmisc].a .",
    "also , the area and diameter of @xmath175 do not decrease , by corollary  [ c : areadiameter ] .",
    "let @xmath251 be the length of the shortest edge of @xmath174 .",
    "by lemma  [ l : intmisc].b , we know that @xmath251 is a weakly increasing function of @xmath233 .",
    "suppose that , at some time @xmath252 , some robot @xmath253 that is able to move is activated . by lines  53 , 54 of algorithm  [ alg2 ] ,",
    "the destination point of @xmath12 lies on the boundary of @xmath42 .",
    "hence , the adversary must stop @xmath12 before it reaches its destination , or it would become external . but this can not happen before @xmath12 has moved by at least @xmath24 , implying that @xmath254 .",
    "we distinguish two cases , based on the measure @xmath255 of the internal angle of @xmath256 corresponding to vertex @xmath257 .",
    "we will prove that , if @xmath258 , then the square of the diameter of @xmath256 increases by at least a constant ; if @xmath259 , then the area of @xmath256 increases by at least a constant .     increases by at least @xmath260    suppose that @xmath258 . let @xmath261 the diameter of @xmath174 , and let @xmath262 be such that @xmath263 .",
    "due to line  50 of algorithm  [ alg2 ] , and referring to figure  [ fig15 ] , it is easy to prove that @xmath264 hence @xmath265 because @xmath266 , it follows that @xmath267 , and @xmath268 .",
    "therefore , by the law of cosines applied to triangle @xmath269 , @xmath270 hence , in this case , the square of the diameter of @xmath175 increases by at least @xmath271 .",
    "increases by at least @xmath272    let @xmath259 , and let @xmath273 occupy the two vertices of @xmath256 adjacent to vertex @xmath257 , in such a way that @xmath274 as figure  [ fig5 ] shows .",
    "it follows that @xmath275 then , recalling that @xmath266 , we have that the area of @xmath175 increases at least by the area of the triangle @xmath276 , which in turn is at least @xmath277 @xmath278    concluding , every time a robot of @xmath166 moves , either the square of the diameter of @xmath175 increases by at least @xmath271 , or the area of @xmath175 increases by at least @xmath279 . but lemma  [ l : canmove ] states that there is always at least one robot of @xmath166 that is able to move , and therefore the robots will move infinitely many times , due to the fairness of the ssynchscheduler . from corollary  [ c :",
    "areadiameter ] , and from the fact @xmath271 and @xmath279 are positive constants , it follows that either the diameter or the area of @xmath175 grows unboundedly .",
    "this contradicts the fact that @xmath280 , and that @xmath39 is independent of @xmath2 .",
    "due to lemma  [ l : intfinal ] , all robots become external at some point , and it remains to show that they finally reach a _ strictly _ convex configuration and correctly terminate .",
    "this turns out to be a significantly easier task .",
    "[ l : extfinal ] if algorithm  [ alg2 ] is executed from a configuration in which all robots are external and no robot s light is set to _ adjusting _ , then after finitely many turns all robots have terminated , no two of them have collided , and the configuration is strictly convex .    in the vertex adjustments phase , each robot eventually sets its own light to _ external _ ( if it has not already done so in the interior depletion phase ) .",
    "meanwhile , as soon as a vertex robot @xmath12 sees only robots whose lights are set to _",
    "external _ , it sets its own light to _ adjusting _ and makes a default move , as in figure  [ fig1:b ] .",
    "recall that robots are non - rigid , hence a vertex robot may be stopped before reaching its destination , but not before having moved by at least @xmath11 .",
    "when @xmath12 is activated again , it sees itself in the _ adjusting _ state and , if it sees a robot set to _ off _ , it necessarily also sees a robot set to _",
    "external_. indeed , after the default move , @xmath12 can see all the robots in the swarm .",
    "note that , if a robot is set to _ adjusting _ , neither of its two neighbors on the perimeter of the convex hull can be _",
    "off_. hence , if @xmath12 sees a robot set to _ off _ , and since it sees itself set to _ adjusting _ , it must also see a robot set to _",
    "external_. therefore @xmath12 sets its light back to _ external _ ( lines  2123 ) , thus allowing other robots to move .",
    "@xmath12 also terminates because , as already noted , its two neighbors can not be _ off _",
    "( line  24 ) and , since @xmath12 sees every robot in the swarm and the configuration is convex , @xmath12 does not see any internal robots ( line  25 ) .",
    "as observed in section  [ s : ssynch ] , where a similar procedure was used to reduce the size of the convex hull while increasing the set of vertex robots , when a robot occupying a vertex of the convex hull moves , it becomes a vertex of the new convex hull . on the other hand ,",
    "if a robot @xmath12 lies in the interior of an edge of the convex hull and one of its two neighbors @xmath13 lies on a vertex , then , as soon as @xmath13 moves , @xmath12 becomes a vertex of the new convex hull .",
    "hence , eventually all robots become vertices of the convex hull . after that",
    ", whenever a robot is activated , it permanently sets its light to _ external _ and terminates .",
    "it follows that eventually all robots terminate in a strictly convex configuration .",
    "moreover , by the observations already made in section  [ s : invariants ] , and referring to figure  [ fig2 ] , it is clear that no collisions can occur in this phase .      from lemmas  [ l : intfinal ] and  [ l : extfinal ]",
    ", the correctness of algorithm  [ alg2 ] immediately follows , provided that the robots are not initially collinear .",
    "this case is considered in the following .",
    "[ t : correctness2 ] algorithm  [ alg2 ] solves mutual visibilityfor non - rigid  ssynchrobots with 3-colored lights .    due to lemmas  [ l : intfinal ] and  [ l : extfinal ] , we only have to show that the case in which the robots are initially collinear correctly evolves into one of the other cases . if @xmath177 , this is easy to verify through a case analysis , following the algorithm s description of section  [ s : alg2descr ] .",
    "so , let @xmath281 , and let robots @xmath12 and @xmath13 initially occupy the vertices of the line segment @xmath282 .",
    "nothing happens until @xmath12 or @xmath13 is activated ; then , at least one of them becomes _ adjusting _ and moves orthogonally to @xmath42 .",
    "after @xmath12 or @xmath13 has moved , some robots eventually become _ external _ ( line  35 ) . indeed ,",
    "if both @xmath12 and @xmath13 move , then all other robots can see both of them .",
    "in particular , there is at least one such robot occupying a non - degenerate vertex of the convex hull , which sees two _ adjusting _ robots , and therefore becomes _ external _ ( line  33 ) .",
    "if only @xmath12 moves ( or vice versa ) , then @xmath13 sees only three robots ( including itself ) , and its corresponding convex hull angle is acute , hence it becomes _ external _ ( line  32 ) . in the latter case , only @xmath13 is allowed to become _ external _ , while the other robots wait , because their corresponding angles are not acute .",
    "when a robot has become _ external _ , any robot that was _ adjusting _ can see it , and hence becomes _ external _ as well .",
    "if , in addition , neither of its two neighbors is _ off _ , it also terminates ( note that an _ adjusting _ robot must be located on the convex hull s boundary ) .    at this point",
    "the execution proceeds normally , except that there may be one of two vertex robots that have already terminated , and we have to show that this does not prevent the others from forming a strictly convex configuration . obviously the interior depletion phase causes no trouble and it is carried out correctly , but the vertex adjustments phase might `` get stuck '' .",
    "we will prove that this is not the case .",
    "clearly , if at most one robot has terminated , all robots except perhaps one are able to move in the vertex adjustments phase , and therefore they all become non - degenerate vertices .",
    "if @xmath12 and @xmath13 initially move in the same direction , they become neighboring vertices , and all the other robots become consecutive external robots .",
    "it is easy to see that in this case the external robots are still able to make adjusting movements in cascade , and become non - degenerate vertices .",
    "finally , suppose that @xmath12 and @xmath13 initially move in opposite directions .",
    "let @xmath167 be the robot closest to @xmath12 , and @xmath283 the robot closest to @xmath13 .",
    "since @xmath281 , @xmath284 .",
    "as already noted , at least one between @xmath167 and @xmath283 becomes a non - degenerate vertex of the convex hull , say @xmath167 . on the other hand , depending on how much @xmath12 and @xmath13 move",
    ", @xmath283 may become internal , or a degenerate or non - degenerate vertex of the convex hull .",
    "if @xmath283 becomes internal , as in figure  [ fig10b : a ] , then both @xmath12 and @xmath13 see an internal robot : indeed , after the move , @xmath12 and @xmath13 can see all robots .",
    "then , @xmath12 and @xmath13 become _ external _ but do not terminate ( line  25 ) , and everything works as intended in the later phases . if @xmath283 becomes a degenerate vertex of the convex hull , as in figure  [ fig10b : b ] , then it is an _ off _ neighbor of both @xmath12 and @xmath13 , which once again become _ external _ but do not terminate ( line  24 ) .",
    "again , the execution transitions seamlessly into another phase .",
    "if @xmath283 becomes a non - degenerate vertex of the convex hull , as well as @xmath167 , then all the robots between them become internal .",
    "note that , in this case , @xmath12 and @xmath13 may terminate ( indeed , they may not be able to see each other , and hence they may not realize that there are internal robots ) , but they do not lie at adjacent vertices of @xmath42 , due to the presence @xmath167 and @xmath283 . after the interior depletion phase , @xmath167 and @xmath283 are able to adjust , thus enabling all other external robots to become non - degenerate vertices , in cascade .",
    "in this section we briefly touch on the asynchmodel . in the rigidcase , we show that algorithm  [ alg2 ] solves the mutual visibilityproblem . in the non - rigidcase",
    ", we show how to solve mutual visibilityassuming that the robots agree on the direction of one coordinate axis .",
    "algorithm  [ alg2 ] turns out to solve the mutual visibilityproblem for rigid  asynchrobots , as well . for the interior depletion phase ,",
    "the collision avoidance proof gets slightly more complex , but termination is easier to prove . on the other hand , the vertex adjustments phase and the segment breaking phase work almost in the same way .",
    "first we state an equivalent of lemma  [ l : coll1 ] .",
    "the only difference is that , instead of a generic time @xmath173 , now we have to consider a specific time @xmath285 at which a robot @xmath12 performs a _",
    "look_. also , instead of considering the position of @xmath12 at time @xmath56 , we consider the destination point computed after such a _ look_. after these changes , the proof of lemma  [ l : coll1 ] works in the asynchcase as well , and therefore we have the following .",
    "[ l : coll3 ] let rigid  asynchrobots execute algorithm  [ alg2 ] , and let @xmath12 and @xmath13 be two internal robots at time @xmath285 . if @xmath12 executes a _ look_phase at time @xmath2 , and the next destination point of @xmath12 is @xmath1 , then @xmath286    the previous lemma can be used to prove that no collisions occur during the interior depletion phase .",
    "[ l : coll3b ] if rigid  asynchrobots execute algorithm  [ alg2 ] from a non - collinear configuration , no collisions occur as long as there are internal robots .",
    "suppose for a contradiction that the internal robot @xmath12 performs a _",
    "look_at time @xmath2 , then robot @xmath13 performs a _",
    "look_at time @xmath207 , and they collide at time @xmath287 , in @xmath288 .",
    "we may further assume that this is the first collision between the two robots , and therefore @xmath289 .",
    "because the model is rigidand each internal robot s destination point is on the convex hull , it follows that each internal robot makes exactly one move and then becomes external .",
    "therefore , @xmath14 , @xmath208 , @xmath290 , and the destination point of @xmath12 are all collinear , and the same holds for @xmath13 .",
    "additionally , we have @xmath291 ( see figure  [ fig9 ] ) .        by lemma  [ l : coll3 ]",
    "applied to @xmath13 at time @xmath292 , and because @xmath293 lies between @xmath294 and the destination point of @xmath13 , we have @xmath295 on the other hand , @xmath296 , implying that @xmath297 by adding the two inequalities together , we obtain @xmath298 recall that @xmath299 and that @xmath208 lies between @xmath14 and @xmath290 , and therefore the last inequality implies @xmath300 hence @xmath301 and @xmath302 but we already know that the right - hand side is not positive , hence so is the left - hand side : @xmath303 now , by lemma  [ l : coll3 ] applied to @xmath12 at time @xmath2 , and recalling that @xmath290 lies between @xmath14 and the destination point of @xmath12 , we have @xmath304 if we add together the last two inequalities and we recall that @xmath305 , we get @xmath306 because @xmath288 and @xmath305 , we finally obtain @xmath307 which is equivalent to @xmath308 , implying that @xmath18 , a contradiction .",
    "we can now prove that algorithm  [ alg2 ] works also with rigid  asynchrobots .",
    "[ t : correctness3 ] algorithm  [ alg2 ] solves mutual visibilityfor rigid  asynchrobots with 3-colored lights .    in the interior depletion phase there can be no collisions , due to lemma  [ l : coll3b ] . also , whenever an internal robot moves , its destination lies on the boundary of the `` real '' @xmath42 ( cf .  line  53 of algorithm  [ alg2 ] ) .",
    "since movements are rigid , such a robot becomes external in a single move .",
    "suppose for a contradiction that the interior depletion phase does not terminate .",
    "then , at some point , the set of external robots reaches a maximum , all the external robots are set to _ external _ , and no robot is moving ( indeed , moving internal robots are bound to become external ) .",
    "hence , lemma  [ l : canmove ] can be applied . as a consequence",
    ", there is some internal robot that is able to move , and which will therefore reach the convex hull s perimeter at the end of its next _ move_phase , thus becoming external .",
    "this contradicts our assumptions .",
    "therefore , in finite time all robots become external , and the interior depletion phase terminates .    when all robots are external , none of them moves unless it sees only robots set to _ external _ ( line  27 ) .",
    "this means that , in the vertex adjustments phase , a robot waits until it is sure that no robot is in the middle of a move ( note that this holds also for robots that it can not see , because as soon as one of them moves it becomes visible to all other robots ) .",
    "indeed , a robot sets itself to _ adjusting _ right before starting to move and sets itself back to _",
    "external _ when it is done moving .",
    "hence the robots synchronize themselves , and we may pretend them to be ssynch , as opposed to asynch . then , the proof proceeds exactly as in lemma  [ l : extfinal ] .    in the case in which the robots are initially collinear",
    ", the proof follows the lines of theorem  [ t : correctness2 ] , with a few differences . indeed , despite being asynch , the robots manage to wait for each other and synchronize their actions .",
    "suppose that one endpoint robot @xmath12 becomes _ adjusting _ and starts moving to its destination .",
    "then , every robot is bound to wait for the other endpoint robot , @xmath13 , to take action .",
    "so , @xmath13 could either become _ adjusting _ as well and start moving ( if it performed its _",
    "look_before @xmath12 started moving ) , or it could notice @xmath12 and become _",
    "external_. if @xmath12 and @xmath13 are both _ adjusting _ and moving asynchronously ,",
    "some other robots eventually become _ external _ , but do not move yet .",
    "in particular , referring to figure  [ fig10 ] , at least robots @xmath167 and @xmath283 can become external in this phase .",
    "notice that , if @xmath12 and @xmath13 move asynchronously in opposite directions ( figure  [ fig10:b ] ) , @xmath167 and @xmath283 may switch between being internal and being external several times . however , as soon as they set their light to _ external _ , they do not set it back to _ off _ even if they become internal again .",
    "but @xmath12 moves exactly by @xmath309 , and @xmath13 moves exactly by @xmath310 ( line  12 ) , because the model is rigid .",
    "this movement length is chosen in such a way that both @xmath167 and @xmath283 eventually become vertex robots , as figure  [ fig10:b ] suggests .",
    "therefore the colors of @xmath167 and @xmath283 are eventually consistent , despite asynchrony .",
    "so , every robot waits for both @xmath12 and @xmath13 to see some _ external _ robots and thus become _ external _ themselves . only then",
    "do other robots start moving ( lines  2629 ) . as a consequence",
    ", we may once again pretend that the robots in this phase are ssynch , and the proof is completed as in theorem  [ t : correctness2 ] .",
    "unfortunately , for non - rigid  asynchrobots , our correctness proof of the interior depletion phase of algorithm  [ alg2 ] fails .",
    "indeed , to prove collision avoidance , we used in a crucial way the fact that , if two internal robots are moving at the same time , then at most one of them saw the other robot in the middle of a movement .",
    "this is true under the non - rigid  ssynchmodel ( obviously ) and under the rigid  asynchmodel ( because each internal robot becomes external after only one move ) , but not under the non - rigid  asynchmodel . in this model , an internal robot @xmath12 may perform different moves in different directions before becoming external . for instance , if @xmath12 s first movement is stopped by the adversary and , in the meantime , new robots have become _ external _ or new robots have become visible , @xmath12 may decide to move in a significantly different direction the second time .",
    "this , paired with the ability of the asynchscheduler to hold a moving robot for an indefinitely long time and then release it and let it complete its move , does cause collisions in some ( quite pathological ) cases . on the other hand , however , the vertex adjustments phase of algorithm  [ alg2 ] works under all models ; therefore we only need to replace the interior depletion phase and the segment breaking phase .    with the additional assumption that all robots agree on one axis , there is an easy way to fix the interior depletion phase , which is illustrated in figure  [ fig6 ] .",
    "say that the robots agree on the @xmath311 axis , i.e. , they agree on the `` north '' direction , but they may disagree on `` east '' and `` west '' . then , if an internal robot sees that every robot that lies to the north is set to _",
    "( i.e. , if its own @xmath311 coordinate is maximum among the internal robots ) , it is eligible to move . if there is a row of several internal robots that are all eligible to move ( as in figure  [ fig6 ] ) , then only the two endpoints are allowed to move , and the others wait .",
    "the left endpoint moves to the upper - left quadrant , and the right endpoint moves to the upper - right quadrant , and their destination points are on the convex hull , but not on locations already occupied by external robots . to guarantee termination",
    ", we make each robot move straight to the north toward the boundary of the convex hull of the visible robots , unless there are external robots in the way . in this special case",
    ", we make the robot move slightly sideways .",
    "also the protocol for the segment breaking phase needs some modifications : indeed , referring to figure  [ fig10:b ] , in which @xmath12 and @xmath13 move in opposite directions , it is no longer true that @xmath167 and @xmath283 will eventually be external robots when @xmath12 and @xmath13 stop ( recall that robots are non - rigidnow ) . unfortunately , @xmath167 and @xmath283 may become temporarily external while @xmath12 and @xmath13 move , and thus they may ( permanently ) set themselves to _ external _ , which could lead to inconsistent behaviors . once again , we can fix the protocol if the robots agree on the @xmath311 axis : now , in the segment breaking phase , an endpoint robot moves according to algorithm  [ alg2 ] only if it has the maximum @xmath311 coordinate .",
    "this makes only one endpoint move in most cases , which eliminates the aforementioned issue .",
    "moreover , if both endpoints have the same @xmath311 coordinate , they will both move north , thus forming a configuration like the one in figure  [ fig10:a ] , which causes no trouble .",
    "the mutual visibilityproblem is solvable by non - rigid  asynchrobots carrying 3-colored lights , provided that they agree on one axis .",
    "we show that the above algorithm is correct . in the interior depletion phase",
    ", there can be no collisions , and each internal robot eventually reaches the convex hull . indeed , suppose that initially there is a unique internal robot @xmath12 with largest @xmath311 coordinate .",
    "as soon as enough external robots have set themselves to _ external _ , @xmath12 starts moving north , and no other robot moves .",
    "eventually @xmath12 becomes external without colliding with any robot ( note that , even if @xmath12 does not initially see the boundary of the convex hull , it will eventually see it after finitely many moves ) .",
    "if several internal robots have the largest @xmath311 coordinate , as in figure  [ fig6 ] , the argument is similar . at most two robots",
    "can move at the same time , and they can not collide because the difference of their @xmath33 coordinates can not decrease . after enough cycles , either they have reached the convex hull , or one of them has been `` left behind '' and is no longer eligible to move . either way , at least one internal robot eventually becomes external .",
    "once an internal robot has become external , the same argument repeats for all other internal robots .",
    "note that these `` sub - phases '' do not interfere with each other , because a new robot becomes eligible to move only after the previous eligible robots have stopped on the convex hull .",
    "the moment the last internal robot becomes external , no robot is moving , and therefore the whole swarm correctly transitions to the vertex adjustments phase , which works exactly as described in theorem  [ t : correctness3 ] and lemma  [ l : extfinal ] .",
    "if the robots are initially collinear , they correctly transition to a non - collinear configuration , as in theorem  [ t : correctness3 ] .",
    "indeed , note that the two endpoint robots can not move in opposite directions ( as in figure  [ fig10:b ] ) , and hence it does not matter if they are rigidor non - rigid , since in this case it is not harmful if they move by smaller amounts than those indicated by algorithm  [ alg2 ] ( cf .  figure  [ fig10:a ] ) . the same clearly holds if @xmath178 and the middle robot executes line  16 .",
    "here we discuss some applications of the previous mutual visibilityalgorithms to other problems , and we also discuss different robot models .",
    "as already observed , algorithm  [ alg1 ] also solves the convex formationproblem , where the robots have to terminate in a strictly convex position .",
    "moreover , no robot ever crosses the perimeter of the initial convex hull unless , of course , all the robots are initially collinear .",
    "this works for rigid  ssynchrobots carrying 2-colored lights .    for non - rigid  ssynchrobots carrying 3-colored lights ,",
    "algorithm  [ alg2 ] also solves the convex formationproblem , but it has an additional property : during the interior depletion phase , the convex hull of the robots remains unaltered ( unless all robots are collinear ) , and in the vertex adjustments phase it shrinks a little , due to the small movements of the vertices .",
    "we can actually make these movements as small as we want , by changing line  29 of algorithm  [ alg2 ] into @xmath312 where @xmath313 is an arbitrarily - chosen positive constant .",
    "similarly , in lines  12 and  16 we can make the robot move orthogonally to @xmath42 by @xmath313 or less . as a result",
    ", we can guarantee that the robots will terminate in a ( strictly convex ) configuration whose vertices are contained in an @xmath313-wide band around the initial convex hull s perimeter .",
    "similar observations hold for the algorithms and models discussed in section  [ s : asynch ] .      as a followup to algorithms  [ alg1 ] and  [ alg2 ]",
    ", the robots can even solve the circle formationproblem , in which they have to become concircular and then terminate . moreover , if they are rigid  ssynch(respectively , non - rigid  ssynch ) , they can do so with the same 2-colored ( respectively , 3-colored ) lights that they used to solve mutual visibility .",
    "first , it is necessary to slightly modify the termination condition of the algorithms : in algorithm  [ alg1 ] , when a robot sees only robots set to _",
    "vertex _ , it does not terminate , but it starts executing a _ circle formation _ phase .",
    "similarly , in algorithm  [ alg2 ] , we remove lines  2325 , thus preventing vertex robots from reverting their color to _ external _ and terminating after they have adjusted their position .",
    "instead , they wait until they only see robots set to _",
    "adjusting_. accordingly , in lines  27 and  36 we remove the conditions that prevent robots from moving if they see other robots set to _",
    "adjusting_. since we are assuming that robots are ssynch , it is straightforward to see that the correctness proof of section  [ s : ssynch2 ] goes through even after these modifications to the protocol , and that eventually all robots are set to _",
    "adjusting_. at this point , the circle formation phase starts .    since all robots are set to _ adjusting _",
    ", each robot knows that all of them occupy non - degenerate vertices of the convex hull , and that there are no other robots in the swarm .",
    "hence the phase starts in a strictly convex configuration , and all the robots see each other .",
    "in particular , the _",
    "smallest enclosing circle _",
    "( sec ) computed by each active robot is the same . in the circle formation phase ,",
    "the robots move toward the perimeter of the sec in a precise order , as illustrated in figure  [ fig7 ] .",
    "if a robot lies in @xmath1 , which is not on the sec , and one of its neighbors lies in @xmath13 , which is on the sec , then the robot in @xmath1 moves along the extension of the edge of the convex hull that is incident to @xmath1 and not to @xmath13 .",
    "if both neighbors of the robot lie on the sec ( as with the robot in @xmath3 in figure  [ fig7 ] ) , it chooses one of its two incident edges , and moves along the extension of that edge .",
    "it is clear that the combined motion of the robots does not cause collisions or obstructions , and that the sec is always preserved .",
    "indeed , any robot that is already on the sec remains still , and those that are inside the sec are allowed to move only within the sec itself .",
    "moreover , the direction in which each robot moves is preserved until one of them reaches the sec . hence , even if robots are non - rigid , after finitely many turns at least one of them reaches the sec , and therefore eventually they all reach the sec . at this point",
    ", they correctly terminate .",
    "the same circle formation phase can also be used in conjunction with the algorithms discussed in section  [ s : asynch ] for asynchrobots .",
    "the only difference is that , instead of modifying the asynchalgorithms like we did with the ssynchones , we simply add an extra state , called _ done _ , to synchronize robots and make them transition correctly from the vertex adjustments phase into the circle formation phase .",
    "that is , instead of terminating , a robot sets itself to _ done _ , and then waits until all other robots are set to _ done _ , as well",
    ". only then does it proceed to executing the circle formation phase described above .",
    "of course , before the circle formation phase starts , if a robot sees another robot set to _ done _ , it treats its like an _ external _ robot .",
    "this works with both rigidand non - rigid  asynchrobots carrying 4-colored lights .",
    "a simple modification of algorithm  [ alg1 ] solves the near - gatheringproblem , which requires all the robots to converge to a point without colliding : it is sufficient to remove lines  8 , 9 , and  23 , that is , all the operations involving colors , and the termination condition .",
    "indeed , if there is only one internal robot , either it will become external , or the other robots will converge to its location . on the other hand ,",
    "if all robots become external , the convex hull will keep shrinking until its vertices converge to a point .",
    "this works for rigid  ssynchrobots , even without the use of colored lights .",
    "however , if the robots carry 2-colored lights , they can also terminate when they get close enough to one another .",
    "this is done by simply modifying the termination condition of line  9 : @xmath314 where @xmath313 is any given positive constant .",
    "suppose that the robots are non - rigid  ssynch , and as such they can be stopped by the scheduler at each turn before they reach their destination point , but not before they have moved by at least @xmath24 .",
    "recall that in this case they have an algorithm for mutual visibilitythat uses 3-colored lights , described in section  [ s : ssynch2 ] .",
    "however , if the robots know the exact value of @xmath24 and they can use it in their computations , they can solve mutual visibilityeven with 2-colored lights , by executing a slightly modified version of algorithm  [ alg1 ] .    if all the robots are initially collinear , algorithm  [ alg1 ] makes them reach a non - collinear configuration , even if they are non - rigid .",
    "subsequently , the invariants discussed in section  [ s : invariants ] keep holding , and in particular the convex hull of the robots never grows , and vertex robots never become non - vertex robots . we have to show that a version of lemma  [ l : main ] can be obtained for this model , as well .",
    "referring to figure  [ fig1 ] , we can make the robot in @xmath1 move toward @xmath315 by a smaller amount , never passing internal robots , and never colliding with them , unless they are closer than @xmath24 .",
    "if an internal robot @xmath12 is closer than @xmath24 and it stands between @xmath1 and @xmath315 , the robot in @xmath1 moves close enough to @xmath12 , on the line parallel to @xmath52 , and it sets its light to the correct value ( note that it knows before moving whether it will end up being a vertex robot or not ) .",
    "this `` lateral move '' can not be stopped by the scheduler , and it is guaranteed to create a new external robot , and eventually increase by one the number of vertex robots .",
    "on the other hand , if only `` non - lateral moves '' are made , the analysis in section  [ s : convergence ] can be generalized , because equation  [ e : default ] takes the form @xmath316 where @xmath317 $ ] , and @xmath318 is a constant . indeed ,",
    "if the convex hull of the robots never grows , and its initial diameter is @xmath319 , then each moving robot is guaranteed to move by at least a fraction of @xmath320 of its computed movement vector .",
    "therefore , all the lemmas in section  [ s : convergence ] can be reproved by merely adjusting some coefficients in the formulas .",
    "it remains to prove that , if only one internal robot is left , it eventually reaches the boundary of the convex hull without colliding with other robots .",
    "but since @xmath24 is known , we can make this robot stay still until it either becomes external ( due to other robots movements ) , or the diameter of the convex hull becomes smaller than @xmath24 .",
    "as soon as it is guaranteed to make a reliable move , it can reach the midpoint of an edge of the convex hull , and therefore become external .",
    "when all robots are external , they eventually reach a strictly convex configuration and they correctly terminate , as detailed in the proof of theorem  [ t : correctness ] .",
    "suppose that the robots do not carry visible lights and have no internal memory , but they share the knowledge of the total number of robots in the swarm , @xmath21 . if the robots are rigid  ssynch , it is possible to slightly modify algorithm  [ alg1 ] to solve mutual visibilityin this model , as well .",
    "note that the information given by other robots visible lights is used only when a robot has to terminate ( line  9 ) , or when it is the only internal robot and it has to move to the perimeter of the convex hull ( line  23 ) .",
    "however , both these situations can be recognized locally by counting the vertices of the convex hull of the visible robots : if it has @xmath21 non - degenerate vertices , mutual visibilityhas been solved , and the executing robot can terminate .",
    "if the convex hull has @xmath123 vertices and the executing robot is internal , it moves to the boundary , as in line  23 of algorithm  [ alg1 ] .",
    "the same techniques can be used to modify the algorithm of section  [ s : delta ] , so that non - rigid  ssynchrobots with knowledge of @xmath24 and knowledge of @xmath21 can solve mutual visibilitywithout the use of colored lights .",
    "we are also able to optimize algorithm  [ alg2 ] for robots with knowledge of @xmath21 : namely , we can achieve termination detection even if the robots do not use the _ adjusting _ color , as follows .",
    "when all robots are external and a vertex robot makes a default move , it does not change its color , but remains _",
    "external_. then , when a vertex robot sees @xmath21 robots , it terminates .",
    "note that making a default move allows a robot to see all other robots at its next activation , and therefore each external robot makes at most one default move before terminating .",
    "moreover , when all robots are collinear , we apply this simple protocol : if a robot is an endpoint of the convex hull , it moves orthogonally to it ( without changing color ) ; otherwise it stays still . this way , as soon as an endpoint is activated",
    ", the configuration becomes non - collinear .",
    "the only exception to this rule is the case @xmath178 , in which the central robot has to move orthogonally to the segment , while the other two robots stay still .",
    "this technique allows non - rigid  ssynchrobots with knowledge of @xmath21 to solve mutual visibilitywith 2 colors as opposed to 3 .",
    "observe that lemma  [ l : vessels ] requires only @xmath123 valves to be opened infinitely often , as opposed to @xmath21 .",
    "this implies that , if rigid  ssynchrobots execute the modification of algorithm  [ alg1 ] described in section  [ s : nearg ] , they converge to a point even if one robot is unable to move .",
    "therefore , in the presence of one faulty robot , near - gatheringis still solvable , even without the use of colored lights .",
    "( on the other hand , if two robots are faulty , near - gatheringis clearly unsolvable , because the two faulty robots can not approach each other . ) additionally , if @xmath21 is known , mutual visibilityand convex formationare solved in the presence of a faulty robot , provided that it is located on the boundary of the convex hull .",
    "suppose that the scheduler is _ sequential _",
    ", i.e. , it is ssynchand it activates exactly one robot at each turn . in this very special model there is a simple algorithm to solve mutual visibilitywith no termination detection , even with no colored lights and no knowledge of @xmath21 , and even if the robots are non - rigidand two of them are faulty .",
    "( if three robots are faulty , mutual visibilityis clearly unsolvable . )",
    "when a robot is activated , it just moves by a small amount , without crossing or landing on any line that passes through two robots that it can currently see ( including itself ) , as illustrated in figure  [ fig8 ] .",
    "clearly , when a robot moves as described , it becomes visible to all other robots .",
    "hence , when all robots ( except possibly two of them ) have moved at least once , they can all see each other .",
    "this protocol solves mutual visibilitywith no termination detection , in the sense that , after finitely many turns , the robots will keep seeing each other .",
    "however they will never stop moving because they will never know if their task is terminated or not .",
    "indeed , termination detection is not achievable under this set of assumptions and , to be able to obtain it , some other assumptions are needed ; for example , 2-colored lights or the knowledge of @xmath21 . with 2-colored lights , a robot can change its own color the first time it moves , and terminate at the next activation .",
    "with knowledge of @xmath21 , a robot simply terminates when it sees @xmath21 robots .",
    "in this paper we initiated the investigation of the computational capabilities of a swarm of anonymous mobile robots with obstructed visibility : in this model , which has never been considered in the literature , two robots can not see each other if a third robot lies between them .",
    "we focused on the basic problem of mutual visibility , in which the robots , starting from an arbitrary configuration , have to reach a configuration in which they all see each other , and then terminate the execution .",
    "this task is clearly impossible if the robots are completely oblivious , unable to communicate , and do not have any additional information . indeed , in this scenario a robot can never distinguish between an initial configuration in which it can not see some other robots , and a configuration in which all robots are visible and it is safe to terminate ( recall that the termination operation can not be undone ) .",
    "therefore we employed the extended model of luminous robots , in which each robot is carrying a visible light that it can set to different colors .",
    "the goal is then to minimize the number of colors required by the robots to solve the mutual visibilityproblem under different settings and restrictions .",
    "namely , we considered ssynchand asynchrobots , and rigidand non - rigidmovements .",
    "we also discussed how to reduce the number of used colors if some information is given to the robots , such as the size of the swarm , @xmath21 , or a minimum distance @xmath24 that a robot is guaranteed to cover in each movement .",
    "our main results are summarized in theorems  [ t : sum1 ] and  [ t : sum2 ] .",
    "we then touched on more complex problems , and proposed solutions that use our mutual visibilityprotocols as a preprocessing step .",
    "notably , we gave the first algorithms for the near gatheringproblem ( with fault tolerance ) and the circle formationproblem that work under the obstructed visibility model .",
    "we proposed two main algorithms , and several modifications and adaptations to various models .",
    "algorithm  [ alg1 ] ( _ shrink _ ) uses 2 colors and makes the convex hull of the robots shrink , ideally converging to a point .",
    "algorithm  [ alg2 ] ( _ contain _ ) uses 3 colors , and keeps the initial convex hull basically unaltered .",
    "it is therefore suited for practical situations in which the robots have to surround a large - enough area , as well as solving mutual visibility . also , both algorithms keep the robots within the initial convex hull ( unless they are initially collinear ) , which is useful in practice , for instance in the presence of hazardous areas around the swarm .",
    "some interesting research problems remain unsolved .",
    "we would like to reduce the number of colors used by our algorithms in the various models , or to prove our algorithms optimal .",
    "our solutions to mutual visibilityin some models use only 2 colors ( or no lights at all if @xmath21 is known ) , which is clearly optimal . for other models , such as non - rigid  ssynchand rigid  asynch",
    ", we used 3 colors , and our question is whether this can be improved .",
    "we conjecture that algorithm  [ alg1 ] , which uses only 2 colors and has been designed and proven correct for rigid  ssynchrobots , can be applied with no changes also to non - rigid  ssynchrobots ( we could prove that 2 colors are sufficient in this model under the assumption that the robots know  @xmath24 ) . in the non - rigid  asynchsetting we were only able to solve mutual visibility(with 3 colors ) assuming that the robots agree on the direction of one coordinate axis .",
    "we ask if this assumption can be dropped , perhaps if more colors are used .",
    "another question is whether mutual visibilitycan be solved deterministically without using colored lights or extra information , and without termination detection . that is",
    ", we allow the robots to move forever , but we require them to remain mutually visible from a certain time on .",
    "we proposed a simple solution that works under the sequential scheduler , and we ask if this can be generalized to ssynchor even asynchschedulers .",
    "we emphasize that obstructed visibility represents a broad line of research in the field of computation by mobile robots , and this paper explored just a few directions .",
    "several classical problems are worth studying under this model , such as the general pattern formation problem , flocking , scattering , with or without bounded visibility , etc .            c.  agathangelou , c.  georgiou , and m.  mavronicolas . a distributed algorithm for gathering many fat mobile robots in the plane . in _ proceedings of the 32nd acm symposium on principles of distributed computing ( podc ) _ , pages 250259 , 2013 .",
    "z.  bouzid , s.  dolev , m.  potop - butucaru , and s.  tixeuil .",
    "robocast : asynchronous communication in robot networks . in _ proceedings of the 14th international conference on principles of distributed systems ( opodis )",
    "_ , lncs 6490 , pages 1631 , 2010 .",
    "k.  bolla , t.  kovacs , and g.  fazekas .",
    "gathering of fat robots with limited visibility and without global navigation . in _ proceedings of the international symposium on swarm and evolutionary computing _ , pages 3038 , 2012 .",
    "i.  chatzigiannakis , m.  markou , and s.  nikoletseas .",
    "distributed circle formation for anonymous oblivious robots . in _ proceedings of the 3rd international workshop on experimental and efficient algorithms ( wea ) _ , pages 159174 , 2004 .",
    "s.  das , p.  flocchini , g.  prencipe , n.  santoro , and m.  yamashita .",
    "the power of lights : synchronizing asynchronous robots using visible bits . in _ proceedings of the 32nd international conference on distributed computing systems ( icdcs ) _ , pages 506515 , 2012 .",
    "s.  datta , a.  dutta , s.  gan  chaudhuri , and k.  mukhopadhyaya .",
    "circle formation by asynchronous fat robots . in _ proceedings of the 9th international conference on distributed computing and internet technology ( icdcit ) _ , pages 195207 , 2013 .",
    "x.  dfago and a.  konagaya .",
    "circle formation for oblivious anonymous mobile robots with no common sense of orientation . in _ proceedings of the 2nd acm international workshop on principles of mobile computing ( pomc ) _ , pages 97104 , 2002 .",
    "a.  efrima and d.  peleg .",
    "distributed models and algorithms for mobile robot systems . in _ proceedings of the 33rd international conference on current trends in theory and practice of computer science ( sofsem ) _ ,",
    "pages 7087 , 2007 .",
    "flocchini , g.  prencipe , n.  santoro , and g.  viglietta .",
    "distributed computing by mobile robots : solving the uniform circle formation problem . in _ proceedings of the 18th international conference on principles of distributed systems ( opodis ) _ , pages 217232 , 2014 .",
    "p.  flocchini , n.  santoro , g.  viglietta , and m.  yamashita .",
    "rendezvous of two robots with constant memory . in _ proceedings of the 20th international colloquium on structural information and communication complexity ( sirocco ) _ , pages 189200 , 2013 .",
    "b.  katreniak .",
    "biangular circle formation by asynchronous mobile robots . in _ proceedings of the 12th international colloquium on structural information and communication complexity ( sirocco ) _",
    ", 185199 , 2005 .",
    "d.  peleg .",
    "distributed coordination algorithms for mobile robot swarms : new directions and challenges . in _ proceedings of the 7th international workshop on distributed computing ( iwdc ) _ ,",
    "pages 112 , 2005 .",
    "g.  viglietta .",
    "rendezvous of two robots with visible bits . in _ proceedings of the symposium on algorithms and experiments for sensor systems , wireless networks and distributed robotics ( algosensors ) _ , pages 291306 , 2013 ."
  ],
  "abstract_text": [
    "<S> consider a finite set of identical computational entities that can move freely in the euclidean plane operating in look - compute - move cycles . </S>",
    "<S> let @xmath0 denote the location of entity @xmath1 at time @xmath2 ; entity @xmath1 can see entity @xmath3 at time @xmath2 if at that time no other entity lies on the line segment @xmath4 . </S>",
    "<S> we consider the basic problem called mutual visibility : starting from arbitrary distinct locations , within finite time the entities must reach , without collisions , a configuration where they all see each other . </S>",
    "<S> this problem must be solved by each entity autonomously executing the same algorithm . </S>",
    "<S> we study this problem in the _ luminous robots _ model ; in this generalization of the standard model of oblivious robots , each entity , called _ robot _ , has an externally visible persistent light that can assume colors from a fixed set of size @xmath5 . </S>",
    "<S> the case where the number of colors is less than 2 ( i.e. , @xmath6 ) corresponds to the classical model without lights : indeed , having lights of one possible color is equivalent to having no lights at all .    the extensive literature on computability in such a model , mostly for @xmath6 and recently for @xmath7 , </S>",
    "<S> has never considered the problem of mutual visibilitybecause it has always assumed that three collinear robots are mutually visible .    in this paper </S>",
    "<S> we remove this assumption , and investigate under what conditions luminous robots can solve mutual visibilitywithout collisions , and at what cost , in terms of the number of colors used by the robots . </S>",
    "<S> we establish a spectrum of results , depending on the power of the adversary ( i.e. , the scheduler controlling the robots actions ) , on the number @xmath5 of colors , and on the a - priori knowledge the robots have about the system . among such results </S>",
    "<S> , we prove that mutual visibilitycan always be solved without collisions in ssynchwith @xmath8 colors and in asynchwith @xmath9 colors . </S>",
    "<S> if an adversary can interrupt and stop a robot before it reaches its computed destination , mutual visibilityis still solvable without collisions in ssynchwith @xmath9 colors , and , if the robots agree on the direction of one axis , also in asynch . </S>",
    "<S> all the results are obtained constructively by means of novel protocols .    as a byproduct of our solutions , </S>",
    "<S> we provide the first obstructed - visibility solutions to two classical problems for oblivious robots : _ collision - less convergence to a point _ </S>",
    "<S> ( also called _ near - gathering _ ) and _ circle formation_. </S>"
  ]
}