{
  "article_text": [
    "our first target is to construct the jacobian ring associated to a calabi - yau @xmath0 as described in section 2 of @xcite .",
    "this variety @xmath0 is defined by a matrix @xmath1 subject to the condition that all @xmath2-minors are non - zero . in practice",
    ", we work over the field @xmath3 or @xmath4 , @xmath5 prime , instead of @xmath6 . the matrices contained in the _ hyperelliptic locus _ were of special importance for us : these are of the form @xmath7 with @xmath8 , where @xmath9 denotes a tuple of @xmath10 distinct numbers in @xmath6 .",
    "the magma program below produces such an admissible matrix .",
    "there are three options :    * work with a user - defined matrix . in this case one",
    "sets randmat:=false and hyperell:=false .",
    "the line a:=rmatrixspace(k,4,8)!0 ; ( marked with `` modify here '' ) has to be replaced by a statement that defines the desired matrix , e.g.   + ....    a:=matrix(k , [      [   1 ,   1 ,   1 ,   1 ,   1 ,   1 ,   1 ,   1 ] ,      [   1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ] ,      [   1 ,   4 ,   9 , 16 , 25 , 36 , 49 , 64 ] ,      [   1 ,   8 , 27 , 64,125,216,343,512 ] ] ) ; .... + in this case the non - degeneracy condition is _ not _ checked ; it has to be ensured by the user . *",
    "use a random matrix . set randmat:=true and hyperell:=false .",
    "the program creates a random matrix in @xmath11 which satisfies the non - degeneracy condition .",
    "the parameter randrange specifies the maximal absolute value of the matrix coefficients that are created . *",
    "work with a user - defined matrix contained in the hyperelliptic locus . in this case",
    "put hyperell:=true , the value of randmat is irrelevant . in the line marked with `` modify here ''",
    "the definition la:= can be replaced by any tuple of @xmath10 distinct elements in @xmath12 .",
    "for our implementation we used magma version 2.11 - 2 .",
    "it was carried out under the operating system linux on an ordinary personal computer .",
    "the following program produces the desired matrix .    ....",
    "randmat      : = true ; randrange    : = 10 ; hyperell     : = true ;    k : = rationals ( ) ; a : = rmatrixspace(k,4,8)!0 ; //",
    "< = = modify here    genpos:=not(randmat ) and not(hyperell ) ; while not(genpos ) do      n:=randrange ;      if hyperell then          la:= [ ] ;          for i:=1 to 8 do              la[i]:=random(2*n-2)-n+1 ;          end for ;          la:=[1,2,3,4,5,6,7,8 ] ; //",
    "< = = modify here          a:= [ ] ;          for i:=0 to 3 do              a[i+1]:= [ ] ;              for j:=1 to 8 do                  a[i+1][j]:=la[j]^i ;              end for ;          end for ;      else          a:= [ ] ;          for i:=1 to 4 do              a[i]:= [ ] ;              for j:=1 to 8 do                  a[i][j]:=random(2*n-2)-n+1 ;              end for ;          end for ;      end if ;      a:=matrix(k , a ) ;      seq:=[1,2,3,4,5,6,7,8 ] ;      set:=sequencetoset(seq ) ;      subsets:=subsets(set,4 ) ;      res:=true ;      for su in subsets do          seq:=settosequence(su ) ;          b:= [ ] ;          for i:=1 to 4 do              b[i]:= [ ] ;              for j:=1 to 4 do                  b[i][j]:=a[j][seq[i ] ] ;              end for ;          end for ;          b:=matrix(k , b ) ;          res:=res and not(determinant(b ) eq 0 ) ;      end for ;      genpos:=res ; end while ; ....    in the first part of the program a random or hyperelliptic matrix is created according to the user specification . the second part is to check the non - degeneracy condition .",
    "this is done in the straightforward way : a loop runs through all @xmath13-element subsets @xmath14 , creates the submatrix that consists of the columns of @xmath15 given by the numbers in @xmath16 , and computes the determinant of this submatrix .",
    "in order to carry out explicit computations in the cohomology of @xmath0 one replaces the intersection of four quadrics given by the matrix @xmath15 by a certain toric hypersurface with defining equation @xmath17.\\ ] ] as outlined in section 4 of @xcite .",
    "the next step is to define the polynomial ring and the jacobian ideal associated to this hypersurface .",
    "the polynomial ring is created by    ....    pr:=polynomialring(k,12,\"glex \" ) ; xn:= [ ] ; for i:=0 to 7 do      xn[i+1]:=\"x \" cat integertostring(i ) ; end for ; yn:= [ ] ; for i:=1 to 4 do      yn[i]:=\"y \" cat integertostring(i ) ; end for ; assignnames(~pr , xn cat yn ) ; x:=function(i )      return pr.(1+i ) ; end function ; y:=function(i )      return pr.(8+i ) ; end function ; ....    the polynomial ring pr has @xmath18 variables @xmath19 which are accessed by x(@xmath20 ) and y(@xmath21 ) and diplayed as x@xmath20 , y@xmath21 , respectively .",
    "now the defining equation of the toric hypersurface can be computed from the coefficient matrix @xmath15 .    ....",
    "f:= [ ] ; for i:=1 to 4 do      f[i]:=pr!0 ;      for j:=0 to 7 do          f[i]:=f[i]+a[i][j+1]*x(j)^2 ;      end for ; end for ; f:=pr!0 ; for i:=1 to 4 do      f:=f+y(i)*f[i ] ; end for ; ....    the resulting equation is now stored in the variable f. finally , we define the jacobian ideal associated to this equation .    ....    i:= [ ] ; for i:=1 to 12 do      i:=append(i , derivative(f , i ) ) ; end for ; i:=ideal(i ) ; i:=groebnerbasis(i ) ; i:=idealwithfixedbasis(i ) ; ....",
    "in this section we describe how to determine a basis for the cohomology of @xmath0 as desribed in section 4 of @xcite . in section 2",
    "we defined an action on the ring pr by a certain finite group @xmath22 .",
    "the cohomology of @xmath0 is given by the @xmath22-fixed part of this ring modulo the jacobian ideal .",
    "it is a graded @xmath12-algebra @xmath23 where the component @xmath24 is generated by the monomials with total degree @xmath25 in the variables @xmath26 and total degree @xmath5 in @xmath27 .",
    "it follows that a basis of @xmath28 can be computed by the following procedure :    * enumerate all monomials of @xmath29-degree @xmath25 and @xmath30-degree @xmath5 . *",
    "discard all monomials which do not agree with their normal form with respect to the jacobian ideal .",
    "this yields a basis of @xmath24 . *",
    "discard all monomials which are not fixed by the action of @xmath22 .",
    "the remaining monomials constitute a basis of @xmath24 .    for ( i )",
    "we define two additional polynomial rings with @xmath10 and @xmath13 indeterminates , respectively .    ....",
    "xr:=polynomialring(k,8 ) ; yr:=polynomialring(k,4 ) ; ....    we also provide functions which map the indeterminates of xr to @xmath26 and the indeterminates yr to @xmath27 , respectively . using these functions",
    ", we are now able to enumerate all monomials of @xmath29-degree @xmath20 and @xmath30-degree @xmath21 as follows : first , we use the magma function monomialsofdegree in order to produce all monomials of degree @xmath20 in xr and degree @xmath21 in yr .",
    "the functions below cast these monomials into elements of pr , and the desired monomial set is obtained by multiplying any element of the first set with any element of the second .    ....",
    "xmon2mon:=function(xmon )      res:=pr!1 ;      for i:=0 to 7 do          exp:=degree(xmon , i+1 ) ;          res:=res*(pr.(i+1))^exp ;      end for ;      return res ; end function ;    ymon2mon:=function(ymon )      res:=pr!1 ;      for i:=1 to 4 do          exp:=degree(ymon , i ) ;          res:=res*(pr.(i+8))^exp ;      end for ;      return res ; end function ; ....    step ( ii ) is based on the following simple function .    ....",
    "isbasiselt:=function(mon )      nf:=normalform(mon , i ) ;      return ( nf eq mon ) ; end function ; ....    finally , step ( iii ) is carried out by the function below .",
    "it makes use of the fact that the group @xmath22 is generated by @xmath31 , where @xmath32 runs through the set @xmath33 ( see section 4 of @xcite for the notation ) .    ....",
    "ishinvar:=function(mon )      cond:=true ;      for i:=0 to 6 do          deg1:=degree(mon , i+1 ) ;          deg2:=degree(mon , i+2 ) ;          cond:=cond and iseven(deg1+deg2 ) ;      end for ;      deg1:=degree(mon,1 ) ;      deg2:=degree(mon,8 ) ;      cond:=cond and iseven(deg1+deg2 ) ;      return cond ; end function ; ....    based on these functions , the following loop now determines a basis for every component the graded ring .",
    "the result is the nested array basis in which basis[@xmath34 contains the basis elements of @xmath24 , given as elements of the ring pr .    ....",
    "basis:= [ ] ; for i:=0 to 2 do      basis[i+1]:= [ ] ;      xdeg:=2*i;ydeg:=i ;      xmons:=monomialsofdegree(xr , xdeg ) ;      ymons:=monomialsofdegree(yr , ydeg ) ;      for xmon in xmons do          for ymon in ymons do          mon:=xmon2mon(xmon)*ymon2mon(ymon ) ;              cond:=ishinvar(mon ) ;              cond:=cond and isbasiselt(mon ) ;              if cond then                  basis[i+1]:=append(basis[i+1],mon ) ;              end if ;          end for ;      end for ; end for ; basis[4]:=[x(7)^6*y(4)^3 ] ; ....    in order to save time , we define the component basis[@xmath34 directly instead of using the procedure .",
    "the reason is that the space of polynomials of bidegree @xmath35 is already quite large , so the computation would take several seconds .",
    "we briefly recall the definition of the characteristic subvariety @xmath36 from section 3 in @xcite .",
    "let @xmath37 denote a basis of @xmath38 and @xmath39 a basis of @xmath40 .",
    "taking the multiplication map to its dual yields a linear map @xmath41 fix a bijection @xmath42 .",
    "furthermore , let @xmath43 denote a representation matrix of @xmath44 with respect to @xmath45 and @xmath46 .",
    "then @xmath36 is the subvariety in @xmath47 given by the equations @xmath48.\\ ] ] thus in order to compute the variety , we have to carry out the following steps :    * provide functions for the bijection @xmath49 and its inverse @xmath50 * compute a representation matrix of the multiplication map @xmath51 with respect to the basis @xmath52 and @xmath39 * obtain a representation matrix with respect to @xmath45 and @xmath53 by transposition * deduce matrix @xmath15 by base change from @xmath54 to @xmath55 * write down the defining equations of @xmath36    the bijections @xmath49 and @xmath50 are provided by the following two functions .    ....",
    "r:=polynomialring(gf(2),9 ) ; symm2order:=monomialsofdegree(r,2 ) ; symm2order:=settosequence(symm2order ) ; symm2spc:=vectorspace(k,#symm2order ) ;    ijpos:=function(i , j )      if i gt j then          i_:=j ; j_:=i ;      else          i_:=i ; j_:=j ;      end if ;      p:=9 - i _ + 1 ;      offs:=45 -   1/2*p*(p+1 ) ;      offs:=offs + ( j_-i _ ) + 1 ;      offs:=integers()!offs ;      return offs ; end function ;           pos2ij:=function(pos )      mon:=symm2order[pos ] ;      res:= [ ] ;      for i:=1 to 9 do          if degree(mon , i ) eq 2 then              return [ i , i ] ;          end if ;          if degree(mon , i ) eq 1 then              res:=append(res , i ) ;          end if ;      end for ;      return res ; end function ; ....    in order to carry out ( ii ) we need a function which computes , for an arbitrary polynomial @xmath56 in the polynomial ring pr , a coordinate vector of length @xmath57 of the cohomology class represented by @xmath56 with respect to basis .    ....",
    "cspc:=vectorspace(k,20 ) ; poly2vec:=function(poly )      res:=cspc!0 ;      nf:=normalform(poly , i ) ;      offs:=0 ;      for p:=0 to 3 do          for i:=1 to # basis[p+1 ] do              coe:=monomialcoefficient(nf , basis[p+1][i ] ) ;              res[offs+i]:=coe ;          end for ;          offs:=offs+#basis[p+1 ] ;      end for ;      return res ; end function ; ....    the representation matrix is now obtained by computing the products of all pairs of elements in basis[2 ] .",
    "the @xmath58 rows of the matrix are given by the @xmath40-parts of the coordinate vectors of these products .    ....",
    "m:= [ ] ; for l:=1 to 45 do      m[l]:= [ ] ;      ij:=pos2ij(l);i:=ij[1];j:=ij[2 ] ;      mon1:=basis[2][i ] ; mon2:=basis[2][j ] ;      vec:=poly2vec(mon1*mon2 ) ;      for k:=1 to 9 do          m[l][k]:=vec[10+k ] ;      end for ; end for ; m:=matrix(k , m ) ; ....    the implementation of the steps ( iii ) and ( iv ) is straightforward , provided one takes into account that @xmath59 and @xmath60 .",
    "the final result is stored in the matrix named c.    ....    n:= [ ] ; for l:=1 to 45 do      n[l]:= [ ] ;      ij:=pos2ij(l ) ;      s:=sequencetoset(ij ) ;      if # s eq 2 then          la:=2 ;      else          la:=1 ;      end",
    "if ;      for k:=1 to 9 do          n[l][k]:=la*m[l][k ] ;      end for ; end for ; n:=matrix(k , n ) ; c:=transpose(n ) ; ....    finally , the matrix c is used to carry out ( v ) .",
    "the resulting projective scheme is stored in the variable charvar .    ....",
    "csr:=polynomialring(k,9 ) ; chareqs:= [ ] ; for l:=1 to 9 do      f:=csr!0 ;      for k:=1 to 45 do          ij:=pos2ij(k);i:=ij[1];j:=ij[2 ] ;          mon:=csr.i*csr.j ;          f:=f+c[l][k]*mon ;      end for ;      chareqs[l]:=f ; end for ; p8:=projectivespace(csr ) ; charvar:=scheme(p8,chareqs ) ; ....    the dimension and arithemtic genus are obtained by the function calls    dimension(charvar ) and .",
    "the computation of the characteristic subvariety @xmath61 works essentially in the same way as in the previous section . as before , let @xmath37 denote a basis of @xmath38 . by @xmath62",
    "we denote a vector which spans the @xmath63-dimensional space @xmath64 . the dual of the multiplication map yields @xmath65 in order to write down a representation matrix , we fix a bijection @xmath66 let @xmath67 a representation matrix of @xmath44 with respect to @xmath62 and @xmath68",
    ". then @xmath61 is by definition a hypersurface in @xmath47 given by the quation @xmath69.\\ ] ] thus we can proceed as follows .    *",
    "provide functions for the bijection @xmath49 and its inverse @xmath50 * compute a representation matrix of the multiplication map @xmath70 with respect to the basis @xmath71 and @xmath62 * obtain a representation matrix with respect to @xmath72 and @xmath73 by transposition * deduce matrix @xmath15 by base change from @xmath74 to @xmath75 * write down the defining equation of @xmath61    step ( i ) is achieved by    ....",
    "r:=polynomialring(gf(2),9 ) ; symm3order:=monomialsofdegree(r,3 ) ; symm3order:=settosequence(symm3order ) ; symm3spc:=vectorspace(k,#symm3order ) ;    ijkpos:=function(i , j , k )      s:=sort([i , j , k ] ) ;      i_:=s[1];j_:=s[2];k_:=s[3 ] ;      offs:=0 ;      for l:=1 to i_-1 do          p:=10 - l ;          offs:=offs + 1/2*p*(p+1 ) ;      end for ;      p0:=9-i_+1 ;      j0:=j_-i_+1 ;      k0:=k_-i_+1 ;      offs2:=0 ;      p0_:=p0 - j0 + 1 ;      offs2:=1/2*p0*(p0 + 1 ) - 1/2*p0_*(p0_+1 ) ;      offs2:=offs2 + ( k0 - j0 ) + 1 ;      offs:=offs+offs2 ;      offs:=integers()!offs ;      return offs ; end function ;       pos2ijk:=function(pos )      mon:=symm3order[pos ] ;      res:= [ ] ;      for i:=1 to 9 do          if degree(mon , i ) eq 3 then              return [ i , i , i ] ;          end if ;          if degree(mon , i ) eq 2 then              res:=res cat [ i , i ] ;          end if ;          if degree(mon , i ) eq 1 then              res:=append(res , i ) ;          end if ;      end for ;      return res ; end function ; ....    for step ( ii ) we can use the function poly2vec from the previous section .",
    "the representation matrix of the multiplication map @xmath76 is then computed by    ....",
    "m:= [ ] ; for l:=1 to 165 do      m[l]:= [ ] ;      ijk:=pos2ijk(l);i:=ijk[1];j:=ijk[2];k:=ijk[3 ] ;      mon1:=basis[2][i ] ; mon2:=basis[2][j ] ;      mon3:=basis[2][k ] ;      vec:=poly2vec(mon1*mon2*mon3 ) ;      m[l][1]:=vec[20 ] ; end for ; m:=matrix(k , m ) ; ....    for step ( iii ) and ( iv ) , notice that @xmath77 , @xmath78 and @xmath79 for @xmath80 pairwise distinct .    ....",
    "n:= [ ] ; for l:=1 to 165 do      n[l]:= [ ] ;      ijk:=pos2ijk(l ) ;      s:=sequencetoset(ijk ) ;      case # s :          when 1 :              la:=1 ;          when 2 :              la:=3 ;          when 3 :              la:=6 ;      end case ;      n[l][1]:=la*m[l][1 ] ; end for ; n:=matrix(k , n ) ; c:=transpose(n ) ; ....    now the characteristic variety is obtained by    ....",
    "csr:=polynomialring(k,9 ) ; chareq:=csr!0 ; for l:=1 to 165 do      ijk:=pos2ijk(l ) ;      i:=ijk[1];j:=ijk[2];k:=ijk[3 ] ;      mon:=csr.i*csr.j*csr.k ;      chareq:=chareq+c[1][l]*mon ; end for ; p8:=projectivespace(csr ) ; charvar:=scheme(p8,chareq ) ; ....",
    "for the implementation of the _ plethysm method _ ( see section 3 in @xcite ) it is neccessary to compute a representation matrices @xmath81 of the maps @xmath82 with respect to the basis computed in section [ cohomologybasis ] .",
    "the idea is simple : multiply every basis element with some fixed @xmath83 , use the function poly2vec from section [ firstcharsubv ] in order to transform the products into row vectors and form a matrix out of these rows .",
    "this task is carried out by the following code .",
    "the result is an array called _ thetamats _ whose elements are the representation matrices corresponding to the @xmath84 basis vectors of @xmath38 .    ....",
    "thetamats:= [ ] ; for j:=1 to 9 do      the:=basis[2][j ] ;      thetamat:= [ ] ;      for p:=0 to 3 do          for i:=1 to # basis[p+1 ] do              poly:=the*basis[p+1][i ] ;              vec:=poly2vec(poly ) ;              vec:=elementtosequence(vec ) ;              thetamat:=append(thetamat , vec ) ;          end for ;      end for ;      thetamat:=matrix(k , thetamat ) ;      thetamats:=append(thetamats , thetamat ) ;      delete thetamat ; end for ; ....",
    "each map @xmath86 induces an endomorphism on @xmath87 .",
    "the aim of this section is to represent the elements of @xmath87 by vectors in @xmath88 , and to compute the action of @xmath89 with respect to this representation .",
    "for the first part , we only have to fix a bijection @xmath90 if @xmath91 denotes a basis of @xmath28 , then the isomorphism @xmath92 is given by @xmath93 .",
    "the following two functions provide such a bijection .    ....",
    "r:=polynomialring(gf(2),20 ) ; symm2order:=monomialsofdegree(r,2 ) ; symm2order:=settosequence(symm2order ) ; symm2spc:=vectorspace(k,#symm2order ) ;    ijpos:=function(i , j )      if i gt j then          i_:=j ; j_:=i ;      else          i_:=i ; j_:=j ;      end if ;      p:=20 - i _ + 1 ;      offs:=210 -   1/2*p*(p+1 ) ;      offs:=offs + ( j_-i _ ) + 1 ;      offs:=integers()!offs ;      return offs ; end function ;    pos2ij:=function(pos )      mon:=symm2order[pos ] ;      res:= [ ] ;      for i:=1 to 20 do          if degree(mon , i ) eq 2 then              return [ i , i ] ;          end if ;          if degree(mon , i ) eq 1 then              res:=append(res , i ) ;          end if ;      end for ;      return res ; end function ; ....    given an basis vector @xmath83 and some @xmath94 , our next task is two compute the image @xmath95 . by the above isomorphism",
    ", @xmath96 corresponds to an element of the form @xmath97 , and the induced map is given by @xmath98 it means that we have to proceed as follows :    * use the matrices in thetamats in order to compute the images @xmath99 and @xmath100 as elements in @xmath101 . *",
    "compute the product @xmath102 ; if @xmath103 , then @xmath104 use the bijection @xmath49 in order to map this element to @xmath88 .",
    "* do the same for @xmath105 , and return the sum .",
    "this is carried out by the following magma code .    ....",
    "symm2imthe:=function(th , pos )      ij:=pos2ij(pos ) ; i:=ij[1 ] ; j:=ij[2 ] ;      imi:=cspc!0 ; imi[i]:=1 ;      imj:=cspc!0 ; imj[j]:=1 ;      imj:=imj*thetamats[th ] ;      res1:=symm2spc!0 ;      for k:=1 to 20 do          if not(imj[k ] eq 0 ) then              res1[ijpos(i , k)]:=imi[i]*imj[k ] ;          end if ;      end for ;      imi:=cspc!0 ; imi[i]:=1 ;      imi:=imi*thetamats[th ] ;      imj:=cspc!0 ; imj[j]:=1 ;      res2:=symm2spc!0 ;      for k:=1 to 20 do          if not(imi[k ] eq 0 ) then              res2[ijpos(k , j)]:=imi[k]*imj[j ] ;          end if ;      end for ;      res:=res1+res2 ;      return res ; end function ; ....    by linearity we can now compute the image of arbitrary elements in @xmath88 .    ....",
    "symm2imthe_:=function(th , vec )      res:=symm2spc!0 ;      seq:=elementtosequence(vec ) ;      for i:=1 to # seq do          imvec:=symm2imthe(th , i ) ;          res:=res+vec[i]*imvec ;      end for ;      return res ; end function ; ....    for the application of the plethysm method , it is essential to carry out the following task : given a subspace @xmath106 , compute the sum @xmath107 of the images of all higgs field maps .",
    "( here @xmath108 denotes a basis of the graded subspace @xmath38 . )",
    "we use the built - in linear algebra functions of magma in order to provide this .    ....",
    "symm2 ;      for bvec in b do          for th:=1 to 9 do              ims:=append(ims , symm2imthe_(th , bvec ) ) ;          end for ;      end for ;      return sub < symm2spc|ims > ; end function ; ....",
    "the grading @xmath109 on the jacobian ring induces a natural grading @xmath110 on symmetric @xmath85-space . for the plethysm method",
    ", we have to compute the iterated images of the graded subspaces @xmath111 under the higgs field elements .",
    "in particular , for @xmath112 we have to determine the image of @xmath111 under the isomorphism @xmath113 .",
    "we provide a function which returns for each @xmath5 a set @xmath114 such that the image of @xmath111 in @xmath88 is spanned by the basis vectors @xmath115 .",
    "it seems to be the easiest strategy to compute the index set for each @xmath5 `` by hand '' .",
    "let @xmath91 denote a basis of @xmath28 .",
    "we assume that the indices are chosen such that @xmath116 is spanned by @xmath117 , @xmath38 is spanned by @xmath118 , @xmath40 by the elements @xmath119 and finally @xmath64 by @xmath120 .",
    "we first consider @xmath121 . in this case",
    "@xmath122 is generated by the image of @xmath123 , which means that the image of @xmath122 in @xmath88 is spanned by @xmath124 .",
    "the space @xmath125 is generated by @xmath126 , so the image is spanned by @xmath127 with @xmath128 . for @xmath129 we have to consider the image of @xmath130 etc .",
    "if we work through all degrees up to @xmath131 , we end up with the following function .",
    "symm2degind:=function(p )      case p :          when 0 :              return [ ijpos(1,1 ) ] ;          when 1 :              res:= [ ] ;              for i:=1 to 9 do                  res:=append(res , ijpos(1,1+i ) ) ;              end for ;              return res ;          when 2 :              res:= [ ] ;              for i:=1 to 9 do                  res:=append(res , ijpos(1,10+i ) ) ;              end for ;              for i:=1 to 9 do                  for j:=i to 9 do                      res:=append(res , ijpos(1+i,1+j ) ) ;                  end for ;              end for ;              return res ;          when 3 :              res:=[ijpos(1,20 ) ] ;              for i:=1 to 9 do                  for j:=1 to 9 do                      res:=append(res , ijpos(1+i,10+j ) ) ;                  end for ;              end for ;              return res ;          when 4 :              res:= [ ] ;              for i:=1 to 9 do                  res:=append(res , ijpos(1+i,20 ) ) ;              end for ;              for i:=1 to 9 do                  for j:=i to 9 do                      res:=append(res , ijpos(10+i,10+j ) ) ;                  end for ;              end for ;              return res ;          when 5 :              res:= [ ] ;              for i:=1 to 9 do                  res:=append(res , ijpos(10+i,20 ) ) ;              end for ;              return res ;               when 6 :              res:=[ijpos(20,20 ) ] ;              return res ;      end case ;         return -1 ; end function ; ....        symm2degspc:=function(p )      basis:= [ ] ;      inds:=symm2degind(p ) ;      for i:=1 to # inds do          vec:=symm2spc!0 ;          vec[inds[i]]:=1 ;          basis:=append(basis , vec ) ;      end for ;      return sub < symm2spc|basis > ; end function ; ...."
  ],
  "abstract_text": [
    "<S> the purpose of these notes is to provide the details of the jacobian ring computations carried out in @xcite , based on the computer algebra system magma @xcite . </S>"
  ]
}