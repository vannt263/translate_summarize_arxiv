{
  "article_text": [
    "the study and application of graph theory have been increasingly active in both the academic world and in industry .",
    "the advent of large - scale datasets has lead to the invention of new tools to handle the scale such as graph databases  @xcite and graph analytics frameworks  @xcite . in the academic world , the emerging field of graph signal processing  @xcite strives to develop methods combining graphs and data associated to their vertices .",
    "the analysis of dynamical processes taking place on a network is a typical use - case of this combination with applications in various domains such as neuroscience  @xcite , the study of epidemics in physics  @xcite and rumor spreading in social networks  @xcite . in these examples ,",
    "some quantity or state ( such as activity , information or congestion ) spreads over a network , as illustrated in fig .",
    "activity patterns formed by these dynamical phenomena or processes are defined by two properties : i ) their localization both in space and time and ii ) the way they spread , always propagating through the neighborhood over time . in the following ,",
    "we refer to those particular processes as causal processes .",
    "a _ causal process _ on graph is thus a particular type of dynamical process that models a physical phenomenon propagating and spreading from a node to its neighbors in successive time steps .",
    "in addition , in many applications such patterns appear regularly on the network in the same locations , possibly with some variations .",
    "the repetition of the dynamics offers a chance to better understand the underlying process causing the spreading as well as to anticipate or forecasting possible future spreads of a pattern using historical data .     and can only spread over the neighboring intersections through time . over the days",
    ", thousands of patterns can be analyzed to extract important insights such as : how patterns spread , how long they last , are they repetitive , what is the variability of the spread , etc . learning the particular characteristics of congestion patterns and classifying them would be very beneficial to drivers as appropriate measures could be taken by the authorities as soon as congestion appears . ]    in the present work , we introduce a novel and intuitive method designed to track recurring patterns of activity induced by causal processes on graphs .",
    "it relies on the _ causal multilayer graph _ ( cmg ) , a particular kind of multilayer graph designed to follow the propagation of events in successive time steps ( see following section ) . from the causal multilayer graph and the data attached to its nodes , we extract dynamic activation components , subgraphs of the cmg representing patterns of activity .",
    "we then classify and analyze these patterns to reveal global trends and insights on several applications showing that our framework is applicable to a large class of problems .",
    "the idea of pattern detection on graphs has some similarity with the temporal motif detection of  @xcite and the temporal subgraph isomorphism of  @xcite .",
    "however , motifs are restricted to be subgraphs of a few nodes , typically 2 or 3 ( due to the np - hard graph matching process ) , while our method can deal with patterns of any size .",
    "our patterns are a type of mesoscale structure within temporal graphs as described in  @xcite .",
    "these structures seem important for understanding dynamical activity in temporal networks but are not well explored yet ( except for network communities ) .",
    "we present new results in this direction , as we show in our applications .",
    "although there has been a huge amount of research on multilayer networks in the past few years , scalable data - driven methods dedicated to the analysis of dynamic data evolving on multilayer graphs are still lacking  @xcite .",
    "the proposed method here scales linearly with the number of nodes and time - steps making it possible to handle millions of nodes by leveraging today s multicore architecture .",
    "in addition , it is simple to tune as it mainly depends on a single parameter and is very flexible as it supports directed , weighted and dynamic graphs .",
    "the manuscript is structured as follows .",
    "firstly , we describe the peculiar structure of the causal multilayer graph .",
    "then , we introduce the causal multilayer graph of activity that contains the dynamical patterns to be analyzed .",
    "next , we propose a method to compare and cluster / classify activity patterns which we call dynamic activated components . in the second major part of the manuscript , we illustrate the usage of our framework in three different real - world applications .",
    "as a first application we extract dynamic patterns of activity in a social network and compare our approach to the work of de domenico _ et al .",
    "_ on rumor spreading in  @xcite .",
    "the second application is devoted to the analysis of the flux of pedestrians and congestion patterns in a train station .",
    "finally , we show interesting `` mood '' patterns extracted from more than @xmath0 collaborative music playlists . in the appendix",
    ", we dedicate two sections to explain how to construct the cmg of activity efficiently in order to handle large datasets alongside its generalization to dynamic graphs . as part of the open science movement , we release the code and data related to this work to the community under the gpl v2 license on the laboratory s github account  @xcite .",
    "in order to track dynamical activity in real data in a computationally efficient way , we need to introduce several mathematical objects and divide the method in several steps .",
    "we start by introducing the cmg as a conceptual object to guide the reader and help making connections to previous works on multilayer networks .",
    "however in the actual implementation , the construction of the complete cmg is avoided .",
    "instead , we reduce the cmg to small parts by combining the signal describing the activity on the network and the network itself . in this section ,",
    "we focus on the description of the concept and leave the technical details of the implementation in the appendix  [ sec : efficient_construction ] . for clarity",
    ", we also restrict the presentation to a static graph .",
    "however , in the appendix  [ sec : generalized ] , we present the more general version of our method that takes into account the possible evolution of the graph with respect to time .",
    "several notations are introduced throughout this section . to help the reader ,",
    "they are summarized in table  [ tab : notation ] .",
    ".notations for the different mathematical objects . [ cols=\"^,^ \" , ]      a graph , @xmath1 , is constructed by doing the union of all the playlists in the dataset . as a consequence ,",
    "an edge between two songs only exists if at least one playlist contains this particular sequence of songs .",
    "this graph thus encodes song `` affinity '' together with their _ causal relationships_. the number of nodes of @xmath1 is over @xmath2 .",
    "every edge in the graph has been created from an actual human - made audio playlist .",
    "it is thus perfectly suited for building new playlists following human tastes .      as a signal on the graph , we use the likelihood that a song is in a particular place on a playlist . to compute it ,",
    "we count how many times a particular song has been placed at a particular position for all playlists . for example , take a song a which has been placed 3 times in the first position of a playlist and 5 times in the third position .",
    "thus , in this example , the vector on the node a has 2 non - zero values @xmath3 .",
    "the number of entries of each vector is equal to the number of songs in the longest playlist .",
    "similarly to the previous application , we normalize the signal by z - score , giving a likelihood to be at a given position in a playlist . as a consequence ,",
    "song with positions evenly distributed in playlists do not reach the threshold . only songs appearing at a limited number of positions in playlists e.g only in the first and third position in the previous example , have non - zero binary values for these positions .",
    "note that having well - defined locations for songs is important as we use their ordering in playlists as causal relationships between them .",
    "setting @xmath4 proves to be a reasonable choice of threshold as the extracted components have an average width of around @xmath5 steps : it is close to the average length of a handcrafted playlist in the dataset .",
    "we propose an algorithm to generate playlists based on music `` moods '' using average activated components obtained by @xmath6-means clustering . as an outcome of our method",
    "we show that different music moods are associated , in a totally unsupervised manner , to the clusters .",
    "moods are `` electroish '' , `` metallic '' , `` rocky '' ( see fig .",
    "[ fig12 ] for example ) and can be viewed as a meta - genre of music regrouping related music genres such as rock , indie , alternative , etc .",
    "we extract activated components of songs from the causal multilayer graph by thresholding the normalized popularity vector ( keeping the largest peaks of appearance of songs in playlists ) .",
    "each activated component is a group of songs fitting nicely together and respecting a precise order within the playlists .",
    "these activated components are then clustered together using @xmath6-means clustering .",
    "the number of clusters @xmath7 is here naturally given by the number of dominant genres present in the dataset .",
    "this is a natural choice as we expect playlists to be classified by genre .",
    "in addition , music genre often proves to be one of the most important criteria when creating a mix : in the dataset , half of the distribution of the playlist categories are labeled with a music genre .",
    "this choice of @xmath6 is validated by the results which are indeed meaningful in term of genres .",
    "each cluster can be labeled with a mood _ a posteriori _ by analyzing music genres present within the clusters .",
    "once the mood has been chosen by a user , the algorithm selects the average activated component associated to the mood . to generate a playlist , a seed song , the first of the playlist ,",
    "is selected in the first layer of the component . in its simplest form",
    ", the selection is done at random .",
    "however , many criteria such as user history , ratings or time since last played , can be used to select a starting point .",
    "then , the rest of the playlist is constructed by doing a random walk on the _ causal _ edges of the component .",
    "the familiarity versus discovery ratio can be tuned by modifying the edge weights according to the popularity of each node .",
    "the random walker would have more or less chances to reach a popular song depending on the user s will .",
    "a good playlist should alternate between familiarity , discovery and smoothness in transitions between songs @xcite .",
    "an average activated component is a coherent weighted subgraph of songs , where each node and edge are weighted by their likelihood of appearance at that particular position .",
    "the most popular songs , appearing in many activated components , have a large weight , filling the contract for the familiarity part .",
    "less popular songs will also be clustered together giving choice for the discovery part . finally ,",
    "the smoothness of transitions is guaranteed by the graph @xmath1 : each song to song transition has been created by a human and is appealing to at least one of them .",
    "keeping the original ordering of songs in a playlist ( successive positions of several songs , not just 2 ) has been shown to be crucial when designing recommender systems as shown in  @xcite and  @xcite . following the causal edges of an average activated component takes into account the ordering of several successive songs with their positions within playlists , unlike a random walk on the graph @xmath1 which considers only one to one coupling between songs .    ,",
    "[ fig13 ] , fig .",
    "[ fig14 ] , fig .",
    "[ fig15 ] . *",
    "the spatial spread is the number of genres per layer of the average activated component .",
    "as one could expect , popular genres such as rock and alternative have a bigger spatial spread and are easily mixed with other genres . , title=\"fig : \" ] , fig .  [ fig13 ] , fig .  [ fig14 ] , fig .  [ fig15 ] . *",
    "the spatial spread is the number of genres per layer of the average activated component .",
    "as one could expect , popular genres such as rock and alternative have a bigger spatial spread and are easily mixed with other genres .",
    ", title=\"fig : \" ]      the activated components can also be used for exploring and visualizing the dataset . since",
    "each activated component has a large spatial spread , we group songs on each layer by genre as it drastically reduces the dimensionality and exhibits interesting insights on how users create playlists .",
    "note that genres are here to validate the methodology and have not been used to cluster the activated components together .",
    "like in previous applications the method is completely unsupervised .",
    "the results are shown in fig.[fig12 ] , fig.[fig13 ] , fig.[fig14 ] , fig.[fig15 ] .",
    "while the dataset is biased towards rock , alternative and indie ( more than 40% of all the songs ) , the clustering still achieves to extract relatively pure patterns of related genres , or music `` moods '' , as it is shown in fig .",
    "[ fig12 ] and fig .",
    "[ fig13 ] .",
    "as music experts could have expected , songs of popular genres are more volatile : they can easily be mixed with other genres and have a higher spatial spread , see fig .",
    "[ fig15 ] and fig .",
    "[ fig16 ] . on the contrary , songs of `` connoisseur genres '' such as metal , jazz , hip - hop or classical stay clustered in their universe .",
    "from a general point of view , we have presented a new framework to extract and analyze sparse repeated patterns created by dynamical processes on graphs .",
    "our approach is based on the causal multilayer graph , a novel multilayer graph structure that encodes the propagation or spreading of events across time .",
    "the construction of the causal multilayer graph and the extraction of dynamic activation components are computationally efficient and fully leverage today s multicore architecture . by applying our framework in three different real - world applications",
    ", we have demonstrated that clustering similar patterns of activity and analyzing average activation components reveals new insights on the underlying causal processes .",
    "in addition to the applications presented here , our method can also be applied to problems actually modeled as temporal networks , allowing a different approach and an additional degree of model complexity .",
    "more generally , we believe that our model shows great promise for a wider range of problems such as the spreading of epidemic outbreaks , social network activity , brain eeg recordings or any type of sensor networks . applications where time series have been recorded on the vertices of a network are numerous , present in many fields of science such as engineering , social , biological , physical or computational science and keep increasing with the actual data deluge .",
    "this work was partially funded by snf grant number 200021_154350 1 .      in this section ,",
    "we describe the different steps to construct the cmg of activity , in a fast manner , directly from the spatial graph , @xmath1 , and the mask , @xmath8 . for clarity , several technical details aimed at optimizing further the implementation , but which are not crucial for the understanding ,",
    "are given in the next section .",
    "we first combine the data into one object .",
    "each binary activation vector , @xmath9 , is stored as a property ( label ) on node @xmath10 of @xmath1 , creating a property graph which is still denoted @xmath1 .",
    "the causal multilayer graph of activity @xmath11 is created in a series of steps illustrated in fig .",
    "[ fig5 ] and detailed as follows :    1 .",
    "iterating over each edge , @xmath12 , of @xmath1 linking a source node , @xmath10 , and a destination node @xmath13 , the algorithm first reads the vectors @xmath9 and @xmath14 .",
    "an inter - layer connection is created between layer @xmath15 and @xmath16 whenever @xmath17 and @xmath18 are activated ( since we already know that @xmath10 and @xmath13 are spatial neighbors ) i.e. @xmath19 .",
    "that is to say , an edge exists in @xmath20 whenever @xmath21 where @xmath22 is the logical and .",
    "we introduce a new vector @xmath23 of size @xmath24 associated to the edge @xmath25 , for all @xmath26 $ ] : @xmath27 the value @xmath28 encodes the existence ( 1 ) or absence ( 0 ) of an inter - layer edge between vertices @xmath17 and @xmath18 .",
    "the vector @xmath23 is stored as a property of edge @xmath25 .",
    "2 .   since we are also interested in self activation of vertices across time ( the set @xmath29 ) we compute an additional vector @xmath30 for each _ vertex _ @xmath10 of @xmath1 , @xmath31 for all @xmath26 $ ] .",
    "the vector @xmath30 is stored as a property of node @xmath10 .",
    "the construction of the graph @xmath11 is then done by reading the collection of edge vectors , @xmath32 , node vectors , @xmath33 , and adding edges between successive time layers when ones are encountered .    , is directly constructed from the activated entries of the binary mask ( top left ) and the original graph , @xmath1 ( top right ) . the construction of @xmath34 is not needed .",
    ", title=\"fig : \" ] , is directly constructed from the activated entries of the binary mask ( top left ) and the original graph , @xmath1 ( top right ) .",
    "the construction of @xmath34 is not needed .",
    ", title=\"fig : \" ]    the complexity of this process is linear in the number of edges and vertices of @xmath1 .",
    "it is also linear in the number of time - steps .",
    "the scalability of our method comes from the properties of @xmath11 .",
    "layers are time - ordered , allowing connections between layers to be encoded as binary vectors .",
    "the creation of edges only depends on the state of pairs of nodes .",
    "therefore , it relies on local values , which allows for , an efficient parallel implementation .",
    "the main task consists in handling the properties ( vectors ) of triplets , @xmath35 , where @xmath36 is the spatial edge connecting source node , @xmath10 , and destination node , @xmath13 .",
    "this is sufficient to create all causal edges between @xmath10 and @xmath13 ( @xmath37 ) .",
    "this interesting property is particularly suited to large scale graph analytics frameworks such as https://dato.com/products/create/index.html[graphlab create ] @xcite or apache graphx  @xcite , which have dedicated processes for applying functions to all triplets in parallel .",
    "thus , our implementation gracefully scales with the number of cores and is much faster than a sequential naive implementation . to our knowledge",
    ", no other implementation of multilayer graphs matches the speed and the scalability of the method proposed here .",
    "the first step of the algorithm reads both activation mask vectors @xmath38 , @xmath39 from @xmath10 and @xmath13 , respectively , as arbitrary precision integers @xcite .",
    "an arbitrary precision integer can store any integer number ( limited by available memory ) , and can be seen as a list of `` standard '' @xmath40 bit integers with a common interface .",
    "graphlab create only allows the storage of basic datatypes as properties of nodes and edges such as integer , double , bool , and string ( at the time of the writing ) .",
    "we had to transform the rows of our activation mask , @xmath41 , to bitstring to be able to store them on vertices and edges .",
    "any bit compression algorithm can be used to reduce storage space .",
    "the arbitrary precision integer stored as a string offers a compression ratio of more than 3 over the raw bitstring .    in the second step of the algorithm ,",
    "the vector @xmath28 is created by performing a logical and ( @xmath22 ) between @xmath38 and @xmath39",
    ". it amounts to performing a logical and between two vectors : @xmath9 and the left - shift version of @xmath14 ( hence involving a logical and and a bit shift ) .",
    "the last ( least significant ) bit in this operation is dropped ( @xmath23 is of size @xmath24 ) as it would correspond to a link between layer @xmath24 and @xmath42 , the latter of which does not exist . once the vector @xmath28 is created , all the ones have to be found to create the causal edges . for each @xmath43 , its position in the vector",
    "gives the time @xmath15 and allows the creation of two pairs , @xmath44 and @xmath45 , a causal edge , which is then added in the causal multilayer graph of activity @xmath11 . instead of",
    "looping through all the bits of @xmath28 and checking for a @xmath43 at each position , we have implemented another strategy that jumps from @xmath43 to @xmath43 in @xmath28 and gives the position of the layer number @xmath15 .",
    "this optimization is better than the classical for loop when @xmath28 is sparse .",
    "the details are given in algorithm  [ algo ] .",
    "we invite the interested reader to refer to  @xcite for more information on this low level bit manipulation trick .",
    "the fig .",
    "[ fig6 ] illustrates the algorithm formally defined in algorithm  [ algo ] .    .",
    "* the binary mask vector of the destination node , @xmath46 , is shifted ( in this illustration left - shifted ) to align source layer , @xmath15 , and destination layer @xmath16 .",
    "then , a logical and is performed between the two vectors ( top right picture ) . on the bottom figure , the result @xmath47 , stored in @xmath25 , is read to create the edges ( and nodes ) of @xmath11.,title=\"fig : \" ] . * the binary mask vector of the destination node , @xmath46 ,",
    "is shifted ( in this illustration left - shifted ) to align source layer , @xmath15 , and destination layer @xmath16 .",
    "then , a logical and is performed between the two vectors ( top right picture ) . on the bottom figure , the result @xmath47 , stored in @xmath25 , is read to create the edges ( and nodes ) of @xmath11.,title=\"fig : \" ]        in sec .",
    "[ sec : act_cmg ] , we introduced the mathematical foundations of the causal multilayer graph of activity . here , we generalize this model to account for dynamic spatial graphs , where edges or nodes are allowed to appear or disappear across layers . by encoding the position of nodes and edges as additional vectors on the nodes and edges of the generalized spatial graph @xmath1 , the generalized cmg of activity",
    "can be constructed very efficiently using a variation of the algorithm introduced in appendix  [ sec : efficient_construction ] .",
    "let us assume we have a set @xmath49 of @xmath42 graphs , one for each time - step @xmath50 $ ] .",
    "the number of vertices and edges is allowed to change from graph to graph .",
    "in addition , a mask @xmath41 that associates a value ( 0 or 1 ) to each vertex of the set @xmath49 is given .",
    "in this case , it may not be a matrix .",
    "the mask can also be computed from a signal @xmath51 on the vertices of the collection of graphs @xmath49 .",
    "we first create the generalized spatial graph @xmath1 , which concatenates all @xmath49 .",
    "a vertex @xmath10 belongs to @xmath52 if there exist some layer @xmath15 such that @xmath53 . similarly , an edge @xmath12 connecting vertex @xmath10 and @xmath13 of @xmath1 exists if for some @xmath15 there is an edge @xmath54 connecting @xmath17 and @xmath55 . taking the definition of eq .  ,",
    "the expression of the weights in eq .",
    "is @xmath56 for @xmath37 , where @xmath57 is the weight of the edge between @xmath17 and @xmath55 ; for @xmath58 , @xmath59 and zero for the rest .",
    "the second step associates vectors to each vertex and edge of @xmath1 . similarly to sec .",
    "[ sec : act_cmg ] , a vector @xmath9 of length @xmath42 is associated to each vertex @xmath10 .",
    "additional vectors , i.e values of the signal @xmath60 can also be stored on each vertex . in the case where vertex @xmath10 is not present in some graph",
    "@xmath61 the entry @xmath38 exists and is set to zero .",
    "it is equivalent to adding an extraneous inactive and unconnected vertex @xmath10 at layer @xmath15 .",
    "we now introduce an additional mask : the edge mask @xmath62 .",
    "it associates a binary vector of length @xmath42 to each edge of @xmath1 i.e. : for each edge @xmath25 of @xmath1 between node @xmath10 and @xmath13 , @xmath63 if there is an edge between @xmath17 and @xmath55 , zero otherwise .",
    "notice that edge weights can also be stored as vectors on each edge , similarly to what is done to the signal @xmath51 on vertices . for the sake of simplicity , we assume the graphs to be unweighted here .        fig .",
    "[ fig19 ] explains the construction of the generalized cmg of activity using the different vectors .",
    "similarly to the standard model , for each edge @xmath25 the destination vertex mask is shifted before performing a logical and with the source vector .",
    "the only difference is the introduction of the edge mask @xmath65 which is logically `` anded '' between the source and shifted destination masks .",
    "we use the same process at the vertex level to account for self - edges ( connections between @xmath17 and @xmath66 ) .     and a destination node @xmath46 connected by edge @xmath25 , together with their respective mask .",
    "top right : the binary mask vector of @xmath46 , is shifted ( in this illustration left - shifted ) .",
    "then , a logical and is performed between the three vectors . on the bottom figure , the result @xmath47 , stored in @xmath25 , is read to create the edges ( and nodes ) of @xmath11 . in this example , the pair @xmath67 is disconnected because the first entry of @xmath62 is @xmath68 .",
    "only one edge between @xmath69 and @xmath70 is created.,title=\"fig : \" ]   and a destination node @xmath46 connected by edge @xmath25 , together with their respective mask .",
    "top right : the binary mask vector of @xmath46 , is shifted ( in this illustration left - shifted ) .",
    "then , a logical and is performed between the three vectors . on the bottom figure , the result @xmath47 , stored in @xmath25 , is read to create the edges ( and nodes ) of @xmath11 . in this example , the pair @xmath67 is disconnected because the first entry of @xmath62 is @xmath68 .",
    "only one edge between @xmath69 and @xmath70 is created.,title=\"fig : \" ]"
  ],
  "abstract_text": [
    "<S> graphs are now ubiquitous in almost every field of research . recently </S>",
    "<S> , new research areas devoted to the analysis of graphs and data associated to their vertices have emerged . </S>",
    "<S> focusing on dynamical processes , we propose a fast , robust and scalable framework for retrieving and analyzing recurring patterns of activity on graphs . </S>",
    "<S> our method relies on a novel type of multilayer graph that encodes the spreading or propagation of events between successive time steps . </S>",
    "<S> we demonstrate the versatility of our method by applying it on three different real - world examples . </S>",
    "<S> firstly , we study how rumor spreads on a social network . </S>",
    "<S> secondly , we reveal congestion patterns of pedestrians in a train station . </S>",
    "<S> finally , we show how patterns of audio playlists can be used in a recommender system . in each example </S>",
    "<S> , relevant information previously hidden in the data is extracted in a very efficient manner , emphasizing the scalability of our method . with a parallel implementation scaling linearly with the size of the dataset , our framework easily handles millions of nodes on a single commodity server .    dynamical processes on graphs , causal multilayer graph , pattern analysis , network analysis . </S>"
  ]
}