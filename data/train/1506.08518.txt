{
  "article_text": [
    "computing maximal ( non - extendable ) repetitions in a word is a classical topic in the area of string algorithms ( see for example @xcite and references therein ) .",
    "maximal repetitions of substrings , also called _ runs _ , give information on the repetitive regions of a word , and are used in many applications , for example in the analysis of genomic sequences .",
    "kolpakov and kucherov @xcite gave the first linear - time algorithm for computing all the runs in a word and conjectured that any word of length @xmath2 contains less than @xmath2 runs .",
    "recently , bannai et al .",
    "@xcite , using the notion of lyndon roots of a run , proved this conjecture and designed a much simpler algorithm computing the runs .    here",
    "we deal with a generalization of this problem to the commutative setting .",
    "recall that an abelian power is a concatenation of two or more words that have the same parikh vector , i.e. , that have the same number of occurrences of each letter of the alphabet .",
    "for example , @xmath10 is an abelian square , since @xmath11 and @xmath12 both have two @xmath13 s and one @xmath14 , i.e. , the same parikh vector @xmath15 . when an abelian power occurs within a word",
    ", one can search for its `` maximal '' occurrence by extending it to the left and to the right character by character without violating the condition on the number of occurrences of each letter .",
    "following the approach of constantinescu and ilie  @xcite , we say that a parikh vector @xmath1 is an abelian period of a word @xmath0 if @xmath0 can be written as @xmath16 for some @xmath17 where for @xmath18 all the @xmath19 s have the same parikh vector @xmath1 and the parikh vectors of @xmath20 and @xmath21 are contained in @xmath1 .",
    "if @xmath22 , we say that the word @xmath0 is periodic with period @xmath1 .",
    "note that the factorization above is not necessarily unique .",
    "for example , @xmath23 and @xmath24 ( @xmath25 denotes the empty word ) are two factorizations of the word @xmath26 both corresponding to the abelian period @xmath27 .",
    "moreover , the same word can have different abelian periods .",
    "in this paper we define an _ abelian run _ of period @xmath1 in a word @xmath0 as an occurrence of a substring @xmath28 of @xmath0 such that @xmath28 is periodic with abelian period @xmath1 and this occurrence can not be extended to the left nor to the right by one letter into a substring periodic with period @xmath1 .    for example",
    ", let @xmath29 . then the prefix @xmath30 $ ] has abelian period @xmath31 but it is not an abelian run since the prefix @xmath32 $ ] also has abelian period @xmath31 .",
    "the latter , on the other hand , is an abelian run of period @xmath31 in @xmath0 .",
    "looking for abelian runs in a word can be useful to detect regions in the word where there is some kind of non - exact repetitiveness , for example regions with several consecutive occurrences of a substring or its reversal .",
    "matsuda et al .",
    "@xcite recently presented an offline algorithm for computing all abelian runs of a word of length @xmath2 in @xmath8 time .",
    "notice that , however , the definition of abelian run in  @xcite is slightly different from the one we consider here .",
    "we compare both versions in section [ sect - def ] .",
    "basically , our notion of abelian run is more restrictive than the one of  @xcite , for which we use the term `` anchored run '' .",
    "we first present an online algorithm that , given a word @xmath0 of length @xmath2 over an alphabet of cardinality @xmath3 and a parikh vector @xmath1 , returns all the abelian runs of period @xmath1 in @xmath0 in time @xmath4 and space @xmath5 , where @xmath6 is the norm of @xmath1 , that is , the sum of its components .",
    "this algorithm improves upon the one given in  @xcite which runs in time @xmath33 .",
    "next , we give an @xmath7-time online algorithm for computing all the abelian runs with periods of norm @xmath6 of a word of length @xmath2 , for any given @xmath6 .",
    "finally , we present an @xmath8 ( resp .",
    "@xmath34 ) -time offline randomized ( resp .",
    "deterministic ) algorithm for computing all the abelian runs of a word of length @xmath2 .",
    "the rest of this article is organized as follows .",
    "[ sect - def ] introduces central concepts and fixes the notation . in sect .",
    "[ sect - prev ] we review the results on abelian runs given in @xcite . sect .",
    "[ sect - new ] is devoted to the presentation of our main result : a new solution for computing the abelian runs for a given parikh vector . in sect .",
    "[ sect - newer ] we apply this algorithm in a procedure for computing the abelian runs with periods of a given norm .",
    "next , in sect .",
    "[ sect - all ] , we design a solution for computing all the abelian runs , which builds upon the result recalled in sect .",
    "[ sect - prev ] .",
    "finally , we conclude in sect .",
    "[ sect - conc ] .",
    "let @xmath35 be a finite ordered alphabet of cardinality @xmath3 , and let @xmath36 be the set of finite words over @xmath37 .",
    "we assume that the mapping between @xmath38 and @xmath39 can be evaluated in constant time for @xmath40 .",
    "we let @xmath41 denote the length of the word @xmath42 . given a word @xmath43 $ ] of length @xmath44 , we write @xmath45 $ ] for the @xmath46-th symbol of @xmath42 and , for @xmath47",
    ", we write @xmath48 $ ] to denote a fragment of @xmath42 from the @xmath46-th symbol to the @xmath49-th symbol , both included .",
    "this fragment is an occurrence of a substring @xmath50\\cdots w[j]$ ] . for @xmath51 ,",
    "@xmath52 $ ] denotes the empty fragment .",
    "we let @xmath53 denote the number of occurrences of the symbol @xmath54 in the word @xmath42 .",
    "the parikh vector of @xmath42 , denoted by @xmath55 , counts the occurrences of each letter of @xmath37 in @xmath42 , that is , @xmath56 .",
    "notice that two words have the same parikh vector if and only if one word is a permutation ( i.e. , an anagram ) of the other",
    ". given the parikh vector @xmath55 of a word @xmath42 , we let @xmath57 $ ] denote its @xmath39-th component and @xmath58 its norm , defined as the sum of its components . thus , for @xmath59 and @xmath60",
    ", we have @xmath57=|\\s{w}|_{a_i}$ ] and @xmath61=|\\s{w}|$ ] .",
    "finally , given two parikh vectors @xmath62 , we write @xmath63 if @xmath64\\le \\qv[i]$ ] for every @xmath65 .",
    "if additionally @xmath66 , we write @xmath67 and say that @xmath1 is contained in @xmath68 .",
    "[ def - ap ] a factorization @xmath69 satisfying @xmath17 , @xmath70 , and @xmath71 is called a _ periodic factorization _ of @xmath0 with respect to @xmath1 .",
    "if a word @xmath42 admits such a factorization , we say that @xmath1 is an _ ( abelian ) period _ of @xmath42 .",
    "we call fragments @xmath72 and @xmath73 respectively the _ head _ and the _ tail _ of the factorization , while the remaining factors are called",
    "_ cores_. note that the head and the tail are of length strictly smaller than @xmath74 ; in particular they can be empty .",
    "observe that a periodic factorization with respect to a fixed period is not unique .",
    "however , it suffices to specify @xmath75 to indicate a particular factorization ; see  @xcite .",
    "dealing with factorizations of fragments of a fixed text , it is more convenient to use a different quantity for this aim .",
    "suppose @xmath76=u_0\\cdots u_k$ ] is a factorization with respect to abelian period @xmath1 with @xmath77 .",
    "observe that consecutive starting positions @xmath78 of factors @xmath79 differ by exactly @xmath6 .",
    "hence , they share a common remainder modulo @xmath6 , which we call the _ anchor _ of the factorization .",
    "note that the anchor does not change if we trim a factorization of @xmath76 $ ] to a factorization of a shorter fragment , or if we extend it to a factorization of a longer fragment .",
    "a fragment @xmath76 $ ] has an abelian period @xmath1 _ anchored _ at @xmath80 if it has a periodic factorization with respect to @xmath1 whose anchor is @xmath81 .",
    "if @xmath0 has a factorization with at least two cores , we say that @xmath0 is _ periodic _ with period @xmath1 ( anchored at @xmath80 if @xmath81 is the anchor of the factorization ) .",
    "a fragment @xmath76 $ ] is called an _ abelian run _ with period @xmath1 if it is periodic with period @xmath1 and maximal with respect to this property ( i.e. , each of @xmath82 $ ] and @xmath83 $ ] either does not exist or it is not periodic with period @xmath1 ) .",
    "we shall often represent an abelian run @xmath76 $ ] as a tuple @xmath84 where @xmath85 and @xmath86 are respectively the lengths of the head and the of the tail of a periodic factorization of @xmath76 $ ] with period @xmath1 and at least two cores ( see  [ figu - def ] ) . note that @xmath87 is the anchor of the factorization , and that @xmath88 is the number of cores , in particular it is an integer .",
    "observe that an abelian run with period @xmath1 may have several valid factorizations .",
    "for example , @xmath89 and @xmath90 are factorization of a run @xmath91 $ ] with period @xmath92 in @xmath93 .",
    "therefore the run can be represented as @xmath94 and as @xmath95 .",
    "however , in @xmath96 only @xmath97 is a representation of @xmath98 $ ] as an abelian run with period @xmath92 .",
    "this is because @xmath99 corresponds to a factorization @xmath98=a\\cdot ba \\cdot b$ ] with one core only , and such a factorization does not indicate that @xmath98 $ ] is an abelian run .",
    "( 0,0 ) rectangle ( 2,.5 ) ; ( 2,0 ) rectangle ( 4,.5 ) ; ( 4,0 ) rectangle ( 7,.5 ) ; ( 7,0 ) rectangle ( 10,.5 ) ; ( 10,0 ) rectangle ( 13,.5 ) ; ( 13,0 ) rectangle ( 14,.5 ) ; ( 14,0 ) rectangle ( 15,.5 ) ;    at ( 2.25,.75 ) @xmath39 ; at ( 13.75,.75 ) @xmath100 ;    ( 2,-.5 )  ( 4,-.5 ) ; at ( 3,-1 ) @xmath85 ;    ( 13,-.5 )  ( 14,-.5 ) ; at ( 13.5,-1 ) @xmath86 ;    ( 4,-.5 )  ( 7,-.5 ) ; at ( 5.5,-1 ) @xmath74 ;    ( 7,-.5 )  ( 10,-.5 ) ; at ( 8.5,-1 ) @xmath74 ;    ( 10,-.5 )  ( 13,-.5 ) ; at ( 11.5,-1 ) @xmath74 ;    ( 4,1 )  ( 13,1 ) ; at ( 8.5,1.5 ) @xmath101 ;    matsuda et al .",
    "@xcite gave a different definition of abelian runs , where maximality is with respect to extending a fixed factorization .",
    "in this paper , we call such fragments anchored ( abelian ) runs .",
    "[ def - anchored ] a fragment @xmath76 $ ] is a _",
    "@xmath80-anchored abelian run _ with period @xmath1 if @xmath76 $ ] is periodic with period @xmath1 anchored at @xmath80 and maximal with respect to this property ( i.e. , each of @xmath82 $ ] and @xmath83 $ ] either does not exist or it is not periodic with period @xmath1 anchored at @xmath80 ) .    note that every abelian run is an anchored run with the same period ( for some anchor ) .",
    "the converse is not true , since it might be possible to extend an anchored run preserving the period but not the anchor .",
    "for example , in the word @xmath29 considered in the introduction , the fragment @xmath102={\\varepsilon}\\cdot ab \\cdot ab \\cdot a$ ] is a @xmath103-anchored run but not an abelian run , since @xmath104=a \\cdot ba \\cdot ba \\cdot a$ ] is periodic with abelian period @xmath31 .",
    "since a factorization is uniquely determined by the anchor , standard inclusion - maximality is equivalent to the condition in definition  [ def - anchored ] .",
    "let @xmath76 $ ] and @xmath105 $ ] be fragments of @xmath0 with abelian period @xmath1 anchored at @xmath80 . if @xmath76 $ ] is properly contained in @xmath105 $ ] ( i.e , @xmath106 and @xmath107 , or @xmath108 and @xmath109 ) , then @xmath76 $ ] is not a @xmath80-anchored abelian run with period  @xmath1 .",
    "abelian runs enjoy the same property , but its proof is no longer trivial .",
    "[ lemma - maximality ]",
    "let @xmath76 $ ] and @xmath105 $ ] be fragments of @xmath0 with abelian period @xmath1 .",
    "if @xmath76 $ ] is properly contained in @xmath105 $ ] , then @xmath76 $ ] is not an abelian run with period @xmath1 .",
    "we assume that @xmath110 .",
    "the case of @xmath109 is symmetric . for a proof by contradiction",
    "suppose that @xmath76 $ ] is an abelian run and let @xmath76=u_0\\cdots u_k$ ] be a periodic factorization with period @xmath1 and at least two cores ( i.e. , satisfying @xmath111 )",
    ". a periodic factorization of @xmath105 $ ] can be trimmed to a factorization @xmath82={v}_0\\cdots { v}_{\\ell}$ ] . however , since @xmath76 $ ] is an abelian run , this factorization must have at most one core ( i.e. , @xmath112 ) .",
    "moreover , @xmath113 can not be extended to a factorization of @xmath82=u'_0u_1\\cdots u_k$ ] . in other words",
    "@xmath114 , the extension of @xmath20 by one letter to the left , must satisfy @xmath115 .",
    "let @xmath77 .",
    "the conditions on the number of cores imply @xmath116|$ ] and @xmath117\\pp j]| < |v_0|+2p$ ] . consequently , @xmath118 , i.e. , @xmath114 is a proper prefix of @xmath119 . this yields @xmath120 , which is in contradiction with @xmath115 .",
    "[ coro - run ] let @xmath0 be a word . for a fixed parikh vector @xmath1 , there is at most one abelian run with abelian period @xmath1 starting at each position of @xmath0 .",
    "matsuda et al .",
    "@xcite presented an algorithm that computes all the anchored runs of a word @xmath0 of length @xmath2 in @xmath8 time and space complexity .",
    "the initial step of the algorithm is to compute maximal abelian powers in @xmath0 . recall that an abelian power is a concatenation of several abelian - equivalent words .",
    "in other words , an abelian power of period @xmath1 is a word admitting a periodic factorization with respect to @xmath1 with an empty head , an empty tail and at least two cores .",
    "a fragment @xmath76 $ ] is a maximal abelian power if it can not be extended to a longer power of period @xmath1 ( preserving the anchor ) .",
    "formally , the maximality conditions  are    1 .",
    "@xmath121 } \\ne \\pv_{\\s{w}[i\\pp i+p-1]}$ ] or @xmath122 , and 2 .",
    "@xmath123 } \\ne \\pv_{\\s{w}[j+1\\pp j+p]}$ ] or @xmath124 ,    where @xmath77 .",
    "the approach of  @xcite is to first compute all the abelian squares using the algorithm by cummings & smyth  @xcite .",
    "the next step is to group squares into maximal abelian powers . for this",
    ", it suffices to merge pairs of overlapping abelian squares of the form @xmath125 $ ] and @xmath126 $ ] . this way maximal abelian powers",
    "are computed in @xmath8 time .",
    "observe that there is a natural one - to - one correspondence between maximal abelian powers and anchored runs : it suffices to trim the head and the tail of the factorization of an anchored run to obtain a maximal abelian power .",
    "hence , the last step of the algorithm is to compute the maximal head and tail by which each abelian power can be extended .",
    "this could be done naively in @xmath127 time overall , but a clever computation enables to find all the abelian runs in time and space @xmath8 ( see  @xcite for further details ) .",
    "in section  [ sect - all ] , we extend this result to compute the abelian runs only rather than all the anchored runs .",
    "both these algorithms work offline : they need to know the whole word before reporting any abelian run . in the following two sections",
    "we give several online algorithms , which are able to report a run ending at position @xmath128 of a word @xmath0 before reading @xmath129 $ ] and the following letters .",
    "clearly , not knowing @xmath50 $ ] one can not decide whether the run could be extended to the right , so this is the optimal delay .",
    "however , these methods are restricted to finding runs of a given period or a given norm of the periods , respectively .",
    "in this section we present our online solution for computing all the abelian runs of a given parikh vector @xmath1 of norm @xmath6 in a given word @xmath0 .",
    "the algorithm works in @xmath4 time and @xmath5 space where @xmath130 .",
    "first , in sect .  [ sub - anchored ] , we show how to compute all anchored runs of period  @xmath1 .",
    "later , in sect .  [ sub - abelian ] , we modify the algorithm to return abelian runs only .",
    "we conclude in sect .",
    "[ sub - example ] with an example course of actions in our solution .",
    "we begin with a description of data maintained while scanning the string @xmath0 . for an integer @xmath80 ,",
    "let @xmath131 $ ] be the starting position of the longest suffix of @xmath132 $ ] which has period @xmath1 anchored at @xmath80 .",
    "if there is no such a suffix , we set @xmath131 = \\infty$ ] . since this notion depends on @xmath133 only , we store @xmath134 $ ] for @xmath135 only .",
    "let @xmath136 be the starting position of the longest suffix of @xmath132 $ ] whose parikh vector is contained in or equal to @xmath1 . in other words",
    ", we have @xmath137}\\subseteq \\pv$ ] and @xmath138}\\not\\subseteq \\pv$ ] ( or @xmath139 ) .",
    "note that @xmath140 if @xmath50 $ ] does not occur in @xmath1 .",
    "observe that the tail of any periodic factorization of a suffix of @xmath132 $ ] must be contained in @xmath141 $ ] .",
    "this leads to the following characterization :    [ lemma - char - simple ] let @xmath142 .",
    "we have @xmath134\\le k$ ] for @xmath143 and @xmath134=\\infty$ ] for @xmath144 .    for @xmath143 , the fragment @xmath145 $ ] has abelian period @xmath1 anchored at @xmath80 .",
    "( the underlying factorization has empty head , no cores and tail @xmath145 $ ] , unless @xmath146 , when the factorization has one core , empty head and empty tail ) .",
    "hence , we have @xmath134\\le k$ ] directly from the definition .    for @xmath144 ,",
    "the tail of the factorization with anchor @xmath133 would need to start at position @xmath80 , which is impossible ( see  [ figu - case1 ] ) .",
    "( .5,0 ) rectangle ( 7.5,.5 ) ; ( 7.5,0 ) rectangle ( 9,.5 ) ; ( 9,0 ) rectangle ( 12.5,.5 ) ;    at ( .25,.25 ) @xmath0 ; at ( 7,.75 ) @xmath147 ; at ( 9.25,.75 ) @xmath136 ; at ( 12.25,.75 ) @xmath39 ;    ( 8.5,-.5 ) rectangle ( 12.5,-1 ) ;    at ( 13,-.75 ) @xmath148 ; at ( 10.5,-.75 ) impossible tail ;    the values @xmath149 and @xmath136 are actually sufficient to describe @xmath150 based on @xmath151 .",
    "[ lemma - algo ] for @xmath142 the following equalities hold :    1 .",
    "[ case1 ] @xmath134=\\infty \\ne b_{i-1}[k]$ ] for @xmath152 , 2 .   [ case2 ] @xmath134=b_{i-1}[k]$ ] for @xmath153 and for @xmath154 , 3 .   [ case3 ] @xmath155 = b_i$ ] if @xmath156 and @xmath155=b_{i-1}[i - p+1]$ ] otherwise .",
    "lemma  [ lemma - char - simple ] implies that @xmath131=\\infty$ ] for @xmath144 and @xmath157=\\infty$ ] for @xmath158 ( hence @xmath157=b_{i}[k]$ ] in this latter case ) . for @xmath159",
    ", we have @xmath160}\\subseteq \\pv$ ] , so we can extend the factorization of a suffix of @xmath161 $ ] whose tail starts at position @xmath80 ( see  [ figu - case2 ] ) .",
    "finally , note that @xmath155 $ ] is the starting position of the maximal suffix of @xmath132 $ ] with an empty - tail periodic factorization .",
    "if @xmath162}\\ne \\pv$ ] ( i.e. , if @xmath163 ) , this is just @xmath141 $ ] .",
    "otherwise , we can extend the factorization of a suffix of @xmath161 $ ] whose tail starts at position @xmath164 .",
    "( .5,0 ) rectangle ( 8,.5 ) ; ( 8,0 ) rectangle ( 9.5,.5 ) ; ( 9.5,0 ) rectangle ( 12,.5 ) ; ( 12,0 ) rectangle ( 12.5,.5 ) ;    at ( .25,.25 ) @xmath0 ; at ( 3.75,.75 ) @xmath157 $ ] ; at ( 8.25,.75 ) @xmath149 ; at ( 10.25,.75 ) @xmath80 ; at ( 9.75,.75 ) @xmath136 ; at ( 12.25,.75 ) @xmath39 ;    ( 10,-1.5 ) rectangle ( 12.5,-2 ) ; at ( 13,-1.75 ) @xmath165 ;    ( 3.5,-2.5 ) rectangle ( 5,-3 ) ; ( 6,-2.5 ) rectangle ( 10,-3 ) ; ( 10,-2.5 ) rectangle ( 12,-3 ) ; at ( 5.5,-2.75 ) @xmath166 ;    ( 3.5,-3.5 ) rectangle ( 5,-4 ) ; ( 6,-3.5 ) rectangle ( 10,-4 ) ; ( 10,-3.5 ) rectangle ( 12.5,-4 ) ; at ( 5.5,-3.75 ) @xmath166 ;    at ( 1.75,-2.55 ) fragment ; at ( 1.75,-2.95 ) ending at @xmath128 ; at ( 1.75,-3.55 ) fragment ; at ( 1.75,-3.95 ) ending at @xmath39 ;    having read letter @xmath50 $ ] , we need to report anchored runs which end at position @xmath128 . for this , we use the following characterization .    [ lem - report - anchored ] let @xmath167 .",
    "a fragment @xmath168 $ ] is a @xmath80-anchored run with period @xmath1 if and only if @xmath157 = b\\le k-2p$ ] and @xmath134>b$ ] .",
    "clearly an anchored run ending at position @xmath128 must be a left - maximal suffix of @xmath161 $ ] with a given anchor .",
    "moreover , we must have @xmath169 so that the factorization has at least two cores and @xmath134>b$ ] due to right - maximality .",
    "it is easy to see that these conditions are sufficient .    by lemma  [ lemma - algo ] ,",
    "most entries of @xmath150 are inherited from @xmath151 , so we use a single array @xmath170 and having read @xmath50 $ ] , we update its entries . as evident from lemma",
    "[ lem - report - anchored ] , each anchored run to be reported corresponds to a modified entry .",
    "the algorithm in  [ algo - run0 ] implements our approach . the * while * loop increments @xmath80 from @xmath149 to @xmath136 . for @xmath171 ,",
    "we set @xmath172 $ ] to @xmath173 and possibly report a run . note",
    "that @xmath174 is within the scope of case  [ case3 ] rather than case  [ case1 ] in lemma  [ lemma - algo ] .",
    "however , later we set @xmath175 $ ] to @xmath176 if @xmath177 ( as described in case  [ case3 ] ) .",
    "nevertheless , if an @xmath46-anchored run needs to be reported , we have @xmath178<\\infty = b_{i}[i - p+1]$ ] , so @xmath179 and thus @xmath174 is considered in the loop .",
    "anchoredrun , p , w , n [ loop - for - begin ] [ loop - while - begin ] [ loop - while - end ] [ loop - for - end ]    the algorithm computes all the anchored runs with period @xmath1 of norm @xmath6 in a word @xmath0 of length @xmath2 in time @xmath4 and additional space @xmath5 .",
    "the correctness of the algorithm comes from lemmas  [ lemma - algo]-[lem - report - anchored ] and the discussion above .",
    "the external * for * loop in lines  [ loop - for - begin][loop - for - end ] runs @xmath180 times . the internal * while * loop in lines  [ loop - while - begin][loop - while - end ] can not iterate more than @xmath180 times since it starts with @xmath80 equal to @xmath103 and ends when @xmath80 is equal to @xmath2 and @xmath80 can only be incremented by @xmath181 ( in line  [ loop - while - end ] ) .",
    "the test @xmath182 } \\not\\subseteq \\pv$ ] in line  [ loop - while - begin ] can be realized in constant time once we store @xmath182}$ ] and a counter of its components for which the value is greater than in @xmath1 .",
    "this data needs to be updated once we increment @xmath39 in the * for * loop and @xmath80 in line  [ loop - while - end ] .",
    "we then need to increment the component @xmath50 $ ] or decrement the component @xmath183 $ ] of @xmath182}$ ] , respectively .",
    "the global counter needs to be updated accordingly .",
    "all the other operations run in constant time .",
    "thus the total time complexity of the algorithm is @xmath4 .",
    "the space complexity comes from the number of counters ( @xmath3 ) and the size of the array @xmath170 ( @xmath6 ) .",
    "note that the space consumption can be reduced to @xmath184 at the price of introducing ( monte carlo ) randomization . instead of storing the parikh vectors in a plain form",
    ", we can use dynamic hash tables  @xcite so that the size is proportional to the number of non - zero entries .",
    "run , p , w , n    in this section we extend our algorithm so that it reports abelian runs only . for an offline solution",
    ", we could simply determine the anchored runs ( using the procedure developed above ) and filter out those which are not maximal .",
    "however , in order to obtain an online algorithm , we need a more subtle approach , which is based on the following characterization .",
    "[ lem - report - abelian ] a fragment @xmath168 $ ] is an abelian run with period @xmath1 if and only if it is an anchored run ( with period @xmath1 ) and for each @xmath185 the inequalities @xmath186\\ge b$ ] and @xmath187>b$ ] hold .    by lemma  [ lemma - maximality ] , an abelian run of period @xmath1 can not be properly contained in a fragment with period @xmath1 ( anchored at some @xmath185 ) .",
    "conditions involving @xmath186 $ ] and @xmath188 $ ] enforce left - maximality and right - maximality , respectively . since each abelian run is an anchored run ( with the same period ) and",
    "since all anchored runs are periodic , the claim follows .    to apply lemma  [ lem - report - abelian ] , it suffices to find an anchor @xmath80 such that @xmath189=\\min_{k'}b_{i-1}[k']<\\min_{k'}b_{i}[k']$ ] .",
    "there can be several such anchors and in case of ties we are going to detect the one for which the factorization of @xmath168 $ ] has shortest tail .",
    "this factorization maximizes the number of cores , so if @xmath168 $ ] is an anchored run with any anchor , it is with that one in particular . note that the * while * loop in lines  [ loop - while - begin][loop - while - end ] of algorithm anchoredrun processes anchors @xmath190 in the order of decreasing tail lengths and updates the underlying values @xmath172 $ ] from @xmath157 $ ] to @xmath131 $ ] . for the sought anchor @xmath80",
    "this update strictly increases the value @xmath191 $ ] , and moreover this is the first increase of the minimum within a given iteration of the outer * for * loop .",
    "hence , we record the original minimum and check for an abelian run only if @xmath191 $ ] increases from that value .    to implement the procedure described above",
    ", we need to efficiently compute the smallest element in the array @xmath170 . for this , recall that @xmath192 $ ]",
    "can only be modified from @xmath173 to @xmath80 ( and the value @xmath80 does not decrease throughout the algorithm ) or from some value back to @xmath173 .",
    "we maintain a doubly - linked list @xmath193 of all indices @xmath100 with finite @xmath192 $ ] such that the order of indices @xmath100 in the list",
    "is consistent with the order of values @xmath192 $ ] . to update the list",
    ", it suffices to insert the index @xmath100 to the end of list while setting @xmath192 $ ] to @xmath80 , and remove it from the list setting @xmath192 $ ] to @xmath173 .",
    "then the smallest value in @xmath170 is attained at an argument stored as the first element of the list @xmath193 ( or @xmath173 , if the list is empty ) .",
    "the algorithm , depicted in  [ algo - run ] , implements the approach described above .",
    "it uses the following constant - time functions to operate on lists :    * that inserts @xmath194 at the end of the doubly - linked list @xmath193 and returns a pointer to the location of @xmath194 in the list ; * that deletes the element pointed by @xmath195 from the doubly - linked list @xmath193 ; * that returns the first element of the list @xmath193 ( 0 if the list is empty ) .",
    "the algorithm also uses an array @xmath196 which maps any anchor @xmath100 to a pointer of the corresponding location in the list @xmath193 ( or @xmath197 if @xmath192=\\infty$ ] ) .",
    "the discussion above proves that correctly computes abelian runs with period @xmath1 in @xmath0 .",
    "its running time is the same as that of since the structure of the computations remains the same while additional instructions run in constant time .",
    "memory consumption is still @xmath198 because both @xmath193 and @xmath196 take @xmath184 space .    the algorithm computes all the abelian runs with period @xmath1 of norm @xmath6 in a word @xmath0 of length @xmath2 in time @xmath4 and additional space @xmath5 , which can be reduced to @xmath184 using randomization .",
    "let us see the behaviour of the algorithm on @xmath199 , @xmath200 and @xmath201 : + @xmath202 \\quad l= ( 0)$ ]    @xmath203}\\subseteq \\pv",
    "\\quad b = [ 0 , 0 , \\infty , \\infty ] \\quad l= ( 0,1)$ ]    @xmath204}\\subseteq \\pv   \\quad b =",
    "[ 0 , 0 , 0 , \\infty ] \\quad l= ( 0,1,2)$ ]    @xmath205}\\subseteq \\pv   \\quad b = [ 0 , 0 , 0 , 0 ] \\quad l= ( 0,1,2,3)$ ]    @xmath206}\\not\\subseteq \\pv \\quad b=0 \\quad b=[\\infty , 0,0,0 ] \\quad l= ( 1,2,3 ) \\quad k=1 $ ]    @xmath207}\\subseteq \\pv \\quad   b = [ 1 , 0 , 0 , 0 ] \\quad l= ( 1,2,3,0)$ ]    @xmath208}\\subseteq \\pv$ ]    @xmath209}\\not\\subseteq \\pv \\quad k=2 $ ]    @xmath210}\\not\\subseteq \\pv \\quad b=0 \\quad b = [ 1 , 0 , \\infty , 0 ] \\quad l= ( 1,3,0 ) \\quad k=3 $ ]    @xmath211}\\subseteq \\pv \\quad   b = [ 1 , 0 , 3 , 0 ] \\quad l= ( 1,3,0,2)$ ]    @xmath212}\\subseteq \\pv$ ]    @xmath213}\\not\\subseteq \\pv \\quad k=4 $ ]    @xmath214}\\subseteq \\pv$ ]    @xmath215}\\not\\subseteq \\pv \\quad k=5 $ ]    @xmath216}\\not\\subseteq \\pv \\quad b=0 \\quad   b = [ 1 , \\infty , 3 , 0 ] \\quad l= ( 3,0,2)\\quad k=6 $ ]    @xmath217}\\subseteq \\pv \\quad   b = [ 1 , 6 , 3 , 0 ] \\quad l= ( 3,0,2,1)$ ]    @xmath218}\\subseteq \\pv$ ]    @xmath219}\\not\\subseteq \\pv \\quad k=7 $ ]    @xmath220}\\subseteq \\pv$ ]    @xmath221}\\not\\subseteq \\pv \\quad k=8 $ ]    @xmath222}\\not\\subseteq \\pv \\quad b=1 \\quad b=[\\infty,6,3,0 ] \\quad l=(3,2,1 ) \\quad k=9 $ ]    @xmath223}\\not\\subseteq \\pv \\quad b=6 \\quad b=[\\infty,\\infty,3,0 ] \\quad l=(3,2)\\quad k=10 $ ]    @xmath224}\\subseteq \\pv \\quad b=[10,\\infty,3,0 ] \\quad l=(3,2,0)$ ]    @xmath225    @xmath226 \\quad l= ( 3,0 ) \\quad k = 11 $ ]    @xmath227 \\quad l= ( 0)$ ]    @xmath228    @xmath229 \\quad l= ( ) \\quad k=13 $ ]",
    "in this section we develop an @xmath7-time algorithm to compute all abelian runs with periods of norm @xmath6 .",
    "first , we describe the algorithm for anchored runs and later generalize it to abelian runs .",
    "let us start with a simple offline algorithm which works in @xmath4 time to compute @xmath80-anchored runs with period of norm @xmath6 for fixed values @xmath6 and @xmath80 .",
    "this method is similar to the algorithm of matsuda et al .",
    "@xcite briefly described in section  [ sect - prev ] .",
    "namely , it suffices to compute maximal abelian powers with periods of norm @xmath6 anchored at @xmath80 , and then extend them by a head and a tail .",
    "block _ as any fragment of the form @xmath230 $ ] such that @xmath231 .",
    "note that the cores in decompositions with anchor @xmath133 are blocks .",
    "finding @xmath80-anchored powers with periods of a given norm @xmath6 is very easy if the anchor is fixed .",
    "we consider consecutive blocks , naively check if they are abelian - equivalent and merge any maximal chains of abelian - equivalent blocks . determining the head and",
    "the tail of the @xmath80-anchored runs is also simple . for each @xmath231",
    "we compute the longest suffix of @xmath161 $ ] and the longest prefix of @xmath232 $ ] whose parikh vectors are contained in @xmath233}$ ] .",
    "this approach can be implemented online in @xmath5 space as follows : we scan consecutive blocks and ( naively ) check their abelian equivalence .",
    "whenever we read a full block ( say , starting at position @xmath39 ) , we compute the longest suffix @xmath234 $ ] of @xmath161 $ ] whose parikh vector is contained in @xmath233}$ ] .",
    "this gives a periodic factorization of @xmath235 $ ] anchored at @xmath81 .",
    "we then try to extend it to the right while reading further characters .",
    "once it is impossible to extend the factorization , say by letter @xmath236 $ ] , we declare @xmath237 $ ] as a maximal fragment with period @xmath233}$ ] anchored at @xmath80 .",
    "if the decomposition has at least two cores , we report an anchored run .",
    "if we succeed to extend by a full block ( i.e. , if @xmath233}=\\pv_{w[i+p\\pp i+2p-1]}$ ] ) , we do not restart the algorithm but instead we continue to extend the factorization .",
    "this way , we guarantee that @xmath238 whenever we start building a new factorization .",
    "clearly , the procedure described above computes all @xmath80-anchored runs with period of norm @xmath6 . to compute all anchored runs , we simply run it in parallel for all @xmath6 possible anchors",
    ".    there is an algorithm which computes online all the anchored runs with periods of norm @xmath6 in a word @xmath0 of length @xmath2 over an alphabet of size @xmath3 in time @xmath33 and additional space @xmath239 , which can be reduced to @xmath240 using randomization .",
    "let us first slightly modify the algorithm presented in the previous section .",
    "observe that whenever we start a new phase having just read a block @xmath230 $ ] , instead of performing the computations using a simple procedure described above , we could launch the algorithm of section  [ sub - anchored ] for @xmath241 $ ] and @xmath242}$ ] , simulate it until it needs to read @xmath243 $ ] and then feed it with newly read letters until the maximal extension of @xmath230 $ ] anchored at @xmath80 is found ( i.e. , until the respective entry of the @xmath170 array is set to @xmath173 ) .",
    "other anchored runs output by the algorithm should be ignored , of course . as before ,",
    "if such a process is running while we have completed reading a subsequent block , we do not start a new phase .",
    "it is easy to see that such an algorithm is equivalent to the previous one .",
    "however , if we use the algorithm of section  [ sub - abelian ] instead , we automatically get a possibility to check whether the maximal extension of @xmath230 $ ] anchored at @xmath80 is a maximal fragment with period @xmath233}$ ] .",
    "note that we start the simulation at a position @xmath244 which is smaller than @xmath149 , unless the latter is @xmath103 .",
    "this guarantees that left - maximality is correctly verified despite the fact the fragment prior to position @xmath147 is ignored in the simulation . as before , we disregard any other abelian run that the algorithm of section  [ sub - abelian ] may return .",
    "we run this process in parallel for all possible anchors to guarantee that each abelian run with period of norm @xmath6 is reported exactly once .",
    "more precisely , in ambiguous cases a run is reported for the anchor corresponding to the factorization with shortest tail , just as in section  [ sub - abelian ] .",
    "there is an algorithm which computes online all the abelian runs with periods of norm @xmath6 in a word @xmath0 of length @xmath2 over an alphabet of size @xmath3 in time @xmath33 and additional space @xmath239 , which can be reduced to @xmath240 using randomization .",
    "in this section we present an @xmath8-time offline algorithm which computes all the abelian runs . as a starting point",
    ", we use the set of all anchored runs computed by the algorithm by matsuda et al .",
    "( see section  [ sect - prev ] ) . recall that all abelian runs are anchored runs with the same period .",
    "hence , it suffices to filter out those anchored runs which are properly contained in another anchored run with the same period .",
    "we also need to make sure that every abelian run is reported once only ( despite possibly being @xmath80-anchored for different anchors @xmath80 ) .",
    "note that this filtering can be performed independently for distinct periods .",
    "if we have a list of anchored runs with a fixed period , sorted by the starting position , it is easy to retrieve the abelian runs of that period with a single scan of the list .",
    "ordering by the starting position can be performed together for all periods so that it takes @xmath245 time where @xmath246 is the number of all anchored runs .",
    "hence , the main difficulty is grouping according to the period .",
    "for this , we shall assign to each fragment of @xmath0 an _ identifier _ , so that two fragments are abelian - equivalent if and only if their identifiers are equal .",
    "the identifiers of periods can be easily retrieved since given a @xmath80-anchored run , we can easily locate one of the cores of the underlying factorization .",
    "thus , in the remaining part of this section we design a naming algorithm which assigns the identifiers . a naive solution would be to generate the parikh vectors of all substrings of @xmath0 , sort these vectors removing duplicates , and give each fragment a rank of its parikh vector in that order . however , already storing the parikh vectors can take prohibitive @xmath247 space .    to overcome this issue",
    ", we use the concept of _ diff - representation _ , originally introduced in the context of abelian periods  @xcite .",
    "observe that in a sense the parikh vectors of fragments can be generated efficiently : for a fixed @xmath6 , we can first generate @xmath248}$ ] , then update it to @xmath249}$ ] , and so on until we reach @xmath250}$ ] .",
    "in other words , the parikh vectors of all fragments of length @xmath6 can be represented in a sequence so that the total hamming distance of the adjacent vectors is @xmath4 . the diff - representation , designed to manipulate sequences satisfying such a property , is formally defined as a sequence of single - entry changes such that the original sequence of vectors is a subsequence of intermediate results when applying this operations starting from the null vector ( of the fixed dimension @xmath246 ) .",
    "note that the diff - representation of a sequence of parikh vectors of all fragments of @xmath0 can be computed in time @xmath8 proportional to its size .",
    "the following result lets us efficiently assign identifiers to its elements .",
    "given a sequence of vectors of dimension @xmath246 represented using a diff - representation of size @xmath251 , consider the problem of assigning integer identifiers of size @xmath252 so that equality of vectors is equivalent to equality of their identifiers .",
    "it can be solved in @xmath253 time using a deterministic algorithm and in @xmath254 time using a monte carlo algorithm which is correct with high probability ( @xmath255 where @xmath256 can be chosen arbitrarily large ) .    in our setting this yields the following result .",
    "there exists an @xmath8-time randomized algorithm ( monte carlo , correct with high - probability ) which computes all abelian runs in a given word of length @xmath2 .",
    "additionally , there exists an @xmath9-time deterministic algorithm solving the same problem .",
    "we gave algorithms that , given a word @xmath0 of length @xmath2 over an alphabet of cardinality @xmath3 , return all the abelian runs of a given period @xmath1 in @xmath0 in time @xmath4 and space @xmath5 , or all the abelian runs with periods of a given norm @xmath6 in time @xmath7 and space @xmath239 .",
    "these algorithms work in an online manner .",
    "we also presented an @xmath8 ( resp .",
    "@xmath34)-time offline randomized ( resp .",
    "deterministic ) algorithm for computing all the abelian runs in a word of length  @xmath2",
    ". one may wonder if it is possible to reduce further the complexities of these latter algorithms .",
    "we believe that further combinatorial results on the structure of the abelian runs in a word could lead to novel solutions .",
    "r.  kolpakov , g.  kucherov , finding maximal repetitions in a word in linear time , in : 40th annual symposium on foundations of computer science , focs 1999 , ieee computer society , new - york , 1999 , pp .",
    "http://dx.doi.org/10.1109/sffcs.1999.814634 [ ] .",
    "h.  bannai , t.  i , s.  inenaga , y.  nakashima , m.  takeda , k.  tsuruta , a new characterization of maximal repetitions by lyndon trees , in : p.  indyk ( ed . ) , proceedings of the twenty - sixth annual acm - siam symposium on discrete algorithms , soda 2015 , san diego , ca , usa , january 4 - 6 , 2015 , siam , 2015 , pp . 562571 . http://dx.doi.org/10.1137/1.9781611973730.38 [ ] .",
    "s.  matsuda , s.  inenaga , h.  bannai , m.  takeda , computing abelian covers and abelian runs , in : j.  holub , j.  zdrek ( eds . ) , prague stringology conference , psc 2014 , czech technical university in prague , 2014 , pp . 4351 .",
    "g.  fici , t.  lecroq , a.  lefebvre ,  .",
    "prieur - gaston , online computation of abelian runs , in : a.  h. dediu , e.  formenti , c.  martn - vide , b.  truthe ( eds . ) , language and automata theory and applications , lata 2015 , vol .",
    "8977 of lncs , springer international publishing , 2015 , pp .",
    "http://dx.doi.org/10.1007/978-3-319-15579-1_30 [ ] .",
    "m.  dietzfelbinger , a.  r. karlin , k.  mehlhorn , f.  meyer auf der heide , h.  rohnert , r.  e. tarjan , dynamic perfect hashing : upper and lower bounds , siam journal on computing 23  ( 4 ) ( 1994 ) 738761 .",
    "http://dx.doi.org/10.1137/s0097539791194094 [ ] .",
    "t.  kociumaka , j.  radoszewski , w.  rytter , fast algorithms for abelian periods in words and greatest common divisor queries , in : n.  portier , t.  wilke ( eds . ) , 30th international symposium on theoretical aspects of computer science , stacs 2013 , vol .",
    "20 of lipics , schloss dagstuhl - leibniz - zentrum fuer informatik , 2013 , pp .",
    "http://dx.doi.org/10.4230/lipics.stacs.2013.245 [ ] ."
  ],
  "abstract_text": [
    "<S> given a word @xmath0 and a parikh vector @xmath1 , an abelian run of period @xmath1 in @xmath0 is a maximal occurrence of a substring of @xmath0 having abelian period @xmath1 . </S>",
    "<S> our main result is an online algorithm that , given a word @xmath0 of length @xmath2 over an alphabet of cardinality @xmath3 and a parikh vector @xmath1 , returns all the abelian runs of period @xmath1 in @xmath0 in time @xmath4 and space @xmath5 , where @xmath6 is the norm of @xmath1 , i.e. , the sum of its components . </S>",
    "<S> we also present an online algorithm that computes all the abelian runs with periods of norm @xmath6 in @xmath0 in time @xmath7 , for any given norm @xmath6 . </S>",
    "<S> finally , we give an @xmath8-time offline randomized algorithm for computing all the abelian runs of @xmath0 . </S>",
    "<S> its deterministic counterpart runs in @xmath9 time .    </S>",
    "<S> combinatorics on words , text algorithms , abelian period , abelian run </S>"
  ]
}