{
  "article_text": [
    "a cryptographic hash function is a deterministic procedure that compresses an arbitrary block of data and returns fixed - size bit string , the hash value ( message digest or digest ) . an accidental or intentional change of the data will almost certainly change the hash value .",
    "hash functions are used to verify the integrity of data or data signature .",
    "+ let us suppose that @xmath0 is a hash function without key .",
    "the function @xmath1 is secured if the following three problems are difficult to solve .",
    "+ * problem 1 : * first preimage attack + @xmath2 _ instance : _ a function @xmath0 and an image @xmath3 + @xmath2 _ query : _",
    "@xmath4 @xmath5 such that @xmath6 + we suppose that a possible hash @xmath7 is given , we want to know if there exists @xmath8 such that @xmath6 . if we can solve _ first preimage attack _ ,",
    "then @xmath9 is a valid pair . a hash function for which _ first preimage attack _ ca nt be solved efficiently is sometimes called _ preimage resistant_. + * problem 2 : * second preimage attack + @xmath2 _ instance : _ a function @xmath0 and an element @xmath10 + @xmath2 _ query : _",
    "@xmath4 @xmath11 such that @xmath12 and @xmath13 + a message @xmath14 is given , we want to find a message @xmath15 such that @xmath16 and @xmath13 .",
    "if this is possible , then @xmath17 is a valid pair .",
    "a function for which _ second preimage attack _",
    "ca nt be solve efficiently is sometimes called _ second preimage resistant_. + * problem 3 : * collision attack + @xmath2 _ instance : _ a function @xmath0 + @xmath2 _ query : _",
    "@xmath4 @xmath18 such that @xmath12 and @xmath13 + we want to known if it is possible to find two distinct messages @xmath14 and @xmath15 such that @xmath13 .",
    "a function for which collision attack ca nt be solve efficiently is sometimes called _ collision resistant_.",
    "+ there exists many hash functions : md4 , md5 , sha-0 , sha-1 , ripemd , haval .",
    "it was reported that such widely hash functions are no longer secured @xcite .",
    "thus , new hash functions should be studied .",
    "the existing hash functions such as md4 , md5 , sha-0 , sha-1 , ripemd , haval ... want to achieve two goals at the same time :    @xmath19 ) : :    for any input @xmath8 , they return a hash of @xmath8    ( of fixed length , this length depends on the hash function choosed ) @xmath20 ) : :    preimage resistant , second preimage resistant and collision resistant .",
    "our contribution is to separate the two goals defined in points @xmath19 ) and @xmath20 ) .",
    "our hash function @xmath21 is defined as follows :    * @xmath22 , * @xmath23 is a classical hash function such as md5 , sha-0 , sha-1 , ripemd , haval , .... * given a @xmath7 , find @xmath8 such that @xmath24 is np - complete , * find @xmath14 , @xmath15 such that @xmath25 and @xmath26 is np - complete , * for any input @xmath8 , the length of @xmath27 is not fixed .",
    "this is the main difference with the classical hash functions .",
    "the paper is organized as follows : in section 2 , some preliminaries are presented .",
    "section 3 is devoted to the design of our hash function .",
    "concluding remarks are stated in section 4 .",
    "let s define some preliminaries useful for the next section .",
    "data security in two dimension have been studied by many authors @xcite .",
    "let @xmath28 and @xmath29 be two positive integers , and let @xmath30 and @xmath31 be non - negative integral vectors .",
    "denoted by @xmath32 the set of all @xmath33 matrices @xmath34 satisfying @xmath35 @xmath36    thus a matrix of 0 s and 1 s belongs to @xmath32 provided its row sum vector is @xmath37 and its column sum vector is @xmath38 .",
    "the set @xmath32 was studied by many authors @xcite .",
    "ryser @xcite has defined an _ interchange _ to be a transformation which replaces the @xmath39 submatrix : @xmath40 of a matrix a of 0 s and 1 s with the @xmath41 submatrix @xmath42 if the submatrix @xmath43 ( or @xmath44 ) lies in rows @xmath45 and columns @xmath46 , then we call the interchange a @xmath47 _ -interchange_. an interchange ( or any finite sequence of interchanges ) does not alter the row and column sum vectors of a matrix . ryser has shown the following result .",
    "[ th : n1 ] @xcite let @xmath48 and @xmath49 be two @xmath28 and @xmath29 matrices composed of 0 s and 1 s , possessing equal row sum vectors and equal column sum vectors",
    ". then @xmath48 is transformable into @xmath49 by a finite number of interchanges .",
    "let us consider a matrix @xmath50 , i.e. its row sum vector @xmath37 is such that @xmath51 and its column sum vector @xmath38 is such that @xmath52 .",
    "we define the function @xmath53 from @xmath54 to @xmath55 as follows : @xmath56 where @xmath57 denotes the concatenation .",
    "irving and jerrum @xcite have studied the extension of the problem in three dimension and shown that problems that are solvable in polynomial time in the two - dimensional case become np - complete .",
    "suppose that for a given @xmath58 table @xmath59 of non - negative integers , and for each @xmath60 , the row , column and file sums are denoted by @xmath61 and @xmath62 respectively .",
    "in other words : @xmath63    the following problem is studied by irving and jerrum @xcite : + * problem 4 . * three - dimensional contingency tables ( 3dct ) + @xmath2 _ instance : _ a positive integer @xmath29 , and for each @xmath60 non - negative integers + @xmath64 values @xmath65 , @xmath66 and @xmath62 + @xmath2 _ question : _ does there exist an @xmath58 contingency table @xmath67 of non - negative integers such that : @xmath68 for all @xmath60 ? irving and jerrum show the following result :    [ corrol:1 ] @xcite 3dct is np - complete , even in the special case where all the row , column and file sums are 0 or 1 .",
    "let us consider a matrix @xmath69 such that its row sum matrix is a matrix @xmath37 such that @xmath70 ( i.e. @xmath71 ) , the column sum matrix is a matrix @xmath72 such that @xmath73 ( i.e. @xmath74 ) and the file sum matrix is a matrix @xmath75 such that @xmath76 ( i.e. @xmath77 ) .",
    "we define the function @xmath78 as follows : @xmath79 @xmath80    let us consider the following matrices @xmath48 and @xmath81 .",
    "we define the element product of matrices @xmath48 and @xmath81 as follows :    _ element product of matrices of dimension 2 _ + let @xmath82 , we define the _ element product of matrices _ @xmath48 and @xmath81 as follows : @xmath83    _ element product of matrices of dimension 3 _ + let @xmath84 , we define the _ element product of matrices _ @xmath48 and @xmath81 as follows : @xmath85",
    "before the construction of our hash function , let us explain the main idea .      in page 175 of paper @xcite , brualdi gives the example of the following five matrices :    @xmath86    @xmath87    which belong to @xmath32 where @xmath88 .",
    "let us note @xmath89 the following matrix : @xmath90 based on the _ element product of matrix _ defined in the previous subsection , it is easy to verify that : @xmath91    @xmath92    by computation , we evaluate that : @xmath93    it is easy to verify that @xmath94 , @xmath95 , @xmath96 and @xmath97 .",
    "all these differences imply that    * the second term of @xmath98 is not equal to the second term of @xmath99 , * the third term of @xmath98 is not equal to the third term of @xmath99 , * the fifth term of @xmath98 is not equal to the fifth term of @xmath99 , * the sixth term of @xmath98 is not equal to the sixth term of @xmath99 .    more formally , from the construction of @xmath53",
    ", we can deduce easily that if @xmath100 , then :    @xmath101 ) : :    the i - th term of @xmath102 would probably be    different from the i - th term of @xmath103 , @xmath104 ) : :    the ( n+j)-th term of @xmath102 would probably be    different from the ( n+j)-th term of @xmath103 .    from the fact that @xmath105 which is related to @xmath78 ( this is an extension of @xmath53 ) is np - complete , we deduce that :    @xmath106 ) : :    given @xmath7 and a matrix @xmath89 , find a matrix    @xmath48 such that @xmath107 is    np - complete .",
    "our idea is to build a new hash function @xmath21 such that @xmath108 where    * @xmath23 is a classical hash function such as md5 , sha-0 , sha-1 , ripemd , haval , ... * @xmath109 is a function which exploits the ideas presented in @xmath101 ) , @xmath104 ) and @xmath106 ) .",
    "let us denote @xmath110 the vector such that @xmath111 and each of its elements is equal to 1 .",
    "also , let us denote @xmath112 the matrix such that @xmath113 and each of its elements is equal to 1 .",
    "in other words : @xmath114    we denote @xmath115 the set of strictly positive natural number defined as follows : @xmath116    in the next sub - section , we formalize the observation made in points @xmath101 ) and @xmath104 ) and we take into account the np - completeness of 3dct to build a new hash function .      for any integers @xmath117 and @xmath118 such that @xmath119 , let us denote @xmath120 the decomposition of the integer @xmath117 in base 2 on @xmath118 positions . in other words : @xmath121 let us also define the following function : @xmath122 @xmath123 represents the number of bits necessary to represent any integer between @xmath124 and @xmath29 in base 2 .",
    "+ we also define the following functions : @xmath125 @xmath126 represents the maximun of sum of any @xmath29 consecutive elements of the matrix @xmath48 belonging to the same row , or to the same column or to the same file .",
    "@xmath127 represents the number of bits necessary to represent in base 2 the sum of any @xmath29 consecutive elements of the matrix @xmath48 belonging to the same row , or to the same column , or to the same file .",
    "+ subsequently , in the aim to be more precise , we redefine @xmath78 as follows :    @xmath128    let us define the following problem : + * problem 5 : * + @xmath2 _ instance : _ a positive integer @xmath29 , two binary strings @xmath8 and @xmath7 + @xmath129 two matrices @xmath130 + @xmath2 _ query : _ find two matrices @xmath131 + @xmath132  such   that : @xmath133    let us characterize the complexity of @xmath134 .",
    "[ ref : prop1 ] problem 5 is np - complete .",
    "* proof idea of proposition [ ref : prop1 ] : *   + we want to show how to transform a solution of 3dct to a solution of problem 5 . without loss of generality , we work in dimension 2 . let us suppose that we want to find a matrix @xmath135 such that :    [ e : gpgp ] @xmath136    where @xmath137 and @xmath138 .",
    "+ it is easy to see that the determination of the matrix @xmath139 which verifies equations ( [ e : gpgp ] ) is also equivalent to determining the matrix @xmath140 such that :    [ e : gh ] @xmath141    where @xmath142 and @xmath143 . + * remark 1 : * @xmath144 ( respectively @xmath145 ) is a duplication of @xmath37 ( respectively @xmath72 ) . + it is easy to see that from the matrix :    @xmath146    which verifies equations ( [ e : gpgp ] ) , we can associate the two following matrices @xmath147 and @xmath148 @xmath149    @xmath150    which verify equations ( [ e : gh ] ) .",
    "this is the idea of the transformation which associates to one solution of the problem defined in equations ( [ e : gpgp ] ) two distinct solutions of the problem defined in equations ( [ e : gh ] ) .",
    "+ before the proof , let us introduce the function duplic ( which is pseudo - duplication ) of x. we note : @xmath151 where @xmath152 and @xmath153 .",
    "we define the function @xmath154 as follows : @xmath155 the function duplic is defined as follows : @xmath156 where @xmath157 is defined as follows : @xmath158 and @xmath159 for illustration , @xmath160 is defined as follows : @xmath161    * remark 2 : * in the definition of @xmath162 , the term @xmath163 means the concatenation of all the elements between @xmath164 and @xmath165 . in other words : @xmath166 where @xmath167 .",
    "* proof of proposition [ ref : prop1 ] * : it suffices to show that @xmath168 .",
    "+ let us suppose that the procedure _ generalize _ solves problem 5 and we want to show how to build a procedure _ sol3dct _ which solves 3dct . + the procedure _",
    "sol3dct _ takes as input a binary string x , an integer n and returns as output the matrix @xmath48 of size @xmath29 such that @xmath169 .",
    "the procedure _ generalize _ takes as input :    * p the dimension of the matrices * two binary strings @xmath8 and @xmath7 * two matrices @xmath170 and @xmath89    and returns as output :    * two matrices @xmath72 and @xmath59 such that : * @xmath171 and @xmath172    we show in the procedure below how to use @xmath173 as a subroutine to solve @xmath174 .    procedure = * sol3dct ( n : integer , x : string , var a : matrix ) ; * + v , w , c , d : matrix + p , i , j , k : integer + z : string + * begin * = + 1 : @xmath175 + 2 : @xmath176 + 3 : @xmath177 + 4 : @xmath178 + 5 : @xmath179 + 6 : for i = 1 = to n do + 7 : for j = 1 = to n do + 8 : for k = 1 = to n do + 9 : @xmath180 + 10 : endfor + 11 : endfor + 12 : endfor + * end * +    * remark 3 : * in the procedure * sol3dct * , the matrix @xmath48 belongs to the set @xmath181 , whereas the matrices @xmath182 belong to the set @xmath183 .",
    "+ the string @xmath184 of the procedure * sol3dct * ( see instruction 3 ) is constructed such that @xmath169 if and only if the matrices @xmath72 and @xmath59 defined in equations ( [ ee : ep1 ] ) and ( [ ee : ep2 ] ) are the solutions of problem 5 with the following entries :    * 2n the dimension of the matrices , * two binary strings @xmath184 and @xmath184 , * two matrices @xmath170 and @xmath89 such that @xmath185 , @xmath186 .",
    "the terms of the matrix @xmath72 are : @xmath187    the terms of the matrix @xmath59 are : @xmath188 @xmath189 + the main idea of the design of the collision - resistant hash function @xmath21 is that :    * the hash function @xmath21 is the composition of two functions @xmath109 and @xmath23 , * the function @xmath109 is a function for which _ problem 1 _ , _ problem 2 _ and _ problem 3 _ ca nt be solved efficiently and @xmath109 is not a compression function . * @xmath23 is a hash function such as sha-256 , ripemd , or haval , ....    let us consider two vectors @xmath190 and @xmath191 .",
    "we say that @xmath190 is not a linear combination of @xmath191 and we note @xmath190 is nlc of @xmath191 if and only if @xmath192 such that @xmath193 .",
    "two matrices @xmath194 verify the hypotheses ( [ e : gp ] ) if and only if :    [ e : gp ] @xmath195    the matrices @xmath170 and @xmath89 used as entries in the procedures @xmath109 and @xmath21 below verify the hypotheses defined by equations ( [ e : gp ] ) .",
    "we note @xmath196 the empty chain .",
    "let us define the function @xmath197 which takes as input a vector @xmath198 of size @xmath199 and returns as output an equivalent matrix @xmath48 of size @xmath58 .",
    "* procedure * @xmath197 ( vect : table[1 .. @xmath199 ] of bit ; var a : table[1 .. n , 1 .. n , 1 .. n ] of bit ) + @xmath201 var i , j , k , t : integer + @xmath201 begin + @xmath202@xmath203 + @xmath202for i = 1 to n do + @xmath204for j = 1 to n do + @xmath205for k = 1 to n do + @xmath206@xmath207 + @xmath206@xmath208 + @xmath205endfor + @xmath204endfor + @xmath202endfor + @xmath209end + the function @xmath109 is defined as follows : + * function * @xmath109 : + @xmath201 _ entry . _",
    "@xmath210 the initial message + @xmath211 @xmath170 : table[1 .. n , 1 .. n,1 .. n ] of integer + @xmath211 @xmath89 : table[1 .. n , 1 .. n,1 .. n ] of integer + @xmath212 @xmath29 : an integer + @xmath201 _ output . _ @xmath213 : an intermediate message + @xmath201 var i , p : integer + @xmath201 begin + @xmath214 1 .",
    "pad @xmath210 with one bit equal to 1 , followed by a variable number of + @xmath215 zero bits and a block of bits encoding the length of @xmath210 in bits , + @xmath215 so that the total length of the padded message is the smallest + @xmath216 possible multiple of @xmath199 .",
    "let @xmath217 denote the padded message + @xmath214 2 .",
    "cut @xmath217 into a sequence of @xmath199-bits vectors + @xmath218 @xmath219 + @xmath214 3 .",
    "@xmath220  @xmath196 + @xmath2214 . for i",
    "= 1 to p do + @xmath222 4.1 @xmath223 + @xmath224 4.2 @xmath213 @xmath225 @xmath213 @xmath57 @xmath226 @xmath57 @xmath227 + @xmath228 endfor + @xmath214 5 . return @xmath213 + @xmath229end + our hash function @xmath21 is defined as the composition of the function @xmath109 and @xmath23 , where @xmath23 is a hash function such as sha-256 , ripemd , haval ... the matrices @xmath170 and @xmath89 used as entry in the hash function @xmath21 must verify the hypotheses defined in equations ( [ e : gp ] ) . to obtain the hash of the message @xmath210 by @xmath21 , we proceed as follows :    * we obtain the intermediate message @xmath213 by application of the function @xmath109 to the message @xmath210 , * by application of the hash function @xmath23 to @xmath213 , we build the hash of the initial message .",
    "formally , the hash function is defined as follows : +   + * procedure * @xmath21 : + @xmath201 _ entry . _ @xmath210 the initial message + @xmath211 @xmath170 : table[1 .. n , 1 .. n,1 .. n ] of integer + @xmath211 @xmath89 : table[1 .. n , 1 .. n,1 .. n ] of integer + @xmath230 @xmath29 : an integer + @xmath201 _ output .",
    "_ @xmath231 : the hash of the message @xmath210 + @xmath201 begin + @xmath232 @xmath233 + @xmath232 @xmath234 + @xmath235end + * comment :* + we can represent roughly the function @xmath109 as follows :    = 8.6 cm    in the figure [ figgraph9 ] :    * the aim of the branches ( 1 ) and ( 2 ) is to make that the problem 2 and problem 3 are difficult to solve efficiently for the function @xmath21 * the aim of the branch ( 6 ) is to make sure that problem 1 is difficult to solve efficiently for the function @xmath21    during some attacks , an adversary is needed to solve the following problem :    * problem 6 : * + @xmath2 _ instance : _ matrices a , v , w + @xmath236 binary strings : @xmath237 and @xmath238 + @xmath2 _ query : _ find a matrix @xmath81 such that @xmath239 and : @xmath240 based on problem 5 , we deduce that @xmath241 is np - complete . + second preimage attack and collision of the function @xmath21",
    "are difficult because :    * problem 5 and problem 6 are np - complete , * from the fact that @xmath170 and @xmath89 verify the hypotheses ( [ e : gp ] ) , we deduce that if we take two matrices @xmath48 and @xmath81 such that @xmath242 , then we would probably have @xmath243    first preimage attack of the function @xmath21 is difficult because the 3dct is np - complete .",
    "truncated differential attack of @xmath109 is possible , but the differential attack of @xmath21 is difficult because 3dct is np - complete and also problem 5 is np - complete .",
    "let s consider the two messages x1 and x2 : + @xmath244    @xmath245    we have md5(x1)=md5(x2)= efe502f744768114b58c8523184841f3 + after applying our hash function on these messages using @xmath246 , @xmath247[j][k ] = i + 8j + 64k$ ] , @xmath248[j][k ] = 700-(j+8*k+64*i)$ ] for @xmath249 we obtain : + @xmath21(x1)= 5fe0e56f9a4ab66a47d73ce660a2c4eb and + @xmath21(x2 ) = 620e2f3cfe0afc403c0a8343173526fc .",
    "+ it follows that @xmath250 whereas @xmath251 .",
    "from a classical hash function @xmath23 , we have built a new hash function @xmath21 from which first preimage attack , second preimage attack and collision attack are difficult to solve . our new hash function is a composition of functions .",
    "the construction used the np - completeness of three - dimensional contingency tables and the relaxation of the constraint that a hash function should also be a compression function .",
    "the complexity of our new hash function increases with regard to the complexity of classical hash functions .",
    "2 r. a. brualdi , _ matrices of zeros and ones with fixed row and column sum vectors _ , linear algebra and its applications , * 33 * , 1980 , pp .",
    "159 - 231 .",
    "l. cox , _ suppression methodology and statistical disclosure control _ , j. amer .",
    "assoc . , 75(1980 ) , pp .",
    "377 - 385 .",
    "i. p. fellegi , _ on the question of statistical confidentiallity _",
    ", j. amer .",
    "assoc . , 67 , ( 1972 ) , pp .",
    "d. r. fulkerson , _ an upper bound for the permanent of a fully indecomposable matrix _ , pacific j. math . ,",
    "* 10 * , 1960 , pp .",
    "831 - 836 .",
    "d. gale , _ a theorem on flows in networks _",
    ", pacific j. math .",
    ", * 7 * , 1957 , pp",
    ". 1073 - 1082 .",
    "r. m. haber , _ minimal term rank of a class of ( 0,1)-matrices _ , canad .",
    ", * 15 * , 1963 , pp . 188 - 192 .",
    "hongbo yu , xiaoyun wang , _ multi - collision attack on the compression functions of md4 and 3-pass haval _ , lecture notes in computer science , * 4817 * , springer 2007 , pp .",
    "206 - 226 .",
    "hongbo yu , gaoli wang , guoyan zhang , xiaoyun wang , _ the second - preimage attack on md4 _ , lecture notes in computer science , * 3810 * , springer 2005 , pp . 1 - 12",
    "kao , d. gusfield hongbo yu , _ efficient detection and protection of information in cross tabulated tables : linear invariant set _ , siam j. disc .",
    ", 6 ( 1993 ) , pp . 460 - 473 .",
    "xiaoyun wang , hongbo yu , yiqun lisa yin , _ efficient collision search attack on sha-0 _ , lecture notes in computer science , * 3621 * , springer 2005 , pp . 1 - 16 .",
    "xiaoyun wang , yiqun lisa yin , hongbo yu , _ finding collisions in the full sha-1 _ , lecture notes in computer science , * 3621 * , springer 2005 , pp .",
    "xiaoyun wang , xuejia lai , dengguo feng , hui cheng , xiuyuan yu , _ cryptanalysis of the hash functions md4 and ripemd _ , lecture notes in computer science , * 3494 * , springer 2005 , pp . 1 - 18 .",
    "xiaoyun wang , hongbo yu , _ how to break md5 and other hash functions _ , lecture notes in computer science , * 3494 * , springer 2005 , pp .",
    "bert den boer , antoon bosselaers , _ collisions for the compression functions of md5 _ , lecture notes in computer science , * 765 * , springer 1994 , pp .",
    "293 - 304 .",
    "r. w. irving , m. r. jerrum , _ three - dimensional statistical data security problems _ , siam j. comput .",
    "* 23 * , no 1 , pp .",
    "170 - 184 , 1994 .",
    "h. j. ryser , _ combinatorial properties of matrices of zeros and ones _ , canad .",
    "* 9 * , pp .",
    "371 - 377 , 1957 .",
    "g. sande , _ automated cell suppression to preserve confidentiality of business statistics _",
    ", statist .",
    "j. united nations ece 2 ( 1984 ) pp ."
  ],
  "abstract_text": [
    "<S> a cryptographic hash function is a deterministic procedure that compresses an arbitrary block of numerical data and returns a fixed - size bit string . </S>",
    "<S> there exists many hash functions : md5 , haval , sha , ... it was reported that these hash functions are no longer secure . </S>",
    "<S> our work is focused on the construction of a new hash function based on composition of functions . </S>",
    "<S> the construction used the np - completeness of three - dimensional contingency tables and the relaxation of the constraint that a hash function should also be a compression function . +    * keywords :* np - complete , one - way function , matrix of zeros and ones , three - dimensional contingency table , collision - resistant hash function . </S>"
  ]
}