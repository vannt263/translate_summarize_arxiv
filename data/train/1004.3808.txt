{
  "article_text": [
    "garbage collectors automatically reclaim dynamically allocated objects that will never be accessed again by the program .",
    "garbage collection is widely acknowledged for supporting fast development of reliable and secure software .",
    "it has been incorporated into modern languages , such as java and c#. many recent projects have attempted to verify the safety or correctness of garbage collectors . the goal of this verification is to reduce the trusted computing base of a system and increase the system s reliability .",
    "this is particularly important for secure systems based on proof - carrying code ( pcc ) @xcite or typed assembly language ( tal ) @xcite ; typical large - scale pcc / tal systems can verify the safety of the mutator ( the program ) , but not of the run - time system that manages memory and other resource on the mutator s behalf .",
    "this prevents untrusted programs from customizing the run - time system .",
    "furthermore , bugs in the unverified run - time systems could result in security vulnerabilities that undermine the guarantees promised by pcc and tal .",
    "proving that garbage collectors are safe and correct has been a challenge . in this work",
    ", we provide the first fully mechanized correctness proofs of garbage collectors and allocators realistic enough to run large , off - the - shelf benchmarks . to make this verification tractable",
    ", we exploit recent advances in automated theorem proving technology , using the boogie @xcite and z3 @xcite tools to provide _ automated _ verification of the correctness properties .",
    "our key contribution is the expression of garbage collector specifications and invariants in a style that allows efficient , automated verification .",
    "we verify two collectors , both practical enough for use with real - world c # benchmarks : a cheney copying collector @xcite , with a bump allocator ; and a mark - sweep collector @xcite , with a local - cache allocator that allows fast bump - pointer allocation .",
    "both are simple enough to verify , yet efficient enough to support realistic benchmarks competitively .",
    "the collectors and their associated allocators consist of x86 assembly language instructions and macro instructions , annotated with preconditions , postconditions , invariants , and assertions .",
    "these annotations require significant human effort to write , but once they are written , the boogie verification condition generator and the z3 theorem prover verify the annotated collectors automatically , with no further human intervention .",
    "the collectors and allocators are entirely self - contained , relying on no unverified library code , and the verification relies on only a minimal set of trusted axioms and definitions describing 32-bit arithmetic , x86 instructions , memory words , and the interface to the mutator .",
    "we show how to define higher - level abstractions , particularly abstractions drawn from region - based type systems , in terms of these trusted axioms and definitions ; these higher - level abstractions provide forms of local reasoning that make automated verification tractable .",
    "the verification ensures that if an allocation or garbage collection operation completes , then the physical heap managed by the allocator and collector faithfully represents the abstract graph of objects defined by the mutator .",
    "the verification also ensures that the garbage collector deallocates all objects unreached during the collection .",
    "the verification does not prove termination ; verified collectors or allocators could fail to terminate because of an infinite loop , or fail to terminate properly because of a 32-bit integer overflow exception , or an explicit halt operation .",
    "( the allocators and collectors halt if they run out of memory , or if the mutator relies on a feature not supported by our collectors , such as multithreading . )",
    "the collectors and allocators include support for objects , arrays , strings , header words , interior pointers , static data scanning , stack scanning , object descriptors , stack frame descriptors , return - address lookup tables , and bit - level data manipulation , making them realistic enough to support off - the - shelf single - threaded c # benchmarks compiled with the bartok compiler , using the native bartok memory layouts and descriptor formats . to assess the efficacy of the proposed collectors , we ran the verified collectors with the bartok runtime and compared their performance with the standard bartok mark - sweep and generational copying collectors .",
    "the verified collectors demonstrated competitive performance .",
    "the contributions in this paper include :    1 .",
    "we provide the first mechanically verified garbage collectors that support a real - world object model , including vtables , arrays , object descriptors , stacks , etc .",
    "we provide the first mechanically verified garbage collectors that can link to code generated by a real - world , optimizing compiler ( bartok ) .",
    "we demonstrate how to apply _ automated _ verification to garbage collectors , including both copying and mark - sweep garbage collectors .",
    "this automation allows scaling the verification to realistic collectors without employing a huge human effort .",
    "we propose a simple , efficient , easy - to - verify mark - sweep collector and allocator based on local caches .",
    "we provide the first performance measurements of off - the - shelf c # benchmarks running on top of verified garbage collectors .    [",
    "[ outline . ] ] * outline . *",
    "+ + + + + + + + + +    section [ sec - label ] discusses previous work on garbage collector verification .",
    "section [ sec - boogie ] describes boogie and z3 .",
    "section [ sec - miniature - ms ] presents a complete example mark - sweep collector and allocator in the boogiepl programming language @xcite , describing the specification and invariants in detail .",
    "section [ sec - regions ] generalizes section [ sec - miniature - ms ] s ideas to cover copying collectors , borrowing ideas from region - based type systems , and section [ sec - miniature - copy ] presents a complete example copying collector in detail .",
    "section [ sec - collectors ] presents two simple , yet practical , collectors ( and their allocators ) : a cheney - queue copying collector and an iterative mark - sweep collector .",
    "section [ sec - measurements ] shows that the practical collectors perform reasonably well compared to bartok s native collectors on a range of off - the - shelf c # benchmarks .",
    "section [ sec - conslusion ] concludes .",
    "[ [ code - availability . ] ] * code availability . *",
    "+ + + + + + + + + + + + + + + + + + + +    the garbage collectors were coded in an x86-like subset of the boogiepl language ; a small tool automatically extracted the x86 instructions , which were assembled and linked with the benchmarks ( see section [ subsec - assembly ] ) .",
    "the complete boogiepl code for the two practical collectors is available as part of the public microsoft research singularity rdk2 source ( in `` source code '' , in the base / imported / bartok / runtime / verified / gcs directory , which can be browsed without downloading all of singularity ) at :    ....",
    "http://www.codeplex.com/singularity ....    the boogie and z3 tools ( april 2008 release ) , used to verify the two collectors , are available from :    ....    http://research.microsoft.com/specsharp/ ....",
    "hand - written proofs of garbage collector correctness , at least for abstract models of garbage collectors , go back decades ( e.g. , @xcite ) .",
    "the work of birkedal _ et al _ @xcite is noteworthy for formally proving a cheney copying collector correct , rather than a mark - sweep collector , and emphasizing _ local reasoning _ based on separation logic .",
    "nevertheless , the local reasoning is used mainly to separate pieces of the invariant at a coarse granularity ( e.g. separating invariants about forwarded objects from unforwarded objects ) ; we offer a different perspective on local reasoning in section [ sec - regions ] .    other work @xcite has mechanically proven garbage collector correctness , but only for mark - sweep collectors , only using abstract models of memory ( for instance , representing the heap as just a mathematical graph and the root set as just a mathematical set ) , only using abstract models of programs rather than programs executable on real hardware , and ( with the exception of russinoff  @xcite ) , all using interactive theorem provers .",
    "for example , russinoff  @xcite and havelund  @xcite both mechanically verify the same small ( albeit concurrent ) mark - sweep algorithm , which consists of just 11 statements .",
    "in addition to the standard annotations required to declare the algorithm s invariants , both papers also required , as hints to the theorem prover , many explicit user declarations of lemmas : 55 lemmas in havelund  @xcite , and over 100 lemmas in russinoff  @xcite .",
    "( most of these lemmas are necessary because the theorem provers lack the ability to automatically instantiate variables in definitions and quantified formulas at useful values . ) by contrast , the small collector presented in section  [ sec - miniature - ms ] requires no user - declared lemmas ; a small number of triggering annotations embedded in the source code and invariants provide the theorem prover with enough hints for the proof to succeed .",
    "more recently , mccreight _ et al _ @xcite used an interactive theorem prover to verify the correctness of both mark - sweep and copying collectors written in a risc - like assembly language , with a more realistic memory model .",
    "furthermore , their results are foundational , requiring trust only in a small coq proof checker ( which is much smaller than boogie / z3 ) , a specification of correctness , and a risc machine language model .",
    "this required an enormous effort though , relying on over 10000 lines of coq scripts per collector , and the treatment of the memory still falls short of what realistic compilers expect : the collectors assume that every object has exactly two fields , and there is no stack , no static data area , no object and stack frame descriptors , and so on .",
    "we adopt mccreight _ et al _ s definition of correctness as a starting point for our work .",
    "several papers @xcite use typed regions to implement type - safe copying garbage collectors ; these garbage collectors copy live data from an old region to a new region , and then ( safely ) delete the old region .",
    "type safety is a weaker property than correctness , though , and these techniques do nt obviously extend to mark - sweep collection .",
    "we borrow ideas from typed regions to help us verify our copying collector .",
    "banerjee _ et al _",
    "@xcite also use regions to aid program verification , providing a flexible set of region constructors ( region union , region intersection , etc . ) , and region predicates ( region disjointness , region subset , etc . ) .",
    "although their programming language may be too high level to express practical garbage collectors , their region operations could be useful for gc verification in a lower - level language .",
    "note that in contrast to typed regions and banerjee _ et al _ s approach , we do not build regions into our logic or language directly ; instead , our garbage collectors construct regions from more primitive first - order logic concepts .",
    "vechev _ et al _ @xcite describe how to mechanically fit prefabricated , high - level garbage collection building blocks together in a provably correct way , but they do not mechanically verify the building blocks themselves .",
    "for instance , they assume that `` the algorithm skeleton is fixed , and the operations performed by the skeleton are known to be correct .",
    "for example , we assume that basic stop - the - world tracing is implemented correctly ( i.e. , the trace procedure marks all the objects that are reachable from the pending set when it executes without interruptions ) . ''",
    "we expect our work to be complementary , since our techniques could be used to verify building blocks for garbage collection .",
    "boogiepl  @xcite is a simple imperative programming language designed to support automated program verification .",
    "it includes pure ( side - effect free ) expressions , written in a standard c / c#/java syntax , imperative statements ( which may update local variables and global variables ) , pure functions , and imperative procedures .",
    "procedures support preconditions and postconditions , written with the keywords ` requires ` and ` ensures ` , that specify what must be true upon entry to the procedure and what the procedure guarantees is true upon exit from the procedure . within a procedure , loop invariants for ` while ` loops are written with the ` invariant ` keyword .",
    "the following example shows a pure function ` pos ` , which returns true if its argument is positive , and a procedure ` increasex ` that adds a positive number ` y ` to a global variable ` x ` :    ....    function{:expand true } pos(i : int)returns(bool){i>0 }    var x : int ;    procedure increasex(y : int )      requires pos(y ) ;      modifies x ;      ensures   x > old(x ) ;    {      x : = x + y ;    } ....    in this example , the expression ` old(x ) ` refers to the value of ` x ` at the beginning of the procedure s execution , so that the postcondition `` ` ensures   x > old(x ) ; ` '' says that ` x ` will have a larger value upon exit from the procedure than upon entry to the procedure .",
    "a procedure must disclose all the global variables it modifies ( just ` x ` in this example ) ; this allows callers of the procedure to know which variables remain unmodified by the procedure . the ` expand true ` annotation turns a function definition into a macro that is expanded to its definition whenever it is used , so that `` ` requires pos(y ) ; ` '' is just an abbreviation for `` ` requires y > 0 ; ` '' .",
    "( recursive or mutually recursive macro definitions are disallowed . )",
    "our programs occasionally use the statement `` ` assert p ; ` '' , which asks the verifier to prove ` p ` , which is then used as a lemma for subsequent proving .",
    "( we do not use the statement `` ` assume p ; ` '' , which introduces a new lemma ` p ` _ without _ proof , since this would make our verification unsound . )",
    "the boogie tool generates verification conditions from the boogiepl code .",
    "these verification conditions are logical formulas that , if valid , guarantee that each procedure call satisfies the procedure s precondition , each procedure guarantees its postcondition , and each loop invariant holds on entry to the loop and is maintained by each loop iteration .",
    "for example , the verification condition for the ` increasex ` example above might be :    ....    pos(y ) = = > x + y > x ....    ( here , ` = = > ` is boogie s syntax for logical implication . )",
    "boogie passes these verification conditions to an automated theorem prover , which attempts to prove the validity of the verification conditions .",
    "we use the z3 theorem prover  @xcite , which is efficient , scales to large formulas , and reasons about many useful first - order logic theories , including integers , bit vectors , arrays , and uninterpreted functions .    both boogie and z3 are part of the trusted computing base for the verified garbage collectors .",
    "in other words , a bug in boogie or z3 could incorrectly lead to a buggy garbage collector being declared `` verified '' .",
    "currently , our trust in boogie and z3 rests on the large amount of testing that they have endured ( including testing at public competitions  @xcite ) . in the future",
    ", we may also be able to leverage z3 s recent proof generation feature  @xcite , which generates proofs checkable with a smaller trusted computing base , although the time and memory overheads of proof generation may be prohibitive .",
    "boogiepl s data types are more purely mathematical than the data types in conventional programming languages .",
    "the type ` int ` represents mathematical integers , ranging from negative infinity to positive infinity , while ` bv32 ` represents 32-bit values .",
    "the theorem prover support for ` int ` is more mature and efficient than for ` bv32 ` , so we used ` int ` wherever possible ( section [ sec - collectors ] describes how we reconciled this approach with the x86 s native 32-bit words ) .",
    "boogiepl also supports array types ` [ int]t ` for any element type ` t ` , defining arrays as simple mappings from mathematical integers to elements .",
    "the boogiepl `` select '' expression ` a[i ] ` retrieves element ` i ` from array ` a ` , where ` i ` can be any integer .",
    "the boogiepl `` update '' expression ` a[i : = v ] ` generates a new array , equal to ` a ` except at element ` i ` , where the new array contains the value ` v ` , so that ` ( a[i : = v])[i ] = = v ` is true for any ` a ` , ` i ` , and ` v ` . for convenience , the statement `` ` a[i ] : = v ; ` '' is an abbreviation for `` ` a : = ( a[i : = v ] ) ; ` '' .",
    "arrays can also be multidimensional : an array ` a ` of type ` [ int , int]t ` supports a select expression ` a[i1,i2 ] ` and an update expression ` a[i1,i2 : = v ] ` . note that boogiepl arrays lack many properties of say , java arrays .",
    "for example , boogiepl arrays are not references , so there s no issue of aliasing : the statement `` ` a : = b ; ` '' assigns a copy of array ` b ` to variable ` a ` .    due to formatting constraints",
    ", the boogiepl code shown in this paper omits most type annotations .",
    "we abbreviate ` a<=b & & b < c ` as ` a<=b < c ` , and ` function{:expand true } ` as ` fun ` .",
    "the notation `` @xmath0 '' is an abbreviation for the universal quantifier `` @xmath1 '' with a particular _ trigger _ `` ` t ` '' , used as a hint to z3 , as described further in section [ subsec - trigger ] . for now , the reader may ignore the `` ` t ` '' .",
    "finally , the code uses a convention that variables prefixed with a dollar sign ( e.g. `` ` $ x ` '' ) are `` ghost '' variables , erased before run - time , as described further in section [ sec - conabs ] .",
    "this section presents a miniature allocator and mark - sweep collector written in the boogiepl programming language , introducing some of the invariants used by the more realistic collectors in subsequent sections .",
    "the allocator and collector are implemented as a single boogiepl file , shown in its entirety in figures [ fig : exampledefs]-[fig : examplealloc ] . as in previous verified collectors , a large fraction of the code",
    "consists of preconditions , postconditions , loop invariants , and auxillary definitions .",
    "these require human effort to write , but once written , verification is fast and automated .",
    "when run on this example garbage collector , boogie verifies all 7 procedures in the collector in less than 2 seconds ; since boogie and z3 process boogiepl files entirely automatically , no human assistance or proof scripts are required :    ....    \\spec#\\bin\\boogie.exe mini-ms.bpl      boogie program verifier version 0.90 ,    copyright ( c ) 2003 - 2008 , microsoft .",
    "boogie program verifier finished    with 7 verified , 0 errors ....    the miniature collector assumes that every object has exactly two fields , numbered ` 0 ` and ` 1 ` , and each field holds a non - null pointer to some object .",
    "the collector manages memory addresses in the range ` memlo` ... `memhi - 1 ` , where ` memlo ` and ` memhi ` are constants such that ` 0 < memlo < = memhi ` , but whose values are otherwise unspecified ( see figure [ fig : exampledefs ] ) .",
    "memory is object addressed , rather than byte addressed or word addressed , so that each memory location in the range ` memlo` ... `memhi - 1 ` contains either an entire object , or free space big enough to allocate an object in .",
    "the variable ` mem ` , of type ` [ int , int]int ` , represents all of memory ; for each address ` i ` in the range ` memlo` ... `memhi - 1 ` and field ` field ` in the range 0 ... 1 , the value ` mem[i , field ] ` holds the contents of the field ` field ` in the object at address ` i ` . for conciseness ,",
    "figure  [ fig : exampledefs ] defines ` memaddr(i ) ` to mean ` memlo < = i < memhi ` .    the allocator and collector use a variable ` color ` to represent the state of memory at each address .",
    "if ` color[i ] ` is ` 0 ` , the memory at address ` i ` is free",
    ". otherwise , the memory is occupied by an object and is either colored white ( ` color[i ] = = 1 ` ) , gray ( ` color[i ] = = 2 ` ) , or black ( ` color[i ] = = 3 ` ) .          to verify a garbage collector",
    ", we must specify what it means for a collector to be correct . for the mark - sweep collector ,",
    "the most obvious criterion is that it frees all objects unreachable from the root and leaves all reachable objects unmodified .",
    "however , this definition of correctness is specific to one particular class of collectors ; it does nt account for collectors that move objects , and does nt account for mutator - collector interaction , such as write barriers and read barriers .",
    "we d like one definition of correctness that encompasses many classes of collectors , so we follow a more general approach advocated by mccreight _ et al _ @xcite . in this approach ,",
    "the mutator defines an abstract state , consisting of an abstract graph of abstract nodes .",
    "a memory manager is responsible for representing the abstract state in memory .",
    "the memory manager exposes procedures to initialize memory , allocate memory , read memory , and write memory ( see ` initialize ` , ` alloc ` , ` readfield ` , and ` writefield ` in figures [ fig : exampleinit ] , [ fig : examplealloc ] ) .",
    "these four procedures define the boundary between the memory manager and the mutator .",
    "the preconditions and postconditions for these four procedures express the specification of memory manager s correctness , where correctness means that each of these procedures faithfully represents the abstract state .    to make this notion of correctness precise , the variable ` $ absmem ` of type `",
    "[ int , int]int ` defines the abstract state as a mapping from abstract nodes and fields to abstract values . in the miniature memory model presented so far ,",
    "each field contains a pointer to a node , so the abstract values stored in the abstract graph are always abstract nodes .",
    "( section [ sec - collectors ] extends the set of abstract values with other values , such as primitive integers and null . ) for example , figure [ fig : conabs ] shows an abstract graph consisting of 4 nodes , ` a1 ` , ` a2 ` , ` a3 ` , and ` a4 ` , each having two fields numbered ` 0 ` ( on top ) and ` 1 ` ( on the bottom ) . in this example , ` a1 ` s bottom field points to ` a3 ` , so ` $ absmem[a1,1 ] = = a3 ` .",
    "integers represent abstract nodes , but these integers can be any mathematical integers , and need not be related to the addresses used by the computer s actual memory .",
    "in fact , the variable ` $ absmem ` is not represented at run - time at all ; it is used solely for verification .",
    "we call such variables `` ghost variables '' ( also known as `` auxillary variables '' ) , and we use a naming convention that prefixes each ghost variable with a dollar sign .    the function ` mutatorinv ( ... ) ` defines the invariant that holds on the memory manager s data while the mutator is running .",
    "initialize establishes ` mutatorinv ` , while ` alloc ` , ` readfield ` , and ` writefield ` require ` mutatorinv ` as a precondition and guarantee ` mutatorinv ` as a postcondition .",
    "each collector defines ` mutatorinv(var1 ...",
    "varn ) ` as it wishes .",
    "the mutator is not allowed to modify any of the variables ` var1` ... `varn ` directly , but instead must use ` readfield ` , ` writefield ` , and ` alloc ` to affect these variables .",
    "since ` mutatorinv ` varies across collectors , a mutator that wants to work with all collectors should treat ` mutatorinv ` as abstract . in this framework , the specifications for ` initialize ` , ` alloc ` , ` readfield ` , and ` writefield ` are exactly the same across all collectors , except for the differing definitions of ` mutatorinv ` .",
    "the function ` $ toabs:[int]int ` maps each concrete memory address in the range ` memlo` ... `memhi - 1 ` to an abstract node , or to ` no_abs ` .",
    "the memory management procedures ensure that ` $ toabs ` is well formed ( ` wellformed($toabs ) ` ) , which says that any two distinct concrete addresses ` i1 ` and ` i2 ` map to distinct abstract nodes , unless they map to ` no_abs ` .",
    "( note : we use a concrete - to - abstract mapping , rather than an abstract - to - concrete mapping , because our invariants quantify over concrete addresses , not abstract addresses , and these quantified concrete addresses make convenient arguments to ` $ toabs ` . ) in figure [ fig : conabs ] , ` $ toabs ` maps addresses ` c1 ` , ` c2 ` , and ` c3 ` to abstract nodes ` a1 ` , ` a2 ` , and ` a3 ` , respectively , while all other concrete addresses map to ` no_abs ` .",
    "the function ` pointer($toabs , ptr,$abs ) ` says that ` $ toabs ` maps the concrete address ` ptr ` to the abstract node ` $ abs ` .",
    "suppose the mutator calls ` readfield(c1,0 ) ` , which will return the contents of field ` 0 ` of the object at address ` c1 ` .",
    "the precondition ` pointer($toabs , ptr,$toabs[ptr ] ) ` requires ` c1 ` to be a valid pointer , mapped to some abstract node ( ` a1 ` in this example ) . in the miniature memory model presented so far ,",
    "all fields hold pointers , so the return value will also be a pointer ; the postcondition for ` readfield ` ensures that the returned value is the pointer corresponding to the abstract node ` $ absmem[$toabs[ptr],field ] ` = ` $ absmem[a1,0 ] ` = ` a2 ` . since only one pointer ,",
    "` c2 ` , maps to ` a2 ` , the postcondition forces ` readfield(c1,0 ) ` to return exactly the address ` c2 ` .",
    "( the well - formedness condition , ` wellformed($toabs ) ` ensures that no node other than ` c2 ` maps to ` a2 ` . )",
    "once the mutator obtains the pointer ` c2 ` from ` readfield(c1,0 ) ` , it may call , say , ` readfield(c2,1 ) ` to obtain the pointer ` c3 ` . in this way",
    ", the specification of ` readfield ` allows the mutator to traverse the reachable portion of memory , even though the specification never mentions reachability directly . the specification does not obligate the memory manager to retain unreachable objects .",
    "since ` a1 ` , ` a2 ` , and ` a3 ` do not point to ` a4 ` , the memory manager need not devote any physical memory for representing ` a4 ` . in figure [ fig : conabs ] , there is no concrete address that maps to ` a4 ` .",
    "note that figure  [ fig : exampleinit ] s implementation of ` readfield ` always returns a value ` val ` that equals ` mem[ptr , field ] ` .",
    "therefore , we could write an alternate version of ` readfield ` that did nt bother to return a value ` val ` , and instead wrote `` ` mem[ptr , field ] ` '' in its postconditions in place of ` val ` ( e.g. ` ensures pointer($toabs , mem[ptr , field ] , ... ) ` ) . in this case",
    ", the mutator could perform the load from ` mem[ptr , field ] ` itself , relying on ` readfield ` s postcondition to ensure that ` mem[ptr , field ] ` corresponds to the proper abstract node .",
    "similarly , we could write an alternate version of ` writefield ` that omitted the statement ` mem[ptr , field ] : = val ` , and instead wrote ` mem[ptr , field : =",
    "val ] ` in place of ` mem ` in its postconditions . in this case",
    "the mutator could store ` val ` to ` mem[ptr , field ] ` itself , relying on ` writefield ` s postconditions to ensure that ` mutatorinv ` holds after the store .",
    "in fact , our practical garbage collectors use these alternate versions of ` readfield ` and ` writefield ` , so that the practical mutators can inline the loads and stores ( this avoids the run - time overhead of making calls to ` readfield ` and ` writefield ` to perform the loads and stores . )",
    "the mutator allocates new abstract nodes by calling ` alloc ` ( figure  [ fig : examplealloc ] ) , passing in a fresh abstract node ` $ abs ` whose fields initially point to itself .",
    "( a `` fresh '' abstract node is an abstract node that does not yet appear in the range of ` $ toabs ` . ) unlike ` readfield ` and ` writefield ` , ` alloc ` modifies ` $ toabs ` , which potentially invalidates any pointers that the mutator possesses .",
    "( the mutator ca nt use an invalid pointer that refers to an old version of ` $ toabs ` , because ` pointer($toabs , ... ) ` for an old ` $ toabs ` wo nt satisfy the preconditions for ` readfield ` and ` writefield ` , which are in terms of the current ` $ toabs ` . ) therefore , the mutator may pass in a root pointer , and the ` alloc ` procedure returns a new root pointer that points to the same abstract node as the old pointer .",
    "we could also allow ` readfield ` and ` writefield ` to modify ` $ toabs ` , in which case these procedures would also require a root ( or roots ) to be passed in .",
    "in practice , though , this would be an onerous burden on the mutator .",
    "the specification described so far hides the garbage collection process behind the ` initialize ` , ` readfield ` , ` writefield ` , and ` alloc ` interfaces .",
    "we also verify one internal property of the garbage collector , invisible to the mutator : after a collection , only abstract nodes that the collector reached have physical memory dedicated to them ; unreached abstract nodes are not represented in memory .",
    "it s easy to define an axiom for reachability for any particular abstract graph : for any node ` a ` , if ` a ` is reachable , then ` a ` s children are also reachable .",
    "it s difficult , though , to track reachability as the edges in a graph evolve .",
    "for the two collectors presented here , the ` $ absmem ` graph remains unmodified throughout collection , but in general , this is not true : incremental collectors interleave short spans of garbage collection with short spans of mutator activity , and the mutator activity modifies ` $ absmem ` .",
    "therefore , we adopt a looser criterion : rather than checking that all remaining allocated nodes at the end of a collection are _ reachable _ from the root , we merely check that all remaining allocated nodes were _ reached _ from the root at some time since the start of the collection . verifying",
    "this property was only a small extension to the rest of the verification .",
    "( for simplicity , figures [ fig : exampledefs]-[fig : examplealloc ] omit this property , but the practical garbage collectors in the public source release include verification of this property . )      ``    ` function{:expand false } t(i ) { true } `    ` const no_abs : int , memlo : int , memhi : int ; `    ` axiom 0 < memlo ` ` < = ` ` memhi ; `    ` fun memaddr(i ) { memlo ` ` < = ` ` i ` ` < ` ` memhi } `    ``    ` fun unalloc(i ) { i ` ` = = ` ` 0 } `    ` fun white(i ) { i ` ` = = ` ` 1 } `    ` fun gray(i ) { i ` ` = = ` ` 2 } `    ` fun black(i ) { i ` ` = = ` ` 3 } `    ``    ` var mem:[int , int]int , color:[int]int ; `    ` var $ toabs:[int]int , $ absmem:[int , int]int ; `    ``    ` fun wellformed($toabs ) { `    `   ( ` @xmath2`i1`@xmath3``@xmath2`i2`@xmath4    `         memaddr(i1 ) & & memaddr(i2 ) `    `      & & $ toabs[i1 ] ` ` ! = ` ` no_abs `    `      & & $ toabs[i2 ] ` ` ! = ` ` no_abs `    `      & & i1 ` ` ! = ` ` i2 `    `   ` ` = = > ` ` $ toabs[i1 ] ` ` ! = ` ` $ toabs[i2 ] ) `    ` } `    ` fun pointer($toabs ` , ` ptr ` , ` $ abs ) { `    `     memaddr(ptr ) & & $ abs ` ` ! = ` ` no_abs & & $ toabs[ptr ] ` ` = = ` ` $ abs `    ` } `    ` fun objinv(i ` , ` $ toabs ` , ` $ absmem ` , ` mem ) { `    `   $ toabs[i ] ` ` ! = ` ` no_abs = = > `    `       pointer($toabs ` , ` mem[i,0 ] ` , ` $ absmem[$toabs[i],0 ] ) `    `    & & pointer($toabs ` , ` mem[i,1 ] ` , ` $ absmem[$toabs[i],1 ] ) `    ` } `    ` fun gcinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) { `    `     wellformed($toabs ) `    ` & & ( ` @xmath2`i`@xmath3 ` memaddr(i ) = = > `    `             objinv(i ` , ` $ toabs ` , ` $ absmem ` , ` mem ) `    `          & & 0 ` ` < = ` ` color[i ] ` ` < ` ` 4 `    `          & & ( black(color[i ] ) ` ` = = > ` ` ! white(color[mem[i,0 ] ] ) `    `                              & & ! white(color[mem[i,1 ] ] ) ) `    `          & & ( $ toabs[i ] ` ` = = ` ` no_abs ` ` < = = > ` ` unalloc(color[i ] ) ) ) `    ` } `    ` fun mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) { `    `     wellformed($toabs ) `    ` & & ( ` @xmath2`i`@xmath3 ` memaddr(i ) = = > `    `             objinv(i ` , ` $ toabs ` , ` $ absmem ` , ` mem ) `    `          & & 0 ` ` < = ` ` color[i ] ` ` < ` ` 2 `    `          & & ( $ toabs[i ] ` ` = = ` ` no_abs ` ` < = = > ` ` unalloc(color[i ] ) ) ) `    ` } `    ``    ` procedure initialize ( ) `    `   modifies $ toabs ` , ` color ; `    `   ensures   mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   wellformed($toabs ) ; `    ` { `    `   var ptr ; `    `   ptr : = memlo ; `    `   while ( ptr ` ` < ` ` memhi ) `    `     invariant t(ptr ) & & memlo ` ` < = ` ` ptr ` ` < = ` ` memhi ; `    `     invariant ( ` @xmath2`i`@xmath3 ` memlo ` ` < = ` ` i < ptr = = > `    `                    $ toabs[i ] ` ` = = ` ` no_abs & & unalloc(color[i ] ) ) ; `    `   { `    `     color[ptr ] : = 0 ; `    `     $ toabs[ptr ] : = no_abs ; `    `     ptr : = ptr + 1 ; `    `   } `    ` } `    ``    ``    ` procedure readfield(ptr ` , ` field ) returns ( val ) `    `   requires mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires pointer($toabs ` , ` ptr ` , ` $ toabs[ptr ] ) ; `    `   requires field ` ` = = ` ` 0 || field ` ` = = ` ` 1 ; `    `   ensures   pointer($toabs ` , ` val ` , ` $ absmem[$toabs[ptr],field ] ) ; `    ` { `    `   assert t(ptr ) ; `    `   val : = mem[ptr , field ] ; `    ` } `    ``    ``    ` procedure writefield(ptr ` , ` field ` , ` val ) `    `   requires mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires pointer($toabs ` , ` ptr ` , ` $ toabs[ptr ] ) ; `    `   requires pointer($toabs ` , ` val ` , ` $ toabs[val ] ) ; `    `   requires field ` ` = = ` ` 0 || field ` ` = = ` ` 1 ; `    `   modifies $ absmem ` , ` mem ; `    `   ensures   mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   $ absmem = = old($absmem)[$toabs[ptr],field : = $ toabs[val ] ] ; `    ` { `    `   assert t(ptr ) & & t(val ) ; `    `   mem[ptr , field ] : = val ; `    `   $ absmem[$toabs[ptr],field ] : = $ toabs[val ] ; `    ` } `    ` procedure garbagecollect(root ) `    `   requires mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires root ` ` !",
    "= ` ` 0 = = > pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `   modifies color ` , ` $ toabs ; `    `   ensures   mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   root ` ` !",
    "= ` ` 0 = = > pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `   ensures   ` @xmath5`(`@xmath2`i`@xmath6 ` memaddr(i ) ` ` & & $ toabs[i ] ` ` !",
    "= ` ` no_abs = = > `    `                $ toabs[i ] ` ` = = ` ` old($toabs)[i ] ) ; `    `   ensures   root ` ` !",
    "= ` ` 0 = = > $ toabs[root ] = = old($toabs)[root ] ; `    ` { `    `   assert t(root ) ; `    `   if ( root ` ` ! = ` ` 0 ) `    `   { `    `     call mark(root ) ; `    `   } `    `   call sweep ( ) ; `    ` } `    ``    ``    ``    ``    ``    ``    ``    ` procedure mark(ptr ) `    `   requires gcinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires memaddr(ptr ) & & t(ptr ) ; `    `   requires $ toabs[ptr ] ` ` !",
    "= ` ` no_abs ; `    `   modifies color ; `    `   ensures   gcinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` ! black(color[i ] ) = = > color[i ] ` ` = = ` ` old(color)[i ] ) ; `    `   ensures   !",
    "white(color[ptr ] ) ; `    ` { `    `   if ( white(color[ptr ] ) ) `    `   { `    `     color[ptr ] : = 2 ; // make gray `    `     call mark(mem[ptr,0 ] ) ; `    `     call mark(mem[ptr,1 ] ) ; `    `     color[ptr ] : = 3 ; //",
    "make black `    `   } `    ` } `    ` procedure sweep ( ) `    `   requires gcinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` ! gray(color[i ] ) ) ; `    `   modifies color ` , ` $ toabs ; `    `   ensures   mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` memaddr(i ) = = > `    `                     ( black(old(color)[i ] ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` no_abs ) `    `                  & & ( $ toabs[i ] ` ` !",
    "= ` ` no_abs = = > $ toabs[i ] ` ` = = ` ` old($toabs)[i ] ) ) ; `    ` { `    `   var ptr ; `    `   ptr : = memlo ; `    ``    `   while ( ptr ` ` < ` ` memhi ) `    `     invariant t(ptr ) & & memlo ` ` < = ` ` ptr ` ` < = ` ` memhi ; `    `     invariant wellformed($toabs ) ; `    `     invariant ( ` @xmath2`i`@xmath3 ` memaddr(i ) = = > `    `         0 ` ` < = ` ` color[i ] ` ` < ` ` 4 `    `      & & ! gray(color[i ] ) `    `      & & ( black(old(color)[i ] ) = = > `    `             $ toabs[i ] ` ` ! = ` ` no_abs `    `          & & objinv(i ` , ` $ toabs ` , ` $ absmem ` , ` mem ) `    `          & & ( mem[i,0 ] ` ` > = ` ` ptr = = >",
    "! white(color[mem[i,0 ] ] ) ) `    `          & & ( mem[i,1 ] ` ` > = ` ` ptr = = >",
    "! white(color[mem[i,1 ] ] ) ) ) `    `      & & ( $ toabs[i ] ` ` = = ` ` no_abs ` ` < = = > ` ` unalloc(color[i ] ) ) `    `      & & ( $ toabs[i ] ` ` !",
    "= ` ` no_abs = = > $ toabs[i ] ` ` = = ` ` old($toabs)[i ] ) `    `      & & ( ptr ` ` < = ` ` i ` ` = = > ` ` color[i ] ` ` = = ` ` old(color)[i ] ) `    `      & & ( i ` ` < ` ` ptr ` ` = = > ` ` 0 ` `",
    "< = ` ` color[i ] ` ` < ` ` 2 ) `    `      & & ( i ` ` < ` ` ptr & & white(color[i ] ) = = > black(old(color)[i ] ) ) ) ; `    `   { `    `     if ( white(color[ptr ] ) ) `    `     { `    `       color[ptr ] : = 0 ; //",
    "deallocate `    `       $ toabs[ptr ] : = no_abs ; `    `     } `    `     else if ( black(color[ptr ] ) ) `    `     { `    `       color[ptr ] : = 1 ; // make white `    `     } `    `     ptr : = ptr + 1 ; `    `   } `    ` } `    ``    ` procedure alloc(root ` , ` $ abs ) returns ( newroot , ptr ) `    `   requires mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires root ` ` !",
    "= ` ` 0 = = > pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `   requires $ abs ` ` !",
    "= ` ` no_abs ; `    `   requires ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ abs ) ; `    `   requires $ absmem[$abs,0 ] ` ` = = ` ` $ abs ; `    `   requires $ absmem[$abs,1 ] ` ` = = ` ` $ abs ; `    `   modifies color ` , ` $ toabs ` , ` mem ; `    `   ensures   mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   root ` ` !",
    "= ` ` 0 = = > pointer($toabs`,`newroot`,`old($toabs)[root ] ) ; `    `   ensures   pointer($toabs ` , ` ptr ` , ` $ abs ) ; `    `   ensures   wellformed($toabs ) ; `    ` { `    ``    `   while ( true ) `    `     invariant mutatorinv(color ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `     invariant root ` ` ! = ` ` 0 = =",
    "> pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `     invariant ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ abs ) ; `    `     invariant root !",
    "= 0 = = > $ toabs[root ] = = old($toabs)[root ] ; `    ``    `   { `    `     ptr : = memlo ; `    ``    `     while ( ptr ` ` < ` ` memhi ) `    `       invariant t(ptr ) & & memlo ` ` < = ` ` ptr ` `",
    "< = ` ` memhi ; `    `     { `    `       if ( unalloc(color[ptr ] ) ) `    `       { `    `         color[ptr ] : = 1 ; // make white `    `         $ toabs[ptr ] : = $ abs ; `    `         mem[ptr,0 ] : = ptr ; `    `         mem[ptr,1 ] : = ptr ; `    `         newroot : = root ; `    `         return ; `    `       } `    `       ptr : = ptr + 1 ; `    `     } `    ``    `     call garbagecollect(root ) ; `    `   } `    ` } `    figure [ fig : examplealloc ] s ` alloc ` procedure performs an ( inefficient ) linear search for a free memory address ; if no free space remains , ` alloc ` calls the garbage collector .",
    "the collector recursively marks all nodes reachable from some root pointer ( the `` mark phase '' ) , and then deallocates all unmarked objects ( the `` sweep phase '' ) .",
    "figures [ fig : examplemark ] and [ fig : examplesweep ] show the code for the ` mark ` and ` sweep ` procedures .",
    "the next few paragraphs trace the preconditions and postconditions for ` mark ` and ` sweep ` backwards , starting with ` sweep ` s postconditions .",
    "a key property of ` sweep ` is that it leaves no dangling pointers ( pointers from allocated objects to free space ) .",
    "this property is part of ` mutatorinv ` : each memory address ` i ` satisfies ` objinv(i , ... ) ` , which ensures that if some object lives at ` i ` ( if ` $ toabs[i ] ! = no_abs ` ) , then the object s fields contain valid pointers to allocated objects ( see figure [ fig : exampledefs ] ) .",
    "specifically , the fields ` mem[i,0 ] ` and ` mem[i,1 ] ` are , like ` i ` , mapped to some abstract nodes , so that ` $ toabs[mem[i,0 ] ] !",
    "= no_abs ` @xmath5 and ` $ toabs[mem[i,1 ] ] !",
    "= no_abs ` . to maintain this property , `",
    "sweep ` must ensure that any object it deallocates had no pointers from objects that remain allocated . since ` sweep ` deallocates white objects and leaves gray and black objects allocated , ` sweep ` s preconditions",
    "requires that no gray - to - white or black - to - white pointers exist .    to rule out gray - to - white pointers , `",
    "sweep ` s second precondition requires that no gray objects exist at all :    @xmath7));}\\ ] ]    the ` gcinv ` function ( see figure [ fig : exampledefs ] ) prohibits black - to - white pointers : every black object has fields pointing to non - white objects .",
    "( this is known as the tri - color or three color invariant @xcite . )",
    "the ` mark ` procedure s postconditions must satisfy ` sweep ` s preconditions . to ensure that no gray objects exist at the end of the mark phase , ` mark ` s",
    "second postcondition says that any non - black object at the end of the mark phase retained its original color from the beginning of the mark phase .",
    "for example , any leftover gray objects must have been gray at the beginning of the mark phase .",
    "since no gray objects existed at the beginning , no gray objects exist at the end . `",
    "mark ` obeys the ban on black - to - white pointers by coloring an object black _ after _ its children are non - white .",
    "( before coloring a node s children , ` mark ` temporarily colors the node gray to indicate the node is `` in progress '' ; without this intermediate step , a cycle in the graph would send ` mark ` into an infinite loop . )      in the absence of universal and existential quantifiers , many theories are decidable and have practical decision procedures .",
    "these include the theory of arrays , the theory of linear arithmetic , the theory of uninterpreted functions , and the combination of these theories .",
    "unfortunately , adding quantifiers makes the theories either undecidable or very slow to decide : the combination of linear arithmetic and arrays , for example , is undecidable in the presence of quantifiers .",
    "this forces verification to rely on heuristics for instantiating quantifiers .",
    "the choice of heuristics determines the success of the verification .",
    "many automated theorem provers , including z3  @xcite and simplify  @xcite , use programmer - supplied _ triggers _ to guide quantifier instantiation .",
    "( many other automated theorem provers , such as cvc3  @xcite and yices  @xcite , use triggers internally , but do not expose triggers directly to programmers . ) consider again ` sweep ` s precondition prohibiting gray objects . here",
    "are two ways to write this in boogiepl syntax , each with a different trigger :    ....    forall i::{memaddr(i)}memaddr(i)==>!gray(color[i ] ) )    forall i::{color[i ] }   memaddr(i)==>!gray(color[i ] ) ) ....    both have the same logical meaning , but use different instantiation strategies .",
    "the first asks ` i ` to be instantiated with expression ` e ` whenever an expression ` memaddr(e ) ` appears during an attempt to prove a theorem .",
    "the second asks ` i ` to be instantiated with ` e ` whenever ` color[e ] ` appears .",
    "selecting appropriate triggers is challenging in general . with an overly selective trigger ,",
    "a quantified formula may never get instantiated , leaving a theorem unproved . with an overly liberal trigger",
    ", a quantified formula may be instantiated too often ( even infinitely often ) , drowning the theorem prover in unwanted information .",
    "shaz qadeer suggested that we look at formulas of form ` forall i::{f(i)}f(i ) = = > p ` , using ` f(i ) ` as a trigger .",
    "for example , we could use ` memaddr(i ) ` as a trigger , although this appears in so many places that it would be easy to accidentally introduce an infinite instantiation loop .",
    "( the appearance of ` memaddr(ptr ) ` inside the ` pointer ` function , which in turn appears in the ` objinv ` function , which in turn appears in the ` gcinv ` function , is one example of such a loop . ) to avoid accidental loops , we introduce a function ` t(i : int ) ` , solely for use as a trigger , writing the invariants above as :    ....    forall i::{t(i)}t(i)==>memaddr(i)==>!gray(color[i ] ) ) ....    ( note that the ` = = > ` operator is right associative . )    we define the function ` t ` to be true everywhere : for all ` i ` , ` t(i ) = = true ` .",
    "thus , adding ` t(e ) ` to a logical formula does nt change the purely logical meaning of the formula . however , ` t(e ) ` does function as a hint to z3 , indicating that ` e ` is an interesting expression that should be used to instantiate quantifiers . in this way , adding instances of ` t(e ) ` for various ` e ` can guide z3 s quantifier instantiation , as illustrated further below .    for conciseness , we abbreviate ` forall i::{t(i)}t(i)== > ` as @xmath8 . to avoid instantiation loops ,",
    "we never write a formula of the form @xmath9 , where ` e ` is some expression other than a simple quantified variable .",
    "based on the trigger ` t(i ) ` , we use two strategies to ensure sufficient instantiation of quantified formulas .",
    "first , we write explicit assertions of ` t(e ) ` for various expressions ` e ` that appear in the program .",
    "this helps z3 prove formulas @xmath10 .",
    "for example , the ` readfield ` procedure explicitly asserts ` t(ptr ) ` to instantiate the quantifiers in ` mutatorinv ` at the value ` ptr ` .",
    "second , we use the trigger ` t(i ) ` to prove formulas of the form @xmath11 . in this case , since ` t ` appears in both quantifiers , z3 automatically instantiates ` p ` at ` i = j ` to prove ` q(j ) ` .",
    "this second strategy is nt sufficient for all ` p ` and ` q ` ; for example , knowing @xmath12 = = 0}$ ] does not prove @xmath13 = = 0}$ ] , even though mathematically , both these formulas are equivalent .",
    "nevertheless , this strategy works well for purely local reasoning .",
    "for example , ` sweep ` s loop invariant maintains the property : @xmath14)}\\ ] ] if the loop updates ` color ` by changing ` color[ptr ] ` to ` 1 ` ( white ) , then the theorem prover attempts to prove :    ....        ( memaddr(i)==>!gray(color[i ] ) )    = = > ( memaddr(i)==>!gray(color'[i ] ) ) ....    where ` color ' = = color[ptr : = 1 ] ` . in the case",
    "where ` i !",
    "= ptr ` , ` color[i ] = = color'[i ] ` and the proof is trivial . in the case",
    "where ` i = = ptr ` , ` ! gray(color'[i ] ) = = !",
    "gray(1 ) = = true ` .",
    "the proof is easy because the formula ` memaddr(i ) = = > ` @xmath15 ` ! gray(color[i ] ) ` is entirely local ; it depends only on array elements at index ` i ` .",
    "many formulas depend on non - local array elements , though .",
    "consider how ` mark ` maintains this piece of the tri - color invariant ( no black - to - white pointers ) from ` gcinv ` in figure [ fig : exampledefs ] :    ....    black(color[i ] ) = = > !",
    "white(color[mem[i,0 ] ] ) ....",
    "this depends not only on ` i ` s color , but on the color of some other node ` mem[i,0 ] ` . for non - local formulas",
    ", the local instantiation strategy suffices for some programs but not for others . for example , it suffices for the collector in figures [ fig : exampledefs]-[fig : examplealloc ] ( we invite the reader to write out the verification conditions by hand to see ) , but did not suffice for an analogous copying collector that we wrote ( it did not sufficiently instantiate information about objects pointed to by forwarding pointers ) .",
    "this limitation motivated the use of regions , as described in the next section .",
    "a mark - sweep collector appears easier to verify than a copying collector , because the mark - sweep collector does nt modify pointers inside objects .",
    "as the previous section mentioned , the mark - sweep collector in figures [ fig : exampledefs]-[fig : examplealloc ] passed verification even with a very simple triggering strategy , while the analogous copying collector did not .",
    "therefore , this section augments the two strategies described in the previous section with a third instantiation strategy , based on _",
    "regions_. together , these three strategies were sufficient for both mark - sweep and copying collectors .",
    "( although regions are nt _ necessary _ for our mark - sweep collector , and can be omitted for strictly non - moving mark - sweep collectors , regions would be useful for mark - sweep collectors that employ compaction , or for collectors that combine mark - sweep and copying collection . )",
    "regions have proven useful for verifying the type safety of copying collectors @xcite , which suggests that they might also help verify the _ correctness _ of copying collectors .",
    "type systems for regions are similar to the verification presented in section [ sec - miniature - ms ] : section [ sec - miniature - ms ] s verification mapped concrete addresses to abstract nodes , while type systems type - check a region by mapping concrete addresses in the region to types ( e.g. , a type system with types ` parent ` and ` child ` might map figure [ fig : conabs ] s ` c1 ` to ` parent ` and ` c2 ` and ` c3 ` to ` child ` ) .",
    "this suggests a strategy for importing regions ( and the ease of verifying copying collectors via regions ) from type systems : rather than defining just one concrete - to - abstract mapping ` $ toabs ` , allow multiple regions , where each region is an independent concrete - to - abstract mapping .",
    "for example , consider how figure [ fig : exampledefs ] s object invariant uses ` $ toabs ` :    .... objinv(i,$toabs,$absmem , mem ) =    $ toabs[i ] !",
    "= no_abs = = >       pointer($toabs , mem[i,0 ] , $ absmem[$toabs[i],0 ] )       ... ....    expanding the ` pointer ` function exposes a non - local invariant :    ....    $ toabs[i ] !",
    "= no_abs = = >       ... $ toabs[mem[i,0 ] ] !",
    "= no_abs ... ....    this invariant is crucial ; as discussed in section [ sec - miniature - ms ] , it ensures that no dangling pointers exist .",
    "however , it s not obvious how to prove that this invariant is maintained when ` $ toabs[mem[i,0 ] ] ` changes .",
    "therefore , the remainder of this paper adopts a region - based object invariant :    ....    objinv(i,$rs,$rt,$toabs,$absmem , mem ) =      $ rs[i ] !",
    "= no_abs = = >         pointer($rt , mem[i,0 ] , $ absmem[$toabs[i],0 ] )     ... ....    this object invariant describes an object living in a source region ` $ rs ` , whose fields point to some target region ` $ rt ` . expanding the pointer function yields :    ....    $ rs[i ] !",
    "= no_abs = = >       ... $ rt[mem[i,0 ] ] !",
    "... ....    now we adopt another idea from region - based type systems : regions only grow over time , and are then deallocated all at once ; deallocating a single object from a region is not allowed . in our setting , this means that for any address ` j ` and region ` $ r ` , ` $ r[j ] ` may change monotonically from ` no_abs ` to some particular abstract node , but thereafter ` $ r[j ] ` is fixed at that abstract node .",
    "the function ` rextend ` expresses this restriction ; the memory manager only changes ` $ r ` to some new ` $ r ' ` if ` rextend($r,$r ' ) ` holds :    ....    fun rextend($r:[int]int,$r':[int]int ) {      ( forall i::{$r[i]}{$r'[i ] }        $ r[i ] ! = no_abs = = > $ r[i ] = = $ r'[i ] )    } ....    rextend s quantifier is _ not _ based on ` t ` ; instead , it can trigger on either ` $ r[i ] ` or ` $ r'[i ] ` .",
    "( note that ` rextend ` introduces no instantiation loops , because it only mentions ` r ` and ` r ' ` at index ` i ` , and does not mention ` t ` at all . ) in combination with the second strategy from section [ sec - miniature - ms ] , this triggering allows z3 to prove formulas of the form @xmath16))==>(}\\forall^{\\tt t}\\texttt{i.p(r'[e]))}$ ] , where ` e ` depends on ` i ` .",
    "for example , given the guarantee that ` rextend($rt,$rt ' ) ` , the object invariant ensures that if ` $ rt[mem[i,0 ] ] !",
    "= no_abs ` , then ` $ rt'[mem[i,0 ] ] !",
    "= no_abs ` .    given this region - based object invariant",
    ", a memory manager can express all other invariants about node ` i ` as purely local invariants .",
    "for example , our region - based mark - sweep collector relates ` i ` s color to ` i ` s region state using purely local reasoning , using a first region ` $ r1 ` to represent the set of all currently allocated objects and a second region ` $ r2 ` to represent the set of objects reached so far during the current collection :    ....       ( white(color[i ] ) = = >            $ r1[i ] !",
    "= no_abs & & $ r2[i ] = = no_abs         & & objinv(i,$r1,$r1,$toabs,$absmem , mem ) )    & & ( gray(color[i ] ) = = >            $ r1[i ] !",
    "= no_abs & & $ r2[i ] !",
    "= no_abs         & & $ r1[i ] = = $ r2[i ]         & & objinv(i,$r1,$r1,$toabs,$absmem , mem ) )    & & ( black(color[i ] ) = = >            $ r1[i ]",
    "! = no_abs & & $ r2[i ] !",
    "= no_abs         & & $ r1[i ] = = $ r2[i ]         & & objinv(i,$r2,$r2,$toabs,$absmem , mem ) ) ....    if ` i ` is black , then ` objinv(i,$r2,$r2 , ... ) ` ensures that ` i ` s fields point to members of region ` $ r2 ` .",
    "members of ` $ r2 ` can not be white , since the invariant above forces white nodes to _ not _ be members of ` $ r2 ` .",
    "thus , the invariant indirectly expresses the standard tri - color invariant ( no black - to - white pointers ) , and the collector need not state the tri - color invariant directly .",
    "we briefly sketch the region lifetimes during a mark - sweep garbage collection .",
    "the collector s mark phase begins with ` $ r1 ` equal to ` $ toabs ` and ` $ r2 ` empty ( i.e. ` $ r2 ` maps all nodes to ` no_abs ` ) . at the beginning of the mark phase ,",
    "all allocated objects are white , so the invariant above needs ` objinv(i,$r1,$r1 , ... ) ` , and requires that no objects be members of ` $ r2 ` . as the mark",
    "phase marks each reached node ` i ` gray , it adds ` i ` to ` $ r2 ` , so that ` $ r2[i ] ! = no_abs ` . at the end of the mark phase , ` $ r2 ` contains exactly the reached objects , while ` $ r1 ` and ` $ toabs ` are the same as at the beginning of the mark phase .",
    "the sweep phase then removes unreached objects from ` $ toabs ` until ` $ toabs = = $ r2 ` ; ` sweep ` leaves ` $ r1 ` and ` $ r2 ` unmodified . after sweeping , only the objects in ` $ r2 ` remain allocated ( sweeping removes all objects in ` $ r1 ` that are nt in ` $ r2 ` ) . at this point , ` $ r1 ` is no longer useful , so the mutator takes an action analogous to `` deallocating '' region ` $ r1 ` : it simply forgets about ` $ r1 ` , throwing out all invariants relating to ` $ r1 ` and keeping only the invariants for ` $ r2 ` . in the next collection cycle , ` $ r2 ` becomes the new ` $ r1 ` , and the process repeats .",
    "` function{:expand false } t(i ) { true } `    ` const no_abs : int ` , ` memlo : int ` , ` memmid : int ` , ` memhi : int ; `    ` const map_no_abs:[int]int ; `    ` axiom ( ` @xmath2`i`@xmath3 ` map_no_abs[i ] ` ` = = ` ` no_abs ) ; `    ` axiom 0 ` ` < ` ` memlo & & memlo ` ` < = ` ` memmid & & memmid ` `",
    "< = ` ` memhi ; `    ` fun memaddr(i ) { memlo ` ` < = ` ` i ` ` < ` ` memhi } `    ``    ` var mem:[int , int]int ` , ` fwdptr:[int]int ; `    ` var $ toabs:[int]int ` , ` $ absmem:[int , int]int ; `    ` var $ r1:[int]int ` , ` $ r2:[int]int ; `    ``    ` //",
    "fromspace ranges from fi to fl ` , ` where fk .. fl is empty `    ` //",
    "tospace ranges from ti to tl ` , ` where tk .. tl is empty `    ` var fi : int ; `    ` var fk : int ; `    ` var fl : int ; `    ` var ti : int ; `    ` var tj : int ; `    ` var tk : int ; `    ` var tl : int ; `    ``    ` fun wellformed($r ) { `    `   ( ` @xmath2`i1`@xmath3``@xmath2`i2`@xmath3 ` memaddr(i1 ) `    `      & & memaddr(i2 ) `    `      & & $ r[i1 ] ` ` ! = ` ` no_abs `    `      & & $ r[i2 ] ` ` !",
    "= ` ` no_abs `    `      & & i1 ` ` ! = ` ` i2 `    `   ` ` = = > ` ` $ r[i1 ] ` ` !",
    "= ` ` $ r[i2 ] ) `    ` } `    ``    ` fun pointer($r ` , ` ptr ` , ` $ abs ) { `    `     memaddr(ptr ) & & $ abs ` ` ! = ` ` no_abs `    ` & & $ r[ptr ] ` ` = = ` ` $ abs `    ` } `    ``    ` fun objinv(i ` , ` $ rs ` , ` $ rt ` , ` $ toabs ` , ` $ absmem ` , ` mem ) { `    `   $ rs[i ] ` ` ! = ` ` no_abs = = > `    `       pointer($rt ` , ` mem[i,0 ] ` , ` $ absmem[$toabs[i],0 ] ) `    `    & & pointer($rt ` , ` mem[i,1 ] ` , ` $ absmem[$toabs[i],1 ] ) `    ` } `    ``    ` fun gcinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl , `    `                $ r1 ` , ` $ r2 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) { `    `     wellformed($toabs ) `    ` & & memlo ` ` < = ` ` fi & & fi ` ` < = ` ` fk & & fk ` ` < = ` ` fl & & fl ` ` < = ` ` memhi `    ` & & memlo ` ` < = ` ` ti & & ti ` ` < = ` ` tj & & tj ` ` < = ` ` tk & & tk ` ` < = ` ` tl & & tl ` ` < = ` ` memhi `    ` & & ( fl ` ` < = ` ` ti || tl ` `",
    "< = ` ` fi ) `    ` & & ( ` @xmath2`i`@xmath3 `",
    "memaddr(i ) = = > `    `         ( $ r2[i ] ` ` !",
    "= ` ` no_abs ` ` = = > ` ` $ toabs[i ] ` ` = = ` ` $ r2[i ] ) `    `      & & ( $ r1[i ] ` ` ! = ` ` no_abs ` ` < = = > ` ` fi ` `",
    "< = ` ` i ` ` < ` ` fk ) `    `      & & ( $ r2[i ] ` ` ! = ` ` no_abs ` ` < = = > ` ` ti ` ` < = ` ` i ` ` < ` ` tk ) `    `      & & ( fi ` ` < = ` ` i ` ` < ` ` fk = = > `    `             ( fwdptr[i ] ` ` = = ` ` 0 ` ` < = = > ` ` $ toabs[i ] ` ` ! = ` ` no_abs ) `    `          & & ( fwdptr[i ] ` ` !",
    "= ` ` 0 ` ` = = > ` ` pointer($r2 ` , ` fwdptr[i ] ` , ` $ r1[i ] ) ) `    `          & & ( fwdptr[i ] ` ` = = ` ` 0 ` ` = = > ` ` $ toabs[i ] ` ` = = ` ` $ r1[i ] `    `                              & & objinv(i ` , ` $ r1 ` , ` $ r1 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ) ) `    `      & & ( ti ` `",
    "< = ` ` i ` ` < ` ` tk ` ` = = > `    `              fwdptr[i ] ` ` = = ` ` 0 & & $ toabs[i ] ` ` !",
    "= ` ` no_abs & & $ toabs[i ] ` ` = = ` ` $ r2[i ] ) `    `      & & ( ti ` ` < = ` ` i ` ` < ` ` tj ` ` = = > ` ` objinv(i ` , ` $ r2 ` , ` $ r2 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ) `    `      & & ( tj ` ` < = ` ` i ` ` < ` ` tk ` ` = = > ` ` objinv(i ` , ` $ r2 ` , ` $ r1 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ) ) `    ` } `    ``    ``    ` fun mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl , `    `                     $ toabs ` , ` $ absmem ` , ` mem ) { `    `     wellformed($toabs ) `    ` & & memlo ` ` < = ` ` fi & & fi ` `",
    "< = ` ` fk & & fk ` ` < = ` ` fl & & fl ` ` < = ` ` memhi `    ` & & memlo ` ` < = ` ` ti & & ti ` ` = = ` ` tj & & tj ` ` = = ` ` tk & & tk ` ` < = ` ` tl & & tl ` ` < = ` ` memhi `    ` & & ( fl ` ` < = ` ` ti || tl ` ` < = ` ` fi ) `    ` & & ( ` @xmath2`i`@xmath3 ` memaddr(i ) = = > `    `         objinv(i ` , ` $ toabs ` , ` $ toabs ` , ` $ toabs ` , ` $ absmem ` , ` mem ) `    `      & & ( fi ` ` < = ` ` i ` ` < ` ` fk ` ` = = > ` ` fwdptr[i ] ` ` = = ` ` 0 ) `    `      & & ( $ toabs[i ] ` ` ! = ` ` no_abs ` ` < = = > ` ` fi ` ` < = ` ` i ` ` < ` ` fk ) ) `    ` } `    ``    ``    ` // as a region evolves ` , ` it adds new mappings ` , ` but each mapping is `    ` // permanent : rextend ensures that new mappings do not overwrite old mappings . `",
    "` fun rextend(rold ` , ` rnew ) returns ( bool ) `    ` { `    `   ( forall i::{rold[i]}{rnew[i ] } rold[i ] ` ` !",
    "= ` ` no_abs ` ` = = > ` ` rold[i ] ` ` = = ` ` rnew[i ] ) `    ` } `    ``    ` procedure initialize ( ) `    `   modifies $ toabs ` , ` fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ; `    `   ensures   mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   wellformed($toabs ) ; `    ` { `    `   $ toabs : = map_no_abs ; `    `   fi : = memlo ; `    `   fk : = memlo ; `    `   fl : = memmid ; `    `   ti : = memmid ; `    `   tj : = memmid ; `    `   tk : = memmid ; `    `   tl : = memhi ; `    ` } `    ``    ``    ` procedure readfield(ptr ` , ` field ) returns ( val ) `    `   requires mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires pointer($toabs ` , ` ptr ` , ` $ toabs[ptr ] ) ; `    `   requires field ` ` = = ` ` 0 || field ` ` = = ` ` 1 ; `    `   ensures   pointer($toabs ` , ` val , `    `                    $ absmem[$toabs[ptr],field ] ) ; `    ` { `    `   assert t(ptr ) ; `    `   val : = mem[ptr , field ] ; `    ` } `    ``    ``    ` procedure writefield(ptr ` , ` field ` , ` val ) `    `   requires mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires pointer($toabs ` , ` ptr ` , ` $ toabs[ptr ] ) ; `    `   requires pointer($toabs ` , ` val ` , ` $ toabs[val ] ) ; `    `   requires field ` ` = = ` ` 0 || field ` ` = = ` ` 1 ; `    `   modifies $ absmem ` , ` mem ; `    `   ensures   mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   $ absmem = = `    `     old($absmem)[$toabs[ptr],field : = $ toabs[val ] ] ; `    ` { `    `   assert t(ptr ) & & t(val ) ; `    `   mem[ptr , field ] : = val ; `    `   $ absmem[$toabs[ptr],field ] : = $ toabs[val ] ; `    ` } `    ``    ` procedure forwardfromspaceptr(ptr ` , ` $ freshabs ) returns(ret ) `    `   requires gcinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ r1 ` , ` $ r2 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires t(ptr ) & & fi ` ` < = ` ` ptr ` ` < ` ` fk ; `    `   requires t($freshabs ) & & $ freshabs ` ` !",
    "= ` ` no_abs ; `    `   requires ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ freshabs ) ; `    ``    `   modifies fwdptr ` , ` $ toabs ` , ` $ r2 ` , ` tk ` , ` mem ; `    ``    `   ensures   gcinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ r1 ` , ` $ r2 ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   t(ret ) & & pointer($r2 ` , ` ret ` , ` $ r1[ptr ] ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ freshabs ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` i ` ` ! = ` ` old(tk ) ` ` = = > ` ` mem[i ` , ` 0 ] ` ` = = ` ` old(mem)[i ` , ` 0 ] ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` i ` ` !",
    "= ` ` old(tk ) ` ` = = > ` ` mem[i ` , ` 1 ] ` ` = = ` ` old(mem)[i ` , ` 1 ] ) ; `    `   ensures   rextend(old($r2 ) ` , ` $ r2 ) ; `    ` { `    `   if ( fwdptr[ptr ] ` ` ! = ` ` 0 ) { `    ``    `     // object already copied `    `     ret : = fwdptr[ptr ] ; `    ``    `   } `    `   else { `    `     // copy object to to - space `    ``    `     while ( tk ` ` > = ` ` tl ) { `    `       // out of memory `    `     } `    ``    `     assert t(ptr ) & & t(tk ) ; `    `     ret : = tk ; `    `     mem[ret ` , ` 0 ] : = mem[ptr ` , ` 0 ] ; `    `     mem[ret ` , ` 1 ] : = mem[ptr ` , ` 1 ] ; `    `     fwdptr[ret ] : = 0 ; `    `     $ toabs[ret ] : = $ r1[ptr ] ; `    `     $ r2[ret ] : = $ r1[ptr ] ; `    `     $ toabs[ptr ] : = no_abs ; `    `     fwdptr[ptr ] : = ret ; `    `     tk : = tk + 1 ; `    ``    `   } `    ` } `    ``    ` procedure garbagecollect(root ` , ` $ freshabs ) returns(newroot ) `    `   requires mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires root ` ` !",
    "= ` ` 0 = = > pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `   requires t($freshabs ) & & $ freshabs ` ` !",
    "= ` ` no_abs ; `    `   requires ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ freshabs ) ; `    `   modifies fwdptr ` , ` $ toabs ` , ` $ r1 ` , ` $ r2 ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` mem ; `    `   ensures   mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   root ` ` ! = ` ` 0 = = > pointer($toabs ` , ` newroot ` , ` old($toabs)[root ] ) ; `    `   ensures   ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` ! = ` ` $ freshabs ) ; `    ` { `    `   var fwd0 ` , ` fwd1 ` , ` temp ; `    `   assert t(root ) ; `    `   $ r1 : = $ toabs ; `    `   $ r2 : = map_no_abs ; `    `   if ( root ` ` ! = ` ` 0 ) { `    `     call newroot : = forwardfromspaceptr(root ` , ` $ freshabs ) ; `    `   } `    `   while ( tj ` ` < ` ` tk ) `    `     invariant t(tj ) & & t(root ) & & t(newroot ) ; `    `     invariant gcinv(fwdptr`,`fi`,`fk`,`fl`,`ti`,`tj`,`tk`,`tl`,`$r1`,`$r2`,`$toabs`,`$absmem`,`mem ) ; `    `     invariant root ` ` !",
    "= ` ` 0 = = > pointer($r2 ` , ` newroot ` , ` old($toabs)[root ] ) ; `    `     invariant ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ freshabs ) ; `    `   { `    `     assert t(mem[tj,0 ] ) & & t(mem[tj,1 ] ) ; `    `     call fwd0 : = forwardfromspaceptr(mem[tj,0 ] ` , ` $ freshabs ) ; `    `     call fwd1 : = forwardfromspaceptr(mem[tj,1 ] ` , ` $ freshabs ) ; `    `     mem[tj,0 ] : = fwd0 ; `    `     mem[tj,1 ] : = fwd1 ; `    `     tj : = tj + 1 ; `    `   } `    `   temp : = fi ; `    `   fi : = ti ; `    `   ti : = temp ; `    ``    `   temp : = fl ; `    `   fl : = tl ; `    `   tl : = temp ; `    ``    `   fk : = tk ; `    `   tj : = ti ; `    `   tk : = ti ; `    ``    `   $ toabs : = $ r2 ; `    ` } `    ``    ` procedure alloc(root ` , ` $ abs ) returns ( newroot , ptr ) `    `   requires mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   requires root ` ` ! = ` ` 0 = = > `    `              pointer($toabs ` , ` root ` , ` $ toabs[root ] ) ; `    `   requires $ abs ` ` !",
    "= ` ` no_abs ; `    `   requires ( ` @xmath2`i`@xmath3 ` memaddr(i ) ` ` = = > ` ` $ toabs[i ] ` ` !",
    "= ` ` $ abs ) ; `    `   requires $ absmem[$abs,0 ] ` ` = = ` ` $ abs ; `    `   requires $ absmem[$abs,1 ] ` ` = = ` ` $ abs ; `    ``    `   modifies fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` mem ` , ` $ r1 ` , ` $ r2 ; `    ``    `   ensures   mutatorinv(fwdptr ` , ` fi ` , ` fk ` , ` fl ` , ` ti ` , ` tj ` , ` tk ` , ` tl ` , ` $ toabs ` , ` $ absmem ` , ` mem ) ; `    `   ensures   wellformed($toabs ) ; `    `   ensures   root ` ` !",
    "= ` ` 0 = = > `    `              pointer($toabs ` , ` newroot ` , ` old($toabs)[root ] ) ; `    `   ensures   pointer($toabs ` , ` ptr ` , ` $ abs ) ; `    ``    ` { `    `   newroot : = root ; `    `   assert t(root ) ; `    ``    `   if ( fk ` ` > = ` ` fl ) { `    `     call newroot : = garbagecollect(root ` , ` $ abs ) ; `    `   } `    ``    `   while ( fk ` ` > = ` ` fl ) { `    `     // out of memory `    `   } `    ``    `   assert t(newroot ) & & t(fk ) ; `    ``    `   ptr : = fk ; `    `   $ toabs[ptr ] : = $ abs ; `    `   $ r1[ptr ] : = $ abs ; `    ``    `   mem[ptr,0 ] : = ptr ; `    `   mem[ptr,1 ] : = ptr ; `    `   fwdptr[ptr ] : = 0 ; `    ``    `   fk : = fk + 1 ; `    ` } `",
    "this section applies the previous section s region - based verification to a miniature copying collector . like the miniature mark - sweep collector ,",
    "the miniature copying collector is a single boogiepl file ; it is shown in its entirety in figures [ fig : examplecopydef]-[fig : examplecopyalloc ] .",
    "the copying collector is a standard two - space cheney - queue collector @xcite .",
    "the heap consists of two equally sized spaces . at any given time ,",
    "one of the spaces is called _ from - space _ and the other is called _ to - space_. from - space ranges from address ` fi ` to ` fl ` , while to - space ranges from address ` ti ` to ` tl ` ( where the ` f ` and ` t ` stand for * f*rom and * t*o , and the ` i ` and ` l ` indicate the * i*nitial address and the * l*imit of each space ) .",
    "the allocator , shown in figure [ fig : examplecopyalloc ] , alloctes objects in from - space until from - space fills up . the memory ` fi` ... `fk ` contains allocated objects , and the memory ` fk` ... `fl ` contains free space , so that allocation simply requires bumping the variable ` fk ` up by one .",
    "when from - space fills up with objects ( so that ` fk = = fl ` ) , the allocator calls the collector , shown in figure [ fig : examplecopygc ] .",
    "the collector traverses all from - space objects reachable from the root pointer , and copies these objects into to - space .",
    "( all objects left in from - space are garbage , and are simply ignored by the mutator and collector . )",
    "the collector swaps the ` fi` ...",
    "`fl ` variables with the ` ti` ... `tl ` variables , so that from - space becomes to - space and to - space becomes from - space .",
    "the collector then returns returns control to the allocator , which attempts allocation again .",
    "( note that if no garbage existed before the collection , then no free memory will be available after the collection ; in this case , the allocator is out of memory and has no choice but to give up . )",
    "the ` forwardfromspacepointer ` procedure copies a single object , with address ` ptr ` , from from - space to to - space .",
    "however , before copying the object , it checks to make sure that the object was nt already copied earlier .",
    "more specifically , for each object copied to to - space , ` forwardfromspacepointer ` sets a _",
    "forwarding pointer _ that points from the old from - space object to the new to - space copy .",
    "the variable ` fwdptr ` is an array mapping each old from - space object s address to the corresponding new to - space object address .",
    "if ` fwdptr[ptr ] ` is non - zero , then the object at from - space address ` ptr ` was already copied to the to - space address ` fwdptr[ptr ] ` , and ` forwardfromspacepointer ` simply returns this to - space address .",
    "otherwise , ` forwardfromspacepointer ` copies each field of the object into to - space , sets ` fwdptr[ptr ] ` to the to - space address , and returns the to - space address .",
    "when the collector copies an object to to - space , the fields of the copied object initially point back to from - space .",
    "the collector later fixes up the pointers to point to to - space by calling ` forwardfromspacepointer ` on each field of the to - space object .",
    "the set of objects not yet fixed form a contiguous work area in to - space .",
    "the collection algorithm in figure [ fig : examplecopygc ] treats this work area as a `` scan queue '' : ` forwardfromspacepointer ` adds newly copied objects to the back of the queue ( ` tk ` ) , and ` garbagecollect ` fixes objects from the front of the queue ( ` tj ` ) . when the queue is empty ( ` tj = = tk ` ) , all objects are fixed , and the collection is done .",
    "the copying collector shares the same region - based ` objinv ` from section [ sec - regions ] .",
    "other invariants differ from the mark - sweep collector , though .",
    "for example , the copying collector has no colors , so there is no invariant to relate colors to regions .",
    "there are invariants that relate the forwarding pointer to regions , though .",
    "for example , each object ` i ` in from - space satisfies this invariant , which ensures that no object with a non - null forwarding pointer is present in ` $ toabs ` , and that any forwarding pointer points to a resident of ` $ r2 ` :    ....     ( fwdptr[i ] = = 0 < = = > $ toabs[i ] ! = no_abs ) & & ( fwdptr[i ] ! = 0   = = > pointer($r2,fwdptr[i],$r1[i ] ) ) ....    the region ` $ r2 ` is empty at the start of the collection .",
    "the collector adds each object that it creates in to - space to ` $ r2 ` , while leaving ` $ r1 ` unchanged .",
    "the collector also updates ` $ toabs ` to reflect the current concrete location of each abstract object ( either moved to to - space , or still living in from - space ) ; at the end , the collector assigns ` $ r2 ` to ` $ toabs ` , and throws out all invariants related to ` $ r1 ` .    during the collection , each fixed object in to - space points from region ` $ r2 ` to region ` $ r2 ` :    ....      objinv(i,$r2,$r2,$toabs,$absmem , mem ) ....    each object still in the to - space scan queue points from region ` $ r2 ` back to region ` $ r1 ` :    ....      objinv(i,$r2,$r1,$toabs,$absmem , mem ) ....    meanwhile , each object in from - space points from region ` $ r1 ` to region ` $ r1 ` :    ....      objinv(i,$r1,$r1,$toabs,$absmem , mem ) ....    in this way , the region variables ` $ r1 ` and ` $ r2 ` concisely specify the state of each object .",
    "this section applies the region - based verification from the previous two sections to realistic copying and mark - sweep collectors , replacing the naive recursive mark - sweep algorithm of figures [ fig : exampledefs]-[fig : examplealloc ] with a more efficient iterative algorithm in subsection [ subsec - marksweep ] , then replacing high - level language constructs with assembly language in subsection [ subsec - assembly ] , and then replacing the miniature 2-field , 1-root memory model with a bartok - compatible memory model in subsection [ subsec - bartok ] . if sections [ sec - miniature - ms]-[sec - miniature - copy ] were the inspiration , this section is the perspiration ; the code for the realistic collectors is far longer than figures [ fig : exampledefs]-[fig : examplecopyalloc ] , but not fundamentally much more interesting .",
    "we present only short description and selected highlights of the code , including a large excerpt from the realistic copying collector in subsection [ subsec - copyforward ] ; the reader can find the full code and complete invariants in the public release .",
    "our verified mark - sweep collector uses the standard 3-color invariant . in the beginning of the collection",
    "all objects are white and the goal is to mark black all objects reachable from the roots . after this marking process , the sweep process can go over the objects to reclaim all white objects and to mark all black objects white in preparation for the next collection . in the beginning of the collection",
    "all objects directly reachable from the roots are put into a list denoted the _ mark - stack_. all objects in this list are colored gray , meaning that they have been reached , but their descendants have not yet been traversed . after the roots have been scanned , the collector proceeds by iteratively choosing a gray object @xmath17 from the mark - stack , inserting @xmath17 s direct descendants into the mark - stack and marking @xmath17 black .",
    "the black color signifies that the object is reachable and all its direct descendants have been noticed ( i.e. , put in the mark - stack ) .",
    "the _ unallocated _ color labels free space .    keeping the object color requires two bits per object .",
    "the colors can be kept in the object header or in a separate table .",
    "following previous work ( e.g. , @xcite ) we have chosen the latter .",
    "bartok assumes that objects are 4-byte aligned .",
    "therefore , it is enough to keep two color bits per 4 bytes ( creating a space overhead of 6% ) .",
    "the two bits that correspond to the beginning of an object specify its color .",
    "all other bit pairs are marked as unallocated .",
    "this provides an additional benefit .",
    "when a pointer in the heap points to a location that is marked unallocated , we know that the said pointer is an interior pointer .",
    "interior pointers that are discovered during the tracing stage must be treated in a special manner .",
    "the collector needs to find the beginning of the object in order to discover its header and from it information on pointer fields in the object .",
    "the algorithm follows a very simple collection scheme . one could choose a simpler scheme for verification , for example , by giving up the mark - stack and searching the heap for gray objects , or employing recursion .",
    "one could also complicate the scheme and make it more efficient , for example , by using bit - wise sweep .",
    "however , we attempted to find the middle way between simplicity and efficiency , in order to enable verification while maintaining the practicability of the collector .",
    "a major performance consideration is the allocator .",
    "therefore , we paid special attention to making the allocator efficient , cache - friendly , scalable , and simple .",
    "we chose the local allocation cache method that was first invented and used with the ibm jvm allocator  @xcite and later employed and explained in @xcite .",
    "this method provides efficiency by allowing bump - pointer allocation with a mark - sweep collection .",
    "the mutator holds a local cache in which it allocates small objects by simply bumping a pointer . when the space in the cache is exhausted , the mutator acquires a new local cache from the first chunk in the free list .",
    "if that chunk is too large ( larger than some threshold maxcachesize ) , then only maxcachesize bytes of the first chunk are taken for the local cache , and the rest is left for future cache allocations . allocation of large objects use the free list directly ; however , since most allocated objects in typical programs are small , most allocation work is efficient .",
    "furthermore , these allocations are cache - friendly since the spatial order of allocated objects in the memory matches the temporal order in which the program allocates them .",
    "since the mutator only acquires objects or spaces of substantial size from the free list , there is no need to keep small chunks in it .",
    "thus , sweep only fills the free - list with large enough spaces ; in our implementation the minimum cache size was set to 256 bytes and objects of size 192 or up are considered large ( and are thus directly allocated from the free list ) .",
    "the mark - sweep collector invariants follow the region - based approach of section [ sec - regions ] , sharing the definition of ` pointer ` and ` objinv ` with the copying collector .",
    "unlike earlier sections , though , this mark - sweep collector has a free list with non - trivial structure .",
    "we use two ghost variables , ` $ fs ` and ` $ fn ` to represent the size of each free list entry and the next - list - entry pointer in each free list entry .",
    "any address i where ` $ fs[i ] !",
    "= 0 ` holds a free list entry .",
    "each free list entry must be at least 8 bytes : 4 bytes to store the next pointer , and 4 bytes to store the size .",
    "the central invariant ensures , among other things , that the space occupied by each free list entry does not overlap with any object or any other free list entry :    ``    ` $ fs[i ] !",
    "= 0 = = > `    `     $ toabs[i ] = = no_abs `    ` & & i + 8 < = i + $ fs[i ]",
    "< = memhi `    ` & & ( ` @xmath0`j .",
    "i < j < i + $ fs[i ] = = > `    `        $ toabs[j ] = = no_abs & & $ fs[j ] = = 0 ) `    ` & & ... `    @xmath18it also ensures that any non - null next - list - entry pointer points to a subsequent list entry , and that there are no other non - null next - list - entry pointers between the ` i ` and ` $ fn[i ] ` :    ` $ fs[i ] ! = 0 = = > `    `     ( $ fn[i ] ! = 0 = = > i + $ fs[i ] < $ fn[i ] < = memhi `    `       & & $ fs[$fn[i ] ] !",
    "= 0 ) `    ` & & ( ` @xmath0`j .",
    "i < j < $ fn[i ] `    `       & & $ fs[j ] ! = 0 = = > $ fn[j ] = = 0 ) `    @xmath18to allocate a new local cache , the allocator disconnects the first list element from the rest of the free list .",
    "( for convenience in this case , the invariants allow disconnected list elements to co - exist with the rest of the free list . )",
    "figure [ fig : mark ] specifies the marking phase , written as high - level pseudocode .",
    "the objects reachable from the roots are marked , and then , using the mark - stack , all reachable objects are popped from the stack , marked black , and their children are marked gray ( and pushed to the markstack if necessary ) .    the sweep phase is also depicted in figure [ fig : mark ] .",
    "we keep a very simple algorithm .",
    "note that we do not bother maintaining information that would allow jumping over unallocated objects ( hence the statement `` ` addr + = 4 ; ` '' , which jumps only over one word ) .",
    "there are various other optimizations possible , but we chose a version that keeps the balance between simplicity and efficiency .",
    "finally , the pseudo - code of the allocator is provided in figure [ fig : alloc ] .",
    "small objects are allocated from the local cache .",
    "a slow path occurs when the cache is exhausted or the allocation is of a large object . in these cases",
    "the free - list must be traversed . for a cache allocation",
    "any chunk is good , so the first chunk is used .",
    "if the first chunk is very large , then only part of it is assigned as the current cache . for large objects ,",
    "the list is traversed using a first - fit allocation strategy .",
    "after the object is allocated from the chunk , the remains of the chunk is returned to the free list only if the created smaller chunk has size larger than mincachesize .",
    "so far , this paper has expressed all memory management code in boogiepl or in pseudocode , neither of which were designed to execute on real computers .",
    "we decided to write our real copying and mark - sweep collectors ( and allocators ) in x86 assembly language , for two reasons .",
    "first , we did nt want a high - level language compiler in our trusted computing base .",
    "second , the mutator - to - allocator interface requires some assembly language to read the stack pointer , so that the collectors can scan the roots on the stack .",
    "we still wanted to use boogie to verify our code , so this left us with a choice : translate annotated x86 into boogiepl , or translate boogiepl into x86 .",
    "the former approach is the most common way to use boogiepl , but we chose the latter approach , for the following reason . since the garbage collectors are written in boogiepl , the boogie and z3 tools guarantee that we really have verified the collectors , at least in boogiepl form , even if our boogiepl - to - x86 translation subsequently turns the verified boogiepl into erroneous x86 code . (",
    "if we had translated x86 to boogiepl , we would have had to ask the reader to trust that our translator did nt just produce a trivially verifiable boogiepl program . )",
    "we wrote a small tool to automatically translate an x86-like subset of boogiepl into masm - compatible x86 code , which we then assemble and link with bartok - compiled benchmarks .",
    "the tool rejects boogiepl programs that do not conform to the x86-like subset , such as programs that attempt to use ghost variables at run - time .",
    "the x86-like subset of boogiepl ( an example of which appears in figures [ fig : realisticcopya]-[fig : realisticcopyb ] ) consists of top - level variable declarations , non - recursive pure function declarations , and non - recursive procedure declarations .",
    "each procedure is either a macro that gets inline - expanded , or a run - time procedure called with the x86 call instruction .",
    "the tool enforces matching call and return instructions ; the boogiepl code may read the stack pointer at any time , but may not write it .",
    "each procedure consists of local variable declarations followed by a sequence of statements . since there s no recursion , local variables are statically allocated , as in early fortran .",
    "global and local variables may be ghost variables , of any type , or physical variables , of type ` int ` .",
    "the tool enforces our convention that ghost variables always begin with a ` $ ` character .",
    "the predefined global variables ` eax ` , ` ebx ` , ` ecx ` , ` edx ` , ` esi ` , ` edi ` , ` ebp ` , and ` esp ` , all of type ` int ` , represent the x86 registers .",
    "we maintain the invariant that all registers , physical variables , and words in memory hold an integer in the range 0 .. @xmath19 at all times .",
    "each statement in a procedure is a label ( used as a jump or branch target ) , an assignment to a ghost variable ( ignored by the translation ) , an assignment to a register or physical variable , a procedure call , or a control statement .",
    "control statements are either unconditional jumps ( `` ` goto label ; ` '' ) or conditional branches :    .... if(operand1 cmp operand2 ) { goto label ; } ....    where ` operand1 ` and ` operand2 ` are registers , physical variables , or integer constants , and ` cmp ` is a comparison operator .",
    "most statements are translated into single x86 instructions , but conditional branches translate into 2 x86 instructions ( a compare and a branch ) . a procedure call either translates into an inline expansion of the called procedure , or a single x86 call instruction .",
    "each assignment statement is either a simple move operation `` ` operand1 : = operand2 ; ` '' , an arithmetic operation , or a memory operation .",
    "arithmetic operations can either statically check for 32-bit integer overflow , or check at run - time .",
    "for example , the statement `` ` call eax : = sub(eax , 5 ) ; ` '' statically verifies that ` eax - 5 ` does not overflow , because of the ( tool - supplied ) specification of ` sub ` ( where ` word(e ) ` means that 0@xmath20`e`@xmath21 ) :    .... procedure sub(x : int , y : int ) returns(ret : int ) ;    requires word(x - y ) ;    ensures   ret = = x - y ; ....    the program is not allowed to modify predefined global variables , like ` mem ` , directly .",
    "to read or write memory , the program must call tool - supplied ` load ` and ` store ` procedures , which the tool translates into x86 mov instructions .",
    "the preconditions for ` load ` and ` store ` guarantee that the verified code does not read or write outside its allowed memory area , and that all reads and writes are to 4-byte aligned addresses .",
    "in contrast to the two - dimensional memory ` mem[objaddress , field ] ` presented earlier , ` load ` and ` store ` work with a one - dimensional memory ` mem[byteaddress ] ` .",
    "our verified garbage collectors form a critical piece of our long - term goal : an entire verified run - time system for bartok - compiled code . because the existing bartok run - time system contains over 70,000 lines of code",
    ", we decided to take an incremental approach towards creating a verified run - time system , starting with as small a run - time system as possible , so as to make the verification as easy as possible .",
    "we still wanted to be able to run real bartok - compiled benchmarks , though , and these benchmarks rely on many non - trivial run - time system features .",
    "so before attempting to verify any run - time system code , we examined the 12 large benchmarks used in previous papers @xcite to see which features could be evicted from the run - time system .",
    "we found that we could remove two major features , while still supporting 10 of the 12 benchmarks :    1 .",
    "only one benchmark ( specjbb ) was multithreaded , so we omitted support for multithreading from our run - time system .",
    "only one of the remaining benchmarks ( mandelform ) relied on gc support for unsafe code , such as pinning objects ( to cast gc - managed pointers to unmanaged pointers for unsafe code ) and handling callbacks from unsafe code to safe code .",
    "our verified gc simply halts any program that tries to use these features .",
    "this still left a moderately large set of features to support :    1 .",
    "objects have a header word , pointing to a virtual method table ( vtable ) . before the header word",
    ", there is a `` pre - header '' that holds a hash code or other primitive value .",
    "2 .   non - indexed object types can have any number of fields .",
    "indexed object types can be strings , single - dimensional arrays , or multi - dimensional arrays , each having a different memory layout .",
    "array element types can be pointers , primitive values , structs without pointers , or structs with pointers .",
    "we implemented only partial support for arrays of structs with pointers , since the 10 benchmarks did not rely on full support .",
    "pointers point to an object s header word , with one exception : root pointers may be _ interior pointers _ that point to data inside an object , ranging from the header word up to , and including , the address of the end of the object ( i.e. the address of the first word beyond the object s last field or array element ) .",
    "an object s virtual method table has fields that the collector can read to compute the length of an object and to determine which fields of an object are pointers .",
    "bartok s pointer - tracking representation consists of 2 compact bit - level formats for non - indexed objects , 1 non - compact format for non - indexed objects , 1 format for strings , 2 formats for single - dimensional arrays , and 2 formats for multi - dimensional arrays .",
    "our collectors support all of these ( except for some arrays of structs with pointers ) .",
    "5 .   roots may live on the stack or in static data segments .",
    "each static data segment has a bitmap , with one bit per static data word , indicating pointers and non - pointers in the segment .",
    "finding pointers on the stack is more complicated ; the collector has to traverse frame pointers to find the stack frames , and it has to look up return addresses in a sorted table of return addresses to find a descriptor for each frame . to simplify finding pointers",
    ", we set a compiler flag telling bartok to treat all registers as caller - save registers , with no callee - save registers .",
    "although the complete boogiepl specification of the features above is rather long and tedious , it s worth showing one example .",
    "one of the compact pointer - tracking formats is a dense format , using one bit per field .",
    "the specification for this says that if the tag of an object for abstract node ` $ abs ` , with vtable ` vt ` , is ` dense_tag ` , then each field is a pointer if and only if the corresponding bit in the vtable s mask field is ` 1 ` :    ``    ` tag(vt)==dense_tag = = > ( ` @xmath0`j.2<=j",
    "< numfields($abs)== > `    `   vfieldptr($abs , j)==(j<30 & & getbit(mask(vt),2+j ) ) ) `    ``    @xmath18where ` mask ` looks up a 32-bit value from the vtable ( in read - only memory ) , and ` tag ` and ` getbit ` extract bits from words :    ....    fun mask(vt : int ) { ro32(vt + ?",
    "vt_mask ) }    fun tag(vt : int ) { and(mask(vt ) , 15 ) }    fun getbit(x : int , i : int ) { 1 = = and(shr(x , i ) , 1 ) } ....    the mutator - allocator interface specification uses the uninterpreted function ` vfieldptr ` to state which physical values are primitive values , and which are pointer values .",
    "the ` value ` function states the meaning of values in each of these two cases :    ....    fun value(isptr,$r , v,$abs ) {       ( isptr & & word(v ) & & gcaddrex(v ) & & !",
    "word($abs )                         & & pointer($r , v - 4 , $ abs ) )    || ( isptr & & word(v ) & & !",
    "gcaddrex(v ) & & $ abs = = v )    || ( ! isptr & & word(v ) & & $ abs = = v )    } ....    for primitive data , the data s abstract value equals its concrete value .",
    "pointer data may point to gc memory , under the collector s control , or they may point outside gc memory , in which case the collector treats them the same as primitive values . the `` ` - 4 ` '' in the pointer specification converts a pointer to a header word into a pointer to the beginning of the object ( the pre - header ) .",
    "interior pointers are defined like the ordinary pointers shown above , but may have offsets larger than 4 , which forces the collector to search for the beginning of the object .",
    "the mark - sweep collector already has a table of colors , so it simply searches backwards from the interior pointer to find the first word whose color is nt ` unallocated ` .",
    "we also had to add an analogous bit map to the copying collector , with one bit per heap word , solely for the purpose of handling interior pointers .",
    "( on the bright side , these bit maps did give us a chance to exercise z3 s bit vector support . )    before we added support for bartok s memory model , the trusted mutator - allocator specification was fairly short and readable .",
    "after adding bartok s memory model , the specification ballooned to hundreds of lines of bit - level details . at this point , we started to wonder if the specification itself had bugs .",
    "we used two techniques to test the specification .",
    "first , we used boogie s `` smoke '' feature , which attempts to prove false at various points in the program .",
    "this did not turn up any bugs .",
    "second , we hand - translated the specification into c # code , and then added run - time assertions to the original bartok garbage collectors based on this c # code .",
    "we saw many assertion violations , which led us to 5 specification bugs , ranging from mundane ( forgetting to multiply by 4 to convert a word address to a byte address ) to subtle ( forgetting that bartok compresses the sorted return address tables by omitting any entry whose descriptor is identical to the previous entry ) .      as a larger example ,",
    "figures [ fig : realisticcopya]-[fig : realisticcopyb ] show a complete excerpt from the realistic verified copying collector : the ` copyandforward ` procedure , which copies an object from from - space to to - space .",
    "( this procedure corresponds to the portion of the miniature copying collector s ` forwardfromspaceptr ` procedure that copies an object from from - space to to - space , after determining that the object hasnt already been forwarded . ) in addition , the right - hand side of figures [ fig : realisticcopya]-[fig : realisticcopyb ] shows the generated masm - compatible x86 code generated by our boogiepl - to - x86 translation tool .",
    "the ` copyandforward ` procedure is implemented using the control , arithmetic , and memory constructs described in subsection [ subsec - assembly ] : ` if ` , ` goto ` , ` call ` , ` addchecked ` , ` sub ` , etc . there s one slight embellishment in the implementation : the x86-like subset of boogiepl distinguishes between the read - only memory that describes bartok - generated gc tables , the read - write stack memory that the mutator controls , and the read - write heap memory that the garbage collector controls .",
    "the variable ` $ gcmem ` represents the last of these , and the garbage collector uses ` gcload ` and ` gcstore ` operations to read and write ` $ gcmem ` .",
    "the translator turns ` gcload ` and ` gcstore ` into x86 ` mov ` instructions , as seen on the right - hand side of figures [ fig : realisticcopya]-[fig : realisticcopyb ] .",
    "the ` copyandforward ` procedure relies on several helper procedures , also written in boogiepl and verified using boogie / z3 ( and all available in the public source release ) .",
    "the ` getsize ` procedure accepts a pointer in register ` ecx ` to an object with vtable ` edx ` , and computes the size of the object .",
    "( this is complicated in general , because the object may be a non - index type , a string , or a single- or multi - dimensional array . ) the inline procedure ` copyword ` copies a single field , with field index ` edi ` , from from - space object ` ecx ` to to - space object ` esi ` .",
    "( we split this into a separate procedure , because the verification time of the separate procedures was lower than the verification time of a single , combined procedure . ) finally , the inline procedure ` bb4setbit ` sets a single bit , at position ` esi ` , in a bit - vector at address ` edi ` .",
    "( the bit vector consists of an array of 4-byte words , each containing 32 bits of the bit vector . )",
    "note that the translator inlines the code from ` copyword ` and ` bb4setbit ` directly into the code for ` copyandforward ` , as seen on the right - hand side of figures [ fig : realisticcopya]-[fig : realisticcopyb ] .",
    "the miniature collectors used a trigger ` t ` in quantifiers to guide quantifier instantiation . to reduce unnecessary quantifier instantiation ,",
    "the realistic collector implementation uses seperate triggers for separate purposes : ` tv ` is used for general - purpose values , including pointers , while ` to ` is used for field indices .",
    "the preconditions to ` copyandforward ` specify the following :    1 .",
    "the ` ecx ` register contains a pointer ` $ ptr ` , which is a valid pointer to a from - space object .",
    "2 .   the copying collector s overall invariant ` copygcinv ` on gc memory holds .",
    "( this invariant is like the ` gcinv ` invariant in the miniature copying collector , although it deals with more complexities than the miniature collector .",
    "for example , the object at address ` tj ` , the head of the scan queue , may be in the middle of being scanned as ` copyandforward ` runs .",
    "the ` copygcinv ` keeps track of both the beginning of this head object , ` tj ` , and the end of the head object , ` $ _ tj ` . )",
    "the from - space object has not been forwarded ( ` ! isfwdptr ( ... ) ` ) .",
    "note that unlike the miniature copying collector , the real collector stores the forwarding pointer in the header field of a from - space object after the from - space object is copied , overwriting the vtable ( virtual method table ) pointer in the header .",
    "( the collector can distinguish a vtable pointer from a forwarding pointer , because vtables do not live in to - space . )",
    "also note that the header field follows the pre - header field , so it lives at address ` $ ptr + 4 ` rather than ` $ ptr ` .",
    "the object has been reached .",
    "( this is used to prove that all copied objects were reached during the collection , so that non - reached objects are actually collected . )    to copy an object , ` copyandforward ` first loads the vtable from the object s header and calls ` getsize ` to get the size of the object , which it places in ` ebp `",
    ". it then reserves space for the copied object in to - space , by adding ` ebp ` bytes to the to - space scan queue tail ` tk ` and checking that this addition causes neither a 32-bit integer overflow nor an overflow past the to - space limit ` tl ` .",
    "( with additional effort , we could probably prove that enough space will always be available in to - space , but the run - time cost of checking for space is small . )    after reserving memory in to - space , ` copyandforward ` enters a loop that copies each field ` edi ` of the object .",
    "the `` ` assert ` '' statements after the ` loop ` label specify the loop invariants . ( for conciseness , figure [ fig : realisticcopyb ] omits most of the loop invariants , which are similar to ` copyandforward ` s postconditions , but longer . )    after copying the object , ` copyandforward ` overwrites the old from - space object s vtable with a forwarding pointer to the new to - space object .",
    "( note that the x86 load - effective - address instruction ` lea ` simply computes an address . ) next , ` copyandforward ` sets a bit in the gc bit vector to indicate the start of an object , so that the collector can later find the start of the object from an interior pointer . finally , `",
    "copyandforward ` updates the ghost variables ` $ r2 ` and ` $ toabs ` and returns .    at the end of ` copyandforward ` , the postconditions guarantee that :    1 .",
    "the overall invariant ` copygcinv ` still holds 2 .",
    "the new ` $ r2 ` is a valid extension of the old ` $ r2 ` 3 .   the return value , `",
    "eax ` , is a valid pointer to a to - space object .",
    "furthermore , the fields of the object point back to from - space .",
    "( in region terminology , the object points from the to - space region ` $ r2 ` to the from - space region ` $ r1 ` . )",
    "the to - space scan queue grows at the tail ( ` tk ` ) , but remains the same at the head ( ` tj ` ) .",
    "the object at the head of the to - space queue ( ` tj ` ) is unmodified .",
    "the to - space object pointed to by ` eax ` is actually located in the to - space memory area ` ti` ... `tl ` .",
    ".verification times for practical collectors [ cols=\"<,^,^,^ \" , ]     @xmath22`procedure copyandforward($ptr ` , ` $ _ tj ) `",
    "@xmath22 `   requires ecx ` ` = = ` ` $ ptr ; `    @xmath22 `   requires copygcinv ( ... ) ; `    @xmath22 `   requires pointer($r1 ` , ` $ ptr ` , ` $ r1[$ptr ] ) & & tv($ptr ) ; `    @xmath22 `   requires ! isfwdptr($gcmem[$ptr + 4 ] ) ; `    @xmath22 `   requires $ _ tj ` ` < = ` ` tk ; `    @xmath22 `   requires reached($toabs[$ptr ] ` , ` $ time ) ; `    @xmath22 `   modifies $ r2 ` , ` $ gcmem ` , ` $ toabs ` , ` tk ` , ` $ gcslice ; `    @xmath22 `   modifies eax ` , ` ebx ` , ` ecx ` , ` edx ` , ` esi ` , ` edi ` , ` ebp ` , ` esp ; `    @xmath22 `   ensures   copygcinv ( ... ) ; `    @xmath22 `   ensures   rextend(old($r2 ) ` , ` $ r2 ) ; `    @xmath22 `   ensures   pointer($r2 ` , ` eax ` , ` $ r1[$ptr ] ) ; `    @xmath22 `   ensures   tj ` ` = = ` ` old(tj ) ; `    @xmath22 `   ensures   tk ` ` > = ` ` old(tk ) ; `    @xmath22 `   ensures   old($toabs)[tj ] ` ` !",
    "= ` ` no_abs = = > `",
    "@xmath22 `              $ toabs[tj ] ` ` !",
    "= ` ` no_abs & & $ toabs[tj ] ` ` = = ` ` old($toabs)[tj ] ; `    @xmath22 `   ensures   ( forall j::{to(j ) } to(j ) = = > `    @xmath22 `               0 ` ` < = ` ` j & & tj + 4 * j ` ` < ` ` $ _ tj = = > `    @xmath22 `                 $ gcmem[tj + 4 * j ] ` ` = = ` ` old($gcmem)[tj + 4 * j ] & & ... ; `    @xmath22 `   ensures   ti ` ` < = ` ` eax & & eax ` ` < ` ` tk & & gcaddrex(eax + 4 ) ; `    @xmath22 ` { `    @xmath22 `   var tmp ; `    @xmath22 ``    @xmath22 `   call edx : = gcload(ecx + 4 ) ;              ` @xmath23 * mov edx , dword ptr [ ecx+4 ] `` *    @xmath22 `   esp : = esp - 4 ; call getsize($ptr ` , ` ... ) ; ` @xmath23 * call _ ? getsize `` *    @xmath22 `   ebp : = eax ;                               ` @xmath23 * mov ebp , eax `` *    @xmath22 `   assert to(numfields($r1[$ptr ] ) ) ; `    @xmath22 ``    @xmath22 `   esi : = tk ;                                ` @xmath23 * mov esi , dword ptr _ $ $ tk `` *    @xmath22 `   call tk : = addchecked(tk ` , ` ebp ) ;           ` @xmath23 * add dword ptr _ $ $ tk , ebp `` *    @xmath22 `                                                ` * jc overflowed `` *    @xmath22 `   assert tv(esi ) ; `    @xmath22 ``    @xmath22 `   eax : = tl ;                                ` @xmath23 * mov eax , dword ptr _ $ $ tl `` *    @xmath22 `   if ( tk ` ` < = ` ` eax ) { goto skip1 ; }            ` @xmath23 * cmp dword ptr _ $ $ tk , eax `` *    @xmath22 `                                                ` * jbe copyandforward$skip1 `` *    @xmath22 `     // out of memory `    @xmath22 `     call debugbreak ( ) ;                      ` @xmath23 * int 3 `` *    @xmath22 `   skip1 :                                    ` @xmath23 * copyandforward$skip1 : `` *",
    "@xmath22 ``    @xmath22 `   edi : = 0 ;                                 ` @xmath23 * mov edi,0 `` *    @xmath22 `   edx : = 0 ;                                 ` @xmath23 * mov edx,0 `` *    @xmath22 `   loop :                                     ` @xmath23 * copyandforward$loop : `` *    @xmath22 `       //",
    "loop invariants : `    @xmath22 `       assert 4 * edi ` ` = = ` ` edx ; `    @xmath22 `       assert to(edi ) & & 0 ` ` < = ` ` edi & & edi ` ` < = ` ` numfields($r1[$ptr ] ) ; `    @xmath22 `       assert copygcinv ( ... ) ; `    @xmath22 `       assert rextend(old($r2 ) ` , ` $ r2 ) ; `    @xmath22 `       ... `    @xmath22 `     if ( edx ` ` > = ` ` ebp ) { goto loopend ; }       ` @xmath23 * cmp edx , ebp `` *    @xmath22 `                                               ` * jae copyandforward$loopend `` *    @xmath22 `     // copy one field : `    @xmath22 `     call copyword($ptr`,`$_tj`,`esi`,`edi`,`ebp ) ;    ` @xmath23 * mov eax , dword ptr [ ecx+4*edi ] `` *    @xmath22 `                                               ` * mov dword ptr [ esi+4*edi],eax `` *    @xmath22 `     call edi : = add(edi ` , ` 1 ) ;                ` @xmath23 * add edi,1 `` *    @xmath22 `     call edx : = add(edx ` , ` 4 ) ;                ` @xmath23 * add edx,4 `` *    @xmath22 `     goto loop ;                             ` @xmath23",
    "* jmp copyandforward$loop `` *    @xmath22 `   loopend :                                 ` @xmath23 * copyandforward$loopend : `` *    @xmath22 ``    @xmath22 `   // set forwarding pointer : `    @xmath22 `   call eax : = lea(esi + 4 ) ;                ` @xmath23 * lea eax , dword ptr [ esi+4 ] `` *    @xmath22 `   call gcstore(ecx + 4 ` , ` eax ) ;              ` @xmath23 * mov dword ptr [ ecx+4],eax `` *    @xmath22 `   eax : = esi ;                              ` @xmath23 * mov eax , esi `` *    @xmath22 `   // set bit in table : `    @xmath22 `   call esi : = sub(esi ` , ` ti ) ;                 ` @xmath23 * sub esi , dword ptr _ $ $ ti `` *    @xmath22 `   edi : = bt ;                               ` @xmath23 * mov edi , dword ptr _",
    "$ $ bt `` *    @xmath22 `   call bb4setbit ( ... ) ;                     ` @xmath23 * mov ecx , esi `` *    @xmath22 `                                               ` * shr esi,7 `` *    @xmath22 `                                               ` * shr ecx,2 `` *    @xmath22 `                                               ` * add esi , esi `` *    @xmath22 `                                               ` * add esi , esi `` *    @xmath22 `                                               ` * add esi , edi `` *    @xmath22 `                                               ` * and ecx,31 `` *    @xmath22 `                                               ` * mov edi,1 `` *    @xmath22 `                                               ` * shl edi , cl `` *    @xmath22 `                                               ` * mov ecx , edi `` *    @xmath22 `                                               ` * mov edi , dword ptr [ esi ] `` *    @xmath22 `                                               ` * or edi , ecx `` *    @xmath22 `                                               ` * mov dword ptr [ esi],edi `` *    @xmath22 `   $ r2[eax ] : = $ r1[$ptr ] ; `    @xmath22 `   $ toabs[eax ] : = $ toabs[$ptr ] ; `    @xmath22 `   $ toabs[$ptr ] : = no_abs ; `    @xmath22 `   assert to(1 ) ; `    @xmath22 `   assert tv(eax - ti ) ; `    @xmath22 ``    @xmath22 `   esp : = esp + 4 ; return ;                   ` @xmath23 * ret `` *    @xmath22 ` } `",
    "this section presents performance results , measured on a single core of a 4-core , 2.4ghz intel core2 with 4 gb of ram , 4 mb of l2 cache , and a 64 kb l1 cache .    verifying the copying collector , mark - sweep collector , and the code shared between the collectors took 115 seconds , 70 seconds , and 12 seconds , respectively ( see table [ table : vertime ] ) .",
    "this fast verification reflects our choice of a simple trigger ` t(i ) ` .",
    "the copying collector and mark - sweep collector contained 802 x86 instructions ( before inlining ) and 865 x86 instructions ( before inlining ) , plus 177 x86 instructions ( before inlining ) shared between the collectors .",
    "the boogiepl files for the copying and mark - sweep collectors contained 2398 non - comment , non - blank lines and 3038 non - comment , non - blank lines , plus 779 non - comment , non - blank lines of boogiepl code shared between the collectors .",
    "thus , there are about 2 - 3 lines of annotation per x86 instruction .",
    "these annotations require a non - trivial amount of human effort to write , but the effort is not too much greater than the effort spent in ordinary development and testing .",
    "the trusted definitions , including x86 instruction specifications and the bartok interface specification , occupied 546 non - blank , non - comment lines .",
    "figure [ fig : performance ] shows the performance of the 10 benchmarks cited in section [ sec - collectors ] as a function of heap size , both for our verified memory managers and for bartok s native run - time system .",
    "we denote the verified copying collector by vc , the verified mark - sweep collector by vms , the generational copying bartok collector by gen , and the bartok standard mark - sweep collector by ms .",
    "these results demonstrate that ( a ) our collectors work on real benchmarks , and ( b ) the space and time consumption is in the same ballpark as bartok s native run - time system .",
    "we emphasize the `` ballpark '' nature of the comparison between the verified collectors and the native bartok collectors , because this comparison is highly unfair to the native collectors , which support more features than the verified collectors .",
    "in particular , bartok s native run - time system supports multithreading , which adds synchronization overhead to the mutator and memory manager .",
    "bartok s native collectors were not designed to be used with a fixed heap size ; they expect to grow the heap as needed . to get a time vs. space plot for the bartok collectors , we varied the triggering mechanism used for heap growth , and then measured the actual heap space used .",
    "for the generational collector , we set the nursery size to 4 mb or 1/4 of the maximum heap size , whichever was smaller .",
    "several benchmarks created fragmentation that made it difficult for the verified mark - sweep collector to find space for very large objects .",
    "the standard bartok mark - sweep collector simply grows the heap when the current heap lacks space for a very large object ; we configured the verified mark - sweep collector to set aside part of the heap as a wilderness area , used as a last resort for very large object allocation . while this wilderness area enabled these benchmarks to keep running under heavy fragmentation , the performance still suffered , as seen in figures  [ fig : performance - zinger ] , [ fig : performance - sat ] , and [ fig : performance - bartok ] . for other benchmarks ,",
    "though , the verified mark - sweep collector performed well across a large spectrum of heap sizes .",
    "the verified copying collector , as expected , required a larger minimum heap size , but performed asymptotically well as the heap size increased .",
    "we have presented two simple collectors with the minimal set of properties required to make them reasonably efficient in a practical setting .",
    "we have mechanically verified that these collectors maintain a heap representation that is faithful to a mutator - defined abstract heap , and have run the collector on large , off - the - shelf c # benchmarks .    given the large size of the mutator - allocator specification , we were very curious to see whether our collectors would run correctly the first time .",
    "alas , running the verified copying collector revealed two specification bugs that we had nt caught before : ` initialize ` s postcondition forgot to ensure that the ` ebp ` register was saved , and the allocation postcondition specified a return value that was off by 4 bytes ( a header / pre - header confusion ) .",
    "thus , the copying collector ran correctly the _ third _ time we tried it , which is still no small achievement for a garbage collector hand - coded in assembly language .",
    "furthermore , we were then able to verify the mark - sweep collector against the debugged specification , so that the mark - sweep collector ran correctly the first time we tried it .",
    "in addition , having a clear and well - tested specification is useful for tal / pcc verifiers : based on the specification , we found a bug in our tal verifier @xcite , which did nt check that the sparse pointer tracking formats mention no field more than once ; this bug can allow tal code to crash when linked to bartok s native sliding / compacting collector .",
    "the fast verification times give us hope that there is still room to grow to support more features and better gc algorithms .",
    "in particular , multithreading and pinning are essential for many applications and libraries . pinning should be easy for the mark - sweep collector , but would complicate the copying collector : pinned objects fragment the heap , forcing the allocator to allocate from a non - contiguous free space .",
    "multithreading would require reasoning about mutual exclusion ( e.g. to keep allocators in different threads from allocating the same memory simultaneously ) , reasoning about suspending mutator threads during collection , and support for a more elaborate object pre - header word ( for monitor operations on objects ) .",
    "as the collectors grow , modularity becomes more important , so we re interested to see if the boogie / z3 approach can be combined with modular verification approaches based on separation logic and/or higher - order logic ; hopefully , the automation provided by boogie / z3 will allow verification at a scale where modularity becomes essential .",
    "the authors would like to thank nikolaj bjrner , shaz qadeer , shuvendu lahiri , bjarne steensgaard , jeremy condit , juan chen , zhaozhong ni , and the anonymous reviewers for many helpful discussions , suggestions , and comments .",
    "hezi azatchi , yossi levanoni , harel paz , and erez petrank .",
    "an on - the - fly mark and sweep garbage collector based on sliding view . in _",
    "oopsla03 acm conference on object - oriented systems , languages and applications _",
    ", acm sigplan notices , anaheim , ca , november 2003 .",
    "acm press .",
    "katherine barabash , ori ben - yitzhak , irit goft , elliot  k. kolodner , victor leikehman , yoav ossia , avi owshanko , and erez petrank . a parallel , incremental , mostly concurrent garbage collector for servers .",
    ", 27(6):10971146 , november 2005 .",
    "mike barnett , bor - yuh  evan chang , robert deline , bart jacobs , and k.  rustan  m. leino .",
    "boogie : a modular reusable verifier for object - oriented programs . in _",
    "formal methods for components and objects : 4th international symposium , fmco _ , 2005 .",
    "lars birkedal , noah torpe - smith , and john  c. reynolds .",
    "local reasoning about a copying garbage collector . in",
    "_ conference record of the thirty - first annual acm symposium on principles of programming languages _ , number 39 ( 1 ) in acm sigplan notices , pages 220231 , venice , january 2004 .",
    "acm press .",
    "l.  burdy .",
    "vs. coq to prove a garbage collector . in r.  j. boulton and p.  b. jackson , editors , _ fourteenth international conference on theorem proving in higher order logics : supplemental proceedings _ , pages 8597 , september 2001 .",
    "report edi ",
    "rr0046 , division of informatics , university of edinburgh .",
    "juan chen , chris hawblitzel , frances perry , mike emmi , jeremy condit , derrick coetzee , and polyvios pratikakis .",
    "type - preserving compilation for large - scale optimizing object - oriented compilers .",
    ", 43(6):183192 , 2008 .",
    "damien doligez and georges gonthier .",
    "portable , unobtrusive garbage collection for multiprocessor systems . in",
    "_ conference record of the twenty - first annual acm symposium on principles of programming languages _ , acm sigplan notices , portland , or , january 1994 .",
    "acm press .",
    "tamar domani , elliot kolodner , and erez petrank . a generational on - the - fly garbage collector for java . in _ proceedings of sigplan 2000 conference on programming languages design and implementation",
    "_ , acm sigplan notices , vancouver , june 2000 .",
    "acm press .",
    "edsgar  w. dijkstra , leslie lamport , a.  j. martin , c.  s. scholten , and e.  f.  m. steffens .",
    "on - the - fly garbage collection : an exercise in cooperation . in _",
    "lecture notes in computer science , no .",
    "46_. springer - verlag , new york , 1976 .",
    "georges gonthier . verifying the safety of a practical concurrent garbage collector . in r.",
    "alur and t.  henzinger , editors , _ computer aided verification cav96 _ , lecture notes in computer science , new",
    "brunswick , nj , 1996 .",
    "springer - verlag .",
    "paul  b. jackson . verifying a garbage collection algorithm . in",
    "_ proceedings of 11th international conference on theorem proving in higher order logics tphols98 _ , volume 1479 of _ lecture notes in computer science _ , pages 225244 , canberra ,",
    "september 1998 .",
    "springer - verlag .",
    "haim kermany and erez petrank .",
    "the compressor : concurrent , incremental and parallel compaction . in",
    "_ proceedings of sigplan 2006 conference on programming languages design and implementation _ , acm sigplan notices , pages 354363 , ottawa , june 2006 .",
    "acm press .",
    "filip pizlo , erez petrank , and bjarne steensgaard . a study of concurrent real - time garbage collectors . in _ proceedings of sigplan 2008 conference on programming languages design and implementation",
    "_ , acm sigplan notices , pages 3344 , tucson , az , june 2008 .",
    "acm press ."
  ],
  "abstract_text": [
    "<S> garbage collectors are notoriously hard to verify , due to their low - level interaction with the underlying system and the general difficulty in reasoning about reachability in graphs . </S>",
    "<S> several papers have presented verified collectors , but either the proofs were hand - written or the collectors were too simplistic to use on practical applications . in this work , we present two mechanically verified garbage collectors , both practical enough to use for real - world c # benchmarks . </S>",
    "<S> the collectors and their associated allocators consist of x86 assembly language instructions and macro instructions , annotated with preconditions , postconditions , invariants , and assertions . </S>",
    "<S> we used the boogie verification generator and the z3 automated theorem prover to verify this assembly language code mechanically . </S>",
    "<S> we provide measurements comparing the performance of the verified collector with that of the standard bartok collectors on off - the - shelf c # benchmarks , demonstrating their competitiveness . </S>"
  ]
}