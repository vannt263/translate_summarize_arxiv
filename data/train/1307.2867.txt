{
  "article_text": [
    "constraint programming ( cp ) is widely used to solve a variety of practical problems such as planning and scheduling @xcite , and industrial configuration @xcite .",
    "the theoretical properties of constraint problems , in particular the computational complexity of different types of problem , have been extensively studied and quite a lot is known about what restrictions on the general _ constraint satisfaction problem _ are sufficient to make it tractable @xcite .",
    "however , much of this theoretical work has focused on problems where each constraint is represented _ explicitly _ , by a table of allowed assignments .    in practice , however , a lot of the success of cp is due to the use of special - purpose constraint types for which the software tools provide dedicated algorithms  @xcite .",
    "such constraints are known as _",
    "global constraints _ and are usually represented _ implicitly _ by an algorithm in the solver .",
    "this algorithm may take as a parameter a _ description _ that specifies exactly which kinds of assignments a particular instance of this constraint should allow .",
    "theoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local _ consistency _ for individual constraints .",
    "this is generally done by pruning from the domains of variables those values that can not lead to a satisfying assignment @xcite .",
    "another strand of research has explored when it is possible to replace global constraints by collections of explicitly represented constraints @xcite .",
    "these techniques allow faster implementations of algorithms for _ individual constraints _ , but do not shed much light on the complexity of problems with multiple _ overlapping _ global constraints , which is something that practical problems frequently require .    as an example , consider the following family of constraint problems involving clauses and cardinality constraints of unbounded arity .",
    "[ example : running ] consider a family of constraint problems on a set of boolean variables @xmath0 ( where @xmath1 ) , with the following five constraints :    * @xmath2 is the binary clause @xmath3 ; * @xmath4 is a cardinality constraint on @xmath5 specifying that exactly one of these variables takes the value 1 ; * @xmath6 is a cardinality constraint on @xmath7 specifying that exactly one of these variables takes the value 1 ; * @xmath8 is a cardinality constraint on @xmath9 specifying that exactly @xmath10 of these variables takes the value 1 ; * @xmath11 is the clause @xmath12 .",
    "this problem is illustrated in figure  [ fig : runningexampleg ] .    ]",
    "this family of problems is not included in any previously known tractable class , but will be shown to be tractable using the results of this paper .",
    "as discussed in  @xcite , when the constraints in a family of problems have unbounded arity , the way that the constraints are _ represented _ can significantly affect the complexity .",
    "previous work in this area has assumed that the global constraints have specific representations , such as propagators  @xcite , negative constraints  @xcite , or gdnf / decision diagrams  @xcite , and exploited properties particular to that representation . in contrast , here we investigate the conditions that yield efficiently solvable classes of constraint problems with global constraints , without requiring any specific representation .",
    "many global constraints have succinct representations , so even problems with very simple structures are known to be hard in some cases @xcite .",
    "we will therefore need to impose some restrictions on the properties of the individual global constraints , as well as on the problem structure .    to obtain our results ,",
    "we define a notion of equivalence on assignments and a new width measure that identifies variables that are constrained in exactly the same way .",
    "we then show that we can replace variables that are equated under our width measure with a single new variable whose domain represents the possible equivalence classes of assignments .",
    "both of these simplification steps , merging variables and equating assignments , can be seen as techniques for eliminating symmetries in the original problem formulation .",
    "we describe some sufficient conditions under which these techniques provide a polynomial - time reduction to a known tractable case , and hence identify new tractable classes of constraint problems involving global constraints .",
    "in order to be more precise about the way in which global constraints are represented , we will extend the standard definition of a constraint problem .",
    "let @xmath13 be a set of variables , each with an associated set of domain elements .",
    "we denote the set of domain elements ( the domain ) of a variable @xmath14 by @xmath15 .",
    "we extend this notation to arbitrary subsets of variables , @xmath16 , by setting @xmath17 .",
    "an _ assignment _ of a set of variables @xmath13 is a function @xmath18 that maps every @xmath19 to an element @xmath20 .",
    "we denote the restriction of @xmath21 to a set of variables @xmath22 by @xmath23 .",
    "we also allow the special assignment @xmath24 of the empty set of variables .",
    "in particular , for every assignment @xmath21 , we have @xmath25 .",
    "global constraints have traditionally been defined , somewhat vaguely , as constraints without a fixed arity , possibly also with a compact representation of the constraint relation . for example , in @xcite a global constraint is defined as `` a constraint that captures a relation between a non - fixed number of variables '' .",
    "below , we offer a precise definition similar to the one in @xcite , where the authors define global constraints for a domain @xmath26 over a list of variables @xmath27 as being given intensionally by a function @xmath28 computable in polynomial time .",
    "our definition differs from this one in that we separate the general _ algorithm _ of a global constraint ( which we call its _ type _ ) from the specific description .",
    "this separation allows us a better way of measuring the size of a global constraint , which in turn helps us to establish new complexity results .",
    "a _ global constraint type _ is a parametrised polynomial - time algorithm that determines the acceptability of an assignment of a given set of variables .",
    "each global constraint type , @xmath29 , has an associated set of _ descriptions _ ,",
    "each description @xmath31 specifies appropriate parameter values for the algorithm @xmath29 .",
    "in particular , each @xmath31 specifies a set of variables , denoted by @xmath32 .    a _ global constraint _ @xmath33 $ ] , where @xmath34 , is a function that maps assignments of @xmath32 to the set @xmath35 . each assignment that is allowed by @xmath33 $ ]",
    "is mapped to 1 , and each disallowed assignment is mapped to 0 .",
    "the _ extension _ or _ constraint relation _ of @xmath33 $ ] is the set of assignments , @xmath21 , of @xmath32 such that @xmath33(\\theta ) = 1 $ ] .",
    "we also say that such assignments _ satisfy _ the constraint , while all other assignments _ falsify _ it .",
    "when we are only interested in describing the set of assignments that satisfy a constraint , and not in the complexity of determining membership in this set , we will sometimes abuse notation by writing @xmath36 $ ] to mean @xmath33(\\theta ) = 1 $ ] .    as can be seen from the definition above , a global constraint is not usually explicitly represented by listing all the assignments that satisfy it . instead",
    ", it is represented by some description @xmath37 and some algorithm @xmath29 that allows us to check whether the constraint relation of @xmath33 $ ] includes a given assignment . to stay within the complexity class",
    ", this algorithm is required to run in polynomial time . as the algorithms for many common global constraints",
    "are built into modern constraint solvers , we measure the _ size _ of a global constraint s representation by the size of its description .",
    "[ example : egc ] a very general global constraint type is the _ extended global cardinality _ constraint type  @xcite .",
    "this form of global constraint is defined by specifying for every domain element @xmath38 a finite set of natural numbers @xmath39 , called the cardinality set of @xmath38 .",
    "the constraint requires that the number of variables which are assigned the value @xmath38 is in the set @xmath39 , for each possible domain element @xmath38 .    using our notation ,",
    "the description @xmath37 of an egc global constraint specifies a function @xmath40 that maps each domain element to a set of natural numbers .",
    "the algorithm for the egc constraint then maps an assignment @xmath21 to @xmath41 if and only if , for every domain element @xmath42 , we have that @xmath43 .    the cardinality constraint @xmath4 from example  [ example : running ] can be expressed as an egc global constraint with description @xmath37 such that @xmath44 , and @xmath45 .",
    "[ example : clauses ] we can view the disjunctive clauses used to define propositional satisfiability problems as a global constraint type in the following way .",
    "the description @xmath37 of a clause is simply a list of the literals that it contains , and @xmath32 is the corresponding set of variables .",
    "the algorithm for the clause then maps any boolean assignment @xmath21 of @xmath32 that satisfies the disjunction of the literals specified by @xmath37 to 1 , and all other assignments to 0 .",
    "note that a clause forbids precisely one assignment to @xmath32 ( the one that falsifies all of the literals in the clause ) .",
    "hence the extension of a clause contains @xmath46 assignments , so the size of the constraint _ relation _ grows exponentially with the number of variables , but the size of the constraint _ description",
    "_ grows only linearly .",
    "[ example : table - const ] a rather degenerate example of a a global constraint type is the _ table _ constraint .    in this case the description @xmath37 is simply a list of assignments of some fixed set of variables , @xmath32 .",
    "the algorithm for a table constraint then decides , for any assignment of @xmath32 , whether it is included in @xmath37 .",
    "this can be done in a time which is linear in the size of @xmath37 and so meets the polynomial time requirement .",
    "_ negative _ constraints are complementary to table constraints , in that they are described by listing",
    "_ forbidden _ assignments .",
    "the algorithm for a negative constraint @xmath33 $ ] decides , for any assignment of @xmath32 , whether it is _ not _ included in @xmath37 .",
    "observe that the clauses described in example  [ example : clauses ] are a special case of the negative constraint type , as they have exactly one forbidden assignment .",
    "we observe that any global constraint can be rewritten as a table or negative constraint .",
    "however , this rewriting will , in general , incur an exponential increase in the size of the description .",
    "an instance of the constraint satisfaction problem ( csp ) is a pair @xmath47 where @xmath13 is a finite set of _ variables _ , and @xmath48 is a set of _ global constraints _ such that for every @xmath33 \\in c$ ] , @xmath49 . in a csp instance , we call @xmath32 the _ scope _ of the constraint @xmath33 $ ] .    a _ solution _ to a csp instance @xmath47 is an assignment @xmath21 of @xmath13 which satisfies every global constraint , i.e. , for every @xmath33 \\in c$ ] we have @xmath50 $ ] .    the general constraint satisfaction problem is clearly np - complete , so in the remainder of the paper we shall look for more restricted versions of the problem that are _ tractable _ , that is , solvable in polynomial time .",
    "first , we are going to consider restrictions on the way that the constraints in a given instance interact with each other , or , in other words , the way that the constraint scopes overlap ; such restrictions are known as _ structural _ restrictions  @xcite .",
    "a hypergraph @xmath51 is a set of vertices @xmath13 together with a set of hyperedges @xmath52 .",
    "given a csp instance @xmath53 , the hypergraph of @xmath54 , denoted @xmath55 , has vertex set @xmath13 together with a hyperedge @xmath32 for every @xmath33 \\in c$ ] .    one special class of hypergraphs that has received a great deal of attention is the class of _ acyclic _ hypergraphs  @xcite .",
    "this notion is a generalisation of the idea of tree - structure in a graph , and has been very important in the analysis of relational databases .",
    "a hypergraph is said to be acyclic if repeatedly removing all hyperedges contained in other hyperedges , and all vertices contained in only a single hyperedge , eventually deletes all vertices @xcite .    solving a csp instance",
    "@xmath54 whose constraints are represented extensionally ( i.e. , as table constraints ) is known to be tractable if the hypergraph of @xmath54 , @xmath55 , is acyclic  @xcite .",
    "indeed , this has formed the basis for more general notions of `` bounded cyclicity ''  @xcite or `` bounded hypertree width ''  @xcite , which have also been shown to imply tractability for problems with explicitly represented constraint relations . however , this is no longer true if the constraints are global , not even when we have a fixed , finite domain , as the following examples show .",
    "[ example : singleegc ] any hypergraph containing only a single edge is clearly acyclic ( and therefore has hypertree width one  @xcite ) , but the class of csp instances consisting of a single egc constraint over an unbounded domain is -complete  @xcite .",
    "[ example:3col ] the -complete problem of 3-colourability @xcite is to decide , given a graph @xmath56 , whether the vertices @xmath13 can be coloured with three colours such that no two adjacent vertices have the same colour .",
    "we may reduce this problem to a csp with egc constraints ( cf .",
    "example  [ example : egc ] ) as follows : let @xmath13 be the set of variables for our csp instance , each with domain @xmath57 . for every edge @xmath58 , we post an egc constraint with scope @xmath59 , parametrised by the function @xmath60 such that @xmath61 .",
    "finally , we make the hypergraph of this csp instance acyclic by adding an egc constraint with scope @xmath13 parametrised by the function @xmath62 such that @xmath63 .",
    "this reduction clearly takes polynomial time , and the hypergraph of the resulting instance is acyclic .",
    "these examples indicate that when dealing with implicitly represented constraints we can not hope for tractability using structural restrictions alone .",
    "we are therefore led to consider _ hybrid _ restrictions , which restrict both the nature of the constraints and the structure at the same time .",
    "a _ constraint catalogue _ is a set of global constraints .",
    "a csp instance @xmath47 is said to be over a constraint catalogue  @xmath64 if for every @xmath33 \\in c$ ] we have @xmath33 \\in { \\ensuremath{\\mathcal c}}$ ] .",
    "previous work on the complexity of constraint problems has restricted the _ extensions _ of the constraints to a specified set of _ relations _ , known as a constraint _ language _  @xcite .",
    "this is an appropriate form of restriction when all constraints are given explicitly , as table constraints .",
    "however , here we work with global constraints where the relations are often implicit , and this can significantly alter the complexity of the corresponding problem classes , as we will illustrate below . hence we allow a more general form of restriction on the constraints by specifying a constraint catalogue  containing all allowed constraints .    [",
    "def : csprestricted ] let @xmath64 be a constraint catalogue , and let @xmath65 be a class of hypergraphs .",
    "we define @xmath66 to be the class of csp instances over @xmath64 whose hypergraphs are in @xmath65 .",
    "using definition  [ def : csprestricted ] , we will restate an earlier structural tractability result , which will form the basis for our results in section  [ sect : main - results ] .",
    "a _ tree decomposition _ of a hypergraph @xmath51 is a pair @xmath67 where @xmath68 is a tree and @xmath69 is a labelling function from nodes of @xmath68 to subsets of @xmath13 , such that    1 .   for every @xmath19",
    ", there exists a node @xmath70 of @xmath68 such that @xmath71 , 2 .   for every hyperedge @xmath72",
    ", there exists a node @xmath70 of @xmath68 such that @xmath73 , and 3 .",
    "for every @xmath19 , the set of nodes @xmath74 induces a connected subtree of @xmath68 .",
    "the _ width _ of a tree decomposition is @xmath75 .",
    "the _ treewidth",
    "_ @xmath76 of a hypergraph @xmath77 is the minimum width over all its tree decompositions .",
    "let @xmath65 be a class of hypergraphs , and define @xmath78 to be the maximum treewidth over the hypergraphs in @xmath79 .",
    "if @xmath80 is unbounded we write @xmath81 ; otherwise @xmath82 .",
    "we can now restate using the language of global constraints the following result , from dalmau et al .",
    "@xcite , which builds on several earlier results  @xcite .",
    "[ thm : dalmau ] let @xmath64 be a constraint catalogue  and @xmath65 a class of hypergraphs .",
    "@xmath83 is tractable if @xmath82 .",
    "observe that the family of constraint problems described in example  [ example : running ] is not covered by the above result , because the treewidth of the associated hypergraphs is unbounded .",
    "whenever constraint scopes overlap , we may ask whether the possible assignments to the variables in the overlap are essentially different . it may be that some assignments extend to precisely the same satisfying assignments in each of the overlapping constraints .",
    "if so , we may as well identify such assignments .",
    "[ def : disjoint - union ] let @xmath84 and @xmath85 be two assignments of disjoint sets of variables @xmath86 and @xmath87 , respectively .",
    "the disjoint union of @xmath84 and @xmath85 , denoted @xmath88 , is the assignment of @xmath89 such that @xmath90 for all @xmath91 , and @xmath92 for all @xmath93 .",
    "let @xmath94 be a set of assignments of a set of variables @xmath13 .",
    "the _ projection _ of @xmath94 onto a set of variables @xmath95 is the set of assignments @xmath96 .",
    "note that when @xmath97 we have @xmath98 for any set @xmath99 , but when @xmath100 and @xmath101 , we have @xmath102 .",
    "let @xmath33 $ ] be a global constraint , and @xmath103 . for every assignment @xmath104 of @xmath99 ,",
    "let @xmath105 ) = \\pi_{{\\ensuremath{\\mathsf{vars}}}(\\delta ) - x}(\\{\\theta \\in e[\\delta ] \\mid    \\theta|_x = \\mu\\})$ ] .    in other words , for any assignment @xmath104 of @xmath99 , the set @xmath105)$ ] is the set of assignments of @xmath106 that extend @xmath104 to a satisfying assignment for @xmath33 $ ] ; i.e. ,  those assignments @xmath21 for which @xmath107 $ ] .",
    "[ def : equiv - tuples ] let @xmath33 $ ] be a global constraint , and @xmath103 .",
    "we say that two assignments @xmath108 to @xmath99 are _ extension equivalent _ on @xmath99 with respect to @xmath33 $ ] if @xmath109 ) = { \\ensuremath{\\mathsf{ext}}}(\\theta_2,e[\\delta])$ ] .",
    "we denote this equivalence relation by @xmath110 , x]$ ] ; that is , @xmath110 , x](\\theta_1 , \\theta_2)$ ] holds if and only if @xmath84 and @xmath85 are extension equivalent on @xmath99 with respect to @xmath33 $ ] .    in other words , two assignments to some subset of the variables of a constraint @xmath33 $ ] are extension equivalent if every assignment to the rest of the variables combines with both of them to give either two assignments that satisfy @xmath33 $ ] , or two that falsify it .",
    "[ example : clauses2classes ] consider the special case of extension equivalence with respect to a clause ( cf .",
    "example  [ example : clauses ] ) .    given",
    "any clause @xmath33 $ ] , and any non - empty set of variables @xmath111 , any assignment to @xmath99 will either satisfy one of the corresponding literals specified by @xmath37 , or else falsify all of them .",
    "if it satisfies at least one of them , then any extension will satisfy the clause , so all such assignments are extension equivalent .",
    "if it falsifies all of them , then an extension will satisfy the clauses if and only if it satifies one of the other literals .",
    "hence the equivalence relation @xmath110 , x]$ ] has precisely 2 equivalence classes , one containing the single assignment that falsifies all the literals corresponding to x , and one containing all other assignments .",
    "let @xmath112 be a set of global constraints .",
    "we write @xmath113 for the set of variables common to all of their scopes , that is , @xmath114",
    "\\in s } { \\ensuremath{\\mathsf{vars}}}(\\delta)$ ] .    for any set @xmath112 of global constraints",
    ", we define the _ join _ of @xmath112 , denoted @xmath115 , to be a global constraint @xmath116 $ ] with @xmath117 \\in s } { \\ensuremath{\\mathsf{vars}}}(\\delta)$ ] such that for any assignment @xmath21 to @xmath118 , we have @xmath119 $ ] if and only if for every @xmath33 \\in s$ ] we have @xmath50 $ ] .",
    "the join of a set of global constraints may have no simple compact description , and computing its extension may be computationally expensive . however , we introduce this construct simply in order to describe the combined effect of a set of global constraints in terms of a single constraint .",
    "let @xmath120 , for some @xmath121 , be a set of variables with @xmath122 , and let @xmath123 , e_2[\\delta_2]\\}$ ] be a set of two global constraints as defined below :    * @xmath124 $ ] is a table constraint with @xmath125 which enforces _ equality _ , i.e. , @xmath126 , where for each @xmath127 and @xmath128 , @xmath129 .",
    "* @xmath130 $ ] is a negative constraint with @xmath131 which enforces a _ not - all - equal _ condition , i.e. , @xmath132 , where for each @xmath127 and @xmath133 , @xmath129 .",
    "we will use substitution notation to write assignments explicitly ; thus , an assignment of @xmath59 that assigns @xmath38 to both variables is written @xmath134 .",
    "we have that @xmath135 .",
    "the equivalence classes of assignments to @xmath113 under @xmath136 $ ] are @xmath137 , @xmath138 , and @xmath139 , each containing the single assignment shown , as well as ( for @xmath140 ) a final class containing all other assignments , for which we can choose an arbitrary representative assignment , @xmath141 , such as @xmath142 .",
    "each assignment in the first 3 classes has just 2 possible extensions that satisfy @xmath115 , since the value assigned to @xmath143 must equal the value assigned to @xmath144 , and the value assigned to @xmath145 must be different .",
    "the assignment @xmath141 has no extensions , since @xmath146 ) = \\emptyset$ ] .",
    "hence the number of equivalence classes in @xmath147 $ ] is at most 4 , even though the total number of possible assignments of @xmath113 is @xmath148    [ def : cooperating - language ] we say that a constraint catalogue  @xmath64 is a _ cooperating _ catalogue  if for any finite set of global constraints @xmath149 , we can compute a set of assignments of the variables @xmath113 containing at least one representative of each equivalence class of @xmath136 $ ] in polynomial time in the size of @xmath113 and the total size of the constraints in @xmath112 .",
    "note that this definition requires two things .",
    "first , that the number of equivalence classes in the equivalence relation @xmath150 $ ] is bounded by some fixed polynomial in the size of @xmath113 and the size of the constraints in @xmath112 . secondly , that a suitable set of representatives for these equivalence classes can be computed efficiently from the constraints .",
    "[ example : clausescooperate ] consider a constraint catalogue  consisting entirely of clauses ( of arbitrary arity ) .",
    "it was shown in example  [ example : clauses2classes ] that for any clause @xmath33 $ ] and any non - empty @xmath103 the equivalence relation @xmath110 , x]$ ] has precisely 2 equivalence classes .",
    "if we consider some finite set , @xmath112 , of clauses , then a similar argument shows that the equivalence relation @xmath136 $ ] has at most @xmath151 classes .",
    "these are given by the single assignments of the variables in @xmath113 that falsify the literals corresponding to the variables of @xmath113 in each clause ( there are at most @xmath152 of these  they may not all be distinct ) together with at most one further equivalence class containing all other assignments ( which must satisfy at least one literal in each clause of @xmath112 ) .",
    "hence the total number of equivalence classes in the equivalence relation @xmath136 $ ] increases at most linearly with the number of clauses in @xmath112 , and a representative for each class can be easily obtained from the descriptions of these clauses , by projecting the falsifying assignments down to the set of common variables , @xmath113 , and adding at most one more , arbitrary , assignment .    by same argument",
    ", if we consider some finite set , @xmath112 , of table constraints , then the equivalence relation @xmath136 $ ] has at most one class for each assignment allowed by each table constraint in @xmath112 , together with at most one further class containing all other assignments .    in general , arbitrary egc constraints ( cf .",
    "example  [ example : egc ] ) do not form a cooperating catalogue .",
    "however , we will show that if we bound the size of the variable domains , then the resulting egc constraints do form a cooperating catalogue .",
    "let @xmath99 be a set of variables with domain @xmath153 .",
    "a _ counting function _ for @xmath99 is any function @xmath154 such that @xmath155 .",
    "every assignment @xmath21 to @xmath99 defines a corresponding counting function @xmath156 given by @xmath157 for every @xmath158 .",
    "it is easy to verify that no egc constraint can distinguish two assignments with the same counting function ; for any egc constraint , either both assignments satisfy it , or they both falsify it .",
    "it follows that two assignments with the same counting function are extension equivalent with respect to egc constraints .",
    "[ def : counting - constraint ] a global constraint @xmath33 $ ] is called a _ counting constraint _ if , for any two assignments @xmath159 of @xmath32 which have the same counting function , either @xmath160 $ ] or @xmath161 $ ] .",
    "egc constraints are not the only constraint type with this property . constraints that require the sum ( or the product ) of the values of all variables in their scope to take a particular value , and constraints that require the minimum ( or maximum ) value of the variables in their scope to take a certain value , are also counting constraints .",
    "another example is given by the nvalue constraint type , which requires that the number of distinct domain values taken by an assignment is a member of a specified set of acceptable numbers .",
    "in an nvalue constraint , @xmath33 $ ] , the description @xmath37 specifies a finite set of natural numbers @xmath162 .",
    "the algorithm @xmath29 maps an assignment @xmath21 to 1 if @xmath163 .",
    "the reason for introducing counting functions is the following key property , previously noted by bulatov and marx @xcite .",
    "[ prop : num - counting - funcs ] the number of possible counting functions for a set of variables @xmath99 is at most @xmath164 , where @xmath165 .",
    "if every variable @xmath166 has @xmath26 as its set of domain elements , that is , @xmath167 , then every counting function corresponds to a distinct way of partitioning @xmath168 variables into at most @xmath169 boxes .",
    "there are @xmath170 ways of doing so ( * ? ? ?",
    "* section  2.3.3 ) . on the other hand , if there are variables @xmath166 such that @xmath171 , then that disallows some counting functions .",
    "[ thm : coop - language ] any constraint catalogue  that contains only counting constraints with bounded domain size , table constraints , and negative constraints , is a cooperating catalogue .    let @xmath64 be a constraint catalogue  containing only global constraints of the specified types , and let @xmath172 be a finite subset of @xmath64 .",
    "partition @xmath112 into two subsets : @xmath173 , containing only counting constraints and @xmath174 containing only table and negative constraints .",
    "let @xmath175 be a set containing assignments of @xmath113 , such that for every counting function @xmath60 for @xmath113 , there is some assignment @xmath176 with @xmath177 . by property  [ prop : num - counting - funcs ] , the number of counting functions for @xmath113 is bounded by @xmath178 , where @xmath179 is the bound on the domain size for the counting constraints in @xmath64 .",
    "hence such a set @xmath175 can be computed in polynomial time in the size of @xmath113 .",
    "for each constraint in @xmath174 we have that the description is a list of assignments ( these are the allowed assignments for the table constraints and the forbidden assignments for the negative constraints , see example  [ example : table - const ] ) .",
    "as we described in example  [ example : clausescooperate ] , for each table constraint @xmath33 \\in s$ ] , we can obtain a representative for each equivalence class of @xmath110 , { \\ensuremath{\\mathsf{iv}}}(s)]$ ] by taking the projection onto @xmath113 of each allowed assignment , which we can denote by @xmath180 , together with at most one further , arbitrary , assignment , @xmath141 , that is not in this set .",
    "this set of assignments contains at least one representative for each equivalence class of @xmath110 , { \\ensuremath{\\mathsf{iv}}}(s)]$ ] ( and possibly more than one representative for some of these classes ) .    similarly , for each negative constraint @xmath33",
    "\\in s$ ] , we can obtain a representative for each equivalence class of @xmath110 , { \\ensuremath{\\mathsf{iv}}}(s)]$ ] , by taking the projection onto @xmath113 of each forbidden assignment , which we can again denote by @xmath180 , together with at most one further , arbitrary , assignment , @xmath141 , that is not in this set .",
    "now consider the set of assignments @xmath181 \\in s^{\\pm } }    \\pi_{{\\ensuremath{\\mathsf{iv}}}(s)}(\\delta)$ ] , where @xmath141 is an arbitrary assignment of @xmath113 which does not occur in @xmath180 for any @xmath33 \\in s$ ] ( if such an assignment exists ) .",
    "we claim that this set of assignments contains at least one representative for each equivalence class of @xmath136 $ ] ( and possibly more than one for some classes ) .",
    "to establish this claim we will show that any assignment @xmath21 of @xmath113 that is not in @xmath182 must be extension equivalent to some member of @xmath182 .",
    "let @xmath21 be an assignment of @xmath113 that is not in @xmath182 ( if such an assignment exists ) .",
    "if @xmath174 contains any positive constraints , then @xmath21 has an empty set of extensions to these constraints , and hence is extension equivalent to @xmath141 .",
    "otherwise , any extension of @xmath21 will satisfy all negative constraints in @xmath174 , so the extensions of @xmath21 that satisfy @xmath115 are completely determined by the counting function @xmath156 . in this case",
    "@xmath21 will be extension equivalent to some element of @xmath175 .",
    "moreover , the set of assignments @xmath182 can be computed from @xmath112 in polynomial time in the the size of @xmath113 and the total size of the descriptions of the constraints in @xmath174 .",
    "therefore , @xmath64 is a cooperating catalogue  as described in definition  [ def : cooperating - language ] .",
    "[ example : runningcooperates ] by theorem  [ thm : coop - language ] , the constraints in example  [ example : running ] form a cooperating catalogue .",
    "in this section , we will show that , for any constraint problem over a cooperating catalogue , a set of variables that all occur in exactly the same set of constraint scopes can be replaced by a single new variable with an appropriate domain , to give a polynomial - time reduction to a smaller problem .",
    "let @xmath183 be a hypergraph .",
    "the _ dual _ @xmath184 of @xmath77 is a hypergraph with vertex set @xmath185 and a hyperedge @xmath186 for every @xmath19 . for a class @xmath65 of hypergraphs , let @xmath187 .",
    "[ example : dual ] consider the hypergraph @xmath77 in figure  [ fig : runningexampleg ] .",
    "the dual , @xmath184 , of this hypergraph has vertex set @xmath188 and five hyperedges @xmath189 , @xmath190 , @xmath191 , @xmath192 and @xmath193 .",
    "this transformation is illustrated in figure  [ fig : runningexamplegtogd ] .     and",
    "@xmath194 from example  [ example : dual],scaledwidth=80.0% ]    note that the dual of the dual of a hypergraph is not necessarily the original hypergraph , since we do not allow multiple identical hyperedges .",
    "[ example : dualdual ] consider the dual hypergraph @xmath184 defined in example  [ example : dual ]",
    ". taking the dual of this hypergraph yields @xmath195 , with vertex set @xmath196 ( corresponding to the 5 hyperedges in @xmath184 ) and 5 distinct hyperedges , as shown in figure  [ fig : runningexamplegdtogdd ] .     and",
    "@xmath195 from example  [ example : dualdual],scaledwidth=80.0% ]    in the example above , taking the dual of a hypergraph twice had the effect of merging precisely those sets of variables that occur in the same set of hyperedges .",
    "it is easy to verify that this is true in general : taking the dual twice equates precisely those variables that occur in the same set of hyperedges .",
    "[ lem : dual - vars ] for any hypergraph @xmath77 , the hypergraph @xmath195 has precisely one vertex corresponding to each maximal subset of vertices of @xmath77 that occur in the same set of hyperedges .",
    "next , we combine the idea of the dual with the usual notion of treewidth to create a new measure of width .",
    "[ def : tdd ] let @xmath77 be a hypergraph .",
    "the treewidth of the dual of the dual ( twdd ) of @xmath77 is @xmath197 .    for a class of hypergraphs @xmath65",
    ", we define @xmath198 .",
    "[ example : runningtwdd ] consider the class @xmath65 of hypergraphs of the family of problems described in example  [ example : running ] .",
    "whatever the value of @xmath199 , the dual hypergraph , @xmath184 is the same , as shown in figure  [ fig : runningexamplegtogd ] .",
    "hence for all problems in this family the hypergraph @xmath195 is as shown in figure  [ fig : runningexamplegdtogdd ] , and can be shown to have treewidth 3 .",
    "hence @xmath200 .",
    "when replacing a set of variables in a csp instance with a single variable , we will use the following definition .",
    "[ def : equiv - repr ] let @xmath201 be a csp instance and @xmath95 be a non - empty subset of variables that all occur in the scopes of the same set @xmath112 of constraints .",
    "the _ quotient _ of @xmath54 with respect to @xmath99 , denoted @xmath202 , is defined as follows .",
    "* the variables of @xmath202 are given by @xmath203 , where @xmath204 is a fresh variable , and the domain of @xmath204 is the set of equivalence classes of @xmath205 $ ] .",
    "* the constraints of @xmath202 are unchanged , except that each constraint @xmath33 \\in s$ ] is replaced by a new constraint @xmath206 $ ] , where @xmath207 . for any assignment @xmath21 of @xmath208",
    ", we define @xmath206(\\theta)$ ] to be 1 if and only if @xmath209 $ ] , where @xmath104 is a representative of the equivalence class @xmath210 .",
    "we note that , by definition  [ def : equiv - tuples ] , the value of @xmath206 $ ] specified in definition  [ def : equiv - repr ] is well - defined , that is , it does not depend on the specific representative chosen for the equivalence class @xmath210 , since each representative has the same set of possible extensions .",
    "[ lem : equiv - repr ] let @xmath201 be a csp instance and @xmath95 be a non - empty subset of variables that all occur in the scopes of the same set of constraints .",
    "the instance @xmath202 has a solution if and only if @xmath54 has a solution .",
    "let @xmath53 and @xmath99 be given , and let @xmath211 be the set of constraints @xmath33 $ ] such that @xmath103 .",
    "construct the instance @xmath202 as specified in definition  [ def : equiv - repr ] . any solution to @xmath54",
    "can be converted into a corresponding solution for @xmath202 , and vice versa .",
    "this conversion process just involves replacing the part of the solution assignment that gives values to the variables in the set @xmath99 with an assignment that gives a suitable value to the new variable @xmath204 .",
    "[ thm : dd - csp ] any csp instance @xmath54 can be converted to an instance @xmath212 with @xmath213 , such that @xmath212 has a solution if and only if @xmath54 does . moreover , if @xmath54 is over a cooperating catalogue , this conversion can be done in polynomial time .",
    "let @xmath201 be a csp instance .",
    "for each variable @xmath19 we define @xmath214 \\in c \\mid v \\in { \\ensuremath{\\mathsf{vars}}}(\\delta)\\}$ ] we then partition the vertices of @xmath54 into subsets @xmath215 , where each @xmath216 is a maximal subset of variables @xmath14 that share the same value for @xmath217 .",
    "we initially set @xmath218 .",
    "then , for each @xmath216 in turn , we set @xmath219 .",
    "finally we set @xmath220 . by lemma  [ lem : dual - vars ] , @xmath213 , and by lemma  [ lem : equiv - repr ]",
    ", @xmath212 has a solution if and only if @xmath54 has a solution .",
    "finally , if @xmath54 is over a cooperating catalogue , then by definition  [ def : cooperating - language ] , we can compute the domains of each new variable introduced in polynomial time in the size of each @xmath216 and the total size of the constraints .",
    "hence we can compute @xmath212 in polynomial time .    using theorem  [ thm : dd - csp ]",
    ", we can immediately get a new tractable csp class by extending theorem  [ thm : dalmau ] .",
    "[ thm : tractable - hyp - class ] let @xmath64 be a constraint catalogue  and @xmath79 a class of hypergraphs .",
    "@xmath83 is tractable if @xmath64 is a cooperating catalogue and @xmath221 .",
    "let @xmath64 be a cooperating catalogue , @xmath65 a class of hypergraphs such that @xmath221 , and @xmath222 .",
    "reduce @xmath54 to a csp instance @xmath212 using theorem  [ thm : dd - csp ] . by definition",
    "[ def : tdd ] , since @xmath213 , @xmath223 , which means that @xmath212 satisfies the conditions of theorem  [ thm : dalmau ] , and hence can be solved in polynomial time .",
    "recall the family of constraint problems described in example  [ example : running ] at the start of this paper .",
    "since the constraints in this problem form a cooperating catalogue   ( example  [ example : runningcooperates ] ) , and all instances have bounded twdd ( example  [ example : runningtwdd ] ) , this family of problems is tractable by theorem  [ thm : tractable - hyp - class ] .",
    "we have identified a novel tractable class of constraint problems with global constraints .",
    "in fact , our results generalize several previously studied classes of problems  @xcite . moreover , this is the first representation - independent tractability result for constraint problems with global constraints .",
    "our new class is defined by restricting both the nature of the constraints and the way that they interact .",
    "as demonstrated in example  [ example : singleegc ] , instances with a single global constraint may already be -complete @xcite , so we can not hope to achieve tractability by structural restrictions alone . in other words , notions such as bounded degree of cyclicity",
    "@xcite or bounded hypertree width  @xcite are not sufficient to ensure tractability in the framework of global constraints , where the arity of individual constraints is unbounded .",
    "this led us to introduce the notion of a cooperating constraint catalogue , which is sufficiently restricted to ensure that an individual constraint is always tractable .",
    "however , this restriction on the nature of the constraints is still not enough to ensure tractability on any structure : example  [ example:3col ] demonstrates that not all structures are tractable even with a cooperating constraint catalogue .",
    "in fact , a family of problems with acyclic structure ( hypertree width one ) over a cooperating constraint catalogue  can still be np - complete . this led us to investigate restrictions on the structure that are sufficient to ensure tractability for all instances over a cooperating catalogue .",
    "in particular , we have shown that it is sufficient to ensure that the dual of the dual of the hypergraph of the instance has bounded treewidth .",
    "an intriguing open question is whether there are other restrictions on the nature of the constraints or the structure of the instances that are sufficient to ensure tractability in the framework of global constraints .",
    "very little work has been done on this question , apart from the pioneering work of bulatov and marx  @xcite , which considered only a single global cardinality constraint , along with arbitrary table constraints , and of chen and dalmau  @xcite on two specific succinct representations .",
    "almost all other previous work on tractable classes has considered only table constraints .",
    "this may be one reason why such work has had little practical impact on the design of constraint solvers , which rely heavily on the use of in - built special - purpose global constraints .",
    "aschinger , m. , drescher , c. , friedrich , g. , gottlob , g. , jeavons , p. , ryabokon , a. , thorstensen , e. : optimization methods for the partner units problem . in : proc .",
    "lncs , vol .",
    "6697 , pp .",
    "419 . springer ( 2011 )    aschinger , m. , drescher , c. , gottlob , g. , jeavons , p. , thorstensen , e. : structural decomposition methods and what they are good for . in : schwentick , t. , drr , c. ( eds . ) proc .",
    "lipics , vol .  9 , pp .",
    "1228 ( 2011 )                                            van hoeve , w.j . ,",
    "katriel , i. : global constraints . in : rossi , f. , van beek , p. , walsh , t. ( eds . ) handbook of constraint programming , foundations of artificial intelligence , vol .  2 , chap .",
    "elsevier ( 2006 )"
  ],
  "abstract_text": [
    "<S> we study the complexity of constraint satisfaction problems involving global constraints , i.e. ,  special - purpose constraints provided by a solver and represented implicitly by a parametrised algorithm . such constraints are widely used ; indeed , they are one of the key reasons for the success of constraint programming in solving real - world problems .    </S>",
    "<S> previous work has focused on the development of efficient propagators for individual constraints . in this paper </S>",
    "<S> , we identify a new tractable class of constraint problems involving global constraints of unbounded arity . </S>",
    "<S> to do so , we combine structural restrictions with the observation that some important types of global constraint do not distinguish between large classes of equivalent solutions . </S>"
  ]
}