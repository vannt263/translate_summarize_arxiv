{
  "article_text": [
    "the importance of models inspired from the field of game theory is nowadays well - established in theoretical computer science .",
    "they allow to describe and analyse the possible interactions of antagonistic agents ( or players ) as in the _ controller synthesis _ problem , for instance .",
    "this problem asks , given a model of the environment of a system , and of the possible actions of a controller , to compute a controller that constraints the environment to respect a given specification .",
    "clearly , one can not , in general , assume that the two players ( the environment and the controller ) will collaborate , hence the need to find a _ controller strategy _ that enforces the specification _ whatever the environment does_. this question thus reduces to computing a so - called winning strategy for the corresponding player in the game model .    in order to describe precisely the features of complex computer systems , several game models have been considered in the literature .",
    "in this work , we focus on the model of priced timed games  @xcite ( ptgs for short ) , which can be regarded as an extension ( in several directions ) of classical finite automata . first , like timed automata  @xcite , ptgs have _ clocks _ , which are real - valued variables whose values evolve with time elapsing , and which can be tested and reset along the transitions .",
    "second , the locations are associated with price - rates and transitions are labeled by discrete prices , as in priced timed automata  @xcite . these prices allow one to associate a _ cost _ with all runs ( or plays ) , which depends on the sequence of transitions traversed by the run , and on the time spent in each visited location .",
    "finally , a ptgis played by two players , called @xmath0 and @xmath1 , and each location of the game is owned by either of them ( we consider a turn - based version of the game ) .",
    "the player who controls the current location decides how long to wait , and which transition to take .    in this",
    "setting , the goal of @xmath0 is to reach a given set of target locations , following a play whose cost is as small as possible .",
    "player @xmath1 has an antagonistic objective : he tries to avoid the target locations , and , if not possible , to maximise the accumulated cost up to the first visit of a target location . to reflect these objectives",
    ", we define the upper value @xmath2 of the game as a mapping of the configurations of the ptgto the least cost that @xmath0 can guarantee while reaching the target , whatever the choices of @xmath1 .",
    "similarly , the lower value @xmath3 returns the greatest cost that @xmath1 can ensure ( letting the cost being @xmath4 in case the target locations are not reached ) .",
    "ccc    ( q1 ) ; ( q2 ) ; ( q3 ) ; ( q4 ) ; ( q5 ) ; ( q6 ) ; ( q7 ) ; ( qf ) ;    ( q1 ) edge ( q2 ) ( q2 ) edge ( q3 ) ( q2 ) edge ( q5 ) ( q5 ) edge ( q6 ) ( q6 ) edge node[above ] @xmath5 ( q1 ) ( q5 ) edge[bend right=15 ] node[pos=.7,above , xshift=2 mm ] @xmath6 ( q7 ) ( q3 ) edge node[above right , xshift=-2 mm ] @xmath7 ( q7 ) ( q3 ) edge ( q1 ) ( q3 ) edge ( q4 ) ( q4 ) edge node[below left ] @xmath8 ( qf ) ( q7 ) edge ( qf ) ( q1 ) edge[bend left=40 ] ( qf ) ;    ( 1.3,-2 ) rectangle ( 5.6,1 ) ;    & &    ( 6,-5 )  ( 10.5,-5 ) node[anchor = north ] @xmath9 ; ( 6,-5 ) node[anchor = south ] @xmath10 ( 7,-5 ) node[anchor = south ] @xmath11 ( 8,-5 ) node[anchor = south ] @xmath12 ( 9,-5 ) node[anchor = south ] @xmath13 ( 9.6,-5 ) node[anchor = south ] @xmath14 ( 10,-5 ) node[anchor = south ] @xmath5 ;    ( 6,-5 )  ( 6,-9 ) node[anchor = west ] @xmath15 ; ( 6,-8.3 ) node[anchor = east ] @xmath16 ( 6,-7.3 ) node[anchor = east ] @xmath17 ( 6,-6.7 ) node[anchor = east ] @xmath18 ( 6,-5.6 ) node[anchor = east ] @xmath19 ( 6,-5.1 ) node[anchor = east ] @xmath20 ;    ( 6,-8.3 )  ( 7,-7 )  ( 8,-6.85)(9,-5.6)(9.6,-5.1)(10,-5 ) ;    ( 7,-7 )  ( 6,-7 ) ; ( 7,-7 )  ( 7,-5 ) ; ( 8,-6.85 ) ",
    "( 6,-6.85 ) ; ( 8,-6.85 ) ",
    "( 8,-5 ) ; ( 9,-5.6 ) ",
    "( 6,-5.6 ) ; ( 9,-5.6 ) ",
    "( 9 , -5 ) ; ( 9.6,-5.1 ) ",
    "( 6,-5.1 ) ; ( 9.6,-5.1 ) ",
    "( 9.6,-5 ) ;    an example of ptgis given in figure  [ fig : ex - ptg2 ] , where the locations of @xmath0 ( respectively , @xmath1 ) are represented by circles ( respectively , rectangles ) , and the integers next to the locations are their price - rates , i.e. , the cost of spending one time unit in the location .",
    "moreover , there is only one clock @xmath21 in the game , which is never reset and all guards on transitions are @xmath22 $ ] ( hence this guard is not displayed and transitions are only labeled by their respective discrete cost ) : this is an example of _ simple priced timed game _ , as we will define them properly later .",
    "it is easy to check that @xmath0 can force reaching the target location @xmath23 from all configurations @xmath24 of the game , where @xmath25 is a location and @xmath9 is a real valuation of the clock in @xmath26 $ ] .",
    "let us comment on the optimal strategies for both players . from a configuration @xmath27 , with",
    "@xmath28 $ ] , @xmath1 better waits until the clock takes value @xmath5 , before taking the transition to @xmath29 ( he is forced to move , by the rule of the game ) .",
    "hence , @xmath1 s optimal value is @xmath30 from all configurations @xmath27 .",
    "symmetrically , it is easy to check that @xmath0 better waits as long as possible in @xmath31 , hence his optimal value is @xmath32 from all configurations @xmath33 .",
    "however , optimal value functions are not always _ that simple _ , see for instance the lower value function of @xmath34 on the right of figure  [ fig : ex - ptg2 ] , which is a piecewise affine function . to understand why value functions can be piecewise affine , consider the sub - game enclosed in the dotted rectangle in figure  [ fig : ex - ptg2 ] , and consider the value that @xmath0 can guarantee from a configuration of the form @xmath35 in this sub - game .",
    "clearly , @xmath0 must decide how long he will spend in @xmath36 and whether he will go to @xmath37 or @xmath31 .",
    "his optimal value from all @xmath35 is thus @xmath38 . since @xmath39 if and only if @xmath40 , the best choice of @xmath0 is to move instantaneously to @xmath31 if @xmath41 $ ] and to move instantaneously to @xmath37 if @xmath42 $ ] , hence the value function of @xmath36 ( in the subgame ) is a piecewise affine function with two pieces .",
    "[ [ related - work . ] ] related work .",
    "ptgs were independently investigated in @xcite and @xcite . for ( non - necessarily turn - based ) ptgs with _ non - negative _ prices , semi - algorithms are given to decide the _ value problem _ that is to say , whether the lower value of a location ( the best cost that @xmath0 can guarantee in valuation @xmath10 ) , is below a given threshold .",
    "they also showed that , under the _ strongly non - zeno assumption _ on prices ( asking the existence of @xmath43 such that every cycle in the underlying region graph has a cost at least @xmath44 ) , the proposed semi - algorithms always terminate . this assumption was justified in @xcite by showing that , in the absence of non - zeno assumption , the _ existence problem _ , that is to decide whether @xmath0 has a strategy guaranteeing to reach a target location with a cost below a given threshold , is indeed undecidable for ptgs with non - negative prices and three or more clocks .",
    "this result was recently extended in @xcite to show that the _ value problem _ is also undecidable for ptgs with non - negative prices and four or more clocks . in @xcite ,",
    "the undecidability of the existence problem has also been shown for ptgs with arbitrary price - rates ( without prices on transitions ) , and two or more clocks . on a positive side",
    ", the value problem was shown decidable by @xcite for ptgs with one clock when the prices are non - negative : a 3-exponential time algorithm was first proposed , further refined in @xcite into an exponential time algorithm .",
    "the key point of those algorithms is to reduce the problem to the computation of optimal values in a restricted family of ptgs called _ simple priced timed games _ ( sptgs for short ) , where the underlying automata contain no guard , no reset , and the play is forced to stop after one time unit .",
    "more precisely , the ptgis decomposed into a sequence of sptgs whose value functions are computed and re - assembled to yield the value function of the original ptg . alternatively , and with radically different techniques , a pseudo - polynomial time algorithm to solve one - clock ptgs with arbitrary prices on transitions , and price - rates restricted to two values amongst @xmath45 ( with @xmath46 ) was given in @xcite .",
    "[ [ contributions . ] ] contributions .    following the decidability results sketched above ,",
    "we consider ptgs with one clock .",
    "we extend those results by considering arbitrary ( positive and negative ) prices .",
    "indeed , all previous works on ptgs with only one clock ( except @xcite ) have considered non - negative weights only , and the status of the more general case with arbitrary weights has so far remained elusive . yet , arbitrary weights are an important modeling feature .",
    "consider , for instance , a system which can consume but also produce energy at different rates . in this case",
    ", energy consumption could be modeled as a positive price - rate , and production by a negative price - rate .",
    "we propose an _ exponential time algorithm to compute the value of one - clock sptgs with arbitrary weights_. while this result might sound limited due to the restricted class of simple ptgs we can handle , we recall that the previous works mentioned above @xcite have demonstrated that solving sptgs is a key result towards solving more general ptgs",
    ". moreover , this algorithm is , as far as we know , the first to handle the full class of sptgs with arbitrary weights , and we note that the solutions ( either the algorithms or the proofs ) known so far do not generalise to this case .",
    "finally , as a side result , this algorithm allows us to solve the more general class of _ reset - acyclic _ one - clock ptgs that we introduce .",
    "thus , although we can not ( yet ) solve the whole class of ptgs with arbitrary weights , our result may be seen as a potentially important milestone towards this goal .",
    "some proofs and technical details are in the appendix .",
    "[ [ notations - and - definitions . ] ] notations and definitions .",
    "let @xmath21 denote a positive real - valued variable called",
    "_ clock_. a _ guard _ ( or _ clock constraint _ ) is an interval with endpoints in @xmath47 .",
    "we often abbreviate guards , for instance @xmath48 instead of @xmath49 $ ] .",
    "let @xmath50 be a finite set of guards .",
    "we let @xmath51\\!]\\xspace}}=\\bigcup_{i\\in s } i$ ] . assuming @xmath52",
    "are all the endpoints of the intervals in  @xmath53 ( to which we add @xmath10 ) , we let @xmath54 be the set of _ regions _ of @xmath53 . observe that @xmath55 is also a set of guards .",
    "we rely on the notion of _ cost function _ to formalise the notion of optimal value function sketched in the introduction .",
    "formally , for a set of guards @xmath50 , a _ cost function _ over @xmath53 is a function @xmath56\\!]\\xspace } } \\to { \\ensuremath{\\overline{{\\ensuremath{\\mathbf{r}}}}}}= { \\ensuremath{\\mathbf{r}}}\\cup \\{+\\infty,-\\infty\\}$ ] such that over all regions @xmath57 , @xmath58 is either infinite or a continuous piecewise affine function , with a finite set of cutpoints ( points where the first derivative is not defined ) @xmath59 , and with @xmath60 for all @xmath61 .",
    "in particular , if @xmath62 contains @xmath4 ( respectively , @xmath63 ) for some region @xmath64 , then @xmath65 ( @xmath66 ) .",
    "we denote by @xmath67 the set of all cost functions over @xmath53 . in our algorithm to solve sptgs , we will need to combine cost functions thanks to the @xmath68 operator .",
    "let @xmath69 and @xmath70 be two costs functions on set of guards @xmath71 , such that @xmath51\\!]\\xspace } } \\cap { \\ensuremath{[\\![s']\\!]\\xspace}}$ ] is a singleton .",
    "we let @xmath72 be the cost function in @xmath73 such that @xmath74 for all @xmath75\\!]\\xspace}}$ ] , and @xmath76 for all @xmath77\\!]\\xspace}}\\setminus{\\ensuremath{[\\![{\\ensuremath{\\mathsf{reg}_{s}}}]\\!]\\xspace}}$ ] .",
    "we consider an extended notion of one - clock priced timed games ( ptgs for short ) allowing for the use of _ urgent locations _ , where only a zero delay can be spent , and _ final cost functions _ which are associated with each final location and incur an extra cost to be paid when ending the game in this location .",
    "formally , a ptg@xmath78 is a tuple @xmath79 where    @xmath80 ( respectively , @xmath81 ) is a finite set of _ locations _ for player @xmath0 ( respectively , @xmath1 ) , with @xmath82 ;    @xmath83 is a finite set of _ final _ locations , and we let @xmath84 be the whole location space ;    @xmath85 indicates _ urgent _ locations . ] ;    @xmath86 is a finite set of _ transitions _ ;    @xmath87 associates to each @xmath88 its _ final cost function _ , that is an affine cost function @xmath89 over @xmath90 ;    @xmath91 mapping an integer _",
    "price _ to each location  its _ price - rate_and transition .",
    "intuitively , a transition @xmath92 changes the current location from @xmath93 to @xmath94 if the clock has value in @xmath95 and the clock is reset according to the boolean @xmath96 .",
    "we assume that , in all ptgs , the clock @xmath21 is _ bounded _ , i.e. , there is @xmath97 such that for all guards @xmath98 , @xmath99 $ ] . can be turned into an equivalent ( with respect to reachability properties ) @xmath100 whose clocks are bounded @xcite , this technique can not be applied to ptgs , in particular with arbitrary prices . ]",
    "we denote by @xmath101 the set @xmath102 of _ regions of _ @xmath78 .",
    "we further denote in the subscript of several notations when the game is clear from the context .",
    "] by @xmath103 , @xmath104 and @xmath105 respectively the values @xmath106 , @xmath107 and @xmath108 } \\max_{{\\ensuremath{\\ell}}\\in{\\ensuremath{l } } }     that is , @xmath103 , @xmath104 and @xmath105 are the largest absolute values of the location prices , transition prices and final cost functions .",
    "let @xmath109 be a ptg .",
    "a _ configuration _ of @xmath78 is a pair @xmath110 .",
    "we denote by @xmath111the set of configurations of @xmath78 .",
    "let @xmath112 and @xmath113 be two configurations .",
    "let @xmath114 be a transition of @xmath78 and @xmath115 be a delay .",
    "then , there is a @xmath116-transition from @xmath112 to @xmath113 with cost @xmath117 , denoted by @xmath118 , if    @xmath119 implies @xmath120 ;    @xmath121 ;    @xmath122 implies @xmath123 ;    @xmath124 implies @xmath125 ;    @xmath126 .    observe that the cost of @xmath116 takes into account the price - rate of  @xmath93 , the delay spent in @xmath93 , and the price of @xmath127 .",
    "we assume that the game has no deadlock : for all @xmath128 , there are @xmath129 and @xmath130 such that @xmath131 .",
    "finally , we write @xmath132 whenever there are @xmath133 and @xmath127 such that @xmath131 .",
    "play _ of @xmath134is a finite or infinite path @xmath135 . for a finite play @xmath136 ,",
    "we let @xmath137 . for an infinite play @xmath135 , we let @xmath138 be the least position @xmath139 such that @xmath140 if such a position exists , and @xmath141 otherwise . then , we let @xmath142 be the _ cost _ of @xmath143 , with @xmath144 if @xmath141 , and @xmath145 otherwise .    a _ strategy _ for player @xmath0 is a function @xmath146 mapping every finite play ending in location of @xmath0 to a pair @xmath147 , indicating what @xmath0 should play .",
    "we also request that the strategy proposes only valid pairs @xmath116 , i.e. , that for all runs @xmath148 ending in @xmath112 , @xmath149 implies that @xmath150 .",
    "strategies @xmath151 of player @xmath1 are defined accordingly .",
    "we let @xmath152 and @xmath153 be the sets of strategies of @xmath0 and @xmath1 , respectively . a pair of strategies @xmath154",
    "is called a _ profile of strategies_. together with an initial configuration @xmath155 , it defines a unique play @xmath156 where for all @xmath157 , @xmath158 is the unique configuration such that @xmath159 with @xmath160 if @xmath161 ; and @xmath162 if @xmath163 .",
    "we let @xmath164 ( respectively , @xmath165 ) be the set of plays that conform with @xmath146 ( and start in  @xmath166 ) .",
    "as sketched in the introduction , we consider optimal reachability - cost games on ptgs , where the aim of player @xmath0 is to reach a location of @xmath83 while minimising the cost .",
    "to formalise this objective , we let the value of a strategy @xmath146 for @xmath0 be the function @xmath167 such that for all @xmath128 : @xmath168 . intuitively , @xmath169 is the largest value that @xmath1 can achieve when playing against strategy @xmath146 of @xmath0 ( it is thus a worst case from the point of view of @xmath0 ) .",
    "symmetrically , for @xmath170 , @xmath171 , for all @xmath128 .",
    "then , the _ upper and lower values _ of @xmath78 are respectively the functions @xmath172 and @xmath173 where , for all @xmath174 , @xmath175 and @xmath176 .",
    "we say that a game is _ determined _ if the lower and the upper values match for every configuration @xmath177 , and in this case , we say that the optimal value @xmath178 of the game @xmath78 exists , defined by @xmath179 .",
    "a strategy @xmath146 of @xmath0 is _ optimal _",
    "( respectively , @xmath180-_optimal _ ) if @xmath181 ( @xmath182 ) , i.e. , @xmath146 ensures that the cost of the plays will be at most @xmath183 ( @xmath184 ) .",
    "symmetrically , a strategy @xmath151 of @xmath1 is _ optimal _",
    "( respectively , @xmath180-_optimal _ ) if @xmath185 ( @xmath186 ) .    [",
    "[ properties - of - the - value . ] ] properties of the value .",
    "let us now prove useful preliminary properties of the value function of ptgs , that  as far as we know  had hitherto never been established . using a general determinacy result by gale and stewart @xcite",
    ", we can show that ptgs ( with one clock ) are _",
    "determined_. hence , the value function @xmath178 exists for all ptg@xmath78 .",
    "we can further show that , for all locations  @xmath93 , @xmath187 is a _ piecewise continuous function _ that might exhibit discontinuities _ only on the borders of the regions _ of @xmath101 ( where @xmath187 is the function such that @xmath188 for all @xmath189 ) .",
    "see appendix  [ app : continuity - of - val ] for detailed proofs of these results .",
    "the continuity holds only in the case of ptgs with a single clock .",
    "an example with two clocks and a value function exhibiting discontinuities inside a region is in appendix  [ app : pas - continu2 ] .",
    "[ thm : determined ] [ prop : continuity - of - val ] for all ( one - clock ) ptgs @xmath78 :    @xmath190 , i.e. , ptgs are _ determined _ ; and    for all @xmath191 , for all @xmath192 , @xmath187 is either infinite or continuous over @xmath64 .",
    "[ [ simple - priced - timed - games . ] ] simple priced timed games .",
    "as sketched in the introduction , our main contribution is to solve the special case of simple one - clock priced timed games with arbitrary costs .",
    "formally , an @xmath193-sptg , with @xmath194 $ ] , is a ptg@xmath109 such that for all transitions @xmath195 , @xmath196 $ ] and @xmath124 .",
    "hence , transitions of @xmath193-sptgs are henceforth denoted by @xmath197 , dropping the guard and the reset .",
    "then , an sptgis a @xmath5-sptg .",
    "this paper is devoted mainly to proving the following theorem on sptgs :    [ thm : main - result ] let @xmath78 be an sptg .",
    "then , for all locations @xmath198 , the function @xmath187 is either infinite , or continuous and piecewise - affine with at most an exponential number of cutpoints .",
    "the value functions for all locations , as well as a pair of optimal strategies @xmath199 ( that always exist if no values are infinite ) can be computed in exponential time .    before sketching the proof of this theorem",
    ", we discuss a class of ( simple ) strategies that are sufficient to play optimally . roughly speaking ,",
    "@xmath200has always a _ memoryless _ optimal strategy , while @xmath201might need _",
    "( finite ) memory _ to play optimally  it is already the case in untimed quantitative reachability games with arbitrary weights ( see appendix  [ app : ex - jf ] ) .",
    "moreover , these strategies are finitely representable ( recall that even a memoryless strategy depends on the current _ configuration _ and that there are infinitely many in our time setting ) .",
    "we formalise @xmath1 s strategies with the notion of _ finite positional strategy _ ( fp - strategy ) : they are memoryless strategies @xmath202 ( i.e. , for all finite plays @xmath203 and @xmath204 ending in the same configuration , we have @xmath205 ) , such that for all locations @xmath93 , there exists a finite sequence of rationals @xmath206 and a finite sequence of transitions @xmath207 such that    for all @xmath208 , for all @xmath209 $ ] , either @xmath210 , or @xmath211 ( assuming @xmath212 ) ; and    if @xmath213 , then @xmath214 .",
    "we let @xmath215 be the set of @xmath216 for all @xmath93 and @xmath139 , and @xmath217 be the set of all successive intervals generated by @xmath215 .",
    "finally , we let @xmath218 be the size of @xmath202 .",
    "intuitively , in an interval @xmath219 $ ] , @xmath202 always returns the same move : either to take _ immediately _ @xmath220 or to wait until the clock reaches the endpoint @xmath216 and then take @xmath220 .",
    "@xmath201 , however may require memory to play optimally .",
    "informally , we will compute optimal _ switching _ strategies , as introduced in @xcite ( in the untimed setting ) .",
    "a switching strategy is described by a pair @xmath221 of fp - strategies and a switch threshold @xmath222 , and consists in playing @xmath223 until the total accumulated cost of the discrete transitions is below @xmath222 ; and then to _ switch _ to strategy @xmath224 .",
    "the role of @xmath224 is to ensure reaching a final location : it is thus a ( classical ) attractor strategy .",
    "the role of @xmath223 , on the other hand , is to allow @xmath201to decrease the cost low enough ( possibly by forcing negative cycles ) to secure a cost below @xmath222 , and the computation of @xmath223 is thus the critical point in the computation of an optimal switching strategy .",
    "to characterise @xmath223 , we introduce the notion of negative cycle strategy ( nc - strategy ) .",
    "formally , an nc - strategy @xmath146 of @xmath201is an fp - strategy such that for all runs @xmath225 with @xmath226 , and @xmath227 in the same interval of @xmath228 , the sum of prices of _ discrete transitions _ is at most @xmath229 , i.e. , @xmath230 . to characterise the fact that @xmath223 must allow @xmath201to reach a cost which is _ small enough , without necessarily reaching a target state _ , we define the _ fake value _ of an nc - strategy @xmath146 from a configuration @xmath177 as @xmath231 , i.e. , the value obtained when _ ignoring _ the @xmath146-induced plays that _ do not _ reach the target .",
    "thus , clearly , @xmath232 .",
    "we say that an nc - strategy is _ fake - optimal _ if its fake value , in every configuration , is equal to the optimal value of the configuration in the game .",
    "this is justified by the following result whose proof relies on the switching strategies described before ( see a detailed proof in appendix  [ app : fake - optimality ] ) :    [ lem : fake - optimality ] if @xmath233 , for all @xmath93 and @xmath9 , then for all nc - strategies @xmath146 , there is a strategy @xmath234 such that @xmath235 for all configurations @xmath177 .",
    "in particular , if @xmath146 is a fake - optimal nc - strategy , then @xmath234 is an optimal ( switching ) strategy of the sptg .",
    "then , an sptgis called _ finitely optimal _ if    @xmath0 has a fake - optimal nc - strategy ;    @xmath1 has an optimal fp - strategy ; and    @xmath236 is a cost function , for all locations  @xmath93 .    the central point in establishing theorem  [ thm : main - result ]",
    "will thus be to prove that * all sptgs are finitely optimal * , as this guarantees the existence of well - behaved optimal strategies and value functions .",
    "we will also show that they can be computed in exponential time .",
    "the proof is by induction on the number of urgent locations of the sptg . in section  [ sec : urgentsptg ]",
    ", we address the base case of sptgs with urgent locations only ( where no time can elapse ) .",
    "since these sptgs are very close to the _ untimed _ min - cost reachability games of @xcite , we adapt the algorithm in this work and obtain the function ( algorithm  [ algo : value - iteration - fixed ] )",
    ". this function can also compute @xmath237 for all @xmath93 and all games @xmath78 ( even with non - urgent locations ) since time can not elapse anymore when the clock has valuation @xmath5 .",
    "next , using the continuity result of theorem  [ prop : continuity - of - val ] , we can detect locations @xmath93 where @xmath238 , for all @xmath28 $ ] , and remove them from the game .",
    "finally , in section  [ sec : solving - sptg ] we handle sptgs with non - urgent locations by refining the technique of @xcite ( that work only on sptgs with non - negative costs ) .",
    "compared to @xcite , our algorithm is simpler , being iterative , instead of recursive .",
    "throughout this section , we consider an @xmath193-sptg@xmath109 where all locations are urgent , i.e. , @xmath239 . we first explain briefly how we can compute the value function of the game for a _ fixed _",
    "clock valuation @xmath240 $ ] ( more precisely , we can compute the vector @xmath241 ) . since no time can elapse",
    ", we can adapt the techniques developed in @xcite to solve ( untimed ) _ min - cost reachability games_. the adaptation consists in taking into account the final cost functions ( see appendix  [ app : urgentsptg ] ) .",
    "this yields the function (  [ algo : value - iteration - fixed ] ) , that computes the vector @xmath241 for a fixed  @xmath9 .",
    "the results of @xcite also allow us to compute associated optimal strategies : when @xmath242 the optimal strategy for @xmath1 is memoryless , and the optimal strategy for @xmath0 is a switching strategy @xmath221 with a threshold @xmath222 ( as described in the previous section ) .",
    "now let us explain how we can reduce the computation of @xmath243 \\mapsto { \\ensuremath{{\\sf val}}}({\\ensuremath{\\ell}},{\\ensuremath{\\nu}\\xspace})$ ] ( for all @xmath93 ) to a _",
    "finite number of calls _ to .",
    "let @xmath244 be the set of affine functions over @xmath245 $ ] such that @xmath246 , where @xmath247\\cap{\\ensuremath{\\mathbf{z}}}$ ] .",
    "observe that @xmath248 has cardinality @xmath249 , i.e. , pseudo - polynomial in the size of @xmath78 . from @xcite , we conclude that the functions in @xmath248 are sufficient to characterise @xmath250 , in the following sense : for all @xmath251 and @xmath240 $ ] such that @xmath252 , there is @xmath253 with @xmath254 ( see lemma  [ lem : for - all - val - there - is - f - in - f ] , appendix  [ app : urgentsptg ] for the details )",
    ". using the continuity of @xmath250 ( theorem  [ prop : continuity - of - val ] ) , we show that all the cutpoints of @xmath250 are intersections of functions from  @xmath244 , i.e. , belong to the set of _ possible cutpoints _",
    "@xmath255\\mid \\exists f_1,f_2\\in{{\\sf f}}_{{\\ensuremath{\\mathcal g}\\xspace}}\\quad f_1\\neq f_2\\land f_1({\\ensuremath{\\nu}\\xspace})=f_2({\\ensuremath{\\nu}\\xspace})\\}$ ] .",
    "observe that @xmath256 contains at most @xmath257 points ( also a pseudo - polynomial in the size of  @xmath78 ) since all functions in @xmath244 are affine , and can thus intersect at most once with every other function .",
    "moreover , @xmath258 , since all functions of @xmath244 take rational values in @xmath10 and @xmath259 .",
    "thus , for all @xmath93 , @xmath260 is a cost function ( with cutpoints in @xmath256 and pieces from @xmath248 ) . since @xmath260 is a piecewise affine function , we can characterise it completely by computing only its value on its cutpoints .",
    "hence , we can reconstruct @xmath260 by calling on each rational valuation @xmath261 . from the optimal strategies computed along @xcite",
    ", we can also reconstruct a fake - optimal nc - strategy for @xmath0 and an optimal fp - strategy for @xmath1 , hence :    [ prop : basecase ] every @xmath64-sptg@xmath78 with only urgent locations is finitely optimal .",
    "moreover , for all locations  @xmath93 , the piecewise affine function @xmath260 has cutpoints in @xmath262 of cardinality @xmath263 , pseudo - polynomial in the size of @xmath78 .",
    "in this section , we consider sptgs with possibly non - urgent locations .",
    "we first prove that all such sptgs are finitely optimal .",
    "then , we introduce algorithm  [ alg : solve ] to compute optimal values and strategies of sptgs . to the best of our knowledge ,",
    "this is the first algorithm to solve sptgs with arbitrary weights . throughout the section",
    ", we fix an sptg@xmath109 with possibly non - urgent locations . before presenting our core contributions ,",
    "let us explain how we can detect locations with infinite values .",
    "as already argued , we can compute @xmath264 for all @xmath93 assuming all locations are urgent , since time can not elapse anymore when the clock has valuation @xmath5 .",
    "this can be done with .",
    "then , by continuity , @xmath265 ( respectively , @xmath266 ) , for some @xmath93 if and only if @xmath267 ( respectively , @xmath268 ) for all @xmath28 $ ] .",
    "we remove from the game all locations with infinite value without changing the values of other locations ( as justified in  @xcite ) .",
    "thus , we henceforth assume that @xmath269 for all @xmath112 .",
    "[ [ the - ensuremathmathcal - gxspace_ensuremathlr - construction . ] ] the @xmath270 construction .    to prove finite optimality of sptgs and to establish correctness of our algorithm",
    ", we rely in both cases on a construction that consists in decomposing @xmath78 into a sequence of sptgs with _ more urgent locations_. intuitively , a game with more urgent locations is easier to solve since it is closer to an untimed game ( in particular , when all locations are urgent , we can apply the techniques of section  [ sec : urgentsptg ] ) . more precisely , given a set  @xmath271 of non - urgent locations , and a valuation @xmath272 $ ] , we will define a ( possibly infinite ) sequence of valuations @xmath273 and a sequence @xmath274 , @xmath275 of sptgs such that    all locations of @xmath78 are also present in each @xmath276 , except that the locations of @xmath271 are now urgent ; and    for all @xmath277 , the value function of @xmath278 is equal to @xmath250 on the interval @xmath279 $ ] .",
    "hence , we can re - construct @xmath250 by assembling well - chosen parts of the values functions of the @xmath278 ( assuming @xmath280 ) .",
    "this basic result will be exploited in two directions .",
    "first , we prove by induction on the number of urgent locations that all sptgs are finitely optimal , by re - constructing @xmath250 ( as well as optimal strategies ) as a @xmath68-concatenation of the value functions of a finite sequence of sptgs with one more urgent locations .",
    "the base case , with only urgent locations , is solved by proposition  [ prop : basecase ] .",
    "this construction suggests a _ recursive _ algorithm in the spirit of @xcite ( for non - negative prices ) .",
    "second , we show that this recursion can be _ avoided _ ( see algorithm  [ alg : solve ] ) . instead of turning locations urgent one at a time , this algorithm makes them all urgent and computes directly the sequence of sptgs with only urgent locations .",
    "its proof of correctness relies on the finite optimality of sptgs and , again , on our basic result linking the values functions of @xmath78 and games @xmath278 .",
    "let us formalise these constructions .",
    "let @xmath78 be an sptg , let @xmath281 $ ] be an endpoint , and let @xmath282 be a vector of rational values . then , @xmath283 is an @xmath64-sptgin which both players may now decide , in all non - urgent locations @xmath93 , to _ wait _ until the clock takes value @xmath64 , and then to stop the game , adding the cost @xmath284 to the current cost of the play .",
    "formally , @xmath285 is such that @xmath286 ; for all @xmath287 and @xmath288 $ ] , @xmath289 , for all @xmath290 , @xmath291 ; @xmath292 , \\bot,{\\ensuremath{\\ell}}^f)\\mid { \\ensuremath{\\ell}}\\in { { \\ensuremath{l}}}\\setminus { \\ensuremath{{\\ensuremath{l}}_u}}\\}$ ] ; for all @xmath293 , @xmath294 if @xmath295 , and @xmath296 otherwise .",
    "then , we let @xmath297 , i.e. , the game obtained thanks to @xmath298 by letting @xmath299 be the value of @xmath78 in @xmath64 .",
    "one can check that this first transformation does not alter the value of the game , for valuations before @xmath64 : @xmath300 for all @xmath301 .",
    "next , we make locations urgent . for a set @xmath302 of non - urgent locations ,",
    "we let @xmath270 be the sptgobtained from @xmath303 by making urgent every location @xmath93 of @xmath271 . observe that , although all locations @xmath304 are now urgent in @xmath270 , their clones @xmath305 allow the players to wait until @xmath64 .",
    "when @xmath271 is a singleton @xmath306 , we write @xmath307 instead of @xmath308 . while the construction of @xmath303 does not change the value of the game , introducing urgent locations _",
    "does_. yet , we can characterise an interval @xmath309 $ ] on which the value functions of @xmath310 and @xmath311 coincide , as stated by the next proposition",
    ". the interval @xmath309 $ ] depends on the _ slopes _ of the pieces of @xmath312 as depicted in figure  [ fig : slopebigger ] : for each location @xmath25 of @xmath0 , the slopes of the pieces of @xmath312 contained in @xmath309 $ ] should be @xmath313 ( and @xmath314 when @xmath93 belongs to @xmath1 ) .",
    "it is proved by lifting optimal strategies of @xmath315 into @xmath316 , and strongly relies on the determinacy result of theorem  [ thm : determined ] :    [ lem : samevalue ] let @xmath317 , @xmath302 and @xmath318 a non - urgent location of @xmath201 ( respectively , @xmath200 ) .",
    "assume that @xmath319 is finitely optimal , and for all @xmath320 @xmath321 then , for all @xmath322 $ ] and @xmath323 , @xmath324 .",
    "furthermore , fake - optimal nc - strategies and optimal fp - strategies in @xmath319 are also fake - optimal and optimal over @xmath309 $ ] in @xmath270 .    given an sptg@xmath78 and some _ finitely optimal _",
    "@xmath270 , we now characterise precisely the left endpoint of the maximal interval ending in @xmath64 where the value functions of @xmath78 and @xmath325 coincide , with the operator @xmath326\\to [ 0,1]$ ] ( or simply @xmath327 , if @xmath271 is clear ) defined as : @xmath328 \\ { { \\ensuremath{{\\sf val}}}}_{{\\ensuremath{\\mathcal g}\\xspace}_{{\\ensuremath{l}}',r}}({\\ensuremath{\\ell}},{\\ensuremath{\\nu}\\xspace } ) = { { \\ensuremath{{\\sf val}}}}_{{\\ensuremath{\\mathcal g}\\xspace}}({\\ensuremath{\\ell}},{\\ensuremath{\\nu}\\xspace})\\}\\,.\\ ] ] by continuity of the value ( theorem  [ prop : continuity - of - val ] ) , this supremum exists and @xmath329 .",
    "moreover , @xmath330 is a cost function on @xmath331 $ ] , since @xmath270 is finitely optimal .",
    "however , this definition of @xmath332 is semantical . yet , building on the ideas of proposition  [ lem : samevalue ] , we can effectively compute @xmath332 , given @xmath333 .",
    "we claim that @xmath334 is the _ minimal valuation _ such that for all locations @xmath335 ( respectively , @xmath336 ) , the slopes of the affine sections of the cost function @xmath337 on @xmath331 $ ] are at least ( at most ) @xmath338 ( see lemma  [ lem : operatornext ] in appendix ) .",
    "hence , @xmath332 can be obtained ( see figure  [ fig : howtoconstructri ] ) , by inspecting iteratively , for all @xmath93 of @xmath0 ( respectively , @xmath1 ) , the slopes of @xmath337 , by decreasing valuations , until we find a piece with a slope @xmath339 ( respectively , @xmath340 ) .",
    "this enumeration of the slopes is effective as @xmath333 has finitely many pieces , by hypothesis .",
    "moreover , this guarantees that @xmath341 .",
    "thus , one can reconstruct @xmath250 on @xmath342 $ ] from the value functions of the ( potentially infinite ) sequence of games @xmath274 , @xmath275 where @xmath343 for all @xmath139 such that @xmath344 , for all possible choices of non - urgent locations @xmath271",
    ". next , we will define two different ways of choosing @xmath271 : the former to prove finite optimality of all sptgs , the latter to obtain an algorithm to solve them .    at ( 0,5 )",
    "@xmath345 ; at ( 7,0 ) @xmath9 ; ( -0.3,0 ) ",
    "( 7,0 ) ; ( 0,-0.3 )  ( 0,5 ) ; ( 6,0 ) ",
    "( 6,5 ) ; ( 3,0 ) ",
    "( 3,5 ) ;    at ( 3,0 ) @xmath346 ; at ( 6,0 ) @xmath64 ;    ( 0,0.5 ) .. controls ( 0.5,7 ) and ( 1.5,0 ) .. ( 6,4 ) ; ( 3.5,0 ) ",
    "( 3.5,7 ) ; ( 5.5,0 ) ",
    "( 5.5,7 ) ;    ( c)(d ) ;    at ( c ) @xmath347 ; at ( d ) @xmath347 ;    \\(p ) at ( @xmath348 ) ;    \\(c )  ( @xmath349 ) ;    ( 3.5,0 )  ( c ) ; ( 5.5,0 )  ( d ) ; at ( 3.5,0 ) @xmath350 ; at ( 5.5,0 ) @xmath351 ;    ( cy ) at ( @xmath352 ) ; ( dy ) at ( @xmath353 ) ;    ( cy ) ",
    "( c ) ; ( dy ) ",
    "( d ) ;    at ( cy ) @xmath354 ; at ( dy ) @xmath355 ;       at ( 0,5 ) @xmath356 ; at ( 7,0 ) @xmath9 ; ( -0.3,0 )  ( 7,0 ) ; ( 0,-0.3 )  ( 0,5 ) ; ( 6,0 )  ( 6,5 ) ; ( 3,0 ) ",
    "( 3,5 ) ; ( 0,4 ) ",
    "( 7,4 ) ; at ( 0,4 ) @xmath357 ; at ( 3,0 ) @xmath332 ; at ( 6,0 ) @xmath64 ;    ( 6,4 )  ( 5,3 ) ",
    "( 4,2.7 ) ",
    "( 3.7,2 ) ",
    "( 2,1.7 )  ( 1.5,1 ) ",
    "( 1,1.3 ) ",
    "( 0.5,0.5 ) ",
    "( 0,0.5 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    ( 0,0 ) ",
    "( 0.5,0.125 ) ;    [ [ sptgs - are - finitely - optimal . ] ] sptgs are finitely optimal .    to prove finite optimality of all sptgs we reason by induction on the number of non - urgent locations and instantiate the previous results to the case where @xmath358 where @xmath359 is a non - urgent location of _ minimum price - rate _",
    "( i.e. , for all @xmath251 , @xmath360 ) . given @xmath272 $ ] , we let @xmath361 be the decreasing sequence of valuations such that @xmath362 for all @xmath363 . as explained before , we will build @xmath250 on @xmath364 $ ] from the value functions of games @xmath365 . assuming finite optimality of those games",
    ", this will prove that @xmath78 is finitely optimal _ under the condition _ that @xmath361 eventually stops , i.e. , @xmath366 for some @xmath139 .",
    "this property is given by the next lemma , which ensures that , for all @xmath139 , the owner of @xmath359 has a strictly better strategy in configuration @xmath367 than waiting until @xmath368 in location @xmath359 .",
    "[ lem : strictlysmaller][lem : stationarysequence - locmin ] if @xmath365 is finitely optimal for all @xmath277 , then    if @xmath369 ( respectively , @xmath81 ) , @xmath370 ( respectively , @xmath371 ) , for all @xmath139 ; and    there is @xmath372 such that @xmath366 .    by iterating this construction ,",
    "we make all locations urgent iteratively , and obtain :    [ prop : expcutpoints ] every sptg@xmath78 is finitely optimal and for all locations @xmath93 , @xmath236 has at most @xmath373 cutpoints .    as announced , we show by induction on @xmath374 that every @xmath64-sptg @xmath78 with @xmath375 non - urgent locations is finitely optimal , and that the number of cutpoints of @xmath236 is at most @xmath376 , which suffices to show the above bound , since @xmath377 .",
    "the base case @xmath378 is given by proposition  [ prop : basecase ] .",
    "now , assume that @xmath78 has at least one non - urgent location , and consider @xmath359 one with minimum price . by induction hypothesis ,",
    "all @xmath379-sptgs @xmath380 are finitely optimal for all @xmath381 $ ] .",
    "let @xmath361 be the decreasing sequence defined by @xmath382 and @xmath362 for all @xmath383 .",
    "by lemma  [ lem : stationarysequence - locmin ] , there exists @xmath384 such that @xmath385 .",
    "for all @xmath386 , @xmath387 on @xmath388 $ ] by definition of @xmath389 , so that @xmath236 is a cost function on this interval , for all @xmath93 , and the number of cutpoints on this interval is bounded by @xmath390 by induction hypothesis ( notice that maximal transition prices are the same in @xmath78 and @xmath391 , but that we add @xmath375 more final locations in @xmath391 ) . adding the cutpoint @xmath5 , summing over @xmath139 from @xmath10 to @xmath384 , and observing that @xmath392 , we bound the number of cutpoints of @xmath236 by @xmath376 .",
    "finally , we can reconstruct fake - optimal and optimal strategies in @xmath78 from the from fake - optimal and optimal strategies of @xmath365 .",
    "[ [ computing - the - value - functions . ] ] computing the value functions .",
    "the finite optimality of sptgs allows us to compute the value functions .",
    "the proof of proposition  [ prop : expcutpoints ] suggests a _ recursive _ algorithm to do so : from an sptg@xmath78 with minimal non - urgent location @xmath359 , solve recursively @xmath393 , @xmath394 , @xmath395 , _",
    "etc_.  handling the base case where all locations are urgent with algorithm  [ algo : value - iteration - fixed ] .",
    "while our results above show that this is correct and terminates , we propose instead to solve  without the need for recursion  the sequence of games @xmath396 , @xmath397 i.e. , _ making all locations urgent at once_. again , the arguments given above prove that this scheme is _ correct _ , but the key argument of lemma  [ lem : stationarysequence - locmin ] that ensures _ termination _ can not be applied in this case . instead",
    ", we rely on the following lemma , stating , that there will be at least one cutpoint of @xmath250 in each interval @xmath331 $ ] .",
    "observe that this lemma relies on the fact that @xmath78 is finitely optimal , hence the need to first prove this fact independently with the sequence @xmath393 , @xmath394 , @xmath395,  termination then follows from the fact that @xmath250 has finitely many cutpoints by finite optimality .",
    "[ lem : r_2-r_1-r_0 ] let @xmath398 $ ] such that @xmath274 is finitely optimal .",
    "suppose that @xmath399 , and let @xmath400 .",
    "there exists @xmath401 and @xmath304 such that    @xmath330 is affine on @xmath402 $ ] , of slope equal to @xmath338 , and    @xmath403 .    as a consequence",
    ", @xmath236 has a cutpoint in @xmath404 .",
    "algorithm  [ alg : solve ] implements these ideas .",
    "each iteration of the * while * loop computes a new game in the sequence @xmath396 , @xmath405 described above ; solves it thanks to ; and thus computes a new portion of @xmath250 on an interval on the left of the current point @xmath406 $ ] .",
    "more precisely , the vector @xmath407 is first computed in line  [ alg : init ] .",
    "then , the algorithm enters the * while * loop , and the game @xmath408 obtained when reaching line  [ alg : game - constructed ] is @xmath396 .",
    "then , the algorithm enters the * repeat * loop to analyse this game .",
    "instead of building the whole value function of @xmath408 , algorithm  [ alg : solve ] builds only the parts of @xmath409 that coincide with @xmath410 .",
    "it proceeds by enumerating the possible cutpoints @xmath346 of @xmath409 , starting in  @xmath64 , by decreasing valuations ( line  [ alg : cutpoint ] ) , and computes the value of @xmath409 in each cutpoint thanks to ( line  [ alg : call - si ] ) , which yields a new piece of @xmath409 .",
    "then , the * if * in line  [ line : begin ] checks whether this new piece coincides with @xmath250 , using the condition given by proposition  [ lem : samevalue ] . if it is the case , the piece of @xmath409 is added to @xmath411 ( line  [ alg : concat ] ) ; * repeat * is stopped otherwise . when exiting the * repeat * loop , variable @xmath412 has value @xmath413 .",
    "hence , at the next iteration of the * while * loop , @xmath414 when reaching line  [ alg : game - constructed ] . by continuing this reasoning inductively ,",
    "one concludes that the successive iterations of the * while * loop compute the sequence @xmath396 , @xmath405 as announced , and rebuilds @xmath250 from them .",
    "termination in exponential time is ensured by lemma  [ lem : r_2-r_1-r_0 ] : each iteration of the * while * loop discovers at least one new cutpoint of @xmath250 , and there are at most exponentially many ( note that a tighter bound on this number of cutpoints would entail a better complexity of our algorithm ) .",
    "let us briefly sketch the execution of algorithm  [ alg : solve ] on the sptgin figure  [ fig : ex - ptg2 ] . during the first iteration of the * while * loop , the algorithm computes the correct value functions until the cutpoint @xmath13 : in the @xmath415 loop , at first @xmath416 but the slope in @xmath34 is smaller than the slope that would be granted by waiting , as depicted in figure  [ fig : ex - ptg2 ] . then , @xmath417 where the algorithm gives a slope of value @xmath418 in @xmath419 while the cost of this location of @xmath200is @xmath420 . during the first iteration of the * while * loop , the inner * repeat * loop thus ends with @xmath421 .",
    "the next iterations of the * while * loop end with @xmath422 ( because @xmath34 does not pass the test in line  [ line : begin ] ) ; @xmath423 ( because of @xmath419 ) and finally with @xmath424 , giving us the value functions on the entire interval @xmath26 $ ] .",
    "all value functions are in figure  [ fig : val_sptg ] in the appendix .",
    "@xmath425[alg : init ] @xmath426 ( ) @xmath427 @xmath428 @xmath429 @xmath430[alg : game - constructed ] ( ) @xmath431 or @xmath432 @xmath433[alg : cutpoint ] @xmath434[alg : call - si ] [ alg : concat ] @xmath435 ; @xmath436 @xmath437",
    "in @xcite , _ general _ ptgs with _ non - negative prices _ are solved by reducing them to a finite sequence of sptgs , by eliminating guards and resets .",
    "it is thus natural to try and adapt these techniques to our general case , in which case algorithm  [ alg : solve ] would allow us to solve _ general ptgs with arbitrary costs_. let us explain why it is not ( completely ) the case .",
    "the technique used to remove guards from ptgs consists in enhancing the locations with regions while keeping an equivalent game . this technique _",
    "can _ be adapted to arbitrary weights , see appendix  [ app : raptg ] for a proof adapted from ( * ? ? ?",
    "* lemma  4.6 ) .    the technique to handle resets , however , consists in _ bounding _ the number of clock resets that can occur in any play following an optimal strategy of @xmath201or @xmath200 .",
    "then , the ptgcan be _ unfolded _ into a _",
    "reset - acyclic _ ptgwith the same value . by reset - acyclic ,",
    "we mean that no cycle in the configuration graph visits a transition with a reset .",
    "this reset - acyclic ptgcan be decomposed into a finite number of components that contain no reset and are linked by transitions with resets .",
    "these components can be solved iteratively , from the bottom to the top , turning them into sptgs .",
    "thus , if we _ assume _ that the ptgs we are given as input _ are _ reset - acyclic , we can solve them in _ exponential time _",
    ", and show that their value functions are cost functions with at most exponentially many cutpoints , using our techniques ( see appendix  [ app : raptg ] ) . unfortunately , the arguments to bound the number of resets do not hold for arbitrary costs , as shown by the ptgin  [ fig : ex - ptgrr ] .",
    "we claim that @xmath438 ; that @xmath201has no optimal strategy , but a family of @xmath180-optimal strategies @xmath439 each with value  @xmath180 ; and that each @xmath439 requires _ memory whose size depends on @xmath180 _ and might _ yield a play visiting at least @xmath440 times the reset _ between @xmath441 and @xmath34 ( hence the number of resets can not be bounded ) . for all @xmath442",
    ", @xmath439 consists in : waiting @xmath443 time units in @xmath441 , then going to @xmath34 during the @xmath444 first visits to @xmath441 ; and to go directly to @xmath29 afterwards . against @xmath439",
    ", @xmath1 has two possible choices :    either wait @xmath10 time unit in @xmath34 , wait @xmath180 time units in @xmath419 , then reach @xmath29 ; or    wait @xmath180 time unit in @xmath34 then force the cycle by going back to @xmath441 and wait for @xmath0 s next move .",
    "thus , all plays according to @xmath439 will visit a sequence of locations which is either of the form @xmath445 , with @xmath446 ; or of the form @xmath447 . in the former case ,",
    "the cost of the play will be @xmath448 ; in the latter , @xmath449 .",
    "this shows that @xmath438 , but there is no optimal strategy as none of these strategies allow one to guarantee a cost of @xmath10 ( neither does the strategy that waits @xmath5 time unit in @xmath441 ) .    at ( 0,0 ) ( q0 ) ; ( q1 ) ; ( q2 ) ; ( qf ) ;    ( q2 ) edge node[above ] @xmath450 ( qf ) ( q1 ) edge node[above ] @xmath451 ( q2 ) ( q0 ) edge[bend left=10 ] node[above ] @xmath451 ( q1 ) ( q1 ) edge[bend left=10 ] node[below ] @xmath452 ( q0 ) ;    ( q0.north )  + + ( 0,.5 ) ",
    "node[above ] @xmath5 ( @xmath453 )  ( qf ) ;    however , we may apply the result on reset - acyclic ptgs to obtain :    the value functions of all one - clock ptgs are cost functions with at most exponentially many cutpoints .",
    "let @xmath78 be a one - clock ptg .",
    "let us replace all transitions @xmath454 resetting the clock by @xmath455 , where @xmath456 is a new final location with @xmath457observe that @xmath458 exists even if we can not compute it , so this transformation is well - defined .",
    "this yields a reset - acyclic ptg @xmath408 such that @xmath459",
    ".    10    rajeev alur , mikhail bernadsky , and p.  madhusudan .",
    "optimal reachability for weighted timed games . in _ proceedings of the 31st international colloquium on automata , languages and programming ( icalp04 ) _ , volume 3142 of _ lecture notes in computer science _ , pages 122133 .",
    "springer , 2004 .",
    "rajeev alur and david  l. dill . a theory of timed automata .",
    ", 126(2):183235 , 1994 .",
    "rajeev alur , salvatore la  torre , and george  j. pappas .",
    "optimal paths in weighted timed automata . , 318(3):297322 , 2004 .",
    "gerd behrmann , ansgar fehnker , thomas hune , kim  g. larsen , judi romijn , and frits  w. vaandrager .",
    "minimum - cost reachability for priced timed automata . in _ proceedings of the 4th international workshop on hybrid systems : computation and control ( hscc01 ) _ , volume 2034 of _ lecture notes in computer science _ ,",
    "pages 147161 .",
    "springer , 2001 .",
    "j.  berendsen , t.  chen , and d.  jansen .",
    "undecidability of cost - bounded reachability in priced probabilistic timed automata . in _ theory and applications of models of computation _ ,",
    "volume 5532 of _ lncs _ , pages 128137 .",
    "springer , 2009 .",
    "patricia bouyer , thomas brihaye , vronique bruyre , and jean - franc cois raskin . on the optimal reachability problem of weighted timed automata .",
    ", 31(2):135175 , 2007 .",
    "patricia bouyer , thomas brihaye , and nicolas markey . improved undecidability results on weighted timed automata .",
    ", 98(5):188194 , 2006 .",
    "patricia bouyer , franck cassez , emmanuel fleury , and kim  g. larsen .",
    "optimal strategies in priced timed game automata . in _ proceedings of the 24th conference on foundations of software technology and theoretical computer science ( fsttcs04 ) _ , volume 3328 of _ lecture notes in computer science _ , pages 148160 .",
    "springer , 2004 .",
    "patricia bouyer , samy jaziri , and nicolas markey . on the value problem in weighted timed games .",
    "research report lsv-14 - 12 , laboratoire spcification et vrification , ens cachan , france , october 2014 .",
    "24  pages .",
    "patricia bouyer , kim  g. larsen , nicolas markey , and jacob  illum rasmussen . almost optimal strategies in one - clock priced timed games . in _ proceedings of the 26th conference on foundations of software technology and theoretical computer science ( fsttcs06 ) _ , volume 4337 of _ lecture notes in computer science _ , pages 345356 .",
    "springer , 2006 .",
    "thomas brihaye , vronique bruyre , and jean - franois raskin . on optimal timed strategies . in _ proceedings of the third international conference on formal modeling and analysis of timed systems ( formats05 )",
    "_ , volume 3829 of _ lecture notes in computer science _ , pages 4964 .",
    "springer , 2005 .",
    "thomas brihaye , gilles geeraerts , axel haddad , and benjamin monmege . to reach or not to reach ?",
    "efficient algorithms for total - payoff games . in luca aceto and david de  frutos",
    "escrig , editors , _ proceedings of the 26th international conference on concurrency theory ( concur15 ) _ , volume  42 of _ lipics _ , pages 297310 .",
    "schloss dagstuhl ",
    "leibniz - zentrum fr informatik , september 2015 .",
    "thomas brihaye , gilles geeraerts , shankara  narayanan krishna , lakshmi manasa , benjamin monmege , and ashutosh trivedi . dding negative prices to priced timed games . in _ proceedings of the 25th international conference on concurrency theory ( concur13 ) _ , volume 8704 of _ lecture notes in computer science _ , pages 560575 .",
    "springer , 2014 .",
    "d.  gale and f.  m. stewart .",
    "infinite games with perfect information . in _ contributions to the theory of games , vol .",
    "annals of mathematical studies _ , volume  28 of _ lecture notes in computer science _ , pages 245266 .",
    "princeton university press . ,",
    "thomas  dueholm hansen , rasmus ibsen - jensen , and peter  bro miltersen .",
    "a faster algorithm for solving one - clock priced timed games . in _ proceedings of the 24th international conference on concurrency theory ( concur13 ) _ , volume 8052 of _ lecture notes in computer science _ , pages 531545 .",
    "springer , 2013 .",
    "p.  j. ramadge and w.  m. wonham . the control of discrete event systems . in _",
    "ieee _ , volume  77 , pages 8198 , 1989 .",
    "micha rutkowski .",
    "two - player reachability - price games on single - clock timed automata . in",
    "_ proceedings of the 9th workshop on quantitative aspects of programming languages ( qapl11 ) _ , volume  57 of _ electronic proceedings in theoretical computer science _ , pages 3146 , 2011 .",
    "we start with the proof of determinacy . for all @xmath460 , define @xmath461 as the _ qualitative _ game which is played like @xmath78 , and only the objective of @xmath0 is altered ( in order to make it qualitative ) : now @xmath0 wins a play if and only if the cost of the play is @xmath462 .",
    "further , let @xmath463 be the set of prefixes of runs ending in a final vertex and whose cost is less than or equal to @xmath464",
    ". then the set of winning plays for @xmath0 in this game is @xmath465 where @xmath466 denotes the set of plays having @xmath143 as a prefix .",
    "the set @xmath53 is an open set in the topology induced by cones . in  @xcite",
    ", it is shown that in any game whose set of winning plays is an open set is _ determined _ , i.e. one of the two players has a winning strategy .",
    "therefore @xmath467 is determined for all @xmath464 .",
    "now let us prove that @xmath468 .",
    "first , recall that , by definition of @xmath469 and @xmath183 : @xmath470 for all configurations @xmath117 .",
    "fix a configuration @xmath117 .",
    "we consider several cases :    1 .",
    "first assume that @xmath471 . by definition , for all @xmath472 and all strategies @xmath473 , @xmath474 .",
    "hence , for all @xmath472 , @xmath1 has no winning strategy in the game @xmath467 .",
    "therefore , by determinacy of this game , @xmath0 has a winning strategy .",
    "equivalently , for all @xmath472 , there exists @xmath475 such that @xmath476 .",
    "this implies that : @xmath477 hence , by   and we conclude that : @xmath478 when these values are finite .",
    "2 .   in the case where @xmath479 , we conclude , by   that @xmath480 too .",
    "finally , in the case where @xmath481 then for all @xmath464 , @xmath1 has no winning strategy for @xmath467 .",
    "therefore , by determinacy , @xmath0 has a winning strategy @xmath482 in @xmath467 .",
    "thus , for all @xmath464 : @xmath483 , and : @xmath484 .",
    "we then turn to the proof of continuity . therefore",
    ", our goal is to show that for every location @xmath93 , region @xmath191 and valuations @xmath9 and @xmath485 in @xmath64 , @xmath486    this is equivalent to showing @xmath487 as those two equations are symmetric with respect to @xmath9 and @xmath485 , we only have to show either of them .",
    "we will thus focus on the latter , which , by using the upper value , can be reformulated as : for all strategies @xmath146 of @xmath201 , there exists a strategy @xmath234 such that @xmath488 .",
    "note that this last equation is equivalent to say that there exists a function @xmath489 mapping plays @xmath490 from @xmath491 , consistent with @xmath234 ( i.e. , such that @xmath492 for some strategy @xmath151 of @xmath1 ) to plays from @xmath112 , consistent with @xmath146 , such that @xmath493    let @xmath494 , @xmath495 and @xmath146 be a strategy of @xmath201 .",
    "we define @xmath234 and @xmath489 by induction on the size of their arguments ; more precisely , we define @xmath496 and @xmath497 by induction on @xmath464 , for all plays @xmath498 and @xmath499 from @xmath491 , consistent with @xmath234 of size @xmath500 and @xmath464 , respectively .",
    "we also show during this induction that for each play @xmath501 from @xmath491 , consistent with @xmath502 , if we let @xmath503 :    1 .",
    "@xmath504 and @xmath505 have the same length , i.e. , @xmath506 , 2 .   for every @xmath507 , @xmath508 and @xmath509",
    "are in the same region , i.e. , there exists a region @xmath510 such that @xmath511 and @xmath512 , 3 .",
    "@xmath513 , 4 .",
    "@xmath514 .",
    "notice that no property is required on the strategy @xmath234 for finite plays that do not start in @xmath491 .    if @xmath515 , as there is no play of length @xmath10 , nothing has to be done to define @xmath234 .",
    "moreover , in that case , @xmath516 and @xmath517 .",
    "both plays have size  @xmath5 , @xmath9 and @xmath485 are in the same region by hypothesis of the lemma , and @xmath518 , therefore all four properties are true .    let us suppose now that the construction is done for a given @xmath519 , and perform it for @xmath520 .",
    "we start with the construction of @xmath234 . to that extent , consider a play @xmath501 from @xmath491 , consistent with @xmath234 such that @xmath521 is a location of player @xmath0 .",
    "let @xmath133 and @xmath127 be the choice of delay and transition made by @xmath146 on @xmath505 , i.e. , @xmath522 .",
    "then , we define @xmath523 where @xmath524 .",
    "the delay @xmath525 respects the guard of transition @xmath127 since either @xmath526 or @xmath527 , in which case @xmath528 is in the same region as @xmath529 since @xmath530 and @xmath531 are in the same region .",
    "this is illustrated in figure  [ fig : deltaprime ] .",
    "( -0.5,0 )  ( 2.5,0 ) ; at ( 0,-0.3 ) @xmath528 ; ( vkp ) at ( 0,0 ) @xmath347 ; at ( 1,0.3 ) @xmath532 ; ( vk ) at ( 1,0 ) @xmath347 ; ( vkdelta ) at ( 2,0 ) @xmath347 ;    at ( 1,-1.5 ) ( a ) ;    ( vk ) to[bend left ] node[midway , above ] @xmath133 ( vkdelta ) ; ( vkp ) to[bend right ] node[midway , below ] @xmath525 ( vkdelta ) ;    ( -0.5,0 )  ( 2.5,0 ) ; at ( 0,-0.3 ) @xmath532 ; ( vk ) at ( 0,0 ) @xmath347 ; at ( 1,0.3 ) @xmath528 ; ( vkp ) at ( 1,0 ) @xmath347 ; ( vkdelta ) at ( 2,0 ) @xmath347 ;    at ( 1,-1.5 ) ( b ) ;    ( vk ) to[bend right ] node[midway , below ] @xmath133 ( vkdelta ) ; ( vkp ) to[bend left ] node[midway , above ] @xmath525 ( vkdelta ) ;    ( -0.5,0 )  ( 2.5,0 ) ; at ( 0,-0.3 ) @xmath532 ; ( vk ) at ( 0,0 ) @xmath347 ; ( vkdelta ) at ( 1,0 ) @xmath347 ; at ( 2,-0.3 ) @xmath528 ; ( vkp ) at ( 2,0 ) @xmath347 ;    at ( 1,-1.5 ) ( c ) ;    ( vk ) to[bend right ] node[midway , below ] @xmath133 ( vkdelta ) ; ( vkp ) edge[loop above ] node[midway , above ] @xmath525 ( vkp ) ;    we now build the mapping @xmath489 .",
    "let @xmath533 be a play from @xmath491 consistent with @xmath234 and @xmath534 its prefix of size @xmath464 .",
    "let @xmath535 be the delay and transition taken after @xmath536 . using the construction of @xmath489 over plays of length @xmath464 by induction , the play @xmath537 ( with @xmath538 ) verifies properties ( i ) , ( ii ) and ( iii ) .",
    "if @xmath539 is a location of @xmath201and @xmath540 , then @xmath541 is obtained by applying those choices on @xmath542 .",
    "if @xmath539 is a location of @xmath200 , the last valuation @xmath543 of @xmath505 is rather obtained by choosing action @xmath116 verifying @xmath544 . note that transition @xmath127 is allowed since both @xmath545 and @xmath546 are in the same region ( for similar reasons as above ) .    by induction hypothesis @xmath547 , thus ( i ) holds , i.e. , @xmath548 .",
    "moreover , @xmath543 and @xmath549 are also in the same region as either they are equal to @xmath545 and @xmath546 , respectively , or @xmath127 contains a reset in which case @xmath550 which proves ( ii ) . to prove ( iii ) , notice that we always have either @xmath551 or @xmath552 or @xmath553 . in all of these possibilities",
    ", we have @xmath554 . by noticing again that either @xmath555 and @xmath556 , or @xmath127 contains a reset in which case @xmath550",
    ", we conclude the proof of ( iii ) .",
    "we finally check property ( iv ) . in both cases : @xmath557 if @xmath127 contains no reset , let us prove that @xmath558 indeed , since @xmath559 and @xmath560 , we have @xmath561 .",
    "then , two cases are possible : either @xmath524 or @xmath544 .",
    "so we have three different possibilities :    * if @xmath562 , @xmath563 , thus @xmath564 . * if @xmath120 , then @xmath565 , thus @xmath566 . *",
    "if @xmath567 , then @xmath568 , thus @xmath569 .    if @xmath127 contains a reset , then @xmath563 .",
    "if @xmath570 , we have that @xmath571 . otherwise , either @xmath120 and @xmath572 , or @xmath567 and @xmath573 .    in all cases ,",
    "we have proved .",
    "coupled with the fact that @xmath574 , we conclude that : @xmath575    now that @xmath234 and @xmath489 are defined ( noticing that @xmath489 is stable by prefix , we extend naturally its definition to infinite plays ) , notice that for all play @xmath504 from @xmath491 consistent with @xmath234 , either @xmath504 does not reach a final location and its cost is @xmath4 , but in this case @xmath505 has also cost @xmath4 ; or @xmath504 is finite . in this case",
    "let @xmath531 be the clock valuation of its last configuration , and @xmath530 be the clock valuation of the last configuration of @xmath505 .",
    "combining @xmath576 and @xmath577 we have @xmath578 which concludes the proof .",
    "( q0 ) ; ( c2 ) ; ( q1 ) ; ( c1 ) ;    ( q0 ) edge node[above ] @xmath579 ( q1 ) ( q0 ) edge node[above right ] @xmath579 ( c1 ) ( c1 ) edge node[below ] @xmath580 ( c2 ) ( c2 ) edge node[above left ] @xmath452 ( q0 ) ;    let us consider the example in  [ fig : pas - continu2 ] ( that we describe informally since we did not properly define games with multiple clocks ) , with clocks @xmath21 and @xmath581 .",
    "one can easily check that , starting from a configuration @xmath582 in location @xmath441 and where @xmath579 and @xmath583 , the following cycle can be taken : @xmath584 , where @xmath585 , @xmath586 and @xmath587 denote respectively the transitions from @xmath441 to @xmath34 ; from @xmath34 to @xmath419 ; and from @xmath419 to @xmath441 .",
    "observe that the cost of this cycle is null , and that no other delays can be played , hence @xmath588 .",
    "however , starting from a configuration @xmath589 , and following the same path , yields the cycle @xmath590 with cost @xmath229 .",
    "hence , @xmath591 , and the function is not continuous although both valuations @xmath592 and @xmath593 are in the same region . observe that this holds even for priced timed _ automata _ , since our example requires only one player .",
    "( 1 ) ; ( 2)[right of=1 ] ; ( 3)[right of=2 ] ;    \\(1 )  ( 0 , -1 )  node[above]@xmath594 ( 4 , -1 )  ( 3 ) ;    \\(1 ) edge[bend left=10 ] node[above]@xmath229 ( 2 ) ( 2 ) edge[bend left=10 ] node[below]@xmath10 ( 1 ) edge node[above]@xmath10 ( 3 ) ( 3 ) edge[loop right ] node[right]@xmath10 ( 3 ) ;    as an example , consider the sptgof  [ fig : weighted - game ] , where @xmath595 is a positive integer , and every location has price - rate  @xmath10 : hence , this game can be seen as an ( untimed ) min - cost reachability game as studied in @xcite , where it has been initially studied .",
    "we claim that the values of locations @xmath34 and @xmath419 are both @xmath594 .",
    "indeed , consider the following strategy for @xmath0 : during each of the first @xmath595 visits to @xmath419 ( if any ) , go to @xmath34 ; else , go to @xmath29 .",
    "clearly , this strategy ensures that the final location @xmath29 will eventually be reached , and that either    transition @xmath596 ( with weight  @xmath594 ) will eventually be traversed ; or    transition @xmath597 ( with weight  @xmath229 ) will be traversed at least  @xmath595 times .",
    "hence , in all plays following this strategy , the cost will be at most  @xmath594 .",
    "this strategy allows @xmath0 to secure  @xmath594 , but he can not ensure a lower cost , since @xmath1 always has the opportunity to take the transition @xmath598 ( with weight  @xmath594 ) instead of cycling between @xmath34 and @xmath419 . hence , @xmath1 s optimal choice is to follow the transition @xmath598 as soon as @xmath34 is reached , securing a cost of @xmath594 .",
    "the @xmath0 strategy we have just given is optimal , and there is _ no optimal memoryless strategy _ for @xmath0 . indeed ,",
    "always playing @xmath599 does not ensure a cost at most @xmath594 ; and , always playing @xmath600 does not guarantee to reach the target , and this strategy has thus value @xmath4 .",
    "first of all , notice that all finite plays @xmath601 with all clock valuations in the same interval @xmath95 of @xmath217 verify @xmath602 . indeed , the cost of @xmath148 is the sum of the cost generated by staying in locations , which is bounded by @xmath603 , and the cost of the transitions .",
    "one can extract at least @xmath604 cycles with transition prices as most @xmath229 ( by definition of an nc - strategy ) , and what remains is of size at most @xmath605 , ensuring that the transition cost is bounded by @xmath606 .",
    "then , by splitting runs among intervals of @xmath228 , we can easily obtain that all finite plays @xmath607 verify @xmath608 .",
    "indeed , letting @xmath609 the interval of @xmath228 visited during @xmath148 ( with @xmath610 ) , one can split @xmath148 into @xmath464 runs @xmath611 such that in @xmath612 all clock values are in @xmath613 ( remember that sptgs contain no reset transitions ) . by the previous inequality",
    ", we have @xmath614 .",
    "thus , also splitting costs @xmath615 with respect to discrete cost and cost of delaying , we obtain @xmath616 , since @xmath617 and @xmath618 .",
    "we now turn to the proof of the lemma . to that extent ,",
    "we suppose known an attractor strategy for @xmath201 , i.e. , a strategy that ensures to reach a final location : it exists thanks to the hypothesis on the finiteness of the values . from every configuration",
    ", it reaches a final location with a cost bounded above by a given constant  @xmath619 .",
    "notice first that , with the hypothesis that no configuration has a value @xmath63 in the sptgwe consider , it is not possible that @xmath620 for a configuration @xmath177 ( i.e. , that no runs of @xmath621 reach the target ) .",
    "indeed , consider the strategy @xmath234 obtained by playing @xmath146 until having computed a cost bounded above by a fixed integer @xmath622 , in which case we switch to the attractor strategy . by the previous inequality ,",
    "the switch is sure to happen since the right term tends to @xmath63 when the length of @xmath148 tends to @xmath623 .",
    "then , we know that the value guaranteed by @xmath234 is at most @xmath624 , implying that the optimal value @xmath625 is @xmath63 , which contradicts the hypothesis",
    ". then , to prove the result of the lemma , consider the strategy @xmath234 obtained by playing @xmath146 until having computed a cost bounded above by the finite value @xmath626 , in which case we switch to the attractor strategy .",
    "once again , the switch is sure to happen , implying that every play conforming to @xmath146 reaches the target : moreover , the cost of such a play is necessarily at most @xmath627 by construction .",
    "then , we directly obtain that @xmath628 .",
    "we rely on the proofs of @xcite that can easily be adapted in our case , even though we must give the whole explanation here , knowing that prices coming from goal functions can be rational , and hence do not strictly fall in the framework of @xcite .",
    "since all locations in @xmath78 are urgent , we may extract from a play @xmath629 the clock valuations , as well as prices @xmath630 , hence denoting plays by their sequence of locations @xmath631 .",
    "the cost of this play is @xmath632 if @xmath633 for all @xmath634 ; and @xmath635 if @xmath464 is the least position such that @xmath636 .",
    "let us show how to compute the vector @xmath637 , for a given @xmath638 $ ] , in terms of a sequence of values .",
    "following the arguments of @xcite , we first observe that locations @xmath93 with values @xmath639 and @xmath640 can be pre - computed ( using respectively attractor and mean - payoff techniques ) and removed from the game without changing the values of the other nodes .",
    "then , because of the particular structure of the game @xmath78 ( where a real cost is paid only on the target location , all other prices being integers ) , for all plays @xmath143 , @xmath641 is a value from the set @xmath642 .",
    "we further define @xmath643 .",
    "clearly , @xmath644 contains at most @xmath645 values between two consecutive integers , i.e. , @xmath646\\cap{\\ensuremath{{\\ensuremath{\\mathbf{z}}}_{{\\ensuremath{\\nu}\\xspace},{\\ensuremath{\\boldsymbol{\\varphi}}}}}}| { \\leqslant}|{\\ensuremath{{\\ensuremath{l}}_f}}| \\label{eq : at - least - qfin}\\ ] ]    then , we define an operator @xmath647 mapping every vector @xmath648 of @xmath649 to @xmath650 defined by @xmath651 we will obtain @xmath652 as the limit of the sequence @xmath653 defined by @xmath654 if @xmath655 , and @xmath656 if @xmath657 , and then @xmath658 for @xmath277 .",
    "the intuition behind is that _",
    "@xmath659 is the value of the game ( when the clock takes value @xmath9 ) if we impose that @xmath0 must reach the target within @xmath139 steps _ ( and get a payoff of @xmath4 if it fails to do so ) .",
    "formally , for a play @xmath660 , we let @xmath661 if @xmath636 for some @xmath662 , and @xmath663 otherwise",
    ". we further let @xmath664 ( where @xmath665 and @xmath666 are respectively strategies of @xmath1 and @xmath0 ) .",
    "lemma  1 of @xcite allows us to easily obtain that    for all @xmath277 , and @xmath667 : @xmath668 .",
    "now , let us study how the sequence @xmath669 behaves and converges to the finite values of the game .",
    "using again the same arguments as in @xcite ( @xmath670 is a monotonic and scott - continuous operator over the complete lattice @xmath649 , etc ) , the sequence @xmath669 converges towards the greatest fixed point of @xmath670 .",
    "let us now show that @xmath671 is actually this greatest fixed point .",
    "first , corollary  1 of @xcite can be adapted to obtain    [ lem : after - n - steps - no - infty ] for all @xmath667 : @xmath672 .",
    "the next step is to show that the values that can be computed along the sequence ( still assuming that @xmath673 is finite for all @xmath93 ) are taken from a finite set :    for all @xmath277 and for all @xmath667 : @xmath674 \\cap { \\ensuremath{{\\ensuremath{\\mathbf{z}}}_{{\\ensuremath{\\nu}\\xspace},{\\ensuremath{\\boldsymbol{\\varphi}}}}}}\\ ] ] where @xmath675 has cardinality bounded by @xmath676 .    following the proof of ( * ?",
    "? ? * lemma  3 ) , it is easy to show that if @xmath0 can secure , from some vertex @xmath93 , a cost less than @xmath677 , i.e. , @xmath678 , then it can secure an arbitrarily small cost from that configuration , i.e. , @xmath268 , which contradicts our hypothesis that the value is finite .",
    "hence , for all @xmath277 , for all @xmath93 : @xmath679 . by lemma  [ lem : after - n - steps - no - infty ] and since the sequence is non - increasing , we conclude that , for all @xmath277 and for all @xmath667 : @xmath680 since all @xmath681 are also in @xmath644 , we conclude that @xmath682 for all @xmath277 .",
    "the upper bound on the size of @xmath675 is established by .",
    "this allows us to bound the number of iterations needed for the sequence to stabilise .",
    "the worst case is where all locations are assigned a value bounded below by @xmath677 from the highest possible value where all vertices are assigned a value bounded above by @xmath683 , which is itself reached after @xmath684 steps .",
    "hence :    the sequence @xmath669 stabilises after a number of steps at most @xmath685 .",
    "finally , the proofs of ( * ? ? ?",
    "* lemma  4 and corollary  2 ) allow us to conclude that this sequence converges towards the value @xmath652 of the game ( when all values are finite ) , which proves that the value iteration scheme of  [ algo : value - iteration - fixed ] computes exactly @xmath652 for all @xmath240 $ ] .",
    "indeed , this algorithm also works when some values are not finite . as a corollary",
    ", we obtain a characterisation of the possible values of @xmath78 :    [ cor : possible - values ] for all @xmath193-sptg@xmath78 with only urgent locations , for all location @xmath667 and valuation @xmath240 $ ] , @xmath686 is contained in the set @xmath687 of cardinal @xmath688 , pseudo - polynomial with respect to the size of  @xmath78 .    finally , section 3.4 and 3.5 of @xcite",
    "explain how to compute simultaneously optimal strategies for both players .",
    "in our context , this allows us to obtain for every valuation @xmath638 $ ] and location @xmath93 of an @xmath193-sptg , such that @xmath242 , a memoryless optimal strategy for @xmath1 , and an optimal switching strategy for @xmath0 : a switching strategy is described by a pair @xmath221 of memoryless strategies and a switch threshold @xmath222 , so that the optimal strategy is obtained by playing @xmath223 until the value of the current finite play is below @xmath222 , in which case , we switch to strategy @xmath224 , that can be taken as an attractor strategy , that only wants to reach a final location .",
    "still for an @xmath193-sptgwith only urgent locations , we now study a precise characterisation of the functions @xmath689 \\mapsto { \\ensuremath{{\\sf val}}}({\\ensuremath{\\ell}},{\\ensuremath{\\nu}\\xspace})$ ] , for all @xmath93 , in particular showing that these are cost functions of @xmath690\\}}}}$ ] .",
    "we first define the set @xmath244 of affine functions over @xmath245 $ ] as follows : @xmath691\\cap{\\ensuremath{\\mathbf{z}}}\\}\\ ] ] observe that this set is finite and that its cardinality is @xmath249 , pseudo - polynomial in the size of @xmath78 .",
    "moreover , as a direct consequence of corollary  [ cor : possible - values ] , this set contains enough information to compute the value of the game in each possible valuation of the clock , in the following sense :    [ lem : for - all - val - there - is - f - in - f ] for all @xmath251 , for all @xmath240 $ ] : if @xmath692 is finite , then there is @xmath253 such that @xmath254 .",
    "we compute the set of intersections of two affine functions of @xmath248 : @xmath693\\mid \\exists f_1,f_2\\in{{\\sf f}}_{{\\ensuremath{\\mathcal g}\\xspace}}\\quad f_1\\neq f_2\\land f_1({\\ensuremath{\\nu}\\xspace})=f_2({\\ensuremath{\\nu}\\xspace})\\}\\,.\\ ] ] this set is depicted in figure  [ fig : network - posscp ] on an example .",
    "observe that @xmath256 contains at most @xmath694 points since all functions from @xmath244 are affine , hence they can intersect at most once with every other function .",
    "thus , the cardinality of @xmath256 is @xmath263 , also bounded by a pseudo - polynomial in the size of  @xmath78 .",
    "moreover , since all functions of @xmath244 take rational values in @xmath10 and @xmath259 , we know that @xmath258 .",
    "this set contains all the cutpoints of the value function of @xmath78 , as shown in proposition  [ prop : basecase ] .    at ( 7,0 ) @xmath9 ; ( -0.3,0 )  ( 7,0 ) ; ( 0,-1.7 )  ( 0,5 ) ; at ( 0,0 ) 0 ; at ( 6,0 ) @xmath193 ; ( 6,-1.7 )  ( 6,4.5 ) ;    ( 0,3 )  ( 6,4 ) ; ( 0,2 )  ( 6,3 ) ; ( 0,1 )  ( 6,2 ) ;    ( 0,4.5 ) ",
    "( 6,0.5 ) ; ( 0,3.5 ) ",
    "( 6,-0.5 ) ; ( 0,2.5 )  ( 6,-1.5 ) ;    ( 0,2.5 ) ",
    "( 6,2.5 ) ; ( 0,1.5 ) ",
    "( 6,1.5 ) ; ( 0,0.5 ) ",
    "( 6,0.5 ) ;    /in gd / hu , g / fu , g / hu , fu / gu , f / gu , gu / fd , h / gu , gu / hd ( x ) ; ; ( y ) at ( , 0 ) ; ( x )  ( y ) ;    notice , that this result allows us to compute @xmath695 for every @xmath667 . first , we compute the set @xmath696 , which can be done in pseudo - polynomial time in the size of @xmath78",
    ". then , for all @xmath697 , we can compute the vectors @xmath698 of values in each location when the clock takes value @xmath699 using  [ algo : value - iteration - fixed ] .",
    "this provides the value of @xmath695 in each cutpoint , for all locations @xmath93 , which is sufficient to characterise the whole value function , as it is continuous and piecewise affine .",
    "observe that all cutpoints , and values in the cutpoints , in the value function are rational numbers , so  [ algo : value - iteration - fixed ] is effective .",
    "thanks to the above discussions , this procedure consists in a pseudo - polynomial number of calls to a pseudo - polynomial algorithm , hence , it runs in pseudo - polynomial time .",
    "this allows us to conclude that @xmath260 is a cost function for all @xmath93 .",
    "this proves item ( iii ) of the definition of finite optimality for sptgs with only urgent locations    let us conclude the proof that sptgs are finitely optimal by showing that @xmath0 has a fake - optimal nc - strategy , and @xmath1 has an optimal fp - strategy .",
    "let @xmath700 be the sequence of elements from @xmath256 in increasing order , and let us assume @xmath701 .",
    "for all @xmath702 let @xmath703 be the function from @xmath248 that defines the piece of @xmath260 in the interval @xmath704 $ ] ( we have shown above that such an @xmath703 always exists ) . formally , for all @xmath702 , @xmath705 verifies @xmath706 , for all",
    "@xmath707 $ ] .",
    "next , for all @xmath708 , let @xmath709 be a value taken in the middle of @xmath710 $ ] , i.e. , @xmath711 .",
    "note that all @xmath712 s are rational values since all @xmath508 s are . by applying in each @xmath712",
    ", we can compute @xmath713 , and we can extract an optimal memoryless strategy @xmath714 for @xmath1 and an optimal switching strategy @xmath715 for @xmath0 .",
    "thus we know that , for all @xmath667 , playing @xmath715 ( respectively , @xmath714 ) from @xmath716 allows @xmath0 ( respectively , @xmath1 ) to ensure a cost at most ( respectively , at least ) @xmath717 .",
    "however , it is easy to check that the bound given by @xmath718 holds in every valuation , i.e. , for all @xmath93 , for all @xmath9 @xmath719 this holds because :    @xmath0 can play @xmath715 from all clock valuations ( in @xmath720 $ ] ) since we are considering an @xmath64-sptg ; and    @xmath1 does not have more possible strategies from an arbitrary valuation @xmath721 $ ] than from  @xmath712 , because all locations are urgent and time can not elapse ( neither from @xmath9 , nor from @xmath712 ) .    and symmetrically for @xmath1 .",
    "we conclude that @xmath0 can consistently play the same strategy @xmath715 from all configurations @xmath112 with @xmath722 $ ] and secure a cost which is at most @xmath723 , i.e. , @xmath715 is optimal on this interval . by definition of @xmath715 , it is easy to extract from it a fake - optimal nc - strategy ( actually , @xmath715 is a switching strategy described by a pair @xmath221 , and @xmath223 can be used to obtain the fake - optimal nc - strategy ) .",
    "the same reasoning applies to strategies of @xmath1 and we conclude that @xmath1 has an optimal fp - strategy .",
    "we start with an auxiliary lemma showing a property of the rates of change of the value functions associated to non - urgent locations    [ lem : rate ] let @xmath78 be an @xmath64-sptg , @xmath93 and @xmath94 be non - urgent locations of @xmath0 and @xmath1 , respectively .",
    "then for all @xmath724 : @xmath725    for the location @xmath93 , the inequality rewrites in @xmath726 using the upper definition of the value ( thanks to the determinacy result of theorem  [ thm : determined ] ) , it suffices to prove , for all @xmath442 , the existence of a strategy @xmath666 such that for all strategies @xmath665 of the opponent @xmath727 the definition of the value implies the existence of a strategy @xmath728 such that for all strategies @xmath665 @xmath729 then , @xmath666 can be obtained by playing from @xmath112 , at the first turn , as prescribed by @xmath728 but delaying @xmath730 time units more ( that we are allowed to do since @xmath93 is non - urgent ) , and , for other turns , directly like @xmath728 .",
    "a similar reasoning allows us to obtain the result for @xmath94 .",
    "then , we observe that the construction of @xmath303 does not alter the value of the game :    [ lem : waiting ] for all @xmath721 $ ] and locations @xmath93 , @xmath731 .    now",
    ", we turn our attention to the construction of @xmath270 .",
    "we show that , even if the locations in @xmath271 are turned into urgent locations , we may still obtain for them a similar result of the rates of change as the one of lemma  [ lem : rate ] :    [ lem : bounded ] for all locations @xmath335 ( respectively , @xmath336 ) , and @xmath721 $ ] , @xmath732 ( respectively , @xmath733 .",
    "it suffices to notice that from @xmath112 , @xmath0 ( respectively , @xmath1 ) may choose to go directly in @xmath305 ensuring the value @xmath734 .",
    "let @xmath146 and @xmath151 be a fake - optimal nc - strategy of @xmath0 and an optimal fp - strategy of @xmath1 in @xmath319 , respectively .",
    "notice that both strategies are also well - defined finite positional strategies in @xmath270 .",
    "first , let us show that @xmath146 is indeed an nc - strategy in @xmath270 . take a finite play @xmath735 , of length @xmath736 , that conforms with @xmath146 in @xmath270 , and with @xmath737 and @xmath738 in the same interval @xmath95 of @xmath228 .",
    "for every @xmath739 that is in @xmath80 , and @xmath740 , @xmath741 must have a @xmath10 delay , otherwise @xmath530 would not be in the same interval as @xmath742 .",
    "thus , the play @xmath743 also conforms with @xmath146 ( with possibly different costs ) .",
    "furthermore , as all the delays are @xmath10 we are sure that this play is also a valid play in @xmath319 , in which @xmath146 is an nc - strategy .",
    "therefore , @xmath744 , and @xmath146 is an nc - strategy in @xmath270 .",
    "we now show the result for @xmath745 .",
    "the proof for @xmath746 is a straightforward adaptation .",
    "notice that every play in @xmath270 that conforms with @xmath146 is also a play in @xmath319 that conforms with @xmath146 , as @xmath146 is defined in @xmath319 and thus plays with no delay in location @xmath93 .",
    "thus , for all @xmath322 $ ] and @xmath323 , by the optimality result of lemma  [ lem : fake - optimality ] , @xmath747    to obtain that @xmath748 , it remains to show the reverse inequality . to that extent ,",
    "let @xmath148 be a finite play in @xmath270 that conforms with @xmath151 , starts in a configuration @xmath749 with @xmath322 $ ] , and ends in a final location .",
    "we show by induction on the length of @xmath148 that @xmath750 .",
    "if @xmath148 has size @xmath5 then @xmath94 is a final configuration and @xmath751 .    otherwise @xmath752 where @xmath504 is a run that conforms with @xmath151 , starting in a configuration @xmath753 and ending in a final configuration . by induction hypothesis",
    ", we have @xmath754 .",
    "we now distinguish three cases , the two first being immediate :    * , then @xmath755 leads to the next configuration @xmath753 , thus @xmath756 * , we have that @xmath757 is a valid transition in @xmath408",
    ". therefore , @xmath758 , hence @xmath759 * finally , , then @xmath760 . as @xmath761 is a valid transition in @xmath319 , we have @xmath762 .",
    "furthermore , since @xmath763 $ ] , we can use to obtain @xmath764 therefore @xmath765    this concludes the induction . as a consequence , @xmath766 for all locations @xmath94 and @xmath322 $ ] , which finally proves that @xmath767 .",
    "fake - optimality of @xmath666 over @xmath309 $ ] in @xmath319 is then obtained by .",
    "this lemma allows us to effectively compute @xmath332 :    [ lem : operatornext ] let @xmath78 be an @xmath768 , @xmath302 , and @xmath769 $ ] , such that @xmath770 is finitely optimal for all @xmath771 .",
    "then , @xmath334 is the minimal valuation such that for all locations @xmath335 ( respectively , @xmath336 ) , the slopes of the affine sections of the cost function @xmath337 on @xmath331 $ ] are at least ( respectively , at most ) @xmath338 .",
    "moreover , @xmath341 .    since @xmath772 on @xmath331 $ ] , and as @xmath93 is non - urgent in @xmath78 , lemma  [ lem : rate ] states that all the slopes of @xmath236 are at least ( respectively , at most ) @xmath338 on @xmath331 $ ] .",
    "we now show the minimality property by contradiction . therefore , let @xmath773 such that all cost functions @xmath337 are affine on @xmath774 $ ] , and assume that for all @xmath335 ( respectively , @xmath336 ) , the slopes of @xmath337 on @xmath774 $ ] are at least ( respectively , at most ) @xmath338 .",
    "hence , this property holds on @xmath775 $ ] .",
    "then , by applying proposition  [ lem : samevalue ] @xmath776 times ( here , we use the finite optimality of the games @xmath770 with @xmath771 ) , one can show that for all @xmath777 $ ] @xmath778 . using lemma  [ lem : waiting ]",
    ", we also know that for all @xmath301 , and @xmath93 , @xmath779 .",
    "thus , @xmath780 . as @xmath773 , this contradicts the definition of @xmath334 .",
    "we finally prove that @xmath341 .",
    "this is immediate in case @xmath781 , since @xmath782 .",
    "otherwise , from the result obtained previously , we know that there exists @xmath773 , and @xmath783 such that @xmath784 is affine on @xmath774 $ ] of slope smaller ( respectively , greater ) than @xmath785 if @xmath369 ( respectively , @xmath786 ) , i.e. , @xmath787 from lemma  [ lem : bounded ] , we also know that @xmath788 both equations combined imply @xmath789 which is not possible if @xmath790 .",
    "[ lem : eqgoal ] assume that @xmath791 is finitely optimal .",
    "if @xmath792 is affine on a non - singleton interval @xmath793 $ ] with a slope greater has minimal price amongst locations of @xmath78 .",
    "] than @xmath785 , then there exists @xmath794 such that for all @xmath740 , @xmath795 .",
    "let @xmath146 and @xmath151 be some fake - optimal nc - strategy and optimal fp - strategy in @xmath791 . as @xmath95 is a non - singleton interval , there exists a subinterval @xmath796 , which is not a singleton and is contained in a interval of @xmath146 and of @xmath151 .",
    "let @xmath797 . as already noticed in the proof of lemma  [ lem : r_2-r_1-r_0 ] , the play @xmath798 necessarily reaches a final location and has cost @xmath356 .",
    "let @xmath799 be its prefix until the first final location @xmath539 ( the prefix used to compute the cost of the play ) .",
    "we also let @xmath800 be a valuation such that @xmath801 .",
    "assume by contradiction that there exists an index @xmath139 such that @xmath802 and let @xmath139 be the smallest of such indices .",
    "for each @xmath803 , if @xmath804 , let @xmath805 and @xmath806 .",
    "similarly , if @xmath807 , we let @xmath808 and @xmath809 . as @xmath810 is contained in an interval of @xmath146 and @xmath151 , we have @xmath811 and either @xmath812 , or @xmath813 . applying this result for all @xmath814",
    ", we obtain that @xmath815 is a prefix of @xmath816 : notice moreover that , as before , this prefix has cost @xmath817 .",
    "in particular , @xmath818 which implies that the slope of @xmath792 is at most @xmath785 , and therefore contradicts the hypothesis . as a consequence , we have that @xmath819 for all @xmath139 .",
    "again by contradiction , assume now that @xmath820 for some @xmath821 . by the same reasoning as before , we then would have @xmath822 , which again contradicts the hypothesis",
    ".    therefore , @xmath823 .",
    "if we let @xmath824 , we have @xmath825 . since @xmath146 and @xmath151 are fp - strategies , that play constantly in valuation @xmath9 , we know that @xmath826 has no cycle , therefore @xmath827\\cap { \\ensuremath{\\mathbf{z}}}$ ] .",
    "notice that the previous developments also show that for all @xmath800 ( here , @xmath801 is not needed ) , @xmath828 , with the same location @xmath539 , and weight @xmath464 .",
    "since this equality holds on @xmath829 which is not a singleton , and @xmath792 is affine on @xmath95 , it holds everywhere on @xmath95 .      for the first item , we assume @xmath830 , since the proof of the other case only differ with respect to the sense of the inequalities . from lemma  [ lem : operatornext ] , we know that in @xmath365 there exists @xmath831 such that @xmath832 is affine of @xmath833 $ ] and its slope is smaller that @xmath785 , i.e. , @xmath834 .",
    "lemma  [ lem : bounded ] also ensures that @xmath835 . combining both inequalities allows us to conclude .",
    "we now turn to the proof of the second item , showing the stationarity of sequence @xmath836 .",
    "we consider first the case where .",
    "let @xmath363 such that @xmath837 ( if there exist no such @xmath139 then @xmath838 ) .",
    "recall from lemma  [ lem : operatornext ] that there exists @xmath839 such that @xmath840 is affine on @xmath841 $ ] , of slope greater than @xmath785 . in particular , @xmath842 lemma  [ lem : eqgoal ] states that on @xmath841 $ ] , @xmath840 is equal to some @xmath843 .",
    "as @xmath844 is an affine function , @xmath845 , and @xmath846 , for all  @xmath9 , @xmath847 since @xmath391 is assumed to be finitely optimal , we know that @xmath848 , by definition of @xmath362 . therefore , for all valuation @xmath849 , we have @xmath850 .",
    "consider then @xmath851 such that @xmath852 .",
    "we claim that @xmath853 .",
    "indeed , we have @xmath854 . as , in @xmath78",
    ", @xmath359 is a non - urgent location , lemma  [ lem : rate ] ensures that ( @xmath855 ) : @xmath856 . as for all @xmath857 , @xmath858 , ( @xmath855 )",
    "is equivalent to @xmath859 .",
    "recall that @xmath844 has a slope strictly greater that @xmath785 , therefore @xmath860 . as a consequence @xmath861 ( this is depicted in figure  [ fig : fineqfj ] ) .    at ( 0,5 ) @xmath862 ; at ( 7,0 ) @xmath9 ; ( -0.3,0 ) ",
    "( 7,0 ) ; ( 0,-0.3 )  ( 0,5 ) ; ( 6,0 ) ",
    "( 6,5 ) ; ( 3,0 ) ",
    "( 3,5 ) ; ( 7,4 )  ( -0.5,0.25 ) ; at ( 7,4 ) @xmath785 ;    ( 6,3.5 )  + + ( -0.75,-0.375 )  + + ( -0.75,0.2 )  + + ( -0.75,-0.1 ) ",
    "+ + ( -0.75,-0.375 )  + + ( -1,-0.5 )  + + ( -1,0.4 ) ; ( 6,3.5 )  + + ( 0.5,-0.3 ) ; ( 3,2.85 ) ",
    "+ + ( -2,-1 ) ;    ( 6,3.5 )  + + ( -1.5,-2 ) ; ( 3,2.85 )  + +",
    "( -1.5,-1.5 ) ; at ( 4.5,1.5 ) @xmath844 ; at ( 1.5,1.35 ) @xmath863 ;    at ( 3,0 ) @xmath864 ; at ( 6,0 ) @xmath368 ;    therefore , there can not be more than @xmath865 non - null elements in the sequence @xmath866 , which proves that there exists @xmath867 such that @xmath366 .",
    "we continue with the case where .",
    "let @xmath868 . in this case , we look at the affine parts of @xmath869 with a slope greater than @xmath785 , and we show that there can only be finitely many such segment in @xmath870 $ ] .",
    "we then show that there is at least one such segment contained in @xmath279 $ ] for all @xmath139 , bounding the size of the sequence .    in the following , we call _ segment _ every interval @xmath871\\subset ( r_\\infty,1]$ ] such that @xmath346 and @xmath412 , are two consecutive cutpoints of the cost function @xmath869 over @xmath872 $ ] .",
    "recall that it means that @xmath869 is affine on @xmath871 $ ] , and if we let @xmath873 be the greatest cutpoint smaller than @xmath346 , and @xmath874 the smallest cutpoint greater than @xmath412 , the slopes of @xmath869 on @xmath875 $ ] and @xmath876 $ ] are different from the slope on @xmath871 $ ] .",
    "we abuse the notations by referring to _ the slope of a segment @xmath871 $ ] _ for the slope of @xmath869 on @xmath871 $ ] and simply call _ cutpoint _ a cutpoint of @xmath869 .    to every segment @xmath871 $ ] with a slope greater than @xmath785 , we associate a function @xmath877}\\in { { \\sf f}}_{\\ensuremath{\\mathcal g}\\xspace}$ ] as follows .",
    "let @xmath139 be the smallest index such that @xmath871\\cap[r_{i+1},r_i]$ ] is a non singleton interval @xmath878 $ ] .",
    "lemma  [ lem : eqgoal ] ensures that there exists @xmath877}\\in { { \\sf f}}_{\\ensuremath{\\mathcal g}\\xspace}$ ] such that for all @xmath879 $ ] , @xmath880}({\\ensuremath{\\nu}\\xspace})$ ] .",
    "consider now two disjoint segments @xmath871 $ ] and @xmath881 $ ] with a slope strictly greater than @xmath785 , and assume that @xmath877}=f_{[c , d]}$ ] ( in particular both segments have the same slope )",
    ". without loss of generality , assume that @xmath882 .",
    "we claim that there exists a segment @xmath883 $ ] in - between @xmath871 $ ] and @xmath881 $ ] with a slope greater than the slope of @xmath881 $ ] , and that @xmath884}$ ] and @xmath877}$ ] intersect over @xmath885 $ ] , in a point of abscisse @xmath21 , i.e. , @xmath886 $ ] verifies @xmath884}(x ) = f_{[a , b]}(x)$ ] ( depicted in figure  [ fig : puregeometry ] ) .",
    "( 2,0.5 ) ",
    "( 2.25,4 ) ",
    "( 4,6.5 ) ",
    "( 6,6 ) ; ( -0.5,-0.5 )  ( 6.5,6.5 ) ;    at ( 0,0 ) @xmath346 ; at ( 1,1 ) @xmath412 ; at ( 2,0.5 ) @xmath489 ; at ( 2.25,4 ) @xmath887 ; at ( 4,6.5 ) @xmath888 ; at ( 5,5 ) @xmath117 ; at ( 6,6 ) @xmath889 ; at ( 2.115,2.115 ) @xmath347 ; at ( 2.115,2.115 ) @xmath21 ;    let @xmath888 be the greatest cutpoint smaller than @xmath117 .",
    "we know that the slope of @xmath890 $ ] is different from the one of @xmath881 $ ] .",
    "if it is greater then define @xmath891 and @xmath892 , those indeed satisfy the property .",
    "if the slope of @xmath890 $ ] is smaller than the one of @xmath881 $ ] , then for all @xmath893 , @xmath894}({\\ensuremath{\\nu}\\xspace})$ ] .",
    "let @xmath21 be the greatest point in @xmath895 $ ] such that @xmath896}(x)$ ] .",
    "we know that it exists since @xmath897}(b)$ ] , and @xmath869 is continuous .",
    "observe that @xmath894}({\\ensuremath{\\nu}\\xspace})$ ] , for all @xmath898 .",
    "finally , let @xmath489 be the smallest cutpoint of @xmath869 strictly greater than @xmath21 , and @xmath887 the greatest cutpoint of @xmath869 smaller than or equal to @xmath21 . by construction @xmath883",
    "$ ] is a segment that contains @xmath21 .",
    "the slope of the segment @xmath883 $ ] is @xmath899}=\\frac{{{\\ensuremath{{\\sf val}}}}_{\\ensuremath{\\mathcal g}\\xspace}({\\ensuremath{{\\ensuremath{\\ell}}^\\star}},g ) - { { \\ensuremath{{\\sf val}}}}_{\\ensuremath{\\mathcal g}\\xspace}({\\ensuremath{{\\ensuremath{\\ell}}^\\star}},x)}{g - x}$ ] , and the slope of the segment @xmath881 $ ] is equal to @xmath900 } = \\frac{f_{[c , d]}(g ) - f_{[c , d]}(x)}{g - x}$ ] . remembering that @xmath896}(x)$ ] , and that @xmath901}(g)$ ] since @xmath902",
    ", we obtain that @xmath899 } > s_{[c , d]}$ ] .",
    "finally , since @xmath896}(x ) = f_{[e , g]}(x)$ ] , it is indeed the abscisse of the intersection point of @xmath903}=f_{[a , b]}$ ] and @xmath884}$ ] , which concludes the proof of the previous claim .",
    "for every function @xmath794 , there are less than @xmath904 intersection points between @xmath58 and the other functions of @xmath248 ( at most one for each pair @xmath905 ) . if @xmath58 has a slope greater than @xmath785 , thanks to the previous paragraph , we know that there are at most @xmath904 segments @xmath871 $ ] such that @xmath877}=f$ ] .",
    "summing over all possible functions @xmath58 , there are at most @xmath906 segments with a slope greater than @xmath785 .",
    "now , we link those segments with the valuations @xmath368 s , for @xmath363 . by item @xmath907 ,",
    "thanks to the finite - optimality of @xmath908 , @xmath909 .",
    "furthermore , lemma  [ lem : r_2-r_1-r_0 ] states that the slope of the segment directly on the left of @xmath368 is equal to @xmath785 . with the previous inequality in mind",
    ", this can not be the case if @xmath869 is affine over the whole interval @xmath910 $ ] .",
    "thus , there exists a segment @xmath871 $ ] of slope strictly greater than @xmath785 such that @xmath911 $ ] . as we also know",
    "that the slope left to @xmath912 is @xmath785 , it must be the case that @xmath913 $ ] .",
    "hence , we have shown that in - between @xmath912 and @xmath368 , there is always a segment ( this is depicted in figure  [ fig : slopeslocmin ] ) . as the number of such segments is bounded by @xmath906 , we know that the sequence @xmath368 is stationary in at most @xmath914 steps , i.e. , that there exists @xmath915 such that @xmath366 .    at ( 0,5 ) @xmath862 ; at ( 7,0 ) @xmath9 ; ( -0.3,0 )  ( 7,0 ) ; ( 0,-0.3 )  ( 0,5 ) ; ( 6,0 )  ( 6,5 ) ; ( 3,0 )  ( 3,5 ) ; ( 7,4 )  ( -0.5,0.25 ) ; at ( 7,4 ) @xmath785 ;    at ( 3,0 ) @xmath912 ; at ( 6,0 ) @xmath368 ;    ( 6,3.5 )  ( 5,3 ) ; ( 5,3 )  ( 4,1.5 ) ; ( 4,1.5 ) ",
    "( 2,0.5 ) ",
    "( 1,-0.3 ) ; at ( 5,3 ) @xmath347 ; at ( 4,1.5 ) @xmath347 ; at ( 0,2 ) @xmath916 + @xmath917 ; ( 0,2 )  ( 3,2 ) ;    ( 3,1 ) ",
    "+ + ( -2.5,-1.25 ) ;      we denote by @xmath379 the smallest valuation ( smaller than @xmath918 ) such that for all locations  @xmath93 , @xmath330 is affine over @xmath402 $ ] .",
    "then , the proof goes by contradiction : using lemma  [ lem : operatornext ] , we assume that for all @xmath919 ( respectively , @xmath920 ) :    * either ( @xmath921 ) the slope of @xmath330 on @xmath402 $ ] is greater ( respectively , smaller ) than @xmath338 , * or ( @xmath922 ) for all @xmath923 $ ] , @xmath924 .",
    "let @xmath925 and @xmath926 ( respectively , @xmath223 and @xmath927 ) be a fake - optimal nc - strategy and an optimal fp - strategy in @xmath274 ( respectively , @xmath928 ) .",
    "let @xmath929 , so that strategies @xmath223 and @xmath927 have the _ same behaviour _ on all valuations of the interval @xmath930 , i.e. , either always play urgently the same transition , or wait , in a non - urgent location , until reaching some valuation greater than or equal to @xmath918 and then play the same transition .",
    "observe preliminarily that for all @xmath919 ( respectively , @xmath920 ) , if on the interval @xmath930 , @xmath223 ( respectively , @xmath927 ) goes to @xmath305 then the slope on @xmath931 $ ] ( and thus on @xmath402 $ ] ) is @xmath338 .",
    "thus for such a location @xmath93 , we know that @xmath922 holds for @xmath93 ( by letting @xmath379 be @xmath932 ) .    for other locations @xmath93 , we will construct a new pair of nc- and fp - strategies @xmath146 and @xmath151 in @xmath274 such that for all locations @xmath93 and valuations @xmath933 @xmath934 as a consequence , with lemma  [ lem : fake - optimality ] ( over game @xmath274 ) , one would have that @xmath935 , which will raise a contradiction with the definition of @xmath918 as @xmath936 ( by lemma  [ lem : operatornext ] ) , and conclude the proof .",
    "we only show the construction for @xmath146 , as it is very similar for @xmath151 .",
    "strategy @xmath146 is obtained by combining strategies @xmath223 over @xmath937 $ ] , and @xmath925 over @xmath938 $ ] : a special care has to be spent in case @xmath223 performs a jump to a location @xmath305 , since then , in @xmath146 , we rather glue this move with the decision of strategy @xmath925 in @xmath939 .",
    "formally , let @xmath112 be a configuration of @xmath274 with @xmath745 . we construct @xmath940 as follows :    * if @xmath941 , @xmath942 ; * if @xmath943 , @xmath944 and @xmath945 for some delay @xmath133 ( such that @xmath946 ) , we let @xmath947 where @xmath948 ; * otherwise @xmath949 .    for all finite plays @xmath148 in @xmath274 that conform to @xmath146 , start in a configuration @xmath112 such that @xmath950 $ ] and @xmath951 , and end in a final location , we show by induction that @xmath952 . note that @xmath148 either only contains valuations in @xmath938 $ ] , or is of the form @xmath953 , or is of the form @xmath954 with @xmath504 a run that satisfies the above restriction .    *",
    "if @xmath955 $ ] , then @xmath148 conforms with @xmath925 , thus , as @xmath925 is fake - optimal , @xmath956 ( the last inequality comes from the definition of @xmath957 ) .",
    "therefore , in the following cases , we assume that @xmath933 .",
    "* consider then the case where @xmath148 is of the form @xmath953 . * * if @xmath335 , @xmath93 is urgent in @xmath274 , thus @xmath958 .",
    "furthermore , since @xmath148 conforms with @xmath146 , by construction of @xmath146 , the choice of @xmath223 on @xmath930 consists in going to @xmath305 , thus , as observed above , @xmath922 holds for @xmath93 .",
    "therefore , @xmath959 . * * if @xmath960 , by construction , it must be the case that @xmath961 where @xmath962 and @xmath963 .",
    "thus , @xmath964 . in particular , observe that @xmath965 where @xmath966 . as @xmath504 conforms with @xmath925 which is fake - optimal in @xmath274 , @xmath967 ( since @xmath968 ) .",
    "thus @xmath969 where @xmath970 conforms with @xmath223 which is fake - optimal in @xmath928 .",
    "therefore , @xmath971 ( since @xmath968 ) . * * if @xmath972 then @xmath973 . by lemma  [ lem : rate ] , since @xmath974 ( @xmath93 is not urgent in @xmath78 since @xmath305 exists ) , @xmath975 .",
    "furthermore , observe that if we define @xmath504 as the play @xmath976 in @xmath928 , then @xmath504 conforms with @xmath223 and @xmath977 thus , as @xmath223 is fake - optimal in @xmath928 , @xmath978 .",
    "* we finally consider the case where @xmath979 with @xmath504 that starts in configuration @xmath113 such that @xmath980 . by induction hypothesis @xmath981 . * * if @xmath982 , let @xmath983 be the play of @xmath928 starting in @xmath113 that conforms with @xmath223 and @xmath927 . if @xmath983 does not reach a final location , since @xmath223 is an nc - strategy , the costs of its prefixes tend to @xmath63 . by considering the strategy @xmath234 of lemma  [ lem : fake - optimality ] ,",
    "we would obtain a run conforming with @xmath927 of cost smaller than @xmath984 which would contradict the optimality of @xmath927 .",
    "hence , @xmath983 reaches the target .",
    "moreover , since @xmath927 is optimal and @xmath223 is fake - optimal , we finally know that @xmath985 ( since @xmath986 $ ] )",
    ". therefore , @xmath987 since the play @xmath988 conforms with @xmath223 , we finally have @xmath989 . * * if @xmath990 and @xmath972 , let @xmath991 be the play in @xmath928 defined by @xmath992 and @xmath993 the play in @xmath274 defined by @xmath994 .",
    "we have @xmath995 since @xmath996 conforms with @xmath925 , fake - optimal , and reaches a final location , @xmath997 ( since @xmath957 ) .",
    "we also have that @xmath991 conforms with @xmath223 , so the previous explanations already proved that @xmath998 . as a consequence @xmath952 . * * if @xmath990 and @xmath745 , we know that @xmath93 is non - urgent , so that @xmath999",
    ". therefore , by definition of @xmath146 , @xmath1000 where @xmath1001 for some delay @xmath133 , and @xmath1002 .",
    "if we let @xmath991 be the play in @xmath928 defined by @xmath1003 and @xmath993 the play in @xmath274 defined by @xmath1004 , as in the previous case , we obtain that @xmath952 .    as a consequence of this induction",
    ", we have shown that for all @xmath251 , and for all @xmath933 , @xmath1005 , which shows one inequality of , the other being obtained very similarly .",
    "( 6,0 )  ( 11,0 ) node[anchor = north ] @xmath21 ; ( 6,0 ) node[anchor = south ] @xmath10 ( 7,0 ) node[anchor = south ] @xmath11 ( 8,0 ) node[anchor = south ] @xmath12 ( 9,0 ) node[anchor = south ] @xmath13 ( 10,0 ) node[anchor = north ] @xmath5 ;    ( 6,0 )  ( 6,-4 ) node[anchor = east ] @xmath1006 ; ( 6,-3.3 ) node[anchor = east ] @xmath16 ( 6,-2 ) node[anchor = east ] @xmath17 ( 6.05,-1.85 ) node[anchor = west ] @xmath18 ( 6,-0.6 ) node[anchor = east ] @xmath19 ( 6,0.3 ) node[anchor = east ] @xmath5 ;    ( 6,-3.3 )  ( 7,-2 )  ( 8,-1.85)(9,-0.6)(10,0.3 ) ;    ( 6,-5 )  ( 11,-5 ) node[anchor = north ] @xmath21 ; ( 6,-5 ) node[anchor = south ] @xmath10 ( 7,-5 ) node[anchor = south ] @xmath11 ( 8,-5 ) node[anchor = south ] @xmath12 ( 9,-5 ) node[anchor = south ] @xmath13 ( 9.6,-5 ) node[anchor = south ] @xmath14 ( 10,-5 ) node[anchor = south ] @xmath5 ;    ( 6,-5 )  ( 6,-9 ) node[anchor = east ] @xmath1007 ; ( 6,-8.3 ) node[anchor = east ] @xmath16 ( 6,-7 ) node[anchor = east ] @xmath17 ( 6.05,-6.85 ) node[anchor = west ] @xmath18 ( 6,-5.6 ) node[anchor = east ] @xmath19 ( 6,-5.1 ) node[anchor = east ] @xmath20 ;    ( 6,-8.3 )  ( 7,-7 )  ( 8,-6.85)(9,-5.6)(9.6,-5.1)(10,-5 ) ;    ( -2,0 ) ",
    "( 3,0 ) node[anchor = north ] @xmath21 ; ( -2,0 ) node[anchor = south ] @xmath10 ( -1,0 ) node[anchor = south ] @xmath11 ( 0,0 ) node[anchor = south ] @xmath12 ( 2,0 ) node[anchor = south ] @xmath5 ;    ( -2,0 ) ",
    "( -2,-4 ) node[anchor = east ] @xmath1008 ; ( -2,-3 ) node[anchor = east ] @xmath1009 ( -2,-1.7 ) node[anchor = east ] @xmath17 ( -2.05,-1.5 ) node[anchor = west ] @xmath18 ( -2,-2 ) node[anchor = west ] @xmath8 ;    ( -2,-3 )  ( -1,-1.7 )  ( 0,-1.5)(2,-2 ) ;    ( -2,-5 )  ( 3,-5 ) node[anchor = north ] @xmath21 ; ( -2,-5 ) node[anchor = south ] @xmath10 ( 2,-5 ) node[anchor = south ] @xmath5 ;    ( -2,-5 )  ( -2,-9 ) node[anchor = east ] @xmath1010 ; ( -2,-6.3 ) node[anchor = east ] @xmath1011 ( -2,-7.3 ) node[anchor = east ] @xmath8 ;    ( -2,-6.3 )  ( 2,-7.3 ) ;    ( 6,-10 )  ( 11,-10 ) node[anchor = north ] @xmath21 ; ( 6,-10 ) node[anchor = south ] @xmath10 ( 9,-10 ) node[anchor = south ] @xmath13 ( 10,-10 ) node[anchor = south ] @xmath5 ;    ( 6,-10 )  ( 6,-14 ) node[anchor = east ] @xmath1012 ; ( 6,-13.5 ) node[anchor = east ] @xmath420 ( 6,-10.5 ) node[anchor = east ] @xmath19 ( 6,-9.8 ) node[anchor = east ] @xmath5 ;    ( 6,-13.5 )  ( 9,-10.5 ) (10,-9.8 ) ;    ( 6,-15 ) ",
    "( 11,-15 ) node[anchor = north ] @xmath21 ; ( 6,-15 ) node[anchor = south ] @xmath10 ( 10,-15 ) node[anchor = south ] @xmath5 ;    ( 6,-15 ) ",
    "( 6,-19 ) node[anchor = east ] @xmath1013 ; ( 6,-18 ) node[anchor = east ] @xmath1014 ( 6,-14.8 ) node[anchor = east ] @xmath5 ;    ( 6,-18 ) ",
    "( 10,-14.8 ) ;    ( -2,-10 )  ( 3,-10 ) node[anchor = north ] @xmath21 ; ( -2,-10 ) node[anchor = south ] @xmath10 ( 2,-10 ) node[anchor = south ] @xmath5 ;    ( -2,-10 ) ",
    "( -2,-14 ) node[anchor = east ] @xmath1015 ; ( -2,-13.5 ) node[anchor = east ] @xmath418 ( -2,-10 ) node[anchor = east ] @xmath10 ;    ( -2,-13.5 )  ( 2,-10 ) ;    figure  [ fig : val_sptg ] shows the value functions of the sptgof figure  [ fig : ex - ptg2 ] . here",
    "is how the algorithm obtains those functions .",
    "first it computes the functions at valuation @xmath5 , thanks to .",
    "then , it computes the value of the game where all states are urgent but additional terminal states have been added by the function to allow waiting until @xmath5 .",
    "this step gives the correct value functions until the cutpoint @xmath13 : in the @xmath415 loop , at first @xmath416 but the slope in @xmath34 is smaller than the slope that would be granted by waiting .",
    "then @xmath417 where the algorithm gives a slope of value @xmath418 in @xmath419 while the cost of this @xmath1 s location is @xmath420 .",
    "we thus choose @xmath1016 and compute the algorithm on the interval @xmath1017 $ ] with final states allowing one to wait until @xmath64 and get the already known value in @xmath64 .",
    "the algorithm then stops at @xmath12 in order to allow @xmath34 to wait , then in @xmath11 because of @xmath419 and finally the algorithm reaches @xmath10 giving us the value functions on the entire interval @xmath26 $ ] .",
    "towards solving reset - acyclic ptgs , our first step is to remove strict guards from the transitions , i.e. , guards of the form @xmath1018 $ ] , @xmath1019 or @xmath1020 with @xmath1021 . for this",
    ", we enhance the ptgwith regions in a method similar to what is done in  ( * ? ? ?",
    "* lemma  4.6 ) .",
    "formally , let @xmath1022 be a ptg .",
    "we define the region - ptgof @xmath78 as @xmath1023 where :      it is easy to verify that , in all configurations @xmath1035 reachable from the null valuation , the valuation @xmath9 is @xmath1036 . more interestingly , in all configurations @xmath1037 reachable from the null valuation ,",
    "the valuation @xmath9 is in @xmath1038 $ ] : indeed if @xmath1039 ( respectively , @xmath1040 ) , it intuitively simulates a configuration of the original game with a valuation arbitrarily close to @xmath1036 , but greater than @xmath1036 ( respectively , smaller than @xmath1040 ) .",
    "the game can thus take transitions with guard @xmath1041 , but can not take transitions with guard @xmath1042 anymore .",
    "[ lem : region_ptg ] let @xmath78 be a one - clock ptg , and @xmath408 be its region - ptg defined as before . for @xmath1043 and @xmath740 , @xmath1044 .",
    "moreover , we can transform an @xmath180-optimal strategy of @xmath408 into a @xmath1045-optimal strategy of @xmath78 with @xmath1046 .",
    "the proof consists in replacing strategies of @xmath408 where players can play on the borders of regions , by strategies of @xmath78 that play increasingly close to the border as time passes .",
    "if played close enough , the loss created can be chosen as small as we want .",
    "consider now the region - ptg@xmath78 associated to a reset - acyclic ptg(and of polynomial size with respect to the original ptg ) .",
    "we can decompose the graph of @xmath78 into strongly connected components ( that do not contain reset transitions by hypothesis ) .",
    "consider first its bottom strongly connected components , i.e. , components with no reset transitions exiting from them .",
    "all clock constraints are of the form @xmath871 $ ] with @xmath1047 , or @xmath1048 .",
    "we denote by @xmath1049 the constants appearing in the guards of the component ( adding @xmath10 ) .",
    "then , solving the component amounts to        once all bottom strongly connected components are solved , we replace the reset transitions going to them by final locations again , using the cost computed so far .",
    "we continue until no strongly connected components remain .",
    "each sptgbeing solvable in exponential time , the overall reset - acyclic can be solved in exponential time too ."
  ],
  "abstract_text": [
    "<S> priced timed games are two - player zero - sum games played on priced timed automata ( whose locations and transitions are labeled by weights modeling the costs of spending time in a state and executing an action , respectively ) . </S>",
    "<S> the goals of the players are to minimise and maximise the cost to reach a target location , respectively . </S>",
    "<S> we consider priced timed games with one clock and arbitrary ( positive and negative ) weights and show that , for an important subclass of theirs ( the so - called _ simple _ priced timed games ) , one can compute , in exponential time , the optimal values that the players can achieve , with their associated optimal strategies . as side results , we also show that one - clock priced timed games are determined and that we can use our result on simple priced timed games to solve the more general class of so - called reset - acyclic priced timed games ( with arbitrary weights and one - clock ) . </S>"
  ]
}