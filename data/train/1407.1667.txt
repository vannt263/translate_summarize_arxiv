{
  "article_text": [
    "hardware and software systems are rarely built from scratch .",
    "almost every non - trivial system is based on existing components .",
    "a typical component might be used in the design of multiple systems .",
    "examples of such components include function libraries , web apis , and asics .",
    "consider the mapping application in a typical smartphone .",
    "such an application might call the location service provided by the phone s operating system to get the user s co - ordinates , then call a web api to obtain the correct map image tiles , and finally call a graphics library to display the user s location on the screen . none of these components are exclusive to the mapping application and all of them are commonly used by other applications .",
    "the construction of systems from reusable components is an area of active research .",
    "examples of important work on the subject can be found in sifakis work on component - based construction @xcite , and de alfaro and henzinger s work on `` interface - based design '' @xcite .",
    "furthermore , other situations , such as web - service orchestration @xcite , can be viewed as the construction of systems from libraries of reusable components .",
    "synthesis is the automated construction of a system from its specification .",
    "in contrast to model checking , which involves verifying that a system satisfies the given specification , synthesis aims to automatically construct the required system from its formal specification .",
    "the modern approach to temporal synthesis was initiated by pnueli and rosner who introduced linear temporal logic ( ltl ) synthesis @xcite . in ltl synthesis , the specification is given in ltl and the system constructed is a finite - state transducer modeling a reactive system . in this setting",
    "it is always assumed that the system is `` constructed from scratch '' rather than `` composed '' from existing components .",
    "recently , lustig and vardi @xcite introduced the study of synthesis from reusable components .",
    "the use of components abstracts much of the detailed behavior of a sub - system , and allows one to write specifications that mention only the aspects of sub - systems relevant for the synthesis of the system at large .",
    "a major concern in the study of synthesis from reusable components is the choice of a mathematical model for the components and their composition .",
    "the exact nature of the reusable components in a software library may differ .",
    "one finds in the literature many different types of components ; for example , function libraries ( for procedural programming languages ) or object libraries ( for object - oriented programming languages ) .",
    "indeed , there is no single `` right '' model encompassing all possible facets of the problem .",
    "the problem of synthesis from reusable components is a general problem to which there are as many facets as there are models for components and types of composition @xcite .    as a basic model for a component ,",
    "following @xcite , we abstract away the precise details of the component and model a component as a _ transducer _",
    ", i.e. , a finite - state machine with outputs .",
    "transducers constitute a canonical model for reactive components , abstracting away internal architecture and focusing on modeling input / output behavior . in @xcite ,",
    "two models of composition were studied . in _ dataflow _",
    "composition , the output of one component is fed as input to another component .",
    "the synthesis problem for dataflow composition was shown to be undecidable . in _ control - flow",
    "_ composition control is held by a single component at every point in time .",
    "the synthesis problem can then be viewed as constructing a supervisory transducer that switches control between the component transducers .",
    "control - flow composition is motivated by software ( and web services ) in which a single function is in control at every point during the execution .",
    "ltl synthesis in this setting was shown in @xcite to be 2exptime - complete , just like classical ltl synthesis @xcite .    in this paper , we extend the control - flow synthesis model of @xcite to probabilistic components , which are transducers with a probabilistic transition function .",
    "this is a well known approach to modeling systems where there is probabilistic uncertainty about the results of input actions .",
    "intuitively , we aim at constructing a reliable system from unreliable components .",
    "there is a rich literature about verification and analysis of such systems , cf .",
    "@xcite , as well about synthesis in the face of probabilistic uncertainty @xcite .",
    "the introduction of probability requires us to use a probabilistic notion of correctness ; here we choose the _ qualitative _ criterion that the specification be satisfied with probability  @xmath0 , leaving the study of _ quantitative criteria _ to future work .    here",
    ", our focus is on proving decidability , rather than on establishing precise complexity bounds , leaving the study of precise bounds to future work .",
    "consequently , we abstract away from the details of the specification formalism and assume that the specification is given in terms of deterministic parity word automata ( dpw ) .",
    "this allows us to consider all @xmath1-regular properties .",
    "we define and study the _ dpw probabilistic realizability _ and synthesis problems , where the input is a library @xmath2 of probabilistic components and a dpw @xmath3 , and the question is whether one can construct a _",
    "system @xmath4 from the components in @xmath2 , such that , regardless of the external environment , the traces generated by the system  @xmath4 are accepted by  @xmath3 with probability  1 .",
    "each component in the library can be used an arbitrary number of times in the construction and there is no apriori bound on the size of the system obtained .",
    "the technical challenge here is dealing with the finiteness of the system under construction . in @xcite , as well as in @xcite ,",
    "one need not deal with finiteness from the start .",
    "in fact , one can test realizability without being concerned with finiteness of the constructed system , as finiteness is a _ consequence _ of the construction .",
    "this is not the case here , where we need to deal with finiteness from the start .",
    "nevertheless , we are able to show that the problem is in 2exptime .    before tackling the full problem",
    ", we first consider a restricted version of the problem , where the specification is given in the form of a parity index on the states of the components , and the composed system must satisfy the parity condition .",
    "we call this the _ embedded parity realizability _ problem .",
    "we solve this problem and then show how solving the embedded parity realizability problem directly allows us to solve the more general dpw probabilistic realizability problem as well .",
    "the key idea here is that by taking the product of the specification dpw with each of the components , we can obtain larger components each of whose states has a parity associated with it .",
    "the challenge in completing the reduction is the need to generate a static composition , which does not depend on the history of the computation .",
    "here we use ideas about synthesis with incomplete information from @xcite .",
    "given a set @xmath5 of directions , a _",
    "@xmath5-tree _ is a set @xmath6 such that ( a ) there is an element @xmath7 , called the _ root _ of t , such that , for all @xmath8 there exists @xmath9 with @xmath10 , and ( b ) if @xmath11 is a non - root element of @xmath12 , where @xmath13 and @xmath14 , then @xmath15 is also an element of @xmath12 .",
    "the elements of @xmath12 are called its _",
    "nodes_. for every node @xmath16 , the set of _ successors _ of @xmath15 is given by @xmath17 .",
    "a node with no successors is called a _",
    "leaf_. a _ path",
    "_ @xmath18 of a tree @xmath12 is a set @xmath19 such for every pair of nodes @xmath20 in @xmath18 , there exists @xmath21 such that @xmath22 or @xmath23 . a path is infinite if it has no leaf nodes , otherwise it is finite .",
    "a _ subtree _ of @xmath12 is a tree @xmath24 . for a node @xmath8 ,",
    "the _ subtree rooted at @xmath15 _ is the tree @xmath25 .",
    "the _ full _",
    "@xmath5-tree is @xmath26 .",
    "the _ full subtree _ at @xmath15 is the tree whose set of nodes is @xmath27 .    given an alphabet @xmath28 , a _",
    "@xmath28-labeled @xmath5-tree _ is a pair @xmath29 , where @xmath12 is a tree and @xmath30 maps each node of @xmath12 to a letter in @xmath28 .",
    "a _ subtree _ of @xmath31 , is a @xmath28-labeled @xmath5-tree @xmath32 , where @xmath33 is a subtree of @xmath12 and @xmath34 , for all @xmath35 .      for a set @xmath36 ,",
    "let @xmath37 be the set of positive boolean formulas over @xmath36 ( i.e. , boolean formulas built from elements in @xmath36 using @xmath38 and @xmath39 ) , including the formulas * true * ( an empty conjunction ) and * false * ( an empty disjunction ) . for a set @xmath40 and a formula @xmath41 , we say that @xmath42 _ satisfies _",
    "@xmath43 iff assigning * true * to elements in @xmath42 and assigning * false * to elements in @xmath44 makes @xmath43 true . an _ alternating tree automaton _",
    "is tuple @xmath45 , where @xmath28 is the input alphabet , @xmath5 is a set of directions , @xmath46 is a finite set of states , @xmath47 is an initial state , @xmath48 is a transition function , and @xmath49 specifies the acceptance condition that defines a subset of @xmath50 .",
    "each element of @xmath51 is called an _",
    "atom_. the alternating automaton @xmath52 runs on @xmath28-labeled full @xmath5-trees .",
    "a run of @xmath52 over a @xmath28-labeled @xmath5-tree @xmath29 is a @xmath53-labeled @xmath54-tree @xmath55 .",
    "each node of @xmath56 corresponds to a node of @xmath12 .",
    "a node in @xmath56 , labeled by @xmath57 , describes a copy of the automaton that reads the node @xmath15 of @xmath12 and visits the state @xmath58 .",
    "note that multiple nodes of @xmath56 can correspond to the same node of @xmath12 .",
    "the labels of a node and its successors have to satisfy the transition function .",
    "formally , @xmath55 satisfies the following conditions :    1 .",
    "@xmath59 and @xmath60 .",
    "2 .   let @xmath61 with @xmath62 and @xmath63 .",
    "then there exists a set @xmath64 such that @xmath4 satisfies @xmath43 , and for all @xmath65 , we have @xmath66 and @xmath67 .",
    "@xmath4 is allowed to be empty .",
    "an infinite path @xmath18 of a run @xmath55 is labeled by a word in @xmath50 .",
    "let @xmath68 be the set of states in @xmath46 that occur infinitely often in @xmath69 .",
    "the _ bchi _ acceptance condition is given as @xmath70 , and @xmath18 satisfies @xmath49 if @xmath71 .",
    "parity _ acceptance condition is given as a function @xmath72 , and @xmath18 satisfies @xmath49 if @xmath73 is even .",
    "a run @xmath55 is accepting if all its infinite paths satisfy the acceptance condition .",
    "an automaton accepts a tree iff there exists a run that accepts it .",
    "we denote by @xmath74 the set of all @xmath28-labeled @xmath5-trees accepted by @xmath52 .",
    "the transition function @xmath75 of an alternating tree automaton is",
    "_ nondeterministic _ if every formula produced by @xmath75 can be written in disjunctive normal form such that if two atoms @xmath76 and @xmath77 occur in the same conjunction then @xmath78 and @xmath79 must be different .",
    "a _ nondeterministic tree automaton _",
    "@xmath52 is an alternating tree automaton with a nondeterministic transition function . in this case",
    "the transition function returns a set of @xmath80-ary tuples of states and can be represented as a function @xmath81 .",
    "a _ deterministic transducer _ is a tuple @xmath82 , where : @xmath83 is a finite input alphabet , @xmath84 is a finite output alphabet , @xmath46 is a finite set of states , @xmath47 is an initial state , @xmath85 is an output function labeling states with output letters , and @xmath86 is a transition function .",
    "we define @xmath87 as follows : @xmath88 and for @xmath89 and @xmath90 , @xmath91 .",
    "we denote by @xmath92 , the @xmath84-labeled @xmath83-tree @xmath93 , where for all @xmath89 , we have @xmath94 .",
    "we say @xmath92 is the _ unwinding _ of @xmath95 .",
    "a @xmath28-labeled @xmath5-tree @xmath12 is called _ regular _ , if there exists a deterministic transducer @xmath96 such that @xmath97 .",
    "a probability distribution on a finite set @xmath36 is a function @xmath98 $ ] such that @xmath99 .",
    "we use @xmath100 to denote the set of all probability distributions on set @xmath36 .",
    "probabilistic transducer _",
    ", is a tuple @xmath101 , where : @xmath83 is a finite input alphabet , @xmath84 is a finite output alphabet , @xmath46 is a finite set of states , @xmath47 is an initial state , @xmath102 is a probabilistic transition function , @xmath103 is a set of exit states , and @xmath85 is an output function labeling states with output letters .",
    "note that there are no transitions out of an exit state .",
    "if @xmath104 is empty , we say @xmath105 is a probabilistic transducer without exits .",
    "note that deterministic transducers are a special case of probabilistic transducers .    given a probabilistic transducer @xmath106 , a _ strategy _ for @xmath107 is a function @xmath108 that probabilistically chooses an input for each sequence of states .",
    "a strategy is memoryless if the choice depends only on the last state in the sequence .",
    "a memoryless strategy can be written as a function @xmath109 .",
    "a strategy is _ pure _ if the choice is deterministic .",
    "a pure strategy is a function @xmath110 , and a memoryless and pure strategy is a function @xmath111 .",
    "a strategy @xmath112 along with a probabilistic transducer @xmath107 , with set of states @xmath46 , induces a probability distribution on @xmath50 , denoted @xmath113 . by standard measure",
    "theoretic arguments , it suffices to define @xmath113 for the cylinders of @xmath50 , which are sets of the form @xmath114 , where @xmath115 .",
    "first we extend @xmath75 to exit states as follows : for @xmath90 , @xmath116 , @xmath117 , @xmath118 and @xmath119 when @xmath120",
    ". then we define @xmath121 , and for @xmath122 , @xmath123 , @xmath124 .",
    "these conditions say that there is a unique start state , and the probability of visiting a state @xmath125 , after visiting @xmath126 , is the same as the probability of the strategy picking a particular letter multiplied by the probability that the transducer transitions from @xmath58 to @xmath125 on that input letter , summed over all input letters .",
    "given a directed graph @xmath127 , a _ strongly connected component _ of @xmath128 is a subset @xmath129 of @xmath130 , such that for all @xmath131 , @xmath132 is reachable from @xmath133 .",
    "we can define a natural partial order on the set of maximal strongly connected components of @xmath128 as follows : @xmath134 if there exists @xmath135 and @xmath136 such that @xmath137 is reachable from @xmath138 .",
    "then @xmath139 is an _",
    "ergodic set _ of @xmath128 if it is a minimal element of the partial order .",
    "let @xmath107 be a probabilistic transducer , @xmath46 be its set of states , and @xmath112 be a memoryless strategy for @xmath107 .",
    "we define the graph induced by @xmath112 on @xmath46 , denoted by @xmath140 , as the directed graph @xmath141 , where @xmath142 if @xmath143 .",
    "that is , there is an edge from @xmath144 to @xmath145 if the transducer can transition from the state @xmath144 to the state @xmath145 on an input letter that the strategy chooses with positive probability .",
    "given @xmath146 , we say that @xmath145 is reachable from @xmath144 if there is a path from @xmath144 to @xmath145 in @xmath140 .",
    "we say a state is ergodic if it belongs to some ergodic set of @xmath140 .",
    "an ergodic set is reachable if there is a path from the start state to some state in the ergodic set .",
    "a state @xmath58 of @xmath107 is _ reachable under @xmath112 _",
    ", if there is a path in @xmath140 from @xmath147 to @xmath58 .",
    "a _ library _ is a set of probabilistic transducers that share the same input and output alphabets .",
    "each transducer in the library is called a _",
    "component_. given a finite set of directions @xmath5 , we say a library @xmath2 has width @xmath5 , if each component in the library has exactly @xmath80 exit states .",
    "since we can always add dummy unreachable exit states to any component , we assume , w.l.o.g .",
    ", that all libraries have an associated width , usually denoted @xmath5 . in the context of a particular component , we often refer to elements of @xmath5 as exits , and subsets of @xmath5 as sets of exits .",
    "given a component @xmath107 from library @xmath2 , and a strategy @xmath112 for @xmath107 , we say that the exit @xmath148 is _ selected _ by @xmath112 , if the @xmath149th exit state of @xmath107 is reachable under @xmath112 .",
    "an _ index function _ for a transducer is a function that assigns a natural number , called a priority index , to each state of the transducer .",
    "an index function for a library is a function that assigns a priority to every state of every component in the library .",
    "given an index function @xmath150 for a library @xmath2 , we define @xmath151 to be the highest priority assigned by @xmath150 .",
    "we can assume , w.l.o.g .",
    ", that @xmath151 is not larger than twice the maximal number of states in the components of the library . given a transducer @xmath107 , index function @xmath150 , and a strategy @xmath112 for @xmath107 , we say @xmath112 _ visits _",
    "priority @xmath152 if there exists a state @xmath58 of @xmath107 such that @xmath153 and @xmath58 is reachable under @xmath112 .",
    "reactive synthesis involves the automated construction of reactive programs from specifications .",
    "given sets @xmath154 and @xmath155 of input and output signals , respectively , we can view a program as a function @xmath156 that maps a finite sequence of sets of input signals into a set of output signals .",
    "a reactive system can be viewed as a non - terminating program that interacts with an adversarial environment .",
    "the environment generates an infinite sequence of input signals , which are modeled as infinite words over the alphabet @xmath157 .",
    "the execution of the program for a particular input word results in an infinite computation , which is represented as an infinite word over @xmath158 .",
    "given an ltl formula @xmath159 over @xmath160 , realizability of @xmath159 is the problem of determining whether there exists a program @xmath161 all of whose computations satisfy the specification @xmath159 .",
    "the correct synthesis of @xmath159 then amounts to constructing such @xmath161 @xcite .",
    "the complete behavior of the system can be described by the set of all possible executions ( i.e. the _ traces _ of the system ) , which is represented as a @xmath162-labeled @xmath157-tree , called an _",
    "execution tree_. the automata - theoretic approach involves constructing a tree automaton that accepts all computation trees all of whose paths satisfy @xmath159 .",
    "the solution to the ltl synthesis problem then consists of a reduction to the nonemptiness problem of tree automata @xcite ( an earlier and more complicated solution can be found in @xcite ) .",
    "the ltl synthesis problem is closely related to church s problem @xcite .",
    "the automata - theoretic approach to synthesis has been quite fruitful since the original work of pnueli and rosner @xcite .",
    "automata - theoretic methods have been applied successfully to the synthesis of branching specifications @xcite and to synthesis in the presence of incomplete or hidden information @xcite .",
    "the work reported in this paper extends the reactive - synthesis framework to synthesis from probabilistic components .",
    "we first informally describe our notion of control - flow composition of components from a library .",
    "the components in the composition take turns interacting with the environment , and at each point in time , exactly one component is active .",
    "when the active component reaches an exit state , control is transferred to some other component .",
    "thus , to define a control flow composition , it suffices to name the components used and describe how control should be transferred between them .",
    "we use a deterministic transducer to define the transfer of control .",
    "each library component can be used multiple times in a composition , and we treat these occurrences as distinct _ component instances_. we emphasize that the composition can contain potentially arbitrarily many repetitions of each component inside it .",
    "thus , the size of the composition , a priori , is not bounded .",
    "note that our notion of composition is _ static _",
    ", where the components called are determined before run time , rather than _ dynamic _ , where the components called are determined during run time .",
    "let @xmath2 be a library with width @xmath5 .",
    "a _ composer _ over @xmath2 is a deterministic tranducer @xmath163 . here",
    "@xmath164 is an arbitrary finite set of states .",
    "there is no bound on the size of @xmath164 .",
    "each @xmath165 is the name of an instance of a component from @xmath2 and @xmath166 is the type of @xmath167 .",
    "we use the following notational convention for component instances and names : the upright letter @xmath168 always denotes component names ( i.e. states of a composer ) and the italicized letter @xmath107 always denotes the corresponding component instances ( i.e. elements of @xmath2 ) .",
    "further , for notational convenience we often write @xmath169 directly instead of @xmath170 .",
    "note that while each @xmath167 is distinct , the corresponding components @xmath169 need not be distinct .",
    "each composer defines a unique composition over components from @xmath2 .",
    "the current state of the composer corresponds to the component that is in control .",
    "the transition function @xmath171 describes how to transfer control between components : @xmath172 denotes that when the composition is in the @xmath149th final state of component @xmath107 it moves to the start state of component @xmath173",
    ". a composer can be viewed as an implicit representation of a composition .",
    "we give an explicit definition of composition below .",
    "[ def : composition ] let @xmath174 be a composer over library @xmath2 with width @xmath5 , where @xmath175 , @xmath176 and @xmath177 .",
    "the composition defined by @xmath96 , denoted @xmath178 , is a probabilistic transducer @xmath179 , where @xmath180 , @xmath181 , @xmath182 , and the transition function @xmath75 is defined as follows : for @xmath183 , @xmath184 and @xmath185 ,    1 .   if @xmath186 , then @xmath187 2 .   if @xmath188 , where @xmath189 , then @xmath190    note that the composition is a probabilistic transducer without exits .",
    "when the composition is in a state @xmath191 corresponding to a non - exit state @xmath58 of component @xmath169 , it behaves like @xmath169 .",
    "when the composition is in a state @xmath192 corresponding to an exit state @xmath193 of component @xmath169 , the control is transferred to the start state of another component as determined by the transition function of the composer .",
    "thus , at each point in time , only one component is active and interacting with the environment .",
    "in this section we consider a simplified version of the general synthesis problem , where each state of a component in the library has a priority associated with it and the specification to be satisfied is that the highest priority visited i.o",
    ". must be even with probability @xmath0 .",
    "let @xmath107 be a probabilistic tranducer and @xmath150 be an index function .",
    "a strategy @xmath112 for @xmath107 is _ winning _ for the environment if with positive probability the highest priority visited infinitely often ( i.o . )",
    "we say that @xmath107 _ satisfies _",
    "@xmath150 if there exists no winning strategy for the environment . given a composer @xmath96 over library @xmath2",
    ", we say that @xmath96 _ satisfies _",
    "@xmath150 if @xmath178 satisfies @xmath150 .    given a library @xmath2 with width @xmath5 , an _ exit control relation _ is a set @xmath194 .",
    "we say that a composer @xmath195 over @xmath2 is _ compatible _ with @xmath196 , if the following holds : for all @xmath197 and @xmath148 , if @xmath198 then @xmath199 .",
    "thus , each element of @xmath196 can be viewed as a constraint on how the composer is allowed to connect components .",
    "the _ embedded parity realizability problem _ is : given a library @xmath2 with width @xmath5 , an exit control relation @xmath196 for @xmath2 , and an index function @xmath150 for @xmath2 , decide whether there exists a composer @xmath96 over @xmath2 , such that @xmath96 satisfies @xmath150 and @xmath96 is compatible with @xmath196 .",
    "if such a composer exists , we say that @xmath2 _ realizes _",
    "@xmath150 under @xmath196 .",
    "the _ embedded parity synthesis problem _ is to find such a composer @xmath96 if it exists .",
    "the following theorem allows us to restrict attention to memoryless strategies .",
    "it states that if a winning strategy exists , then a memoryless winning strategy must also exist .",
    "here we give a direct combinatorial proof , but we note that the result can also be obtained by adapting the methods in @xcite , where a similar result was proved for @xmath200@xmath201 player stochastic parity games by chatterjee et al .",
    "[ theorem : memoryless ] given a probabilistic transducer @xmath107 , and index function @xmath150 , if there exists a winning strategy for the environment then there exists a pure and memoryless winning strategy .",
    "we break up the proof of this theorem in two parts in lemma [ lemma : memoryless - strategy ] and lemma [ lemma : pure - strategy ] . in the first part",
    "we show that given a winning strategy @xmath112 we can find a memoryless winning strategy @xmath202 from @xmath112 . in the second part we show that given a memoryless winning strategy @xmath202 , we can obtain a pure and memoryless strategy @xmath203 from @xmath202 .",
    "together the two lemmas suffice to complete the proof .",
    "[ lemma : memoryless - strategy ] let @xmath107 be a transducer and @xmath112 be a winning strategy for the environment . then there exists a memoryless strategy @xmath204 such that @xmath204 is winning .    let @xmath112 be a strategy that is winning for the environment .",
    "let @xmath46 be the set of states of @xmath107 , and let @xmath205 be the complete directed graph on @xmath46 .",
    "given @xmath206 , @xmath207 is the set of finite simple paths in @xmath128 from @xmath145 to @xmath144 . since @xmath128 is finite ,",
    "@xmath207 is also finite . given a finite path @xmath208 , @xmath209 is the set of edges in @xmath49 . given a set of edges @xmath210 , @xmath211 is the set of infinite paths in which each edge in @xmath212 is visited i.o .",
    "let @xmath213 be the set of states which have positive probability of being visited i.o . under @xmath112 ,",
    "that is , for each state @xmath58 in @xmath214 , the set of paths in @xmath50 that visit @xmath58 i.o .",
    "has positive measure under @xmath113 .",
    "similarly , let @xmath215 be the set of edges that have positive probability of being followed infinitely often , i.e. , @xmath216 . let @xmath217 be the directed graph @xmath218 . we first show that each maximal strongly connected component ( mscc ) of @xmath217 is also an ergodic set .    if @xmath219 is an edge in @xmath220 , then in order for an infinite path to to follow this edge i.o . , it must also travel from @xmath145 to @xmath144 i.o .",
    "every finite path from @xmath145 to @xmath144 can be partitioned into a simple path from @xmath145 to @xmath144 and a finite number of cycles .",
    "thus for each @xmath221 , there exists @xmath222 , such that @xmath223 .",
    "therefore @xmath224 .",
    "since @xmath225 , there exists at least one @xmath226 such that @xmath227 and @xmath228 .",
    "thus each edge in @xmath217 can in effect be traversed in the opposite direction by following some path in @xmath217 .",
    "so @xmath217 does not have an mscc with an outgoing edge , and thus , is a collection of ergodic sets .",
    "next we show that there exists some ergodic set @xmath36 in @xmath217 such that the highest parity in @xmath36 is odd . given @xmath229 ,",
    "let @xmath230 denote the event that @xmath58 is the highest parity state visited i.o .",
    "since @xmath112 is winning , there must be some @xmath229 such that @xmath58 has odd parity and the event @xmath231 has positive probability .",
    "then @xmath232 , and let @xmath233 be the ergodic set in @xmath217 that contains @xmath58 .",
    "let @xmath234 be the set of paths that visit @xmath58 i.o . and leave @xmath36 at most finitely many times . since , by the definition of @xmath217 , it is not possible for a path to leave @xmath36 i.o . with positive probability ,",
    "we get @xmath235 , and therefore @xmath236 . now",
    "the probability that a suffix of a path remains in @xmath36 , but does not visit some @xmath237 is zero .",
    "this is because , @xmath36 is strongly connected , and so avoiding @xmath125 loses a positive amount of probability infinitely many times . in the limit",
    ", the probability of remaining in @xmath36 and never visiting @xmath125 goes to zero . if there is some @xmath238 such that the parity of @xmath152 is greater than the parity of @xmath58 , then all paths in @xmath239 must have suffixes that avoid @xmath152 , and so @xmath240 , which contradicts that @xmath231 has positive probability .",
    "therefore @xmath58 has the highest parity in @xmath36 .",
    "finally , since each state in @xmath36 is visited i.o . with positive probability , then the probability of visiting some state in @xmath36 starting from the start state @xmath147",
    "must be positive .",
    "let @xmath241 be the shortest finite path starting from @xmath147 and ending in @xmath36 , such that @xmath242 .",
    "we now define a memoryless strategy @xmath243 that is winning for the environment .",
    "we first consider the case when @xmath232 .",
    "let @xmath244 be the successors of @xmath58 in @xmath217 .",
    "given @xmath90 , we define @xmath245 , and @xmath246 .",
    "given @xmath247 and @xmath208 , we say that @xmath152 is _ activated _ by @xmath112 at @xmath248 , if @xmath249 .",
    "if @xmath250 is empty , then this implies that , for all @xmath208 , whenever some @xmath251 is activated by @xmath112 at @xmath248 , some @xmath252 must also be activated by @xmath112 at @xmath253 .",
    "then any time a path visits @xmath58 , there is a positive probability of visiting a state in @xmath254 next .",
    "so a path that visits @xmath58 and remains in @xmath214 loses some finite amount of probability . in the limit , a path visiting @xmath58 i.o .",
    "must have probability zero because any such path has a suffix in @xmath255 .",
    "this contradicts @xmath256 .",
    "thus @xmath250 is non - empty for all @xmath232 .",
    "we define @xmath257 as follows : for @xmath232 , @xmath258 is distributed uniformly over @xmath250 and is @xmath259 elsewhere .",
    "we extend @xmath204 to all of @xmath46 as follows : for states in @xmath18 , we chose the value of @xmath204 such that edges in @xmath18 have positive probability under @xmath260 , and for all other states we let @xmath204 take an arbitrary value .",
    "then @xmath204 is a memoryless strategy since it is a function @xmath261 .",
    "consider the graph @xmath262 induced by @xmath204 on @xmath46 .",
    "every edge in @xmath220 is also an edge in @xmath262 , and no edges that leave @xmath214 have been added . also , all edges in @xmath18 are also in @xmath262 .",
    "so the set @xmath263 is a reachable ergodic set of @xmath204 . since the highest parity in @xmath36 is odd , @xmath204 is a winning strategy .",
    "[ lemma : pure - strategy ] let @xmath107 be a transducer and @xmath112 be a winning memoryless strategy for the environment . then there exists a memoryless and pure strategy @xmath204 such that @xmath204 is winning",
    ".    let @xmath264 . given two memoryless strategies @xmath112 and",
    "@xmath204 , we say that @xmath204 _ refines _",
    "@xmath112 , iff @xmath265 , @xmath266 , @xmath267 implies @xmath268 .",
    "the set of inputs chosen with positive probability at state @xmath58 by memoryless strategy @xmath112 is simply the support of the distribution @xmath269 , denoted @xmath270",
    ". then @xmath204 refines @xmath112 iff @xmath265 , @xmath271 .",
    "note that , if @xmath204 refines @xmath112 , then @xmath262 is a subgraph of @xmath272 , and each connected component of @xmath262 is contained in a connected component of @xmath272 .",
    "now assume that @xmath112 is a winning memoryless strategy for the environment .",
    "since @xmath112 is winning , by lemma [ lemma : odd - ergodic ] , there must be at least one reachable ergodic set @xmath273 of @xmath272 such that the highest parity in @xmath161 is odd .",
    "let @xmath274 be a state with the highest parity .",
    "then if a memoryless strategy @xmath204 refines @xmath112 , such that @xmath58 lies in a reachable ergodic set of @xmath262 , then @xmath204 is also winning .",
    "this is because every ergodic set of @xmath262 that contains @xmath58 must be contained within some connected component of @xmath272 containing @xmath58 , and @xmath161 contains all such components .",
    "so the highest parity in such an ergodic set of @xmath262 must also be odd .",
    "thus it suffices to give a procedure of stepwise refinement of @xmath112 , keeping @xmath58 in a reachable ergodic set at each step , that terminates in a pure strategy .",
    "this is because , at each step of the procedure , the refined strategy is winning , and so it is also winning at the end .",
    "we detail a two stage procedure below .",
    "stage 1 : :    in the first stage we only modify @xmath112 for states within    the ergodic set @xmath161 and each state is only modified once .    at each step",
    "we maintain a set @xmath275 of    previously selected states .",
    "the modified strategy at step    @xmath276 is denoted @xmath277 .",
    "the set of already    selected states at step @xmath276 is denoted @xmath278 .",
    "the procedure is then defined inductively as follows :    +    1 .",
    "@xmath279 , and @xmath280 agrees with    @xmath112 on @xmath281 and chooses some input    @xmath282 deterministically at @xmath58 .    2 .",
    "@xmath283 , where    @xmath284 is chosen such that there is an edge    @xmath285 in @xmath286 for some state    @xmath287 . @xmath288 agrees with @xmath277 on    @xmath289 , and @xmath290 chooses    input @xmath291 deterministically such    that @xmath292 .",
    "+    at each step , the size of @xmath293 decreases by one .",
    "the    prodecure terminates when @xmath293 is empty .",
    "this happens in    @xmath294 steps .",
    "in order to ensure that the inductive    procedure is sound , we need to show that a suitable choice for    @xmath295 and @xmath296 exists at each step .",
    "we first    prove that , for all @xmath297 , for all    @xmath298 , all edges leaving @xmath125 in    @xmath272 are also present in @xmath286 .",
    "this is    true at the first step .",
    "if this is true at step @xmath276 , then    it is also true at step @xmath299 , since    @xmath300 and @xmath288 and    @xmath277 have the same value on states in    @xmath301 , so no edges that leave states in    @xmath301 are removed at step @xmath299 .",
    "so the    statement holds by induction .",
    "since @xmath161 is an ergodic set    of @xmath272 , for all @xmath297 , there is some edge    @xmath302 in @xmath272 that starts in    @xmath303 and ends @xmath278 .",
    "now , by the claim    proven above , @xmath302 is also an edge in    @xmath286 .",
    "then the source vertex of @xmath302 can    be chosen as @xmath295 in step @xmath299 . also ,",
    "because @xmath304 is an edge in    @xmath286 , there must be some @xmath305    such that @xmath306 and    @xmath307 .",
    "then we can choose    @xmath308 as @xmath296 .",
    "therefore the inductive    construction is well defined .",
    "+    next we show that , for all @xmath309 , @xmath277    refines @xmath112 , and @xmath58 is reachable in    @xmath310 from every state in @xmath278 . let    @xmath277 refine @xmath112 .",
    "since @xmath288    and @xmath277 agree on states in @xmath311 , and    @xmath312 , we    have @xmath288 refines @xmath112 .",
    "let    @xmath58 be reachable in @xmath286 from every state    in @xmath278 . since @xmath313 ,    it suffices to show that @xmath58 is reachable in    @xmath314 from every vertex in @xmath278 , and    there is an edge in @xmath314 from @xmath295    to some vertex in @xmath278 .",
    "the first part is true because    @xmath288 and @xmath277 take the same value on    states in @xmath315 , and the second part follows directly from    the definition of @xmath290 .",
    "+    let @xmath316 .",
    "then @xmath202 refines    @xmath112 , all edges leaving @xmath317 in    @xmath272 are also edges in @xmath318 , and    @xmath58 is reachable in @xmath318 from all states    in @xmath161 .",
    "stage 2 : :    since @xmath161 is a reachable ergodic set of @xmath272 ,    there exists a minimal path @xmath18 in @xmath272    that starts from @xmath147 and ends in some state in    @xmath161 . since the path is minimal , none of its edges lie in    @xmath161 . then @xmath18 is also a path in    @xmath318 .",
    "let @xmath319 where @xmath320 .",
    "then there    exists @xmath321 such that    @xmath322 and    @xmath323 .",
    "we define a pure    memoryless strategy @xmath204 as follows : for states in    @xmath161 , @xmath58 agrees with @xmath202 ; for a    state @xmath324 in @xmath18 , @xmath204 chooses    input @xmath325 deterministically ; and for a state    @xmath125 that is not in @xmath161 or @xmath18 ,    @xmath204 chooses some input @xmath326    deterministically .",
    "+    then @xmath204 refines @xmath202 by construction , and    thus @xmath204 refines @xmath112 . in order to prove that    @xmath204 is also a winning strategy , it suffices to show that    @xmath58 belongs to a reachable ergodic set of    @xmath262 .",
    "+    now , by construction , @xmath18 is also a path in    @xmath262 , and so some state in @xmath161 is reachable    from the start state in @xmath262 . also , @xmath58 is    reachable in @xmath262 from all states in @xmath161 .",
    "therefore @xmath58 is reachable from the start state in    @xmath262 .",
    "since @xmath161 is an ergodic set of    @xmath272 , and @xmath262 is a subgraph of    @xmath272 , therefore there is no path in @xmath262    from @xmath58 to a state in @xmath317 .",
    "therefore , if    @xmath247 is reachable from @xmath58 in    @xmath262 , then @xmath58 is also reachable from    @xmath152 in @xmath262 .",
    "thus @xmath58 lies in a    reachable ergodic set of @xmath262 .",
    "memoryless strategies are important because they induce an ergodic structure on the set of states .",
    "ergodic sets are useful because they enable us to replace probabilistic reasoning with combinatorial reasoning . in particular",
    ", they have the following crucial properties : ( a ) the suffix of a path is contained in some ergodic set with probability @xmath0 , and ( b ) the suffix of a path is contained in a proper subset of an ergodic set with probability zero @xcite .",
    "this allows us to define the winning strategy condition in terms of graph reachability .",
    "[ lemma : odd - ergodic ] let @xmath107 be a probabilistic transducer and @xmath112 be a memoryless strategy for @xmath107 . then @xmath112 is winning for the environment iff @xmath140 has a reachable ergodic set whose highest priority is odd .",
    "let @xmath46 be the set of states of @xmath107 , @xmath327 be the set of ergodic sets of @xmath140 and @xmath328 be the set of all ergodic states .",
    "we use the following useful property of ergodic sets @xcite : ( a )    the suffix of a path is contained in some ergodic set with probability @xmath0 , and ( b ) the suffix of a path is contained in a proper subset of an ergodic set with probability zero .",
    "formally , we have , for all @xmath208 , @xmath329 , and for all @xmath330 , @xmath331 , @xmath332 .",
    "let @xmath333 be the set of paths in @xmath50 whose highest parity visited i.o .",
    "if the highest parity in each ergodic set is even , then every path in @xmath333 must have a suffix that is either contained in @xmath334 or is contained in @xmath335 , where @xmath336 is a proper subset of some ergodic set . thus @xmath333 is contained in the union of @xmath337 and @xmath338 .",
    "the probability of both these sets of paths is zero under @xmath113 .",
    "thus @xmath339 , and @xmath112 is not winning for the environment .",
    "next , assume that there is a reachable ergodic set @xmath340 such that the highest parity in @xmath340 is odd .",
    "let @xmath341 be a state with this parity . since @xmath340 is reachable from the start state , there exists a path @xmath342 , such that @xmath18 starts from @xmath147 and ends in @xmath340 and @xmath242 . since @xmath340 is an ergodic set , the probability of a path leaving @xmath340 after reaching it is @xmath259 @xcite .",
    "so we also have @xmath343 .",
    "consider the set of paths @xmath344 .",
    "then each path in @xmath4 visits @xmath125 i.o . , and",
    "therefore , @xmath345 .",
    "now @xmath346 , and therefore , @xmath347 .",
    "thus , @xmath112 is winning for the environment .",
    "when the underlying probabilistic transducer is a composition , ergodic sets acquire additional structure . given a composer @xmath96 and a memoryless strategy @xmath112 for @xmath178 , if a reachable ergodic set @xmath36 of @xmath348 contains some state from a component @xmath107 of @xmath178 , then either @xmath36 is contained in @xmath107 or all the reachable states of @xmath107 are contained in @xmath36 .",
    "formally :    [ lemma : component - ergodic ] let @xmath163 be a composer over @xmath2 and @xmath112 be a memoryless strategy for @xmath178 .",
    "let @xmath349 and @xmath350 be the state space of @xmath169 .",
    "let @xmath36 be a reachable ergodic set of @xmath351 such that @xmath352 . then either @xmath353 or @xmath354 , where @xmath42 is the set of states of @xmath178 that are reachable under @xmath112 .",
    "assume that @xmath352 and @xmath36 is not contained in @xmath355 .",
    "let @xmath356 and @xmath357 , for some @xmath358 .",
    "since @xmath36 is ergodic , there is a path @xmath18 in @xmath348 from @xmath359 to @xmath360 .",
    "let @xmath361 be the first state along @xmath18 such that @xmath362 .",
    "we claim that @xmath363 , where @xmath364 is the start state of @xmath169 .",
    "let @xmath365 , where @xmath366 , be the predecessor of @xmath361 in @xmath18 . by the definition of @xmath348 , there is an edge from @xmath367 to @xmath361 only if @xmath178 can transition from @xmath367 to @xmath361 on some input with positive probability . by definition [ def :",
    "composition ] , @xmath178 can transition from @xmath368 to @xmath369 only if @xmath370 is a final state of @xmath371 and @xmath372 is the initial state of @xmath169 .",
    "thus @xmath373 is in @xmath36 .",
    "since @xmath36 is an ergodic set , if it contains a state @xmath361 of @xmath178 , then it also contains all states reachable under @xmath112 from @xmath361 . by definition ,",
    "every state in @xmath374 is reachable under @xmath112 from @xmath375 .",
    "since @xmath36 contains @xmath373 , it also contains all states in @xmath374 .",
    "given a graph @xmath128 , each of whose vertices is assigned a priority , we say that @xmath128 has the _ odd ergodic property _ if it has a reachable ergodic set whose highest priority is odd . consider a composer @xmath96 and a memoryless strategy @xmath112 for @xmath178 .",
    "then , by lemma [ lemma : odd - ergodic ] , @xmath112 is winning for the environment iff @xmath348 has the odd ergodic property .",
    "so the probabilistic notion of winning strategy is reduced to a combinatorial one .",
    "however , the graph @xmath348 is very large as it contains all the internal states of each component explicitly .",
    "further , to show that @xmath96 satisfies @xmath150 , we have to consider every possible memoryless strategy for @xmath96 .",
    "we tackle this complexity by simplifying the description of a strategy @xmath112 and graph @xmath348 so as to abstract away the inner states of components and the choices that @xmath112 makes on those inner states .",
    "let @xmath164 be the state space of @xmath96 .",
    "we aim to replace @xmath348 by a simpler graph @xmath376 , whose set of vertices is @xmath164 , such that the odd ergodic property is preserved .",
    "we first discuss this transformation informally , and then give formal definitions and proofs .",
    "let @xmath107 be a component of @xmath178 . if some reachable ergodic set of @xmath348 lies entirely within @xmath107 , we say @xmath107 is a _",
    "sink_. when the highest priority in the ergodic set is odd ( resp .",
    "we say @xmath107 is an _ odd _",
    "_ even _ ) sink for @xmath112 .",
    "note that a component can be both an odd and an even sink for a given strategy .",
    "intuitively , we aim to replace the subgraph of @xmath348 that corresponds to states of @xmath107 by a single new vertex @xmath377 to obtain a new graph @xmath376 and assign a suitable priority to @xmath377 such that the odd ergodic property is preserved by the transformation . now",
    "if @xmath107 is not a sink , then , by lemma [ lemma : component - ergodic ] , @xmath377 lies in a reachable ergodic set of @xmath376 iff all reachable states of @xmath107 lie in a reachable ergodic set of @xmath348 . in this case",
    ", we can simply assign the highest reachable priority in @xmath107 to @xmath377 and the odd ergodic property is preserved . if , however , @xmath107 is a sink , then the collapse of @xmath107 to a single vertex might introduce new ergodic sets in the graph .",
    "that is , @xmath377 might lie in an ergodic set of @xmath376 which has no analogue in @xmath348 .",
    "we then have to choose the priority of @xmath377 such that the odd ergodic property is still preserved .",
    "there are two cases to consider :    * @xmath107 is an odd sink for @xmath112 .",
    "then , by lemma [ lemma : odd - ergodic ] , @xmath112 is winning for the environment .",
    "let @xmath378 denote @xmath112 restricted to the states in @xmath107 .",
    "then @xmath378 is a memoryless strategy for @xmath107 that is winning for the environment , and in every composition involving @xmath107 , the environment can simply play @xmath378 on the states in @xmath107 to win .",
    "so a component that is an odd sink is not useful for synthesizing compositions .",
    "we note that it is easy to check for and remove any odd sinks from @xmath2 in a preprocessing step before attempting synthesis .",
    "checking whether a particular component is a sink is equivalent to model checking markov decision processes and can be done in polynomial time @xcite . in the rest of the paper , we assume that the given library @xmath2 does not contain components that are odd sinks . * @xmath107 is an even sink for @xmath112 but not an odd sink for @xmath112 . then , by lemma [ lemma : component - ergodic ] , every reachable state in @xmath107 either lies in an even sink or does not lie in an ergodic set .",
    "so no reachable state in @xmath107 is part of an ergodic set with odd highest priority . thus collapsing @xmath107 to @xmath377",
    "does not remove any ergodic sets with odd highest priority .",
    "it only remains to consider the possibility that the transformation can introduce a new ergodic set whose highest priority is odd .",
    "we can avoid this by assigning a priority of @xmath379 to @xmath377 , where @xmath151 is the highest parity assigned by the index function @xmath150",
    ". then if @xmath377 is part of a reachable ergodic set @xmath380 in @xmath376 , then @xmath380 has highest priority @xmath379 , which is even .",
    "thus the odd ergodic property is preserved .    in formalizing the approach given above , instead of explicitly transforming @xmath348 into a more abstract graph ,",
    "it is simpler to directly define a suitable graph on the state space @xmath164 of the composer @xmath96 such that the odd ergodic property is preserved . just as a memoryless strategy",
    "@xmath112 applied to the composition @xmath178 gives rise to the graph @xmath348 , we define a combinatorial object , called a _ choice function _ , such that choice function @xmath204 together with composer @xmath96 gives rise to a graph @xmath381 .",
    "[ def : choice ] given a library @xmath2 with width @xmath5 and index function @xmath150 , we define the set @xmath382 as follows : @xmath383 iff there exists a memoryless strategy @xmath112 for @xmath107 such that    * @xmath384 is the set of exits of selected by @xmath112 in @xmath107 . * if @xmath107 is an even sink for @xmath112 , then @xmath385 .",
    "* otherwise @xmath386 is the highest priority visited by @xmath112 in @xmath107 .    given a composer @xmath387 over @xmath2 , a _ choice function _ for @xmath96 ,",
    "is a function @xmath388 , such that , for all @xmath165 , @xmath389 .",
    "the graph induced by @xmath204 on @xmath96 , denoted @xmath381 , is the directed graph @xmath390 , where @xmath391 if @xmath392 for some @xmath148 such that @xmath393 where @xmath394 .",
    "the priority of a vertex @xmath395 of @xmath381 is @xmath386 where @xmath396 .",
    "we say that @xmath204 has _",
    "@xmath397 , if @xmath381 has a reachable ergodic set whose highest priority is @xmath397 .",
    "the size of the set @xmath398 is at most @xmath399 . for an arbitrary triple @xmath400",
    ", we can check whether @xmath401 in time polynomial in @xmath402 using standard techniques for solving markov decision processes @xcite .",
    "thus @xmath398 can be computed in time exponential in the size of @xmath2 .",
    "[ theorem : rank ] let @xmath96 be a composer over @xmath2 .",
    "then there exists a strategy for @xmath178 that is winning for the environment iff there exists a choice function for @xmath96 that has an odd rank .",
    "let @xmath163 .",
    "let @xmath350 be the state space of @xmath403 , for @xmath404 , and let @xmath405 be the state space of @xmath178 .",
    "_ only if _ : :    assume there exists a strategy for @xmath178 that    is winning for the environment .",
    "then , by theorem [ theorem : memoryless ] ,    there exists a memoryless winning strategy @xmath112 .",
    "we    construct a choice function @xmath204 for @xmath96 as    follows : for all @xmath406 ,    @xmath407 , where @xmath36 is the    set of exits of @xmath169 selected by @xmath112 , and    @xmath408 if @xmath169 is an even sink for    @xmath112 and otherwise @xmath152 is the highest priority    in @xmath169 visited by @xmath112 .",
    "since @xmath112    is winning , @xmath351 has a reachable    ergodic set @xmath409 with odd highest priority @xmath397 .",
    "consider the set @xmath410    defined as follows : for all    @xmath406 ,    @xmath411 if    @xmath412 .",
    "thus , @xmath413 contains a    state of the composer @xmath96 if the corresponding component    of @xmath178 overlaps with the ergodic set    @xmath409 .",
    "since @xmath2 contains no    components that are odd sinks , and even sinks can not be a part of an    ergodic set whose highest priority is odd , @xmath409 must    contain all the reachable states in each component named in    @xmath413 .",
    "+    we claim that @xmath413 is an ergodic set of    @xmath381 .",
    "we first show that @xmath413 is    strongly connected .",
    "let @xmath167 and    @xmath414 be in @xmath413 .",
    "since    all the reachable states of @xmath169 and @xmath371    are contained in @xmath409 , in particular their start states are    also contained in @xmath409 .",
    "let these be @xmath415 and    @xmath324 respectively .",
    "then there is a path in    @xmath348 from @xmath416 to    @xmath417 because @xmath409 is an ergodic set of    @xmath348 .",
    "consider the path    @xmath18 from @xmath416 to @xmath417    that contains the least number of exit states .",
    "let the length of    @xmath18 be @xmath418 and let @xmath419 be    the first exit state along @xmath18 .",
    "suppose    @xmath420 , where    @xmath421 is the exit state of @xmath169 in direction    @xmath15 , and let @xmath422 be the start state of    @xmath423 . then , if @xmath424 ,    we have @xmath425 , so there is an edge from    @xmath167 to @xmath426 in    @xmath381 , and the immediate next state after    @xmath419 in @xmath18 is @xmath427 .",
    "the suffix of @xmath18 starting from @xmath427 is    a path @xmath428 from @xmath427 to    @xmath417 of length less than @xmath418 .",
    "further , by    construction , among all such paths it has the least number of exit    states .",
    "assume , by the induction hypothesis , there is a path from    @xmath426 to @xmath414 in    @xmath381 .",
    "since    @xmath429 is also an edge in    @xmath381 , therefore , by induction , there is a path from    @xmath167 to @xmath414 in    @xmath381 . @xmath167 and",
    "@xmath414 were chosen arbitrarily in    @xmath413 .",
    "so @xmath413 is strongly    connected .",
    "+    next , we show that there are no edges that leave    @xmath413 .",
    "assume there is some edge in    @xmath381 from a vertex    @xmath430 to a vertex    @xmath431 .",
    "let    @xmath432",
    ". then there exists    @xmath425 such that    @xmath420 . let    @xmath433 be the exit state of @xmath169 in    direction @xmath15",
    ". then @xmath433 is reachable    under @xmath112 and so is @xmath434 , where @xmath422 is the start state of    @xmath426 .",
    "therefore , there is an edge in    @xmath348 from @xmath435 to    @xmath436 , which contradicts that @xmath409    is an ergodic set .",
    "thus no edges leave @xmath413 in    @xmath381 and @xmath413 is ergodic .",
    "+    finally , we show that the highest priority in    @xmath413 is @xmath397 . by construction of    @xmath204 , since @xmath409 does not contain any even    sinks , the priority of a vertex @xmath167 in    @xmath413 is the highest priority visited in    @xmath169 by @xmath112 .",
    "thus , the highest priority in    @xmath413 is at most the highest priority in    @xmath409 , which is @xmath397 .",
    "let    @xmath437 be such that @xmath58 has priority    @xmath397 .",
    "then the highest priority visited by @xmath112    in @xmath423 is @xmath397 , so    @xmath438 for some    @xmath384 .",
    "since    @xmath439 , the highest priority in    @xmath413 is @xmath397 , and @xmath204 has    rank @xmath397 . _ if _ : :    now assume that @xmath204 is a choice function for    @xmath96 with rank @xmath152 , for some odd    @xmath440 .",
    "then , by the definition of choice    function , for all @xmath406 , there    exists a memoryless strategy @xmath441 for @xmath169 ,    such that @xmath442 where    @xmath443 is the set of exit directions of @xmath169    under @xmath441 , and @xmath444 if    @xmath169 is an even sink for @xmath441 and otherwise    @xmath445 is the highest priority visited by    @xmath441 .",
    "+    we define a memoryless strategy @xmath112 for    @xmath178 as follows : for all    @xmath446 , @xmath447 .",
    "since    @xmath204 has rank @xmath152 , there exists a reachable    ergodic set @xmath410 of    @xmath381 with highest priority @xmath152 .",
    "consider    the set @xmath448 , which consists of all states in all components    corresponding to the set @xmath413 .",
    "let    @xmath449 be the subset of @xmath409 that is reachable    under @xmath112 from the start state of    @xmath178 .",
    "we first show that @xmath449 is    strongly connected .",
    "let @xmath450 and    @xmath451 be two arbitrary states in @xmath449 .",
    "then @xmath415 is a state of @xmath169 and    @xmath324 is a state of @xmath371 .",
    "further ,    @xmath167 and @xmath414 are both    in @xmath413 .",
    "we have the following two cases :    +    1 .   _",
    "@xmath415 is the start state of @xmath169_.    consider the shortest path in @xmath381 from    @xmath167 to @xmath414 .",
    "such a    path exists because @xmath413 is an ergodic set of    @xmath381 .",
    "let the length of the path be @xmath418    and let @xmath426 be the successor of    @xmath167 in this path .",
    "so there is path of length    @xmath452 in @xmath381 from    @xmath426 to @xmath414 .",
    "now , by    the definition of @xmath381 , there exists    @xmath453 such that    @xmath420 and the exit    state in direction @xmath15 is reachable from the start state    of @xmath167 under @xmath441 .",
    "thus there is    a path in @xmath351 from    @xmath450 to @xmath454 where    @xmath422 is the start state of @xmath423 . by    induction",
    ", there is a path in @xmath351    from @xmath416 to @xmath417 .    2 .",
    "@xmath415 is not the start state of @xmath169_.    let @xmath432 , where    @xmath384 .",
    "since @xmath152 is the highest    priority in @xmath413 and    @xmath455 , we have    @xmath456 .",
    "thus    @xmath457 and so @xmath169 is not an    even sink for @xmath112 . also , the library    @xmath2 is assumed to have no components that are    odd sinks .",
    "thus , some exit of @xmath169 must be reachable from    @xmath415 under @xmath441 .",
    "let this exit be in    direction @xmath453 , and let    @xmath420 .",
    "then there    is a path in @xmath351 from    @xmath450 to @xmath454 where    @xmath422 is the start state of @xmath423 . now , since    @xmath422 is a start state , by the previous case , there is a    path from @xmath427 to @xmath417 in    @xmath348 .",
    "so there is a path from    @xmath416 to @xmath417 and therefore    @xmath449 is strongly connected .",
    "+    assume that some edge in @xmath348 leaves    @xmath449 .",
    "let there be an edge between    @xmath458 and @xmath459 .",
    "now    @xmath426 can not belong to    @xmath413 because otherwise @xmath460    would be in @xmath449 .",
    "so we have @xmath461 and    @xmath360 must be an exit state of @xmath169 .",
    "therefore there is an edge in @xmath381 from    @xmath462 to    @xmath463 , which    contradicts that @xmath413 is ergodic .",
    "thus    @xmath449 is also an ergodic set .",
    "+    by lemma [ lemma : odd - ergodic ] , it suffices to show that the highest    priority in @xmath449 is odd .",
    "now @xmath152 is the    highest priority in @xmath413 , and @xmath152 is    odd , which means @xmath464 .",
    "so there must exist @xmath462 such that some state @xmath58 in    @xmath169 has priority @xmath152 and is reachable under    @xmath441 .",
    "then @xmath465 is in @xmath449    and so @xmath449 has highest priority at least    @xmath152 .",
    "assume some state @xmath460 in    @xmath449 has priority @xmath466 . since    @xmath125 is reachable under @xmath467 , therefore , we    have @xmath468 , for some    @xmath384 and @xmath469 .",
    "this contradicts the fact that    @xmath470 .",
    "thus the highest priority    in the ergodic set @xmath449 is @xmath152 , which is odd .",
    "let @xmath471 .",
    "a composer and choice function pair has a natural representation as a regular @xmath472-labeled @xmath5-tree .",
    "given a composer @xmath174 over @xmath2 , and a choice function @xmath204 for @xmath96 , we denote by @xmath473 , the regular @xmath472-labeled full @xmath5-tree @xmath474 , where for all @xmath475 , we have that @xmath476 . thus @xmath473 is the tree obtained as a result of adding labels to @xmath477 such that a node @xmath15 corresponding to @xmath165 that is labeled with @xmath169 in @xmath477 is labeled with @xmath478 where @xmath479 .",
    "as we show in the next lemma , the mapping is reversible , in the sense that given a regular @xmath472-labeled @xmath5-tree , we can obtain a composer and choice function in a natural way .",
    "[ lemma : choice - tree ] let @xmath12 be a regular @xmath472-labeled full @xmath5-tree .",
    "then there exist a composer @xmath96 over @xmath2 and a choice function @xmath204 for @xmath96 such that @xmath480 .",
    "since @xmath12 is regular , there exists a deterministic transducer @xmath481 that generates @xmath12 .",
    "we define @xmath482 as follows : for all @xmath229 ,    * there is a state @xmath483 in @xmath164 * if @xmath484 then @xmath485 * for all @xmath453 , @xmath486 where @xmath487    we define @xmath488 as follows : for all @xmath229 , @xmath489 where @xmath490 .",
    "then , since @xmath491 , @xmath204 is a choice function .",
    "let @xmath492 and @xmath493 .",
    "we need to show that @xmath494 .",
    "consider a node @xmath495 .",
    "we have @xmath496 and @xmath497 .",
    "let @xmath498 and @xmath499 .",
    "then , by construction of @xmath96 and @xmath204 , @xmath500 , @xmath501 , and @xmath502",
    ". therefore @xmath503 .    in light of lemma",
    "[ lemma : choice - tree ] , we can represent an arbitrary regular @xmath472-labeled full @xmath5-tree as @xmath473 for some composer @xmath96 over @xmath2 and some choice function @xmath204 for @xmath96 .",
    "similarly , we can represent an arbitrary regular @xmath2-labeled full @xmath5-tree as @xmath477 for some composer @xmath96 over @xmath2 .    since the question of whether a given composition satisfies @xmath150 boils down to whether its composer has a choice function that has an odd rank , we find it useful to characterize regular trees that correspond to choice functions having a particular rank ( see @xcite for related results ) .",
    "first , we inductively define the set of _ marked _ nodes of a @xmath472-labeled @xmath5-tree as follows : the root is always marked , and a node @xmath504 , where @xmath148 and @xmath9 , is marked if @xmath505 is marked and @xmath393 , where @xmath506 is the label on @xmath507 .",
    "[ lemma : rank ] let @xmath163 be a composer over library @xmath2 with width @xmath5 , @xmath150 be an index function for @xmath2 , @xmath204 be a choice function for @xmath96 , and @xmath508 .",
    "then @xmath204 has rank @xmath152 iff @xmath473 has a full subtree @xmath12 such that :    1 .",
    "the root of @xmath12 is marked .",
    "every node in @xmath12 that is marked has priority label at most @xmath152 .",
    "3 .   from each marked node in @xmath12",
    "there is a path in @xmath12 to a marked node with priority label @xmath152 .    _ only if : _",
    "assume @xmath204 has rank @xmath152 .",
    "then , by definition , there exists a reachable ergodic set of @xmath381 whose highest priority is @xmath152 .",
    "let @xmath165 be a vertex of @xmath381 that lies in this ergodic set such that there is a path in @xmath381 from @xmath509 to @xmath167 and @xmath167 has priority @xmath152 .",
    "since @xmath167 is reachable from @xmath509 in @xmath381 , there exists some @xmath475 such that @xmath510 and @xmath15 is marked .",
    "then the node @xmath511 is labeled with @xmath512 for some @xmath384 .",
    "let @xmath513 be the full subtree of @xmath473 rooted at @xmath15 .",
    "we show that @xmath513 has the desired property .",
    "let @xmath505 be a node in @xmath513 that is marked and let @xmath514 .",
    "then @xmath426 must lie in the ergodic set of @xmath381 containing @xmath167 and @xmath515 for some @xmath516 and @xmath517 .",
    "so @xmath505 is labeled @xmath518 and has a priority label less than or equal to @xmath152 .",
    "all that remains is to show that some marked node in @xmath513 with a priority label @xmath152 is reachable from @xmath505 .",
    "since @xmath167 is reachable from @xmath426 in @xmath381 , there must exist @xmath519 such that @xmath520 and @xmath521 is marked .",
    "then @xmath522 is also labeled @xmath512 .",
    "since @xmath513 is a full subtree , and @xmath523 , therefore @xmath524 also lies in @xmath513 and there is a path from @xmath505 to @xmath524 .    _",
    "let @xmath12 be a full subtree of @xmath473 that satisfies the given property .",
    "consider the set @xmath525 of vertices in @xmath381 defined as follows : @xmath526 if there exists some marked node @xmath8 such that @xmath527 .",
    "note that every vertex in @xmath528 is reachable from @xmath509 in @xmath381 and has priority at most @xmath152 .",
    "consider the subgraph @xmath529 of @xmath381 induced by @xmath528 .",
    "let @xmath530 be an ergodic set of @xmath529 and let @xmath168 be an arbitrary vertex in @xmath530 .",
    "then there exists a marked node @xmath531 such that @xmath532 .",
    "let @xmath533 be such that @xmath534 is marked and has priority label @xmath152",
    ". then every node along the path from @xmath505 to @xmath534 is also marked .",
    "let @xmath535 and @xmath536 , for @xmath537 .",
    "then the priority of @xmath538 is @xmath152 and @xmath539 is a path in @xmath529 .",
    "since @xmath540 and @xmath541 is an ergodic set of @xmath529 , @xmath538 must also lie in @xmath530 .",
    "thus the highest priority in @xmath530 is @xmath152 .",
    "finally , it suffices to show that no edges leave @xmath528 in @xmath381 , as this implies that @xmath530 is also an ergodic set of @xmath381 .",
    "consider an edge in @xmath381 from a vertex @xmath542 to a vertex @xmath543 .",
    "then there exist @xmath384 and @xmath544 such that @xmath545 and @xmath396 for some priority @xmath386 .",
    "since @xmath168 lies in @xmath528 , there exists a marked node @xmath8 such that @xmath546 .",
    "then @xmath547 is also marked and @xmath548 . by the construction of @xmath528",
    ", @xmath549 lies in @xmath528 .",
    "thus there are no edges that leave @xmath528 .",
    "the conditions given by lemma [ lemma : rank ] can be checked by a suitable tree automaton as follows :    [ lemma : automata ] let @xmath2 be a library with width @xmath5 and let @xmath550 . then there exists an nondeterministic bchi tree automaton ( nbt ) @xmath551 such that @xmath551 accepts a @xmath472-labeled regular @xmath5-tree @xmath12 iff @xmath552 for some composer @xmath96 over @xmath2 and choice function @xmath204 with rank @xmath152 .    by lemma [ lemma : choice - tree ] and [ lemma :",
    "rank ] , it suffices to construct an nbt @xmath551 such that @xmath551 accepts a tree @xmath33 iff @xmath33 has a full subtree @xmath12 that satisfies the three conditions in lemma [ lemma : rank ] . for simplicity",
    ", the automaton is defined over binary trees , where @xmath553 , but the definition can be easily extended to @xmath418-ary trees .",
    "let @xmath554 .",
    "we define @xmath555 , @xmath556 and @xmath557 .",
    "the states of the automaton can then be described as follows :    * @xmath558 : in this state the automaton is searching for the root of the special subtree .",
    "* @xmath559 : this represents a branch not taken .",
    "* @xmath560 and @xmath561 : in these states the automaton has entered the subtree and is looking for nodes labeled with @xmath152 . *",
    "@xmath562 : in this state the automaton has just visited a node with label @xmath152 in the subtree . *",
    "@xmath563 : this is an error state that is entered if there is a label higher than @xmath152 in the subtree .",
    "the transition function @xmath75 is defined as follows : for all @xmath564 ,    1 .   for @xmath565 , @xmath566 .",
    "2 .   for @xmath567 @xmath568 3 .   for @xmath569 , if @xmath570 then @xmath571 , if @xmath572 then @xmath573 and if @xmath574 then @xmath575    in the first stage , @xmath551 guesses the location of the root of the special subtree @xmath12 . while searching for this root , @xmath551 remains in the state @xmath558 .",
    "when it encounters the root , it enters the state @xmath560 for the first time .",
    "this starts the second stage , where @xmath551 considers only marked nodes in @xmath12 . in directions that correspond to a non - marked node , @xmath551 moves to the state @xmath559 and remains there perpetually . from every marked node in @xmath12 , @xmath551 guesses a path to another marked node with label @xmath152 , using the states @xmath560 and @xmath561 .",
    "it starts this search in state @xmath560 , moves to state @xmath561 immediately , remains there until it encounters a marked node with label @xmath152 , and then moves to state @xmath562 .",
    "if there is no path from some node to another node with label @xmath152 , all runs corresponding to the choice of @xmath12 as subtree will eventually get stuck in @xmath561 .",
    "thus , some run corresponding to @xmath12 as the required subtree is accepting iff @xmath12 satisfies the required conditions .    [",
    "theorem : embedded ] let @xmath2 be a library with width @xmath5 , @xmath196 be an exit control relation for @xmath2 , and @xmath150 be an index function for @xmath2 .",
    "there exists a non - deterministic parity tree automaton ( npt ) @xmath576 such that , for all composers @xmath96 over @xmath2 , @xmath576 accepts @xmath477 iff @xmath96 satisfies @xmath150 and @xmath96 is compatible with @xmath196 .",
    "consequently , @xmath576 is non - empty iff @xmath2 realizes @xmath150 under @xmath196 .",
    "we define @xmath577 , where @xmath578 is a safety tree automaton that accepts @xmath477 iff @xmath96 is compatible with @xmath196 , and @xmath579 is an npt that accepts @xmath477 iff @xmath96 satisfies @xmath150 .",
    "since the intersection of a safety automaton and an npt is again an npt , @xmath576 is also an npt .    _",
    "construction of @xmath578 _ : for simplicity , we define the automaton for the case @xmath553 , and note that the definition can be easily extended for arbitrary @xmath5 .",
    "@xmath580 , where @xmath581 is defined as follows : for all @xmath582 ,    * @xmath583 * for @xmath584 , if @xmath585 then @xmath586    note that @xmath578 has no transitions out of the states @xmath259 and @xmath0 iff the exit control relation @xmath196 is violated .",
    "thus @xmath578 accepts @xmath477 iff @xmath96 is compatible with @xmath196 .",
    "_ construction of @xmath579 _ : let @xmath471 and let @xmath587 be the nbt defined in lemma [ lemma : automata ] .",
    "we define @xmath588 , where @xmath589    while @xmath551 accepts @xmath472-labeled @xmath5-trees , @xmath590 accepts @xmath2-labeled @xmath5-trees . @xmath590",
    "simply simulates @xmath551 by using its larger transition function to guess the missing portion of the labels .",
    "we can characterize the regular trees accepted by @xmath590 as follows : for a composer @xmath96 over @xmath2 , @xmath590 accepts @xmath477 iff there exists a choice function for @xmath96 which has rank @xmath152 .    consider the automaton @xmath591 whose language is the union of the language of each @xmath590 , for all odd @xmath592 .",
    "let @xmath96 be a composer over @xmath2 .",
    "then @xmath591 accepts @xmath477 iff there exists a choice function for @xmath96 that has an odd rank .",
    "thus , by theorem [ theorem : rank ] , @xmath591 accepts @xmath477 iff @xmath96 does not satisfy @xmath150 .",
    "finally , consider the automaton @xmath593 , which is the complement of @xmath591 .",
    "then @xmath579 accepts @xmath477 iff @xmath96 satisfies @xmath150 .",
    "since an npt is nonempty iff it accepts a regular tree , and @xmath2 realizes @xmath150 under @xmath196 iff some composer @xmath96 over @xmath2 satisfies @xmath150 and @xmath96 is compatible with @xmath196 , therefore @xmath576 is non - empty iff @xmath2 realizes @xmath150 under @xmath196 .",
    "the nbt @xmath590 accepts @xmath80-ary trees and has @xmath594 states , with an alphabet of size @xmath595 , so @xmath591 is an nbt with @xmath596 states , where @xmath597 .",
    "it follows that @xmath579 is a nondeterministic parity tree automaton ( npt ) with @xmath598 states and parity index @xmath596 @xcite . also , @xmath578 is a safety automaton with @xmath599 states .",
    "thus , their intersection @xmath576 is an npt with @xmath600 states and parity index @xmath596 , whose nonemptiness can be tested in time @xmath601 @xcite .",
    "we thus obtain the following :    the embedded parity realizability problem is in exptime .",
    "if an alternating tree automaton is nonempty , then it must accept some regular tree @xcite . given a regular tree accepted by @xmath576 , we can obtain a finite transducer that generates that tree .",
    "this transducer is a composer that realizes @xmath150 under @xmath196 .",
    "thus , we also obtain a solution to the embedded parity synthesis problem .",
    "the embedded parity synthesis problem is in exptime .",
    "the complexity of our solution is exponential in both  @xmath602 , where  @xmath276 is the highest parity index , as well as  @xmath80 , which is the number of exit states in each component .",
    "the exponential dependence on @xmath276 is expected , as typical algorithms for solving parity games are exponential in the parity index , cf .",
    "improving @xmath602 to @xmath276 is an open challenge .",
    "it is also an open question whether the exponential dependence on  @xmath80 can be avoided .",
    "we remark that the embedded parity synthesis problem can be viewed as a 2-player partial information stochastic parity game .",
    "informally , the game can be described as follows : the two players are the composer c and the environment e. the c player chooses components and the e player chooses paths through the components chosen by c. c can not see the moves e makes inside a component . at the start",
    "c chooses a component @xmath107 from the library @xmath2 .",
    "the turn passes to e , who chooses a sequence of inputs , inducing a path in @xmath107 from its start state to some exit @xmath15 in @xmath5 .",
    "the turn then passes to c , which must choose some component @xmath173 in @xmath603 and pass the turn to e and so on . as c can not see the moves made by e inside @xmath107",
    ", c can not base its choice on the run of e in @xmath107 , but only on the exit induced by the inputs selected by e and previous moves made by c. so c must choose the same next component @xmath173 for different runs that reach exit @xmath15 of @xmath107 .",
    "in general , different runs will visit different priorities inside @xmath107 .",
    "this is a two - player stochastic parity game where one of the players does not have full information .",
    "if c has a winning strategy that requires a finite amount of memory , then we can use such a strategy to obtain a suitable finite composer that satisfies the index function @xmath150 , thus solving the embedded parity synthesis problem . if c has no winning strategy or",
    "if every winning strategy requires infinite memory , then @xmath150 is not realizable from the library @xmath603 .",
    "we also note that , when viewed in the framework of games , our result is a rare positive result for partial - information stochastic games . in general , 2-player partial information stochastic games are known to be undecidable even for co - buchi objectives ( and thus for parity objectives ) @xcite .",
    "let @xmath604 be a deterministic parity automaton ( dpw ) , @xmath107 be a probabilistic transducer and @xmath2 be a library of components .",
    "we say @xmath604 is a _ monitor _ for @xmath107 ( resp .",
    "@xmath2 ) if the input alphabet of @xmath604 is the same as the output alphabet of @xmath107 ( resp .",
    "@xmath2 ) . let @xmath604 be a monitor for @xmath107 and let @xmath605 be the language accepted by @xmath604 .",
    "we say a strategy @xmath112 for @xmath107 is _ winning _ for the environment iff @xmath606 , i.e. , the output of @xmath107 is rejected by @xmath604 with positive probability .",
    "we say that @xmath107 _ satisfies _",
    "@xmath604 if there exists no winning strategy for the environment .",
    "the _ dpw probabilistic realizability problem _ is : given a library @xmath2 and a dpw @xmath604 that is a monitor for @xmath2 , decide whether there exists a composer @xmath96 over @xmath2 , such that @xmath178 satisfies @xmath604 .",
    "if such a composer exists , we say that @xmath2 _ realizes _ @xmath604 .",
    "the _ dpw probabilistic synthesis problem _ is to find such a composer @xmath96 if it exists .",
    "we transform this problem into a version of the embedded parity problem solved in section [ sec : embedded - parity ] .",
    "let @xmath607 be a dpw and @xmath608 be a probabilistic transducer . for @xmath609 , we denote by @xmath610 , the probabilistic transducer @xmath611 , where @xmath612 if @xmath613 and @xmath259 otherwise .",
    "given a library @xmath2 with width @xmath5 , we define the _ augmented library _ @xmath614 .",
    "the width of @xmath615 is @xmath616 .",
    "we define the exit control relation @xmath617 for @xmath615 as follows : for all @xmath148 , @xmath609 , @xmath582 , we have @xmath618",
    ". we also extend @xmath619 to @xmath615 as follows : for @xmath620 , @xmath621 .",
    "thus @xmath619 is an index function for @xmath615 .",
    "our first step is to treat this augmented library as a new library and solve the embedded parity synthesis problem for @xmath615 with @xmath619 as the index function and @xmath622 as the exit control relation .",
    "this gives us a tree automaton that accepts @xmath615-labeled @xmath623-trees and that is empty iff @xmath615 does not realize @xmath619 under @xmath622 .",
    "later , we show how to transform this automaton into another that accepts @xmath2-labeled @xmath5-trees and is empty iff @xmath2 does not realize @xmath604 .",
    "since , by definition , @xmath615 bijectively maps to @xmath624 , we find it convenient to use labels from @xmath624 in place of @xmath615 .",
    "we now define a composer for the augmented library .",
    "the states of the composer are pairs of the form @xmath625 , where @xmath361 is a monitor state and @xmath168 represents an instance of a component from @xmath2 .",
    "a _ composer _ for @xmath615 , is a deterministic transducer @xmath626 .",
    "the following lemma follows directly from theorem [ theorem : embedded ] still uniquely identifies an element of @xmath615 . ] .",
    "[ lemma : embedded - dpw ] let @xmath2 be a library and @xmath604 be a dpw that is a monitor for @xmath2 .",
    "there exists an npt @xmath627 that accepts a regular tree @xmath12 iff @xmath97 for some composer @xmath96 over @xmath615 such that @xmath178 satisfies @xmath619 and @xmath96 is compatible with @xmath622 .    given a composer @xmath96 over a library @xmath2 and a monitor @xmath604 for @xmath2",
    ", we can extend @xmath96 to a composer over the augmented library @xmath615 .",
    "let @xmath2 be a library and @xmath604 be a monitor for @xmath2 .",
    "let @xmath163 be a composer over @xmath2 .",
    "the _ augmentation _ of @xmath96 by @xmath604 , denoted @xmath628 , is a composer over @xmath615 such that @xmath629 , where    * for all @xmath630 , @xmath631 , @xmath632 .",
    "* for all @xmath633 , @xmath631 and @xmath634 , @xmath635 .",
    "we say @xmath628 is an augmented composer .",
    "while a composer only keeps track of the transfer of control between components , the augmented composer also keeps track of the state of the monitor before and after the control is transferred . to go from augmented composers to composers , we use techniques from synthesis with incomplete information @xcite",
    "we start by describing a relation between @xmath477 and @xmath636 .",
    "first we need to introduce some convenient notation .",
    "let @xmath36 , @xmath42 and @xmath336 be finite sets . for a @xmath336-labeled @xmath637-tree @xmath638 , we denote by @xmath639 , the @xmath640-labeled @xmath637-tree @xmath641 in which each node is labeled by both its direction in @xmath42 and its labeling in @xmath638 .",
    "we define operators @xmath642 and @xmath643 .",
    "the operator @xmath644 replaces each letter @xmath645 , where @xmath425 and @xmath646 , by the letter @xmath15 .",
    "the operator @xmath643 maps @xmath336-labeled @xmath36-trees to @xmath336-labeled @xmath637-trees as follows : @xmath647 , where for each node @xmath648 , we have @xmath649 .",
    "[ lemma : augmented ] let @xmath2 be a library and @xmath604 be a monitor for @xmath2 . let @xmath96 be a composer over @xmath2 and @xmath628 be the augmentation of @xmath96 by @xmath604",
    ". then @xmath650 .",
    "let @xmath12 be the unlabeled full @xmath5-tree and @xmath33 be the unlabeled full @xmath623-tree .",
    "let @xmath651 . since @xmath477 is a @xmath2-labeled @xmath5-tree",
    ", @xmath652 is a @xmath2-labeled @xmath623-tree , and @xmath653 is a @xmath654-labeled @xmath623-tree . let @xmath655 .",
    "now , by definition , @xmath636 is also a @xmath654-labeled @xmath623-tree .",
    "let @xmath656 .",
    "it suffices to prove that @xmath657 .",
    "let @xmath658 and @xmath659 .",
    "let @xmath660 and let @xmath661 be the direction of @xmath662",
    ". then @xmath663",
    ". then @xmath664 .",
    "therefore @xmath657 .    [",
    "theorem : augmented ] let @xmath2 be a library and @xmath604 be a monitor for @xmath2 .",
    "let @xmath96 be a composer over @xmath2 and @xmath628 be the augmentation of @xmath96 by @xmath604",
    ". then @xmath96 satisfies @xmath604 iff @xmath628 satisfies @xmath619 .",
    "let @xmath607 and @xmath665 .",
    "let @xmath46 and @xmath666 be the state spaces of @xmath178 and @xmath667 , respectively .",
    "then @xmath668 . let @xmath147 be the start state of @xmath178 .",
    "then @xmath669 is the start state of @xmath667 .",
    "let @xmath605 be the language of @xmath604 .",
    "given @xmath670 , we denote by @xmath671 , the output sequence produced by @xmath178 corresponding to state sequence @xmath662 .",
    "we define @xmath672 .",
    "then a strategy @xmath112 for @xmath178 is winning for the environment iff @xmath673 .",
    "we define a notion of consistency for words in @xmath674 as follows : @xmath669 is consistent , and if @xmath675 is consistent then , for all @xmath229 , @xmath676 is consistent , where @xmath677 is the last letter of @xmath49 .",
    "an infinite path in @xmath678 is _ consistent _ if all of its finite prefixes are consistent .",
    "we let @xmath409 denote the set of all consistent paths in @xmath678 , and @xmath679 denote the subtree of @xmath674 that contains all consistent words in @xmath674 .",
    "then @xmath679 contains all paths in @xmath409 .",
    "we define @xmath196 to be the set of paths in @xmath678 where the highest parity visited i.o .",
    "is even .",
    "let @xmath204 be a strategy for @xmath667 and @xmath260 be the probability measure it induces on @xmath678 . then , by the definition of @xmath615 , for every @xmath675",
    "that is not consistent , we have @xmath680 .",
    "therefore , the probability that an infinite path over @xmath666 is not consistent is zero .",
    "so consistent paths are the only ones that matter probabilistically .",
    "in particular , given two strategies @xmath204 and @xmath681 for @xmath667 , such that @xmath682 for all @xmath683 , we have @xmath684 .",
    "thus , in order to define a strategy for all of @xmath674 it suffices to define it for @xmath679 . also , @xmath204 is winning for the environment iff @xmath685 , i.e. , the probability that the highest parity visted i.o . in a consistent path is positive .",
    "similarly , given a strategy @xmath112 over @xmath178 , we have @xmath686 , i.e. , the probability of a path not beginning from the start state is zero .",
    "this means that two strategies that agree on nodes in @xmath687 induce the same distribution on @xmath50 .",
    "thus , in order to define a strategy for all of @xmath688 , it suffices to define it for @xmath687 .",
    "finally , we note that @xmath679 is isomorphic to @xmath689 , with the isomorphism @xmath690 given by @xmath691 .",
    "let @xmath128 be the set of all strategies @xmath692 , and @xmath104 be the set of all strategies @xmath693 .",
    "then @xmath694 can be lifted to a bijection from @xmath104 to @xmath128 as follows : for @xmath695 , @xmath696 , @xmath697 and @xmath698",
    ". then @xmath699 and @xmath700 . thus @xmath695 ( resp .",
    "@xmath696 ) is winning for the environment iff @xmath701 ( resp .",
    "@xmath702 ) is winning for the environment .    given a library @xmath2 and monitor @xmath604",
    ", we can solve the embedded realizability problem for the augmented library @xmath615 to obtain a regular tree @xmath12 , where @xmath97 for some composer @xmath96 over @xmath615 such that @xmath96 satisfies @xmath619 .",
    "then the tree @xmath703 is also regular , so @xmath704 for some composer @xmath705 over @xmath2 .",
    "now we would like to use @xmath705 to solve the dpw realizability problem , but @xmath705 is only guaranteed to satisfy @xmath604 if @xmath96 is the augmentation of @xmath705 by @xmath604 .",
    "therefore , to solve the dpw realizability problem , we have to obtain an automaton that accepts a tree @xmath706 if the augmentation of @xmath705 by @xmath604 satisfies @xmath619 .",
    "[ theorem : narrow ] let @xmath36 , @xmath42 and @xmath336 be finite sets . given an alternating automaton @xmath627 over @xmath640-labeled @xmath637-trees , we can construct an alternating automaton @xmath707 over @xmath336-labeled @xmath36-trees such that @xmath707 accepts a labeled tree @xmath708 iff @xmath627 accepts @xmath709 .",
    "further , @xmath627 and @xmath707 have the same acceptance condition and @xmath710 .",
    "let @xmath711 be an alternating automaton that accepts @xmath640-labeled @xmath712-trees .",
    "we define automaton @xmath713 over @xmath336-labeled @xmath637-trees , where for each @xmath229 , @xmath646 and @xmath714 , @xmath715 is obtained from @xmath716 by replacing each atom @xmath717 by the atom @xmath718 .",
    "so a state @xmath719 in @xmath720 corresponds to a state @xmath58 in @xmath627 that reads only nodes in direction @xmath505 .",
    "then @xmath720 accepts a @xmath336-labeled @xmath637-tree @xmath721 iff @xmath627 accepts @xmath722 .",
    "next , we define alternating automaton @xmath723 over @xmath336-labeled @xmath36-trees , where for every @xmath724 and @xmath714 , @xmath725 is obtained from @xmath726 by replacing each atom @xmath727 by the atom @xmath728 . then for every @xmath336-labeled @xmath36-tree @xmath708 , we have @xmath729 iff @xmath730 ( see @xcite for proof ) .    therefore , @xmath707 accepts @xmath708 iff @xmath627 accepts @xmath709 , and @xmath707 is the required automaton .",
    "given an alternating automaton @xmath627 , let @xmath731 denote the corresponding automaton constructed in theorem [ theorem : narrow ] .",
    "let @xmath2 be a library and @xmath604 be a monitor for @xmath2 .",
    "then there exists an alternating parity tree automaton ( apt ) @xmath576 such that , for all composers @xmath96 over @xmath2 , @xmath576 accepts @xmath477 iff @xmath96 satisfies @xmath604 .",
    "consequently , @xmath576 is non - empty iff @xmath2 realizes @xmath604 .",
    "let @xmath607 .",
    "let @xmath707 be the npt that accepts @xmath732 iff @xmath705 satisfies @xmath619 and @xmath705 is compatible with @xmath622 , for all composers @xmath705 over @xmath615 . such a @xmath707 exists by lemma [ lemma : embedded - dpw ] .",
    "let @xmath733 .",
    "we show that @xmath627 , which is an apt , is the required automaton .",
    "let @xmath96 be a composer over @xmath2 . by theorem  [ theorem : augmented ]",
    ", @xmath96 satisfies @xmath604 iff @xmath628 satisfies @xmath619 .",
    "therefore , @xmath734 accepts @xmath636 iff @xmath96 satisfies @xmath604 . by lemma [ lemma : augmented ] , @xmath735 and by theorem [",
    "theorem : narrow ] , @xmath576 accepts a tree @xmath12 iff @xmath734 accepts @xmath736 .",
    "thus , @xmath576 accepts @xmath477 iff @xmath96 satisfies @xmath604 . since an apt is nonempty iff it accepts a regular tree , and @xmath2 realizes @xmath604 iff some composer @xmath96 over @xmath2 satisfies @xmath604 , therefore @xmath576 is non - empty iff @xmath2 realizes @xmath604 .",
    "each transducer in the augmented library @xmath615 has a set of final states of size @xmath737 .",
    "thus the automaton @xmath707 has size exponential in both @xmath80 and @xmath738 .",
    "the translation from @xmath707 to @xmath627 adds no blowup , but @xmath627 is an apt , while @xmath707 is an npt . since emptiness for an alternating parity tree automaton",
    "can be checked in time exponential in the size of the automaton @xcite , therefore @xmath627 can be be checked for emptiness in time doubly exponential in @xmath80 and @xmath738 .",
    "the dpw probabilistic realizability problem is in 2exptime .",
    "again , if an alternating tree automaton is nonempty , then it must accept some regular tree @xcite , and given a regular tree accepted by @xmath576 , we can obtain a finite transducer that generates that tree . this transducer is a composer that realizes @xmath604 .",
    "thus , we also obtain a solution to the dpw probabilistic synthesis problem .",
    "the dpw probabilistic synthesis problem is in 2exptime .",
    "the doubly exponential upper bound for our solution can be viewed as follows : we inherit one exponential from the embedded parity solution and the second exponential is introduced by the use of an apt to deal with incomplete information .",
    "it is an open question whether the second exponential can be avoided .",
    "component - based synthesis seeks to build systems that satisfy a given specification using pre - existing components .",
    "this contrasts with classical synthesis , where the aim is to build a system from scratch .",
    "the component - based approach is closer in spirit to how systems are built in the real world . in this paper",
    ", we generalize the component - based synthesis problem to a probabilistic setting .",
    "our components are modeled as probabilistic transducers and the specification is given as a deterministic parity automaton .",
    "the composition itself is described by a deterministic transducer , called a _ composer _ , which governs the transitions between components .",
    "we break the problem down in two stages .",
    "first we solve a simpler version , which we call the _ embedded parity synthesis problem _ , where the specification is embedded as parities in the components themselves .",
    "our solution combines techniques from markov chain analysis and automata theoretic verification .",
    "then we show how to solve the more general case of a separate specification , which we call the _ dpw probabilistic synthesis problem _ , by reducing it to the simpler case using techniques from synthesis with incomplete information .",
    "we show that the embedded parity synthesis problem is in exptime and the dpw probabilistic synthesis problem is in 2exptime . the question of tighter lower and upper bounds we leave for future work . in particular",
    ", it is an open question whether the dpw probabilistic synthesis problem is in exptime .",
    "another line of work is suggested by the possibility of probabilistic composers . in recent work , we show that allowing the composer to be a probabilistic transducer makes the synthesis problem sensitive to the specification formalism @xcite .",
    "it turns out that probabilistic composers are more expressive than their deterministic counterparts for dpw specifications , but they have the same expressive power for embedded parity specifications .",
    "l.  de  alfaro and t.a .",
    "interface - based design . in _",
    "engineering theories of software - intensive systems _ , nato science series : mathematics , physics , and chemistry 195 , pages 83104 .",
    "springer , 2005 .",
    "probabilistic linear - time model checking : an overview of the automata - theoretic approach . in _",
    "formal methods for real - time and probabilistic systems _",
    ", lncs 1601 , pages 265276 .",
    "springer , 1999 ."
  ],
  "abstract_text": [
    "<S> synthesis is the automatic construction of a system from its specification . in classical synthesis algorithms </S>",
    "<S> , it is always assumed that the system is `` constructed from scratch '' rather than composed from reusable components . </S>",
    "<S> this , of course , rarely happens in real life , where almost every non - trivial commercial software system relies heavily on using libraries of reusable components . </S>",
    "<S> furthermore , other contexts , such as web - service orchestration , can be modeled as synthesis of a system from a library of components . </S>",
    "<S> recently , lustig and vardi introduced _ dataflow _ and _ control - flow _ synthesis from libraries of reusable components . </S>",
    "<S> they proved that dataflow synthesis is undecidable , while control - flow synthesis is decidable . in this work , we consider the problem of control - flow synthesis from libraries of _ </S>",
    "<S> probabilistic components_. we show that this more general problem is also decidable . </S>"
  ]
}