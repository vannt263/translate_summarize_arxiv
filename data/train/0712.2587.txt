{
  "article_text": [
    "the new demand of wireless communications in recent years inspires a quick advance in wireless transmission technology .",
    "technology blossoms in both high - mobility low - bit - rate and low - mobility high - bit - rate transmissions . apparently , the next challenge in wireless communications would be to reach high transmission rate under high mobility .",
    "the main technology obstacle for high - bit - rate transmission under high mobility is the seemingly highly time - varying channel characteristic due to movement ; such a characteristic further enforces the difficulty in compensating the intersymbol interference .",
    "presently , a typical receiver for wireless communications usually contains separate modules respectively for channel estimation and channel equalization .",
    "the former module estimates the channel parameters based on a known training sequence or pilots , while the latter module uses these estimated channel parameters to eliminate the channel effects due to multipath fading .",
    "however , the effectiveness in channel fading elimination for such a system structure may be degraded at a fast time - varying environment , which makes high - bit - rate transmission under high - mobility environment a big challenge .",
    "recent researches @xcite@xcite@xcite@xcite@xcite have confirmed that better system performance can be obtained by jointly considering a number of system devices , such as channel coding , channel equalization , channel estimation , and modulation , when compared with the system with individually optimized devices .",
    "specially , some works on combining devices of codeword decision and channel effect cancellation in typical receivers can appropriately exclude channel estimation labor and still perform well . in 1994 , seshadri @xcite first proposed a blind maximum - likelihood sequence estimator ( mlse ) in which the data and channel are simultaneously estimated .",
    "skoglund et al @xcite later provided a milestone evidence for the fact that the joint design system is superior in combating with serious multipath block fading .",
    "they also applied similar technique to a multiple - input - multiple - output ( mimo ) system at a subsequent work @xcite . in short , skoglund",
    "et al looked for the non - linear codes that are suitable for this channel by computer search . through simulations",
    ", they found that the non - linear code that combines channel estimation and error protection , when being carefully designed by considering multipath fading effect , outperforms a typical communication system with perfect channel estimation by at least 2 db .",
    "their results suggest the high potential of applying a single , perhaps non - linear , code to improve the transmission rate at a highly mobile environment , at which channel estimation becomes technically infeasible .",
    "similar approach was also proposed by @xcite , and the authors actually named such codes the _ training codes_. in @xcite , chugg and polydoros derived a recursive metric for joint maximum - likelihood ( ml ) decoding , and hint that the recursive metric may only be used with the sequential algorithms @xcite . as there are no efficient decoding approaches for the codes mentioned above ,",
    "these authors mostly considered only codes of short length , or even just the principle of code design for combined channel estimation and error protection .",
    "one of the drawbacks of these combined - channel - estimation - and - error - protection codes is that only exhaustive search can be used to decode their codewords due to lack of systematic structure .",
    "such drawback apparently inhibits the use of the codes for combined channel estimation and error protection in practical applications .",
    "this leads to a natural research query on how to construct an efficiently decodable code with channel estimation and error protection functions .    in this work ,",
    "the research query was resolved by first finding that the codeword that maximizes the system signal - to - noise ratio ( snr ) should be orthogonal to its delayed counterpart .",
    "we then found that the code consists of the properly chosen self - orthogonal codewords can compete with the computer - searched codes in performance . with this self - orthogonality property",
    ", the maximum - likelihood metrics for these structural codewords can be equivalently fit into a recursive formula , and hence , the priority - first search decoding algorithm can be employed . as a consequence , the decoding complexity , as compared to the exhaustive decoding , reduces considerably .",
    "extensions of our proposed coding structure that was originally designed for channels with constant coefficients to channels with varying channel coefficients within a codeword block are also established .",
    "simulations conclude that our constructed extension code is robust even for a channel whose coefficients vary more often than a coding block .",
    "the paper is organized as follows .",
    "section [ sectionii ] describes the system model considered , followed by the technical backgrounds required in this work . in section [ codeconstruction ] , the coding rule that optimizes the system snr is established , and is subsequently used to construct the codes for combined channel estimation and error protection .",
    "the corresponding recursive maximum - likelihood decoding metrics for our rule - based systematic codes are derived in section [ secml ] .",
    "simulations are summarized and remarked in section [ simulationresults ] .",
    "extension to channels with varying coefficients within a codeword is presented in section [ fastfading ] .",
    "section [ conclusions ] concludes the paper .    in this work ,",
    "superscripts `` @xmath0 '' and `` @xmath1 '' specifically reserve for the representations of matrix hermitian transpose and transpose operations , respectively @xcite , and should not be confused with the matrix exponent .",
    "the system model defined in this section and the notations used throughout follow those in @xcite .",
    "transmit a codeword @xmath2^t$ ] , where each @xmath3 , of a @xmath4 code @xmath5 over a block fading ( specifically , quasi - static fading ) channel of memory order @xmath6 .",
    "denote the channel coefficients by @xmath7^t$ ] that are assumed _ constant _ within a coding block .",
    "the complex - valued received vector is then given by : @xmath8 where @xmath9 is zero - mean complex - gaussian distributed with @xmath10=\\sigma_n^2{\\mathbb{i}}_l$ ] , @xmath11 is the @xmath12 identity matrix , and @xmath13    some assumptions are made in the following .",
    "both the transmitter and the receiver know nothing about the channel coefficients @xmath14 , but have the knowledge of multipath parameter @xmath15 or its upper bound .",
    "besides , there are adequate guard period between two encoding blocks so that zero interblock interference is guaranteed . based on the system model in and the above assumptions , we can derive @xcite the least square ( ls ) estimate of channel coefficients @xmath14 for a given @xmath16 ( interchangeably , @xmath17 ) as : @xmath18 and the joint maximum - likelihood ( ml ) decision on the transmitted codeword becomes : @xmath19 where @xmath20 .",
    "notably , codeword @xmath16 and transformed codeword @xmath21 is not one - to - one corresponding unless the first element of @xmath16 , namely @xmath22 , is fixed . for convenience",
    ", we will always set @xmath23 for the codebooks we construct in the sequel .      in literatures ,",
    "no systematic code constructions have been proposed for combined channel estimation and error protection for quasi - static fading channels .",
    "efforts were mostly placed on how to find the proper sequences to compensate the channel fading by computer searches @xcite@xcite@xcite@xcite@xcite@xcite@xcite .",
    "decodability for the perhaps structureless computer - searched codes thus becomes an engineering challenge .    in 2003 ,",
    "skoglund , giese and parkvall @xcite searched by computers for nonlinear binary block codes suitable for combined estimation and error protection for quasi - static fading channels by minimizing the sum of the pairwise error probabilities ( pep ) under equal prior , namely , @xmath24 where @xmath25 denotes the @xmath26th codeword of the @xmath4 nonlinear block code .",
    "although the operating signal - to - noise ratio ( snr ) for the code search was set at @xmath27 db , their simulation results showed that the found codes perform well in a wide range of different snrs .",
    "in addition , the mismatch in the relative powers of different channel coefficients , as well as in the channel rice factors @xcite , has little effect on the resultant performance .",
    "it was concluded that in comparison with the system with the benchmark error correcting code and the perfect channel estimator , significant performance improvement can be obtained by adopting their computer - searched nonlinear codes .",
    "later in 2005 , coskun and chugg @xcite replaced the pep in by a properly defined pairwise distance measure between two codewords , and proposed a suboptimal greedy algorithm to speed up the code search process .",
    "in 2007 , giese and skoglund @xcite re - applied their original idea to the single- and multiple - antenna systems , and used the asymptotic pep and the generic gradient - search algorithm in place of the pep and the simulated annealing algorithm in @xcite to reduce the system complexity .    at the end of @xcite ,",
    "the authors pointed out that `` an important topic for further research is to study how the decoding complexity of the proposed scheme can be decreased . ''",
    "they proceeded to state that along this research line , `` one main issue is to investigate what kind of structure should be enforced on the code to allow for simplified decoding . ''",
    "stimulating from these ending statements , we take a different approach for code design .",
    "specifically , we pursued and established a systematic code design rule for combined channel estimation and error protection for quasi - static fading channels , and confirmed that the codes constructed based on such rule maximize the average system snr .",
    "as so happened that the computer - searched code in @xcite satisfies such rule , its insensitivity to snrs , as well as channel mismatch , somehow finds the theoretical footing .",
    "enforced by the systematic structure of our rule - based constructed codes , we can then derive a recursive _ maximum - likelihood _ decoding metric for use of priority - first search decoding algorithm .",
    "the decoding complexity is therefore significantly decreased at moderate - to - high snrs as contrary to the obliged exhaustive decoder for the structureless computer - searched codes .",
    "it is worth mentioning that although the codes searched by computers in @xcite@xcite target the unknown channels , for which the channel coefficients are assumed constant in a coding block , the evaluation of the pep criterion does require to presume the knowledge of channel statistics .",
    "the code constructed based on the rule we proposed , however , is guaranteed to maximize the system snr regardless of the statistics of the channels .",
    "this hints that our code can still be well applied to the situation where channel blindness becomes a strict system restriction .",
    "details will be introduced in subsequent sections .      for a better understanding",
    ", we give a short description of a code tree for the @xmath4 code @xmath28 over which the decoding search is performed before our describing the priority - first search decoding algorithm in this subsection .",
    "a code tree of a @xmath4 binary code represents every codeword as a path on a binary tree as shown in fig .",
    "[ codetree ] .",
    "the code tree consists of @xmath29 levels .",
    "the single leftmost node at level zero is usually called the _",
    "origin node_. there are at most two branches leaving each node at each level .",
    "the @xmath30 rightmost nodes at level @xmath31 are called the _ terminal nodes_.    each branch on the code tree",
    "is labeled with the appropriate code bit @xmath32 . as a convention , the path from the single origin node to one of the @xmath33 terminal nodes",
    "is termed the _ code path _ corresponding to the codeword .",
    "since there is a one - to - one correspondence between the codeword and the code path of @xmath28 , a codeword can be interchangeably referred to by its respective code path or the branch labels that the code path traverses .",
    "similarly , for any node in the code tree , there exists a unique path traversing from the single original node to it ; hence , a node can also be interchangeably indicated by the path ( or the path labels ) ending at it .",
    "we can then denote the path ending at a node at level @xmath34 by the branch labels @xmath35 $ ] it traverses . for convenience , we abbreviates @xmath35^t$ ] as @xmath36 , and will drop the subscript when @xmath37 .",
    "the successor pathes of a path @xmath36 are those whose first @xmath34 labels are exactly the same as @xmath36 .",
    "( 250,330)(40,0 ) ( 200,320)(10,0)5(1,0)5 ( 200,260)(10,0)5(1,0)5 ( 200,220)(10,0)5(1,0)5 ( 200,200)(10,0)5(1,0)5 ( 200,160)(10,0)5(1,0)5 ( 200,140)(10,0)5(1,0)5 ( 200,120)(10,0)5(1,0)5 ( 200,100)(10,0)5(1,0)5 ( 200,80)(10,0)5(1,0)5 ( 200,60)(10,0)5(1,0)5 ( 200,40)(10,0)5(1,0)5 ( 200,20)(10,0)5(1,0)5 ( 250,320 ) ( 250,300 ) ( 250,280 ) ( 250,260 ) ( 250,240 ) ( 250,220 ) ( 250,200 ) ( 250,180 ) ( 250,20)(0,20)8 ( 200,315)(0,1)5 ( 200,260)(0,1)5 ( 200,220)(0,1)5 ( 200,195)(0,1)5 ( 200,20)(0,40)4(0,1)5 ( 200,35)(0,40)4(0,1)5 ( 150,150)(10,0)5(1,0)5 ( 150,110)(10,0)5(1,0)5 ( 150,70)(10,0)5(1,0)5 ( 150,30)(10,0)5(1,0)5 ( 200,190)(0,40)4 ( 200,30)(0,40)4 ( 150,110)(0,10)2(0,1)5 ( 150,30)(0,10)2(0,1)5 ( 150,135)(0,10)2(0,1)5 ( 150,55)(0,10)2(0,1)5 ( 100,130)(10,0)5(1,0)5 ( 100,50)(10,0)5(1,0)5 ( 150,210)(0,80)2 ( 150,50)(0,80)2 ( 100,50)(0,10)4(0,1)5 ( 100,95)(0,10)4(0,1)5 ( 50,90)(10,0)5(1,0)5 ( 100,90 ) ( 100,250 ) ( 50,165)(0,-10)8(0,-1)5 ( 50,170 )    ( 200,300)(1,0)50 ( 200,280)(1,0)50 ( 200,240)(1,0)50 ( 200,180)(1,0)50    ( 200,300)(0,1)10 ( 200,270)(0,1)10 ( 200,230)(0,1)10 ( 200,180)(0,1)10    ( 150,190)(0,40)4(1,0)50 ( 150,190)(0,80)2(0,1)40 ( 100,210)(0,80)2(1,0)50 ( 100,210)(0,1)80 ( 50,250)(1,0)50 ( 50,170)(0,1)80    the priority - first search on a code tree is guided by an evaluation function @xmath38 that is defined for every path .",
    "it can be typically algorithmized as follows",
    ".    step  .",
    "_ _    * ( initialization ) * load the stack with the path that ends at the original node",
    ".    [ step ] * ( evaluation ) * evaluate the @xmath38-function values of the successor paths of the current top path in the stack , and delete this top path from the stack .",
    "* ( sorting ) * insert the successor paths obtained in step  [ step ] into the stack such that the paths in the stack are ordered according to ascending @xmath38-function values of them .    * ( loop ) * if the top path in the stack ends at a terminal node in the code tree , output the labels corresponding to the top path , and the algorithm stops ; otherwise , go to step  [ step ] .",
    "it remains to find the evaluation function @xmath38 that secures the maximum - likelihoodness of the output codeword .",
    "we begin with the introduction of a sufficient condition under which the above priority - first search algorithm guarantees to locate the code path with the smallest @xmath38-function value among all code paths of @xmath5 .",
    "[ lemma0 ] if @xmath38 is non - decreasing along every path @xmath36 in the code tree , i.e. , @xmath39 the priority - first search algorithm always outputs the code path with the smallest @xmath38-function value among all code paths of @xmath5 .",
    "let @xmath40 be the first top path that reaches a terminal node ( and hence , is the output code path of the priority - first search algorithm . ) then , _ step 3 _ of the algorithm ensures that @xmath41 is no larger than the @xmath38-function value of any path currently in the stack .",
    "since condition guarantees that the @xmath38-function value of any other code path , which should be the offspring of some path @xmath36 existing in the stack , is no less than @xmath42 , we have @xmath43 consequently , the lemma follows .    in the design of the search - guiding function @xmath38 , it is convenient to divide it into the sum of two parts . in order to perform maximum - likelihood decoding ,",
    "the first part @xmath44 can be directly defined based on the maximum - likelihood metric of the codewords such that from , @xmath45 after @xmath44 is defined , the second part @xmath46 can be designed to validate with @xmath47 for any @xmath48 .",
    "then , from @xmath49 for all @xmath48 , the desired maximum - likelihood priority - first search decoding algorithm is established since is valid .    in principle , both @xmath50 and @xmath51 range over all possible paths in the code tree .",
    "the first part , @xmath50 , is simply a function of all the branches traversed thus far by the path , while the second part , @xmath51 , called the _",
    "heuristic function _ , helps predicting a future route from the end node of the current path to a terminal node @xcite .",
    "notably , the design of the heuristic function @xmath46 that makes valid condition is not unique .",
    "different designs may result in variations in computational complexity .",
    "we close this section by summarizing the target of this work based on what have been mentioned in this section .    1",
    ".   [ item1 ] a code of comparable performance to the computer - searched code is constructed according to certain rules so that its code tree can be efficiently and systematically generated ( section  [ codeconstruction ] ) .",
    "[ item2 ] efficient recursive computation of the maximum - likelihood evaluation function @xmath38 from the predecessor path to the successor paths is established ( section  [ secml ] ) .",
    "3 .   with the availability of items [ item1 ] and [ item2 ] , the construction and maximum - likelihood decoding of codes with longer codeword length becomes possible , and",
    "hence , makes the assumption that the unknown channel coefficients @xmath14 are fixed during a long coding block somewhat impractical especially for mobile transceivers .",
    "extension of items [ item1 ] and [ item2 ] to the unknown channels whose channel coefficients may change several times during one coding block will be further proposed ( section  [ fastfading ] ) .",
    "in this section , the code design rule that guarantees the maximization of the system snr regardless of the channel statistics is presented , followed by the algorithm to generate the code based on such rule .",
    "a known inequality @xcite for the multiplication of two positive semidefinite hermitian matrices , @xmath52 and @xmath17 , is that @xmath53 where @xmath54 represents the matrix trace operation , and @xmath55 is the maximal eigenvalue of @xmath17 @xcite .",
    "the above inequality holds with equality when @xmath17 is an identity matrix .    from the system model @xmath56",
    ", it can be derived that the average snr satisfies : @xmath57}{e[\\|{\\boldsymbol{n}}\\|^2]}\\nonumber\\\\ & = & \\frac{e[{\\mathrm{tr}}({\\boldsymbol{h}}^h{\\mathbb{b}}^t{\\mathbb{b}}{\\boldsymbol{h}})]}{l\\sigma_n^2}\\nonumber\\\\ & = & \\frac{{\\mathrm{tr}}(e[{\\boldsymbol{h}}{\\boldsymbol{h}}^h]{\\mathbb{b}}^t{\\mathbb{b}})}{l\\sigma_n^2}\\nonumber\\\\ & = & \\frac{n}{l}\\frac 1{\\sigma_n^2}{\\mathrm{tr}}\\left(e[{\\boldsymbol{h}}{\\boldsymbol{h}}^h]\\frac{1}{n}{\\mathbb{b}}^t{\\mathbb{b}}\\right)\\nonumber\\\\ & \\leq&\\frac{n}{l}\\frac 1{\\sigma_n^2}{\\mathrm{tr}}(e[{\\boldsymbol{h}}{\\boldsymbol{h}}^h])\\lambda_{\\max}\\left(\\frac{1}{n}{\\mathbb{b}}^t{\\mathbb{b}}\\right).\\nonumber\\end{aligned}\\ ] ] then , the theories on ineq .   result that taking @xmath58 will optimize the average snr regardless of the statistics of @xmath14 @xcite .",
    "existence of codeword sequences satisfying is promised only for @xmath59 with @xmath31 odd ( and trivially , @xmath60 ) . in some other cases such as @xmath61",
    ", one can only design codes to approximately satisfy as : @xmath62 and @xmath63 owing to this observation , we will relax to allow some off - diagonal entries in @xmath64 to be either @xmath65 or @xmath66 whenever a strict maintenance of is impossible .    empirical examination by simulated - annealing code - search algorithm shows that for @xmath67 and @xmath31 even , the best half - rate codes that minimize the sum of peps in under follow those in @xcite .",
    "] complex zero - mean gaussian distributed @xmath14 with @xmath68=(1/2){\\mathbb{i}}_p$ ] and @xmath59 all satisfy that @xmath69 except three codewords at @xmath70 .",
    "a possible cause for the appearance of three exception codewords at @xmath70 is that the best code that minimizes the sum of the pairwise error probabilities may not be the truly optimal code that reaches the smallest error probability , and hence , does not necessarily yield the maximum average snr as demanded by . we have also obtained and examined the computer - searched code used in @xcite for @xmath71 , and found as anticipated that every codeword carries the property of .",
    "the operational meaning of the condition @xmath72 is that the codeword is orthogonal to its shifted counterpart , and hence , a space - diversity nature is implicitly enforced .",
    "this coincides with the conclusion made in @xcite that the training sequence satisfying that @xmath64 is proportional to @xmath73 can provide optimal channel estimation performance .",
    "it should be mentioned that codeword condition has been identified in @xcite , and the authors in @xcite remarked that a code sequence with certain aperiodic autocorrelation property can possibly be exploited in future code design approaches , which is one of the main research goals of this paper .",
    "( 480,150)(0,50 ) ( 40,82)(110,0 ) ( 40,90)(110,0 ) ( 40,100)(110,0 ) ( 40,107)(110,0 ) ( 40,114)(110,0 ) ( 40,121)(110,0 ) ( 40,128)(110,0 ) ( 40,140)(110,0 ) ( 40,152)(110,0 ) ( 40,153)(110,0 ) ( 40,160)(110,0 ) ( 40,167)(110,0 ) ( 40,174)(110,0 )    ( 0,140)(1,0)50 ( 50,120)(40,40 ) ( 90,140)(1,0)33 ( 129,100)(0,1)31 ( 135,140)(1,0)45 ( 180,110)(120,60 ) ( 300,140)(1,0)50 ( 350,110)(150,60 ) ( 500,140)(1,0)50 ( 40,80)(110,98 ) ( 30,55)(280,135 ) ( 30,55)(280,25)*equivalent channel *    ( 0,145)(0,0)[b]@xmath16 ( 310,145)(40,0)[b]@xmath74 ( 520,145)(30,0)[b]@xmath75    by noting . ] that @xmath21 is idempotent and symmetric , and both @xmath76 and @xmath77 are equal to @xmath15 , where @xmath78 denotes the operation to transform an @xmath79 matrix into a @xmath80 vector , for a matrix @xmath52 is defined as : @xmath81 ] the best joint maximum - likelihood decision in can be reformulated as : @xmath82 we therefore transform the original system in to an equivalent system model that contains an _",
    "outer product demodulator _ and a _ minimum euclidean distance selector _ at the @xmath21-domain as shown in fig .",
    "[ fig : equivalent_channel ] . as the outer product demodulator can be viewed as a generalization of the _ square - law combining _ that is of popular use in non - coherent detection for both slow and fast fading @xcite , the above equivalent transformation suggests a potential application of combined channel estimate and error protection codes for the non - coherent system in which the fading is rapid enough to preclude a good estimate of the channel coefficients .",
    "further discussion on how to design codes for unknown fast - fading channels will be continued in section  [ fastfading ] .    as a consequence of",
    ", the maximum - likelihood decoding is to find the codeword @xmath83 whose euclidean distance to @xmath74 is the smallest .",
    "similar to , we can then bound the error probability by : @xmath84 the pep - based upper bound in hints that a good code design should have an adequately large pairwise euclidean distance @xmath85 among all codeword pairs @xmath86 and @xmath87 , where @xmath86 is the equivalent codeword at the @xmath21-domain , and is one - to - one corresponding to the codeword @xmath25 if @xmath22 is fixed and known . based on this observation",
    ", we may infer under equal prior that a uniform draw of codewords satisfying @xmath72 at the @xmath21-domain may asymptotically result in a good code . in light of the one - to - one correspondence relation between @xmath16 and @xmath21",
    ", we may further infer that uniform selection of codewords in the set of @xmath88 is conceptually equivalent to uniform - pick of codewords in @xmath89 .",
    "recall that in order to perform the priority - first search decoding on a code tree , an efficient and systematic way to generate the code tree ( or more specifically , an efficient and systematic way to generate the successor paths of the top path ) is necessary .",
    "the uniform pick principle then suggests that considering only the codewords with the same prefix @xmath90 $ ] , the ratio of the number of codewords satisfying @xmath91 with respect to the candidate sequence pool shall be made equal to that of codewords satisfying @xmath92 , whenever possible . this can be mathematical interpreted as : @xmath93 where @xmath94 is the set of all codewords whose first @xmath34 bits equal @xmath95 , and @xmath96 is the set of all possible @xmath97-sequences of length @xmath31 , whose first @xmath34 bits equal @xmath95 and whose @xmath17-representation satisfies @xmath98 . accordingly ,",
    "if @xmath99 can be computed explicitly , the desired efficient and systematic generation of the code tree becomes straightforward .",
    "simulations on the above uniform selective code over @xmath89 show that its performance is almost the same as the computer - searched code that minimizes the sum of peps .",
    "hence , the maximizing - the - pairwise - euclidean - distance intuition we adopt for code design performs well as we have anticipated .",
    "in the next subsection , we will provide an exemplified encoding algorithm based on the above basic rule specifically for channels of memory order @xmath65 , namely , @xmath59 .",
    "the encoding algorithm for larger memory order can be similarly built .",
    "[ encode - subsection ]    before the presentation of the exemplified encoding algorithm , the explicit formula for @xmath99 needs to be established first .",
    "may not have an explicit close - form formula for memory order higher than one .",
    "however , our encoding algorithm can still be applied as long as @xmath99 can be pre - calculated ( cf .",
    "appendix ) . ]    [ lem1 ] fix @xmath59 .",
    "then , for @xmath31 odd , and @xmath100 , @xmath101 where @xmath102 is the set indicator function , and @xmath103 .    in addition , for @xmath31 even , and @xmath104 @xmath105 here , we assume that @xmath106 specifically for the case of @xmath37 .",
    "the lemma requires @xmath107 where @xmath108 respectively for @xmath109 , @xmath110 and @xmath111 . in order to satisfy",
    ", there should be @xmath112 of @xmath113 equal to @xmath65 , and the remaining of them equal @xmath66 , provided that @xmath114 and @xmath115 .",
    "notably , @xmath116 is always an even number for the cases considered in the lemma .",
    "the proof is then completed by the observation that @xmath117 $ ] and @xmath118 $ ] are one - to - one correspondence for given @xmath119 .",
    "it is already hint in the above lemma that for @xmath31 odd , our encoding algorithm will uniformly pick @xmath33 codewords from the candidate sequences satisfying the exact snr - maximization condition @xmath72 .",
    "however , for @xmath31 even , two conditions on candidate sequences will be used .",
    "half of the codewords will be uniformly drawn from those candidate sequences satisfying @xmath120 , and the other half of the codewords agree with @xmath121 . the proposed codeword selection process is simply to list all the candidate sequences in binary - alphabetical order , starting from zero , and uniformly pick the codewords from the ordered list in every @xmath122 interval , where @xmath123 where @xmath124 represents the desired @xmath64 , and @xmath125 is the number of conditions and equals @xmath65 for @xmath31 odd , and @xmath126 for @xmath31 even . as a result ,",
    "the selected codewords are those sequences with index @xmath127 for integer @xmath26 .",
    "the encoding algorithm is summarized in the following .",
    "step  . _ _    [ step1 ] * ( input ) * let @xmath26 be the index of the requested codeword in the desired @xmath4 block code , where @xmath128 .",
    "* ( initialization ) * set @xmath129 for @xmath31 odd , and @xmath126 for @xmath31 even .",
    "let @xmath23 .",
    "put ( in terms of the notations in lemma  [ lem1 ] ) : @xmath130 compute @xmath131 also , re - adjust @xmath132 if @xmath31 is even and @xmath133 .",
    "let the minimum candidate sequence index @xmath134 and the maximum candidate sequence index @xmath135 in @xmath136 be respectively @xmath137    initialize @xmath138 and @xmath139 .    * ( generation of the next code bit)*[step3 ]    set @xmath140 , and compute @xmath141 .    if @xmath142 , then the next code bit @xmath143 , and re - adjust @xmath144 ;    else , the next code bit @xmath145 , and re - adjust @xmath146 .    *",
    "( loop ) * if @xmath37 , output codeword @xmath16 , and the algorithm stops ; otherwise , go to step [ step3 ] .",
    "in this section , a recursive maximum - likelihood metric @xmath44 and its heuristic function @xmath46 for use of the priority - first search decoding algorithm to decode the structural codewords over multiple code trees are established .",
    "let @xmath147 be the set of the codewords that satisfy @xmath148 , where @xmath149 , and assume that @xmath150 , and @xmath151 whenever @xmath152 .",
    "then , by denoting for convenience @xmath153 , we can continue the derivation of the maximum - likelihood criterion from as : @xmath154\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\sum_{\\theta=1}^\\theta \\left[-{\\mathrm{vec}}({\\mathbb{b}}{\\mathbb{d}}_\\theta{\\mathbb{b}}^t)^t{\\mathrm{vec}}({\\boldsymbol{y}}{\\boldsymbol{y}}^h)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\sum_{\\theta=1}^\\theta \\left[-{\\mathrm{tr}}\\left([({\\mathbb{b}}\\otimes{\\mathbb{b}}){\\mathrm{vec}}({\\mathbb{d}}_\\theta)]^t{\\mathrm{vec}}({\\boldsymbol{y}}{\\boldsymbol{y}}^h)\\right)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\sum_{\\theta=1}^\\theta \\left[-{\\mathrm{tr}}\\left({\\mathrm{vec}}({\\mathbb{d}}_\\theta)^t({\\mathbb{b}}^t\\otimes{\\mathbb{b}}^t){\\mathrm{vec}}({\\boldsymbol{y}}{\\boldsymbol{y}}^h)\\right)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\sum_{\\theta=1}^\\theta \\left[-{\\mathrm{tr}}\\left(({\\mathbb{b}}\\otimes{\\mathbb{b}})^t{\\mathrm{vec}}({\\boldsymbol{y}}{\\boldsymbol{y}}^h){\\mathrm{vec}}({\\mathbb{d}}_\\theta)^t\\right)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\},\\label{trbbyyhh}\\end{aligned}\\ ] ] where `` @xmath155 '' is the kronecker product , and @xmath156 is the set indicator function that has been used in lemma  [ lem1 ] . defining @xmath157 we get : @xmath158,\\end{aligned}\\ ] ] which indicates that the @xmath26th column of @xmath159 , where @xmath160 , can be written as @xmath161 here",
    ", we adopt @xmath162 by convention .",
    "resume the derivation in by denoting the matrix entry of @xmath163 by @xmath164 : @xmath165\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c } } } \\sum_{\\theta=1}^\\theta\\left[-\\sum_{i=0}^{p-1}\\sum_{j=0}^{p-1}\\delta_{i , j}^{(\\theta)}{\\mathrm{tr}}(({\\mathbb{e}}^j{\\boldsymbol{c}})({\\mathbb{e}}^i{\\boldsymbol{c}})^t{\\boldsymbol{y}}{\\boldsymbol{y}}^h)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c } } } \\sum_{\\theta=1}^\\theta\\left[-\\sum_{i=0}^{p-1}\\sum_{j=0}^{p-1}\\delta_{i , j}^{(\\theta)}{\\mathrm{tr}}\\left(({\\mathbb{e}}^i)^t{\\boldsymbol{y}}{\\boldsymbol{y}}^h{\\mathbb{e}}^j{\\boldsymbol{c}}{\\boldsymbol{c}}^t\\right)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c } } } \\sum_{\\theta=1}^\\theta\\left[-{\\mathrm{tr}}({\\mathbb{w}}_\\theta{\\boldsymbol{c}}{\\boldsymbol{c}}^t)\\right]\\bf{1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\},\\end{aligned}\\ ] ] where @xmath166 we then conclude : @xmath167 { \\bf 1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c } } } \\sum_{\\theta=1}^\\theta \\left[-{\\mathrm{vec}}(\\mathbb{w}_\\theta)^h{\\mathrm{vec}}({\\boldsymbol{c}}{\\boldsymbol{c}}^t)-{\\mathrm{vec}}({\\boldsymbol{c}}{\\boldsymbol{c}}^t)^t{\\mathrm{vec}}(\\mathbb{w}_\\theta)\\right ] { \\bf 1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\nonumber\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\frac 12 \\sum_{\\theta=1}^\\theta\\left[\\sum_{m=1}^{n}\\sum_{n=1}^{n}\\left(-w_{m , n}^{(\\theta)}b_mb_n\\right)\\right ] { \\bf 1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\},\\label{originalg}\\end{aligned}\\ ] ] where @xmath168 is the real part of the entry of @xmath169 , and is given by : @xmath170 the maximum - likelihood decision remains unchanged by adding a constant , independent of the codeword @xmath16 ; hence , a constant is added to make non - negative the decision criterion as:[multiblock footnote omitted ] @xmath171 { \\bf 1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}\\right\\}\\\\ & = & \\arg\\min_{{\\boldsymbol{b}}\\in{\\mathcal{c}}}\\sum_{\\theta=1}^\\theta\\left [ \\sum_{m=1}^{n}\\max_{1\\leq\\eta\\leq\\theta}\\left(\\sum_{n=1}^{m-1}|w^{(\\eta)}_{m , n}|+\\frac 12|w_{m , m}^{(\\eta)}|\\right)- \\frac 12\\sum_{m=1}^{n}\\sum_{n=1}^{n}w_{m , n}^{(\\theta)}b_mb_n \\right]{\\bf 1}\\{{\\boldsymbol{b}}\\in{{\\mathcal c}}_\\theta\\}.\\end{aligned}\\ ] ] it remains to prove that the metric of @xmath172 can be computed recursively for @xmath173 .",
    "define for path @xmath36 over code tree @xmath174 that @xmath175 then , by the symmetry that @xmath176 for @xmath177 and @xmath149 , we have that for @xmath178 , @xmath179 where @xmath180 and for @xmath181 , @xmath182 this implies that we can recursively compute @xmath183 and @xmath184 from the previous @xmath185 and @xmath186 with the knowledge of @xmath187 , @xmath188 , @xmath189 , @xmath190 and @xmath191 , and the initial condition satisfies that @xmath192 for @xmath181 .",
    "a final remark in this discussion is that although the computation burden of @xmath193 in increases linearly with @xmath34 , such a linearly growing load can be moderately compensated by the fact that @xmath193 is only necessary to compute it once for each @xmath34 and @xmath194 , because it can be shared for all paths ending at level @xmath34 over code tree @xmath194 .      taking the maximum - likelihood metric @xmath44 into the sufficient condition in yields that : @xmath195.\\end{aligned}\\ ] ] hence ,",
    "in addition to @xmath196 , the heuristic function should satisfy : @xmath197    apparently , a function that guarantees to satisfy is the zero - heuristic function , that is , @xmath198 for any path @xmath36 in the code trees . adopting the zero - heuristic function @xmath199 , together with the recursively computable maximum - likelihood metric @xmath44 in , makes feasible the _ on - the - fly _ priority - first search decoding . in comparison with the exhaustive - checking decoding , significant improvement in the computational complexity",
    "is resulted especially at medium - to - high snrs .    in situation when the codeword length @xmath31 is not large such as @xmath200 so that the demand of _ on - the - fly _ decoding can be moderately relaxed , we can adopt a larger heuristic function to further reduce the computational complexity . upon the reception of all @xmath201 , the heuristic function that satisfies regardless of @xmath202 , @xmath189 , @xmath203",
    "can be increased up to : @xmath204 where for @xmath205 and @xmath149 , @xmath206 and @xmath207 with initially @xmath208 , and @xmath209 .",
    "simulations show that when being compared with the zero - heuristic function @xmath199 , the heuristic function in further reduces the number of path expansions during the decoding process up to one order of magnitude ( cf",
    ".  tab .",
    "[ table3a ] , in which @xmath210 and @xmath211 . ) .",
    "a final note on the priority - first search of the maximum - likelihood codeword is that in those cases that equality in can not be fulfilled , codewords will be selected equally from multiple code trees , e.g. , one code tree structured according to @xmath120 , and the other code tree targeting @xmath121 for @xmath31 even and @xmath59 .",
    "since the transmitted codeword belongs to only one of the code trees , to maintain _ individual stack _ for the codeword search over _ each _ code tree will introduce considerable unnecessary decoding burdens especially for the code trees that the transmitted codeword does not belong to .",
    "hence , only one stack is maintained during the priority - first search , and the evaluation function values for different code trees are compared and sorted in the same stack .",
    "the path to be expanded next is therefore the one whose evaluation function value is globally the smallest .",
    "in this section , the performance of the rule - based constructed codes proposed in section [ codeconstruction ] is examined .",
    "also illustrated is the decoding complexity of the maximum - likelihood priority - first search decoding algorithm presented in the previous section .",
    "for ease of comparison , the channel parameters used in our simulations follow those in @xcite , where @xmath14 is complex zero - mean gaussian distributed with @xmath68=(1/p){\\mathbb{i}}_p$ ] and @xmath59 .",
    "the average system snr is thus given by : @xmath212\\frac{1}{n}{\\mathbb{b}}^t{\\mathbb{b}}\\right ) = \\frac n{l}\\frac 1{\\sigma_n^2}{\\mathrm{tr}}\\left(\\frac{1}{np}{\\mathbb{b}}^t{\\mathbb{b}}\\right)=\\frac n{(n+p-1)}\\frac 1{\\sigma_n^2 } , \\label{avesnr}\\ ] ] since @xmath213 for all codewords simulated.[multiblock footnote omitted ]    .,width=480 ]    ) and the rule - based half - rate code with double code trees ( double-@xmath31).,width=480 ]    there are three codes simulated in fig .",
    "[ fig : wer ] : the computer - searched half - rate code obtained in  @xcite ( sa-22 ) , the rule - based double - tree code in which half of the codewords satisfying @xmath120 and the remaining half satisfying @xmath121 ( double-22 ) , and the rule - based single - tree code whose codewords are all selected from the candidate sequences satisfying @xmath120 ( single-22 ) .",
    "we observe from fig .",
    "[ fig : wer ] that the double-22 code performs almost the same as the sa-22 code obtained in @xcite at @xmath71 . actually , extensive simulations in fig .",
    "[ fig : wer1 ] show that the performance of the rule - based double - tree half - rate codes is as good as the computer - searched half - rate codes for all @xmath214 .",
    "however , when @xmath215 , the approximation in can no longer be well maintained due to the restriction that @xmath99 must be an integer , and an apparent performance deviation between the rule - based double - tree half - rate codes and the computer - searched half - rate codes can therefore be sensed for @xmath31 below 12 .",
    "in addition to the double-22 code , the performance of the single-22 code is also simulated in fig .  [",
    "fig : wer ] .",
    "since the pairwise codeword distance in the sense of for the single-22 code is in general smaller than that of the double-22 code , its performance has @xmath216 db degradation to that of the double-22 code .",
    "however , we will see in later simulation that the single-22 code has the smallest decoding complexity among the three codes in fig .",
    "[ fig : wer ] .",
    "this suggests that to select codewords uniformly from a single code tree should not be ruled out as a candidate design , especially when the decoding complexity becomes the main system concern .    ) and double - tree ( seq - double-@xmath217 ) codes using the priority - first search decoding guided by either evaluation function @xmath218 or evaluation function @xmath219.,width=480 ]    in fig .",
    "[ fig : complexity ] , the average numbers of node expansions per information bit are illustrated for the codes examined in fig .",
    "[ fig : wer ] .",
    "since the number of nodes expanded is exactly the number of tree branch metrics ( i.e. , one recursion of @xmath38-function values ) computed , the equivalent complexity of exhaustive decoder is correspondingly plotted .",
    "it can then be observed that in comparison with the exhaustive decoder , a significant reduction in computational burdens can be obtained at moderate - to - high snrs by adopting the double-22 code and the priority - first search decoder with on - the - fly evaluation function @xmath218 , namely , @xmath44 ( cf .",
    ". further reduction can be approached if the double-22 code is replaced with the single-22 code .",
    "the is because performing the sequential search over multiple code trees introduce extra node expansions for those code trees that the transmitted codeword does not belong to .",
    "an additional order - of - magnitude reduction in node expansions can be achieved when the evaluation function @xmath211 is used instead .",
    ".,width=480 ]    the authors in @xcite and @xcite only focused on the word - error - rates ( wers ) .",
    "no bit error rate ( ber ) performances that involve the mapping design between the information bit patterns and the codewords were presented . yet , in certain applications , such as voice transmission and digital radio broadcasting , the ber is generally considered a more critical performance index .",
    "in addition , the adoption of the ber performance index , as well as the signal - to - noise ratio per information bit , facilitates the comparison among codes of differen code rates .",
    "figure [ fig : fig4 ] depicts the ber performances of the codes simulated in fig .",
    "[ fig : wer ] .",
    "the corresponding @xmath220 is computed according to : @xmath221 where @xmath222 is the code rate .",
    "the mapping between the bit patterns and the codewords of the given computer - searched code is obtained through simulated annealing by minimizing the upper bound of : @xmath223 where , other than the notations defined in , @xmath224 is the information sequence corresponding to @xmath26-th codeword , and @xmath225 is the hamming distance .",
    "for the rule - based constructed codes in section [ encode - subsection ] , the binary representation of the index of the requested codeword in step [ step1 ] is directly taken as the information bit pattern corresponding to the requested codeword . the result in fig .",
    "[ fig : fig4 ] then indicates that the ber performances of the three curves are almost the same , which directs the conclusion that taking the binary representation of the requested codeword index as the information bit pattern for the rule - based constructed code not only makes easy its implementation but also has similar ber performance to the computer - optimized codes .    ,",
    "double-@xmath217 , single-@xmath226 , double-@xmath226 , single-@xmath227 and double-@xmath227.,width=480 ]    , double-@xmath217 , single-@xmath226 , double-@xmath226 , single-@xmath227 and double-@xmath227.,width=480 ]    in the end , we demonstrate the wer and ber performances of single-@xmath226 , double-@xmath226 , single-@xmath227 , double-@xmath227 codes , together with those of single-@xmath217 and double-@xmath217 codes , over the quasi - static fading channels respectively in figs .",
    "[ fig : sim5 ] and [ fig : sim6 ] .",
    "both figures show that the double-@xmath227 code has the best maximum - likelihood performance not only in wer but also in ber .",
    "this result echoes the usual anticipation that the performance favors a longer code as long as the channel coefficients remain unchanged in a coding block .",
    "their decoding complexities are listed in tab .",
    "[ table3a ] , from which we observe that the saving of decoding complexity of metric @xmath219 with respect to metric @xmath218 increases as the codeword length further grows .",
    ".average numbers of node expansions per information bit for the priority - first search decoding of the constructed half - rate codes of length @xmath217 , @xmath226 and @xmath227 . [ cols=\"^,>,>,>,>,>,>,>,>,>,>,>\",options=\"header \" , ]      + @xmath228 + @xmath228 +",
    "the authors would like to thank prof .",
    "m.  skoglund , dr .  j.  giese and prof .",
    "s.  parkvall of the royal institute of technology ( kth ) , stockholm , sweden , for kindly providing us their computer - searched codes for further study in this paper .",
    "j.  giese and m.  skoglund , `` single- and multiple - antenna constellations for communication over unknown frequency - selective fading channels , '' _ ieee trans .",
    "theory _ , vol .",
    "53 , no .  4 , pp .",
    "1584 - 1594 , april 2007 .",
    "y.  s.  han and c. r. p. hartmann and c .- c .",
    "chen , `` efficient priority - first search maximum - likelihood soft - decision decoding of linear block codes , '' _ ieee trans .",
    "theory _ , vol .",
    "39 , no .  5 , pp .",
    "15141523 , september 1993 .",
    "y.  s.  han , p .-",
    ".  chen and h.  -b .",
    "wu , `` a maximum - likelihood soft - decision sequential decoding algorithm for binary convolutional codes , '' _ ieee trans .",
    "communications _ , vol .",
    "50 , no .  2 , pp .  173 - 178 , february 2002 .",
    "c.  heegard , s.  coffey , s.  gummadi and e.  j.  rossin , m.  b.  shoemake and m.  wilhoyte , `` combined equalization and decoding for ieee 802.11b devices , '' _ ieee j.  select .",
    "areas commun .",
    "_ , vol .  21 , no .  2 , pp .  125 - 138 , february 2003 .      j.  c.  l.  ng , k.  b.  letaief and r.  d.  murch , `` complex optimal sequences with constant magnitude for fast channel estimation initialization , '' _ ieee trans .  commun .",
    "_ , vol .",
    "46 , no .  3 , pp .  305 - 308 , march 1998 .    s.  i.  park , s.  r.  park , i.  song and n.  suehiro , `` multiple - access interference reduction for qs - cdma systems with a novel class of polyphase sequence , '' _ ieee trans .  inform .",
    "theory _ , vol .  46 , no .  4 , pp .",
    "1448 - 1458 , july 2000 .",
    "yang and j.  wu , `` optimal binary training sequence design for multiple - antenna systems over dispersive fading channels , '' _ ieee trans .",
    "vehicular  technology _ , vol .",
    "51 , no .  5 , pp .",
    "1271 - 1276 , september  2002 ."
  ],
  "abstract_text": [
    "<S> the code that combines channel estimation and error protection has received general attention recently , and has been considered a promising methodology to compensate multi - path fading effect . </S>",
    "<S> it has been shown by simulations that such code design can considerably improve the system performance over the conventional design with separate channel estimation and error protection modules under the same code rate . </S>",
    "<S> nevertheless , the major obstacle that prevents from the practice of the codes is that the existing codes are mostly searched by computers , and hence exhibit no good structure for efficient decoding . </S>",
    "<S> hence , the time - consuming exhaustive search becomes the only decoding choice , and the decoding complexity increases dramatically with the codeword length . in this paper , by optimizing the signal - to - noise ratio , we found a systematic construction for the codes for combined channel estimation and error protection , and confirmed its equivalence in performance to the computer - searched codes by simulations . </S>",
    "<S> moreover , the structural codes that we construct by rules can now be maximum - likelihoodly decodable in terms of a newly derived recursive metric for use of the priority - first search decoding algorithm . </S>",
    "<S> thus , the decoding complexity reduces significantly when compared with that of the exhaustive decoder . </S>",
    "<S> the extension code design for fast - fading channels is also presented . </S>",
    "<S> simulations conclude that our constructed extension code is robust in performance even if the coherent period is shorter than the codeword length .    </S>",
    "<S> code design , priority - first search decoding , training codes , time - varying multipath fading channel , channel estimation , channel equalization , error - control coding </S>"
  ]
}