{
  "article_text": [
    "in this note we complete the work begun in the sequence of papers @xcite , @xcite-@xcite about equilateral triangles , regular tetrahedra , cubes , and regular octahedrons all with vertices having integer coordinates . very often we will refer to this property by saying that the various objects are in @xmath1 . strictly speaking these geometric objects",
    "are defined as being more than the set of their vertices that determines them , but for us here , these are just the vertices .",
    "so , for instance , an equilateral triangle is going to be a set of three points in @xmath2 for which the euclidean distances between every two of these points are the same .",
    "the main purpose of the paper is to take a close look at the regular octahedrons in @xmath2 .",
    "the simplest example of a regular octahedron with integer coordinates for its vertices is @xmath3 , [ 1 , 0 , 1 ] , [ 1 , 1 , 0 ] , [ 1 , 1 , 2 ] , [ 1 , 2 , 1 ] , [ 2 , 1 , 1]\\},\\ ] ] which can be obtained from the usual unit cube in @xmath4 , multiplying the vertices by a factor of two and then taking the coordinates of the centers of the new faces .",
    "it turns out that this procedure gives all such octahedrons as shown in @xcite :    [ fig1 ] @xmath5 @xmath6    [ oldtheorem ] every regular octahedron in @xmath2 is the dual of a cube that can be obtained ( up to a translation with a vector with integer coordinates ) by doubling a cube in @xmath1 .",
    "referring to figure  [ fig1 ] ( b ) , we showed that if the regular octahedron @xmath7 is in @xmath2 , then so is the cube @xmath8 and vice versa .",
    "this defines a one - to - one correspondence between the classes of cubes ( invariant under integer translations ) and the classes regular octahedra ( invariant under integer translations ) in @xmath2 . in @xcite",
    "we determined a sequence of irreducible cubes , one from each of the classes of cubes invariant under integer translations and cube symmetries .",
    "for each one of these cubes we can construct as before a regular octahedron , obtaining this way a sequence of irreducible regular octahedrons .",
    "in @xcite , we improved and adapted the earlier code for counting all cubes with vertices in @xmath9 and extended the sequence a098928 . in this paper ,",
    "the usual techniques and ideas are going to be the same except some counting procedure that is very efficient in comparison to what we had before .",
    "we are going to treat this in the general case so , let us suppose that these objects can be either equilateral triangles , regular tetrahedrons , cubes or regular octahedrons with vertices in @xmath2 .",
    "for such an object , say @xmath10 , we can translate it , within @xmath2 , to @xmath11 that is in the positive octant and in such way each plane of coordinates contains at least one vertex of @xmath11 .",
    "let us denote by @xmath12 the number of objects in @xmath13 obtained by applying to @xmath11 all 48 possible symmetries of the cube @xmath13 .",
    "these symmetries are generated in the following way : first we have symmetries with respect to the middle planes and compositions , for example    @xmath14    in a total of eight including the identity , then each one of these is coupled with one of the six permutations of the variables ( @xmath15 ) .",
    "these transformations form a group isomorphic with the group of all @xmath16 orthogonal matrices having entries @xmath17 and it is also known as the group of symmetries of a cube or of a regular octahedron .",
    "it is isomorphic to @xmath18 .",
    "we are going to denote this group by @xmath19 although it is usually known under the name of ( extended ) octahedral group and denoted simply by @xmath20 .",
    "if we think of @xmath12 as the cardinality of    @xmath21    which is , by the first theorem of isomorphism of groups , the same as the cardinality of the group factor @xmath22 , where @xmath23 is the subgroup of @xmath19 of those symmetries that leave @xmath11 invariant . the structure of subgroups of @xmath19 is known and for each divisor of 48 there is a subgroup of that order .",
    "hence , we expect @xmath12 to be in the set @xmath24 and most of the time to be @xmath25 since an arbitrary object @xmath11 in @xmath13 is unlikely to be invariant under any of the symmetries of @xmath26",
    ".    then , we denote by @xmath27 , the cardinality of the set of all the objects counted in @xmath12 and their ( all possible ) integer translations that leave the resulting objects in @xmath13 .",
    "also , we denote by @xmath28 the objects counted in @xmath27 which are in @xmath29 . finally , let us denote by @xmath30 the number of objects counted in @xmath28 which are in @xmath31 .",
    "then , we found a formula that gives the number of objects obtained from @xmath10 , under all symmetries and translation that leaves the resulting object in @xmath32 , @xmath33 .",
    "this fact has been essentially proved in theorem 2.2 in @xcite .",
    "the formula that gives this number is    @xmath34    let us suppose that the object @xmath10 can be squeezed within a box of dimensions @xmath35 ( @xmath36 ) , i.e. up to symmetries and translations , @xmath10 can be transformed to @xmath37 fitting snugly into @xmath38    we can similarly consider all eight reflections compatible with the box @xmath39 of the form    @xmath40    let us denote the group of these transformations by @xmath41 .",
    "we notice that each one of these transformation leaves the object @xmath11 inside the box @xmath39 . from case to case",
    ", depending of what the values @xmath42 , @xmath43 and @xmath44 are , we may have the result of some or all of the permutation transformations applied to @xmath37 still in @xmath39 .",
    "hence , we will denote by @xmath45 the cardinality of the set    @xmath46 ( { \\cal o ' } ) \\in b_{m , n , p}|s_1\\in { \\cal s}_b , s_2\\in { \\cal s}_6\\}.\\ ] ]    let us look at an example",
    ". suppose @xmath10 ( equal with @xmath11 ) is the equilateral triangle given by its vertices : @xmath47 , [ 5 , 7 , 0 ] , [ 7 , 0 , 1]\\}.\\ ] ]    we observe that @xmath48",
    ". then one can check that @xmath49 is the collection of eight triangles    @xmath50 , [ 2 , 7 , 0 ] , [ 7 , 2 , 2]\\ } , \\{[0 , 0 , 1 ] , [ 2 , 7 , 2 ] , [ 7 , 2 , 0]\\ } , \\{[0 , 2 , 0 ] , [ 5 , 7 , 2 ] , [ 7 , 0 , 1]\\},\\\\ \\\\   \\{[0 , 5 , 0 ] , [ 5 , 0 , 2 ] , [ 7 , 7 , 1]\\ } , \\{[0 , 5 , 2 ] , [ 5 , 0 , 0 ] , [ 7 , 7 , 1]\\ } , \\{[0 , 7 , 1 ] , [ 2 , 0 , 0 ] , [ 7 , 5 , 2]\\ } , \\{[0 , 7 , 1 ] , [ 2 , 0 , 2 ] , [ 7 , 5 , 0]\\ } , \\end{array}}\\ ] ]    so @xmath51 .",
    "it turns out that @xmath52 , @xmath53 , @xmath54 and @xmath55",
    ". formula ( [ oldformula ] ) becomes    @xmath56    it turns out the this factorization is not accidental and the following alternative to ( [ oldformula ] ) is true .",
    "[ coj ] given @xmath10 , one of the objects mentioned before , and @xmath39 the smallest box containing a translation of @xmath10 ( @xmath36 ) , we let @xmath57 , @xmath58 , and @xmath59 then the number of distinct objects in the cube @xmath60 ( @xmath61 ) , obtained from @xmath10 by all possible integer translations and symmetries is equal to @xmath62    .",
    "the case @xmath63 implies @xmath64 and @xmath65 because there is no room to shift the orbit @xmath66 inside of @xmath67 .",
    "the formula follows from ( [ oldformula ] ) .",
    "let us look into the case @xmath68 and @xmath69 .",
    "we begin by observing that each integer translation of the box @xmath39 in all possible ways inside @xmath60 will give @xmath70 more copies of @xmath10 .",
    "there is no overlap between these copies because neither one of them can be inside of two distinct translations of @xmath39 .",
    "this is due to the minimality of @xmath42 , @xmath43 and @xmath44 .",
    "we get @xmath71 such copies by counting all possible translations . since @xmath42 , @xmath43 and @xmath44",
    "are all distinct , the box @xmath39 can be positioned first with the biggest of its dimensions along one of the directions given by the axis of coordinates , that is three different ways , and for each such position the next largest dimension can be positioned along the two remaining directions .",
    "the minimality of @xmath42 , @xmath43 and @xmath44 makes the six different situations generate distinct objects .",
    "this explains the factor of six that appears in ( [ newformula ] ) for this situation .    in the last case ,",
    "the box @xmath39 has two of its dimensions the same , so there are only three possibilities to arrange the box before one translates it . to see that we get all possible translates and symmetries of @xmath10 by this counting",
    ", we can start with one copy @xmath11 .",
    "construct the minimum box around it . in terms of its position and dimensions , we know in what of the six or three cases we are .",
    "we transform it into the standard standard position , @xmath39 , and look at the corresponding object , @xmath72 .",
    "the transformations involved form a group of transformations generated by the permutations of the coordinates , the reflections into the axes and integer translations .",
    "every transformation in this group , say @xmath73 with @xmath74 a permutation , @xmath75 a reflection or a composition of reflections and @xmath76 a translation , which satisfies @xmath77 determines a representation @xmath78 with @xmath79 , @xmath80 as in the definition of @xmath70 .",
    "this can be done by taking @xmath81 and @xmath82 .",
    "this is true again because of the minimality of the box @xmath39 , i.e. there is only one integer translation that takes a reflected box @xmath83 into @xmath39 .",
    "this new way of counting is more efficient from a computational point of view because @xmath84 is simply no bigger than 48 , as opposed to the previous situation when @xmath27 , @xmath28 and @xmath30 could turn out to be big numbers and so the number of iterations for computing them would be also large . roughly speaking , this counting factors out fast the problem with the integer translations . as an example , let us consider @xmath85 , [ 0 , 3 , 4 ] , [ 1 , 4 , 0 ] , [ 3 , 0 , 4 ] , [ 4 , 1 , 0 ] , [ 4 , 4 , 3]\\}.\\ ] ]    the minimal box here is @xmath86 and after rotating @xmath87 in all possible ways ( figure  [ fig2 ] ( b ) ) we get @xmath88 .",
    "[ fig2 ] @xmath89",
    "@xmath90    the idea of calculations is basically the same as in @xcite , in which we have constructed a list of irreducible cubes that are used to generate all the other cubes in @xmath60 . here",
    ", we are using theorem  [ oldtheorem ] , to construct a similar list of irreducible regular hexahedrons .",
    "as expected , an _ irreducible _ regular hexahedron is one whose coordinates can not be obtained from a strictly smaller one with vertices in @xmath2 by integer dilations and translations .",
    "one simple consequence of theorem  [ oldtheorem ] is the next corollary .",
    "[ sideofoctahedrons ] the sides of every irreducible regular octahedron in @xmath2 are of the form @xmath91with @xmath92 .",
    "we used the same way of finding the parameterizations of the equilateral triangles as in @xcite :    [ fig3 ] @xmath93  @xmath94    @xmath95    @xmath96    where @xmath97 and @xmath98 is a suitable solution of @xmath99 that makes all the numbers in ( [ paramtwo ] ) integers .",
    "the sides - lengths of @xmath100 are equal to @xmath101 and the triangle can be completed to a regular tetrahedron ( in space ) with integer coordinates if and only if @xmath102 for some @xmath103 .",
    "related to this fact we have the following proposition .",
    "[ numberofro ] for a prime @xmath104 , the number of irreducible regular octahedrons in @xmath2 ( up to translations and symmetries ) having side lengths equal to @xmath105 , is at most @xmath106 , where @xmath107 with @xmath108 and @xmath109 defined as in @xcite .",
    "the exact number of such objects is yet a big mystery to us .",
    "we wrote the code using the maple software and so we took advantage of the build in commands available for a various number of functions .",
    "the beginning is pretty standard :      * step 1 . *",
    "the next three procedures calculate all possible values of @xmath110 , then the parameters @xmath42 , @xmath43 , and finally the normal vector @xmath111 .",
    "the values of @xmath110 are determined by using a characterization theorem for the quadratic form involved here , i.e. all values of @xmath110 less than @xmath43 such that @xmath110 is of the form a product of primes of the form @xmath112 , @xmath113 or @xmath114 .    ....",
    "> kvalues:=proc(n )   local i , j , k , l , a , p , q , r , m , mm ;   l:={};mm:=floor((n+1)/2 ) ;   for i from 2 to mm do   a:=ifactors(2*i-1 ) ;   k:=nops(a[2]);r:=0 ;       for j from 1 to k do         m:=a[2][j][1 ] ; p:=m mod 3 ;         if m=3 then r:=1 fi ;         if r=0 and p=2   then r:=1 fi ;       od ;   if r=0 then l:=l union { 2*i-1};fi ;   od ; l:=l union { 1 } ; l:=convert(l , list ) ;   end : ....      next , we are interested in the solutions @xmath116 of the equation @xmath102 , which are primitive in the sense that @xmath117 , @xmath118 , @xmath119 , and @xmath120 .",
    "we apply this procedure to only those @xmath110 s which are the output of @xmath121 .    ....",
    "> listofmn:=proc(k ) local a , b , i , nx , x , m , n , l ; x:=[isolve(k^2=m^2-m*n+n^2 ) ] ;   nx:=nops(x ) ; l:= { } ;    for i from 1 to nx do      if lhs(x[i][1])=m then a:=rhs(x[i][1 ] ) ; b:=rhs(x[i][2 ] ) ;       else   b:=rhs(x[i][1 ] ) ; a:=rhs(x[i][2 ] ) ; fi ;      if   gcd(a , b)=1 and a>=0 and b>0 and 2*a < b then l:=l union { [ a , b]};fi ;    od;l ; end : ....    a prime of the form @xmath112 has a unique primitive decomposition as described , for example , @xmath122\\}$ ] since @xmath123 and @xmath124 is a prime .",
    "in general , the number of solutions is equal to @xmath125 where @xmath126 is the number of distinct factors of @xmath110 which are of the form @xmath112 .",
    "this choice of @xmath42 and @xmath43 helps identify the irreducible octahedrons : all the other solutions @xmath116 of the equation @xmath102 lead to the same regular octahedron .",
    "we included the case @xmath127 to obtain the output @xmath128\\}$ ] for @xmath129 which is necessary later on .    in the next procedure ,",
    "we find only the solutions @xmath111 of @xmath130 that satisfy @xmath131 and @xmath132 .",
    "the number of such solutions can be calculated precisely in terms of the prime factorization of @xmath133 ( see @xcite ) .    ....",
    "abcsol:=proc(d ) local i , j , k , m , u , x , y , sol , cd;sol:= { } ; for i from 1 to d do      u:=[isolve(3*d^2-i^2=x^2+y^2)];k:=nops(u ) ;      for j from 1 to k do         if rhs(u[j][1])>=i and rhs(u[j][2])>=i then           cd:=gcd(gcd(i , rhs(u[j][1])),rhs(u[j][2 ] ) ) ;         if cd=1 then sol:=sol union { sort([i , rhs(u[j][1]),rhs(u[j][2])])};fi;fi ; od ; od;convert(sol , list ) ; end : ....    for @xmath134 , for instance , the procedure _ abcsol _ gives the four solutions : [ 1 , 5 , 29 ] , [ 7 , 17 , 23 ] , [ 11 , 11 , 25 ] and [ 13 , 13 , 23 ] .",
    "we observe that two of them have the property that @xmath135 , in which case , we know ( see @xcite ) that the formulae ( [ paramtwo ] ) simplify quite a bit .",
    "* step 2 . *",
    "the next seven procedures implement the new way of finding @xmath136 and @xmath137 which appear in the parametrization ( [ paramtwo ] ) .",
    "it is followed by the calculation of the of the parametrization of equilateral triangles ( [ paramtwo ] ) and only one regular octahedron is constructed based on theorem  [ oldtheorem ] .",
    "this octahedron is then translated minimally into the positive octant and the minimal cube containing it is computed .      ....",
    "> uniquedecomposition:=proc(p ) local out , s , out1,out2 ; if p=2 then out:=[1,1 ] ; fi ;    if p>2 then s:=isolve(p = x^2 + 3*y^2 ) ;     out1:=abs(rhs(s[1][1]));out2:=abs(rhs(s[1][2 ] ) ) ;      if out1 ^ 2 + 3*out2 ^ 2=p then out:=[out1,out2 ] ; else out:=[out2,out1];fi ;    fi ; out ; end : ....    for @xmath140 this procedure has the needed output @xmath141",
    "$ ] . as an example , @xmath142 $ ] since @xmath143 is a prime and @xmath144 .",
    "the next procedure is calculating the factorization in @xmath145 $ ] of a number of the form @xmath146 .    ....",
    "> factorovereisensteinintegers:=proc(u , v )   local i , n , m , k , a , x , f1,f2,g , y , y1,y2,l , nn , mm , uu , vv ;   a:=sqrt(3)*i;nn:=gcd(u , v);uu:=u / nn;vv:=v / nn ;   n:=uu^2 + 3*vv^2;x:=uu+vv*a;m:=ifactors(n);k:=nops(m[2 ] ) ;   for i from 1 to k do      f1:=m[2][i][1 ] ; f2:=m[2][i][2 ] ;        if f1>2 then           g:=uniquedecomposition(f1 ) ;           else   g:=[1,1 ] ; f2:=1 ;        fi ;      y:=expand(rationalize(x/(g[1]+a*g[2 ] ) ) ) ;      y1:=re(y);y2:=type(y1,integer ) ;        if y2=true then l[i]:=[g[1]+a*g[2],f2 ] ; else          l[i]:=[g[1]-a*g[2],f2 ] ;        fi ; od;[nn , seq(l[i],i=1 .. k),expand(nn*product(l[ii][1]^l[ii][2],ii=1 .. k))];end : ....",
    "@xmath149 perhaps one word of caution is necessary at this point .",
    "the decomposition in general is not unique in the usual sense since @xmath150 . as in the example",
    "shown , we go for the second representation when something like this happens .",
    "we are interested in this decomposition because it provides suitable values for @xmath136 and @xmath137 that we find next .",
    "this turns out to be the greatest common divisor between @xmath151 and @xmath152 with @xmath153 , @xmath154 and @xmath97 ( see @xcite ) .    ....",
    "> findgcd:=proc(a , b , q ) local a , i , j , f , f1,f2,common , m , qq , fac , nfac , s , rs , p ; a:=sqrt(3)*i ; f:=factorovereisensteinintegers(a , b);m:=nops(f)-1 ; common:=gcd(f[1],2*q ) ; qq:=2*q / common^2 ; p:=common ; fac:=ifactors(qq);nfac:=nops(fac[2 ] ) ;     for i from 1 to nfac do       f1:=fac[2][i][1];f2:=fac[2][i][2 ] ;          if f1=2 then f2:=1;fi ;           s:=uniquedecomposition(f1 ) ;          for j from 1 to m do            if s[1]+a*s[2]=f[j][1 ] then               p:=p*(s[1]+a*s[2])^(min(f[j][2],f2 ) ) ; fi ;             if s[1]-a*s[2]=f[j][1 ] then               p:=p*(s[1]-a*s[2])^(min(f[j][2],f2 ) ) ; fi ;          od ;     od;p:=expand(p);rs:=[re(p),im(p)/sqrt(3 ) ] ; [ rs , a*rs[1]+3*b*rs[2 ] mod 2*q , a*rs[2]-b*rs[1 ] mod 2*q ] ; end : ....    in the case we have seen before , where @xmath134 , if we take @xmath155 , @xmath156 and @xmath157 , then we have @xmath158 , @xmath159 and @xmath160 .",
    "the procedure above gives @xmath161 and @xmath162 and checks that @xmath163 ( mod @xmath152 ) and @xmath164 ( mod @xmath152 ) .",
    "these two conditions are enough to insure that the expressions in ( [ paramtwo ] ) , all give integer values for the coordinates of @xmath165 and @xmath166 . in the next procedure",
    "we use the @xmath136 and @xmath137 determined earlier and construct an irreducible regular octahedron in @xmath2 , given a vector @xmath111 and the possible values for @xmath116 in the decomposition of @xmath102 .",
    "we are using simple formulae which can be derived easily from figure 1(b ) , thinking that the point @xmath167 is the origin , @xmath168 $ ] , @xmath169 $ ] and @xmath170 $ ] are the points @xmath171 , @xmath172 and @xmath173 . then the other three vertices are simply given by the addition of every two of these there vectors .",
    "although there are six possible equilateral triangles that one may start with in this construction , one can see that in the end , essentially the same regular octahedron ( up to symmetries and translations ) is obtained .    ....",
    "> findpar:=proc(a , b , c , mm , nn ) local q , d , r , s , rs , a , b , k , mx , nx , my , ny , mz , nz , mu , nu , mv , nv , mw , nw , u , v , w , x , y , z , t , r1,r2,dd , e , f ;    q:=a^2+b^2;k:=sqrt(mm^2-mm*nn+nn^2);d:=sqrt((a^2+b^2+c^2)/3);a:=a*c;b:=b*d ;      rs:=findgcd(a ,- b , q);r:=rs[1][2 ] ; s:=rs[1][1 ] ;      mx:=-(d*b*(3*r+s)+a*c*(r - s))/(2*q);nx:=-(r*a*c+d*b*s)/q ;      my:=(d*a*(3*r+s)-b*c*(r - s))/(2*q);ny:=-(r*b*c - d*a*s)/q;mz:=(r - s)/2;nz:=r ;      mu:=nx;mv:=ny;mw:=nz;nu:=nx - mx;nv:=ny - my ; nw:=nz - mz ;      u:=mu*mm - nu*nn;v:=mv*mm - nv*nn;w:=mw*mm - nw*nn ;      x:=mx*mm - nx*nn;y:=my*mm - ny*nn;z:=mz*mm - nz*nn ;      r1:=[(x+u-2*a*k)/3,(v+y-2*b*k)/3,(z+w-2*c*k)/3 ] ;      r2:=[(x+u+2*a*k)/3,(v+y+2*b*k)/3,(z+w+2*c*k)/3 ] ;   if r1[1]=floor(r1[1 ] ) then t:=[[u , v , w],[x , y , z],r1 ] ; else                           t:=[[u , v , w],[x , y , z],r2 ] ;   fi ;    dd:=[t[1][1]+t[2][1],t[1][2]+t[2][2],t[1][3]+t[2][3 ] ] ;    e:=[t[1][1]+t[3][1],t[1][2]+t[3][2],t[1][3]+t[3][3 ] ] ;    f:=[t[2][1]+t[3][1],t[2][2]+t[3][2],t[2][3]+t[3][3 ] ] ;   [ t[1],t[2],t[3],dd , e , f ] ; end : ....    since for @xmath174 we get @xmath175\\}$ ] , we checked to see what regular octahedron is obtained for @xmath176 : [ 2301 , -1421 , -880 ] , [ 880 , -2301 , 1421 ] , [ 2401 , 100 , 1521 ] , [ 3181 , -3722 , 541 ] , [ 4702 , -1321 , 641 ] , and [ 3281 , -2201 , 2942 ] . since the set @xmath177 has 336 elements in it , there are essentially at most 337 irreducible regular octahedra in @xmath2 with side lengths equal to @xmath178 as we pointed out in proposition  [ numberofro ] .",
    "next , we have a short function for subtracting two vectors @xmath179 and @xmath180 .      in order to compare various octahedrons",
    "it is easier if they are all translated to the positive octant in such a way each plane of coordinates contains at least a vertex of the octahedron .",
    "this is accomplished with the next routine .    ....",
    "> tmttopqoctahedron:=proc(t ) local i , a , b , c , v , c ;   a:=min(t[1][1],t[2][1],t[3][1],t[4][1],t[5][1],t[6][1 ] ) ;   b:=min(t[1][2],t[2][2],t[3][2],t[4][2],t[5][2],t[6][2 ] ) ;   c:=min(t[1][3],t[2][3],t[3][3],t[4][3],t[5][3],t[6][3 ] ) ;     v:=[a , b , c];c:={subtrv(t[1],v),subtrv(t[2],v),subtrv(t[3],v ) ,        subtrv(t[4],v),subtrv(t[5],v),subtrv(t[6],v ) } ; end : ....",
    "so , for instance , the octahedron mentioned earlier of sides lengths @xmath178 becomes : [ 2401 , 1521 , 3822 ] , [ 3822 , 2401 , 1521 ] , [ 2301 , 0 , 1421 ] , [ 1521 , 3822 , 2401 ] , [ 0 , 1421 , 2301 ] , and",
    "[ 1421 , 2301 , 0 ] .",
    "the smallest cube @xmath181 ^ 3 $ ] containing an octahedron positioned in the positive octant as specified earlier is computed in the following procedure .    ....",
    "> mscofmoctahedron:=proc(q )   local a , b , c , t ;    t:=convert(q , list ) ;     a:=max(t[1][1],t[2][1],t[3][1],t[4][1],t[5][1],t[6][1 ] ) ;     b:=max(t[1][2],t[2][2],t[3][2],t[4][2],t[5][2],t[6][2 ] ) ;     c:=max(t[1][3],t[2][3],t[3][3],t[4][3],t[5][3],t[6][3 ] ) ;   max(a , b , c ) ;   end : ....    * step 3 . * in our construction of these octahedrons",
    "we end up with essentially the same octahedron if we proceed from a different face of it . to eliminate the possibility of counting an octahedron twice or more than one time",
    ", we would like to have a way of distinguishing between octahedra and so an invariant to translation and symmetries , like the side lengths , will be good .",
    "such an invariant is the set of @xmath110 values which are given by the four pairs of opposite ( parallel ) faces of a regular octahedron .",
    "we must have @xmath182 so , knowing @xmath183 and the @xmath184 s will give us @xmath185 s .",
    "the set @xmath186 is clearly and invariant to translations and the symmetries we have talked about at the beginning of the paper .",
    "hence , two octahedra with different sets of k - values will be essentially different .",
    "we determine these k - values from the first three points given in the procedure @xmath187 .",
    "the following calculation finds @xmath188 , given @xmath111 such that @xmath130 .                    ....",
    "> fourkvalues:=proc(t )   local n1,n2,n3,n4,x , length ;   length:=distance(t[1],t[2])/sqrt(2 ) ;     n1:=unitvector(addvec(t[1],t[2],t[3 ] ) ) ;     n2:=unitvector(addvec(t[1],t[2],multbyfactorv(t[3],-3 ) ) ) ;     n3:=unitvector(addvec(t[1],t[3],multbyfactorv(t[2],-3 ) ) ) ;     n4:=unitvector(addvec(t[3],t[2],multbyfactorv(t[1],-3 ) ) ) ;   { length / n1,length / n2,length / n3,length / n4 } ;   end : ....        .... >",
    "orbitbox1:=proc(t )   local i , k , t1,a , b , c , x , t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,t17,t18 ,   t19,t20,t21,t22,t23,t24,s , q ;   q:=convert(t , list ) ;     a:=max(q[1][1],q[2][1],q[3][1],q[4][1],q[5][1],q[6][1 ] ) ;     b:=max(q[1][2],q[2][2],q[3][2],q[4][2],q[5][2],q[6][2 ] ) ;     c:=max(q[1][3],q[2][3],q[3][3],q[4][3],q[5][3],q[6][3 ] ) ;     t1:=t ;     t2:={seq([q[i][1],q[i][2],c - q[i][3]],i=1 .. 6 ) } ;     t3:={seq([q[i][1],b - q[i][2],q[i][3]],i=1 .. 6 ) } ;     t4:={seq([a - q[i][1],q[i][2],q[i][3]],i=1 .. 6 ) } ;     t5:={seq([a - q[i][1],b - q[i][2],q[i][3]],i=1 .. 6 ) } ;     t6:={seq([a - q[i][1],q[i][2],c - q[i][3]],i=1 .. 6 ) } ;     t7:={seq([q[i][1],b - q[i][2],c - q[i][3]],i=1 .. 6 ) } ;     t8:={seq([a - q[i][1],b - q[i][2],c - q[i][3]],i=1 .. 6 ) } ;     s:={t1,t2,t3,t4,t5,t6,t7,t8 } ;     s ;   end : ....      .... > orbitbox:=proc(t , p )   local s , q , tt , a , b , c , m , ss , i , d , u , v , w , y , mm , nn , x , k ;   q:=convert(t , list ) ;   a:=max(q[1][1],q[2][1],q[3][1],q[4][1],q[5][1],q[6][1 ] ) ;   b:=max(q[1][2],q[2][2],q[3][2],q[4][2],q[5][2],q[6][2 ] ) ;   c:=max(q[1][3],q[2][3],q[3][3],q[4][3],q[5][3],q[6][3 ] ) ;   d:=max(a , b , c);u:=d - a;v:=d - b;w:=d - c;y:={u , v , w};k:=p - d ;      tt[1]:={seq([q[i][3],q[i][2],q[i][1]],i=1 .. 6 ) } ;      tt[2]:={seq([q[i][2],q[i][3],q[i][1]],i=1 .. 6 ) } ;      tt[3]:={seq([q[i][1],q[i][3],q[i][2]],i=1 .. 6 ) } ;      tt[4]:={seq([q[i][2],q[i][1],q[i][3]],i=1 .. 6 ) } ;      tt[5]:={seq([q[i][3],q[i][1],q[i][2]],i=1 .. 6 ) } ;         s:=orbitbox1(t ) ;     for i from 1 to 5 do         s:=s union orbitbox1(tt[i ] ) ;     od ;   s:=convert(s , list);m:=nops(s);ss:= { } ;     for i from 1 to m do       if s[i][1][1]<=a and s[i][2][1]<=a and s[i][3][1]<=a and s[i][4][1]<=a and s[i][5][1]<=a and s[i][6][1]<=a          and s[i][1][2]<=b and s[i][2][2]<=b and s[i][3][2]<=b and s[i][4][2]<=b and s[i][5][2]<=b and s[i][6][2]<=b          and s[i][1][3]<=c and s[i][2][3]<=c and s[i][3][3]<=c and s[i][4][3]<=c and s[i][5][3]<=c and s[i][6][3]<=c          and s[i][1][1]>=0 and s[i][2][1]>=0 and s[i][3][1]>=0 and s[i][4][1]>=0 and s[i][5][1]>=0 and s[i][6][1]>=0          and s[i][1][2]>=0 and s[i][2][2]>=0 and s[i][3][2]>=0 and s[i][4][2]>=0 and s[i][5][2]>=0 and s[i][6][2]>=0          and s[i][1][3]>=0 and s[i][2][3]>=0 and s[i][3][3]>=0 and s[i][4][3]>=0 and s[i][5][3]>=0 and s[i][6][3]>=0        then ss:=ss union { s[i ] } ; fi ;     od ;    mm:=nops(ss ) ;    nn:=(k+u+1)*(k+v+1)*(k+w+1 ) ;      if nops(y)=3 then x:=6*mm*nn;fi ;      if nops(y)=2 then x:=3*mm*nn;fi ;      if nops(y)=1 then x:=mm*nn;fi ;   [ x , ss , nops(ss),[u , v ] ] ; end : ....    the next two routines calculate the orbit of an octahedron within its minimal cube @xmath13 .",
    "this orbit has at most 48 elements and it is needed in the process of elimination of octahedrons that have already appeared in the construction . in comparison with the previous orbit ,",
    "it is bigger and invariant to all the symmetries .    ....",
    "> orbit1octahedron:=proc(t ) local i , k , t1,a , b , c , x , t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14 , t15,t16,t17,t18,t19,t20,t21,t22,t23,t24,s , q , d , a1,b1,c1 ;   q:=convert(t , list ) ;   d:=mscofmoctahedron(t ) ;   t1:=t ;   t2:={seq([q[k][2],q[k][3],q[k][1]],k=1 .. 6 ) } ;   t3:={seq([q[k][1],q[k][3],q[k][2]],k=1 .. 6 ) } ;   t4:={seq([q[k][1],q[k][2],d - q[k][3]],k=1 .. 6 ) } ;   t5:={seq([q[k][2],q[k][3],d - q[k][1]],k=1 .. 6 ) } ;   t6:={seq([q[k][1],q[k][3],d - q[k][2]],k=1 .. 6 ) } ;   t7:={seq([q[k][1],d - q[k][2],q[k][3]],k=1 .. 6 ) } ;   t8:={seq([q[k][2],d - q[k][3],q[k][1]],k=1 .. 6 ) } ;   t9:={seq([q[k][1],d - q[k][3],q[k][2]],k=1 .. 6 ) } ;   t10:={seq([d - q[k][1],q[k][2],q[k][3]],k=1 .. 6 ) } ;   t11:={seq([d - q[k][2],q[k][3],q[k][1]],k=1 .. 6 ) } ;   t12:={seq([d - q[k][1],q[k][3],q[k][2]],k=1 .. 6 ) } ;   t13:={seq([q[k][1],d - q[k][2],d - q[k][3]],k=1 .. 6 ) } ;   t14:={seq([q[k][2],d - q[k][3],d - q[k][1]],k=1 .. 6 ) } ;   t15:={seq([q[k][1],d - q[k][3],d - q[k][2]],k=1 .. 6 ) } ;   t16:={seq([d - q[k][1],d - q[k][2],q[k][3]],k=1 .. 6 ) } ;   t17:={seq([d - q[k][2],d - q[k][3],q[k][1]],k=1 .. 6 ) } ;   t18:={seq([d - q[k][1],d - q[k][3],q[k][2]],k=1 .. 6 ) } ;   t19:={seq([d - q[k][1],q[k][2],d - q[k][3]],k=1 .. 6 ) } ;   t20:={seq([d - q[k][2],q[k][3],d - q[k][1]],k=1 .. 6 ) } ;   t21:={seq([d - q[k][1],q[k][3],d - q[k][2]],k=1 .. 6 ) } ;   t22:={seq([d - q[k][1],d - q[k][2],d - q[k][3]],k=1 .. 6 ) } ;   t23:={seq([d - q[k][2],d - q[k][3],d - q[k][1]],k=1 .. 6 ) } ;   t24:={seq([d - q[k][1],d - q[k][3],d - q[k][2]],k=1 .. 6 ) } ;   s:={t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16 ,   t17,t18,t19,t20,t21,t22,t23,t24 } ;   s ; end : > orbitoctahedron:=proc(t )   local s , q , t1 ;   q:=convert(t , list ) ;",
    "t1:={seq([q[k][3],q[k][2],q[k][1]],k=1 .. 6 ) } ;   s:=orbit1octahedron(t ) union orbit1octahedron(t1 ) ;   s ; end : ....    * step 5 .",
    "* at this point we are ready to build a list of minimal , irreducible octahedrons . with each entry",
    "we keep , in order , @xmath133 , the value @xmath42 which is the size of the minimal cube @xmath192 , the six vertices of the octahedron , the @xmath110-values and the corresponding vector @xmath111 . in the end , another list is created in a new procedure , to get the list of all corresponding reducible cubes needed in a calculation for a given dimension @xmath43 .",
    "the construction is a little complicated because there are octahedrons for which all @xmath110-values are different of @xmath193 .    ....",
    "> extendlist:=proc(n , n , l::list , mm , nn , orb::array ) local d , i , sol , nsol , nel , ttpcube , orb::array ,   ll::list , tnel , nl::list , cio , o , po , k , kvalues , m , exception , int , nn ;   nn:=floor((n+1)/2 ) ;   orb:=array(1 .. 2*nn+1 ) ;   nel:=nops(l ) ;   ll:=l ;   k:=sqrt(mm^2-mm*nn+nn^2 ) ;   m:=n*k ;   if m<=n then    sol:=abcsol(n);nsol:=nops(sol ) ;    tnel:=nel;orb:=orb ;      for i from 1 to nsol do       o:=findpar(sol[i][1],sol[i][2],sol[i][3],mm , nn);po:=tmttopqoctahedron(o ) ;           kvalues:=fourkvalues([o[1],o[2],o[3 ] ] ) ;              exception:=evalb(1 in kvalues ) ;               if k=1 or exception = false then                  int:=orbitoctahedron(po ) intersect orb[m ] ;                  cio:=nops(int ) ;                    if cio=0 then                    orb[m]:=orb[m ] union orbitbox(po , n)[2 ] ;                    d:=mscofmoctahedron(po ) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                nl[tnel+1]:=[n , d , po , kvalues , sol[i ] ] ;                tnel:=tnel+1 ;              fi ;         fi ;         od ;   ll:=[seq(l[i],i=1 .. nel),seq(nl[j],j = nel+1 .. tnel ) ] ;   fi;ll , orb ;   end : ....          .... > extendlistupton:=proc(n ) local i , j , k , l , kv , kvn , nn , l , orb::array , mn , nmn , e , n , ii ; kv:=kvalues(n);kvn:=nops(kv ) ;     nn:=floor((n+1)/2 ) ;     l:=[];orb:=array(1 .. 2*nn+1 ) ;         for ii from 1 to 2*nn+1 do           orb[ii]:= { } ;         od ;       for i from 1 to kvn do        k:=kv[i];mn:=listofmn(k);nmn:=nops(mn ) ;         for j from 1 to nmn do          for l from 1 to nn+1 do            n:=2*l-1 ;             e:=extendlist(n , n , l , mn[j][1],mn[j][2],orb ) ;             l:=e[1 ] ;            for ii from 1 to 2*nn+1 do              orb[ii]:=e[2][ii ] ;            od ;      od ;     od ;    od ;   l;end : ....                                      .... > l:=extendlistupton(100 ) :   extendlistuptonmultiples:=proc(n , l )   local i , j , x , lc , m , mm , d , dd , c , cc , ll ;   m:=nops(l);i:=1;ll:= { } ;   while i<=m   do     d:=l[i][2 ] ;        if d<=n then           mm:=floor(n / d);c:=l[i][3];j:=2 ;            while j<=mm   do                 cc:=multbyfactoroctahedron(c , j ) ;                 dd:=d*j;lc:=nops(ll ) ;                 ll:=ll union { [ l[i][1]*j , dd , cc , l[i][4 ] ] } ;                j:=j+1 ;            od ;         fi ;       i:=i+1 ;    od ;   convert(ll , list ) ;   end :                                      .... > addupnew:=proc(n , l , ll ) local i , j , k , nc , mm , m , d , c , cc , x , dd , nt ; nc:=0 ; m:=nops(l ) ; i:=1 ;     while i<=m   do     d:=l[i][2 ] ;              if d<=n then                  x:=orbitbox(l[i][3],n)[1 ] ;                  nc:=nc+x ;              fi ;   i:=i+1 ;     od ;   m:=nops(ll ) ;    i:=1 ;      while i<=m   do      d:=ll[i][2 ] ;        if d<=n then                x:=orbitbox(ll[i][3],n)[1 ] ;                nc:=nc+x ;        fi ;   i:=i+1 ;     od ;   nc;end : ....          no : = [ [ 1 , 0 ] , [ 2 , 1 ] , [ 3 , 8 ] , [ 4 , 32 ] , [ 5 , 104 ] , [ 6 , 261 ] , [ 7 , 544 ] , [ 8 , 1000 ] , [ 9 , 1696 ] , [ 10 , 2759 ] , [ 11 , 4296 ] , [ 12 , 6434 ] , [ 13 , 9352 ] , [ 14 , 13243 ] , [ 15 , 18304 ] , [ 16 , 24774 ] , [ 17 , 32960 ] , [ 18 , 43223 ] , [ 19 , 55976 ] , [ 20 , 71752 ] , [ 21 , 90936 ] , [ 22 , 113973 ] , [ 23 , 141312 ] , [ 24 , 173436 ] , [ 25 , 210960 ] , [ 26 , 254587 ] , [ 27 , 305000 ] , [ 28 , 364406 ] , [ 29 , 432824 ] , [ 30 , 511421 ] , [ 31 , 600992 ] , [ 32 , 702556],[33 , 817200 ] , [ 34 , 946131 ] , [ 35 , 1090392 ] , [ 36 , 1251238 ] , [ 37 , 1430072 ] , [ 38 , 1629391 ] , [ 39 , 1850064 ] , [ 40 , 2094276 ] , [ 41 , 2363616 ] , [ 42 , 2659813 ] , [ 43 , 2984600 ] , [ 44 , 3341660 ] , [ 45 , 3731720 ] , [ 46 , 4156689 ] , [ 47 , 4618480 ] , [ 48 , 5119292 ] , [ 49 , 5661600 ] , [ 50 , 6248705 ] , [ 51 , 6882808 ] , [ 52 , 7568126 ] , [ 53 , 8306520 ] , [ 54 , 9104339 ] , [ 55 , 9962320 ] , [ 56 , 10888762 ] , [ 57 , 11882896 ] , [ 58 , 12949661 ] , [ 59 , 14090952 ] , [ 60 , 15311286 ] , [ 61 , 16613736 ] , [ 62 , 18001975 ] , [ 63 , 19479680 ] , [ 64 , 21052826 ] , [ 65 , 22724576 ] , [ 66 , 24500175 ] , [ 67 , 26383240 ] , [ 68 , 28387456 ] , [ 69 , 30510616 ] , [ 70 , 32758963 ] , [ 71 , 35136544 ] , [ 72 , 37656214 ] , [ 73 , 40317328 ] , [ 74 , 43125329 ] , [ 75 , 46085496 ] , [ 76 , 49207224 ] , [ 77 , 52493112 ] , [ 78 , 55954267 ] , [ 79 , 59592272 ] , [ 80 , 63415296 ] , [ 81 , 67428832 ] , [ 82 , 71642127 ] , [ 83 , 76059704 ] , [ 84 , 80701546 ] , [ 85 , 85565064 ] , [ 86 , 90662451 ] , [ 87 , 95997360 ] , [ 88 , 101592122 ] , [ 89 , 107443264 ] , [ 90 , 113561009 ] , [ 91 , 119951832 ] , [ 92 , 126644136 ] , [ 93 , 133629672 ] , [ 94 , 140916757 ] , [ 95 , 148513712 ] , [ 96 , 156444624 ] , [ 97 , 164706400 ] , [ 98 , 173308509 ] , [ 99 , 182260568 ] , [ 100 , 191575248 ] ]            r. guy , _ unsolved problems in number theory _ , springer - verlag , 2004 e. grosswald , _ representations of integers as sums of squares _ , springer verlag , new york , 1985 . i. j. schoenberg , _ regular simplices and quadratic forms _ , j. london math . soc .",
    "12 ( 1937 ) 48 - 55 ."
  ],
  "abstract_text": [
    "<S> in this paper we describe a procedure for calculating the number of regular octahedrons that have vertices with coordinates in the set @xmath0 . as a result </S>",
    "<S> , we introduce a new sequence in _ the online encyclopedia of integer sequences _ ( a178797 ) and list the first one hundred terms of it . </S>",
    "<S> we adapt the method appeared in @xcite which was used to find the number of regular tetrahedra with coordinates of their vertices in @xmath0 . </S>",
    "<S> the idea of this calculation is based on the theoretical results obtained in @xcite . </S>",
    "<S> a new fact proved here helps increasing the speed of all the programs used before . </S>",
    "<S> the procedure is put together in a series of commands written for maple .    </S>",
    "<S> [ section ] [ theorem ] proposition [ theorem ] corollary [ theorem ] lemma [ theorem ] definition [ theorem ] problem [ theorem ] conjecture [ theorem ] example [ theorem ] remark    # 1#1 # 1#1 # 1*#1 * </S>"
  ]
}