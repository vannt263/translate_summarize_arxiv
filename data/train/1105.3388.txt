{
  "article_text": [
    "in the today s world full of crypto algorithms , one may wonder what makes a block cipher attractive .    in the authors opinion , the answer to",
    "the question is one word : elegance .",
    "if something looks nice , then there is a big chance that it is also good .",
    "an elegant specification makes it easier to memorize .",
    "memorability makes it easier to realize and to analyze , that allows for fruitful cryptanalytic results , leading to deeper understanding which , in turn , makes greater confidence in the algorithm .",
    "the elegance comprises the following features :    * few algebraic operations .",
    "using of many operations results in hardly - tractable and possibly undesirable interactions between them . * simple and regular key schedule . a complex key schedule , which effectively adds another , unrelated , function to the cipher , results in hardly - tractable and possibly undesirable interactions between the functions .    idea , a secure block cipher designed by xuejia lai and james l. massey @xcite is an example of elegance .",
    "besides being elegant with an efficient choice and arrangement of algebraic operations , it is elegant for some more features :    * the use of incompatible group operations , where _ incompatible _ means there are no simple relations ( such as distributivity ) between them .",
    "the incompatibility eliminates any exploitable algebraic property thus makes it infeasible to solve the cipher algebraically .",
    "* the use of modular multiplication .",
    "multiplication produces huge mathematical complexity while consuming few clock cycles on modern processors .",
    "it thus greatly contributes to security and efficiency of the cipher .",
    "however , idea uses multiplication modulo the fermat prime @xmath8 which does not exist for @xmath9 or @xmath7 , making it not extendable to machine word lengths nowadays .",
    "furthermore , its key schedule is rather irregular due to the rotation of the primary key .",
    "skipjack , a secure block cipher designed by the u.s .",
    "national security agency @xcite , is another example of elegant design . besides being elegant with an efficient , simple and regular key schedule",
    ", it is elegant for one more feature : the use of two ciphers an outer cipher , or _ wrapper _ , consisting of first and last rounds , and an inner cipher , or _",
    "core _ , consisting of middle rounds .",
    "the terms `` core '' and `` wrapper '' were introduced in the design rationale of a structural analogous of skipjack : the block cipher mars @xcite . mars s designers justify this two - layer structure by writing that it breaks any repetitious property , it makes any iterative characteristic impossible , and it disallows any propagation of eventual vulnerabilities in either layer to the other one , thus making attacks more difficult .",
    "the wrapper is primarily aimed at fast diffusion and the core primarily at strong confusion . as claude e. shannon termed in his pioneer work @xcite , _ diffusion _ here refers to the process of letting each input bit affect many output bits ( or , equivalently , each output bit be affected by many input bits ) , and _ confusion _ here refers to the process of letting that affection very involved , possibly by doing it multiple times in very different ways . if a cipher is seen as a polynomial map in the plaintext and the key to the ciphertext , then the methods of diffusion and confusion can be described as the effort of making the polynomials as complete as possible , i.e. such that they contain virtually all terms at all degrees .",
    "approach is very evident in the structure of skipjack ( see figure  [ fig : the - full - cipher-2 ] ) .",
    "skipjack ( as opposed to mars ) was moreover sought elegant as the wrapper there is , in essence , the inverse function of the core .    however , skipjack uses an s - box that renders it rather slow , hard to program in a secure and efficient manner , and not extendable to large machine word lengths , as such .",
    "this article describes an attempt to combine the elegant idea of using incompatible and complex machine - oriented algebraic operations in idea with the elegant structure of skipjack into a scalable and tweakable block cipher called nsabc nice - structured algebraic block cipher .",
    "nsabc is scalable .",
    "it is defined for every even word length _",
    "w_. it encrypts a 4__w__-bit text block under a 5__w__-bit key , thus allows scaling up with 8-bit increment in block length and 10-bit increment in key length .",
    "nsabc is tweakable .",
    "it can use an easily changeable 4__w__-bit parameter , called _ tweak _",
    "@xcite , to make a unique version of the cipher for every block encrypted under the same key . included in the specification is a formula for changing the tweak .",
    "nsabc makes use of entirely the overall structure of skipjack , including the key schedule , and only replaces the internal 4-round feistel structure of skipjack with another structure .",
    "the new structure consists of two rounds of the binary operation @xmath10 , that encrypts a text word _",
    "x _ using a key word _",
    "z _ and a key - dependent word _ e_. the operation @xmath11 is derived from an algebraic group over _ w_-bit words taking @xmath12 as the unit element , so it is also capable of decrypting by means of the inverse element of _ z _ in the group .",
    "the two rounds are separated by an exclusive - or ( xor ) operation that modifies the current text word by a tweak word .",
    "nsabc is put in public domain .",
    "as it bases on skipjack , eventual users should be aware of patent(s ) that may be possibly held by the u.s .",
    "government and take steps to make sure the use is free of legal issues .",
    "we ( the designers of nsabc ) are not aware of any patent related to other parts of the design .",
    "the rest of the article is organized as follows .",
    "section 2 defines operations and notations .",
    "section 3 specifies the cipher .",
    "section 5 gives numerical examples .",
    "section 4 suggests some implementation techniques .",
    "section 6 concludes the article .",
    "source code of software implementations are given in the appendices .",
    "throughout this article , _ w _ denotes the machine word length .",
    "we use the symbols @xmath13 , @xmath14 , @xmath15 and @xmath16 to denote addition , subtraction ( and arithmetic negation ) , multiplication and multiplicative inversion , respectively , modulo @xmath17 ( unless otherwise said ) .",
    "we use the symbols @xmath18 and @xmath19 to denote bit - wise complement and exclusive - or ( xor ) _ _ on _ w_-bit operands ( unless otherwise said ) .",
    "we write @xmath20 to denote leftward rotation ( i. e. cyclic shift toward the most significant bit ) of _ x _ , that is always a _ w_-bit word , by _",
    "n _ bits . for even _ w _",
    ", the symbol @xmath21 denotes swapping the high and low order halves , i.e. @xmath22    let s define binary operation @xmath23 by    @xmath24    and binary operation @xmath6 by    @xmath25    the bivariate polynomials on the right hand side are permutation polynomials in either variable for every fixed value of the other variable [ riv99 ] . in other words , @xmath23 and @xmath6 are quasi - group operations .",
    "furthermore , @xmath23 is a group operation over the set of _ w_-bit numbers .",
    "this fact becomes obvious by considering an alternative definition for the @xmath23 operation @xcite : it can be done by dropping the rightmost bit , which is always `` 1 '' , of the product modulo @xmath26 of the operands each appended with an `` 1 '' bit .",
    "symbolically ,    @xmath27/2\\;(\\mathrm{\\textrm{mod}\\:}2^{w})\\ ] ]    the group defined by @xmath23 is thus isomorphic to the multiplicative group of odd integers modulo @xmath26 , via the isomorphism @xmath28    the unit ( i.e. , identity ) element of the group is 0 .",
    "the inverse element of _ x _ , denoted @xmath29 , is    @xmath30    the following relations are obvious .",
    "@xmath31\\ ] ]    @xmath32\\ ] ]    since the unary operator @xmath14 is an involution , the following relations hold .",
    "@xmath33    @xmath34    notice that 0 is the right unit element w.r.t . the operation @xmath6 .",
    "hence    @xmath35 which means that @xmath36 is also the right inverse element of _ y _ w. r. t. the @xmath6 operation .",
    "since @xmath37 holds for every _ x _ , the following relations hold .",
    "@xmath38    @xmath39    let _ e _ be a fixed _",
    "w_-bit number .",
    "let s define binary operations @xmath40 and @xmath11 by    @xmath41    @xmath42    then @xmath40 and @xmath11 are quasi - group operations over the set of _ w_-bit numbers .",
    "this follows from a more general fact that the right - hand side trivariate polynomials are permutations in either variable while keeping the other two fixed [ riv99 ] .",
    "actually , the symbols @xmath40 and @xmath11 each defines an entire family of binary operations , of which each is uniquely determined by _",
    "furthermore , from the definition it immediately follows that @xmath40 is a group operation , namely , the group is isomorphic to one defined by @xmath23 via the isomorphism    @xmath43    the unit element of the group is _",
    "e_.    the inverse element of _ x _ in the group , denoted @xmath44 , is    @xmath45\\,\\boxtimes\\,\\left[2(x - e)\\boxplus1\\right]^{-1}\\ ] ]    simple calculation proves the following relations .",
    "@xmath46\\ ] ]    @xmath47\\ ] ]    @xmath48    @xmath49    @xmath50    notice that _ e _ is also the right unit element w. r. t. @xmath11 , and @xmath51 also the right inverse element of _ y _ w. r. t. @xmath11 .",
    "the operation @xmath11 , which is non - commutative and non - associative , will be used for encryption and , due to the existence of right inversion , also for decryption .",
    "we write multi - part data values in _ string _ ( or _ number _ ) notation or _ tuple _ ( or _ vector _ ) notation . in string notation ,",
    "the value is written as a sequence of symbols , possibly separated by space(s ) that are insignificant . in tuple notation ,",
    "the value is written as a sequence , in parentheses , of comma - separated symbols .    for examples , _ z y x _ and 43 210 are in string notation , @xmath52 and @xmath53 are in tuple notation .",
    "the string notation indicates _",
    "high - first _ order : the first ( i.e. leftmost ) symbol denotes the most significant part of the value when it is interpreted as a number .",
    "conversely , the tuple notation indicates _ low - first _ order : the first symbol denotes the least significant part of the value when it is interpreted as a number .    for examples , to interpret a 3-word number",
    ", @xmath54 denotes the most significant word of @xmath55 and @xmath56 denotes the least significant word of @xmath57 .",
    "the same value may appear in either notation .",
    "thus , for example , for every _ a _ , _ b _ , _ c _ and _ d _ ,    @xmath58    the term _ part _ introduced above usually refers to `` word '' , but it may also refer to `` digit '' [ of a number ] , `` component '' [ of a tuple or vector ] , as well as group thereof . if , for example _ x _ , _ y _ , _ z _ , _ t _ are 1-digit , 2-digit , 3-digit and 4-digit values respectively , then @xmath59 means @xmath60 , @xmath61 , @xmath62 and @xmath63 .    note that the `` string notation '' and `` number notation '' being used as synonyms does not mean that big - endian data ordering is mandated . in order to avoid security irrelevant details",
    ", we do not specify endianess .",
    "we nevertheless provide a `` reference '' implementations in c++ , where every octet string is considered as a [ generally multi - word ] number with the first octet taken as the least significant one .",
    "the implementation thus interprets octet strings as numbers in little - endian order .",
    "let @xmath64 denote the permutation that reverses the word order of a non - empty word string .",
    "for example , for @xmath65 ,    ` \\mathtt{0x0123abcd}\\mathrm{^{r}}=\\mathtt{0xcdab2301 } `    let @xmath66 denote the permutation that swaps the high order and low order halves of every word of a non - empty word string .",
    "for example , for @xmath65 ,    ` \\mathtt{0x0123abcd}\\mathrm{^{s}}=\\mathtt{0x1032badc } `    the operator @xmath19 on word strings denote word - wise application of @xmath19 .",
    "for example ,    @xmath67    unless otherwise said , operators @xmath13 and @xmath14 on word strings denote word - wise modular addition and subtraction , respectively .",
    "for example ,    @xmath68    @xmath69    let @xmath70 denote the word - wise application of the inversion operator @xmath70 on a word string . for example ,    @xmath71    given word strings _ e _ and _ x _ of the same length , let @xmath72 denote the word - wise application of the inversion operator @xmath44 on every word _",
    "x _ of _ x _ with the index - matching word of _ e _ taken as the [ right ] unit element _",
    "e_. for example ,    @xmath73    operations on word strings are used in this article only to express the decryption function explicitly .",
    "this section provides details of nsabc/_w_. from now on _ w _ , the word length , must be even .    throughout this article , _ x _ denotes a 4__w__-bit plaintext block , _ y _ a 4__w__-bit ciphertext block , _ z _ a 5__w__-bit key , _",
    "t _ a 4__w__-bit secret _ tweak _ , i.e. , a value that is used to encrypt only one block under the key , _ u _ a _",
    "w_-bit _ unit key _ ,",
    "i.e. an additional key that generates right unit elements for the underlying quasi - groups .",
    "tweaking is optional .",
    "it may be disabled by keeping",
    "constant ( like _ z _ and _ u _ ) while encrypting many blocks .",
    "when tweaking is disabled , nsabc becomes a conventional , non - tweakable , block cipher .",
    "mathematically , the cipher is given by two functions ,    00.00.0000    which encrypts _ x _ under control of _ z _ , _ t _ and _ u _ ,    which decrypts _ y _ under control of _ z _ , _ t _ and _ u _ ,    satisfying the apparent relation    @xmath74    the function encrypt is defined in terms of four functions :    00.00.0000    a _ text encryption _ function that encrypts a plaintext block using a _ key schedule _ , a _ unit schedule _ and a _ tweak schedule _ ;    a _ key expansion _",
    "function , that generates the key schedule from _ z _ ;    a _ unit element _ function , that generates the unit schedule from _ u _ ; and    a _ tweak expansion _",
    "function , that generates the tweak schedule from _ t_.       00.00.0000    4__w__-bit plaintext block    5__w__-bit key    4__w__-bit tweak    _",
    "w_-bit unit key       00.00.0000    4__w__-bit ciphertext block       @xmath75    an explicit relation for encrypt is given in algorithm  [ alg : function - encrypt ] .",
    "an explicit relation for decrypt is given in algorithm  [ alg : function - decrypt ] .",
    "mechanically , encryption is performed on a conceptual processor with a 4-word _ text register _",
    "@xmath76 , a 5-word _ key register _",
    "@xmath77 , a 4-word _ tweak register _",
    "@xmath78 and a word _",
    "unit register _",
    "_ u_. the key register is initially loaded with the key _",
    "z_. the tweak register is initially loaded with the tweak _",
    "t_. the unit register is initially loaded with the unit key _ u_. the text register is initially loaded with the plaintext block _ x _ and finally it contains the ciphertext block _",
    "y_.    the concrete , vector , notation here specifies the order of words so , for example , @xmath56 is initially loaded with the least significant word of _ x _ and finally it contains the least significant word of _",
    "y_.      the text register @xmath76 is initially loaded with the plaintext block _ x _ and finally it contains the ciphertext block _",
    "y_.    text encryption proceeds in 32 rounds of operations .",
    "a round is of either _ type a _ or _",
    "type b_. the rounds are arranged in four _ passes _ : firstly eight rounds of type a , then eight rounds of type b , then eight rounds of type a again , finally eight rounds of type b again .    for _ k_-th round , @xmath79 , the text word @xmath56 is permuted ,",
    "i.e. it is updated by an execution unit called _ g - box _ that implements a permutation _",
    "g _ on the set of word values , and the contents of the text word @xmath56 are mixed , by exclusive - or ( xor ) , into an other text word that is either @xmath80 or @xmath81 .",
    "the order of operations and the target of mixing depend on the round type :    * for an a - typed round ( see figure  [ fig : rounds ] part a ) , _ g _ applies first , then the mixing takes place and targets @xmath80 .",
    "that is , the contents of @xmath56 enters the _",
    "g_-box , the output value of the _ g_-box is stored back to @xmath56 , then the contents of @xmath56 and @xmath80 are xored and the result is stored to @xmath80 .",
    "the words @xmath54 and @xmath81 are left unchanged . * for a b - typed round ( see figure  [ fig : rounds ] part b ) , the mixing takes place and targets @xmath81 first , then _",
    "g _ applies .",
    "that is , the contents of @xmath56 and @xmath81 are xored and the result is stored to @xmath81 , then the contents of @xmath56 enters the _",
    "g_-box , the output value of the _ g_-box is stored back to @xmath56 .",
    "the words @xmath80 and @xmath54 are left unchanged .",
    "representative rounds . ]    besides the text input , the _ g_-box also takes as its inputs an ordered pair of _",
    "w_-bit _ key words _ @xmath82 ( depicted by @xmath83 in fig .",
    "[ fig : rounds ] and [ fig : permutation - g ] ) , an ordered pair of _ w_-bit _ unit words",
    "_ @xmath84 ( depicted by @xmath85 in fig .",
    "[ fig : rounds ] and [ fig : permutation - g ] ) , and a _ w_-bit _ tweak word _ @xmath86 ( depicted by in fig .",
    "[ fig : rounds ] and [ fig : permutation - g ] ) .",
    "the details on how key words , unit words and tweak words are generated and used will be given in the subsequent subsections .",
    "the encryption round is completed with a rotation by one word toward the least significant word on the text register , i.e. the text register is modified by simultaneous loading the word @xmath56 with the contents of the word @xmath80 , @xmath80 with the contents of @xmath54 , @xmath54 with the contents of @xmath81 , and @xmath81 with the contents of @xmath56 .",
    "00.00.0000    4__w__-bit plaintext block    64__w__-bit key schedule    64__w__-bit unit schedule    32__w__-bit tweak schedule       00.00.0000    4__w__-bit ciphertext block       for  @xmath87  loop    if  @xmath88  then    @xmath89    @xmath90     elsif  @xmath91  then    @xmath92    @xmath89    end  if       end  loop    relations : :       @xmath93    for  @xmath88 :    @xmath94    @xmath95    @xmath96    @xmath97    for  @xmath91 :    @xmath98    @xmath95    @xmath99    @xmath97     for  @xmath100 :    @xmath101     @xmath102    @xmath103    @xmath104    @xmath105      the tweak register @xmath78 is initially loaded with the tweak _",
    "t_. the tweak words are generated in 32 rounds of operations .    for _ k_-th round , @xmath79 , the value of the word @xmath106 of the tweak register is taken as the tweak word @xmath86 [ which enters the _ g_-box in the _",
    "k_-th encryption round ] .",
    "then , similarly to the text register , the tweak register is rotated by one word toward the least significant word ( see figure  [ fig : rounds ] ) .",
    "00.00.0000    4__w__-bit tweak       00.00.0000    32__w__-bit tweak schedule       @xmath107    for  @xmath87  loop    @xmath108    @xmath109    end  loop     relations : :       @xmath110    for  @xmath100 :     @xmath111    @xmath112    @xmath113    @xmath114    @xmath115    @xmath116     note . for @xmath117 ,",
    "the tweak schedule is    @xmath118      the key register @xmath77 is initially loaded with the key _",
    "z_. the key words are generated in 64 rounds of operations .    for _ k_-th round , @xmath119 , the value of the word @xmath120 of the key register is taken as the key word @xmath121 [ which enters the _ g_-box of the _ k_/2-th encryption round as the first key word if _",
    "k _ is even , or as the second key word if _ k _ is odd ] .",
    "the key register is then rotated by one word toward the least significant word .",
    "the rotation is similar to that on the text register and the tweak register .",
    "( see figure  [ fig : rounds ] . )",
    "00.00.0000    5__w__-bit key       00.00.0000    64__w__-bit key schedule       @xmath122    for  @xmath123  loop    @xmath124    @xmath125    end  loop    relations : :       @xmath126    for  @xmath127 :     @xmath128    @xmath129    @xmath130    @xmath131    @xmath132    @xmath133    @xmath134    note . for @xmath135 ,",
    "the key schedule is    @xmath136      the unit register _",
    "u _ is initially loaded with the unit key _",
    "u_.    unit words are generated in 64 rounds of operations .",
    "for _ k_-th round , @xmath119 , the value of the unit register _",
    "u _ is taken as the unit word @xmath137 [ which , similarly to the key word @xmath121 , enters the _ g_-box of _ k_/2-th encryption round as the first unit word if _ k _ is even , or as the second unit word if _ k _ is odd ] .",
    "the register is then added modulo @xmath17 by the [ key - dependent ] constant @xmath138 to become ready for the next round .",
    "( see figure  [ fig : rounds ] . )",
    "00.00.0000    _",
    "w_-bit unit key       00.00.0000    64__w__-bit unit schedule       @xmath139    for  @xmath123  loop    @xmath140    @xmath141    end  loop     relations : :       @xmath142    for  @xmath143 :    @xmath144    @xmath145    @xmath146    or ,  equivalently ,  for  every  @xmath147 :    @xmath148     note . given unit key _",
    "u _ , the unit schedule is    @xmath149      the _ g_-box implements a permutation _",
    "( see figure  [ fig : permutation - g ] ) that takes as argument a text word and is parametrized by an ordered pair of key words @xmath150 , an ordered pair of unit words @xmath151 and a tweak word @xmath152 to return a text word as the result .",
    "the _ g_-box operates on a word register that initially contains the argument and finally contains the result .",
    "the _ g_-box proceeds in two rounds , each consisting of an operation @xmath11 followed by a half - word swap s. the two rounds are separated by an exclusive - or ( xor ) operation .    for the first round , the operation @xmath11 takes the contents of the register as the left operand , @xmath153 as the right operand , and @xmath154 as its right unit element .",
    "the result is stored back to the register .",
    "the register is then modified by operation s , i.e. swapping the contents of its high and low order halves .    for the inter - round xor operation ,",
    "the register is modified by xoring its contents with the tweak word @xmath152 and storing the result back to it .",
    "for the second round , the register is processed similarly to the first round with @xmath155 and @xmath156 being used instead of @xmath153 and @xmath154 , respectively .",
    "permutation g.,title=\"fig : \" ]       00.00.0000    _ w_-bit text word    pair of _",
    "w_-bit key words    pair of _",
    "w_-bit unit words    _ w_-bit tweak word       00.00.0000    _",
    "w_-bit text word       @xmath157    @xmath158    @xmath159    @xmath160    @xmath158    @xmath161    relation : :       @xmath162    [ [ notes ] ] notes + + + + +    1 .",
    "the cipher uses 64 distinct instances from the family of operations @xmath11 .",
    "alternatively , it may be seen as using 64 identical instances of the single operation @xmath6 or @xmath23 , but operands and result of each instance are `` biased '' by adding or subtracting the constant @xmath154 ( or @xmath156 ) that is specific to the instance , and furthermore , being seen as @xmath23 , the left operand enters and the result leaves it in altered sign .",
    "like skipjack , the _",
    "g_-box permutes @xmath153 ( or @xmath155 ) while keeping @xmath4 and other parameters fixed . unlike skipjack ,",
    "the _ g_-box does nt permute the word @xmath163 where @xmath164 and @xmath165 stand for the high and the low order half respectively .",
    "4 .   unlike skipjack , diffusion in the _",
    "g_-box is incomplete , i.e. not every input bit affects all output bits .",
    "indeed , the _ v_-th bit of the argument , with @xmath166 , affects only all bits of the low order half and bits _ v _ through @xmath167 of the result ; bits @xmath168 through @xmath169 remain unaffected . 5 .   if @xmath170 then _ g _ becomes the identity .",
    "decryption can be easily derived from encryption .",
    "namely , if    @xmath171    then it immediately follows that       00.00.0000    4__w__-bit ciphertext block    5__w__-bit key    4__w__-bit tweak    _",
    "w_-bit unit key       00.00.0000    4__w__-bit plaintext block       @xmath172    @xmath173    in other words , encrypting the cipher block in reverse half - word order ( @xmath174 ) using the tweak in reverse half - word order ( @xmath175 ) , the unit schedule in reverse word order ( @xmath176 ) , and the key schedule consisting of inverse words of one expanded from the key in reverse word order ( @xmath177 ) , where the inversions are of the quasi - groups defined by the operation @xmath11 and each quasi - group is uniquely given by its right unit that is the index - matching word of the encryption unit schedule in reverse word order ( @xmath176 ) , recovers the plain block in reverse half - word order ( @xmath178 ) .",
    "[ [ notes-1 ] ] notes + + + + +    1 .   the full cipher is illustrated in figure  [ fig : the - full - cipher-1 ] , where @xmath179 , @xmath180 , @xmath135 and @xmath117 ( the unit schedule is omitted ) .",
    "the figure is obtained by `` unrolling ''",
    "( i.e. eliminating all rotations of ) the dataflow graph of the full cipher that would be obtained by cascading the individual rounds as in figure  [ fig : rounds ] .",
    "2 .   the overall structure is up to word indexing identical to that of skipjack .",
    "the word re - indexing , which is cryptographically insignificant , was introduced to ease description and illustration .",
    "3 .   like skipjack",
    ", decryption is similar to encryption . to decrypt with skipjack , one swaps adjacent words in the cipher and the plain block and swaps adjacent word pairs in the key . to decrypt with nsabc ,",
    "one reverses the word order , i.e. , swaps the first and the last words as well as the second first and the second last ones in the text block , the tweak and the key . for skipjack ,",
    "one also swaps high and low order halves of every word . for nsabc ,",
    "one swaps high and low order halves of every word but that of the key .",
    "4 .   unlike skipjack ,",
    "just swapping the words and half - words does nt turn encryption into decryption ",
    "one needs to invert key words too .",
    "thus although encrypt and decrypt can be expressed explicitly in terms of crypt , decrypt can not be expressed explicitly in terms of encrypt .",
    "the full cipher , by `` unrolling''.,title=\"fig : \" ]      the 4__w__-bit secret tweak _",
    "t _ is used to encrypt only one block [ under a given key _",
    "z _ and unit key _ _ u _ _ ] . in order to encrypt multiple blocks",
    "the tweak is derived from the block index and a 4__w__-bit [ additional ] key , called _ tweak key _ , as follows .",
    "let @xmath181 denote the tweak used to encrypt _",
    "j_-th block .",
    "for the first block ( @xmath182 ) , the tweak key is used as the tweak directly :    @xmath183    the subsequent tweak is computed from the current tweak by the recurrent relation :    @xmath184    or , equivalently ,    @xmath185    where all operands are regarded as 4__w__-bit numbers and all operators are defined on 4__w__-bit arithmetic , i.e. mod @xmath186 .",
    "[ [ notes-2 ] ] notes + + + + +    1 .",
    "the third relation , where @xmath187 conveniently designates the [ unnamed ] tweak key , is meant for random access .",
    "the family of functions @xmath188 , parametrized by the tweak key @xmath187 , is not @xmath189-almost 2-xor universal according to definition in @xcite .",
    "eventual application of this family in the liskov - rivest - wagner construction , i.e. encryption by @xmath190 , is therefore impossible .",
    "2 .   for efficient random access",
    ", applications may opt to use non - flat spaces of the block index _",
    "j_. for example , an application that encrypts relational databases may define the index in the format @xmath191 , where @xmath192 is database number , @xmath193 is table number within the database , @xmath194 is row number within the table , @xmath195 is field number within the row and @xmath196 is block number within the field .",
    "3 .   tweaking must be disabled when the cipher is used as a permutation , i. e. to generate a sequence of unique numbers .",
    "4 .   tweaking should be enabled in all other modes of operation .",
    "for example , a non - tweakable block cipher can generate a sequence of independent numbers by encrypting a counter block in cipher block chaining ( cbc ) mode ; nsabc can generate a similar sequence with virtually the same cycle length by encrypting a constant block in a `` tweaked cbc '' mode .",
    "an encipherment in nsabc/16 with    @xmath197    results in    @xmath198    table  [ tab : contents - of - registers ] lists states of the [ conceptual ] processor during the encipherment , i.e. the contents of all registers at the start of round _ k _ for _ k _ = 0 , 1 , 2 , ... , 64 for key schedule and unit schedule , and _",
    "k _ = 0 , 1 , 2 , ... , 32 for tweak schedule and text encryption .",
    "the start of round 64 ( 32 ) conveniently means the end of round 63 ( 31 ) , which is that of the entire algorithm .",
    "= = =  = = = =  = = = = = = = = = = = = = = = = = = = =  = = =  = = = = = = = = = = = = = = = =  = = = = = = = = = = = = = = = =    unit  key  register  tweak  register  text  register     k  u  z4  z3  z2  z1  z0  k  t3  t2  t1  t0  x3  x2  x1  x0    = = =  = = = =  = = = = = = = = = = = = = = = = = = = =  = = =  = = = = = = = = = = = = = = = =  = = = = = = = = = = = = = = = =    0  1998  88880777006600050000  0  0001002203334444  0123456789abcdef    1  4cc9  00008888077700660005    2  7ffa  00050000888807770066  1  4444000100220333  388401234567b12f    3  b32b  00660005000088880777    4  e65c  07770066000500008888  2  0333444400010022  1e90388401235bf7    5  198d  88880777006600050000    6  4cbe  00008888077700660005  3  0022033344440001  60ac1e903884618f    7  7fef  00050000888807770066    8",
    "b320  00660005000088880777  4  0001002203334444  499160ac1e907115    9  e651  07770066000500008888    10  1982  88880777006600050000  5  4444000100220333  c2d7499160acdc47    11  4cb3",
    "00008888077700660005    12  7fe4  00050000888807770066  6  0333444400010022  f1efc2d749919143    13  b315  00660005000088880777    14  e646  07770066000500008888  7  0022033344440001  03d2f1efc2d74a43    15  1977  88880777006600050000    16  4ca8  00008888077700660005  8  0001002203334444  273d03d2f1efe5ea    17  7fd9  00050000888807770066    18  b30a  00660005000088880777  9  4444000100220333  1615c2d703d2f1ef    19  e63b  07770066000500008888    20  196c  88880777006600050000  10  0333444400010022  a9b6e7fac2d703d2    21  4c9d  00008888077700660005    22  7fce  00050000888807770066  11  0022033344440001  18c0aa64e7fac2d7    23  b2ff  00660005000088880777    24  e630  07770066000500008888  12  0001002203334444  b049da17aa64e7fa    25  1961  88880777006600050000    26  4c92  00008888077700660005  13  4444000100220333  851857b3da17aa64    27  7fc3  00050000888807770066    28  b2f4  00660005000088880777  14  0333444400010022  71f82f7c57b3da17    29  e625",
    "07770066000500008888    30  1956  88880777006600050000  15  0022033344440001  d5f0abef2f7c57b3    31  4c87  00008888077700660005    32  7fb8  00050000888807770066  16  0001002203334444  e5118243abef2f7c    33  b2e9  00660005000088880777    34  e61a  07770066000500008888  17  4444000100220333  94fae51182433f15    35  194b  88880777006600050000    36  4c7c  00008888077700660005  18  0333444400010022  7bb394fae511f9f0    37  7fad  00050000888807770066    38  b2de  00660005000088880777  19  0022033344440001  11747bb394faf465    39  e60f  07770066000500008888    40  1940  88880777006600050000  20  0001002203334444  d14f11747bb345b5    41  4c71  00008888077700660005    42  7fa2  00050000888807770066  21  4444000100220333  0385d14f11747836    43  b2d3  00660005000088880777    44  e604  07770066000500008888  22  0333444400010022  873b0385d14f964f    45  1935  88880777006600050000    46  4c66  00008888077700660005  23  0022033344440001  cb9b873b03851ad4    47  7f97  00050000888807770066    48  b2c8  00660005000088880777  24  0001002203334444  d6fccb9b873bd579    49  e5f9  07770066000500008888",
    "50  192a  88880777006600050000  25  4444000100220333  d4cf0385cb9b873b    51  4c5b  00008888077700660005    52  7f8c  00050000888807770066  26  0333444400010022  779f53f40385cb9b    53  b2bd  00660005000088880777    54  e5ee  07770066000500008888  27  0022033344440001  8cecbc0453f40385    55  191f  88880777006600050000    56  4c50  00008888077700660005  28  0001002203334444  c93a8f69bc0453f4    57  7f81  00050000888807770066    58  b2b2",
    "00660005000088880777  29  4444000100220333  2e1a9ace8f69bc04    59  e5e3  07770066000500008888    60  1914  88880777006600050000  30  0333444400010022  8038921e9ace8f69    61  4c45  00008888077700660005    62  7f76  00050000888807770066  31  0022033344440001  d4be0f51921e9ace    63  b2a7  00660005000088880777    64  e5d8  07770066000500008888  32  0001002203334444  88b14e700f51921e",
    "this section provides methods for efficient software implementation for two types of environment : memory - constrained , such as embedded computers , and memory - abundant , such as servers and personal computers .",
    "the function encrypt can be implemented without using any writeable memory on a processor with at least 16 word registers :    * 4 for @xmath76  text register * 5 for @xmath77  key register * 4 for @xmath78  tweak register * 1 for _ u _  unit register , * 1 for the constant value @xmath138 , and * 1 for _ k _  round index .    indeed , the schedules _ k _ , _ l _ and _ c _ can vanish because every word of them , once produced , can be consumed immediately , provided that the functions ke , te , ue and crypt are programmed to run in parallel and synchronized with each increment of _ k_. source code of this implementation is given in appendix a.    unlike encrypt , decrypt needs memory for the key schedule because on - the - fly modular multiplicative inversion is too slow to be practical . in this environment , modes of operation that avoid decrypt ( i.e. ones using encrypt to decrypt ) are thus preferable",
    ".      the quasi - group operation @xmath11 can be evaluated by only one multiplication and one addition . indeed ,    @xmath199    where _ x _ is a text word , _ z _ key word , and    @xmath200    @xmath201    so , instead of using the @xmath202 pairs , one may pre - compute the @xmath203 pairs once and use them many times .",
    "the cipher is parallelizable .",
    "the following procedure executes all 32 rounds in 20 steps , of which half performing two or three parallel evaluations of _ g_. recall that @xmath204 is the result of _ g _ in round _",
    "k_.    1 .   compute @xmath205 2 .",
    "compute @xmath206 3 .",
    "compute @xmath207 4 .",
    "compute @xmath208 5 .",
    "compute @xmath209 6 .",
    "compute @xmath210 , @xmath211 in parallel 7 .",
    "compute @xmath212 , @xmath213 in parallel 8 .",
    "compute @xmath214 , @xmath215 , @xmath216 in parallel 9 .",
    "compute @xmath217 , @xmath218 in parallel 10 .",
    "compute @xmath219 , @xmath220 in parallel 11 .",
    "compute @xmath221 12 .",
    "compute @xmath222 13 .",
    "compute @xmath223 14 .",
    "compute @xmath224 15 .",
    "compute @xmath225 16 .",
    "compute @xmath226 , @xmath227 in parallel 17 . compute @xmath228 , @xmath229 in parallel 18 .",
    "compute @xmath230 , @xmath231 , @xmath232 in parallel 19 . compute @xmath233 , @xmath234 in parallel 20 .",
    "compute @xmath235 , @xmath236 in parallel    the procedure becomes evident by examining the dataflow graph of the cipher , shown in figure  [ fig : the - full - cipher-2 ] , which is obtained by `` unrolling '' the one in figure  [ fig : the - full - cipher-1 ] .",
    "here `` unrolling '' means introducing a rotation so that the g - boxes with congruent round indices ( mod 3 ) lay on a straight line .",
    "the full cipher , by another `` unrolling '' . ]    on a x86 - 64 processor in 32-bit mode ( @xmath9 ) , the procedure takes about 256 clock cycles , i.e. 256/16 = 16 clock cycles per byte encrypted .",
    "( the source code of this implementation is given in appendix b. ) in 64-bit mode ( @xmath7 ) , it takes about 384 clock cycles , i.e. 384/32 = 12 clock cycles per byte .",
    "the procedure may be also coded twice , i.e. it may be run in two instances in parallel on a single core of the processor , with the second instance delayed by a few steps after the first , to encrypt two blocks possibly under different tweaks and/or keys .",
    "this method has shown to be effective for x86 - 64 processors in 64-bit mode , resulting in about 9 clock cycles per byte .",
    "we defined nsabc , a block cipher utilizing a group operation that is essentially modular multiplication of machine words , a powerful operation available on many processors .",
    "nsabc was meant to be elegant .",
    "it uses no s - boxes or `` magic '' constants .",
    "it uses only machine word - oriented algebraic operations .",
    "it makes use of the simple and regular structure of skipjack which has become publicly known for over a decade sufficient time to be truly understood .",
    "it is elegant to be easily memorizable , realizable and analyzable .",
    "nsabc bases on some valuable design of a well - reputed agency in the branch .",
    "we therefore believe that it is worth analysis and it can withstand rigorous analysis .",
    "if this happens to be true , then we may have a practical cipher with 256-bit blocks , allowing to encrypt enormous amount of data under the same key , and with 320-bit keys , allowing to protect data over every imaginable time .    in cipher design",
    "there is always a trade - off between security and efficiency , and designers always have to ask : `` what do we want , a very strong and fairly fast cipher , or fairly strong but very fast ? ''",
    "nsabc reflects the authors view on the dilemma .",
    "if skipjack is regarded as very strong and just fairly fast , then nsabc may be regarded as a design emphasizing the second aspect make it very fast , abeit just fairly strong . for _ w_-bit word length ,",
    "nsabc key length is 5__w _ _ bits , optionally plus 5__w _ _ bits more , whilst the true level of security is yet to be determined . on the other hand , on a modern 64-bit processor",
    "it takes only 9 clock cycles to encrypt a byte .",
    ".... typedef uint32_t word ;   //----------------------------------------------------------------------",
    "static word o(word x , word y , word e ) {      return 2*x*y + ( 1 - 2*e)*(x - y + e ) ; } //----------------------------------------------------------------------",
    "static word g(word x , word z0 , word z1 , word u0 , word u1 , word t ) {         x = o(x , z0,u0 ) ;      x = _ rotl(x,16 ) ;      x ^= t ;      x = o(x , z1,u1 ) ;      x = _ rotl(x,16 ) ;      return x ; } //---------------------------------------------------------------------- void encrypt ( word y[4 ] , word const x[4 ] , word const z[5 ] ,                 word const t[4 ] , word u ) {      word          x0 = x[0 ] , x1 = x[1 ] , x2 = x[2 ] , x3 = x[3 ] ,          z0 = z[0 ] , z1 = z[1 ] , z2 = z[2 ] , z3 = z[3 ] , z4 = z[4 ] ,          t0 = t[0 ] , t1 = t[1 ] , t2 = t[2 ] , t3 = t[3 ] ,           u0 = u ,          u1 = u0 + 2*u + 1 ;      for(int k = 0 ; k <",
    "32 ; k++ )      {          if(k & 8)          //",
    "b - round          {              x3 ^= x0 ;              x0 = g(x0 , z3 , z4 , u0 , u1 , t0 ) ;          }          else               // a - round          {              x0 = g(x0 , z3 , z4 , u0 , u1 , t0 ) ;              x1 ^= x0 ;          }          word x = x0 ; x0 = x1 ; x1 = x2 ; x2 = x3 ; x3 = x ;          word z = z0 ; z0 = z2 ; z2 = z4 ; z4 = z1 ; z1 = z3 ; z3 = z ;          word t = t0 ; t0 = t1 ; t1 = t2 ; t2 = t3 ; t3 = t ;          u0 = u1 + 2*u + 1 ;          u1 = u0 + 2*u + 1 ;      }      y[0 ] = x0 ; y[1 ] = x1 ; y[2 ] = x2 ; y[3 ] = x3 ; } ....    .... void expandkey    ( word m[64 ] , word n[64 ] , word const z[5 ] , word u ) {      word z0=z[0 ] , z1=z[1 ] , z2=z[2 ] , z3=z[3 ] , z4=z[4 ] ;      word u = u ;      for ( int k=0 ; k<64 ; k++ )      {          m[k ] = 2*(z3 - u ) + 1 ;          n[k ] = ( 2*u - 1)*(z3 - u ) ;          u + = 2*u + 1 ;          word z = z0 ; z0=z1 ; z1=z2 ; z2=z3 ; z3=z4 ; z4=z ;      } } //----------------------------------------------------------------------",
    "static inline   word g ( word x , word t , word m0 , word m1 , word n0 , word n1 ) {      x * = m0 ;      x + = n0 ;      x = _ rotl(x,16 ) ;      x ^= t ;      x * = m1 ;      x + = n1 ;      x = _ rotl(x,16 ) ;      return x ; } //---------------------------------------------------------------------- void crypt ( word y[4 ] , word const x[4 ] , word const t[4 ] ,               word const m[64 ] , word const n[64 ] ) {         // step 1      word const g0 = g(x[0 ] ,               t[0 ] ,   m[0 ] , m[1 ] , n[0 ] , n[1 ] ) ;      //",
    "step 2      word const g1 = g(x[1]^g0 ,            t[1 ] ,   m[2 ] , m[3 ] , n[2 ] , n[3 ] ) ;      // step 3      word const g2 = g(x[2]^g1 ,            t[2 ] ,   m[4 ] , m[5 ] , n[4 ] , n[5 ] ) ;      // step 4      word const g3 = g(x[3]^g2 ,            t[3 ] ,   m[6 ] , m[7 ] , n[6 ] , n[7 ] ) ;      //",
    "step 5      word const g4 = g(g0^g3 ,              t[0 ] ,   m[8 ] , m[9 ] , n[8 ] , n[9 ] ) ;      //",
    "step 6      word const g5 = g(g1^g4 ,              t[1 ] , m[10],m[11],n[10],n[11 ] ) ;      word const g11= g(g4 ,                 t[3 ] , m[22],m[23],n[22],n[23 ] ) ;      //",
    "step 7      word const g6 = g(g2^g5 ,              t[2 ] , m[12],m[13],n[12],n[13 ] ) ;      word const g9 = g(g5 ,                 t[1 ] , m[18],m[19],n[18],n[19 ] ) ;      // step 8      word const g7 = g(g3^g6 ,              t[3 ] , m[14],m[15],n[14],n[15 ] ) ;      word const g10= g(g6 ,                 t[2 ] , m[20],m[21],n[20],n[21 ] ) ;      word const g13= g(g6^g9 ,              t[1 ] , m[26],m[27],n[26],n[27 ] ) ;      // step 9      word const g8 = g(g4^g7 ,              t[0 ] , m[16],m[17],n[16],n[17 ] ) ;      word const g14= g(g4^g10 ,             t[2 ] , m[28],m[29],n[28],n[29 ] ) ;      //",
    "step 10      word const g12= g(g5^g8 ,              t[0 ] , m[24],m[25],n[24],n[25 ] ) ;      word const g15= g(g5^g8^g11 ,          t[3 ] , m[30],m[31],n[30],n[31 ] ) ;      //",
    "step 11      word const g16= g(g6^g9^g12 ,          t[0 ] , m[32],m[33],n[32],n[33 ] ) ;      //",
    "step 12      word const g17= g(g4^g10^g13^g16 ,     t[1 ] , m[34],m[35],n[34],n[35 ] ) ;      //",
    "step 13      word const g18= g(g5^g8^g11^g14^g17 , t[2 ] , m[36],m[37],n[36],n[37 ] ) ;      //",
    "step 14      word const g19= g(g15^g18 ,            t[3 ] , m[38],m[39],n[38],n[39 ] ) ;      //",
    "step 15      word const g20= g(g16^g19 ,            t[0 ] , m[40],m[41],n[40],n[41 ] ) ;      //",
    "step 16      word const g21= g(g17^g20 ,            t[1 ] , m[42],m[43],n[42],n[43 ] ) ;      word const g27= g(g20 ,                t[3 ] , m[54],m[55],n[54],n[55 ] ) ;      //",
    "step 17      word const g22= g(g18^g21 ,            t[2 ] , m[44],m[45],n[44],n[45 ] ) ;      word const g25= g(g21 ,                t[1 ] , m[50],m[51],n[50],n[51 ] ) ;      //",
    "step 18      word const g23= g(g19^g22 ,            t[3 ] , m[46],m[47],n[46],n[47 ] ) ;      word const g26= g(g22 ,                t[2 ] , m[52],m[53],n[52],n[53 ] ) ;      word const g29= g(g22^g25 ,            t[1 ] , m[58],m[59],n[58],n[59 ] ) ;      //",
    "step 19      word const g24= g(g20^g23 ,            t[0 ] , m[48],m[49],n[48],n[49 ] ) ;      word const g30= g(g20^g26 ,            t[2 ] , m[60],m[61],n[60],n[61 ] ) ;      y[1 ]    = g20^g26^g29 ;      //",
    "step 20      word const g28= g(g21^g24 ,            t[0 ] , m[56],m[57],n[56],n[57 ] ) ;      word const g31= g(g21^g24^g27 ,        t[3 ] , m[62],m[63],n[62],n[63 ] ) ;      y[2 ]    = g21^g24^g27^g30 ;      //",
    "step 21      y[0 ]    = g22^g25^g28 ;      y[3 ]    = g31 ; } //---------------------------------------------------------------------- // multiplicative inverse of x ( mod 2**32 ) , x odd .",
    "// source code by thomas pornin , usenet 2009 .",
    "word inverse(word x ) {      word y = 2 - x ; //",
    "xy = = 1 mod 4      y * = 2 - x*y ;    // xy = = 1 mod 16      y * = 2 - x*y ;    //",
    "xy = = 1 mod 256      y * = 2 - x*y ;    // xy = = 1 mod 65536      y * = 2 - x*y ;    // xy = = 1 mod 4294967296      return y ; } //---------------------------------------------------------------------- void invertkey ( word       im[64 ] , word       in[64 ] ,                   word const m[64 ] , word const n[64 ] ) {      //",
    "m , n , i m , in must not overlap !      for(int k=0 ; k < 64 ; k++ )      {          im[k ] = inverse ( m[63-k ] ) ;          in[k ] = - n[63-k ] * im[k ] ;      } } //---------------------------------------------------------------------- void icrypt ( word x[4 ] , word const y[4 ] , word const t[4 ] ,                word const im[64 ] , word const in[64 ] ) {         word xrs[4 ] , trs[4 ] ;      trs[0 ] = _ rotl(t[3],16 ) ;      trs[1 ] = _ rotl(t[2],16 ) ;      trs[2 ] = _ rotl(t[1],16 ) ;      trs[3 ] = _ rotl(t[0],16 ) ;      xrs[0 ] = _ rotl(y[3],16 ) ;      xrs[1 ] = _ rotl(y[2],16 ) ;      xrs[2 ] = _ rotl(y[1],16 ) ;      xrs[3 ] = _ rotl(y[0],16 ) ;      crypt ( xrs , xrs , trs , i m , in ) ;      x[0 ] = _ rotl(xrs[3],16 ) ;      x[1 ] = _ rotl(xrs[2],16 ) ;      x[2 ] = _ rotl(xrs[1],16 ) ;      x[3 ] = _ rotl(xrs[0],16 ) ; } //---------------------------------------------------------------------- //",
    "testing against the reference implementation void test ( ) {      int const ntimes = 10000 ;      int const nrep    = 100 ;      word x[4 ] , y[4 ] , t[4 ] , z[5 ] , m[64 ] , n[64 ] , im[64 ] , in[64 ] ;      for(int i=0 ; i<5 ; i++ )          z[i ] = random_word ( ) ;      for(int i=0 ; i<4 ; i++ )          t[i ] = random_word ( ) ;      word u = random_word ( ) ;      // correctness of the optimized implementation      expandkey ( m , n , z , u ) ;      for(int n = ntimes ; n ; n-- )      {          for(int i=0 ; i<4 ; i++ )              x[i ] = random_word ( ) ;          memcpy ( y , x , sizeof(x ) ) ;          for(int m = nrep ; m ; m-- )          {              encrypt ( x ,   x ,   z , t , u ) ;              crypt ( y , y , t , m , n ) ;          }          if ( memcmp(y , x , sizeof(x ) ) ! = 0 )              cout < < \" crypt : incorrect encryption ! \" < < endl ;      }      // invertibility of the optimized implementation      invertkey ( i m , in , m , n ) ;      for(int n = ntimes ; n ; n-- )      {          for(int i=0 ; i<4 ; i++ )              x[i ] = random_word ( ) ;          memcpy ( y , x , sizeof(x ) ) ;          for(int m = nrep ; m ; m-- )              crypt ( y , y , t , m , n ) ;          for(int m = nrep ; m ; m-- )              icrypt ( y , y , t , im , in ) ;          if ( memcmp(y , x , sizeof(x ) ) ! = 0 )              cout < < \" icrypt : incorrect decryption ! \" < < endl ;      } } //////////////////////////////////////////////////////////////////////// ...."
  ],
  "abstract_text": [
    "<S> we introduce nsabc/@xmath0 nice - structured algebraic block cipher using @xmath0-bit word arithmetic , a @xmath1-bit analogous of skipjack @xcite with @xmath2-bit key . </S>",
    "<S> the skipjack s internal 4-round feistel structure is replaced with a @xmath0-bit , 2-round cascade of a binary operation @xmath3 that permutes a text word @xmath4 under control of a key word @xmath5 . </S>",
    "<S> the operation @xmath6 , similarly to the multiplication in idea @xcite , bases on an algebraic group over @xmath0-bit words , so it is also capable of decrypting by means of the inverse element of @xmath5 in the group . </S>",
    "<S> the cipher utilizes a secret @xmath1-bit tweak an easily changeable parameter with unique value for each block encrypted under the same key @xcite that is derived from the block index and an additional @xmath1-bit key . </S>",
    "<S> a software implementation for @xmath7 takes circa 9 clock cycles per byte on x86 - 64 processors . </S>"
  ]
}