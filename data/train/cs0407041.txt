{
  "article_text": [
    "constraint programming models for combinatorial optimization problems consist of variables on finite domains , constraints on those variables and an objective function to be optimized . in general ,",
    "constraint programming solvers use domain value enumeration to solve combinatorial optimization problems . by propagation of the constraints ( i.e. removal of inconsistent values ) ,",
    "large parts of the resulting search tree may be pruned . because combinatorial optimization problems are np - hard in general , constraint propagation is essential to make constraint programming solvers practically applicable .",
    "another essential part concerns the enumeration scheme , that defines and traverses a search tree .",
    "variable and value ordering heuristics as well as tree traversal heuristics greatly influence the performance of the resulting constraint programming solver .    in this work",
    "we investigate the possibility of using semidefinite relaxations in constraint programming .",
    "this investigation involves the extraction of semidefinite relaxations from a constraint programming model , and the actual use of the relaxation inside the solution scheme .",
    "we propose to use the solution of a semidefinite relaxation to define search tree ordering and traversal heuristics .",
    "effectively , this means that our enumeration scheme starts at the suggestion made by the semidefinite relaxation , and gradually scans a wider area around this solution .",
    "moreover , we use the solution value of the semidefinite relaxation as a bound for the objective function , which results in stronger pruning . by applying a semidefinite relaxation in this way",
    ", we hope to speed up the constraint programming solver significantly .",
    "these ideas were motivated by a previous work  @xcite , in which a linear relaxation was proved to be helpful in constraint programming .",
    "we implemented our method and provide experimental results on the stable set problem and the maximum clique problem , two classical combinatorial optimization problems .",
    "we compare our method with a standard constraint programming solver , and with specialized solvers for maximum clique problems .",
    "as computational results will show , our method obtains far better results than a standard constraint programming solver .",
    "however , on maximum clique problems , the specialized solvers appear to be much faster than our method .",
    "this paper is an extended and revised version of @xcite . in the current version , a more general view on the proposed method",
    "is presented .",
    "namely , in @xcite the method was proposed for stable set problems only , while in this paper we propose the method to be applied to any constraint programming problem , although not all problems will be equally suitable .",
    "furthermore , in @xcite the method uses a subproblem generation framework on which limited discrepancy search is applied . in the current work",
    "it has been replaced by limited discrepancy search on single values , which is more concise while preserving the behaviour of the algorithm . finally , more experimental results are presented , including problem characterizations and instances of the dimacs benchmark set for the maximum clique problem .",
    "the outline of the paper is as follows .",
    "the next section gives a motivation for the approach proposed in this work .",
    "then , in section  [ sc : prel ] some preliminaries on constraint and semidefinite programming are given .",
    "a description of our solution framework is given in section  [ sc : framework ] . in section  [ sc : formulations ] we introduce the stable set problem and the maximum clique problem , integer optimization formulations and a semidefinite relaxation .",
    "section  [ sc : results ] presents the computational results .",
    "we conclude in section  [ sc : conclusions ] with a summary and future directions .",
    "np - hard combinatorial optimization problems are often solved with the use of a polynomially solvable relaxation . often ( continuous ) linear relaxations are chosen for this purpose . also within constraint programming , linear relaxations",
    "are widely used , see @xcite for an overview .",
    "let us first motivate why in this paper a semidefinite relaxation is used rather than a linear relaxation . for some problems , for instance for the stable set problem , standard linear relaxations are not very tight and not informative .",
    "one way to overcome this problem is to identify and add linear constraints that strengthen the relaxation .",
    "but it may be time - consuming to identify such constraints , and by enlarging the model the solution process may slow down .",
    "on the other hand , several papers on approximation theory following  @xcite have shown the tightness of semidefinite relaxations . however , being tighter , semidefinite programs are more time - consuming to solve than linear programs in practice . hence one has to trade strength for computation time . for some ( large scale ) applications , semidefinite relaxations are well - suited to be used within a branch and bound framework ( see for instance @xcite ) . moreover ,",
    "our intention is not to solve a relaxation at every node of the search tree .",
    "instead , we propose to solve only once a relaxation , before entering the search tree .",
    "therefore , we are willing to make the trade - off in favour of the semidefinite relaxation .    finally , investigating the possibility of using semidefinite relaxations in constraint programming is worthwile in itself . to our knowledge the cross - fertilization of semidefinite programming and constraint programming has not yet been investigated . hence , this paper should be seen as a first step toward the cooperation of constraint programming and semidefinite programming .",
    "in this section we briefly introduce the basic concepts of constraint programming that are used in this paper .",
    "a thorough explanation of the principles of constraint programming can be found in @xcite .",
    "a constraint programming model consists of a set of variables , corresponding variable domains , and a set of constraints restricting those variables . in case of optimization problems , also an objective function is added . in this work",
    "the variable domains are assumed to be finite .",
    "a constraint @xmath0 is defined as a subset of the cartesian product of the domains of the variables that are in @xmath0 .",
    "constraints may be of any form ( linear , nonlinear , logical , symbolic , etcetera ) , provided that the constraint programming solver contains an algorithm to check its satisfiability , or even to identify globally inconsistent domain values .",
    "basically , a constraint programming solver tries to find a solution of the model by enumerating all possible variable - value assignments such that the constraints are all satisfied .",
    "because there are exponentially many possible assignments , constraint propagation is needed to prune large parts of the corresponding search tree .",
    "constraint propagation tries to remove inconsistent values from variable domains before the variables are actually instantiated .",
    "hence , one does nt need to generate the whole search tree , but only a part of it , while still preserving a complete ( exact ) solution scheme .",
    "the general solution scheme is an iterative process in which branching decisions are made , and the effects are propagated subsequently",
    ".    variable and value ordering heuristics , which define the search tree , greatly influence the constraint propagation , and with that the performance of the solver .",
    "if no suitable variable and value ordering heuristics are available , constraint programming solvers often use a lexicographic variable and value ordering , and depth - first search to traverse the tree .",
    "however , when good heuristics are available , they should be applied .",
    "when ` perfect ' value and variable ordering heuristics are followed , it will lead us directly to the optimal solution ( possibly unproven ) .",
    "although perfect heuristics are often not available , some heuristics come pretty close . in such cases , one should try to deviate from the first heuristic solution as little as possible .",
    "this is done by traversing the search tree using a limited discrepancy search strategy ( lds ) @xcite instead of depth - first search .",
    "lds is organized in waves of increasing discrepancy from the first solution provided by the heuristic .",
    "the first wave ( discrepancy 0 ) exactly follows the heuristic .",
    "the next waves ( discrepancy @xmath1 , with @xmath2 ) , explore all the solutions that can be reached when @xmath1 derivations from the heuristic are made .",
    "typically , lds is applied until a maximum discrepancy has been reached , say 3 or 4 .",
    "although being incomplete ( inexact ) , the resulting strategy often finds good solutions very fast , provided that the heuristic is informative . of course",
    "lds can also be applied until all possible discrepancies have been considered , resulting in a complete strategy .      in this section",
    "we briefly introduce semidefinite programming .",
    "a large number of references to papers concerning semidefinite programming are on the web pages @xcite and @xcite .",
    "a general introduction on semidefinite programming applied to combinatorial optimization is given in @xcite and @xcite .",
    "semidefinite programming makes use of positive semidefinite matrices of variables .",
    "a matrix @xmath3 is said to be positive semidefinite ( denoted by @xmath4 ) when @xmath5 for all vectors @xmath6 .",
    "semidefinite programs have the form @xmath7 here @xmath8 denotes the trace of @xmath9 , which is the sum of its diagonal elements , i.e. @xmath10 . the matrix @xmath9 , the cost matrix @xmath11 and the constraint matrices @xmath12 are supposed to be symmetric . the @xmath13 reals @xmath14 and the @xmath13 matrices",
    "@xmath15 define @xmath13 constraints .",
    "we can view semidefinite programming as an extension of linear programming .",
    "namely , when the matrices @xmath16 and @xmath17 are all supposed to be diagonal matrices , the resulting semidefinite program is equal to a linear program , where the matrix @xmath9 is replaced by a non - negative vector of variables @xmath18 . in particular , then a semidefinite programming constraint tr@xmath19 corresponds to a linear programming constraint @xmath20 , where @xmath21 represents the diagonal of @xmath15 .",
    "theoretically , semidefinite programs have been proved to be polynomially solvable to any fixed precision using the so - called ellipsoid method ( see for instance  @xcite ) . in practice , nowadays fast ` interior point ' methods are being used for this purpose ( see  @xcite for an overview ) .",
    "semidefinite programs may serve as a continuous relaxation for ( integer ) combinatorial optimization problems .",
    "unfortunately , it is not a trivial task to obtain a computationally efficient semidefinite program that provides a tight solution for a given problem .",
    "however , for a number of combinatorial optimization problems such semidefinite relaxations do exist , for instance the stable set problem , the maximum cut problem , quadratic programming problems , the maximum satisfiability problem , and many others ( see @xcite for an overview ) .",
    "the skeleton of our solution framework is formed by the constraint programming enumeration scheme , or search tree , as explained in section  [ ssc : cp ] . within this skeleton ,",
    "we want to use the solution of a semidefinite relaxation to define the variable and value ordering heuristics . in this section",
    "we first show how to extract a semidefinite relaxation from a constraint programming model .",
    "then we give a description of the usage of the relaxation within the enumeration scheme .",
    "we start from a constraint programming model consisting of a set of variables @xmath22 , corresponding finite domains @xmath23 , a set of constraints and an objective function . from this model",
    "we need to extract a semidefinite relaxation . in general , a relaxation is obtained by removing or replacing one or more constraints such that all solutions are preserved .",
    "if it is possible to identify a subset of constraints for which a semidefinite relaxation is known , this relaxation can be used inside our framework .",
    "otherwise , we need to build up a relaxation from scratch .",
    "this can be done in the following way .",
    "if all domains @xmath24 are binary , a semidefinite relaxation can be extracted using a method proposed by  @xcite , which is explained below . in general , however , the domains are non - binary . in that case , we transform the variables @xmath25 and the domains @xmath26 into corresponding binary variables @xmath27 for @xmath28 and @xmath29 : @xmath30 we will then use the binary variables @xmath27 to construct a semidefinite relaxation . of course , the transformation has consequences for the constraints also , which will be discussed below .",
    "the method to transform a model with binary variables into a semidefinite relaxation , presented in @xcite , is the following .",
    "let @xmath31 be a vector of binary variables , where @xmath32 is a positive integer .",
    "construct the @xmath33 variable matrix @xmath9 as @xmath34 then @xmath9 can be constrained to satisfy @xmath35 where the rows and columns of @xmath9 are indexed from 0 to @xmath32 .",
    "condition ( [ eq : diag ] ) expresses the fact that @xmath36 , which is equivalent to @xmath37 .",
    "note however that the latter constraint is relaxed by requiring @xmath9 to be positive semidefinite .",
    "the matrix @xmath9 contains the variables to model our semidefinite relaxation .",
    "obviously , the diagonal entries ( as well as the first row and column ) of this matrix represent the binary variables from which we started .",
    "using these variables , we need to rewrite ( a part of ) the original constraints into the form of program  ( [ eq : sdp_general ] ) in order to build the semidefinite relaxation .    in case",
    "the binary variables are obtained from transformation ( [ eq : transform ] ) , not all constraints may be trivially transformed accordingly . especially because the original constraints may be of any form .",
    "the same holds for the objective function . on the other hand , as we are constructing a relaxation , we may choose among the set of constraints an appropriate subset to include in the relaxation .",
    "moreover , the constraints itself are allowed to be relaxed .",
    "although there is no ` recipe ' to transform any given original constraint into the form of program  ( [ eq : sdp_general ] ) , one may use results from the literature @xcite .",
    "for instance , for linear constraints on binary variables a straightforward translation is given in section  [ ssc : sdp ] .",
    "at this point , we have either identified a subset of constraints for which a semidefinite relaxation exists , or built up our own relaxation .",
    "now we show how to apply the solution to the semidefinite relaxation inside the constraint programming framework , also depicted in figure  [ fg : method ] . in general , the solution to the semidefinite relaxation yields fractional values for its variable matrix .",
    "for example , the diagonal variables @xmath38 of the above matrix will be assigned to a value between 0 and 1 .",
    "these fractional values serve as an indication for the original constraint programming variables .",
    "consider for example again the above matrix @xmath9 , and suppose it is obtained from non - binary original variables , by transformation ( [ eq : transform ] ) .",
    "assume that variable @xmath38 corresponds to the binary variable @xmath39 ( for some integer @xmath40 and @xmath41 ) , which corresponds to @xmath42 , where @xmath43 is a constraint programming variable and @xmath44 .",
    "if variable @xmath38 is close to 1 , then also @xmath39 is supposed to be close to 1 , which corresponds to assigning @xmath42 .    hence , our variable and value ordering heuristics for the constraint programming variables are based upon the fractional solution values of the corresponding variables in the semidefinite relaxation .",
    "our variable ordering heuristic is to select first the constraint programming variable for which the corresponding fractional solution is closest to the corresponding integer solution .",
    "our value ordering heuristic is to select first the corresponding suggested value .",
    "for example , consider again the above matrix @xmath9 , obtained from non - binary variables by transformation ( [ eq : transform ] ) .",
    "we select first the variable @xmath43 for which @xmath38 , representing the binary variable @xmath39 , is closest to 1 , for some @xmath44 and corresponding integer @xmath1",
    ". then we assign value @xmath41 to variable @xmath43 .",
    "we have also implemented a randomized variant of the above variable ordering heuristic . in the randomized case ,",
    "the selected variable is accepted with a probability proportional to the corresponding fractional value .",
    "we expect the semidefinite relaxation to provide promising values .",
    "therefore the resulting search tree will be traversed using limited discrepancy search , defined in section  [ ssc : cp ] .",
    "a last remark concerns the solution value of the semidefinite relaxation , which is used as a bound on the objective function in the constraint programming model .",
    "if this bound is tight , which is the case in our experiments , it leads to more propagation and a smaller search space .",
    "this section describes the stable set problem and the maximum clique problem ( see @xcite for a survey ) , on which we have tested our algorithm .",
    "first we give their definitions , and the equivalence of the two problems .",
    "then we will focus on the stable set problem , and formulate it as an integer optimization problem . from this",
    ", a semidefinite relaxation is inferred .",
    "consider an undirected weighted graph @xmath45 , where @xmath46 is the set of vertices and @xmath47 a subset of edges @xmath48 of @xmath49 , with @xmath50 . to each vertex",
    "@xmath51 a weight @xmath52 is assigned ( without loss of generality , we can assume all weights to be nonnegative ) .",
    "a stable set is a set @xmath53 such that no two vertices in @xmath54 are joined by an edge in @xmath47 .",
    "the stable set problem is the problem of finding a stable set of maximum total weight in @xmath49 .",
    "this value is called the stable set number of @xmath49 and is denoted by @xmath55 usually denotes the unweighted stable set number .",
    "the weighted stable set number is then denoted as @xmath56 . in this work , it is not necessary to make this distinction . ] . in the unweighted case ( when all weights are equal to 1 )",
    ", this problem amounts to the maximum cardinality stable set problem , which has been shown to be already np - hard  @xcite .",
    "a clique is a set @xmath57 such that every two vertices in @xmath58 are joined by an edge in @xmath47 .",
    "the maximum clique problem is the problem of finding a clique of maximum total weight in @xmath49 .",
    "this value is called the clique number of @xmath49 and is denoted by @xmath59 is defined similar to @xmath56 and also not distinguished in this paper . ] .",
    "the complement graph of @xmath49 is @xmath60 , with the same set of vertices @xmath61 , but with edge set @xmath62 .",
    "it is well known that @xmath63 .",
    "hence , a maximum clique problem can be translated into a stable set problem on the complement graph .",
    "we will do exactly this in our implementation , and focus on the stable set problem , for which good semidefinite relaxations exist .",
    "let us first consider an integer linear programming formulation for the stable set problem .",
    "we introduce binary variables to indicate whether or not a vertex belongs to the stable set @xmath54 .",
    "so , for @xmath64 vertices , we have @xmath64 integer variables @xmath65 indexed by @xmath51 , with initial domains @xmath66 . in this way , @xmath67 if vertex @xmath1 is in @xmath54 , and @xmath68 otherwise .",
    "we can now state the objective function , being the sum of the weights of vertices that are in @xmath54 , as @xmath69 .",
    "finally , we define the constraints that forbid two adjacent vertices to be both inside @xmath54 as @xmath70 , for all edges @xmath71 .",
    "hence the integer linear programming model becomes : @xmath72    another way of describing the same solution set is presented by the following integer quadratic program @xmath73 note that here the constraint @xmath74 is replaced by @xmath75 , similar to condition  ( [ eq : diag ] ) in section  [ sc : framework ] .",
    "this quadratic formulation will be used below to infer a semidefinite relaxation of the stable set problem .",
    "in fact , both model ( [ eq : ilp_form ] ) and model ( [ eq : quadratic ] ) can be used as a constraint programming model .",
    "we have chosen the first model , since the quadratic constraints take more time to propagate than the linear constraints , while having the same pruning power . to infer the semidefinite relaxation , however , we will use the equivalent model ( [ eq : quadratic ] ) .",
    "the integer quadratic program ( [ eq : quadratic ] ) gives rise to a well - known semidefinite relaxation introduced by lovsz @xcite ( see  @xcite for a comprehensive treatment ) .",
    "the value of the objective function of this relaxation has been named the theta number of a graph @xmath49 , indicated by @xmath76 . for its derivation into a form similar to program  ( [ eq : sdp_general ] )",
    ", we will follow the same idea as in section  [ sc : framework ] for the general case .",
    "as our constraint programming model uses binary variables already , we can immediately define the @xmath77 matrix variable @xmath9 of our relaxation as @xmath78 where the binary vector @xmath79 again represents the stable set , as in section  [ ssc : int_form ] .",
    "first we impose the constraints @xmath80 as described in section  [ sc : framework ] .",
    "next we translate the edge constraints @xmath81 from program  ( [ eq : quadratic ] ) into @xmath82 , because @xmath83 represents @xmath84 . in order to translate the objective function",
    ", we first define the @xmath77 weight matrix @xmath16 as @xmath85 then the objective function translates into @xmath86 .",
    "the semidefinite relaxation thus becomes @xmath87    note that program  ( [ eq : theta1 ] ) can easily be rewritten into the general form of program  ( [ eq : sdp_general ] ) .",
    "namely , @xmath88 is equal to tr@xmath89 where the @xmath77 matrix @xmath90 consists of all zeroes , except for @xmath91 , @xmath92 and @xmath93 , which makes the corresponding right - hand side ( @xmath94 entry ) equal to 0 ( similarly for the edge constraints ) .",
    "the theta number also arises from other formulations , different from the above , see @xcite . in our implementation we have used the formulation that has been shown to be computationally most efficient among those alternatives @xcite . let us introduce that particular formulation ( called @xmath95 in @xcite ) .",
    "again , let @xmath96 be a vector of binary variables representing a stable set . define the @xmath97 matrix @xmath98 where @xmath99 .",
    "furthermore , let the @xmath100 cost matrix @xmath101 be defined as @xmath102 for @xmath103 .",
    "observe that in these definitions we exploit the fact that @xmath104 for all @xmath51 .",
    "the following semidefinite program @xmath105 has been shown to also give the theta number of @xmath49 , see @xcite .",
    "when ( [ eq : theta2 ] ) is solved to optimality , the scaled diagonal element @xmath106 ( a fractional value between 0 and 1 ) serves as an indication for the value of @xmath65 ( @xmath51 ) in a maximum stable set ( see for instance @xcite ) .",
    "again , it is not difficult to rewrite program ( [ eq : theta2 ] ) into the general form of program  ( [ eq : sdp_general ] ) .",
    "program  ( [ eq : theta2 ] ) uses matrices of dimension @xmath64 and @xmath107 constraints , while program  ( [ eq : theta1 ] ) uses matrices of dimension @xmath108 and @xmath109 constraints .",
    "this gives an indication why program  ( [ eq : theta2 ] ) is computationally more efficient .",
    "all our experiments are performed on a sun enterprise 450 ( 4 x ultrasparc - ii 400mhz ) with maximum 2048 mb memory size , on which our algorithms only use one processor of 400mhz at a time . as constraint programming solver we use the ilog solver library , version 5.1 @xcite . as semidefinite programming solver",
    ", we use csdp version 4.1 @xcite , with the optimized atlas 3.4.1 @xcite and lapack 3.0 @xcite libraries for matrix computations .",
    "the reason for our choices is that both solvers are among the fastest in their field , and because ilog solver is written in c++ , and csdp is written in c , they can be hooked together relatively easy .",
    "we distinguish two algorithms to perform our experiments .",
    "the first algorithm is a sole constraint programming solver , which uses a standard enumeration strategy .",
    "this means we use a lexicographic variable ordering , and we select domain value 1 before value 0 .",
    "the resulting search tree is traversed using a depth - first search strategy . after each branching decision",
    ", its effect is directly propagated through the constraints . as constraint programming model",
    "we have used model ( [ eq : ilp_form ] ) , as was argued in section  [ ssc : int_form ] .",
    "the second algorithm is the one proposed in section  [ sc : framework ] .",
    "it first solves the semidefinite program ( [ eq : theta2 ] ) , and then calls the constraint programming solver . in this case",
    ", we use the randomized variable ordering heuristic , defined by the solution of the semidefinite relaxation .",
    "the resulting search tree is traversed using a limited discrepancy search strategy .",
    "in fact , in order to improve our starting solution , we repeat the search for the first solution @xmath64 times , ( where @xmath64 is the number of variables ) , and the best solution found is the heuristic solution to be followed by the limited discrepancy search strategy",
    ".      we will first identify general characteristics of the constraint programming solver and the semidefinite programming solver applied to stable set problems .",
    "it appears that both solvers are highly dependent on the edge density of the graph , i.e. @xmath110 for a graph with @xmath64 vertices and @xmath13 edges .",
    "we therefore generated random graphs on 30 , 40 , 50 and 60 vertices , with density ranging from 0.01 up to 0.95 .",
    "our aim is to identify the hardness of the instances for both solvers , parametrized by the density . based upon this information",
    ", we can identify the kind of problems our algorithm is suitable for .",
    "we have plotted the performance of both solvers in figure  [ fg : perf_cp ] and figure  [ fg : perf_sdp ] . here",
    "the constraint programming solver solves the problems to optimality , while the semidefinite programming solver only solves the semidefinite relaxation .",
    "for the constraint programming solver , we depict both the number of backtracks and the time needed to prove optimality . for the semidefinite programming solver we only plotted the time needed to solve the relaxation .",
    "namely , this solver does not use a tree search , but a so - called primal - dual interior point algorithm . note that we use a log - scale for time and number of backtracks in these pictures .    from these figures",
    ", we can conclude that the constraint programming solver has the most difficulties with instances up to density around 0.2 . here",
    "we see the effect of constraint propagation . as the number of constraints increases",
    ", the search tree can be heavily pruned . on the other hand ,",
    "our semidefinite relaxation suffers from every edge that is added . as the density increases , the semidefinite program increases accordingly , as well as its computation time .",
    "fortunately , for the instances up to 0.2 , the computation time for the semidefinite relaxation is very small .",
    "consequently , our algorithm is expected to behave best for graphs that have edge density up to around 0.2 . for graphs with a higher density",
    ", the constraint programming solver is expected to use less time than the semidefinite programming solver , which makes the application of our method unnecessary .",
    "our first experiments are performed on random weighted and unweighted graphs .",
    "we generated graphs with 50 , 75 , 100 , 125 and 150 vertices and edge density from 0.05 , 010 and 0.15 , corresponding to the interesting problem area .",
    "the results are presented in table  [ tb : random ] .",
    "unweighted graphs on @xmath64 vertices and edge density @xmath111 are named ` g@xmath64d@xmath111 ' .",
    "weighted graphs are similarly named ` wg@xmath64d@xmath111 ' .",
    ".computational results on random graphs , with @xmath64 vertices and @xmath13 edges .",
    "all times are in seconds .",
    "the time limit is set to 1000 seconds .",
    "[ cols=\"<,>,>,^,>,^,>,>,>,^,>,^ , > , > , > \" , ]     in table  [ tb : compare ] we compare our method with two methods that are specialized for maximum clique problems .",
    "the first method was presented by stergrd  @xcite , and follows a branch - and - bound approach .",
    "the second method is a constraint programming approach , using a special constraint for the maximum clique problem , with a corresponding propagation algorithm .",
    "this idea was introduced by fahle  @xcite and extended and improved by rgin  @xcite .",
    "since all methods are performed on different machines , we need to identify a time ratio between them .",
    "a machine comparison from spec shows that our times are comparable with the times of stergrd .",
    "we have multiplied the times of rgin with 3 , following the time comparison made in @xcite . in general",
    ", our method is outperformed by the other two methods , although there is one instance on which our method performs best ( san200_0.9_3 ) .",
    "we have presented a method to use semidefinite relaxations within constraint programming .",
    "the fractional solution values of the relaxation serve as an indication for the corresponding constraint programming variables .",
    "moreover , the solution value of the relaxation is used as a bound for the corresponding constraint programming objective function .",
    "we have implemented our method to find the maximum stable set in a graph .",
    "experiments are performed on random weighted and unweighted graphs , structured graphs from coding theory , and on a subset of the dimacs benchmarks set for maximum clique problems .",
    "computational results show that constraint programming can greatly benefit from semidefinite programming .",
    "indeed , the solution to the semidefinite relaxations turn out to be very informative . compared to a standard constraint programming approach , our method obtains far better results .",
    "specialized algorithms for the maximum clique problem however , generally outperform our method .",
    "the current work has investigated the possibility of exploiting semidefinite relaxations in constraint programming .",
    "possible future investigations include the comparison of our method with methods that use linear relaxations , for instance branch - and - cut algorithms .",
    "moreover , one may investigate the effects of strengthening the relaxation by adding redundant constraints .",
    "for instance , for the stable set problem so - called clique - constraints ( among others ) can be added to both the semidefinite and the linear relaxation .",
    "finally , the proof of optimality may be accelerated similar to a method presented in  @xcite , by adding so - called discrepancy constraints to the semidefinite or the linear relaxation , and recompute the solution to the relaxation .",
    "many thanks to michela milano , monique laurent and sebastian brand for fruitful discussions and helpful comments while writing ( earlier drafts of ) this paper . also thanks to the anonymous referees for useful comments .",
    "m.  milano and w.j .",
    "van hoeve .",
    "reduced cost - based ranking for generating promising subproblems . in p.",
    "van hentenryck , editor , _ eighth international conference on the principles and practice of constraint programming ( cp02 ) _ , volume 2470 of _ lncs _ , pages 116 .",
    "springer verlag , 2002 .",
    "m.  laurent and f.  rendl . .",
    "in k.aardal , g.  nemhauser , and r.  weismantel , editors , _ discrete optimization _ , handbooks in operations research and management science .",
    "elsevier , 2004 . also available as technical report pna - r0210 , cwi , amsterdam .",
    "e.  anderson , z.  bai , c.  bischof , l.s .",
    "blackford , j.  demmel , j.j .",
    "dongarra , j.  du croz , a.  greenbaum , s.  hammarling , a.  mckenney , and d.  sorensen . .",
    "siam , third edition , 1999 .",
    "+ http://www.netlib.org / lapack/."
  ],
  "abstract_text": [
    "<S> constraint programming uses enumeration and search tree pruning to solve combinatorial optimization problems . in order to speed up this solution process </S>",
    "<S> , we investigate the use of semidefinite relaxations within constraint programming . in principle </S>",
    "<S> , we use the solution of a semidefinite relaxation to guide the traversal of the search tree , using a limited discrepancy search strategy . </S>",
    "<S> furthermore , a semidefinite relaxation produces a bound for the solution value , which is used to prune parts of the search tree . </S>",
    "<S> experimental results on stable set and maximum clique problem instances show that constraint programming can indeed greatly benefit from semidefinite relaxations . </S>"
  ]
}