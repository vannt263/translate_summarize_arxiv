{
  "article_text": [
    "automata over infinite alphabets have been receiving an increasing amount of attention , see eg @xcite . in these approaches ,",
    "the countably infinite alphabet @xmath0 can be considered as a set of ` names ' , which can be tested only for equality .",
    "typically , languages of interest such as @xmath1 from @xcite are invariant under name - permutations : if eg @xmath2 is in the language , then so is @xmath3 , where @xmath4 stands for the application of the transposition @xmath5 to the word @xmath2 .",
    "this suggests to think of the names as being bound and languages to be closed under @xmath6-equivalence . on the other hand",
    ", we may fix a name @xmath7 and consider the language @xmath8 from @xcite ; we can think of @xmath7 as a free name and of the @xmath9 as bound .",
    "this suggests to study not only words over names , but also words which contain binders and allow us to make explicit the distinction between bound and free names .",
    "automata on words with binders already appear in @xcite in the study of the @xmath10-calculus .",
    "_ in this paper we begin the systematic study of words with binders from the point of view of the classical theory of formal languages and automata . _    in particular , our contributions are :    * _ nominal languages _ of words with binders (   [ sec : nomlang ] ) as a natural generalisation of formal languages over infinite alphabets ; * _ nominal monoids _",
    "(   [ sec : nom - monoid ] ) as the corresponding algebraic structures ; * _ nominal regular expressions _ (   [ nomre : sec ] ) as a generalisation of regular expressions ; * _ hd - automata with stack _ ( hds ) (   [ sec : hdns ] ) and theorem  [ thm : hdnsnre ] showing that nominal regular expressions can be faithfully encoded into hds .    one of the motivations to study words with binders comes from verification .",
    "for instance , consider the needham - schroeder protocol @xmath11 the ( correct ) runs of the protocol can be characterised by a nominal regular expression @xmath12 where the alphabet is now @xmath13 with @xmath14 and @xmath15 a finite set of ` letters ' ; finally , @xmath16 binds all the free occurrences of @xmath17 in @xmath18 and _ generates a fresh name _ @xmath17 . from  ( [ equ : ns ] ) one could obtain an hds  for monitoring the execution of a protocol , i.e.  the hds  would be able to detect if something goes wrong during the execution ( e.g. , an intruder is performing an attack ) . from an automata theoretic point of view , the interesting new feature appears more clearly if we abstract ( [ equ : ns ] ) to @xmath19 and note that binding ( fresh name generation ) @xmath20 appears under the kleene star , which is the reason why automata accepting such languages need to have a stack .",
    "we introduce languages with name binders .",
    "this section appeals to our intuitive understanding of binding and @xmath6-equivalence as known from eg @xmath10-calculus or first - order logic , but see the next section for a formal treatment . to start with",
    ", the _ alphabet _ is divided disjointly into a countably infinite set @xmath0 ( of _ names _ ) and a finite set @xmath21 ( of _ letters _ ) .",
    "an _ m - word _ is a term built from constants @xmath22 , and two binary operations @xmath23 , according to @xmath24 where @xmath17 ranges over @xmath0 and @xmath25 over @xmath26 .",
    "we denote by @xmath27 the set of all m - words .    as in the classical case",
    "we assume that @xmath28 ( the empty word ) is the neutral element wrt @xmath29 and that @xmath29 is associative .",
    "we often write @xmath30 for the concatenation @xmath31 .",
    "furthermore , we let @xmath32 bind the free occurrences of @xmath17 in @xmath33 and take m - words up to @xmath6-equivalence .",
    "the notion of m - word is the _ _",
    "m__ost general notion of word with binders : we only require from words to form a monoid and behave well wrt @xmath6-equivalence . due to the scope introduced by binding",
    ", words now have a tree structure .",
    "this motivates the following , more special , but perhaps more naturally _ _",
    "g__eneralised , notion of words .",
    "a _ g - word _ is a term built from @xmath28 , unary operations @xmath34 , @xmath35 for each @xmath36 , and a binary operation @xmath37 , according to @xmath38 we denote by @xmath39 the set of all g - words .    regarding binding and @xmath6-equivalence",
    ", we follow the same conventions as for m - words . to consider @xmath39 as a monoid",
    ", we define @xmath40 as follows : @xmath41 where @xmath42 is fresh for @xmath43 and @xmath44 is an @xmath6-renaming of @xmath32",
    ". intuitively speaking , we extrude the scope of the binding to the end of the word .",
    "next we allow binders to appear only at the beginning of a word .",
    "an _ l - word _ is a pair @xmath45 where @xmath46 and @xmath47 .",
    "we denote by @xmath48 the set of all l - words .",
    "we interpret @xmath49 as a prefix of name binders and @xmath33 as the part of the word that has no binders .",
    "@xmath50 is given on the left below @xmath51(p , w ) { \\mbox{$\\;\\;\\stackrel{\\mathrm{def}}{=}\\;\\;$}}(np , w)\\ ] ] where we assume that @xmath49 and @xmath52 , @xmath49 and @xmath43 , and @xmath52 and @xmath33 have no names in common .",
    "whereas previously name - binding was built into the syntax via @xmath37 , we now define explicitly , anticipating notation from   [ sec : nom - monoid ] , a binding operation @xmath53\\_\\colon { \\mbox{$\\mathcal{n}$}}\\times{\\mathbf{l}}\\to{\\mathbf{l}}$ ] via the clause on the right of .    an _ s - word _ is a pair @xmath54 where @xmath55 and @xmath56 is a subset of the names appearing in @xmath33 .",
    "we denote by @xmath57 the set of all s - words .",
    "on @xmath57 , we define the two operations @xmath29 and @xmath53\\_$ ] as follows , assuming that @xmath56 and @xmath58 , @xmath56 and @xmath43 , @xmath58 and @xmath33 have no names in common .",
    "@xmath59(s , w ) { \\mbox{$\\;\\;\\stackrel{\\mathrm{def}}{=}\\;\\;$}}\\begin{cases}(s\\cup\\{n\\},w ) & \\text{if $ n$         in $ w$}\\\\ ( s , w ) & \\text{otherwise}\\end{cases } \\end{array}\\ ] ]    [ rmk : slgm ] we have embeddings @xmath60 .",
    "for @xmath61 we assume that names are ordered ; the other main clauses are @xmath62 and @xmath63 .",
    "the somewhat informal treatment of   [ sec : nomlang ] should be sufficient to understand how automata process words with binders in   [ sec : hdns ] and   [ sec : hsnre ] .",
    "on the other hand , from a conceptual point of view , it is important to have a unifying account .",
    "the presence of names and binders suggests to employ nominal sets @xcite .",
    "this not only provides us with a mathematical theory , but also a clear conceptual guidance : follow the classical universal algebraic account of languages and automata , but replace sets by nominal sets . here",
    ", we apply this to languages and monoids .",
    "nominal sets and their logics come in different versions .",
    "we follow @xcite , for which we need to refer to for details .",
    "more details can also be found in @xcite .",
    "let us just recall    denote by @xmath64 the group of permutations of @xmath0 generated from the set of transpositions @xmath65 .",
    "a set @xmath66 equipped with a @xmath64-action @xmath67 is a _",
    "nominal set _ , if every element in @xmath66 is finitely supported .",
    "this means that for each @xmath68 there is finite set @xmath69 ( called a support of @xmath70 ) such that @xmath71 for all @xmath72 ( where @xmath73 denotes the restriction of @xmath74 to @xmath56 ) .",
    "maps between nominal sets are required to be equivariant , that is , they respect the permutation action .",
    "it follows that each element @xmath68 has a minimal support @xmath75 and one writes @xmath76 ( @xmath17 is _ fresh _ for @xmath70 ) for @xmath77 .",
    "this allows us to define abstraction ( * ? ? ?",
    "* lemma 5.1 ) as @xmath78a{\\mbox{$\\;\\;\\stackrel{\\mathrm{def}}{=}\\;\\;$}}\\{(n , a)\\}\\cup\\{(m,(nm)\\cdot a ) \\mid m\\#a\\}$ ] and @xmath79a{\\mbox{$\\;\\;\\stackrel{\\mathrm{def}}{=}\\;\\;$}}\\{[n]a\\mid n\\in{\\mbox{$\\mathcal{n}$ } } , a\\in a\\}$ ] .",
    "a * nominal algebra * @xmath80 , see ( * ? ? ?",
    "* def 4.13 ) , consists of a nominal set @xmath66 , constants @xmath81 , and a map @xmath79a\\to a$ ] . as in universal algebra , further operations and equations may be added :    a _ nominal monoid _ is a nominal algebra @xmath80 with additional constants @xmath82 and ( equivariant ) operations @xmath83 so that @xmath84 is a monoid .",
    "we say that @xmath85 is * closed * , or that @xmath33 contains no free names , if @xmath86 is empty .",
    "write @xmath87 for the class of all nominal monoids .",
    "we consider the following axioms where @xmath88 , @xmath82 , and @xmath89 are variables ranging over carriers of algebras .",
    "@xmath90x{\\circ}y = [ n](x{\\circ}y )   & \\quad\\quad & \\textbf{ax2 } & \\vdash s{\\circ}[m]y = [ m](s{\\circ}y ) \\\\",
    "\\textbf{ax3 } & n\\ # m \\vdash n{\\circ}[m]y = [ m](n{\\circ}y ) & & \\textbf{ax4 } & \\vdash [ n][m]x = [ m][n]x \\\\ \\textbf{ax5 } & n\\ # x \\vdash [ n]x = x & & \\textbf{ax6 } & n\\ # x \\vdash x{\\circ}[n]y = [ n](x{\\circ}y )      \\end{array}\\ ] ] @xmath91 , @xmath92 , @xmath93 are axiomatised by ax1 , ax1 - 3 , ax1 - 5 , respectively .",
    "[ rmk : axioms ] one possible reading of the operations and the axioms is as follows . in @xmath27",
    ", we have sequential composition @xmath29 , allocation @xmath94 of a resource named @xmath17 , and deallocation @xmath95 . in @xmath39",
    ", we do nt care about deallocation ( garbage collection ) . in @xmath48 ,",
    "the timing of the allocation does not matter and all resources may be allocated at the start . in @xmath57 ,",
    "the order of allocation does not matter and the allocation of an unused resource is redundant .",
    "but other interpretations are possible . with",
    "@xmath78 $ ] as the @xmath96 of the @xmath74-calculus and @xmath29 as @xmath97 , ax6 becomes the familiar law of scope extrusion .",
    "interpreting @xmath78 $ ] as @xmath98 , ax4 - 5 are familiar laws of the universal quantifier . in @xcite , a binder satisfying ax4 - 5",
    "is called a name - restriction operator .",
    "we can now summarise the previous section conveniently in table  [ tb : axioms ] and    [ thm : monoids ] @xmath99 are the initial monoids in , respectively , @xmath87 , @xmath91 , @xmath92 and @xmath93 .",
    "the detailed proof can be found in  @xcite .",
    ".summary of nominal monoids and the axioms [ cols=\"^,<,^,<\",options=\"header \" , ]     [ rmk : plain - words ] we have a mapping @xmath100 to * plain words * ( ie words without binders ) determined by @xmath101 . with the embedding @xmath102 from remark  [ rmk : slgm ]",
    "this induces a map @xmath103 from languages of s - words to subsets of @xmath104 , eg @xmath105 .",
    "in analogy to the classical definition , we introduce _ nominal regular expressions _ : @xmath106 where @xmath107 and @xmath108 . the semantic interpretation @xmath109 is defined as follows .",
    "1 .   @xmath110 , @xmath111 , @xmath112 , @xmath113 , 2 .",
    "@xmath114 , 3 .",
    "@xmath115 , 4 .",
    "@xmath116l(e){\\mbox{$\\;\\;\\stackrel{\\mathrm{def}}{=}\\;\\;$}}\\{[n]w\\mid w\\in l(e)\\}$ ] . 5 .",
    "@xmath117 , where @xmath118 ,    [ rmk : nre ] the definitions of @xmath29 and @xmath53\\_$ ] are dependent on the choice of row in table  [ tb : axioms ] , compare , , .",
    "for example , on @xmath27 we have @xmath78l(e ) = \\{{{\\mbox{\\tiny$\\langle\\!\\!\\langle$}}{n } . { w } { \\mbox{\\tiny$\\rangle\\!\\!\\rangle$ } } } \\mid w \\in l(e)\\}$ ] and on @xmath48 we have @xmath78l(e ) = \\{(np , w ) \\mid ( p , w ) \\in l(e)\\}$ ] . from ",
    "[ sec : hdns ] onwards , we will interpret regular expressions in @xmath27 only .",
    "[ exle : lang - bind ] we have seen in how @xmath119 arises from the needham - schroeder protocol . in ",
    "[ sec : hsnre ] we consider the simpler expression @xmath120 which intuitively represent the computations of a security protocol where ( an unbound number of ) new ` nonces ' @xmath17 are generated within a session @xmath121 and should always be paired up with @xmath121 .",
    "we can also interpret nominal regular expressions in plain words .",
    "for example , let @xmath109 take values in @xmath57 and let @xmath122 denote the map of remark  [ rmk : plain - words ] .",
    "[ exle : tzev - lang ] if we interpret @xmath123 in @xmath57 ( or @xmath48 or @xmath39 ) we obtain the language @xmath124 which is the complement of @xmath125 from .",
    "@xmath126 is not recognised by the fmas of @xcite but it is recognised by the fras of @xcite .",
    "the latter notes that @xmath127 shows that languages recognised by fras are not closed under composition . on the other hand",
    ", the presence of binders allows us to use @xmath29 ( respecting the hidden binders ) instead of @xmath128 and we obtain @xmath129 , where the second equality is our definition of ` nominal concatenation ' on languages of plain words .",
    "this indicates that even for languages without binders the composition with binders is a natural concept .",
    "similarly , if we interpret @xmath130 in @xmath27 we obtain another example of tzevelekos : @xmath131",
    "we build our nominal automata theory on hda  ( after _ history - dependent automata _ )  @xcite .",
    "hda  are a computational model of nominal calculi defined on the notion of _ named sets _ and extend classical automata with finite sets of names _ local _ to states and transitions .",
    "we equip hda  with stack ; this renders them suitable for recognising nominal languages interpreted in @xmath27 .",
    "we argue that hda  are natural candidates to build a theory of automata of nominal languages with binders .",
    "in fact , they are equipped with mechanisms to capture name restriction of nominal calculi  @xcite and formally linked to the nominal set theory in  @xcite .",
    "let @xmath132 be a distinguished name ; a _ stack _ @xmath133 is a sequence of finite partial maps @xmath134 ( we use @xmath135 to denote the empty map ) .",
    "the empty stack is denoted by @xmath136 , a stack with head @xmath137 is written @xmath138 , and @xmath139 respectively are the pop , pop twice , and top operations .",
    "[ def : nset ] a _ ( basic ) named set _ @xmath140 is a set @xmath141 ( of states ) with a map @xmath142 sending @xmath143 to a finite set of names @xmath144 ( called _ local names of @xmath52 _ ) .     basically , the elements @xmath52 of a named set are equipped with a set of _ local _ names @xmath144 .",
    "hereafter we omit subscripts when clear from the context and write a named set @xmath140 as @xmath141 , in which case @xmath145 is understood as the map of local names of @xmath141 ; also , the _ update of a map @xmath146 at @xmath147 with @xmath148 _ is the map @xmath149 } : x \\cup \\{x\\ } \\to y \\cup \\{y\\ } \\quad \\text { such that } \\quad ( f{[{x } \\mapsto { y}]})(a ) = \\left\\{\\begin{array}{ll }      f(a ) , & \\text{if } a \\neq x      \\\\      y ,   & \\text{if } a = x \\end{array}\\right.\\ ] ]    before giving the formal definition , we intuitively present hda  with stack .",
    "a transition @xmath150 from a state @xmath52 consists of the target state @xmath151 , a label @xmath6 , and a map @xmath137 keeping track of the correspondences of names .",
    "labels @xmath6 can be a local name @xmath152 of the source state @xmath52 , letters @xmath153 , or any of the distinguished symbols @xmath154 respectively representing internal transitions , push , pop , _ name allocation _ , and _",
    "name deallocation_. example  [ ex : hdns ] gives a convenient graphical representation of an hds .",
    "[ ex : hdns ] let @xmath155 , @xmath156 , and @xmath157 be states with @xmath158 , @xmath159 , and @xmath160 .",
    "the hds        has initial ( resp .",
    "final ) state @xmath155 ( resp .",
    "@xmath157 ) . both @xmath155 and @xmath161 have a transition exposing their ( unique ) local name ( @xmath162 and @xmath163 respectively ) . maps among local names are represented by dashed arrows . also , @xmath161 has @xmath164 transition to @xmath157 with the empty map of local names .",
    "[ def : hd - automaton ] a ( non - deterministic ) _ history - dependent automaton with stack on @xmath165 _ ( hds ) is a tuple @xmath166 where    * @xmath141 is a named set of _ states _ ( the states of the automaton ) ; * @xmath167 is the _ initial state _ ; * @xmath168 is a partial function from @xmath169 to @xmath0 ; * @xmath170 is the named set of _ final states _ with @xmath171 being the restriction of @xmath172 to @xmath173 ; * @xmath174 is the _ transition function _ returning for each @xmath143 a finite set @xmath175 of _ transitions _ , namely tuples @xmath150 such that * * if @xmath176 then @xmath177 * * if @xmath178 then @xmath179 * * if @xmath180 then @xmath181 * * otherwise @xmath182 + and , in either case , @xmath137 is a partial injective map ( see remark  [ rmk : eta ] on page  ) .",
    "transitions in def  [ def : hd - automaton ] allow hds  to accept names or letters or to manipulate the stack .",
    "besides the usual _ push _ ( @xmath183 ) and _ pop _ ( @xmath164 ) operations , hds  feature allocation ( @xmath184 ) and deallocation ( @xmath95 ) of names .",
    "[ hdns : ex ] let @xmath185 , @xmath186 .",
    "the hds   @xmath187 where @xmath188 formally defines the hds  in example  [ ex : hdns ] ( where @xmath168 is not represented for simplicity ) .",
    "we now define how hds  can recognise languages of @xmath27 .",
    "hereafter , we fix an hds@xmath189 and , for any stack @xmath133 and any name mapping @xmath137 , we define @xmath190 by @xmath191 } \\circ \\sigma } : : ( { \\stackrel{{\\curvearrowleft}}{{\\sigma}}})\\ ] ] that basically updates @xmath133 by post - composing its top map @xmath192 ( if any ) with @xmath137 . note that this requires @xmath192 to be updated to allow composition when @xmath193 .",
    "a _ configuration of @xmath194 _ in  ( [ eq : h ] ) is a triple @xmath195 where @xmath143 , @xmath33 is an @xmath27 , and @xmath133 is a stack .",
    "initial _ a configuration @xmath196 and _ accepting _",
    "@xmath197 if @xmath198 .",
    "[ def : hdstep ] given @xmath199 and two configurations @xmath200 and @xmath201 , @xmath194 in  ( [ eq : h ] ) _ moves from @xmath202 to @xmath203 _ ( written @xmath204 ) iff there is @xmath205 such that either of the following cases applies @xmath206 } ) \\circ \\sigma }      \\\\",
    "\\alpha = { \\mbox{\\tiny$\\rangle\\!\\!\\rangle$ } } & \\implies      w = \\ { \\mbox{\\tiny$\\rangle\\!\\!\\rangle$}}w ' \\ \\land \\      { \\sigma } ' = \\sigma ' : : { \\stackrel{2{\\curvearrowleft}}{{\\sigma } } } , \\text { where }      \\sigma ' = { { { { \\stackrel{{\\curvearrowleft}}{{\\sigma}}}}^\\top } \\circ \\sigma }    \\end{cases}\\ ] ]    the set @xmath207 of states reached by @xmath194 from @xmath202 on @xmath33 is defined as @xmath208 a _ run of @xmath194 on an m - word @xmath33 _ is a sequence of moves of @xmath194 from @xmath209 .    intuitively , hds  `` consume '' the word in input _ moving _ from one configuration to another ( likewise classical automata ) . however , when the current word starts with a name @xmath17 , the automaton can progress only if the name `` is known '' ; namely , it is necessary to find a transition from the current state @xmath52 for which the stack maps a local name of @xmath52 to @xmath17 .",
    "hds  use a stack ( @xmath210 ) to keep track of the names of the current state and , noticeably , ( @xmath211 ) to ( de)allocate bound names in input strings .",
    "more precisely , a binder is consumed using a @xmath184 transition which updates the meaning of the names .",
    "this is basically done by post - composing the mapping @xmath137 in the selected transition with the map on the top of the stack ( opportunely updated to take into account the allocation of @xmath17 ) . instead",
    ", a @xmath95 transition will pop the stack so reassigning previous meanings to names in the current state by post - composing the map @xmath137 of the transition with `` the second one '' in the stack .",
    "an automaton @xmath194 recognises @xmath33 if it has a run from its initial state to a final state that consumes @xmath33 .",
    "[ alang : def ] the hds  @xmath194 in  ( [ eq : h ] ) _ accepts _ ( or _ recognises _ ) @xmath33 if @xmath212 .",
    "the _ language of @xmath194 _ ( written @xmath213 ) is the set of words accepted by @xmath194 .    if @xmath214 is the hds  in example  [ hdns : ex ] and @xmath215 , then @xmath216 .",
    "defs  [ def : hdstep ] and  [ alang : def ] contain some subtleties worth spelling out .",
    "first , observe that the language recognised by @xmath194 depends on @xmath168 which intuitively sets the meaning of the local names of the initial state @xmath217 ; instead , the language of @xmath194 does not depend on the identities of the local names of the states in @xmath218 .",
    "secondly , an alternative definition would allow the initial stack to be empty and the correspondence between local names of the states of @xmath194 and those in the input word is incrementally built during recognition .",
    "this class of hdss would be equivalent to the one in defs  [ def : hd - automaton ] and  [ def : hdstep ] , but it would have made our constructions more complex . finally , as for classical push - down automata , we could have equivalently required that an hds  recognises an m - word @xmath33 only when it has a run leading to a final state that consumes @xmath33 and empties the stack .",
    "we opted for def  [ alang : def ] as it is conceptually simpler .",
    "for instance , the following lemma ( used to prove proposition  [ prop : h * ] ) states that only the top of the stack is relevant for accepting words .",
    "[ lemma : top ] any configuration reachable by an hds  as in  ( [ eq : h ] ) from @xmath219 is also reachable from @xmath220 for any stack @xmath133 .    in ",
    "[ sec : hsnre ] we show how a nominal regular expression @xmath18 can be mapped on an hds  @xmath221 that recognises the language of @xmath18 . theorem  [ thm : hdnsnre ] is the main result    [ thm : hdnsnre ] for each nominal regular expression @xmath18 , @xmath222 interpreted on @xmath27 .",
    "the proof is by induction on the structure of @xmath18 .",
    "the base cases are trivial while the other cases follow by propositions  [ prop : hdsum ] , [ prop : h1h2 ] , [ prop : h * ] , and  [ prop:[n]h ] .",
    "we use nominal regular expressions  ( [ eq : nre ] ) to establish a correspondence between hds  and nominal formal languages .",
    "more precisely , we give ( def  [ def : nretohdns ] ) the map mentioned in theorem  [ thm : hdnsnre ] as the homomorphic image of nominal regular expression on an algebra of hds  given in the rest of this section .",
    "[ def : nretohdns ] the map @xmath223 from nominal regular expressions to hds is defined as : @xmath224 { \\llparenthesis e \\rrparenthesis }    \\end{aligned}\\ ] ] where the operations on hds  in the last four cases are defined in the following .",
    "the operations on hds  in def  [ def : nretohdns ] allow to combine them so that the language of the resulting hds  has a clear relation with those the operations act upon as per propositions  [ prop : hdsum ] , [ prop : h1h2 ] , [ prop : h * ] , and  [ prop:[n]h ] below .",
    "theorem  [ thm : hdnsnre ] can be proved by induction on the structure of nominal regular expressions using such propositions .",
    "[ rmk : nretohdns ] the map @xmath223 in def  [ def : nretohdns ] depends on the choice of local names ; however , as noted in ",
    "[ sec : hdns ] , recognisability does not depend on the identity of such names .",
    "the first two clauses in def  [ sec : hsnre ] do not involve names and stack . notably , the third clause states that the hds  corresponding to an expression @xmath17 has simply a transition from the initial to accepting state and in the initial configuration the unique name of the former is mapped to @xmath17 .",
    "the set @xmath225 of _ ( local ) names _ of an hds@xmath194 as in  ( [ eq : h ] ) is defined as @xmath226 . in the following , we fix two hds@xmath227 and , without loss of generality , we assume that @xmath228 and @xmath229 .",
    "[ def : hdsum ] let @xmath230 be a new state .",
    "we define @xmath231 to be the automaton @xmath232 where    * @xmath233 where @xmath234 and @xmath235 * @xmath236 and @xmath237 for @xmath238 , where @xmath239 is the identity from @xmath240 to @xmath241 * @xmath242 , namely @xmath243 if @xmath244 .",
    "[ prop : hdsum ] @xmath245    the statement trivially follows from def  [ def : hdstep ] as ( i ) @xmath217 has only two outgoing @xmath28-transitions which lead to the initial states of either of @xmath246 or @xmath247 and ( ii ) @xmath168 preserves the name assignments @xmath248 and @xmath249 .",
    "[ lemma : uniquefinal ] for each hds  @xmath194 there is an hds  @xmath250 with a unique final states and such that @xmath251 .    given @xmath194 in  ( [ eq : h ] ) and",
    "@xmath252 such that @xmath253 , we define @xmath254 where @xmath255 , @xmath256 when restricted to @xmath257 , and @xmath258 for each @xmath198 .",
    "the proof that @xmath259 is similar to the proof of proposition  [ prop : hdsum ] .",
    "lemma  [ lemma : uniquefinal ] allows , without loss of generality , @xmath194 in  ( [ eq : h ] ) and each of @xmath246 and @xmath260 in  ( [ twohdns : eq ] ) to have a single final state , namely @xmath261 , @xmath262 and @xmath263 , respectively .",
    "the following construction extends the names of an hds  without altering its language and is used in def  [ def : hdcomp ] .",
    "[ def : hdaddname ] given @xmath194 as in  ( [ eq : h ] ) and @xmath264 , @xmath265 is the hds such that    * @xmath266 is the named set having the same elements of @xmath141 with @xmath267 * @xmath268 is the named set with the same states of @xmath173 and @xmath269 * @xmath270 } ) { \\ \\ \\big| \\ \\ } ( q',\\alpha,\\sigma ) \\in { \\mathit{tr}}(q)\\}$ ] * @xmath271 is the partial map undefined on @xmath147 and behaving as @xmath168 otherwise .",
    "hereafter , we assume that @xmath272 when writing @xmath273 ; in fact , by the locality of the names in the states of an hds , if @xmath52 is a state of @xmath194 such that @xmath274 , we can replace @xmath147 with any name not in @xmath275 by rearranging all the maps in the transitions reaching @xmath52 .",
    "[ prop : hdaddname ] @xmath276 .",
    "the proof that @xmath277 is trivial as all the transitions of @xmath194 have a correspondent in @xmath273 with exactly the same labels and name mappings .",
    "the converse also hold trivially as @xmath147 can not play any role in the recognition of a word in @xmath273 as @xmath278 is not defined on @xmath147 .",
    "[ def : hdcomp ] let @xmath279 and @xmath280 .",
    "the hds  @xmath281 is defined as @xmath282 where @xmath283 and @xmath284    the hds  @xmath285 is built by connecting the accepting state of @xmath286 to @xmath287 , the initial state of @xmath288 , after adding @xmath289 to @xmath286 . note that the newly introduced @xmath28-transition maintains the initial meaning of the names in @xmath289 since @xmath290 acts as @xmath278 on @xmath289 ( and by def  [ def : hdaddname ] ) .",
    "[ rmk : eta ] a definition more complex than def  [ def : hdcomp ] can be given to preserve the injectivity of the initial mapping @xmath290 when @xmath248 and @xmath249 are injective . this requires to relax the injectivity condition on @xmath137 in def  [ def : hd - automaton ] requiring @xmath291 for any @xmath292 .",
    "we opted for the simpler def  [ def : hdcomp ] as it just allows more non - determism without altering the expressiveness of hds .",
    "[ prop : h1h2 ] @xmath293 .",
    "the automaton @xmath281 reaches a final state iff @xmath294 where @xmath295 for @xmath296 .",
    "in fact , to reach @xmath297 it is necessary to reach @xmath298 first and the unique transition from @xmath298 to @xmath287 maintains on the stack the meaning assigned to the names @xmath289 as per the stack .",
    "[ def : h * ] let @xmath194 be as in  ( [ eq : h ] ) with @xmath299 .",
    "the hds  @xmath300 is such that @xmath301    the construction of @xmath302 simply adds an @xmath28-transition from @xmath217 ( the initial state of @xmath194 ) to @xmath303 ( the accepting state of @xmath194 ) and a @xmath183-transition from @xmath303 to @xmath217 that re - establish the mapping of the initial configuration preserving in the stack the meaning of the names .",
    "[ prop : h * ] @xmath304    ( sketch . ) first , observe that trivially @xmath305 because @xmath306 has a transition @xmath307 from @xmath217 .",
    "we now prove that @xmath308 . if @xmath309 then @xmath310 reaches a configuration @xmath311 for a suitable @xmath133 . by construction and def  [ def : hdstep ]",
    ", @xmath306 can visit @xmath312 only a finite number of times @xmath313 .",
    "hence , @xmath314 where @xmath315 is the word processed between the @xmath210-th visit of @xmath312 and the previous visit of @xmath312 ( or of @xmath217 if @xmath316 ) .    observing that each visit of @xmath312 is preceded by a visit of @xmath303 ( since @xmath312 can only be reached trough @xmath303 ) , we have that @xmath317 ( and hence in @xmath318 ) because there @xmath303 can be reached from the configuration @xmath319 . for the same reason",
    ", we can conclude that @xmath320 for each @xmath321 ; in fact , the @xmath210-th visit of @xmath312 yields @xmath306 in the configuration @xmath322 for some stack @xmath133 .",
    "hence , using the unique transition @xmath323 from @xmath312 , the automaton `` resets '' to the configuration @xmath324 , which basically amounts to say that @xmath315 can be recognised by @xmath325 and the next work @xmath326 is processed from a configuration where @xmath168 is on the top of the stack and the thesis follows by lemma  [ lemma : top ] .",
    "we prove that @xmath327 .",
    "any word @xmath328 has the form @xmath329 where @xmath330 for each @xmath331 , so we proceed by induction on @xmath313 . if @xmath332 the thesis follows trivially .",
    "if @xmath333 then , from the configuration @xmath334 , @xmath306 reaches a configuration @xmath335 since @xmath317 by hypothesis . since @xmath336 , the configuration @xmath337 is reachable from @xmath306 .",
    "therefore , @xmath306 reaches the configuration @xmath338 which yields the thesis by lemma  [ lemma : top ] .",
    "[ def:[n]h ] let @xmath107 , @xmath194 be as in  ( [ eq : h ] ) with @xmath339 , and let @xmath340 be new states with @xmath341 and @xmath342 .",
    "the hds  @xmath78\\mathcal h = { \\langleq \\cup \\{\\hat q , \\hat q_f\\ } , \\hat      q , \\eta|_{{|\\hat q| } } , \\{\\hat q_f\\ } , { \\mathit{tr}}'\\rangle}$ ] is such that @xmath343 where @xmath344}$ ] , if @xmath345 , otherwise @xmath346 .",
    "[ prop:[n]h ] @xmath347\\mathcal h } } = [ n]{\\mathcal{l}_{h}}$ ] .    by construction",
    ", @xmath348 reaches @xmath349 iff there is a word @xmath350 such that @xmath351 and @xmath352 reaches reaches @xmath349 where @xmath353 is built as in def  [ def : hdstep ] .",
    "again by construction , this is possible iff @xmath354 visits @xmath303 and the last transition which consumes the word is a ( deallocation ) @xmath95-transition from @xmath303 to @xmath355 .",
    "this is equivalent to say that there is @xmath356 such that @xmath357 which , by remark[rmk : nre ] , yields the thesis .",
    "we build the hds  @xmath358 corresponding to the expression @xmath120 by applying the constructions of   [ sec : hsnre ] . by definition  [ def : nretohdns ] , the hds  corresponding to the expression @xmath121 is @xmath359 with @xmath360 where @xmath361 , @xmath362 , @xmath363 , @xmath364 , and @xmath365 .",
    "analogously , the hds  corresponding to the expression @xmath17 is @xmath366 with @xmath367 where @xmath368 , @xmath369 , @xmath370 , @xmath371 , and @xmath372 .    to compose @xmath359 and @xmath366",
    ", we first have to compute @xmath373 ; by def  [ def : hdaddname ] , @xmath374 where @xmath375 and @xmath376    by def  [ def : hdcomp ] , @xmath377 where @xmath378 , @xmath379    we now build @xmath380({\\mathcal h_{{\\llparenthesis m \\rrparenthesis } } } \\circ { \\mathcal h_{{\\llparenthesis n \\rrparenthesis}}})$ ] ; let @xmath381 and @xmath382 be two new states with @xmath383 and @xmath384 , as prescribed by def  [ def:[n]h ] , we have @xmath385 } , { \\mathsf{q}}_s , \\eta_{[n ] } , \\{{\\mathsf{q}}_t\\ } ,    { \\mathit{tr}}_{[n]}\\rangle}$ ] where @xmath386 } = { { \\cal q}}_\\circ \\cup \\{{\\mathsf{q}}_s , { \\mathsf{q}}_t\\}$ ] and the initial setting @xmath387}$ ] by restricting @xmath388 on @xmath389 , i.e.  @xmath387 } \\colon { \\mathsf{x}}\\mapsto m$ ] ; moreover , @xmath390 } \\colon \\begin{cases }    { \\mathsf{q}}_s \\mapsto \\ { { { \\langle{\\mathsf{q}}_{0,\\dag},{\\mbox{\\tiny$\\langle\\!\\!\\langle$}},\\sigma\\rangle } } \\ } , & \\text{where } { \\mathit{dom}(\\sigma ) } = \\{{\\mathsf{x}},{\\mathsf{y}}\\ } \\text { and } \\sigma({\\mathsf{x } } ) = { \\mathsf{y}}\\text { and } \\sigma({\\mathsf{y } } ) = { \\star}\\\\    { \\mathsf{q}}_{f , n } \\mapsto \\{{{\\langle{\\mathsf{q}}_t,{\\mbox{\\tiny$\\rangle\\!\\!\\rangle$}},\\bot\\rangle } } \\ }    \\\\    { \\mathsf{q}}\\mapsto { \\mathit{tr}}_\\dag({\\mathsf{q } } ) , & \\text{if } { \\mathsf{q}}\\in { { \\cal q}}_\\dag \\setminus \\{{\\mathsf{q}}_{f , n}\\ } \\end{cases}\\ ] ]    further , by def  [ def : h * ] , @xmath391 is obtained by adding two extra transitions @xmath392 and @xmath393}\\rangle}}\\}$ ] .",
    "finally , by def  [ def : hdcomp ] , we obtain the hds  @xmath394 as follows .",
    "first , let @xmath395 be obtained as in  ( [ eq : hm ] ) by defining @xmath396 , @xmath397 , @xmath398 , @xmath399 , and @xmath400 .",
    "then , we set @xmath401 where @xmath402 } \\cup \\{{\\mathsf{q}}_{0,m}',{\\mathsf{q}}_{f , m}'\\}$ ] and @xmath403}({\\mathsf{q } } ) , & \\text{if } { \\mathsf{q}}\\in { { \\cal q}}_{[n ] }    \\\\    { \\mathsf{q}}_{0,m } ' \\mapsto { \\mathit{tr}}_m'({\\mathsf{q}}_{f , m } ' ) \\cup \\{{{\\langle{\\mathsf{q}}_{f , m}',{\\epsilon},\\bot\\rangle}}\\ }    \\\\    { \\mathsf{q}}_{f , m } ' \\mapsto { \\mathit{tr}}_m'({\\mathsf{q}}_{f , m } ' ) \\cup \\{{{\\langle{\\mathsf{q}}_s,{\\epsilon},{\\mathsf{y}}\\mapsto { \\mathsf{y}}\\rangle}}\\ } \\end{cases}\\ ] ]",
    "we conclude with some final remarks .",
    "equivalent definitions could have been adopted ; for instance , @xmath168 above is not required to be injective ( adding some non - determinism in def  [ def : hdstep ] ) or some of the new states introduced by the constructions above could be avoided to obtain more compact hds .",
    "we decided to use conceptually simpler constructions instead of more effective , but more complex ones .",
    "this paper developed the beginnings of a general theory of words with binders : nominal languages , nominal monoids , nominal regular expressions , hd - automata with stacks .",
    "we sketch some further work .",
    "coming back to table  [ tb : axioms ] further classes maybe relevant , for example words satisfying ax4 - 5 but not ax1 - 3 ; it will also be of interest to mix different binders each obeying its own axioms plus further axioms of their interaction .",
    "hd - automata with stacks are more powerful than necessary if one is only interested in recognising regular languages ; a restricted class of hd - automata characterising regular languages of m - words can be described ; the same should be done for g - words , l - words , and s - words ."
  ],
  "abstract_text": [
    "<S> we introduce formal languages over infinite alphabets where words may contain binders . </S>",
    "<S> we define the notions of nominal language , nominal monoid , and nominal regular expressions </S>",
    "<S> . moreover , we extend history - dependent automata ( hd - automata ) by adding stack , and study the recognisability of nominal languages . </S>"
  ]
}