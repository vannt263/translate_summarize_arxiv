{
  "article_text": [
    "a first step towards the construction of runge - kutta methods is the calculation of the order conditions that the coefficients have to obey . in the old days they were obtained by expanding the error term in a taylor series by hand , a procedure which for higher orders sooner or later runs into difficulties because of the largely increasing combinatorial complexity .",
    "it was a major break - through when butcher @xcite published 1963 his result of systematically describing order conditions by rooted trees .",
    "the proof of this result has evolved very much in meantime , mainly under the influence of butcher s later work @xcite and the contributions of hairer and wanner @xcite . in this paper",
    "we will present a simple and elementary proof of butcher s theorem by using very consequently the recursive structure of rooted trees . this way we avoid lengthy calculations of combinatorial coefficients ,",
    "the use of tree - labelings , or fa di bruno s formula as in @xcite .",
    "our proof is very similar in spirit to the presentation of @xmath0-series by hairer in chapter 2 of his lecture notes @xcite .",
    "as early as 1976 jenks @xcite posed the problem of automatically generating order conditions for runge - kutta methods using computer algebra systems , but no replies were received . in 1988 keiper of wolfram research concluded that the method of automatically calculating taylor expansions by brute force was bound to be very inefficient .",
    "naturally he turned to the elegant results of butcher s . utilizing them",
    ", he wrote the _ mathematica _ package butcher.m , which has been available as part of the standard distribution of _ mathematica _ since then .",
    "this package was later considerably improved by sofroniou @xcite and offers a lot of sophisticated tools .    while teaching the simple proof of butcher s result in a first course on numerical odes , the author realized that the underlying recursive structure could also be exploited for a simple and elegant computer implementation .",
    "this approach differs from the work of sofroniou in various respects .",
    "we will present the full source code in _ mathematica _ and some applications .",
    "the runge - kutta methods are one - step discretizations of initial - value problems for systems of @xmath1 ordinary differential equations , @xmath2 where the right - hand side @xmath3\\times \\omega \\subset { { \\mathbb r}}\\times { { \\mathbb r}}^d \\to{{\\mathbb r}}^d$ ] is assumed to be sufficiently smooth . the _ continuous evolution _",
    "@xmath4 of the initial - value problem is approximated in steps of length @xmath5 by @xmath6 .",
    "this _ discrete evolution _",
    "@xmath7 is defined as an approximation of the integral - equation representation @xmath8 by appropriate quadrature formulas : @xmath9 the vectors @xmath10 , @xmath11 , are called _ stages _ , @xmath12 is the stage number . following the standard notation",
    ", we collect the coefficients of the method into a matrix and two vectors @xmath13 the method is _ explicit _ , if @xmath14 is strictly lower triangular .",
    "the method has _ order _",
    "@xmath15 , if the error term expands to @xmath16 in terms of the taylor expansion of the error @xmath17 , the vanishing of all lower order terms in @xmath5 just defines the conditions which have to be satisfied by the coefficients @xmath14 , @xmath18 and @xmath19 of a runge - kutta method .",
    "if we choose @xmath20 , it can be shown @xcite , that there is no loss of generality in considering _ autonomous _",
    "systems only , i.e. , those with no dependence of @xmath21 on @xmath22 .",
    "doing so , the expressions @xmath23 and @xmath24 are likewise independent of @xmath22 .",
    "we will write @xmath25 and @xmath26 for short , calling them the _ flow _ and the _ discrete flow _ of the continuous resp . the discrete system .",
    "the taylor expansions of both the phase flow @xmath25 and the discrete flow @xmath26 are linear combinations of _ elementary _ differentials like @xmath27 we will use the short multilinear notation of the left hand side for the rest of the paper .",
    "an elementary differential can be expressed uniquely by the structure of how the subterms enter the multilinear maps .",
    "for instance , looking at the expression @xmath28 we observe that @xmath29 must be a third derivative , since _ three _ arguments make it _ three_-linear",
    ". this structure can be expressed in general by _ rooted trees _ , e.g. , @xmath30 every node with @xmath31 children denotes a @xmath31th derivative of @xmath21 , which is applied as a multilinear map to further elementary differentials , according to the structure of the tree .",
    "we start reading off this structure by looking at the root .",
    "this defines a _ recursive _ procedure , if we observe the following : having removed the root and its edges , a rooted tree @xmath32 decomposes into rooted subtrees @xmath33 with strictly less nodes .",
    "the roots of the subtrees @xmath33 are exactly the @xmath31 children of @xmath32 s root . this way a rooted tree @xmath32 can be defined as the _ unordered _ list of its successors @xmath34,\\qquad \\#\\beta = 1 + \\#\\beta_1 + \\ldots + \\#\\beta_n.\\ ] ] here , we denote by @xmath35 the _ order _ of a rooted tree @xmath32 , i.e. , the number of its nodes .",
    "the root itself can be identified with the _ empty _ list , @xmath36 $ ] .",
    "an application of this procedure shows for the examples above that @xmath37 is expressed by @xmath38 $ ] and @xmath39 is expressed by @xmath40,\\odot]$ ] . the reader will observe the perfect matching of parentheses and commas . in general the relation between a rooted tree @xmath41 $ ] and its corresponding elementary differential @xmath42",
    "is recursively defined by @xmath43 the dot of multiplication denotes the multilinear application of the derivative to the @xmath31 given arguments . due to the symmetry of the @xmath31-linear map @xmath44 , the order of the subtrees @xmath33 does not matter , which means , that @xmath45 depends in a well - defined way on @xmath32 as an unordered list only .    from @xmath36 $ ] we deduce @xmath46 .",
    "analogously , each of the recursive definitions in the following will have a well - defined meaning if applied to the single root @xmath47 $ ] , mostly by using the reasonable convention that empty products evaluate to one and empty sums to zero  a convention that is also observed by most computer algebra systems .",
    "we are now in a position to calculate and denote the taylor expansion of the continuous flow @xmath48 in a clear and compact fashion",
    ".    given @xmath49 the flow @xmath25 expands to @xmath50 the coefficients @xmath51 and @xmath52 belonging to a rooted tree @xmath41 $ ] are recursively defined by @xmath53 by @xmath54 we denote the number of different ordered tuples @xmath55 which correspond to the same unordered list @xmath56 $ ] .",
    "the assertion is obviously true for @xmath57 .",
    "we proceed by induction on @xmath58 . using the assertion for @xmath58 , the multivariate taylor formula and the multilinearity of the derivatives we obtain @xmath59 @xmath60\\\\ \\#\\beta \\leq p+1 } } \\frac{\\#\\beta\\cdot \\tau^{\\#\\beta-1}}{\\beta!}\\ ! \\cdot\\ ! \\underbrace{\\frac{\\delta_\\beta}{n!}\\ , \\alpha_{\\beta_1}\\cdot\\ldots\\cdot\\alpha_{\\beta_n}}_{=\\alpha_\\beta } \\,f^{(\\beta ) } + o(\\tau^{p+1})\\\\ & = \\sum_{\\#\\beta \\leq p+1 } \\frac{\\#\\beta\\cdot \\tau^{\\#\\beta-1}}{\\beta ! }",
    "\\alpha_\\beta\\,f^{(\\beta ) } + o(\\tau^{p+1 } ) . \\end{split}\\ ] ] plugging this into the integral form of the initial value problem we obtain @xmath61 which proves the assertion for @xmath62 .",
    "a likewise clear and compact expression can be calculated for the taylor expansion of the discrete flow .    given",
    "@xmath49 the discrete flow @xmath26 expands to @xmath63 the vector @xmath64 , @xmath65 $ ] , is recursively defined by @xmath66    because of the definition ( [ eq : rk ] ) of the discrete flow we have to prove that the stages @xmath67 expand to @xmath68 this is obviously the case for @xmath57 .",
    "we proceed by induction on @xmath58 . using the assertion for @xmath58 , the definition of the stages @xmath67 , the multivariate taylor formula and the multilinearity of the derivatives we obtain @xmath69 @xmath70\\\\ \\#\\beta \\leq p+1 } }   \\tau^{\\#\\beta-1 } \\cdot \\underbrace{\\frac{\\delta_\\beta}{n!}\\ , \\alpha_{\\beta_1}\\cdot\\ldots\\cdot\\alpha_{\\beta_n}}_{=\\alpha_\\beta } \\cdot\\,{{\\mathcal{a}}}^{(\\beta)}_i \\,f^{(\\beta ) } + o(\\tau^{p+1})\\\\ & = \\sum_{\\#\\beta \\leq p+1 } \\tau^{\\#\\beta-1 } \\alpha_\\beta\\cdot{{\\mathcal{a}}}^{(\\beta)}_i\\,f^{(\\beta ) } + o(\\tau^{p+1 } ) , \\end{split}\\ ] ] which proves the assertion for @xmath62 .    comparing the coefficients of the elementary differentials in the expansions of both the phase flow and the discrete flow",
    ", we immediately obtain butcher s theorem  @xcite .",
    "[ satz : butcher ] a runge - kutta - method @xmath71 is of order @xmath15 for all @xmath72 , if the order conditions @xmath73 are satisfied for all rooted trees @xmath32 of order @xmath74 .",
    "the recursive constructions underlying the proof of butcher s theorem can easily be realized using modern computer algebra systems like _",
    "mathematica_. we assume that the reader is familiar with this particular package .",
    "we begin by defining the recursive data - structure of a rooted tree as an unordered list  together with two simple routines for input and output :    attributes[tree]=\\{orderless , listable } ; + totree[f_]:=tree@@totree/@f ; totree[f_symbol]:=tree [ ] ; + format[@xmath75_tree]:=stringreplace[tostring[list@@@xmath75/.\\{}->``@xmath76 '' ] , + \\{``\\{''->``['',``}''- > `` ] '' } ]    now , here is an example for the input of the tree representing the elementary differential @xmath77 :    @xmath78=totree[f@xmath79[f@xmath80[f , f@xmath81[f]],f ] ] ; @xmath82=totree[f@xmath80[f , f@xmath80[f@xmath81[f],f ] ] ] ; if[@xmath78==@xmath82,@xmath78 , , ]    @xmath83]\\ ] ] the definition ( [ eq : treedef ] ) of the order @xmath84 is simply expressed by the recursive procedure :    treeorder[@xmath85:=1+plus@@treeorder/@@xmath75    as an example , we take the elementary differential @xmath86 :    @xmath75 = totree[f@xmath80[f@xmath87[f@xmath81[f],f@xmath81[f],f],f ] ] ; treeorder[@xmath75 ]    @xmath89    the definition ( [ eq : factorialdef ] ) of @xmath90 is analogously expressed by :     treefactorial[@xmath75_]:=treeorder[@xmath75]times@@treefactorial/@@xmath75    the above used tree @xmath32 of order 8 gives : treefactorial[@xmath75 ] @xmath91    for the sake of completeness we also express the recursive definition  ( [ eq : factorialdef ] ) of @xmath52 using _ mathematica _ :    treealpha[@xmath75_]:=length[permutations[@xmath75]]/length[@xmath75]!times@@treealpha/@@xmath75    an application to the above example yields : treealpha[@xmath75 ] @xmath92    we are now ready to map the recursive definition ( [ eq : abeta ] ) of @xmath93 and of the order condition @xmath94 to _ mathematica _ :    treea[@xmath75_,n_:1]:=(vars=\\{i , j , k , l , m , p , q , r , u , v , w } ; + times@@(sum[a@xmath95,vars[[n+1]]}}$]treea[#,n+1]//evaluate , + \\{vars[[n+1]],s}//evaluate]&/@@xmath75 ) ) + treeordercondition[@xmath75_]:=sum[b@xmath96treea[@xmath75]//evaluate,\\{i , s } ] + = = 1/treefactorial[@xmath75 ]    for convenience , the coordinate index of the vector @xmath93 can be chosen from the list \\{i , j , k , l , m , p , q , r , u , v , w } and is passed by number as the second argument to treea . the order condition belonging to the above example is obtained as follows :    treeordercondition[@xmath75 ]    @xmath97    even the typesetting of this formula was done completely automatically , using _",
    "s ability to generate tex - sources .    to generate all the order conditions for a given order @xmath58",
    ", we need a device that constructs the set of all trees @xmath32 with @xmath98 .",
    "there are , in principle , two different recursive approaches :    * _ root - oriented _ : generate all trees @xmath32 of order @xmath99 by first , listing all integer partitions @xmath100 , @xmath101 , and next , setting @xmath102 $ ] for all trees @xmath33 of order @xmath103 .",
    "these trees have already been generated by the recursion .",
    "* _ leaf - oriented _ : add a leaf to each node of the trees @xmath104 $ ] of order @xmath105 , increasing thereby the order exactly by one .",
    "this can be done recursively by adding a leaf to every node of the subtrees @xmath33 .",
    "the root - oriented approach was chosen by sofroniou  @xcite in his _ mathematica _ package butcher.m .",
    "it requires an efficient integer partition package and the handling of cartesian products .",
    "the leaf - oriented approach is as least as efficient as the other one , but much easier to code :    addleave[@xmath75_]:=addleave[@xmath75]=fold[union,\\{prepend[@xmath75,tree [ ] ] } , + replacepart[@xmath75,addleave[@xmath75[[#]]],#]&/@range[length[@xmath75 ] ] ] + trees[order_]:=nestlist[union@@addleave/@#&,\\{tree[]},order-1 ]    given an order @xmath58 this procedure generates a list of the sets of trees for each order @xmath106 , e.g. , trees[4 ] @xmath107\\},\\{[[\\odot ] ] , [ \\odot , \\odot ] \\ } ,   \\{[[[\\odot ] ] ] , [ [ \\odot , \\odot ] ] , [ \\odot , [ \\odot ] ] , [ \\odot , \\odot , \\odot ] \\}\\}\\ ] ] for instance , the number of trees for each order @xmath108 is given by the entries of the following list : length/@trees[10 ] @xmath109 the number of order conditions for @xmath110 can thus be obtained by : plus@@% @xmath111    finally , for concrete calculations one has to specify the number @xmath12 of stages .",
    "the following procedure then generates the specific set of equations for _ explicit _ runge - kutta methods :     explicit=\\{a@xmath112:>0/;i<=j , c@xmath113->0 } ; + orderconditions[order_,stages_]:= ( + autonomous = table[sum[a@xmath114,\\{j , stages}]==c@xmath96,\\{i , stages } ] ; + \\{(treeordercondition/@union@@trees[order])/.s->stages/. + torules[and@@autonomous],autonomous}/.explicit )    this way , we can automatically generate and typeset the order conditions for the classical explicit 4-stage runge - kutta methods of order  4 :    first[orderconditions[4,4 ] ]    @xmath115 & { b_3}{\\,}{c_2}{\\,}{a_{3,2}}+{b_4}{\\,}({c_2}{\\,}{a_{4,2}}+{c_3}{\\,}{a_{4,3}})==\\frac{1}{6},\\;{b_4}{\\,}{c_2}{\\,}{a_{3,2}}{\\,}{a_{4,3}}==\\frac{1}{24 } ,   \\\\*[2 mm ] & { b_3}{\\,}c_{2}^{2}{\\,}{a_{3,2}}+{b_4}{\\,}(c_{2}^{2}{\\,}{a_{4,2}}+c_{3}^{2}{\\,}{a_{4,3}})==\\frac{1}{12},\\;{b_2}{\\,}c_{2}^{2}+{b_3}{\\,}c_{3}^{2}+{b_4}{\\,}c_{4}^{2}==\\frac{1}{3 } ,   \\\\*[2 mm ] & { b_3}{\\,}{c_2}{\\,}{c_3}{\\,}{a_{3,2}}+{b_4}{\\,}{c_4}{\\,}({c_2}{\\,}{a_{4,2}}+{c_3}{\\,}{a_{4,3}})==\\frac{1}{8},\\;{b_2}{\\,}c_{2}^{3}+{b_3}{\\,}c_{3}^{3}+{b_4}{\\,}c_{4}^{3}==\\frac{1}{4}\\big\\ } \\end{split}\\ ] ]    even in the more recent literature one can find examples like @xcite , where order conditions for runge - kutta methods are generated by using a computer algebra system to calculate the taylor expansions of the flow and the discrete flow directly .",
    "this approach is typically bound to _",
    "scalar _ non - autonomous equations , i.e. , @xmath116 .",
    "besides being inefficient for higher orders , it is well - known @xcite that for @xmath117 additional order conditions for general systems make an appearance , which do not show up in the scalar case .",
    "the following simple procedure tempts to solve the order conditions for a given order @xmath58 and stage number @xmath12 by using brute force , i.e. , _ mathematica _ s solve - command . to simplify the task , the user is allowed to supply a set pre of a priori chosen additional equations and assignments that he thinks to be helpful .",
    "rungekuttamethod[p_,s_,pre_]:= ( + rktemplate=\\{table[a@xmath118,\\{i , s},\\{j , s}],table[b@xmath119,\\{j,1},\\{i , s } ] , + table[c@xmath96,\\{j,1},\\{i , s}]}/.explicit ; + conditions = pre@xmath120union@@orderconditions[p , s ] ; + solvevars = complement[flatten[rktemplate],\\{0 } ] ; + sol = solve[conditions , solvevars ] ; + thread[\\{a , b , c}==matrixform/@rktemplate/.#]&/@sol )    since _ mathematica _ s solve - command uses a grbner - basis approach for solving systems of polynomial equations , we can show this way that the classical explicit 4-stage runge - kutta method of order @xmath121 is uniquely given by the additional constraints @xmath122 and @xmath123 : rungekuttamethod[4,4,\\{b@xmath124==b@xmath125,c@xmath124==c@xmath125 } ] @xmath126    the next example is more demanding . in his book @xcite",
    ", butcher describes an algorithm for the construction of explicit 6-stage methods of order @xmath127 .",
    "the choices @xmath128 and @xmath129 together with the free parameters @xmath130 and @xmath131 yield a unique method .",
    "butcher provides a two - parameter example by choosing @xmath132 . by just passing this additional information to _ mathematica _ s solve - command",
    "we obtain the following solution :      @xmath138      u&0&0&0&0&0 \\\\*[2 mm ]      \\frac{-1 + 8{\\,}u}{32{\\,}u}&\\frac{1}{32{\\,}u}&0&0&0&0 \\\\*[2 mm ]      \\frac{-1 + 4{\\,}u+2{\\,}v-8{\\,}u{\\,}v}{8{\\,}u } &      \\frac{1 - 2{\\,}v}{8{\\,}u}&v&0&0&0 \\\\*[2 mm ]      \\frac{3{\\,}(1 - 3{\\,}u - v+4{\\,}u{\\,}v)}{16{\\,}u } &      \\frac{3{\\,}(-1+v)}{16{\\,}u } &      -\\frac{3}{4}{\\,}(-1+v)&\\frac{9}{16}&0&0\\\\*[2 mm ]      \\frac{-7 + 22{\\,}u+6{\\,}v-24{\\,}u{\\,}v}{14{\\,}u } &      \\frac{7 - 6{\\,}v}{14{\\,}u}&\\frac{12{\\,}v}{7}&-\\frac{12}{7}&\\frac{8}{7}&0    \\end{matrix } \\right)\\\\*[2 mm ] & b==\\left(\\begin{matrix }      \\frac{7}{90 } &      0 &      \\frac{16}{45 } &      \\frac{2}{15 } &      \\frac{16}{45 } &      \\frac{7}{90 }     \\end{matrix } \\right),\\quad c==\\left(\\begin{matrix }      0 &      u &      \\frac{1}{4 } &      \\frac{1}{2 } &      \\frac{3}{4 } &      1    \\end{matrix } \\right)\\quad \\big\\ }    \\end{split}\\ ] ]    this result shows that the coefficients @xmath139 and @xmath140 of butcher s solution @xcite are in error , a fact that was already observed by sofroniou  @xcite using the _ mathematica _ package butcher.m ."
  ],
  "abstract_text": [
    "<S> this paper presents a simple and elementary proof of butcher s theorem on the order conditions of runge - kutta methods . </S>",
    "<S> it is based on a recursive definition of rooted trees and avoids combinatorial tools such as labelings and fa di bruno s formula . this strictly recursive approach </S>",
    "<S> can easily and elegantly be implemented using modern computer algebra systems like _ mathematica _ for automatically generating the order conditions . the full , but </S>",
    "<S> short source code is presented and applied to some instructive examples . </S>"
  ]
}