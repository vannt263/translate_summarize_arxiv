{
  "article_text": [
    "as we enter the era of precision cosmology , the need for higher resolution cosmological simulations has never been clearer .",
    "recent determinations of the cosmological parameters to accuracies of a few percent by the wmap mission ( bennett et al 2003 ) will entirely transform the industry of cosmological n - body simulations . since the initial conditions are now well - defined , the focus will be on seeking detailed quantitative consistency with the prevailing cosmological paradigm with observations of the large - scale structure through clustering and lensing studies and detailed analysis of the structure and dynamics of galaxy clusters and galaxies themselves . during the last decade",
    ", there has been a huge growth in computational power brought on by steady increase in processor speed and the integration of processors into massively parallel architectures .",
    "numerical cosmologists and dynamicists have developed parallel , n - body codes to take advantage these architectures and there are now a variety of codes that are being used to simulate the formation of large - scale structure and galaxies . in this paper",
    ", we describe a new parallel code that is adaptable and scalable to the next generation of parallel supercomputers .",
    "two classes of cosmological n - body codes are now used widely and are based on either the particle - mesh ( pm ) algorithm ( hockney and eastwood 1981 ) or the barnes - hut tree algorithm ( 1986 ) .",
    "pm codes are the fastest available taking advantage of the fast fourier transform algorithm ( fft ) to solve poisson s equation . while useful for some cosmological applications , pure pm codes fail to resolve structures on scales smaller than the mesh size .",
    "different approaches have been taken increase the force resolution on the sub - mesh scale .",
    "the simplest approach is the p@xmath0 m algorithm where the mesh softened force is corrected at short range using direct summation of pairwise forces between particles ( e.g. hockney and eastwood 1981 , efstathiou et al 1985 ) .",
    "as systems become clustered , the p@xmath0 m algorithm scales as o(n@xmath3 ) where n@xmath4 is the size of the largest halos limiting its application to small n or very large cosmological volumes where halos contain modest numbers of particles .",
    "another approach is to lay down refined sub - meshes on regions of high density to compute force refinements .",
    "this can be done hierarchically and leads to accurate force determination and code speed up .",
    "couchman s ( 1991 ) ap@xmath0 m algorithm used in the hydra code has been highly successful .",
    "a slight disadvantage of this approach is that a density threshold criterion is necessary to lay down sub - meshes and there may be discrete changes in force resolution across arbitrarily set boundaries that have unpredictable effects .",
    "an alternative mesh - refinement scheme is provided by kravtsov et al .",
    "( 1997 ) in the art algorithm that lays down refined meshes as particles begin to crowd into mesh cells . a completely different approach uses the bh tree algorithm modified to include periodic boundary conditions using ewald s method ( bouchet , hernquist and suto 1991 ) .",
    "this method has the advantage that forces are accurately determined at all stages of the calculation on all scales .",
    "the penalty is that tree codes generally have much larger memory requirements and require significantly more computation to achieve a similar force accuracy than pm based algorithms . despite these problems ,",
    "tree codes based on ewald s method have been easier to parallelize then ap@xmath0 m are currently very competitive in many applications ( e.g. dav et al 199 ? , springel et al .",
    "2001 ) .",
    "a natural evolution of cosmological codes is the developments of hybrids that can incorporate the high efficiency of pm codes for long range force determination and the advantage of tree codes for short range force corrections .",
    "xu ( 1995 ) developed a hybrid tree / pm ( tpm ) algorithm that is in the spirit of ap@xmath0 m and the algorithm has since been enhanced by bode et al .",
    "bh trees are used in place of refining sub - meshes and constructed around dense clustered regions to determine short range force corrections .",
    "this method differs from the ewald - method treecodes in that short range forces drop to zero at a few mesh lengths so trees only need to be built locally to calculate the force corrections .",
    "the algorithm has also been parallelized and is scalable to large processor numbers ( e.g. bode and ostriker 2003 ) .",
    "bagla has also introduced a hybrid treepm algorithm that breaks the forces up into short and a long range parts using ewald s original formalism .",
    "the main difference from tpm is that short range forces are corrected using the bh tree method throughout the simulation volume with no need to specify a density threshold for laying down a tree .    in this paper , we describe a new tree / pm hybrid that is in the same spirit as bagla s method but with parallelization .",
    "we call this new algorithm gotpm standing for grid - of - oct - trees - particle - mesh . in  2 , we describe the details of the algorithm including a new parallel pm method based on the fftw fast fourier transform package ( frigo et al .",
    "1998 ) and a method for computing the force refinements using localized bh trees .",
    "since tree refinements are confined to a few mesh lengths , the process of building trees within the simulation volume can be done sequentially leading to large savings in memory compared with ewald tree codes .",
    "we also discuss how to load balance the short range force correction calculations . in  3 , we present measures of the force accuracy and timing tests on a variety of machines to measure the code s performance and parallel scalability . in  4 , we describe some preliminary results of various simulations with the largest containing n=@xmath5 particles . in  5 , we discuss the future incorporation of multi - timestepping and smoothed particle hydrodynamics and algorithmic improvements that will permit simulations containing @xmath6 particles on next generation parallel machines .",
    "the pm algorithm is well documented so we highlight here the features of our implementation and method of parallelization .",
    "we use the pm code developed by park ( 1990 , 1997 ) as our starting point and it follows the usual steps :    1 .   we determine a density field on a mesh from the particle distribution using the triangular - shaped cloud ( tsc ) mass assignment scheme .",
    "2 .   a fast fourier transform ( fft ) of the density field is calculated and then multiplied by the appropriate green s function for the tsc scheme to determine the transform of the potential field .",
    "3 .   an inverse fft determines the potential field in real space .",
    "we interpolate the potential field to determine the gravitational force at each particle position using a 4-point finite difference approximation ( fda ) .",
    "we have parallelized this algorithm using a simple , slab domain decomposition of the simulation cube using the message - passing interface ( mpi ) library .",
    "particles are first distributed in slabs of equal width with an integral number of mesh divisions .",
    "we determine the density field using the tsc method in each slab in each processor .",
    "since the tsc method weights the particle mass to each of the surrounding 27 grid points from the nearest grid point , we need to communicate the contribution to the density field from particles near the boundaries of the slabs .",
    "we achieve this by binning the mass on ghost slices of mesh that are communicated to their neighbours and summed on to the corresponding local slices to find the correct density field quantities .",
    "once the density fields on slabs in each processor are determined we then use the fftw library ( frigo et al .",
    "1998 ) with mpi extensions to calculate the ffts used to obtain the gravitational potential .",
    "the fftw package requires that the complete mesh be divided in slabs of equal width so we can determine the gravitational potential immediately with a parallel fft . with the potential",
    ", we then calculate the particle forces in each slab using fda interpolation .",
    "again , we need to import images of mesh slices at the boundaries to determine forces on particles .",
    "we communicate the 3 or 4 mesh slices from the front and back sides of the slab and then calculate the force on each particle in each processor in parallel .",
    "our implementation assumes all neighbouring mesh slices are in adjacent slabs so the slab width can be no smaller than 4 mesh divisions .",
    "this sets a limits on the number of processors that can be used in a parallel run e.g. only 128 processors can be used with a @xmath7 mesh .",
    "although the code will work with thin slabs , we find in practice below that problems can arise with memory imbalance in the tree algorithm if slices are too thin so slabs with more than 8 mesh divisions are preferred .      in the complete algorithm",
    ", we treat the pm force as the long range contribution to the total force and determine the short range contribution using the tree algorithm .",
    "the pm method softens the newtonian potential within a few mesh divisions and also introduces some anisotropy to the force on the mesh size scale .",
    "we follow the lead of other codes and smooth the pm potential using a gaussian filter with an e - folding radius of 0.9 times the mesh size . to characterize the resultant pm force , we calculate the force many times at a point from a single particle placed at random positions within the mesh in a otherwise homogeneous density field .",
    "figure [ fig - pmfshape ] shows usual behaviour with an asymptotic newtonian force with significant scatter due to anisotropy at the maximum around @xmath8 where @xmath9 is the mesh cell size . our strategy is to fit these points with a smooth function of radius which asymptotically behaves as @xmath10 with a best fit shown in figure [ fig - pmfshape ] .",
    "after some experimentation , we settled on the rather complex fitting function , @xmath11 and find it successfully fits the data .",
    "the short range force is simply determined as the difference between this smooth empirical function and the newtonian gravitational force",
    ". we also determined the scatter in the expected relative force error by laying down a single particle randomly within the grid and measuring the acceleration due to the mesh plus correction at random points .",
    "figure [ fig - rerror ] show that the scatter peaks at a separation of about 2 mesh cell sizes revealing the anisotropy introduced by working on a regular cubic mesh .",
    "these errors are intrinsic to pm methods and we see below in more general situations they introduce a tail in the acceleration error distribution in the 1 - 2% range .",
    "the parallel pm force is very efficient at determining long range gravitational forces but because of the finite mesh size the forces from nearby particles are highly softened . the standard way to overcome",
    "this deficiency is to define a new correction force law for local particles that is the difference between the desired newtonian force and the force law determined by the pm method , @xmath12 .",
    "the correction force has the property that it is nearly newtonian on the sub - mesh scales but then falls to zero beyond four mesh cell sizes where the pm forces become nearly newtonian .",
    "the gravitational potential is also softened using a plummer law on the subgrid scale .",
    "we typically use a softening radius of @xmath13 , where l is the boxsize i.e. so typical simulations are equivalent in resolution to a pm method with a @xmath14 mesh .",
    "three approaches have been used to determine @xmath15 in pm methods .",
    "direct force evaluation using the particle - particle ( p@xmath16 ) method ( hockney and eastwood 1981 ) , adaptive particle sub - meshes with p@xmath16(couchman 1991 ) , and tree methods ( xu 1995 , bode et al .",
    "2000 , and bagla 2000 ) .",
    "direct force evaluation is the most general method and is easily parallelizable .",
    "unfortunately , when clustering is strong the method grinds to a halt because of the @xmath17 nature of the method .",
    "( ap@xmath0 m ) method relies on laying a local refined mesh on regions where strong clustering is occuring and calculating correction forces from this sub - mesh .",
    "it is highly efficient in serial codes but has proved difficult to parallelize .",
    "finally , xu s hybrid tpm algorithm works in a similar way to ap@xmath0 m but a barnes - hut tree is built locally on clustered regions .",
    "this method has been parallelized and performs well ( e.g. bode et al . 2003 ) .",
    "a disadvantage of both these methods is that one requires an arbitrary criterion to establish whether a mesh volume contains clustered material that should be refined .",
    "furthermore , boundaries between finely resolved and more coarsely resolved volumes are sharp and it is not clear if there are physical consequences to assigning these boundaries .",
    "bagla ( 2000 ) provides a way to characterize both the short and long range forces in his treepm algorithim and is completely analogous to p@xmath0 m in that all local forces everywhere within the volume are corrected .",
    "we describe here a parallel version of this method that builds on the parallel pm algorithm above and incorporates most of the efficient tree - building and tree walking software of dubinski s ( 1996 ) parallel tree code partree .",
    "we call our new parallel algorithm gotpm for grid of - oct - trees - particle - mesh",
    ". this new code has the generality of a @xmath18 code in that all forces throughout the simulation volume are calculated accurately on the submesh scale with no density criteria imposed for the addition of refinement .",
    "the equivalent of mesh refinement is done automatically by building trees everywhere within the simulation volume at every step .",
    "we show below that this algorithm also is easy to load balance using algorithms taken from pure parallel tree codes .",
    "it is easiest to describe this algorithm by comparing it directly to the p@xmath0 m method .",
    "the @xmath19 correction force on a particle is determined by summing directly over particles within a sphere centred on the particle which extends out to 2 - 3 mesh cell sizes . beyond this boundary corrections on the mesh force are small , generally less than 1% , and are so neglected . the problem with @xmath19 correction , however , is that the algorithm scales inherently as @xmath20 and a code is therefore slowed down considerably when clustering occurs . in constrast ,",
    "the tree algorithm is @xmath21 and generally requires about 2 to 3 times the amount of work when going from a homogeneous to a clustered state .",
    "the strategy we employ is to replace @xmath19 force correction with a correction determined by the tree method .",
    "the details of the basic bh tree method as implemented here are presented in dubinski ( 1996 ) with the only difference being that the force law is given as the difference between the newtonian and pm force law given in equation ( 1 ) . in brief",
    ", the bh tree algorithm works by arranging particles in a hierarchy of cubes or cells in an oct - tree structure .",
    "forces are determined by descending the tree and summing contributions from interactions with distributions of particles in `` distant '' cells and nearby particles .",
    "cell interactions are determined from the quadrupole order expansion of the potential of the particles within the cube rather than through direct summation so there are great computational savings .",
    "the trick is to introduce a cell opening criterion based on the ratio of the size of a cube to the distance of its centre of mass , i.e. an opening angle .",
    "if the cell is big and nearby , then the opening criterion is satisfied such that the cell is broken down into its 8 sub - cells each of which is examined in turn .",
    "if the cell is small and sufficiently distant , the opening criterion fails and the quadrupole order expansion of the particles in the cell are used to determine the force and the tree descent ends at this node . in practice",
    "the tree method requires only @xmath21 computations per step to determine forces with an error of 1% and therefore has a great advantage over direct summation methods .",
    "there are different choices available for the cell opening criterion as well as strategies for grouping particles to minimize the overhead in tree walks .",
    "the cell opening criterion and grouping strategy we use here is the same as that described in dubinski ( 1996 ) with some slight modifications that we discuss below .",
    "the application of the tree method to determine force corrections in a pm code requires a few general modifications .",
    "the force correction effectively drops to zero at a few mesh lengths .",
    "it is therefore not necessary to build a global tree for the entire particle distribution in the simulation cube .",
    "since the forces are localized , we can build a grid of trees , with a dimension of a few mesh lengths .",
    "if we define @xmath22 as the radius where the correction forces drops to small fraction of a percent then we only need to calculate the contributions from particles within this radius . in p@xmath0 m",
    ", one generally sets @xmath23 but we find in practice for the tree algorithm that @xmath24 is necessary to assure accuracy .",
    "this scale is set to the length of the cubes enclosing the trees .",
    "each particle is incorporated into one tree so to determine the force correction on a particle we need only descend the particle s home tree and the surrounding 26 trees ( figure [ fig - trees ] ) .    in principle ,",
    "p@xmath16 force corrections are necessary from all particles within the volume although particles beyond @xmath22 contribute little to the correction . in practice ,",
    "particles beyond @xmath22 are simply ignored saving a lot of time .",
    "this is necessary since the number of particles surrounding the point where the potential is calculated grows rapidly with radius i.e. @xmath25 for a homogeneous system and @xmath26 when clusters with densities of @xmath27 develop . in a tree code , however , the number of interactions does not grow rapidly with radius .",
    "distant particles are grouped into larger and larger cells so the number of cell interactions only grows roughly as @xmath28 under most circumstances .",
    "it is therefore not necessary to impose a hard spherical boundary of @xmath22 as is done in the @xmath18 method .",
    "as long as the trees are @xmath22 in size then all effective contributions to the force correction will be accounted for and the extra forces from the irregular jagged region beyond the spherical boundary will be small and generally average out .",
    "the force corrections themselves will have an inherent error which depends on the value of the critical opening angle in the tree algorithm and the value of @xmath22 . in practice , we show below that as clustering develops the number of particle cell interactions only grows slowly from the initial homogeneous state to the strongly clustered regime .",
    "computationally , the cpu time per step only grows by a factor of three from the beginning to the end of a simulation .",
    "since the trees are localized and compact there is one further refinement that can be added to improve accuracy and efficiency .",
    "if the number of particles within a cube is small , the cost of building and walking the tree for force determinations can be greater than simply doing a direct forces summation .",
    "we introduce an additional parameter , @xmath29 , that defines the minimum number of particles required for a tree build .",
    "if the number of particles in a bin is less than @xmath29 then we do a direct p@xmath16 summation for all particles within the radius @xmath22 . otherwise , we use the tree machinery for the force calculation . in this mode",
    ", a typical run behaves as a p@xmath0 m code at early times while at late times trees are used to calculate forces wherever clusters develop .",
    "since force corrections are local , we see that this algorithm is easily parallelizable within the context of the pm code we have described .",
    "we outline the implementation of this algorithm below .",
    "the parallel pm code we describe above distributes the particles into domain slabs of equal width and assigns them to independent processors on a parallel computer .",
    "we retain this slab domain decomposition scheme for force corrections with trees but relax the constraint of equal widths for the slices to achieve better load balance .",
    "as the system evolves , particles cross these boundaries and must be moved between processors by exchanging messages .",
    "the inner loop of the algorithm is as follows :",
    "particles are redistributed into domain slices of equal width by exchanging messages for the next pm force evaluation .",
    "the pm force is determined using the slice domain decomposition parallel method described above .",
    "particles are now redistributed into slices of variable width such that the amount of treecode computation per slice is equal .",
    "the boundaries of these domains are determined iteratively using the number of tree force interactions from the last step .",
    "it is a one - dimensional version of the orthogonal recursive bisection ( orb ) domain decomposition method described in dubinski ( 1996 ) and used in other parallel tree codes like gadget ( springel et al .",
    "2001 ) . at the end of this step",
    ", each processor contains a list of particles which requires the same amount of computation to determine tree force corrections .",
    "4 .   we are now ready to build a local grid of trees for the force correction .",
    "to do this , we need to import `` ghost '' particles from neighbouring domains extending a distance @xmath22 from the current slice boundaries .",
    "this is accomplished by exchanging particles with neighbouring processors .",
    "these ghost particles along with the local particles are then binned into cubes of dimension @xmath22 in the slice . to save memory , we only import the positions ( and masses if variable masses are present ) for the ghost particles",
    ". 5 .   for each particle bin",
    ", we then build a bh tree .",
    "we now loop through the local particle list determining the force correction using tree descents from the surrounding 27 trees centred on each particle .",
    "we remember the number of interactions required for each particle for load balancing purposes in step 3 above . 7 .",
    "force corrections are now added to the pm force to determine the corrected newtonian force in a periodic universe .",
    "particles are pushed forward according to the equations of motion and a leapfrog integration scheme .",
    "figure [ fig - dd ] illustrates the domain decomposition scheme needed for the fft s and achieve load balance for short range tree forces .",
    "= 3.0 in    there are a few refinements to this algorithm that improve speed and minimize memory overhead .",
    "first , step 3 is generally expensive in terms of communication time since the domain boundaries must be determined iteratively in @xmath30 message exchanges each possibly requiring the communication of large numbers of particles . to speed this step up , the full orb decomposition is only done every 10 steps . at intermediate steps",
    "the boundaries are held fixed according to the last determination .",
    "since the system does not change dramatically from step to step , only a small fraction of the particles actually cross these boundaries between steps thereby minimizing communication and preserving load balance .",
    "second , we save on memory when building the trees in steps 5 and 6 by only building a small subset of the trees at a time and discarding them after we are done with them .",
    "tree structures inherently require large amounts of data to describe the relational aspects of the tree through pointers and the cells themselves require lots of extra information including the quadrupole components as well as cell dimensional information . since all force corrections for a particle are local to the surrounding 27 trees , we can build the trees in small groups , determine the correction forces for corresponding particles then discard the trees before building a new set .",
    "in practice , we build only @xmath31 grid columns of trees and loop through the volume where @xmath32 is the number of trees in the vertical direction .",
    "the slice height @xmath32 varies from step to step because of the domain decomposition .",
    "for example , in a typical simulation on a 32 processor machine with a @xmath5 mesh with @xmath33 , there are on average @xmath34 trees that need to be built in each processor .",
    "we only need to build 512 trees at a time with this method saving a factor of 1000 in memory for tree data structures .",
    "the only information one needs to save at each step is the basic particle data , i.e. positions , velocities , particle index and computational load .",
    "extra memory is required to handle neighbour particles and memory imbalance induced by the load - balancing algorithm itself . for small cosmological volumes with a great deal of clustering",
    ", the memory imbalance leads to roughly a factor of 2 variation in the number of particles per processor . in the worst case ,",
    "we require about 3 times the memory required for basic particle data ( masses , positions and accelerations ) to handle this problem .",
    "the memory budget for a pure n - body simulation can be broken down into particle memory and mesh memory .",
    "a typical mesh requires @xmath35 bytes for single precision and twice that for double precision .",
    "the particles themselves require memory for positions , velocities , accelerations , masses and softening lengths , a computational work measurement , a particle index to retain identity and a pointer for constructing linked lists when binning particles in cubes .",
    "the total budget is the equivalent of 56 bytes per particle in single precision or 112 bytes in double precision . because of imbalance in particle numbers in the domain",
    "slabs the worst case that occurs with the smallest box sizes leads to domains with up to 3 times the average number of particles .",
    "conservatively , approximately 150 bytes are required per particle in a typical single precision run .",
    "the ghost particles can potentially eat up significant amounts of memory when the domain slabs become thin .",
    "this deficiency can be removed in future versions by using fully 3-d domain decomposition in the tree correction phase though considerable bandwidth may be required to move particles back and forth from slabs in the pm phase and cuboids in the tree phase .    in summary ,",
    "a typical run with @xmath36 and @xmath37 requires @xmath38200 gb in single precision in the worst case of a small box .",
    "this new algorithm is considerably more memory efficient than pure cosmological treecodes that require lots of memory to describe global trees .",
    "to validate the correctness and accuracy of the code , we calculated the accelerations from a 2 m particle dark matter simulation in a @xmath39 mpc box at @xmath40 in a standard cosmology with @xmath41 and @xmath42 .",
    "this resulting particle distribution is strongly clustered and so represented a good test for the method s accuracy .",
    "we used several methods to measure the accelerations . to start",
    ", we used a cosmological parallel treecode based on the ewald method ( dav et al .",
    "1997 ) to determine accelerations with small errors by setting the opening angle parameter @xmath43 and computing cell - particles interactions to quadrupole order .",
    "we used a plummer softening length of @xmath44 times the box size .",
    "this is a costly calculation but the mean relative error in the accelerations @xmath45 is estimated to be @xmath46% .",
    "we consider these accelerations to be exact for the purpose of comparison to other methods .",
    "we then calculated acceleration errors using the ewald method with a more standard value of @xmath47 and the new gotpm algorithm with @xmath48 ( making it a @xmath18 method ) and @xmath49 with @xmath50 and 32 .",
    "the size of the mesh is @xmath51 . in the gotpm algorithm",
    ", we expect errors to arise both from the treecode approximation as well as the pm method itself .",
    "the technique of fitting a smooth potential to the pm force function minimizes but does not eliminate errors induced by close range anisotropies in the mesh force .",
    "figure [ fig - errors ] shows the distribution of relative acceleration errors for various methods and parameter combinations .",
    "the first result is that the values of accelerations between the ewald - tree method and gotpm algorithm agree with each other on the percent level .",
    "this result reassures us that the computed accelerations are physically correct since the two numerical methods are very different in their mathematical formulation : the first method is based on a combination of the ewald expansion of a periodic point mass potential and the second method based on the solution of poisson s equation using fourier methods .",
    "we can clearly see the convergence to smaller errors when going from the p@xmath0 m to gotpm method with @xmath49 and smaller values of @xmath29 .",
    "the distribution of errors in the p@xmath0 m represents the `` best '' one can do to reduce errors in the accelerations using a hybrid pm method of this form .",
    "the distribution of errors between the p@xmath0 m method and gotpm methods are almost indistinguishable when @xmath52 while the time taken to compute these forces using p@xmath0 m requires about 10 times as much cpu time . for larger n simulations ,",
    "the discrepancy in cpu time becomes even greater .",
    "the distribution of errors for a ewald - method treecode using a typical value of @xmath47 .",
    "although , the mean error is slightly less than the gotpm method there is a broader tail in the distribution to larger errors precluding the use of a larger value of @xmath53 .",
    "the ewald - method treecode method requires about 3 times as much cpu time to compute accelerations of comparable accuracy to the gotpm method in the clustered state .",
    "we note , however , the situation is very different when the systems are less clustered .",
    "the gotpm method is several times faster and more accurate when the system is less clustered since it operates essentially like a pure pm method . in constrast ,",
    "the ewald tree method is only slightly faster in the less clustered case and acceleration errors tend to be much larger for a given value of @xmath53 .    using a larger mesh size also increases the accuracies of the accelerations and as we see below can",
    "also requires less computation so if enough memory exists it can be advantageous to use a finer mesh for the pm part of the calculation .    also apparent",
    "is a tail of the distribution of errors that remains as @xmath53 decreases .",
    "the cause of this tail is due to the anisotropy of the pm force on the mesh scale which introduces a random error on the determined acceleration for particles .",
    "this error is inherent to the pm method itself and all techniques using meshes will have this problem .",
    "we also note that the acceleration can be near zero because of the periodic nature of the force so relative errors are amplified in this case and do not necessarily indicate low accuracy .",
    "a plot of the acceleration versus the relative error indeed shows that the largest acceleration errors occur for the smallest accelerations . for @xmath54 ,",
    "the acceleration errors are found to be @xmath55 , the range typically tolerated in treecode simulations .",
    "there does not seem to be a large gain in accuracy in going to smaller @xmath53 because of mesh - induced force errors .",
    "all methods base on pm forces plus correction will have these errors so we recommend using @xmath54 as a compromise between speed and accuracy since generally 0.5% errors are usually tolerated in collisionless n - body calculations .",
    "we note , however , that the relative errors are much smaller for particles feeling large accelerations in the centre of clusters in these simulations so the 0.5% error is a conservative estimate .",
    "the gotpm code has been run on a variety platforms including a 32 processor ibm sp3 in seoul , an hp / compaq gs320 and a beowulf cluster based on intel xeon 2.4 ghz chips with gigabit networking both at cita .",
    "we present results of the code performance and parallel scaling up to 128 cpus on the beowulf cluster though runs with up to 256 cpus have been done and perform well .",
    "our reference simulation computes the evolution of @xmath56 particles using a @xmath7 mesh in a 200 h@xmath57 mpc box in a standard cosmology with @xmath58 and @xmath42 .    to study scaling of the code speed with processor number ,",
    "we follow the computation for 5 equal time steps from @xmath59 when the system is moderately clustered and time the pm and tree phase of the code separately to determine a speed .",
    "these timing tests are done on a beowulf cluster with gigabit networking and dual xeon 2.4 ghz processors with code compiled using the intel c and fortran compilers . figure [ fig - timing ] shows the code speed versus the number of processors @xmath60 from 4 to 128 processors .",
    "the speed scaling is not perfect since the amount of communication time grows as @xmath60 increases .",
    "as @xmath60 grows , the domain slabs become thinner and the number of particles crossing boundaries through both particle redistribution for load - balancing purposes grows significantly as well as the number of ghost particles imported for tree builds .",
    "nevertheless , the code scales well to @xmath61 requiring only 11.6 second per step and clocking at about 1.4 million particles / s .",
    "the pm portion of the calculation only requires 1.8 seconds compared with 9.8 seconds for the tree correction force so the code is dominated by determination of the short range forces .    as part of j. kim s doctoral work , we simulated @xmath5 particles in lcdm and scdm cosmological models in a cosmological box of size @xmath62 mpc .",
    "the simulations were run on a ibm sp3 ( regatta ) system at the korea institute of science and technology information ( kisti ) . over the course of two months , we used one node of 32 cpu s with 208 gbytes of memory for two gotpm simulations .",
    "memory limited us to a @xmath5 mesh .",
    "each model was simulated with 460 time steps in 16 wall - clock days and the peak memory usage was about 170 giga bytes .",
    "the simulation details will be presented in kim s thesis and a forthcoming publication .",
    "the cpu timing of the lcdm simulation is displayed in figure [ fig-1gtime ] .",
    "the cpu time per step grew from 40 minutes to 55 minutes largely due to the increase of tree calculation overload caused by the clustering of particles .",
    "periodic spikes in dd and the total cpu time plot are due to the particle backup at every 15 time steps and pre - halo finding calculations every 5 time steps .",
    "the increase of cpu time in the fda part was partially due to the steady increasing rates of cache miss of particle data in l2 cache .",
    "as the system evolves , the memory locality of the particle data differs significantly from the spatial positions of the particles . in figure",
    "[ fig-1gdd ] , we show the inhomogeneity of particle distributions of pm domain slabs in the lcdm simulation .",
    "we expect the density fluctuation@xmath63 at length scale @xmath64 is related to the power index @xmath65 as ( longair 1998 ) @xmath66 where @xmath64 is defined to be the radius of a sphere having equal volume of the local domain slab . in the case of @xmath67 , @xmath68 of the simulation domain slabs is @xmath69 , respectively .",
    "hence the static domain decomposition of the pm part does not matter seriously to memory budget overload for cosmological volume .",
    "another useful tool for the verification of the code is the comparison of simulated halo mass functions with other analytic halo mass functions .",
    "there have been several fitting functions proposed by many authors for halo mass functions .",
    "press and schecter(1974,hereafter ps ) , lee and shandarin(1998,hereafter ls ) sheth and tormen(1999,hereafter st ) and jenkins et al.(2000 ) have presented analytic and fitting mass functions . on the basis of spherical collapses and gaussian fluctuations in the initial density field , press and schecter derived the mass function as , @xmath70 where @xmath71 is defined @xmath72 and @xmath73 could be calculated from the initial power spectrum @xmath74 .",
    "other analytic halo findings are rather empirical functions to fit to their simulated halo mass functions .",
    "we display the halo mass function for the 1 g particle lcdm simulation with other analytic halo mass functions in figure [ fig - mflcdm0 ] . in a forthcoming paper",
    ", we will describe a halo - finding method used to extract virialized halos from the simulation data during run time .",
    "the simulated halo mass function of mass above @xmath75 is well fitted by the ps predictions but underestimates halo numbers by about 30% below this mass scale .",
    "even with the shortcomings at the high - mass end , our halo mass functions show global consistency with st and jenkins predictions .",
    "we also note that the pm version of the code has already been used to do a series of @xmath7 particle simulations to model gravitational lensing convergence and shear for comparison to lensing surveys ( pen et al .",
    "gotpm is a new parallel hybrid tree / pm cosmological n - body method that is fast , accurate , memory efficient and scaleable to hundreds of processors on parallel machines .",
    "we have verified the correctness and accuracy of the forces through comparison with other methods and produced a mass function consistent with other results in the literature .",
    "this new code is well - suited for the next generation of large - scale cosmological simulations on massively parallel machines .    at present",
    "the code has been used to compute @xmath2 particle simulations but to meet the challenges of doing even larger calculations on future supercomputers with thousands of processors some modifications will be necessary .",
    "the current version uses a single leapfrog timestep .",
    "the incorporation of hierarchical multiple timestepping should be straightforward .",
    "since the rapidly changing force field in dense regions will be mainly calculated as a tree correction , the pm part of the potential can be held fixed or extrapolated over the largest system time step . since all near range forces are localized to particles in the algorithm only trees in the densest regions",
    "need to be updated at smaller fine - grained timesteps while remaining trees can be repaired using methods described by springel et al .",
    "furthermore , the communication needs will be small at the fine - grained timesteps since forces are all determined locally and few particles will cross domain boundaries .",
    "work is proceeding to incorporate multiple timestepping .",
    "one major weakness of the algorithm from the perspective of parallelization and memory needs is the use of slab domain decomposition for the tree correction phase .",
    "as the number of cpu s increase slabs become thinner especially when the system becomes more inhomogeneous .",
    "this leads to dramatic increase in both communication to move ghost particles as well as memory usage since the imported ghost particles can actually dominate local memory .",
    "for @xmath2 simulations with up to 256 processors the algorithm works well but slab domain decomposition will break down on future machines with thousands of processors .",
    "one solution to this weakness , is the use of 3-d cuboid domain decomposition instead of slabs for the tree phase .",
    "this will solve the ghost particle memory and communication problem .",
    "the pm phase will still require slabs since this is inherent to fftw s mpi implementation .",
    "either particle data will have to be moved back and forth between cuboids and slabs every step or the mesh points themselves will have to be communicated .",
    "these various strategies will be examined in coming versions and will prepare the way for @xmath76 g particle simulations .",
    "another weakness of the algorithm is the scatter in the pm mesh force anisotropy .",
    "we can minimize this problem by introducing a spherically symmetric mass allocation kernel .",
    "the extra cost of this scheme will still be small compared to the tree phase of the algorithm .",
    "the advantage of this method is that we can potentially reduce the size of @xmath22 and save on computation during the tree force corrections .",
    "the code is also well suited for incorporation of smoothed particle hydrodynamics ( sph ) .",
    "the grid of localized oct - trees can be exploited immediately to form neighbour lists for sph estimation of density and pressure fields . with the multiple timestepping scheme described above , gotpm with sph",
    "is a natural fit .",
    "the code is currently available by request but will be released publicly in the near future .",
    "jd thanks nserc and the canadian foundation for innovation and acknowledges the cita pre - doc programme that allowed jk s visit .",
    "jk and cp thank the brain korea 21 program of the korean government and the basic research program of the korea science & engineering foundation ( grant no .",
    "1999 - 2 - 113 - 001 - 5 ) .",
    "jk and cp also acknowledge the support from the kisti ( korea institute of science and technology information ) under ` grand challenge support program ' with dr .",
    "s. m. lee as the technical supporter .",
    "the use of the computing system of the supercomputing center is also greatly appreciated ."
  ],
  "abstract_text": [
    "<S> we describe a parallel , cosmological n - body code based on a hybrid scheme using the particle - mesh ( pm ) and barnes - hut ( bh ) oct - tree algorithm . </S>",
    "<S> we call the algorithm gotpm for grid - of - oct - trees - particle - mesh . </S>",
    "<S> the code is parallelized using the message passing interface ( mpi ) library and is optimized to run on beowulf clusters as well as symmetric multi - processors . </S>",
    "<S> the gravitational potential is determined on a mesh using a standard pm method with particle forces determined through interpolation . </S>",
    "<S> the softened pm force is corrected for short range interactions using a grid of localized bh trees throughout the entire simulation volume in a completely analogous way to p@xmath0 m methods . </S>",
    "<S> this method makes no assumptions about the local density for short range force corrections and so is consistent with the results of the p@xmath0 m method in the limit that the treecode opening angle parameter , @xmath1 .    </S>",
    "<S> the pm method is parallelized using one - dimensional slice domain decomposition . </S>",
    "<S> particles are distributed in slices of equal width to allow mass assignment onto mesh points . </S>",
    "<S> the fourier transforms in the pm method are done in parallel using the mpi implementation of the fftw package . </S>",
    "<S> parallelization for the tree force corrections is achieved again using one - dimensional slices but the width of each slice is allowed to vary according to the amount of computational work required by the particles within each slice to achieve load balance . </S>",
    "<S> the tree force corrections dominate the computational load and so imbalances in the pm density assignment step do not impact the overall load balance and performance significantly . </S>",
    "<S> the code performance scales well to 128 processors and is significantly better than competing methods . </S>",
    "<S> we present preliminary results from simulations run on different platforms containing up to @xmath2 particles to verify the code .    </S>",
    "<S> ,    ,    , and    methods : n - body simulations , methods : numerical , cosmology : dark matter </S>"
  ]
}