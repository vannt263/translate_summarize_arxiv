{
  "article_text": [
    "a reversible or information lossless circuit is one that implements a bijective function , or loosely , a circuit where the inputs can be recovered from the outputs and all output values are achievable . a major motivation for studying reversible circuits is the emerging field of quantum computation  @xcite .",
    "a quantum circuit implements a unitary function , and is therefore reversible .",
    "circuit synthesis for reversible computations is an active area of research  @xcite .",
    "the goal in circuit synthesis is , given a gate library , to synthesize an efficient circuit performing a desired computation .",
    "in the quantum context , the individual gates correspond to physical operations on quantum states called qubits , and therefore reducing the number of gates in the synthesis generally leads to a more efficient implementation .",
    "linear reversible classical circuits form an important sub - class of quantum circuits , which can be generated by a single type of gate called a c - not gate  ( see figure  [ fig : ex_gate]c ) .",
    "this gate is an important primitive for quantum computation because it forms a universal gate set when augmented with single qubit rotations  @xcite .",
    "moreover , current quantum circuit synthesis algorithms can generate circuits with strings of c - not gates , and therefore more efficient synthesis for these classical linear reversible sub - circuits would imply more efficient synthesis for the overall quantum computation .",
    "in this paper we consider the problem of efficiently synthesizing an arbitrary linear reversible circuit on @xmath0 wires using c - not gates .",
    "this problem can be mapped to the problem of row reducing a @xmath4 binary matrix . until now",
    "the best synthesis methods have been based on standard row reduction methods such as gaussian elimination and lu - decomposition , which yield circuits with @xmath5 gates  @xcite . however , the best lower bound leaves open the possibility that synthesis with as few as @xmath2 gates in the worst case may exist  @xcite",
    ".    we present a new synthesis algorithm that meets the lower bound , and is therefore asymptotically optimal up to a multiplicative constant .",
    "furthermore , our algorithm is also asymptotically faster than previous methods .",
    "simulation results show that the proposed algorithm outperforms previous methods even for relatively small @xmath0 .",
    "generically our algorithm can be interpreted as a matrix decomposition algorithm , that yields an asymptotically efficient elementary matrix decomposition of a binary matrix .",
    "generalizations to matrices over larger finite fields are straightforward .",
    "we can represent the action of an @xmath0-input @xmath6-output logic gate as a function mapping the values of the inputs to those of the outputs : @xmath7 , where @xmath8 maps each element of @xmath9 to an element in @xmath10 . here",
    "@xmath11 is the two - element field , and @xmath9 is the set of all @xmath0-dimensional vectors over this field .",
    "a gate is _ reversible _ if this function is bijective , that is , @xmath8 is one - to - one and onto .",
    "intuitively , this means that the inputs can be uniquely determined from the outputs and all output values are achievable .",
    "for example , the and gate ( figure  [ fig : ex_gate]a ) is not reversible since it maps three input values to the same output value . the not gate ( figure  [ fig : ex_gate]b ) , on the other hand , is reversible since both possible input values yield unique output values , and both possible output values are achievable .",
    "the _ controlled - not _ or c - not gate , shown in figure  [ fig : ex_gate]c , is another important reversible gate .",
    "this gate passes the first input , called the _",
    "control _ , through unchanged and inverts the second , called the _ target _ , if the control is a one . as its truth table shows ,",
    "this gate is reversible since it maps each input vector to a unique output vector and all output vectors are achievable",
    ".     +    a _ reversible circuit _ is a directed acyclic combinatorial logic circuit where all gates are reversible and are interconnected without fanout  @xcite .",
    "an example of a reversible circuit consisting of c - not gates is shown in figure  [ fig : ex_circ ] .",
    "note that , as is the case for reversible gates , the function computed by a reversible circuit is bijective .",
    "we say a circuit or gate , computing the function @xmath8 , is _ linear _ if @xmath12 for all @xmath13 , where @xmath14 is the bitwise xor operation .",
    "the c - not gate is an example of a linear gate : @xmath15\\right ) \\oplus f\\left(x      \\right)=f\\left(x\\right)\\ \\",
    "\\   & \\ \\ \\   f\\left(\\left[0\\      1\\right]\\right)\\oplus f\\left(\\left[1\\      0\\right]\\right)=",
    "f\\left(\\left[1\\ 1\\right]\\right)\\ \\ \\ & \\ \\ \\",
    "f\\left(\\left[1\\      0\\right]\\right)\\oplus f\\left(\\left[1\\      1\\right]\\right)= f\\left(\\left[0\\ 1\\right]\\right ) \\\\",
    "f\\left(x\\right)\\oplus f\\left(x\\right)=f\\left([0\\ 0]\\right)\\ \\ \\ & \\ \\ \\",
    "f\\left(\\left[0\\ 1\\right]\\right)\\oplus f\\left(\\left[1 \\      1\\right]\\right)=f\\left(\\left[1\\ 0\\right]\\right).\\ \\",
    "\\     \\end{array}\\ ] ] the action of any linear reversible circuit on @xmath0 wires can be represented by a linear transformation over @xmath11 . in particular",
    ", we can represent the action of the circuit as multiplication by a non - singular @xmath4 matrix @xmath16 with elements in @xmath11 : @xmath17 where @xmath18 and @xmath19 are @xmath0-dimensional vectors representing the values of the input and output bits respectively . using this representation , the action of a c - not gate corresponds to multiplication by an _",
    "elementary matrix _ , which is the identity matrix with one off - diagonal entry set to one .",
    "multiplication by an elementary matrix performs a _ row operation _",
    ", the addition of one row of a matrix or vector to another . applying",
    "a series of c - not gates corresponds to performing a series of these row operations on the input vector or equivalently to multiplying it by a series of elementary matrices .",
    "for example , the linear transform computed by the circuit in figure  [ fig : ex_circ ] is given by @xmath20}\\cdot      \\stackrel{g_5}{\\left[\\begin{array}{cccc}1&1&0&0\\\\0&1&0&0\\\\0&0&1&0\\\\0&0&0&1\\end{array}\\right]}\\cdot      \\stackrel{g_4}{\\left[\\begin{array}{cccc}1&0&0&0\\\\0&1&1&0\\\\0&0&1&0\\\\0&0&0&1\\end{array}\\right]}\\cdot      \\stackrel{g_3}{\\left[\\begin{array}{cccc}1&0&0&0\\\\0&1&0&0\\\\0&1&1&0\\\\0&0&0&1\\end{array}\\right]}\\cdot      \\stackrel{g_2}{\\left[\\begin{array}{cccc}1&0&0&0\\\\0&1&0&0\\\\0&0&1&0\\\\0&0&1&1\\end{array}\\right]}\\cdot      \\stackrel{g_1}{\\left[\\begin{array}{cccc}1&0&0&0\\\\1&1&0&0\\\\0&0&1&0\\\\0&0&0&1\\end{array}\\right]}=      \\left[\\begin{array}{cccc}1&0&1&0\\\\0&0&1&0\\\\1&1&1&0\\\\1&1&0&1\\end{array}\\right]\\ ] ]     +    we can use the matrix notation to count the number of different @xmath0-input linear reversible transformations . in order for the transformation to be reversible",
    ", its matrix must be non - singular , in other words , all nontrivial sum of the rows should be non - zero .",
    "there are @xmath21 possible choices for the first row , all vectors except for the all zeros vector .",
    "there are @xmath22 possible choices for the second row , since it can not be the equal to the first row or the all zeros vector . in general , there are @xmath23 possible choices for the @xmath24th row , since it can not be any of the @xmath25 linear combinations of the previous @xmath26 rows ( otherwise the matrix would be singular )",
    ". therefore there are @xmath27 unique @xmath0-input linear reversible transformations .",
    "since any non - singular matrix @xmath16 can be reduced to the identity matrix using row operations , we can write @xmath16 as a product of elementary matrices .",
    "therefore , any linear reversible function can be be synthesized from c - not gates .",
    "moreover , the problem of c - not circuit synthesis is equivalent to the problem of row reduction of a matrix @xmath16 representing the linear reversible function : any synthesis of the circuit can be written as a product of elementary matrices equal to @xmath16 and any such product yields a synthesis .",
    "the length of the synthesized circuit is given by the number of elementary matrices in the product .",
    "standard gaussian elimination and lu - decomposition based methods requires @xmath5 gates in the worst - case  @xcite .",
    "however , the best lower bound is only @xmath28 gates  @xcite .",
    "[ lemma : lwr_bound ] there are @xmath0-bit linear reversible transformation that can not be synthesized using fewer than @xmath29 c - not gates .",
    "* proof * let @xmath30 be the maximum number of c - not gates needed to synthesize any linear reversible function on @xmath0 wires .",
    "the number of different c - not gates which can act on @xmath0 wires is @xmath31 . therefore the number of unique c - not circuit with no more than @xmath30 gates must be no more than @xmath32 , where we have included a do - nothing nop gate in addition to the @xmath33 c - not gates to account for circuits with fewer than @xmath30 gates .",
    "since the number of circuits with no more than @xmath30 c - not gates must be greater than the number of unique linear reversible function on @xmath0 wires , we have the inequality @xmath34 taking the @xmath35 of both the left and right sides of the equations gives @xmath36 @xmath37    this lemma suggests a synthesis more efficient than standard gaussian elimination may be possible .",
    "the multiplicative constant in this lower bound is @xmath38 ( assuming logs are taken base 2 ) .",
    "in this section we present our synthesis algorithm , which achieves the lower bound given in the previous section . in gaussian elimination ,",
    "row operations are used to place ones on the diagonal of the matrix and to eliminate any remaining ones .",
    "one row operation is required for each entry in the matrix that is targeted .",
    "since there are @xmath39 matrix entries , @xmath5 row operation are required in the worst case .",
    "if instead we group entries together and use single row operations to change these groups , we can reduce the number of row operation required , and therefore the number of gates needed to synthesize the circuit .",
    "the basic idea is as follows .",
    "we first partition the columns of the @xmath4 matrix into sections of no more than @xmath6 columns each .",
    "we call the entries in a particular row and section a _ sub - row_. for each section we use row operations to eliminate sub - row patterns that repeat in that section .",
    "this leaves relatively few ( @xmath40 ) non - zero sub - rows in the section .",
    "these remaining entries are handled using gaussian elimination .",
    "if @xmath6 is small enough ( @xmath41 ) , most of the row operations result from the first step , which requires a factor of @xmath6 fewer row operations than full gaussian elimination . as with the gaussian elimination",
    "based method , our algorithm is applied in two steps ; first the matrix is reduced to an upper triangular matrix , the resulting matrix is transposed , and then the process is repeated to reduce it to the identity .",
    "detailed pseudo - code for our algorithm is shown on the next page .",
    "* algorithm 1 : efficient c - not synthesis *     & + & \\{@xmath42 & + & & + & & + & & + & & +   + & & + & & + & & + & } & + & & & & & & & + & & & & & & & + & + & \\{@xmath42 & + & & + & & + & & \\{@xmath42 & + & & & + & & & + & & & & + & & & + & & & \\{@xmath42 & + & & & & + & & & & + & & & & + & & & & & + & & & & + & & & & \\{@xmath42 & & & + & & & & & + * step a * & & & & & + & & & & } & & & + & & & } & + & & & + & & & + & & & \\{@xmath42 & + & & & & + & & & & + & & & & + & & & & & + & & & & + & & & & + & & & & \\{@xmath42 & + & & & & & + & & & & & \\{@xmath42 & + & & & & & & + & & & & & & \\{@xmath42 & + & & & & & & & + * step b * & & & & & & & + & & & & & & & + & & & & & & } & + & & & & & & + * step c * & & & & & & + & } & } & } & } & } & + & & & & & & & +    the following example illustrates our algorithm for a @xmath43-wire linear reversible circuit .    *",
    "1 ) * choose @xmath44 and partition matrix .",
    "@xmath45\\ ] ] * 2 ) * ( step a - section 1 ) eliminate duplicate sub - rows . @xmath46\\stackrel{\\begin{array}{c } 1\\rightarrow 4\\\\ 1\\rightarrow 5\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      1&0 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&1\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      0&0\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      1&0\\\\      1&1 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&1\\\\      1&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      1&0 \\end{array}$ } }     \\end{array}\\right]\\ ] ] * 3 ) * ( step b - section 1 , column 1 ) one already on diagonal .    *",
    "4 ) * ( step c - section 1 , column 1 ) remove remaining ones in column below diagonal .",
    "@xmath47\\stackrel{\\begin{array}{c } 1\\rightarrow 2\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&1\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      0&0\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      1&0\\\\      1&1 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&1\\\\      1&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      1&0 \\end{array}$ } }     \\end{array}\\right]\\ ] ] * 3 ) * ( step b - section 1 , column 1 ) one already on diagonal .    *",
    "4 ) * ( step c - section 1 , column 1 ) remove remaining ones in column below diagonal .",
    "@xmath48\\stackrel{\\begin{array}{c } 2\\rightarrow 3\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      0&1\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      1&1 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&1\\\\      1&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      1&0 \\end{array}$ } }     \\end{array}\\right]\\ ] ] * 5 ) * ( step a - section 2 ) eliminate duplicate sub - rows below row 2 .",
    "@xmath49\\stackrel{\\begin{array}{c } 3\\rightarrow 5\\\\4\\rightarrow 6\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      0&1\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      1&1 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 6 ) * ( step b - section 2 , column 3 ) place one on diagonal .",
    "@xmath50\\stackrel{\\begin{array}{c } 4\\rightarrow 3\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      1&1\\\\      1&1 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 7 ) * ( step c - section 2 , column 3 ) remove remaining ones in column below diagonal .",
    "@xmath51\\stackrel{\\begin{array}{c } 3\\rightarrow 4\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } &     \\begin{array}{cc }      0&0\\\\      1&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      1&1\\\\      0&0 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&1\\\\      0&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 8) * matrix is now upper triangular .",
    "transpose and continue .",
    "@xmath52\\stackrel{\\begin{array}{c } \\mbox{transpose}\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&1\\\\      0&0 \\end{array } &    \\begin{array}{cc }      1&0\\\\      1&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 9 ) * ( step a - section 1 ) eliminate duplicate sub - rows . @xmath53\\stackrel{\\begin{array}{c } 4\\rightarrow 5\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      1&1\\\\      1&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ]    * 10 ) *  = ( step b - section 1 , column 1 ) because matrix is triangular and non - singular there + will always be ones on the diagonal .    * 11 ) * ( step c - section 1 , column 1 ) remove remaining ones in column .",
    "@xmath54 \\stackrel{\\begin{array}{c } 1\\rightarrow 2\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&1 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      1&1\\\\      1&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 12 ) * ( step c - section 1 , column 2 ) remove remaining ones in column",
    "\\stackrel{\\begin{array}{c } 2\\rightarrow 4\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      1&1\\\\      1&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 13 ) * ( step a - section 2 ) eliminate duplicate sub - rows .",
    "@xmath56 \\stackrel{\\begin{array}{c } 3\\rightarrow 6\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      1&1\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 14 ) * ( step c - section 2 , column 1 ) remove remaining ones in column .",
    "@xmath57 \\stackrel{\\begin{array}{c } 3\\rightarrow 5\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&1\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 15 ) * ( step c - section 2 , column 2 ) remove remaining ones in column .",
    "\\stackrel{\\begin{array}{c } 4\\rightarrow 5\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\",
    "\\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      1&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ] * 16 ) * ( step c - section 3 , column 1 ) remove remaining ones in column .",
    "@xmath59 \\stackrel{\\begin{array}{c } 5\\rightarrow 6\\end{array}}{\\longrightarrow } \\left [ \\begin { array}{c|c|c|c } \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array}\\\\       \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } } &     \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } \\\\      \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } &    \\begin{array}{cc }      0&0\\\\      0&0 \\end{array } & \\mbox{\\framebox{$\\begin{array}{cc }      1&0\\\\      0&1 \\end{array}$ } }   \\end{array}\\right]\\ ] ]     +    the synthesized circuit is specified by the row operations and is shown in figure  [ fig : synth_circ ] .",
    "in general , the length of the synthesized circuit is given by the number of row operations used in the algorithm . by accounting for the maximum number of row operations in each step",
    ", we can calculate an upper bound on the maximum number of gates that could be required in synthesizing an @xmath0-wire linear reversible circuit .",
    "c - not gates are added in the steps marked step a - c in the algorithm .",
    "step a is used to eliminate the duplicates in the subsections .",
    "it is called fewer than @xmath60 times per section ( combined for the upper / lower triangular stages of the algorithm ) , giving a total of no more than @xmath61 gates .",
    "step b is used to place ones on the diagonal .",
    "it can be called no more than @xmath0 times .",
    "step c is used to remove the ones remaining after all duplicate sub - rows have been cleared . since there are only @xmath62 @xmath6-bit words , there can be at most as many non - zero sub - rows below the @xmath63 sub - matrix on the diagonal .",
    "therefore , step c is called fewer than @xmath64 times per section , or fewer than @xmath65 times in all . adding these up we have @xmath66 if @xmath67 , @xmath68 if @xmath69 , the first term dominates as @xmath0 gets large .",
    "therefore the number of row operations is @xmath70 . combining this result with lemma  [ lemma : lwr_bound ]",
    ", we have the following theorem .",
    "the worst - case length of an @xmath0-wire c - not circuit is @xmath71 gates .    in equation  [ eqn : row_ops ]",
    ", @xmath72 can be chosen to be arbitrarily close to 1 . in the limit",
    ", the multiplicative constant in the @xmath70 expression becomes @xmath73 ( assuming logs are taken base 2 ) .",
    "by contrast , the multiplicative constant in the lower bound in lemma  [ lemma : lwr_bound ] is @xmath38 .",
    "this algorithm , in addition to generating more efficient circuits than the standard method , is also asymptotically more efficient in terms of run time .",
    "the execution time of the algorithm is dominated by the row operations on the matrix , which are each @xmath74 .",
    "therefore the overall execution time is @xmath75 compared to @xmath76 for standard gaussian elimination  @xcite .",
    "our algorithm is closely related to kronrod s algorithm  ( also known as `` the four russians algorithm '' ) for construction of the transitive closure of a graph  @xcite .",
    "one important difference between the two is that in their case the goal was a fast algorithm for their application , which is only of secondary concern for our application .",
    "our primary goal is an algorithm that produces an efficient circuit synthesis .",
    "generically , our algorithm can be interpreted as producing an efficient elementary matrix decomposition of a binary matrix .",
    "+    though algorithm 1 is asymptotically optimal , it would be of interest to know how large @xmath0 must be before the algorithm begins to outperform standard gaussian elimination . for this purpose",
    "we have synthesized linear reversible circuits using both our method and gaussian elimination for randomly generated non - singular 0 - 1 matrices .",
    "the results of these simulations are summarized in figure  [ fig : avg_length ] .",
    "our algorithm shows an improvement over gaussian elimination for @xmath0 as small as @xmath77 .",
    "the length of the circuit synthesis produced by algorithm 1 is dependent on the choice @xmath6 , the size of the column sections .",
    "here we have somewhat arbitrarily chosen @xmath78 .",
    "the performance for some values of @xmath0 could be significantly improved by optimizing this choice .",
    "this would also smooth out the performance curve in figure  [ fig : avg_length ] for algorithm 1 .",
    "we have given an algorithm for linear reversible circuit synthesis that is asymptotically optimal in the worst - case .",
    "we show that the algorithm is also asymptotically faster than current methods .",
    "while our results are primarily asymptotic , simulation results show that even in the finite case our algorithm outperforms the current synthesis method .",
    "applications of our work include circuit synthesis for quantum circuits .    while the primary motivations for the synthesis method we have given here are to provide an asymptotic bound on circuit complexity and a practical method to synthesize efficient circuits , another application is to bounds on circuit complexity for the finite case .",
    "in particular , we can use our method to determine an upper bound on the maximum number of gates required to synthesize any @xmath0 wire c - not circuit . for this application",
    "the particular partitioning of the columns can be very important .",
    "for example , much better bounds can be determined if the size of the sections are a function of the location of the section in the matrix .",
    "sections to the left have more rows below the diagonal and therefore should be larger than sections towards the right of the matrix which have fewer rows below the diagonal .",
    "an ongoing area of work is determining optimal column partitioning methods .",
    "our algorithm basically yields an efficient decomposition for matrices with elements in @xmath11 , and can be generalized in a straightforward manner for matrices over any finite field .",
    "the asymptotic size of the generalized decomposition is @xmath79 , where @xmath80 is the order of the finite field .",
    "our algorithm , particularly in this generalized form , is quite generic and may lend itself to a wide range of other applications .",
    "related algorithms  @xcite have applications in finding the transitive closure of a graph , binary matrix multiplication , and pattern matching .",
    "a major area of future work is extending our results to more general reversible circuits , particularly quantum circuits .",
    "currently , there is an asymptotic gap between the best upper and lower bounds on the worst - case circuit complexity both for general classical reversible circuits and quantum circuits .",
    "the gap for classical reversible circuits is the same logarithmic factor that previously existed for linear reversible circuits  @xcite , which suggests it may be possible to extend our methods to this problem .",
    "m.  perkowski , l.  jozwiak , p.  kerntopf , a.  mishchenko , a.  al - rabadi , a.  coppola , a.  buller , x.  song , m.  khan , s.  yanushkevich , v.  shmerko , and m.  chrzanowska - jeske . a general decomposition for reversible logic .",
    ", august 2001 ."
  ],
  "abstract_text": [
    "<S> in this paper we consider circuit synthesis for @xmath0-wire linear reversible circuits using the c - not gate library . </S>",
    "<S> these circuits are an important class of reversible circuits with applications to quantum computation . </S>",
    "<S> previous algorithms , based on gaussian elimination and lu - decomposition , yield circuits with @xmath1 gates in the worst - case . </S>",
    "<S> however , an information theoretic bound suggests that it may be possible to reduce this to as few as @xmath2 gates .    </S>",
    "<S> we present an algorithm that is optimal up to a multiplicative constant , as well as @xmath3 times faster than previous methods . while our results are primarily asymptotic , </S>",
    "<S> simulation results show that even for relatively small @xmath0 our algorithm is faster and yields more efficient circuits than the standard method . </S>",
    "<S> generically our algorithm can be interpreted as a matrix decomposition algorithm , yielding an asymptotically efficient decomposition of a binary matrix into a product of elementary matrices . </S>"
  ]
}