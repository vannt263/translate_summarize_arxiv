{
  "article_text": [
    "the computational problem in sensor network localization ( snl ) is one of determining the position of _ sensors _ in two or three dimensions from incomplete and inaccurate inter - sensor distances . in some cases ,",
    "the distances between certain fixed _ anchors _ ( whose positions are known fairly accurately ) and some sensors are also provided @xcite .",
    "while the snl problem in its full generality is known to be computationally intractable @xcite , nevertheless , there has been considerable progress on developing algorithms that can efficiently solve the snl problem ( exactly or approximately ) under appropriate assumptions on the network connectivity , and which are resilient to noises in the distances and the anchor positions .",
    "popular methods include classical multidimensional scaling @xcite , belief propagation @xcite , non - linear filtering @xcite , and geometric methods @xcite .",
    "we refer the readers to @xcite for a broad survey of snl algorithms .",
    "the distance constraints in snl make the problem intrinsically non - convex . in the last few years",
    ", some very effective convex relaxations of the snl problem have been proposed @xcite .",
    "apart from offering remarkable localization accuracy in practice , these algorithms also come with guarantees on exact recovery and stability under appropriate assumptions on the network connectivity @xcite .",
    "a drawback of these algorithms is that their computational complexity often scales poorly with the network size .",
    "for example , the convex relaxations in @xcite result in semidefinite programs ( sdp ) with @xmath0 variables , where @xmath1 is the number of sensors . due to the high memory requirement and computational cost of standard interior - point sdp solvers @xcite , this limits the scope of these sdp - based methods to at most a few hundred sensors . to improve the scalability of the sdp method in @xcite ,",
    "an alternative ( and weaker ) second - order cone programming relaxation was proposed in @xcite that can handle a few thousand sensors .",
    "a more efficient enhancement of the sdp method that could solve for a few thousand sensors on a standard pc was later proposed in @xcite .",
    "our approach in this paper is along the lines of the divide - and - conquer algorithms for anchor - free localization that was proposed in @xcite . in particular",
    ", we solve the snl problem in three steps : ( 1 ) we divide the network into overlapping patches ( subnetworks ) , ( 2 ) we localize these small patches in parallel using some accurate sdp algorithm , and ( 3 ) we register the localized patches to determine the sensor positions in a globally - consistent fashion .",
    "the contribution of this paper concerns step ( 3 ) . in section 2 , we demonstrate how the non - convex problem of rigid registration ( particularly with anchor information ) can be relaxed into a tractable convex program .",
    "this can be seen as a multi - patch extension of the registration algorithm in @xcite . using the proposed sdp relaxation and performing the subnetwork localizations in parallel",
    ", we can solve for networks with up to @xmath2 sensors within @xmath3 minutes on a standard pc and a large @xmath4-sensor network within @xmath5 minutes .",
    "some preliminary simulation results in this direction are provided in section 3 .",
    "we now formally define the snl problem with anchors , which includes anchor - free snl as a special case .",
    "suppose we have @xmath1 sensors and @xmath6 anchors .",
    "denote the positions of the sensors and anchors by @xmath7 where , usually , @xmath8 or @xmath9 .",
    "we will generally refer to the sensors and anchors as _",
    "nodes _ of the network .",
    "we are provided the distances between pairs of nodes that are within a certain radio range of each other @xcite . to represent this distance information",
    ", we introduce the _ distance graph _",
    "@xmath10 where the vertices @xmath11 represent the nodes .",
    "the first @xmath1 vertices represent the sensors , while the last @xmath6 vertices the anchors .",
    "the edge set @xmath12 is given by the requirement that @xmath13 if and only if the distance @xmath14 between nodes @xmath15 is known .",
    "further , we write @xmath16 as the union of @xmath17 and @xmath18 , where @xmath17 are the sensor - sensor edges and @xmath18 are the sensor - anchor edges .",
    "the known distances are represented by @xmath19 . given @xmath20 and @xmath21 , the snl problem is to determine @xmath22 such that @xmath23 motivated by previous work @xcite , we propose the following divide - and - conquer algorithm .",
    "first , we divide @xmath24 into @xmath25 disjoint clusters by recursively partitioning @xmath26 using the shi - malik spectral clustering @xcite . of course , other alternative ways of partitioning could be considered . for each cluster ,",
    "we collect the neighbors of every vertex in that cluster ( @xmath27 and @xmath28 neighbors in @xmath26 if @xmath13 ) , and merge a subset of these neighbors with the cluster ensuring the size of the augmented cluster to be within a fixed bound ( details provided in section [ seciii ] ) .",
    "more specifically , we pick those neighbors that have the maximum number of edges incident on the cluster , that is , the neighbors that are `` most rigidly '' tied to the cluster . the general idea is to expand each cluster so that sufficient pairs of clusters have nodes in common .",
    "in particular , we now have overlapping _ patches _ @xmath29 , where @xmath30 . by construction",
    ", each node belongs to at least one patch , while some nodes belong to two or more patches .",
    "the latter nodes help in `` propagating '' information between patches during the final registration .",
    "we have reduced the large snl problem into @xmath25 smaller localization subproblems , one for each patch .",
    "this is where we speedup the computation by solving these subproblems in parallel .",
    "more precisely , for @xmath31 , let @xmath32 be the subgraph of @xmath26 induced by the vertices in @xmath33 , @xmath34 the distances in @xmath35 induced by the edges in @xmath32 , and @xmath36 the positions of the anchors in patch @xmath33 .",
    "we use either ` snlsdp ` @xcite or ` esdp ` @xcite ( which is a further relaxation of ` snlsdp ` ) to compute the positions of the sensor vertices in @xmath33 from the knowledge of @xmath37 and @xmath36 . for large",
    "noise and small sensing radius , ` snlsdp ` occasionally fails to localize certain patches ( the corresponding sdp is infeasible ) .",
    "we localize these exceptional patches using ` esdp ` , which is somewhat less accurate than ` snlsdp ` but has a larger scope .",
    "while one can also use other efficient snl algorithms , these sdp - based solvers suit our purpose as they offer a good tradeoff between accuracy and run - time for small problems . finally , we refine the sensor positions using the local optimization in @xcite .    at the end of this phase ,",
    "all the patches have been positioned in independent coordinate systems .",
    "if the @xmath27-th sensor belongs to patch @xmath33 , then we use @xmath38 to denote the position of that sensor in @xmath33 . in the ideal",
    "setting where each patch graph @xmath32 is uniquely localizable @xcite and the distances are noise - free , the local sensor positions @xmath39 are identical to the global positions @xmath40 up to a rigid transform that fixes the anchors @xcite . that is , for some orthogonal transform @xmath41 and translation @xmath42 , @xmath43 and @xmath44 it is understood here and henceforth that @xmath45 and @xmath46 .",
    "it remains to determine @xmath22 from the system of equations in and . in practice",
    ", one would expect these equations to hold only approximately due to various imperfections .",
    "thus , one would like to have a reconstruction in which the discrepancy from and is as small as possible .",
    "in particular , we consider the following quadratic loss @xmath47 given by @xmath48 where the optimization variables are : @xmath49 and @xmath50 . here and",
    "henceforth @xmath51 denotes the group of @xmath52 orthogonal matrices , @xmath53 is the euclidean norm , and @xmath54 is used to balance the loss .",
    "the slack variable @xmath55 is introduced to make @xmath47 homogeneous with respect to the variables .",
    "the above optimization can be seen as a generalization of the two - patch registration optimization addressed in @xcite .",
    "in fact , the present idea of first optimizing over the translations and then over the orthogonal transforms is similar to the strategy used in this paper .",
    "we first massage @xmath47 into something more compact using matrix notations .",
    "we begin by collecting the free variables ( sensor positions and translations ) and the constrained variables ( orthogonal transforms ) into two separate matrix variables : @xmath56 \\in \\mathbb{r}^{d \\times ( n+m ) } , \\\\",
    "\\nonumber   \\o & = & \\big[\\o_1 \\cdots \\o_{m+1 } ]   \\in \\mathbb{r}^{d \\times ( m+1)d}.\\end{aligned}\\ ] ] next , we introduce an undirected bipartite graph @xmath57 , where the vertices @xmath58 $ ] correspond to the sensor and anchor , and the vertices @xmath59 $ ] correspond to the patches .",
    "the edge set @xmath60 is given by the requirement that @xmath61 if and only if the @xmath27-th node is in patch @xmath33 . to distinguish between the sensors and anchors , we further divide @xmath62 into the sensor vertices @xmath63 $ ] and the anchor vertices @xmath64 $ ] .",
    "we denote the number of anchors in patch @xmath33 by @xmath65 .",
    "let @xmath66 denote the all - zero vector of length @xmath67 with @xmath68 at the @xmath69-th coordinate , and define @xmath70 in terms of the above notations , we can then write @xmath71 where @xmath72 is the @xmath52 identity matrix and @xmath73 is the kronecker product . by expanding out the squares and rearranging the terms , we get after some computation @xmath74 where @xmath75 note that the block matrix @xmath76 is of size @xmath77 , @xmath78 is of size @xmath79 , and @xmath80 is of size @xmath81 .",
    "in fact , @xmath82 , where @xmath83 is the laplacian of the bipartite graph @xmath84 that is obtained by removing the anchor vertices @xmath85 and the corresponding edges from @xmath26 . in particular , @xmath76 is positive semidefinite .",
    "moreover , if @xmath84 is connected and some @xmath86 , then @xmath76 is non - singular",
    ".    the optimization problem can now be compactly expressed as @xmath87 where @xmath41 denotes the @xmath69-th @xmath52 block of @xmath88 .",
    "the present strategy is to first solve for the unconstrained variable @xmath89 in terms of the unknown orthogonal transformations @xmath88 , representing the former as linear combinations of the latter . in particular , fix some arbitrary @xmath88 , and let @xmath90 .",
    "it is clear from that @xmath91 is quadratic in @xmath89 . in particular ,",
    "the stationary points @xmath92 of @xmath91 obtained by setting its gradient to zero are given by @xmath93 .",
    "note that the hessian of @xmath91 equals @xmath94 , and we known that @xmath76 is non - singular if @xmath84 is connected ( this is always true in practice ) and if there is at least one anchor .",
    "therefore , in this case the unique minimizer of @xmath91 is given by @xmath95 substituting @xmath96 in and simplifying , we have @xmath97 , where @xmath98 . in other words , denoting the @xmath99-th block of @xmath100 by @xmath101 , we have thus reduced the original problem to that of minimizing @xmath102 where the variables are the orthogonal matrices @xmath103 .",
    "this is clearly a difficult non - convex problem .",
    "we now present a convex relaxation of this problem following the ideas in @xcite .",
    "in particular , we consider the ( block ) gram matrix of the transforms , namely @xmath104 , which is of size @xmath105 and whose @xmath99-th block is given by @xmath106 . in terms of this gram matrix",
    ", we can equivalently formulate the optimization in as @xmath107 by dropping the non - convex rank constraint , we get the the following convex program : @xmath108 here @xmath109 means that @xmath110 is symmetric and positive semidefinite , and @xmath111 forces the diagonal @xmath52 blocks of @xmath110 to be identity matrices ( thus requiring each transform to be orthogonal ) .",
    "now is a standard convex program called a semidefinite program that has been well - studied @xcite .",
    "suppose that @xmath112 is the global minimizer of . by the diagonal block constraints in",
    ", it follows that @xmath113 .",
    "if @xmath114 is exactly @xmath115 , we have in fact solved the original non - convex problem ( relaxation is tight ) .",
    "in particular , the factorization @xmath116 , where @xmath117 has rank @xmath115 , gives us the desired orthogonal transforms .",
    "following and , we set @xmath118 and take the first @xmath1 columns of @xmath96 are taken to be the reconstructed global coordinates .",
    "+    on the other hand , if @xmath119 , we need to project @xmath120 onto the space of gram matrices of orthogonal transforms .",
    "in particular , let @xmath121 be the eigenvalues of @xmath120 , and @xmath122 be the corresponding eigenvectors .",
    "let @xmath123^t \\in \\mathbb{r}^{d \\times ( m+1)d}.\\ ] ] notice that due to the relaxation , the @xmath52 blocks of @xmath124 are not guaranteed to be orthogonal .",
    "we round each @xmath52 block of @xmath124 to its `` closest '' orthogonal matrix .",
    "more precisely , let @xmath125 $ ] .",
    "for every @xmath126 , we find @xmath127 that minimizes @xmath128 where @xmath129 denotes the frobenius norm .",
    "this has a closed - form solution , namely @xmath130 where @xmath131 is the svd of @xmath132 @xcite .",
    "following and , we form the matrix @xmath133 $ ] and take the first @xmath1 columns of @xmath118 to be the sensor coordinates .    in the final step ,",
    "we refine the sensor positions obtained at the end of registration using the gradient - based local search in @xcite .",
    "as we will see , this step is in fact quite effective in improving the localization accuracy .",
    "we denote the final sensor positions by @xmath134",
    ".    henceforth , we will refer to the proposed algorithm as ` snlsr ` , short for `` snl via subnetwork registration '' .",
    "we now present some simulation results for snl in @xmath135 using ` snlsr ` .",
    "all the simulations were carried out in matlab @xmath136 on a four - core @xmath137 ghz linux workstation with a @xmath138 gb memory .",
    "it is clear that the computation - intensive steps of our approach are the determination of the patch localizations and the solution of .",
    "the former was accomplished in a parallel fashion using the matlab implementations of ` snlsdp ` @xcite and ` esdp ` @xcite .    for solving the sdp relaxation of",
    ", we used the interior - point solver ` sedumi ` @xcite for medium - sized problems , and ` sdplr ` @xcite for large problems . for the hierarchical clustering",
    ", we partitioned @xmath26 in a recursive fashion until the size of each cluster is below @xmath5 .",
    "we next grow each cluster into a patch by adding its neighbors as explained in section [ secii ] , where we limit the patch size to @xmath139 .",
    "this is roughly the largest patch size for which the run time of ` snlsdp ` is reasonable .",
    "+    following @xcite , we generate the true positions of the sensors and anchors by drawing @xmath140 points @xmath141 from the uniform distribution on the unit square @xmath142 ^ 2 $ ] .",
    "we take the first @xmath1 points to be the sensors and the remaining @xmath6 points to be the anchors .",
    "following @xcite , we set @xmath143 $ ] . the distance graph @xmath10 is given by the condition that @xmath13 if and only if @xmath144 , where @xmath145 is the radio range .",
    "we also use the noise model from @xcite in which the measured distances are given by @xmath146 for @xmath147 where @xmath148 is the standard normal distribution and @xmath149 is the noise level . while other noise models could also be considered , we settled for this noise model to facilitate comparison with the results in @xcite .",
    "for the same reason , we use the root - mean - squared - deviation ( rmsd ) to quantify the localization accuracy which is given by the square root of @xmath150 .",
    "note that it is possible to register the patches in a globally consistent manner using the anchor - free registration , simply by dropping the equations in .",
    "do we get better localization accuracy by incorporating the anchor information into the registration ? exhaustive simulations ( not reported here ) show that by incorporating anchors into the registration , it is indeed possible to improve the accuracy .",
    "simulations show that if the noise is small and the patches are sufficiently rigid , then the margin of improvement is small",
    ". however , under more adversarial settings , the margin can be quite substantial .",
    "a particular example is presented in figure [ figure1 ] .",
    "notice the poor localization in ( c ) around the top left corner .",
    "this is because a couple of patches around this region were poorly localized by ` snlsdp ` , and moreover , the anchors in this region were not considered during the registration . as a consequence , the rigid transform associated with these patches were poorly estimated during the registration .",
    "also , notice that the gradient - based refinement is quite effective in reducing the rmsd in either case .",
    "in particular , while the rmsd gap is about @xmath151 after the registration , the gap comes down to about @xmath152 after the refinement .",
    ".comparison of the run time and localization accuracy of ` snlsr ` ( @xmath153 and rmsd1 ) with @xcite ( @xmath154 and rmsd2 ) for the unit - square graph .",
    "we used ` snlsdp ` @xcite for @xmath155 , and ` esdp ` @xcite for larger problems ( see text for further details ) . [",
    "cols=\"<,<,<,<,<,<,<\",options=\"header \" , ]     [ table1 ]    we next compare ` snlsr ` with the sdp - based methods in @xcite , both in terms of accuracy and scalability .",
    "using the computational resources mentioned earlier , we could solve for at most @xmath156 sensors using ` snlsdp ` @xcite .",
    "we used ` esdp ` to address larger problems .",
    "simulations suggest that our divide - and - conquer method is significantly faster ( often by an order ) than these methods .",
    "the accuracy of ` snlsr ` is comparable , and occasionally better , than these methods .",
    "a visual comparison for a moderate - sized problem is provided in figure [ figure2 ] .",
    "further comparisons are provided in table [ table1 ] .",
    "we note that we empirically tuned @xmath157 in @xmath47 to get the minimum rmsd from ` snlsr ` . for the snl settings considered here , the optimal @xmath157 was in the interval @xmath158 , and the variability of the rmsd within this interval was small ( within @xmath159 of the optimal ) , and even smaller after the refinement .",
    "we presented a divide - and - conquer approach for snl and demonstrated its utility for large - scale problems .",
    "in particular , we showed how the non - convex problem of registering the subnetworks can be relaxed and solved efficiently using modern convex programming tools .",
    "while the simulation results presented here are far from exhaustive , they nevertheless demonstrate that the idea of localizing patches in parallel and then registering them in a globally consistent fashion can indeed lead to fast and scalable algorithms .",
    "n. patwari , j. n. ash , s. kyperountas , a. o. hero iii , r. l. moses , and n. s. correal , `` locating the nodes : cooperative localization in wireless sensor networks , '' _ ieee signal processing magazine _ , vol .",
    "22(4 ) , pp . 54 - 69 , 2005 .",
    "u. a. khan , s. kar , and j. f. moura , `` diland : an algorithm for distributed sensor localization with noisy distance measurements , '' _ ieee transactions on signal processing _ ,",
    "58(3 ) , pp .",
    "1940 - 1947 , 2010 .",
    "p. biswas , t .- c .",
    "liang , k .- c .",
    "toh , y. ye , and t .- c .",
    "wang , `` semidefinite programming approaches for sensor network localization with noisy distance measurements , '' _ ieee transactions on automation science and engineering _ , vol .",
    "3(4 ) , no .",
    "360 - 371 , 2006 ."
  ],
  "abstract_text": [
    "<S> in this paper , we describe an algorithm for sensor network localization ( snl ) that proceeds by dividing the whole network into smaller subnetworks , then localizes them in parallel using some fast and accurate algorithm , and finally registers the localized subnetworks in a global coordinate system . </S>",
    "<S> we demonstrate that this divide - and - conquer algorithm can be used to leverage existing high - precision snl algorithms to large - scale networks , which could otherwise only be applied to small - to - medium sized networks . the main contribution of this paper concerns the final registration phase . in particular , we consider a least - squares formulation of the registration problem ( both with and without anchor constraints ) and demonstrate how this otherwise non - convex problem can be relaxed into a tractable convex program . we provide some preliminary simulation results for </S>",
    "<S> large - scale snl demonstrating that the proposed registration algorithm ( together with an accurate localization scheme ) offers a good tradeoff between run time and accuracy .    </S>",
    "<S> sensor network localization , anchors , scalability , divide - and - conquer , rigid registration , semidefinite programming . </S>"
  ]
}