{
  "article_text": [
    "the low latency fault tolerance ( llft ) system provides fault tolerance for distributed applications , using the leader - follower replication technique .",
    "llft provides application - transparent replication , with strong replica consistency , for applications that involve multiple interacting processes or threads .",
    "llft supports client - server applications where both client and server processes are replicated , and three - tier applications where middle - tier processes are replicated .",
    "llft provides fault tolerance for distributed applications deployed over a local - area network , as in a data center , rather than over a wide - area network , such as the internet .    with llft ,",
    "the processes of the application are replicated , and the replicas of a process form a process group . within a process group ,",
    "one replica is designated as the primary replica , and the other replicas are the backup replicas .",
    "the primary in a process group multicasts messages to a destination process group over a virtual connection , as shown in figure  [ conn ] .",
    "the primary in the destination process group orders the messages , performs the operations , and produces ordering information for non - deterministic operations , which it supplies to the backups in the destination group .",
    "the llft system provides fault tolerance for the distributed applications , with the following properties .",
    "* strong replica consistency . *",
    "the llft system replicates the processes of an application , and maintains strong replica consistency within a primary component .",
    "the application continues to run without loss of processing or messages , and without disruption to its state .",
    "if a fault occurs , llft provides reconfiguration and recovery while maintaining virtual synchrony @xcite , including transfer of state from an existing replica to a new replica and synchronization of the operation of the new replica with the existing replicas . to maintain strong replica consistency within a primary component , llft sanitizes ( masks ) non - deterministic operations , including multi - threading , time - related operations and socket communication .    * low latency . *",
    "the llft system achieves low latency message delivery during normal operation , and low latency reconfiguration and recovery when a fault occurs .",
    "that is , it provides fault tolerance to the applications with minimal overhead in the response times seen by the clients .",
    "llft achieves low latency by design , in that the primary makes the decisions on the order in which operations are performed and the ordering information is reflected to its backups .",
    "moreover , the replicated applications interact with each other directly , without an intermediate daemon process and without additional context switches .    * transparency and ease of use . *",
    "the llft system provides fault tolerance that is transparent to the application .",
    "the application is unaware that it is replicated , and is unaware of faults .",
    "applications programmed using tcp socket apis , or middleware such as java rmi , can be replicated without modifications to the applications .",
    "the application programs require no extra code for fault tolerance , and the application programmers require no special skills in fault tolerance programming .",
    "the application program is identical to that of a non - fault - tolerant unreplicated applications .",
    "= 5.6 in    the novel contributions of this work lie in the design of the components of the llft system .",
    "* low latency messaging protocol .",
    "* the low latency messaging protocol provides reliable , totally ordered message delivery by communicating message ordering information from the primary replica to the backup replicas in a group .",
    "it ensures that , in the event of a fault , a backup has , or can obtain , the messages and the order information that it needs to reproduce the actions of the primary .",
    "the replicated applications interact with each other directly , via a group - to - group multicast .",
    "* leader - determined membership protocol . *",
    "the leader - determined membership protocol ensures that the members of a process group have a consistent view of the membership set and of the primary replica in the group .",
    "it effects a membership change and a consistent view more quickly than other membership protocols , by selecting a new primary deterministically , based on the precedences and ranks ( defined below ) of the backups in the group and by avoiding the need for a multi - round consensus algorithm .",
    "* virtual determinizer framework . *",
    "the virtual determinizer framework renders the replicas of an application virtually deterministic by recording the order and results of each non - deterministic operation at the primary , and by guaranteeing that the backups obtain the same results in the same order as the primary .",
    "the virtual determinizer framework has been instantiated for major sources of non - determinism , including multi - threading , clock - related operations and socket communication .",
    "llft operates in an asynchronous distributed system that comprises one or more applications running on multiple processors and communicating over a local - area network , such as an ethernet .",
    "clients that run outside the local - area network are supported via a gateway .",
    "an application consists of one or more processes , possibly multi - threaded with shared data , that interact with each other and also with file systems and database systems .    a process that is non - faulty completes a computation , but there is no bound on the time required to complete the computation .",
    "the processes communicate via messages using an unreliable , unordered message delivery service , such as udp multicast , with no bound on the time required to communicate a message . with asychronous messaging",
    ", no protocol can guarantee reliable message delivery within a time bound .",
    "thus , we adopt the ( theoretical ) assumption of _ eventual reliable communication _ , _",
    "i.e. _ , if a message is transmitted repeatedly , it is eventually received , as do other researchers @xcite .",
    "the llft system replicates application processes to protect the application against various types of faults , in particular :    * _ * crash fault * _ - a process does not produce any further results . * _ * timing fault * _ - a process does not produce a result within a given time constraint .",
    "llft does not handle byzantine faults .",
    "llft allows processes to recover but , when a process recovers , it is regarded as a new process with a new identity ( birthid ) .",
    "llft also handles communication network faults , including message loss , selective communication loss , and partitioning faults .",
    "healing of partitioning faults is guaranteed by the eventual reliable communication assumption .    to achieve liveness and termination of the algorithms",
    ", llft uses unreliable fault detectors based on timeouts .",
    "the fault detectors are necessarily unreliable , and the timeouts are a measure of how unreliable the fault detectors are .",
    "crash faults are detected as timing faults by the llft fault detectors .",
    "llft uses a leader - follower algorithm to establish the total order of messages , to render operations virtually deterministic , and to establish a consistent group membership .",
    "it does not use a consensus algorithm based on unreliable fault detectors @xcite to circumvent the impossibility result @xcite .",
    "moreover , llft does not assume that a majority of the processes in a group is non - faulty , as do other works such as @xcite .",
    "rather , llft adopts the ( theoretical ) assumption of _ sufficient replication _ , _",
    "i.e. _ , in each primary view , there exists at least one replica that does not become faulty .",
    "the price of this relaxation is that llft must be able to detect and heal partitions of the group membership , which it does using a precedence mechanism ( described below ) .",
    "the risk of multiple concurrent memberships , and thus the need to detect and heal partitions , can be avoided only in systems in which a majority vote is used not only for membership , but also for every value that is communicated , as is done in aircraft flight control systems @xcite .",
    "llft ensures that only one component of a partition , which we refer to as the _ primary component _",
    ", survives in the infinite sequence of consecutive primary views of a group . within that primary component ,",
    "llft maintains _ virtual synchrony _ @xcite which means that , if the primary fails , the new primary must advance to the state of the old primary , in particular the state known to the remote groups of its connections , before it failed .",
    "the replicas of a process form a _ process group ( virtual process)_. each process group has a unique identifier ( _ group i d _ ) , which is supplied by the user .",
    "we equate a process group with its group i d .",
    "this group i d is mapped by llft to a virtual port on which the group sends and receives messages , as discussed below .",
    "each process group has a _ group membership _ that consists of the replicas of the process . typically , different members of a process group run on different processors .",
    "one of the replicas in the process group is the _ primary replica _ , and the other members are the _ backup replicas_. each membership change that introduces a new primary replica constitutes a new _ primary view",
    "_ , which has a _ primary view number_. each member of a process group must know the primary replica in its group .",
    "there is no need for the members of a sending process group to know which member of a destination process group is the primary replica .",
    "the llft system introduces the novel , elegant idea of a virtual connection , which is a natural extension of the point - to - point connection of tcp .",
    "a _ virtual connection _ is a connection between two endpoints , where each endpoint is a process group , over which messages are communicated between the two group endpoints .",
    "a virtual connection is a full - duplex , many - to - many communication channel between the two endpoints .",
    "a sender uses udp multicast to send messages to a destination group over the virtual connection .",
    "a _ virtual port ( group i d ) _ identifies the source ( destination ) group from ( to ) which the messages are sent ( delivered ) over the virtual connection .",
    "all members of a group listen on the same virtual port , and members of different groups listen on different virtual ports .",
    "the groups need to know the virtual ports ( group ids ) of the groups with which they are communicating , just as with tcp .",
    "typically , a process group is an endpoint of more than one virtual connection , as shown in figure [ conn ] , where there are multiple process groups , representing multiple applications running on different processors and interacting over the network , but there might be only two process groups and one virtual connection .",
    "the llft system supports two types of leader - follower replication , namely :    * _ * semi - active replication * _ - the primary orders the messages it receives , performs the operations , and provides ordering information for non - deterministic operations to the backups .",
    "a backup receives and logs incoming messages , performs the operations according to the ordering information supplied by the primary , and logs outgoing messages , but does not send outgoing messages . * _ * semi - passive replication * _ - the primary orders the messages it receives , performs the operations , and provides ordering information for non - deterministic operations to the backups .",
    "in addition , the primary communicates state updates to the backups , as well as file and database updates .",
    "a backup receives and logs incoming messages , and updates its state , but does not perform the operations and does not produce outgoing messages .",
    "semi - passive replication uses fewer processing resources than semi - active replication , but it incurs greater latency for reconfiguration and recovery , if the primary fails .    to maintain strong replica consistency within a primary component , it is necessary to sanitize ( mask ) non - deterministic operations not only for semi - active replication but also for semi - passive replication .",
    "for example , consider requests from two clients that are processed concurrently using semi - passive replication .",
    "processing the request from the first client updates a data item .",
    "processing the request from the second client then updates the same data item .",
    "the request from the second client completes , and the primary sends its update to the backups and its reply to the second client .",
    "the primary then fails before it can send its update to the backups and its reply to the first client .",
    "the processing of the request from the first client is repeated at the new primary .",
    "however , the update to the data item has already been performed and recorded at the backup , before it became the new primary , when the reply was sent to the second client .",
    "the update must not be repeated if the correct result is to be obtained .      the safety and liveness properties for llft , based on the above model ,",
    "are stated below . traditionally , safety and liveness properties are strictly separated . however , in a system that might incur a communication partitioning fault with subsequent recovery from that partitioning , safety is necessarily dependent on liveness . while the system is partitioned , even complete knowledge of all processes does not suffice to determine which of the two or more competing branches is a transient side branch that will be terminated when the partition is healed .",
    "thus , the safety properties for llft are defined in terms of an infinite sequence of consecutive primary views , as assured by the liveness properties .",
    "the proofs of correctness can be found in the appendix .",
    "a discussion of the assumptions of the model , relative to these properties , is included below .      for each process group :",
    "* there exists at most one infinite sequence of consecutive primary views for the group .",
    "each of those primary views has a unique primary view number and a single primary replica .",
    "* there exists at most one infinite sequence of operations in an infinite sequence of consecutive primary views for the group . * for semi - active replication ,",
    "the sequence of operations of a replica , in a membership of the infinite sequence of consecutive primary views , is a consecutive subsequence of the infinite sequence of operations for the group . * for semi - passive replication ,",
    "the sequence of states of a replica , in a membership of the infinite sequence of consecutive primary views , is a consecutive subsequence of the infinite sequence of states for the group .      for each process group :",
    "* there exists at least one infinite sequence of consecutive primary views with consecutive primary view numbers for the group .",
    "* there exists at least one infinite sequence of operations in each infinite sequence of consecutive primary views for the group .",
    "llft imposes implicit bounds on the computation time and the communication time in the form of tunable timeout parameters of the fault detectors . due to the asynchrony of the system ,",
    "those bounds might be violated , which might lead to a replica being mistakenly removed from the membership .    with the assumption of eventual reliable communication ( _ i.e. _ ,",
    "if a message is transmitted repeatedly , it is eventually received ) , a replica that is mistakenly removed from the membership eventually receives a primarychange or removebackup message that informs it that it has been removed .",
    "the replica then applies for readmission to the membership using the proposebackup message . without the assumption of eventual reliable communication ,",
    "a mistakenly removed replica might not receive those messages and , thus , not apply for readmission .",
    "the tuning of the timeout parameters for the fault detectors , relative to the distribution of the times for computation and communication , can be viewed as a probabilistic optimization problem .",
    "the latency to determine a new primary and a new membership after detection of a genuine fault ( true positive ) is matched against the latency caused by detection of a mistaken fault ( false positive ) , to minimize the overall latency of the system .",
    "with the assumption of sufficient replication ( _ i.e. _ , each group contains enough replicas such that in each primary view there exists a replica that does not become faulty ) , the sequence of operations of a group is infinite . without the assumption of sufficient replication , the sequence of operations of a group might be finite .",
    "the llft messaging protocol converts the unreliable , unordered message delivery service of udp multicast into a reliable , totally ordered message delivery service between two group endpoints , just as tcp converts the unreliable message delivery service of ip unicast into a reliable , totally ordered message delivery service between two individual endpoints .",
    "the messaging protocol provides the following services for the application messages :    * _ * reliable delivery * _ - all of the members in a group receive each message that is multicast to the group on a connection . * _ * total ordering * _ - all of the members in a group deliver the messages to the application in the same sequence . * _ * buffer management * _ - when a message no longer needs to be retransmitted ( because all of the intended destinations have received the message ) , the source and the destinations remove the message from their buffers .",
    "the messaging protocol provides reliable , totally ordered message delivery , while maintaining virtual synchrony @xcite in the event of a fault .",
    "it incorporates flow control mechanisms similar to those used by tcp .",
    "flow control is needed to ensure that processing in the primary receiver , and in the backups , can keep up with the primary sender , and that buffer space does not become exhausted .",
    "the types of messages used by the messaging protocol are shown on the left of figure  [ messagetypesmessageheaders ] and are illustrated in figure [ reliable - messaging ] . a request or reply message",
    "is not necessarily a synchronous blocking request or reply , as is commonly used in client / server communication ; a request or reply message can be an asynchronous one - way message . a retransmitted request or",
    "reply message uses the same message type as the original message .",
    "the fields of a message header are shown on the right of figure  [ messagetypesmessageheaders ] .",
    "the quadruple ( sourcegroupid , destgroupid , connseqnum , role ) uniquely identifies a connection , where role is client or server .",
    "a message with a non - zero message sequence number msgseqnum , _",
    "i.e. _ , a request or reply message multicast by the primary is inserted into the sent list at the sender and the received list at the destination .",
    "an ack acknowledges not only the acknowledged message but also all prior messages from the remote primary of the connection , and allows more rapid retransmission and delivery of missing messages .    in a message multicast by the primary on a connection , back contains the primary s mygroup watermark , _",
    "i.e.,@xmath0_the minimum timestamp watermark of the group , which is the minimum of the primary s own mytime stampwatermark and all of the backups mytimestampwatermarks . in a control message sent by a backup to its primary",
    ", back contains the backup s mytimestampwatermark , _",
    "i.e.,@xmath0_the minimum timestamp of messages that the backup received on all of its connections .",
    "the timestamp , which drives the backs , is used for buffer management and not for message ordering .",
    "= 3.3 in      to achieve reliable , totally ordered message delivery , for each connection , the messaging protocol uses the variables shown on the left of figure  [ variables ] .",
    "the message sequence number is used by a member of the destination group to ensure that it has received all messages from the sending group on the connection .",
    "when a member acknowledges the message with message sequence number receiveduptomsn , it indicates that it has received all messages , sent on the connection , with message sequence numbers less than or equal to this sequence number .    for buffer management ,",
    "the messaging protocol uses lamport timestamps and timestamp watermarks to determine when all intended destinations have received a message .",
    "in particular , it uses the global variables shown at the right of figure  [ variables ] .",
    "a message carries mygroupwatermark in the back field of its header , as a form of acknowledgment , so that the remote group can safely discard , from its buffers , messages sent to the group that carry timestamps less than this group watermark .",
    "the primary and the backups use the same timestamp value for a message , which is essential for timestamp watermark - based buffer management .",
    "figure [ data - structures ] shows the pseudocode for the orderinfo struct ( lines 1 - 7 ) and the msgorder struct ( lines 8 - 15 ) . the opaque field ( line 12 ) stores different orderinfo entries for different message types . for a normal read , and a sucessful nonblocking write",
    ", it stores the offset with respect to the lower bound m_msgseqnum so that the upper bound can be calculated , which allows the merger of orderinfo entries for consecutively sent / delivered messages from the same connection into a single orderinfo entry . for a nonblocking write",
    ", it stores the number of times that the same message has been attempted , but failed , to send .",
    "if other orderinfo entries have been created in between , there might be multiple orderinfo entries for the same message .",
    "there is no orderinfo entry for a blocking write .",
    "reliable message delivery is described below in terms of a request from a client group @xmath1 to a server group @xmath2 .",
    "the same considerations apply for a reply from a server group @xmath2 to a client group @xmath1 .",
    "the pseudocode for the messaging protocol is given in figure [ messaging - alg ] .",
    "the primary in group @xmath1 multicasts messages originated by the application to a destination group over a virtual connection .",
    "a backup in group @xmath1 creates and logs ( but does not multicast ) messages originated by the application .",
    "restricting the actions of the backup in this way reduces the amount of network traffic .",
    "when the primary in group @xmath1 first multicasts an application message to group @xmath2 on a connection , it stores the message in a sent list for the connection ( lines 15 - 17 ) .",
    "the primary retransmits a message in the sent list if it does not receive an acknowledgment for the message sufficiently promptly ( as determined by a timeout ) ( lines 45 - 46 ) .",
    "the primary in group @xmath2 includes , in the header ( ack field ) of each application message it multicasts to group @xmath1 on a connection , the message sequence number of the last application message it received without a gap from the primary in group @xmath1 on that connection ( line 10 ) . if the primary in group @xmath2 does not have a message to multicast on the connection sufficiently promptly ( as determined by a timeout ) , it multicasts a firstack message containing an ack for the last application message it received without a gap ( lines 47 - 48 ) .    the primary ( and a backup ) in group",
    "@xmath2 checks the precedence field of a message it receives to determine whether the message originated in a competing membership whose primary has higher precedence .",
    "if so , it multicasts the message on the intra - group connection to ensure that all other members have also received the message , resets its state and rejoins the group ( lines 18 - 20 ) .    the primary ( and a backup ) in group",
    "@xmath2 adds the application messages it receives on the connection to a received list for the connection ( lines 25 , 31 ) , and updates the receiveduptomsn variable ( last message received without a gap ) ( line 32 ) .",
    "if the replica detects a gap in the message sequence numbers ( lines 22 - 25 ) , it creates placeholders for the missing messages , and adds corresponding entries to a nack list . if the replica receives a retransmitted message , and a placeholder for the message exists , it replaces the placeholder with the message and , otherwise , discards the retransmitted message ( lines 26 - 30 ) .",
    "a backup in group @xmath1 acknowledges a firstack message it receives with a secondack message ( lines 60 - 68 ) .",
    "the backup sends a secondack message in response to receiving a firstack message only if the backup application has generated the message that the firstack message acknowledges . if there is no backup in group @xmath1 , the primary in group @xmath1 carries out this responsibility . the primary in group",
    "@xmath2 stops retransmitting a firstack message on receiving the corresponding secondack message ( lines 70 - 71 ) .",
    "if a primary in group @xmath1 receives too many firstack messages from the primary in group @xmath2 , acknowledging the last message the primary in group @xmath1 sent , then the primary in group @xmath2 has not received a secondack from the backups in group @xmath1 .",
    "consequently , the primary in group @xmath1 invokes the intra - group flow control mechanisms to slow down , so that the backups in group @xmath1 can catch up ( lines 65 - 66 ) .",
    "if the primary in group @xmath2 does not have a message to multicast on an inter - group connection sufficiently promptly ( as determined by a timeout ) after it has stopped retransmitting the firstack message due to receiving the secondack message , it multicasts a keepalive message on the connection to indicate the liveness of the connection ( lines 54 - 55 ) .",
    "if the primary ( a backup ) in group @xmath2 determines that it has not received a message from the primary in group @xmath1 on a connection , it multicasts a nack message on the remote ( local ) connection ( lines 49 - 52 ) .",
    "such a determination occurs if :    * the primary or a backup in group @xmath2 sees a gap in the message sequence numbers of the messages it received ( line 24 ) , or * a backup in group @xmath2 receives a secondack message that contains an ack for a message that the backup has not received ( line 72 ) , or * a backup in group @xmath2 receives a message from the primary in group @xmath2 that orders a message that the backup has not received .",
    "the primary and each backup in group @xmath2 periodically exchange heartbeat messages on the intra - group connection ( lines 56 - 59 ) , so that the primary knows that the backup has not failed ( and vice versa ) and the buffer management mechanisms work properly .",
    "the primary in a group communicates ordering information to the backups in its group , so that they obtain the same results in the same order as the primary and , thus , maintain strong replica consistency .",
    "in particular , the primary in group @xmath1 piggybacks , on each message it originates and sends on a connection , the ordering information for the messages it sent on the connection and received on the connection since the last message it sent on the connection ( along with ordering information for other types of operations , as described in section [ determinizer - sec ] ) . a backup in group @xmath1 does not receive the ordering information directly from the primary in group @xmath1 .",
    "instead , the primary in group @xmath2 reflects back the ordering information to group @xmath1 in the next message it multicasts to group @xmath1 . the primary in group",
    "@xmath1 includes the ordering information in each message it sends until it receives that information reflected back to it .",
    "similarly , the primary in group @xmath1 reflects back to group @xmath2 the ordering information it receives in messages from the primary in group @xmath2 .",
    "a replica must retain each message that it originates and that it receives , until it knows that it will no longer need the message , either to retransmit the message in response to a negative acknowledgment or , to process the message if the primary fails and it becomes the new primary .    in llft , timestamps and timestamp watermarks are used for buffer management . each replica in a group maintains a timestamp mygroupwatermark .",
    "each message carries in the back field of the message header the group watermark of the sending group .",
    "each replica in a group maintains , for each connection , a remotegroupwatermark , to store the latest group watermark received from the remote group of that connection .",
    "as shown in figure [ messaging - alg ] ( lines 76 - 84 ) , a replica that sends a message garbage collects the message if the timestamp in the message header is less than or equal to the remotegroupwatermark for the connection on which the message is sent . a replica that receives and delivers a message garbage collects the message if the timestamp in the message header is less than or equal to the mygroupwatermark for that replica s group .",
    "the formation of a membership has been based on two - phase commit with a majority of correct processes to achieve consensus agreement and avoid the split brain problem in which two or more competing memberships are formed @xcite .",
    "unfortunately , in the presence of unreliable communication , it is difficult or expensive to eliminate the risk of competing memberships .",
    "if a communication problem occurs , some of the members might form a new membership , while other members continue to operate with the existing membership .",
    "it is possible to avoid such a situation only if every value that is communicated is subjected to a majority vote of the membership , which is what is done in aircraft flight control systems @xcite . under conditions of unreliable communication",
    ", it is undesirable to degenerate into multiple competing memberships , possibly singleton memberships , and it is also undesirable to fail to form a membership .",
    "the objective must be to form the best possible membership ( a heuristic criterion ) , to detect and heal partitions that form , and to reestablish a consistent state following recovery from a partition @xcite .",
    "the llft membership protocol addresses the problem of maintaining a consistent view of the membership at the primary and the backups .",
    "it ensures that they have the same membership set , the same primary view number , and the same primary , by handling changes at the primary and the backups .",
    "the primary , in turn , determines the addition ( removal ) of the backups to ( from ) the group , as well as their precedences and ranks ( defined below ) . by making a deterministic choice of the primary ,",
    "the membership protocol is faster than a multi - round consensus algorithm @xcite , which is particularly important when normal processing is suspended by primary failure .",
    "the _ precedence _ of a member of a group is determined by the order in which the member joins the group .",
    "if a member fails and subsequently restarts , it is considered a new member , and is assigned a new precedence .",
    "the precedences increase monotonically so that , in the infinite sequence of consecutive primary views for a group , no two members have the same precedence and a member that joins later has a higher precedence .",
    "when a primary adds a new backup to the membership , it assigns the next precedence in sequence to that backup .",
    "the precedences of the members determine the order of succession to become the new primary , if the primary fails .",
    "the _ rank _ of the primary member of a group is @xmath3 , and the ranks of the backup members are @xmath4 when a proposed new primary assigns ranks to the backups of a new membership or when a primary adds a new backup to the membership , it assigns those ranks in the order of their precedences .",
    "the ranks determine the timeouts for detection of faults in the primary or the backups .",
    "the rank of a member can change when another member is removed from the group , whereas the precedence of a member is assigned when it joins the group and does not change while it is a member .",
    "the ranks of the members are consecutive , whereas the precedences need not be , due to removal of a member from the group .",
    "to avoid the situation where two backups both claim to be the next new primary , the fault detection timeouts for the backups increase with increasing rank .",
    "the backup with rank 3 operates a fault detector to determine that the primary is faulty and that the backup with rank 2 is faulty , because it did not determine that the primary is faulty .",
    "thus , the fault detector operated by the backup with rank 3 has a longer timeout than the fault detector operated by the backup with rank 2 , _ etc . _    for efficiency reasons",
    ", the fault detector timeouts must be chosen carefully .",
    "timeouts that are too long cause unnecessary delays after a fault , whereas timeouts that are too short cause membership churn and readmission of members to the group .",
    "for example , the timeout of the fault detector operated by the backup with rank @xmath5 might be 10ms , the timeout of the fault detector operated by the backup with rank @xmath6 might be 30ms , _",
    "etc_. thus , the fault detector timeout of the backup with rank @xmath6 allows for 10ms of inaction by the primary , an additional 10ms of inaction by the backup with rank @xmath5 , and an additional 10ms for skew between the timeouts of the backups .",
    "given its longer timeout , timing out the backup with rank @xmath6 is rare .",
    "however , it might still happen that two backups both propose to become the new primary .",
    "in such a case , the backup with the lower precedence gives up and the backup with the higher precedence continues .",
    "for example , if the backup with rank 2 and the backup with rank 3 both propose to become the new primary , because the backup with rank 3 has higher precedence , it overrides the backup with rank 2 .",
    "only membership changes that correspond to a change of the primary constitute a new view , which we refer to as a _ primary view change_. each new primary view has a _ primary view number_. when the primary view changes , the proposed new primary adjusts the members ranks and resets the message sequence number to one on each of its connections .",
    "it is important for the backups to change the primary view at the same virtual synchrony point as the primary . to this end ,",
    "the new primary produces an ordering information entry for the primary view change and multicasts that entry to the backups , just like the other ordering information . a backup changes to the new primary view when it has performed all of the operations that were ordered before the virtual synchrony point , as described below .",
    "both the primary and the backups in a group need to know when there is a change in the primary of the group , because at that point their ranks change and the message sequence numbers are reset to one . they also need to know about the addition ( removal ) of a backup , because such an event can result in a change in their ranks .",
    "moreover , to achieve reliable message delivery , both the primary and the backups need to know when there is a change in the primary of a remote group .",
    "however , they do not need to know about membership changes due to addition ( removal ) of a backup to ( from ) the remote group .",
    "the types of messages used by the membership protocol are described in figure [ membershipmessages ] and are illustrated in figure [ reliable - membership ] .",
    "the proposeprimary , proposebackup , acceptbackup and removebackup messages are multicast on the intra - group connection .",
    "the proposeprimary , acceptbackup and removebackup messages include the old membership in the payload , and require an explicit acknowledgment from each backup .",
    "for the primary , these acknowledgment messages serve as `` commit '' messages .",
    "the primary ( including the self - appointed new primary ) must retransmit these messages until all of the backups in the membership ( as determined by the primary ) have acknowledged them .",
    "the reason is that all of the members in the group must have a consistent view of the membership and the ranks of the members .",
    "the change of the primary in a group is handled in two phases , as described below .",
    "the pseudocode for the membership protocol for change of the primary is shown in figure [ alg - primary - change ] . in the rules below",
    ", @xmath7 denotes the primary view with primary view number @xmath8 which corresponds to mypvn in the pseudocode , and @xmath9 denotes the precedence of the primary which corresponds to myprecedence in the pseudocode .      in the first ( election ) phase , the new primary is determined .",
    "the new primary determines which backups are included in the new membership and their precedences and ranks .",
    "more specifically , the first phase operates as follows :    * if a backup with precedence @xmath9 does not receive a heartbeat message from the primary of view @xmath7 within a given time period ( and thus determines that the primary is faulty ) and it has not received a proposeprimary message for view @xmath7 from a backup with precedence @xmath10 , the backup multicasts a proposeprimary message on the intra - group connection , denouncing the old primary and appointing itself as the new primary of view @xmath11 . * * the backup excludes from the membership the old primary and the backups with precedences @xmath10 ( line 4 ) .",
    "it excludes such a backup because that backup did not send a proposeprimary message quickly enough to become the new primary and , thus , is declared to be faulty .",
    "* * the backup includes , in the proposeprimary message , the group identifier , the proposed new membership , its current primary view number @xmath8 and its precedence @xmath9 ( line 5 ) . *",
    "if a backup with precedence @xmath12 receives a proposeprimary message for a new primary view @xmath11 , from a proposed new primary with precedence @xmath9 , and the backup is included in the proposed new membership ( which implies that @xmath13 ) , and * * the backup has not generated a proposeprimary message for view @xmath11 , and * * the backup has not acknowledged a proposeprimary message from a backup with precedence @xmath14 for view @xmath11 + then the backup with precedence @xmath12 accepts the proposed new membership and acknowledges the proposeprimary message ( lines 21 - 24 ) . *",
    "if a backup receives a proposeprimary message for new primary view @xmath11 , or a subsequent view , from a proposed new primary with precedence @xmath9 , and the backup is not included in the proposed new membership , and * * the backup has not generated a proposeprimary message for view @xmath11 and @xmath13 , and * * the backup with precedence @xmath12 has not received a proposeprimary message for view @xmath11 from a backup with precedence @xmath14 + then the backup resets its state and rejoins the group ( line 25 ) .",
    "* when the proposed new primary has received acknowledgments for its proposeprimary message from all members in the proposed new membership , it concludes the first phase and proceeds to the second phase ( lines 14 - 16 ) .",
    "note that the sets of conditions in the second and third bullets above are not complementary and collectively exhaustive .",
    "if a backup receives a proposeprimary message that does not satisfy either of those sets of conditions , it ignores that proposeprimary message .",
    "the mechanisms for change of the primary determine the new membership of the group using only one round of message exchange ( proposeprimary and corresponding acknowledgments ) . in a tradeoff for simplicity and timeliness , the mechanisms do not attempt to form a new membership with the maximum possible number of members .",
    "= 3.1 in    [ reliable - membership ]      in the second phase , the new primary queries the remote group of each of its inter - group connections regarding the old primary s state , and determines a virtual synchrony point .",
    "the new primary needs to know the last message sent by the old primary and delivered to each remote group on a connection and , in particular , the ordering information piggybacked onto the last message . to advance to the state of the old primary known to the remote groups",
    "before the old primary failed , the new primary must follow the ordering information . more specifically ,    * the new primary collects information for the virtual synchrony point by multicasting a newprimaryview message on each of its inter - group connections ( lines 28 - 29 ) .",
    "the newprimaryview message contains the most recent ordering information known to the new primary for the connection . * on receiving the newprimaryview message",
    ", the primary of the remote group flushes all messages that came after the last message delivered from the old primary s group ( line 38 ) .",
    "the primary of the remote group acknowledges the newprimaryview message by providing information regarding the last message delivered from , and the last message sent to , the old primary s group ( line 41 ) .",
    "the primary of the remote group sends back the ordering information to the new primary either in a new application message , or in a keepalive message if it does not have an application message to send . * on receiving an acknowledgment from the primary of the remote group , the new",
    "primary determines whether it has missed any messages from that primary .",
    "the new primary then sends nacks for all missing messages until it has received them ( line 30 ) .",
    "the new primary retrieves the ordering information piggybacked on application messages or keepalive messages from the primary of the remote group .",
    "* when the new primary has executed all of the operations according to the ordering information determined by the old primary , it concludes the second phase by resetting the message sequence numbers to one , adjusting the backups ranks , and generating an ordering information entry declaring the start of a new primary view ( lines 33 - 35 ) .",
    "the backups switch to the new primary view when they receive and process the ordering information .",
    "the change of a backup is either the addition of a backup to the group , or the removal of a backup from the group .",
    "the pseudocode for the membership protocol for the addition ( removal ) of a backup is shown in figure [ alg - backup - change ] .",
    "the pseudocode for joining a process group ( lines 1 - 14 ) includes the case where a process is the first member of the group and , thus , is the primary .",
    "a new process begins to log messages as soon as it starts up ( line 1 ) .",
    "the mybirthid of a process ( line 5 ) is a unique identifier , similar to a birth certificate .",
    "it is used to distinguish a process that wishes to join the membership and that does nt yet have a precedence .",
    "the precedence is a unique identifier for a process only after it is a member , and denotes the order in which it has become a member .",
    "the process multicasts a proposebackup message on the intra - group connection ( line 7 ) .",
    "the primary assigns the precedence and the rank of the new backup ( line 23 ) and then multicasts an acceptbackup message ( line 30 ) , containing the new membership , on the intra - group connection . a backup that receives an acceptbackup message , that includes itself in the membership , accepts the new membership , and responds with an acknowledgment ( lines 15 - 18 ) .",
    "the primary checkpoints its state when it has received acknowledgments for the new membership from all of the backups in the group ( lines 39 - 41 ) . the point at which the checkpoint is taken represents the virtual synchrony point for adding the new backup .",
    "the primary transmits the checkpoint to the new backup in a state message ( line 42 ) .",
    "the new backup then sets its state by applying the checkpoint , and replaying the messages from the log ( lines 20 - 21 ) , after deleting obsolete messages .",
    "the primary modifies the ranks of the backups in the group ( line 28 ) and then multicasts a removebackup message ( line 30 ) , containing the new membership , on the intra - group connection .",
    "when a backup receives a removebackup message that includes itself in the membership , the backup accepts the new membership and responds with an acknowledgment ( lines 43 - 45 ) . when a backup receives a removebackup message that does not include itself in the membership , the backup resets its state and multicasts a proposebackup message requesting to be readmitted to the membership ( line 46 ) .    for both addition and removal of a backup , the primary multicasts the new membership to all of the backups in the membership ( line 30 ) , and asynchronously collects acknowledgments from all of them .",
    "it commits the membership change when it has collected acknowledgments from all of the backups in the membership ( line 39 ) .",
    "if a backup does not provide an acknowledgment promptly , the primary removes the backup from the membership ( line 34 ) .",
    "a reliable , totally ordered message delivery protocol ensures consistent replication only if the application is deterministic ( or is rendered deterministic ) . however , modern applications are typically non - deterministic in a number of ways . to maintain strong replica consistency ,",
    "it is necessary to sanitize or mask such sources of non - determinism , _",
    "i.e. _ , to render the application _ virtually deterministic_.    the llft virtual determinizer framework introduces a novel generic algorithm for sanitizing the sources of non - determinism in an application in a transparent manner .",
    "we describe the generic algorithm below , after describing the threading model .",
    "the state of an application process is determined by data that are shared among different threads , and by thread - specific local data managed and changed by each thread .",
    "each thread within a process has a unique thread identifier .",
    "a data item that is shared by multiple threads is protected by a mutex .",
    "the threads and mutexes can be created and deleted dynamically .",
    "each replica in a process group runs the same set of threads .",
    "a thread interacts with other threads , processes , and its runtime environment through system / library calls .",
    "non - determinism can arise from different orderings of , and different results from , such calls at different replicas in the group .",
    "if the operations on the shared and local data in different replicas are controlled in such a way that ( 1 ) the updates on a data item occur in the same order with the same change , and ( 2 ) each thread updates different data items in the same order with the same change , then the replicas will remain consistent .",
    "figure [ determinizer ] on the left gives example pseudocode for a thread that shows how such calls might change the state of an application .",
    "the pseudocode uses three types of system / library calls :    * calls that try to acquire a mutex ( line 18 ) .",
    "the pthread _ mutex_trylock ( ) operation is similar to a nonblocking read in that , if the mutex is currently held by another thread , the call returns immediately with a specific error code , so that the caller thread is not blocked . if the thread of one replica successfully claims the mutex , while the corresponding thread of another replica fails , the two replicas perform different operations ( lines 19 - 22 ) , causing divergence of their states , because one replica changes the shared data sd1 ( line 20 ) while the other replica changes the thread - local data ld5 ( line 22 ) . * calls that retrieve local clock values ( lines 1 , 13 ) .",
    "these calls change thread - local data ( ld1 ) directly ( lines 2 , 14 ) .",
    "if different replicas obtain different clock values , the replicas might arrive at different decisions ( line 15 ) as to whether a timeout occurred .",
    "if one replica times out while the other does not , the states of the replicas will diverge because of the difference in thread - local data ld4 ( line 16 ) .",
    "* calls that read ( write ) from ( to ) a socket asynchronously ( lines 3 , 7 , 12 ) .",
    "if , for the same read operation , one replica successfully reads a message while the other does not , the states of the two replicas will differ in the thread - local data ld2 ( line 5 ) and potentially ld3 ( lines 9 , 11 ) .",
    "the consequence of different results for a nonblocking write call is similar .",
    "the generic algorithm , shown in figure [ determinizer ] on the right , records the ordering information and the return value information of non - deterministic system / library calls at the primary , to ensure that the backups obtain the same results in the same order . for each non - deterministic operation",
    ", the algorithm records the following information :    * * thread identifier * - the identifier of the thread that is carrying out the operation . * * operation identifier * - an identifier that represents one or more data items that might change during the operation or on completion of the operation . * * operation count * - the number of operations carried out by a thread for the given operation identifier . * * operation metadata * - the data returned from the system / library call .",
    "this metadata includes the out parameters ( if any ) , the return value of the call , and the error code ( if necessary ) .",
    "at the primary , the algorithm maintains a queue , the orderinfo queue of four - tuples ( t , o , n , d ) , where thread t has executed a call with operation identifier o and with metadata recorded in d , and this is the nth time in its execution sequence that thread t has executed such a non - deterministic call .",
    "the orderinfo queue spans different threads and different operations .    at the primary",
    ", the algorithm appends an entry ( t , o , n , d ) to the orderinfo queue on return of the operation o ( lines 23 - 28 ) .",
    "the entries are transmitted to the backups reliably and in order , using the piggybacking mechanism of the messaging protocol .    at a backup , for each operation o , the algorithm maintains an o.orderinfo queue of three - tuples ( t , n , d ) , in the order in which the primary created them . when the backup receives the first entry ( t ,",
    "o , n , d ) for operation o , it creates the o.orderinfo queue ( lines 29 - 30 ) .",
    "after the entry is appended to the queue , the algorithm awakens the first application thread in the o.orderinfo queue if it is blocked ( lines 31 - 33 ) .    at a backup ,",
    "when thread t tries to execute operation o as its nth execution in the sequence , if ( t , n , d ) is not the first entry in the o.orderinfo queue , the algorithm suspends the calling thread t ( lines 34 - 39 ) .",
    "it resumes a thread t that was suspended in the order in which ( t , n , d ) occurs in the o.orderinfo queue , rather than the order in which the thread was suspended or an order determined by the operating system scheduler .",
    "it removes an entry ( t , n , d ) from the o.orderinfo queue immediately before it returns control to the calling thread t after its nth execution in the sequence ( lines 40 - 41 ) .",
    "the algorithm requires the ordering of all related operations , _",
    "e.g. _ , both claims and releases of mutexes .",
    "we have instantiated the generic algorithm of the virtual determinizer framework for several major types of non - determinism , including multi - threading , time - related operations and socket communication , as discussed below .",
    "the consistent multi - threading service ( cmts ) creates mutex ordering information at the primary , where the operation identifier is the mutex @xmath15 . for the normal mutex claim call ( pthread _ mutex_lock ( ) library call )",
    ", the operation metadata can be empty if the call is successful .",
    "however , if the normal mutex claim call returns an error code and for the nonblocking mutex claim call ( pthread_mutex_trylock ( ) library call ) , the operation metadata is the return value .    at a backup , to process a mutex ordering information entry , the cmts examines the metadata . if the metadata contain an error code , the cmts returns control to the calling thread with an identical error status , without performing the call",
    "otherwise , it delegates the mutex claim operation to the original library call provided by the operating system . if the mutex is not currently held by another thread , the calling thread acquires the mutex immediately .",
    "otherwise , the calling thread is suspended and subsequently resumed by the operating system when the thread that owns the mutex releases it .",
    "the cmts allows concurrency of threads that do not simultaneously acquire the same mutex .",
    "thus , it achieves the maximum possible degree of concurrency , while maintaining strong replica consistency .",
    "the consistent time service ( cts ) ensures that clock readings at different replicas are consistent . for time - related system calls , such as gettimeofday ( ) and time ( ) ,",
    "the cts creates time ordering information at the primary , where the operation identifier is the time source and the operation metadata is the clock value , or an error code if the call fails .",
    "in addition to consistency for each clock reading , the cts ensures monotonicity of the clock as seen by the replicas in a group , even if the primary fails @xcite . with the cts ,",
    "the replicas see a _ virtual group clock _ that resembles the real - time clock .",
    "each replica maintains an offset to record the difference between its local physical clock and the virtual group clock .",
    "the offset of the primary is 0 .",
    "each backup updates its offset for each clock reading .",
    "if the primary fails , one of the backups becomes the new primary .",
    "the new primary must not include its local physical clock value in the time ordering information it sends to the backups , because doing so might roll backward , or roll forward , the virtual group clock .",
    "instead , the new primary adds the recorded offset to its local physical clock value , and includes that value in the time ordering information it sends to the backups .      an application might use a nonblocking read to receive messages from the network asynchronously .",
    "if no message is received , the nonblocking read call returns a specific error code . on such an error return , the application might switch to some other task and change to a different state .",
    "thus , the event of failing to receive a message must be ordered .",
    "similarly , an application might use a nonblocking write to send data asynchronously .",
    "if the message is not sent successfully , the application might take on a different task and change to a different state .",
    "thus , the event of failing to send a message must be ordered .",
    "on return from a read / write system call on a socket at the primary , the consistent socket communication service ( cscs ) produces a socket ordering information entry for that operation .",
    "the operation identifier is the socket file descriptor .",
    "the operation metadata is an identifier for the message being read / written , if the read / write succeeds , or an error code , if it fails .",
    "it is quite common to combine socket read / write system calls with select / poll system calls .",
    "typically , the application performs a read / write system call only if the select / poll system call indicates that the corresponding socket is readable / writable .",
    "the select / poll system call offers a timeout parameter for the user to specify how long the operating system can take to return from the call .",
    "the cscs produces a socket ordering information entry on returning from a select / poll system call .",
    "the operation identifier is the socket file descriptor .",
    "the operation metadata contains the number of events , the read / write / error mask , and the amount of time left before the timeout ( used on linux ) if the call returns successfully , or an error code , if it fails .",
    "the llft system has been implemented in the c++ programming language for the linux operating system .",
    "the library interpositioning technique is used to capture and control the application s interactions with its runtime environment .",
    "application state is checkpointed and restored using facilities provided by a memory - mapped checkpoint library derived from @xcite .",
    "the implementation of llft is compiled into a shared library .",
    "the library is inserted into the application address space at startup time using the ld_preload facility provided by the operating system .",
    "llft is transparent to the application being replicated , and does not require recompilation or relinking of the application program .",
    "the experimental testbed consists of 14 hp blade servers , each equipped with two 2ghz intel xeon processors , running the ubuntu 9.04 operating system , on a 1gbps ethernet .",
    "a two - tier client / server application was used to benchmark the llft implementation .",
    "the performance evaluation focuses on three areas : ( 1 ) performance of the messaging protocol during normal fault - free operation , ( 2 ) overhead of the virtual determinizer framework , and ( 3 ) performance of the membership protocol during fault recovery .",
    "first , we consider the performance of the messaging protocol during normal fault - free operation .",
    "we characterize the end - to - end latency in the presence of a single client for various invocation patterns : ( 1 ) short requests and short replies , ( 2 ) various size requests and short replies , and ( 3 ) short requests and various size replies .",
    "the end - to - end latency for pattern ( 2 ) is virtually indistinguishable from that for pattern ( 3 ) for the same message size ( for requests and replies ) .",
    "hence , the measurement results shown in figure  [ latency ] refer only to message size .",
    "the figure shows the end - to - end latency without replication using tcp as a baseline for comparison and with 3-way replication using llft to understand the overhead that llft incurs . as can be seen in the figure , the messaging protocol incurs very moderate overhead , ranging from about 15% for large messages to about 55% for small messages .",
    "the overhead of the messaging protocol is determined primarily by the piggybacking of ordering information . for large messages , which require fragmentation in user space , the messaging protocol incurs additional context switches , although the relative overhead is less percentage - wise .",
    "we also measured the throughput , without replication using tcp and with 3-way replication using llft , in the presence of various numbers of concurrent clients .",
    "each client continually issues 1 kb requests without any think time , and the server responds with 1 kb replies .",
    "the measurement results are summarized in figure  [ thrput ] .",
    "it can be seen that , although the throughput reduction under replication is moderate under light loads , it is more prominent under heavy loads .",
    "we also characterized the fault scalability of the messaging protocol .",
    "as shown in figure  [ scalabilityperf ] , the performance does not degrade noticeably as the number of replicas is increased ( so that larger numbers of concurrent faults can be tolerated ) .",
    "these results are as expected because the primary can deliver a message as soon as it is ordered within a connection without having to communicate with the backups .      to evaluate the performance of the virtual determinizer framework",
    ", we injected non - deterministic operations into our benchmark application . for each run",
    ", we varied the number of non - deterministic operations per call , while keeping the request / reply message size fixed at 1 kb .",
    "the measurement results for the end - to - end latency shown in figure  [ ndlatency ] are obtained by introducing clock - related non - deterministic operations ( _ i.e.,@xmath0 _ , gettimeofday ( ) ) into the application .",
    "other types of non - deterministic operations produce a similar profile . in general , the end - to - end latency increases linearly as the number of non - deterministic operations per call increases . on average ,",
    "each additional non - deterministic operation adds about 8 microseconds overhead to the end - to - end latency .",
    "this overhead is primarily due to the piggybacking of ordering information .      to evaluate the performance of the membership protocol during recovery from primary failure",
    ", we considered ( 1 ) the primary view change latency , and ( 2 ) the recovery latency , _",
    "i.e. _ , the primary view change latency plus the virtual synchrony latency .",
    "the failover latency when the primary fails is determined by the fault detection time and the recovery latency . in a system that does not incur lengthy communication delays , the first backup can detect the failure of the primary in about 30 milliseconds , based on the parameters used in our experiments .",
    "figure  [ primaryviewchangelatency ] summarizes the measurement results for the primary view change latency , which are obtained when no client is running , to highlight the primary view change latency itself .",
    "as can be seen in the figure , the latency increases with the number of replicas .",
    "interestingly , when the number of replicas is two ( which the industry regards as the typical case and which majority - based membership algorithms do not handle ) , the primary view change latency is less than 50 microseconds , which is significantly less than the latency with more replicas . in this case , when the primary crashes , only one replica is left . that replica can promote itself to be the new primary without the need to wait for acknowledgments from other replicas .",
    "figure  [ recoverylatency ] summarizes the measurement results for the recovery latency , _",
    "i.e. _ , the primary view change latency plus the virtual synchrony latency .",
    "the figure shows the measured recovery latency in the presence of various numbers of concurrent clients , for 3-way and 2-way replication .",
    "as expected , the recovery latency increases with the number of concurrent clients in both cases .",
    "if the availability requirement allows 2-way replication ( which is typical industry practice ) , the recovery is faster by about 200 microseconds .",
    "the llft system is a software - based approach to fault tolerance .",
    "such an approach was first used in sift @xcite and became the favored approach in later fault - tolerant systems such as the delta-4 @xcite , tft @xcite , hypervisor @xcite and viewstamped replication @xcite systems .",
    "more recent efforts on software fault tolerance system have focused on rendering corba , java rmi and web services applications fault tolerant  @xcite . however , supporting a particular messaging protocol api limits the applicability of those systems .",
    "the llft system provides fault tolerance transparently to both the applications and the operating system , like the tft @xcite , hypervisor @xcite and targon/32 @xcite systems .",
    "however , those systems differ from llft in the way in which they achieve transparency .",
    "the targon/32 system uses a special bus design that ensures atomic transmission of a message sent by a primary to both its destination group and its own backups .",
    "the tft system requires application object code editing .",
    "the hypervisor system requires a hardware instruction counter .",
    "llft uses the more flexible library interpositioning technique .",
    "the user can dynamically insert ( remove ) the llft software into ( from ) a running application process using operating system facilities .",
    "the llft system uses a leader - follower replication technique similar to that used in the delta-4 @xcite and viewstamped replication @xcite systems .",
    "delta-4 uses a separate message to transmit ordering information from the primary to the backups .",
    "thus , the primary must wait until all of the backups have explicitly acknowledged the ordering notification before it sends a message , which can reduce system performance .",
    "in contrast , llft uses piggybacking mechanisms and the virtual determinizer framework to maintain strong replica consistency and virtual synchrony @xcite , if a fault occurs . in the viewstamped replication system ,",
    "the primary generates a new timestamp each time it needs to communicate information to the backups . unlike llft",
    ", the viewstamped replication system is based on atomic transactions , which it combines with a view change algorithm .",
    "atomic multicast protocols that deliver messages reliably and in the same total order , such as isis @xcite , amoeba @xcite , and totem @xcite , have been used to maintain strong replica consistency in fault - tolerant distributed systems . however ,",
    "those protocols introduce delays in either sending or delivering a message .",
    "the llft messaging protocol does not incur such delays , because the primary makes the decisions on the order in which the operations are performed and the ordering information is reflected to the backups in its group . the recent lcr total order broadcast protocol @xcite , which uses logical clocks and a ring topology , optimizes for high throughput in cluster environments , rather than low latency as does llft .",
    "lcr is comparable to the totem single - ring protocol @xcite , which likewise optimizes for high throughput in local - area networks , rather than to llft .",
    "paxos @xcite is a leader election algorithm for asynchronous distributed systems , which uses a two - phase commit strategy in which a majority of the members must vote for the leader .",
    "the requirement of a majority ensures that only one leader will be elected .",
    "paxos assumes a known existing membership , and does not change that membership dynamically as members become faulty and recover .",
    "paxos can achieve consensus in two rounds , if communication is reliable and processes respond promptly .",
    "there exist versions of paxos in which a dedicated proposer selects the new leader and initiates the election , reducing the number of message delays required to confirm the new leader , provided that the proposer is not faulty .",
    "there also exist extensions of paxos in which the leader can change the membership dynamically , to remove faulty members or to add new members .",
    "llft also employs such ideas .",
    "membership protocols for group communication systems , such as transis @xcite and totem @xcite employ fault detectors , based on timeouts , to reach distributed agreement on as large a membership as possible , devolving to smaller memberships , if necessary .",
    "those protocols are relatively costly in the number of messages exchanged , and in the delays incurred .",
    "to avoid such costs , llft uses a novel leader - determined membership protocol that does involve distributed agreement .",
    "rather , it achieves consistent group membership among the members of a group by having the primary determine the membership , which it communicates to the backups in the group .",
    "membership protocols for group communication systems , such as isis @xcite and totem @xcite , use the term _ view change _ to represent a change in the membership of a group .",
    "in particular , each successive membership , which involves addition ( removal ) of a member , constitutes a new view . in llft ,",
    "only membership changes that correspond to a change of the primary constitute a new view , which we refer to as a _ primary view change_. in typical group communication systems , the membership is known more widely than by only the members in the group . in llft , only the primary and the backups in the group need to know the membership of the group .",
    "the llft system includes a novel , generic virtual determinizer framework to capture , transmit and execute ordering information for non - deterministic operations .",
    "the non - deterministic operations handled by llft overlap those considered in other systems such as delta-4 @xcite , tft @xcite , hypervisor @xcite and targon/32 @xcite .",
    "llft addresses non - determinism caused by multi - threading and socket communication , which those works do not discuss .",
    "llft does not yet handle non - determinism introduced by operating system signals and interrupts , which those works do consider .",
    "basile _ et al . _",
    "@xcite , jimenez - peris and arevalo @xcite , and narasimhan _ et al .",
    "_ @xcite have addressed the need to sanitize non - deterministic operations , to achieve strong replica consistency for active replication , rather than for leader - follower ( semi - active or semi - passive ) replication .",
    "the llft mechanisms that are used to order mutex claims / releases are closely related to those of the loose synchronization algorithm ( lsa ) and preemptive deterministic scheduling algorithm ( pds ) of @xcite .",
    "however , lsa does not address the strong replica consistency issues introduced by the pthread_mutex_trylock ( ) library call , and pds is suitable for only a specific threading model .",
    "_ @xcite have investigated semi - passive replication in conjunction with a consensus algorithm . in their model",
    ", the primary server produces its results as a single action , including the reply to the client and the state update for the backups .",
    "their model admits non - deterministic operations , but not concurrent processing , with shared data , of requests from multiple clients . in our more general model , multiple processes ,",
    "possibly with multiple threads , interact with each other and also with file and database systems .",
    "moreover , requests from multiple clients can be processed concurrently and can access shared data . in their semi - passive replication",
    ", every server replica sends a reply to the client whereas , in llft , the backups do not send replies to the client , which reduces the amount of network traffic .",
    "their semi - passive replication uses a rotating coordinator and a variation of consensus , whereas llft uses a leader - determined membership protocol that is not based on consensus .",
    "brito _ et al .",
    "_ @xcite have addressed the issues of minimizing latency and multi - threading in fault - tolerant distributed stream processing systems .",
    "the system that they developed supports active replication , instead of the semi - active or semi - passive replication that llft supports .",
    "their system employs novel speculation mechanisms based on software transactional memory to achieve lower latency and higher concurrency .",
    "zou and jahanian @xcite have adopted the primary - backup replication approach for real - time fault - tolerant distributed systems .",
    "their replication service addresses temporal consistency , introduces the notion of phase variance , and ensures consistency deterministically if the underlying communication mechanism provides deterministic message delivery , and probabilistically if no such support exists .",
    "llft itself provides deterministic message delivery and ensures strong replica consistency .",
    "the low latency fault tolerance ( llft ) system provides fault tolerance for distributed applications deployed over a local - area network , as in a data center .",
    "applications programmed using tcp socket apis , or middleware such as java rmi , can be replicated with strong replica consistency using llft , without any modifications to the applications .",
    "performance measurements show that llft achieves low latency message delivery under normal conditions and low latency reconfiguration and recovery when a fault occurs .",
    "the genericity , application transparency , and low latency of llft make it appropriate for a wide variety of distributed applications .",
    "future work includes the sanitization of other sources of non - determinism ( such as operating system signals and interrupts ) and performance optimization .",
    "it also includes the development of more complex applications for llft ( in particular , file systems and database systems ) , and the development of replication management tools .",
    "the proofs of correctness for llft , based on the model and the safety and liveness properties given in section  [ basicconcepts ] , are provided below .",
    "_ there exists at most one infinite sequence of consecutive primary views for the group .",
    "each of those primary views has a unique primary view number and a single primary replica .",
    "_    assume that the primary @xmath16 became faulty in view @xmath7 , and that the backup @xmath17 with precedence @xmath18 and the backup @xmath19 with precedence @xmath20 , where @xmath21 , each propose a new primary view with the same primary view number , with itself as the primary of the new primary view .",
    "consider the following two cases .",
    "there is a replica @xmath22 that is a member of both proposed new primary views .",
    "according to the rules of the llft membership protocol , if @xmath22 first acknowledges @xmath19 s proposeprimary message , then @xmath22 does not acknowledge @xmath17 s proposeprimary message , because @xmath21 .",
    "thus , @xmath17 is unable to collect acknowledgments from all of the proposed members and it abandons its attempt to form that new membership , resets its state , and applies to rejoin the group . on the other hand , if @xmath22 first acknowledges @xmath17 s proposeprimary message and subsequently receives @xmath19 s proposeprimary message , then @xmath17 is unable to collect acknowledgments from all of the proposed members , because @xmath17 will not receive an acknowledgment from @xmath19 .",
    "there is no replica that is a member of both proposed new primary views ( because neither @xmath17 nor @xmath19 received messages from any replica in the other s proposed membership and , thus , @xmath17 and @xmath19 both regard the other s replicas as faulty ) . because of the eventual reliable communication assumption and because of the retransmission , to all members of the group on the intra - group connection , of a message containing a higher precedence than the precedence of the primary of the primary view , every replica @xmath22 in @xmath17 s membership eventually receives a message from a replica in @xmath19 s membership . because @xmath21 , @xmath22 then realizes that @xmath17 s membership has been superseded by @xmath19 s membership and , thus , @xmath22 abandons its current state and applies for readmission to @xmath19 s membership .",
    "thus , any side branch is pruned .    in the theorems and proofs below",
    ", operations refer to both computation and communication operations .",
    "_ there exists at most one infinite sequence of operations in an infinite sequence of consecutive primary views for the group . _    by theorem 1 , there exists at most one infinite sequence of consecutive primary views .",
    "each of those primary views has a unique primary view number and a single primary replica .",
    "moreover , each of those primary view has an associated sequence of operations determined by the primary of that view .",
    "the sequence of operations in an infinite sequence of consecutive primary views is the concatenation of the sequences of operations for the primary views in the order of their primary view numbers .    _ for semi - active replication , if a backup replica @xmath17 is admitted to a membership of view @xmath7 by primary replica @xmath16 after the start of @xmath7 and @xmath17 subsequently becomes faulty in @xmath7 , then the sequence of operations of @xmath17 in @xmath7 is a consecutive subsequence of the sequence of operations of @xmath16 in @xmath7 .",
    "_    for primary replica @xmath16 of view @xmath7 , the sequence of ordering information is determined by the sequence of operations of @xmath16 . when the backup @xmath17 is admitted to a membership of @xmath7 by @xmath16 after the start of view @xmath7 ,",
    "it receives a state message from @xmath16 , which establishes a synchronization point .",
    "after that point , the sequence of operations performed by @xmath17 is determined by the sequence of ordering information provided by @xmath16 , until @xmath17 becomes faulty .",
    "thus , the sequence of operations of @xmath17 in @xmath7 is a consecutive subsequence of the sequence of operations of @xmath16 in @xmath7 .",
    "_ for semi - active replication , if replica @xmath17 is admitted to the membership of view @xmath7 by primary replica @xmath16 after the start of @xmath7 and @xmath17 is not faulty in @xmath7 , then the sequence of operations of @xmath17 in @xmath7 is a suffix of the sequence of operations of @xmath16 in @xmath7 . _    for primary replica @xmath16 of view @xmath7 ,",
    "the sequence of ordering information is determined by the sequence of operations of @xmath16 .",
    "when @xmath17 is admitted to the membership of view @xmath7 by @xmath16 after the start of @xmath7 , it receives a state message from @xmath16 , which establishes a synchronization point .",
    "after that point , the sequence of operations of @xmath17 is determined by the sequence of ordering information provided by @xmath16 in @xmath7 . moreover , because @xmath17 is not faulty in @xmath7 , it participates in the virtual synchrony at the start of @xmath11 .",
    "thus , @xmath17 s sequence of operations in @xmath7 is a suffix of the sequence of operations of @xmath16 in @xmath7 .    _ for semi - active replication , if replica @xmath17 is an initial member of view @xmath7 with primary replica @xmath16 and @xmath17 subsequently becomes faulty in @xmath7 , then the sequence of operations of @xmath17 in @xmath7 is a prefix of the sequence of operations of @xmath16 in @xmath7 .",
    "_    for primary replica @xmath16 of view @xmath7 , the sequence of ordering information is determined by the sequence of operations of @xmath16 .",
    "because @xmath17 is an initial member of view @xmath7 , it participates in the virtual synchrony at the start of @xmath7 .",
    "after that point , the sequence of operations of @xmath17 is determined by the sequence of ordering information provided by @xmath16 in @xmath7 , until @xmath17 becomes faulty .",
    "thus , @xmath17 s sequence of operations in @xmath7 is a prefix of the sequence of operations of @xmath16 in @xmath7 .    _ for semi - active replication ,",
    "if replicas @xmath17 and @xmath19 are members of the same memberships of views @xmath7 , @xmath11 and @xmath23 , then the sequence of operations of @xmath17 in @xmath11 is the same as the sequence of operations of @xmath19 in @xmath11 .",
    "_    because @xmath17 and @xmath19 are members of the same memberships of views @xmath7 and @xmath11 , both of them participate in the virtual synchrony between @xmath7 and @xmath11 , determined by primary @xmath16 of @xmath11 . because both @xmath17 and @xmath19 are members of the same memberships of views @xmath11 and @xmath23 , neither of them becomes faulty in @xmath11 and both of them participate in the virtual synchrony between @xmath11 and @xmath23 .",
    "consequently , both @xmath17 and @xmath19 perform the same sequence of operations in @xmath11 , which is the same as the sequence of operations performed by @xmath16 , determined by the sequence of ordering information provided by @xmath16 .",
    "_ for semi - active replication , if replicas @xmath17 and @xmath19 are members of the same memberships of views @xmath7 and @xmath24 , then the sequence of operations of @xmath17 in @xmath25 is the same as the sequence of operations of @xmath19 in @xmath25 , where @xmath26 . _    because @xmath17 and @xmath19 are members of the same membeships of views @xmath7 and @xmath24 , they are both members of the same memberships of views @xmath25 for all @xmath27 , @xmath26 , because if they are removed from a membership and apply for readmission , they are admitted as new replicas .",
    "the proof now follows from lemma 4 by induction .",
    "_ for semi - active replication , the sequence of operations of a replica , in a membership of the infinite sequence of consecutive primary views , is a consecutive subsequence of the infinite sequence of operations for the group . _",
    "we consider the following three cases for a semi - active replica @xmath22 .",
    "case 1 : replica @xmath22 is admitted to a membership in view @xmath7 and becomes faulty in the same view @xmath7 . by lemma 1 ,",
    "the sequence of operations of @xmath22 in @xmath7 is a consecutive subsequence of the sequence of operations of primary replica @xmath16 in @xmath7 and , thus , of the infinite sequence of operations for the group .",
    "case 2 : replica @xmath22 is admitted to a membership in view @xmath7 and becomes faulty in view @xmath11 . by lemma 2 ,",
    "the sequence of operations of @xmath22 in @xmath7 is a suffix of the sequence of operations of primary replica @xmath16 in @xmath7 . by lemma 3 ,",
    "the sequence of operations of @xmath22 in @xmath11 is a prefix of the sequence of operations of primary replica @xmath28 in @xmath11 .",
    "thus , the sequence of operations of @xmath22 is the concatenation of the suffix for view @xmath7 and the prefix for view @xmath11 .",
    "thus , the sequence of operations of @xmath22 is a consecutive subsequence of the infinite sequence of operations for the group .",
    "case 3 : replica @xmath22 is admitted to the membership in view @xmath7 and becomes faulty in view @xmath24 , where @xmath29 . by lemma 2 ,",
    "the sequence of operations of @xmath22 in @xmath7 is a suffix of the sequence of operations of primary replica @xmath16 in @xmath7 . by lemma 3 ,",
    "the sequence of operations of @xmath22 in @xmath24 is a prefix of the sequence of operations of primary replica @xmath28 in @xmath24 . by lemma 5",
    ", the sequence of operations of @xmath22 in @xmath25 is the same as the sequence of operations of primary replica @xmath30 in @xmath25 , where @xmath26 .",
    "thus , the sequence of operations of @xmath22 is the concatenation of the suffix for view @xmath7 , the sequences for the views @xmath25 , where @xmath31 , and the prefix for view @xmath24 .",
    "thus , the sequence of operations of @xmath22 is a consecutive subsequence of the infinite sequence of operations for the group .    in the proofs above , which apply to semi - active replication , we consider the sequence of operations performed at the primary and at the backups . to address semi - passive replication",
    ", we consider the sequence of states at the primary and the backups , because for semi - passive replication , the backups perform no operations .",
    "_ for semi - passive replication , the sequence of states of a replica , in a membership of the infinite sequence of consecutive primary views , is a consecutive subsequence of the infinite sequence of states for the group . _",
    "the proof is similar to that for theorem 3 for semi - active replication .",
    "_ there exists at least one infinite sequence of consecutive primary views with consecutive primary view numbers for the group . _    by the sufficient replication assumption ( _ i.e. _ , each group contains enough replicas such that in each primary view there exists at least one replica that does not become faulty ) , if the primary becomes faulty in a view @xmath7 , then there exists a replica @xmath22 in @xmath7 that can assume the role of the primary in view @xmath11 .",
    "the proof now follows by induction .",
    "_ there exists at least one infinite sequence of operations in each infinite sequence of consecutive primary views for the group .",
    "_    there exists at least one operation ( the communication of the state message ) in each primary view .",
    "the proof now follows from theorem 5 .",
    "this research was supported in part by nsf grant cns-0821319 , and by a csisi grant from cleveland state university ( for the first author ) .",
    "10 y.  amir , d.  dolev , s.  kramer , and d.  malkhi .",
    "membership algorithms for multicast communication groups . in _ proceedings of the 6th international workshop on distributed algorithms , lecture notes in computer science 647 _ , pages 292312 , haifa , israel ,",
    "november 1992 .",
    "k.  birman , r.  van renesse , and w.  vogels . adding high availability and autonomic behavior to web services . in _ proceedings of the 26th international conference on software engineering _ , pages 1726 , edinburgh , scotland , 2004 .",
    "t.  c. bressoud . : a software system for application - transparent fault tolerance . in _ proceedings of the 28th ieee international conference on fault - tolerant computing _ ,",
    "pages 128137 , munich , germany , june 1998 .",
    "a.  brito , c.  fetzer , and p.  felber .",
    "minimizing latency in fault - tolerant distributed stream processing systems . in _ proceedings of the 29th ieee international conference on distributed computing systems _ , pages 173182 ,",
    "montreal , quebec , canada , june 2009 .",
    "a.  brito , c.  fetzer , and p.  felber .",
    "multithreading - enabled active replication for event stream processing operators . in _ proceedings of the 28th ieee international symposium on reliable distributed systems _",
    ", pages 2231 , niagara falls , ny , september 2009 .",
    "m.  cukier , j.  ren , c.  sabnis , w.  h. sanders , d.  e. bakken , m.  e. berman , d.  a. karr , and r.  schantz . : an adaptive architecture that provides dependable distributed objects . in _ proceedings of the 17th ieee symposium on reliable distributed systems _ , pages 245253 , west lafayette , in , october 1998 .",
    "r.  guerraoui , m.  hurfinn , a.  mostefaoui , r.  oliveira , m.  raynal and a.  schiper .",
    "consensus in asynchronous distributed systems : a concise guided tour .",
    ", 1752 , pages 3347 , springer , berlin / heidelberg , 2000 .",
    "r.  jimenez - peris and s.  arevalo .",
    "deterministic scheduling for transactional multithreaded replicas . in _ proceedings of the 19th ieee symposium on reliable distributed systems _ , pages 164173 , nuremberg , germany , october 2000 .",
    "m.  f. kaashoek and a.  s. tanenbaum .",
    "group communication in the amoeba distributed operating system . in _ proceedings of the 11th ieee international conference on distributed computing systems _ ,",
    "pages 222230 , arlington , tx , may 1991 .        c.  marchetti , m.  mecella , a.  virgillito , and r.  baldoni .",
    "an interoperable replication logic for corba systems . in _ proceedings of the international symposium on distributed objects and applications _",
    ", pages 716 , antwerp , belgium , september 2000 .",
    "t.  marian , m.  balakrishnan , k.  birman , and r.  van renesse .",
    "tempest : soft state replication in the service tier . in _ proceedings of the ieee international conference on dependable systems and networks _ , pages 227236 , anchorage , ak , june 2008 .            p.  narasimhan , l.  e. moser , and p.  m. melliar - smith . enforcing determinism for the consistent replication of multithreaded corba applications . in _ proceedings of the 18th ieee symposium on reliable distributed systems _ , pages 263273 , lausanne , switzerland , october 1999 .",
    "b. oki and b. liskov .",
    "viewstamped replication : a new primary copy method to support highly - available distributed systems . in",
    "_ proceedings of the acm symposium on principles of distributed computing _ , pages 8-17 , 1988 .",
    "j.  salas , f.  perez - sorrosal , m.  patino - martinez , and r.  jimenez - peris .",
    "eplication : a framework for highly available web services . in _ proceedings of the 15th international conference on the world wide web _ , pages 357366 , edinburgh , scotland , 2006 .",
    "g.  santos , l.  lung , and c.  montez .",
    ": a fault - tolerant infrastructure for web services . in _ proceedings of the ieee international enterprise computing conference",
    "_ , pages 95105 , enschede , the netherlands , september 2005 .",
    "j.  h. wensley , l.  lamport , j.  goldberg , m.  w. green , k.  n. levitt , p.  m. melliar - smith , r.  e. shostak , and c.  b. weinstock . : design and analysis of a fault - tolerant computer for aircraft control . , 66(10):12401255 , 1978 .",
    "w.  zhao , l.  e. moser , and p.  m. melliar - smith .",
    "design and implementation of a pluggable fault - tolerant corba infrastructure . in _ proceedings of the international parallel and distributed processing symposium _ , pages 343352 , fort lauderdale , fl , april 2002 .",
    "w.  zhao , l.  e. moser , and p.  m. melliar - smith . design and implementation of a consistent time service",
    "for fault - tolerant distributed systems . in _ proceedings of the ieee international conference on dependable systems and networks _ , pages 341350 , san francisco , ca",
    ", june 2003 ."
  ],
  "abstract_text": [
    "<S> the low latency fault tolerance ( llft ) system provides fault tolerance for distributed applications , using the leader - follower replication technique . </S>",
    "<S> the llft system provides application - transparent replication , with strong replica consistency , for applications that involve multiple interacting processes or threads . </S>",
    "<S> the llft system comprises a low latency messaging protocol , a leader - determined membership protocol , and a virtual determinizer framework . </S>",
    "<S> the low latency messaging protocol provides reliable , totally ordered message delivery by employing a direct group - to - group multicast , where the message ordering is determined by the primary replica in the group . </S>",
    "<S> the leader - determined membership protocol provides reconfiguration and recovery when a replica becomes faulty and when a replica joins or leaves a group , where the membership of the group is determined by the primary replica . </S>",
    "<S> the virtual determinizer framework captures the ordering information at the primary replica and enforces the same ordering at the backup replicas for major sources of non - determinism , including multi - threading , time - related operations and socket communication . </S>",
    "<S> the llft system achieves low latency message delivery during normal operation and low latency reconfiguration and recovery when a fault occurs </S>",
    "<S> .    distributed applications ; distributed systems ; fault tolerance ; performance ; reliability , availability , serviceability </S>"
  ]
}