{
  "article_text": [
    "in this paper we introduce a new method for constructing randomized online algorithms , which we call the _ knowledge state _ model .",
    "the purpose of this method is the address the trade - off between memory and competitiveness .",
    "the model is introduced and fully described for the first time in this publication , but we note that a number of published algorithms are implicitly consistent with the model although not in its full power .",
    "for example , the algorithm equitable @xcite is a knowledge state algorithm for the @xmath2-cache problem that achieves the optimal randomized competitiveness of @xmath3 for each @xmath2 , using only @xmath4 memory , as opposed to the prior algorithm , partition @xcite , that uses the full information contained in the work function , and hence requires unlimited memory as the length of the request sequence grows . at the other end of the scale ,",
    "the randomized algorithm random_slack @xcite is in fact an extremely simple knowledge state algorithm , which achieves randomized 2-competitiveness for the 2-server problem for all metric spaces , and which achieves randomized @xmath2-competitiveness for the @xmath2-server problem on some spaces , including trees .",
    "we also note that random_slack is _ trackless _ and is an order 1 knowledge state algorithm , _",
    "i.e. _ , its distribution is supported by only one state .",
    "( see the recent acm sigact column @xcite for a summary of tracklessness ; see also @xcite . )",
    "we also note that we have recently used the knowledege state technique to develop an optimally competitive algorithm for the caching problem in shared memory multiprocessor systems @xcite .",
    "it is still an open question , whether there exists an optimally competitive order @xmath5 bookmark randomized algorithm for the @xmath2-cache problem .",
    "an affirmative answer to this question would settle an open problem listed in @xcite . in this paper",
    "we describe progress on this question .",
    "we give an order 2 knowledge state algorithm which is provably @xmath6-competitive .",
    "since an equivalent behavioral algorithm must keep one  bookmark , \" namely the address of an ejected page , it is not an improvement over our earlier result @xcite , but it does illustrate the knowledge state technique in a simple way .",
    "we then give an order 3 knowledge state algorithm which is provably @xmath7-competitive , which is an improvement , in terms of memory requirements , over equitable for the case @xmath1 ( section [ sec : ks cache ] ) .",
    "we also consider the problem of breaking the 2-competitive barrier for the randomized competitiveness of the 2-server problem , a goal which has , as yet , been achieved only in special cases ( section [ sec : server ] ) .",
    "for the class of uniform spaces , this barrier was broken by partition @xcite .",
    "for the line , a @xmath8-competitive algorithm was given by bartal _",
    "et al .  _",
    "@xcite .    in this paper",
    "we give a formal description of the knowledge state method .",
    "it is defined using the mixed model of online computation , which is described in section [ sec : online opt prob ] .",
    "this section relates the mixed model to the standard models of online computation , and explains how a behavioral algorithm can be derived from a mixed model description .",
    "section [ sec : know ] defines the knowledge state method ( in terms of the mixed model ) and shows how potentials can be used to derive the competitive ratio of a knowledge state algorithm . even though the concepts in section [ sec : online opt prob ] and [ sec : know ] are natural and intuitive some of the formal arguments to prove our method are somewhat involved .",
    "in section [ sec : ks cache ] the method is applied to the paging problem ; two optimally competitive algorithms are presented .",
    "we discuss ongoing experimental work for the server problem in section [ sec : server ] .",
    "we will introduce a new model of randomized online computation which is a generalization of both the classic behavioral and distributional models .",
    "we assume that we are given an online problem with states @xmath9 ( also called configurations ) , a fixed _",
    "start state _",
    "@xmath10 , and a requests @xmath11 .",
    "if the current state is @xmath12 and a request @xmath13 is given , an algorithm for the problem must _ service _ the request by choosing a new state @xmath14 and paying a cost , which we denote @xmath15 .",
    "it is convenient to assume that there is a  distance \" function @xmath16 on @xmath9 , and it is possible to choose to move from state @xmath17 to state @xmath14 at cost @xmath18 at any time , given no request .",
    "we will assume that @xmath19 and @xmath20 for any states @xmath21 .",
    "it follows that @xmath22 for any states @xmath23 and request @xmath24 . formally in this paper",
    "we refer to an online problem as an ordered triple @xmath25 .",
    "examples of online problems satisfying these conditions abound , such as the server problem , the cache problem , _",
    "etc._.    given a _ request sequence _ @xmath26 , an algorithm must choose a sequence of states @xmath27 , the _",
    "service_. the _ cost _ of this service is defined to be @xmath28",
    ". an _ offline _",
    "algorithm knows @xmath29 before choosing the service sequence , while an _ online _ algorithm must choose @xmath30 without knowledge of the future requests .",
    "we will assume that there is an optimal offline algorithm , @xmath31 , which computes an optimal service sequence for any given request sequence .",
    "as is customary we say that a deterministic online algorithm @xmath32 is _ @xmath33-competitive _ for a given number @xmath33 if there exists a constant @xmath34 ( not dependent on @xmath29 ) such that @xmath35 for any request sequence @xmath29 .",
    "similarly , we say that a randomized online algorithm @xmath32 is @xmath33-competitive for a given number @xmath33 if there exists a constant @xmath34 ( not dependent on @xmath29 ) such that @xmath36 for any request sequence @xmath29 , where @xmath37 denotes expected value .    in order to make the description of various models of randomized online computation more precise , we introduce the following notation .",
    "let @xmath38 be the set of all finite distributions on @xmath9 .",
    "if @xmath39 and @xmath40 , we say that @xmath41 _ supports _ the distribution @xmath42 if @xmath43 .",
    "the _ distributional support _ ( or  _ support _ \" for short ) of any @xmath39 is defined to be the unique minimal set which supports @xmath42 . by an abuse of notation , if the support of @xmath42 is a singleton @xmath44 , we write @xmath45 .",
    "an instance of the _ transportation problem _ is a weighted directed bipartite graph with distributions on both parts .",
    "formally , an instance is an ordered quintuple @xmath46 where @xmath47 and @xmath48 are finite non - empty sets , @xmath49 is a distribution on @xmath47 , @xmath50 is a distribution on @xmath48 , and @xmath51 is a real - valued function on @xmath52 .",
    "a _ solution _ to this instance is a distribution @xmath53 on @xmath52 such that    1 .",
    "@xmath54 for all @xmath55 .",
    "@xmath56 for all @xmath57 .",
    "then @xmath58 , and @xmath53 is a _ minimal _",
    "solution if @xmath59 is minimized over all solutions , in which case we call @xmath59 the _ minimum transportation cost_.    there are three standard models of randomized online algorithms ( see , for example @xcite ) .",
    "we introduce a new model in this paper , which we call the _",
    "mixed model_. those three standard models are : distribution of deterministic online algorithms , the behavioral model , and the distributional model .",
    "we very briefly describe the three standard models .    in this model",
    ", @xmath32 is a random variable whose value is a deterministic online algorithm . if the random variable has a finite distribution , we say that @xmath32 is _ barely random_.    in this model @xmath32 uses randomization at each step to pick the next configuration .",
    "we assume that @xmath32 has memory .",
    "let @xmath60 be the set of all possible memory states of @xmath32 .",
    "we define a _",
    "full state _ of @xmath32 to be an ordered pair @xmath61 .",
    "let @xmath62 be the initial memory state , and let @xmath63 be the memory state of @xmath32 after servicing the first @xmath64 requests .",
    "then @xmath32 uses randomization to compute @xmath65 , the full state after @xmath64 steps , given only @xmath66 and @xmath67 . a behavioral algorithm",
    "can then be thought of as a function on @xmath68 whose values are random variables in @xmath69 .    if @xmath70 , let @xmath41 be the support of @xmath42 and @xmath71 be the support of @xmath72",
    "we then define @xmath73 to be the minimum transportation cost of the transportation problem @xmath74 , and if @xmath13 , we define @xmath75 to be the minimum transportation cost of the transportation problem @xmath76 , where @xmath77 .",
    "a distributional online algorithm @xmath32 is then defined as follows .    1 .",
    "there is a set @xmath60 of memory states of @xmath32 .",
    "there is a start memory state @xmath62 .",
    "2 .   a _ full state _ of @xmath32 is a pair @xmath78 .",
    "the initial full state is @xmath79 , where @xmath80 .",
    "3 .   for any",
    "given full state @xmath81 and request @xmath24 , @xmath32 deterministically computes a new full state @xmath82 , using only the inputs @xmath42 , @xmath83 , and @xmath24 .",
    "we write @xmath84 or alternatively @xmath85 .",
    "thus , @xmath32 is a function from @xmath86 to @xmath87 .",
    "4 .   given any input sequence @xmath88",
    ", @xmath32 computes a sequence of full states @xmath89 , following the rule that @xmath90 for all @xmath91 .",
    "define @xmath92 .",
    "we note that a distributional online algorithm , despite being a model for a randomized online algorithm , is in fact deterministic , in the sense that the full states @xmath93 are computed deterministically .",
    "the following theorem is well - known .",
    "( it is , for example , implicit in chapter 6 of @xcite . )",
    "[ thm : all models equivalent ] all three of the above models of randomized online algorithms are equivalent , in the following sense . if @xmath94 is an algorithm of one of the models , there exist algorithms @xmath95 , @xmath96 , of each of the other models , such that , given any request sequence @xmath29 , the cost ( or expected cost ) of each @xmath97 for @xmath29 is no greater than the cost ( or expected cost ) of @xmath94 .",
    "the _ mixed model _ of randomized algorithms is a generalization of both the behavioral model and the distributional model .",
    "a mixed online algorithm chooses a distribution at each step , but , as opposed to a distributional algorithm , which must make that choice deterministically , can use randomization to choose the distribution .    a _ mixed _ online algorithm @xmath32 for an online problem @xmath98 is defined as follows . as before , let @xmath38 be the set of finite distributions on @xmath9 .    1 .",
    "there is a set @xmath60 of memory states of @xmath32 .",
    "there is a start memory state @xmath62 .",
    "2 .   a _ full state _ of @xmath32 is a pair @xmath78 .",
    "the initial full state is @xmath79 , where @xmath80 .",
    "3 .   for any given full state @xmath81 and request @xmath24",
    ", there exists a finite set of full states @xmath99 and probabilities @xmath100 , where @xmath101 , such that if the current full state is @xmath2 and the next request is @xmath24 , @xmath32 uses randomization to compute a new full state @xmath82 , by selecting @xmath102 for some @xmath103 . the probability that @xmath32 selects each given @xmath104 is @xmath105 .",
    "we call the @xmath106 the _ subsequents _ and the @xmath107 the _ weights _ of the subsequents , for the request @xmath24 from the full state @xmath2 .",
    "+ @xmath32 is a function on @xmath86 whose values are random variables in @xmath87",
    ". we can write @xmath84 .",
    "alternatively , we write @xmath85 . for fixed @xmath2 and @xmath24 ; @xmath108 , and @xmath109 can be regarded as random variables .",
    "4 .   given any input sequence @xmath88 , @xmath32 computes a sequence of full states @xmath110 , following the rule that @xmath90 for all @xmath111 .",
    "note that , for all @xmath112 , @xmath113 , @xmath114 , and @xmath63 are random variables .",
    "computing the cost of a step of a mixed model online algorithm @xmath32 is somewhat tricky .",
    "we note that it might seem that @xmath115 would be that cost ; however , this is an overestimate . without loss of generality , @xmath32 is sensible .",
    "let @xmath78 and let @xmath13 .",
    "let @xmath116 be the support of @xmath42 .",
    "let @xmath117 be the subsequents and @xmath107 the weights of the subsequents , for the request @xmath24 from the full state @xmath2 .",
    "let @xmath118 be the union of the supports of the @xmath119 .",
    "define @xmath120 .",
    "note that @xmath121 , and its support is @xmath122 .",
    "define @xmath123 .    finally ,",
    "if @xmath124 is the input request sequence , and the sequence of full states of @xmath32 is @xmath125 , we define @xmath126 .",
    "we now prove that the mixed model for randomized online algorithms is equivalent to the three standard models .",
    "[ lem : mixed yields beh ] if @xmath32 is a mixed online algorithm , there is a behavioral online algorithm @xmath127 such that , for any request sequence @xmath29 , @xmath128 .",
    "a memory state of @xmath129 will be a full state of @xmath32 , _ i.e. _ , we could write @xmath130 . by a slight abuse of notation ,",
    "we also define a full state of @xmath129 to be an ordered triple @xmath131 such that @xmath132 is a full state of @xmath32 and @xmath133 .",
    "intuitively , @xmath129 keeps track of its true state @xmath12 , while remembering the full state @xmath132 of an emulation of @xmath32 .    for clarity of the proof ,",
    "we introduce more complex notation for some of the quantities defined earlier .",
    "let @xmath134 , @xmath135 , and @xmath13 .",
    "if @xmath132 is a full state of @xmath32 , define @xmath136 to be the probability that @xmath137 , _",
    "i.e. _ , the conditional probability that @xmath32 chooses @xmath138 to be the next full state , given that the current full state is @xmath132 and the request is @xmath24 .",
    "we assume that there can be at most finitely many choices of @xmath138 for which @xmath139 . in case @xmath132",
    "is not a full state of @xmath32 , then @xmath136 is defined to be zero . if @xmath132 is a full state of @xmath32 and @xmath13 , write @xmath140 , and choose a finite distribution @xmath141 on @xmath142 which is a minimal solution to the transportation problem @xmath143 , where @xmath144 . thus @xmath145 for @xmath12 ; @xmath146 for @xmath147 ; @xmath148 .",
    "we now formally describe the action of the behavioral algorithm @xmath129 .",
    "the initial full state of @xmath129 is @xmath149 .",
    "given that the full state of @xmath129 is @xmath150 and the next request is @xmath13 , and given any @xmath151 , we define @xmath152 , the probability that @xmath129 chooses the next full state to be @xmath153 , as follows :    if @xmath154 , then @xmath155",
    ".    otherwise , @xmath156    let @xmath29 be a given request sequence .",
    "we now prove that @xmath157 . for",
    "any @xmath158 and any knowledge state @xmath132 of @xmath32 , define @xmath159 to be the probability that the full state of @xmath32 is @xmath132 after @xmath64 steps . additionally ,",
    "if @xmath12 , define @xmath160 to be the probability that the full state of @xmath129 is @xmath150 after @xmath64 steps .    to prove the lemma we consider first the following two claims :    1 .   for any @xmath158 , @xmath12 , @xmath39 , and @xmath161 , @xmath162",
    "2 .   for any @xmath158 , @xmath39 , and @xmath161 , @xmath163 .",
    "we prove claims 1 and 2 by simultaneous induction on @xmath64 .",
    "if @xmath164 , both claims are trivial by definition .",
    "now , suppose @xmath165 .",
    "we verify claim 1 for @xmath64 . by the inductive hypothesis ,",
    "claim 2 holds for @xmath166 .",
    "write @xmath167 .",
    "let @xmath168 . if @xmath138 is not a full state of @xmath32 or @xmath169 , we are done",
    "otherwise , recall that @xmath146 for all @xmath147 , and we obtain @xmath170 which verifies claim 1 for @xmath64 . claim 2 for @xmath64 follows trivially .    for the conclusion of the lemma , let @xmath165 , and let @xmath171 .",
    "we use claim 1 for @xmath166 . recall that @xmath172 for any full state @xmath132 of @xmath32 . then @xmath173 and we are done .",
    "[ thm : mixed implies all standard ] if @xmath32 is a mixed model online algorithm for an online problem @xmath174 , there exist algorithms @xmath94 , @xmath95 , and @xmath96 for @xmath174 , of each of the standard models , such that , given any request sequence @xmath29 , the cost ( or expected cost ) of each @xmath97 for @xmath29 is no greater than the cost ( or expected cost ) of @xmath32 .    from lemma [ lem : mixed yields beh ] and theorem [ thm : all models equivalent ] .",
    "[ cor : mixed is comp imples comp ] if there is a @xmath33-competitive mixed model online algorithm for an online problem @xmath174 , there is a @xmath33-competitive online algorithm for @xmath174 for each of the three standard models of randomized online algorithms .",
    "we say that a function @xmath175 is _ lipschitz _ if @xmath176 for all @xmath177 . an _",
    "estimator _ is a non - negative lipschitz function @xmath178 .",
    "if @xmath40 , we say that @xmath41 _ supports an estimator _",
    "@xmath179 if , for any @xmath147 there exists some @xmath180 such that @xmath181 . if @xmath179 is supported by a finite set , then there is a unique minimal set @xmath41 which supports @xmath179 , which we call the _ estimator support _ of @xmath179 .",
    "( we use the term  _ support _ \" instead of  estimator support \" if the context excludes ambiguity . )",
    "we note that all estimators considered in this paper have finite support .",
    "we say that an estimator @xmath179 has _ zero minimum _ if @xmath182 .",
    "the next lemma allows us to compare estimators by examining finitely many values .",
    "[ lem : just check support ] suppose @xmath179 and @xmath183 are estimators , and @xmath41 is the support of @xmath179 .",
    "then @xmath184 for all @xmath12 if and only if @xmath185 for all @xmath186 .",
    "one direction of the proof is trivial .",
    "suppose @xmath187 and @xmath185 for all @xmath186",
    ". then there exists @xmath186 such that @xmath188 .",
    "it follows that @xmath189 , contradiction .",
    "an example of an estimator is the _ work function _ of a request sequence . if @xmath177 , we write @xmath190 to denote the minimal cost of servicing the request sequence @xmath29 starting at configuration @xmath17 and ending at configuration @xmath14 . then , if @xmath29 is a request sequence , the _ work function _",
    "@xmath191 is defined by @xmath192 . if @xmath29 is a request sequence , the _ offset function _ is defined to be @xmath193 , a zero minimum estimator . if @xmath179 is an estimator and if @xmath13 is a request , we define function @xmath194 as @xmath195 . we call",
    " @xmath196 \" the _ update operator_. the following lemma allows us to compute the update in finitely many steps .",
    "[ lem : update uses only support ] if @xmath179 is supported by @xmath41 , then @xmath197 .",
    "trivially , @xmath198 . pick @xmath199 such that @xmath200 .",
    "pick @xmath180 such that @xmath201 . then @xmath202 and we are done .",
    "we note that it is easy to verify that @xmath194 is also an estimator .",
    "we briefly note the following lemma , which is well - known ( see , for example , @xcite ) .",
    "[ lem : update work ] if @xmath203 , let @xmath204 for all @xmath205 .",
    "then @xmath206 for all @xmath12 and @xmath207 for all @xmath165 .",
    "we use _ estimators _ and _ adjustments _ to analyze the competitiveness of an online algorithm @xmath32 .",
    "more specifically , the combination of estimators and adjustments allows us to estimate the optimal cost .",
    "an online algorithm does not know the optimal offline algorithm s cost at any given time , but can keep track of the estimator , and use it as a guide .",
    "the estimator is a real - valued function on configurations that is updated at every step , and which estimates the cost of the optimal offline algorithm , while the adjustment is a real number that is computed at every step .",
    "both the estimator and the adjustment may be calculated using randomization .",
    "a _ knowledge state algorithm _ is a mixed online algorithm that computes an adjustment and an estimator at each step , and uses the current estimator as its memory state .",
    "more formally , if @xmath32 is a knowledge - state algorithm , then :    1 .   at any given step ,",
    "the full state of @xmath32 is a pair @xmath208 , where @xmath209 and @xmath175 is the current estimator .",
    "we call that pair the _ current knowledge state .",
    "if @xmath210 is the knowledge state and the next request is @xmath24 , then @xmath32 computes an adjustment , a number which we call @xmath211 , and uses randomization to pick a new knowledge state @xmath212 . more precisely , there are subsequent knowledge states @xmath213 and subsequent weights @xmath105 for @xmath214 such that 1 .",
    "[ eqn : las vegas update ] @xmath215 for each @xmath12 .",
    "2 .   for each @xmath103 , @xmath32 chooses @xmath216 to be @xmath104 with probability @xmath105 .",
    "3 .   let @xmath120 .",
    "define @xmath123 .",
    "( as defined in the previous section in terms of the transportation problem ) 3 .   finally , if @xmath124 is the input request sequence , and the sequence of full states of @xmath32 is @xmath125 , where @xmath217 , we define @xmath218    if @xmath40 , we say that a knowledge state @xmath208 is _ supported as a knowledge state _ by @xmath41 if @xmath179 is supported by @xmath41 ( in the estimator sense ) and @xmath42 is supported ( distributionally ) by @xmath41 .",
    "note that , in this case , @xmath208 can be represented by the finite set of triples @xmath219 .",
    "we say that a knowledge state algorithm _ has finite support _ if there is a uniform bound on the cardinality of the supports of the knowledge states .",
    "this bound is also called the _ order _ of the knowledge state algorithm .",
    "we say that _",
    "@xmath32 is @xmath33-competitive as a knowledge state algorithm _ if there is a constant @xmath34 such that @xmath220 for any request sequence @xmath221 and any @xmath12 .",
    "[ lem : is opt ] given a request sequence @xmath203 , then for all @xmath12 @xmath222    let @xmath223 be the optimal service of @xmath29 that ends in @xmath17 .",
    "thus : @xmath224 . by ( [ eqn :",
    "las vegas update ] ) : @xmath225 for all @xmath64 . by definition : @xmath226 for all @xmath64 . summing the inequalities over all @xmath64 , and adding to the equation",
    ", we obtain the result .    [",
    "lem : ks comp implies comp ] if a knowledge state algorithm @xmath32 is @xmath33-competitive as a knowledge state algorithm , then @xmath32 is @xmath33-competitive",
    ".    let @xmath34 be the constant given in the definition of @xmath33-competitiveness for a knowledge state algorithm .",
    "let @xmath227 be any request sequence , and let @xmath228 be the optimal service of @xmath29 . since @xmath32 is @xmath33-competitive as a knowledge state algorithm : @xmath229    we now define a @xmath33-knowledge state potential ( @xmath33-ks - potential , for short ) for a given knowledge state algorithm @xmath32 .",
    "let @xmath230 be a real - valued function on knowledge states .",
    "then we say that @xmath230 is a _",
    "@xmath33-ks - potential for @xmath32 _ if    1 .",
    "@xmath231 for any @xmath2 .",
    "if @xmath210 is the current knowledge state and @xmath24 is the next request , @xmath232 are the subsequents of that request , and @xmath107 are the weights of the subsequents , let @xmath233 . then @xmath234    [ thm : ks pot implies comp ] if a knowledge state algorithm @xmath32 has a @xmath33-ks - potential , then @xmath32 is @xmath33-competitive .",
    "the proof follows easily from the definition of a @xmath33-ks - potential and lemmas [ lem : is opt ] and [ lem : ks comp implies comp ] by straightforward arguments .",
    "let @xmath235 be a request sequence .",
    "let @xmath236 be the sequence of knowledge states of @xmath32 given the input @xmath29 , where @xmath217 .",
    "let @xmath237 , a random variable for each @xmath64 .",
    "note that @xmath238 is a constant .",
    "let @xmath239 .",
    "note that @xmath240 .",
    "let @xmath12 be the configuration of the optimal algorithm after @xmath241 steps . then @xmath242 the first inequality above is from lemma [ lem : is opt ] .",
    "the last two inequalities are from the definition of a @xmath33-ks - potential .",
    "it follows that @xmath243 , and , by lemma [ lem : ks comp implies comp ] , we are done .",
    "we can define a _ forgiveness _ online algorithm to be a knowledge state algorithm with the special restriction that there is always exactly one subsequent .",
    "we note that historically , forgiveness came first , so we can think of the knowledge state approach as being a generalization of forgiveness .",
    "a forgiveness algorithm can be deterministic , such as equipoise , a deterministic online 11-competitive algorithm for the 3-server problem ( that was the best known competitiveness for that problem at that time ) , or distributional , such as equitable , an @xmath3-competitive distributional online algorithm for the @xmath2-cache problem .",
    "( see @xcite . )",
    "we now consider the @xmath2-cache problem for fixed @xmath244 .",
    "the @xmath2-cache problem reduces to online optimization , as defined in section [ sec : online opt prob ] of this paper , as follows :    1 .",
    "there is a set of _",
    "pages_. 2 .",
    "@xmath9 is the set of all @xmath2-tuples of distinct pages . if the configuration of an algorithm is @xmath12 , that means that the pages that constitute @xmath17 are in the cache .",
    "the initial configuration is the initial cache .",
    "4 .   if @xmath177 , then @xmath18 is the cost of changing the cache from @xmath17 to @xmath14 . since we assume that it costs 1 to eject a page and bring in a new page , @xmath18 is the cardinality of the set @xmath245 .",
    "@xmath11 is simply the set of all pages .",
    "if a page @xmath24 is requested , it means that the algorithm must ensure that @xmath24 is in the cache at some point as it moves between configurations .",
    "thus , for any @xmath177 and any @xmath13 , we have @xmath246    to complete the reduction , we observe that the support of any configuration request pair @xmath247 is finite . if @xmath248 , that support has only one element , namely @xmath17 , while otherwise , it has @xmath2 elements , namely @xmath249 .",
    "we introduce a convenient notation , a modification of the bar notation of koutsoupias and papadimitriou @xcite , for offset functions for the @xmath2-cache problem , which we call the _ bar notation_. let @xmath49 be a string consisting of at least @xmath2 page names and exactly @xmath2 bars , with the condition that at least @xmath103 page names are to the left of the @xmath250 bar .",
    "then @xmath49 defines an offset function @xmath179 as follows .",
    "let @xmath40 be the set of all configurations @xmath17 such that , for each @xmath251 , the names of at least @xmath103 members of @xmath17 are written to the left of the @xmath250 bar .",
    "let @xmath179 be the estimator such that @xmath41 is the support of @xmath179 , and such that @xmath252 for each @xmath180 .",
    "for example for @xmath0 , @xmath253 denotes the estimator whose support consists of just the configuration @xmath254 , and which takes the value zero on that configuration . for @xmath255",
    ", @xmath256 denotes the estimator whose support consists of the configurations @xmath257 , @xmath258 , @xmath259 , @xmath260 , and @xmath261 , and which takes the value zero on those configurations . from @xcite",
    ", we have :    [ lem : bar lemma ] a function @xmath179 is an offset function for the @xmath2-cache problem if and only if it can be expressed using the bar notation .",
    "recall that partition ( introduced in @xcite ) is optimally competitive for the @xmath2-cache problem , but uses unbounded memory to achieve the optimal competitiveness of @xmath3 .",
    "the memory state of partition is , in fact , the classic offset function , which , in the worst case , requires keeping track of every past request .",
    "we now show how the use of knowledge states simplifies the definition , and in fact the memory requirement , of an optimally competitive randomized algorithm for the 2-cache problem , which we call @xmath263 .",
    "we will follow the rule that , at each step , the adjustment is as large as possible , so that the minimum of the estimator will always be zero .",
    "this guarantees that any potential will always be non - negative .",
    "if there are infinitely many pages , @xmath263 has infinitely many knowledge states , but , up to symmetry , it has only two .",
    "each such knowledge state of @xmath263 is supported by a set of cardinality at most 2 , hence has at most three active pages , and therefore its equivalent behavioral algorithm has at most one bookmark .    in the definitions given below , we say that two pages to are _ equivalent _ for a given knowledge state if they can be transposed without changing the knowledge state . 0.2 in    1 .",
    "if @xmath264 are pages , let @xmath265 . in this case , @xmath266 and @xmath267 are equivalent , _",
    "i.e. _ , @xmath268 .",
    "2 .   if @xmath269 are pages , let @xmath270 , where @xmath271 denotes the distribution which is @xmath272 on the configuration @xmath254 and @xmath272 on the configuration @xmath273 .",
    "in this case @xmath267 and @xmath274 are equivalent , _",
    "i.e. _ , @xmath275",
    ".    we list below the action of @xmath263 . in each case , @xmath276 are distinct pages .    1 .",
    "if @xmath254 is the initial cache , the initial knowledge state is @xmath277 .",
    "if the current knowledge state is @xmath277 then a.   [ act : k2 trivial a ] if the request is @xmath266 , the new knowledge state is @xmath277 .",
    "b.   [ act : k2 ac ] if the request is @xmath274 , then the new knowledge state is @xmath278 .",
    "if the current knowledge state is @xmath279 then a.",
    "[ act : k2 trivial b ] if the new request is @xmath266 , the new knowledge state is @xmath279 .",
    "b.   [ act : k2 bb ] if the new request is @xmath267 , the new knowledge state is @xmath280 . c.   [ act : k2 bd ] if the new request is @xmath281 , then there are three subsequents , namely @xmath282 , @xmath283 , @xmath284 .",
    "the distribution on the subsequents is uniform , _ i.e. _ , each is chosen with probability @xmath285 .",
    "actions [ act : k2 trivial a ] and [ act : k2",
    "trivial b ] are requests to the first block of pages , in the sense of the bar notation .",
    "since the bar notation implies that each page in the first block can be assumed to be in the cache , such a request is ignored by any sensible online algorithm , which means , in our case , that the estimator is unchanged and the adjustment is zero .",
    "we call such requests _ trivial_.    we define a potential @xmath286 by @xmath287 and @xmath288 .    [",
    "lem : pot for k2 ] @xmath286 is a @xmath289-ks - potential for @xmath263 .",
    "let @xmath2 be the current knowledge state and @xmath24 the new request .",
    "write @xmath290 for increase in potential in the given step",
    ". we will show that @xmath291 in all cases . in trivial actions , namely cases [ act : k2 trivial a ] and [ act : k2 trivial b ] , @xmath292 , and we are done .",
    "we first note that : @xmath293 by lemma [ lem : just check support ] , the last inequality need only be verified for configurations in @xmath294 , the support set of @xmath295 .    in this case @xmath296 and @xmath24 is a new page , @xmath274",
    ".    @xmath297 .",
    "thus @xmath298 . since the algorithm must bring in a new page , and since the probability is zero that the minimum transport brings in any other page , @xmath299 .",
    "@xmath300 , and we are done .    , _",
    "i.e. _ , @xmath301 and @xmath302 .    recall @xmath303 .",
    "note that @xmath304 , since , as functions , @xmath305 on the set of all configurations .",
    "@xmath306 , since the probability is @xmath272 that the algorithm does nothing , and the probability is @xmath272 that it ejects @xmath274 and brings in @xmath267 .",
    "@xmath307 , and we are done .    , _",
    "i.e. _ , @xmath301 and @xmath24 is a new page , @xmath16 .",
    "recall @xmath308 , thus @xmath309 . since the algorithm must bring in a new page , and",
    "since the probability is zero that the minimum transport brings in any other page , @xmath299 .",
    "@xmath310 , and we are done .",
    "this completes the proof of all cases .",
    "we have :    [ thm : k2 comp pot ] @xmath263 is @xmath289-competitive .",
    "we note that the number of active pages , _",
    "i.e. _ , pages contained in a support configuration , is never more than three .",
    "the number three is minimal , as given by the theorem below :    [ thm : at least 3 active pages ] there is no knowledge state algorithm for the 2-cache problem that is @xmath262-competitive as a knowledge state algorithm , and which never has more than two active pages , _",
    "i.e. _ , no bookmarks .",
    "if a knowledge state algorithm for the 2-cache problem never has more than two active pages , then it can have no bookmarks , hence is trackless . by theorem 2 of @xcite , there is no @xmath289-competitive trackless online algorithm for the 2-cache problem .",
    "we define a knowledge state algorithm @xmath311 which is @xmath7-competitive for the 3-cache problem .",
    "recall that @xmath312 . up to symmetry , @xmath311 has six knowledge states . the number of active pages , _",
    "i.e. _ , pages contained in a support configuration , is never more than five .",
    "the knowledge states of @xmath311 will be defined as follows . as in the case of @xmath263",
    ", we say that two pages are _ equivalent _ if they can be transposed without changing the knowledge state .    1 .",
    "@xmath313 for any three pages @xmath269 .",
    "the pages @xmath266 , @xmath267 , and @xmath274 are all equivalent , _",
    "i.e. _ , @xmath314 , _ etc .",
    "@xmath315 for any four pages @xmath276 .",
    "the pages @xmath267 , @xmath274 , and @xmath16 are all equivalent .",
    "3 .   @xmath316 for any four pages @xmath276 .",
    "the pages @xmath266 and @xmath267 are equivalent , and @xmath274 and @xmath16 are equivalent .",
    "4 .   @xmath317 for any five pages @xmath318 .",
    "the pages @xmath319 are equivalent .",
    "@xmath320 for any five pages @xmath318 . the pages @xmath266 and @xmath267 are equivalent , and @xmath16 and @xmath321 are equivalent .",
    "@xmath322 for any five pages @xmath318 .",
    "the pages @xmath267 and @xmath274 are equivalent , and @xmath16 and @xmath321 are equivalent .",
    "the actions are of @xmath311 are formally defined below . in each case , @xmath323 are distinct pages .",
    "we do not need to consider separate cases for requests to pages which are equivalent .    1 .",
    "[ act : k3 initial a ] if @xmath324 is the initial cache , the initial knowledge state is @xmath325 .",
    "if the current knowledge state is @xmath325 then a.",
    "[ act : k3 aa ] if the new request is @xmath266 , the new knowledge state is @xmath325 .",
    "b.   [ act : k3 ad ] if the new request is some page @xmath281 , the new knowledge state is @xmath326 .",
    "if the current knowledge state is @xmath327 then a.",
    "[ act : k3 ba ] if the new request is @xmath266 , the new knowledge state is @xmath327 .",
    "b.   [ act : k3 bb ] if the new request is @xmath267 , the new knowledge state is @xmath328 . c.   [ act",
    ": k3 be ] if new request is some page @xmath329 , the new knowledge state is @xmath330 .",
    "if the current knowledge state is @xmath328 then a.",
    "[ act : k3 ca ] if the new request is @xmath266 , the new knowledge state is @xmath328 .",
    "b.   [ act : k3 cc ] if the new request is @xmath274 , the new knowledge state is @xmath325 . c.   [ act :",
    "k3 ce ] if the new request is some page @xmath329 , the new knowledge state is @xmath331 .",
    "if the current knowledge state is @xmath332 then a.",
    "[ act : k3 da ] if the new request is @xmath266 , the new knowledge state is @xmath332 .",
    "b.   [ act : k3 db ] if the new request is @xmath267 , the new knowledge state is @xmath333 c.   [ act : k3 df ] if the new request is some page @xmath334 , then the new knowledge state is chosen uniformly from among the following ten knowledge states : @xmath335 , @xmath336 , @xmath337 , @xmath338 , @xmath339 , @xmath340 , @xmath341 , @xmath342 , @xmath343 , and @xmath344 .",
    "if the current knowledge state is @xmath333 then a.   [ act : k3 ea ] if the new request is @xmath266 , the new knowledge state is @xmath333 .",
    "b.   [ act : k3 ec ] if the new request is @xmath274 , the new knowledge state is @xmath325 . c.   [ act :",
    "k3 ed ] if the new request is @xmath16 , the new knowledge state is @xmath345 .",
    "d.   [ act : k3 ef ] if the new request is some page @xmath334 , then the new knowledge state is @xmath346 .",
    ".   if the current knowledge state is @xmath347 then a.   [ act : k3 fa ]",
    "if the new request is @xmath266 , the new knowledge state is @xmath347 .",
    "b.   [ act : k3 fb ] if the new request is @xmath267 , the new knowledge state is @xmath333 . c.   [ act :",
    "k3 fd ] if the new request is @xmath16 , the new knowledge state is @xmath348 .",
    "d.   [ act : k3 ff ] if the new request is some page @xmath334 , the new knowledge state is chosen uniformly from among the following six knowledge states : @xmath349 , @xmath350 , @xmath351 , @xmath352 , @xmath353 , and @xmath354 .",
    "we define a potential @xmath286 on the knowledge states as follows : @xmath355 , @xmath356 , @xmath357 , @xmath358 , @xmath359 , and @xmath360 .    [",
    "lem : pot for k3 ] @xmath286 is an @xmath361-ks - potential for @xmath311 .    for each action of @xmath311 , let @xmath290 be the increase in potential .",
    "we will show that @xmath362 in each case , the value of @xmath290 can be computed by simple subtraction .",
    "we need only compute the values of @xmath51 and @xmath363 for each action , after which the inequality ( [ eqn : k3 pot ] ) follows by simple arithmetic .    .",
    "these actions are trivial , and thus @xmath364 , and we are done .    .",
    "in these actions , the request is to a new page , and the probability that any other page is in the cache after the action does not increase : thus @xmath299 .",
    "we also know that @xmath298 because @xmath365 the remainder of the verification of ( [ eqn : k3 pot ] ) for each of those actions consists of simple arithmetic .    .",
    "note that @xmath304 since @xmath366 in each case , we must keep @xmath266 and @xmath267 and eject the other two unrequested pages .",
    "the probability is @xmath272 that @xmath274 is in our cache , and @xmath367 that @xmath16 is in our cache , thus @xmath368 for action [ act : k3 ec ] , and @xmath369 for action [ act : k3 ed ] . since @xmath310 for both actions , we are done .    .",
    "note that @xmath304 since @xmath370 for action [ act : k3 db ] , recall that the distribution of @xmath332 is uniform on six configurations . to compute @xmath51",
    ", we describe a minimal transport between the distribution of @xmath332 and the distribution of @xmath333 . that transport is defined as follows",
    ":    if the previous configuration is @xmath324 , @xmath371 , or @xmath372 , do nothing .",
    "if the previous configuration is @xmath373 , eject @xmath16 .",
    "if the previous configuration is @xmath374 , eject @xmath321 .",
    "if the previous configuration is @xmath375 , eject @xmath16 with probability @xmath272 , and eject @xmath321 with probability @xmath272 .",
    "thus , @xmath368 .",
    "it is a routine verification that the required distribution for @xmath333 is achieved . since @xmath376 , we have verified ( [ eqn : k3 pot ] ) for action [ act : k3",
    "db ] .    for action",
    "[ act : k3 fb ] , recall that the distribution of @xmath347 is @xmath272 on @xmath324 , and is @xmath377 on each of @xmath371 , @xmath372 , @xmath373 , and @xmath374 .",
    "a minimal transport can be defined as follows : if @xmath267 is already in the cache we do nothing , while otherwise , we eject @xmath274 . thus , @xmath378 .",
    "it is a routine verification that the required distribution for @xmath333 is achieved .",
    "since @xmath379 , we have verified ( [ eqn : k3 pot ] ) for action [ act : k3 fb ] .    .",
    "note that @xmath304 since @xmath380    for action [ act : k3 bb ] , recall that the distribution of @xmath327 is uniform on @xmath324 , @xmath371 , and @xmath373 .",
    "if @xmath267 is already in the cache we do nothing , while otherwise , we eject @xmath274 with probability @xmath272 and eject @xmath16 with probability @xmath272 . thus , @xmath381 .",
    "it is a routine verification that the required distribution for @xmath328 is achieved . since @xmath382 , we have verified ( [ eqn : k3 pot ] ) for action [ act : k3 bb ] .    for action",
    "[ act : k3 cc ] , recall that the distribution of @xmath328 is uniform on @xmath324 and @xmath371 .",
    "if @xmath274 is already in the cache we do nothing , while otherwise , we eject @xmath16 . thus , @xmath368 .",
    "the resulting distribution is concentrated at @xmath324 , as required for the knowledge state @xmath325 . since @xmath310 , we have verified ( [ eqn : k3 pot ] ) for action [ act : k3 cc ] .    for action",
    "[ act : k3 fd ] , recall that the distribution of @xmath347 is @xmath272 on @xmath324 , and is @xmath377 on each of @xmath371 , @xmath372 , @xmath373 , and @xmath374 .",
    "if @xmath16 is already in the cache we do nothing .",
    "if @xmath321 is in the cache , we eject @xmath321 . otherwise , the cache must be @xmath324 , in which case we eject @xmath267 or @xmath274 with equal probability .",
    "thus , @xmath369 .",
    "it is a routine verification that the required distribution for @xmath348 is achieved . since @xmath383 , we have verified ( [ eqn : k3 pot ] ) for action [ act : k3 fd ] .    .",
    "note that @xmath384 since @xmath385 . by lemma [ lem : just check support ] , this inequality need only be verified for the configurations in the support of @xmath386 .",
    "whatever the initial configuration is , @xmath266 and @xmath267 are in the cache . simply eject the other page .",
    "thus , @xmath387 .",
    "@xmath388 , and we are done .    .",
    "let @xmath389 and let @xmath390 we note : @xmath391 by lemma [ lem : just check support ] , these inequalities need only be verified for the configurations in the support of @xmath392 and @xmath393 , respectively .",
    "we thus have @xmath384 for [ act : k3 df ] , and @xmath394 for [ act : k3 ff ] .    to compute @xmath51 ,",
    "we give minimal transportations from the distribution of @xmath332 , respectively @xmath347 , to the weighted sum of distributions of the subsequents , for each of the two cases . for action",
    "[ act : k3 df ] , whatever the initial configuration is , @xmath266 is in the cache .",
    "eject @xmath266 with probability @xmath395 , and eject each of the other two pages with probability @xmath396 each .",
    "it is a routine verification that the required distribution is achieved .",
    "thus , @xmath387 .",
    "@xmath397 , and we are done .    for action",
    "[ act : k3 ff ] , the probability is @xmath272 that the initial configuration is @xmath324 . in this case , eject one of the three pages , each with probability @xmath285 .",
    "otherwise , the cache will contain @xmath266 , and either @xmath267 or @xmath274 but not both : eject @xmath266 with probability @xmath398 , and otherwise eject either @xmath267 or @xmath274 .",
    "it is a routine verification that the required distribution is achieved .",
    "thus , @xmath387 .",
    "@xmath383 , and we are done .",
    "this completes the proof of all cases .",
    "[ thm : k3 comp pot ] @xmath311 is @xmath361-competitive .",
    "it is our hope that our technique will yield an order 2 knowledge state algorithm whose competitiveness is provably less than 2 for all metric spaces .",
    "we mention briefly progress by giving results for a class of is ",
    "one step up \" in complexity from the class of uniform metric spaces .",
    "we consider the class of metric spaces @xmath399 , which consists of all metric spaces where every distance is either 1 or 2 , and where the perimeter of every triangle is either 3 or 4 .",
    "( the classic octahedral graph , which has six points , is a member of this class , as defined by schlfli @xcite . )",
    "we have a computer generated order 2 knowledge state algorithm for the 2-server problem in this class : its competitiveness is @xmath400 .",
    "we note that we also have calculated ( through computer experimentation ) the minimum value of @xmath33 in the sense that no lower competitiveness for any order 2 knowledge state algorithm for @xmath399 can be proved using the methods described here .",
    "this value is @xmath401 .",
    "we briefly mention that there is an order 3 knowledge state algorithm for @xmath399 which has , up to equivalence , only seven knowledge states , and is @xmath402-competitive .",
    "we also can prove that no randomized online algorithm for the 2-server problem for @xmath399 can achieve competitiveness less than @xmath402 .",
    "all knowledge states and probabilities in this order 3 algorithm can be described using only rational numbers .",
    "these results , as well as our results for the server problem in uniform spaces ( equivalent to the caching problem ) , indicate a natural trade - off between competitiveness and memory of online randomized algorithms .",
    "wolfgang bein , lawrence  l. larmore , and rdiger reischuk .",
    "knowledge states for the caching problem in shared memory multiprocessor systems . in _ proceedings of the 7th international symposium on parallel architectures , algorithms and networks _ , pages 307312 , ieee , 2004 .",
    "don coppersmith , peter  g. doyle , prabhakar raghavan , and marc snir .",
    "random walks on weighted graphs and applications to online algorithms . in _ proc .",
    "22nd symp .",
    "theory of computing ( stoc ) _ , pages 369378 .",
    "acm , 1990 ."
  ],
  "abstract_text": [
    "<S> we introduce the concept of knowledge states ; many well - known algorithms can be viewed as knowledge state algorithms . the knowledge state approach can be used to to construct competitive randomized online algorithms and study the tradeoff between competitiveness and memory . </S>",
    "<S> a knowledge state simply states conditional obligations of an adversary , by fixing a work function , and gives a distribution for the algorithm . </S>",
    "<S> when a knowledge state algorithm receives a request , it then calculates one or more  subsequent \" knowledge states , together with a probability of transition to each . </S>",
    "<S> the algorithm then uses randomization to select one of those subsequents to be the new knowledge state . </S>",
    "<S> we apply the method to the paging problem . </S>",
    "<S> we present optimally competitive algorithm for paging for the cases where the cache sizes are @xmath0 and @xmath1 . </S>",
    "<S> these algorithms use only a very limited number of bookmarks .    _ </S>",
    "<S> keywords : _ design of algorithms ; online algorithms ; randomized algorithms , paging . </S>"
  ]
}