{
  "article_text": [
    "active safety systems have the potential to transform automobile traffic by complementing a human operator s capabilities to prevent accidents and increase efficiency  @xcite . communication between cars",
    "enables cooperative safety applications by further augmenting information gained from local sensors .",
    "examples for active safety applications are traffic signal violation warning , cooperative collision warning and electronic emergency brake light  @xcite .    by transmitting information between each other",
    ", cars can gain a view of the traffic situation more refined than it would be possible merely with sensors  @xcite , because global information about traffic is being made available locally to the cars .",
    "such information can be used in active safety systems to avoid accidents and even improve traffic efficiency by enabling both communication with the infrastructure and between cars  @xcite .",
    "depending on the active safety application , different types of vehicle - to - vehicle ( v2v ) communication paradigms have been investigated .",
    "safety applications often require to maintain continuous tracking of other cars in the vicinity , which is typically done by having cars broadcast information about their position , velocity and other parameters of their state in regular intervals  @xcite .",
    "vehicle ad - hoc networks ( vanets ) using routing protocols such as geocasting or ad - hoc distance vector ( aodv ) handle applications involving several cars in a peer - to - peer ( p2p ) connection  @xcite .",
    "the main challenge is to maintain reliable communication in the presence of possible channel congestion if several cars use the transmission medium simultaneously  @xcite .",
    "traditionally , in the development of communication protocols , the programs are implemented manually , and verification of the protocol is only done after prototyping , either through testing or model checking  @xcite . a slight improvement over this bottom - up approach is to develop a framework for distributed protocol specification and automatically generate inputs to model checkers and theorem provers  @xcite . in contrast , synthesis finds the programs to be executed on each car directly from a global protocol specification . in this approach ,",
    "the synthesis method is guaranteed to generate distributed implementations that satisfy their specification by construction .",
    "however , so far only small problems have been considered in synthesis without particular applications in mind  @xcite .",
    "also , protocol implementations are only valuable in practice if it is clear under which assumptions they are correct and if the communication requirements are clearly specified  @xcite .",
    "only if a precise model of the environment is provided , i.e.  the worst - case behavior of the transmission medium , is an argument of correctness convincing .",
    "synthesis is made difficult on the one hand by distributing a single global specification in a way that the distributed implementation operates correctly in an adverse environment , and on the other hand by having to ensure correctness of the results , which has to be ensured for _ any _ valid protocol specification given as input to the synthesis .",
    "our main contribution is the development of a method that automatically translates global specifications of the protocol into implementations that formally guarantee the desired quality of service requirements under the environment assumptions .",
    "specifically , we develop a synthesis method for reliable asynchronous communication protocols with clearly defined interfaces that can be used in a layered design .",
    "we focus on providing communication services to enable active safety applications for cars and therefore lump any active safety activities into an abstract higher level that interacts via strictly defined interfaces with the lower level communication services that we develop .",
    "our work addresses several shortfalls in previous work on protocol synthesis  @xcite .",
    "we introduce a formal specification language to allow a textual representation of the protocol specifications , which are typically given in graphical form .",
    "moreover , we make precise the semantics of protocol specifications and their implementations that are usually only informally described .",
    "[ cc][cc ] [ cc][cc ]   runs the red traffic light .",
    "hence car @xmath0 ( and potentially other cars ) must stop .",
    "other cars at the intersection may be transmitting over the wireless medium at the same time , which has a deteriorating effect on the communication between @xmath1 and @xmath0.,title=\"fig:\",scaledwidth=45.0% ]    consider the scenario of two cars wanting to communicate with each other at an intersection , c.f .",
    "[ fig : intersection ] .",
    "one major complicating factor for reliable v2v communication is that the cars are constantly moving and have to communicate over wireless links .",
    "cars that intend to communicate share restricted bandwidth availability with all other cars within reach . when constantly tracking cars using broadcasts , scalability is limited by the susceptibility for flooding and frequent message collisions  @xcite , and by having to keep track of the state of every car",
    ".    it would be desirable to be able to implement communication protocols that guarantee the correct transmission of data even in the presence of a large number of other cars .",
    "we therefore consider initiating communication on - demand when required by an active safety application in an emergency . in this approach",
    "we do not track every car but only exchange information when required .",
    "this approach has the advantage that traffic on the network is lower , more predictable , and reliability guarantees can be provided , as demonstrated in this paper .",
    "we adopt an approach in which the sender is responsible for correct delivery by retransmitting data when a package drop is detected  @xcite .",
    "when considering a v2v communication between two cars , we do not explicitly consider the behavior of all other cars .",
    "since from the point of view of the transceivers it is only relevant whether a message is correctly received , we lump together the behavior of all other cars that are not directly involved in the communication and consider them as a single environment .",
    "our method allows us to explicitly state the assumptions on this environment under which the protocol has to perform correctly .",
    "communication between cars is governed by a set of rules summarized as a protocol .",
    "after a data transfer is initiated , messages are transmitted and received in order to guarantee a reliable delivery . a protocol is implemented by equipping each car with a communication service automaton ( csa ) , which can be seen as a building block or `` controller '' handling all communication activities .",
    "hence , the protocol can be seen as a building block with clearly defined behavior and interfaces to its environment consisting of higher level active safety components ( ascs ) and to the lower level that handles the transmission of the messages over the physical medium .",
    "each csa operates locally , i.e.  it can only interact with the sensors and actuators of the car it is located on .",
    "however , since a communication protocol defines events potentially involving several cars , csas need to interact with each other .",
    "this interaction is done by transmitting messages between the cars e.g.  using wireless transceivers .    defining a clear hierarchy of layers",
    "is inspired from the iso osi architecture prevalent in most modern communication networks  @xcite : a _ network layer _ is dedicated to establishing host - to - host connections with basic quality of service ( qos ) guarantees .",
    "data - link layer _ is layered below the network layer and provides error - corrected single hop connections . above the network layer",
    "is the _ transport layer _ , that among other services provides the destination address of a message and qos requirements .",
    "we consider an abstraction in which a car s asc contains the transport layer and all above layers .",
    "the asc specifies parameters such as the data to be sent , the destination address , and limits on transmission delay .",
    "developing a synthesis method requires a formal specification language for protocols and a modelling framework to formally describe executable csas .",
    "moreover , the csas should include interfaces to their corresponding ascs at the higher level , and hence our synthesis method is designed to introduce this inter - level interaction . to illustrate our method we will use the following example motivated by caveney  @xcite , and farkas et al .",
    "@xcite :    consider the scenario of cars at a road intersection shown in fig .",
    "[ fig : intersection ] .",
    "car @xmath1 runs a red traffic light , and car @xmath0 approaches the intersection on a trajectory that would lead to a collision .",
    "the two cars have to communicate in order to avoid an accident . at the intersection",
    "there might be other cars that share the same broadcast medium and hence might interfere with the communication between @xmath1 and @xmath0 .",
    "@xmath2^<<<<{{{\\underline{{\\mathrm{snd}}}}_{{a } \\rightarrow { b}}(d ) } } & & { \\mathrm{asc}_b }   \\ar@<1ex>[ddd]^<<<<{{{\\underline{{\\mathrm{ack}}}}_{{b } \\rightarrow { a } } } } \\\\ \\\\ \\\\ { \\begin{array}{l}\\text{\\sl network}\\\\\\text{\\sl layer { \\phantom{anda}}}\\end{array } } & * + + + [ ] [ f]{m_a } \\ar@<1ex>[d]^>>{!!a_{a \\rightarrow b}(d ) } \\ar@<1ex>[uuu]^<<<<{{{\\underline{{\\mathrm{ack}}}}_{{a } \\leftarrow { b } } } } & & * + + + [ ] [ f]{m_b } \\ar@<1ex>[d]^>>{!!b_{b \\rightarrow a } } \\ar@<1ex>[uuu]^<<<<{{{\\underline{{\\mathrm{snd}}}}_{{b } \\leftarrow { a}}(d ) } } \\\\ { \\begin{array}{l}\\text{\\sl data - link}\\\\\\text{\\sl layer and}\\\\\\text{\\sl below}\\end{array } } & { } \\ar@<1ex>[u]^<<{?b_{a \\leftarrow b } } & { \\begin{array}{c}\\\\\\\\\\text{medium}\\end{array } } \\ar@<2.5ex>@{==}[l ] \\ar@<-2.5ex>@{==}[r ] & { } \\ar@<1ex>[u]^<<{?a_{b \\leftarrow a}(d ) }      } \\ ] ]    the primary objective of a communication protocol is to transfer information between cars .",
    "information transfer between two cars can be interpreted as synchronizing two local events between the cars .",
    "events are indexed by elements @xmath3 from a set @xmath4 .",
    "an event @xmath3 may be associated with data @xmath5 from a set @xmath6 , written @xmath7 .",
    "@xmath6 contains an auxiliary element @xmath8 , indicating the absence of data .",
    "we simply write @xmath3 for notational convencience if @xmath9 in @xmath7 .    a _ _ local event is an event that is triggered either by the asc of a car ( an _ _ environment - triggered event from the point of view of the csa ) , or by the csa of a car itself ( a _ _ system - triggered event ) .",
    "an environment - triggered event that is initiated by the asc at car @xmath1 and is to be synchronized with car @xmath0 is written as @xmath10 .",
    "it is synchronized with the corresponding system - triggered event @xmath11 by the csa of car @xmath0 .",
    "the sets of environment - triggered and system - triggered events are written as @xmath12 and @xmath13 respectively .",
    "if @xmath10 on car @xmath1 is synchronized with @xmath11 on car @xmath0 , then the data @xmath5 is transferred from @xmath1 to @xmath0 .",
    "this is summarized as a single _ _",
    "global event @xmath14 ( note the absence of the line under @xmath3 ) .",
    "the set of global events is denoted by @xmath15 .",
    "a protocol specification defines a desired temporal order on such global events . since global events",
    "involve several cars , a protocol specification is _ _ centralized , i.e. , it is assumed that the actions of all cars can be influenced independently by a single controller .",
    "synchronization is achieved by sending messages across a shared transmission medium .",
    "a csa interacts with the medium by transmitting messages and waiting for reception of messages .",
    "a message _ _ transmission is indicated by `` @xmath16 '' , while a _ _ reception is indicated by `` ? '' prefixed to a message .    the interaction with the higher - level asc",
    "is managed by _ _ calls and _ _ upcalls .",
    "a call is initiated by the asc and causes an environment - triggered event in the csa .",
    "an upcall is initiated by a system - triggered event in the csa",
    ".    continued consider again the intersection problem in fig .",
    "[ fig : intersection ] .",
    "as car @xmath1 is approaching the intersection , it needs to establish whether it is safe to enter the intersection .",
    "it therefore wants to establish a communication with any car that might pose a safety hazard .",
    "car @xmath1 needs to communicate with car @xmath0 to find out if @xmath0 is willing and able to stop or whether @xmath1 should attempt an emergency brake .",
    "each car is assigned a unique address for labelling messages , so that when a car receives a message , it knows whether it is the intended destination .",
    "we assume that the asc at @xmath1 provides its csa with the address of @xmath0 , so that a p2p communication with @xmath0 can be established .",
    "this communication scenario is shown in fig .",
    "[ fig : cars ] , where the csa associated with each car is shown as a box .",
    "data @xmath5 is transferred from @xmath1 to @xmath0 , and @xmath0 should send an acknowledgement back to @xmath1 . sending @xmath5 from @xmath1 to @xmath0 is done by synchronizing the local events @xmath17 and @xmath18 , while the acknowledging synchronizes @xmath19 with @xmath20 .",
    "a call by an asc triggers the corresponding environment - triggered event in the csa on the same car , while an upcall is initiated by the csa when some system - triggered event requires the attention of the higher level .",
    "depending on the application , it is be necessary to guarantee that a transmission is completed with certain requirements on particular aspects such as end - to - end delay , message drop probability or bandwidth .",
    "these aspects are called quality of service ( qos )",
    ". we are concerned with automatically implementing protocols that guarantee that certain requirements on qos are met .",
    "whether qos requirements can be satisfied depends on the properties of the medium used to transmit messages over . in our work",
    "we assume minimal capabilities for a transceiver , so the only way to satisfy qos requirements is to select the appropriate frequency and number of retransmissions for messages .    also , when finding the csas that satisfy the protocol , we have to take into account that the performance of the transmission medium typically degrades as consequence of messages being transmitted .",
    "moreover , a car can not predict the behavior of the transmission medium merely on the basis of its own actions , since there might be other cars sharing the same medium that exhibit unpredictable behavior from the point of view of the car . in example 1 , while cars @xmath1 and @xmath0 are communicating , other cars might be trying to transmit messages itself , leading to a degradation in performance for @xmath1 and @xmath0 that neither car can predict .",
    "we restrict the package drop probability @xmath21 of the transmission medium by assuming that it is below a given threshold probability @xmath22 at all times .",
    "we write this as @xmath23 , where `` @xmath24 '' is the always operator `` @xmath24 '' of linear temporal logic ( ltl ) hence , a full specification in the framework can be stated as an assumption / guarantee specification  @xcite @xmath25 , where a protocol specification @xmath26 only has to hold as long as the assumption that at all times @xmath27 is satisfied .",
    "a straightforward extension to take time into account would be to consider each ( re)transmission to take up some amount of time @xmath28 .",
    "we can then include another assumptions of the form @xmath29 , where @xmath30 is an upper bound on the transmission time .",
    "in this section the concepts described above are formalized .      in a protocol specification , the protocol is viewed as a single component interacting with the ascs , cf .",
    "[ fig : protocol](a ) . only the interaction across the interface between ascs and csas is specified .",
    "the csas , representing an implementation of a protocol , then interface with the lower level transmission medium in order to provide the required services to the higher level . in this way ,",
    "the ascs never come in direct contact with the transmission medium .",
    "as introduced above , a specification of the protocol is given as a temporal ( partial ) order of global events .",
    "a global event is any event involving the interaction of several cars , such as a message transmission ( involving both the sender and the receiver ) .",
    "hence , a protocol specification can be seen as an allowed set of sequences of global events .",
    "moreover , each sequence is tagged with a qos requirement , which , in our case simply is the required probability of the sequence to be synchronized correctly . in order to avoid having to write a list of sequences with potentially many global events repeating",
    ", we use the following temporal logic - like language to define _ _ protocol specifications : @xmath31 where @xmath32 is a global event @xmath33 together with a probability @xmath34 indicating the required qos . extensions of this specification language can also include time , bandwidth or other qos requirements in the same way in the specification . a _ _",
    "specification is a protocol specification together with an environment assumption , in our case an upper bound @xmath22 on the drop probability @xmath21",
    ".    continued the protocol described in the intersection example of fig .",
    "[ fig : intersection ] can be specified as @xmath35 which can be illustrated as a tree as in fig .",
    "[ fig : protspec ] . in the numerical results",
    "presented later for this example we will use different values for @xmath36 and @xmath37 .",
    "the results of the synthesis also depend on the drop probability bound @xmath22 . a complete specification that includes the assumptions on the transmission medium dynamics",
    "would be @xmath38    since we are interested in qos requirements over the drop probability of the transmission medium , a probability @xmath34 on @xmath32 labels each leaf of the tree representing a protocol specification , specifying the desired probability of the ( unique ) sequence of global events @xmath39 occurring that leads to the leaf .",
    "we call a sequence @xmath39 with a probability @xmath34 attached to it a",
    "_ _ @xmath34-sequence and write @xmath40 . the semantics of the protocol specification language is defined by a satisfaction relation : if a @xmath34-sequence @xmath39 of global events satisfies the protocol specification @xmath26 , this is written as @xmath41 .",
    "we first develop an intuitive understanding of a sequence @xmath42 satisfying a specification @xmath26 . recall that a protocol specification only takes the interfaces between csas and ascs into account , and hence views the protocol implementation as a monolithic entity as in fig .",
    "[ fig : protocol](a ) .",
    "each global event @xmath43 in the sequence @xmath39 is interpreted as the synchronization of an environment - triggered event @xmath44 and a system - triggered event @xmath45 .",
    "the asc on car @xmath46 triggers @xmath44 by a call to its csa .",
    "the intention is that the corresponding system - triggered event @xmath45 is synchronized with that event in the csa on car @xmath47 ( and an upcall is made to its asc ) .",
    "the synchronization is correct if after an environment - triggered event @xmath44 , the first system - triggered event is @xmath45 , i.e.  no other system - triggered event is interleaved between them .",
    "note that environment - triggered events that do not correspond to global events in the specification may be interleaved , as the protocol has no control over the higher level .",
    "then , the statement @xmath41 expresses that @xmath39 satisfies the partial order defined in @xmath26 and has a high enough probability @xmath34 attached to it .",
    "we now formally define @xmath48 recursively on the structure of a protocol specification @xmath26 ( cf .  ):",
    "@xmath49 where adding a global event @xmath50 to the head of a sequence @xmath39 is written as @xmath51 . under these semantics a protocol specification is satisfied exactly by those sequences of global events that both obey the partial order induced by @xmath52 and that have a sufficiently high probability attached to them .",
    "@xmath53[f- ] { } \\ar[d]^{{\\mathrm{snd}}_{x \\rightarrow y}(d ) } \\\\ & * + + [ o][f- ] { } \\ar[dl]_(0.7){{\\mathrm{ack}}_{y \\rightarrow x } } \\ar[dr]^(0.7){{\\mathrm{nack}}_{y \\rightarrow x } } \\\\ * + [ o][f-]{p_1 } & & * + [ o][f-]{p_2}}\\ ] ]      we are interested in finding a way to implement a protocol in a distributed manner by finding csas for the cars so that their joint execution satisfies the protocol specification .",
    "that is , the implementation of the protocol must use the transmission medium in order to guarantee the required services to the higher level , see fig .",
    "[ fig : protocol](b ) .",
    "a set @xmath54 of csas satisfies a protocol specification if it produces only the allowed sequences of global events , and these with a sufficiently high probability . in this section",
    "we make precise the concept of a csa and define its semantics in the next section .",
    "a csa is a finite state machine with labelled transitions , which is similar to a protocol entity specification used by ishida et al .",
    "transition labels either indicate which actions should be executed when the transition is taken , or impose conditions on a transition . a transition for which all conditions are satisfied is called _ _ enabled .",
    "the labels that are available to the synthesis method are explained below , and transitions are typically labelled with combinations of labels .",
    "firstly , interaction with the higher - level ascs is encoded by edges labelled with environment - triggered and system - triggered events .",
    "we also introduce two special system - triggered events `` @xmath55 '' and `` @xmath56 '' to @xmath13 that have no corresponding environment - triggered events to be synchronized with .",
    "the purpose of these events is merely to inform the asc of the outcome of a transmission .",
    "a @xmath55 event indicates that allowable retransmission count is exceeded , while the @xmath56 event indicates a successful transmission to the asc triggering the last global event .    secondly , to interact with the transmission medium",
    ", transitions can be labelled with message transmissions and receptions .",
    "each message has a unique identifier @xmath57 .",
    "a broadcast message is written as @xmath58 , where @xmath46 and @xmath47 are the source and destination respectively , and @xmath59 is the data transmitted .",
    "it is read as `` send @xmath57 with data @xmath5 to @xmath47 from source @xmath46 . '' similarly , a reception is written as @xmath60 , where @xmath46 , @xmath47 and @xmath5 have the same interpretation as for a broadcast message .",
    "it is read as `` receive @xmath57 with data @xmath5 from @xmath46 destined for @xmath47 . '' again , if @xmath61 , the parameter is not written .",
    "define @xmath62 and @xmath63 to be the set of broadcasts and receptions respectively .",
    "lastly , we introduce labels for internal actions of a csa . in order to satisfy the qos requirements of the protocol specification",
    ", it may be necessary to allow the retransmission of messages .",
    "to this end , we define a set of _ _ variables @xmath64 over @xmath65 that act as _ _ retransmission counters .",
    "we will construct the csas in such a way that for each message @xmath57 that might be retransmitted , after a transmission @xmath58 , either a reception of some other message is expected or a _ _ timeout `` @xmath66 '' may occur . on the timeout ,",
    "the retransmission counter @xmath67 of the message is increased by one .",
    "if @xmath67 exceeds its _ _ retransmission bound @xmath68 , the transmission fails , causing a @xmath55 event and a corresponding upcall informing the asc .",
    "we write an _ _ update of a variable @xmath69 as @xmath70 , and denote the set of updates by @xmath71 . further",
    ", a transition may be labelled by a",
    "_ _ condition on a retransmission counter , which can be either of the form @xmath72 or @xmath73 .",
    "the set of conditions is defined as @xmath74    when synthesizing a csa from a protocol specification , each transition can be of one of seven kinds , depending on the labels : a environment - triggered event , a conditional system - triggered event , a timeout with a system - triggered event , a timeout with update , a conditional broadcast , a reception with a system - triggered event or a reception with update .",
    "hence , the set of labels is @xmath75 for the respective cases .",
    "the set of such transition labels is denoted by @xmath76 .",
    "a csa @xmath77 is a quintuple @xmath78 where @xmath79 is a set of _ _ states labelled by valuations of variables @xmath64 , @xmath80 is the _ _ initial state , @xmath81 is the set of _ _ final states , and @xmath82 is the ( partial )",
    "_ _ transition function",
    ".    continued the pair of csas shown in fig .",
    "[ fig : services ] represents one potential implementation of the protocol specification in .",
    "the transmissions and receptions are introduced in order to ensure that the qos requirements as defined in the specification is preserved by the csas that can only communicate over the transmission medium .",
    "for example , the sender @xmath83 may retransmit the message @xmath84 up to @xmath85 times in case of repeated timeouts to increase the likelihood of a successful transmission , in order to meet the specification .      in the semantics of a csa ,",
    "we want to reflect that a car should be able to execute it as a controller for its wireless transceiver .",
    "decisions when to make transitions should be based only on information available locally .",
    "for example , a transition labelled by a reception @xmath86 is taken only when a message @xmath57 arrives that has @xmath46 as its destination and @xmath47 as its source .",
    "since a csa is executed locally on a car , we first define the _ _ local semantics of a single csa .",
    "this describes how a csa operates in isolation when receiving calls from the asc on the same car , and messages from the transmission medium , cf .",
    "[ fig : protocol](b ) .",
    "we then define the _ _ global semantics of several csas that operate together , which requires to take the transmission medium dynamics into account , cf .",
    "[ sec : qos ] .",
    "hence , the global semantics can be interpreted as defining the behavior of the protocol in fig .  [",
    "fig : protocol](a ) .",
    "an example of how the semantics are used is presented in sec .  [",
    "sec : pdeduction ] .",
    "for ease of presentation , the semantics are defined as a set of _ _ deduction rules .",
    "a deduction rule is of the form @xmath87 which is the same as @xmath88 , i.e.  the _ _ conclusion @xmath89 follows from the _ _",
    "hypotheses @xmath90 .",
    "a deduction rule can be applied if all its hypotheses hold .",
    "rules can either be applied forward , starting from one or several axioms , or backwards , starting from a conclusion .",
    "forward application corresponds to simulation , while backwards application corresponds to verification .",
    "we first introduce some notation to make the statement of the rules more compact .",
    "retransmission uses conditional transitions and updating of variables . the value @xmath91 of a variable @xmath69 in a state @xmath92 is written @xmath93 . in the initial state @xmath94",
    "all variables valuate to zero .",
    "a condition @xmath95 is satisfied in state @xmath92 , written @xmath96 , if and only if @xmath97 . two states @xmath92 and @xmath98 are equivalent on their values of the variables in @xmath99 , written @xmath100 , if and only if @xmath101 .",
    "we write @xmath102 if and only if @xmath103 and @xmath100 , where @xmath104 may stand for any transition label . furthermore",
    ", we use the @xmath105 operator to append an element to the end of a sequence .",
    "@xmath106 } & \\frac { \\begin{array}{c } t(s , { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' \\end{array } } { \\begin{array}{c } \\langle \\rho , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[sys - c ] } & \\frac { \\begin{array}{cc } t(s , ( { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } , { \\gamma } ) ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' & { \\gamma}(s ) \\end{array } } { \\begin{array}{c } \\langle \\rho , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[to - sys ] } & \\frac { \\begin{array}{c } t(s , ( { \\mathrm{t.o . } } , { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } ) ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' \\end{array } } { \\begin{array}{c } \\langle \\rho , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{t}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + { \\mathrm{t.o.}}+ { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[to - upd ] } & \\frac { \\begin{array}{cc } t(s , ( { \\mathrm{t.o . } } , \\nu\\!+\\!+ ) ) { \\overset{{\\mathcal{v}}\\backslash \\{\\nu\\}}{\\approx } } s ' & s'(\\nu ) = s(\\nu ) + 1 \\end{array } } { \\begin{array}{c } \\langle \\rho , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{t}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + { \\mathrm{t.o . } } , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[b - c ] } & \\frac { \\begin{array}{cc } t(s , ( ! ! m_{y \\rightarrow z}(d ) , { \\gamma } ) ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' & { \\gamma}(s ) \\end{array } } { \\begin{array}{c } \\langle \\rho , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + ! !",
    "m_{y \\rightarrow z}(d ) , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[r - sys ] } & \\frac { \\begin{array}{cc } t(s , ( \\varsigma , { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } ) ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' & \\varsigma = ?",
    "m_{y \\leftarrow z}(d ) \\end{array } } { \\begin{array}{c } \\langle \\rho + \\varsigma , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{r}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + \\varsigma + { { \\underline{{\\epsilon}}}_{{y } \\leftarrow { z}}(d ) } , s ' \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[r - upd ] } & \\frac { \\begin{array}{cc } t(s , ( ?",
    "m_{y \\leftarrow z}(d ) , \\nu\\!+\\!+ ) ) { \\overset{{\\mathcal{v}}\\backslash \\{\\nu\\}}{\\approx } } s ' & s'(\\nu ) = s(\\nu ) + 1 \\end{array } } { \\begin{array}{c } \\langle \\rho + ?",
    "m_{y \\leftarrow z}(d ) , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{r}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + ?",
    "m_{y \\leftarrow z}(d ) , s ' \\rangle \\end{array } }    \\end{array}\\ ] ]    the local semantics is defined by a relation @xmath107 between sequences of transition labels and csa states .",
    "the statement @xmath108 means that @xmath77 at state @xmath92 transforms @xmath109 into @xmath110 by making a single transition to state @xmath98 .",
    "it holds if and only if it is deducible via the rules given in table  [ tab : singlecsarules ] . to make the statement of the global semantics simpler",
    ", we may label the relation by a superscript to distinguish which rules are applied .",
    "for example , @xmath111 indicates that either the rule [ env ] , [ sys - c ] or [ b - c ] are applied .",
    "if the superscript is omitted , any rule may be applied .",
    "we explain the [ env ] rule for csa @xmath112 in detail , the other rules are similar .",
    "the hypothesis @xmath113 expresses that @xmath112 must allow a transition from @xmath92 that is labelled with the environment - triggered event @xmath114 and leads to a state @xmath98 in which the values of all variables in @xmath64 are the same as in @xmath92 ( i.e.  there is no update ) . if this hypothesis is satisfied , @xmath112 at state @xmath92 transforms @xmath109 into @xmath110 by making a transition to state @xmath98 .",
    "the [ env ] rule can be applied at any point if a transition labelled by an environment - triggered event is enabled .",
    "it is not dependent on an input from the higher level asc .",
    "stating the rule this way is sufficient for our presentation , but it can be substituted by @xmath115 } & \\frac { \\begin{array}{c } t(s , { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } ) { \\overset{{\\mathcal{v}}}{\\approx } } s ' \\end{array } } { \\begin{array}{c } \\langle \\rho + { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } , s \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho + { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } , s ' \\rangle \\end{array } } \\end{array}\\ ] ] to explicitly require an input to be able to apply the rule . the input is the last element in the sequence , which is an environment - triggered event @xmath114 , indicating that the asc must have made the corresponding call .",
    "this input may be placed in the sequence ( i.e.  added as last element ) by the global semantics , similar to the inputs for the [ r - sys ] and [ r - upd ] rules .",
    "the [ sys - c ] rule places no restriction on the input and contains as an additional hypothesis that the condition @xmath116 must be satisfied in state @xmath92 .",
    "the system - triggered event @xmath117 gives rise to an upcall .",
    "such outputs can be read off the last element of the deduced sequence and hence are not modelled explicitly in these rules .",
    "the [ to - sys ] rule can be applied for a transition labelled with a timeout @xmath66 and a system - triggered event @xmath117 . in the [ to - upd ]",
    "rule the value of the variable @xmath69 is incremented by one as the transition is taken .",
    "hence we use the operator @xmath118 , since @xmath119 would indicate that all variables in @xmath64 retain their values as the transition is taken .",
    "the [ b - c ] rule can be applied for a conditional broadcast message",
    ". the outgoing message again can be obtained from the last element of the deduced sequence .",
    "rules [ r - sys ] and [ r - upd ] require the reception @xmath120 to occur , hence the rules require the corresponding input .",
    "each csa may deduce a set of sequences of events by transitioning between its states .",
    "decisions between environment - triggered events , receptions and timeouts are made by inputs ( or the absence thereof ) received either from the higher level asc or the lower level transmission medium .",
    "these inputs can only be generated by the global semantics .",
    "we define the global semantics by modelling how the transmission medium operates .",
    "that is , we define the behavior of the protocol in fig .",
    "[ fig : protocol](a ) by composing the behavior of the csas in fig .",
    "[ fig : protocol](b ) and abstracting away all lower level detail .",
    "the global semantics defines when inputs to a csa are received from the transmission medium , and restricts the valid interleavings of locally generated sequences .",
    "the medium therefore also acts as an arbiter or scheduler of transitions .    in the global semantics , we are interested in ensuring that several csas together satisfy the global protocol specification by interacting with each other .",
    "we therefore define the semantics of a list of csas @xmath121 that is executed together on the respective set of cars @xmath122 .",
    "each execution starts with all csas in @xmath54 being in their initial state @xmath123 and making only transitions allowed by the semantics . only a single sequence @xmath124 is deduced , which is an interleaving of the sequences deduced locally .",
    "the deduction rules also express that the medium transmits messages only with a given probability .",
    "hence , the deduced sequence @xmath109 is tagged with a probability @xmath34 , indicating how likely it occurs .",
    "not only do the global semantics define how messages are transmitted , also the valid interleavings of locally deduced sequences are restricted . to motivate this , consider in fig .",
    "[ fig : services ] the execution of the environment - triggered event @xmath125 . since time is abstracted away , the transition may be delayed by an arbitrary amount of time . however , then the retransmission loop in the sender @xmath1 can not reliably increase the likelihood of a successful execution , since the timeout transition can also be taken at any time . in order to prevent this from happening ,",
    "the global semantics ensure that transitions that are not timeouts or receptions are taken immediately if enabled .",
    "hence , only one csa is allowed to make transitions until a timeout or reception is encountered .",
    "then any csa may make a transition .",
    "this is incorporated in the global semantics by always prioritizing one csa is to make a transition .",
    "if this csa has no transition enabled , any other csa may make a transition .",
    "@xmath126 } & \\frac { \\begin{array}{c } \\langle \\rho + ?",
    "m_{z \\leftarrow y}(d ) , s_z \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{r}}\\hspace{0.3cm}}_{m_{z } } } \\langle \\rho ' , s_z ' \\rangle \\\\ \\varsigma = ! !",
    "m_{y \\rightarrow z}(d ) \\end{array } } { \\begin{array}{c } \\langle ( \\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho')^{(1-{\\delta})p } , s[z \\leftarrow s_z ' ] , z \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[drop ] } & \\frac { \\begin{array}{c } \\langle \\rho + ? m_{z \\leftarrow y}(d ) , s_z\\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{r}}\\hspace{0.3cm}}_{m_{z } } } \\langle \\rho ' , s_z ' \\rangle \\\\ \\varsigma = ! !",
    "m_{y \\rightarrow z}(d ) \\end{array } } { \\begin{array}{c } \\langle(\\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho)^{{\\delta}p } , s , z \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[nacc ] } & \\frac { \\begin{array}{c } \\neg(\\langle \\rho + ? m_{z \\leftarrow y}(d ) , s_z \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{r}}\\hspace{0.3cm}}_{m_{z } } } \\langle \\rho ' , s_z ' \\rangle ) \\\\ \\varsigma = ! !",
    "m_{y \\rightarrow z}(d ) \\hspace{1 cm } \\langle \\rho , s_x \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{m_{x } } } \\langle \\rho ' , s_x ' \\rangle \\end{array } } { \\begin{array}{c } \\langle ( \\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho)^p , s , z \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[pr - e ] } & \\frac { \\begin{array}{ccc } \\varsigma \\neq ! ! m_{y \\rightarrow z}(d ) & \\langle \\rho + \\varsigma , s_y \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho ' , s_y ' \\rangle \\end{array } } { \\begin{array}{c } \\langle ( \\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho')^p , s[y \\leftarrow s_y ' ] , y \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[pr - t ] } & \\frac { \\begin{array}{cl } \\varsigma \\neq ! !",
    "m_{y \\rightarrow z}(d ) & \\neg(\\langle \\rho + \\varsigma , s_y \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho '' , s_y '' \\rangle ) \\\\ &",
    "\\langle \\rho + \\varsigma , s_y \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{t}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho ' , s_y ' \\rangle \\end{array } } { \\begin{array}{c } \\langle ( \\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho')^p , s[y \\leftarrow s_y ' ] , y \\rangle \\end{array } } \\\\[{3.7ex } ]    \\text{[npr ] } & \\frac { \\begin{array}{cl } \\varsigma \\neq ! !",
    "m_{y \\rightarrow z}(d ) & \\neg(\\langle \\rho + \\varsigma , s_y \\rangle { \\xrightarrow{\\hspace{0.3cm}{\\mathrm{e , t}}\\hspace{0.3cm}}_{m_{y } } } \\langle \\rho '' , s_y ' \\rangle ) \\\\ & \\langle \\rho + \\varsigma , s_x \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{m_{x } } } \\langle \\rho ' , s_x ' \\rangle \\end{array } } { \\begin{array}{c } \\langle ( \\rho + \\varsigma)^p , s , y \\rangle { \\xrightarrow{\\hspace{0.3cm}{}\\hspace{0.3cm}}_{{\\mathcal{m}}({\\delta } ) } } \\langle ( \\rho')^p , s[x \\leftarrow s_x ' ] , x \\rangle \\end{array } }           \\end{array}\\ ] ]    in the global semantics , we are interested in ensuring that several csas together satisfy the global protocol specification by interacting with each other .",
    "the transmission medium therefore acts as an arbiter or scheduler of transitions .",
    "hence , we can think of the global behavior of several csas @xmath127 as an interleaving @xmath109 of the locally generated sequences @xmath128 of the respective csas .",
    "messages are only transmitted with a certain probability .",
    "hence , the sequence @xmath109 is tagged with a probability @xmath34 , indicating how likely it occurs .",
    "the relation @xmath129 defines the global semantics according to the rules in table  [ tab : compositionrules ] .",
    "it means that @xmath54 with drop probability @xmath22 at state @xmath92 transforms @xmath109 into @xmath110 by making a transition to state @xmath98 while the priority changes from @xmath130 to @xmath131 . in the statement of the rules , updating the @xmath132 element @xmath133 in state @xmath134 with @xmath135 is written as @xmath136 $ ] .",
    "the [ trans ] , [ drop ] and [ nacc ] rules define the transmission medium dynamics . if the last deduced element in the sequence is a broadcast message , i.e.  @xmath137 , the medium tries to transmit .",
    "an application of the [ trans ] rule models a successful message transmission .",
    "this only occurs if the csa for which the message was destined , @xmath138 makes a transition labelled with the corresponding reception . that is , @xmath139 is only satisfied if @xmath138 can execute [ r - sys ] or [ r - upd ] . since",
    "a message transmission occurs with probability @xmath140 , the probability with which the sequence @xmath110 is tagged in the conclusion of [ trans ] is @xmath141 .",
    "an application of the [ drop ] rule models a dropped message .",
    "it has exactly the same hypotheses as [ trans ] , but its conclusion reflects that no progress has been made . the sequence @xmath109 is tagged with @xmath142 due to the message drop probability @xmath22 .",
    "note that the priority is at the source csa @xmath112 , which may now execute a timeout transition ( if enabled ) .",
    "the [ nacc ] rule is applied when a message should be transmitted , but the destination csa has no transition enabled that is labelled by the corresponding reception .",
    "similar to the [ drop ] rule , no progress is made .",
    "also , the probability of the deduced sequence is not affected .",
    "the [ pr - e ] , [ pr - t ] and [ npr ] rules may be applied if the last element of the sequence is not a message transmission .",
    "then the transmission medium is inactive , and and the csa that is currently prioritized may execute : if a transition that is not a timeout or reception is enabled , then [ pr - e ] is applied .",
    "if a timeout transition is enabled , then [ pr - t ] is applied .",
    "the [ npr ] rule may only applied if the currently prioritized csa has no such transitions enabled . in this case",
    ", any csa @xmath130 may execute .",
    "the transitive closure @xmath143 denotes that @xmath144 is transformed into @xmath145 in an arbitrary number of deduction steps .",
    "the csas @xmath54 execute by starting in state @xmath94 with an empty 1-sequence @xmath146 and any csa @xmath130 prioritized .",
    "valid deductions are the tuples @xmath147 for which @xmath148 .",
    "note that an example of how the local and global semantic rules are used is included in sec .",
    "[ sec : pdeduction ] .      by applying the deduction rules , sequences over",
    "both environment - triggered and system - triggered events , broadcasts , receptions and timeouts can be obtained from a set of csas . since protocol specifications are over global events , we need to extract the synchronizations of local events in the sequences generated by a set of csas .",
    "we therefore define the projection function @xmath149\\ ! ] } : \\sigma^ * \\rightarrow { \\mathcal{e}_g}^*$ ] to find a sequence over global events from @xmath109 .",
    "it is defined by @xmath150\\ ! ] } & \\triangleq \\bullet\\\\ { [ \\![{\\rho + r}]\\ ! ] } & \\triangleq \\begin{cases }      { [ \\![{\\rho}]\\ ! ] } + { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } & \\text{if}~r = { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } \\\\      { [ \\![{\\rho'}]\\ ! ] } + { { { \\epsilon}}_{{y } \\rightarrow { z}}(d)}&\\text{if}~{[\\![{\\rho}]\\ ! ] }",
    "= { [ \\![{\\rho'}]\\ ! ] } + { { \\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d)}\\\\      & \\hspace{0.5cm}\\text{and}~r = { { \\underline{{\\epsilon}}}_{{z } \\leftarrow { y}}(d)}\\\\      { [ \\![{\\rho}]\\ ! ] } & \\text{otherwise}. \\end{cases}\\end{aligned}\\ ] ] we use the projection function @xmath149\\!]}$ ] to express whether a set of csas satisfies a protocol specification @xmath26 under the environment assumptions @xmath23 .      in this section we define correctness of a protocol s implementation in form of a set of csas @xmath54 with respect to a specification @xmath25 .",
    "if @xmath54 satisfies this specification this is written as @xmath151 .",
    "correctness depends on the probability of sequences @xmath39 being synchronized correctly by the csas @xmath54 if the transmission medium s drop probability @xmath21 is bounded from above by @xmath22 , i.e.  it satisfies @xmath23 .",
    "if this assumption on the transmission medium is not satisfied , the specification @xmath25 is trivially satisfied by any set of csas .",
    "however , this case is useless in practice , as the protocol will not deliver the data with the required qos .      given a protocol specification @xmath26 , correctness of an implementation depends on whether all csas involved in synchronizing a sequence of global events are in a final state .",
    "we therefore define the set of _ _ globally final states @xmath152 to include all tuples of states @xmath153 so that if there is some sequence involving csas @xmath154 , the states @xmath155 are actually final states from @xmath156 .",
    "we say that a @xmath34-sequence @xmath157 is _ _ generated by a set of csas @xmath54 and drop probability @xmath22 , and write @xmath158 , if it can be deduced by the rules in table  [ tab : singlecsarules ] and table  [ tab : compositionrules ] and the deduction ends in a globally final state @xmath159 .",
    "formally , @xmath160 as noted above in sec .",
    "[ sec : protocol ] , a @xmath34-sequence @xmath40 satisfies a specification @xmath26 exactly if the probability @xmath34 that all ( global ) events in @xmath39 are correctly synchronized is high enough given that the corresponding environment - triggered events are all triggered through calls by the higher level ascs . for a set of csas therefore to satisfy a specification ,",
    "it is required that the synchronization of events in each sequence is performed with high enough probability .",
    "the important criterion for correctness is not whether a sequence @xmath109 is generated , but whether the qos requirements are satisfied .",
    "this is because the decisions between environment - triggered events ( which essentially generate the sequence ) are made by the higher level ascs , over which a csa has no control .",
    "for example , in fig .",
    "[ fig : services ] , the receiver csa has no control over whether @xmath125 or @xmath161 is triggered by its asc in state @xmath162 . in our case",
    "the only qos requirement is the probability of all global events being correctly synchronized , so the question for correctness becomes : given that the ascs trigger the events necessary to generate @xmath39 , how likely is it that all synchronizations performed ?",
    "@xmath54 might generate a given sequence @xmath39 in many different ways , since several sequences @xmath109 deducible by the rules in table  [ tab : singlecsarules ] might satisfy @xmath163\\ ! ] } = \\sigma$ ] . for a sequence @xmath39",
    ", we evaluate the sum of all probabilities @xmath34 for distinct sequences @xmath109 that satisfy @xmath164\\ ! ] } = \\sigma \\wedge ( \\rho)^p { \\models { { \\mathcal{m}}({\\delta})}}),\\ ] ] and get the probability @xmath165 expressing the likelihood of the events in the sequence @xmath39 being correctly synchronized when executing all csas in @xmath54 in parallel ( i.e. using the global semantics ) . _",
    "_ correctness then is expressed by @xmath166 i.e.  if @xmath39 is a sequence allowed by the specification @xmath26 , @xmath54 synchronizes the events @xmath39 at least as likely as it is required .",
    "+ the algorithmically challenging part in establishing correctness is to evaluate @xmath167 .",
    "however , we only need to compute this for the csas that we are synthesizing .",
    "the protocol synthesis method @xmath168 translates a specification into a set of csas that is guaranteed to satisfy the specification .",
    "the inputs to the synthesis are a protocol specification @xmath26 , a set of cars @xmath169 and the specification on the transmission medium dynamics @xmath23 .",
    "@xmath170 produces a csa for each car @xmath171 that interacts with the higher level ascs as outlined in sec .",
    "[ sec : preliminaries ] .",
    "synthesis is preceded by a realizability check , i.e.  checking whether a specification _ can _ be implemented . that is , checking realizability amounts to deciding whether there exists a set of csas that satisfies the specification @xmath172 . if a protocol specification @xmath26 is realizable for a set of cars",
    "@xmath169 under a drop probability @xmath22 , this is written as @xmath173 .",
    "checking realizability consists of two parts : firstly , the specification itself must be well - posed , i.e.  @xmath26 must admit a `` reasonable '' implementation in the form of csas .",
    "secondly , it must be possible to find retransmission bounds so that the qos requirements are satisfied under the given drop probability @xmath22 .",
    "well - posedness is a purely syntactic requirement on the specification .",
    "we introduce this concept because it is easy to check and simplifies the presentation of the synthesis algorithm .",
    "a protocol specification @xmath26 is _ _ well posed if on every @xmath34-sequence satisfying @xmath26 , two ascs take turns in triggering the events , and there are at least two events on each path through the tree induced by the specification .",
    "these rather strict requirements on the specifications for well - posedness can be relaxed by generalizing the synthesis method presented in the next section appropriately .",
    "for example , a straightforward relaxation would be to allow protocol specifications in which for any disjunction @xmath174 , the system - triggered events corresponding to the immediately following global events are all triggered by the same asc .",
    "we do not develop a separate test for realizability but rather show how our method fails for well - posed but nonrealizable specifications .",
    "the synthesis method is implemented in two parts : first , the retransmission bounds are calculated .",
    "then the csas are constructed using the retransmission bounds .",
    "the retransmission bounds are calculated with the structure of the resulting csas in mind , so we present the csa construction first .    for any specification @xmath25 and any set of cars @xmath169 , if the specification is realizable , the resulting set @xmath54 of csas from the synthesis , @xmath170 must satisfy @xmath172 .",
    "formally , @xmath175 .",
    "{ \\mathfrak{r}}({\\varphi } , { \\mathfrak{c } } , { \\delta } ) \\rightarrow ( { \\mathfrak{s}}({\\varphi } , { \\mathfrak{c } } , { \\delta } ) \\vdash \\operatorname{\\mathop\\square}({\\delta}\\leq { \\delta } ) \\rightarrow { \\varphi}).\\ ] ] the synthesis method @xmath168 is implemented in two parts : first , the retransmission bounds are calculated .",
    "then the csas are constructed using the retransmission bounds .",
    "the retransmission bounds are calculated with the structure of the resulting csas in mind , so we present the csa construction first .",
    "table  [ tab : synthesis ] shows the algorithm @xmath176 .",
    "this algorithm constructs the csa @xmath130 for car @xmath46 from the specification @xmath26 .",
    "the parameter @xmath177 is used to uniquely index states in the csa , and @xmath178 is a set of global events that is used to construct appropriate criteria for retransmission ( explained below ) .",
    "@xmath179 is the list of retransmission bounds calculated in the first step ( cf .",
    "[ sec : retransmission ] ) .",
    "each global event @xmath180 that occurs in the protocol specification @xmath26 is assigned an environment - triggered event @xmath44 , a system - triggered event @xmath45 , a message @xmath181 , a variable ( as retransmission counter ) @xmath182 , a retransmission bound @xmath183 from @xmath179 , and system - triggered events @xmath184 and @xmath185 .",
    "the algorithm is invoked by @xmath186 , for each car @xmath171 : does not need to occur in the protocol specification @xmath26 . ]",
    "it synthesises a csa for the well - posed protocol specification @xmath26 for car @xmath46 , where states are indexed starting from @xmath187 , no previous events are stored ( @xmath188 ) and the retransmission bounds @xmath179 are used .    recursively decomposes @xmath26 into its subparts . if @xmath189 , then two csas @xmath190 and @xmath191 are constructed from @xmath192 and @xmath193 first and joined together by forming the union of their state spaces , final states and transitions and substituting the initial state @xmath194 by the initial state @xmath195 . for this purpose",
    "we define @xmath196 $ ] to be the csa @xmath77 with all occurrences of @xmath162 substituted by @xmath197 .    if @xmath198 , the set @xmath178 of global events that has last been received on the path through the csa is updated first .",
    "then again the csa @xmath77 for @xmath199 is constructed .",
    "depending on which car @xmath46 the csa is constructed for , different transitions are now introduced .",
    "if @xmath200 then the asc on car @xmath46 is responsible for triggering the event @xmath114 , and a retransmission loop is introduced :    ( i )    @xmath201[f=]{s_i } \\ar[r]^{{{\\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } }       & * + [ o][f-]{s_{i+1 } } \\ar[r]_{{{\\underline{\\mathrm{fail}}}}_{{\\epsilon}}}^{\\nu_{{\\epsilon } } > n_{{\\epsilon } } } \\ar@/_/[d]_(.6){!!a_{{\\epsilon } , y \\rightarrow z}(d)}_(.45){\\nu_{{\\epsilon } } \\leq n_{{\\epsilon } } } & * + [ o][f-]{s^{init}_{m}}\\\\         & * + [ o][f-]{s_{i+2 } } \\ar@/_/[u]_(.4){{\\mathrm{t.o.}}_{{\\epsilon}}}_(.55){\\nu_{{\\epsilon}}+\\!+ } & } \\ ] ]    if @xmath202 , then car @xmath46 synchronizes @xmath3 by the system - triggered event @xmath203 :    ( ii )    @xmath204[f-]{s_i } \\ar[r]^{{{\\underline{{\\epsilon}}}_{{z } \\leftarrow { y}}(d ) } } & * + [ o][f-]{s^{init}_m } } \\label{eq:2}\\ ] ]    in any other case , simply the csa for @xmath199 is returned as then the car @xmath46 is not directly involved in the transmission .",
    "finally , if @xmath205 then no recursive call to is necessary , but a csa is directly constructed . if @xmath200 then a retransmission loop is constructed :    ( iii )    @xmath201[f-]{s_i } \\ar[r]^{{{\\underline{{\\epsilon}}}_{{y } \\rightarrow { z}}(d ) } }       & * + [ o][f-]{s_{i+1 } } \\ar[r]_{{{\\underline{\\mathrm{fail}}}}_{{\\epsilon}}}^{\\nu_{{\\epsilon } } > n_{{\\epsilon } } } \\ar@/_/[d]_(.6){!!m_{{\\epsilon } , y \\rightarrow z}(d)}_(.45){\\nu_{{\\epsilon } } \\leq n_{{\\epsilon } } } & * + [ o][f-]{s_{i+3}}\\\\         & * + [ o][f-]{s_{i+2 } } \\ar@/_/[u]_(.4){?\\mu_{y \\leftarrow z}(d)}_(.55){\\nu_{{\\epsilon}}+\\!+ } \\ar[r]^{{\\mathrm{t.o.}}_3}=\"?b\"_{{{\\underline{\\mathrm{success}}}}_3}=\"success3 \" & * + [ o][f.]{s_{i+4 } } } \\label{eq:3}\\ ] ]    @xmath168    in this case , a retransmission is not triggered by a timeout , because @xmath206 is the last global event in a sequence of required synchronizations and no feedback from the car @xmath207 can be expected . therefore , a retransmission is initiated by receiving the last message @xmath208 from car @xmath207 again , because this indicates that @xmath207 has not received the message @xmath209 correctly . the message @xmath208 is taken from @xmath178 , the set of global events that has last been received on the path through the csa .",
    "only if no such message is received is a timeout transition made , which indicates success by an upcall to the asc .",
    "the global semantics of csas were carefully constructed so that this timeout is only taken if no message @xmath208 is received .    if @xmath202 , then car @xmath46 synchronizes @xmath3 by the system - triggered event @xmath203 :    ( iv )    @xmath204[f-]{s_i } \\ar[r]^{{{\\underline{{\\epsilon}}}_{{z } \\leftarrow { y}}(d ) } } & * + [ o][f.]{s_{i+1 } } } \\label{eq:4}\\ ] ]    in any other case a trivial csa with one state is returned",
    ".    continued the resulting csas from synthesizing the specification in are shown in fig .",
    "[ fig : services ] .",
    "the csas were generated by calling @xmath186 for @xmath210 .",
    "the retransmission bounds @xmath179 are calculated as explained in the next section according to the qos requirements and to the bound on the drop probability @xmath22 .    .pseudocode of synthesis algorithm .",
    "the csa is constructed from the diagrams explained in the text and referred to by roman numerals .",
    "[ cols= \" < \" , ]      each global event @xmath211 gets assigned a unique message @xmath181 and a unique retransmission bound @xmath212 .",
    "the retransmission bounds are evaluated according to the qos requirements defined in the protocol specification @xmath26 .",
    "recall that the protocol specification @xmath26 induces a tree , cf .",
    "[ fig : protspec ] .",
    "each edge of this tree is translated by the synthesis into a retransmission loop in the csa of exactly one car , with a retransmission bound associated with that loop .",
    "the retransmission bounds have to be selected so that correctness as defined in sec .",
    "[ sec : correctness ] is guaranteed .",
    "we use the semantics to find the conditions on the retransmission bounds that are sufficient for correctness .",
    "we can exploit the tree - like structure of the synthesized csas : apart from the last two retransmission loops in each sequence , the message associated with a retransmission loop is never used at a later point in the same sequence .",
    "each sequence of global events @xmath213 is associated with a sequence of retransmission bounds @xmath214 .",
    "depending on the values of the retransmission bounds , the sequence @xmath39 is generated correctly with a certain _ _ synchronization probability @xmath215 that depends on all retransmission bounds associated with any event in @xmath39 .",
    "note that this probability is the likelihood of @xmath39 being generated correctly _ given _ that the calls are made by the ascs that generate @xmath39 .",
    "the synchronization probability @xmath215 is evaluated as follows : the case of only one retransmission bound ( @xmath216 ) never occurs .",
    "the case of exactly two retransmission bounds ( @xmath217 ) means that the last retransmission loop uses the message transmitted in the retransmission loop one before last , cf .",
    "[ fig : services ] .",
    "the example in this figure can be used to deduce the general expression for @xmath218 .",
    "this is because the synthesis will always generate the same pattern for the last two global events in a specification .",
    "we use the sequence @xmath219 to deduce @xmath218 by evaluating the probability of correct synchronization by applying the deduction rules in table  [ tab : singlecsarules ] and table  [ tab : compositionrules ] .",
    "the csas @xmath220 start in the initial state @xmath221 .",
    "we omit writing the values of the retransmission counters within the states in our presentation .",
    "we let @xmath222 , where @xmath223 are an auxiliary functions describing the probability of reaching a globally final state from @xmath224 when the calls in @xmath39 are made .",
    "initially only @xmath83 can execute by applying the [ env ] rule locally .",
    "hence , we start the deduction at @xmath225 .",
    "we find @xmath226 by applying the global rules to deduce all sequences for which @xmath54 ends in a globally final state and the calls in @xmath39 are made .",
    "first , apply [ pr - e ] globally and [ env ] locally and deduce @xmath227 globally from @xmath228 locally .",
    "this deduction step yields @xmath229 , as the probability is not changed from state @xmath221 to @xmath230 . from now on we omit the left hand side of the relation @xmath231 , since it is equivalent to the right hand side of the previous deduction .",
    "we further omit writing the local deductions .    at @xmath230 ,",
    "globally only the [ pr - e ] rule can be applied .",
    "locally , either [ sys - c ] or [ b - c ] can be applied , depending on the value of the retransmission counter @xmath232 .",
    "applying [ sys - c ] corresponds to taking the transition labelled by @xmath233 .",
    "since then no final state can ever be reached , we only apply the [ b - c ] rule locally .",
    "so we apply locally the [ b - c ] rule : @xmath234 this transition leads to @xmath235 . at this point",
    "the transmission medium is invoked and globally both the [ trans ] and [ drop ] rules can be applied .",
    "if [ trans ] is applied , @xmath236 receives the message and we apply the [ r - sys ] rule locally .",
    "if [ drop ] is applied , merely the probability and prioritization changes .",
    "hence , we can deduce either @xmath237 where @xmath238 . since",
    "two transitions may be taken , we get @xmath239 . after the application of [ drop ] ,",
    "@xmath236 is prioritized but can not make a transition . in state @xmath240 , globally only [ npr ] can be applied , with @xmath83 making a timeout transition using [ to - upd ] locally : @xmath241 since the application of [ to - upd ] increases the retransmission counter @xmath232 by one , we get @xmath242 and the base case @xmath243 .",
    "this indicates that in state @xmath230 , the deduction may be repeated with the bound @xmath85 decreased by one , corresponding to a retransmission .",
    "if @xmath244 , i.e.  in the base case , no more retransmissions are possible .    in state @xmath245 after the transmission , @xmath236 makes a transition in response to a call from its asc . by applying [ env ] instead of [ env@xmath246 , we model that a is made immediately . applying [ pr - e ] globally and [ env ]",
    "locally yields : @xmath247 where @xmath248 . then only [ pr - e ] with [ b - c ] can be applied ( because again , applying [ sys - c ] does not conform with wanting to reach a final state ) .",
    "therefore we get @xmath249 where @xmath250 .",
    "this generates the equalities @xmath251 and @xmath252 .",
    "in @xmath253 we can apply either [ trans ] globally with [ r - sys ] locally on @xmath83 , modelling a successful transmission , or we apply [ drop ] globally , modelling a dropped message .",
    "hence we can either deduce @xmath254 where @xmath250 .",
    "we get @xmath255 . in state @xmath256",
    ", the sequence has been synchronized successfully . here",
    "only [ npr ] with [ to - sys ] on @xmath236 can be applied to yield @xmath257 where @xmath258 @xmath259 .",
    "this deduction ends in a globally final state and hence @xmath260 , because the sequence @xmath39 is correctly synchronized . in state @xmath253",
    "after the message has been dropped , only [ pr - t ] with [ to - upd ] locally on @xmath83 can be applied : @xmath261 where @xmath250 .",
    "this step yields @xmath262 with base case @xmath263",
    ". now @xmath83 retransmits ( if its retransmission count is not yet exceeded ) and we deduce with [ pr - e ] and [ b - c ] locally on @xmath83 : @xmath264 where @xmath265 .",
    "this yields @xmath266 .",
    "now [ trans ] can be applied with [ r - upd ] locally on @xmath236 . however , when applying [ drop ] , no final state can be reached by any sequence of applications of deduction rules .",
    "hence we only apply [ trans ] and [ r - upd ] and get @xmath267 where @xmath265 .",
    "this yields @xmath268 with base case @xmath269 .      for notational convenience",
    ", we drop the @xmath39 superscript if the context is clear and we are not referring to a particular sequence .",
    "when the sequence of global events @xmath39 has exactly two elements ( @xmath270 ) , we get    @xmath271},\\end{aligned}\\ ] ]    where @xmath272 is the _ _ reception probability and @xmath273 .",
    "when @xmath39 has more than two elements ( @xmath274 ) , the synchronization probability can be similarly deduced : @xmath275 where @xmath276 . ideally , we want to find the smallest retransmission bounds that ensure correctness .",
    "each @xmath34-sequence @xmath40 that satisfies the specification @xmath26 induces a condition on the retransmission bounds associated with the elements of @xmath39 .",
    "for example , a sequence @xmath277 induces the condition @xmath278 .",
    "this inequality ensures that the sequence @xmath39 is generated by the csas with high enough probability as required by the correctness criterion set out above .",
    "we can find the retransmission bounds by solving an optimization problem : @xmath279 where @xmath280 is the set of @xmath34-sequences @xmath39 that satisfy the protocol specification @xmath26",
    ".    continued checking realizability of a specification amounts to checking well - posedness of the specification and feasibility of the optimization problem .",
    "for our example specification , the optimization problem is @xmath281 in the case that @xmath282 , @xmath283 and @xmath284 , we get @xmath285 , @xmath286 , and @xmath287 .",
    "take any protocol specification @xmath26 , drop probability bound @xmath22 , and any @xmath34-sequence @xmath39 for which @xmath41 holds .",
    "then , correctness of the synthesis method is established by showing that @xmath288 , where @xmath54 is the result of synthesis .",
    "the definition of the feasible region of the optimization problem ( opt ) contains the inequality @xmath289 for each such sequence @xmath39 . by the semantics of protocol specifications @xmath290 for any sequence @xmath39 .",
    "it is therefore sufficient to show that @xmath291 and @xmath292 , because then @xmath288 , as required to establish correctness .",
    "first , if the retransmission bounds @xmath293 are part of a feasible solution to ( opt ) , then we necessarily have @xmath289 , and so @xmath291 follows from @xmath290 .",
    "second , we have @xmath294 by construction of @xmath295 ( note that the superscript @xmath39 has been dropped from @xmath296 ) : @xmath167 is the sum of all probabilities @xmath34 for which @xmath163\\ ! ] } = \\sigma \\wedge ( \\rho)^p { \\models { { \\mathcal{m}}({\\delta})}}$ ] , i.e.  the environment - triggered events and system - triggered events in @xmath109 synchronize to the sequence of global events @xmath39 and the @xmath34-sequence @xmath157 is generated by @xmath54 and drop probability @xmath22 . by definition ,",
    "it is therefore sufficient to show that in the deduction of the expression for @xmath298 exactly those @xmath34-sequences @xmath157 are taken into account that end in a globally final state @xmath159 ( the prioritization of @xmath46 and @xmath47 can safely be ignored ) and for which @xmath163\\ ! ] } = \\sigma$ ] .",
    "the deduction of @xmath298 in sec .",
    "[ sec : pdeduction ] is essentially done by constructing a product automaton of all csas in @xmath54 using the global semantics , and adding the probabilities along all paths that end in a globally final state corresponding to the sequence @xmath39 having been executed .",
    "note that it would have been enough to show @xmath299 .",
    "a synthesis method that generates csas with @xmath300 would be perfectly correct , but not very useful : the larger @xmath301 gets , the greater the feasible region of ( opt ) gets and the more specifications can be synthesized .",
    "so by having @xmath294 , we have maximized the capabilities of the synthesis method .",
    "the time required to generate a csa from a protocol specification @xmath26 by the algorithm is proportional to the number of global events and disjunctions ( @xmath302 ) in @xmath26 ( ignoring the set operations on @xmath178 ) , which can easily be seen from table  [ tab : synthesis ] , where the implementation of is shown as a simple structural recursion on @xmath26 . when also the set operations on @xmath178 are taken into account , the algorithm is quadratic in the number of global events in @xmath26 .",
    "the main computational complexity arises from the optimization problem opt , which is an integer program and in general is np - hard .",
    "there are however a few points to be noted that may simplify finding a solution .",
    "first , both the objective function and the function @xmath215 are monotonous in their arguments along any dimension . hence",
    ", if opt is feasible for some @xmath303 , it is also feasible for any @xmath304 .",
    "second , since correctness depends on @xmath305 , it is sufficient to solve an optimization problem with a strictly smaller feasible set than that of ( opt ) .",
    "this is helpful if a function @xmath306 can be found s.t .  for all @xmath39 , @xmath307 while still maintaining that there exist retransmission bounds @xmath293 s.t .",
    "@xmath308 for all @xmath309 .",
    "the solution to the resulting optimization problem might not be optimal , but the resulting csas are still correct .",
    "lastly , since any suboptimal solution to opt still gives rise to correct csas , the retransmission bounds may be chosen to be arbitrarily high as long as they are feasible .",
    "note however that there might not be a solution to opt at all , in which case the specification was unrealizable in the first place .",
    "[ cc][cc]data length @xmath310 [ rb][rt]@xmath311 [ cc][cc]minimum delay @xmath312 . the drop probability bound @xmath22 is calculated as a function of @xmath313 , @xmath310 and @xmath312 .",
    "all points on and under the surface are feasible.,title=\"fig:\",scaledwidth=45.0% ]    the implementations of a communication protocol specification provide the ascs with sufficient information on what messages are received so that accidents can effectively be prevented . in this section",
    "we develop the continuing example of the cars at an intersection further by explaining how our protocol can be embedded in an active safety application",
    ".    continued when transmitting data @xmath5 from car @xmath1 to car @xmath0 , six cases can occur .",
    "we distinguish the cases by the final system - triggered events that generate upcalls to the ascs on either car .",
    "the case we call `` correct '' is when @xmath0 receives @xmath5 , @xmath1 knows about it and @xmath0 assumes correctly that @xmath1 knows .",
    "@xmath0 then correctly receives a `` @xmath56 '' upcall , which is consistent with @xmath1 s last upcall .",
    "the ascs can then correctly react in a consistent way , e.g.  by one car gracefully decelerating .",
    "in other cases the ascs can still react in a safe way even if @xmath1 and @xmath0 have inconsistent information about each other : if @xmath0 receives @xmath5 correctly , @xmath1 never receives an acknowledgement and @xmath0 assumes @xmath1 never did , then both ascs receive `` @xmath55 '' upcalls and can react accordingly .",
    "if @xmath0 receives @xmath5 correctly and @xmath1 receives the acknowledgement , but @xmath0 assumes @xmath1 did not receive it , then @xmath0 receives a `` @xmath55 '' upcall and can react conservatively . if @xmath0 does not receive @xmath5 and @xmath1 holds that it did not , then the asc on @xmath1 can react conservative on its `` @xmath55 '' upcall .",
    "if @xmath0 receives @xmath5 correctly , @xmath1 misses the acknowledgement but @xmath0 holds that @xmath1 received it , then @xmath1 incorrectly assumes the worst case but yet reacts conservatively .",
    "the only problematic case is when @xmath0 does not receive @xmath5 but @xmath1 holds that it did .",
    "then the asc on neither @xmath1 nor @xmath0 takes conservative action , potentially resulting in an accident .",
    "however , the synthesis method constructs the csas so that this case never occurs under the given assumptions .",
    "we now conclude the example by presenting numerical results that illustrate in which hypothetical scenarios protocols that we are considering are realizable",
    ".    continued as introduced above , the drop probability bound @xmath22 on the transmission medium may be calculated from other more readily available parameters .",
    "the realizability of a given protocol specification @xmath26 depends on the drop probability bound @xmath22 . for demonstrative purposes ,",
    "we calculate @xmath22 from the number of cars @xmath313 at the intersection that may use the transmission medium simultaneously , the minimum time @xmath312 it may take for a message to be sent between two cars and the maximum amount of data @xmath310 that may be carried in a message . given an empirically obtained function @xmath314 that maps a data - rate @xmath315 to a drop - probability of the transmission medium , we calculate @xmath314 with @xmath316 ( we take @xmath317 as we consider the environment to be all cars except the two that are communicating ) .",
    "we illustrate the effectiveness of our synthesis method by asserting the sigmoid @xmath318 with @xmath319 and @xmath320 . using the protocol specification in",
    ", we illustrate how realizability changes with different values for the number of cars @xmath313 , minimum time to deliver a message @xmath312 and maximum amount of data in a message @xmath310 .",
    "[ fig : feasibility6 ] shows the feasible region of ( opt ) for @xmath26 with @xmath321 , i.e.  for which values of @xmath22 calculated as a function of @xmath313 , @xmath312 and @xmath310 the synthesis problem is realizable .",
    "it is clearly visible from fig .",
    "[ fig : feasibility6 ] that the more cars are sharing the transmission medium , the smaller the delay , and the larger the packets , the higher the worst - case data rate could be on the network , and the specification becomes harder to realize .",
    "if moreover the requirements @xmath36 and @xmath37 are made more stringent , the feasible region decreases even further .",
    "this work demonstrates a framework for reliable communication protocols for intervehicular communication in active safety applications .",
    "the framework , consisting of a precisely defined specification language and execution model ( in the form of csas ) , allows for correct - by - construction synthesis of protocol implementations that satisfy the specifications even in the presence of several other cars sharing the transmission medium .    in our synthesis method",
    "we only take into account the drop probability of the transmission medium and assume that this is sufficient to synthesise reliable protocols .",
    "this also only enables to guarantee qos requirements on the reception probability .",
    "furthermore , in the current formulation , only two cars can participate in a dialogue , but some active safety applications might require to extend this . also , note that if a communication is under way , the arrival of another message can not directly be handled even if it is required to satisfy the qos requirements .",
    "our approach permits several extensions : ( i ) allowing the higher level to specify the qos requirements and the destination address at runtime ( i.e.  for each transmission ) , ( ii ) guaranteeing qos requirements on the end - to - end delay of the communication and more general assumptions on the transmission medium dynamics in order to widen the range of applicability , and ( iii ) including the capability to relay messages over several cars to create a routed network .",
    "the latter would also require a rigorously developed synthesis method for protocols to discover the network topology , which we are currently working on .",
    "the authors would like to extend thanks to rohit pandita and vladimeros vladimerou from toyota as well as scott livingston , pavithra prabhakar and eric wolff at the california institute of technology for fruitful discussions ."
  ],
  "abstract_text": [
    "<S> we present a synthesis method for communication protocols for active safety applications that satisfy certain formal specifications on quality of service requirements . </S>",
    "<S> the protocols are developed to provide reliable communication services for automobile active safety applications . </S>",
    "<S> the synthesis method transforms a specification into a distributed implementation of senders and receivers that together satisfy the quality of service requirements by transmitting messages over an unreliable medium . </S>",
    "<S> we develop a specification language and an execution model for the implementations , and demonstrate the viability of our method by developing a protocol for a traffic scenario in which a car runs a red light at a busy intersection .    </S>",
    "<S> = 10000 = 10000 </S>"
  ]
}