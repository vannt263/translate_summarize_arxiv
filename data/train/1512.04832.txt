{
  "article_text": [
    "the problem of computing a minimum - weight spanning tree ( mst ) received considerable attention in both the distributed setting as well as in the centralized setting . in",
    "the distributed setting , constructing such a tree distributively requires a collaborative computational effort by all the network vertices , and involves sending messages to remote vertices and waiting for their replies .",
    "this is particularly interesting in the @xmath12 model of computation , where due to congestion constrains , each message can encode only a limited number of bits , specifically , this number is typically assumed to be @xmath13 , where @xmath4 denotes the number of nodes in the network .",
    "the main measures considered for evaluating a distributed mst protocol are the _ message _ complexity , namely , the maximum number of messages sent in the worst case scenario , and the _ time _ complexity , namely , the maximum number of communication rounds required for the protocol s execution in the worst case scenario .",
    "the line of research on the distributed mst computation problem was initiated by the seminal work of gallager , humblet , and spira @xcite and culminated in the @xmath11 time and @xmath14 messages algorithm by awerbuch @xcite , where @xmath2 denotes the number of edges in the network .",
    "both of these algorithms apply also to asynchronous systems .",
    "as pointed out in @xcite , the results of @xcite establish an @xmath15 lower bound on the number of messages required to construct a mst .",
    "thus , the algorithm of @xcite is essentially optimal .",
    "this was the state of affairs until the mid - nineties when garay , kutten , and peleg @xcite initiated the analysis of the time complexity of mst construction as a function of additional parameters ( other than @xmath4 ) , and gave the first sublinear time distributed algorithm for the mst problem , running in time @xmath16 , where @xmath5 is the diameter of the network .",
    "this result was later improved to @xmath17 by kutten and peleg @xcite .",
    "the tightness of this latter bound was shown by peleg and rubinovich @xcite who proved that @xmath18 is essentially ( respectively @xmath19 ) is a relaxed variant of the @xmath20 ( rep . ,",
    "@xmath21 ) notation that ignores polylog factors . ] a lower bound on the time for constructing mst on graphs with diameter @xmath22 .",
    "this result was complemented by the work of lotker , patt - shamir and peleg @xcite that showed an @xmath23{n})$ ] lower bound on the time required for mst construction on graphs with small diameter .",
    "note , however , that the time - efficient algorithms of @xcite are not message - optimal , i.e. , they take asymptotically much more than @xmath24 messages . for example , the time - optimal protocol of @xcite requires sending @xmath25 messages . the question of whether there exists an optimal distributed algorithm for mst construction that achieves _ simultaneously _",
    "@xmath0 messages and @xmath1 time still remains open .",
    "this paper addresses the mst verification problem in the @xmath12 model .",
    "informally , the setting we consider is as follows .",
    "a subgraph is given in a distributed manner , namely , some of the edges incident to every vertex are locally marked , and the collection of marked edges at all the vertices defines a _ marked subgraph _ ; see , e.g. , @xcite .",
    "the verification task requires checking distributively whether the marked subgraph is indeed an mst of the given graph .",
    "similarly to the papers dealing with sub - linear time mst construction @xcite , we consider a synchronous environment .",
    "we consider the mst verification problem and establish asymptotically tight upper and lower bounds for the time and message complexities of this problem . specifically , in the positive direction we show the following :    [ thm : upper - bound ] there exists a distributed mst verification algorithm that uses @xmath8 time and @xmath10 messages .",
    "this result appears to indicate that mst verification may be easier than mst construction , since , at the moment , it is not known whether there exists an algorithm that constructs an mst simultaneously in @xmath8 time and @xmath10 messages .",
    "conversely , we show that the verification problem is not much easier than the construction , by proving that the known lower bounds for mst construction also hold for the verification problem . specifically , we prove the following two matching lower bounds .",
    "[ thm : lower - bound - msgs ] any distributed algorithm for mst verification requires @xmath26 messages .    [ thm : lower - bound - time ] any distributed algorithm for mst verification requires @xmath7 time .    to the best of our knowledge",
    ", this paper is the first to investigate distributed verification without assuming any kind of preprocessing ( see section  [ preprocessing ] ) . following this paper , several other works on distributed verification",
    "have already been published .",
    "more specifically , a systematic study of distributed verification is established for various verification tasks @xcite .",
    "distributed verification in the @xmath27 model has been studied in @xcite , mostly focusing on computational complexity issues .",
    "our @xmath7 time lower bound for verifying an mst is achieved by a ( somewhat involved ) modification of the corresponding lower bound for the computational task @xcite . the idea behind our time lower bound",
    "was already found useful in several continuation studies .",
    "specifically , a modification of our proof technique was used in @xcite to yield time lower bounds for several other verification tasks , and for establishing a lower bound on the hardness of approximating an mst .",
    "somewhat surprisingly , in @xcite , the proof technique was extended even further to yield a result in the ( seemingly unrelated ) area of distributed random walks .        in the centralized setting",
    ", there is a large body of literature concerning the problem of efficiently computing an mst of a given weighted graph .",
    "reviews can be found , e.g. , in the survey paper by graham and hell @xcite or in the book by tarjan @xcite ( chapter 6 ) .",
    "the fastest known algorithm for finding an mst is that of pettie and ramachandran @xcite , which runs in @xmath28 time , where @xmath29 is the inverse ackermann function , @xmath4 is the number of vertices and @xmath2 is the number of edges in the graph .",
    "unfortunately , a linear ( in the number of edges ) time algorithm for computing an mst is known only in certain cases , or by using randomization @xcite .",
    "the separation between computation and verification , and specifically , the question of whether verification is easier than computation , is a central issue of profound impact on the theory of computer science . in the context of mst ,",
    "the verification problem ( introduced by tarjan @xcite ) is the following : given a weighted graph , together with a subgraph , it is required to decide whether this subgraph forms an mst of the graph . at the time it was published , the running time of the mst verification algorithm of @xcite was indeed superior to the best known bound on the computational problem . improved verification algorithms in different centralized models were then given by harel @xcite , koml@xmath30s @xcite , and dixon , rauch , and tarjan @xcite , and parallel algorithms were presented by dixon and tarjan @xcite and by king , poon , ramachandran , and sinha @xcite . even though it is not known whether there exists a deterministic algorithm that computes an mst in @xmath31 time , the verification algorithm of @xcite is in fact linear , i.e.",
    ", runs in time @xmath31 ( the same result with a simpler algorithm was later presented by king @xcite and by buchsbaum @xcite ) . for the centralized setting , this may indicate that the verification of an mst is indeed easier than its computation .",
    "some previous papers investigated distributed verification tasks assuming that the algorithm designer can perform a preprocessing stage to help the verification , cf .",
    "@xcite . typically , in this preprocessing stage",
    ", data structures ( i.e. , labels , proofs ) are provided to the nodes of the graph , and using these data structures , the verification proceeds in a constant number of rounds .",
    "the focus in those studies was on the minimum size of a data structure ( i.e. , amount of information stored locally ) , while the complexities of the preprocessing stage providing the data structures were not analyzed .",
    "a point - to - point communication network is modeled as an undirected graph @xmath32 , where the vertices in @xmath33 represent the network processors and the edges in @xmath34 represent the communication links connecting them .",
    "we denote by @xmath4 the number of vertices in @xmath3 , i.e. , @xmath35 , and let @xmath2 denote the number of edges , i.e. , @xmath36 .",
    "the _ length _ of a path in @xmath3 is the number of edges it contains .",
    "the _ distance _ between two vertices @xmath37 and @xmath38 is the length of the shortest path connecting them .",
    "the _ diameter _ of @xmath3 , denoted @xmath5 , is the maximum distance between any two vertices of @xmath3 .",
    "vertices are assumed to have unique _ identifiers _ , and each vertex @xmath38 knows its own identifier @xmath39 .",
    "a weight function @xmath40 associated with the graph assigns a nonnegative integer _ weight _",
    "@xmath41 to each edge @xmath42 .",
    "the vertices do not know the topology or the edge weights of the entire network , but they know the weights of the edges incident to them , that is , the weight @xmath43 is known to @xmath37 and @xmath38 . similarly to corresponding works on mst computation , we assume that the edge weights are bounded by a polynomial in @xmath4 ( this assumption implies that a weight of an edge can be encoded using @xmath13 bits , and hence can be encoded in one message ) .    similarly to previous work , we consider the @xmath12 model .",
    "specifically , the vertices can communicate only by sending and receiving messages over the communication links .",
    "each vertex can distinguish between its incident edges .",
    "moreover , if vertex @xmath38 sends a message to vertex @xmath37 along the edge @xmath44 , then upon receiving the message , vertex @xmath37 knows that the message was delivered over the edge @xmath45 . at most one",
    "@xmath13 bits can be sent on each link in each message . similarly to @xcite , we assume that the communication is carried out in a synchronous manner , i.e. , all the vertices are driven by a global clock .",
    "messages are sent at the beginning of each round , and are received at the end of the round .",
    "( clearly , our lower bounds hold for asynchronous networks as well . )",
    "relevant studies typically assume that computations start either at a single _ source _ node or simultaneously at all nodes .",
    "our results hold for both of these settings .",
    "formally , the _ minimum - weight spanning tree ( mst ) verification _ problem can be stated as follows .",
    "given a graph @xmath32 , a weight function @xmath46 on the edges , and a subset of edges @xmath47 , referred as the _ mst candidate _ , it is required to decide whether @xmath48 forms a minimum spanning tree on @xmath3 , i.e. , a spanning tree whose total weight @xmath49 is minimal . in the distributed model , the input and output of the _ mst verification problem _",
    "are represented as follows .",
    "each vertex knows the weights of the edges connected to its immediate neighbors .",
    "a degree-@xmath50 vertex @xmath51 with neighbors @xmath52 has @xmath50 _ weight variables _ @xmath53 , with @xmath54 containing the weight of the edge connecting @xmath38 to @xmath55 , i.e. , @xmath56 , and @xmath50 _ boolean indicator variables _ @xmath57 indicating which of the edges adjacent to @xmath38 participate in the mst candidate that we wish to verify .",
    "the indicator variables must be consistent , namely , for every edge @xmath58 , the indicator variables stored at @xmath37 and @xmath38 for this edge must agree ( this is easy to verify locally ) . let @xmath59 be the set of edges marked by the indicator variables ( i.e. , all edges for which the indicator variable is set to  1 ) .",
    "the output of the algorithm at each vertex @xmath38 is an assignment to a ( boolean ) output variable @xmath60 that must satisfy @xmath61 if @xmath59 is an mst of @xmath62 , and @xmath63 otherwise .",
    "in this section we describe our mst verification algorithm , prove its correctness and analyze its time and message complexities .",
    "first , we note that in this section we assume that the verification algorithm is initiated by a designated source node .",
    "the case in which all nodes wake up simultaneously can be reduced to the single source setting using the leader election algorithm of @xcite , which employs @xmath0 messages and runs in @xmath64 time .      following",
    "are some definitions and notations used in the description of the algorithm . for a graph @xmath65 , an edge @xmath45",
    "is said to be _ cycle - heavy _ if there exists a cycle @xmath66 in @xmath3 that contains @xmath45 , and @xmath45 has the heaviest weight in @xmath66 . for a graph @xmath65 , a set of edges @xmath67",
    "is said to be an _ mst fragment _ of @xmath3 if there exists a minimum spanning tree @xmath48 of @xmath3 such that @xmath68 is a subtree of @xmath48 ( i.e. , @xmath69 and @xmath68 is a tree ) .",
    "similarly , a collection @xmath70 of edge sets is referred to as an _ mst fragment collection _ of @xmath3 if there exists an mst @xmath48 of @xmath3 such that ( 1 ) @xmath71 is a subtree of @xmath48 for every @xmath72 , ( 2 ) @xmath73 , and ( 3 ) @xmath74 for every @xmath75 , where @xmath76 .",
    "consider a graph @xmath65 , an mst fragment collection @xmath70 , a subgraph @xmath48 of @xmath3 and a vertex @xmath38 in @xmath3 .",
    "the _ fragment graph _ of @xmath3 , denoted @xmath77 , is defined as a graph whose vertices are the mst fragments @xmath72 , and whose edge set contains an edge @xmath78 if and only if there exist vertices @xmath79 and @xmath80 such that @xmath81 . similarly ,",
    "the _ fragment graph induced by _",
    "@xmath48 , denoted @xmath82 , is defined as a graph whose vertices are the mst fragments @xmath72 , and whose edge set contains an edge @xmath78 for @xmath76 if and only if there exist vertices @xmath79 and @xmath80 such that @xmath83 .",
    "the edges of @xmath82 are also referred to as the _ inter - cluster _ edges induced by @xmath48 .    for each vertex @xmath38 , let @xmath84 denote the set of edges of @xmath48 incident to @xmath38 .",
    "for each fragment @xmath85 , the set of _ fragment internal _ edges of @xmath68 induced by @xmath48 , denoted @xmath86 , consists of all edges of @xmath48 with both endpoints in @xmath87 , i.e. , @xmath88 .",
    "the fragment of @xmath38 , denoted by @xmath89 , is the fragment @xmath85 such that @xmath90 .",
    "denote by @xmath91 the set of edges in @xmath89 that are incident to @xmath38 ( i.e. , @xmath92 ) .",
    "similarly , denote by @xmath93 the set of fragment internal edges of @xmath68 induced by @xmath48 and incident to  @xmath38 .    throughout the description of the verification algorithm we assume that the edge weights are distinct .",
    "having distinct edge weights simplifies our arguments since it guarantees the uniqueness of the mst . yet",
    ", this assumption is not essential .",
    "alternatively , in case the graph is not guaranteed to have distinct edge weights , we may use a modified weight function @xmath94 , which orders edge weights lexicographically . at this point",
    "we would like to note that the standard technique ( e.g. , @xcite ) for obtaining unique weights is not sufficient for our purposes .",
    "indeed , that technique orders edge weights lexicographically : first , by their original weight @xmath41 , and then , by the identifiers of the edge endpoints ( say , first comparing the smaller of the two identifiers of the endpoints , and then the larger one ) .",
    "this yields a modified graph with unique edge weights , and an mst of the modified graph is necessarily an mst of the original graph . for construction purposes",
    "it is therefore sufficient to consider only the modified graph .",
    "however , this is not the case for verification purposes , as the given subgraph can be an mst of the original graph but not necessarily an mst of the modified graph .",
    "while we can not guarantee than any mst of the original graph is an mst of the modified graph ( having unique edge weights ) , we make sure that the particular given subgraph @xmath48 is an mst of the original graph if and only if it is an mst of modified one .",
    "this condition is sufficient for our purposes , and allows us to consider only the modified graph . specifically , to obtain the modified graph",
    ", we employ a slightly different technique than the classical one . that is , edge weights are lexicographically ordered as follows . for an edge @xmath95 connecting @xmath38 to its @xmath96th neighbor @xmath55 , consider first its original weight @xmath41 , next , the value @xmath97 where @xmath98 is the indicator variable of the edge @xmath45 ( indicating whether @xmath45 belongs to the candidate mst to be verified ) , and finally , the identifiers of the edge endpoints , @xmath39 and @xmath99 ( say , first comparing the smaller of the two identifiers of the endpoints , and then the larger one ) .",
    "formally , let @xmath100 where @xmath101 and @xmath102",
    ". under this weight function @xmath94 , edges with indicator variable set to 1 will have lighter weight than edges with the same weight under @xmath41 but with indicator variable set to 0 ( i.e. , for edges @xmath103 and @xmath104 such that @xmath105 , we have @xmath106 ) .",
    "it follows that the given subgraph @xmath48 is an mst of @xmath62 if and only if @xmath48 is an mst of @xmath107 . moreover , since @xmath108 takes into account the unique vertex identifiers , it assigns distinct edge weights .",
    "the mst verification algorithm makes use of procedures @xmath109 and @xmath110 , presented in @xcite and @xcite respectively . before we continue , let us first recall what these procedures guarantee .",
    "[ [ procedure - dom ] ] procedure @xmath109 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the distributed procedure @xmath109 , used in @xcite , partitions a given graph into an _",
    "mst fragment collection ( mfc ) _",
    "@xmath70 , where each fragment is of size at least @xmath111 and depth @xmath112 , for a parameter @xmath113 to be specified later ( aiming to optimize the total costs ) .",
    "a _ fragment leader _",
    "vertex is associated with each constructed fragment ( the identifier of the fragment is defined as the identifier of the fragment s leader ) .",
    "after procedure @xmath109 is completed , each vertex @xmath38 knows the identifier of the fragment to which it belongs and @xmath38 s incident edges that belong to the fragment .",
    "( to abide by the assumption of @xcite that each vertex knows the identifiers of its neighbors , before applying procedure @xmath109 , the algorithm performs a single communication round that exchanges vertex identifiers between neighboring vertices . )",
    "the execution of procedure @xmath109 , requires @xmath114 time and @xmath115 messages .",
    "the parameter @xmath113 to be used by our protocol , chosen as a suitable breakpoint so as to optimize the total costs , satisfies @xmath116 , hence , our invocation of procedure @xmath109 will require @xmath117 time and @xmath0 messages .",
    "[ [ the - lab - labeling - scheme ] ] the @xmath110 labeling scheme : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the labeling scheme @xmath110 of @xcite is a centralized procedure designed for the family of weighted trees .",
    "the procedure involves two components : an encoder algorithm @xmath118 and a decoder algorithm @xmath119 .",
    "these two components satisfy the following .    1 .   given a weighted tree @xmath48 , the encoder algorithm @xmath120 assigns a label @xmath121 to each vertex  @xmath38  of  @xmath48 .",
    "2 .   given two labels @xmath122 and @xmath121 assigned by @xmath120 to two vertices @xmath37 and @xmath38 in some weighted tree  @xmath48 , the decoder algorithm @xmath123 outputs @xmath124 , which is the maximum weight of an edge on the path connecting @xmath37 and @xmath38 in @xmath48 .",
    "( the decoder algorithm @xmath123 bases its answer on the pair of labels @xmath122 and @xmath121 only , without knowing any additional information regarding the tree  @xmath48 . )",
    "the labeling scheme @xmath110 produces @xmath125-bit labels , where @xmath126 is the largest weight of an edge . since @xmath126 is assumed to be polynomial in @xmath4 , the label size is @xmath127 bit .",
    "[ [ overview ] ] overview : + + + + + + + + +    the algorithm consists of three phases .",
    "the first phase starts by letting the source node @xmath128 construct a bfs tree rooted at @xmath128 , and calculating the values of the number of nodes @xmath4 and a 2-approximation @xmath50 to the diameter @xmath5 of the graph .",
    "then , the distributed procedure @xmath109 of @xcite in invoked with parameter @xmath129 , where @xmath5 is the diameter of the graph .",
    "this procedure constructs an mst fragment collection ( mfc ) @xmath70 , where every fragment in @xmath70 is of size at least @xmath111 and depth @xmath112 .",
    "as mentioned , our invocation of procedure @xmath109 requires @xmath117 time and @xmath0 messages . the algorithm verifies that the set of edges contained in the constructed mfc is equal to the set of fragment internal edges induced by the mst candidate @xmath48 , i.e. , @xmath130 ( this verifies that each @xmath85 is contained in @xmath48 and that @xmath48 does not contain additional fragment internal edges . ) note that this is a necessary condition for correctness since the graph is assumed to have a unique mst .    in the following phases , the algorithm verifies that",
    "all remaining edges of @xmath48 form an mst on the fragment graph @xmath77 .",
    "let @xmath82 be the fragment graph induced by @xmath48 with respect to the mfc @xmath70 found in the previous phase .",
    "in order to verify that @xmath82 forms an mst on the fragment graph @xmath77 , it suffices to verify that @xmath82 is a tree and that none of the edges of @xmath82 is a _ cycle heavy _",
    "edge in @xmath77 .",
    "the above is done as follows .    in the second phase ,",
    "the structure of @xmath82 is aggregated over the bfs tree to the source node @xmath128 , which in turn verifies that @xmath82 is indeed a tree .",
    "note that this aggregation is not very wasteful , and requires @xmath131 time and @xmath132 messages , where @xmath133 is the number of nodes in @xmath82 .",
    "as shown later , @xmath134 , and hence , this aggregation can be done using @xmath117 time and @xmath0 messages .    in the third phase",
    ", the source node @xmath128 employs the ( centralized ) labeling scheme @xmath110 of @xcite ( or @xcite ) on @xmath82 .",
    "informally , the labeling scheme assigns a label @xmath135 to each vertex @xmath71 of @xmath82 using the encoder algorithm @xmath118 applied on @xmath82 .",
    "the label @xmath135 is then efficiently delivered to each vertex in @xmath71 .",
    "more specifically , the @xmath133 labels are broadcasted over the bfs tree , so that eventually , each node in a fragment knows its corresponding label .",
    "this broadcasts costs @xmath136 time and @xmath137 messages .",
    "recall , that given the labels of two fragments @xmath135 and @xmath138 it is now possible to compute the weight of the heaviest edge on the path connecting the fragments in @xmath82 by applying the decoder algorithm @xmath119 .",
    "once all vertices obtain the labels of their corresponding fragments , each vertex of @xmath3 can verify ( using the decoder  @xmath119 ) by communicating with its neighbors only , that each inter fragment edge incident to it and not participating in @xmath82 forms a cycle when added to @xmath82 for which it is a cycle heavy edge .",
    "following is a more detailed description of the algorithm .    1 .   * * 1 .",
    "[ send_ids ] the source node @xmath128 ( which initiates the algorithm ) constructs a bfs tree rooted at @xmath128 , computes the values @xmath4 and @xmath50 , where @xmath4 is the number of nodes and @xmath50 is the depth of the bfs tree .",
    "( note that @xmath50 is a 2-approximation to the diameter @xmath5 of the graph . )",
    "subsequently , the source node @xmath128 broadcasts a signal over the bfs tree containing the values @xmath4 and @xmath50 and instructing each vertex to send its identifier to all its neighbors .",
    "this guarantees that all nodes know the values of @xmath4 and @xmath50 as well as the identifiers of their neighbors .",
    "in addition , to start the next step ( i.e. , step 2.b ) at the same time , the broadcast is augmented with a counter that is initialized by the source @xmath128 to @xmath139 is decreased by one when delivered to a child in the bfs tree .",
    "let @xmath140 denote the counter received at node @xmath37 . before starting the next step each node @xmath37 waits for @xmath140 rounds after receiving the counter .",
    "[ dom ] perform procedure @xmath141 , with parameter @xmath129 .",
    "the result is an mfc @xmath70 , where each fragment @xmath85 is of size @xmath142 and depth @xmath112 , having a fragment leader and a distinct fragment identifier known to all vertices in the fragment .",
    "[ send_fragment ] each vertex sends its fragment identifier to all its neighbors .",
    "[ identify_int_vs_ext_edges ] by comparing the fragment identifiers of its neighbors with its own fragment identifier , each vertex @xmath38 identifies the sets of edges @xmath91 and @xmath93 .",
    "[ verify_internal_edges ] verify that @xmath130 by verifying at each vertex @xmath38 that @xmath143 .",
    "( else return `` @xmath48 is not an mst '' . ) 2 .",
    "[ count_fragments ] vertex @xmath128 counts the number of fragments , denoted by @xmath133 .",
    "this is implemented by letting @xmath128 broadcast a signal over the bfs tree instructing the nodes to perform a convergecast over the bfs tree . during this convergecast",
    "the number of fragments is aggregated to the root @xmath128 by letting only fragment leader vertices increase the fragment counter .",
    "this guarantees that the fragment counter at the root @xmath128 is @xmath133 .",
    "[ count_inter_fragment ] vertex @xmath128 counts the number of inter fragment edges induced by @xmath48 ( i.e. , the number of edges in @xmath82 ) by performing another convergecast over the bfs tree .",
    "then , @xmath128 verifies that the number of edges is equal to @xmath144 .",
    "( else return `` @xmath48 is not an mst '' . )",
    "[ send_tf ] vertex @xmath128 broadcasts a signal over the bfs tree instructing all vertices to send the description of all their incident edges in @xmath82 to @xmath128 , by performing a convergecast over the bfs tree .",
    "( the edges of @xmath82 are all edges of @xmath48 that connect vertices from different fragments . )",
    "[ verify_tree]vertex @xmath128 verifies that @xmath82 is a tree . ( else",
    "return `` @xmath48 is not an mst '' . )",
    "[ route ] each fragment leader sends a message to vertex @xmath128 over the bfs tree . following these messages , all vertices",
    "save routing information regarding the fragment leaders .",
    "i.e. , if @xmath38 is a fragment leader and @xmath38 is a descendant of some other vertex @xmath37 in the bfs tree , then , after this step is applied , @xmath37 knows which of its children is on the path connecting it to the fragment leader @xmath38 .",
    "[ encode ] vertex @xmath128 computes the labels @xmath145 for all vertices @xmath68 in @xmath82 ( i.e. , assigns a label to each of the fragments ) using the encoder algorithm @xmath118 .",
    "subsequently , @xmath128 sends to each fragment leader its fragment label ( the label of each fragment is sent to the fragment leader over the bfs tree using the routing information established in step [ route ] above ) .",
    "( recall that each label is encoded using @xmath146 bits . )",
    "[ send_labels_leaders ] each fragment leader broadcasts its fragment label to all vertices in the fragment . the broadcast is done over the fragment edges .",
    "[ send_labels_neig ] each vertex @xmath38 sends its fragment label to all its neighbors in other fragments .",
    "( recall that @xmath38 already knows @xmath147 by step [ identify_int_vs_ext_edges ] . )",
    "[ verify_cycle_heavy]each vertex @xmath38 verifies , for every neighbor @xmath37 such that @xmath37 does not belong to @xmath148s fragment and @xmath149 , that @xmath150 .",
    "( the value @xmath151 is computed by applying the decoder algorithm @xmath119 to the labels @xmath152 and @xmath153 . )",
    "( else return `` @xmath48 is not an mst '' . )      we now show that our mst verification algorithm correctly identifies whether the given subgraph @xmath48 is an mst .",
    "we begin with the following claim .",
    "[ clm_fragmet_mst ] let @xmath48 be a spanning tree of @xmath3 such that @xmath48 contains all edges of the mfc @xmath70 and @xmath82 forms an mst on the fragment graph of @xmath3 ( with respect to the mfc @xmath70 ) .",
    "then @xmath48 is an mst on @xmath3 .",
    "since @xmath70 is an mst fragment collection , there exists an mst @xmath154 of @xmath3 such that @xmath154 contains all edges of @xmath70 . due to the minimality of @xmath154 , the fragment graph @xmath155 induced by @xmath154",
    "necessarily forms an mst on @xmath77 , the fragment graph of @xmath3 .",
    "hence we get that @xmath156 , thus @xmath48 is an mst of  @xmath3 .    due to the assumption that edge weights are distinct ,",
    "we get :    [ unique_mst ] the mst of @xmath3 is unique .    by combining claim [ clm_fragmet_mst ] and observation [ unique_mst ]",
    "we get the following .",
    "[ show_mst ] a spanning tree @xmath48 of @xmath3 is an mst if and only if @xmath48 contains all edges of the mfc @xmath70 and @xmath82 forms an mst on @xmath77 .",
    "[ lem : correct ] the mst verification algorithm correctly identifies whether the given tree @xmath48 is an mst of the graph @xmath3 .    by claim [ show_mst ] , to prove the correctness of the algorithm it suffices to show that given an mst candidate @xmath48 , the algorithm verifies that :    \\(1 ) @xmath48 is a spanning tree of @xmath3 ,    \\(2 ) @xmath48 contains all edges of @xmath70 , and    \\(3 ) @xmath82 forms an mst on @xmath77 .    since @xmath70",
    "as constructed by procedure @xmath109 in the first phase is an mfc , it spans all vertices of @xmath3 .",
    "step [ verify_internal_edges ] verifies that @xmath130 , thus after this step , it is verified that @xmath48 does not contain a cycle that is fully contained in some fragment @xmath85 ( since every @xmath85 is a tree ) . on the other hand ,",
    "step [ verify_tree ] verifies that @xmath48 does not contain a cycle that contains vertices from different fragments .",
    "hence , the algorithm indeed verifies that @xmath48 is a spanning tree of @xmath3 , and property ( 1 ) follows .",
    "property ( 2 ) is clearly verified by step [ verify_internal_edges ] of the algorithm . finally , to verify that @xmath82 forms an mst on the fragment graph of @xmath3 it suffices to verify that inter - fragment edges not in @xmath82 are cycle heavy , which is done in step [ verify_cycle_heavy ] .",
    "property ( 3 ) follows .",
    "consider first the phase 1 .",
    "steps [ send_ids ] and [ send_fragment ] clearly take @xmath157 time and @xmath31 messages .",
    "step [ dom ] , i.e. , the execution of procedure @xmath109 , requires @xmath114 time and @xmath158 messages .",
    "( a full analysis appears in @xcite . )",
    "the remaining steps of the first phase are local computations performed by all vertices .",
    "thus , since @xmath113 is set to @xmath159 , the first phase of the mst verification algorithm requires requires @xmath117 time and @xmath0 messages .",
    "observe now , that since the fragments are disjoint and each fragment contains at least @xmath113 vertices , we have the following .    [ num_of_fragments ] the number of mst fragments constructed during the first phase of the algorithm is @xmath160 .",
    "the first two steps of phase 2 , namely , steps [ count_fragments ] and [ count_inter_fragment ] consist of simple broadcasts over the bfs tree , hence they require @xmath157 time and @xmath31 messages .",
    "step [ send_tf ] consists of upcasting all the edges in @xmath82 to @xmath128 .",
    "note that the number of edges in @xmath82 can potentially be as high as @xmath2 . however , given that the verification did not fail in step [ count_inter_fragment ] , we are guaranteed that the number of edges in @xmath82 is @xmath161 .",
    "thus , step [ send_tf ] amounts to upcasting @xmath161 messages and can therefore be performed in @xmath131 time and @xmath162 messages .",
    "step [ route ] consists of an upcast of @xmath133 messages over the bfs tree and thus requires the same time and message complexities as that of step [ send_tf ] .",
    "step [ encode ] consists of a bfs downcast of @xmath133 messages ( each of size @xmath163 ) ; it therefore requires @xmath164 time and @xmath165 messages .",
    "step [ send_labels_leaders ] consists of a broadcast of a label ( of size @xmath146 ) in each of the mst fragments ; this can be performed in @xmath166 time and @xmath167 messages .",
    "finally , step [ send_labels_neig ] can be performed in @xmath13 time and @xmath168 messages , and step [ verify_cycle_heavy ] amounts to local computations .",
    "table  1 below summarizes the time and message complexities of the second and third phases of the algorithm .",
    "[ t : table ]     [ count_fragments],[count_inter_fragment ] & bfs convergecast & @xmath157&@xmath31     + [ send_tf ] , [ route ] & bfs upcast of @xmath133 messages&@xmath131&@xmath169     + [ verify_tree],[verify_cycle_heavy ] & local computation&@xmath170 & none     + [ encode ] & bfs downcast of @xmath133 messages ( each of size @xmath163)&@xmath171&@xmath172 + [ send_labels_leaders ] & broadcast in each of the mst fragments & @xmath166 & @xmath173     + [ send_labels_neig ] & communication between neighbors & @xmath13 & @xmath174 +    combining the above arguments , and using the fact that @xmath175 ( see observation [ num_of_fragments ] ) , we obtain the following .",
    "the algorithm describes above requires @xmath117 time and @xmath0 messages .",
    "theorem [ thm : upper - bound ] follows by combining the lemma above with lemma [ lem : correct ] .",
    "in this section , we prove an @xmath7 lower bound on the time required to solve the mst verification . clearly , @xmath176 time is inevitable in the case of a single source node .",
    "the case in which all nodes start at the same time is also very simple .",
    "indeed , in this case , the @xmath176 time bound follows by considering a cycle @xmath66 of size @xmath4 with all edges having weight 1 except for two edges @xmath45 and @xmath177 located at opposite sides .",
    "the given candidate spanning tree is @xmath178 .",
    "the two edges @xmath45 and @xmath177 can have arbitrary weights , hence , to decide whether @xmath48 is an mst one needs to transfer information along at least half of the cycle .",
    "this shows a lower bound of @xmath176 for the case where @xmath179 .",
    "a similar argument can be applied for arbitrary values of @xmath5 .",
    "the difficult part is to prove a time lower bound of @xmath18 .",
    "we prove this lower bound for the case where all nodes start at the execution at the same time .",
    "the lower bound for the case of a single source node follows directly from this lower bound , relying on the leader election algorithm of @xcite , which runs in @xmath64 time .    in the remaining of this section",
    "we consider the case where all nodes start the execution simultaneously at the same time , and prove a lower bound of @xmath18 . to show the lower bound , we first define a new problem named _ vector equality _ , and then show a lower bound for the time required to solve it .",
    "this is established in section [ sec : veprob ] .",
    "more specifically , for the purposes of this lower bound proof , we consider the collection of graphs denoted @xmath180 , for @xmath181 , as defined in @xcite .",
    "each graph graph @xmath180 consists of @xmath182 vertices , and its diameter is @xmath183 . in section [ subsec : itn ] , we establish a time lower bound of @xmath184 for solving vector equality in each graph @xmath180 .    in section [ sec : lb_ver_prob ] , for @xmath181 , we consider a family @xmath185 of weighted graphs ( these are weighted versions of the graph @xmath180 ) , and show that any algorithm solving the mst verification problem on the graphs in @xmath185 can also be used to solve the vector equality problem on @xmath180 with the same time complexity .",
    "this establishes the desired @xmath18 time lower bound for the distributed mst verification problem .",
    "[ [ the - vector - equality - problem - eqgsrb . ] ] the vector equality problem @xmath186 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    consider a graph @xmath3 and two specified distinguished vertices @xmath128 and @xmath187 , each storing @xmath188 boolean variables , @xmath189 and @xmath190 respectively , for some integer @xmath191 .",
    "an instance of the problem consists of initial assignments @xmath192 and @xmath193 , where @xmath194 , to the variables of @xmath128 and @xmath187 respectively .",
    "given such an instance , the vector equality problem requires @xmath187 to decide whether @xmath195 , i.e. , @xmath196 for every @xmath197 .",
    "let us recall the collection of graphs denoted @xmath180 , for @xmath181 , as defined in @xcite .",
    "( see figure [ f : ti ] ) .",
    "the components used are the _ ordinary path _",
    "@xmath198 on @xmath199 vertices , where @xmath200 , @xmath201 , and the _ highway _",
    "@xmath202 on @xmath203 vertices , where @xmath204 and @xmath205 .",
    "each highway vertex @xmath206 is connected to the corresponding path vertex @xmath207 by a _ spoke _",
    "edge @xmath208 .",
    "the graph @xmath180 is constructed of @xmath209 copies of the path , @xmath210 , and connecting them to the highway @xmath202 .",
    "the two distinguished vertices are @xmath211 and @xmath212 .",
    "the spoke edges are grouped into @xmath203 _ stars _",
    "@xmath213 , @xmath214 , with each @xmath213 consisting of the vertex @xmath206 and the @xmath209 vertices @xmath215 connected to it by spoke edges . hence @xmath216 and @xmath217 .",
    "the graph @xmath180 consists of @xmath218 and @xmath219 .",
    "thus @xmath180 has @xmath182 vertices and diameter @xmath183 .",
    "our goal now is to prove that solving the vector equality problem on @xmath221 with a @xmath222-bit input strings @xmath223 requires @xmath224 time , assuming each message is encoded using @xmath225 bits .",
    "( later , we shall take @xmath226 . )",
    "consider some arbitrary algorithm @xmath227 , and let @xmath228 denote the execution of @xmath227 on @xmath209-bit inputs @xmath223 on the graph @xmath221 .",
    "for simplicity , we assume that @xmath229 is an integer . for @xmath230 , define the _ i - middle set _ of the graph @xmath221 , denoted @xmath231 , as follows . for every @xmath232 ,",
    "define the _ i - middle _ of the path @xmath233 as @xmath234 .",
    "let @xmath235 denote the least integer @xmath236 such that @xmath237 and @xmath238 denote the largest integer @xmath239 such that @xmath240 .",
    "define the _ i - middle _ of @xmath202 as @xmath241 .",
    "now , the _ i - middle set _ of @xmath221 is the union of those middle sets , @xmath242 ( see fig .  [",
    "f : ti ] . ) for @xmath243 , the definition is slightly different , letting @xmath244 .",
    "[ htb ]     the middle set @xmath231 in the graph @xmath180 ]    denote the _ state _ of the vertex @xmath38 at the beginning of round @xmath245 during the execution @xmath228 on the input @xmath223 by @xmath246 . without loss of generality , we may assume that in two different executions @xmath228 and @xmath247 , a vertex reaches the same state at time @xmath245 , i.e. , @xmath248 , if and only if it receives the same sequence of messages on each of its incoming links ; for different sequences , the states are distinguishable .",
    "for a given set of vertices @xmath249 , a _ configuration _",
    "@xmath250 is a vector @xmath251 of the states of the vertices of @xmath252 at the beginning of round @xmath245 of the execution @xmath228 .",
    "denote by @xmath253 $ ] the collection of all possible configurations of the subset @xmath254 at time @xmath245 over all executions @xmath228 of algorithm @xmath227 ( i.e. , on all legal inputs @xmath223 ) , and let @xmath255 = |\\cc[u , t]|$ ] .",
    "prior to the beginning of the execution ( i.e. , at the beginning of round @xmath256 ) , the input strings @xmath223 are known only to vertices @xmath128 and @xmath187 respectively .",
    "the rest of the vertices are found in some initial state , described by the configuration @xmath257 , which is independent of @xmath223 .",
    "thus in particular @xmath258 = 1 $ ] .",
    "( note , however , that @xmath259 = 2^{2m^2}$ ] . )    [ step ] for every @xmath260 , @xmath261 \\le ( 2^b+1)^2 \\cdot \\rho[m_t , t]$ ] .",
    "the lemma is proved by showing that in round @xmath262 of the algorithm , each configuration in @xmath263 $ ] branches off into at most @xmath264 different configurations of @xmath265 $ ] .",
    "fix a configuration @xmath266 $ ] , and let @xmath267 and @xmath268 .",
    "the @xmath269-middle set @xmath270 is connected to the rest of the graph by the highway edges @xmath271 and @xmath272 and by the @xmath273 path edges @xmath274,@xmath275 @xmath276 .",
    "( see fig .",
    "[ f : tt+1 ] . )",
    "[ htb ]     the edges entering the middle set @xmath270 . ]",
    "let us count the number of different configurations in @xmath265 $ ] that may result of the configuration @xmath277 .",
    "starting from the configuration @xmath277 , each vertex @xmath278 is restricted to a single state , and hence it sends a single ( well determined ) message over the edge @xmath279 to @xmath280 thus not introducing any divergence in the execution .",
    "similarly , each vertex @xmath281 is restricted to a single state , and hence it sends a single message over the edge @xmath282 to @xmath283 .",
    "the same applies to all the edges internal to @xmath270 . as for the highway edges @xmath284 , the vertices @xmath285 and @xmath286 are not in the set @xmath287",
    ", hence they may be in any one of many possible states , and the values passed over these edges into the set @xmath270 are not determined by the configuration @xmath277 .",
    "however , due to the restriction of the @xmath225-bounded - message model , at most @xmath288 different behaviors of @xmath289 can be observed by @xmath290 and at most @xmath288 different behaviors of @xmath291 can be observed by @xmath292 .",
    "thus altogether , the configuration @xmath277 branches off into at most @xmath264 possible configurations @xmath293 $ ] , differing only by the states @xmath294 , @xmath295 .",
    "the lemma follows .",
    "applying lemma [ step ] and the fact that @xmath258 = 1 $ ] , we get the following result .",
    "[ cl : bound - rho ] for every @xmath296 , @xmath297 \\le ( 2^b+1)^{2t}$ ] .    to prove the time lower bound for the vector equality problem we introduce the following restricted model of computation as defined in @xcite . a _ two party communication model _",
    "consists of parties @xmath298 and @xmath299 connected via a bidirectional communication link .",
    "let @xmath300 be arbitrary finite sets .",
    "we say that protocol @xmath301 computes function @xmath302 if , when given input @xmath303 known to party @xmath298 and input @xmath304 known to party @xmath225 , the parties are able to determine @xmath305 by a sequence of bit exchanges .",
    "the following observation follows from @xcite , and is used to prove lemma [ l : eq - lb ] .",
    "[ l : similar - executions ] consider a protocol @xmath306 .",
    "suppose that there exist inputs @xmath307 for party @xmath298 and @xmath308 for party @xmath299 for which in the executions of @xmath306 on input @xmath309 and on input @xmath310 , identical sequences of bits are exchanged by both parties .",
    "then the same sequence of bits is exchanged in the execution of @xmath306 on input @xmath311 .",
    "[ l : eq - lb ] for every @xmath312 , solving the vector equality problem @xmath313 requires @xmath224 time .",
    "assume , towards contradiction , that there exists a protocol @xmath301 that correctly solves @xmath313 and has worst case time complexity @xmath314 .",
    "let @xmath315 be the middle set of @xmath316 , as previously defined , corresponding to @xmath317 .",
    "let @xmath318 be the set of vertices that reside on the left side of @xmath315 in @xmath221 and @xmath319 be the set of vertices that reside on the right side of @xmath315 .",
    "note that @xmath320 and @xmath321 .",
    "consider a simulation of protocol @xmath301 by two parties @xmath298 and @xmath299 .",
    "the simulation works so that party @xmath298 simulates the execution of @xmath301 in @xmath315 and in @xmath318 , and party @xmath299 simulates the execution of @xmath301 in @xmath315 and in @xmath319 . at the end of the simulation , party",
    "@xmath299 outputs the output of vertex @xmath187 in the execution of @xmath301 .",
    "every step of the distributed protocol @xmath301 is simulated by multiple bit exchanges between the parties @xmath298 and @xmath299 .",
    "party @xmath298 sends to party @xmath299 all messages sent in @xmath301 by vertices in @xmath318 to vertices in @xmath315 and @xmath299 party sends to party @xmath298 all messages sent in @xmath301 by vertices in @xmath319 to vertices in @xmath315 .",
    "hence , the parties @xmath298 and @xmath299 have full knowledge of the configuration of vertices in @xmath315 and are able to compute the configurations of vertices in @xmath318 and vertices in @xmath319 respectively .",
    "thus , parties @xmath298 and @xmath299 correctly simulate @xmath301 .    combining the assumption that @xmath322 with corollary [ cl : bound - rho ] , we get that the number of possible configuration of @xmath315 in all possible executions of protocol @xmath301 is smaller than @xmath323",
    ". hence there exist inputs @xmath324 such that @xmath325 and protocol @xmath301 reaches the same configuration of @xmath315 when executed with input @xmath326 or @xmath327 .",
    "denote by @xmath328 the execution of @xmath301 on @xmath221 with input @xmath326 , and by @xmath329 the execution of @xmath301 on @xmath221 with input @xmath327 . during both simulations of @xmath328 and @xmath329 , parties @xmath298 and @xmath299 exchange the same sequence of messages ( induced by the configuration of @xmath315 ) . by obs .",
    "[ l : similar - executions ] we get that in the simulation of @xmath301 on input @xmath330 , @xmath298 and @xmath299 exchange the same sequence of messages as in the simulation of @xmath328 .",
    "thus in both executions of protocol @xmath301 ( @xmath328 and @xmath301 with input @xmath330 ) , vertex @xmath187 has identical initial configuration and receives the same sequence of messages , hence it reaches the same decision , in contradiction to the correctness of @xmath301 .      in this section",
    "we use the results achieved in the previous subsection , and show that the distributed mst verification problem can not be solved faster than @xmath224 rounds on weighted versions of the graphs @xmath180 . in order to prove this lower bound , we recall the definition given in @xmath331 of a family of weighted graphs @xmath185 , based on @xmath221 but differing in their weight assignments .",
    "then , we show that any algorithm solving the mst verification problem on the graphs of @xmath185 can also be used to solve the vector equality problem on @xmath180 with the same time complexity .",
    "subsequently , the lower bound for the distributed mst verification problem follows from the lower bound given in the previous subsection for the vector equality problem on @xmath180 .",
    "the graphs @xmath180 defined earlier were unweighted . in this subsection , we define for every graph @xmath180 a family of weighted graphs @xmath332 , where @xmath333 is an edge weight function .",
    "in all the weight functions @xmath333 , all the edges of the highway @xmath202 and the paths @xmath233 are assigned the weight @xmath170 .",
    "the spokes of all stars except @xmath334 and @xmath335 are assigned the weight 4 .",
    "the spokes of the star @xmath335 are assigned the weight 2 .",
    "the only differences between different weight functions @xmath333 occur on the @xmath209 spokes of the star @xmath334 .",
    "specifically , each of these @xmath209 spokes is assigned a weight of either 1 or 3 ; there are thus @xmath323 possible weight assignments . since discarding all spoke edges of weight 4 from the graph @xmath336 leaves it connected , and",
    "since every spoke edge of weight 4 is the heaviest edge on some cycle in the graph , the following is clear .",
    "[ infwe ] no spoke edge of weight 4 belongs to the mst of @xmath336 , for every @xmath337 .",
    "let us pair the spoke edges of @xmath334 and @xmath335 , denoting the @xmath338th pair ( for @xmath276 ) by @xmath339 .",
    "the following is also clear .",
    "[ finwe ] for every @xmath337 and @xmath340 , exactly one of the two edges of @xmath341 belongs to the mst of @xmath336 , namely , the lighter one .",
    "moreover , for every @xmath181 and @xmath337 , all the edges of the highway @xmath202 and the paths @xmath233 , for @xmath276 , belong to the mst of @xmath336 .",
    "note that the horizontal edges belong to the mst under any edge weight function . of the remaining edges ,",
    "exactly one of each pair will join the mst , depending on the particular weight assignment to the spoke edges of the star @xmath334 .",
    "[ reduc2 ] any distributed algorithm for mst verification on the graphs of the class @xmath342 , can be used to solve the @xmath343 problem on @xmath221 with the same time complexity .",
    "consider an algorithm @xmath344 for the mst verification problem , and suppose that we are given an instance of the @xmath343 problem with input strings @xmath223 ( stored in variables @xmath345 and @xmath346 respectively ) .",
    "we use the algorithm @xmath344 to solve this instance of vector equality problem as follows .",
    "vertices @xmath211 and @xmath347 initiate the construction of an instance of the mst verification by turning @xmath221 into a weighted graph from @xmath342 , setting the edge weights and marking the edges participating in the mst candidate as follows : for each @xmath348 , @xmath349 , vertex @xmath128 sets the weight variable @xmath350 corresponding to the spoke edge @xmath351 , to be @xmath352 in addition vertices @xmath128 and @xmath187 mark the edges participating in the mst candidate ( that we wish to verify ) in the following manner : for each @xmath348 , @xmath349 , vertex @xmath128 sets the indicator variable @xmath353 corresponding to the spoke edge @xmath354 , to be @xmath355 for each @xmath356 , @xmath349 , vertex @xmath187 sets the indicator variable @xmath357 corresponding to the spoke edge @xmath358 , to be @xmath359 the rest of the graph edges are assigned fixed weights as specified above .",
    "all path edges and highway edges are marked as participating in the mst candidate .",
    "all spoke edges not belonging to stars @xmath360 are marked as not participating in the mst candidate .",
    "note that the weights of all the edges except those connecting @xmath128 to its immediate neighbors in @xmath334 do not depend on the particular input instance at hand .",
    "similarly , for all edges except the spoke edges belonging to @xmath361 the indicator variable for participating in the mst candidate does not depend on the instance at hand .",
    "hence a constant number of rounds of communication between @xmath362 and their @xmath361 neighbors suffices for performing this assignment ; @xmath128 assigns its edges weights and indicator variables according to its input string @xmath363 , and needs to send at most a constant number of messages to each of its neighbors in @xmath334 , to notify it about the weight and the indicator variable of the spoke edge connecting them .",
    "( same argument holds for vertex @xmath187 ) .",
    "every vertex @xmath38 in the network , upon receiving the first message of algorithm @xmath344 , assigns the values defined by the edge weight function @xmath333 to its variables @xmath54 and the corresponding indicator variable @xmath98 as described above .",
    "( as discussed earlier , this does not require @xmath38 to know @xmath364 , as its assignment is identical under all weight functions @xmath333 , @xmath365 ) . from this point on",
    ", @xmath38 may proceed with executing algorithm @xmath344 for the mst verification problem .",
    "once algorithm @xmath344 terminates , vertex @xmath187 determines its output for the vector equality problem by stating that both input vectors are equal if and only if the mst verification algorithm verified that the given mst candidate is indeed a minimum spanning tree . by lemma [ finwe ]",
    ", the lighter edge of each pair @xmath341 , for @xmath276 , belongs to the mst ; thus , by the construction of the mst candidate and the weight assignment to the edges of @xmath180 the mst candidate forms a minimum spanning tree if and only if the input vectors @xmath223 for the vector equality problem are equal .",
    "hence the resulting algorithm correctly solves the given instance of the vector equality problem .",
    "combined with lemma [ l : eq - lb ] , we now have :    for every @xmath366 , any distributed algorithm for solving mst verification problem on the graphs of the family @xmath342 requires @xmath224 time .",
    "[ cl : sqrtn2 ] any distributed algorithm for the mst verification problem requires @xmath367 time on some @xmath4-vertex graphs of diameter @xmath368 .    theorem [ thm : lower - bound - time ] follows .",
    "we prove a message complexity lower bound of @xmath369 on the _ spanning tree ( st ) verification _ problem , which is a relaxed version of the mst verification problem defined as follows .",
    "given a connected graph @xmath65 and a subgraph @xmath48 ( referred to as the _",
    "st candidate _ ) , we wish to decide whether @xmath48 is a spanning tree to be a spanning forest of @xmath3 . ] of @xmath3 ( not necessarily of minimal weight ) .",
    "clearly , a lower bound on the _",
    "st verification _ problem also applies to the _ mst verification _ problem . since spanning tree verification is independent of the edge weights , for convenience we consider unweighted networks throughout this lower bound proof .",
    "the case of single source node is easy . here , given a @xmath3 with spanning tree @xmath48 , if the execution does not send a message on some edge @xmath370 , then we simply break @xmath45 to two edges by adding another vertex in the middle of @xmath45 .",
    "this brings us to the case where @xmath48 is no longer spanning , but the execution ( and hence the output of nodes ) remains the same .    in",
    "what follows , we consider the somewhat more difficult case where all nodes start the execution at the same time .",
    "we begin with a few definitions .",
    "recall that a _ protocol _",
    "is a local program executed by all vertices in the network . in every step ,",
    "each processor performs local computations , sends and receives messages , and changes its state according to the instructions of the protocol .",
    "a protocol achieving a given task should work on every network @xmath3 and every st candidate @xmath48 .",
    "following @xcite , we denote the _ execution _ of protocol @xmath301 on network @xmath32 with st candidate @xmath48 by @xmath371 .",
    "the _ message history _ of an execution @xmath372 is a sequence describing the messages sent during the execution @xmath373 .",
    "consider a protocol @xmath301 , two graphs @xmath374 and @xmath375 over the same set of vertices @xmath33 , and two st candidates @xmath376 and @xmath377 for @xmath378 and @xmath379 respectively , and the corresponding executions @xmath380 and @xmath381 .",
    "we say that the executions are _ similar _ if their message history is identical .",
    "let @xmath382 be a graph ( together with an assignment @xmath383 of vertex identifiers ) , @xmath48 be a subgraph and let @xmath384 and @xmath385 be two of its edges .",
    "( see example in figure [ f : graph_g_mst ] . )",
    "let @xmath386 be some copy of @xmath387 , where the identifiers of the vertices in @xmath388 are not only pairwise distinct but also distinct from the given identifiers on @xmath33 .",
    "consider the following graphs @xmath389 and @xmath390 and the subgraph  @xmath391 .",
    "* graph @xmath389 is simply @xmath392 .",
    "the subgraph @xmath391 of @xmath389 is defined as the union of the two copies of @xmath48 , one in @xmath3 and the other in @xmath393 .",
    "see example in figure  [ f : graph_g2_mst ] .",
    "note that @xmath389 is not connected , hence it is not a legal input to our problem . *",
    "the graph @xmath390 is a `` cross - wired '' version of @xmath389 .",
    "formally , @xmath394 , where @xmath395 .",
    "( observe that for @xmath396 , @xmath391 is also a subgraph of @xmath390 . )",
    "see example in figure  [ f : graph_g2_e_mst ] .",
    "let @xmath301 be a protocol that correctly solves the st verification problem .",
    "fix @xmath3 to be some arbitrary graph , fix a copy @xmath393 of @xmath3 , fix a spanning tree @xmath48 of @xmath3 , and consider the execution of @xmath301 on either of the graphs @xmath397 and @xmath390 with the st candidates @xmath398 and @xmath391 , respectively .",
    "we stress that @xmath389 ( with candidate @xmath391 ) is not a valid input for the st ( or the mst ) verification problem since it is not connected .",
    "still , we can consider the execution @xmath399 , without requiring anything from its output .",
    "we show that in both executions each vertex sends and receives identical sequences of messages in each communication round of the protocol .",
    "note that at each round the messages sent by some vertex @xmath406 are dependent on @xmath406 s topological view ( neighbors of @xmath406 ) , @xmath406 s initial input ( its identity and the indicator variables of the edges incident to @xmath406 ) , and the set of messages sent and received by @xmath406 in previous communication rounds .",
    "denote by @xmath407 and @xmath408 executions @xmath409 and @xmath410 respectively . note that any vertex @xmath411 has identical topological view and identical initial input in both executions .",
    "vertex @xmath37 has identical initial input and identical number of neighbors in both executions .",
    "although the communication link connecting @xmath37 to @xmath38 in @xmath389 connects @xmath37 to @xmath412 in @xmath390 , vertex @xmath37 is initially unaware of this difference between the executions since it does not know the identifiers of its neighbors .",
    "( the same holds for vertices @xmath38 , @xmath413 and @xmath148 . ) the proof is by induction on @xmath187 , the number of communication rounds of protocol @xmath301 .",
    "* induction base : * for @xmath414 . in the first communication round ,",
    "the messages sent by each vertex depend solely on its topological view and initial input .",
    "let us analyze the sequence of messages sent by vertices in @xmath33 ( the vertices of graphs @xmath389 and @xmath390 that belong to the first copy of @xmath3 ) .",
    "following are the possible cases .",
    "* vertex @xmath415 : vertex @xmath406 has identical topological view and identical initial input in both execution , thus it sends identical sequences of messages in the first round of both executions . *",
    "vertex @xmath37 : as mentioned above , although in execution @xmath408 vertex @xmath37 is connected to @xmath412 instead of @xmath38 , it has no knowledge of this difference .",
    "thus @xmath37 sends identical sequences of messages over each of its communication links .",
    "the fact that no messages are sent over edge @xmath45 in execution @xmath407 , implies that in execution @xmath408 no message is sent by @xmath37 to its neighbor @xmath412 .",
    "thus , @xmath37 sends identical sequences of messages in the first communication round of both executions .",
    "* vertex @xmath38 : can be analyzed in the same manner as vertex @xmath37 .",
    "the above shows that vertices in @xmath33 send the same sequence of messages in the first communication round of both executions .",
    "the induction base claim follows by applying the same argument on vertices of @xmath388 .",
    "assume , towards contradiction , that there exists a protocol @xmath301 that correctly solves the st verification problem for every graph @xmath3 and st candidate @xmath48 , such that execution @xmath371 sends fewer than @xmath417 messages over edges from @xmath418 .",
    "for the rest of the proof we fix @xmath387 to be an arbitrary connected graph and denote the st candidate by @xmath48 .",
    "we take @xmath48 to be a spanning tree and not just any subgraph .",
    "( see figure [ f : graph_g_mst ] ) .      then by the assumption on @xmath301 , execution",
    "@xmath420 sends fewer than @xmath421 messages over edges from @xmath422 . hence there exist @xmath384 and @xmath423 such that @xmath424 and no message is sent over @xmath402 and @xmath403 in execution @xmath407 .",
    "consider the graph @xmath390 with st candidate @xmath391 as previously defined ( see figure [ f : graph_g2_e_mst ] ) .    by lemma [ lem_similarity ] , executions @xmath407 and @xmath425 are similar .",
    "note that @xmath426 , thus @xmath391 is not a spanning tree of @xmath390 ( since the two copies of @xmath3 contained in @xmath390 are connected solely by edges @xmath402 and @xmath403 ) .",
    "since @xmath301 correctly solves the st verification problem , the output of all vertices in @xmath408 is `` 0 '' ( i.e. , the given st candidate @xmath391 is not a spanning tree of the graph @xmath390 ) .    on the other hand , consider the execution @xmath427 with st candidate @xmath48 .",
    "note that @xmath373 is exactly the restriction of @xmath407 on the first copy of @xmath3 contained in @xmath389 .",
    "since @xmath389 contains two disconnected copies of @xmath3 the output of all vertices in execution @xmath407 will be identical to the output of the same vertices in @xmath373 ( since in both executions the vertices have identical topological view and the input variables contain identical values ) . since executions @xmath407 and @xmath408 are similar , the output of @xmath373 is `` 0 '' , in contradiction to the correctness of @xmath301 .",
    "b.  awerbuch .",
    "optimal distributed algorithms for minimum weight spanning tree , counting , leader election , and related problems . in _ proc .",
    "19th acm symp . on theory of computing ( stoc ) _ , 230240 , ny , 1987 .",
    "a.  das sarma , s.  holzer , l.  kor , a.  korman , d.  nanongkai , g.  pandurangan , d.  peleg , and r.  wattenhofer .",
    "distributed verification and hardness of distributed approximation . in _ proc .",
    "43th acm symp . on theory of computing ( stoc ) _",
    ", 2011 .",
    "a.  das sarma , d.  nanongkai , and g.  pandurangan .",
    "a tight unconditional lower bound on distributed random walk computation . in _ proc .",
    "30th acm sigact - sigops symp . on principles of distributed computing ( podc ) _ , 2011 ."
  ],
  "abstract_text": [
    "<S> this paper introduces the notion of distributed verification without preprocessing . </S>",
    "<S> it focuses on the minimum - weight spanning tree ( mst ) verification problem and establishes tight upper and lower bounds for the time and message complexities of this problem . </S>",
    "<S> specifically , we provide an mst verification algorithm that achieves _ simultaneously _ </S>",
    "<S> @xmath0 messages and @xmath1 time , where @xmath2 is the number of edges in the given graph @xmath3 , @xmath4 is the number of nodes , and @xmath5 is @xmath3 s diameter . on the other hand , we show that any mst verification algorithm must send @xmath6 messages and incur @xmath7 time in worst case .    </S>",
    "<S> our upper bound result appears to indicate that the verification of an mst may be easier than its construction , since for mst construction , both lower bounds of @xmath6 messages and @xmath7 time hold , but at the moment there is no known distributed algorithm that constructs an mst and achieves _ simultaneously _ </S>",
    "<S> @xmath0 messages and @xmath1 time . </S>",
    "<S> specifically , the best known time - optimal algorithm ( using @xmath8 time ) requires @xmath9 messages , and the best known message - optimal algorithm ( using @xmath10 messages ) requires @xmath11 time . on the other hand , </S>",
    "<S> our lower bound results indicate that the verification of an mst is not significantly easier than its construction .    </S>",
    "<S> * keywords : * distributed algorithms , distributed verification , labeling schemes , minimum - weight spanning tree . </S>"
  ]
}