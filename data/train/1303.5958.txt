{
  "article_text": [
    "the straight skeleton of a polygon @xmath8 is a straight line graph embedded in @xmath8 , formed by the traces of the vertices of @xmath8 when it is shrunk , each edge moving at the same speed and remaining parallel to its original position .",
    "( see  [ fig : mgdef ] . )    .3 , title=\"fig : \" ]    .3 , title=\"fig : \" ]    .3 , title=\"fig : \" ]    it has been known since at least the 19th century ; for instance , figures representing the straight skeleton can be found in the book by von peschka  @xcite .",
    "aichholzer et al .",
    "@xcite gave the first efficient algorithms for computing the straight skeleton , and presented it as an alternative to the medial axis having only straight - line edges .",
    "the straight skeleton has found numerous applications in computer science , for instance to city model reconstruction  @xcite , architectural modeling  @xcite , polyhedral surface reconstruction  @xcite , biomedical image processing  @xcite .",
    "it also has a direct application to cad , as it allows to compute offset polygons  @xcite .",
    "the straight skeleton has become a standard tool in geometric computing , and thus fast and robust software has been developed to compute it  @xcite .    the complexity of straight skeleton computation , however , is still very much open .",
    "the previously best known algorithms were the @xmath9-time algorithm by eppstein and erickson  @xcite , and the @xmath10-time randomized algorithm by cheng and vigneron  @xcite .",
    "the only known lower bound is @xmath11 , by a reduction from sorting  @xcite . in this paper",
    ", we give new subquadratic algorithms for computing straight skeletons .",
    "in particular , if all input coordinates are @xmath4-bit rational numbers , we give an @xmath12-time randomized algorithm for computing the straight skeleton of a polygon with @xmath2 holes .",
    "it is the first near - linear time algorithm for computing the straight skeleton of a simple polygon .",
    "eppstein and erickson  @xcite introduced _ motorcycle graphs _ so as to model the main difficulty of straight skeleton computation .",
    "we are given a set of @xmath13 motorcycles , each motorcycle having a starting point and a velocity .",
    "each motorcycle moves at constant velocity until it reaches the track left by another motorcycle , in which case it crashes .",
    "the resulting graph is called a motorcycle graph .",
    "( see  [ fig : mgss]a . )",
    "[ fig : mgss],title=\"fig : \" ]    .4 .",
    "[ fig : mgss],title=\"fig : \" ]    the motorcycle graph is a special case of the straight skeleton , where each motorcycle is modeled by a small and thin triangle .",
    "conversely , a polygon induces a motorcycle graph , where each motorcycle starts at a reflex vertex and moves with the same velocity as this vertex moves during the shrinking process .",
    "( see  [ fig : mgss]b . )",
    "cheng and vigneron  @xcite showed that computing the straight skeleton of a non - degenerate polygon reduces to computing this induced motorcycle graph , and a lower envelope computation ; huber and held extended this proof to degenerate cases  @xcite .",
    "the lower envelope computation can be done in @xmath14 expected time if @xmath8 has @xmath2 holes .    previously , the bottleneck of straight skeleton computation was the induced motorcycle graph computation .",
    "this is our main motivation for designing a faster motorcycle graph algorithm . in this paper",
    ", we give an algorithm for computing a motorcycle graph that runs in @xmath0 time , for any @xmath1 , improving on all previously known algorithms . here",
    "is a brief description of our algorithm . for each motorcycle",
    ", we maintain a tentative track , which may be longer than its actual track in the motorcycle graph .",
    "we also maintain a set of target points , which contains the endpoints of the tentative tracks that have been created earlier for this motorcycle , and that it has not reached yet .",
    "initially , the tentative tracks are empty , and then we try to extend them one by one , all the way to the destination point . if two tentative tracks cross , we retract them , by roughly halving the number of possible crossing points on each of them . after performing this halving , the tentative tracks do not intersect , and we can safely move the motorcycle that reaches the end of its tentative track first .",
    "then we try to extend the tentative track of this motorcycle to its next target point , and repeat the process .",
    "an example is given in appendix  [ sec : example ] .",
    "apart from obtaining better time bounds for straight skeleton computation , there are at least two other reasons for studying motorcycle graphs .",
    "first , huber and held  @xcite used the idea of computing the straight skeleton from its induced motorcycle graph to design and implement a practical straight skeleton algorithm .",
    "so it is important , even in practice , to get a better understanding of motorcycle graph computation .",
    "another motivation for studying motorcycle graphs is a direct application to computer graphics , for quad mesh partitioning  @xcite .",
    "some of our results make no particular assumptions on the input , but we also present a few results where we assume that the input coordinates are @xmath4-bit rational numbers .",
    "we believe that this assumption is sufficient for most applications .",
    "for instance , in the applications mentioned above , it is hard to imagine that the input polygons would have features smaller than 1 nm , and size larger than 1000 km , so 64-bit integers should be more than sufficient .",
    "the main novelty in this paper is our algorithm for computing motorcycle graphs ( section  [ sec : algorithm ] ) .",
    "this algorithm is essentially different from the two previous algorithms  @xcite that both simulate the construction in chronological order .",
    "our algorithm , on the other hand , does not construct the motorcycle tracks in chronological order : it may move some motorcycle to its position at time @xmath15 , and then later during the execution of the algorithm , move another motorcycle to its position at an earlier time @xmath16 .",
    "( we give one such example in appendix  [ sec : example ] . )",
    "this answers an open question by eppstein and erickson  ( * ? ? ?",
    "* end of section 5 ) , who asked whether the running time can be improved by relaxing the chronology of the events .",
    "our algorithm uses two auxiliary data structures , one for ray shooting , and another for halving queries .",
    "given a query segment on the supporting line of a motorcycle , a halving query returns a splitting point on this segment such that there are roughly the same number of intersections with other supporting lines on both sides .",
    "( see section  [ sec : notation ] . )",
    "the implementation of these data structures in different settings lead to different time bounds .    for all our results ,",
    "we use the standard real - ram model  @xcite , that allows to perform arithmetic operations exactly on arbitrary real numbers .",
    "but for some of our results , we make the assumption that all input coordinates are @xmath4-bit rational numbers .",
    "it has two advantages : it yields better time bounds , and allows us to handle the straight skeleton of degenerate polygons .",
    "this improvement comes from the fact that , for bounded precision input , two distinct crossing points between the supporting lines of two pairs of motorcycles are at distance @xmath17 from each other .",
    "it allows us to use a simpler halving scheme : instead of halving a segment according to the number of intersection points , we use the midpoint according to the euclidean distance .",
    "( see section  [ sec : bpmg ] and  [ sec : prelss ] . )",
    "[ [ arbitrary - precision - input . ] ] arbitrary precision input .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    for our first set of results , the input coordinates are arbitrary real numbers , on which we can perform exact arithmetic operations . in this case",
    ", our new algorithm computes a motorcycle graph in @xmath0 time ( theorem  [ th : general ] ) .",
    "this improves on the two subquadratic algorithms that were known before : the @xmath9-time algorithm by eppstein and erickson  @xcite , which was first published in 1998 , and the @xmath18-time algorithm by cheng and vigneron  @xcite , which first appeared in 2002 .",
    "we also give , in section  [ sec : coriented ] , an @xmath19-time algorithm for the case of @xmath20-oriented motorcycles , where the velocities take only @xmath20 different directions .",
    "this improves on the algorithm by eppstein and erickson  @xcite , which runs in @xmath0 time when @xmath21 .",
    "our last result with arbitrary precision input is an @xmath22 expected time algorithm for computing the straight skeleton of a polygon with @xmath13 vertices and @xmath2 holes .",
    "( this result does not hold for a degenerate polygon where two reflex vertices may collide during the shrinking process , as in  [ fig : degenerate ] . )",
    ".3 , title=\"fig : \" ]    .3 , title=\"fig : \" ]    .3 , title=\"fig : \" ]    it improves on the algorithm by cheng and vigneron  @xcite which runs in @xmath23 expected time .",
    "it also improves on the @xmath9 time bound of the algorithm by eppstein and erickson  @xcite , but their algorithm is deterministic and applies to degenerate cases .    [ [ bounded - precision - input . ] ] bounded precision input .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    the following results hold when all input coordinates are @xmath4-bit rational numbers .",
    "there has been recent interest in studying computational geometry problems under a bounded precision model ( the word ram ) , for instance the computation of delaunay triangulations , convex hulls , polygon triangulation and line segment intersections  @xcite .",
    "we first show in section  [ sec : bpmg ] that a motorcycle graph can be computed in @xmath24 time if the motorcycles move within a simple polygon , starting from its boundary .",
    "the only other non - trivial cases where we know how to compute a motorcycle graph in near - linear time seem to be the case where all velocities have positive @xmath25-coordinate , which can be solved in @xmath26 time by plane sweep , the case of a constant number of different velocity vectors  @xcite , or a constant number of directions ( section  [ sec : coriented ] ) .",
    "then in section  [ sec : bpss ] , we show that the straight skeleton of a polygon with @xmath13 vertices and @xmath2 holes can be computed in @xmath12 expected time .",
    "this result still holds in degenerate cases .",
    "so with bounded - precision input , and if we allow randomization , it improves on the @xmath9-time algorithm by eppstein and erickson  @xcite .",
    "when @xmath27 , it also improves on the @xmath10-time algorithm by cheng and vigneron  @xcite , which can not handle all degenerate cases .",
    "in particular , our algorithm runs in expected @xmath28 time when @xmath29 , so it is the first near - linear time algorithm for computing the straight skeleton of a simple polygon . the previously best known algorithms run in @xmath7 time in the worst case  @xcite .",
    "for any two points @xmath30 , we denote by @xmath31 the line segment between @xmath32 and @xmath33 . unless specified otherwise , @xmath31 is a closed segment .",
    "the _ relative interior _ of @xmath31 is the open segment @xmath34 .",
    "we say that two segments _ cross _ if their relative interiors intersect .",
    "the motorcycles are numbered from @xmath35 to @xmath13 .",
    "each motorcycle @xmath36 has a _ starting point _",
    "@xmath37 , moves with constant velocity @xmath38 , and has a _ destination point _ @xmath39",
    "that lies in the ray @xmath40 .",
    "( see  [ fig : notation]a . )    .55 , title=\"fig : \" ]    .35 , title=\"fig : \" ]    when @xmath41 , we denote by @xmath42 the time when motorcycle @xmath36 reaches @xmath32 , so @xmath43 . the _ supporting line _",
    "@xmath44 of motorcycle @xmath36 is the line through @xmath37 with direction @xmath38 .",
    "each motorcycle @xmath36 starts at @xmath37 at time 0 , and moves at velocity @xmath38 until it meets the track left by another motorcycle and crashes , or it reaches @xmath39 and stops .",
    "so motorcycle @xmath36 crashes if it reaches a point @xmath32 such that @xmath45 , for some motorcycle @xmath46 that has not crashed or stopped earlier than @xmath47 . if motorcycle @xmath36 crashes , we denote by @xmath48 the point where it crashes , called the _ crashing point_. ( see  [ fig : notation]b . ) otherwise , @xmath36 reaches @xmath39 , and we set @xmath49 .",
    "the _ trajectory _ of @xmath36 is the segment @xmath50 ; in other words it is the track of @xmath36 in the motorcycle graph .    in the original motorcycle graph problem ,",
    "the destination point @xmath39 is at infinity in direction @xmath38 .",
    "we can handle this case by computing a bounding box that includes all the vertices of the arrangement of the supporting lines @xmath44 , @xmath51 , and choosing as destination points the intersections of the rays @xmath40 with the bounding box .",
    "the bounding box can be computed in @xmath52 time as any extreme vertex in the arrangement is the intersection of two lines with consecutive slopes .    unless specified otherwise , we make the following general position assumptions .",
    "no two motorcycles share the same supporting line , or have parallel supporting lines .",
    "no three supporting lines are concurrent .",
    "no point @xmath53 lies on @xmath54 if @xmath55 .",
    "no two motorcycles reach the same point at the same time .",
    "( we make these assumptions so as to simplify the description of the algorithm and the proofs , but our results still hold in degenerate cases . )    the _ crossing point _",
    "@xmath56 is the intersection between @xmath44 and @xmath54 , and thus @xmath57 .",
    "the _ size _ @xmath58 of a segment @xmath31 is the number of crossing points @xmath56 that lie in @xmath31 .",
    "( see  [ fig : size ] . )",
    "is @xmath59 .",
    "point @xmath2 is a possible result @xmath60 of a halving query @xmath61 with @xmath62 .",
    "[ fig : size ] ]    we will need a data structure to answer _ halving queries _ : given a query @xmath63 where @xmath30 are points on the supporting line @xmath44 , find a point @xmath64 such that @xmath65 and @xmath66 , for a constant @xmath67 . in addition",
    ", we require that @xmath2 is not a crossing point , and that both @xmath68 and @xmath69 are strictly smaller than @xmath58 if @xmath70 .",
    "in this section , we present our algorithm for computing motorcycle graphs , as well as its proof of correctness and analysis .",
    "an example of the execution of this algorithm on a set of 4 motorcycles is given in appendix  [ sec : example ] .",
    "our algorithm maintains , for each motorcycle @xmath36 , a _ confirmed track _",
    "@xmath71 , and a _ tentative track _",
    "@xmath72 , such that @xmath73 and @xmath74 .",
    "so the tentative track is at least as long as the confirmed track . as we will show in the next section ,",
    "the confirmed track is a subset of the trajectory , so we have @xmath75 at any time during the execution of the algorithm .",
    "the tentative track , however , may go beyond @xmath48 .",
    "( see appendix  [ sec : example ] . )",
    "our algorithm will ensure that no two tentative tracks cross .",
    "we keep all the tentative tracks in a ray shooting data structure , so that we can enforce this invariant by checking for intersection each time we try to extend a tentative track .",
    "this data structure returns the first tentative track hit by a query ray @xmath76 , if any .",
    "we also build a data structure to answer halving queries , which will be used to shorten tentative tracks and keep them disjoint .",
    "our algorithm builds the motorcycle graph by extending the confirmed tracks until they form the whole motorcycle graph .",
    "we may also update the tentative track of a motorcycle when we extend its confirmed track .",
    "a set of _ target points _ is associated with each motorcycle @xmath36 .",
    "in particular , we maintain in a stack @xmath77 the set of target points that lie beyond the confirmed track of motorcycle @xmath36 , thus @xmath78 .",
    "in other words , @xmath77 records the target points that motorcycle @xmath36 has not reached yet .",
    "( see  [ fig : tracks ] . )    ,  ( m ) .",
    "the confirmed tracks are solid , and the tentative tracks are dashed . for motorcycle 1 ,",
    "the confirmed track and the tentative track go to @xmath79 .",
    "the stack @xmath80 only records @xmath81 . for motorcycle 2",
    ", the confirmed track ends at @xmath82 , the tentative track ends at @xmath83 , and @xmath84 . for motorcycle 3",
    ", we have @xmath85 , @xmath86 , and @xmath87 . for motorcycle 4 , we have @xmath88 , @xmath89 , and @xmath90 . [",
    "fig : tracks ] ]    the stack @xmath77 is ordered from @xmath91 to @xmath39 .",
    "we denote by @xmath92 its first element , so @xmath92 is the target point in @xmath77 that is closest to @xmath91 . at the beginning , we set @xmath93 for all @xmath36 .",
    "new target points will be created in case ( 3b ) of our algorithm , as described below .",
    "if motorcycle @xmath36 has neither crashed nor stopped , then its tentative track ends at the first target point in @xmath77 , so @xmath94 .",
    "otherwise , the tentative track and the confirmed track are the same , thus @xmath95 .",
    "so after a motorcycle has crashed or stopped , the ray shooting data structure records its confirmed track .    an _ event _ @xmath96 happens when a motorcycle @xmath36 reaches a target point @xmath32",
    "we process events one by one , and while an event is being processed , new events may be generated .",
    "after an event has been processed , we process the earliest available event . as @xmath94 is the closest target point to @xmath36 in @xmath77 , it means that we always process the event @xmath97 such that @xmath98 is smallest . note that it does not imply that our simulation is done in chronological order : when we process an event @xmath97 , we may create a new event @xmath99 such that @xmath100 .",
    "( see appendix  [ sec : example ] . )",
    "we record in a priority queue @xmath101 the event @xmath97 for each motorcycle @xmath36 that has not crashed or stopped .",
    "an event with earlier time @xmath98 has higher priority . as @xmath94 , we can update the event queue @xmath101 in @xmath4 time each time a stack @xmath77 is updated .",
    "so we can find the next available event in @xmath4 time .",
    "the first @xmath13 events are the events @xmath102 , @xmath51 , and occur at time @xmath103 .",
    "we process these @xmath13 events in an arbitrary order .",
    "we now explain how to process an event @xmath97 . to avoid confusion , for any motorcycle @xmath46",
    ", we use the notation @xmath104 to denote the endpoints of its confirmed and tentative track just before processing this event , and we use the notation @xmath105 for their position just after processing this event .",
    "we first extend the confirmed track of motorcycle @xmath36 to @xmath106 , thus @xmath107 .",
    "we also delete @xmath106 from @xmath77 .",
    "we are now in one of the following cases :    * if @xmath108 , then motorcycle @xmath36 stops . in order to avoid processing irrelevant events in the future , we remove @xmath77 from @xmath101 . *",
    "if @xmath106 is a crossing point @xmath56 that lies in the confirmed track of @xmath46 ( that is , @xmath109 ) , then @xmath36 crashes at @xmath106 .",
    "so we remove @xmath77 from @xmath101 .",
    "* otherwise , we try to extend the tentative track to the next target point @xmath110 .",
    "so we perform a ray shooting query with ray @xmath111 , which gives us the first track intersected by @xmath112 , if any . * * if @xmath112 does not cross any track , then @xmath113 , and we do not need to do anything else to handle this event . *",
    "* otherwise , let @xmath46 be the result of the ray - shooting query , so @xmath114 is the first track hit by segment @xmath112 , starting from @xmath106 .",
    "we shorten the tentative track of @xmath36 , which means that we insert the new target point @xmath56 into @xmath77 , as well as the point @xmath115 obtained by a halving query on @xmath116 .",
    "if the crossing point @xmath56 does not lie in the confirmed track of @xmath46 , that is , if @xmath117 , then we also shorten the tentative track of @xmath46 , so we insert @xmath56 into @xmath118 , and we insert @xmath119 into @xmath118 .",
    "after applying the rules above , we update the ray shooting data structure ( if needed ) , and we move to the next available event .",
    "initially , we create the target points @xmath53 for @xmath51 . after this",
    ", we create new target points only in case ( 3b ) of our algorithm .",
    "there are two types of such target points : the crossing points @xmath56 obtained by ray - shooting , and the points obtained by halving queries .",
    "we call @xmath120-targets the first type of target points , and @xmath2-targets the latter . by our assumption that the result of a halving query is not a crossing point ,",
    "a target point can not be both a @xmath2-target and a @xmath120-target .",
    "we need the following lemma . remember that we say that two segments cross if their relative interiors intersect .    [ lem : invariant ] during the course of the algorithm , no two tentative tracks cross .    for sake of contradiction , assume that two tentative tracks cross during the course of the algorithm . let @xmath97 be the first event that generates such a crossing , so just before processing this event , the tentative tracks @xmath114 , @xmath121 do not cross , and there is a crossing among the tracks @xmath122 .",
    "we must be in case ( 3 ) , because we do not extend any tentative track in cases ( 1 ) and ( 2 ) .",
    "besides , we only extend the track of motorcycle @xmath36 in case ( 3 ) .",
    "so there must be another motorcycle @xmath123 such that @xmath124 crosses @xmath125 .    in case ( 3a )",
    ", the segment @xmath112 obtained by ray shooting does not cross any tentative track @xmath114 , @xmath126 , and since @xmath113 , then the new portion @xmath127 of the track does not cross any other tentative track .",
    "the same is true in case ( 3b ) , because @xmath128 is in @xmath116 , where track @xmath46 is the first track hit by @xmath112 .",
    "so we just proved that , in any case , the new portion @xmath127 of the track does not cross any track @xmath114 , @xmath126 , and in particular , @xmath127 does not cross @xmath125 .    by our assumption , we also know that @xmath125 can not cross @xmath72 .",
    "so the only remaining possibility is that @xmath125 crosses @xmath129 at @xmath106 .",
    "then @xmath106 is the crossing point @xmath130 .",
    "this point @xmath131 can not be in the confirmed track @xmath132 , because that would be case ( 2 ) of our algorithm , and we showed that we are in case ( 3 ) . since @xmath130 is a @xmath120-target of @xmath36 , and it does not lie in the confirmed track of @xmath133 , then it must have been inserted at the same time in @xmath77 and @xmath134 while processing a previous event . since @xmath130 is not on the confirmed track of @xmath133 , then it must still be in @xmath134 .",
    "so the tentative track @xmath125 can not contain @xmath130 in its relative interior , a contradiction .",
    "we want to argue that our algorithm computes the motorcycle graph correctly .",
    "so assume it is not the case .",
    "as our algorithm moves motorcycles forward until they either reach their destination point or crash , it could only fail if during the execution of our algorithm , the confirmed track of at least one motorcycle @xmath36 goes beyond the point @xmath48 where it is supposed to crash in the motorcycle graph .",
    "let us consider the event @xmath97 that is first processed by our algorithm , such that motorcycle @xmath36 goes beyond @xmath48 .",
    "so @xmath48 is in the segment @xmath135 .",
    "let @xmath46 denote the motorcycle that @xmath36 crashes into , in the ( correct ) motorcycle graph , so @xmath136 .",
    "when we process @xmath97 , in the current graph constructed by our algorithm , motorcycle @xmath46 can not have reached @xmath137 , because it would mean that the tentative tracks @xmath72 and @xmath138 are crossing at @xmath136 , which is impossible by lemma  [ lem : invariant ] .",
    "we now rule out the case where , when our algorithm processes @xmath97 , motorcycle @xmath46 has already crashed into some motorcycle @xmath133 in the graph constructed by the algorithm .",
    "( see  [ fig : correctness2 ] . ) for sake of contradiction , assume it did happen .    ]    * if we had @xmath139 , then @xmath56 would have been created as a @xmath120-target for @xmath46 earlier .",
    "at this point , @xmath36 had not gone past @xmath56 , because @xmath97 is the first such event .",
    "as @xmath140 , the algorithm would have moved @xmath46 to @xmath56 before @xmath36 moves further , and thus @xmath46 would not crash at @xmath56 , a contradiction .",
    "* thus we must have @xmath141 . as @xmath106 is beyond @xmath136 , and tentative tracks",
    "can not cross , we must have @xmath142 .",
    "so @xmath46 crashed into @xmath133 at @xmath143 .",
    "as in the correct motorcycle graph , @xmath46 does not crash into @xmath133 , it means that the algorithm has already moved @xmath133 past its ( correct ) crashing point , which contradicts our assumption that @xmath97 was the first such event .",
    "we just proved that @xmath46 has not stopped or crashed when the algorithm processes event @xmath97 , so at this point there should be an event @xmath144 in the queue . by lemma  [ lem : invariant ] , the tracks @xmath72 and @xmath114 can not cross , so we must have @xmath145 .",
    "( see  [ fig : correctness ] . )    ]    it implies that @xmath146 .",
    "but since @xmath36 crashes into @xmath46 in the ( correct ) motorcycle graph , we must have @xmath147 , thus @xmath148 . as @xmath149 , we have @xmath150 , thus @xmath151 . but this is impossible , because our algorithm always processes the earliest available event , so it would have processed @xmath144 rather than @xmath97 .",
    "our algorithm uses two auxiliary data structures : for answering halving queries , and for ray shooting .",
    "the running time of our algorithm depends on their preprocessing time and query time .",
    "let @xmath152 denote an upper bound on the preprocessing time of these two data structures , and let @xmath153 denote an upper bound on the time needed for a query or update  so we can answer a ray - shooting query or a halving query in time @xmath153 , and we can update the ray shooting data structure in time @xmath153 .",
    "we now prove the following result :    [ th : analysis ] we can compute a motorcycle graph of size @xmath13 in time @xmath154 .    each time we handle an event , we perform at most two halving queries , one ray - shooting query , and we may update two tentative tracks in the ray - shooting data structure .",
    "we also pay an @xmath4 time overhead to update the priority queue @xmath101 .",
    "so after preprocessing , the running time will be at most the number of events times @xmath155 .",
    "thus we only need to argue that our algorithm processes a total of @xmath52 events .",
    "in fact , at each event we process , a motorcycle reaches a target point , so we only need to show that @xmath52 target points are created during the course of the algorithm .",
    "initially , we create @xmath156 target points , which are @xmath53 for @xmath51 . after this , we only create new target points in case ( 3b ) of the algorithm . in this case",
    ", we create one @xmath120-target , and at most two @xmath2-targets obtained by halving .",
    "thus we only need to bound the number of @xmath120-targets . at the end of the algorithm ,",
    "some of these @xmath120-targets @xmath56 correspond to an actual crash , with motorcycle @xmath36 crashing into @xmath46 , or @xmath46 crashing into @xmath36 .",
    "in any case , there are at most @xmath13 such @xmath120-targets .",
    "we need to consider the other @xmath120-targets , that do not correspond to an actual crash . in this case , either motorcycle @xmath36 or @xmath46 does not reach @xmath56 , so at the end of the computation , @xmath56 must appear in the stack @xmath77 or @xmath118 of target points that have not been reached by motorcycle @xmath36 or @xmath46 , respectively .",
    "thus , in order to complete the proof of theorem  [ th : analysis ] , we only need the following lemma .",
    "[ lem : targets ] at the end of the execution of our algorithm , for any motorcycle @xmath36 , the number of @xmath120-targets in @xmath77 is @xmath4 .    in this proof",
    ", we only consider the status of the stack @xmath77 at the end of the algorithm , and we assume that it contains more than one @xmath120-target .",
    "we denote by @xmath157 the @xmath120-targets in @xmath77 , in reverse order , so @xmath158 is a subsequence of @xmath77 , where @xmath159 is closest to @xmath48 and @xmath160 is closest to @xmath39 .    each target @xmath161",
    "was created in case ( 3b ) of our algorithm . at the same time , an @xmath2-target @xmath162 was created by a halving query using another target point @xmath163 . as the points @xmath161 , @xmath164 are in @xmath77 , motorcycle @xmath36 never reaches these points during the course of the algorithm , so @xmath160 and @xmath165 must have been created first , then @xmath166 and @xmath167  and finally @xmath159 and @xmath168 .    for any @xmath169 ,",
    "as @xmath161 is created after @xmath170 , and these two points are created when motorcycle @xmath36 reaches @xmath163 and @xmath171 , respectively , it implies that @xmath171 is in @xmath172 .",
    "we also know that @xmath170 lies in @xmath173 , because @xmath170 appears after @xmath161 in @xmath77 .",
    ", @xmath164 is a sequence of nested segments , that is , we have @xmath175 for all @xmath176 . more precisely :    * if @xmath177 is in @xmath77 , then @xmath178 , because @xmath161 is created after @xmath177 , and motorcycle @xmath36 never reaches @xmath177 .",
    "( see  [ fig : targets1 ] . ) * if @xmath177 is not in @xmath77 , then @xmath179 .",
    "( see  [ fig : targets2 ] . )",
    "it can be proved as follows .",
    "as @xmath177 is created at the same time as @xmath170 , then @xmath161 is created after @xmath177 .",
    "so @xmath161 must have been created after motorcycle @xmath36 reaches @xmath177 , otherwise we would have @xmath180 , and since motorcycle @xmath36 reaches @xmath177 later , @xmath161 would not be in @xmath77 . as @xmath161 is created after motorcycle @xmath36 reaches @xmath177 , we must have @xmath181 .    ,",
    "first case.[fig : targets1 ] ]    , second case.[fig : targets2 ] ]    thus @xmath174 is contained in either @xmath182 or @xmath183 , and since @xmath184 , it follows that the size @xmath185 decreases exponentially when @xmath46 increases from 1 to @xmath186 .",
    "as @xmath187 contains @xmath188 and @xmath189 , we have @xmath190 .",
    "in addition , @xmath191 , so we must have @xmath192 .",
    "our algorithm , presented in section  [ sec : algorithm ] , requires two auxiliary structures .",
    "the first one is simply a ray - shooting data structure . as",
    "ray shooting is a standard operation in computational geometry , we will be able to directly use known data structures .",
    "the second data structure we need is for answering halving queries .",
    "we show below how to construct efficient data structures for this type of queries , and the corresponding time bounds for our motorcycle graph algorithm .",
    "in this section , we present the auxiliary data structures for the most general case , as presented in section  [ sec : notation ] .",
    "so motorcycles have arbitrary starting position , destination point and velocity .    for ray shooting",
    ", we can directly use a data structure by agarwal and matouek  @xcite , which requires preprocessing time @xmath0 , with update and query time @xmath193 , for any @xmath1 .    for halving queries",
    ", we use known range searching data structures and parametric search , as in the work of agarwal and matouek on ray shooting : our problem is an optimization version of range counting in an arrangement of lines , so we obtain the same bounds  ( * ? ? ?",
    "* section 3.1 ) .",
    "[ lem : halving ] given the @xmath13 supporting lines @xmath194 , we can construct a data structure with @xmath0 preprocessing time and @xmath193 query time that answers the following queries @xmath63 .",
    "assume there are @xmath133 crossing points @xmath56 on @xmath31 .",
    "then we return the median crossing point and the next : the @xmath195th and the @xmath196th such crossing point , in the ordering from @xmath32 to @xmath33 along @xmath31 .    with the two auxiliary data structures above ,",
    "theorem  [ th : analysis ] yields the following result .",
    "[ th : general ] a motorcycle graph can be computed in @xmath0 time , for any @xmath1 .",
    "it should be possible to replace the @xmath197 factor in the bounds of lemma  [ lem : halving ] with a polylogarithm using known range searching techniques  @xcite , because we only need a static data structure for halving queries , but in any case we need a dynamic data structure for ray shooting queries , so it would not improve our overall time bounds .",
    "we consider the special case where motorcycles can only take @xmath20 different directions @xmath198 .",
    "eppstein and erickson gave an @xmath0-time algorithm when @xmath21 .",
    "we show that with appropriate auxiliary data structures , we can solve this case in time @xmath28 . in the following",
    ", we do not assume that @xmath21 , so our time bounds will also have a dependency on @xmath20 .",
    "[ cor : coriented ] we can compute a @xmath20-oriented motorcycle graph in @xmath199 time .",
    "we use the following data structures , and then the result follows from theorem  [ th : analysis ] .    [ [ ray - shooting - data - structures . ] ] ray shooting data structures .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a first approach to answer our ray shooting queries is to use @xmath20 instances of a data structure for vertical ray shooting in a planar subdivision .",
    "several data structures are known for this problem  @xcite , we use a data structure by cheng and janardan  @xcite that takes @xmath200 time per update and @xmath4 time per query .",
    "so overall , we get @xmath201 with the terminology of theorem  [ th : analysis ] .",
    "alternatively , we can use @xmath202 instances of a data structure for vertical ray shooting among horizontal segments .",
    "each data structure is used to answer ray shooting queries with a given direction , into segments with another direction : we just need to change the two coordinate axis to these two directions . using a recent result by giyora and kaplan  @xcite",
    ", we obtain @xmath203 .    [",
    "[ halving - queries . ] ] halving queries .",
    "+ + + + + + + + + + + + + + + +    our data structure for halving queries simply consists of a sorted list of motorcycles for each direction .",
    "so for each @xmath204 , we have an array @xmath205 of the motorcycles with direction @xmath206 , sorted according to the intercept of their supporting lines with a line orthogonal to @xmath206 .",
    "we now explain how to answer a halving query @xmath207 .    without loss of generality ,",
    "assume @xmath44 has direction @xmath208 . for each direction",
    "@xmath206 , @xmath209 , the subset of motorcycles whose supporting lines cross @xmath31 appear in consecutive positions in @xmath205 .",
    "we can find the first and the last index of these lines in @xmath4 time by binary search .",
    "so we obtain all the arrangement vertices in @xmath31 in @xmath210 sorted subarrays .",
    "we then compute the median @xmath211 of each such subarray @xmath212 , and the median of these points @xmath211 weighted by the number of points @xmath213 in the corresponding subarray .",
    "this gives a halving point @xmath60 with @xmath214 .",
    "the median of each subarray can be found in @xmath215 time , and their weighted median in @xmath216 time  @xcite , so the query time is dominated by the @xmath20 binary searches .",
    "thus , we can answer halving queries in @xmath217 time .",
    "the data structure for answering halving queries in section  [ sec : general ] is quite involved . in practice",
    ", one would rather implement halving queries by simply halving the euclidean length @xmath218 instead of approximately halving the number of crossing points .",
    "unfortunately , in the infinite precision model that is commonly used in computational geometry , this would cause the analysis of our algorithm in lemma  [ lem : targets ] to break down , because a stack of target points @xmath77 may have size @xmath219 at the end of the algorithm .",
    "such a counterexample would require the distance between consecutive target points in @xmath77 to become exponentially small near the crashing point , which does not seem likely to happen in practice .",
    "to formalize this idea , we make the assumption that all input numbers ( the coordinates of the starting points , the destination points , and the velocities ) are rational numbers , whose numerator and denominator are in @xmath220 for some integer @xmath221 . in other words ,",
    "the input numbers are @xmath221-bit signed integers .",
    "we still assume that arithmetic operations between two numbers can be performed in constant time .",
    "this model also allows us to handle the case where input coordinates are @xmath221-bit rational numbers , that is , rational numbers with @xmath221-bit numerator and denominator ; we just need to scale up each coordinate by a factor @xmath222 to obtain @xmath223-bit integers , losing only a constant factor in our time bounds . in the proofs below",
    "we assume the input numbers are integers , to simplify the presentation , but the results are stated with rational coordinates .",
    "as the input coordinates are @xmath221-bit integers , the coordinates of a crossing point @xmath56 are rational numbers obtained by solving a @xmath224 linear system , their denominator being the determinant @xmath225 .",
    "thus , the denominator is an integer between @xmath226 and @xmath227 .",
    "so any two distinct crossing points are at distance at least @xmath228 from each other .",
    "assume that we replace our halving operation , as defined in section  [ sec : notation ] , with halving the euclidean length .",
    "so @xmath60 is the midpoint of @xmath31 , which can be computed in constant time .",
    "then any nested sequence of segments obtained by successive halving , as in the proof of lemma  [ lem : targets ] , consists of @xmath229 such nested segments , because a segment @xmath174 of length smaller than @xmath228 can not contain another crossing point in its interior , and hence it can not be further subdivided .",
    "so the bound on the size of @xmath77 becomes @xmath229 , and we get the following result .    [",
    "th : bpmotorcycle ] if the input coordinates are @xmath221-bit rational numbers , we can compute a motorcycle graph in time @xmath230 , where @xmath231 is the time needed for updates or queries in the ray - shooting data structure .    for bounded - precision input",
    ", the bottleneck of our algorithm has thus become the ray shooting data structure , whose update and query time bound is @xmath193 in the most general case .",
    "therefore , we obtain a faster motorcycle graph algorithm if we are in a special case where faster ray - shooting data structures are known .",
    "one such case is ray - shooting in a connected planar subdivision , which can be done in @xmath200-time per update and query using a data structure by goodrich and tamassia  @xcite .",
    "we can use this data structure if , for instance , all motorcycles move inside a simple polygon @xmath8 , starting from its boundary .",
    "( so for all @xmath36 , @xmath232 , and @xmath37 is on the boundary of @xmath8 . )",
    "then we perform ray shooting in the union of the tentative tracks and the edges of @xmath8 , which form a connected subdivision .",
    "it yields the following time bound .",
    "[ th : bpsmotorcycle ] we can compute a motorcycle graph in time @xmath28 for @xmath13 motorcycles moving inside a simple polygon with @xmath156 vertices , starting on its boundary , and if the input has @xmath4-bit rational coordinates .",
    "in this section , we give new results on straight skeleton computation , using our new motorcycle graph algorithm .      as we mentioned in the introduction , the straight skeleton problem and the motorcycle graph problem",
    "are closely related .",
    "we now explain it in more details .",
    "consider the reflex ( non - convex ) vertices of a polygon @xmath8 .",
    "when we construct the straight skeleton of @xmath8 , these vertices move inward and may collide into edges , or other vertices .",
    "these events , called split events and vertex events , are the difficult part of straight skeleton computation , because they affect the topology of the shrinking polygon by splitting it , and because they are non - local : a reflex vertex may affect a chain of edges on the other side of the polygon .",
    "the other type of events , called edge events , where an edge shrinks to a point , are easily handled with a priority queue .",
    "so the interaction between reflex vertices is a crucial part in straight skeleton computation , and the motorcycle graph presented below helps to determine these interactions .",
    "the motorcycle graph _ induced _ by a polygon @xmath8 is such that each motorcycle starts at a reflex vertex , moves as the same velocity as the corresponding reflex vertex when we shrink @xmath8 , and stops if it reaches the boundary @xmath233 of @xmath8 .",
    "( see  [ fig : mgss ] . )",
    "if @xmath8 is degenerate , then two reflex vertices may collide and create a new reflex vertex . in this case",
    "we need to create a new motorcycle after the collision .",
    "( see  [ fig : degenerate ] . )",
    "so when two motorcycles collide in the induced motorcycle graph , we may have to create a new motorcycle  @xcite .",
    "our motorcycle graph algorithm , as described above , does not apply directly to this case , because the proof of lemma  [ lem : targets ] breaks down .",
    "( the reason is that @xmath77 may hold a linear number of target points at the end of the execution of the algorithm , due to the newly created motorcycles .",
    "see  [ fig : counterexample ] . )     holds a linear number of target points at the end of execution of the algorithm .",
    "the speed of the motorcycle at the bottom are adjusted so that @xmath160 is created first , then @xmath166  [fig : counterexample ] ]    in section  [ sec : bpss ] , we will explain how to compute these generalized motorcycle graphs efficiently on bounded - precision input .",
    "but the following theorem still holds in degenerate cases .",
    "[ th : reduction ] the straight skeleton of a polygon @xmath8 with @xmath13 vertices and @xmath2 holes can be computed in expected time @xmath14 if we know the motorcycle graph induced by the vertices of @xmath8 .    from the discussion above , and using our motorcycle graph algorithm from theorem  [ th : general ] , we obtain the following result .",
    "[ cor : motorgeneral ] we can compute the straight skeleton of a non - degenerate polygon with @xmath13 vertices and @xmath2 holes in @xmath234 time for any @xmath1 .",
    "we use the same bounded precision assumptions as in section  [ sec : bpmg ] , where the input coordinates are @xmath221-bit integers or , equivalently , @xmath221-bit rational numbers . similarly , to simplify the presentation",
    ", we use the integer model in the proofs , but we state the results in the rational model .",
    "thus , the coordinates of the vertices of the input polygon @xmath8 are @xmath221-bit integers .",
    "the supporting lines @xmath44 of the motorcycles are angle bisectors between two edges of the input polygon .",
    "in order to apply the same halving scheme as in section  [ sec : bpmg ] , where the euclidean length is used instead of the number of arrangement vertices , we need to argue that the separation between two vertices in this arrangement of bisectors can not be too small .",
    "this distance can be shown to be at least @xmath235 , where @xmath236 , by applying the separation bound by burnikel et al .",
    "so we obtain a result for induced motorcycle graphs that is analogous to theorem  [ th : bpmotorcycle ] .",
    "[ lem : bpinduced ] given a polygon @xmath8 whose input coordinates are @xmath221-bit rational numbers , we can compute the motorcycle graph induced by @xmath8 in time @xmath230 , where @xmath231 is the time needed for updates or queries in the ray - shooting data structure .    in the lemma statement above",
    ", we do not exclude degenerate cases .",
    "this is another advantage of this bounded precision model .",
    "as the argument in our analysis only relies on the separation bound between two distinct crossing points , and not on the number of motorcycles crossing a given segment , a newly created motorcycle does not affect our analysis as it still obeys the same separation bound : a newly created motorcycle still lies on the bisector of two input edges , though these two edges are not adjacent in the input polygon  @xcite .",
    "( see  [ fig : degenerate ] . )",
    "we still need to describe an efficient ray - shooting data structure .",
    "as our input polygon has @xmath2 holes , the boundary @xmath233 of @xmath8 together with the tentative tracks form a collection of @xmath237 disjoint simple polygons .",
    "we could directly use known ray - shooting data structures  @xcite , which can be made dynamic at the expense of an extra @xmath197 factor in the running time  @xcite . in the following ,",
    "we give a different approach , which leads to a better time bound when used as a subroutine of our algorithm .",
    "this approach takes advantage of the fact that the holes of @xmath8 are fixed ( only the tentative tracks are dynamic ) .",
    "we use a spanning tree with low crossing number , which is not a new idea in ray - shooting data structures  @xcite .",
    "we pick one point on the boundary of each hole of @xmath8 , and on the boundary of @xmath8 .",
    "we connect these @xmath237 points using a spanning tree @xmath238 with low stabbing number  @xcite , that is , a spanning tree such that any line crosses at most @xmath239 edges of @xmath240 .",
    "this tree can be computed in @xmath241 time  ( * ? ? ?",
    "* section 8) .",
    "we maintain a polygonal subdivision which is the overlay of @xmath8 with @xmath238 and the tentative tracks .",
    "so at each intersection between an edge of @xmath238 and an edge of @xmath8 or a tentative track , we split the corresponding edges and tracks at the intersection point . this subdivision @xmath242 is connected and has @xmath243 edges , and we maintain it in the ray shooting data structure by goodrich and tamassia  @xcite , which has @xmath200 update and query time .",
    "each time a tentative track is extended or retracted , as a tentative track intersects @xmath239 edge of @xmath238 , we can update the subdivision and the data structure by making @xmath239 updates in the ray shooting data structure . similarly ,",
    "when our motorcycle graph algorithm tries to extend a tentative track , we can find the first tentative track being hit by a query ray in @xmath244 time : we first perform a ray shooting query in @xmath242 , which takes @xmath200 time .",
    "if we hit an edge of @xmath238 , we make another ray shooting query starting at the hitting point of the previous query , and in the same direction .",
    "we repeat this process as long as the result of the query is an edge of @xmath238 , and by the low - stabbing number property , it may only happen @xmath239 times .",
    "overall , our ray shooting data structure has update and query time @xmath245 .",
    "so by theorem  [ th : reduction ] and lemma  [ lem : bpinduced ] , we obtain the following result . note that it still holds for degenerate input .",
    "[ th : bpss ] the straight skeleton of a polygon with @xmath13 vertices and @xmath2 holes , whose coordinates are @xmath4-bit rational numbers , can be computed in @xmath12 expected time .",
    "10    p.  agarwal and j.  erickson .",
    "geometric range searching and its relatives . in b.",
    "chazelle , j.  e. goodman , and r.  pollack , editors , _ advances in discrete and computational geometry _ , volume  23 , page 156 .",
    "american mathematical society , 1998 .",
    "p.  agarwal and j.  matouek .",
    "ray shooting and parametric search .",
    ", 22(4):794806 , 1993 .",
    "p.  agarwal and m.  sharir .",
    "applications of a new space - partitioning technique . , 9(1):1138 , 1993 .",
    "p.  agarwal and m.  sharir .",
    "ray shooting amidst convex polygons in 2d .",
    ", 21(3):508519 , 1996 .",
    "o.  aichholzer , f.  aurenhammer , d.  alberts , and b.  grtner . a novel type of skeleton for polygons .",
    ", 1(12):752761 , 1995 .",
    "l.  arge , g.  s. brodal , and l.  georgiadis .",
    "improved dynamic planar point location . in _ proc",
    "47th symposium on foundations of computer science _ , pages 305314 , 2006 .",
    "g.  barequet , m.  goodrich , a.  levi - steiner , and d.  steiner .",
    "straight - skeleton based contour interpolation .",
    "in _ proc .",
    "14th acm - siam symposium on discrete algorithms _ , pages 119127 , 2003 .",
    "k.  buchin and w.  mulzer .",
    "delaunay triangulations in _ o_(sort(_n _ ) ) time and more .",
    ", 58(2):6 , 2011 .    c.  burnikel , r.fleischer , k.  mehlhorn , and s.  schirra . a strong and easily computable separation bound for arithmetic expressions involving square roots . in _ proc",
    "8th acm - siam symposium on discrete algorithms _ , pages 702709 , 1997 .",
    "f.  cacciola . a cgal implementation of the straight skeleton of a simple 2d polygon with holes . in _",
    "2nd cgal user workshop _",
    "http://www.cgal.org/userworkshop/2004/straight_skeleton.pdf .",
    "t.  chan .",
    "optimal partition trees . , 47(4):661690 , 2012 .",
    "t.  chan and m.  patrascu .",
    "transdichotomous results in computational geometry , i : point location in sublogarithmic time .",
    ", 39(2):703729 , 2009 .",
    "b.  chazelle , h.  edelsbrunner , m.  grigni , l.  guibas , j.  hershberger , m.  sharir , and j.  snoeyink .",
    "ray shooting in polygons using geodesic triangulations .",
    ", 12(1):5468 , 1994 .",
    "cheng and r.  janardan .",
    "new results on dynamic planar point location . , 21(5):972999 , 1992 .",
    "cheng and a.  vigneron .",
    "motorcycle graphs and straight skeletons . , 47(2):159182 , 2007 .",
    "f.  cloppet , j.  oliva , and g.  stamon .",
    "angular bisector network , a simplified generalized voronoi diagram : application to processing complex intersections in biomedical images .",
    ", 22(1):120128 , 2000 .",
    "t.  cormen , c.  leiserson , r.rivest , and c.  stein . . the mit press , 3 edition , 2009 .",
    "d.  eppstein and j.  erickson . raising roofs , crashing cycles , and playing pool : applications of a data structure for finding pairwise interactions .",
    ", 22(4):569592 , 1999 .",
    "d.  eppstein , m.  goodrich , e.  kim , and r.  tamstorf .",
    "motorcycle graphs : canonical quad mesh partitioning . , 27(5):14771486 , 2008 .    j.  erickson . crashing motorcycles efficiently .",
    "http://www.cs.uiuc.edu/~jeffe/open/cycles.html , 1998 .",
    "p.  felkel and  .",
    "obdrlek . straight skeleton implementation . in _ proc .",
    "14th spring conference on computer graphics _ , pages 210218 , 1998 .",
    "y.  giyora and h.  kaplan .",
    "optimal dynamic vertical ray shooting in rectilinear planar subdivisions . in _ proc .",
    "18th acm - siam symposium on discrete algorithms _ , pages 1928 , 2007",
    ".    m.  goodrich and r.  tamassia .",
    "dynamic ray shooting and shortest paths in planar subdivisions via balanced geodesic triangulations .",
    ", 23(1):5173 , 1997 .",
    "j.  hershberger and s.  suri . a pedestrian approach to ray shooting : shoot a ray , take a walk .",
    ", 18(3):403431 , 1995 .",
    "s.  huber and m.  held .",
    "theoretical and practical results on straight skeletons of planar straight - line graphs . in _ proc .",
    "27th symposium on computational geometry _ , pages 171178 , 2011 .",
    "t.  kelly and p.  wonka .",
    "interactive architectural modeling with procedural extrusions .",
    ", 30(2):14:114:15 , 2011 .",
    "r.  laycock and a.  day .",
    "automatically generating large urban environments based on the footprint data of buildings . in _ proc .",
    "8th acm symposium on solid modeling and applications _ , pages 346351 , 2003 .",
    "j.  matouek .",
    "efficient partition trees . , 8:315334 , 1992 .",
    "j.  oliva , m.  perrin , and s.  coquillart .",
    "3d reconstruction of complex polyhedral shapes from contours using a simplified generalized voronoi diagram .",
    ", 15(3):397408 , 1996 .",
    "p.  palfrader , m.  held , and s.  huber . on computing straight skeletons by means of kinetic triangulations .",
    "in _ proc .",
    "20th european symposium on algorithms _",
    ", pages 766777 , 2012 .",
    "f.  preparata and m.  shamos . .",
    "springer , berlin , 1985 .",
    "g.  von peschka . .",
    "buschak &  irrgang , brnn , 1877 .",
    "in this section , we give the pseudocode of our algorithm .",
    "it is more detailed than the algorithm description in section [ sec : algorithm ] , and it can handle degenerate cases .",
    "the proof of correctness and the analysis are essentially the same as in section  [ sec : main ] , but they require a more detailed case analysis .    to deal with the degenerate cases where some supporting lines are concurrent , or two or more motorcycles reach a point at the same time , we record all the target points created so far in a dictionary data structure @xmath246 .",
    "we can implement @xmath246 as a balanced binary search tree , sorted in lexicographical order of the coordinates @xmath247 , which allows to retrieve a point in @xmath4 time .",
    "we associate three fields with each point @xmath32 stored in @xmath246 :    * a list @xmath248 records the motorcycles @xmath36 such that @xmath249 .",
    "so @xmath248 records all the motorcycles @xmath36 that could possibly reach @xmath32 , at a given point of the execution of our algorithm .",
    "the set @xmath248 itself is stored in a dictionary data structure , so that we can decide in @xmath4 time whether a motorcycle @xmath36 is in @xmath248 . *",
    "two motorcycles @xmath250 of @xmath248 such that @xmath251 are smallest .",
    "it will allow us to find out whether two motorcycles crash simultaneously at @xmath32 . *",
    "a flag @xmath252 which is set to false initially , and is set to true as soon as a confirmed track has reached @xmath32 , implying that any other motorcycle that reaches @xmath32 must crash .",
    "after the initialization stage , our algorithm handles repeatedly the earliest available event , according to the four cases ( 1 ) , ( 2 ) , ( 3a ) and ( 3b ) from section  [ sec : algorithm ] .",
    "lines  [ line : check_0 ] and  [ line : check_1 ] deal with case ( 1 ) and ( 2 ) .",
    "the condition @xmath253 corresponds to case ( 1 ) .",
    "the other two conditions check whether we are in case ( 2 ) . in particular ,",
    "condition @xmath254 means that at least one other motorcycle has reached @xmath32 , thus motorcycle @xmath36 crashes . with degenerate input , it is possible that another ( or several other ) motorcycle reaches @xmath32 at the same time as @xmath36 , in which case @xmath255 if @xmath96 is the first event involving @xmath32 that has been processed .",
    "the condition at line  [ line : check_1 ] checks whether we are in this situation .",
    "if so , @xmath36 must crash . as @xmath96 is the first event involving @xmath32 that we process",
    ", there is no earlier event in @xmath248 , so we can find another motorcycle that reaches @xmath32 at the same time in constant time using the second field associated with @xmath32 in @xmath246 .",
    "case ( 3a ) corresponds to a positive answer to the test at line [ line : check_2 ] .",
    "the condition @xmath256 detects whether the track of @xmath36 to the next target points hits any other track .",
    "the other condition @xmath257 and @xmath258 , checks for a boundary case , where @xmath92 falls on another tentative track .",
    "the test is positive if @xmath259 has already been identified as a target point of @xmath46 before . in this case",
    "we only extend the tentative track of @xmath36 , without doing any unnecessary halving .    line  [ line : check_3 ] branches to case ( 3b ) .",
    "similar to line [ line : check_2 ] , we do not perform an unnecessary halving operation when @xmath260 or @xmath261 .",
    "our pseudocode does not handle explicitly the case where two motorcycles have same supporting line .",
    "these cases can be easily handled by ad - hoc arguments  @xcite .",
    "one way of doing it is to insert additional target points at initialization . for each supporting line shared by several motorcycles , between any two consecutive motorcycles @xmath262 along this line that go toward each other ,",
    "we insert their potential collision point , that is , we insert into @xmath77 and @xmath118 the point @xmath32 such that @xmath263 . for each motorcycle",
    "@xmath36 along this line , if the first starting point @xmath264 in the ray @xmath40 is in @xmath265 , we also update @xmath39 to be @xmath264 .",
    "initialize the dictionary @xmath246 .",
    "set @xmath266 , @xmath267 and @xmath268 .",
    "insert @xmath37 and @xmath39 into @xmath246 ; insert motorcycle @xmath36 into @xmath269 and @xmath270 .",
    "initialize the event queue @xmath271 and the data structures for ray - shooting and halving .",
    "let @xmath96 be the earliest available event .",
    "set @xmath272 .",
    "pop @xmath92 from @xmath77 .",
    "[ line : check_1 ] motorcycle @xmath36 crashes . set @xmath273 . remove @xmath36 from @xmath274 for all @xmath275 .",
    "remove @xmath77 from @xmath271 .",
    "[ line : check_2 ] set @xmath277 .",
    "[ line : check_3 ] [ line : check_4 ] set @xmath277 .",
    "[ line : check_5 ] push @xmath259 into @xmath77 .",
    "push @xmath278 into @xmath77 . set @xmath279 .",
    "insert @xmath36 into @xmath280 and @xmath281 .",
    "[ line : check_6 ] push @xmath259 into @xmath118 .",
    "push @xmath282 into @xmath118 .",
    "set @xmath283 .",
    "insert @xmath46 into @xmath280 and @xmath281 .",
    "set @xmath284 .",
    "we give an example of the execution of our algorithm on a set of 4 motorcycles .",
    "( confirmed tracks are solid , and tentative tracks are dotted . )",
    "it demonstrates two features of our algorithm , that were mentioned above .",
    "* a tentative track may be longer than the final track in the motorcycle graph .",
    "for instance , the tentative track @xmath285 in ( b ) is longer than the final track @xmath286 in ( q ) .",
    "* our algorithm does not construct the motorcycle graph in chronological order .",
    "for instance , in ( i ) , motorcycle 2 is moved to @xmath287 , which is its position at time @xmath288 .",
    "then in ( k ) , motorcycle 3 is moved to @xmath289 , which is its position at time @xmath290 .",
    "the four motorcycles @xmath291 and @xmath292 start at time @xmath293 at initial points @xmath294 , @xmath295 , @xmath296 and @xmath297 .",
    "their velocities are @xmath298 , @xmath299 , @xmath300 , and @xmath301 .",
    "we use the halving scheme as specified in section  [ sec : notation ] with @xmath62 .",
    "so for instance , we create @xmath289 in ( j ) by halving @xmath302 .",
    "there are three crossings along this segment : @xmath303 .",
    "then @xmath289 is created as a point between @xmath304 and @xmath305 , in this case we just use the midpoint ."
  ],
  "abstract_text": [
    "<S> we present a new algorithm for computing motorcycle graphs that runs in @xmath0 time for any @xmath1 , improving on all previously known algorithms . </S>",
    "<S> the main application of this result is to computing the straight skeleton of a polygon . </S>",
    "<S> it allows us to compute the straight skeleton of a non - degenerate polygon with @xmath2 holes in @xmath3 expected time . </S>",
    "<S> if all input coordinates are @xmath4-bit rational numbers , we can compute the straight skeleton of a ( possibly degenerate ) polygon with @xmath2 holes in @xmath5 expected time .    in particular </S>",
    "<S> , it means that we can compute the straight skeleton of a simple polygon in @xmath6 expected time if all input coordinates are @xmath4-bit rationals , while all previously known algorithms have worst - case running time @xmath7 . </S>"
  ]
}