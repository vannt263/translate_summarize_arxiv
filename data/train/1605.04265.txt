{
  "article_text": [
    "due to the increasing amount of geographic data and its steady change , automatic approaches become more and more important in the area of cartography .",
    "this particularly applies to the time - consuming and demanding task of label placement and much research has been done on its automation .",
    "badly placed labels of feature of interest make maps easily unreadable  @xcite .",
    "depending on the type of map feature the label placement is done differently . for _ point features _ ( e.g. ,",
    "cities on small - scale maps ) labels are typically placed closely to that feature , while for _ line features _ ( e.g. , roads , rivers ) the name is either placed along or inside the feature .",
    "the latter approach is also used for _ area features _",
    "( e.g. , lakes ) . independently of the applied technique and feature type",
    ", labels should not overlap each other and clearly identify the features  @xcite .",
    "the cartographic label placement problem has also attracted the interest of researchers in computational geometry and it has been thoroughly investigated from both the practical and theoretical perspective  ( * ? ? ?",
    "* chapter 58.3.1 ) ,  @xcite .",
    "while algorithms for labeling point features got a lot of attention , much less work has been done on line features and area features . in this paper",
    "we address labeling line features , namely labeling the entire road network of a road map .",
    "we take an algorithmic , mathematical perspective on the underlying optimization problem and build up on our recent theoretical results for labeling tree - shaped networks  @xcite .",
    "we apply the quality criteria for label placement in road maps elaborated by chiri  @xcite based on interviews with cartographers .",
    "they include that ( c1 ) labels are placed inside and parallel to the road shapes , ( c2 ) every road section between two junctions should be clearly identified , and ( c3 ) no two road labels may intersect .",
    "similar criteria have been described in a classical paper by  imhof  @xcite .",
    "variations of embedded labels have been considered in road maps before .",
    "chiri  @xcite and strijk et al .",
    "9 ) presented simple , local heuristics that place non - overlapping labels based on a discrete set of candidate positions  in contrast we consider the problem globally applying a continuous sliding model .",
    "seibert and unger  @xcite utilized the geometric properties of grid - based road networks and proved that it is np - complete to decide whether at least one label can be placed for each road .",
    "for the same grid - based setting neyer and wagner  @xcite evaluated a practically efficient algorithm that is not applicable for general road networks .",
    "road labeling with embedded labels has also been considered for interactive and dynamic maps .",
    "maass and dllner  @xcite provided a heuristic for labeling interactive 3d road maps taking obstacles into account .",
    "vaaraniemi et al .",
    "@xcite presented a study on a force - based labeling algorithm for dynamic maps considering both point and line features .",
    "schwartges et al .",
    "@xcite investigated embedded labels in interactive maps allowing panning , zooming and rotation of the map .",
    "they evaluated a simple heuristic for maximizing the number of placed labels .",
    "in contrast , non - embedded labels are typically considered for single line features such as rivers .",
    "edmondson et al .",
    "@xcite presented an algorithm for placing straight labels along single line features .",
    "wolff et al .",
    "@xcite also considered the case that labels may bend .",
    "recently , schwartges et al .",
    "@xcite used _ billboards _",
    "( labels with short leaders ) for naming roads in interactive 3d maps to avoid label  distortion .     is created whose embedding is the simplified road network ; blue segments : road sections , red segments : junction edges .",
    "( c ) phase 2 : creating the labeling using  @xmath1 .",
    "( d )  a labeling produced by the osm renderer mapnik .",
    "the six labels of road _ osloer strae _ are enclosed by red ellipses .",
    ", title=\"fig : \" ]   is created whose embedding is the simplified road network ; blue segments : road sections , red segments : junction edges .",
    "( c ) phase 2 : creating the labeling using  @xmath1 .",
    "( d )  a labeling produced by the osm renderer mapnik .",
    "the six labels of road _ osloer strae _ are enclosed by red ellipses .",
    ", title=\"fig : \" ]   is created whose embedding is the simplified road network ; blue segments : road sections , red segments : junction edges .",
    "( c ) phase 2 : creating the labeling using  @xmath1 .",
    "( d )  a labeling produced by the osm renderer mapnik .",
    "the six labels of road _ osloer strae _ are enclosed by red ellipses .",
    ", title=\"fig : \" ]   is created whose embedding is the simplified road network ; blue segments : road sections , red segments : junction edges .",
    "( c ) phase 2 : creating the labeling using  @xmath1 .",
    "( d )  a labeling produced by the osm renderer mapnik .",
    "the six labels of road _ osloer strae _ are enclosed by red ellipses .",
    ", title=\"fig : \" ]    for labeling point features a typical objective is to maximize the number of non - overlapping placed labels , because every placed label enhances the map with further information . while this is mostly true for point features ,",
    "maximizing the number of labels is not the right objective for label placement of roads since not every label that is placed necessarily contributes more information to the map .",
    "for example , consider the placed labels of the road _ osloer strae _ in fig .",
    "[ fig : motivation](d ) . we can easily remove some of those labels without losing any information , because the map user can still identify the same road sections ; see fig .",
    "[ fig : motivation](c ) . in online map services , however , one often can find such redundant labels ; see fig .",
    "[ fig : webservices ] for two examples .",
    "some roads may have unnecessarily many labels , which may in turn cause others to remain completely unlabeled .",
    "hence , the user can not identify such roads on the map , a real disadvantage if headed for that road . due to these observations",
    "we do not aim to maximize the number of labels , but the number of labeled _ road sections_. for the purpose of this paper , a _ road section _ forms a connected piece of the road network that logically belongs together , e.g. , a part of a road between two junctions or a part that stands out by its color or width .",
    "our algorithm , however , is independent of the actual definition of road sections ; any partition of the road network into disjoint road sections can be handled .",
    "we say that a road section is _ labeled _ if a label ( partly ) covers it . as the underlying model for maximizing labeled road sections we re - use the planar graph model that has been introduced in our theoretical companion paper  @xcite .",
    "in that paper we further proved that labeling a maximum number of road sections is np - hard , even for planar graphs and if no road consists of multiple branches .",
    "however , we presented a polynomial - time algorithm for the case that the road graph is a tree .",
    "while the result for trees is mostly of theoretic interest ( road networks rarely form trees ) , we will show in this paper that our tree - based algorithm can in fact be used successfully as the core of an efficient and practical road labeling algorithm that produces near - optimal solutions .",
    "[ [ contribution - outline . ] ] contribution & outline .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    we introduce a new , versatile algorithmic framework for placing non - overlapping labels in road networks maximizing the number of labeled road sections .",
    "we keep the algorithmic components easily exchangeable . in sect .",
    "[ sec : model ] we discuss and expand the model introduced in  @xcite .",
    "afterwards , we present a workflow for labeling road networks consisting of two phases ; see fig .  [",
    "fig : motivation ] .    _ phase 1 ( sect .",
    "[ sec : transformation ] ) .",
    "_ we translate the given road network into a semantic representation ( an abstract road graph ) that identifies pieces of the road network that belong semantically together . to that end , we simplify the road network , e.g. , we merge lanes closely running in parallel . by design",
    "this simplification maintains the overall geometry of the road network and only merges structures in the data that should not be labeled independently .",
    "phase  1 is not part of the labeling optimization process .",
    "_ phase 2 ( sect .  [ sec : labeling ] ) . _ based on the abstract road graph , we create an actual labeling using one of three presented algorithms : a naive base - line algorithm , a heuristic extending our tree - based algorithm  @xcite and a mixed - integer linear programming ( milp ) formulation .    as proof of concept we implemented the core of the framework only taking the most important cartographic criteria into account .",
    "however , with some engineering it can be easily enhanced to more complex models , e.g. , enforcing minimum distances between labels , abbreviating road names , or using alternative definitions of road sections . in sect .",
    "[ sec : evaluation ] we present a detailed evaluation of our framework on 11 sample city maps . due to its availability and popularity in practice",
    ", we compare our results against the standard openstreetmap ( osm ) renderer mapnik as a representative of local heuristics ; it uses a strategy similar to  @xcite .",
    "we show that our tree - based algorithm is fast and yields near - optimal labelings that improve upon mapnik by @xmath0 on average .",
    "at any given scale , road networks are typically drawn as follows .",
    "each road or road lane is represented as a thick , polygonal curve , i.e. , a polygonal curve with non - zero width ; see the background of fig .  [ fig : motivation](a ) .",
    "if two ( or more ) such curves intersect , they form junctions .",
    "if two or more lanes of the same road closely run in parallel they merge to one even thicker curve such that individual lanes become indistinguishable .",
    "we then want to place road labels inside those thick curves .",
    "more precisely , a _ road label _ can again be represented as a thick curve ( the bounding shape of the road name ) that is contained in and parallel to the thick curve representing its road ; see  fig .",
    "[ fig : motivation](c ) .    for the purpose of this paper",
    "it is sufficient to use a simplified representation , which represents the road network and its labels as thin curves instead  @xcite .",
    "more precisely , a road network is modeled as a planar embedded _ abstract road graph _ whose edges correspond to the skeleton of the actual thick curves . in this model",
    "a label is again a thin curve of certain length that is contained in the skeleton . following the cartographic quality criteria  ( c1)(c3 ) , we want to place labels ,",
    "i.e. , find sub - curves of the skeleton , such that    each label starts and ends on road sections , but not on junctions ,    no two labels overlap , and    a maximum number of road sections are labeled .",
    "requiring that labels end on road sections avoids ambiguous placement of labels in junctions where it is otherwise unclear how the road passes through it . note that this does not forbid labels across junctions . from a labeling of the abstract road graph it is straight - forward to transform each label back into its _",
    "text representation _ by placing the individual letters of each label along the thick curves ; see fig .",
    "[ fig : model - issues](a ) .",
    "[ [ abstract - road - graph - model . ] ] abstract road graph model .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    we have introduced the abstract road graph in  @xcite , but for the convenience of the reader we repeat it here , see also fig .  [",
    "fig : motivation](b ) and fig .",
    "[ fig : model - issues](a ) . a road network ( in an abstract sense )",
    "is a planar geometric _ graph _ @xmath2 , where each vertex @xmath3 has a position in the plane and each edge  @xmath4 is represented by a polyline whose end points are @xmath5 and @xmath6 .",
    "each edge further has a _ road name_. a maximal connected subgraph of @xmath1 consisting of edges with the same name forms a _ road _",
    "the length of the name of @xmath7 is denoted by  @xmath8 .",
    "each edge @xmath9 is either a _ road section _ ,",
    "i.e. , the part of a road in between two junctions , or a _ junction edge _ , which models road junctions .",
    "formally , a _ junction _ is a maximal connected subgraph of  @xmath1 that only consists of junction edges .",
    "we require that no two road sections in @xmath1 are incident to the same vertex and that vertices incident to road sections have at most degree  2 .",
    "thus , the road graph @xmath1 decomposes into road sections , separated by junctions .",
    "we say a point  @xmath10 lies on @xmath1 , if there is an edge @xmath11 whose polyline contains  @xmath10 .",
    "hence , a polyline  @xmath12 ( in particular a single line segment ) lies on  @xmath1 if each point of  @xmath12 lies on  @xmath1 .",
    "further , @xmath12 _ covers _",
    "@xmath13 , if there is a point of  @xmath12 that lies on  @xmath13 .",
    "if each point of @xmath13 is covered by  @xmath12 , @xmath13 is _ completely covered_. the _ geodesic distance _ of two points on  @xmath1 is the length of the shortest polyline on @xmath1 connecting both points .",
    "a _ label _ of a road  @xmath7 is a simple open polyline  @xmath12 on  @xmath1 that has length  @xmath14 , ends on road sections of  @xmath1 , and whose segments only lie on edges of  @xmath7 .",
    "the start point of @xmath12 is denoted as the _ head _ @xmath15 and the endpoint as the _ tail _ @xmath16 .",
    "obviously , the edges that are covered by @xmath12 form a path  @xmath17 such that @xmath18 , and @xmath19 are ( partly ) covered and @xmath20 are completely covered by  @xmath12 . if @xmath21 is a road section ( and not a junction edge ) , we say that  @xmath21 is _ labeled _  by  @xmath12 .",
    "we extend the above abstract road graph model and restrict ourselves to _ well - shaped _ labels , i.e. , labels that are not too curvy or do not contain broken type setting due to sharp bends ; see fig .  [",
    "fig : model - issues](b ) .",
    "similar to schwartges et al .",
    "@xcite , we apply a local criterion to decide whether a label is well - shaped . to that end , we define a label @xmath12 to be _ well - shaped _ if for each covered edge @xmath22 there is a _",
    "well - shaped _ piece of  @xmath13 that completely contains the part of @xmath12 on  @xmath13 .",
    "further , we require that for each pair of incident edges of @xmath23 the bend angle is at most @xmath24 , where @xmath24 is a pre - defined constant .",
    "we redefine a _ labeling _",
    "@xmath25 to be a set of mutually non - overlapping , well - shaped labels .",
    "our theoretic results  @xcite remain valid for this restriction . in particular",
    "only few minor technical adaptions are required for the tree labeling algorithm .    in order to identify _",
    "well - shaped _ pieces of a polyline  @xmath26 with edges  @xmath27 , we extend the approach presented by schwartges et al .",
    "they define the curviness @xmath28 of @xmath26 by summing up the bend angles @xmath29 of all incident edge pairs @xmath21 , @xmath30 , i.e. , @xmath31 to determine the best label positions for any given label .",
    "we want to locally classify road pieces as well - shaped instead and adapt their idea as follows .",
    "let @xmath32 be a maximal sub - polyline of @xmath26 with the property that any sub - polyline of @xmath32 with length at most @xmath33 has curviness at most @xmath24 .",
    "each such sub - polyline @xmath32 forms a well - shaped piece of @xmath26 and they can all be computed in @xmath34 time . this local criterion for well - shapedness is based on the curviness of a fixed - width window sliding along the polyline ; it is independent of the label length ( similarly to what mapnik does ) . in our experiments we set  @xmath33 to twice the length of the letter ` w ` and @xmath35 , analogously to the parameters that mapnik  uses .    a _ labeling _",
    "@xmath25 for a road network is a set of mutually non - overlapping , well - shaped labels , where two labels @xmath12 and @xmath36 _ overlap _ if they intersect in a point that is not their respective head or tail .",
    "following the criteria  ( c1)(c3 ) , the problem maxlabeledroadsis to find a labeling @xmath25 that labels a maximum number of road sections , i.e. , no other labeling labels more road sections .",
    "in  @xcite we showed that maxlabeledroadsis np - hard in general and can be solved in @xmath37 time if  @xmath1 is a tree .",
    "[ [ sec : issues ] ] shortcomings for real - world road networks .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    while the abstract road graph model allows theoretical insights , we can not directly apply it to real - world road networks . due to the following issues , we need to invest some effort in a preprocessing phase ( see sect .",
    "[ sec : transformation ] ) to guarantee that the resulting labels in the text representation do not overlap , look nicely and are embedded in the roads shapes .",
    "issue  1 : if lanes run closely in parallel , their drawings in the road network merge to one thick curve and individual lanes become indistinguishable .",
    "hence , in our abstract model , such lanes should be aggregated to a single road section that represents the skeleton of the merged curve , and labels should be contained in it ; see fig  [ fig : motivation](c ) .    issue  2 : real - world road networks are not planar , but edges may cross , namely at tunnels and bridges ; see fig .",
    "[ fig : model - issues](c ) . to avoid overlaps between labels placed on those road sections , we either can model the intersection as a regular junction of two roads or we split one into two shorter road sections that do not cross the other road section . in both cases",
    "the road graph becomes planar . for our prototype",
    "we use the first variant ( also used by mapnik ) , because more road sections can be labeled .",
    "issue  3 : in real - world road networks some road sections are possibly so long that the label should be repeated after appropriate distances .",
    "issue  4 : labels have a certain font size so that when transforming an abstract label curve into its text representation , labels of different roads may overlap due to their road sections being too close ; see fig .",
    "[ fig : model - issues](d ) .",
    "the first phase of our framework consists of transforming the input road network data into an abstract road graph while resolving the four issues mentioned in sect .",
    "[ sec : issues ] .",
    "typically , road networks are given as a set of polylines that describe the roads and road lanes .",
    "individual polylines do not necessarily form semantic components such as road sections .",
    "so as a first step , we break all polylines down into individual line segments ( whose union forms the road network ) .",
    "let @xmath38 be the set of all these line segments .",
    "we further require that each line segment @xmath39 is annotated with its _ road name _ @xmath40 , the stroke width @xmath41 and the color @xmath42 that are used to draw @xmath43 , and finally the _ font size _",
    "@xmath44 that shall be used to display the name .",
    "we say that two line segments @xmath45 are _ equally represented _ if @xmath46 and @xmath47 .",
    "we assume that @xmath48 for any  @xmath43 ; otherwise we set @xmath49 .",
    "the workflow consists of the following five steps ; see fig .",
    "[ fig : workflow ] .    identification .",
    "identify single _ road components _",
    ", i.e. , sets of line segments that have the same name , are equally represented , and form a connected component .    simplification .",
    "simplify each road component such that lanes running closely in parallel are aggregated .",
    "replace bridges and tunnels by artificial junctions .",
    "transform the segment representation into an abstract road graph .    resolving overlaps . identify mutual overlaps of road sections and block them for label placement .",
    "below we describe each step in more detail .",
    "we define the _ hull _ of a line segment  @xmath39 to be the region of points whose euclidean distance to  @xmath43 is at most @xmath41 ; see fig .",
    "[ fig : workflow](a ) .",
    "the hull of a polyline is then the union of its segments hulls .",
    "we approximate hulls by simple polygons .",
    "step 1  identification . for each road name @xmath50 , each color @xmath51 and each font size",
    "@xmath52 we define the intersection graph of the hulls of the line segments @xmath53 . in this intersection graph each hull is a vertex and two vertices are connected if and only if the corresponding hulls intersect . in each ( non - empty ) intersection graph",
    "we identify all connected components , which we call _ road components _ ; e.g. , in fig .",
    "[ fig : workflow](a ) the blue segments form a road component . thus , based on @xmath38 we obtain a set  @xmath54 of road components . by definition ,",
    "each component @xmath55 has a unique name  @xmath56 , stroke width  @xmath57 , color @xmath58 and font size  @xmath59 .",
    "step 2  simplification . for each road component",
    "@xmath55 we geometrically form the union of the corresponding hulls .",
    "thus , the result is a simple polygon  @xmath26 ( possibly with holes ) ; see fig .",
    "[ fig : workflow](b ) , top .",
    "this polygon describes the contour of the road component as drawn on the map .",
    "we discard all polygons whose area is smaller than some threshold as they are too small to be labeled ; we use the area of the letter ` w ` as threshold . for each remaining polygon @xmath26",
    "we construct the _ skeleton _ of @xmath26 as a linear representation of the corresponding road component such that labels centered on the skeleton are guaranteed to be contained in @xmath26 .",
    "this skeleton is based on the conforming delaunay triangulation of the interior of  @xmath26 following bader and weibel  @xcite . for triangles that have one or three _ internal _ edges , i.e.",
    ", edges that do not belong to the boundary of  @xmath26 , we connect the triangle centroid to the midpoints of the internal edges . for triangles with two internal edges ,",
    "we simply connect the midpoints of these two edges , see fig .",
    "[ fig : workflow](b ) , bottom . from those line segments ,",
    "we form a set of maximal polylines by appending all those line segments that meet at the midpoint of a triangle edge ( but not at a triangle centroid ) .",
    "since these polylines may consist of many vertices and meander _ locally _ , we simplify them using the douglas - peucker algorithm , but only if the simplified shortcuts keep a distance of at least @xmath60 to the boundary of  @xmath26 , see fig .",
    "[ fig : workflow](c ) .",
    "finally , we delete any segment  @xmath43 whose text box @xmath61 is not completely contained in  @xmath26 . here",
    "the _ text box _",
    "@xmath61 of @xmath43 is defined as a rectangle centered at  @xmath43 with two sided parallel to  @xmath43 .",
    "these parallel sides have the same length as  @xmath43 , the two orthogonal sides have length  @xmath59 , see fig .",
    "[ fig : workflow](b ) , bottom .",
    "segments with the text box not contained in @xmath26 may occur at the protrusions of the component where circular arcs are approximated by polylines , see fig .",
    "[ fig : workflow](c ) , top left .",
    "the remaining set of polylines forms the skeleton of @xmath26 .",
    "thus , for each road component  @xmath62 we obtain a skeleton such that all text boxes of the skeleton edges are contained in @xmath26 .",
    "this resolves  issue  1 .",
    "we annotate each skeleton edge with the name , stroke width , color and font size of  @xmath62 .",
    "step 3  planarization .",
    "so far polylines of different road components may intersect at other points than their end points , e.g. , polylines representing bridges and tunnels may cross other polylines . as motivated in sect .",
    "[ sec : issues ] , we subdivide these polylines to resolve intersections ; see fig .",
    "[ fig : workflow](d ) . more precisely , if two line segments @xmath63 and @xmath64 of two polylines intersect at a point  @xmath65 , we replace them by the four segments @xmath66 , @xmath67 , @xmath68 and @xmath69 .",
    "we do the intersection tests with a certain tolerance to identify @xmath70-crossings safely . however ,",
    "this may yield short stubs that protrude junctions slightly ; we remove those stubs .",
    "thus , this step resolves issue  2and yields a set of annotated polylines only intersecting in vertices .",
    "step 4  transformation .",
    "next we create the abstract road graph from the polylines of the previous step . as a result of step 3 we know that any two polylines intersect only in vertices .",
    "we first take the union of all polylines , identify vertices that are common to two or more polylines and mark these vertices as _",
    "junction seeds_. this induces already a planar graph @xmath2 with polyline edges whose vertices @xmath71 are either junction seeds or have degree 1 .",
    "it remains to partition the edges of @xmath1 into road sections and junction edges .",
    "initially , we mark all edges as road sections .",
    "we distinguish two types of junction seeds in @xmath1 .",
    "if a junction seed @xmath6 has degree at least @xmath72 , only two of its incident edges @xmath13 and @xmath73 belong to the same road @xmath7 and all other incident edges belong to different roads ( and have a different road type than @xmath7 ) then we do not create any junction edges at @xmath6 , see fig .",
    "[ fig : workflow](e ) , small box .",
    "since @xmath7 is the only road that may use the junction at @xmath6 and it is visually clear that all other roads end at @xmath6 we can safely treat @xmath6 as an internal vertex of a road section of @xmath7 .",
    "so we disconnect all incident edges of @xmath6 except @xmath13 and @xmath73 from @xmath6 and let each of them end at its own slightly displaced copy of @xmath6 .",
    "the edges @xmath13 and @xmath73 are merged at @xmath6 and the new edge remains a road section .",
    "this resolves the situation as desired .    for all other junction seeds we create junction edges as follows .",
    "let @xmath6 be a junction seed and let @xmath74 be the set of edges incident to @xmath6 .",
    "we intersect the hulls of all edges in @xmath74 and project their intersection points onto the corresponding edges , see fig .",
    "[ fig : workflow](f ) . for each edge",
    "@xmath75 we determine the projection point  @xmath76 that is farthest away from @xmath6 ( in geodesic distance ) .",
    "if the distance between  @xmath76 and @xmath6 exceeds a given threshold @xmath77 , we shift @xmath76 to the point on @xmath13 that has distance @xmath77 from @xmath6 .",
    "now we subdivide @xmath13 at  @xmath76 and mark the edge @xmath78 as a junction edge ; the other edge at @xmath76 ( if non - empty ) remains a road section .",
    "the threshold @xmath77 ensures that roads running closely in parallel are not completely marked as junction edges . figure  [ fig : workflow](g ) shows the resulting abstract road graph .    to resolve issue",
    "3we subdivide road sections whose length exceeds a certain threshold ( in our experiment 350 pixels ) by inserting a very short junction edge .",
    "step 5  resolving overlaps . by step 2",
    "the hulls of edges that belong to the same road component do not overlap .",
    "however , if two sections of different roads run closely in parallel , their hulls ( and hence their labels ) may overlap .",
    "we identify overlaps of the hulls of non - incident edges in @xmath1 and block the corresponding parts of the edge whose road is less important for placing labels ; ties are broken arbitrarily .",
    "more complex approaches using road displacement could be applied , however , we have chosen a simple solution . by design hulls of incident edges",
    "may only overlap if both are junction edges ; those overlaps are handled by the labeling algorithms ; see sect .",
    "[ sec : labeling ] .",
    "this resolves issue  4 .",
    "in this section we present the four different methods for solving maxlabeledroadsthat we subsequently evaluate in our experiments in sect .",
    "[ sec : evaluation ] .",
    "furthermore , we describe a technique for decomposing road graphs into several smaller , independent components that may speed up computations .      baseline .",
    "an obvious base - line heuristic to obtain lower bounds is to simply place a well - shaped label on each individual road section that is long enough to admit such a label without extending into any junctions .",
    "we use this approach to show that it is beneficial to position labels across junctions .",
    "mapnik ( http://mapnik.org ) is a standard open source renderer for openstreetmap that includes an road labeling algorithm .",
    "the algorithm iteratively labels so - called _ ways _ , which are polylines describing line features in openstreetmap . along",
    "each way it places labels with a certain spacing and locally ensures that labels do not intersect already placed labels of other ways .",
    "it does not use any semantic structure from the road network ( e.g. , road sections ) , but relies on how the contributors of openstreetmap modeled single ways .",
    "we may run the rendering algorithm and extract all placed labels from its output .",
    "the tree - based heuristic makes use of our recently proposed algorithm that optimally solves maxlabeledroadsif @xmath1 is a tree  @xcite .",
    "the basic idea for trees is that a placed label splits the tree into several independent sub - trees , which then are labeled recursively .",
    "using dynamic programming we reuse already computed results so that the algorithm s complexity becomes polynomial , namely @xmath79 running time and @xmath80 space . applying some further intricate modifications we improved this to @xmath37 time and @xmath81 space , and @xmath80 time if each road in @xmath1 is a path .",
    "we omit the details and use that algorithm as a _",
    "black box_. if  @xmath1 is a tree , our heuristic optimally labels  @xmath1 .",
    "otherwise it computes a spanning tree  @xmath70 on  @xmath1 using kruskal s algorithm and computes an optimal labeling for @xmath70 .",
    "we construct  @xmath70 such that all road sections of  @xmath1 are contained in  @xmath70 .",
    "since a road section is only incident to junction edges , this is always possible . in sect .",
    "[ sec : evaluation ] we show that large parts of realistic road networks can actually be decomposed into paths and trees without losing optimality .    milp .",
    "in order to provide upper bounds for the evaluation of our labeling algorithms , we implement a mixed - integer linear programming ( milp ) model that solves maxlabeledroadsoptimally on arbitrary abstract road graphs .",
    "the basic idea is to discretize all possible label positions and to restrict the space of feasible solutions to non - overlapping sets of labels .",
    "we now describe the milp formulation in detail . to simplify the presentation",
    ", we drop the rather technical concept of _ well - shaped _ labels , but note that it can be easily incorporated into the milp . in the following",
    "let the edges of @xmath1 be ( arbitrarily ) directed .",
    "we first discretize the problem as follows .",
    "two labels @xmath12 and @xmath36 are _ equivalent _ if they cover the same edges in the same order , i.e. , @xmath82 , and only their end points differ ; see fig .",
    "[ fig : rules](b ) . for each such equivalence class",
    "we create one label  @xmath12 ; we denote its equivalence class by  @xmath83 .",
    "further , let  @xmath38 denote the set of such created labels .",
    "the main idea of the milp is to select a subset of  @xmath38 and to determine the exact positions of the labels end points on their terminals such that they do not overlap and label a maximum number of road sections .",
    "now , consider a label  @xmath84 and the path @xmath85 that is covered by  @xmath12 ; see fig .",
    "[ fig : rules](b ) . in the following we call @xmath18 and @xmath19 the _ terminals _ of  @xmath12 and the others _",
    "internal edges _ of  @xmath12 .",
    "assume that the head of the label  @xmath12 lies on @xmath18 and the tail on @xmath19 , then @xmath12 can slide along  @xmath23 changing the covered road sections until the head or tail of  @xmath12 _ hits _ an end point of @xmath18 or @xmath19 , respectively . at each position",
    ", @xmath12 coincides with an equivalent label  @xmath36 .",
    "obviously , those labels exactly form @xmath86 .",
    "further , there exist two positions on  @xmath18 such that the head of @xmath12 has either minimum geodesic distance @xmath87 or maximum geodesic distance @xmath88 to the source of @xmath18 , respectively .",
    "we define the interval  @xmath89 $ ] .",
    "analogously , we define the interval @xmath90 for the tail of @xmath12 and the edge @xmath19 .    for each label  @xmath91",
    "we introduce the variables  @xmath92 ,  @xmath93 and  @xmath94 , and for each road section @xmath11 the variable @xmath95 .",
    "we interpret @xmath96 such that  @xmath12 is selected for the labeling .",
    "the variables  @xmath97 and @xmath98 are interpreted as the geodesic distances of the head and tail to the source of the head s and tail s terminal , respectively ; see fig .",
    "[ fig : rules](c ) .",
    "we interpret @xmath99 as road section  @xmath13 being labeled and maximize the sum @xmath100 subject to the following constraints .    for each @xmath84",
    "we require @xmath101 where @xmath102 , @xmath103 denotes the given length of  @xmath12 and @xmath104 is a linear expression describing what length of @xmath13 is covered by @xmath12 .",
    "this expression depends on which end point of @xmath13 is covered , whether the head or tail of  @xmath12 lies on  @xmath13 , and on the position variables @xmath105 and @xmath106 , respectively ; we omit the technical definition .",
    "further , for each pair @xmath107 we require @xmath108    & \\quad\\text { terminal~$e$ and $ \\ell$ covers the source of~$e$. }   \\end{split}\\end{aligned}\\ ] ] for each road section @xmath11 and all labels @xmath109 labeling  @xmath13 we require @xmath110 constraint  ( [ constr : length ] ) ensures that each label has the desired length  @xmath103 .",
    "constraint  ( [ constr : overlap1 ] ) ensures that a label does not overlap another label internally , i.e. , it ( partly ) covers an edge that is completely covered by another label . constraint  ( [ constr : overlap2 ] )",
    "ensures that labels ending on the same road section do not overlap on that edge , but  @xmath12 ends on @xmath13 before  @xmath36 starts ; see fig .",
    "[ fig : rules](c ) . similar constraints are introduced for the other combinations on how heads and tails of @xmath12 and @xmath36 can lie on a common edge , and on whether source or target of  @xmath13 is covered . for an appropriate large @xmath111",
    "the constraint is trivially satisfied if @xmath12 or @xmath36 is not selected for the labeling .",
    "finally , constraint  ( [ constr : counting ] ) ensures that road section  @xmath13 is only counted as labeled , if there is at least one selected label covering  @xmath13 .",
    "since @xmath38 models all possible label positions and the constraints restrict the space of feasible solutions to non - overlapping sets of labels , it is clear that any optimal solution of the above milp corresponds to an optimal solution of maxlabeledroads .",
    "milpsolves maxlabeledroadsoptimally .    finding an optimal solution for a milp formulation",
    "is np - hard in general and remains np - hard for the stated formulation , because maxlabeledroadsis np - hard .",
    "however , it turns out that in practice we can apply specialized solvers to find optimal solutions for reasonably sized instances in acceptable time , see sect .",
    "[ sec : evaluation ] .",
    "we may speed up both our heuristic treeand the exact approach milpby decomposing the road graph into smaller , independent components to be labeled separately , i.e. , components whose individual optimal solutions compose to a conflict - free optimal solution of the initial road graph .",
    "such a decomposition allows to compute solutions in parallel with either of the above methods and it further decreases the total combinatorial complexity .",
    "the decomposition rules guarantee that the labelings of the components can always be merged without creating any label overlaps .",
    "we name this technique d&c .",
    "step 1  decomposition . for many road sections , e.g. , long sections , of real - world road networks labels can be easily placed preserving the optimal labeling .",
    "we iterate through the edges of @xmath1 and cut or remove some of them if one of the following rules applies . as a result",
    "the graph decomposes into independent connected components ; see fig .",
    "[ fig : rules](d)(g ) .",
    "let  @xmath13 be the currently considered edge and let  @xmath7 be the road of @xmath13 .",
    "_ rule  1_. if @xmath13 is a junction edge and it can not be completely covered by a well - shaped label , i.e. , @xmath13 is not well - shaped , then remove @xmath13 .    _ rule  2_. if @xmath13 is a road section that ends at a junction that is not connected to any other road section of  @xmath7 , then detach @xmath13 from that junction .    _",
    "rule  3_. if @xmath13 is a road section , a well - shaped label  @xmath12 fits on  @xmath13 , and @xmath13 is at least twice as long as  @xmath12 , then cut @xmath13 at its midpoint .",
    "_ rule  4_. if @xmath13 is a road section , a well - shaped label  @xmath12 fits on @xmath13 , and @xmath13 is connected to a junction that is only connected to road sections of  @xmath7 that may completely contain a well - shaped label , then detach @xmath13 from that junction .",
    "on each edge we apply at most one rule . if we apply _ rule  3_or _ rule  4_on an edge  @xmath13 , we call @xmath13 a _ long - edge_. afterwards , we determine all connected components of the remaining graph  @xmath112 , which are then independently labeled .",
    "step 2  label placement . for the constructed components we compute solutions in parallel with either of the above methods .",
    "step 3  composition .",
    "finally , we compose the labelings of the second step to one labeling . due to the decomposition , no two labels of different components can overlap . if a long - edge  @xmath13 is not labeled , we place a label on it , which is possible by definition .",
    "we adapt the algorithms of step 2 such that they do not count labeled road sections that were created by _",
    "rule  3 _ , but we count the corresponding long - edge in this step .    [",
    "[ correctness . ] ] correctness .",
    "+ + + + + + + + + + + +    we now prove the correctness of the approach . to that end",
    "we first formalize the presented rules .",
    "we assume that the edges of  @xmath1 are ( arbitrarily ) directed .",
    "_ rule  1_. if @xmath13 is a junction edge and it can not be completely covered by a well - shaped label , i.e. , @xmath13 is not well - shaped , then remove @xmath13 .",
    "_ rule  2_. let  @xmath113 be the set of road sections that belong to the same road as  @xmath13 , and that are reachable from  @xmath6 in  @xmath1 when only traversing junction edges .",
    "if @xmath114 is a road section and @xmath115 for an @xmath116 , then remove the junction edge incident to  @xmath5 .",
    "_ rule  3_. if @xmath114 is a road section , a well - shaped label  @xmath12 fits on  @xmath13 , and @xmath13 is twice as long as  @xmath12 , then replace @xmath13 by the road sections  @xmath117 and @xmath118 , where @xmath119 and @xmath120 are two new vertices at the midpoint  @xmath10 of @xmath13 , @xmath18 is a sub - polygon of  @xmath13 from @xmath121 to @xmath122 and @xmath123 is a sub - polygon of  @xmath13 from @xmath120 to @xmath65 .",
    "we mark @xmath18 and @xmath123 as _ stubs _ and call @xmath13 a _ long - edge_.    _ rule  4_. if @xmath114 is a road section , a well - shaped label  @xmath12 fits on  @xmath13 and for at least one end node  @xmath116 the road sections in @xmath124 are all stubs , then remove the junction edge incident to  @xmath5 .",
    "we mark @xmath13 as _ stub _ and call @xmath13 a _ long - edge_.    [ apx : thm : rules ] let @xmath1 be an abstract road graph and let @xmath25 be the resulting labeling after applying d&c  combined with an algorithm that yields optimal labelings .",
    "an optimal labeling  @xmath125 of @xmath1 and @xmath126 label the same number of road sections .",
    "let  @xmath2 be an abstract road graph and let @xmath125 be an optimal labeling of @xmath1 , i.e. , no more road sections can be labeled .",
    "we show that we can transform @xmath125 into a labeling @xmath25 that is found by d&c , and , furthermore , @xmath126 and @xmath125 label the same number of road sections .",
    "if not mentioned otherwise , we assume a label to be well - shaped .",
    "_ rule  1_. assume that we apply _",
    "rule  1_on @xmath1 by deleting a junction edge  @xmath13 that can not be completely covered by a well - shaped label . by definition",
    "no label may end on a junction edge , but it must end on a road section . thus , in any labeling the edge @xmath13 can not be covered by any label .",
    "we therefore can delete the edge preserving the optimal labeling , i.e. , an optimal labeling of @xmath1 and @xmath127 label the same number of road sections .",
    "_ rule  2_. assume that we apply _",
    "rule  2_on the edge  @xmath13 .",
    "since @xmath13 is the only edge in @xmath128 , the edge is the end of a road , i.e. , all other edges incident to @xmath5 can not belong to the same road of  @xmath13 .",
    "since @xmath13 is a junction edge , no label may end on a junction edge , and labels may only cover edges of the same road , no label can cover  @xmath13 in any labeling .",
    "we therefore can delete the edge preserving the optimal labeling .",
    "_ rule  3_. assume that we apply _",
    "rule  3_on the road section  @xmath114 splitting  @xmath13 into the edges  @xmath117 and @xmath129 .",
    "since @xmath13 may contain a well - shaped label , the road section @xmath13 must be labeled in @xmath125 .",
    "if  @xmath13 is only labeled by labels that are completely contained in @xmath13 , i.e. , they do not cover other edges of  @xmath1 , we will find one of those labels in the composition step of d&c .    hence , assume that there is a label  @xmath130 that covers @xmath13 and @xmath121 . since @xmath13 is twice as long as the label length of  @xmath13 , this label can not cover the location of @xmath119(@xmath120 ) .",
    "the same applies for a label @xmath131 that covers  @xmath13 and  @xmath65 . since @xmath13 is labeled by @xmath132 ( @xmath133 )",
    "we can remove all other labels that only label  @xmath13 without changing the maximum number of labeled road sections .",
    "hence , the point at @xmath119 is not covered by any label , which means we can split @xmath13 at this point preserving the optimal labeling .",
    "_ rule  4_. assume that we apply _",
    "rule  4_on the road section  @xmath114 with @xmath134 ; same arguments hold for @xmath135 .",
    "hence , the road sections in @xmath124 are all stubs , i.e. , well - shaped labels can placed on any of these road sections .",
    "let  @xmath136 be the junction edge that is connected to  @xmath121 .",
    "assume that there is a label  @xmath12 that labels @xmath13 and an edge  @xmath73 of @xmath124 such that @xmath5 is covered   by  @xmath12 .",
    "if  @xmath13 and @xmath73 are also labeled by other labels , we can remove  @xmath12 without changing the number of labeled road sections and remove  @xmath136 .",
    "so assume that @xmath13 is not labeled by another label .",
    "in that case we remove  @xmath12 and place a label that completely lies on @xmath13 without covering any other edges ; by definition of the rule this is possible . if  @xmath73 is also not labeled by any other label , we also place a label on @xmath73 , which is possible , because  @xmath73 is a stub .",
    "hence , we can remove  @xmath136 preserving the optimal labeling .",
    "we evaluate our framework and in particular the performance of our new tree - based labeling heuristic by conducting a set of experiments on the road networks of 11 north american and european cities ; see  table  [ table : instances16 ] .",
    "while the former ones are characterized by grid - shaped road networks , the latter ones rarely posses such regular geometric structures .",
    "since the road networks in rural areas are much sparser than those of cities , we refrained from considering these networks and focused on the more complex city road networks .",
    "we extracted the abstract road graphs from the data provided by openstreetmap .",
    "we applied the spherical mercator projection espg:3857 , which is also known as _ web mercator _ and used by several popular map - services .",
    "we considered the three scale factors 4.773 , 2.387 and 1.193 , which approximately correspond to the map scales 1:15000 , 1:8000 , 1:4000 .",
    "further , they correspond to the _ zoom levels _ 15 , 16 and 17 , respectively , which are widely used by map services as openstreetmap .",
    "those zoom levels show road networks in a size that already allows labeling single road sections , while the map is not yet so large that it becomes trivial to label the roads .",
    "we applied the standard drawing style for openstreetmap , which in particular includes the stroke width and color of roads as well as the font size of the labels .",
    "further , this specifies for each zoom level the considered road categories ; the higher the zoom level the more categories are taken into account .",
    "our implementation is written in c++ and compiled with gcc 4.8.4 using optimization level  ` -o3 ` .",
    "milps were solved by gurobi 6.0 .",
    "the experiments were performed on a 4-core intel core i7 - 2600k cpu clocked at 3.4 ghz , with 32 gib ram .",
    "the d&c - approach labels single components in parallel . for computing the delaunay triangulation we used the library fade2d .    for each city and each zoom level we applied the algorithms baseline ,",
    "tree , d&c+tree , milpand d&c+milp .",
    "we adapted the algorithm such that short road sections ( shorter than the width of the letter ` w ` ) are not counted , because they are rarely visible .",
    "further , we let mapnik ( version 3.0.9 ) render the same input . for each label we identified for each of its letters the closest road section  @xmath137 with the same name and counted it as labeled .",
    "since mapnik does not optimize the labeling by the same criteria as we do , we compensate this by also counting neighboring road sections as labeled if the junction in between them is not incident to any other road section .",
    "this accounts for those long road sections that we split artificially to resolve  issue  3 .",
    "[ table : instances15 ] [ table : instances17 ]    .statistics for baltimore ( ba ) , berlin ( be ) , boston ( bo ) , los angeles ( la ) , london ( lo ) , montreal ( mo ) , paris ( pa ) , rome ( ro ) , seattle ( se ) , vienna ( vi ) and washington ( wa ) for zoom level 15 , 16 and 17 .",
    "_ osm _ : number of input segments in thousands .",
    "_ segm . : _ percentage of segments after phase 1 , step 3 in relation to input segments .",
    "_ graph _ : number of road sections after phase 1 in thousands .",
    "_ time : _ running time for phase 1 . [ cols=\"<,<,^,^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     _ phase 1 . _ with a maximum of 67 seconds ( london , zoom 17 ) and 27 seconds averaged over all instances , phase 1 can be applied on large instances in reasonable time . during phase 1",
    "the number of segments is reduced to between @xmath138 and @xmath139 of the original instance ( measured after step 3 , before creating junction edges ) ; see table  [ table : instances15 ] .",
    "this clearly indicates that the procedure aggregates many lanes , since by design the approach does not change the overall geometry , but the simplification maintains the shape of the original network .",
    "this is also confirmed by the labelings ; see fig .",
    "[ fig : motivation](b)(c ) and interactive maps .",
    "_ phase 2 , running time .",
    "_ we first consider the average running times over all zoom levels ; see fig .",
    "[ plot : all : time ] .",
    "we did not measure the running times of mapnik , because its labeling procedure is strongly interwoven with the remaining rendering procedure , which prevents a fair comparison . as to be expected milpis the slowest method ( max .",
    ", los angeles , zl 15 ) , while baselineis the fastest procedure ( max .",
    "0.17 sec . ) . combining milpwith d&c  results in an average speedup of 2.29 over all instances and a maximum speedup of 3.44",
    "; see table  [ table : speedup ] .",
    "the algorithm treeneeds less than 4.7 seconds and its median is about 1.3 seconds . hence , despite its worst - case cubic asymptotic running time , it is fast in practice .",
    "similar to milp , it is further enhanced by combining it with  d&c  for a speedup of 1.64 with respect to  tree , and an average speedup of 6.14 with respect to d&c+milp ; see table  [ table : speedup ] . in the latter case",
    "it has even a maximum speedup of about 21.6 .",
    "since decomposing and composing the labelings is done sequentially , the theoretically possible speed up using  d&c  is not achieved .",
    "if we break down the running times into single zoom levels , we observe similar results ; see e.g. , fig .",
    "[ fig : running - time : selection ] . since with increasing zoom level the instance size grows , for most of the algorithms also the running time increases . only for north american cities and milpwe",
    "observe that the running time for instances of smaller zoom levels are higher than for larger zoom levels .",
    "_ phase 2 , quality .",
    "_ first we analyze the average percentage of labeled road sections over the three zoom levels ; see fig .  [",
    "plot : all : rs ] . as an upper bound , milp , which provably solves maxlabeledroadsoptimally , yields results from @xmath140 ( rome ) to @xmath141 ( montreal ) . considering zoom levels independently",
    ", we obtain a minimum of @xmath142 ( rome , zl 15 ) and a maximum of @xmath143 ( montreal , zl 17 ) .",
    "we think that the wide span is attributed to the different structures of road networks and road names , e.g. , rome has a lot of short alleys and long road names .",
    "hence , many road components are too short or convoluted to contain a single label .",
    "abbreviating road names could help to overcome this problem .",
    "the algorithm d&c+treeyields marginally better results than tree , but only @xmath144 on average , see table  [ table : speedup ] . comparing d&c+treewith milpwe observe that d&c+treeyields near - optimal results with respect to our road - section based model . on average",
    "it reaches @xmath145 of the optimal solution ; see table  [ table : speedup ] .",
    "while the quality ratio is only @xmath146 for washington , more than half of the instances are labeled with a quality ratio of @xmath147 . for european cities",
    "the percentage of road sections that belong to components that are optimally solved by tree(long edges , paths , and trees ) is notably higher than those for north american cities ; see fig .",
    "[ fig : components ] .",
    "nonetheless , we obtain similar percentages of labeled road sections for north american cities .",
    "hence , the heuristic computing a spanning tree of non - tree components is both fast and yields near - optimal results . the additional implementation effort of treeis further justified by the observation that the naive way to place labels only on single road sections lags far behind ; only @xmath148 on average , @xmath149 as maximum and @xmath150 as minimum compared to the optimal solution .",
    "mapnik achieves on average @xmath151 of the optimal solution and a maximum of @xmath146 . for more than the half of the instances",
    "mapnik achieves at most @xmath152 of the optimal solution .",
    "so in direct comparison , d&c+treelabels @xmath0 more road sections than mapnik on average .",
    "moreover , d&c+treehas a better utilization of labels and achieves an average ratio of 1.61 labeled road sections per label , compared to mapnik with a ratio of 1.37 ; see fig .",
    "[ apx : fig : number - of - labels ] .    with increasing zoom level the number of labeled road sections",
    "is increased , which is to be expected , since more road sections become long - edges ; see fig .",
    "[ fig : quality : selection ] for four cities ( similar results apply for the others ) and fig .",
    "[ fig : components ] . for each zoom level , we observe similar results as described before : treeand d&c+treeachieve near - optimal solutions and mapnik labels considerably fewer road sections .",
    "however , for smaller zoom levels the gap between milpand mapnik shrinks . from a visual perspective",
    ", labels lie on the skeleton of the road network , which is achieved by design ; see fig .",
    "[ fig : motivation](c ) and the interactive maps . instead of unnecessary repetition of labels ,",
    "labels are only placed if they actually convey additional information . in particular , visual components are labeled , but not single lanes that are indistinguishable due to the zoom level .",
    "we introduced a generic framework for labeling road maps based on an abstract road graph model that is combinatorial rather than geometric .",
    "we showed in our experimental evaluation that our proposed heuristic for decomposing the road graph into tree - shaped subgraphs and labeling those trees provably optimally is both efficient and effective .",
    "it has running times in the range of seconds to one minute even for large road networks such as london with more than 100,000 road sections and achieves near - optimal quality ratios ( on average 97% ) compared to upper bounds computed by the exact method milp .",
    "our algorithm clearly outperforms the labeling algorithm of the standard osm renderer mapnik , with an average improvement in labeled road sections of @xmath0 .",
    "interestingly , milpis able to compute mathematically optimal solutions within a few minutes for all our test instances , even though it is slower by a factor of about 6 compared to the tree - based algorithm .",
    "so for practical purposes there is a trade - off between a final , but rather small improvement in quality at the cost of a significant and by the very nature of milpunpredictable increase in running time .",
    "we only implemented essential cartographic criteria to evaluate the algorithmic core of our framework ; further criteria ( e.g. , abbreviated names ) and alternative definitions of road sections can be easily incorporated .",
    "the framework can further be pipelined with labeling algorithms for other map features , e.g. , after placing labels for point features , one may block all parts of the road network covered by a point label and label the remaining road network such that no labels overlap . while this allows to label different types of features sequentially ,",
    "constructing a labeling of all features in one single step remains an important open problem .",
    "a.  gemsa , b.  niedermann , and m.  nllenburg . label placement in road maps . in v.",
    "t. paschos and p.  widmayer , editors , _ algorithms and complexity ( ciac15 ) _ , volume 9079 of _ lncs _ , pages 221234 .",
    "springer , 2015 .",
    "s.  maass and j.  dllner .",
    "embedded labels for line features in interactive 3d virtual environments . in _",
    "computer graphics , virtual reality , visualisation and interaction ( afrigraph03 ) _ , pages 5359 .",
    "acm , 2007 .",
    "n.  schwartges , b.  morgan , j .- h . haunert , and a.  wolff . labeling streets along a route in interactive 3d maps using billboards . in f.  bacao , m.  y. santos , and m.  painho , editors , _ geo . inf .",
    "science as an enabler of smarter cities and communities ( agile15 ) _ , lngc , pages 269287 .",
    "springer , 2015 .",
    "a.  wolff , l.  knipping , m.  van kreveld , t.  strijk , and p.  k. agarwal .",
    "a simple and efficient algorithm for high - quality line labeling . in _ innovations in gis",
    "vii : geocomputation _ , chapter  11 , pages 147159 .",
    "taylor & francis , 2000 ."
  ],
  "abstract_text": [
    "<S> given an unlabeled road map , we consider , from an algorithmic perspective , the cartographic problem to place non - overlapping road labels embedded in their roads . </S>",
    "<S> we first decompose the road network into logically coherent road sections , e.g. , parts of roads between two junctions . based on this decomposition , </S>",
    "<S> we present and implement a new and versatile framework for placing labels in road maps such that the number of labeled road sections is maximized . in an experimental evaluation with road maps of 11 major cities </S>",
    "<S> we show that our proposed labeling algorithm is both fast in practice and that it reaches near - optimal solution quality , where optimal solutions are obtained by mixed - integer linear programming . in comparison to the standard openstreetmap renderer mapnik , our algorithm labels  @xmath0 more road sections in average . </S>"
  ]
}