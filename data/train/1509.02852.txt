{
  "article_text": [
    "model predictive control ( mpc ) is a popular control approach , which efficiently treats constraints on state and control variables .",
    "solid introduction into mpc is found in @xcite and @xcite , industrial applications are discussed in @xcite , numerical aspects of mpc are surveyed in @xcite and @xcite .",
    "@xcite has developed an on - line numerical method for nonlinear mpc , based on the so - called newton - krylov method ; see @xcite for other applications of the newton - krylov method .",
    "@xcite provide an efficient preconditioner for the newton - krylov method and extend the mpc model , treated in @xcite , to the minimum - time problem .    in the present note ,",
    "we demonstrate how the preconditioned newton - krylov method by @xcite works in cases , where the system dynamics or constraints can discretely change on - line .",
    "the problem with discrete switches requires simultaneous solution to several finite - horizon predictions , which can be done independently on parallel processors .",
    "the computer time can be also reduced by using the same preconditioner for all finite - horizon control problems , if the discrete changes of the system dynamics or constraints do not lead to large norms of the residual mapping @xmath0 , introduced in section 2 . if the norm @xmath1 is not small enough after a discrete switch , the method may be even ruined during execution .",
    "such a behavior is inherited from the newton method , which converges only for sufficiently good initial guess .",
    "the finite - horizon predictions with @xmath1 larger than a suitable tolerance may be discarded or refined .",
    "the necessity to compute several close trajectories also appears in the so called particle control problems ; see e.g. @xcite .",
    "the rest of the note is organized as follows .",
    "section 2 presents a framework of the receding horizon prediction problem and obtains its solution in the form of a nonlinear equation .",
    "section 3 discusses how this nonlinear equation is efficiently solved for an ensemble of sufficiently close trajectories issued from the current state .",
    "section 4 describes a test example and presents formulas for computer implementation .",
    "section 5 shows numerical results .",
    "in this section , we introduce the receding horizon problem for an mpc model considered in  @xcite .",
    "the finite horizon is an interval @xmath2 $ ] , where @xmath3 may depend on @xmath4 .",
    "the control input @xmath5 and parameter vector  @xmath6 are determined so as to minimize the performance index @xmath7 subject to the state dynamics @xmath8 and the equality constraints for the state @xmath9 and the control  @xmath10 @xmath11 @xmath12 the initial value condition @xmath13 for equation ( [ e1 ] ) is the state vector @xmath14 of the dynamic system .",
    "the control vector @xmath15 , solving the problem over the receding horizon , is used afterwards as an input to control the dynamic system at time  @xmath4 .",
    "let us discretize the continuous control problem stated above on a time grid @xmath16 , @xmath17 , obtained by partitioning the horizon @xmath2 $ ] into @xmath18 subintervals of size @xmath19 .",
    "the vector functions @xmath20 and @xmath5 are replaced by their values @xmath21 and @xmath22 at the grid points @xmath16 . the integral in the performance index @xmath23",
    "is approximated by the rectangular quadrature rule .",
    "equation ( [ e1 ] ) is integrated by the explicit euler method .",
    "the discretized optimal control problem is as follows : @xmath24,\\ ] ] subject to @xmath25 @xmath26 @xmath27    the necessary optimality conditions for the discretized finite horizon problem are obtained by means of the discrete lagrangian function @xmath28+\\sum_{i=0}^{n-1}\\lambda_{i+1}^t [ x_i - x_{i+1}+\\phi_i(\\tau_i , x_i , u_i , p)\\delta\\tau_i]\\\\ & & + \\sum_{i=0}^{n-1}\\mu_i^tc(\\tau_i , x_i , u_i , p)\\delta\\tau_i+\\nu^t\\psi(x_n , p),\\end{aligned}\\ ] ] where @xmath29^t$ ] , @xmath17 , and @xmath30^t$ ] , @xmath31 . here",
    ", @xmath32 is the costate vector and @xmath33 is the lagrange multiplier vector associated with constraint  ( [ e5 ] ) .",
    "the terminal constraint ( [ e6 ] ) is relaxed by the aid of the lagrange multiplier @xmath34 .",
    "the necessary optimality conditions are the kkt stationarity conditions : @xmath35 , @xmath36 , @xmath17 , @xmath37 , @xmath38 , @xmath31 , @xmath39 , @xmath40 .    for convenience in the subsequent formulations",
    ", we introduce the hamiltonian function @xmath41    the number of unknowns in the kkt conditions can be reduced by eliminating the states @xmath21 and costates @xmath42 :    \\(1 ) starting from the current measured or estimated state @xmath43 , compute @xmath21 , @xmath44 , by the forward recursion @xmath45 then starting from @xmath46 compute the costates @xmath42 , @xmath47 , by the backward recursion @xmath48 ( 2 ) combine the control input @xmath10 , the lagrange multiplier @xmath33 , the lagrange multiplier @xmath34 , and the parameter @xmath6 , all in one vector @xmath49^t.\\ ] ] calculate the mapping @xmath50 $ ] , using just obtained values @xmath21 and @xmath42 , as    @xmath51}\\\\ & & \\hspace*{-2em}=\\left[\\begin{array}{c}\\begin{array}{c } \\frac{\\partial h^t}{\\partial u}(\\tau_0,x_0,\\lambda_{1},u_0,\\mu_0,p)\\delta\\tau_0\\\\ \\vdots\\\\\\frac{\\partial h^t}{\\partial u}(\\tau_i , x_i,\\lambda_{i+1},u_i,\\mu_i , p)\\delta\\tau_i\\\\ \\vdots\\\\\\frac{\\partial h^t}{\\partial u}(\\tau_{n-1},x_{n-1},\\lambda_{n},u_{n-1 } , \\mu_{n-1},p)\\delta\\tau_{n-1}\\end{array}\\\\\\;\\\\ \\begin{array}{c}c(\\tau_0,x_0,u_0,p)\\delta\\tau_0\\\\ \\vdots\\\\c(\\tau_i , x_i , u_i , p)\\delta\\tau_i\\\\\\vdots\\\\ c(\\tau_{n-1},x_{n-1},u_{n-1},p)\\delta\\tau_{n-1}\\end{array}\\\\\\;\\\\ \\psi(x_n , p)\\\\[2ex ] \\begin{array}{c}\\frac{\\partial\\phi^t}{\\partial p}(x_n , p)+ \\frac{\\partial\\psi^t}{\\partial p}(x_n , p)\\nu\\\\ + \\sum_{i=0}^{n-1}\\frac{\\partial h^t}{\\partial p}(\\tau_i , x_i , \\lambda_{i+1},u_i,\\mu_i , p)\\delta\\tau_i\\end{array } \\end{array}\\right].\\end{aligned}\\ ] ]    the vector argument @xmath9 in @xmath50 $ ] denotes the initial vector @xmath43 in the forward recursion .    the equation with respect to the unknown vector @xmath52 @xmath53=0\\ ] ] gives the required necessary optimality conditions that are solved on the controller in real time .",
    "the controlled dynamic system is sampled on a discrete time grid @xmath54 , @xmath55 .",
    "the sampled values of the state and parameters are @xmath56 and @xmath57 . choosing a small @xmath58 , which is usually much less than @xmath59 and @xmath60",
    ", we introduce the operator @xmath61-f[u_{j-1},x_j , t_j])/h.\\ ] ] the discrete equation @xmath62=0 $ ] is then equivalent to the operator equation @xmath63 , where @xmath64 , @xmath65 $ ] .",
    "this operator equation allows us to compute @xmath66 , if @xmath67 is known .",
    "let us denote the @xmath68-th column of the @xmath69 identity matrix by @xmath70 , where @xmath71 is the dimension of the vector @xmath72 , and form an @xmath69 matrix @xmath73 with the columns @xmath74 , @xmath75 .",
    "the matrix @xmath73 is an @xmath76 approximation of the jacobian matrix @xmath77 $ ] , which is symmetric .",
    "we suppose that @xmath78 is an approximate solution to the equation @xmath79=0 $ ] and omit discussion of methods for computing @xmath78 .",
    "the first block entry of @xmath78 is taken as the control @xmath80 at the state @xmath43 .",
    "the next state @xmath81 is either sensor estimated or computed by the formula @xmath82 ; cf .",
    "( [ e4 ] ) .    at the time @xmath54 , @xmath83",
    ", we have the state @xmath84 and the vector @xmath67 evaluated at the previous time @xmath85 .",
    "we solve the following operator equation with respect to @xmath86 : @xmath87 then we set @xmath88 , @xmath89 and choose the first block component of @xmath66 as the control @xmath90 .",
    "the next system state @xmath91 is either sensor estimated or computed by the formula @xmath92 .",
    "an approximate solution to ( [ e7 ] ) can be found by computing the matrix @xmath73 and then solving the system of linear equations @xmath93 by the gaussian elimination with pivoting .",
    "a more efficient way is solving ( [ e7 ] ) by the gmres method , where the operator @xmath94 is used instead of @xmath73 as in @xcite and @xcite .",
    "convergence of gmres can be accelerated by preconditioning .",
    "a matrix @xmath95 that is close to the matrix @xmath96 and such that computing @xmath97 for an arbitrary vector @xmath98 is relatively easy , is referred to as a preconditioner .",
    "the preconditioning for the system of linear equations @xmath99 with the preconditioner @xmath95 formally replaces the original system @xmath99 with the equivalent preconditioned linear system @xmath100 . when the condition number @xmath101 is sufficiently small , convergence of the preconditioned gmres is fast .",
    "the vector @xmath102 is often computed via back - substitutions as @xmath103 , where @xmath104 and @xmath72 are the triangular factors in the lu factorization @xmath105 computed by the gaussian elimination .",
    "@xcite compute the matrix @xmath73 exactly for some time instances @xmath54 and use it as a preconditioner for gmres at a number of subsequent time instances @xmath54 , @xmath106 , ",
    ", @xmath107 .    in the present paper ,",
    "we suggest to apply the above described numerical method in more general situations , where the dynamic system and/or constraints depend on a discrete parameter , or switch , with few values @xmath108 ,  , @xmath109 .",
    "in other words , there are @xmath109 functions @xmath110 and @xmath109 mappings @xmath111 , @xmath112 , and at each time instance @xmath54 we must select @xmath68 such that the performance index is minimized .    the numerical method is modified as follows . at the time @xmath54 , @xmath83 ,",
    "the system state is given by @xmath84 , and we have the vector @xmath67 evaluated at the previous time @xmath85",
    ". since there are @xmath109 mappings @xmath113 , we must solve @xmath109 operator equations with respect to @xmath86 : @xmath114 solutions @xmath115 with low precision can be discarded or refined . in the set of admissible solutions @xmath115",
    ", we select the solution @xmath116 with minimum performance index .",
    "then we set @xmath117 , @xmath89 and choose the first block component of @xmath66 as the control @xmath90 .",
    "the next system state @xmath91 is either sensor estimated or computed by the formula @xmath118 .",
    "equations ( [ e8 ] ) are solved by gmres independently . however , a preconditioner for all @xmath68 can be a single matrix @xmath73 , which is evaluated for some suitable @xmath68 .",
    "the vector @xmath67 satisfies @xmath119 .",
    "when each of the @xmath109 equations @xmath120 is solved by the newton method , it may succeed only if all the residuals @xmath121 are sufficiently small , or at least some of them .",
    "thus , the changes by the discrete switches should not be too radical , which is the main limitation of the modified method .",
    "we consider a minimum - time problem on the two - dimensional plane from a state @xmath122 to a state @xmath123 with inequality constraints .",
    "the system dynamics is governed by the system of differential equations @xmath124=",
    "\\left[\\begin{array}{c}(ax+b)\\cos u\\\\(ax+b)\\sin u\\end{array}\\right].\\ ] ] the control variable @xmath10 is subject to an inequality constraint : @xmath10 stays within the band @xmath125 . following @xcite we introduce a slack variable @xmath126 and replace the inequality constraint by the equality @xmath127 the state is forced to pass through the point @xmath123 at time @xmath128 by imposing two terminal constraints @xmath129=0.\\ ] ] the objective is to minimize the performance index @xmath130 where @xmath131 the term @xmath132 is responsible for the shortest time to destination , and the function @xmath104 serves to stabilize the slack variable @xmath126 .    for convenience , we change the time variable @xmath4 within the horizon by the new time @xmath133 , which runs over the interval @xmath134 $ ] .",
    "the corresponding discretized finite - horizon problem on a uniform grid @xmath16 uses the following data structures and computations :    * @xmath135 , where @xmath17 , and @xmath136 ; * the participating variables are the state @xmath137 $ ] , the costate @xmath138 $ ] , the control @xmath139 $ ] , the lagrange multipliers @xmath140 and @xmath141 $ ] ; * the system dynamics is governed by the equations @xmath142 where @xmath31 ; * the costate is computed by the backward recursion ( @xmath143 , @xmath144 ) @xmath145 where @xmath146 ; * the nonlinear equation @xmath147 , where @xmath148,\\end{aligned}\\ ] ] has the following rows from the top to bottom : @xmath149 = 0\\end{array}\\hspace*{2em}\\right.\\ ] ] @xmath150 = 0\\hspace*{12em}\\right.\\ ] ] @xmath151=0 \\right.\\hspace*{8em}\\ ] ] @xmath152 @xmath153",
    "we set @xmath154 and consider @xmath109 cases of the system dynamics simultaneously .",
    "the cases are determined by the three pairs of constants : @xmath155 , @xmath156 , @xmath157 .",
    "other parameters are the same in all cases : the end points of the computed trajectory are @xmath158 and @xmath159 ; the constants in the inequality constraint for the control are @xmath160 and @xmath161 ; @xmath162 .",
    "the number of grid points on the horizon is @xmath163 , the time step of the dynamic system is @xmath164 , the numerical differentiation step is @xmath165 .",
    "the value of @xmath72 at time @xmath166 is approximated by the matlab function ` fsolve ` with a special initial guess .",
    "we use the gmres method without restarts implemented in matlab .",
    "the number of gmres iterations does not exceed @xmath167 , and the absolute tolerance of the gmres iterations equals @xmath168 .",
    "we apply a simple preconditioning strategy as follows .",
    "the exact jacobian @xmath169 is computed periodically at time instances with the period @xmath170 .",
    "then the lu factorization of the jacobian is used as the preconditioner until the next time when it is recomputed .",
    "figure  [ fig1 ] displays the computed trajectory for the test problem with automatic switches in the system dynamics .",
    "time to destination along this trajectory at the initial point @xmath122 is @xmath171 .",
    "figure  [ fig2 ] plots the control @xmath172 computed by our method .",
    "figure  [ fig3 ] shows how the system dynamics switch between @xmath173 along the trajectory : first 95 steps are executed with @xmath174 , then 18 steps with @xmath175 , and last 79 steps with @xmath176 . the residual norm @xmath177 is shown in figure  [ fig4 ] .",
    "we observe in figure  [ fig2 ] that during a switch to another pair of @xmath173 , the control @xmath172 undergoes abrupt change .",
    "the corresponding deterioration of the norm @xmath177 at these points is seen in figure  [ fig4 ] .",
    "the method continues to work while the deterioration is sufficiently small .",
    "a robust implementation of our method should verify @xmath177 when switching between discrete parameters .",
    "figures  [ fig5 ] and [ fig6 ] show the number of gmres iterations in the non - preconditioned and preconditioned variants , respectively . the variant without preconditioning uses 4920 iterations in total . the variant with preconditioning uses 2216 iterations in total",
    "]    . ]     of the chosen pair @xmath173 . ]    . ]",
    "the numerical method , developed for nonlinear mpc problems in @xcite , can be used in cases , when an ensemble of near solutions for the finite - horizon prediction have to be computed simultaneously .",
    "the reduction of computing time may be achieved by using parallel processors for each prediction and/or by using a single preconditioner for the whole ensemble .",
    "m.  diehl , h.  j.  ferreau , and n.  haverbeke .",
    "efficient numerical methods for nonlinear mpc and moving horizon estimation .",
    "l.  magni et al . ( eds . ) : _ nonlinear model predictive control _ , lncis 384 , pp .  391417 , springer , heidelberg , 2009 ."
  ],
  "abstract_text": [
    "<S> continuation model predictive control ( mpc ) , introduced by t. ohtsuka in 2004 , uses krylov - newton approaches to solve mpc optimization and is suitable for nonlinear and minimum time problems . </S>",
    "<S> we suggest particle continuation mpc in the case , where the system dynamics or constraints can discretely change on - line . </S>",
    "<S> we propose an algorithm for on - line controller implementation of continuation mpc for ensembles of predictions corresponding to various anticipated changes and demonstrate its numerical effectiveness for a test minimum time problem arriving to a destination . </S>",
    "<S> simultaneous on - line particle computation of ensembles of controls , for several dynamically changing system dynamics , allows choosing the optimal destination on - line and adapt it as needed .    </S>",
    "<S> nonlinear model predictive control , particle control , newton - krylov method </S>"
  ]
}