{
  "article_text": [
    "today s hardware technology provides a hierarchy of storage media from tapes and disks at the bottom through main memory and ( even on - cpu ) memory caches at the top . storage media from different levels of this memory hierarchy considerably differ in price , storage size , and access time .",
    "currently , the most pronounced performance and price ( and consequently also size ) gap is between main memory and the next - lower level in the memory hierarchy , usually magnetic disks which have to rely on comparably slow , mechanical , physically moving parts .",
    "one often refers to the upper layers above this gap by _ internal memory _ and the lower layers of the memory hierarchy by _",
    "external memory_. the technological reality is such that the time for accessing a given bit of information in external memory is five to six orders of magnitude larger than the time required to access a bit in internal memory .",
    "apart from this , concerning external memory , _ random accesses _ ( which involve moving the disk head to a particular location ) are significantly more expensive than _ sequential scans_.    modern software and database technology uses clever heuristics to minimize the number of accesses to external memory and to prefer _ streaming _ over _ random accesses _ to external memory .",
    "there has also been a wealth of research on the design of so - called _ external memory algorithms _ ( cf .",
    ", e.g.  @xcite ) .",
    "the classes considered in _ computational complexity theory _",
    ", however , usually do not take into account the existence of different storage media . in @xcite , we introduced a formal model for such a scenario .",
    "the two most significant cost measures in our setting are the number of random accesses to external memory and the size of the internal memory .",
    "our model is based on a standard multi - tape turing machine .",
    "some of the tapes of the machine , among them the input tape , represent the external memory .",
    "they are unrestricted in size , but access to these tapes is restricted by allowing only a certain number @xmath3 ( where @xmath2 denotes the input size ) of reversals of the head directions .",
    "this may be seen as a way of ( a ) restricting the number of sequential scans and ( b ) restricting random access to these tapes , because each random access can be simulated by moving the head to the desired position on a tape , which involves at most two head reversals .",
    "the remaining tapes of the turing machine represent the internal memory .",
    "access to these internal memory tapes ( i.e. , the number of head reversals ) is unlimited , but their size is bounded by a parameter @xmath4 .",
    "we let @xmath5 denote the class of all problems that can be solved on such an @xmath6-bounded turing machine , i.e. , a turing machine with an arbitrary number of external memory tapes which , on inputs of size @xmath2 , performs less than @xmath3 head reversals on the external memory tapes , and uses at most space @xmath4 on the internal memory tapes .",
    "the astute reader who wonders if it is realistic to assume that the external memory tapes can be read in _ both _ directions ( which disks can not so easily ) and that a sequential scan of an entire external memory tape accounts for only one head reversal ( and thus seems unrealistically cheap ) be reminded that this paper s main goal is not to design efficient external memory algorithms but , instead , to prove _ lower _ bounds .",
    "thus , considering a rather powerful computation model makes our lower bound results only stronger .    in the present paper , we prove lower bounds for _ randomized _ computations ( i.e. , computations where in each step a coin may be tossed to determine the next configuration ) in a scenario with several storage media . to this end , we introduce the complexity class @xmath7 , which consists of all decision problems that can be solved by an @xmath6-bounded randomized turing machine with one - sided bounded error , where no false positive answers are allowed and the probability of false negative answers is at most @xmath8 ( in the literature , such randomized algorithms are often called _ one - sided - error monte carlo algorithms _ , cf .",
    "@xcite ) . to also deal with computation problems where an output ( other than just a yes / no answer ) has to be generated , we write @xmath9 to denote the class of all functions @xmath10 for which there exists an @xmath6-bounded randomized turing machine that , for every input word @xmath11 , ( a ) always produces either the correct output @xmath12 on one of its external memory tapes or gives the answer _",
    "`` i do nt know '' _ and ( b ) gives the answer _",
    "`` i do nt know '' _ with probability at most @xmath8 ( in the literature , such randomized algorithms are sometimes called",
    "_ las vegas algorithms _ , cf .",
    "@xcite ) . +",
    "* contributions : * our first main result is a lower bound for three natural decision problems : the _ set equality problem _ and the _ multiset equality problem _ ask whether two given ( multi)sets of strings are equal , and the _ checksort problem _ asks , given two sequences of strings , whether the second is a sorted version of the first . + we show ( ) that neither problem is contained in @xmath13{n}}{\\log n}),o(1))$ ] .",
    "this lower bound turns out to be _ tight _ in the following senses :    1 .   if the number of sequential scans ( i.e. , head reversals ) increases from @xmath14 to @xmath15 , then each of the three problems can be solved with only constant internal memory and without using randomization . in other words",
    "( see corollary  [ cor : tight - bounds - for - short - versions ] ) , the ( multi)set equality problem and the checksort problem belong to @xmath16 .",
    "when using randomization with the complementary one - sided error model , i.e. , machines where no false negative answers are allowed and the probability of false positive answers is at most 0.5 , then the _ multiset equality _ problem can be solved with just two sequential scans of the input ( and without ever writing to external memory ) , and internal memory of size @xmath15 . in other words ( theorem  [ thm : efficient - randomized / ndet - solutions](a ) ) , the multiset equality problem belongs to @xmath17 .",
    "when using nondeterministic machines , then ( multi)set equality and checksort can be solved with three sequential scans on two external memory tapes and internal memory of size @xmath15 . in other words ( theorem  [ thm : efficient - randomized / ndet - solutions](b ) ) , the ( multi)set equality problem and the checksort problem belong to @xmath18 .    as a consequence ,",
    "we obtain a separation between the deterministic , the randomized , and the nondeterministic @xmath19 classes ( corollary  [ cor : detvsrandvsndet ] ) .",
    "our lower bound for the checksort problem , in particular , implies that the _ sorting problem _",
    "( i.e. , the problem of sorting a sequence of input strings ) does not belong to the complexity class @xmath20{n}}{\\log n}),o(1))$ ] and thus generalizes the main result of @xcite to randomized computations .",
    "our lower bound for the set equality problem leads to the following lower bounds on the worst case data complexity of database query evaluation problems in a streaming context :    1 .",
    "there is an _ xquery _ query @xmath21 such that the problem of evaluating @xmath21 on an input xml document stream of length @xmath2 does _ not _ belong to the class @xmath20{n}}{\\log n}),o(1))$ ] ( theorem  [ thm : xquery ] ) .    speaking informally ,",
    "this means that , no matter how many external memory devices ( of arbitrarily large size ) are available , as long as the internal memory is of size at most @xmath22{n}}{\\log n})$ ] , every randomized algorithm that produces the correct query result with probability at least @xmath8 will perform @xmath0 random accesses to external memory .",
    "we obtain analogous results for _ relational algebra _ queries and for the node - selecting xml query language _ xpath _ :",
    "1 .   there is a _ relational algebra _",
    "query @xmath21 such that the problem of evaluating @xmath21 on a stream consisting of the tuples of the input database relations does _ not _ belong to the complexity class @xmath20{n}}{\\log n}),o(1))$ ] , where @xmath2 denotes the total size of the input database relations .",
    "furthermore , this bound is tight with respect to the number of random accesses to external memory , as the data complexity of every relational algebra query belongs to @xmath16 ( theorem  [ thm : relalgebra ] ) .",
    "2 .   there is an _ xpath _",
    "query @xmath21 such that the problem of filtering an input xml document stream with @xmath21 ( i.e. , checking whether at least one node of the document matches the query ) does _ not _ belong to the class @xmath23{n}}{\\log n}),o(1))$ ] ( theo - rem  [ thm : xpath ] ) .",
    "this means that there is an _",
    "query @xmath21 such that , no matter how many external memory devices ( of arbitrarily large size ) are available , as long as the internal memory is of size at most @xmath22{n}}{\\log n})$ ] , every randomized algorithm which accepts every input document that matches @xmath21 , and which rejects documents not matching @xmath21 with probability @xmath24 , will perform @xmath0 random accesses to external memory .",
    "+ * related work : * obviously , our model is related to the _ bounded reversal turing machines _ , which have been studied in classical complexity theory ( see , e.g. , @xcite ) .",
    "however , in bounded reversal turing machines , the number of head reversals is limited on _ all _ tapes , whereas in our model there is no such restriction on the internal memory tapes .",
    "this makes our model considerably stronger , considering that in our lower bound results we allow internal memory size that is polynomially related to the input size .",
    "furthermore , to our best knowledge , all lower bound proofs previously known for reversal complexity classes on multi - tape turing machines go back to the space hierarchy theorem ( cf . , e.g. , @xcite ) and thus rely on diagonalization arguments , and apply only to classes with @xmath25 head reversals . in particular",
    ", these lower bounds do not include the checksort problem and the ( multi)set equality problem , as these problems can be solved with @xmath15 head reversals .    in the classical _ parallel disk model _ for external memory algorithms ( see , e.g. , @xcite ) , the cost measure is simply the number of bits read from external memory divided by the page size .",
    "several refinements of this model have been proposed to include a distinction between _ random access _ and _ sequential scans _ of the external memory , among them arge and bro miltersen s _ external memory turing machines _",
    "we note that their notion of external memory turing machines significantly differs from ours , as their machines only have a single external memory tape and process inputs that consist of a _ constant _ number @xmath26 of input strings .",
    "strong lower bound results ( in particular , for different versions of the _ sorting problem _ ) are known for the parallel disk model ( see @xcite for an overview ) as well as for arge and bro miltersen s external memory turing machines @xcite . however , to the best of our knowledge , all these lower bound proofs heavily rely on the assumption that the input data items ( e.g. , the strings that are to be sorted ) are _ indivisible _ and that at any point in time , the external memory consists , in some sense , of a permutation of the input items .",
    "we emphasize that the present paper s lower bound proofs do not rely on such an indivisibility assumption .",
    "strong lower bounds for a number of problems are known in the context of _ data streams _ and for models which permit a small number of sequential scans of the input data , but no auxiliary external memory ( that is , the version of our model with no extra external memory tapes apart from the input tape ) @xcite .",
    "all these lower bounds are obtained by communication complexity .",
    "note that in the presence of at least two external memory tapes , communication between remote parts of memory is possible by simply copying data from one tape to another and then re - reading both tapes in parallel .",
    "these communication abilities of our model spoil any attempt to prove lower bounds via communication complexity , which is the tool of choice both for computation models permitting few scans but no auxiliary external memory , and for 1-tape turing machines .",
    "the deterministic @xmath19-classes were introduced in @xcite .",
    "in @xcite we studied those classes where only a _",
    "external memory tape is available and used methods from communication complexity to obtain lower bounds for these classes .",
    "the main result of @xcite was a lower bound for the _ sorting problem _ concerning the deterministic @xmath19-classes with an _ arbitrary _ number of external memory tapes .",
    "an important tool for proving this bound was to introduce deterministic _ list machines _ as an intermediate machine model .",
    "an overview of the methods used and the results obtained in @xcite was given in @xcite .",
    "the present paper builds on @xcite , as it considers @xmath19-classes with an _ arbitrary _ number of external memory tapes and it uses _ list machines _ as a key tool for proving lower bound results .",
    "however , the results presented here go significantly beyond those obtained in @xcite . here",
    "we obtain lower bounds for _ decision _ problems in the _ randomized _ versions of the model .",
    "the main result of @xcite is that the sorting problem does not belong to @xmath27{n}}{\\log n}\\big),\\bigo(1))$ ] , and the proof given there heavily relies on the fact that the machines are _",
    "deterministic _ and the _ output _ of the sorting problem can not be generated within the given resource bounds .",
    "in contrast to the present paper s approach , the proof method of @xcite neither works for decision problems , i.e.  problems where no output is generated , nor for randomized computations .",
    "finally , let us remark that the main result of @xcite can be obtained as an immediate corollary of the present paper s lower bound for the checksort problem .",
    "+ * organization : * after introducing the deterministic , the nondeterministic , and the randomized @xmath19 classes in section  [ section : classst ] , we formally state our main lower bounds for decision problems in section  [ section : mainresults ] . in section",
    "[ section : mainresults_queryeval ] we use these results to derive lower bounds on the data complexity of query evaluation for the languages _ xquery _ , _ xpath _ , and _",
    "relational algebra_. the subsequent sections are devoted to the proof of the lower bound on the decision problems _",
    "( multi)set equality _ and _ checksort _ : in section  [ section : listmachines ] , [ section : simulationlemma ] , and [ section : lowerboundsforlm ] we introduce randomized _ list machines _ , show that randomized turing machines can be simulated by randomized list machines , and prove that randomized list machines can neither solve the _ ( multi)set equality problem _ nor the _ checksort problem_. afterwards , in section  [ section : boundsfortms ] we transfer these results from list machines to turing machines .",
    "we close with a few concluding remarks and open problems in section  [ section : conclusion ] .",
    "the present paper is the full version of the extended abstract published in the proceedings of the 25th acm sigact - sigart symposium on principles of database systems ( pods06 ) .",
    "we write @xmath28 to denote the set of natural numbers ( that is , nonnegative integers ) .    as our basic model of computation , we use standard multi - tape nondeterministic turing machines ( ntms , for short ) ; cf . , e.g. , @xcite .",
    "the turing machines we consider will have @xmath29 tapes .",
    "we call the first @xmath30 tapes _ external memory tapes _ ( and think of them as representing @xmath30 disks ) .",
    "we call the other @xmath31 tapes _ internal memory tapes_. the first tape is always viewed as the input tape .    without loss of generality",
    "we assume that our turing machines are normalized in such a way that in each step at most one of its heads moves to the left or to the right .",
    "let @xmath32 be an ntm and @xmath33 a finite run of @xmath32 .",
    "let @xmath34 be the number of a tape .",
    "we use @xmath35 to denote the number of times the head on tape @xmath36 changes its direction in the run @xmath33 .",
    "furthermore , we let @xmath37 be the number of cells of tape @xmath36 that are used by @xmath33 .    [ def : boundedtm ] let @xmath38 and @xmath39 .",
    "a ( nondeterministic ) turing machine @xmath32 is _ @xmath40-bounded _ , if every run @xmath33 of @xmath32 on an input of length @xmath2 ( for arbitrary @xmath41 ) satisfies the following conditions : ( 1 )  @xmath33 is finite , ( 2 )  @xmath42 , and to the number @xmath43 of changes of the head direction here . as defined here",
    ", @xmath3 thus bounds the number of sequential scans of the external memory tapes rather than the number of changes of head directions . ] ( 3 )  @xmath44 , where @xmath29 is the total number of tapes of @xmath32 .",
    "[ def : st ] + let @xmath38 and @xmath39 .",
    "a decision problem belongs to the class @xmath45 ( resp . , @xmath46 ) , if it can be decided by a deterministic ( resp .",
    ", nondeterministic ) @xmath40-bounded turing machine .",
    "note that we put no restriction on the running time or the space used on the first @xmath30 tapes of an @xmath40-bounded turing machine .",
    "the following lemma shows that these parameters can not get too large .",
    "[ lem : time ] let @xmath38 and @xmath39 , and let @xmath32 be an @xmath40-bounded ntm .",
    "then for every run @xmath47 of @xmath32 on an input of size @xmath2 we have @xmath48 and thus @xmath49    in @xcite , the lemma has only been stated and proved for deterministic turing machines , but it is obvious that the same proof also applies to nondeterministic machines ( to see this , note that , by definition , _ every _ run of an @xmath40-bounded turing machine is finite ) .    in analogy to the definition of _ randomized _ complexity classes such as the class @xmath50 of randomized polynomial time ( cf .",
    ", e.g. , @xcite ) , we consider the randomized versions @xmath51 and @xmath52 of the @xmath19 and @xmath53 classes .",
    "the following definition of randomized turing machines formalizes the intuition that in each step , a coin can be tossed to determine which particular successor configuration is chosen in this step . for a configuration @xmath54 of an ntm @xmath32 , we write @xmath55 to denote the set of all configurations @xmath56 that can be reached from @xmath54 in a single step . each such configuration @xmath57 is chosen with uniform probability , i.e. , @xmath58 . for a run @xmath59 , the probability @xmath60 that @xmath32 performs run",
    "@xmath33 is the product of the probabilities @xmath61 , for all @xmath62 . for an input word @xmath11 , the probability that @xmath32 accepts @xmath11 ( resp .",
    ", that @xmath32 outputs @xmath63 ) is defined as the sum of @xmath60 for all accepting runs @xmath33 of @xmath32 on input @xmath11 ( resp .",
    ", of all runs of @xmath32 on @xmath11 that output @xmath63 ) .",
    "we say that a decision problem @xmath64 is solved by a @xmath65-rtm if , and only if , there is an ntm @xmath32 such that every run of @xmath32 has finite length , and the following is true for all input instances @xmath11 : if @xmath66 , then @xmath67 ; if @xmath68 , then @xmath69 .",
    "similarly , we say that a function @xmath70 is computed by a _ _",
    "lasvegas-__rtm if , and only if , there is an ntm @xmath32 such that every run of @xmath32 on every input instance @xmath11 has finite length and outputs either @xmath12 or _",
    "`` i do nt know '' _ , and @xmath71 .",
    "[ def : rst ] + let @xmath72 and @xmath73 .",
    "a.   a decision problem @xmath64 belongs to the class @xmath74 , if it can be solved by a @xmath65-rtm that is @xmath40-bounded .",
    "b.   a function @xmath70 belongs to @xmath75 , if it can be solved by a _",
    "lasvegas_-rtm that is @xmath40-bounded .    as a straightforward observation one obtains :    [ prop : detvsrandvsndet ] for all @xmath72 and @xmath73 , + @xmath76 .    for classes @xmath77 and @xmath78 of functions we let @xmath79 and @xmath80 .",
    "analogous notations are used for the @xmath53 , @xmath51 , and @xmath81 classes , too .    as usual , for every ( complexity ) class @xmath82 of decision problems",
    ", @xmath83 denotes the class of all decision problems whose _ complements _ belong to @xmath82 . note that the @xmath51-classes consist of decision problems that can be solved by randomized algorithms that allow a moderate number of false negatives , but no false positives .",
    "in contrast to this , the @xmath84-classes consist of problems that can be solved by randomized algorithms that allow a moderate number of false positives , but no false negatives .    from lemma  [ lem : time ]",
    ", one immediately obtains for all functions @xmath85 with @xmath86 that @xmath87 , @xmath88 , and @xmath89 ( where @xmath90 , @xmath91 , and @xmath92 denote the class of problems solvable in polynomial time on deterministic , randomized , and nondeterministic turing machines , respectively ) .",
    "our first main result is a lower bound for the _ ( multi)set equality problem _ as well as for the _ checksort problem_. the _ ( multi)set equality problem _ asks if two given ( multi)sets of strings are the same .",
    "the _ checksort problem _ asks for two input lists of strings whether the second list is the lexicographically sorted version of the first list .",
    "we encode inputs as strings over the alphabet @xmath93 .",
    "formally , the _ ( multi)set equality _ and the _ checksort _ problem are defined as follows : the input instances of each of the three problems are    _",
    "instance : _ : :    @xmath94 , +    where @xmath95 , and @xmath96    ( for all @xmath97 )    and the task is to decide the following :    _  @xmath98 problem : _ : :     +    decide if @xmath99 .",
    "_  @xmath100 problem : _ : :     +    decide if the multisets @xmath101 and    @xmath102 are equal ( i.e. , they contain the    same elements with the same multiplicities ) .",
    "_  @xmath103 problem : _ : :     +    decide if @xmath104 is the lexicographically    sorted ( in ascending order ) version of @xmath105 .    for an instance @xmath106 of the above problems",
    ", we usually let @xmath107 denote the size of the input . furthermore ,",
    "in our proofs we will only consider instances where all the @xmath108 and @xmath109 have the same length @xmath110 , so that @xmath111 .",
    "the present paper s technically most involved result is the following lower bound :    [ theo : set - equality ] let @xmath38 such that @xmath112 and @xmath113n / r(n)\\right)$ ] .",
    "then , none of the problems , , belongs to the class @xmath7 .",
    "sections  [ section : listmachines][section : boundsfortms ] are devoted to the proof of theorem  [ theo : set - equality ] .",
    "the proof uses an intermediate computation model called _ list machines _ and proceeds by ( 1 ) showing that randomized turing machine computations can be simulated by randomized list machines that have the same acceptance probabilities as the given turing machines and ( 2 ) proving a lower bound for @xmath114 and @xmath103 on randomized list machines .    by applying the reduction used in (",
    "* theorem 9 ) , we obtain that the lower bound of theorem  [ theo : set - equality ] also applies for the `` @xmath115 '' versions of @xmath114 and @xmath103 , i.e. , the restrictions of these problems to inputs of the form @xmath116 , where each @xmath108 and @xmath117 is a 0 - 1-string of length at most @xmath118 , and @xmath119 is an arbitrary constant @xmath120 . by using the standard _ merge sort _ algorithm , one easily obtains that the `` @xmath115 '' versions of @xmath114 and @xmath103 belong to @xmath121 .",
    "moreover , in ( * ? ? ?",
    "* lemma7 ) it has been shown that the ( general ) sorting problem can be solved by an @xmath122-bounded deterministic turing machine . as an immediate consequence ,",
    "we obtain :    [ cor : tight - bounds - for - short - versions ] , , check - sort , and their `` @xmath115 '' versions , are in @xmath123 , but not in @xmath124{n}/\\log n),o(1))$ ] .    a detailed proof can be found in appendix  [ appendix : proofsofcorollaries ] .",
    "+ as a further result , we show that    [ thm : efficient - randomized / ndet - solutions ]    a.   [ thm : efficient - randomized / ndet - solutions : corst ] @xmath100 belongs to + @xmath125 .",
    "b.   [ thm : efficient - randomized / ndet - solutions : nst ] each of the problems @xmath100 , @xmath103 , @xmath98 belongs to  @xmath18 .    _",
    "( [ thm : efficient - randomized / ndet - solutions : corst ] ) : _ we apply fairly standard _ fingerprinting techniques _ and show how to implement them on a @xmath126-bounded randomized turing machine .",
    "consider an instance @xmath127 of the @xmath100 problem .",
    "for simplicity , let us assume that all the @xmath108 and @xmath128 have the same length @xmath110 .",
    "thus the input size @xmath2 is @xmath129 .",
    "we view the @xmath108 and @xmath109 as integers in @xmath130 represented in binary .",
    "we use the following algorithm to decide whether the multisets @xmath101 and @xmath131 are equal :    1 .   during a first sequential scan of the input , determine the input parameters @xmath110 , @xmath26 , and @xmath2 .",
    "2 .   choose a prime @xmath132 uniformly at random .",
    "3 .   choose an arbitrary prime @xmath133 such that @xmath134 .",
    "such a prime exists by bertrand s postulate .",
    "4 .   choose @xmath135 uniformly at random .",
    "5 .   for @xmath136 , let @xmath137 and @xmath138 .",
    "if @xmath139 then accept , else reject .",
    "let us first argue that the algorithm is correct ( for sufficiently large @xmath140 ) : clearly , if the multisets @xmath101 and @xmath131 are equal then the algorithm accepts . on the other hand , if they are distinct , the probability that the multisets @xmath141 and @xmath142 are equal is @xmath143 .",
    "this is due to the following .    [ claim : randomprime ] let @xmath144 , @xmath145 , and @xmath146 .",
    "then for a prime @xmath147 chosen uniformly at random , @xmath148    we use the following well - known result ( see , for example , theorem 7.5 of @xcite ) : let @xmath149 , @xmath150 , and @xmath151 .",
    "then for a prime @xmath147 chosen uniformly at random , @xmath152 the claim then follows if we apply this result with @xmath153 simultaneously to the at most @xmath154 numbers @xmath155 with @xmath156 .",
    "+ to proceed with the proof of theorem  [ thm : efficient - randomized / ndet - solutions](_[thm : efficient - randomized / ndet - solutions : corst ] _ ) , suppose that the two multisets are distinct",
    ". then the polynomial @xmath157 is nonzero .",
    "note that all coefficients and the degree of @xmath158 are at most @xmath159 .",
    "we view @xmath158 as a polynomial over the field @xmath160 . as a nonzero polynomial of degree at most @xmath161",
    ", it has at most @xmath161 zeroes .",
    "thus the probability that @xmath162 for the randomly chosen @xmath135 is at most @xmath163 .",
    "therefore , if the multisets @xmath141 and @xmath142 are distinct , the algorithm accepts with probability at most @xmath164 , and the overall acceptance probability is at most @xmath165 for sufficiently large @xmath26 .",
    "this proves the correctness of the algorithm .",
    "let us now explain how to implement the algorithm on a @xmath166-bounded randomized turing machine .",
    "note that the binary representations of the primes @xmath161 and @xmath133 have length @xmath15 .",
    "the standard arithmetical operations can be carried out in linear space on a turing machine .",
    "thus with numbers of length @xmath15 , we can carry out the necessary arithmetic on the internal memory tapes of our @xmath126-bounded turing machine .    to choose a random prime @xmath161 in step ( 2 ) ,",
    "we simply choose a random number @xmath167 and then test if it is prime , which is easy in linear space . if the number is not prime , we repeat the procedure , and if we do this sufficiently often , we can find a random prime with high probability . steps ( 3 ) and ( 4 ) can easily be carried out in internal memory . to compute the number @xmath168 in step ( 5 ) ,",
    "we proceed as follows : suppose the binary representation of @xmath108 is @xmath169 , where @xmath170 is the least significant bit .",
    "observe that @xmath171 we can evaluate this sum sequentially by taking all terms modulo @xmath161 ; this way we only have to store numbers smaller than @xmath161 .",
    "this requires one sequential scan of @xmath108 and no head reversals .    to evaluate the polynomial @xmath172 modulo @xmath133 , we proceed as follows : let @xmath173 and @xmath174 .",
    "again we can compute the sum sequentially by computing @xmath168 , @xmath175 , and @xmath176 for @xmath177 .",
    "we can evaluate @xmath178 analogously and then test if holds .",
    "this completes the proof of part ( _ [ thm : efficient - randomized / ndet - solutions : corst ] _ ) of theorem  [ thm : efficient - randomized / ndet - solutions ] .",
    "_ ( b ) : _ let @xmath11 be an input of length @xmath2 , @xmath179 . note that the multisets @xmath180 and @xmath181 are equal if and only if there is a permutation @xmath182 of @xmath183 such that for all @xmath184 , @xmath185 .",
    "the idea is to `` guess '' such a permutation @xmath182 ( suitably encoded as a string over @xmath186 ) , to write sufficiently many copies of the string @xmath187 onto the first tape , and finally solve the problem by comparing @xmath108 and @xmath188 bitwise , where in each step we use the next copy of @xmath31 .    a @xmath189-bounded nondeterministic turing machine @xmath190 can do this as follows . in a forward scan",
    ", it nondeterministically writes a sequence @xmath191 of @xmath192 many strings on its first and on its second tape , where @xmath193 for binary numbers @xmath194 from @xmath183 , and bit strings @xmath195 and @xmath196 of length at most @xmath2 . while writing the first @xmath197 strings , it ensures that for every @xmath198 , either @xmath199 and @xmath200 coincide on bit @xmath201 , or that both strings have no such bit at all .",
    "while writing the last @xmath26 strings , it ensures that for all @xmath184 and @xmath202 , @xmath203 . finally , @xmath190 checks in a backward scan of both external memory tapes that @xmath204 for all @xmath205 , and that @xmath206 and @xmath207 for all @xmath208 .",
    "the @xmath98 problem can be solved in a similar way .",
    "deciding @xmath103 is very similar : the machine additionally has to check that @xmath117 is smaller than or equal to @xmath209 for all @xmath210 .",
    "this can be done , e.g. , by writing @xmath211 additional copies of @xmath31 , and by comparing @xmath117 and @xmath209 bitwise on these strings for each @xmath36 and @xmath210 .",
    "theorems  [ theo : set - equality ] and [ thm : efficient - randomized / ndet - solutions ] , in particular , immediately lead to the following separations between the deterministic , randomized , and nondeterministic @xmath19 classes :    [ cor : detvsrandvsndet ] let @xmath38 with @xmath212  and  @xmath213n / r(n)\\right)\\cap \\omega(\\log n)$ ] . then ,    a.   @xmath214 , b.   @xmath215 + @xmath216 .",
    "the ( straightforward ) proof can be found in appendix  [ appendix : proofsofcorollaries ] .",
    "let us note that the lower bound of theorem  [ theo : set - equality ] for the problem @xmath103 in particular implies the following generalization of the main result of @xcite to randomized computations :    [ cor : sort ] the sorting problem ( i.e. , the problem of sorting a sequence of input strings ) does not belong to the class @xmath217{n}/\\log n),o(1))$ ] .",
    "the ( straightforward ) proof can be found in appendix  [ appendix : proofsofcorollaries ] .",
    "our lower bound for the @xmath98 problem ( theorem  [ theo : set - equality ] ) leads to the following lower bounds on the worst case data complexity of database query evaluation problems in a streaming context :    [ thm : relalgebra ]    a.   for every relational algebra query @xmath21 , the problem of evaluating @xmath21 on a stream consisting of the tuples of the input database relations can be solved in @xmath16 .",
    "b.   there exists a relational algebra query @xmath218 such that the problem of evaluating @xmath218 on a stream of the tuples of the input database relations does not belong to the class @xmath217{n}/\\log n),o(1))$ ] .    _",
    "( a ) : _  it is straightforward to see that for every relational algebra query @xmath21 there exists a number @xmath219 such that @xmath21 can be evaluated within @xmath219 sequential scans and sorting steps .",
    "every sequential scan accounts for a constant number of head reversals and constant internal memory space .",
    "each sorting step can be accomplished using the sorting method of ( * ? ? ?",
    "* lemma7 ) ( which is a variant of the merge sort algorithm ) with @xmath15 head reversals and constant internal memory space .",
    "since the number @xmath219 of necessary sorting steps and scans is constant ( i.e. , only depends on the query , but not on the input size @xmath2 ) , the query @xmath21 can be evaluated by an @xmath220-bounded deterministic turing machine .",
    "_ ( b ) : _  consider the relational algebra query @xmath221 which computes the symmetric difference of two relations @xmath222 and @xmath223 . note that the query result is empty if , and only if , @xmath224 .",
    "therefore , any algorithm that evaluates @xmath218 solves , in particular , the @xmath98 problem . hence ,",
    "if @xmath218 could be evaluated in @xmath225{n}/\\log n),o(1))$ ] , then set - equality could be solved in @xmath124{n}/\\log n),o(1))$ ] , contradicting theorem  [ theo : set - equality ] .",
    "we also obtain lower bounds on the worst case data complexity of evaluating _ xquery _ and _ xpath _ queries against xml document streams :    [ thm : xquery ] there is an _ xquery _ query @xmath21 such that the problem of evaluating @xmath21 on an input xml document stream of length @xmath2 does not belong to the class @xmath217{n}/\\log n),o(1))$ ] .",
    "[ thm : xpath ] there is an _",
    "query @xmath21 such that the problem of filtering an input xml document stream with @xmath21 ( i.e. , checking whether at least one node of the document matches the query ) does not belong to the class @xmath226{n}/\\log n),o(1))$ ] .    for proving the theorems  [ thm : xquery ] and [ thm : xpath ]",
    ", we represent an instance @xmath227 of the @xmath98 problem by an xml document of the form    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ` < instance > ` + `  < set1 > ` + `  < item >  < string >  ` @xmath228 `  < /string >  < /item > ` + `  ` @xmath229 + `  < item >  < string >  ` @xmath230 `  < /string >  < /item > ` + `  < /set1 > ` + `  < set2 > ` + `  < item >  <",
    "string >  ` @xmath231 `  < /string >  < /item > ` + `  ` @xmath229 + `  < item >  < string >  ` @xmath232 `  < /string >  < /item > ` + `",
    "< /set2 > ` + ` < /instance > ` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    ( for technical reasons , we enclose every string @xmath233 and @xmath234 by a ` string`-element _ and _ an ` item`-element . for the proof of theorem  [ thm : xquery ] ,",
    "one of the two would suffice , but for the proof of theorem  [ thm : xpath ] it is more convenient if each @xmath233 and @xmath234 is enclosed by two element nodes . )    it should be clear that , given as input @xmath235 , the above xml document can be produced by using a constant number of sequential scans , constant internal memory space , and two external memory tapes .",
    "+    of theorem  [ thm : xquery ] + the @xmath98 problem can be expressed by the following xquery query @xmath236    ` < result > ` + `  if  (  every  ` @xmath237`y  in  /instance / set2/item / string  satisfies ` + `  ` @xmath238`y  ) ` + `  and ` + `  (  every  ` @xmath239`x  in  /instance / set1/item / string  satisfies ` + `  ` @xmath238`y  ) ` + `  then  < true/ > ` + `  else  ( ) ` + ` <",
    "/result > `    note that if @xmath240 , then @xmath21 returns the document ` < result><true/></result > ` , and otherwise @xmath21 returns the `` empty '' document ` < result></result > ` .",
    "thus , if @xmath21 could be evaluated in @xmath217{n}/\\log n),o(1))$ ] , then the @xmath98 problem could be solved in @xmath241{n}/\\log n),o(1))$ ] , contradicting theorem  [ theo : set - equality ] .",
    "+    of theorem  [ thm : xpath ] + the _ xpath _ query @xmath21 of figure  [ fig : xpath - query ]    `  set1itemstring  ` + `  instanceset2itemstring `    selects all ` item`-nodes below ` set1 ` whose string content does _ not _ occur as the string content of some ` item`-node below ` set2 ` ( recall the `` existential '' semantics of _ xpath _",
    "@xcite ) . in other words : @xmath21 selects all ( nodes that represent ) elements in @xmath242 , for @xmath243 and @xmath244 .",
    "now assume , _ for contradiction _ , that the problem of filtering an input xml document stream with the _ xpath _ query @xmath21 ( i.e. , checking whether at least one document node is selected by @xmath21 ) belongs to the class @xmath245{n}/\\log n),o(1))$ ]",
    ". then , clearly , there exists an @xmath246{n}/\\log n),o(1)\\big)$]-bounded randomized turing machine @xmath32 which has the following properties for every input @xmath247 ( where @xmath243 and @xmath244 ) :    1 .",
    "if @xmath21 selects at least one node ( i.e. , @xmath248 , i.e. , @xmath249 ) , then @xmath32 accepts with probability @xmath250 .",
    "if @xmath21 does not select any node ( i.e. , @xmath251 , i.e. , @xmath252 ) , then @xmath32 rejects with probability @xmath24 .",
    "this machine @xmath32 can be used to solve the @xmath98 problem by a machine @xmath253 as follows : first , @xmath253 starts @xmath32 with input @xmath254 .",
    "afterwards , @xmath253 starts @xmath32 with input @xmath255 .",
    "if both runs reject , then @xmath253 accepts its entire input . otherwise , @xmath253 rejects .",
    "+ let us analyze the acceptance / rejectance probabilities of @xmath253 :    1 .",
    "if @xmath256 , then either @xmath249 or @xmath257 , and thus , due to ( 1 ) , at least one of the two runs of @xmath32 has to accept .",
    "the machine @xmath253 will therefore reject with probability 1 . 2 .",
    "if @xmath258 , then @xmath252 and @xmath259 . due to ( 2 ) , we therefore know that each of the two runs of @xmath32 will accept with probability @xmath24 and thus , in total , @xmath253 will accept with probability @xmath260 .    to increase the acceptance probability to 0.5 , we can start two independent runs of @xmath253 and accept if at least one of the two runs accept . in total",
    ", this leads to a @xmath246{n}/\\log n),o(1)\\big)$]-bounded randomized turing machine which , on every input @xmath254 ,    1 .   accepts with probability",
    "@xmath24 , if @xmath240 , 2 .   rejects with probability 1 , otherwise .",
    "in other words : this machine shows that the @xmath98 problem belongs to @xmath124{n}/\\log n),o(1))$ ] , contradicting theorem  [ theo : set - equality ] .",
    "therefore , the problem of filtering an input xml document stream with the _ xpath _ query @xmath21 does not belong to the class @xmath245{n}/\\log n),o(1))$ ] .",
    "this section as well as the subsequent sections are devoted to the proof of theorem  [ theo : set - equality ] . for proving theorem  [ theo : set - equality ]",
    "list machines_. the important advantage that these list machines have over the original turing machines is that they make it fairly easy to track the `` flow of information '' during a computation .    in @xcite",
    "we introduced the notion of deterministic list machines with output . in",
    "what follows , we propose a nondeterministic version of such machines without output , i.e. , nondeterministic list machines for solving decision problems . to introduce _ nondeterminism _ to the notion of @xcite requires some care  the straightforward approach where , instead of the transition functions used in @xcite , transition _ relations _ are allowed , will lead to a machine model that is too weak for adequately simulating nondeterministic turing machines .",
    "therefore , instead of using transition _ relations _ , the following notion of nondeterministic list machines allows explicit nondeterministic choices in transitions .",
    "[ def : lm ] + a _ nondeterministic list machine ( nlm ) _ is a tuple @xmath261 consisting of    1 .",
    "a @xmath73 , the _ number of lists_. 2 .",
    "an @xmath262 , the _ length of the input_. 3 .   a finite set @xmath263 whose elements are called _ input numbers _ ( usually , @xmath264 or @xmath265 ) .",
    "4 .   a finite set @xmath82 whose elements are called _",
    "nondeterministicchoices_. 5 .   a finite set @xmath266 whose elements are called _ ( abstract ) states_.",
    "+ we assume that @xmath263 , @xmath82 , and @xmath266 are pairwise disjoint and do not contain the two special symbols ` @xmath267 ' and ` @xmath268 ' .",
    "+ we call @xmath269  the _ alphabet _ of the machine . 6 .   an _ initial state _ @xmath270",
    ".   a _ transition function _",
    "@xmath271 with @xmath272{rl }      \\text{movement } \\",
    "{ \\deff}\\!\\!\\!\\ !   &      \\big\\{\\ \\big(\\textit{head - direction},\\textit{move}\\big )",
    "\\   \\bigmid      \\\\       &   \\mbox{\\quad }   \\textit{head - direction}\\in\\set{-1,+1},\\\\       &   \\hspace{0.6cm}\\mbox{\\qquad}\\textit{move}\\in\\set{\\textit{true},\\textit{false } } \\",
    "\\big\\}.      \\end{array }      $ ] 8 .   a set @xmath273 of _ final states_. 9 .   a set @xmath274 of _ accepting states_. ( we use @xmath275 @xmath276 to denote the set of _ rejecting _ states . )",
    "intuitively , an nlm @xmath277 operates as follows : the input is a sequence @xmath278 . instead of tapes ( as a turing machine )",
    ", an nlm operates on @xmath30 lists .",
    "in particular , this means that a new list cell can be inserted between two existing cells . as for tapes",
    ", there is a read - write head operating on each list .",
    "cells of the lists store strings in @xmath279 ( and not just symbols from @xmath280 ) .",
    "initially , the first list , called the _ input list _ , contains @xmath281 , and all other lists are empty .",
    "the heads are on the left end of the lists .",
    "the transition function only determines the nlm s new state and the head movements , and _ not what is written into the list cells_. in each step of the computation , the heads move according to the transition function , by choosing `` nondeterministically '' an arbitrary element in @xmath82 . in each computation step , the current state , the content of all current head positions , and the nondeterministic choice @xmath282 used in the current transition , are written _ behind _ each head .",
    "when a final state is reached , the machine stops .",
    "if this final state belongs to @xmath283 , the according run is _ accepting _ ; otherwise it is _",
    "rejecting_. figure  [ fig : uebergang ] illustrates a transition of an nlm",
    ". the formal definition of the semantics of nondeterministic list machines can be found in appendix  [ appendix : lmsemantics ] .",
    "the new string @xmath11 that is written in the tape cells consists of the current state @xmath285 , the content of the list cells read before the transition , and the nondeterministic choice @xmath119 .",
    ", title=\"fig : \" ] +    @xmath284 .",
    "the new string @xmath11 that is written in the tape cells consists of the current state @xmath285 , the content of the list cells read before the transition , and the nondeterministic choice @xmath119 .",
    ", title=\"fig : \" ]    an nlm is called _ deterministic _ if @xmath286 .",
    "+ for every run @xmath33 of an nlm @xmath190 and for each list @xmath287 of @xmath190 , we define @xmath288 to be the number of changes of the direction of the @xmath287-th list s head in run @xmath33 .",
    "we say that @xmath190 is _ @xmath289-bounded _ , for some @xmath290 , if it has at most @xmath30 lists , every run @xmath33 of @xmath190 is finite , and  @xmath291    _ randomized _ list machines are defined in a similar way as randomized turing machines : for configurations @xmath54 and @xmath56 of an nlm @xmath190 , the probability @xmath292 that @xmath54 yields @xmath56 in one step , is defined as @xmath293 . for a run @xmath59 , the probability @xmath60 that @xmath190 performs run",
    "@xmath33 is the product of the probabilities @xmath294 , for all @xmath62 . for an input @xmath295 ,",
    "the probability that @xmath190 accepts @xmath296 is defined as the sum of @xmath60 for all accepting runs @xmath33 of @xmath190 on input @xmath296 .",
    "the following notation will be very convenient :    let @xmath190 be an nlm and let @xmath297 such that every run of @xmath190 has length @xmath298 . for every input @xmath295 and every sequence @xmath299 , we use @xmath300 to denote the run @xmath301 obtained by starting @xmath190 with input @xmath296 and by making in its @xmath36-th step the nondeterministic choice @xmath302 ( i.e. , @xmath303 is the @xmath302-successor of @xmath304 ) .",
    "an important property of list machines is that they can simulate turing machines in the following sense :    [ lemma : tm2lm ] let @xmath38 , @xmath39 , and let @xmath305 be an @xmath40-bounded ntm with a total number of  @xmath306 tapes and with @xmath307 . then for every @xmath308 there exists an @xmath309-bounded nlm  @xmath310 with @xmath311 and @xmath312 , where @xmath313 is an upper bound on the length of @xmath32 s runs on input words of length @xmath2 ,  and @xmath314 for some number @xmath315 that does _ not _ depend on @xmath316 , @xmath26 , @xmath110 , @xmath30 , such that for all @xmath317 we have @xmath318 furthermore , if @xmath32 is deterministic , then @xmath190 is deterministic , too .    in section  [ section : boundsfortms ] we will use the simulation lemma to transfer the lower bound results for list machines to lower bound results for turing machines .    in @xcite ,",
    "the simulation lemma has been stated and proved for deterministic machines . for nondeterministic machines ,",
    "the construction is based on the same idea .",
    "however , some further work is necessary to assure that the according list machine accepts with the same probability as the given turing machine . throughout the remainder of this section",
    ", the proof idea is given ; a detailed proof of lemma  [ lemma : tm2lm ] can be found in appendix  [ appendix : simulationlemma ] . for proving lemma  [ lemma : tm2lm ] , the following straightforward characterization of probabilities for turing machines is very convenient .",
    "[ def : rhot ] let @xmath32 be an ntm for which there exists a function @xmath319 such that every run of @xmath32 on a length @xmath2 input word has length at most @xmath313 .",
    "let @xmath320 be the maximum branching degree of @xmath32 ( note that @xmath321 is finite since @xmath32 s transition relation is finite ) .",
    "let @xmath322 be the least common multiple of the numbers 1,2,,@xmath321 , and let @xmath323 .",
    "for every @xmath41 , every input word @xmath324 of length @xmath2 , and every sequence @xmath325 , we define @xmath326 to be the run @xmath301 of @xmath32 that is obtained by starting @xmath32 with input @xmath11 and by choosing in its @xmath36-th computation step the @xmath327-th of the @xmath328 possible next configurations .",
    "[ lemma : probandtms ] let @xmath32 be an ntm for which there exists a function @xmath319 such that every run of @xmath32 on a length @xmath2 input word has length at most @xmath313 , and let @xmath329 be chosen according to definition  [ def : rhot ] .",
    "then we have for every run @xmath33 of @xmath32 on an input @xmath11 of length @xmath2 that  @xmath330    the ( straightforward ) proof can be found in appendix  [ appendix : proofsomittedinsec : classst ] .    for proving lemma  [ lemma : tm2lm ] ,",
    "let @xmath32 be an ntm .",
    "we construct an nlm @xmath190 that simulates @xmath32 .",
    "the lists of @xmath190 represent the external memory tapes of @xmath32 .",
    "more precisely , the cells of the lists of @xmath190 represent segments , or _ blocks _ , of the corresponding external memory tapes of @xmath32 in such a way that the content of a block at any step of the computation can be reconstructed from the content of the cell representing it .",
    "the blocks evolve dynamically in a way that is described below .",
    "s set @xmath82 of _ nondeterministic choices _ is defined as @xmath331 , where @xmath329 is chosen according to definition  [ def : rhot ] and @xmath332 is an upper bound on @xmath32 s running time and tape length , obtained from lemma  [ lem : time ] .",
    "each step of the list machine corresponds to the sequence of turing machine steps that are performed by @xmath32 while none of its external memory tape heads changes its direction or leaves its current tape block .",
    "of course , the length @xmath333 of this sequence of @xmath32 s steps is bounded by @xmath32 s entire running time @xmath334 .",
    "thus , if @xmath335 is the nondeterministic choice used in @xmath190 s current step , the prefix of length @xmath333 of @xmath119 tells us , which nondeterministic choices ( in the sense of definition  [ def : rhot ] ) @xmath32 makes throughout the corresponding sequence of @xmath333 steps .",
    "the _ states _ of @xmath190 encode :    1 .",
    "the current state of the turing machine @xmath32 .",
    "2 .   the content and the head positions of the internal memory tapes @xmath336 of @xmath32 .",
    "3 .   the head positions of the external memory tapes @xmath337 .",
    "4 .   for each of the external memory tapes @xmath337",
    ", the boundaries of the block in which the head currently is .",
    "representing @xmath32 s current state and the content and head positions of the @xmath31 internal memory tapes requires @xmath338 states .",
    "the @xmath30 head positions of the external memory tapes increase the number of states by a factor of @xmath339 .",
    "the @xmath340 block boundaries increase the number of states by another factor of @xmath341 .",
    "so overall , the number of states is bounded by @xmath342 by lemma  [ lem : time ] , this yields the bound .    initially , for an input word @xmath343 , the first turing machine tape is split into @xmath26 blocks which contain the input segments @xmath344 ( for @xmath345 ) , respectively , @xmath346 ( that is , the @xmath26-th input segment is padded by as many blank symbols as the turing machine may enter throughout its computation ) .",
    "all other tapes just consist of one block which contains the blank string @xmath347 .",
    "the heads in the initial configuration of @xmath190 are on the first cells of their lists .",
    "now we start the simulation : for a particular nondeterministic choice @xmath348 , we start @xmath32 s run @xmath349 . as long as no head of the external memory tapes of @xmath32 changes its direction or crosses the boundaries of its current block",
    ", @xmath190 does not do anything . if a head on a tape @xmath350 crosses the boundaries of its block , the head @xmath351 of @xmath190 moves to the next cell , and the previous cell is overwritten with sufficient information so that if it is visited again later , the content of the corresponding block of tape @xmath351 of @xmath32 can be reconstructed .",
    "the blocks on all other tapes are split behind the current head position ( `` behind '' is defined relative to the current direction in which the head moves ) .",
    "a new cell is inserted into the lists behind the head , this cell represents the newly created tape block that is behind the head .",
    "the newly created block starting with the current head position is represented by the ( old ) cell on which the head still stands .",
    "the case that a head on a tape @xmath350 changes its direction is treated similarly .",
    "the simulation stops as soon as @xmath32 has reached a final state ; and @xmath190 accepts if , and only if , @xmath32 does",
    ". a close look at the possible runs of @xmath32 and @xmath190 shows that @xmath190 has the same acceptance probabilities as @xmath32 .",
    "this section s main result is that it provides constraints on a list machine s parameters , which ensure that list machines which comply to these constraints can neither solve the _ multiset equality problem _ nor the _ checksort problem_. in fact , we can show a slightly stronger result , the precise formulation of which requires the following observation .",
    "[ def : sortedness ] let @xmath262 and let @xmath182 be a permutation of @xmath352 .",
    "we define  @xmath353 to be the length of the longest subsequence is a _ subsequence _ of a sequence @xmath354 , if there exist indices @xmath355 such that @xmath356 , @xmath357 ,  , @xmath358 . ] of @xmath359 that is sorted in either ascending or descending order ( i.e. , that is a subsequence of @xmath360 or of @xmath361 ) .",
    "[ rem : permut ] it is well - known that for every permutation @xmath182 of @xmath352 , @xmath362 and that there exists a particular permutation @xmath363 with @xmath364 in fact , one way of finding such a permutation is to let @xmath365 be the numbers @xmath366 , sorted lexicographically by their reverse binary representation .",
    "[ lemma : mainlm ] + let @xmath367 such that @xmath26 is a power of @xmath368 and  @xmath369 , @xmath370 , @xmath371 , @xmath372 .",
    "we let @xmath373 , identify @xmath263 with the set @xmath374 , and divide it into @xmath26 consecutive intervals @xmath375 , each of length @xmath376 .",
    "let @xmath377 be a permutation of @xmath352 with @xmath378 , and let @xmath379 + then there is no @xmath289-bounded nlm @xmath380 with @xmath381 and @xmath382 , such that for all @xmath383 we have : + if @xmath384 , then @xmath385 ; otherwise  @xmath386 .",
    "it is straightforward to see that the above lemma , in particular , implies that neither the _ ( multi)set equality problem _ nor the _ checksort problem _ can be solved by list machines with the according parameters .    the proof of lemma  [ lemma : mainlm ] is based on the following ideas ( the detailed proof is given in appendix  [ appendix : proofboundlm ] ) :    1 .",
    "suppose for contradiction that @xmath190 is an nlm that meets the lemma s requirements .",
    "[ sketch : vekc ] observe that there exists an upper bound @xmath334 on the length of @xmath190 s runs ( lemma  [ lemma : shapeofruns]([item : lm : lengthofruns ] ) in appendix  [ appendix : proofboundlm ] ) and a particular sequence @xmath387 of nondeterministic choices ( lemma  [ lemma : choose_c ] ) , such that for at least half of the inputs @xmath388 with @xmath389 , the particular run @xmath390 accepts .",
    "+ we let @xmath391 and , from now on , we only consider runs that are generated by the fixed sequence @xmath392 of nondeterministic choices .",
    "[ sketch : i0 ] show that , throughout its computation , @xmath190 can `` mix '' the relative order of its input values only to a rather limited extent ( cf .",
    ", lemma  [ lemma : merge ] ) .",
    "this can be used to show that for every run of @xmath190 on every input @xmath393 there must be an index @xmath351 such that @xmath394 and @xmath395 are never compared throughout this run .",
    "[ sketch : skeleton ] use the notion of the _ skeleton _ of a run ( cf .",
    ", definition  [ def : skeleton ] ) , which , roughly speaking , is obtained from a run by replacing every input value @xmath108 with its index @xmath36 and by replacing every nondeterministic choice @xmath282 with the wildcard symbol `` ? '' .",
    "in particular , the skeleton contains input _ positions _ rather than concrete input _ values _ ; but given the skeleton together with the concrete input values and the sequence of nondeterministic choices , the entire run of @xmath190 can be reconstructed .",
    "[ sketch : zeta ] now choose @xmath396 to be a skeleton that is generated by the run @xmath390 for as many input instances @xmath397 as possible , and use @xmath398 to denote the set of all those input instances .",
    "due to [ sketch : i0 ] .",
    "there must be an index @xmath351 such that for all inputs from @xmath398 , the values @xmath394 and @xmath395 ( i.e. , the values from the input positions @xmath351 and @xmath399 ) are never compared throughout the run that has skeleton @xmath396 . to simplify notation",
    "let us henceforth assume without loss of generality that @xmath400 .",
    "now fix @xmath401 such that the number of @xmath402 with + @xmath403 + is as large as possible .",
    "argue that , for our fixed @xmath401 , there must be at least two distinct @xmath402 and @xmath404 such that @xmath405 and @xmath406 .",
    "this is achieved by observing that the number of skeletons depends on the machine s",
    "parameters @xmath30 , @xmath316 , @xmath26 , @xmath407 , but _ not _ on @xmath110 ( lemma  [ lemma : noofrcpskels ] ) and by using the lemma s assumption on the machine s parameters @xmath408 .",
    "now we know that the input values of @xmath409 and @xmath410 coincide on all input positions except @xmath250 and @xmath411 . from [ sketch : i0 ] .",
    "we know that the values from the positions @xmath250 and @xmath411 are never compared throughout @xmath190 s ( _ accepting _ ) runs @xmath412 and @xmath413 . from this",
    "we obtain ( cf .",
    ", lemma  [ lemma : compositionlemma ] ) an accepting run @xmath414 of @xmath190 on input @xmath415{rcl }        \\vek{u } &   \\deff   &        ( u_1,\\twodots , u_m , u'_1,\\twodots , u'_m )       \\\\         &   \\deff   &         \\big(v_1,v_2,\\twodots , v_m , w_{\\varphi^{-1}(1)},w_{\\varphi^{-1}(2 ) } ,            \\twodots , w_{\\varphi^{-1}(m)}\\big ) .",
    "\\end{array}\\ ] ] in particular , this implies that @xmath416 .",
    "however , for this particular input @xmath417 we know that @xmath418 , and therefore , @xmath419 .",
    "this gives us a contradiction to the assumption that @xmath386 for all inputs @xmath420 with @xmath421 .",
    "[ lemma : tmbound ] let @xmath72 such that @xmath422 and @xmath423{n}/r(n)\\big)$ ] .",
    "then , there is no @xmath424-bounded @xmath65-rtm that solves the following problem .",
    "-@xmath377 @xmath425 , + where @xmath426 is a power of @xmath368 , and + @xmath427 , where @xmath428 is the permutation of @xmath352 obtained from remark  [ rem : permut ] , and the sets @xmath429 are obtained as the partition of the set @xmath430 into @xmath26 consecutive subsets , each of size @xmath431 .",
    "decide if @xmath432 .",
    "suppose for contradiction that there is a @xmath73 such that the problem @xmath433-@xmath377 is solved by an @xmath40-bounded @xmath65-rtm @xmath32 .",
    "without loss of generality we may assume that @xmath434 .",
    "let @xmath435 be the constant introduced in lemma  [ lemma : tm2lm ] ( the simulation lemma ) .",
    "let @xmath26 be a sufficiently large power of @xmath368 such that @xmath436{l }    1 + \\",
    "d\\cdot t^2\\cdot r(2m\\cdot(m^3{+}1))\\cdot s(2m\\cdot(m^3{+}1 ) )   \\\\    +",
    "\\ 3t\\cdot \\log ( 2m\\cdot(m^3{+}1 ) ) .",
    "\\end{array}\\end{aligned}\\ ] ] such an @xmath26 exists because @xmath437 ( for equation ) and @xmath438n\\right)$ ] ( for equation ) .",
    "let @xmath439 and @xmath440 .",
    "by lemma  [ lemma : tm2lm ] , there is an @xmath441-bounded nlm @xmath442 with @xmath443 states that simulates @xmath32 on inputs from @xmath444 . in particular , for all instances @xmath445 the following is true :    @xmath446 :    we clearly have @xmath447 . by , we have @xmath448 by , we have @xmath449{l } m^3",
    "\\end{array } \\\\",
    "\\ge \\ \\ ; &      \\begin{array}[t]{l }        1 + ( m^2{+}1)\\cdot        \\big (        1 + \\ d\\cdot t^2\\cdot r(2m\\cdot(m^3{+}1))\\cdot s(2m\\cdot(m^3{+}1 ) )   \\\\ + \\ 3t\\cdot\\log ( 2m\\cdot(m^3{+}1 ) )   \\big )   \\end{array }",
    "\\\\   = \\ \\ ; &       \\begin{array}[t]{l }         1 + ( m^2{+}1)\\cdot         \\big (         1 + \\ d\\cdot t^2\\cdot r(2m\\cdot(n{+}1))\\cdot s(2m\\cdot(n{+}1 ) ) \\\\         +",
    "\\ 3t\\cdot \\log ( 2m\\cdot(n{+}1 ) )         \\big )       \\end{array } \\\\",
    "\\geq \\ \\ ; & 1 + ( m^2{+}1)\\cdot    \\big ( \\log(2 ) + \\log(k)\\big )",
    "\\\\   = \\ \\ ; & 1 + ( m^2{+}1)\\cdot \\log(2 k).\\end{aligned}\\ ] ] thus , @xmath446 is a contradiction to lemma  [ lemma : mainlm ] , and the proof of lemma  [ lemma : tmbound ] is complete .    of theorem",
    "[ theo : set - equality ] for inputs that are instances of the problem -@xmath377 , the problems , , , and -@xmath377 coincide .",
    "thus , lemma  [ lemma : tmbound ] immediately implies theorem  [ theo : set - equality ] .",
    "we have proved tight lower bounds for the natural decision problems _ ( multi)set equality _ and _ checksort _ , in our turing machine based computation model for processing large data sets .",
    "these lower bounds do not only hold for deterministic , but even for _ randomized _ algorithms with one - sided bounded error probability .",
    "our results are obtained by carefully analyzing the flow of information in a turing machine computation .    as applications of these lower bound results",
    ", we obtained lower bounds on the worst case data complexity of query evaluation for the languages _ xquery _ , _ xpath _ , and _ relational algebra _ on data streams .",
    "we complement our lower bounds for _ checksort _ and _ ( multi)set equality _ by proving that these problems can be solved by nondeterministic machines and by randomized machines with complementary one - sided error probabilities . as a consequence ,",
    "we obtain a separation between the deterministic , the randomized , the co - randomized , and the nondeterministic external memory complexity classes .    a specific problem for which we could not prove lower bounds ,",
    "even though it looks very similar to the set equality problem , is the _",
    "disjoint sets problem _ , which asks if two given sets of strings are disjoint .",
    "another important future task is to develop techniques for proving lower bounds ( a ) for randomized computations with two - sided bounded error and ( b ) for appropriate problems in a setting where @xmath0 head reversals ( i.e. , sequential scans of external memory devices ) are available .",
    "l.  arge and p.  bro  miltersen . on showing lower bounds for external - memory computational geometry problems .",
    "in j.  abello and j.  vitter , editors , _ external memory algorithms and visualization _ , dimacs series in discrete mathematics and theoretical computer science , pages 139159 .",
    "1999 .",
    "m.  grohe , c.  koch , and n.  schweikardt .",
    "tight lower bounds for query processing on streaming and external memory data . in _ proc .",
    "icalp05 _ , volume 3580 of _ springer lncs _ , pages 10761088 , 2005 .",
    "( best paper award at icalp05 , track  b. ) .",
    "m.  henzinger , p.  raghavan , and s.  rajagopalan . computing on data streams . in _ external memory algorithms _ , volume  50 , pages 107118 .",
    "dimacs series in discrete mathematics and theoretical computer science , 1999 ."
  ],
  "abstract_text": [
    "<S> we study the randomized version of a computation model ( introduced in @xcite ) that restricts random access to external memory and internal memory space . </S>",
    "<S> essentially , this model can be viewed as a powerful version of a data stream model that puts no cost on sequential scans of external memory ( as other models for data streams ) and , in addition , ( like other external memory models , but unlike streaming models ) , admits several large external memory devices that can be read and written to in parallel .    </S>",
    "<S> we obtain tight lower bounds for the decision problems set equality , multiset equality , and checksort . </S>",
    "<S> more precisely , we show that any randomized one - sided - error bounded monte carlo algorithm for these problems must perform @xmath0 random accesses to external memory devices , provided that the internal memory size is at most @xmath1{n } / { \\log n})$ ] , where @xmath2 denotes the size of the input data </S>",
    "<S> .    from the lower bound on the set equality problem we can infer lower bounds on the worst case data complexity of query evaluation for the languages xquery , xpath , and relational algebra on streaming data . </S>",
    "<S> more precisely , we show that there exist queries in xquery , xpath , and relational algebra , such that any ( randomized ) las vegas algorithm that evaluates these queries must perform @xmath0 random accesses to external memory devices , provided that the internal memory size is at most @xmath1{n}/ { \\log n})$ ] . </S>"
  ]
}