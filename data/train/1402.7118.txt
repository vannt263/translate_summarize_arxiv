{
  "article_text": [
    "modern computing has reached a point that allows users from every part of the globe to exchange information seamlessly .",
    "nevertheless , the environment can not be considered friendly .",
    "cyber attacks each year are reaching a new peak , while recently disclosed events clearly indicate that privacy measures are not properly deployed or applied .",
    "the hostile environment to which modern users are exposed to has triggered the generation of many security and privacy protocols . in many scenarios ,",
    "users have to co - operate to perform several tasks which result in some of their data being partially or fully exposed .",
    "since the latter might not be an acceptable option , given the sensitivity of the submitted information , there has been much research effort in the area of secure multi - party computation ( mpc ) .    while there has been much progress made in recent years towards making mpc practical ,",
    "the efficiency of many protocols is still not acceptable for many real - world applications . to cover this gap , apart from general mpc protocols ( which allow any function to be computed )",
    ", many mpc protocols for specialized computations have been introduced .",
    "while they might support only a small set of functions , these protocols can be obtain much improved performance , even in devices with limited computing resources .",
    "thus , apart from the interest in general mpc protocols , many application needs are pushing towards the development of more targeted mpc protocols .",
    "a typical example of this trend are protocols which allow privacy - aware summation of values .",
    "these protocols are widely used for load monitoring of smart meters , privacy - aware participatory sensing , and generally for submitting time series data with privacy .",
    "recently , a new protocol was proposed by patsakis , clear and laird @xcite ( referred to here as pcl ) that allows privacy - aware multiparty aggregation of values .",
    "a notable feature is that it supports multiple rounds of aggregation from the same set of public keys published by the users , and it relies only on the standard decisional diffie - hellman ( ddh ) assumption .",
    "pcl is based on a protocol due to kursawe , danezis and kohlweiss @xcite ( referred to here as kdk ) which also has a variant that supports multiple rounds of aggregation by exploiting bilinear pairings .",
    "both these papers do not consider the performance of their protocols in practice .",
    "in fact , @xcite does not address its performance relative to multi - round kdk . in this paper",
    ", we extensively compare the performance of both protocols , and show that in practice pcl outperforms multi - round kdk by a significant margin , largely due to the cost of pairings , but also due to the larger finite field in which recovery of the sum takes place . following on from concrete performance results ,",
    "we propose a new extension that is applicable to both protocols , which leads to considerable performance improvements . in pcl ,",
    "protection against collusion tolerance is traded off against the number of rounds supported .",
    "our extension trades collusion tolerance further ( in both protocols ) to achieve a performance gain .",
    "however , since a tolerance of @xmath0 of the parties is satisfactory for many real - world applications ( note that this corresponds to the byzantine optimum ) , we argue that reducing tolerance to ( say ) @xmath1 is justified given the significant gains in performance .",
    "the main technical contribution of this work are as follows .",
    "firstly , a thorough performance analysis is given of the multi - round protocols pcl and kdk .",
    "to the best of our knowledge , this is the first assessment of the practicality of multi - round kdk .",
    "secondly , we introduce a new technique that is applicable to both protocols that allows all parties to reduce their computational load by adjusting their collusion tolerance .",
    "we prove security for the extended versions of both protocols that employ this technique .      the rest of this work is organized as follows . in the next section we provide a brief overview of the related work in this area , along with a description of the two protocols , pcl and kdk in their single - round and multi round versions .",
    "afterwards , in section 3 , we compare the performance of the two protocols . sections 4 and five describe methods to reduce the computational load of pcl and kdk protocols respectively .",
    "in many application scenarios users have to co - operate to achieve specific tasks , however , they need to know that the that they will send will not be disclosed . based on this problem , yao introduced the concept of secure multiparty computation was @xcite . despite the huge initial advances",
    "@xcite , only recently did real - world implementations become practical @xcite .    due to efficiency",
    ", secure multiparty computation can be categorized into schemes that allow arbitrary computations to be performed without leaking information , and more specialized protocols which allow the private evaluation of particular functions , such as summation . in the first category we have schemes based on garbled circuits ( efficient implementations include @xcite ) ,",
    "nielsen s protocol using oblivious transfer @xcite and oblivious ram @xcite .",
    "other protocols use arithmetic circuits such as those based on the bgw protocol e.g : viff @xcite and spdz which employs fully homomorphic encryption @xcite .",
    "as already discussed , the second category includes more application - specific protocols .",
    "for instance for calculating the private sum of @xmath2 users we have the scheme of clifton _",
    "@xcite , the two round scheme of yang _",
    "_ @xcite and the single round scheme of shi _ et al . _ but relies on the previously distribution of shares of shares of zeros from a trusted third party @xcite .",
    "other protocols are focused on calculating one bit multi - party computations , such as dc - net @xcite and @xcite .",
    "we adopt the standard simulation - based definition of security in the semi - honest model .",
    "we base our definition below on definition 2.1 in @xcite . here",
    "we consider only computational security , and relax the more standard definition to deterministic functionalities with a single output .",
    "note that this definition is general enough to accommodate multi - round aggregation .",
    "let @xmath3 be a vector of the inputs from each party and let @xmath4 be a protocol .",
    "we define the view of a party @xmath5 in the execution of protocol @xmath4 with input vector @xmath6 as @xmath7 where @xmath8 is party @xmath9 input , @xmath10 is its random coins and @xmath11 are the @xmath12 protocol messages it received during the protocol execution .",
    "similarly , the combined view of a set of @xmath13 parties is denoted by @xmath14 .",
    "let @xmath15 be a deterministic @xmath2-ary functionality and let @xmath4 be a protocol that _ correctly _ computes @xmath16 .",
    "we say that @xmath4 if @xmath17-private if for every @xmath3 where @xmath18 , there exists a ppt algorithm @xmath19 such that for every @xmath20 with @xmath21 , and every @xmath22 where @xmath18 , it holds that : @xmath23 where @xmath24 denotes computational indistinguishability .",
    "kursawe , danezis and kohlweiss ( kdk ) @xcite present a specialized multiparty computation ( mpc ) protocol for private summation , which is shown is be secure in the semihonest model under the decisional diffie - hellman ( ddh ) assumption .",
    "we refer to this protocol as kdk . in their protocol ,",
    "@xmath2 parties @xmath25 can compute a joint sum of their inputs @xmath26 for some positive integer @xmath27 .",
    "an overview of their protocol follows .",
    "let @xmath28 be a prime .",
    "the `` public parameters '' used in the protocol consist of a description of a cyclic group @xmath29 of order @xmath28 together with a generator @xmath30 of @xmath29 . it is assumed that ddh is intractable in @xmath29 .",
    "these public parameters @xmath31 are known to all parties @xmath5 .",
    "the group operation of @xmath29 is written multiplicatively .    1 .",
    "* setup : * party @xmath5 generates a secret key @xmath32 and computes her public key @xmath33 .",
    "she broadcasts @xmath34 .",
    "2 .   for every @xmath35 : + *",
    "main round : * * party @xmath5 chooses her input @xmath36 . *",
    "compute @xmath37 . *",
    "compute @xmath38 . *",
    "broadcast @xmath39 .",
    "* output : * the protocol produces an output in @xmath40 , namely the sum of the user inputs . to compute the sum @xmath41 : * compute @xmath42 .",
    "* use pollard s lambda algorithm to compute the discrete log @xmath43 of @xmath44 with respect to @xmath30 in @xmath45 .",
    "the time complexity of pollard s lambda algorithm is @xmath46 .",
    "* output @xmath41 .",
    "it can be easily observed that @xmath47      if the protocol must be run a number of times , it would be desirable to avoid re - running the `` setup '' phase above which involves each party generating and broadcasting a new public key ; in practice , a verification step for these keys may also be needed .",
    "to re - use the published keys @xmath48 for more than a single round of aggregation , kursawe et al . propose an extension of their protocol that facilitates multiple - rounds .",
    "in fact , their multi - round protocol accommodates an unbounded number of rounds .",
    "they make use of bilinear pairings to achieve this .",
    "more details on bilinear pairings are provided in section [ sec : perf ] when we address practical issues .",
    "we give a very brief overview here that is sufficient to understand the multi - round protocol .",
    "the following is based on the definition from @xcite ( section 2 ) .",
    "[ def : pairing ] let @xmath49 , @xmath50 and @xmath51 be cyclic groups of prime order @xmath52 .",
    "we write @xmath49 and @xmath50 additively , and @xmath51 multiplicatively .",
    "a bilinear pairing @xmath53 is an efficiently computable map satisfying    * _ bilinearity : _",
    "@xmath54 for all @xmath55 , @xmath56 and @xmath57 . *",
    "_ non - degeneracy : _ if @xmath58 is a generator for @xmath49 and @xmath59 is a generator for @xmath50 , then @xmath60 .",
    "examples of bilinear pairings ( or their modifications ) that are used in cryptography include the tate pairing @xcite , weil pairing @xcite , and ate pairing @xcite .",
    "let @xmath49 , @xmath50 and @xmath51 be cyclic groups of prime order @xmath28 .",
    "let @xmath53 be a cryptographic bilinear pairing meeting the conditions of definition [ def : pairing ] .",
    "furthermore , the bilinear decisional diffie hellman ( bddh ) assumption is expected to hold with respect to @xmath49 , @xmath50 , @xmath51 and @xmath61 .",
    "let @xmath62 be a hash function .",
    "the main changes to kdk to support multiple rounds are as follows ( optimizations are discussed later ) :    * the public parameters include generators @xmath55 , @xmath56 and @xmath63 . * the public keys are generated as @xmath64 for all @xmath65 . * in round @xmath66 , party @xmath5 computes * * @xmath67 ( i.e. for a good choice of @xmath68 , we have @xmath69 for some uniformly random @xmath70 , which is intractable to find ) . * * @xmath71 .    the rest of the protocol remains unchanged except that the computations are performed in @xmath51 , and @xmath5 may choose a different input value in every round . naturally , the output of the protocol is then @xmath72 if @xmath12 rounds are executed .",
    "patsakis , clear and laird @xcite introduced another multi - round variant of kdk without pairings .",
    "their protocol ( referred to here as pcl ) allows a bounded number of rounds @xmath12 to be performed from the same public key information .",
    "however , @xmath12 depends on the acceptable collusion tolerance @xmath73 .",
    "both single - round and multi - round kdk are @xmath17-private for any @xmath73 . on the other hand , in order for pcl to be @xmath17-private , at most @xmath74 rounds are permitted . concretely , for @xmath75 ( byzantine tolerance ) and @xmath76 , we can securely run 33 rounds before re - keying .",
    "one of the advantages of pcl is that it only relies on the ddh assumption in some cyclic group @xmath29 of prime order @xmath28 , like single - round kdk .",
    "however , there are also benefits regarding performance over multi - round kdk as highlighted in section [ sec : perf ]",
    ".    it is observed in @xcite that kdk is centered on a fixed matrix @xmath77 with entries in @xmath78 that determine the exponents used to compute @xmath79 . in other words , party @xmath5 raises @xmath80 s public key @xmath81 to the power @xmath82 when computing @xmath79 .",
    "however , the matrix @xmath77 used in kdk has the form : @xmath83 for @xmath84 ; @xmath85 for @xmath86 ( @xmath87 in upper triangle ) and @xmath88 for @xmath89 ( @xmath90 in lower triangle ) .",
    "therefore , @xmath77 is skew - symmetric i.e. @xmath91 .",
    "the main idea in pcl is to generate a new skew - symmetric matrix @xmath92 in a deterministic manner for each round @xmath66 .",
    "furthermore , the matrix @xmath92 is chosen to have coefficients in @xmath93 instead of @xmath78 in order to prove security .",
    "we refer the reader to @xcite for details . here",
    "we assume a function @xmath94 that takes a random seed and a round number , and outputs a pseudorandom s kew - symmetric matrix over @xmath93 .",
    "note that the seed can be pre - determined or derived from the users public keys .",
    "the main differences to single - round kdk are as follows :    * let @xmath95 be a seed deterministically derived form @xmath96 .",
    "* in round @xmath66 , party @xmath5 computes * * @xmath97 . * * @xmath98 .",
    "the remaining steps are the same as single - round kdk with the exception that each party may choose a different input value in every round , and the final output is @xmath12 values in @xmath40 .",
    "we begin by comparing the _ original _ multi - round kdk from @xcite and _ original _ pcl protocol form @xcite .",
    "we are unaware of any concrete performance results for multi - round kdk , which we believe are important in order to assess its practicality . in this section ,",
    "the performance of both multi - round protocols is measured and compared .",
    "the results motivate our proposed optimizations .",
    "firstly , we compare the necessary group operations that a party @xmath5 must perform in a given round .",
    "multi - round kdk requires @xmath99 pairings , @xmath99 multiplications in @xmath51 and an exponentiation in @xmath51 .",
    "note the omission of the inversions in @xmath51 for @xmath100 .",
    "the reason for this is that in the _ setup _ phase , party @xmath5 can compute @xmath101 for @xmath100 where @xmath102 is @xmath80 s public key .",
    "thus by bilinearity of @xmath61 , no inversions are needed in @xmath51 .",
    "on the other hand , pcl needs @xmath2 exponentiations and @xmath2 multiplications in group @xmath29 , derivation of the _ per - round information _ for kdk involves computing @xmath67 whereas pcl involves computing @xmath103 .",
    "however , the latter can be optimized since only a single row of the matrix @xmath92 is needed by party @xmath5 . as pointed out in @xcite , @xmath104 uses a hash function @xmath105 to generate @xmath106 ; that is , @xmath107 .",
    "however , derivation of the _ per - round information _ in both protocols is negligible relative to the cost of the group operations .    at present , all known efficient realizations of bilinear pairings are based on elliptic curves . therefore , in order to implement multi - round kdk , we had to instantiate @xmath49 and @xmath50 with elliptic curve groups .",
    "there is far less freedom when choosing an elliptic curve when pairings are involved , since the chosen curve must satisfy additional properties .",
    "notwithstanding , to provide a fair performance comparison between both protocols , the same curve was used for both protocols .",
    "consider an elliptic curve @xmath108 over @xmath109 for prime @xmath52 whose order is @xmath110 .",
    "for pcl , the group @xmath29 may be instantiated by the additive group formed by @xmath111 . for multi - round kdk",
    ", we have opted to use the modified tate pairing to instantiate @xmath61 since efficient implementations exist in libraries such as miracl .",
    "now the embedding degree @xmath66 of @xmath108 is the smallest positive integer such that @xmath112 .",
    "concretely , the tate pairing takes two points on @xmath113 $ ] and outputs an element of @xmath114 ( more precisely , an element of a multiplicative subgroup of order @xmath28 of @xmath115 ) , where @xmath113 $ ] denotes the set of points on @xmath116 of order @xmath28 i.e. the set of points @xmath77 with @xmath117 , where @xmath118 is the additive identity ( _ point at infinity _ ) . basically , @xmath49 and @xmath50 must be two distinct subgroups of @xmath116 of order @xmath28 .",
    "in fact , we can set @xmath49 to @xmath111 to make the pairing calculation faster .",
    "furthermore , certain pairing - friendly curves @xmath108 allow us to choose @xmath50 such that it is isomorphic to a subgroup of @xmath119 where @xmath120 is related to @xmath108 ( known as the `` twisted curve '' ) ; this means arithmetic operations can be carried out in the smaller field @xmath121 where @xmath122 is the `` twist degree '' .",
    "the curve chosen for our implementation is a member of the pairing - friendly bn family from @xcite with a 254-bit prime @xmath52 , embedding degree @xmath123 , and `` twist degree '' @xmath124 . as a consequence of the latter , arithmetic operations in @xmath50 can be carried out in @xmath125 instead of @xmath126 .",
    "in addition , @xmath51 is the group generated by @xmath127 , and thus its arithmetic operations are carried out in the `` big '' field @xmath128 .",
    "this has implications for message recovery , since pollard s lambda algorithm is much slower .",
    "we implemented both protocols in c++ using the miracl c / c++ library version 5 using the bn curve as described above . the code was compiled with g++ with the compiler flags `` -m64 -o2 '' as recommended in the miracl documentation , and was executed on a machine with an intel core i5 - 3340 m cpu ( 2.7 ghz ) and 4 gb of ram , and running 64-bit debian gnu / linux 3.2.41 . for each protocol .",
    "we measured the time taken to compute a single round per participant ( recall that a round involves preparing the value @xmath39 for some party @xmath5 ) .",
    "we ran this 100 times for different values of @xmath2 .",
    "note that on each run a random index @xmath129 was chosen , and the round was executed for @xmath5 .",
    "our results are shown in table [ tab : round_times ] .",
    "as expected , the cost of a round is roughly linear in @xmath2 .",
    "moreover , the difference in times between kdk and pcl is significant ; on average pcl outperforms kdk by a factor of @xmath130 based on the times in table [ tab : round_times ] ) . for even a moderate number of users such as @xmath76 ,",
    "it is clear that multi - round kdk is not suited to time - sensitive applications .",
    "this is more pronounced for resource - constrained devices such as wireless sensors .",
    "[ tab : round_times ]    .mean time in ms ( over 100 runs ) for a party to compute a round ( standard deviation in parenthesis ) . [ cols=\"<,>,>,>\",options=\"header \" , ]     [ results ]      now we turn our attention to the aggregation phase of the protocol . in",
    "any given round , this entails multiplying all elements @xmath39 to calculate @xmath131 , then finding a discrete logarithm with respect to a generator @xmath30 to recover the sum @xmath132 of the parties inputs in the round . for this purpose ,",
    "pollard s lambda algorithm is employed . in pcl ,",
    "the @xmath39 belong to @xmath29 whereas in multi - round kdk , they belong to @xmath51 . recall that our implementation with elliptic curves instantiates @xmath29 as @xmath111 whereas @xmath51 is instantiated as a subgroup of @xmath114 . as such , this phase is more expensive for multi - round kdk because the field operations take place in a `` bigger '' field .",
    "pollard s lambda algorithm dominates recovery of the sum .",
    "its time complexity is @xmath133 where @xmath134 denotes the size of the message space . in this case , @xmath135 since each party chooses her message in @xmath136 .    in order to compare multi - round kdk to pcl in this phase",
    ", we measured the time taken to compute pollard s lambda algorithm for different message space sizes . moreover , values were randomly generated in the set @xmath137 for different values of @xmath138 and the time taken to recover @xmath139 given @xmath140 using pollards lambda algorithm was measured ( the range given to the algorithm was @xmath141 ; here @xmath30 denotes the generator of the group in question and multiplicative notation is employed arbitrarily .",
    "the measurements were performed in sage version 5.9 on the same machine and operating system as that used for the previous experiment above .",
    "we ran the experiment 10 times each for @xmath142 for both @xmath111 and the group @xmath143 ( recall that @xmath123 for the curve we used ) .",
    "our results are shown in figure [ fig : dl_times ] .",
    "observe that for @xmath144-bit numbers , multi - round kdk takes almost half a minute to recover the result .",
    "hence , for large values of @xmath27 , it is the recovery phase that acts as the main bottlekneck in multi - round kdk .",
    "( pcl ) and @xmath128 ( multi - round kdk ) for different value ranges ( upper bound in bits ) . ]",
    "although the performance results from table [ tab : round_times ] are favorable for pcl , there is still a motivation for seeking improvements , because many applications involve running the protocol on low - powered devices such as mobile phones . in particular , when a user s phone has low battery , it would be desirable to reduce their computational load .",
    "we introduce an optimization that allows parties to adjust their computational workloads at the expense of reducing their protection against collusion tolerance .",
    "consider a skew - symmetric matrix @xmath77 generated in a particular round of the protocol .",
    "ordinarily , each row of the matrix has @xmath99 non - zero entries with overwhelming probability .",
    "it is easy to see that the cost of computing @xmath145 for some round @xmath66 is linear in the number of non - zero entries in the associated matrix @xmath77 .",
    "a user @xmath5 can reduce this cost by setting some entries in row @xmath146 of @xmath77 to zero .",
    "suppose he sets @xmath147 entries of the @xmath146-th row of @xmath77 to zero ; the zero at @xmath148 is not included .",
    "his computation time is now @xmath149 of the original . for convenience ,",
    "we refer to these zeros as _",
    "holes_. if @xmath5 sets a",
    "_ hole _ at position @xmath150 , then @xmath80 necessarily has a hole at position @xmath146 .",
    "so if one party sets @xmath147 holes , another @xmath147 parties enjoy a marginally reduced cost .",
    "this idea raises some natural questions including    1 .",
    "since the matrix @xmath77 is deterministically and non - interactively generated in each round , how are a party s holes set ? 2 .",
    "what impact does the number of holes @xmath147 have on the collusion tolerance of the protocol ?",
    "does this lead to fewer rounds , and how many ? 3 .",
    "for some collusion tolerance @xmath17 and some desired number of rounds @xmath139 , how many users @xmath151 can simultaneously set @xmath147 holes while maintaining privacy ?    the first question can be addressed by assuming that all parties who seek to place holes declare this intention in the initial stage of the protocol .",
    "we define the predicate @xmath152 such that for all @xmath65 , we have @xmath153 if and only if @xmath5 sets holes . for all parties @xmath5 with @xmath153 , we assume they all set @xmath147 holes .",
    "the following algorithm is used to compute @xmath77 in a given round .",
    "note that we are using a hash function @xmath154 with seed @xmath155 effectively as a prng being modelled as a random oracle . ] . as such",
    ", we use the notation @xmath156 to denote the fact that @xmath157 is pseudorandomly sampled from the set @xmath158 using a pseduorandom function derived from @xmath154 and @xmath155 .    1 .",
    "set @xmath77 to the @xmath159 zero matrix .",
    "2 .   create an array @xmath160 of length @xmath2 ; set @xmath161 \\gets \\alpha$ ] for every @xmath65 .",
    "3 .   for all @xmath65 : 1 .   if @xmath162 , set @xmath163 .",
    "; 1 .   set @xmath164 $ ] .",
    "2 .   choose a subset of @xmath165 of cardinality @xmath166 ( these correspond to the holes ) .",
    "formally , sample @xmath167 .",
    "3 .   set @xmath168 \\gets w[j ] - 1 $ ] for every @xmath169 .",
    "4 .   set @xmath170 .",
    "3 .   for each @xmath171 : 1 .   set @xmath172 .",
    "2 .   set @xmath173    it turns out the all parties can set @xmath147 holes and benefit from a performance boost .",
    "the following lemma gives a _ lower bound _ on the number of non - holes a party must set , and therefore the number of exponentiations in @xmath29 ( viewed multiplicatively ) that have to performed per round ( per party ) to maintain @xmath17-privacy in the worst - case ( this is the number of non - holes plus 1 ) .",
    "recall that @xmath2 exponentiations are needed per round in the original pcl protocol .",
    "[ lem : expon ] let @xmath12 be the number of rounds .",
    "let @xmath174 be the collusion tolerance .",
    "a lower bound on the number of non - holes a party must set per round to guarantee @xmath17-privacy is @xmath175 .    to derive this lower bound",
    ", we consider the worst - case scenario .",
    "this corresponds to the case where all parties choose the same @xmath147 positions , which all lie outside the @xmath17 parties controlled by the adversary .",
    "a skew - symmetric matrix @xmath176 can be viewed as @xmath2 quadratic equations in @xmath2 variables @xmath177 .",
    "moreover , the @xmath146-th row of @xmath77 represents the equation @xmath178 .",
    "there are @xmath179 unique monomials @xmath180 .",
    "there is a corresponding coefficient matrix @xmath181 for @xmath77 whose @xmath146-th row consists of the coefficients for each monomial . by construction",
    ", @xmath182 is linearly dependant since all @xmath2 equations must sum to zero to achieve correctness .",
    "but , if we remove one row ( say the @xmath2-th ) to yield @xmath183 , then @xmath183 should be linearly independent .",
    "this is necessary to ensure security ( see the proof of theorem 1 in @xcite for more details ) .",
    "if we have @xmath12 rounds , then the resulting coefficient matrix @xmath184 ( formed by vertically concatenating the first @xmath99 rows of @xmath185 for @xmath186 ) must be linearly independent to guarantee security .",
    "but by dropping the adversary s @xmath17 parties , along with @xmath147 parties corresponding to the holes ( in the worst - case ) , we are left with @xmath187 parties . a precondition for linear independence",
    "is that @xmath188 .",
    "since each party must set @xmath189 non - holes , it follows from the inequality that a lower bound is @xmath175 .",
    "lemma [ lem : expon ] only considers a lower bound .",
    "this tell us the best we can hope for .",
    "we explain in the next section why setting the number of non - holes to merely meet this lower bound is not sufficient for @xmath17-privacy .",
    "let @xmath77 be a skew - symmetric matrix .",
    "@xmath77 can be viewed as an undirected graph @xmath45 , where the vertices represent the parties @xmath25 , and there is an edge between @xmath5 and @xmath80 if @xmath190 .",
    "if @xmath45 can be partitioned into more than one connected component , say components @xmath191 and @xmath192 , then partial sums can be learned of the parties in both components .",
    "it turns out that by just setting non - holes to merely meet the lower bound given by lemma [ lem : expon ] is not sufficient to avoid partitions . since @xmath77 is deterministically generated , it might be tempting to modify the algorithm to generate @xmath77 such that this does not occur . however , we do nt know ahead of time which @xmath17 parties are controlled by the adversary .",
    "let @xmath139 the number of non - holes set by each player . from lemma",
    "[ lem : expon ] , @xmath193 .",
    "formally , to ensure @xmath17-privacy , given a connected graph @xmath45 of degree @xmath139 , it must hold that if any @xmath194 vertices are removed to yield @xmath195 , then @xmath195 remains connected .",
    "in fact , such as graph @xmath45 is referred to as @xmath66-vertex - connected , where @xmath66 in this case is @xmath196 .",
    "there are techniques to generate @xmath45 to satisfy this property .",
    "one of those techniques involve each party linking to its @xmath139 `` nearest neighbors '' , where the distance between @xmath5 and @xmath80 is @xmath197 .",
    "therefore , we can change the algorithm that generates the skew - matrix @xmath77 to follow this technique .",
    "this means that we can ensure @xmath17-privacy and perform only @xmath198 exponentiations per round , as opposed to @xmath2 in the original protocol .",
    "due to its comparitively poor performance , as shown in table [ tab : round_times ] , there is abundant motivation for reducing the computational cost of a round of multi - round kdk . our technique from section [ sec : pcl_holes ]",
    "can also be applied to multi - round kdk , although with even greater scope for improvement .",
    "the reason for this is as follows .",
    "recall the coefficient matrix from the proof of lemma [ lem : expon ] . in pcl",
    ", @xmath99 rows are added to this matrix in every round . however , in multi - round kdk , due to the pairing , there is no linear relationship between the set of equations of each round . as such",
    ", we only have to consider a single set of @xmath99 equations in isolation .",
    "since there are fewer equations , it is easier to avoid linear dependence , and more holes can be set as a consequence . since a skew - symmetric matrix @xmath77 is fixed for multi - round kdk , we replace this matrix with one generated according to the technique mentioned in section [ sec : graph ] .",
    "like above , we consider the worst - case scenario and derive a lower bound on @xmath147 .",
    "let us represent the number of dishonest users as a fraction @xmath199 $ ] of @xmath2 . as a necessary condition for linear independence",
    ", the following inequality must be satisfied @xmath200 since we know that @xmath201 , we can simplify ( [ eq : ineq_alpha ] ) to obtain an upper bound on @xmath147 : @xmath202 because there will always be @xmath203 non - holes , the number of additional non - holes that is necessary is @xmath204 .",
    "it follows that the computational load as a fraction of the original load is then lower bounded by @xmath205 which shows that as @xmath2 grows , the cost of this modified protocol relative to the original converges towards @xmath206 .",
    "while there are several protocols that enable users to privately compute the summary of their values , in many cases , as in the case of kdk , there are several hidden implementation bottlenecks which can significantly delay the calculations of different stages of the protocol . in this work",
    "we indicate that for instance the multi - round kdk protocol , due its heavy reliance on pairings is not practical at present for large numbers of users @xmath207 , whereas pcl is highly practical in these cases at the expense of reduced collusion tolerance .",
    "we showed that further customization of the privacy level facilitates further extensions to both protocols , and such extensions were shown to be secure .",
    "if applied , these extension can boost the efficiency of both these protocols , leading to faster applications with customizable levels of privacy ."
  ],
  "abstract_text": [
    "<S> in this work we compare two recent multiparty computation ( mpc ) protocols for private summation in terms of performance . </S>",
    "<S> both protocols allow multiple rounds of aggregation from the same set of public keys generated by parties in an initial stage . </S>",
    "<S> we instantiate the protocols with a fast elliptic curve and provide an experimental comparison of their performance for different phases of the protocol . </S>",
    "<S> furthermore , we introduce a technique that allows the computational load of both protocols to be reduced at the expense of protection against collusion tolerance . </S>",
    "<S> we prove that both protocols remain secure with this technique , and evaluate its impact on collusion tolerance and the number of rounds supported .    multiparty computation , private summation , custom collusion tolerance , private aggregation </S>"
  ]
}