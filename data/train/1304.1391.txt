{
  "article_text": [
    "several real world applications require solutions of classification problems on large datasets .",
    "even though svms are known to give excellent classification results , their application to problems with large datasets is impeded by the burdensome training time requirements .",
    "recently , much progress has been made in the design of fast training algorithms @xcite for svms with the linear kernel ( linear svms ) . however , many applications require svms with non - linear kernels for accurate classification .",
    "training time complexity for svms with non - linear kernels is typically quadratic in the size of the training dataset @xcite .",
    "the difficulty of the long training time is exacerbated when grid search with cross - validation is used to derive the optimal hyper - parameters , since this requires multiple svm training runs .",
    "another problem that sometimes restricts the applicability of svms is the long classification time .",
    "the time complexity of svm classification is linear in the number of support vectors and in some applications the number of support vectors is found to be very large @xcite .    in this paper",
    ", we propose a new approach for fast svm training .",
    "consider a two class dataset of @xmath2 data vectors , @xmath3 , and the corresponding target labels @xmath4 , i = 1,2, ... ,n\\}$ ] .",
    "the svm primal problem can be represented as the following unconstrained optimization problem @xcite : @xmath5 here @xmath6 is the hinge loss of @xmath7 .",
    "note that svm formulations where the penalty parameter @xmath8 is divided by @xmath2 have been used extensively @xcite .",
    "these formulations enable better analysis of the scaling of @xmath8 with @xmath2 @xcite .",
    "the problem in ( [ eq : svc_primal2 ] ) requires optimization over @xmath2 variables . in general , for svm training algorithms the training time will reduce if the size of the training dataset is reduced .",
    "_ in this paper , we present an alternative to ( [ eq : svc_primal2 ] ) , called approximate extreme points support vector machines ( aesvm ) , that requires optimization over only a subset of the training dataset . _",
    "the aesvm formulation is : @xmath9 here @xmath10 is the number of vectors in the selected subset of @xmath11 , called the representative set @xmath12 .",
    "the constants @xmath13 are defined in ( [ eq : betadef ] ) .",
    "we will prove in section [ sec : prop ] that :    * @xmath14 , where @xmath15 and @xmath16 are the solutions of ( [ eq : svc_primal2 ] ) and ( [ eq : aesvm_primal2 ] ) respectively * under the assumptions given in corollary 4 , @xmath17 * the aesvm problem minimizes an upper bound of a low rank gram matrix approximation of the svm objective function    based on these results we claim that solving the problem in ( [ eq : aesvm_primal2 ] ) yields a solution close to that of ( [ eq : svc_primal2 ] ) . as a by - product of the reduction in size of the training set ,",
    "aesvm is also observed to result in fast classification .",
    "considering that the representative set will have to be computed several times if grid search is used to find the optimum hyper - parameter combination , we also propose fast algorithms to compute @xmath18 .",
    "in particular , we present an algorithm of time complexity @xmath19 and an alternative algorithm of time complexity @xmath20 to compute @xmath18 , where @xmath21 is a predefined large integer .    the main contributions of this work can be summarized as follows :    * _ theoretical : _ theorems 1 and 2 , and corollaries 3 to 5 give rationale for the use of aesvm as a computationally less demanding alternative to the svm formulation .",
    "* _ algorithmic : _ the algorithm derivers , described in section [ sec : derrp ] , computes the representative set in linear time . * _ experimental : _ our extensive experiments on nine datasets of varying characteristics , illustrate the suitability of applying aesvm to classification on large datasets .",
    "this paper is organized as follows : in section 2 , we briefly discuss recent research on fast svm training that is closely related to this work .",
    "next , we provide the definition of the representative set and discuss properties of aesvm .",
    "in section 4 , we present efficient algorithms to compute the representative set and analyze its computational complexity .",
    "section 5 describes the results of our computational experiments .",
    "we compared aesvm to the widely used libsvm library , core vector machines ( cvm ) , ball vector machines ( bvm ) , lasvm , @xmath0 , and the random features method by @xcite .",
    "our experiments used eight publicly available datasets and a data set on eeg from an animal model of epilepsy @xcite .",
    "we conclude with a discussion of the results of this paper in section 6 .",
    "several methods have been proposed to efficiently solve the svm optimization problem .",
    "svms require special algorithms , as standard optimization algorithms such as interior point methods @xcite have large memory and training time requirements that make it infeasible for large datasets . in the following sections we discuss the",
    "most widely used strategies to solve the svm optimization problem .",
    "we present a comparison of some of these methods to aesvm in section [ sec : disc ] .",
    "svm solvers can be broadly divided into two categories as described below .",
    "the svm primal problem is a convex optimization problem with strong duality @xcite .",
    "hence its solution can be arrived at by solving its dual formulation given below : @xmath22 here @xmath23 , is the kernel product @xcite of the data vectors @xmath7 and @xmath24 , and @xmath25 is a vector of all variables @xmath26 . solving the dual problem is computationally simpler , especially for non - linear kernels and a majority of the svm solvers use dual optimization . some of the major dual optimization algorithms are discussed below .    _ decomposition methods _ @xcite have been widely used to solve ( [ eq : svc_dual ] ) .",
    "these methods optimize over a subset of the training dataset , called the ` working set ' , at each algorithm iteration .",
    "@xmath27 @xcite and smo @xcite are popular examples of decomposition methods .",
    "both these methods have a quadratic time complexity for linear and non - linear svm kernels @xcite .",
    "heuristics such as shrinking and caching @xcite enable fast convergence of decomposition methods and reduce their memory requirements .",
    "libsvm @xcite is a very popular implementation of smo .",
    "a _ dual coordinate descent _",
    "@xcite svm solver computes the optimal @xmath25 value by modifying one variable @xmath26 per algorithm iteration .",
    "dual coordinate descent svm solvers , such as liblinear @xcite , have been proposed primarily for the linear kernel .",
    "_ approximations of the gram matrix _",
    "@xcite , have been proposed to increase training speed and reduce memory requirements of svm solvers .",
    "the gram matrix is the @xmath2x@xmath2 square matrix composed of the kernel products @xmath28 .",
    "_ training set selection _ methods attempt to reduce the svm training time by optimizing over a selected subset of the training set .",
    "several distinct approaches have been used to select the subset .",
    "some methods use clustering based approaches @xcite to select the subsets . in @xcite , hierarchical clustering",
    "is performed to derive a dataset that has more data vectors near the classification boundary than away from it .",
    "minimum enclosing ball clustering is used in @xcite to remove data vectors that are unlikely to contribute to the svm training .    _ random sampling _ of training data is another approach followed by approximate svm solvers .",
    "@xcite proposed reduced support vector machines ( rsvm ) , in which only a random subset of the training dataset is used .",
    "they solve a modified formulation of the l2-svm that minimizes the @xmath29-norm of @xmath30 instead of its @xmath31-norm .",
    "@xcite proposed the lasvm algorithm that uses _ active selection _ techniques to train svms on a subset of the training dataset .",
    "a _ core set _",
    "@xcite can be loosely defined as the subset of @xmath11 for which the solution of an optimization problem such as ( [ eq : svc_dual ] ) has a solution similar to that for the entire dataset @xmath11 .",
    "@xcite proved that the l2-svm is a reformulation of the minimum enclosing ball problem for some kernels .",
    "they proposed core vector machine ( cvm ) that approximately solves the l2-svm formulation using core sets . a simplified version of cvm called ball vector machine ( bvm )",
    "was proposed in @xcite , where only an enclosing ball is computed .",
    "@xcite proposed an algorithm to solve the l1-svm problem , by computing the shortest distance between two polytopes @xcite using core sets .",
    "however , there are no published results on solving l1-svm with non - linear kernels using their algorithm .",
    "another method used to approximately solve the svm problem is to map the data vectors into a _ randomized feature space _ that is relatively low dimensional compared to the kernel space @xmath32 @xcite .",
    "inner products of the projections of the data vectors are approximations of their kernel product .",
    "this effectively reduces the non - linear svm problem into the simpler linear svm problem , enabling the use of fast linear svm solvers .",
    "this method is referred as rfeatsvm in the following sections of this document .      in recent years",
    ", linear svms are finding increased use in applications with high - dimensional datasets .",
    "this has led to a surge in publications on efficient primal svm solvers , which are mostly used for linear svms . to overcome the difficulties caused by the non - differentiability of the primal problem ,",
    "the following methods are used .",
    "_ stochastic sub - gradient descent _",
    "@xcite uses the sub - gradient computed at some data vector @xmath7 to iteratively update @xmath33 .",
    "@xcite proposed a stochastic sub - gradient descent svm solver , pegasos , that is reported to be among the fastest linear svm solvers .",
    "_ cutting plane algorithms _ @xcite solve the primal problem by successively tightening a piecewise linear approximation .",
    "it was employed by @xcite to solve linear svms with their implementation @xmath0 .",
    "this work was generalized in @xcite to include non - linear svms by approximately estimating @xmath34 with arbitrary basis vectors using the fix - point iteration method @xcite .",
    "@xcite proposed a related method for linear svms , that corrected some stability issues in the cutting plane methods .",
    "as mentioned in the introduction , aesvm is an optimization problem on a subset of the training dataset called the representative set . in this section",
    "we first define the representative set",
    ". then we present some properties of aesvm .",
    "these results are intended to provide theoretical justifications for the use of aesvm as an approximation to the svm problem ( [ eq : svc_primal2 ] ) .",
    "we denote the cardinality of a set @xmath35 by @xmath36 .",
    "the convex hull of a set @xmath11 is the smallest convex set containing @xmath11 @xcite and can be obtained by taking all possible convex combinations of elements of @xmath11 .",
    "assuming @xmath11 is finite , the convex hull is a polygon .",
    "the extreme points of @xmath11 , @xmath37 , are defined to be the vertices of the convex polygon formed by the convex hull of @xmath11 .",
    "any vector @xmath7 in @xmath11 can be represented as a convex combination of vectors in @xmath37 : @xmath38    we can see that functions of any data vector in @xmath11 can be computed using only @xmath37 and the convex combination weights @xmath39 .",
    "the design of aesvm is motivated by the intuition that the use of extreme points may provide computational efficiency . however , extreme points are not useful in all cases , as for some kernels all data vectors are extreme points in kernel space . for example , for the gaussian kernel , @xmath40 .",
    "this implies that all the data vectors lie on the surface of the unit ball in the gaussian kernel space and therefore are extreme points .",
    "hence , we introduce the concept of _ approximate extreme points_.    consider the set of transformed data vectors : @xmath41 here , the explicit representation of vectors in kernel space is only for the ease of understanding and all the computations are performed using kernel products .",
    "let @xmath42 be a positive integer that is much smaller than @xmath2 and @xmath43 be a small positive real number . for notational simplicity , we assume @xmath2 is divisible by @xmath42 .",
    "let @xmath44 be subsets of @xmath45 for @xmath46 , such that @xmath47 and @xmath48 for @xmath49 , where @xmath50 .",
    "we require that the subsets @xmath44 satisfy @xmath51 and @xmath52    let @xmath53 denote an arbitrary subset of @xmath44 .",
    "next , for any @xmath54 we define : @xmath55 consider the collection of subsets @xmath56 a set of approximate extreme points of @xmath44 is denoted by @xmath57 , and is defined as follows are valid for any @xmath53 . the requirement for the smallest @xmath53",
    "is made only for the sake of a computationally simpler aesvm problem ] @xmath58 it can be seen that @xmath59 for @xmath60 are analogous to the convex combination weights @xmath61 for @xmath62 .",
    "the _ representative set _",
    "@xmath18 of @xmath45 is the union of the sets of approximate extreme points of its subsets @xmath44 . @xmath63    the representative set has properties that are similar to @xmath37 .",
    "given any @xmath64 , we can find @xmath44 such that @xmath54 .",
    "let @xmath65 . now using ( [ eq : aex ] )",
    ", we can write : @xmath66 here",
    "@xmath67 is a vector that accounts for the approximation error @xmath68 in ( [ eq : aex ] ) . from ( [ eq : aex])-([eq : rkhs_ae ] ) we can conclude that : @xmath69 since @xmath43 will be set to a very small positive constant , we can infer that @xmath67 is a very small vector .",
    "the weights @xmath70 are used to define @xmath71 in ( [ eq : aesvm_primal2 ] ) as : @xmath72    for ease of notation , we refer to the set @xmath73 as the representative set of @xmath11 in the remainder of this paper . for the sake of simplicity",
    ", we assume that all @xmath74 are arranged so that @xmath12 is positioned as the first @xmath10 vectors of @xmath11 , where @xmath75 .",
    "consider the following optimization problem .",
    "@xmath76 we use the problem in ( [ eq : f3_primal ] ) as an intermediary between ( [ eq : svc_primal2 ] ) and ( [ eq : aesvm_primal2 ] ) . the intermediate problem ( [ eq : f3_primal ] )",
    "has a direct relation to the aesvm problem , as given in the following theorem .",
    "the properties of the @xmath77 function given below are relevant to the following discussion : @xmath78 for @xmath79 and @xmath80 .",
    "* theorem 1 * _ let @xmath81 and @xmath82 be as defined in ( [ eq : f3_primal ] ) and ( [ eq : aesvm_primal2 ] ) respectively .",
    "then , @xmath83 _    let @xmath84 and @xmath85 , where @xmath86 . from the properties of @xmath70 in ( [ eq : aex ] ) , and from ( [ eq :",
    "rpyprop ] ) we get : @xmath87 \\label{eq : l3_def}\\\\ & = \\frac{c}{n } \\overset{n}{\\underset{i = 1}{\\sum } } max\\left[0 , \\overset{m}{\\underset{t = 1}\\sum } \\gamma^i _",
    "t\\left\\{1- y_{t}(\\mathbf{w}^t { { \\bf z}_t } + b)\\right\\}\\right]\\nonumber\\end{aligned}\\ ] ]    using properties ( [ eq : maxa ] ) and ( [ eq : maxc ] ) we get : @xmath88 \\nonumber\\\\ & = \\frac{c}{n } \\overset{m}{\\underset{t = 1}\\sum } max\\left[0 , 1- y_{t}(\\mathbf{w}^t { { \\bf z}_t } + b)\\right ] \\overset{n}{\\underset{i = 1}{\\sum}}\\gamma^i _ t \\nonumber\\\\ & = { \\cal l}_2({\\bf w},b,{\\bf x}^ * ) \\nonumber\\end{aligned}\\ ] ] adding @xmath89 to both sides of the inequality above we get @xmath90    the following theorem gives a relationship between the svm problem and the intermediate problem .    * theorem 2 * _ let @xmath91 and @xmath81 be as defined in ( [ eq : svc_primal2 ] ) and ( [ eq : f3_primal ] ) respectively",
    ". then , @xmath92 _    let @xmath93 , denote the average hinge loss that is minimized in ( [ eq : svc_primal2 ] ) and @xmath94 be as defined in theorem 1 . using ( [ eq : rkhs_ae ] ) and ( [ eq : svc_primal2 ] ) we get : @xmath95 from the properties of @xmath70 in ( [ eq : aex ] ) , and from ( [ eq : rpyprop ] ) we get : @xmath96 using ( [ eq : maxa ] ) on ( [ eq : t1e1 ] ) , we get : @xmath97 + \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum}}max\\left\\{0 , -y_{i}\\mathbf{w}^t \\tau_i\\right\\}\\\\ & = { \\cal l}_3({\\bf w},b,{\\bf x}^ * ) + \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum}}max\\left\\{0 , -y_{i}\\mathbf{w}^t \\tau_i\\right\\}\\end{aligned}\\ ] ] using ( [ eq : maxb ] ) on ( [ eq : t1e1 ] ) , we get : @xmath98 - \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum}}max\\left\\{0 , y_{i}\\mathbf{w}^t",
    "\\tau_i\\right\\}\\\\ & = { \\cal l}_3({\\bf w},b,{\\bf x}^ * ) - \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum}}max\\left\\{0 , y_{i}\\mathbf{w}^t \\tau_i\\right\\}\\end{aligned}\\ ] ] from the two inequalities above we get , @xmath99 adding @xmath89 to the inequality above we get @xmath100    using the above theorems we derive the following corollaries .",
    "these results provide the theoretical justification for aesvm .",
    "* corollary 3 * _ let @xmath101 be the solution of ( [ eq : svc_primal2 ] ) and @xmath102 be the solution of ( [ eq : aesvm_primal2 ] ) . then , @xmath103 _    it is known that @xmath104 ( refer theorem 1 in @xcite ) .",
    "it is straight forward to see that the same result also applies to aesvm , @xmath105 .",
    "based on ( [ eq : taunorm ] ) we know that @xmath106 . from theorem 2",
    "we get : @xmath107 since @xmath101 is the solution of ( [ eq : svc_primal2 ] ) , @xmath108 . using this property and theorem 1 in the inequality above",
    ", we get : @xmath109    now we demonstrate some properties of aesvm using the dual problem formulations of aesvm and the intermediate problem .",
    "the dual form of aesvm is given by : @xmath110 the dual form of the intermediate problem is given by : @xmath111 consider the mapping function @xmath112 , defined as @xmath113 it can be seen that the objective functions @xmath114 and @xmath115 are identical .",
    "@xmath116 it is also straight forward to see that , for any feasible @xmath117 of ( [ eq : f3_dual ] ) , @xmath118 is a feasible point of ( [ eq : aesvm_dual ] ) as it satisfies the constraints in ( [ eq : aesvm_dual ] ) .",
    "however , the converse is not always true . with that clarification",
    ", we present the following corollary .",
    "* corollary 4 * _ let @xmath101 be the solution of ( [ eq : svc_primal2 ] ) and @xmath102 be the solution of ( [ eq : aesvm_primal2 ] ) .",
    "let @xmath119 be the dual variable corresponding to @xmath102 .",
    "let @xmath120 be as defined in ( [ eq : hfunc ] ) .",
    "if there exists an @xmath121 such that @xmath122 and @xmath121 is a feasible point of ( [ eq : f3_dual ] ) , then , @xmath123 _    let @xmath124 be the solution of ( [ eq : f3_primal ] ) and @xmath125 the solution of ( [ eq : f3_dual ] ) .",
    "we know that @xmath126 and @xmath127 .",
    "since @xmath128 , we get @xmath129 but , from theorem 1 we know @xmath130 .",
    "hence @xmath131 from the above result we get @xmath132 from theorem 2 we have the following inequalities : @xmath133 adding ( [ eq : cor2e1 ] ) and ( [ eq : cor2e2 ] ) we get : @xmath134\\label{eq : cor2}\\end{aligned}\\ ] ] where @xmath135 . using ( [ eq : cor4e1 ] ) and",
    "the properties @xmath136 and @xmath137 in ( [ eq : cor2 ] ) : @xmath138\\\\ & \\le \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum } } \\|{\\bf w}_2^*\\| \\|\\tau_i\\| + \\|{\\bf w}_1^*\\| \\|\\tau_i\\|\\\\ & \\le \\frac{c}{n}\\overset{n}{\\underset{i = 1}{\\sum } } 2\\sqrt{c\\epsilon } = 2c\\sqrt{c\\epsilon}\\end{aligned}\\ ] ]    now we prove a relationship between aesvm and the gram matrix approximation methods mentioned in section [ sec : otherdual ] .",
    "* corollary 5 *    _ let @xmath139 , @xmath115 , and @xmath140 be the objective functions of the svm dual ( [ eq : svc_dual ] ) , intermediate dual ( [ eq : f3_dual ] ) and aesvm ( [ eq : aesvm_primal2 ] ) respectively . let @xmath141 , @xmath67 , and @xmath142 be as defined in ( [ eq : zdef ] ) , ( [ eq : rkhs_ae ] ) , and ( [ eq : f3_primal ] ) respectively .",
    "let @xmath143 and @xmath144 be the @xmath145 matrices with @xmath146 and @xmath147 respectively . then for any feasible @xmath148 : _    1 .",
    "rank of @xmath149 , and @xmath150 2 .",
    "@xmath151    using @xmath143 , the svm dual objective function @xmath139 can be represented as : @xmath152 similarly , @xmath115 can be represented using @xmath144 as : @xmath153 applying @xmath154 to the definition of @xmath144 , we get : @xmath155 here @xmath156 is the @xmath10x@xmath10 matrix comprised of @xmath157 and @xmath158 is the @xmath2x@xmath10 matrix with the elements @xmath159 .",
    "hence the rank of @xmath160 and intermediate dual problem ( [ eq : f3_dual ] ) is a low rank approximation of the svm dual problem ( [ eq : svc_dual ] ) .",
    "the gram matrix approximation error can be quantified using ( [ eq : rkhs_ae ] ) and ( [ eq : taunorm ] ) as : @xmath161\\\\ % \\gamma^i _",
    "s{\\bf z}_s + \\tau_i)- ( \\overset{m}{\\underset{t = 1}\\sum } \\gamma^i _ t { \\bf z}_t ) ^t ( \\overset{m}{\\underset{s = 1}\\sum } \\gamma^i _",
    "s{\\bf z}_s)\\right]\\\\   & = \\overset{n}{\\underset{i = 1}{\\sum } } \\left[\\tau_i ^t",
    "\\tau_i + 2\\overset{m}{\\underset{t = 1}\\sum } \\gamma^i _ t { \\bf z}_t ^t \\tau_i\\right ] \\le n\\epsilon + 2 \\overset{m}{\\underset{t = 1}\\sum } { \\bf z}_t ^t \\overset{n}{\\underset{i = 1}{\\sum } } \\gamma^i _ t \\tau_i\\end{aligned}\\ ] ]    by the principle of duality , we know that @xmath162 , where @xmath117 is any feasible point of ( [ eq : f3_dual ] ) . using theorem 1 on the inequality above , we get @xmath163 thus the aesvm problem minimizes an upper bound ( @xmath140 ) of a rank @xmath10 gram matrix approximation of @xmath139 .",
    "based on the theoretical results in this section , it is reasonable to suggest that for small values of @xmath43 , the solution of aesvm is close to the solution of svm .",
    "in this section , we present algorithms to compute the representative set . _",
    "the aesvm formulation can be solved with any standard svm solver such as smo and hence we do not discuss methods to solve it_. as described in section [ sec : rpdef ] , we require an algorithm to compute approximate extreme points in kernel space . @xcite proposed an algorithm to derive extreme points of the convex hull of a dataset in kernel space .",
    "their algorithm is computationally intensive , with a time complexity of @xmath164 , and is unsuitable for large datasets as @xmath165 typically has a super - linear dependence on n. the function @xmath165 denotes the time complexity of a svm solver ( required by their algorithm ) , to train on a dataset of size n. we next propose two algorithms leveraging the work by @xcite to compute the representative set in kernel space @xmath18 with much smaller time complexities .",
    "we followed the divide and conquer approach to develop our algorithms .",
    "the dataset is first divided into subsets @xmath166 , where @xmath167 , @xmath168 and @xmath169 .",
    "the parameter @xmath21 is a predefined large integer .",
    "it is desired that each subset @xmath170 contains data vectors that are more similar to each other than data vectors in other subsets .",
    "our notion of similarity of data vectors in a subset , is that the distances between data vectors within a subset is less than the distances between data vectors in distinct subsets .",
    "this first level of segregation is followed by another level of segregation .",
    "we can regard the first level of segregation as coarse segregation and the second as fine segregation .",
    "finally , the approximate extreme points of the subsets obtained after segregation , are computed .",
    "the two different algorithms to compute the representative set differ only in the first level of segregation as described in the following sections .",
    "we propose the methods , fls1 and fls2 given below to perform a first level of segregation . in the following description we use arrays @xmath171 and @xmath172 of @xmath2 elements . each element of @xmath171 ( @xmath173 ) , @xmath174 ( @xmath175 ) , contains the index in @xmath11 of the last data vector of the subset to which @xmath7 belongs .",
    "it is straight forward to replace this @xmath2 element array with a smaller array of size equal to the number of subsets .",
    "we use a @xmath2 element array for ease of description .    _",
    "fls1(@xmath176 ) _    for some applications , such as anomaly detection on sequential data ,",
    "data vectors are found to be homogeneous within intervals .",
    "for example , the atmospheric conditions typically do not change within a few minutes and hence weather data is homogeneous for a short span . for such datasets",
    "it is enough to segregate the data vectors based on its position in the training dataset .",
    "the same method can also be used on very large datasets without any homogeneity , in order to reduce computation time .",
    "the complexity of this method is @xmath177 , where @xmath178 .    1 .   for outerindex = 1 *",
    "_ _ t__o * ceiling(@xmath179 ) 2 .   for innerindex = ( outerindex - 1)@xmath21 *",
    "_ _ t__o * min((outerindex)@xmath21,@xmath180 ) 3 .   set @xmath181    _ 2 .",
    "fls2(@xmath176 ) _    when the dataset is not homogeneous within intervals or it is not excessively large we use the more sophisticated algorithm , fls2 , of time complexity @xmath182 given below . in step 1 of fls2 , the distance @xmath183 in kernel space of all @xmath184 from @xmath24",
    "is computed as @xmath185 .",
    "the algorithm fls2(@xmath176 ) , in effect builds a binary search tree , with each node containing the data vector @xmath186 selected in step 2 that partitions a subset of the dataset into two .",
    "the size of the subsets successively halve , on downward traversal from the root of the tree to the other nodes . when the size of all the subsets at a level become @xmath187 the algorithm halts .",
    "the complexity of fls2 can be derived easily when the algorithm is considered as an incomplete binary search tree building method .",
    "the last level of such a tree will have @xmath188 nodes and consequently the height of the tree is @xmath189 . at each level of the tree",
    "the calls to the bfprt algorithm @xcite and the rearrangement of the data vectors in steps 2 and 3 are of @xmath177 time complexity .",
    "hence the overall time complexity of fls2(@xmath176 ) is @xmath182 .    1 .",
    "compute distance @xmath183 in kernel space of all @xmath184 from the first vector @xmath24 in @xmath190 2 .   select @xmath186 such that there exists @xmath191 data vectors @xmath184 with @xmath192 , using the linear time bfprt algorithm 3 .   using @xmath186 ,",
    "rearrange @xmath190 as @xmath193 , where @xmath194 and @xmath195 4 .   if @xmath196 for @xmath197 where @xmath198 , set @xmath174 = index of last data vector in @xmath199 . for @xmath197 where @xmath200 , set @xmath174 = index of last data vector in @xmath201 .",
    "5 .   if @xmath202 run fls2(@xmath203 ) and fls2(@xmath204 )      after the initial segregation , another method sls(@xmath205 ) is used to further segregate each set @xmath170 into smaller subsets @xmath206 of maximum size @xmath42 , @xmath207 , where @xmath42 is predefined ( @xmath208 ) and @xmath209 .",
    "the algorithm sls(@xmath205 ) is given below . in step 2.b",
    ", @xmath210 is the data vector in @xmath170 that is farthest from the origin in the space of the data vectors .",
    "for some kernels , such as the gaussian kernel , all data vectors are equidistant from the origin in kernel space .",
    "if the algorithm chooses @xmath211 in step 2.b based on distances in such kernel spaces , the choice would be arbitrary and such a situation is avoided here .",
    "each iteration of the for loop in step 2 involves several runs of the bfprt algorithm , with each run followed by a rearrangement of @xmath170 . specifically , the bfprt algorithm is first run on @xmath21 data vectors , then on @xmath212 data vectors , then on @xmath213 data vectors and so on .",
    "the time complexity of each iteration of the for loop including the bfprt algorithm run and the rearrangement of data vectors is : @xmath214 .",
    "the overall complexity of sls(@xmath205 ) considering the q for loop iterations is @xmath215 , since @xmath216 .    1",
    ".   initialize @xmath217 2 .   for q = 1 *",
    "_ _ t__o * @xmath218 1 .",
    "identify subset @xmath170 of @xmath190 using @xmath219 2 .",
    "set @xmath220 , where @xmath221 3 .",
    "compute distance @xmath183 in kernel space of all @xmath222 from @xmath211 4 .",
    "select @xmath186 such that , there exists @xmath42 data vectors @xmath222 with @xmath192 , using the bfprt algorithm 5 .   using @xmath186 ,",
    "rearrange @xmath170 as @xmath223 , where @xmath224 and @xmath225 6 .   for @xmath197 where @xmath198 , set @xmath175 = index of last data vector in @xmath199 , where @xmath175 is the @xmath226 element of @xmath173 7 .",
    "remove @xmath199 from @xmath170 8 .   if @xmath227 set : @xmath228 and @xmath229 repeat steps 2.c to 2.h 9 .   if @xmath230 for @xmath197 where @xmath200 , set @xmath175 = index of last data vector in @xmath201      after computing the subsets @xmath206 , the algorithm deriveae is applied to each @xmath206 to compute its approximate extreme points .",
    "the algorithm deriveae is described below .",
    "deriveae uses three routines .",
    "sphereset(@xmath206 ) returns all @xmath231 that lie on the surface of the smallest hypersphere in kernel space that contains @xmath206 .",
    "it computes the hypersphere as a hard margin support vector data descriptor ( svdd ) @xcite .",
    "spheresort(@xmath206 ) returns data vectors @xmath231 sorted in descending order of distance in the kernel space from the center of the svdd hypersphere .",
    "checkpoint(@xmath232 ) returns true if @xmath7 is an approximate extreme point of the set @xmath233 in kernel space .",
    "the operator @xmath234 indicates a set operation that returns the set of the members of @xmath235 excluding @xmath236 .",
    "the matrix @xmath237 contains the approximate extreme points of @xmath206 and @xmath238 is a @xmath239 sized vector .    1 .   initialize : @xmath237 = sphereset(@xmath206 ) and @xmath240 2 .",
    "set @xmath241 = spheresort(@xmath242 ) 3 .",
    "for each @xmath7 taken in order from @xmath241 , call the routine checkpoint(@xmath243 ) if it returns @xmath244 , then set @xmath245 4 .   for each @xmath246 , execute checkpoint(@xmath247 ) if it returns @xmath244 , set @xmath248 5 .   initialize a matrix @xmath158 of size @xmath249x@xmath239 with all elements set to 0 set @xmath250 , where @xmath251 is the element in the @xmath226 row and @xmath252 column of @xmath158 6 .   for",
    "each @xmath231 and @xmath253 , execute checkpoint(@xmath254 ) set the @xmath226 row of @xmath158 = @xmath255 , where @xmath255 is the result of checkpoint(@xmath254 ) 7 .   for j = 1",
    "* _ _ t__o * @xmath239 set @xmath256    checkpoint(@xmath232 ) is computed by solving the following quadratic optimization problem : @xmath257 where @xmath258 .",
    "if the optimized value of @xmath259 , checkpoint(@xmath232 ) returns true and",
    "otherwise it returns false .",
    "it can be seen that the formulation of @xmath260 is similar to ( [ eq : aex ] ) .",
    "the value of @xmath255 computed by checkpoint(@xmath261 ) , is used in step 6 of deriveae .",
    "now we compute the time complexity of deriveae .",
    "we use the fact that the optimization problem in checkpoint(@xmath232 ) is essentially the same as the dual optimization problem of svm given in ( [ eq : svc_dual ] ) .",
    "since deriveae solves several svm training problems in steps 1,3,4 , and 6 , it is necessary to know the training time complexity of a svm . as any svm solver method",
    "can be used , we denote the training time complexity of each step of deriveae that solves an svm problem as @xmath262 . , @xmath263 here @xmath264 is the largest value of @xmath265 during the run of deriveae(@xmath206 ) .",
    "this enables us to derive a generic expression for the complexity of deriveae , independent of the svm solver method used .",
    "hence the time complexity of step 1 is @xmath262 .",
    "the time complexity of steps 3 , 4 and 6 are @xmath266 , @xmath267 , and @xmath267 respectively .",
    "the time complexity of step 2 is @xmath268 , where @xmath269 = sphereset(@xmath206 ) .",
    "hence the time complexity of deriveae is @xmath270 . since @xmath271 is typically very small and @xmath272",
    ", we denote the time complexity of deriveae by @xmath273 .",
    "to derive @xmath274 , it is required to first rearrange @xmath11 , so that data vectors from each class are grouped together as @xmath275 . here",
    "then the selected segregation methods are run on @xmath277 and @xmath278 separately .",
    "the algorithm derivers given below , combines all the algorithms defined earlier in this section with a few additional steps , to compute the representative set of @xmath11 .",
    "the complexity of derivers can easily be computed by summing the complexities of its steps .",
    "the complexity of steps 1 and 6 is o(n ) .",
    "the complexity of step 2 is @xmath19 if fls1 is run or @xmath279 if fls2 is run . in step 3",
    ", the @xmath280 method sls is run . in steps 4 and 5",
    ", deriveae is run on all the subsets @xmath206 giving a total complexity of @xmath281 .",
    "here we use the fact that the number of subsets @xmath206 is @xmath282 .",
    "thus the complexity of derivers is @xmath283 when fls1 is used and @xmath284 when fls2 is used .    1",
    ".   set @xmath285 and @xmath286 2 .",
    "run [ @xmath287 = fls(@xmath277,p ) and [ @xmath288 = fls(@xmath278,p ) , where fls is fls1 or fls2 3 .   run [ @xmath289 = sls(@xmath277,v,@xmath290 ) and [ @xmath291 = sls(@xmath278,v,@xmath292 ) 4 .   using @xmath293 , identify each subset @xmath206 of @xmath277 and run [ @xmath294 = deriveae(@xmath206 ) set @xmath295 sum of number of data vectors in all @xmath237 derived from @xmath277 5 .   using @xmath296 , identify each subset @xmath206 of @xmath278 and run [ @xmath294 = deriveae(@xmath206 ) set @xmath297 sum of number of data vectors in all @xmath237 derived from @xmath278 6 .   combine in the same order , all @xmath237 to obtain @xmath12 and all @xmath238 to obtain @xmath298 set @xmath299",
    "we focused our experiments on an smo @xcite based implementation of aesvm and derivers .",
    "we evaluated the classification performance of aesvm using the nine datasets , described below .",
    "next , we present an evaluation of the algorithm derivers , followed by an evaluation of aesvm",
    ".      nine datasets of varied size , dimensionality and density were used to evaluate derivers and our aesvm implementation . for datasets",
    "d2 , d3 and d4 , we performed five fold cross validation .",
    "we did not perform five fold cross - validation on the other datasets , because they have been widely used in their native form with a separate training and testing set .",
    "d1 : : :    _ kdd99 intrusion detection    dataset_-    this dataset is available as a training set of 4898431 data vectors    and a testing set of 311027 data vectors , with forty one features    ( @xmath300 ) .",
    "as described in @xcite , a huge portion of    this dataset is comprised of repeated data vectors .",
    "experiments were    conducted only on the distinct data vectors .",
    "the number of distinct    training set vectors was @xmath301 and the number of    distinct testing set vectors was @xmath302 .",
    "the training    set density = 33% .",
    "d2 : : :    _ localization data for person    activity _    - this dataset has been used in a study on agent - based care for    independent living @xcite .",
    "it has @xmath303 data    vectors of seven features .",
    "it is comprised of continuous recordings    from sensors attached to five people and can be used to predict the    activity that was performed by each person at the time of data    collection . in our experiments we used this dataset to validate a    binary problem of classifying the activities lying and lying down    from the other activities . features 3 and 4 ,",
    "that gives the time    information , were not used in our experiments .",
    "hence for this dataset    @xmath304 . the dataset density = 96% .",
    "d3 : : :    _ seizure detection dataset_- this dataset has @xmath305    data vectors , three features ( @xmath306 ) and density = 100%",
    ".    it is comprised of continuous eeg recordings from rats induced with    status epilepticus and is used to evaluate algorithms that classify    seizure events from seizure - free eeg .",
    "an important characteristic of    this dataset is that it is highly unbalanced , the total number of data    vectors corresponding to seizures is minuscule compared to the    remaining data .",
    "details of the dataset can be found in @xcite , where    it is used as dataset a. d4 : : :    _ forest cover type    dataset_-    this dataset has @xmath307 data vectors and fifty four    features ( @xmath308 ) and density = 22% .",
    "it is used to    classify the forest cover of areas of 30mx30 m size into one of seven    types .",
    "we followed the method used in @xcite , where a classification    of forest cover type 2 from the other cover types was performed .",
    "d5 : : :    _ ijcnn1    dataset_-    this dataset was used in ijcnn 2001 generalization ability challenge    @xcite .",
    "the training set and testing set have 49990    ( @xmath309 ) and 91701 data vectors respectively .",
    "it has    22 features ( @xmath310 ) and training set density = 59% d6 : : :    _ adult income    dataset_-    this dataset derived from the 1994 census database , was used to    classify incomes over $ 50000 from those below it .",
    "the training set has    @xmath311 with @xmath312 and density = 11% ,    while the testing set has 16281 data vectors .",
    "the data is    pre - processed as described in @xcite .",
    "d7 : : :    _ epsilon    dataset_-    this is a dataset that was used for 2008 pascal large scale learning    challenge and in @xcite . it is comprised of 400000 data vectors that    are 100% dense with @xmath313 . since this is too large    for our experiments , we used the first 10% of the training set giving    @xmath314 .",
    "the testing set has 100000 data vectors .",
    "d8 : : :    _ mnist character recognition    dataset_-    the widely used dataset @xcite of hand written characters has a    training set of @xmath315 , @xmath316 and    density = 19% .",
    "we performed the binary classification task of    classifying the character 0 from the others .",
    "the testing set has    10000 data vectors .",
    "d9 : : :    _ w8a",
    "dataset_-    this artificial dataset used in @xcite was randomly generated and has    @xmath317 features .",
    "the training set has    @xmath318 with a density = 4% and the testing set has    14951 data vectors .",
    "we began our experiments with an evaluation of the algorithm derivers , described in section [ sec : derrp ] .",
    "the performances of the two methods fls1 and fls2 were compared first .",
    "we ran derivers on d1 , d2 , d4 and d5 with the parameters @xmath319 , and @xmath320 $ ] , first with fls1 and then fls2 . for d2",
    ", derivers was run on the entire dataset for this particular experiment , instead of performing five fold cross - validation .",
    "this was done because , d2 is a small dataset and the difference between the two first level segregation methods can be better observed when the dataset is as large as possible .",
    "the relatively small value of @xmath321 was also chosen considering the small size of d2 and d5 .",
    "to evaluate the effectiveness of fls1 and fls2 , we also ran derivers with fls1 and fls2 after randomly reordering each dataset .",
    "the results are shown in figure [ fig : resfls ] .    for datasets",
    "d1 and d5 , fls2 gave smaller representative sets in a shorter duration than fls1 .",
    "as expected , for the relatively homogeneous dataset d2 , fls1 and fls2 gave similar results , with fls2 giving slightly larger representative sets .",
    "dataset d4 was seen to have much smaller representative sets with fls1 than with fls2 .",
    "the results of derivers obtained after randomly rearranging the datasets , indicate the utility of fls2 .",
    "for all the datasets , the results of fls2 after random reordering was seen to be significantly better than the results of fls1 after random rearrangement .",
    "hence we can infer that the good results obtained with fls2 are not caused by any pre - existing order in the datasets .",
    "after d2 and d4 were randomly rearranged a sharp increase was observed in representative set sizes and computation times for derivers with fls1 .",
    "this indicates the importance of dataset homogeneity to the performance of fls1 .",
    "the results indicated for randomized experiments on derivers are the averages of five repetitions .",
    "next we investigated the impact of changes in the values of the parameters @xmath21 and @xmath42 on the performance of derivers .",
    "all combinations of @xmath322 and @xmath323 were used to compute the representative set of d1 .",
    "the computations were performed for @xmath324 and @xmath325 .",
    "the method fls2 was used for the first level segregation in derivers .",
    "the results are shown in table [ tb : rp2 ] . as expected for an algorithm of time complexity @xmath284 , the computation time",
    "was generally observed to increase for an increase in the value of @xmath42 or @xmath21 .",
    "it should be noted that our implementation of derivers was based on smo and hence @xmath326 . in some cases the computation time decreased when @xmath21 or @xmath42 increased .",
    "this is caused by a decrease in the value of @xmath327 , which is inferred from the observed decrease of the size of the representative set @xmath10 ( @xmath328 ) . a sharp decrease in @xmath10",
    "was observed when @xmath42 was increased .",
    "the impact of increasing @xmath21 on the size of the representative set was found to be less drastic .",
    "this observation indicates that deriveae selects fewer approximate extreme points when @xmath42 is larger .",
    "@xmath21&@xmath329&@xmath330&@xmath331&@xmath332&@xmath333 + @xmath334 & 10.7(27 ) & 6.1(67 ) & 5.1(131 ) & 4.5(258 ) & 4.3(338 ) + @xmath335 & 9.9(78 ) & 5.3(72 ) & 4.4(130 ) & 3.9(249 ) & 3.7(351 ) + @xmath336 & 9.8(142 ) & 5.2(83 ) & 4.3(134 ) & 3.7(242 ) & 3.5(352 ) + @xmath337 & 9.8(254 ) & 5.1(104 ) & 4.2(144 ) & 3.7(240 ) & 3.4(355 ) +    as described in section [ sec : compae ] , we compared several svm training algorithms with our implementation of aesvm .",
    "we performed a grid search with all combinations of the svm hyper - parameters @xmath338 and @xmath339 .",
    "the hyper - parameter @xmath340 is related to the hyper - parameter @xmath8 as @xmath341 .",
    "we represent the grid in terms of @xmath340 as it is used in several svm solvers such as libsvm , lasvm , cvm and bvm .",
    "furthermore , the use of @xmath340 enables the application of the same hyper - parameter grid to all datasets . to train aesvm with all the hyper - parameter combinations in the grid",
    ", the representative set has to be computed using derivers for all values of kernel hyper - parameter @xmath342 in the grid .",
    "this is because the kernel space varies when the value of @xmath342 is varied .",
    "for all the computations , the input parameters were set as @xmath343 and @xmath344 .",
    "the first level segregation in derivers was performed using fls2 .",
    "three values of the tolerance parameter @xmath43 were investigated , @xmath345 .",
    "the results of the computation for datasets d1 - d5 , are shown in the table [ tb : rp1 ] .",
    "the percentage of data vectors in the representative set was found to increase with increasing values of @xmath342 .",
    "this is intuitive , as when @xmath342 increases the distance between the data vectors in kernel space increases .",
    "with increased distances , more data vectors @xmath7 become approximate extreme points .",
    "the increase in the number of approximate extreme points with @xmath342 causes the rising trend of computation time shown in table [ tb : rp1 ] . for a decrease in the value of @xmath43",
    ", @xmath10 increases .",
    "this is because , for smaller @xmath43 fewer @xmath7 would satisfy the condition : optimized @xmath259 in checkpoint(@xmath232 ) .",
    "this results in the selection of a larger number of approximate extreme points in deriveae .     1pt@p1.4cm|@p1.4cm|@p1.6cm|@p1.4cm|@p1.6cm|@p1.6cm|@p1.6cm| + @xmath43&dataset&g = @xmath346&g = @xmath347&g = @xmath348&g = @xmath349&g = @xmath350&g = @xmath351&g = @xmath352 + & d1 & 1.5(98 ) & 1.9(104 ) & 2.4(110 ) & 3.2(119 ) & 4.3(132 ) & 5.9(148 ) & 8.1(168 ) + & d2 & 1.2(7 ) & 1.5(8 ) & 2(9 ) & 2.8(11 ) & 4.1(15 ) & 6(18 ) & 9.2(23 ) + & d3 & 0.6(37 ) & 0.6(37 ) & 0.6(36 ) & 0.6(36 ) & 0.5(37 ) & 0.6(37 ) & 0.6(39 ) + & d4 & 4.3(45 ) & 6.4(57 ) & 9.4(74 ) & 13.9(103 ) & 20.7(139 ) & 30.7(178 ) & 44.8(216 ) + & d5 & 4.5(7 ) & 8.3(9 ) & 14(11 ) & 21.8(14 ) & 31.8(18 ) & 43.7(21 ) & 54.9(22 ) + & d1 & 3(136 ) & 4(159 ) & 5.3(191 ) & 7.2(240 ) & 9.9(297 ) & 13.3(362 ) & 17.4(435 ) + & d2 & 2.8(12 ) & 3.8(18 ) & 5(27 ) & 6.8(37 ) & 9.3(44 ) & 13.5(44 ) & 19.9(82 ) + & d3 & 0.5(36 ) & 0.6(37 ) & 0.6(38 ) & 0.7(39 ) & 0.8(41 ) & 0.9(43 ) & 1.1(47 ) + & d4 & 13.5(135 ) & 18.3(211 ) & 24.9(300 ) & 34.2(400 ) & 47.7(493 ) & 63.5(513 ) & 74.4(445 ) + & d5 & 20.1(16 ) & 27.9(22 ) & 37.4(27 ) & 47.6(31 ) & 57.3(34 ) & 66(34 ) & 74(34 ) + & d1 & 7(316 ) & 9.3(425 ) & 12.2(552 ) & 15.7(726 ) & 19.6(926 ) & 24.2(1112 ) & 28.9(1235 ) + & d2 & 6.2(59 ) & 7.8(87 ) & 9.8(98 ) & 13(109 ) & 18.3(138 ) & 25.6(187 ) & 34.3(235 ) + & d3 & 0.7(39 ) & 0.8(42 ) & 0.9(45 ) & 1.1(50 ) & 1.4(59 ) & 1.7(73 ) & 2.2(100 ) + & d4 & 30.7(607 ) & 39.5(814 ) & 51.9(1051 ) & 66(1171 ) & 75.1(1044 ) & 77.8(839 ) & 78.4(649 ) + & d5 & 43.3(50 ) & 51.8(58 ) & 60.3(62 ) & 67.7(63 ) & 73.8(59 ) & 78.7(52 ) & 81.8(44 ) +    the results of applying derivers to the high - dimensional datasets d6-d9 are shown in table [ tb : rp4 ] .",
    "it was observed that @xmath353 was much larger for d6-d9 than for the other datasets .",
    "we computed the representative set with @xmath354 only , as for smaller values of @xmath43 we expect the representative set to be close to 100% of the training set .",
    "the increasing trend of the size of the representative set with increasing @xmath342 values can be observed in table [ tb : rp4 ] also .",
    "1pt@p1.6cm|@p1.6cm|@p1.6cm|@p1.6cm|@p1.6cm|@p1.6cm|@p1.4cm| + dataset&g = @xmath346&g = @xmath347&g = @xmath348&g = @xmath349&g = @xmath350&g = @xmath351&g = @xmath352 + d6 & 69.3(19 ) & 70.4(19 ) & 73.4(19 ) & 80.3(14 ) & 83.9(9 ) & 84(8 ) & 87.9(8 ) + d7 & 84.4(1077 ) & 84.6(1089 ) & 84.9(1069 ) & 85.6(1085 ) & 86.9(1079 ) & 89.9(1032 ) & 94.7(818 ) + d8 & 90(131 ) & 96.6(94 ) & 98.8(78 ) & 99.5(72 ) & 100(70 ) & 100(71 ) &",
    "100(63 ) + d9 & 60.8(34 ) & 62.9(36 ) & 67(30 ) & 70.8(21 ) & 72.7(16 ) & 75.2(14 ) & 76.7(15 ) +      to judge the accuracy and efficiency of aesvm , its classification performance was compared with the smo implementation in libsvm , ver .",
    "we chose libsvm because it is a state - of - the - art smo implementation that is routinely used in similar comparison studies . to compare the efficiency of aesvm to other popular approximate svm solvers we chose cvm , bvm , lasvm , @xmath0 , and rfeatsvm .",
    "a description of these methods is given in section [ sec : relwork ] .",
    "we chose these methods because they are widely cited , their software implementations are freely available and other studies @xcite have reported fast svm training using some of these methods .",
    "lasvm is also an efficient method for online svm training .",
    "however , since we do not investigate online svm learning in this paper , we did not test the online svm training performance of lasvm .",
    "we compared aesvm with cvm and bvm even though they are l2-svm solvers , as they has been reported to be faster alternatives to svm implementations such as libsvm .",
    "the implementation of aesvm and derivers were built upon the libsvm implementation .",
    "all methods except @xmath0 were allocated a cache of size 600 mb .",
    "the parameters for derivers were @xmath355 and @xmath344 , and the first level segregation was performed using fls2 .",
    "to reflect a typical svm training scenario , we performed a grid search with all eighty four combinations of the svm hyper - parameters @xmath338 and @xmath356 .",
    "as mentioned earlier , for datasets d2 , d3 and d4 , five fold cross - validation was performed .",
    "the results of the comparison have been split into sub - sections given below , due to the large number of svm solvers and datasets used .",
    "first we present the results of the performance comparison for d2 in figures [ fig : pares1 ] and [ fig : pares2 ] . for ease of representation ,",
    "only the results of grid points corresponding to combinations of @xmath357 and @xmath358 are shown in figures [ fig : pares1 ] and [ fig : pares2 ] .",
    "figure [ fig : pares1 ] shows the graph between training time and classification accuracy for the five algorithms .",
    "figure [ fig : pares2 ] shows the graph between the number of support vectors and classification accuracy .",
    "we present classification accuracy as the ratio of the number of correct classifications to the total number of classifications performed .",
    "since the classification time of an svm algorithm is directly proportional to the number of support vectors , we represent it in terms of the number of support vectors .",
    "it can be seen that , aesvm generally gave more accurate results for a fraction of the training time of the other algorithms , and also resulted in less classification time .",
    "the training time and classification times of aesvm increased when @xmath43 was reduced .",
    "this is expected given the inverse relation of @xmath10 to @xmath43 shown in tables [ tb : rp1 ] and [ tb : rp4 ] . the variation in accuracy with @xmath43 is not very noticeable .",
    "figures [ fig : pares1 ] and [ fig : pares2 ] indicate that aesvm gave better results than the other algorithms for svm training and classification on d2 , in terms of standard metrics . to present a more quantitative and easily interpretable comparison of the algorithms",
    ", we define the five performance metrics given below .",
    "these metrics combine the results of all runs of each algorithm into a single value , for each dataset . for these metrics",
    "we take libsvm as a baseline of comparison , as it gives the most accurate solution among the tested methods . furthermore",
    ", an important objective of these experiments is to show the similarity of the results of aesvm and libsvm . in the description given below",
    ", @xmath359 can refer to any or any approximate svm algorithm such as aesvm , cvm , lasvm etc .    1 .",
    "_ root mean squared error of classification accuracy , @xmath360 _ : the similarity of the solution of @xmath359 to libsvm , in terms of its classification accuracy , is indicated by : @xmath361 here @xmath362 and @xmath363 are the classification accuracy of libsvm and @xmath359 respectively , in the @xmath364 cross - validation fold with the @xmath365 set of hyper - parameters of grid search .",
    "expected training time speedup , @xmath366 _ : the expected speedup in training time is indicated by : @xmath367 here @xmath368 and @xmath369 are the training times of libsvm and @xmath359 respectively .",
    "overall training time speedup , @xmath370 _ : it indicates overall training time speedup for the entire grid search with cross - validation , including the time taken to compute the representative set . the total time taken by derivers to compute the representative set for all values of @xmath342",
    "is represented as @xmath371 . for methods other than aesvm , @xmath372 .",
    "@xmath373 4 .   _ expected classification time speedup , @xmath374 _ : the expected speedup in classification time is indicated by : @xmath375 here @xmath376 and @xmath377 are the number of support vectors in the solution of libsvm and @xmath359 respectively .",
    "_ overall classification time speedup , @xmath378 _ : the overall speedup in classification time is indicated by : @xmath379     aesvm @xmath324 & aesvm @xmath380 & aesvm @xmath381 & cvm & bvm & lasvm + & d1 & 0.28 & 0.16 & 0.21 & 0.44 & 0.6 & 0.12 + & d2 & 2.56 & 1.81 & 1.19 & 26.59 & 24.06 & 2.18 + & d3 & 0.16 & 0.10 & 0.05 & 0.33 & 0.39 & 55.2 + & d4 & 1.08 & 0.82 & 0.74 & 9.4 & 9.44 & @xmath382 + & d5 & 0.99 & 0.39 & 0.23 & 0.74 & 0.84 & 0.13 + & d1 & 451.5 & 145 & 41.7 & 8.9 & 28.6 & 0.8 + & d2 & 1614.7 & 289.6 & 62.8 & 0.7 & 0.8 & 0.2 + & d3 & 28012.3 & 14799.3 & 7573.8 & 60.4 & 76.8 & 0.9 + & d4 & 103.1 & 13.8 & 3.4 & 8 & 6.6 & @xmath382 + & d5 & 40.2 & 5 & 2 & 0.3 & 0.5 & 0.6 + & d1 & 92.1 & 34.2 & 9.5 & 6.2 & 21.6 & 0.8 + & d2 & 148.6 & 45.5 & 14.3 & 0.5 & 0.5 & 0.1 + & d3 & 968.5 & 800.6 & 514.4 & 23.9 & 22.8 & 0.5 + & d4 & 11.9 & 4.1 & 2.2 & 6.2 & 4.4 & @xmath382 + & d5 & 5.2 & 2.5 & 1.5 & 0.2 & 0.3 & 0.5 + & d1 & 4.8 & 3.6 & 2.8 & 1.2 & 2 & 1.1 + & d2 & 35.9 & 15.5 & 7.9 & 4.7 & 5 & 1 + & d3 & 48.7 & 25.8 & 13.4 & 0.4 & 0.6 & 0.6 + & d4 & 8.4 & 3.3 & 1.8 & 12.4 & 12.1 & @xmath382 + & d5 & 4.3 & 1.9 & 1.4 & 0.8 & 1 & 1 + & d1 & 3.8 & 3.1 & 2.5 & 1.1 & 1.9 & 1 + & d2 & 23.4 & 10.9 & 6.1 & 4.5 & 4.4 & 1 + & d3 & 32.2 & 16.1 & 9 & 0.3 & 0.5 & 0.2 + & d4 & 5.4 & 2.7 & 1.7 & 12 & 10.7 & @xmath382 + & d5 & 2.8 & 1.8 & 1.4 & 0.8 & 1 & 1 +    the results of the classification performance comparison on datasets d1-d5 , are shown in table [ tb : testing1 ] .",
    "it was observed that for all tested values of @xmath43 , aesvm resulted in large reductions in training and classification times when compared to libsvm for a very small difference in classification accuracy .",
    "most notably , for d3 the expected and overall training time speedups were of the order of @xmath334 and @xmath1 respectively , which is outstanding . comparing the results of aesvm for different @xmath43 values",
    ", we see that @xmath360 generally improves by decreasing when @xmath43 decreases , while the metrics improve by increasing when @xmath43 increases .",
    "the increase in @xmath366 and @xmath370 is of a larger order than the increase in @xmath360 when @xmath43 increases .    comparing aesvm to cvm , bvm and lasvm",
    ", we see that aesvm in general gave the least values of @xmath360 and the largest values of @xmath366 , @xmath370 , @xmath374 and @xmath378 . in a few cases lasvm gave low @xmath360 values . however , in all our experiments lasvm took longer to train than the other algorithms including libsvm .",
    "_ we could not complete the evaluation of lasvm for d4 due to its large training time , which was more than 40 hours for some hyper - parameter combinations .",
    "_ it was also found that lasvm sometimes resulted in a larger classification time than the other algorithms including libsvm .",
    "cvm and bvm generally gave high vales of @xmath360 .",
    "table [ tb : testing1 ] compares the classification accuracy of cvm , bvm , lasvm and aesvm to the exact svm solution given by libsvm .",
    "another method to compare the algorithms is in terms of the maximum classification accuracy , and the mean and standard deviation of the classification accuracies , without using libsvm as a reference point .",
    "such a comparison for datasets d1-d5 , is given in table [ tb : testing2 ] .",
    "the five algorithms under comparison were found to give similar maximum classification accuracies except for d2 and d4 , where cvm and bvm gave significantly smaller values .",
    "another interesting result is that for d3 , the mean and standard deviation of accuracy of lasvm was found to be widely different from the other algorithms .",
    "for all the tested values of @xmath43 the maximum , mean and standard deviation of the classification accuracies of aesvm were found to be similar .",
    "1pt@p1.5cm|@p1.5cm|@p1.5cm|@p1.4cm|@p1.4cm|@p1.57cm|@p1.4cm| accuracy & dataset & aesvm @xmath324 & aesvm @xmath380 & aesvm @xmath381 & cvm & bvm & lasvm & libsvm + & d1 & 93.4 & 93.8 & 93.6 & 94.1 & 94.4 & 94.3 & 93.9 + & d2 & 77.1 & 77.2 & 77.8 & 70.3 & 67.1 & 78.1 & 78.2 + & d3 & 99.9 & 99.9 & 99.9 & 99.9 & 99.9 & 99.9 & 99.9 + & d4 & 68.3 & 68.3 & 68.3 & 63.7 & 62.3 & @xmath382 & 68.2 + & d5 & 98.7 & 98.8 & 98.9 & 99 & 99.1 & 99.2 & 99 + & d1 & 92.2 , 0.7 & 92.3 , 0.8 & 92.3 , 0.8 & 92.7 , 0.8 & 92.6 , 0.9 & 92.5 , 0.8 & 92.4 , 0.8 + & d2 & 72.3 , 3.6 & 73.2 , 3.7 & 73.6 , 3.7 & 52.2 , 0.8 & 54.6 , 0.7 & 73.5 , 0.5 & 74.1 , 3.5 + & d3 & 99.8 , 0 & 99.8 , 0.1 & 99.8 , 0.1 & 99.8 , 0.2 & 99.8 , 0.2 & 69.3 , 29.9&99.8 , 0.1 + & d4 & 61.3 , 3.1 & 61 , 3.1 & 61 , 3.1 & 55.5 , 3.1 & 54.9 , 3.4 & @xmath382 & 60.6 , 3.2 + & d5 & 96 , 2.5 & 96.3 , 2.6 & 96.5 , 2.6 & 96.6 , 2.5 & 97 , 2 & 97 , 2 & 96.6 , 2.4 +    next we present the results of performance comparison of cvm , bvm , lasvm , aesvm , and libsvm on the high - dimensional datasets d6-d9 . as described in section [ sec : derrs ] , derivers was run with only @xmath324 for these datasets .",
    "the results of the performance comparison are shown in tables [ tb : testing3 ] and [ tb : testing4 ] .",
    "_ cvm was found to take longer than 40 hours to train on d6 , d7 and d8 with some hyper - parameter values and hence we could not complete its evaluation for those datasets .",
    "bvm also took longer than 40 hours to train on d7 and it was also not evaluated for d7_. aesvm consistently reported @xmath366 , @xmath370 , @xmath374 and @xmath378 values that are larger than 1 unlike the other algorithms .",
    "similar to the results in table [ tb : testing1 ] , lasvm and bvm resulted in very large @xmath360 values for some datasets .",
    "the results in table [ tb : testing4 ] are similar to table [ tb : testing2 ] , with similar maximum accuracies for all algorithms and significantly lower mean and higher standard deviation of accuracy for bvm and lasvm on some datasets .",
    "@xmath324 & cvm & bvm & lasvm + & d6 & 0.21 & - & 7.8 & 0.85 + & d7 & 1.37 & - & - & 2.37 + & d8 & 0.02 & - & 17.55 & 0 + & d9 & 0.15 & 1 & 0.89 & 27.5 + & d6 & 1.8 & - & 0.6 & 0.8 + & d7 & 1.4 & - & - & 0.9 + & d8 & 1.1 & - & 4.7 & 1 + & d9 & 1.6 & 1.4 & 17.5 & 0.6 + & d6 & 1.5 & - & 0.6 & 0.5 + & d7 & 1.2 & - & - & 0.7 + & d8 & 1.1 & - & 2.6 & 0.9 + & d9 & 1.3 & 1.2 & 16.9 & 0.5 + & d6 & 1.2 & - & 1.5 & 1 + & d7 & 1.16 & - & - & 1 + & d8 & 1 & - & 3.2 & 1 + & d9 & 1.2 & 1.8 & 4.9 & 2.3 + & d6 & 1.1 & - & 1.5 & 1 + & d7 & 1.1 & - & - & 1 + & d8 & 1 & - & 2.6 & 1 + & d9 & 1.1 & 1.9 & 5.2 & 1.1 +     1pt@p1.5cm|@p1.4cm|@p1.6cm|@p1.57cm|@p1.4cm| accuracy & dataset & aesvm @xmath324 & cvm & bvm & lasvm & libsvm + & d6 & 85.2 & - & 85.2 & 85 & 85.1 + & d7 & 88.3 & - & - & 88.4 & 88.6 + & d8 & 99.7 & - & 99.7 & 99.7 & 99.7 + & d9 & 99.3 & 99.5 & 99.5 & 99.5 & 99.5 + & d6 & 81.3 , 2.8 & - & 80.2 , 8.9 & 81.1 , 2.9 & 81.4 , 2.8 + & d7 & 85.3 , 5.7 & - & - & 85.2 , 6.2 & 85.7 , 4.8 + & d8 & 92.3 , 3.6 & - & 88.5 , 18.1 & 92.3 , 3.6 & 92.3 , 3.6 + & d9 & 98.7 , 0.8 & 98.9 , 0.8 & 98.9 , 0.8 & 85.5 , 23.9 & 98.8 , 0.8 +      @xmath0 differs from the other svm solvers in its ability to compute a solution close to the svm solution for a given number of support vectors ( @xmath384 ) .",
    "the algorithm complexity is directly proportional to the parameter @xmath384 , but with a decrease in @xmath384 the approximation becomes worse and the difference between the solutions of @xmath0 and svm increases .",
    "we used a value of @xmath385 for our experiments , as it has been reported to give good performance @xcite .",
    "@xmath0 was tested on datasets d1 , d4 , d5 , d6 , d8 and d9 , with the gaussian kernel and the same hyper - parameter grid as described earlier .",
    "the results of the grid search are presented in table [ tb : testing5 ] .",
    "the results of our experiments on aesvm ( with @xmath324 ) and libsvm are repeated in table [ tb : testing5 ] for ease of reference . the maximum , mean and standard deviation of classification accuracies",
    "are represented as max .",
    ", mean acc . , and",
    "acc . respectively",
    ".     1pt@p1.2cm|@l|@l|@l|@l|@p1.8cm|@p1.8cm|@p1.6cm| dataset & solver & @xmath360 ( x@xmath386 ) & @xmath366 & @xmath370 & @xmath374 & @xmath378 & max .",
    "( x@xmath386 ) & mean acc . ( x@xmath386 ) & std .",
    "( x@xmath386 ) + & aesvm & 0.28 & 451.5 & 92.1 & 4.8 & 3.8 & 93.4 & 92.2 & 0.7 + & @xmath0 & 0.74 & 3.7 & 0.9 & 6.8 & 6.8 & 94 & 92.7 & 0.5 + & libsvm & & & & & & 93.9 & 92.4 & 0.8 + & aesvm & 1.08 & 103.1 & 11.9 & 8.4 & 5.4 & 68.3 & 61.3 & 3.1 + & @xmath0 & 2.14 & 3.1 & 1.2 & 186.8 & 186.8 & 68.1 & 61.8 & 2.7 + & libsvm & & & & & & 68.2 & 60.6 & 3.2 + & aesvm & 0.99 & 40.2 & 5.2 & 4.3 & 2.8 & 98.7 & 96 & 2.5 + & @xmath0 & 0.26 & 0.2 & 0.1 & 5.8 & 5.8 & 99 & 96.7 & 2.4 + & libsvm & & & & & & 99 & 96.6 & 2.4 + & aesvm & 0.21 & 1.8 & 1.5 & 1.2 & 1.1 & 85.2 & 81.3 & 2.8 + & @xmath0 & 9.39 & 1.1 & 0.9 & 20 & 20 & 85.2 & 79.6 & 10.7 + & libsvm & & & & & & 85.1 & 81.4 & 2.8 + & aesvm & 0.02 & 1.1 & 1.1 & 1 & 1 & 99.7 & 92.3 & 3.6 + & @xmath0 & 54.2 & 37.6 & 23.8 & 49 & 49 & 99.9 & 55.7 & 42.3 + & libsvm & & & & & & 99.7 & 92.3 & 3.6 + & aesvm & 0.15 & 1.6 & 1.3 & 1.2 & 1.1 & 99.3 & 98.7 & 0.8 + & @xmath0 & 22.6 & 1.2 & 0.9 & 21.3 & 21.3 & 99.2 & 86.1 & 18.8 + & libsvm & & & & & & 99.5 & 98.8 & 0.8 +    @xmath0 was found to generally give higher @xmath360 values than aesvm . in particular , for the high dimensional datasets ( d6 , d8 and d9 ) , the @xmath360 values were significantly higher .",
    "the training speedup values of @xmath0 are much lower than aesvm except for d8",
    ". as expected , the classification time speedups of @xmath0 are significantly higher than aesvm .",
    "the maximum accuracies of all the algorithms were similar .",
    "however , the mean and standard deviation of accuracies of @xmath0 were very different from aesvm and libsvm for the high dimensional datasets d6 , d8 and d9 .",
    "@xcite proposed a promising method to approximate non - linear kernel svm solutions using simpler linear kernel svms .",
    "this is accomplished by first projecting the training dataset into a randomized feature space and then using any svm solver with the linear kernel on the projected dataset .",
    "we concentrated our experiments on investigating the accuracy of the solution of rfeatsvm and its similarity to the svm solution .",
    "libsvm with the linear kernel was used to compute the rfeatsvm solution on the projected datasets .",
    "we used libsvm , in spite of the availability of faster linear svm implementations , as it is an exact svm solver .",
    "hence only the performance metrics related to accuracy were used to compare the performance of aesvm , libsvm and rfeatsvm .",
    "the random fourier features method , described in algorithm 1 of @xcite , was used to project the datasets d1 , d5 , d6 and d9 into a randomized feature space of dimension e. the results of the accuracy comparison are given in table [ tb : testing6 ] .",
    "we used a smaller hyper - parameter grid of all twenty four combinations of @xmath357 and @xmath358 for our experiments .",
    "the results reported in table [ tb : testing6 ] for aesvm and libsvm were computed for this smaller grid .",
    "dataset & solver & @xmath360 ( x@xmath386 ) & max .",
    "( x@xmath386 ) & mean acc . ( x@xmath386 ) &",
    "( x@xmath386 ) & original density % & density after projection % + & aesvm & 0.24 & 93.6 & 92.2 & 0.9 & & + & rfeatsvm ( e = 100 ) & 56.18 & 37.8 & 36.1 & 1.3 & 33 & 100 + & libsvm & & 93.6 & 92.3 & 0.9 & & + & aesvm & 0.9 & 98.6 & 95.7 & 2.8 & & + & rfeatsvm ( e = 100 ) & 5.3 & 94.7 & 91.6 & 1.4 & 59 & 100 + & libsvm & & 98.9 & 96.2 & 2.7 & & + & aesvm & 0.16 & 85.1 & 81.2 & 2.9 & & + & rfeatsvm ( e = 1000 ) & 4 & 81.6 & 78 & 2.2 & 11 & 100 + & libsvm & & 85 & 81.3 & 3 & & + & aesvm & 0.15 & 99.3 & 98.6 & 0.8 & & + & rfeatsvm ( e = 1000 ) & 0.6 & 98.7 & 97.4 & 0.6 & 4 & 95.8 + & libsvm & & 99.5 & 98.8 & 0.9 & & +    we used the same number of dimensions ( e ) of the randomized feature space for d1 and d6 as in @xcite .",
    "the @xmath360 values for rfeatsvm were significantly higher than aesvm for most datasets , especially for d1 and d6 .",
    "the maximum accuracy for rfeatsvm was found to be much less than aesvm and libsvm for all datasets . the time taken to compute the randomized feature space",
    "is not reported because it was found to be negligibly small .",
    "another important observation was that the projected datasets were found to be almost 100% dense .",
    "the training time of svm solvers are typically linearly proportional to the density of the dataset and hence a highly dense dataset can take a significant training time even with fast linear svms .",
    "dense datasets also have large memory requirements .",
    "to validate our proposal of aesvm as a fast alternative to svm for all non - linear kernels , we performed a few experiments with the polynomial kernel , @xmath388 .",
    "the hyper - parameter grid composed of all twelve combinations of @xmath389 and @xmath390 was used to compute the solutions of aesvm and libsvm on the datasets d1 , d4 and d6 .",
    "the results of the computation of the representative set using derivers are shown in table [ tb : testing7 ] .",
    "the parameters for derivers were @xmath355 , @xmath344 and @xmath354 , and the first level segregation was performed using fls2 .",
    "the performance comparison of aesvm and libsvm with the polynomial kernel is shown in table [ tb : testing8 ] .",
    "like in the case of the gaussian kernel , we found that aesvm gave results similar to libsvm with the polynomial kernel , while taking shorter training and classification times .",
    "dataset&d = 2 & d = 3&d = 4 + d1 & 6.6(410 ) & 14.2(1329 ) & 22.5(3696 ) + d4 & 30.3(752 ) & 57.7(1839 ) & 76.5(2246 ) + d6 & 69(20 ) & 69.7(21 ) & 70.4(22 ) +     1pt@p1.2cm|@l|@l|@l|@l|@p1.87cm|@p1.8cm|@p1.6cm| dataset & solver & @xmath360 ( x@xmath386 ) & @xmath366 & @xmath370 & @xmath374 & @xmath378 & max .",
    "( x@xmath386 ) & mean acc . ( x@xmath386 ) &",
    "( x@xmath386 ) + & aesvm & 0.15 & 31.2 & 2 & 3.1 & 3.1 & 94 & 93.5 & 0.4 + & libsvm & & & & & & 94.1 & 93.5 & 0.4 + & aesvm & 2.04 & 3.3 & 1.5 & 2 & 1.9 & 64.3 & 60.8 & 2.5 + & libsvm & & & & & & 64.5 & 60.7 & 2.5 + & aesvm & 0.6 & 2.7 & 1.9 & 1.5 & 1.5 & 84.5 & 80.5 & 2.5 + & libsvm & & & & & & 84.6 & 81 & 2.3 +",
    "aesvm is a new problem formulation that is almost identical to , but less complex than , the svm primal problem .",
    "aesvm optimizes over only a subset of the training dataset called the representative set , and consequently , is expected to give fast convergence with most svm solvers . in contrast , the other studies mentioned in section [ sec : relwork ] are mostly algorithms that solve the svm primal or related problems .",
    "methods such as rsvm also use different problem formulations .",
    "however , they require special algorithms to solve , unlike aesvm .",
    "in fact , aesvm can be solved using many of the methods in section [ sec : relwork ] .",
    "as described in corollary 5 , there are some similarities between aesvm and the gram matrix approximation methods discussed earlier",
    ". it would be interesting to see a comparison of aesvm , with the core set based method proposed by @xcite .",
    "however , due to the lack of availability of a software implementation and of published results on l1-svm with non - linear kernels using their approach , the authors find such a comparison study beyond the scope of this paper .    _ the theoretical and experimental results presented in this paper demonstrate that the solutions of aesvm and svm are similar in terms of the resulting classification accuracy . _",
    "a summary of the experiments in section [ sec : exp ] , that compared an smo based aesvm implementation , cvm , bvm , lasvm , libsvm , @xmath0 and rfeatsvm , is presented in figures [ fig : ressummary1 ] to [ fig : ressummary4 ] . _",
    "it can be seen that aesvm typically gave the lowest approximation error ( @xmath360 ) , while giving highest overall training time speedup ( @xmath370 ) .",
    "aesvm also gave competitively high overall classification time speedup ( @xmath378 ) in comparison with the other algorithms except @xmath0_. it was found that the maximum classification accuracies of all the algorithms except rfeatsvm were similar .",
    "rfeatsvm , and in some cases cvm and bvm , gave lower maximum classification accuracies . though the results of rfeatsvm illustrated in figures [ fig : ressummary1 ] and [ fig : ressummary2 ] , were computed for a smaller hyper - parameter grid ( refer section [ sec : exprfeatsvm ] ) , we believe it indicates the overall performance of the method . apart from the excellent experimental results for aesvm with the gaussian kernel , aesvm also gave good results with the polynomial kernel as described in section [ sec : polyexp ] .",
    "the algorithm derivers was generally found to be efficient , especially for the lower dimensional datasets d1-d5 .",
    "for the high dimensional datasets d6-d9 , the representative set was almost the same size as the training dataset , resulting in small gains in training and classification time speedups for aesvm . in particular , for d8 ( mnist dataset ) the representative set computed by derivers was almost 100% of the training set . a similar result was reported for this dataset in @xcite , where a divide and conquer method was used to speed up nearest neighbor search .",
    "dataset d8 is reported to have resulted in nearly no speedup , compared to a speedup of almost one thousand for other datasets when their method was used .",
    "their analysis found that the data vectors in d8 were very distant from each other in comparison with the other datasets .",
    "this observation can explain the performance of derivers on d8 , as data vectors that are very distant from each other are expected to have large representative sets .",
    "it should be noted that irrespective of the dimensionality of the datasets , aesvm always resulted in excellent performance in terms of classification accuracy .",
    "there seems to be no relation between dataset density and the performance of derivers and aesvm .",
    "the authors will provide the software implementation of aesvm and derivers upon request .",
    "based on the presented results , we suggest the parameters @xmath324 , @xmath355 and @xmath331 for derivers . a possible extension of this paper is to apply the idea of the representative set to other svm variants and to support vector regression ( svr ) .",
    "it is straightforward to see that the theorems in section [ sec : prop ] can be extended to svr",
    ". it would be interesting to investigate aesvm solvers implemented using methods other than smo .",
    "modifications to derivers using the methods in section [ sec : relwork ] might improve its performance on high dimensional datasets .",
    "the authors will investigate improvements to derivers and the application of aesvm to the linear kernel in their future work .",
    "j.  guo , n.  takahashi , and t.  nishi . a learning algorithm for improving the classification speed of support vector machines . in _ proceedings of the 2005 european conference on circuit theory and design",
    "_ , volume  3 , pages 381  384 , 2005 .    c.  j. hsieh , k.  w. chang , c.  j. lin , s.  s. keerthi , and s.  sundararajan",
    "a dual coordinate descent method for large - scale linear svm . in _ proceedings of the 25th international conference on machine learning _ , pages 408415 , 2008 .",
    "m.  nandan , s.  s. talathi , s.  myers , w.  l. ditto , p.  p. khargonekar , and p.  r. carney .",
    "support vector machines for seizure detection in an animal model of chronic epilepsy .",
    "_ journal of neural engineering _ , 70 ( 3 ) , 2010 .",
    "e.  osuna and o.  castro .",
    "convex hull in feature space for support vector machines . in _ proceedings of the 8th ibero - american conference on ai : advances in artificial intelligence _ ,",
    "iberamia 2002 , pages 411419 , 2002 .",
    "e.  osuna , r.  freund , and f.  girosi .",
    "training support vector machines : an application to face detection . in _",
    "ieee computer society conference on computer vision and pattern recognition _ ,",
    "pages 130 136 , 1997 .",
    "d.  pavlov , d.  chudova , and p.  smyth . towards scalable",
    "support vector machines using squashing . in _ proceedings of the sixth acm sigkdd international conference on knowledge discovery and data mining _ , pages 295299 .",
    "acm , 2000 .",
    "s.  s. talathi , d.  u. hwang , m.  l. spano , j.  simonotto , m.  d. furman , s.  m. myers , j.  t. winters , w.  l. ditto , and p.  r. carney .",
    "non - parametric early seizure detection in an animal model of temporal lobe epilepsy .",
    "_ journal of neural engineering _ , 5:0 8598 , 2008 .",
    "m.  tavallaee , e.  bagheri , w.  lu , and a.  a. ghorbani . a detailed analysis of the kdd cup 99 data set . in _ proceedings of the 2009 ieee symposium computational intelligence for security and defense applications _ , pages 5358 , 2009 .            h.  yu , j.  yang , and j.  han . classifying large data sets using svms with hierarchical clusters . in",
    "_ proceedings of the ninth acm sigkdd international conference on knowledge discovery and data mining _ ,",
    "pages 306315 , 2003 .",
    "g.  x. yuan , c.  h. ho , and c.  j. lin .",
    "an improved glmnet for l1-regularized logistic regression . in _ proceedings of the 17th acm",
    "sigkdd international conference on knowledge discovery and data mining _",
    ", pages 3341 , 2011 .",
    "t.  zhang . solving large scale linear prediction problems using stochastic gradient descent algorithms . in _ proceedings of the twenty - first international conference on machine learning _ , icml 04 , 2004 ."
  ],
  "abstract_text": [
    "<S> applications of non - linear kernel support vector machines ( svms ) to large datasets is seriously hampered by its excessive training time . </S>",
    "<S> we propose a modification , called the approximate extreme points support vector machine ( aesvm ) , that is aimed at overcoming this burden . </S>",
    "<S> our approach relies on conducting the svm optimization over a carefully selected subset , called the representative set , of the training dataset . </S>",
    "<S> we present analytical results that indicate the similarity of aesvm and svm solutions . </S>",
    "<S> a linear time algorithm based on convex hulls and extreme points is used to compute the representative set in kernel space . </S>",
    "<S> extensive computational experiments on nine datasets compared aesvm to libsvm @xcite , cvm @xcite , bvm @xcite , lasvm @xcite , @xmath0 @xcite , and the random features method @xcite . </S>",
    "<S> our aesvm implementation was found to train much faster than the other methods , while its classification accuracy was similar to that of libsvm in all cases . in particular , for a seizure detection dataset , aesvm training was almost @xmath1 times faster than libsvm and lasvm and more than forty times faster than cvm and bvm . </S>",
    "<S> additionally , aesvm also gave competitively fast classification times .    </S>",
    "<S> support vector machines , convex hulls , large scale classification , non - linear kernels , extreme points </S>"
  ]
}