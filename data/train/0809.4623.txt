{
  "article_text": [
    "pocp is a matlab package aimed at solving approximately nonlinear optimal control problems ( ocps ) for which all the problem data are polynomial .",
    "consider a continuous - time system described by the differential equation @xmath0 where @xmath1 and @xmath2 are the state and input vectors , respectively .",
    "given the running cost @xmath3 and the final cost @xmath4 , the total cost to be minimized in the ocp is defined as @xmath5 where @xmath6 is the horizon length .",
    "different ocps can be formulated depending if the initial condition @xmath7 has been assigned or not .",
    "consider the following constraints :    * @xmath8 ; * @xmath9 ; * @xmath10 .",
    "an ocp with free initial condition is of the form @xmath11 to solve this problem using pocp all the data must be polynomial .",
    "more specifically , @xmath12 , @xmath13 , @xmath14 , @xmath15 , @xmath16 , and @xmath17 must be polynomial functions .",
    "when set @xmath18 contains only one point , the initial condition is fixed . from this viewpoint , the minimization problem ( [ eq : probfree ] ) can be used also to formulate ocps where the initial condition is fixed .    however , it can be interesting to consider a more general framework where the initial condition is not known exactly , but stochastically . in this case",
    ", the probability measure of the initial condition @xmath19 is given , and we consider the following ocp @xmath20 to better understand how to use this formulation , see @xcite .",
    "pocp can also deal with problems where some state variables are fixed at time @xmath21 and some of them can be chosen inside a set @xmath22 .",
    "pocp can be used for problems where the horizon @xmath6 is fixed or not .",
    "a full explanation of the theory on which pocp is based is out of scope for this user s guide .",
    "the interested reader is referred to @xcite and @xcite .",
    "the techniques implemented in pocp are based on a modeling via occupation measures associated with semidefinite programming ( sdp ) relaxations .",
    "pocp formulates a hierarchy of relaxations giving a sequence of lower bounds on the optimal value of the ocps ( [ eq : probfree ] ) and ( [ eq : probfixed ] ) .",
    "furthermore , pocp returns the moment matrices of the occupation measures used and , as a byproduct , a polynomial subsolution of the hamilton - jacobi - bellman ( hjb ) equation .",
    "pocp is a free matlab package consisting of an archive file downloadable from    .... www.laas.fr/~henrion/software/pocp ....    the installation consists of two steps :    * extract the directory ` @pocp ` from the archive file , * copy ` @pocp ` on your working directory or , using the command ` addpath ` , add the parent directory of ` @pocp ` to the matlab path .",
    "pocp is based on gloptipoly version 3.3 or higher @xcite .",
    "therefore it is assumed that this package is properly installed . to compute polynomial subsolutions of the hjb equation",
    ", the optimization modelling toolbox yalmip @xcite must be installed as well .",
    "consider the double integrator @xmath23 with state constraint @xmath24 and input constraint @xmath25 .",
    "when we consider the problem of steering in minimum time the state to the origin , an analytic solution to this problem is available @xcite . when @xmath26^t$ ] , the value of the minimum time to reach the origin is @xmath27 . in the following , we show a matlab pocp script which defines the problem and calculates a lower bound on the optimal value .",
    ".... % system variables mpol x 2 ;   % state vector of size 2 mpol u ; % scalar input    % state and input matrices a = [ 0 1 ; 0 0 ] ; b = [ 0 ; 1 ] ;    % define optimal control problem prob = pocp ( ...         ' state ' , x , ...         ' input ' , u , ...         ' dynamics ' , a*x+b*u ) ;    % set further properties prob = set(prob , ' idirac ' , x , [ 1 ; 1 ] , ... % initial condition                   ' fdirac ' , x , [ 0 ; 0 ] , ... % final condition                   ' tconstraint ' , [ x(2)>=-1 ; u>=-1 ; u<=1 ] , ... % constraints                    ' scost ' , 1 ) ;   % setting integral cost h to 1    % call to the solver [ status , cost ] = solvepocp(prob , 14 ) ; % 14 = degree of moment matrix    disp('the lower bound on the minimum time is ' ) ; disp(cost ) ; ....    we can notice that the user is required to know only four commands : ` mpol ` ( a gloptipoly command to define variables ) , ` pocp ` , ` set ` and ` solvepocp ` . when the script file is executed , we obtain the following output    .... ... the lower bound on the minimum time is      3.4988 ....    in the following section we illustrate all pocp commands together with examples of their usage .",
    "pocp consists of three commands : ` pocp ` , ` set ` , and ` solvepocp ` .      * short description : * creates a new pocp object . + * syntax and usage : * when used in the form    ....",
    "> > prob = pocp ; ....    the command ` pocp ` creates an empty pocp object ` prob ` of class ` pocp ` .",
    "the problem data can be then specified using the command ` set ` .",
    "the ` pocp ` command can also be used to create a pocp object and , at the same time , set the problem data . in this case , the syntax is    ....",
    "> > prob = pocp('property1 ' , argument1 , argument2 , ... , ' property2 ' , ... ) ....    the properties and the arguments should be specified accordingly to the syntax of the ` set ` command , see below .",
    "* short description : * sets the data of a pocp . + * syntax and usage : * specifies one or more properties of the pocp object .",
    "for example , to set a property which requires two arguments , use    .... > > prob = set(prob , ' property1 ' , argument1 , argument2 ) ; ....    to set more properties at once ,    .... > > prob = set(prob , ' property1 ' , argument1 , ... , ' property2 ' , ... ) ; ....    to help the user remember the name of the properties the following convention has been used : `` ` i ` '' refers to the initial condition , `` ` f ` '' to the final condition , `` ` t ` '' to the trajectory , and `` ` s ` '' ( for sum ) to an integral .    in the sequel we list and describe all the properties that can be specified and their arguments .      *",
    "property name : * ` state ` . + *",
    "number of arguments : * 1 . +",
    "* default value : * empty . +",
    "* description : * specifies state variables , a vector of gloptipoly class ` mpol ` .",
    "+ * example * + in this example we declare a variable ` x ` of dimension 2 and , after creating a pocp object ` prob ` , we set ` x ` as the state variable .    ....",
    "> > mpol x 2 ; > > prob = pocp ; > > prob = set(prob , ' state ' , x ) ; ....    state variables can also have different names as in the following example    ....",
    "> > mpol x1 x2 ; > > prob = pocp ; > > prob = set(prob , ' state ' , [ x1 ; x2 ] ) ; ....    for more information on declaring gloptipoly variables type    .... >",
    "> help mpol ....    or check @xcite .",
    "* property name : * ` input ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * empty .",
    "+ * description : * specifies input variables , a vector of gloptipoly class ` mpol ` .",
    "+ * example * + suppose a pocp object ` prob ` has been already defined . with the following commands a scalar ` mpol ` variable `",
    "u ` is defined and then set as the input variable .    ....",
    "> > mpol u ; > > prob = set(prob , ' input ' , u ) ; ....      * property name : * ` time ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * empty . + * description : * specifies the time variable , a scalar of gloptipoly class ` mpol ` .",
    "when the time variable is not specified but is needed internally by pocp , then it is defined automatically .",
    "+ * example * + suppose a pocp object ` prob ` has already been defined . with",
    "the following commands a scalar ` mpol ` variable ` t ` is defined and then set as the time variable .    ....",
    "> > mpol t ; > > prob = set(prob , ' time ' , t ) ; ....      * property name : * ` dynamics ` . + * number of arguments : * 1 . +",
    "* default : * empty . + * description : * specifies the system dynamics , a vector of gloptipoly class ` mpol ` of the same size as the state vector . +",
    "* example * + assume a pocp object ` prob ` has been created and the state vector ` x ` and input variable ` u ` have been set . in this example",
    "we set the linear dynamics specified by the state matrix ` a ` and input matrix ` b ` .    ....",
    "> > a = [ 0 1 ; 1 1 ] ; > > b = [ 0 ; 1 ] ; > > prob = set(prob , ' dynamics ' , a*x+b*u ) ; ....      * property name : * ` horizon ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * 0 .",
    "+ * description : * specifies the horizon length , a non - negative number . if set to 0 , the horizon is free .",
    "+ * example * + assume the pocp object ` prob ` has already been created . with the following command",
    "the horizon length is set to 1 .    ....",
    "> > prob = set(prob , ' horizon ' , 1 ) ; ....      * property name : * ` fcost ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * 0 . + * description : * specifies the final cost , a polynomial of gloptipoly class ` mpol ` whose variables are elements of the state vector .",
    "if both the final cost and the integral cost are 0 , then pocp minimizes the trace of the moment matrix of the occupation measure of the trajectory . +",
    "* example * + assume a pocp object ` prob ` has already been created and ` x(1 ) ` is one of the state variables .",
    "the following command sets the final cost to ` x(1)^2 ` .    ....",
    "> > prob = set(prob , ' fcost ' , x(1)^2 ) ; ....      * property name : * ` scost ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * 0 .",
    "+ * description : * specifies the integral cost , a polynomial of gloptipoly class ` mpol ` whose variables are the time variable and elements of the state and input vectors . for minimum time",
    "optimal control problems , set ` scost ` to ` 1 ` and set ` horizon ` to 0 .",
    "if both the final cost and the integral cost are 0 , then pocp minimizes the trace of the moment matrix of the occupation measure of the trajectory . +",
    "* example * + assume a pocp object ` prob ` has already been created and the state and input vectors are ` x ` and ` u ` , respectively . with the following command",
    "the integral cost is set to ` x*x+u*u ` .    ....",
    "> > prob = set(prob , ' scost ' , x'*x+u'*u ) ; ....      * property name : * ` testtime ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * empty . + * description : * when the system dynamics does not depend on time and the horizon is free the test function does not depend on time . in the other cases",
    "the test function depends on time .",
    "however , this default behavior can be modified by setting the property ` testtime ` . when the argument is ` true ` ( ` false ` ) the test functions will ( not ) depend on time . to restore the default behavior ,",
    "specify an empty ( ` [ ] ` ) argument .",
    "+ * example * + assume a pocp object ` prob ` has already been defined . to make the test function depend also on time , use the following command +    ....",
    "> > prob = set(prob , ' testtime ' , true ) ; ....      * property name : * ` iconstraint ` .",
    "+ * number of arguments : * 1 .",
    "+ * default : * empty . + * description : * specifices equality and inequality constraints on the initial condition , a column vector of gloptipoly class ` supcon ` .",
    "+ * example * + assume the pocp object ` prob ` has already been created and ` x(1 ) ` and ` x(2 ) ` are the state variables . with the following command ,",
    "both variables are constrained to be less than or equal to 1 .    ....",
    "> > prob = set(prob , iconstraint , [ x(1)<=1 ; x(2)<=1 ] ) ; ....    if the sum of ` x(1 ) ` and ` x(2 ) ` must be equal to 1 , the following command should be used    .... > > prob = set(prob , iconstraint , x(1)+x(2)==1 ) ; ....      * property name : * ` idirac ` .",
    "+ * number of arguments : * 2 or 3 .",
    "+ * default : * unspecified , considered as a problem unknown . + * description : * this property should be set when one or more state variables take their value at time 0 accordingly to a distribution given by the sum of dirac deltas .",
    "two or three arguments can be specified .",
    "the first argument is a column vector containing the state variables involved .",
    "the second is a matrix whose columns contain the value of the variables ( one column for each dirac delta ) .",
    "the third argument ( optional when the second argument has only one column ) is a row vector specifying the probability of each dirac delta . +",
    "* example * + assume a pocp object ` prob ` has already been created and ` x(1 ) ` and ` x(2 ) ` are the state variables .",
    "with the following command we set the initial condition to @xmath28    ....",
    "> > prob = set(prob , ' idirac ' , [ x(1 ) ; x(2 ) ] , [ 1 ; 1 ] ) ; ....    if the value at time 0 is @xmath29 with probability @xmath30 and @xmath31 with probability @xmath32 , we should use    .... > > prob = set(prob , ' idirac ' , x , [ 0 1 ; 1 1 ] ; [ 0.8 0.2 ] ) ; ....      * property name : * ` iuniform ` .",
    "+ * number of arguments : * 2 .",
    "+ * default : * unspecified , considered as a problem unknown . + * description : * this property should be set when one or more state varibles take their value at time 0 accordingly to a uniform distribution on a box .",
    "two arguments must be specified .",
    "the first argument is a column vector containing the state variables involved .",
    "the second is a matrix with two columns and the number of rows equal to the length of the first argument , specifying the intervals .",
    "+ * example * + assume a pocp object ` prob ` has already been created and ` x(1 ) ` and ` x(2 ) ` are the state variables .",
    "with the following command we set the value of ` x(1 ) ` to be uniformly distributed on the interval @xmath33 $ ] and the value of ` x(2 ) ` on the interval @xmath34 $ ]    .... > > prob = set(prob , ' iuniform ' , [ x(1 ) ; x(2 ) ] , [ -1 1 ; 0 2 ] ) ; ....    the properties ` idirac ` and ` iuniform ` can also be used in the same problem , like in the following    ....",
    "> > prob = set(prob , ' iuniform ' , x(1 ) , [ -1 1 ] ) ; > > prob = set(prob , ' idirac ' , x(2 ) , -1 ) ; ....      * property name : * ` fconstraint ` .",
    "+ * number of arguments : * 1 . +",
    "* default : * empty . + * description : * specifies equality and inequality constraints on the state variables at the end of the horizon .",
    "the usage is the same as for the property ` iconstraint ` .      *",
    "property name : * ` fdirac ` .",
    "+ * number of arguments : * 2 or 3 .",
    "+ * default : * unspecified , considered as a problem unknown . + * description : * this property should be set when one or more state variables take their value at the end of the horizon accordingly to a distribution given by the sum of dirac deltas .",
    "the usage is the same as for the property ` idirac ` .",
    "* property name : * ` tconstraint ` + * number of arguments : * 1 .",
    "+ * default : * empty . + * description : * specifies equality and inequality constraints on the system variables along the trajectory , a column vector of gloptipoly class ` supcon ` .",
    "+ * example * + assume a pocp object ` prob ` has already been created and ` x ` is the scalar state , ` u ` is the input , and ` t ` is the time variable . with the following command we set the constraints `",
    "x>=0 ` and ` x+u+t<=1 `    .... > > prob = set(prob , ' tconstraint ' , [ x>=0 ; x+u+t<=1 ] ) ; ....      * property name : * ` sconstraint `",
    ". + * number of arguments : * 1 .",
    "+ * default : * empty . +",
    "* description : * specifices constraints on the integral of some variables , a column vector of gloptipoly class ` momcon ` .",
    "+ * example * + assume a pocp object ` prob ` has already been created and ` u ` is the input variable .",
    "to enforce the integral constraint @xmath35 , use the following command    ....",
    "> > prob = set(prob , ' sconstraint ' , mom(u^2)<=1 ) ; ....      * the system variables ( state vector , input vector , and time ) must be set before they are used .",
    "constraints on the initial state can not be entered if the state vector has not been set . when more properties are specified with the same ` set ` command , the system variables should be specified first .",
    "once the system variables ( state vector , input vector , and time ) have been specified , they can not be modified any further .",
    "* the current version of the software does not check for conflicts between different kinds of constraints .",
    "e.g. , if the value at time @xmath36 for a state variable is assigned by setting the property ` idirac ` and then the same variable appears in the constraints set by ` iconstraint ` , the behavior of pocp is unpredictable .      *",
    "short description : * builds and solves an sdp relaxation of a pocp . + * syntax and usage : * when used in the form    ....",
    "> > [ status , cost , measures ] = solvepocp(prob , degree ) ; ....    or , equivalently ,    ....",
    "> > [ status , cost , measures ] = solvepocp(prob , ' mom ' , degree ) ; ....    the command ` solvepocp ` builds and solves an sdp relaxation where moments of degree up to ` degree ` are used .",
    "the input argument ` mom ` stands for moments .",
    "the output parameters have the following meaning :    * when ` status ` is strictly negative , the sdp problem is infeasible or could not be solved .",
    "otherwise , the sdp problem could be solved ; * ` cost ` is a lower bound on the objective function of the pocp if ` status ` is non - negative ; * ` measures ` is a structure containing the measures used by gloptipoly to solve the relaxation of the pocp .",
    "once the relaxation is solved , ` measures ` contains fields ` measures.initial ` , ` measures.final ` , and ` measures.trajectory ` .",
    "if the initial or final conditions have been assigned , the corresponding measures are empty ( ` [ ] ` ) . to extract the moment matrix corresponding to one of the measures , use the gloptipoly function ` mmat ` in combination with ` double ` .",
    "for example , to retrieve the moment matrix corresponding to the trajectory occupation measure , use the following command + .... > > double(mmat(measures.trajectory ) ) ; ....    it is also possible to call ` solvepocp ` by specifying the degree of the test function to be used when defining the moment problem :    .... > > [ status , cost , measures ] = solvepocp(prob , ' tf ' , degree ) ; ....    the input argument ` tf ` stands for test function . as a rule of thumb , ` degree ` should be at least twice the degree of the dynamics . increasing the value of ` degree ` improves the quality of the approximation , but it also increases the size of the sdp problem solved .",
    "the command ` solvepocp ` can also be called by specifying four output parameters :    .... > > [ status , cost , measures , vf ] = solvepocp(prob , degree ) ; ....    using this syntax , a subsolution of the hjb equation is calculated and stored in ` vf ` ( for value function ) .",
    "this approximation is a polynomial of gloptipoly class ` mpol ` .",
    "if the option ` tf ` is used , ` degree ` corresponds to the degree of the subsolution of the hjb equation .",
    "the subsolution ` vf ` is computed by using the yalmip toolbox , which must be installed properly .",
    "in this section we show how pocp can be used to design a suboptimal controller .",
    "consider as in @xcite the nonlinear system @xmath37 the optimal control problem consists in driving to the origin the initial states from the set @xmath38\\times[-1,1]$ ] by minimizing the cost functional @xmath39 with @xmath40 the terminal time @xmath6 is free .    to solve this problem and design a control law",
    ", we can define a pocp problem and use the command ` solvepocp ` with four output arguments . by setting the initial condition to be uniformly distributed on the box @xmath41 , the fourth output argument of ` solvepocp `",
    "contains a polynomial subsolution of the hjb equation which approximates the value function along all the optimal trajectories starting from @xmath41 , see @xcite .",
    "therefore , a natural choice to derive a control law consists in solving the following minimization problem @xmath42,\\ ] ] where @xmath43 represents the approximated value function .",
    "since the dynamics is affine in @xmath44 and @xmath45 is quadratic in @xmath44 , the global minimizer of ( [ eq : hjb ] ) can be calculated by using first order optimality conditions : @xmath46 in the sequel we show a matlab pocp script which calculates a polynomial approximation of the value function ` vf ` and defines the control law ` u_x ` .    .... % variable declaration mpol x 2 mpol u    % problem definition prob = pocp ( ...         ' state ' , x , ...         ' input ' , u , ...         ' dynamics ' , [ x(2)+x(1)^2-x(1)^3 ; u ] , ...         ' horizon ' , 0 , ...         ' iuniform ' , x , [ -1 1 ; -1 1 ] , ...         ' fd ' , x , [ 0;0 ] , ...         ' scost ' , x'*x+u^2/100 ) ;    % problem solved with test function up to degree 8 [ status , cost , measures , vf ] = solvepocp(prob , ' tf ' , 8) ;    % control law definition u_x = -50 * diff(vf , x)*[0 ; 1 ] ; ....    the value of ` u_x ` can be easily evaluated by using the gloptipoly commands ` assign ` and ` double ` .",
    "for example , to obtain a value for the control at @xmath47 , the following commands can be used .    ....",
    "> > assign([x ; u ] , [ 0.5 0.5 0 ] ' ) ; > > controlvalue = double(u_x ) ; ....    notice that when we assign the value of ` x ` we must assign also the value of ` u ` ( any value can be used ) . for more information on the commands ` assign ` and ` double ` , see the documentation of gloptipoly .",
    "figure [ fig : nonlinear ] shows some trajectories starting from @xmath41 and obtained by simulating the system with the calculated control law .",
    "this example is taken from ( * ? ? ?",
    "* example 3.27 ) . for",
    "the nonlinear system @xmath48 and the cost functional @xmath49 , the solution of the hjb equation is @xmath50 , which is only positive semidefinite . since the solution is polynomial , we can show with this example that the solution can be found exactly ( and only using test functions up to degree 2 ) :    .... mpol x 2 mpol u    p = pocp ( ) ; p = set(p,'state',x ) ; p = set(p,'input',u ) ; p = set(p,'dynamics',[-x(1)^3+x(1)*u ; u ] ) ; p = set(p,'scost',x(2)^2+u^2 ) ; p = set(p,'idirac',x , [ 1 ; 1 ] ) ; p = set(p,'fdirac',x , [ 0 ; 0 ] ) ; p = set(p,'tconst ' , [ x>=-1.1 ; x<=1.1 ] ) ;    [ status , cost , measures , vf ] = ...   solvepocp(p,'tf ' , 2 ) ;    disp('subsolution of hjb equation= ' ) ; vf ....    running the above script we obtain the following output :    .... scalar polynomial x(2)^2 ....",
    "to improve the numerical behavior of the sdp solver used by pocp , the variables ( state , input and time ) could be scaled .",
    "scaling can be achieved by using the gloptipoly command ` scale ` .",
    "for example , to substitute the variable ` x ` with ` 2*x ` , use the following commands    .... > > mpol x > > scale(x , 2 ) ....    scaling changes only the internal representation of the variables . from the user point of view",
    "nothing changes , and there is no need to scale the result of the optimization problem . for more information about the ` scale ` command ,",
    "see the documentation of gloptipoly .",
    "if possible , all the variables should be scaled within the interval @xmath51 $ ] .",
    "we end this guide by listing ideas for improvements and new features of pocp :    * to further extend the class of continuous - time problems considered , more flexibility on the initial and final time ( currently @xmath36 and @xmath6 ) could be permitted .",
    "if the cost @xmath52 is considered , the problem @xmath53 could be modeled with pocp , with @xmath54 an assigned probability measure on @xmath55 . setting @xmath54 to be a uniform measure on the set @xmath56,~ x_j\\in[-1,-1]~\\forall j=1,\\dots , n\\}$ ]",
    ", we could obtain a subsolution of the hjb equation which gives a good approximation of the value function on a box centered at the origin of the state space and for all the values of @xmath57 in the interval @xmath58 $ ] , see @xcite . *",
    "version 3.3 of gloptipoly can not be used to retrieve information on the dual variables of the moment problem . as a workaround to calculate a subsolution of the hjb equation , pocp currently uses gloptipoly in combination with yalmip . if gloptipoly will include this feature in some future version , pocp will not require yalmip .",
    "* gloptipoly does not support currently the assignment of a measure ( e.g. , it can not be specified that a variable is uniformly distributed on an interval ) . if gloptipoly will include this feature in some future version , the pocp code could be significantly simplified ."
  ],
  "abstract_text": [
    "<S> pocp is a new matlab package running jointly with gloptipoly 3 and , optionally , yalmip . </S>",
    "<S> it is aimed at nonlinear optimal control problems for which all the problem data are polynomial , and provides an approximation of the optimal value as well as some control policy . </S>",
    "<S> thanks to a user - friendly interface , pocp reformulates such control problems as generalized problems of moments , in turn converted by gloptipoly 3 into a hierarchy of semidefinite programming problems whose associated sequence of optimal values converges to the optimal value of the polynomial optimal control problem . in this paper </S>",
    "<S> we describe the basic features of pocp and illustrate them with some numerical examples . </S>"
  ]
}