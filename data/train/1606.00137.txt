{
  "article_text": [
    "a software product line ( spl ) aims at applying a pre - planned systematic reuse of large - grained software artifacts ( e.g. components ) to increase the software productivity and reduce the development cost @xcite . the main idea behind spl is to analyze the business domain of a family of products in order to identify the common and the variable parts between these products @xcite . in spl ,",
    "the variability is realized at different levels of abstraction ( e.g. requirement and design ) . at the requirement level , it is originated starting from the differences in users wishes , and does not carry any technical sense @xcite ( e.g. the user needs _",
    "camera _ and _ wifi _ features in the phone ) . at the design level ,",
    "the variability starts to have more details related to technical senses to form the product architectures .",
    "these technical senses are described via software product line architecture ( spla ) .",
    "such technical senses are related to which components compose the product ( e.g. _ video recorder _ , and _ photo capture _ components ) , how these components interact through their interfaces ( e.g. _ video recorder _ provides a _ video stream _",
    "interface to _ media store _ ) , and what topology forms the architectural configuration ( i.e. how components are composited and linked ) @xcite .    developing a spl from scratch is a highly costly task since this means the development of the domain software artifacts @xcite .",
    "in addition , it is common for companies to develop a set of software product variants that share common functionalities and differ in terms of other ones .",
    "these products are usually developed in an ad - hoc manner ( e.g. clone and own ) by adding or / and removing some functionalities to an existing software product to meet the requirement of a new need @xcite .",
    "nevertheless , when the number of product variants grows , managing the reuse and maintenance processes becomes a severe problem @xcite . as a consequence ,",
    "it is necessary to identify and manage variability between product variants as a spl .",
    "the goal is to reduce the cost of spl development by first starting it from existing products and then being able to manage the reuse and maintenance tasks in product variants using a spl .",
    "thus , many research contributions have been proposed to re - engineer existing product variants into a spl @xcite .",
    "nevertheless , existing works are mostly focused on recovering the variability in terms of features defined at the requirement level . despite the major importance of the spla ,",
    "there is only two works aiming at recovering the variability at the architectural level @xcite .",
    "these approaches are not fully - automated and rely on the domain knowledge which is not always available .",
    "also , they do not identify dependencies among the architectural elements . to address this limitation ,",
    "we propose in this paper an approach to automatically recover the architecture of a set of software product variants by capturing the variability at the architectural level and the dependencies between the architectural elements .",
    "we rely on formal concept analysis ( fca ) to analyze the variability . in order to validate the proposed approach , we experimented on two families of open - source product variants ; mobile media and health watcher .",
    "the evaluation shows that our approach is able to identify the architectural variability and the dependencies as well .",
    "the rest of this paper is organized as follows .",
    "section [ background ] presents the background needed to understand our proposal .",
    "then , in section [ process ] , we present the recovery process of spla .",
    "section [ identifyingarchitecturevariability ] presents the identification of architecture variability .",
    "then , section [ identifyingarchitecturedependencies ] presents the identification of dependencies among architectural - element variants .",
    "experimental evaluation of our approach is discussed in section [ experimentation ] .",
    "then , the related work is discussed in section [ relatedwork ] . finally , concluding remarks and future directions are presented in section [ conclusion ] .",
    "[ background ]      in our previous work @xcite , _ _ romantic _ _ approach has been proposed to automatically recover a component - based architecture from the source code of an existing object - oriented software .",
    "components are obtained by partitioning classes of the software . thus each class",
    "is assigned to a unique subset forming a component .",
    "_ romantic _ is based on two main models .",
    "the first concerns the object - to - component mapping model which allows to link object - oriented concepts ( e.g. package , class ) to component - based ones ( e.g. component , interface ) .",
    "a component consists of two parts ; internal and external structures . the internal structure is implemented by a set of classes that have direct links only to classes that belong to the component itself . the external structure is implemented by the set of classes that have direct links to other components classes .",
    "classes that form the external structure of a component define the component interface . fig .",
    "[ fig : mappingmodel1 ] shows the object - to - component mapping model . the second main model proposed in _",
    "romantic _ is used to evaluate the quality of recovered architectures and their architectural - element .",
    "for example , the quality - model of recovered components is based on three characteristics ; composability , autonomy and specificity .",
    "these refer respectively to the ability of the component to be composed without any modification , to the possibility to reuse the component in an autonomous way , and to the fact that the component implements a limited number of closed functionalities . based on these models , _ romantic _ defines a fitness function applied in a hierarchical clustering algorithm @xcite as well as in search - based algorithms @xcite to partition the object - oriented classes into groups , where each group represents a component . in this paper , _ romantic _",
    "is used to recover the architecture of a single object oriented software product .          formal concept analysis ( fca )",
    "is a mathematical data analysis technique developed based on lattice theory @xcite .",
    "it allows the analysis of the relationships between a set of objects described by a set of attributes . in this context",
    ", maximal groups of objects sharing the same attributes are called formal concepts .",
    "these are extracted and then hierarchically organized into a graph called a concept lattice .",
    "each formal concept consists of two parts .",
    "the first allows the representation of the objects covered by the concepts called the extent of the concept .",
    "the second allows the representation of the set of attributes shared by the objects belonging to the extent .",
    "this is called the intent of the concept .",
    "concepts can be linked through sub - concept and super - concept relationship @xcite where the lattice defines a partially ordered structure .",
    "a concept @xmath1 is a sub - concept of the super - concept @xmath2 , if the extent of the concept @xmath2 includes the extent of the concept @xmath1 and the intent of the concept @xmath1 includes the intent of the concept @xmath2 .    [",
    "cols=\"^,^,^,^,^,^,^,^ \" , ]          table 3 shows the results of component extraction from each variant independently , in terms of the number of components , for each variant of mm and hw .",
    "the results show that classes related to the same functionality are grouped into the same component .",
    "the difference in the numbers of the identified components in each variant has resulted from the fact that each variant has a different set of user s requirements . on average",
    ", a variant contains 6.25 and 7.7 main functionalities respectively for mm and hw .",
    "table 4 summarizes the results of component variants in terms of the number of components having variants ( nocv ) , the average number of variants of a component ( anvc ) , the maximum number of component variants ( mxcv ) and the minimum number of component variants ( mncs ) .",
    "the results show that there are many sets of components sharing the most of their classes .",
    "each set of components mostly provides the same functionality .",
    "thus , they represent variants of the same architectural component .",
    "table [ comvar ] presents an instance of 6 component variants identified from hw , where _ x _ means that the corresponding class is a member in the variant . by analyzing these variants ,",
    "it is clear that these components represent the same architectural component .",
    "in addition to that , we noticed that there are some component variants having the same set of classes in multiple product variants .",
    "the architecture configurations are identified based on the above results .",
    "table 6 shows the configuration of mm variants , where _ x _ means that the component is a part of the product variants .",
    "the results show that the products are similar in their architectural configurations and differ considering other ones .",
    "the reason behind the similarity and the difference is the fact that these products are common in some of their user s requirements and variable in some others .",
    "these architecture configurations are used as a formal context to extract the concept lattice .",
    "we use the concept explorer tool to generate the concept lattice . due to limited space",
    ", we only give the concept lattice of hw ( c.f .",
    "[ fig : hwlattice ] ) . in table 7 , the numbers of core ( mandatory ) and optional components are given for mm and hw .",
    "the results show that there are some components that represent the core architecture , while some others represent delta ( optional ) components .",
    "the results of the identification of optional - component dependencies are given in table 8 ( _ com 5 _ is excluded since it is a mandatory component ) .",
    "for conciseness , the detailed dependencies among components are only shown for mm only .",
    "the dependencies are represented between all pairs of components in mm ( where r= require , e= exclude , o= or , rb = required by , tr = transitive require , trb = transitive require by , and a = and ) .",
    "table 9 shows a summary of mm and hw dependencies between all pairs of components .",
    "this includes the number of direct require constrains ( nrc ) , the number of exclude ones ( ne ) , the number of and groups ( noa ) , and the number of or groups ( no ) .",
    "alternative constrains is represented as exclude ones .",
    "the results show that there are dependencies among components that help the architect to avoid creating invalid configuration .",
    "for instance , a design decision of and components indicates that these components depend on each other , thus , they should be selected all together .    to the best our knowledge",
    ", there is no architecture description language supporting all kinds of the identified variability .",
    "the existing languages are mainly focused on modeling component variants , links and interfaces , while they do not support dependencies among components such as and - group , or - group , and require .",
    "thus , on the first hand , we use some notation presented in @xcite to represent the concept of component variants and links variability . on the other hand , we propose some notation inspired from feature modeling languages to model the dependencies among components . for the purpose of understandability , we document the resulting components by assigning a name based on the most frequent tokens in their classes names .",
    "figure [ mmmodel ] shows the architectural variability model identified for mm variants , where the large boxes denote to design decisions ( constraints ) .",
    "for instance , core architecture refers to components that should be selected to create any concrete product architecture . in mm , there is one core components manipulating the base controller of the product .",
    "this component has two variants . a group of _ multi media stream _ , _ video screen controller _ , and _ multi screen music _ components represents an and design decision .",
    "the identification of component dependencies is based on the occurrence of components .",
    "e.g. , if two components never selected to be included in a concrete product architecture , we consider that they hold an exclude relation .",
    "however , this method could provide correct or incorrect dependencies . to evaluate the accuracy of this method",
    ", we manually validate the identified dependencies .",
    "this is based on the functionalities provided by the components .",
    "for instance , we check if the component functionality requires the functionality of the required component and so on .",
    "the results show that 79% of the required dependencies are correct . as an example of a correct relation",
    "is that _ sms controller _ requires _ invalid exception _ as it performs an input / output operations . on the other hand",
    ", it seems that _ image util _ does not require _ image album vector stream_. also , 63% of the exclude constrains are correct . for and and or dependencies , we find that 88% of and groups are correct , while 42% of or groups",
    "are correct .",
    "thus , the precision of identifying dependencies is 68% in average .      in our case studies",
    ", mm is the only case study that has an available architecture model containing some variability information . in @xcite",
    ", the authors presented the aspect oriented architecture for mm variants .",
    "this contains information about which products had added components , as well as in which product a component implementation was changed ( i.e. component variants ) .",
    "we manually compare both models to validate the resulting model .",
    "[ vallidation ] shows the comparison results in terms of the total number of components in the architecture model ( tnoc ) , the number of components having variants ( nchv ) , the number of mapped components in the other model ( nc ) , the number of unmapped components in the other model ( numc ) , the number of optional components ( noc ) and the number of mandatory ones ( nom ) .",
    "the results show that there are some variation between the results of our approach and the pre - existed model .",
    "the reason behind this variation is the idea of compositional components .",
    "for instance , our approach identifies only one core component compared to 4 core components in the other model .",
    "our approach grouped all classes related to the controller components together in one core components .",
    "on the other hand , the other model divided the controller component into _ abstract controller _ , _ album data _ , _ media controller _ , and _ photo view controller _ components .",
    "in addition , the component related to handling exceptions is not mentioned in the pre - existed model at all .",
    "[ relatedwork ] in this section , we discuss the contributions that have been proposed in two research directions ; recovering the software architecture of a set of product variants and variability management .    in @xcite ,",
    "an approach aiming at recovering spla was presented .",
    "it identifies component variants based on the detection of cloned code among the products .",
    "however , the limitation of this approach is that it is a semi - automated , while our approach is fully automated .",
    "also , it does not identify dependencies among the components . in @xcite ,",
    "the authors presented an approach to reconstruct home service robots ( hsr ) products into a spl .",
    "although this approach identifies some architectural variability , but it has some limitation compared to our approach . for instance , it is specialized on the domain of hsr as the authors classified , at earlier step , the architectural units based on three categories related to hsr . these categories guide the identification process .",
    "in addition , the use of feature modeling language ( hierarchical trees ) to realize the identified variability is not efficient as it is not able to represent the configuration of architectures .",
    "domain knowledge plays the main role to identify the architecture of each single product and the dependencies among components . in some cases",
    ", domain knowledge is not always available .",
    "the authors in @xcite proposed an approach to reverse engineering architectural feature model .",
    "this is based on the software architect s knowledge , the architecture dependencies , and the feature model that is extracted based on a reverse engineering approach presented in @xcite .",
    "the idea , in @xcite , is to take the software architect s variability point of view in the extracted feature model ( i.e. still at the requirement level ) ; this is why it is named architecture feature model .",
    "however , the major limitations of this approach are firstly that the software architect is not available in most cases of legacy software , and secondly that the architecture dependencies are generally missing as well . in @xcite ,",
    "the authors proposed an approach to extract the feature model .",
    "the input of the extraction process is feature names , feature descriptions and dependencies among features .",
    "based on this information , they recover ontological constraints ( e.g. feature groups ) and cross tree constrains . a strong assumption behind this approach",
    "is that feature names , feature descriptions , and dependencies among features are available . in @xcite",
    ", the authors use fca to generate a feature model .",
    "the input of their approach is a set of feature configurations .",
    "however , the extraction of the feature model elements is based on np - hard problems ( e.g. set cover to identify or groups ) .",
    "furthermore , architecture variability is not taken into account in this approach . in @xcite ,",
    "an approach was presented to visually analyze the distribution of variability and commonality among the source code of product variants .",
    "the analysis includes multi - level of abstractions ( e.g. line of code , method , class , etc . ) .",
    "this aims to facilitate the interpretation of variability distribution , to support identifying reusable entities . in @xcite ,",
    "the authors presented an approach to extract reusable software components from a set of similar software products .",
    "this is based on identifying similarity between components identified independently from each software .",
    "this approach can be related only to the first step of our approach .",
    "in spla , the variability is mainly represented in terms of components and configurations . in the case of migrating product variants to a spl , identifying the architecture variability among the product variants is necessary to facilitate the software architect s tasks .",
    "thus , in this paper , we proposed an approach to recover the architecture variability of a set of product variants .",
    "the recovered variability includes mandatory and optional components , the dependencies among components ( e.g. require , etc . ) , the variability of component - links , and component variants .",
    "we rely on fca to analyze the variability .",
    "then , we propose two heuristics .",
    "the former is to identify the architecture variability .",
    "the latter is to identify the architecture dependencies .",
    "the proposed approach is validated through two sets of product variants derived from mobile media and health watcher .",
    "the results show that our approach is able to identify the architectural variability and the dependencies as well .",
    "there are three aspects to be considered regarding the hypothesis of our approach .",
    "firstly , we identify component variants based on the similarity between the name of classes composing the components , i.e. , classes that have the same name should have the same implementation . while in some situations",
    ", components may have very similar set of classes , but they are completely unrelated . secondly , dependencies among components are identified based on component occurrences in the product architectures .",
    "thus , the identified dependencies maybe correct or incorrect . finally , the input of our approach is the components independently identified form each product variants using _ romantic _ approach .",
    "the accuracy of the obtained variability depends on the accuracy of _ romantic _ approach .",
    "our future research will focus on migrating product variants into component based software product line , the mapping between the requirements variability ( i.e. features ) and the architectures variability , and mapping between components variability and component - links variability .",
    "acher , m. , cleve , a. , collet , p. , merle , p. , duchien , l. , lahire , p. : reverse engineering architectural feature models . in : software architecture .",
    "lncs , vol . 6903 , pp .",
    "springer , heidelberg ( 2011 )      kang , k.c . , kim , m. , lee , j. , kim , b. : feature - oriented re - engineering of legacy systems into product line assets - a case study . in : software product lines .",
    "lncs , vol . 3714 , pp .",
    "springer , heidelberg ( 2005 )        chardigny , s. , seriai , a.d . ,",
    "oussalah , m. , tamzalit , d. : search - based extraction of component - based architecture from object - oriented systems . in : 2nd ecsa .",
    "lncs , vol . 5292 , pp .",
    "springer , heidelberg ( 2008 )            figueiredo , e. and cacho , n. and santanna , c. and monteiro , m. and kulesza , u. and garcia , a. and soares , s. and ferrari , f. and khan , s. , et al . : evolving software product lines with aspects . in : proc . of 30th icse , pp . 261270 .",
    "( 2008 )        shatnawi , a. , seriai , a.d . :",
    "mining reusable software components from objectoriented source code of a set of similar software . in :",
    "ieee 14th inter . conf . on information reuse and integration ( iri ) , pp . 193200 ."
  ],
  "abstract_text": [
    "<S> a software product line ( spl ) aims at applying a pre - planned systematic reuse of large - grained software artifacts to increase the software productivity and reduce the development cost . </S>",
    "<S> the idea of spl is to analyze the business domain of a family of products to identify the common and the variable parts between the products . </S>",
    "<S> however , it is common for companies to develop , in an ad - hoc manner ( e.g. clone and own ) , a set of products that share common functionalities and differ in terms of others . </S>",
    "<S> thus , many recent research contributions are proposed to re - engineer existing product variants to a spl </S>",
    "<S> . nevertheless , these contributions are mostly focused on managing the variability at the requirement level . </S>",
    "<S> very few contributions address the variability at the architectural level despite its major importance . starting from this observation , we propose , in this paper , an approach to reverse engineer the architecture of a set of product variants . </S>",
    "<S> our goal is to identify the variability and dependencies among architectural - element variants at the architectural level . </S>",
    "<S> our work relies on formal concept analysis ( fca ) to analyze the variability . to validate the proposed approach , we experimented on two families of open - source product variants ; mobile media and health watcher . </S>",
    "<S> the results show that our approach is able to identify the architectural variability and the dependencies .    </S>",
    "<S> line architecture@xmath0 architecture variability@xmath0 architecture recovery@xmath0 product variants@xmath0 reverse engineering@xmath0 source code@xmath0 object - oriented . </S>"
  ]
}