{
  "article_text": [
    "in knowledge representation , rules play a prominent role . default rules of the form _ if a then normally b _ are being investigated in nonmonotonic reasoning , and various semantical approaches have been proposed for such rules . since it is not possible to assign a simple boolean truth value to such default rules , a semantical approach is to define when a rational agent accepts such a rule .",
    "we could say that an agent accepts the rule _ birds normally fly _ if she considers a world with a flying bird to be less surprising than a world with a nonflying bird . at the same time",
    ", the agent can also accept the rule _ penguin birds normally do not fly _ ; this is the case if she considers a world with a nonflying penguin bird to be less surprising than a world with a flying penguin bird .",
    "the informal notions just used can be made precise by formalizing the underlying concepts like default rules , epistemic state of an agent , and the acceptance relation between epistemic states and default rules . in the following",
    ", we deal with qualitative default rules and a corresponding semantics modelling the epistemic state of an agent . while a full epistemic state could compare possible worlds according to their possibility , their probability , their degree of plausibility , etc .",
    "@xcite ) , we will use ordinal conditional functions ( ocfs ) , which are also called ranking functions @xcite .",
    "to each possible world @xmath0 , an ocf @xmath1 assigns a natural number @xmath2 indicating its degree of surprise : the higher @xmath2 , the greater is the surprise for observing @xmath0 .    in @xcite a criterion when a ranking function respects the conditional structure of a set @xmath3of conditionals is defined , leading to the notion of c - representation for @xmath3 , and it is argued that ranking functions defined by c - representations are of particular interest for model - based inference . in @xcite a system that computes a c - representation for any such @xmath3  that is consistent",
    "is described , but this c - representation may not be minimal .",
    "an algorithm for computing a minimal ranking function is given in @xcite , but this algorithm fails to find all minimal ranking functions if there is more than one minimal one . in @xcite",
    "an extension of that algorithm being able to compute all minimal c - representations for @xmath3  is presented .",
    "the algorithm developed in @xcite uses a non - declarative approach and is implemented in an imperative programming language . while the problem of specifying all c - representations for @xmath3  is formalized as an abstract , problem - oriented constraint satisfaction problem @xmath4  in @xcite , no solving method is given there .    in this paper",
    ", we present a high - level , declarative approach using constraint logic programming techniques for solving the constraint satisfaction problem @xmath4  for any consistent @xmath3 . in particular , the approach developed here supports the generation of all minimal solutions ; these minimal solutions are of special interest as they provide a preferred basis for model - based inference from @xmath3 .",
    "the rest of this paper is organized as follows : after recalling the formal background of conditional logics as it is given in @xcite and as far as it is needed here ( section  [ sec_background ] ) , we elaborate the birds - penguins scenario sketched above as an illustration for a conditional knowledge base and its semantics in section  [ sec_example ] . the definition of the constraint satisfaction problem @xmath4   and its solution set denoting all c - representations for @xmath3  is given in sec .",
    "[ sec_c_representations ] . in section  [ sec_clp_approach ] , a declarative , high - level clp program solving @xmath4",
    "is developed , observing the objective of being as close as possible to @xmath4 , and its realization in prolog is described in detail ; in section  [ sec_example_applications_and_first_evaluation ] , it is evaluated with respect to a series of some first example applications . section  [ sec_conclusions ] concludes the paper and points out further work .",
    "we start with a propositional language @xmath5 , generated by a finite set @xmath6  of atoms @xmath7 .",
    "the formulas of @xmath5 will be denoted by uppercase roman letters @xmath8 .",
    "for conciseness of notation , we will omit the logical _ and_-connective , writing @xmath9 instead of @xmath10 , and overlining formulas will indicate negation , i.e.  @xmath11 means @xmath12 .",
    "let @xmath13 denote the set of possible worlds over @xmath5 ; @xmath13 will be taken here simply as the set of all propositional interpretations over @xmath5 and can be identified with the set of all complete conjunctions over @xmath6 . for @xmath14",
    ", @xmath15 means that the propositional formula @xmath16 holds in the possible world @xmath0 .    by introducing a new binary operator @xmath17",
    ", we obtain the set @xmath18 of _ conditionals _ over @xmath5 .",
    "@xmath19 formalizes `` _ _ if @xmath20 then ( normally ) @xmath21 _ _ '' and establishes a plausible , probable , possible etc connection between the _ antecedent _ @xmath20 and the _ consequence _ @xmath21 . here",
    ", conditionals are supposed not to be nested , that is , antecedent and consequent of a conditional will be propositional formulas .",
    "a conditional @xmath22 is an object of a three - valued nature , partitioning the set of worlds @xmath13 in three parts : those worlds satisfying @xmath9 , thus _ verifying _ the conditional , those worlds satisfying @xmath23 , thus _ falsifying _ the conditional , and those worlds not fulfilling the premise @xmath20 and so which the conditional may not be applied to at all .",
    "this allows us to represent @xmath22 as a _ generalized indicator function _ going back to @xcite ( where @xmath24 stands for _ unknown _ or _ indeterminate _ ) : @xmath25 to give appropriate semantics to conditionals , they are usually considered within richer structures such as _ epistemic states_. besides certain ( logical ) knowledge , epistemic states also allow the representation of preferences , beliefs , assumptions of an intelligent agent .",
    "basically , an epistemic state allows one to compare formulas or worlds with respect to plausibility , possibility , necessity , probability , etc .",
    "well - known qualitative , ordinal approaches to represent epistemic states are spohn s _ ordinal conditional functions , ocfs _ , ( also called _ ranking functions _ ) @xcite , and _ possibility distributions _",
    "@xcite , assigning degrees of plausibility , or of possibility , respectively , to formulas and possible worlds . in such qualitative frameworks ,",
    "a conditional @xmath22 is valid ( or _ accepted _ ) , if its confirmation , @xmath9 , is more plausible , possible , etc .  than its refutation , @xmath23 ; a suitable degree of acceptance is calculated from the degrees associated with @xmath9 and @xmath23 .    in this paper , we consider spohn s ocfs @xcite .",
    "an ocf is a function @xmath26 expressing degrees of plausibility of propositional formulas where a higher degree denotes `` less plausible '' or `` more suprising '' .",
    "at least one world must be regarded as being normal ; therefore , @xmath27 for at least one @xmath28 .",
    "each such ranking function can be taken as the representation of a full epistemic state of an agent .",
    "each such @xmath29 uniquely extends to a function ( also denoted by  @xmath29 ) mapping sentences and rules to @xmath30 and being defined by @xmath31 for sentences @xmath16 and by @xmath32 for conditionals @xmath33 .",
    "note that @xmath34 since any @xmath0 satisfying @xmath9 also satisfies @xmath20 and therefore @xmath35 .",
    "the belief of an agent being in epistemic state @xmath36 with respect to a default rule @xmath37 is determined by the satisfaction relation @xmath38 defined by : @xmath39 thus , @xmath37 is believed in @xmath29 iff the rank of @xmath40 ( verifying the conditional ) is strictly smaller than the rank of @xmath41 ( falsifying the conditional ) .",
    "we say that @xmath29 _ accepts _ the conditional @xmath37 iff @xmath42 .",
    "in order to illustrate the concepts presented in the previous section we will use a scenario involving a set of some default rules representing common - sense knowledge .",
    "[ example : penguins_1 ] suppose we have the propositional atoms @xmath43 - _ flying _ , @xmath44 - _ birds _ , @xmath45 - _ penguins _ , @xmath46 - _ winged _ animals ,",
    "@xmath47 - _ kiwis_. let the set @xmath48 consist of the following conditionals : +    [ cols= \" < , < , < , < \" , ]      + where worlds are represented as complete conjunctions of literals over @xmath6 , using the representation described above .    using these predicates , in the following subsections we will present the complete source code of the constraint logic program ` genocf`solving @xmath4 .",
    "the particular program code given here uses the sicstus prolog system and its clp(fd ) library implementing constraint logic programming over finite domains @xcite .",
    "the main predicate expecting a knowledge base of conditionals and yielding a vector of @xmath49 values as specified by ( [ eq_kappa_accepts_r_with_kappaiminus ] ) is presented in fig .",
    "[ fig_main_kappa ] .",
    "kappa(kb , k ) : - consult(kb ) , indices(is ) , length(is , n ) , length(k , n ) , domain(k , 0 , n ) , constrain_k(is , k ) , labeling ( [ ] , k ) .",
    "after reading in the knowledge base and getting the list of indices , a list of free constraint variables , one for each conditional , is generated .",
    "in the two subsequent subgoals , the constraints corresponding to the formulas ( [ eq_kappaiminus_lower_upper_bound ] ) and ( [ eq_kappa_accepts_r_with_kappaiminus ] ) are generated , constraining the elements of accordingly .",
    "finally , yields a list of @xmath49 values . upon backtracking",
    ", this will enumerate all possible solutions with an upper bound of @xmath50 as in ( [ eq_kappaiminus_lower_upper_bound ] ) for each @xmath49 .",
    "later on , we will demonstrate how to modify in order to take minimality into account ( sec .",
    "[ sec_generation_of_minimal_solutions ] ) .    how the subgoal in generates a constraint for each index @xmath51 according to ( [ eq_kappa_accepts_r_with_kappaiminus ] ) is defined in fig .",
    "[ fig_constrain_k ] .",
    "constrain_k ( [ ] , _ ) .",
    "constrain_k([i|is],k ) : - constrain_ki(i , k ) , constrain_k(is , k ) .",
    "constrain_ki(i , k ) : - verifying_worlds(i , vworlds ) , falsifying_worlds(i , fworlds ) , list_of_sums(i , k , vworlds , vs ) , list_of_sums(i , k , fworlds , fs ) , minimum(vmin , vs ) , minimum(fmin , fs ) , element(i , k , ki ) , ki # > vmin - fmin .",
    "given an index , determines all worlds verifying and falsifying the -th conditional ; over these two sets of worlds the two @xmath52 expressions in ( [ eq_kappa_accepts_r_with_kappaiminus ] ) are defined .",
    "two lists and of sums corresponding exactly to the first and the second sum , repectively , in ( [ eq_kappa_accepts_r_with_kappaiminus ] ) are generated ( how this is done is defined in fig .  [ fig_list_of_sums ] and will be explained below ) . with the constraint variables and denoting the minimum of these two lists , the constraint    ` ki # > vmin - fmin `    given in the last line of fig .",
    "[ fig_constrain_k ] reflects precisely the restriction on @xmath49 given by ( [ eq_kappa_accepts_r_with_kappaiminus ] ) .    for an index , a kappa vector , and a list of worlds , the goal ( cf .  fig .",
    "[ fig_list_of_sums ] ) yields a list of sums such that for each world in , there is a sum in that is generated by where is the list of indices @xmath53 . in the goal , corresponds exactly to the respective sum expression in ( [ eq_kappa_accepts_r_with_kappaiminus ] ) , i.e. , it is the sum of all such that and falsifies the -th conditional",
    ".    list_of_sums ( _ , _ , [ ] , [ ] ) .",
    "list_of_sums(i , k , [ w|ws ] , [ s|ss ] ) : - indices(js ) , sum_kappa_j(js , i , k , w , s ) , list_of_sums(i , k , ws , ss ) .    sum_kappa_j ( [ ] , _ , _ , _ , 0 ) . sum_kappa_j([j|js ] , i , k , w , s ) : - sum_kappa_j(js , i , k , w , s1 ) , element(j , k , kj ) , ( ( j = i , falsify(j , w ) ) -",
    "# = s1 + kj ; s # = s1 ) .",
    "[ ex_kb_birds_clp_output ]",
    "suppose that is a file containing the conditionals of the knowledge base @xmath54 given in ex .",
    "[ eq_multiple_minimal_solutions ] .",
    "then the first five solutions generated by the program given in figures [ fig_main_kappa ]  [ fig_list_of_sums ] are :    ....       | ? - kappa('kb_birds.pl ' , k ) .",
    "k = [ 1,0,1 ] ? ;       k = [ 1,0,2 ] ? ;       k = [ 1,0,3 ] ? ;       k = [ 1,1,0 ] ? ;       k = [ 1,1,1 ] ?",
    "....    note that the first and the fourth solution are the minimal solutions .",
    "[ example : penguins_1_clp_output ] if is a file containing the conditionals of the knowledge base @xmath55 given in ex .",
    "[ example : penguins_1 ] , the first six solutions generated by ` kappa/2 ` are :    ....       | ? - kappa('kb_penguins.pl ' , k ) .",
    "k = [ 1,2,2,1,1 ] ? ;       k = [ 1,2,2,1,2 ] ? ;       k = [ 1,2,2,1,3 ] ? ;       k = [ 1,2,2,1,4 ] ? ;       k = [ 1,2,2,1,5 ] ? ;       k = [ 1,2,2,2,1 ]",
    "?   ....      the enumeration predicate of sicstus prolog allows for an option that minimizes the value of a cost variable .",
    "since we are aiming at minimizing the sum of all @xmath49 , the constraint introduces such a cost variable .",
    "thus , exploiting the sicstus prolog minimization feature , we can easily modify to generate a minimal solution : we just have to replace the last subgoal in fig .",
    "[ fig_main_kappa ] by the two subgoals :    ....     sum(k , # = , s ) ,                % introduce constraint variable s                                   %     for sum of kappa_i     minimize(labeling([],k ) , s ) .",
    "% generate single minimal solution ....    with this modification , we obtain a predicate that returns a single minimal solution ( and fails on backtracking ) . hence calling similar as in ex .",
    "[ ex_kb_birds_clp_output ] yields the minimal solution .    however , as pointed out in sec .",
    "[ sec_c_representations ] , there are good reasons for considering not just a single minimal solution , but all minimal solutions .",
    "we can achieve the computation of all minimal solutions by another slight modification of .",
    "this time , the enumeration subgoal in fig .",
    "[ fig_main_kappa ] is preceded by two new subgoals as in in fig .",
    "[ fig_main_kappa_min_all ] .",
    "kappa_min_all(kb , k ) : - consult(kb ) , indices(is ) , length(is , n ) , length(k , n ) , domain(k , 0 , n ) , constrain_k(is , k ) , sum(k , # = , s ) , min_sum_kappas(k , s ) , labeling ( [ ] , k ) .",
    "min_sum_kappas(k , min ) : - once((labeling([up],[min ] ) , labeling([],k ) ) ) .",
    "the first new subgoal introduces a constraint variable just as in . in the subgoal",
    ", this variable is constrained to the sum of a minimal solution as determined by .",
    "these two new subgoals ensure that in the generation caused by the final subgoal , exactly all minimal solutions are enumerated .",
    "[ ex_kb_birds_clp_output_all_min ] continuing example  [ ex_kb_birds_clp_output ] , calling    ....       | ? - kappa_min_all('kb_birds.pl ' , k ) .",
    "k = [ 1,0,1 ] ? ;       k = [ 1,1,0 ] ? ;       no ....    yields the two minimal solutions for @xmath54 .",
    "[ example : penguins_1_clp_output_all_min ] for the situation in ex .",
    "[ example : penguins_1_clp_output ] , ` kappa_min_all/2 ` reveals that there is a unique minimal solution :    ....       | ? - kappa_min_all('kb_penguins.pl ' , k ) .",
    "k = [ 1,2,2,1,1 ] ? ;       no ....    determining the ocf @xmath1 induced by the vector @xmath56 according to ( [ eq_conditional_indifference_no_kappaplus ] ) yields the ranking function given in fig .",
    "[ figure_kappa_after_initialzation ] .",
    "although the objective in developing ` genocf `  was on being as close as possible to the abstract formulation of the constraint satisfaction problem @xmath4 , we will present the results of some first example applications we have carried out .    for @xmath57 , we generated synthetic knowledge bases according to the following schema : using the variables @xmath58 , ` kb_synth < n>_c<2n\\!\\!-\\!\\!1>.pl ` contains the @xmath59 conditionals given by : : @xmath60 for instance , ` kb_synth4_c7.pl ` uses the five variables @xmath61 and contains the seven conditionals : @xmath62 the basic idea underlying the construction of these synthetic knowledge bases is to establish a kind of subclass relationship between @xmath63 and @xmath64 for each @xmath65 on the one hand , and to state that every @xmath63 is exceptional to @xmath64 with respect to its behaviour regarding @xmath43 , again for each @xmath65 .",
    "this sequence of pairwise exceptional elements will force any minimal solution of @xmath66 to have at least one @xmath49 value of size greater or equal to @xmath50 .    from `",
    "kb_synth<\\ensuremath{n}>_c < m>.pl ` , the knowledge bases ` kb_synth<\\ensuremath{n}>_c",
    "< m\\!\\!-\\!\\!j>.pl ` are generated for @xmath67 by removing the last @xmath68 conditionals .",
    "for instance , ` kb_synth4_c5.pl ` is obtained from ` kb_synth4_c7.pl ` by removing the two conditionals @xmath69 , @xmath70 .",
    "figure  [ fig_sicstus_results ] shows the time needed by ` genocf `   for computing all minimal solutions for various knowledge bases . the execution time is given in seconds where the value 0 stands for any value less than 0.5 seconds .",
    "measurements were taken for the following environment : sicstus 4.0.8 ( x86-linux - glibc2.3 ) , core  2  duo e6850 3.00ghz .",
    "while the number of variables determines the set of possible worlds , the number of conditionals induces the number of contraints .",
    "the values in the table in fig .",
    "[ fig_sicstus_results ] give some indication on the influence of both values , the number of variables and the number of conditionals in a knowledge base .",
    "for instance , comparing the knowledge base ` kb_synth7_c10.pl ` , having 8 variables and 10 conditionals , to the knowledge base ` kb_synth8_c10.pl ` , having 9 variables and also 10 conditionals , we see an increase of the computation time by a factor 2.3 . increasing the number of conditionals , leads to no time increase from ` kb_synth7_c10.pl ` to ` kb_synth7_c11.pl ` , and to a time increase factor of about 1.6 when moving from ` kb_synth8_c10.pl ` to ` kb_synth8_c11.pl ` , while for moving from",
    "` kb_synth8_c10.pl ` to ` kb_synth9_c10.pl ` and ` kb_synth10_c10.pl ` , we get time increase factors of 3.3 and 11.0 , respectively .",
    "of course , these knowledge bases are by no means representative , and further evaluation is needed .",
    "in particular , investigating the complexity depending on the number of variables and conditionals and determining an upper bound for worst - case complexity has still to be done .",
    "furthermore , while the code for ` genocf `  given above uses sicstus prolog , we also have a variant of ` genocf`for the swi prolog system @xcite . in our further investigations ,",
    "we want to evaluate ` genocf`also using swi prolog , to elaborate the changes required and the options provided when moving between sicstus and swi prolog , and to study whether there are any significant differences in execution that might depend on the two different prolog systems and their options .",
    "while for a set of probabilistic conditionals @xmath71}}}}$ ] the principle of maximum entropy yields a unique model , for a set @xmath3  of qualitative default rules @xmath72 there may be several minimal ranking functions . in this paper",
    ", we developed a clp approach for solving @xmath4 , realized in the prolog program ` genocf ` .",
    "the solutions of the constraint satisfaction problem @xmath4  are vectors of natural numbers @xmath73 that uniquely determine an ocf @xmath74 accepting all conditionals in @xmath3 .",
    "the program ` genocf `  is also able to generate exactly all minimal solutions of @xmath4 ; the minimal solutions of @xmath4  are of special interest for model - based inference .    among the extentions of the approach described here we are currently working on ,",
    "is the investigation and evaluation of alternative minimality criteria . instead of ordering the vectors @xmath75 by the sum of their components",
    ", we could define a componentwise order on @xmath76  by defining @xmath77 iff @xmath78 for @xmath51 , yielding a partial order @xmath79 on @xmath76 .",
    "still another alternative is to compare the full ocfs @xmath74 induced by @xmath73 according to ( [ eq_conditional_indifference_no_kappaplus ] ) , yielding the ordering @xmath80 on @xmath76  defined by @xmath81 iff @xmath82 for all @xmath14 .    in general",
    ", it is an open problem how to strengthen the requirements defining a c - representation so that a unique solution is guaranteed to exist .",
    "the declarative nature of constraint logic programming supports easy constraint modification , enabling the experimentation and practical evaluation of different notions of minimality for @xmath76  and of additional requirements that might be imposed on a ranking function .",
    "furthermore , in @xcite the framework of default rules concidered here is extended by allowing not only default rules in the knowledge base @xmath3 , but also strict knowledge , rendering some worlds completely impossibe .",
    "this can yield a reduction of the problem s complexity , and it will be interesting to see which effects the incorporation of strict knowledge will have on the clp approach presented here .      c.  beierle and g.  kern - isberner . a verified asml implementation of belief revision . in e.",
    "brger , m.  butler , j.  p. bowen , and p.  boca , editors , _ abstract state machines , b and z , first international conference , abz 2008 , london , uk , september 16 - 18 , 2008 . proceedings _ ,",
    "volume 5238 of _ lncs _ , pages 98111 .",
    "springer , 2008 .    c.  beierle and g.  kern - isberner . on the computation of ranking functions for default rules",
    " a challenge for constraint programming . in _ proc .",
    "deklarative modellierung und effiziente optimierung mit constraint - technologie .",
    "workshop at gi jahrestagung 2011 _ , 2011 .",
    "( to appear ) .    c.  beierle , g.  kern - isberner , and n.  koch . a high - level implementation of a system for automated reasoning with default rules ( system description ) .",
    "in a.  armando , p.  baumgartner , and g.  dowek , editors , _ proc . of the 4th international joint conference on automated reasoning ( ijcar-2008 ) _ , volume 5195 of _ lncs _ , pages 147153 .",
    "springer , 2008 .",
    "s.  benferhat , d.  dubois , and h.  prade . representing default rules in possibilistic logic . in _",
    "proceedings 3th international conference on principles of knowledge representation and reasoning kr92 _ , pages 673684 , 1992 .",
    "m.carlsson , g.  ottosson , and b.  carlson . an open - ended finite domain constraint solver . in h.",
    "glaser , p.  h. hartel , and h.  kuchen , editors , _ programming languages : implementations , logics , and programs , ( plilp97 ) _ , volume 1292 of _ lncs _ , pages 191206 .",
    "springer , 1997 .          w.  spohn .",
    "ordinal conditional functions : a dynamic theory of epistemic states . in w.l .",
    "harper and b.  skyrms , editors , _ causation in decision , belief change , and statistics , ii _ , pages 105134 .",
    "kluwer academic publishers , 1988 ."
  ],
  "abstract_text": [
    "<S> in order to give appropriate semantics to qualitative conditionals of the form _ if a then normally b _ , ordinal conditional functions ( ocfs ) ranking the possible worlds according to their degree of plausibility can be used . </S>",
    "<S> an ocf accepting all conditionals of a knowledge base r can be characterized as the solution of a constraint satisfaction problem . </S>",
    "<S> we present a high - level , declarative approach using constraint logic programming techniques for solving this constraint satisfaction problem . </S>",
    "<S> in particular , the approach developed here supports the generation of all minimal solutions ; these minimal solutions are of special interest as they provide a basis for model - based inference from r. </S>"
  ]
}