{
  "article_text": [
    "in static analysis and verification , model - driven _ abstraction refinement _ has emerged in the last decade as a fundamental method for improving abstractions towards more precise yet efficient analyses .",
    "the basic idea is simple : given an abstraction modeling some observational behavior of the system to analyze , refine the abstraction in order to remove the artificial computations that may appear in the approximate analysis by considering how the concrete system behaves when false alarms or spurious traces are encountered .",
    "the general concept of using spurious counterexamples for refining an abstraction stems from the counterexample - guided abstraction refinement ( cegar ) paradigm  @xcite .",
    "the model here drives the automatic identification of prefixes of the counterexample path that do not correspond to an actual trace in the concrete model , by isolating abstract ( failure ) states that need to be refined in order to eliminate that spurious counterexample .",
    "model - driven refinements , such as cegar , provide algorithmic methods for achieving abstractions that are complete ( i.e. , precise @xcite ) with respect to some given property of the concrete model .",
    "we investigate here the dual problem of _",
    "abstraction simplification_. instead of refining abstractions in order to eliminate spurious traces , our goal is to simplify an abstraction @xmath0 towards a simpler ( ideally , the simplest ) model @xmath1 that maintains the same approximate behavior as @xmath0 does . in abstract model checking",
    ", this abstraction simplification has _ to keep the same examples _ of the concrete system in the following sense . recall that an abstract path @xmath2 in an abstract transition system @xmath3 is _ spurious _ when no real concrete path is abstracted to @xmath2 .",
    "assume that a given abstract state space @xmath0 of a system @xmath3 gets simplified to @xmath1 and thus gives rise to a more abstract system @xmath4 .",
    "then , we say that @xmath4 keeps the same examples of @xmath3 when the following condition is satisfied : if @xmath5 is a spurious path in the simplified abstract system @xmath4 then there exists a spurious path @xmath6 in the original system @xmath3 that is abstracted to @xmath5 .",
    "such a methodology is called egas , example - guided abstraction simplification , since this abstraction simplification does not add spurious paths , namely , it does keep examples , since each spurious path in @xmath4 comes as an abstraction of a spurious path in @xmath3 .",
    "= [ ->,>=latex ] ( 0,2 ) node[name=1]1 ( 2,5 ) node[name=2]2 ( 2,3 ) node[name=3]3 ( 2,1 ) node[name=4]4 ( 2,-1 ) node[name=5]5 ( 4,3 ) node[name=6]6 ( 4,1 ) node[name=7]7 ( 6,3 ) node[name=8]8 ( 6,1 ) node[name=9]9 ; ( 8,2 ) node[name = f]@xmath7 ; ( 0,5 ) node[name = a]@xmath8 ; ( 1 ) to ( 2 ) ; ( 1 ) to ( 4 ) ; ( 2 ) to ( 6 ) ; ( 3 ) to ( 7 ) ; ( 4 ) to ( 6 ) ; ( 5 ) to ( 7 ) ; ( 6 ) to ( 8) ; ( 7 ) to ( 9 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = b1 ] ( 3.south east ) + + ( 0.1,-0.1 ) node[name = b2 ] ; ( b1 ) rectangle ( b2 ) ;    ( 4.north west ) + + ( -0.1,0.1 ) node[name = b3 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b4 ] ; ( b3 ) rectangle ( b4 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    ( 8.north west ) + + ( -0.1,0.1 ) node[name = d1 ] ( 9.south east ) + + ( 0.1,-0.1 ) node[name = d2 ] ; ( d1 ) rectangle ( d2 ) ;    ( 10,2 ) node[name=1]1 ( 12,5 ) node[name=2]2 ( 12,3 ) node[name=3]3 ( 12,1 ) node[name=4]4 ( 12,-1 ) node[name=5]5 ( 14,3 ) node[name=6]6 ( 14,1 ) node[name=7]7 ( 16,3 ) node[name=8]8 ( 16,1 ) node[name=9]9 ; ( 18,2 ) node[name = f]@xmath7 ; ( 10,5 ) node[name = a]@xmath9 ; ( 1 ) to ( 2 ) ; ( 1 ) to ( 4 ) ; ( 2 ) to ( 6 ) ; ( 3 ) to ( 7 ) ; ( 4 ) to ( 6 ) ; ( 5 ) to ( 7 ) ; ( 6 ) to ( 8) ; ( 7 ) to ( 9 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = b1 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b2 ] ; ( b1 ) rectangle ( b2 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    ( 8.north west ) + + ( -0.1,0.1 ) node[name = d1 ] ( 9.south east ) + + ( 0.1,-0.1 ) node[name = d2 ] ; ( d1 ) rectangle ( d2 ) ;    ( 20,2 ) node[name=1]1 ( 22,5 ) node[name=2]2 ( 22,3 ) node[name=3]3 ( 22,1 ) node[name=4]4 ( 22,-1 ) node[name=5]5 ( 24,3 ) node[name=6]6 ( 24,1 ) node[name=7]7 ( 26,3 ) node[name=8]8 ( 26,1 ) node[name=9]9 ;    ( 20,5 ) node[name = a]@xmath10 ; ( 1 ) to ( 2 ) ; ( 1 ) to ( 4 ) ; ( 2 ) to ( 6 ) ; ( 3 ) to ( 7 ) ; ( 4 ) to ( 6 ) ; ( 5 ) to ( 7 ) ; ( 6 ) to ( 8) ; ( 7 ) to ( 9 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = b1 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b2 ] ; ( b1 ) rectangle ( b2 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 8.north west ) + + ( -0.1,0.1 ) node[name = d1 ] ( 9.south east ) + + ( 0.1,-0.1 ) node[name = d2 ] ; ( d1 ) rectangle ( d2 ) ;    let us illustrate how egas works through a simple example .",
    "let us consider the abstract transition system @xmath3 in figure  [ figure-1 ] , where concrete states are numbers which are abstracted by blocks of the state partition @xmath11,[2,3],[4,5],[6],[7],[8,9]\\}$ ] .",
    "the abstract state space of @xmath3 is simplified by merging the abstract states @xmath12 $ ] and @xmath13 $ ] : egas guarantees that this can be safely done because @xmath14 ) = \\{[1]\\}= \\operatorname{pre}^\\sharp([4,5])$ ] and @xmath15 ) = \\{[6],[7]\\}= \\operatorname{post}^\\sharp([4,5])$ ] , where @xmath16 and @xmath17 denote , respectively , the abstract predecessor and successor functions in @xmath3 .",
    "this abstraction simplification leads to the abstract system @xmath18 in figure  [ figure-1 ] .",
    "let us observe that the abstract path @xmath19 , [ 2,3,4,5 ] , [ 7 ] , [ 8,9]\\rangle$ ] in @xmath18 is spurious because there is no concrete path whose abstraction in @xmath18 is @xmath2 , while @xmath2 is instead the abstraction of the spurious path @xmath20,$ ] @xmath13,$ ] @xmath21 , [ 8,9]\\rangle$ ] in @xmath3 .",
    "on the other hand , consider the path @xmath22 , [ 2,3,4,5 ] , [ 6 ] , [ 8,9]\\rangle$ ] in @xmath18 and observe that all the paths in @xmath3 that are abstracted to @xmath23 , i.e.@xmath20,[2,3],[6],[8,9]\\rangle$ ] and @xmath20,[4,5],[6],[8,9]\\rangle$ ] , are not spurious .",
    "this is consistent with the fact that @xmath24 actually is not a spurious path .",
    "likewise , @xmath18 can be further simplified to the abstract system @xmath25 where the blocks @xmath26 $ ] and @xmath21 $ ] are merged into a new abstract state @xmath27 $ ] .",
    "this transformation also keeps examples because now there is no spurious path in @xmath25 .",
    "let us also notice that if @xmath3 would get simplified to an abstract system @xmath28 by merging the blocks @xmath29 $ ] and @xmath12 $ ] into a new abstract state @xmath30 $ ] then this transform would not keep examples because we would obtain the spurious loop path @xmath31 , [ 1,2,3 ] , [ 1,2,3 ] , ...",
    "\\rangle$ ] in @xmath28 ( because in @xmath28 @xmath30 $ ] has a self - loop ) while there is no corresponding spurious abstract path in @xmath3 whose abstraction in @xmath28 is @xmath32 .",
    "egas is formalized within the standard abstract interpretation framework by cousot and cousot  @xcite .",
    "this ensures that egas can be applied both in abstract model checking and in abstract interpretation .",
    "consider for instance the following two basic abstract domains @xmath33 and @xmath34 for sign analysis of an integer variable , so that sets of integer numbers in @xmath35 is the concrete domain .    ( 0,0 ) node[name=2 ] @xmath36 ; ( -1,1 ) node[name=3 ] @xmath37 ; ( 1,1 ) node[name=4 ] @xmath38 ; ( 0,2 ) node[name=5 ] @xmath39 ;    ( -2.5,1 ) node @xmath33 ;    \\(2 )  ( 3 ) ; ( 2 ) ",
    "( 4 ) ; ( 3 )  ( 5 ) ; ( 4 )  ( 5 ) ;    ( 5,1 ) node @xmath34 ;    ( 4,0 ) node[name=2 ] @xmath38 ; ( 4,2 ) node[name=5 ] @xmath39 ;    \\(2 )  ( 5 ) ;    recall that in abstract interpretation the best correct approximation of a semantic function @xmath40 on an abstract domain @xmath0 that is defined through abstraction / concretization maps @xmath41/@xmath42 is given by @xmath43 .",
    "consider a simple operation of increment @xmath44++ on an integer variable @xmath44 . in this case ,",
    "the best correct approximations on @xmath33 and @xmath34 are as follows : @xmath45 \\text{++}^{a_2 } = \\ { \\mathbb{z}_{\\geq 0 } \\mapsto \\mathbb{z}_{\\geq 0},\\ :   \\mathbb{z } \\mapsto \\mathbb{z}\\}.\\end{gathered}\\ ] ] we observe that the best correct approximations of @xmath46 in @xmath33 and @xmath34 encode the same function , meaning that the approximations of @xmath46 in @xmath33 and @xmath34 are equivalent , the latter being clearly simpler .",
    "in fact , we have that @xmath47 and @xmath48 are exactly the same function on @xmath35 .",
    "in other terms , the abstract domain @xmath33 contains some `` irrelevant '' abstract values for approximating the increment operation , that is , @xmath36 and @xmath37 .",
    "this simplification of an abstract domain relatively to a semantic function is formalized in the most general abstract interpretation setting .",
    "this allows us to provide , for generic continuous semantic functions , a systematic and constructive method , that we call _ correctness kernel _ , for simplifying a given abstraction @xmath0 relatively to a given semantic function @xmath40 towards the unique minimal abstract domain that induces an equivalent approximate behavior of @xmath40 as in @xmath0 .",
    "we show how correctness kernels can be embedded within the cegar methodology by providing a novel refinement heuristics in a cegar iteration step which turns out to be more accurate than the basic refinement heuristics  @xcite .",
    "we also describe how correctness kernels may be applied in predicate abstraction - based model checking @xcite for reducing the search space without applying ball et al.s @xcite cartesian abstractions , which typically yield additional loss of precision .",
    "this is an extended and revised version of the conference paper  @xcite that includes full proofs .",
    "as usual in standard abstract interpretation  @xcite , abstract domains ( or abstractions ) are specified by galois connections / insertions ( gcs / gis for short ) or , equivalently , adjunctions .",
    "concrete and abstract domains , @xmath49 and @xmath50 , are assumed to be complete lattices which are related by abstraction and concretization maps @xmath51 and @xmath52 that give rise to an adjunction @xmath53 , that is , for all @xmath54 and @xmath55 , @xmath56 .",
    "it is known that @xmath57 is an upper closure operator ( uco ) on @xmath58 , i.e.  a monotone , idempotent and increasing function .",
    "also , abstract domains can be equivalently defined as ucos , meaning that any gi @xmath53 induces the uco @xmath59 , any uco @xmath60 induces the gi @xmath61 , and these two transforms are the inverse of each other .",
    "gis of a common concrete domain @xmath58 are preordered w.r.t .",
    "their relative precision as usual : @xmath62    i.e.  @xmath33/@xmath34 is a refinement / simplification of @xmath34/@xmath33    iff @xmath63 .",
    "moreover , @xmath64 and @xmath65 are equivalent when @xmath66 and @xmath67 .",
    "we denote by @xmath68 the family of abstract domains of @xmath58 up to the above equivalence .",
    "it is well known that @xmath69 is a complete lattice , so that one can consider the most concrete simplification ( i.e. , lub @xmath70 ) and the most abstract refinement ( i.e. , glb @xmath71 ) of any family of abstract domains .",
    "let us recall that the lattice of abstract domains @xmath69 is isomorphic to the lattice of ucos on @xmath58 @xmath72 , where @xmath73 denotes the pointwise ordering between functions , so that lub s and glb s of abstractions can be equivalently characterized in @xmath74 .",
    "let us also recall that each @xmath75 is uniquely determined by its image @xmath76 because @xmath77 .",
    "moreover , a subset @xmath78 is the image of some uco on @xmath58 iff @xmath79 is meet - closed , i.e.  @xmath80 ( note  that @xmath81 ) .",
    "often , we will identify ucos with their images .",
    "this does not give rise to ambiguity , since one can distinguish their use as functions or sets according to the context .",
    "hence , if @xmath82 are two abstractions then they can be viewed as images of two ucos on @xmath58 , denoted respectively by @xmath59 and @xmath83 , so that @xmath0 is more precise than @xmath84 when @xmath85 .",
    "let @xmath86 be some concrete semantic function    for simplicity , we consider 1-ary functions    and let @xmath87 be a corresponding abstract function defined on some abstraction @xmath88 .",
    "then , @xmath89 is a sound abstract interpretation when @xmath90 .",
    "moreover , the abstract function @xmath91 is called the _ best correct approximation _ ( b.c.a . ) of @xmath40 on @xmath0 because any abstract interpretation @xmath89 is sound iff @xmath92 .",
    "hence , for any abstraction @xmath0 , @xmath93 plays the role of the best possible approximation of @xmath40 on @xmath0 .",
    "given a semantic function @xmath94 on some concrete domain @xmath58 and an abstraction @xmath95 , does there exist the _ most abstract domain _ that induces the same best correct approximation of @xmath40 as @xmath0 does ?",
    "let us formalize the above question .",
    "consider two abstractions @xmath82 .",
    "we say that @xmath0 and @xmath84 induce the same best correct approximation of @xmath40 when @xmath96 and @xmath97 are the same function up to isomorphic representations of abstract values .",
    "if @xmath59 and @xmath83 are the corresponding ucos then this boils down to : @xmath98 in order to keep the notation easy , this is denoted simply by @xmath99 .",
    "also , if @xmath100 is a set of concrete functions then @xmath101 means that for any @xmath102 , @xmath99 .",
    "hence , given @xmath88 and by defining @xmath103 the question is whether @xmath104 holds or not .",
    "this leads us to the following notion of correctness kernel .",
    "given @xmath105[1ex]{$    \\mathrel{\\mathop { \\hspace*{1pt}\\longrightarrow\\hspace*{1pt}}\\limits^{\\,_{\\mbox{\\tiny \\hspace*{-2.2pt}}}}}$ } } } c$ ] define : @xmath106 as @xmath107 if @xmath108 then @xmath109 is called the _ correctness kernel _ of @xmath0 for @xmath110 .",
    "it is worth remarking that the dual question on the existence of the _ most concrete domain _ that induces the same best correct approximation of @xmath40 as @xmath0 has a negative answer , as shown by the following simple example .",
    "[ esempio2 ] consider the lattice @xmath58 depicted below .",
    "( 0,0 ) node[name=1 ] @xmath111 ; ( 0,1 ) node[name=2 ] @xmath112 ; ( -1,2 ) node[name=3 ] @xmath113 ; ( 1,2 ) node[name=4 ] @xmath114 ; ( 0,3 ) node[name=5 ] @xmath115 ;    \\(1 )  ( 2 ) ; ( 2 ) ",
    "( 3 ) ; ( 2 )  ( 4 ) ; ( 3 )  ( 5 ) ; ( 4 )  ( 5 ) ;    let us also consider the monotonic function @xmath94 defined as @xmath116 and the abstraction @xmath117 whose image is @xmath118 .",
    "let us observe that @xmath119 .",
    "consider now the abstractions @xmath120 and @xmath121 and observe that @xmath122 .",
    "however , we have that @xmath123 , because the image of @xmath124 is @xmath125 . hence , @xmath126 . therefore , if we let @xmath127 then @xmath128 .",
    "consequently , the most concrete domain that induces the same best correct approximation of @xmath40 as @xmath129 does not exist .",
    "our key technical result is the following _ constructive _ characterization of the property of `` having the same b.c.a . '' for two comparable abstract domains . in the following ,",
    "given a poset @xmath0 and any subset @xmath130 , @xmath131 denotes the set of maximal elements of @xmath132 in @xmath0 .",
    "[ key ] let @xmath133 and @xmath134 such that @xmath135 .",
    "suppose that @xmath136 is continuous ( i.e. , preserves lub s of chains in @xmath58 ) .",
    "then , @xmath137      let us now observe that @xmath149 : in fact , since @xmath150 , this is equivalent to @xmath151 , which is obviously equivalent to @xmath152 .    since @xmath153 , we have that @xmath154 is equivalent to @xmath155 . by the characterization of completeness in (",
    "* lemma  4.2 ) , since , by hypothesis , @xmath156 is continuous , we have that the completeness equation @xmath155 is equivalent to @xmath157 , which is in turn equivalent to @xmath158 .    summing up , we have thus shown that @xmath159 and this , by the above property  @xmath160 , implies the thesis .",
    "it is important to remark that the above proof basically consists in reducing the equality @xmath161 between b.c.a.s to a standard property of completeness of the abstract domains @xmath0 and @xmath84 for the function @xmath40 and then in exploiting the constructive characterization of completeness of abstract domains by giacobazzi et al .",
    "* section  4 ) . in this sense , the proof itself is particularly interesting because it provides an unexpected reduction of best correct approximations to a completeness problem .    as a consequence of lemma  [ key ]",
    "we obtain the following constructive result of existence for correctness kernels . recall that if @xmath162 then @xmath163 denotes the glb - closure of @xmath79 in @xmath0 , while @xmath164 denotes the dual lub - closure .",
    "[ kernel ] let @xmath95 and @xmath165 such that , for any @xmath102 , @xmath166 is continuous .",
    "then , the correctness kernel of @xmath0 for @xmath110 exists and it is @xmath167    let @xmath168",
    ". we prove the following equivalent statement formalized through ucos : @xmath169 is the correctness kernel of @xmath129 for @xmath110 .",
    "let @xmath170 .",
    "by lemma  [ key ] , we have that @xmath171 .",
    "since @xmath172 , as a consequence we also have that @xmath173 is the correctness kernel of @xmath129 for @xmath110 .",
    "+ therefore , let us prove that @xmath174 let us first observe that for any @xmath175 , if @xmath176 then @xmath177 : in fact , @xmath178 , so that from @xmath179 , by maximality of @xmath180 , we get @xmath181 .",
    "+ @xmath182 : consider @xmath175 and @xmath183 .",
    "then , it turns out that @xmath184 .",
    "in fact , since @xmath181 , we have that @xmath185 .",
    "moreover , if @xmath186 and @xmath187 then @xmath188 , so that , by maximality of @xmath180 , @xmath189 , i.e. , @xmath190 .",
    "+ @xmath191 : consider @xmath192 and @xmath193 . then , @xmath194 so that @xmath195 . if @xmath196 and @xmath187 then @xmath197 . hence , since @xmath198 and by maximality of @xmath180 , we have that @xmath199 , and in turn @xmath189 .",
    "thus , @xmath183 .",
    "consider sets of integers @xmath200 as concrete domain domain and the square operation @xmath201 as concrete function , i.e. , @xmath202 , which is obviously additive and therefore continuous .",
    "consider the abstract domain @xmath203 , depicted in the following figure , that represents the sign of an integer variable .",
    "( 0,0 ) node[name=1 ] @xmath204 ;    ( -1,1 ) node[name=2 ] @xmath205 ; ( 0,1 ) node[name=3 ] @xmath36 ; ( 1,1 ) node[name=4 ] @xmath206 ;    ( -1,2 ) node[name=5 ] @xmath37 ; ( 0,2 ) node[name=6 ] @xmath207 ; ( 1,2 ) node[name=7 ] @xmath38 ;    ( 0,3 ) node[name=8 ] @xmath39 ; ( 1 )  ( 2 ) ; ( 1 )  ( 3 ) ; ( 1 )  ( 4 ) ; ( 2 )  ( 5 ) ; ( 2 )  ( 6 ) ; ( 3 ) ",
    "( 5 ) ; ( 3 )  ( 7 ) ; ( 4 )  ( 6 ) ; ( 4 )  ( 7 ) ; ( 5 )  ( 8) ; ( 6 )  ( 8) ; ( 7 )  ( 8) ;    @xmath208 induces the following best correct approximation of @xmath209 : @xmath210 let us characterize the correctness kernel @xmath211 by theorem  [ kernel ] .",
    "we have that @xmath212 .",
    "moreover , @xmath213 therefore , @xmath214 so that , by theorem  [ kernel ] : @xmath215 thus , it turns out that we can safely remove the abstract values @xmath216 and @xmath37 from @xmath208 and still preserve the same b.c.a .  as @xmath208 does .",
    "besides , we can not remove further abstract elements otherwise we do not retain the same b.c.a .  as @xmath208 .",
    "for example , this means that @xmath208-based analyses of programs like @xmath217 can be carried out by using the simpler domain @xmath218 , yet providing the same input / output abstract behavior .",
    "it is worth remarking that in theorem  [ kernel ] the hypothesis of continuity is crucial for the existence of correctness kernels and this is shown by the following example .",
    "[ esempio1 ] let us consider as concrete domain @xmath58 the @xmath219 ordinal , i.e. , @xmath220 , and let @xmath86 be defined as follows : @xmath221 let @xmath75 be the identity @xmath222 uco , so that @xmath223 . for any @xmath224 ,",
    "consider @xmath225 defined as @xmath226 and observe that for any @xmath227 , we have that @xmath228 . however , it turns out that @xmath229 .",
    "hence , @xmath230 .",
    "hence , the correctness kernel of @xmath129 for @xmath40 does not exist .",
    "observe that @xmath231 is clearly not continuous and therefore this example is consistent with theorem  [ kernel ] .",
    "following the approach by ranzato and tapparo  @xcite , partitions of a state space @xmath232 can be viewed as particular abstract domains of the concrete domain @xmath233 .",
    "let @xmath234 denote the set of partitions of @xmath232 . given a partition @xmath235 , the corresponding set of ( possibly empty ) unions of blocks of @xmath236 , namely @xmath237 ,",
    "is viewed as an abstract domain of @xmath233 by means of the following galois insertion @xmath238 : @xmath239 hence , the abstraction @xmath240 provides the minimal over - approximation of a set @xmath132 of states through blocks of @xmath236 .    consider a transition system @xmath241 and a corresponding abstract transition system @xmath242 defined over a state partition @xmath235",
    "can be defined over an abstract state space @xmath0 determined by a surjective abstraction function @xmath243 . ]",
    "fixpoint - based verification of a temporal specification on the abstract model @xmath3 relies on the computation of least / greatest fixpoints of operators which are defined using boolean connectives ( union , intersection , complementation ) on abstract states and abstract successor / predecessor functions @xmath17/@xmath16 on the abstract transition system @xmath244 .",
    "the key point here is that successor / predecessor functions are defined as best correct approximations on the abstract domain @xmath236 of the corresponding concrete successor / predecessor functions . in standard abstract model checking @xcite ,",
    "the abstract transition relation is defined as the existential / existential relation @xmath245 between blocks of @xmath236 , namely : @xmath246 as shown in @xcite , it turns out that @xmath247 and @xmath248 are the best correct approximations of , respectively , @xmath249 and @xmath250 functions on the above abstraction @xmath238 .",
    "in fact , for a block @xmath251 , we have that @xmath252 and an analogous equation holds for @xmath250 .",
    "we thus have that @xmath253 and @xmath254 .",
    "this abstract interpretation - based framework allows us to apply correctness kernels in the context of abstract model checking .",
    "the abstract transition system @xmath255 is viewed as an abstract interpretation defined by the abstract domain @xmath256 @xmath257 and the corresponding abstract functions @xmath253 and @xmath254 .",
    "then , the correctness kernel of the abstraction @xmath237 for the concrete predecessor / successor @xmath258 , that we denote simply by @xmath259 ( by theorem  [ kernel ] , this clearly exists since @xmath249 and @xmath250 are additive functions ) , provides a simplification of the abstract domain @xmath237 that preserves the best correct approximations of predecessor and successor functions .",
    "this simplification @xmath259 of the abstract state space @xmath236 works as follows :    [ kernel - part ] @xmath259 merges two blocks @xmath260 if and only if for any @xmath261 , @xmath262 and @xmath263 .    by theorem  [ kernel ] , we have that the kernel @xmath259 of the abstraction @xmath264 for @xmath249 and @xmath250 is as follows : @xmath265 let us observe that both b.c.a.s @xmath266 are additive functions , so that for any @xmath267 , @xmath268 and for any @xmath269 , @xmath270 .",
    "moreover , @xmath259 is closed under arbitrary unions .",
    "hence , the kernel can be simplified as follows : @xmath271 we therefore have that a block @xmath272 is merged together with all the blocks @xmath273 such that for any block @xmath261 , @xmath274 and @xmath275 .",
    "thus , the thesis follows .",
    "reconsider the abstract transition system @xmath3 in section  [ intro ] and let @xmath276,[2,3],[4,5],[6],[7],[8,9]\\}$ ] be the underlying state partition . in this case",
    ", we have that @xmath277\\ } , \\{[2,3],[4,5]\\ } , \\{[6],[7]\\}\\big\\}\\big),\\\\ \\operatorname{img}(\\operatorname{post}^{\\exists\\exists } ) = \\operatorname{cl}_{\\cup } \\big(\\big\\{\\{[2,3],[4,5]\\ } , \\{[6],[7]\\},\\{[8,9]\\}\\big\\}\\big ) .",
    "\\end{array}\\ ] ] hence , by corollary  [ kernel - part ] , in the correctness kernel @xmath259 the block @xmath12 $ ] is merged with @xmath13 $ ] while @xmath26 $ ] is merged with @xmath21 $ ] .",
    "this therefore simplifies the partition @xmath236 to @xmath278 , [ 2,3,4,5 ] , [ 6,7 ] , [ 8,9]\\}$ ] , that is , we obtain the abstract transition system @xmath25 in section  [ intro ] .",
    "let us discuss how correctness kernels give rise to an example - guided abstraction simplification ( egas ) paradigm in abstract transition systems .",
    "let us first recall some basic notions of cegar @xcite .",
    "consider an abstract transition system @xmath279 defined over a state partition @xmath235 and a finite abstract path @xmath280 in @xmath3 , where each @xmath281 is a block of @xmath236 .",
    "typically , this is a path counterexample to the validity of a temporal formula that has been given as output by a model checker ( for simplicity we do not consider here loop path counterexamples ) .",
    "the set of concrete paths that are abstracted to @xmath2 are defined as follows : @xmath282 .",
    "s_i\\in b_i \\;\\&\\ ; \\forall i\\in [ 1,n ) .",
    "s_i { \\shortrightarrow}s_{i+1}\\}.\\ ] ] the abstract path @xmath2 is _ spurious _ when it represents no real concrete path , i.e. , when @xmath283 .",
    "the sequence of sets of states @xmath284 is inductively defined as follows : @xmath285 ; @xmath286 . as shown in @xcite , it turns out that @xmath2 is spurious iff there exists a least @xmath287 $ ] such that @xmath288 .",
    "in such a case , the partition @xmath236 is refined by splitting the block @xmath289 .",
    "the three following sets partition the states of the block @xmath289 :    dead - end states : @xmath290    bad states : @xmath291    irrelevant states : @xmath292    the split of the block @xmath289 must separate dead - end states from bad states , while irrelevant states may be joined indifferently with dead - end or bad states . however , the problem of finding the coarsest refinement of @xmath236 that separates dead - end and bad states is np - hard  @xcite and thus some refinement heuristics are used .",
    "according to the basic heuristics of cegar ( * ? ? ?",
    "* section  4 ) , @xmath289 is simply split into @xmath293 and @xmath294 .",
    "= [ ->,>=latex ] ( 0,3 ) node[name=1]1 ( 0,1 ) node[name=2]2 ( 2,4 ) node[name=3]3 ( 2,2 ) node[name=4]4 ( 2,0 ) node[name=5]5 ( 4,3 ) node[name=6]6 ( 4,1 ) node[name=7]7 ; ( 6,3.5 ) node[name = f , rotate=45]@xmath295 ; ( 6,0.5 ) node[name = f , rotate=-45]@xmath295 ;    ( 0,4.5 ) node[name = a]@xmath8 ; ( 1 ) to ( 5 ) ; ( 2 ) to ( 4 ) ; ( 2 ) to ( 5 ) ; ( 3 ) to ( 6 ) ; ( 4 ) to ( 7 ) ; ( 5 ) to ( 7 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = a3 ] ( 2.south east ) + + ( 0.1,-0.1 ) node[name = a4 ] ; ( a3 ) rectangle ( a4 ) ;    ( 3.north west ) + + ( -0.1,0.1 ) node[name = b3 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b4 ] ; ( b3 ) rectangle ( b4 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    ( 8,6 ) node[name=1]1 ( 8,4 ) node[name=2]2 ( 10,7 ) node[name=3]3 ( 10,5 ) node[name=4]4 ( 10,3 ) node[name=5]5 ( 12,6 ) node[name=6]6 ( 12,4 ) node[name=7]7 ; ( 14,3.5 ) node[name = f , rotate=-45]@xmath295 ; ( 8,7.5 ) node[name = a]@xmath9 ;    \\(1 ) to ( 5 ) ; ( 2 ) to ( 4 ) ; ( 2 ) to ( 5 ) ; ( 3 ) to ( 6 ) ; ( 4 ) to ( 7 ) ; ( 5 ) to ( 7 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = a3 ] ( 2.south east ) + + ( 0.1,-0.1 ) node[name = a4 ] ; ( a3 ) rectangle ( a4 ) ;    ( 3.north west ) + + ( -0.1,0.1 ) node[name = b3 ] ( 4.south east ) + + ( 0.1,-0.1 ) node[name = b4 ] ; ( b3 ) rectangle ( b4 ) ;    ( 5.north west ) + + ( -0.1,0.1 ) node[name = b5 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b6 ] ; ( b5 ) rectangle ( b6 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    ( 8,0 ) node[name=1]1 ( 8,-2 ) node[name=2]2 ( 10,1 ) node[name=3]3 ( 10,-1 ) node[name=4]4 ( 10,-3 ) node[name=5]5 ( 12,0 ) node[name=6]6 ( 12,-2 ) node[name=7]7 ; ( 8,1.5 ) node[name = a]@xmath10 ;    \\(1 ) to ( 5 ) ; ( 2 ) to ( 4 ) ; ( 2 ) to ( 5 ) ; ( 3 ) to ( 6 ) ; ( 4 ) to ( 7 ) ; ( 5 ) to ( 7 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = a3 ] ( 2.south east ) + + ( 0.1,-0.1 ) node[name = a4 ] ; ( a3 ) rectangle ( a4 ) ;    ( 3.north west ) + + ( -0.1,0.1 ) node[name = b3 ] ( 3.south east ) + + ( 0.1,-0.1 ) node[name = b4 ] ; ( b3 ) rectangle ( b4 ) ;    ( 4.north west ) + + ( -0.1,0.1 ) node[name = b5 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b6 ] ; ( b5 ) rectangle ( b6 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    ( 16,3 ) node[name=1]1 ( 16,1 ) node[name=2]2 ( 18,4 ) node[name=3]3 ( 18,2 ) node[name=4]4 ( 18,0 ) node[name=5]5 ( 20,3 ) node[name=6]6 ( 20,1 ) node[name=7]7 ; ( 16,4.5 ) node[name = a]@xmath296 ;    \\(1 ) to ( 5 ) ; ( 2 ) to ( 4 ) ; ( 2 ) to ( 5 ) ; ( 3 ) to ( 6 ) ; ( 4 ) to ( 7 ) ; ( 5 ) to ( 7 ) ;    ( 1.north west ) + + ( -0.1,0.1 ) node[name = a1 ] ( 1.south east ) + + ( 0.1,-0.1 ) node[name = a2 ] ; ( a1 ) rectangle ( a2 ) ;    ( 2.north west ) + + ( -0.1,0.1 ) node[name = a3 ] ( 2.south east ) + + ( 0.1,-0.1 ) node[name = a4 ] ; ( a3 ) rectangle ( a4 ) ;    ( 3.north west ) + + ( -0.1,0.1 ) node[name = b3 ] ( 3.south east ) + + ( 0.1,-0.1 ) node[name = b4 ] ; ( b3 ) rectangle ( b4 ) ;    ( 4.north west ) + + ( -0.1,0.1 ) node[name = b7 ] ( 4.south east ) + + ( 0.1,-0.1 ) node[name = b8 ] ; ( b7 ) rectangle ( b8 ) ;    ( 5.north west ) + + ( -0.1,0.1 ) node[name = b5 ] ( 5.south east ) + + ( 0.1,-0.1 ) node[name = b6 ] ; ( b5 ) rectangle ( b6 ) ;    ( 6.north west ) + + ( -0.1,0.1 ) node[name = c1 ] ( 6.south east ) + + ( 0.1,-0.1 ) node[name = c2 ] ; ( c1 ) rectangle ( c2 ) ;    ( 7.north west ) + + ( -0.1,0.1 ) node[name = c3 ] ( 7.south east ) + + ( 0.1,-0.1 ) node[name = c4 ] ; ( c3 ) rectangle ( c4 ) ;    let us see a simple example . consider the abstract path @xmath297 , [ 345 ] , [ 6]\\rangle$ ] in the abstract transition system @xmath3 depicted in figure  [ figura - bis ] .",
    "this is a spurious path and the block @xmath298 $ ] is therefore partitioned as follows : @xmath299 $ ] dead - end states , @xmath300 $ ] bad states and @xmath301 $ ] irrelevant states .",
    "the refinement heuristics of cegar tells us that irrelevant states are joined with bad states so that @xmath3 is refined to the abstract transition system @xmath18 . in turn , consider the spurious path @xmath302 , [ 34 ] , [ 6 ] \\rangle$ ] in @xmath18 , so that cegar refines @xmath18 to @xmath28 by splitting the block @xmath303 $ ] . in the first abstraction refinement ,",
    "let us observe that if irrelevant states would have been joined together with dead - end states rather than with bad states we would have obtained the abstract system @xmath25 , and @xmath25 does not contain spurious paths so that it surely does not need to be further refined .",
    "egas can be integrated within the cegar loop thanks to the following remark .",
    "if @xmath304 and @xmath305 are paths , respectively , in @xmath306 and @xmath307 , where @xmath308 and @xmath309 is finer than @xmath310 , i.e.   @xmath311 , then we say that @xmath304 is abstracted to @xmath305 , denoted by @xmath312 , when @xmath313 and for any @xmath314 $ ] , @xmath315 .",
    "[ coro2 ] consider an abstract transition system @xmath316 over a partition @xmath235 and its simplification @xmath317 induced by the correctness kernel @xmath259 .",
    "if @xmath2 is a spurious abstract path in @xmath4 then there exists a spurious abstract path @xmath23 in @xmath3 such that @xmath318 .",
    "this is a simple consequence of corollary  [ kernel - part ] .",
    "let @xmath319 , where @xmath320 , and let @xmath321 be the block of @xmath2 that causes the spuriousness of @xmath2 . then , for each @xmath322 $ ] , we have that @xmath323 , where @xmath324 . by corollary  [ kernel - part ] , for each @xmath325 and @xmath326 , @xmath327 and for each @xmath3281,n]$ ] and @xmath326 , @xmath329",
    ". then , in order to define the path @xmath23 in @xmath3 , for @xmath330 $ ] , one can choose any block @xmath331 in @xmath236 such that @xmath332 .",
    "the key point to note here is that the definition of the correctness kernel @xmath259 guarantees that @xmath333 causes the spuriousness of @xmath23 and that @xmath334 .",
    "thus , it turns out that the abstraction simplification induced by the correctness kernel does not add spurious paths .",
    "these observations suggest us a new refinement strategy within the cegar loop .",
    "let @xmath319 be a spurious path in @xmath3 and @xmath284 such that @xmath288 for some minimum @xmath287 $ ] , so that the block @xmath289 needs to be split .",
    "the set of irrelevant states @xmath335 is partitioned as follows .",
    "we first define the subset of _ bad - irrelevant _ states @xmath336 .",
    "let @xmath337 and @xmath338 .",
    "then , we define : @xmath339 the underlying idea is simple : @xmath336 contains the irrelevant states that : ( 1 ) can be reached from a block that reaches some bad state and ( 2 ) reach a block that is also reached by some bad state . by corollary  [ coro2 ] ,",
    "it is therefore clear that by merging @xmath336 and @xmath340 no spurious path is added w.r.t .  the abstract system where they are kept separate .",
    "the subset of _ dead - irrelevant _ states @xmath341 is analogosly defined : if @xmath342 and @xmath343 then @xmath344 it may happen that : ( a )  an irrelevant state is both bad- and dead - irrelevant ; ( b )  an irrelevant state is neither bad- nor dead - irrelevant . from the viewpoint of egas , the states of case ( a ) can be equivalently merged with bad or dead states since in both cases no spurious path is added . on the other hand , the states of case ( b )",
    "are called _ fully - irrelevant _ because egas does not provide a merging strategy with bad or dead states . for these states",
    ", one could use , for example , the basic refinement heuristics of cegar that merge them with bad states .    in the above example",
    ", for the spurious path @xmath345,[3,4,5],[6]}$ ] in @xmath3 , the block @xmath346 $ ] needs to be refined : @xmath347,\\ ; b^{\\text{dead}}=[5],\\ ;   b^{\\text{irr}}=[4].\\ ] ] here , @xmath114 is a dead - irrelevant state because @xmath348 ) = \\{[1],[2]\\}$ ] , @xmath349)= \\{[7]\\}$ ] and @xmath350\\cup [ 2 ] ) \\cap   \\operatorname{pre}([7 ] ) ) \\cap [ 4 ] = \\{4\\}$ ] .",
    "hence , according to the egas refinement strategy , the dead - irrelevant state @xmath114 is merged in @xmath25 with the dead - end state @xmath115 .",
    "let us discuss how correctness kernels can be also used in the context of predicate abstraction - based model checking @xcite .",
    "following ball et al.s approach @xcite , predicate abstraction can be formalized by abstract interpretation as follows .",
    "let us consider a program @xmath236 with @xmath227 integer variables @xmath351, ... ,@xmath352 .",
    "the concrete domain of computation of @xmath236 is @xmath353 where @xmath354 .",
    "values in @xmath355 are denoted by tuples @xmath356 .",
    "the program @xmath236 generates a transition system @xmath357 so that the concrete semantics of @xmath236 is defined by the corresponding successor function @xmath358 .",
    "a finite set @xmath359 of state predicates is considered , where each predicate @xmath360 denotes the subset of states that satisfy @xmath360 , i.e.  @xmath361 .",
    "these predicates give rise to the so - called _ boolean abstraction _",
    "@xmath362 which is related to @xmath363 through the following abstraction and concretization maps ( here , @xmath364 is understood in @xmath365 ) :    @xmath366    these functions give rise to a disjunctive ( i.e. , @xmath42 preserves lub s ) galois connection @xmath367 .",
    "verification of reachability properties based on predicate abstraction consists in computing the least fixpoint of the best correct approximation of @xmath250 on the boolean abstraction @xmath84 , namely , @xmath368 . as argued in @xcite , the boolean abstraction @xmath84 may be too costly for the purpose of reachability verification , so that one usually abstracts @xmath84 through the so - called _ cartesian abstraction_. this latter abstraction formalizes precisely the abstract @xmath250 operator computed by the verification algorithm of the c2bp tool in slam  @xcite .",
    "however , the cartesian abstraction of @xmath84 may cause a loss of precision , so that this abstraction is successively refined by reduced disjunctive completion and the so - called focus operation , and this formalizes the bebop tool in slam  @xcite .",
    "@xmath44 , @xmath369 , @xmath180 , @xmath370 ;    @xmath371 ( ) \\ {     \\ {    @xmath372 ;   @xmath373 ;     @xmath374 \\ { @xmath44++ ;  @xmath375 ; }    } @xmath376     @xmath377    @xmath378 ;   @xmath160    }    let us consider the example program in figure  [ exprog ] , taken from @xcite , where the goal is that of verifying that the assert at line @xmath160 is never reached , regardless of the context in which @xmath379 is called .",
    "ball et al .",
    "@xcite consider the following set of predicates @xmath380 so that the boolean abstraction is @xmath381 .",
    "clearly , the analysis based on @xmath84 allows to conclude that line @xmath160 is not reachable .",
    "this comes as a consequence of the fact that the least fixpoint computation of the best correct approximation @xmath382 for the do - while loop provides as result @xmath383 because : @xmath384 where , according to a standard approach , the guard of the if statement is simply ignored .",
    "hence , at the exit of the do - while loop one can conclude that @xmath385 holds , hence @xmath386 is satisfied , so that @xmath387 and therefore line @xmath160 can never be reached .",
    "let us characterize the correctness kernel of the boolean abstraction @xmath84 .",
    "let @xmath388 and @xmath389 .",
    "the best correct approximations of @xmath390 and @xmath391 on the abstract domain @xmath84 turn out to be as follows : @xmath392 & \\tuple{1,1 } \\mapsto \\{\\tuple{1,1}\\ } \\big\\}\\\\ \\alpha_b { \\circ}\\operatorname{post}_{s_2 } { \\circ}\\gamma_b = \\big\\ { & \\tuple{0,0 } \\mapsto \\{\\tuple{0,0},\\tuple{0,1}\\ } , \\tuple{0,1 } \\mapsto \\{\\tuple{0,0}\\ } , \\\\[-5pt ] & \\tuple{1,0 } \\mapsto \\{\\tuple{0,0},\\tuple{0,1}\\ } ,   \\tuple{1,1 } \\mapsto \\{\\tuple{0,0}\\ } \\big\\}\\end{aligned}\\ ] ] thus , we have that @xmath393 and @xmath394 so that @xmath395    hence , by theorem  [ kernel ] , the kernel @xmath396 of @xmath84 for @xmath397 is : @xmath398 & \\{\\tuple{0,0},\\tuple{0,1},\\tuple{1,0},\\tuple{1,1}\\ } \\big\\ }    \\big ) \\big ) = \\operatorname{cl}_\\cup \\big ( \\big\\ {    \\{\\tuple{0,0}\\ } , \\ { \\tuple{0,1}\\ } , \\ { \\tuple{1,1}\\ } \\big\\ } \\big ) \\end{aligned}\\ ] ] where we observe that the set @xmath399 is obtained as the intersection @xmath400 .",
    "this correctness kernel @xmath396 can be therefore represented as @xmath401 thus , it turns out that @xmath396 is a proper abstraction of the boolean abstraction @xmath84 that , for example , is not able to express precisely the property @xmath402 .",
    "it is interesting to compare this correctness kernel @xmath396 with ball et al.s  @xcite cartesian abstraction of @xmath84 .",
    "the cartesian abstraction is defined as @xmath403 where @xmath404 is the componentwise ordering between tuples of values in @xmath405 ordered by @xmath406 and @xmath407 ( @xmath408 is a bottom element that represents the empty set of states ) .",
    "the concretization function @xmath409 is as follows : @xmath410 it turns out that these two abstractions are not comparable . for instance , @xmath411 represents @xmath412 which is instead not represented by @xmath396 , while @xmath413 represents @xmath414 which is not represented in @xmath58 . however , while the correctness kernel guarantees no loss of information in analyzing the program @xmath236 ( and therefore the analysis with @xmath396 concludes that @xmath160 can not be reached ) , the analysis of @xmath236 with the cartesian abstraction @xmath58 is inconclusive because : @xmath415 where @xmath416 , so that at the exit of the do - while loop one can not infer with @xmath58 that line @xmath160 is unreachable .",
    "few examples of abstraction simplifications are known .",
    "a general notion of domain simplification and compression in abstract interpretation has been introduced in @xcite as a formal dual of abstraction refinement .",
    "this duality has been further exploited in @xcite to include semantics transformations in a general theory for transforming abstractions and semantics based on abstract interpretation .",
    "our domain transformation does not fit directly in this framework . following @xcite ,",
    "given a property @xmath417 of abstract domains , the so - called core of an abstract domain @xmath0 , when it exists , provides the most concrete simplification of @xmath0 that satisfies the property @xmath417 , while the so - called compressor of @xmath0 , when it exists , provides the most abstract simplification of @xmath0 that induces the same refined abstraction in @xmath417 as @xmath0 does .",
    "examples of compressors include the least disjuctive basis @xcite , where @xmath417 is the abstract domain property of being disjunctive , and examples of cores include the completeness core @xcite , where @xmath417 is the domain property of being complete for some semantic function .",
    "the correctness kernel defined in this paper is neither an instance of a domain core nor an instance of a domain compression .",
    "the first because , given an abstraction @xmath0 , the correctness kernel of @xmath0 characterizes the most abstract domain that induces the same best correct approximation of a function @xmath40 on @xmath0 , whilst the notion of domain core for the domain property @xmath418 of inducing the same b.c.a .  as @xmath0 would not be meaningful , as this would trivially yield @xmath0 itself .",
    "the second because there is no ( unique ) maximal domain refinement of an abstract domain which induces the same property @xmath418 .",
    "the egas methodology opens some stimulating directions for future work , such as ( 1 )  the formalization of a precise relationship between egas and cegar and ( 2 )  an experimental evaluation of the integration in the cegar loop of the egas - based refinement strategy of section  [ egas ] .",
    "it is here useful to recall that some work formalizing cegar in abstract interpretation has already been done  @xcite . on the one hand",
    ", @xcite shows that cegar corresponds to iteratively compute a so - called complete shell @xcite of the underlying abstract model @xmath0 with respect to the concrete successor transformer , while @xcite formally compares cegar with an abstraction refinement strategy based on the computations of abstract fixpoints in an abstract domain .",
    "these works can therefore provide a starting point for studying the relationship between egas and cegar in a common abstract interpretation setting .",
    "this work was carried out during a visit of the authors to the equipe `` abstraction '' lead by p.  and r.  cousot , at cole normale suprieure , paris .",
    "this work was partially supported by the university of padova under the projects aviamo and becom ."
  ],
  "abstract_text": [
    "<S> in static analysis , approximation is typically encoded by abstract domains , providing systematic guidelines for specifying approximate semantic functions and precision assessments . however , it may happen that an abstract domain contains redundant information for the specific purpose of approximating a given semantic function modeling some behavior of a system . </S>",
    "<S> this paper introduces correctness kernels of abstract interpretations , a methodology for simplifying abstract domains , i.e.removing abstract values from them , in a maximal way while retaining exactly the same approximate behavior of the system under analysis . </S>",
    "<S> we show that , in abstract model checking and predicate abstraction , correctness kernels provide a simplification paradigm of the abstract state space that is guided by examples , meaning that it preserves spuriousness of examples ( i.e. , abstract paths ) . </S>",
    "<S> in particular , we show how correctness kernels can be integrated with the well - known cegar ( counterexample - guided abstraction refinement ) methodology . </S>"
  ]
}