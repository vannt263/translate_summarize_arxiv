{
  "article_text": [
    "a cyber - physical system ( cps ) is a mechanism controlled or monitored by computer - based algorithms",
    ". examples of cps include smart grid , autonomous automobile systems , medical monitoring , process control systems , distributed robotics , and automatic pilot avionics , etc .",
    "the connection between the cyber part and the physical part heavily relies on communication networks , which has been raising a major security concern , as different types of cyber attacks can tamper the data collection processes and interfere safety critical decision making processes , which may cause irreparable damadges to the physical systems being controlled and to people who depend on those systems .",
    "+ there has been a growing number of publications addressing the cyber security issues from both the computer science community , which focuses on the computer computation related issues , and the systems control community , which focuses on issues related to the system dynamics affected by cyber attacks .",
    "recently , more and more efforts have been made in classifying different types of malicious attacks , assuming that the attackers are sufficiently intelligent @xcite @xcite , instead of merely just generating random failures , which is well studied in the fields of reliability and fault tolerant control .",
    "typically , an intelligent attacker requires _",
    "system knowledge _ , and abilities for _ resource disclosure _ and _ resource disruption _ in order to carry out a successful attack , which is covert to a system user until the attacker s goal of causing a damage to the system is achieved .",
    "so _ covertness _ and _ damage infliction _ are two major characteristics of a successful attack . by analyzing different intelligent cyber attacks",
    ", proper countermeasures may be developed to prevent a target system from being harmed by a specific type of attacks .",
    "+ in this paper we study a special type of data deception attacks in the discrete - event system framework , where an attacker can intercept sensor measurements ( or observations ) modeled by observable events and alter them arbitrarily but with an upper bound imposed on the length of each altered observation sequence . by sending those altered observation sequences to a given supervisor",
    ", whose function is known to the attacker in advance , the attacker can deliberately and covertly guide the system to move into some undesirable states without making any change to the supervisor .",
    "the key challenge is how to `` fool '' the supervisor to make it believe that the system is operating correctly , while using the supervisor s own control functions to carry out the attack , i.e. , to lead the system move into a bad state . to this end , we first propose the concept of _ attack under bounded sensor reading alterations _",
    "( absra ) , which can be modelled as a finite - state transducer , possessing the properties of covertness , damadge infliction and control feasibility under partial observations .",
    "then we show that the supremal ( or least restrictive ) absra exists and is computable via a specific synthesis algorithm , as long as both the plant model @xmath0 and the given supervisor @xmath1 are finitely representable . upon this novel absra synthesis algorithm",
    ", we present a supervisor synthesis algorithm , which can ensure that a nonempty synthesized supervisor will be `` robust '' to any absra , in the sense that such an attack will either reveal itself to the supervisor due to abnormal system executions ( so that proper contingent actions can be taken by the supervisor , which is nevertheless outside the scope of this paper ) or will not be able to lead the system to a bad state ( i.e. , no damadge will be inflicted ) .",
    "+ our construction of an absra model as a transducer is inspired by some recent work on opacity enforcement @xcite , which aims to use observable event insertions to prevent a potential attacker from correctly determining the actual state of a target system .",
    "due to the different objectives of two works , the modeling details and synthesis algorithms are completely different .",
    "there have been some works on cyber attack detection and prevention in the discrete - event community @xcite @xcite @xcite , mainly from an adaptive fault tolerant control point of view , which heavily rely on real - time fault diagnosis to identify the existence of an attack and then take necessary robust or adaptive supervisory control actions . in those works the intelligence of an attacker",
    "is not considered , and an attack is treated as a fault . as a contrast , we do not rely on real time attack detection , but rely on prior knowledge of attack models , and simply build attack - robustness features into a supervisor to ensure that the supervisor will not be affected by any absra unnoticeably .",
    "it is this robust control nature distinguishes our works from existing des - based cyber attack detection and prevention approaches , which fall in the adaptive control domain . +",
    "the remainder of the paper is organized as follows . in section",
    "ii we review the basic concepts and operations of discrete event systems , and formulate an absra synthesis problem , which is then solved in section iii , where we show that the supremal absra exists and computable . in section iv we present an algorithm to synthesize a supervisor , which is robust to any absra .",
    "a simple yet realistic example runs through the entire paper to illustrate all relevant concepts and algorithms .",
    "conclusions are drawn in section v.",
    "in this section we first recall some standard concepts used in the ramadge - wonham supervisory control paradigm .",
    "then we introduce the concept of absra , followed by a concrete absra synthesis algorithm , which reveals that the supremal absra is computable , as long as both the plant model and the given supervisor are regular .      given an arbitrary finite alphabet @xmath2 , let @xmath3 be the free monoid with the empty string @xmath4 being the unit element and the string concatenation being the monoid operation .",
    "given two strings @xmath5 , @xmath6 is called a _",
    "prefix substring _ of @xmath7 , written as @xmath8 , if there exists @xmath9 such that @xmath10 , where @xmath11 denotes the concatenation of @xmath6 and @xmath12 .",
    "any subset @xmath13 is called a _",
    "language_. the _ prefix closure _ of @xmath14 is defined as @xmath15 . given two languages @xmath16 , let @xmath17 denote the concatenation of two sets .",
    "let @xmath18 .",
    "a mapping @xmath19 is called the _",
    "natural projection _ with respect to @xmath20 , if    1 .",
    "@xmath21 , 2 .",
    "@xmath22 3 .",
    "@xmath23 .    given a language @xmath13 , @xmath24 .",
    "the inverse image mapping of @xmath25 is @xmath26 given @xmath27 and @xmath28 , the _ synchronous product _ of @xmath29 and @xmath30 is defined as @xmath31 , where @xmath32 and @xmath33 are natural projections .",
    "clearly , @xmath34 is commutative and associative . +",
    "a given target plant is modelled as a _",
    "deterministic finite - state automaton _ , @xmath35 , where @xmath36 stands for the state set , @xmath2 for the alphabet , @xmath37 for the ( partial ) transition function , @xmath38 for the initial state and @xmath39 for the marker state set .",
    "we follow the notation system in @xcite , and use @xmath40 to denote that the transition @xmath41 is defined . for each state",
    "@xmath42 , let @xmath43 be the set of events enabled at @xmath44 in @xmath0 .",
    "the domain of @xmath45 can be extended to @xmath46 , where @xmath47 for all @xmath42 , and @xmath48 .",
    "the _ closed _ behavior of @xmath0 is defined as @xmath49 , and the _ marked _ behavior of @xmath0 is @xmath50 .",
    "@xmath0 is _ nonblocking _ if @xmath51 .",
    "we assume that the marker state set @xmath52 is partitioned into two disjoint sets @xmath53 , where @xmath54 is the set of _ desirable _ states and @xmath55 denotes the set of _ bad _ states .",
    "+ we now recall the concept of supervisors .",
    "let @xmath56 , where disjoint @xmath57 ( @xmath58 ) and @xmath59 ( @xmath60 ) denote respectively the sets of _ controllable _ ( _ observable _ ) and _ uncontrollable _ ( _ unobservable _ ) events , respectively .",
    "let @xmath61 be the collection of all _ control patterns_. a _",
    "( feasible ) supervisory control map of @xmath0 under partial observation @xmath62 _ is defined as @xmath63 , where @xmath64 for each @xmath65 , @xmath66 is interpreted as the set of events allowed to be fired after @xmath6 .",
    "thus , a supervisory control map will not disable any uncontrollable events , and will impose the same control pattern after strings , which can not be distinguished based on observations .",
    "let @xmath67 denote the closed - loop system of @xmath0 under supervision of @xmath68 , i.e. ,    * @xmath69 , * @xmath70 , * @xmath71 .",
    "the control map @xmath68 is _ finitely representable _ if @xmath67 can be denoted by a finite - state automaton , say @xmath72 such that    * @xmath73 and @xmath74 , where ` @xmath34 ' is automaton product @xcite , * @xmath75 , * @xmath76 .",
    "it has been shown that , as long as a closed - loop language @xmath77 is _ controllable _ @xcite and _ observable _ @xcite , there always exists a finitely - representable supervisory control map @xmath68 such that @xmath78 and @xmath79 . from now on we assume that @xmath67 is finitely representable by @xmath1 , which is called a _ supervisor_. we assume that @xmath1 is _ legal _ in the sense that @xmath80 , i.e. , under the supervision of @xmath1 , the plant @xmath0 should never enter any bad marker state .",
    "we assume that an attacker can intersept each observable event generated by the plant @xmath0 , and replace it by a sequence of observable events from @xmath58 in order to `` fool '' the given supervisor @xmath1 , whose function is known to the attacker . considering that in practice any event occurance takes an unnegligible amount of time , it is impossible for an attacker to insert an arbitrarily long observable sequence to replace a received observable event . for this reason , we assume that there exists a known natural number @xmath81 such that the length of any observable sequence that the attacker can insert is no more than @xmath82 .",
    "let @xmath83 be the set of all such bounded observable sequences , where @xmath84 denotes the length of @xmath6 , and by convention , @xmath85 .",
    "we model a sensor attack as a finite state transducer @xmath86 , where @xmath87 is the state set , @xmath2 the input alphabet , @xmath88 the output alphabets , @xmath89 the initial state , @xmath90 the marker state set , which is specifically set as @xmath91 , and @xmath92 the ( partial ) transition map , where for all @xmath93 and @xmath94 , @xmath95 , i.e. , at each state @xmath96 all unobservable events are self - looped with @xmath4 as the output .",
    "this is natural because an attacker can only observe observable events , thus , will not make any move upon unobservable events . we still keep unobservable events here to make it easy for us for subsequent technical development",
    "clearly , @xmath97 .",
    "let @xmath98 and @xmath99 be the _ input _ and _ output _ maps , respectively , where for each @xmath100 , @xmath101 and @xmath102 .",
    "+ the basic procedure of an attack is to intercept every single observable event @xmath103 generated by the plant @xmath0 , replace it with some observable string @xmath104 , and send @xmath12 to the supervisor @xmath1 , in order to trick @xmath1 to issue a control command @xmath105 that may drive the plant @xmath0 towards a bad marker state .",
    "this attack procedure is depicted in figure [ fig : cyber - security-0 ] .",
    "the sequential composition of the attack @xmath106 and the supervisor @xmath1 essentially forms a new supervisor , denoted as @xmath107 , which receives an observable output @xmath103 and generates a control command @xmath105 .",
    "the exact definition of this new supervisor reveals the nature of the attack , which is given below . the _ sequential composition _ of @xmath106 and @xmath1 is a deterministic finite state transducer @xmath108 , where @xmath109 denotes the deadlocking dump state , and for each @xmath110 , @xmath111 , @xmath112 if one of the following holds ,    * @xmath113 , * @xmath114 .    for each @xmath115 , @xmath111 , @xmath116 if @xmath117 but @xmath118 is undefined .",
    "thus , all transitions that go to the dumpt state @xmath109 may potentially reveal the attack , which , for an intelligent attack , should be avoided .",
    "+ the _ impact _ of @xmath106 on the closed - loop system @xmath119 is captured by the composition of the plant @xmath0 and the new supervisor @xmath107 , i.e. , @xmath120 where for each @xmath121 , @xmath111 , @xmath122 if @xmath123 and @xmath124 . clearly , @xmath125 is also a transducer , and it is not difficult to check that @xmath126 where `` = '' is in the sense of des - isomorphism , and @xmath127 denotes a function mapping one transducer to another transducer by simply marking every state . in other words , if @xmath106 is an attack model for the system @xmath119 , then @xmath128 is also an attack model , which has the same attack effect as that of @xmath106 on @xmath119 . since @xmath129 , we call @xmath130 a _ canonical attack _ with respect to @xmath119 .",
    "since for any attack , there exists a canonical attack , which has the same attack effect , from now on we only focus on canonical attacks . on the other hand , we will see that @xmath106 usually is stucturally simpler than its canonical one @xmath130 , whereas the latter is easier to compute .",
    "an interesting question is how to synthesize a simplified attack model @xmath106 from a given canonical attack model @xmath130 , which bears some similarity to the problem of supervisor reduction @xcite , and will be addressed in our future works .",
    "+ to illustrate the aforementioned concepts , let us go through a simple single - tank example depicted in figure [ fig : cyber - security-1 ] , which consists of        one water supply source whose supply rate is @xmath131 , one tank , and one control valve at the bottom of the tank controlling the outgoing flow rate @xmath132 , whose value depends on the valve opening and the water level @xmath133 .",
    "we assume that the valve can only be fully open or fully closed to simplify our illustration , and in case of a full opening , the water level @xmath133 can only go down .",
    "the water level @xmath133 can be measured , whose value can trigger some predefined events , denoting the water levels : _ low _ ( h = l ) , _ medium _ ( h = m ) , _ high _ ( h",
    "= h ) , and _ extremely high _ ( h = eh ) .",
    "we construct a simple discrete - event model of the system depicted in figure [ fig : cyber - security-2 ] ,    , scaledwidth=90.0% ]    where the alphabet @xmath2 contains all events shown in the figure .",
    "all events are observable , i.e. , @xmath134 . only the actions of opening the valve ( @xmath135 ) and closing the valve ( @xmath136 ) are controllable , and all water level events are uncontrollable . in the model",
    "we use a shaded oval to denote a marker state , i.e. , state 5 and state 9 in figure [ fig : cyber - security-2 ] .",
    "assume that we do not want the water level to be extremely high , i.e. , the event h = eh should not occur .",
    "thus , state 9 is a bad marker state , i.e. , @xmath137 and @xmath138 . to prevent state 9 from being reached ,",
    "we compose a requirement @xmath139 shown in figure [ fig : cyber - security-3 ] , whose alphabet is @xmath140h = l , h = m , h = h , h = eh@xmath141 , but the event h = eh is never allowed in the model .",
    "a supervisor @xmath1 can be synthesized by using the standard ramadge - wonham supervisory control paradigm , which is also depicted in figure [ fig : cyber - security-3 ] .",
    "( left ) and the supervisor @xmath1 ( right),scaledwidth=90.0% ]    it is clear that the supervisor @xmath1 only opens the valve when the water level is high , i.e. , it disables the event @xmath136 at state 6 when the event h = h occurs .",
    "our intuition tells us that if an attack always change events of h = m , h = h , h = eh to the event h = l , then the supervisor will not prevent the water level from reaching the extreme high level , i.e. , the event h = eh will happen . for this reason , we conjecture an attack model @xmath106 shown in figure [ fig : cyber - security-4 ] , where water levels will be altered to h = l , whereas all other events will remain unchanged .",
    "( left ) and the sequential composition @xmath107 ( right),scaledwidth=60.0% ]    the sequential composition @xmath107 indicates that , no matter which water level is reached , the attack @xmath106 always sends h = l to the supervisor @xmath1 , which tricks it to believe that it is safe to allow the valve to be either closed or opened .",
    "the impact of @xmath106 on the closed - loop system @xmath119 is depicted in figure [ fig : cyber - security-5 ] .",
    ", scaledwidth=90.0% ]    by marking every state in @xmath142 we obtain a canonical attack model @xmath143 .",
    "+    [ prop0](1 ) @xmath144 ; ( 2 ) @xmath145 ; ( 3 ) @xmath146 , @xmath147.@xmath148    proof : by the above definition of sequential composition , the proposition follows.@xmath149 +    [ prop1]given two attacks @xmath150 and @xmath151 with the same input alphabet @xmath2 and output alphabet @xmath88 , assume that @xmath152",
    ". then we have @xmath153.@xmath148    proof : by the above definition of sequential composition , the proposition follows.@xmath149 + given two attacks @xmath150 and @xmath151 with the same input alphabet @xmath2 and output alphabet @xmath88 , let @xmath154 be their union , which is a deterministic finite - state transducers . then by the definition of transducer union , we have @xmath155 . +    [ prop2]@xmath156.@xmath148    proof : since @xmath157 and @xmath158 , by prop .",
    "[ prop1 ] we have @xmath159 . to show the other direction , for each string @xmath160 , by the definition of the sequential composition , we know that @xmath161 .",
    "thus , either @xmath162 or @xmath163 , which means either @xmath164 or @xmath165 .",
    "thus , @xmath166 , which concludes the proof.@xmath149 + so far we have introduced a simple sensor attack model , and explained how this attack affects the closed - loop system .",
    "but we have not described what kind of sensor attacks can be considered intelligent .",
    "next , we will introduce the concept of absra .",
    "let @xmath62 be the natural projection .",
    "an intelligent canonical attack needs to possess the following properties :    1 .",
    "its insertions must be covert to the given supervisor , i.e. , @xmath167 namely the supervisor will not see any unexpected observable sequences from the attack .",
    "2 .   any of its insertion sequence may potentally cause damages to @xmath0 , i.e. , @xmath168 namely any sequence of insertions by the attack will cause @xmath0 to reach some bad state eventually .",
    "a weaker version of this property is described below : @xmath169 which says that the attack @xmath106 will tamper the absolute correctness of the supervisor @xmath1 so that there exists some possibility that the system may reach some bad marker state .",
    "3 .   @xmath107 forms a standard supervisor for the plant @xmath0 that enforces normality @xcite , i.e. , @xmath170 and @xmath171 which denotes that at each state the attack will not intervene the event enablement by the supervisor because we consider only sensor attacks , not actuator attacks .",
    "we call a nonempty model @xmath106 satisfying the aforementioned four properties ( 1)-(4 ) an _ attack with bounded sensor reading alterations _ ( absra ) of @xmath119 . + it is not difficult to check that the attack @xmath106 shown in figure [ fig : cyber - security-4 ] does not satisfy property ( 1 ) because @xmath1 can not fire @xmath136 before h = l , but @xmath106 can .",
    "nevertheless , the sequential composition @xmath107 satisfies all three properties , thus , is an absra . by the aforementioned discussions , we know that the canonical attack model @xmath172 is also an absra . +    [ thm1]given a plant @xmath0 and a legal supervisor @xmath1 , let @xmath173 be a ( possibly infinite ) collection of absra s with respect to @xmath119",
    ". then @xmath174 satisfies properties ( 1)-(4).@xmath148    proof : by prop .",
    "[ prop2 ] , we know that @xmath175 .",
    "we now verify that @xmath174 satisfies all four properties .",
    "+ ( a ) since for each @xmath176 , @xmath177 is an absra , we have that @xmath178 thus , by prop .",
    "[ prop2 ] we have that @xmath179 ( b ) in addition , we have that for each @xmath176 , @xmath180 thus , by prop .",
    "[ prop2 ] we have @xmath181 ( c ) since for each @xmath176 , we have @xmath182 we get @xmath183 the last property ( 4 ) can be easily checked .",
    "thus , @xmath174 satisfies all four properties , and the theorem follows.@xmath149 + theorem [ thm1 ] only implies that the least restrictive ( or supremal ) attack language exists .",
    "but it is not clear whether this supremal language is regular , i.e. , whether it can be recognized by a finite - state transducer .",
    "therefore , at this moment the existance of the supremal absra is still unknown .",
    "we now state our main problem in this paper . +    given a plant @xmath0 and a legal supervisor @xmath1 , design an absra @xmath106.@xmath148",
    "+    in the next section we will show that the supremal attack language is regular , i.e. , indeed the supremal absra exists , and is computable .",
    "we first recall the concepts of controllability @xcite , and normality @xcite . because we deal with both finite - state automata and finite - state transducers , to make notations simple , we introduce a general purpose alphabet @xmath184 , which can be either @xmath185 or @xmath186 , depending on a specific application context .",
    "let @xmath187 and @xmath188 be an uncontrollable alphabet and an observable alphabet respectively , where if @xmath189 then @xmath190 .",
    "let @xmath191 be the natural projection . in case that @xmath189 , we have @xmath192 , @xmath193 if @xmath103 , or @xmath4 otherwise , and @xmath194 . when we mention a finite - state transitional structure @xmath195 , we mean that @xmath195 is either a finite - state automaton or a finite - state transducer . +    [ def1]given a finite - state transitional structure @xmath195 , a sublanguage @xmath196 is _ controllable _ w.r.t . @xmath195 and",
    "@xmath197 , if @xmath198.@xmath148 +    [ def2]given a finite - state transitional structure @xmath195 , a sublanguage @xmath196 is _ normal _ w.r.t . @xmath195 and",
    "@xmath199 , if @xmath200.@xmath148 +    given a finite - state transitional structure @xmath195 , whose alphabet is @xmath184 , and a requirement @xmath201 , let @xmath202 by an argument similar to the one used in @xcite , we can derive that the supremal controllable and normal sublanguage of @xmath203 exists , denoted as @xmath204 , such that for all @xmath205 , we have @xmath206 .",
    "+ in our setup , an attack is able to arbitrarily alter an observable event .",
    "thus , each event @xmath111 is considered controllable , as the attack can choose not to use this alteration . under this consideration , the uncontrollable alphabet @xmath197 is actually empty .",
    "thus , in the following attack model synthesis , we do not explicitly require controllability .",
    "this may sound a bit unusual because we do have an uncontrollable alphabet @xmath59 for the plant @xmath0 - how those uncontrollable events affect the attack model synthesis ?",
    "if we carefully check the properties of an absra , we can see that property ( 4 ) actually implicitly enforces controllability with respect to @xmath59 because it requires the attack not to change the event enablement of the supervisor @xmath1 at the current state , and since by default the supervisor @xmath1 ensures controllability with respect to @xmath59 , and so does the attack model .",
    "+ assume that there exists @xmath207 , which denotes a set of _ protected _ observable events that can not be altered by an absra , i.e. , given an attack model @xmath86 , for all @xmath94 , @xmath208 , we have that @xmath209 .",
    "we now undertake the following absra synthesis procedure . + * procedure 1 : ( absra synthesis ) *    1 .",
    "input : a plant @xmath35 , a supervisor @xmath210 and @xmath211 .",
    "2 .   construct a single - state transducer @xmath212 , where @xmath213 and the transition map @xmath214 encodes transitions labeled by a subset of @xmath215 , denoting all observable event alterations that the attack wants to consider .",
    "3 .   let @xmath216 be a requirement .",
    "4 .   undertake the following iteration on @xmath217 1 .",
    "compute @xmath218 .",
    "2 .   check property ( 4 ) in the definition of absra .",
    "if it holds , then go to step 5 ) . otherwise , set @xmath219 and continue the iteration on @xmath220 .",
    "output : @xmath221 , which recognizes @xmath222.@xmath148 +    procedure 1 terminates finitely.@xmath148    proof : assume that @xmath223 is recognized by a transducer @xmath224 , whose state set is @xmath225 .",
    "then @xmath226 is recognizable by a transducer , say @xmath227 , whose state set is a subset of @xmath228 .",
    "it is not difficult to check that for all @xmath229 , if they hit the same state in @xmath227 , then we know that @xmath230 if and only if @xmath231 in other words , @xmath232 if and only if @xmath233 . thus , for each state in @xmath227 , either all strings hitting that state are in @xmath234 or none of them are in @xmath234 , namely @xmath234 is recognized by a sub - transducer @xmath235 of @xmath227 .",
    "suppose the state set of @xmath235 is @xmath236 . by the property of automaton composition ,",
    "we know that there exists a transducer @xmath237 recognizing @xmath238 such that the state set of @xmath237 is a subset of @xmath239 . since @xmath236 , we know that @xmath237 is des - isomorphic to a sub - transducer of @xmath227 . by using the same argument , we can check that each @xmath240 is recognized by a transducer , which is des - isomorphic to a sub - transducer of @xmath227 .",
    "in addition , the state sets of those sub - transducers form a monotonic non - increasing sequence with respect to set inclusion . thus , in a finite number of iterations , a fixed sub - transducer will be reached , whose language is @xmath240 .",
    "this means procedure 1 must terminate finitely.@xmath149 +    [ lem1]let @xmath240 and @xmath221 be computed in procedure 1 . then @xmath241.@xmath148    proof : by the proof of lemma 1 we know that @xmath221 is des - isomorphic to the prefix closure of a sub - transducer of @xmath242 . then by the definitions of sequential composition and transducer product , the lemma follows .",
    "@xmath149 +    @xmath221 obtained in procedure 1 is the supremal absra of @xmath119 .",
    "@xmath148    proof : ( a ) we first show that @xmath221 is an absra , i.e. , @xmath221 satisfies properties ( 1)-(4 ) .",
    "it is clear that when the algorithm terminates , property ( 4 ) must hold .",
    "so we only focus on properties ( 1)-(3 ) . by the definition of @xmath221 and prop . 1",
    ", we know that @xmath243 by lemma 2 , we have @xmath244 . since @xmath245 and @xmath246 , by prop .",
    "1 we have @xmath247    for the third property , by lemma 2 we know that @xmath248 .",
    "thus , by the definition of normality and the nonblocking property associated with a sub - transducer of @xmath242 , which recognizes @xmath240 , we have @xmath249 this concludes our proof that @xmath221 is an absra . + ( b ) next , we show that @xmath221 is the supremal absra .",
    "let @xmath130 be an absra of the system .",
    "clearly , @xmath250 . due to the controllability of @xmath1 and the assumption that @xmath130 is an absra , i.e. , it must satisfy property ( 4 ) , it is easy to check that @xmath251 is controllable w.r.t .",
    "@xmath252 and @xmath59 . since @xmath130 must satisfy property ( 3 ) , we know that @xmath251 must be normal w.r.t . @xmath252 and @xmath58",
    "in addition , @xmath130 satisfies property ( 4 ) .",
    "thus , we can easily detive that @xmath253 , namely , @xmath254 .",
    "this means @xmath255 , which concludes the proof of the theorem .",
    "@xmath149 + as an illustration , we apply procedure 1 to the plant @xmath0 shown in figure [ fig : cyber - security-2 ] and the supervisor @xmath1 shown in figure [ fig : cyber - security-3 ] .",
    "we can see that the sensor attack model @xmath106 in figure [ fig : cyber - security-4 ] is actually @xmath256 in procedure 1 because all events in the model are observable . the composition @xmath257 is shown in figure [ fig : cyber - security-4 ] .",
    "the outcome of @xmath258 is shown in figure [ fig : cyber - security-5 ] , which is isomorphic to @xmath0 .",
    "this is not surprising because any string in @xmath259 may be potentially extended to the bad marker state .",
    "the requirement @xmath260 is simply the same as @xmath258 . clearly , we know that @xmath240 is recognizable by a transducer shown in figure [ fig : cyber - security-6 ] , which is almost the same as @xmath258 , except that the only marker state is that bad marker state due to the requirement @xmath260 .",
    ", scaledwidth=90.0% ]    since all events are observable , from @xmath261 we can derive that @xmath262 .",
    "thus , @xmath221 can be chosen by marking every state in @xmath258 , i.e. , @xmath263 , which means @xmath221 is actually a canonical attack of @xmath256 with respect to @xmath119 . by theorem 2 we know that @xmath221 is the supremal absra of @xmath119 .",
    "in the previous section we discuss how to design an absra model to interrupt a given system s operations from an attacker s point of view . in this section",
    "we present a synthesis approach to design a supervisor , which is `` robust '' to any absra in the sense that either the attack is not covert or incurs no damage to the system .",
    "+ recall that an absra affects a target system @xmath119 by altering the sequence of observable events , which tricks @xmath1 to issue commands improperly . by protecting observable events from being altered unnoticeably can in principle effectively deter an absra .",
    "an observable event in this framework denotes a specific set of strongly associated measurements .",
    "for example , in the aforementioned single - tank system , the event h = h may either be associated with one simple water level measurement or possibly several sensor measurements such as the actual water level , and the corresponding pressure on the bottom of the tank - the more sensor measurements associated with the event , the harder for an attack to alter the event without being detected . when applying suitable encryption techniques , it is even more complicated for an attack to complete the job .",
    "thus , it is indeed technically feasible to prevent observable events from being altered by either adopting new secure information transmission technologies or introducing more sensors to significantly increase the complication of altering the corresponding observable event without being detected .",
    "nevertheless , there is always a financial consideration .",
    "an attractive solution to a potential industrial user is to identify only critical observable events , which , when being protected from external alterations , will lead to a supervisor robust to any absra .",
    "+    given a plant @xmath0 , a requirement @xmath139 , and a protected observable alphabet @xmath207 , synthesize a supervisor @xmath1 such that there is no arsra of the closed - loop system @xmath119.@xmath148 +    with the same notations used in the previous section , let @xmath264 be the collection of all controllable and normal supervisors @xcite .",
    "let @xmath265 , which always exists and computable , as long as @xmath266 is regular .",
    "our goal is to design a supervisor @xmath267 such that procedure 1 returns an ampty absra @xmath221 with respect to the given protected observable alphabet @xmath211 . to this end , we present the following synthesis procedure : + * procedure 2 : ( absra - robust supervisor synthesis ) *    1 .",
    "input : a plant @xmath0 , a requirement @xmath139 and a protected observable alphabet @xmath211 .",
    "2 .   compute @xmath268 . if @xmath269 , terminate . otherwise , assume @xmath270 is recognized by a finite - state automaton @xmath271 , and continue",
    "compute @xmath221 by using procedure 1 , i.e. , computer @xmath272 .",
    "4 .   compute @xmath273 .",
    "5 .   output : a recognizer @xmath1 of @xmath274.@xmath148 +    [ thm3]given a plant @xmath0 , a requirement @xmath266 , and a protected observable alphabet @xmath211 , let @xmath1 be computed above . if @xmath275 , then we have @xmath276 , where @xmath277 is defined in procedure 1 , i.e. , there is no absra @xmath106 of @xmath119.@xmath148    proof : assume that it is not true .",
    "then there exists an absra @xmath106 such that @xmath278 , where @xmath279 .",
    "since @xmath1 is controllable and normal with respect to @xmath0 , and @xmath280 , we can get that @xmath281 . since @xmath272 , we know that @xmath282 .",
    "but on the other hand , we know that @xmath283 , i.e. , @xmath284 , which leads to a contradiction .",
    "thus , the absra @xmath106 does not exist .",
    "@xmath149 + we would like to emphasize here again that , although theorem [ thm3 ] indicates that there is no absra @xmath106 for the closed - loop system @xmath285 , it does not mean that a sensor reading alteration attack will not be carried out by an attacker .",
    "but such an attack will either reveal itself to the supervisor before it achieves its attack goal due to abnormal system executions ( so that proper contingent actions such as system shutdown can be taken by the supervisor , which is outside the scope of this paper ) or will not be able to lead the system to a bad state .",
    "+ in theorem [ thm3 ] , if @xmath286 , then with the given protected observable alphabet @xmath211 , there does not exist a supervisor @xmath1 that is absra - robust .",
    "we face the following synthesis problem . +    given a plant @xmath0 and a requirement @xmath139 ,",
    "compute a protected observable alphabet @xmath207 of the minimum size , which allows a nonempty absra - robust supervisor @xmath1 to exist.@xmath148 +    it is clear that problem 3 is solvable in the sense that it is decidable whether there exists such a @xmath211 with the minimum size because we can simply enumerate each subset @xmath287 , and apply procedure 2 on @xmath211 to compute the corresponding supervisor @xmath1 . since there is a finite number of such subsets ,",
    "this brutal - force method will terminate , and provide a protected observable alphabet of the minimum size together with the corresponding supervisor , if it exists .",
    "the computational complexity of this procedure is certainly high , which is exponential to @xmath288 , but polynomial to the sizes of @xmath0 and @xmath139 due to our adoption of normality to handle observability . if the size of @xmath58 is big , to find a computationally viable algorithm that can solve problem 3 becomes important , which will be addressed in our future works .",
    "+ we now use that simple single - tank system to illustrate how to use procedure 2 to compute an absra - robust supervisor , and how to determine a minimum protected observable alphabet , which allows the existence of an absra - robust supervisor .",
    "let @xmath289h = h@xmath141 .",
    "the model of @xmath256 and @xmath271 are shown in figure [ fig : cyber - security-7 ] .     and",
    "@xmath271,scaledwidth=90.0% ]    when we run procedure 1 , we first compute @xmath290 .",
    "the outcome is depicted in figure [ fig : cyber - security-8 ] .",
    "( right ) and @xmath290 ( left),scaledwidth=100.0% ]    we can see that @xmath290 contains no bad marker state in @xmath55 .",
    "thus , in procedure 1 we have @xmath291 , which returns @xmath292 .",
    "after that , in step 4 ) of procedure 2 , we have that @xmath293 .",
    "thus , @xmath271 is an absra - robust supervisor for @xmath0 with respect to the given @xmath211 .",
    "clearly , it is a solution to problem 3 because we can not find any other protected observable alphabet with a size smaller than 1 , which can render an absra - robust supervisor .",
    "in this paper we have first introduced the concept of absra , upon which we have shown that the supremal absra exists and computable , as long as the plant model @xmath0 and the supervisor @xmath1 are finitely representable , i.e. , their languages are regular . after that , we have brought in the problem of synthesizing an absra - robust supervisor , and shows that it is possible to find a minimum protected observable sub - alphabet , which may render an absra - robust supervisor . + it is interesting to point out that , if we replace the third property of an absra model with a weaker observability property , e.g. , the standard observability @xcite , the supremal absra may not exist any more . nevertheless , the existence of an absra is still decidable and computable ( with possibly a higher computational complexity ) , as this absra synthesis problem is equivalent to a synthesis problem of centralized supervisory control under partial observation , which has been shown solvable @xcite .",
    "fortunately , the normality property can be easily satisfied in reality , as it only requires that only observable and controllable events can be disabled in online applications - in real industrial applications , it is typical that all control commands are observable . for this reason ,",
    "the supervisor synthesis approach proposed in this paper aiming to defy absra is practically feasible .",
    "the idea of this paper was originated from a discussion between the author and prof stephane lafortune on opacity enforcement . without such an inspiring discussion , this paper would never be formed .",
    "for this reason , the author would like to thank prof lafortune for his contribution .",
    "a. a. cardenas , s. amin , and s. sastry .",
    "secure control : towards survivable cyber - physical systems . in _ proc .",
    "28th international conference on distributed computing systems workshops _ , 2008 , pp .",
    "495500 .",
    "a. teixeira , d. perez , h. sandberg , and k. h. johansson .",
    "attack models and scenarios for networked control systems . in _ proc .",
    "1st international conference on high confidence networked systems _ , 2012 , pp .",
    "5564 .",
    "l. k. carvalho , y. wu , r. kwong and s. lafortune .",
    "detection and prevention of actuator enablement attacks in supervisory control systems . in _ proc .",
    "13th international workshop on discrete event systems _",
    ", 2016 , pp ."
  ],
  "abstract_text": [
    "<S> one of the major challenges about cyber physical systems is how to prevent cyber attacks to ensure system integrity . </S>",
    "<S> there has been a large number of different types of attacks discussed in the modern control and computer science communities . in this paper </S>",
    "<S> we aim to investigate one special type of attacks in the discrete - event system framework , where an attacker can arbitrarily alter sensor readings after intercepting them from a target system in order to trick a given supervisor to issue control commands improperly , driving the system to an undesirable state . </S>",
    "<S> we first consider the cyber attack problem from an attacker point of view , and formulate an attack with bounded sensor reading alterations ( absra ) problem . </S>",
    "<S> we then show that the supremal ( or least restrictive ) absra exists and can be synthesized , as long as the plant model and the supervisor model are regular , i.e. , representable by finite - state automata . upon the synthesis of the supremal absra , we present a synthesis algorithm , which ensures that a computed supervisor will be absra - robust , </S>",
    "<S> i.e. , either an absra will be detectable or will not lead the system to an undesirable state .    </S>",
    "<S> discrete - event systems , supervisory control , cyber security , attack under bounded sensor reading alterations , partial observation , controllability </S>"
  ]
}