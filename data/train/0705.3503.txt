{
  "article_text": [
    "security protocols , in particular those for for anonymity and fair exchange , often use randomization to achieve their targets . since they usually involve more than one agent , they also give rise to concurrent and interactive activities that can be best modeled by nondeterminism .",
    "thus it is convenient to specify them using a formalism which is able to represent both _",
    "probabilistic _ and _ nondeterministic _ behavior .",
    "formalisms of this kind have been explored in both automata theory @xcite and in process algebra @xcite .",
    "see also @xcite for comparative and more inclusive overviews .    due to the presence of nondeterminism , in such formalisms",
    "it is not possible to define the probability of events in _ absolute _ terms .",
    "we need first to decide how each nondeterministic choice during the execution will be solved .",
    "this decision function is called _ scheduler_.",
    "once the scheduler is fixed , the behavior of the system ( _ relatively _ to the given scheduler ) becomes fully probabilistic and a probability measure can be defined following standard techniques .",
    "it has been observed by several researchers that in security the notion of scheduler needs to be restricted , or otherwise any secret choice of the protocol could be revealed by making the choice of the scheduler depend on it .",
    "this issue was for instance one of the main topics of discussion at the panel of csfw 2006 .",
    "we illustrate it here with an example on anonymity .",
    "we use the standard ccs notation , plus a construct of probabilistic choice @xmath0 representing a process that evolves into @xmath1 with probability @xmath2 and into @xmath3 with probability @xmath4 .    the following system _",
    "sys _ consists of one receiver @xmath5 and two senders @xmath6 which communicate via private channels @xmath7 respectively . which of the two senders is successful is decided probabilistically by @xmath5 . after reception",
    ", @xmath5 sends a signal _",
    "ok_. @xmath8 the signal _ ok _ is not private , but since it is the same in both cases , in principle an external observer should not be able to infer from it the identity of the sender ( @xmath9 or @xmath10 ) .",
    "so the system should be anonymous .",
    "however , consider a team of two attackers @xmath11 and @xmath12 defined as @xmath13 and consider the parallel composition @xmath14 .",
    "we have that , under certain schedulers , the system is no longer anonymous .",
    "more precisely , a scheduler could leak the identity of the sender via the channels @xmath15 by forcing @xmath5 to synchronize with @xmath11 on _ ok _ if @xmath5 has chosen the first alternative , and with @xmath12 otherwise .",
    "this is because in general a scheduler can see the whole history of the computation , in particular the random choices , even those which are supposed to be private .",
    "note that the visibility of the synchronization channels to the scheduler is not crucial for this example : we would have the same problem , for instance , if @xmath9 , @xmath10 were both defined as @xmath16 , @xmath5 as @xmath17 , and @xmath18 as @xmath19 .",
    "the above example demonstrates that , with the standard definition of scheduler , it is not possible to represent a truly private random choice ( or a truly private nondeterministic choice , for the matter ) with the current probabilistic process calculi .",
    "this is a clear shortcoming when we want to use these formalisms for the specification and verification of security protocols .",
    "there is another issue related to verification : a private choice has certain algebraic properties that would be useful in proving equivalences between processes .",
    "in fact , if the outcome of a choice remains private , then it should not matter at which point of the execution the process makes such choice , until it actually uses it .",
    "consider for instance @xmath11 and @xmath12 defined as follows    [ cols=\"^,^ \" , ]     process @xmath11 receives a value and then decides randomly whether it will accept the value @xmath20 or @xmath21 .",
    "process @xmath12 does exactly the same thing except that the choice is performed before the reception of the value .",
    "if the random choices in @xmath11 and @xmath12 are private , intuitively we should have that @xmath11 and @xmath12 are equivalent ( @xmath22 ) .",
    "this is because it should not matter whether the choice is done before or after receiving a message , as long as the outcome of the choice is completely invisible to any other process or observer .",
    "however , consider the parallel context @xmath23 . under any scheduler @xmath11",
    "has probability at most @xmath24 to perform @xmath25 . with @xmath12",
    ", on the other hand , the scheduler can choose between @xmath26 and @xmath27 based on the outcome of the probabilistic choice , thus making the maximum probability of @xmath25 equal to @xmath21 .",
    "the execution trees of @xmath28 and @xmath29 are shown in figure [ fig : exectrees ] .",
    "+    in general when @xmath30 represents a private choice we would like to have @xmath31 \\approx c[\\tau.p ] + _ p c[\\tau.q ]      \\label{eq : equivcontext}\\ ] ] for all processes @xmath32 and all contexts @xmath33 _ not containing replication ( or recursion)_. in the case of replication the above can not hold since @xmath34 makes available each time the choice between @xmath1 and @xmath3 , while @xmath35 chooses once and for all which of the two ( @xmath1 or @xmath3 ) should be replicated . similarly for recursion .",
    "the reason why we need a @xmath36 is explained in section [ sec : testing ] .",
    "the algebraic property ( [ eq : equivcontext ] ) expresses in an abstract way the privacy of the probabilistic choice . moreover , this property is also useful for the verification of security properties .",
    "the interested reader can find in @xcite an example of application to a fair exchange protocol . in principle",
    "( [ eq : equivcontext ] ) should be useful for any kind of verification in the process algebra style .",
    "we propose a process - algebraic approach to the problem of hiding the outcome of random choices .",
    "our framework is based on a calculus obtained by adding to ccs an internal probabilistic choice construct .",
    "this calculus , to which we refer as ccs@xmath37 , is a variant of the one studied in @xcite , the main differences being that we use replication instead than recursion , and we lift some restrictions that were imposed in @xcite to obtain a complete axiomatization .",
    "the semantics of ccs@xmath37 is given in terms of segala s _ simple probabilistic automata _",
    "@xcite .",
    "in order to limit the power of the scheduler , we extend ccs@xmath37 with terms representing explicitly the notion of scheduler .",
    "the latter interact with the original processes via a labeling system .",
    "this will allow to specify at the syntactic level ( by a suitable labeling ) which choices should be visible to schedulers , and which ones should not .",
    "the main contributions of this paper are :    * a process calculus ccs@xmath38 in which the scheduler is represented as a process , and whose power can therefore be controlled at the syntactic level . * an application of ccs@xmath38 to an extended anonymity example ( the dining cryptographers protocol , dcp ) .",
    "we also briefly outline how to extend ccs@xmath38 so to allow the definition of private nondeterministic choice , and we apply it to the dcp with nondeterministic master . to our knowledge",
    "this is the first formal treatment of the scheduling problem in dcp and the first formalization of a nondeterministic master for the ( probabilistic ) dcp . * the adaptation of the standard notions of probabilistic testing preorders to ccs@xmath38 , and the `` sanity check '' that they are still precongruences with respect to all the operators except the nondeterministic sum . for the latter we have the problem that @xmath1 and @xmath39 are must equivalent , but @xmath40 and @xmath41 are not .",
    "this is typical for the ccs @xmath42 : usually it does not preserve weak equivalences . *",
    "the proof that , under suitable conditions on the labelings of @xmath33 , @xmath39 and @xmath43 , ccs@xmath38 satisfies the property expressed by ( [ eq : equivcontext ] ) , where @xmath44 is probabilistic testing equivalence .      the works that are most closely related to ours are @xcite . in those paper",
    "the authors consider probabilistic automata and introduce a restriction on the scheduler to the purpose of making them suitable to applications in security protocols .",
    "their approach is based on dividing the actions of each component of the system in equivalence classes ( _ tasks _ ) .",
    "the order of execution of different tasks is decided in advance by a so - called _ task scheduler_. the remaining nondeterminism within a task",
    "is solved by a second scheduler , which models the standard _ adversarial scheduler _ of the cryptographic community .",
    "this second entity has limited knowledge about the other components : it sees only the information that they communicate during execution .",
    "in contrast to the above approach , our definition of scheduler is based on a labeling system , and the same action can receive different labels during the execution , so our `` equivalence classes '' ( schedulable actions with the same label ) can change dynamically .",
    "however we do nt know at the moment whether this difference determines a separation in the expressive power .",
    "the main difference , anyway , is that our framework is process - algebraic and we focus on testing preorders , their congruence properties , and the conditions under which certain equivalences hold .",
    "another work along these lines is @xcite , which uses partitions on the state - space to obtain partial - information schedulers .",
    "however in that paper the authors consider a synchronous parallel composition , so the setting is rather different .      in the next section we briefly recall some basic notions . in section [ sec : ccss ] we define a preliminary version of the language ccs@xmath38 and of the corresponding notion of scheduler . in section [ sec : expressiveness ] we compare our notion of scheduler with the more standard `` semantic '' notion , and we improve the definition of ccs@xmath38 so to retrieve the full expressive power of the semantic schedulers . in section [ sec : testing ]",
    "we study the probabilistic testing preorders , their compositionality properties , and the conditions under which ( [ eq : equivcontext ] ) holds .",
    "section [ sec : application ] presents an application to security .",
    "section [ sec : conclusion ] concludes .",
    "in this section we briefly recall some preliminary notions about the simple probabilistic automata and ccs@xmath37 .",
    "a _ discrete probability measure _ over a set @xmath45 is a function @xmath46 $ ] such that @xmath47 and @xmath48 where @xmath49 is a countable family of pairwise disjoint subsets of @xmath45 .",
    "the set of all discrete probability measures over @xmath45 will be denoted by @xmath50 .",
    "we will denote by @xmath51 ( called the _ dirac measure _ on @xmath52 ) the probability measure that assigns probability @xmath21 to @xmath53 .",
    "we will also denote by @xmath54\\mu_i$ ] the probability measure obtained as a convex sum of the measures @xmath55 .",
    "a _ _ simple probabilistic automaton _",
    "_ is a tuple @xmath56 where @xmath9 is a set of states , @xmath57 is the _ initial state _ , @xmath11 is a set of actions and @xmath58 is a _ transition relation_. intuitively , if @xmath59 then there is a transition from the state @xmath60 performing the action @xmath61 and leading to a distribution @xmath62 over the states of the automaton .",
    "the idea is that the choice of transition among the available ones in @xmath63 is performed nondeterministically , and the choice of the target state among the ones allowed by @xmath62 ( i.e. those states @xmath64 such that @xmath65 ) is performed probabilistically .",
    "a probabilistic automaton @xmath66 is _ fully probabilistic _ if from each state of @xmath66 there is at most one transition available .",
    "an execution @xmath67 of a probabilistic automaton is a ( possibly infinite ) sequence @xmath68 of alternating states and actions , such that @xmath69 , and for each @xmath70 @xmath71 and @xmath72 hold .",
    "we will use @xmath73 to denote the last state of a finite execution @xmath67 , and @xmath74 and @xmath75 to represent the set of all the finite and of all the executions of @xmath66 , respectively .    a _ scheduler _ of a probabilistic automaton @xmath76",
    "is a function @xmath77 such that @xmath78 implies that @xmath79 .",
    "the idea is that a scheduler selects a transition among the ones available in @xmath63 and it can base his decision on the history of the execution .",
    "the _ execution tree _ of @xmath66 relative to the scheduler @xmath80 , denoted by @xmath81 , is a fully probabilistic automaton @xmath82 such that @xmath83 , @xmath84 , @xmath85 , and @xmath86 if and only if @xmath87 for some @xmath62 and @xmath88 .",
    "intuitively , @xmath81 is produced by unfolding the executions of @xmath66 and resolving all deterministic choices using @xmath80 .",
    "note that @xmath81 is a simple and fully probabilistic automaton .",
    "let @xmath61 range over a countable set of _ channel names_. the syntax of ccs@xmath37 is the following : @xmath89{@{\\textrm{\\hspace{20pt}}}l@{}l@{\\textrm{\\hspace{20pt}}}l }      \\multicolumn{2}{l}{\\alpha : : = a { \\",
    "\\,|\\ \\,}\\bar{a } { \\",
    "\\,|\\ \\,}\\tau }        & \\textrm{\\textbf{prefixes } } \\\\[2pt ]        \\multicolumn{2}{l}{p , q : : = }     & \\textrm{\\textbf{processes } } \\\\[2pt ]              & \\alpha.p               & \\textrm{prefix } \\\\[2pt ]      { \\ \\,|\\ \\ , } & p { \\;|\\;}q             & \\textrm{parallel } \\\\[2pt ]      { \\ \\,|\\ \\ , } & p + q                  & \\textrm{nondeterministic choice } \\\\[2pt ]      { \\ \\,|\\ \\ , } & { \\textstyle{\\sum_{i}\\:}}p_ip_i     & \\textrm{internal probabilistic choice } \\\\[2pt ]      { \\ \\,|\\ \\ , } & ( \\nu a)p               & \\textrm{restriction } \\\\[2pt ]      { \\ \\,|\\ \\ , } & !",
    "p                     & \\textrm{replication } \\\\[2pt ]      { \\ \\,|\\ \\ , } & 0                      & \\textrm{nil } \\end{array}\\ ] ]    @xmath90            \\textrm{sum1 } &              { \\frac{\\displaystyle p { \\overset{\\alpha}{\\longrightarrow } } \\mu } { \\displaystyle p + q { \\overset{\\alpha}{\\longrightarrow } } \\mu } } &            \\textsc{par1 } &              { \\frac{\\displaystyle p { \\overset{\\alpha}{\\longrightarrow } } \\mu } { \\displaystyle p { \\;|\\;}q   { \\overset{\\alpha}{\\longrightarrow } } \\mu { \\;|\\;}q } } \\\\[20pt ]            \\textrm{com } &               { \\frac{\\displaystyle p   { \\overset{a}{\\longrightarrow } } \\delta(p ' ) \\quad q { \\overset{{\\overline{a}}}{\\longrightarrow } } { } \\delta(q')}{\\displaystyle p { \\;|\\;}q { \\overset{\\tau}{\\longrightarrow } } \\delta(p ' { \\;|\\;}q ' ) } } &               \\textrm{prob } &              { \\frac{\\displaystyle } { \\displaystyle { \\textstyle{\\sum_{i}\\ : } } p_ip_i { \\overset{\\tau}{\\longrightarrow } } { \\textstyle{\\sum_{i}\\:}}[p_i]\\delta(p_i ) } } \\\\[20pt ]            \\textrm{bang1 } &              { \\frac{\\displaystyle p   { \\overset{\\alpha}{\\longrightarrow } } \\mu } { \\displaystyle ! p   { \\overset{\\alpha}{\\longrightarrow } } \\mu { \\;|\\;}!p } } &            \\textrm{bang2 } &               { \\frac{\\displaystyle p   { \\overset{a}{\\longrightarrow } } \\delta(p_1 ) \\quad p { \\overset{{\\overline{a}}}{\\longrightarrow } } { } \\delta(p_2)}{\\displaystyle ! p { \\overset{\\tau}{\\longrightarrow } } \\delta(p_1 { \\;|\\;}p_2 { \\;|\\;}!p ) } }      \\end{array }      $ ]    we will also use the notation @xmath91 to represent a binary sum @xmath92 with @xmath93 and @xmath94 .",
    "the semantics of a ccs@xmath37 term is a probabilistic automaton defined inductively on the basis of the syntax according to the rules in figure [ fig : ccsp_sem ] .",
    "we write @xmath95 when @xmath96 is a transition of the probabilistic automaton .",
    "we also denote by @xmath97 the measure @xmath98 such that @xmath99 for all processes @xmath1 and @xmath100 if @xmath5 is not of the form @xmath101 .",
    "similarly @xmath102 such that @xmath103 .",
    "a transition of the form @xmath104 , i.e. a transition having for target a dirac measure , corresponds to a transition of a non - probabilistic automaton ( a standard labeled transition system ) .",
    "thus , all the rules of ccs@xmath37 imitate the ones of ccs except from prob .",
    "the latter models the internal probabilistic choice : a silent @xmath36 transition is available from the sum to a measure containing all of its operands , with the corresponding probabilities .",
    "note that in the produced probabilistic automaton , all transitions to non - dirac measures are silent .",
    "this is similar to the _ alternating model _",
    "@xcite , however our case is more general because the silent and non - silent transitions are not necessarily alternated . on the other hand , with respect to to the simple probabilistic automata the fact that the probabilistic transitions are silent looks as a restriction .",
    "however , it has been proved by bandini and segala @xcite that the simple probabilistic automata and the alternating model are essentially equivalent , so , being in the middle , our model is equivalent as well .",
    "in this section we present a variant of ccs in which the scheduler is explicit , in the sense that it has a specific syntax and its behavior is defined by the operational semantics of the calculus",
    ". we will refer to this calculus as ccs@xmath38 .",
    "processes in ccs@xmath38 contain labels that allow us to refer to a particular sub - process .",
    "a scheduler also behaves like a process , using however a different and much simpler syntax , and its purpose is to guide the execution of the main process using the labels that the latter provides .",
    "a _ complete process _ is a process running in parallel with a scheduler , and we will formally describe their interaction by defining an operational semantics for complete processes .",
    "we will present ccs@xmath38 in an incremental way .",
    "first we define the basic calculus ccs@xmath38 which is the same as ccs@xmath37 with the addition of the explicit scheduler .",
    "then we will perform an extensions of this basic calculus by adding choice to the scheduler so to achieve its full expressive power .",
    "finally , in section [ sec : application ] , we outline an extension of ccs@xmath38 with a second _ independent _ scheduler , to the purpose of making private certain nondeterministic choices .",
    "@xmath105{@{\\textrm{\\hspace{10pt } } } l @ { } l @{\\textrm{\\hspace{10pt } } } l }              \\multicolumn{2}{l}{i : : = 0\\,i { \\ \\,|\\ \\,}1\\,i { \\ \\,|\\ \\,}\\epsilon\\quad }    & \\textrm{\\textbf{label indexes } } \\\\[2pt ]              \\multicolumn{2}{l}{l : : =   l^{i } }                                 & \\textrm{\\textbf{labels } } \\\\[10pt ]                \\multicolumn{2}{l}{p , q : : = }     & \\textrm{\\textbf{processes } } \\\\[2pt ]                      & l{\\hspace{-2pt}:\\hspace{-2pt}}\\alpha.p           & \\textrm{prefix } \\\\[2pt ]              { \\ \\,|\\ \\ , } & p { \\;|\\;}q             & \\textrm{parallel } \\\\[2pt ]              { \\ \\,|\\ \\ , } & p + q                  & \\textrm{nondeterministic choice } \\\\[2pt ]              { \\ \\,|\\ \\ , } & l{\\hspace{-2pt}:\\hspace{-2pt}}{\\textstyle{\\sum_{i}\\:}}p_ip_i     & \\textrm{internal prob",
    ". choice } \\\\[2pt ]              { \\ \\,|\\ \\ , } & ( \\nu a)p               & \\textrm{restriction } \\\\[2pt ]              { \\ \\,|\\ \\ , } & ! p                     & \\textrm{replication } \\\\[2pt ]              { \\ \\,|\\ \\ , } & 0                      & \\textrm{nil }            \\end{array } &          \\begin{array}[t]{@{\\textrm{\\hspace{10pt}}}l@{}l@{\\textrm{\\hspace{10pt}}}l }              \\multicolumn{2}{l}{s , t : : = }      & \\textrm{\\textbf{scheduler } } \\\\[2pt ]                      & \\sigma(l).s            & \\textrm{schedule single action } \\\\[2pt ]              { \\ \\,|\\ \\ , } & \\sigma(l , l).s          & \\textrm{synchronization } \\\\[2pt ]              { \\ \\,|\\ \\ , } & 0                      & \\textrm{nil } \\\\[10pt ]                \\multicolumn{2}{l}{cp : : =   p \\parallel s }    & \\textrm{\\textbf{complete process } }          \\end{array }      \\end{array }      $ ]    let @xmath61 range over a countable set of _ channel names _ and @xmath106 over a countable set of _ atomic labels_. the syntax of ccs@xmath38 , shown in figure [ fig : syntax ] , is the same as the one of ccs@xmath37 except for the presence of labels .",
    "these are used to select the subprocess which `` performs '' a transition . since",
    "only the operators with an initial rule can originate a transition , we only need to assign labels to the prefix and to the probabilistic sum .",
    "we use labels of the form @xmath107 where @xmath106 is an atomic label and the index @xmath60 is a finite string of @xmath20 and @xmath21 , possibly empty for @xmath108 . ] .",
    "indexes are used to avoid multiple copies of the same label in case of replication , which occurs dynamically due to the the bang operator . as explained in the semantics , each time a process",
    "is replicated we relabel it using appropriate indexes .",
    "a scheduler selects a sub - process for execution on the basis of its label , so we use @xmath109 to represent a scheduler that selects the process with label @xmath106 and continues as @xmath9 . in the case of synchronization",
    "we need to select two processes simultaneously , hence we need a scheduler the form @xmath110 .",
    "a complete process is a process put in parallel with a scheduler , for example @xmath111 .",
    "note that for processes with an infinite execution path we need schedulers of infinite length .",
    "@xmath112            \\textrm{sum1 } &              { \\frac{\\displaystyle p \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\mu}{\\displaystyle p + q \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\mu } } &            \\textsc{par1 } &              { \\frac{\\displaystyle p \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\mu}{\\displaystyle   p { \\;|\\;}q \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\mu { \\;|\\;}q } } \\\\[22pt ]            \\textrm{com } & \\multicolumn{3}{l } {              { \\frac{\\displaystyle p \\parallel \\sigma(l_1 ) { \\overset{a}{\\longrightarrow } } \\delta(p ' \\parallel 0 ) \\qquad                   q \\parallel \\sigma(l_2 ) { \\overset{{\\overline{a}}}{\\longrightarrow } } { } \\delta(q ' \\parallel 0)}{\\displaystyle p { \\;|\\;}q \\parallel \\sigma(l_1,l_2).s { \\overset{\\tau}{\\longrightarrow } } \\delta(p'{\\;|\\;}q ' \\parallel s ) } }          } \\\\[22pt ]                                                        \\textrm{bang1 } &              { \\frac{\\displaystyle p \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\mu}{\\displaystyle !",
    "p \\parallel s { \\overset{\\alpha}{\\longrightarrow } } \\rho_0(\\mu ) { \\;|\\;}\\rho_1(!p ) } } &            \\textrm{prob } &              { \\frac{\\displaystyle } { \\displaystyle l{\\hspace{-2pt}:\\hspace{-2pt}}{\\textstyle{\\sum_{i}\\:}}p_ip_i",
    "\\parallel \\sigma(l).s                      { \\overset{\\tau}{\\longrightarrow } } { \\textstyle{\\sum_{i}\\:}}[p_i]\\delta(p_i \\parallel s ) } } \\\\[22pt ]            \\textrm{bang2 } & \\multicolumn{3}{l } {              { \\frac{\\displaystyle p \\parallel \\sigma(l_1 ) { \\overset{a}{\\longrightarrow } } \\delta(p_1 \\parallel 0 ) \\qquad                   p \\parallel \\sigma(l_2 ) { \\overset{{\\overline{a}}}{\\longrightarrow } } { } \\delta(p_2 \\parallel 0)}{\\displaystyle ! p \\parallel \\sigma(l_1,l_2).s { \\overset{\\tau}{\\longrightarrow } }                      \\delta(\\rho_0(p_1){\\;|\\;}\\rho_{10}(p_2){\\;|\\;}\\rho_{11}(!p ) \\parallel s ) } }          }      \\end{array }      $ ]    the operational semantics of the ccs@xmath38-calculus is given in terms of probabilistic automata defined inductively on the basis of the syntax , according to the rules shown in figure [ fig : ccss_sem ] .",
    "act is the basic communication rule . in order for @xmath113 to perform @xmath67",
    ", the scheduler should select this process for execution , so the scheduler needs to be of the form @xmath109 .",
    "after the execution the complete process will continue as @xmath114 .",
    "the res rule models restriction on channel @xmath61 : communication on this channel is not allowed by the restricted process . similarly to the section [ sec : ccsp ] , we denote by @xmath115 the measure @xmath98 such that @xmath116 for all processes @xmath1 and @xmath117 if @xmath5 is not of the form @xmath118 . sum1 models nondeterministic choice . if @xmath114 can perform a transition to @xmath62 , which means that @xmath9 selects one of the labels of @xmath1 , then @xmath119 will perform the same transition , i.e. the branch @xmath1 of the choice will be selected and @xmath3 will be discarded . for example",
    "@xmath120 note that the operands of the sum do not have labels , the labels belong to the subprocesses of @xmath1 and @xmath3 . in the case of nested choices , the scheduler must go deep and select the label of a prefix , thus resolving all the choices at once .",
    "par1 has a similar behavior for parallel composition .",
    "the scheduler selects @xmath1 to perform a transition on the basis of the label .",
    "the difference is that in this case @xmath3 is not discarded ; it remains in the continuation .",
    "@xmath121 denotes the measure @xmath98 such that @xmath122 .",
    "com models synchronization .",
    "if @xmath123 can perform the action @xmath61 and @xmath124 can perform @xmath125 , then @xmath126 , scheduling both @xmath127 and @xmath128 at the same time , can synchronize the two .",
    "prob models internal probabilistic choice .",
    "note that the scheduler can not affect the outcome of the choice , it can only schedule the choice as a whole ( that s why a probabilistic sum has a label ) and the process will move to a measure containing all the operands with corresponding probabilities .",
    "finally , bang1 and bang2 model replication .",
    "the rules are the same as in ccs@xmath37 , with the addition of a re - labeling operator @xmath129 .",
    "the reason for this is that we want to avoid ending up with multiple copies of the same label as the result of replication , since this would create ambiguities in scheduling as explained in section [ sec : detlabeling ] .",
    "@xmath130 replaces all labels @xmath107 inside @xmath1 with @xmath131 , and it is defined as @xmath132 and homomorphically on the other operators ( for instance @xmath133 @xmath134 ) .",
    "we also denote by @xmath135 the measure @xmath98 such that @xmath136 .",
    "note that we relabel only the resulting process , not the continuation of the scheduler : there is no need for relabeling the scheduler since we are free to choose the continuation as we please .",
    "let us give an example of how bang1 and relabeling work .",
    "let @xmath137 . to prove a transition for @xmath138 we have to prove it for @xmath1 and then relabel the resulting process :    as we can see in the example , when a process @xmath139 is activated , the spawned copy of @xmath1 is relabeled by adding @xmath20 to the index of all the labels , and @xmath140",
    "is relabeled by adding @xmath21 .",
    "so the labels of @xmath141 and @xmath142 will be disjoint . as remarked above",
    ", the continuation @xmath9 is not relabeled , if we want to perform @xmath143 after @xmath61 then @xmath9 should start with @xmath144 .",
    "the idea in ccs@xmath38 is that a _ syntactic _ scheduler will be able to completely solve the nondeterminism of the process , without needing to rely on a _ semantic _ scheduler at the level of the automaton .",
    "this means that the execution of a process in parallel with a scheduler should be fully probabilistic . to achieve this",
    "we will impose a condition on the labels that we can use in ccs@xmath38 processes .",
    "a _ labeling _ is an assignment of labels to the prefixes and probabilistic sums of a process .",
    "we will require all labelings to be _",
    "deterministic _ in the following sense .",
    "a labeling of a process @xmath1 is _ deterministic _",
    "iff for all schedulers @xmath9 there is only one transition rule @xmath145 that can be applied and the labelings of all processes @xmath146 such that @xmath147 are also deterministic .",
    "a labeling is _ linear _ iff all labels are pairwise disjoint .",
    "we can show that linear labelings are preserved by transitions , which leads to the following proposition .",
    "a linear labeling is deterministic .",
    "there are labelings that are deterministic without being linear .",
    "in fact , such labelings will be the means by which we hide information from the scheduler .",
    "however , the property of being deterministic is crucial since it implies that the scheduler will resolve all the nondeterminism of the process .",
    "let @xmath1 be a ccs@xmath38 process with a deterministic labeling .",
    "then for all schedulers @xmath9 , the automaton produced by @xmath148 is fully probabilistic .",
    "ccs@xmath38 with deterministic labelings allows us to separate probabilities from nondeterminism in a straightforward way : a process in parallel with a scheduler behaves in a fully probabilistic way and the nondeterminism arises from the fact that we can have many different schedulers .",
    "we may now ask the question : how powerful are the syntactic schedulers wrt the semantic ones , i.e. those defined directly over the automaton ?",
    "let @xmath1 be as ccs@xmath37 process and @xmath149 be the ccs@xmath38 process obtained from @xmath1 by applying a linear labeling .",
    "we say that the semantic scheduler @xmath80 of @xmath1 is equivalent to the syntactic scheduler @xmath9 of @xmath149 , written @xmath150 , iff the automata @xmath151 and @xmath152 are probabilistically bisimilar in the sense of @xcite . a scheduler @xmath9 is _ non - blocking _ for a process @xmath1 if it always schedules some transitions , except when @xmath1 itself is blocked .",
    "since semantic schedulers are usually not allowed to block , we will restraint ourselves to non - blocking syntactic schedulers to obtain a @xmath153 correspondence .",
    "let @xmath154 be the set of the semantic schedulers for the process @xmath1 , and @xmath155 be the set of the non - blocking syntactic schedulers for process @xmath149 .",
    "the following result holds for pure ccs processes ( that is , ccs@xmath37 processes without probabilistic choice ) .",
    "let @xmath1 be a pure ccs process and let @xmath149 be a ccs@xmath38 process obtained by adding a linear labeling to @xmath1 .",
    "then @xmath156 [ prop : equiv_scheduler_1 ]      in proposition [ prop : equiv_scheduler_1 ] we considered pure ccs processes in which the execution tree has only one possible execution .",
    "now consider a process @xmath1 containing an internal probabilistic choice .",
    "even if we fix the scheduler , the outcome of the choice is not always the same , so @xmath114 could produce different executions . as a consequence ,",
    "the syntactic schedulers we have defined are not enough to give us back all the semantic ones .",
    "consider the process @xmath157 .",
    "after the probabilistic choice , either @xmath158 or @xmath159 will be available , but we can not know which one . as a consequence , we can not create a scheduler that selects @xmath61 or @xmath143 , whatever is available .",
    "in fact , it s not even possible to create a non - blocking scheduler at all , both @xmath160 and @xmath161 will block on some executions .",
    "the problem here is that the process can make choices that are independent from the scheduler , so the latter should adapt its behavior to the outcome of these choices . to achieve this ,",
    "we extend ccs@xmath38 by adding a _ scheduler choice _ construct .",
    "the new syntax and semantics are displayed in figure [ fig : schedulerchoice ] .",
    "a scheduler can be the sum @xmath162 of several schedulers , and the outcome of the probabilistic choice ( in the process ) will determine the one to activate .",
    "in the case where more than one could be activated at the same time , we give preference to the first one in the sum , so the scheduler still behaves in a deterministic way .",
    "@xmath163    in our previous example , we can use the scheduler @xmath164 which will produce @xmath61 or @xmath143 depending on the outcome of the probabilistic choice . with the scheduler choice",
    ", we can retrieve the full power of the semantic scheduler for full ccs@xmath37 processes .",
    "proposition [ prop : equiv_scheduler_1 ] holds for full ccs@xmath37 processes if we extend schedulers with scheduler choice .",
    "[ prop : equiv_scheduler_2 ]      up to now we are using only linear labelings which , as we saw , give us the whole power of semantic schedulers .",
    "however , we can construct non - linear labelings that are still deterministic , that is there is still only one transition possible at any time even though we have multiple occurrences of the same label .",
    "there are various cases of useful non - linear labelings .",
    "let @xmath1,@xmath3 be ccs@xmath38 processes with deterministic labelings ( not necessarily disjoint ) .",
    "the following labelings are all deterministic : @xmath165 [ prop : detlab ]    consider the case where @xmath1 and @xmath3 in the above proposition share the same labels . in",
    "( [ eq : detlab1 ] ) the scheduler can not select an action inside @xmath32 , it must select the choice itself .",
    "after the choice , only one of @xmath32 will be available so there will be no ambiguity in selecting transitions .",
    "the case ( [ eq : detlab2 ] ) is similar but with nondeterministic choice .",
    "now the guarding prefixes must have different labels , since the scheduler should be able to resolve the choice , however after the choice only one of @xmath32 will be available .",
    "hence , again , the multiple copies of the labels do not constitute a problem . in ( [ eq : detlab3 ] ) we allow the same label on the guarding prefixes of a nondeterministic choice .",
    "this is because the guarding channels @xmath7 are restricted and only one of the corresponding output actions is available ( @xmath125 ) . as a consequence",
    ", there is no ambiguity in selecting transitions .",
    "a scheduler @xmath166 can only perform a synchronization on @xmath61 , even though @xmath127 appears twice .",
    "however , using multiple copies of a label limits the power of the scheduler , since the labels provide information about the outcome of a probabilistic choice ( and allow the scheduler to choose different strategies through the use of the scheduler choice ) .",
    "in fact , this is exactly the technique we will use to archive the goals described in section [ sec : introduction ] .",
    "consider for example the process : @xmath167 from proposition [ prop : detlab]([eq : detlab1 ] ) this labeling is deterministic .",
    "however , since both branches of the probabilistic sum have the same label @xmath127 , the scheduler can not resolve the choice between @xmath1 and @xmath3 based on the outcome of the choice .",
    "there is still nondeterminism : the scheduler @xmath168 will select @xmath1 and the scheduler @xmath169 will select @xmath3",
    ". however this selection will be independent from the outcome of the probabilistic choice .",
    "note that we did not impose any direct restrictions on the schedulers , we still consider all possible syntactic schedulers for the process ( [ eq : example1 ] ) above .",
    "however , having the same label twice limits the power of the syntactic schedulers with respect to the semantic ones .",
    "this approach has the advantage that the restrictions are limited to the choices with the same label .",
    "we already know that having pairwise different labels gives the full power of the semantic scheduler .",
    "so the restriction is local to the place where we , intentionally , put the same labels .",
    "testing relations @xcite are a method of comparing processes by considering their interaction with the environment . a _",
    "test _ is a process running in parallel with the one being tested and which can perform a distinguished action @xmath170 that represents success .",
    "two processes are testing equivalent if they can pass the same tests .",
    "this idea is very useful for the analysis of security protocols , as suggested in @xcite , since a test can be seen as an adversary who interferes with a communication agent and declares @xmath170 if an attack is successful",
    ". then two processes are testing equivalent if they are vulnerable to the same attacks .    in the probabilistic",
    "setting we take the approach of @xcite which considers the exact probability of passing a test ( in contrast to @xcite which considers only the ability to pass a test with probability non - zero ( may - testing ) or one ( must - testing ) ) .",
    "this approach leads to the definition of two preorders @xmath171 and @xmath172 .",
    "@xmath173 means that the if @xmath1 can pass @xmath174 then @xmath3 can also pass @xmath174 with the same probability .",
    "@xmath175 means that if @xmath1 always passes @xmath174 with at least some probability then @xmath3 always passes @xmath174 with at least the same probability .",
    "a labeling of a process is _ fresh _ ( with respect to a set @xmath176 of processes ) if it is linear and its labels do not appear in any other process in @xmath177 .",
    "a test @xmath174 is a ccs@xmath38 process with a fresh labeling , containing the distinguished action @xmath170 .",
    "let @xmath178 denote the set of all tests with respect to @xmath177 and let @xmath179 denote the restriction on all channels of @xmath1 , thus allowing only @xmath36 actions .",
    "we define @xmath180 to be the probability of the set of executions of the fully probabilistic automaton @xmath181 that contain @xmath170 .",
    "note that this set can be produced as a countable union of disjoint cones so its probability is well - defined .",
    "let @xmath32 be ccs@xmath38 processes .",
    "we define must and may testing preorders as follows : @xmath182          & &   \\qquad { p_\\omega}(p , s_p , o ) \\le { p_\\omega}(q , s_q , o ) \\\\[4pt ]          p { \\sqsubseteq_{\\textrm{\\textbf{must}}}}q & \\textrm { iff } &              \\forall o \\in \\it{test}_{p , q } \\ \\forall s_q \\in syn((\\nu)(q{\\;|\\;}o ) ) \\",
    "\\exists s_p \\in syn((\\nu)(p{\\;|\\;}o ) ) : \\\\[2pt ]          & &   \\qquad { p_\\omega}(p , s_p , o ) \\le { p_\\omega}(q , s_q , o )      \\end{array}\\ ] ]    we also define @xmath183 to be the equivalences induced by @xmath184 respectively .    a context @xmath33 is a process with a hole .",
    "a preorder @xmath185 is a precongruence if @xmath186 implies @xmath187 { \\sqsubseteq}c[q]$ ] for all contexts @xmath33 .",
    "may and must testing are precongruences if we restrict to contexts with fresh labelings and without occurrences of @xmath42 .",
    "this result is essentially an adaptation to our framework of the analogous precongruence property in @xcite .",
    "let @xmath32 be ccs@xmath38 processes such that @xmath173 and let @xmath33 be a context with a fresh labeling and in which @xmath42 does not occur",
    ". then @xmath187 { \\sqsubseteq_{\\textrm{\\textbf{may}}}}c[q]$ ] .",
    "similarly for @xmath172 .",
    "[ prop : precongruence ]    this also implies that @xmath183 are congruences . note that @xmath32 in the above proposition are not required to have linear labelings ,",
    "@xmath1 might include multiple occurrences of the same label thus limiting the power of the schedulers @xmath188 .",
    "this shows the locality of the scheduler s restriction : some choices inside @xmath1 are hidden from the scheduler but the rest of the context is fully visible .",
    "if we remove the freshness condition then proposition [ prop : precongruence ] is no longer true .",
    "let @xmath189 , @xmath190 and @xmath191)$ ] .",
    "we have @xmath192 but @xmath187,c[q]$ ] can be separated by the test @xmath193 ( the labeling is omitted for simplicity since tests always have fresh labelings . )",
    "it is easy to see that @xmath194 $ ] can pass the test with probability @xmath21 by selecting the correct branch of @xmath174 based on the outcome of the probabilistic choice . in @xmath187",
    "$ ] this is not possible because of the labels @xmath195 that are common in @xmath196 .",
    "we can now state the result that we announced in section [ sec : introduction ] .",
    "let @xmath32 be ccs@xmath38 processes and @xmath33 a context with a fresh labeling and without occurrences of bang .",
    "then @xmath197 + _",
    "p c[l_1{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.q ] )   & { \\approx_{\\textrm{\\textbf{may } } } } & c[l{\\hspace{-2pt}:\\hspace{-2pt}}(p + _ p q ) ] \\quad \\textrm{and } \\\\",
    "l{\\hspace{-2pt}:\\hspace{-2pt}}(c[l_1{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.p ] + _ p c[l_1{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.q ] )   & { \\approx_{\\textrm{\\textbf{must } } } } & c[l{\\hspace{-2pt}:\\hspace{-2pt}}(p + _ p q ) ]      \\end{aligned}\\ ] ] [ thm : distoversum ]    the proof is given in the appendix .",
    "there are two crucial points in the above theorem .",
    "the first is that the labels of the context are copied , thus the scheduler can not distinguish between @xmath198 $ ] and @xmath199 $ ] based on the labels of the context .",
    "the second is that @xmath32 are protected by a @xmath36 action labeled by the same label @xmath127 .",
    "this is to ensure that in the case of a nondeterministic sum ( @xmath200 $ ] ) the scheduler can not find out whether the second operand of the choice is @xmath1 or @xmath3 unless it commits to selecting the second operand",
    ". for example let @xmath201 .",
    "then @xmath202 is not testing equivalent to @xmath203 since they can be separated by @xmath204 and a scheduler that resolves @xmath205 to @xmath61 and @xmath206 to @xmath5 .",
    "however , if we take @xmath207 then @xmath208 is testing equivalent to @xmath209 since the scheduler will have to resolve both branches of @xmath208 in the same way ( even though we still have non - determinism ) .",
    "the problem with replication is simply the persistence of the processes .",
    "it is clear that @xmath210 can not be equivalent in any way to @xmath34 since the first replicates only one of @xmath32 while the second replicates both .",
    "however theorem [ thm : distoversum ] together with proposition [ prop : precongruence ] imply that @xmath211 + _ p c[l_1{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.q ] ) ] { \\approx_{\\textrm{\\textbf{may}}}}c'[c[l{\\hspace{-2pt}:\\hspace{-2pt}}(p + _ p q ) ] ]      \\label{eq : twocontexts}\\ ] ] where @xmath33 is a context without bang and @xmath212 is a context without @xmath42 . the same is also true for @xmath213 .",
    "this means that we can lift the sum towards the root of the context until we reach a bang .",
    "intuitively we can not move the sum outside the bang since each replicated copy must perform a different probabilistic choice with a possibly different outcome .",
    "theorem [ thm : distoversum ] shows that the probabilistic choice is indeed private to the process and invisible to the scheduler .",
    "the process can perform it at any time , even in the very beginning of the execution , without making any difference to an outside observer .",
    "in this section we discuss an application of our framework to anonymity .",
    "in particular , we show how to specify the dining cryptographers protocol @xcite so that it is robust to scheduler - based attacks .",
    "we first propose a method to encode _ secret value passing _ , which will turn out to be useful for the specification : @xmath214 \\\\",
    "l{\\hspace{-2pt}:\\hspace{-2pt}}\\bar{c}{\\langlev\\rangle}.p & { \\overset{\\scriptscriptstyle\\delta}{= } } & l{\\hspace{-2pt}:\\hspace{-2pt}}{\\overline{cv}}.p\\end{aligned}\\ ] ] this is the usual encoding of value passing in css except that we use the same label in all the branches of the nondeterministic sum . to ensure that the resulting labeling will be deterministic we should restrict the channels @xmath215 and make sure that there will be at most one output on @xmath216 .",
    "we will write @xmath217 for @xmath218 .",
    "for example , the labeling of the following process is deterministic : @xmath219 this case is a combination of the cases ( [ eq : detlab1 ] ) and ( [ eq : detlab3 ] ) of proposition [ prop : detlab ] .",
    "the two outputs on @xmath216 are on different branches of the probabilistic sum , so during an execution at most one of them will be available .",
    "thus there is no ambiguity in scheduling the sum produced by @xmath220 .",
    "the scheduler @xmath168 will perform a synchronization on @xmath221 or @xmath222 , whatever is available after the probabilistic choice . in other words , using the labels we manage to hide the information about which value was transmitted to @xmath1 .",
    "@xmath223      crypt_i & { \\overset{\\scriptscriptstyle\\delta}{= } } &          \\underbrace { m_i(pay ) } _ { l_{5,i}}.          \\underbrace { c_{i , i}(coin_1 ) } _ { l_{6,i}}.          \\underbrace { c_{i , i\\oplus 1}(coin_2 ) } _ { l_{7,i}}.          \\underbrace { { \\overline{out}}_i{\\langlepay\\otimes coin_1\\otimes coin_2\\rangle } } _ { l_{8,i } }   \\\\[2pt ]      coin_i & { \\overset{\\scriptscriptstyle\\delta}{= } } & l_{9,i}{\\hspace{-2pt}:\\hspace{-2pt } } (          ( \\underbrace { \\bar{c}_{i , i}{\\langle0\\rangle } } _ { l_{10,i } } { \\;|\\;}\\underbrace { \\bar{c}_{i\\ominus 1,i}{\\langle0\\rangle } } _ { l_{11,i } } ) + _ { 0.5 }          ( \\underbrace { \\bar{c}_{i , i}{\\langle1\\rangle } } _ { l_{10,i } } { \\;|\\;}\\underbrace { \\bar{c}_{i\\ominus 1,i}{\\langle1\\rangle } } _ { l_{11,i } } )          ) \\\\[2pt ]      prot & { \\overset{\\scriptscriptstyle\\delta}{= } } & ( \\nu \\vec{m } ) (          master { \\;|\\;}(\\nu \\vec{c } ) (              { \\textstyle{\\prod_{i=0}^{2}\\ : } } crypt_i { \\;|\\;}{\\textstyle{\\prod_{i=0}^{2}\\ : } } coin_i ) ) \\end{aligned}\\ ] ]    the problem of the dining cryptographers is the following : three cryptographers are dining together . at the end of the dinner , the bill has to be paid by either one of them or by another agent called the master .",
    "the master decides who will pay and then informs each of them separately whether he has to pay or not .",
    "the cryptographers would like to find out whether the payer is the master or one of them .",
    "however , in the latter case , they also wish to keep the payer anonymous .    the dining cryptographers protocol ( dcp ) solves the above problem as follows : each cryptographer tosses a fair coin which is visible to himself and his neighbor to the right .",
    "each cryptographer checks the two adjacent coins and , if he is not paying , announces _ agree _ if they are the same and _ disagree _ otherwise .",
    "however , the paying cryptographer will say the opposite . it can be proved that if the number of _ disagrees _ is even , then the master is paying ; otherwise , one of the cryptographers is paying @xcite .",
    "an external observer @xmath174 is supposed to see only the three announcements @xmath224 . as discussed in @xcite",
    ", dcp satisfies anonymity if we abstract from their order .",
    "if their order is observable , on the contrary , then a scheduler can reveal the identity of the payer to @xmath174 simply by forcing the payer to make his announcement first .",
    "of course , this is possible only if the scheduler is unrestricted and can choose its strategy depending on the decision of the master ( or on the results of the coins ) .",
    "in our framework we can solve the problem by giving a specification of the dcp in which the choices of the master and of the coins are made invisible to the scheduler .",
    "the specification is shown in figure [ fig : dining ] .",
    "we use some meta - syntax for brevity : the symbols @xmath225 and @xmath226 represent the addition and subtraction modulo 3 , while @xmath227 represents the addition modulo 2 ( xor ) .",
    "the notation @xmath228 stands for @xmath21 if @xmath229 and @xmath20 otherwise .",
    "there are many sources of nondeterminism : the order of communication between the master and the cryptographers , the order of reception of the coins , and the order of the announcements .",
    "the crucial points of our specification , which make the nondeterministic choices independent from the probabilistic ones , are : ( a ) all communications internal to the protocol ( master - cryptographers and cryptographers - coins ) are done by secret value passing , and ( b ) in each probabilistic choice the different branches have the same labels .",
    "for example , all branches of the master contain an output on @xmath230 , always labeled by @xmath128 , but with different values each time .",
    "thanks to the above independence , the specification satisfy strong probabilistic anonymity .",
    "there are various equivalent definitions of this property , we follow here the version presented in @xcite .",
    "let @xmath231 represent an observable ( the sequence of announcements ) , and @xmath232 represent the conditional probability , under the scheduler @xmath9 , that the protocol produces @xmath231 given that the master has selected cryptographer @xmath70 as the payer .    the protocol in figure [ fig : dining ]",
    "satisfies the following property : for all schedulers @xmath9 and all observables @xmath231 , @xmath233    note that different schedulers will produce different traces ( we still have nondeterminism ) but they will not depend on the choice of the master .",
    "some previous treatment of the dcp , including @xcite , had solved the problem of the leak of information due to too - powerful schedulers by simply considering as observable sets of announcements instead than sequences .",
    "thus one could think that using a true concurrent semantics , for instance event structures , would solve the problem .",
    "we would like to remark that this is false : true concurrency would weaken the scheduler enough in the case of the dcp , but not in general .",
    "for instance , it would not help in the anonymity example in the introduction .",
    "@xmath234              cp & : : = p \\parallel s , t          \\end{array }          &          \\begin{array}{ll }              \\textrm{indep } &              { \\frac{\\displaystyle p \\parallel t { \\overset{\\alpha}{\\longrightarrow } } \\mu } { \\displaystyle \\begin{array}{c }                      l{\\hspace{-2pt}:\\hspace{-2pt}}\\{p\\ } \\parallel \\sigma(l).s , t { \\overset{\\alpha}{\\longrightarrow } } \\mu ' \\\\                      \\textrm{where } \\mu'(p ' \\parallel s , t ' ) = \\mu(p ' \\parallel t ' )                  \\end{array } } }          \\end{array }      \\end{array}\\ ] ]    we sketch here a method to hide also certain nondeterministic choices from the scheduler , and we show an application to the variant of the dining cryptographers with nondeterministic master .",
    "first we need to extend the calculus with the concept of a second _ independent _ scheduler @xmath10 that we assume to solve the nondeterministic choices that we want to make transparent to the main scheduler @xmath9 .",
    "the new syntax and semantics are shown in figure [ fig : independent ] .",
    "@xmath235 represents a process where the scheduling of @xmath1 is protected from the main scheduler @xmath9 .",
    "the scheduler @xmath9 can `` ask '' @xmath10 to schedule @xmath1 by selecting the label @xmath106 .",
    "then @xmath10 resolves the nondeterminism of @xmath1 as expressed by the indep rule .",
    "note that we need to adjust also the other rules of the semantics to take @xmath10 into account , but this change is straightforward .",
    "we assume that @xmath10 does not collaborate with @xmath9 so we do not need to worry about the labels in @xmath1 .    to model the dining cryptographers with nondeterministic master we replace the @xmath236 process in figure [ fig : dining ] by the following one .",
    "@xmath237 essentially we have replaced the probabilistic choice by a _ protected _ nondeterministic one .",
    "note that the labels of the operands are different but this is not a problem since this choice will be scheduled by @xmath10 .",
    "note also that after the choice we still have the same labels @xmath238 , however the labeling is still deterministic , similarly to the case [ eq : detlab2 ] of proposition [ prop : detlab ] .    in case of a nondeterministic selection of the culprit , and a probabilistic anonymity protocol , the notion of strong probabilistic anonymity has not been established yet , although some possible definitions have been discussed in @xcite .",
    "our framework makes it possible to give a natural and precise definition .",
    "a protocol with nondeterministic selection of the culprit satisfies strong probabilistic anonymity iff for all observables @xmath231 , schedulers @xmath9 , and independent schedulers @xmath239 which select different culprits , we have : @xmath240",
    ".    we can prove the above property for our protocol :    the dcp with nondeterministic selection of the culprit specified in this section satisfies strong probabilistic anonymity .",
    "we have proposed a process - calculus approach to the problem of limiting the power of the scheduler so that it does not reveal the outcome of hidden random choices , and we have shown its applications to the specification of information - hiding protocols . we have also discussed a feature , namely the distributivity of certain contexts over random choices , that makes our calculus appealing for verification .",
    "finally , we have considered the probabilistic testing preorders and shown that they are precongruences in our calculus .",
    "our plans for future work are in two directions : ( a ) we would like to investigate the possibility of giving a game - theoretic characterization of our notion of scheduler , and ( b ) we would like to incorporate our ideas in some existing probabilistic model checker , for instance prism .",
    "we would like to thank vincent danos for having pointed out to us an attack to the dining cryptographers protocol based on the order of the scheduler , which has inspired this work .",
    "10    vardi , m.y . : automatic verification of probabilistic concurrent finite - state programs . in : proc . of the 26th annual symp . on foundations of computer science , ieee computer society press ( 1985 ) 327338    hansson , h. , jonsson , b. : a framework for reasoning about time and reliability . in : proc . of the 10th symposium on real - time systems , ieee computer society press ( 1989 ) 102111    yi , w. , larsen , k.g . : testing probabilistic and nondeterministic processes . in : proc . of the 12th ifip international symposium on protocol specification , testing and verification , north holland ( 1992 )    segala , r. : modeling and verification of randomized distributed real - time systems .",
    "phd thesis , department of electrical engineering and computer science , massachusetts institute of technology ( 1995 ) available as technical report mit / lcs / tr-676 .",
    "segala , r. , lynch , n. : probabilistic simulations for probabilistic processes .",
    "nordic journal of computing * 2 * ( 1995 )    hansson , h. , jonsson , b. : a calculus for communicating systems with time and probabitilies . in : proc . of the 11th symposium on real - time systems , ieee computer society press ( 1990 ) 278287    bandini , e. , segala ,",
    "r. : axiomatizations for probabilistic bisimulation . in : proc . of the 28th international colloquium on automata , languages and programming .",
    "lncs 2076 , springer ( 2001 ) 370381    andova , s. : probabilistic process algebra .",
    "phd thesis , technische universiteit eindhoven ( 2002 )    mislove , m. , ouaknine , j. , worrell , j. : axioms for probability and nondeterminism . in : proc .  of the 10th int .",
    "wksh . on expressiveness in concurrency",
    "( express 03 ) .",
    "volume  96 of entcs , elsevier ( 2004 )    palamidessi , c. , herescu , o.m .",
    ": a randomized encoding of the @xmath241-calculus with mixed choice .",
    "theoretical computer science * 335 * ( 2005 ) 373404 + http://www.lix.polytechnique.fr/~catuscia / papers / prob_enc / report.% pdf[http://www.lix.polytechnique.fr/~catuscia / papers / prob_enc / report.% pdf ] .",
    "deng , y. , palamidessi , c. , pang , j. : compositional reasoning for probabilistic finite - state behaviors . in : processes , terms and cycles : steps on the road to infinity .",
    "lncs 3838 . springer ( 2005 ) 309337 + http://www.lix.polytechnique.fr/~catuscia / papers / yuxin / bookjw / par.%",
    "pdf[http://www.lix.polytechnique.fr/~catuscia / papers / yuxin / bookjw / par.% pdf ] .",
    "sokolova , a. , vink , e.d .",
    ": probabilistic automata : system types , parallel composition and comparison . in : validation of stochastic systems : a guide to current research .",
    "lncs 2925 .",
    "springer ( 2004 ) 143    jonsson , b. , larsen , k.g .",
    ", yi , w. : probabilistic extensions of process algebras . in : handbook of process algebras .",
    "elsevier ( 2001 ) 685710    chatzikokolakis , k. , palamidessi , c. : a framework for analyzing probabilistic protocols and its application to the partial secrets exchange .",
    "theoretical computer science . to appear . a short version of this paper appeared in the _ proc .",
    "of the symp . on trustworthy global computing _ , lncs 3705 , 146 - 162 .",
    "springer , 2005 .",
    "+ http://www.lix.polytechnique.fr/~catuscia / papers / partialsecrets / tc% sreport.pdf[http://www.lix.polytechnique.fr/~catuscia / papers / partialsecrets / tc% sreport.pdf ] .",
    "de  alfaro , l. , henzinger , t.a . ,",
    "jhala , r. : compositional methods for probabilistic systems . in : proceedings of concur 2001 .",
    "lncs 2154 , springer ( 2001 )    mitchell , j.c .",
    ", ramanathan , a. , scedrov , a. , teague , v. : a probabilistic polynomial - time process calculus for the analysis of cryptographic protocols .",
    "theoretical computer science * 353 * ( 2006 ) 118164    canetti , r. , cheung , l. , kaynar , d. , liskov , m. , lynch , n. , pereira , o. , segala , r. : task - structured probabilistic i / o automata . in : proc . of the 8th int .",
    "workshop on discrete event systems ( wodes06 ) , ( 2006 )    canetti , r. , cheung , l. , kaynar , d.k . ,",
    "liskov , m. , lynch , n.a . , pereira , o. , segala , r. : time - bounded task - pioas : a framework for analyzing security protocols . in : proc",
    "of disc 06 .",
    "lncs 4167 , springer ( 2006 ) 238253    nicola , r.d . , hennessy , m.c.b .",
    ": testing equivalences for processes .",
    "theoretical computer science * 34 * ( 1984 ) 83133    abadi , m. , gordon , a.d . : a calculus for cryptographic protocols : the spi calculus .",
    "information and computation * 148 * ( 1999 ) 170    chaum , d. : the dining cryptographers problem : unconditional sender and recipient untraceability .",
    "journal of cryptology * 1 * ( 1988 ) 6575    bhargava , m. , palamidessi , c. : probabilistic anonymity . in : proc . of concur 2005 .",
    "lncs 3653 , springer ( 2005 ) 171185 + http://www.lix.polytechnique.fr/~catuscia / papers / anonymity / concur.% pdf[http://www.lix.polytechnique.fr/~catuscia / papers / anonymity / concur.% pdf ] .",
    "in this appendix we give the proof of the main technical result of our paper .",
    "* theorem [ thm : distoversum ] * let @xmath32 be ccs@xmath38 processes and @xmath33 a context with a fresh labeling and without occurrences of bang .",
    "then @xmath242 + _ p c[l_0{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.q ] ) & { \\approx_{\\textrm{\\textbf{may } } } } & c[l{\\hspace{-2pt}:\\hspace{-2pt}}(p + _ p",
    "q ) ] \\quad \\textrm{and } \\\\          l{\\hspace{-2pt}:\\hspace{-2pt } } ( c[l_0{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.p ] + _ p c[l_0{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.q ] ) & { \\approx_{\\textrm{\\textbf{must } } } } & c[l{\\hspace{-2pt}:\\hspace{-2pt}}(p + _ p q ) ]      \\end{aligned}\\ ] ]     + since we will always use the label @xmath106 for all probabilistic sum @xmath30 , and @xmath243 for @xmath39 and @xmath43 , we will omit these labels to make the proof more readable",
    ". we will also denote @xmath244 by @xmath245 .",
    "let @xmath246 + _ p c[\\tau.q]$ ] and @xmath247 $ ] .",
    "we will prove that for all tests @xmath174 and for all schedulers @xmath248 there exists @xmath249 such that @xmath250 and vice versa .",
    "this implies both @xmath251 and @xmath252 .      in order for the scheduler of @xmath255 to be non - blocking",
    ", it has to be of the form @xmath256 , since the only possible transition of @xmath255 is the probabilistic choice labeled by @xmath106 .",
    "by ( [ eq : pom1 ] ) we have @xmath257 + c[\\tau.q ] , \\sigma(l).s_1 , o ) =          p\\ { p_\\omega}(c[\\tau.p],s_1,o ) + \\bar{p}\\ { p_\\omega}(c[\\tau.q],s_1,o)\\ ] ] the proof will be by induction on the structure of @xmath33 .",
    "let @xmath174 range over tests with fresh labelings , let @xmath258 range over nonblocking schedulers for both @xmath259 $ ] and @xmath260 $ ] ( such that @xmath256 is a nonblocking scheduler for @xmath255 ) and let @xmath261 range over nonblocking schedulers for @xmath209 .",
    "the induction hypothesis is : @xmath262,s_1,o ) + \\bar{p}\\ { p_\\omega}(c[\\tau.q],s_1,o ) = { p_\\omega}(c[p + _ p q ] , s_2 , o )          \\quad \\textrm{and }",
    "\\\\      \\leftarrow)\\ \\forall o\\ \\forall s_2\\ \\exists s_1 : \\\\",
    "\\qquad p\\ { p_\\omega}(c[\\tau.p],s_1,o ) + \\bar{p}\\ { p_\\omega}(c[\\tau.q],s_1,o ) = { p_\\omega}(c[p + _ p q ] , s_2 , o ) \\end{array}\\ ] ] we have the following cases for @xmath33 :    * case @xmath263 $ ] .",
    "trivial . *",
    "case @xmath264 + the scheduler @xmath258 of @xmath259 $ ] and @xmath260 $ ] has to be of the form @xmath265 where @xmath128 is the label of a @xmath266 prefix in @xmath174 ( if no such prefix exists then the case is trivial ) .",
    "+ a scheduler of the form @xmath110 can schedule any process of the form @xmath267 ( with label @xmath127 ) giving the transition : @xmath268 and producing always the same @xmath269 .",
    "the probability @xmath270 for these processes will be given by equation ( [ eq : pom2 ] ) .",
    "+ thus for ( @xmath271 ) we have @xmath272,\\sigma(l_1,l_2).s_1',o ) +              \\bar{p}\\ { p_\\omega}(l_1{\\hspace{-2pt}:\\hspace{-2pt}}a.c[\\tau.q],\\sigma(l_1,l_2).s_1',o ) } \\\\[3pt ]          & = & p\\ { p_\\omega}(c'[\\tau.p ] , s_1 ' , o ' ) + \\bar{p}\\ { p_\\omega}(c'[\\tau.q ] , s_1 ' , o ' ) & \\textrm{(\\ref{eq : pom2 } ) } \\\\[3pt ]          & = & { p_\\omega}(c'[p + _ p q ] , s_2 ' , o ' )                      & \\textrm{ind . hyp . } \\\\[3pt ]          & = & { p_\\omega}(l_1{\\hspace{-2pt}:\\hspace{-2pt}}a.c'[p + _ p q ] , \\sigma(l_1,l_2).s_2 ' , o ) & \\textrm{(\\ref{eq : pom2 } ) } \\\\[3pt ]          & = & { p_\\omega}(r_2 , s_2 , o )      \\end{array}\\ ] ] for ( @xmath273 ) we can perform the above derivation in the opposite direction , given that a scheduler for @xmath274 $ ] must be of the form @xmath275 . *",
    "case @xmath276 + since we only consider contexts with fresh labelings , @xmath277 is itself a test , and @xmath278 thus for ( @xmath271 ) we have @xmath279{\\;|\\;}r , s_1 , o ) +              \\bar{p}\\ { p_\\omega}(c'[\\tau.q ] { \\;|\\;}r , s_1 , o ) }         \\\\[3pt ]              & = & { p_\\omega}(c'[p + _ p q ] , s_2 , r{\\;|\\;}o )                    & \\textrm{ind .",
    "hyp . } \\\\[3pt ]          & = & { p_\\omega}(c'[p + _ p q]{\\;|\\;}r , s_2 , o )                    & \\textrm{(\\ref{eq3 } ) } \\\\[3pt ]          & = & { p_\\omega}(r_2 , s_2 , o )      \\end{array}\\ ] ] for ( @xmath273 ) we can perform the above derivation in the opposite direction . * case @xmath280 + since we consider only contexts with fresh labelings , the labels of @xmath212 are disjoint from those of @xmath5 , thus the scheduler of a process of the form @xmath281 + _ q r)$ ] must be of the form @xmath282 where @xmath283 is a scheduler containing labels of @xmath284 $ ] and @xmath285 a scheduler containing labels of @xmath5 .",
    "moreover @xmath286 + _ q r ) , s , o ) } \\nonumber\\\\          & = & q\\ { p_\\omega}(c'[x ] , s_c+s_r , o ) + \\bar{q}\\ { p_\\omega}(r , s_c+s_r , o ) \\nonumber\\\\          & = & q\\ { p_\\omega}(c'[x ] , s_c , o ) + \\bar{q}\\ { p_\\omega}(r , s_r , o ) \\label{eq : pom3 }      \\end{aligned}\\ ] ] as a consequence , the scheduler @xmath258 of @xmath259 $ ] and @xmath260 $ ] has to be of the form @xmath287 . + for ( @xmath271 ) we have @xmath288 + _",
    "q r ) , s_1 , o ) +              \\bar{p}\\ { p_\\omega}(l_1{\\hspace{-2pt}:\\hspace{-2pt } } ( c'[\\tau.q ] + _ q r ) , s_1 , o ) }      \\\\[3pt ]                & = & { p_\\omega}(l_1{\\hspace{-2pt}:\\hspace{-2pt } } ( c'[p+_pq ] + _ q r ) , \\sigma(l_1).(s_c'+s_r ) , o ) & \\textrm{(\\ref{eq : pom3 } ) } \\\\          & = & { p_\\omega}(r_2 , s_2 , o )      \\end{array}\\ ] ] for ( @xmath273 ) we can perform the above derivation in the opposite direction , given that a scheduler for @xmath289 + _ q r)$ ] must be of the form @xmath290 . *",
    "case @xmath291 + consider the process @xmath292 + r$ ] .",
    "the scheduler @xmath258 of this process has to choose between @xmath292 $ ] and @xmath5 .",
    "+ there are two cases to have a transition using the sum1 , sum2 rules .",
    "* * either @xmath293 + r { \\;|\\;}o ) \\parallel s_r { \\overset{\\alpha}{\\longrightarrow } } \\mu $ ] such that @xmath294 . in this case @xmath295 + r ,",
    "s_r , o ) = { p_\\omega}(r , s_r , o ) \\label{eq4}\\ ] ] * * or @xmath293 + r { \\;|\\;}o ) \\parallel s_c { \\overset{\\alpha}{\\longrightarrow } } \\mu $ ] such that @xmath296 { \\;|\\;}o ) \\parallel s_c { \\overset{\\alpha}{\\longrightarrow } } \\mu$ ] . in this case @xmath295 + r ,",
    "s_c , o ) = { p_\\omega}(c'[l_0{\\hspace{-2pt}:\\hspace{-2pt}}\\tau.p ] , s_c , o ) \\label{eq5}\\ ] ] + now consider the process",
    "@xmath297 + r$ ] .",
    "since @xmath1 and @xmath3 are behind the @xmath298 action , this process has exactly the same visible labels as @xmath292 + r$ ] .",
    "thus @xmath285 and @xmath283 will select @xmath5 and @xmath297 $ ] respectively and the equations ( [ eq4 ] ) and ( [ eq5 ] ) will hold .",
    "+ in the case ( i ) ( @xmath299 ) we have : @xmath300 + r , s_r , o ) +              \\bar{p}\\ { p_\\omega}(c'[\\tau.q ] + r ) , s_r , o ) }         \\\\[3pt ]                        & = & { p_\\omega}(r_2 , s_2 , o )      \\end{array}\\ ] ] for ( @xmath273 ) we can perform the above derivation in the opposite direction . * case @xmath302 + the process @xmath303 { \\;|\\;}o ) $ ] has the same transitions as @xmath304 { \\;|\\;}(\\nu a)o)$ ] .",
    "the result follows by the induction hypothesis ."
  ],
  "abstract_text": [
    "<S> when dealing with process calculi and automata which express both nondeterministic and probabilistic behavior , it is customary to introduce the notion of scheduler to solve the nondeterminism . </S>",
    "<S> it has been observed that for certain applications , notably those in security , the scheduler needs to be restricted so not to reveal the outcome of the protocol s random choices , or otherwise the model of adversary would be too strong even for `` obviously correct '' protocols . </S>",
    "<S> we propose a process - algebraic framework in which the control on the scheduler can be specified in syntactic terms , and we show how to apply it to solve the problem mentioned above . </S>",
    "<S> we also consider the definition of ( probabilistic ) may and must preorders , and we show that they are precongruences with respect to the restricted schedulers . furthermore , we show that all the operators of the language , except replication , distribute over probabilistic summation , which is a useful property for verification . </S>"
  ]
}