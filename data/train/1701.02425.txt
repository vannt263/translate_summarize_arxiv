{
  "article_text": [
    "is there a good way to prove @xmath0[l]{\\qquad\\fbox{\\rmln } }    \\else\\marginpar{\\vspace{0.7\\baselineskip}\\hspace{-1.15\\textwidth}\\fbox{\\rmln } }    \\fi \\fi}\\ ] ] for @xmath1 $ ] , or @xmath2[l]{\\qquad\\fbox{\\rmb4p } }    \\else\\marginpar{\\vspace{0.7\\baselineskip}\\hspace{-1.15\\textwidth}\\fbox{\\rmb4p } }    \\fi \\fi}\\ ] ] for @xmath3 $ ] ?",
    "each is a strict inequality involving only one variable ( no parameters ) in a specific finite interval .",
    "such inequalities are rarely of general interest",
    ". no one will present any of them as a lemma , much less as a theorem . yet , often in the proof of some general result , the need for verifying an inequality like that pops up .",
    "for instance , ( [ b4p ] ) appears in @xcite and ( [ ln ] ) in the proof of the non - negativity of a class of sine polynomials in @xmath4 $ ] .    numerical computation and graphing",
    "provide evidence for the validity of such an inequality , but obviously not as rigorous proofs .",
    "nevertheless , a simple principle makes it possible to use numerics to rigorously prove the inequality .",
    "i dub it the dif technique .",
    "the obvious proof is omitted .",
    "the requirement of having to verify the inequality for all @xmath5 $ ] reduces to checking ( [ g12 ] ) only for a finite number of values .    in applying the principle to ( [ ln ] ) , the increasing functions @xmath6 and @xmath7 and @xmath8 meet the requirement .",
    "the choice of @xmath9 is obviously not unique ; @xmath10 also works .    in checking the inequalities @xmath11",
    ", i merely use the values of the two sides , computed using some numerical computer software .",
    "for example , maple 13 gives @xmath12 some may object to this step on the ground that computer numerics contain rounding errors , thus making it unreliable .",
    "in fact , modern numerical software is highly accurate with calculations involving well - known functions . as long as we keep ourselves within a reasonable scope of the accuracy of the software",
    ", we should be very safe .",
    "maple , by default , does its calculations with an accuracy of 10 digits .",
    "as long as the numerical inequality holds within a 5 or 6 digit accuracy , it should be very reliable . in case of doubt",
    ", one can instruct maple to use a higher number of digits to recheck the inequality .",
    "for the extremely skeptical , they can employ interval arithmetic ( available , for instance , as a toolbox of matlab ) to quench any remaining doubt .",
    "the dif technique is summarized as follows :    to establish inequality ( [ b4p ] ) , one can use @xmath13 which are obviously decreasing functions , and the uniformly spaced sequence @xmath14    alternatively , one can use @xmath15 for which a much shorter sequence is sufficient : @xmath16 to complete the proof , one must fill in a necessary step , namely , to show that @xmath17 and @xmath18 are decreasing . to that end , we can try to show that @xmath19 ( and the analog @xmath20 ) , for which the dif technique is applicable .",
    "_ the procedure has its limitations .",
    "it can not handle non - strict inequalities , when @xmath21 at @xmath22 or @xmath23 or some difficult - to - compute interior point .",
    "sometimes it can serve as part of the proof , using another trick to take care of the non - strict inequality in a neighborhood of the critical point .",
    "a similar remark applies to inequalities in a non - compact interval such as @xmath24 .",
    "_    _ if the inequality involves other variables , e.g.  in the form of parameters , the procedure fails .",
    "again , it may be possible to find a way around the difficulty with some tricks . _    _ what can we do if @xmath25 and/or @xmath26 are not monotone ? _",
    "if their critical points are known , we can simply verify the inequality in each of the sub - intervals sub - divided by the critical points . to handle the general case",
    ", we can choose a sufficient large ( positive or negative ) @xmath27 so that @xmath28 is a difference of two monotone functions . in particular , we can use this technique to verify if a given value is a strict lower / upper bound of a given function .    _ in practice , step 1 together with a decent graphing of the functions @xmath17 and @xmath18 , especially if the software allows you to zoom into any sub - interval of @xmath29 $ ] , is sufficient to offer 99% confidence that the desired inequality is valid .",
    "the provision of the sequence @xmath9 is mainly for the purpose of allowing other people to double check the assertion , especially in cases when @xmath17 and @xmath18 are extremely close together . _",
    "_ for special classes of functions , there are other more efficient numerical procedures . for example , the sturm procedure is the best choice for studying algebraic and trigonometric polynomials .",
    "see @xcite@xcite for details . _",
    "finding or verifying @xmath9 , though conceptually straightforward , is tedious if done manually .",
    "we present a simple maple procedure that can help in this aspect .",
    "let us first describe the usage of the procedure .",
    "the procedure is written in the maple programming language and the code lines are typed into a file , say called dif .",
    "i used maple 13 for the experiments .",
    "very likely , the same code works all for other versions .      in an interactive maple session",
    ", commands can be entered either in text or math mode .",
    "below , the command are shown in the text mode because it is easier to typeset .",
    "the math mode input and output are also shown .    while inside a maple session , the procedure is loaded by using the command read(dif ) .",
    "newer versions of maple do not require the semicolon at the end of the command if typed in the math mode .",
    "some older versions may need it .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... read(dif ) ; g1 : = ( ( 1 - 3*x)/2)*ln((1 - 3*x)/2 ) + 2*((1 - 24*x)/5)*ln((1 - 24*x)/5 ) ; g2 : = 3*((1 - 15*x)/4)*ln((1 - 15*x)/4 ) ; dif(g2 , g1 , [ 0 , 0.04 ] ) ;                    # first format dif(g1 , g2 , [ 0 , 0.04 ] ) ; dif(g1 , g2 , [ 0 , 0.04 ] , long=1 ) ; .... _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in this first format , the third input argument @xmath30 $ ] is a list of two numbers , representing @xmath29 $ ] .",
    "the output is shown below :        the procedure is written to mandate that the first argument is the larger function . in case of an error , the procedure will complain as shown .",
    "the procedure could have been easily rewritten to automatically swap the functions in that situation .",
    "however , i believe that the error checking feature serves as a further insurance of the proper choice of g1 and  g2 .    in the long=1 version , the output is a matrix of five columns . the first column is a count , namely @xmath31 , of the points @xmath9 given in the second column . if @xmath32 are increasing , the third column is @xmath33 and the fourth column is @xmath34 .",
    "if @xmath32 are decreasing , they are @xmath35 and @xmath36 instead . in all cases ,",
    "the values in the third column should be larger than that in the same row of the fourth column ; the fifth column is the difference between these values .",
    "the last three columns are listed as a visual check to make sure that the claimed inequalities ( [ g12 ] ) are valid within reasonable computational errors .",
    "for example , if the values are computed with 10 ( the default in maple ) digit accuracy , then the differences between the values in the third and fourth columns ( i.e. the value in the fifth column ) should be at least @xmath37 .",
    "if this is not true , the procedure can be rerun with increased accuracy , for example , with the maple command `` digits : = 20 '' .",
    "it is the user s responsibility to make sure that g1 and g2 are either both increasing or both decreasing in @xmath38 $ ] . the procedure does not have the intelligence to verify that premise rigorously . in case",
    "that assumption is not valid , the procedure may still output some ( useless ) answer .    to help a bit",
    ", the long=1 option will plot the graphs of g1 ( red curve ) and g2 ( blue ) to allow the user do a visual check .",
    "if the monotonicity of @xmath32 is not obvious , try the dif technique on @xmath39 .",
    "* the variable used in g1 and g2 can be arbitrary .",
    "it does not matter if you have used @xmath40 or @xmath41 ; or @xmath42 .",
    "the procedure automatically detects it . *",
    "if there is more than one variable present in g1 and g2 ( perhaps due to typos ) , an error message will be printed .",
    "more complicated error checking is not available .",
    "it is the responsibility of the user .",
    "* dif fails if it takes more than 100 steps without reaching the right endpoint @xmath23 of the interval .",
    "this can mean either the desired inequality is false or the difference between @xmath25 and @xmath26 so small that it actually requires more than 100 points of @xmath9 .",
    "one can try to exclude the latter by using the steps = n option with a larger n.      by default , dif rounds each @xmath9 down to a number of decimal digits compatible with about one - hundredth of the length of the interval @xmath29 $ ] .",
    "this can be altered with the option digits = n . using a higher n may generate a shorter @xmath9 sequence .",
    "the specification of n is only suggestive .",
    "dif may ignore it if necessary due to computational accuracy .",
    "the next two examples show the second format of the procedure .",
    "the third input argument is a list of more than two numbers , which are interpreted as a sequence of @xmath9 to be verified .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... dif(g1 , g2 , [ 0 , 0.04 ] , digits=5 ) ; dif(g1 , g2 , [ 0 , 0.009 , 0.019 , 0.025 , 0.034 , 0.04 ] )         # second format dif(g1",
    ", g2 , [ 0 , 0.009 , 0.017 , 0.025 , 0.034 , 0.04 ] ) .... _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the output is shown below .",
    "when the supplied sequence @xmath9 does not satisfy ( [ g12 ] ) , the procedure will balk at the first instance of violation and print `` false '' .",
    "failure is also indicated by the fact that the last element of the last column of the displayed matrix is negative .    in case of success ,",
    "the display is similar to the regular long=1 option , but without the graphs of @xmath32 .",
    "if graphs are desired , add long=1 .",
    "we briefly explain the code , assuming that the reader has rudimentary knowledge of maple programming .    the entire code ( with added comments )",
    "is repeated in the appendix .",
    "the reader can use cut and paste to transfer that to a file , called `` dif '' , on the computer .",
    "we break the code ( minus the comments ) up into small chunks .",
    "line numbers are added for reference and are not part of the code ; they should not be typed in the file .",
    "blank lines have been added for aesthetic purposes and are optional .",
    "....    1   ffloor : = ( x , n ) \\rightarrow   subsop(2=-n , convert(floor(x*10^n ) , float ) ) : ....    the first non - comment line in the file defines a separate procedure ffloor which is used by dif , in line 27 .",
    "it is a useful one to add to the regular maple repertoire .",
    "maple has a built - in command floor(x ) to round a floating point number x down to the nearest integer , but there is no command to conveniently round x to the nearest float with a given number of decimal places .",
    "one can achieve the effect by using the command : ` floor(10^n*x)/10^n ` .",
    "the resulting value is correct .",
    "however , it is aesthetically undesirable because , in most cases , it will be printed with some annoying trailing 0 s . using ffloor fixes that .",
    "the rest of the code is dif proper .    ....    2   dif : = proc(g1,g2,a,\\{long:=0,steps:=100,digits:=-100,relax:=99\\ } )    3     local aa , bb , ga , gb , f1 , f2 , tt , t1 , cc , acc , tau , inc , var , ev ; ....",
    "these two lines specify the procedure name dif , the mandatory arguments g1 , g2 , and a , the optional arguments , and the local variables .    ....    4     ev : = ( a , g ) \\rightarrow   evalf(subs(var = a , g ) ) ; ....    the next line defines a procedure ev(a , g ) to be used only internally within dif , essentially as a shorthand for a frequent construction .",
    "it takes an expression g and computes its numerical value when a float a is substituted into the variable contained in g.    ....    5     var : = indets(evalf([g1,g2 ] ) , name ) ;    6     if nops(var ) > 1 then    7        error \" functions have more than one variable : \" , var ;    8     else    9        var : = var[1 ] ;   10     end if ; ....    in line 5 , indets ( ... ) returns a list of variables found in g1 and g2 , and stores it in var . here",
    "evalf is called before invoking indets , because the latter thinks @xmath43 , such as in @xmath44 , as a variable instead of as a constant .",
    "if var has more than one element , then an error is thrown ; otherwise , we change var to mean the sole variable it contains .",
    "....   11     aa : = a[1 ] ; bb : = a[-1 ] ;    12     ga : = ev(aa , g1 ) ; gb : = ev(aa , g2 ) ;   13     if ga < gb then error \" function 1 is smaller .",
    "swap the functions .",
    "\"   14     end if ; ....    here we compute ga = @xmath45 and gb = @xmath46 and make sure that the former is larger .    ....   15",
    "gb : = ev(bb , g2 ) ;     16     if ga < gb then f1 : = g1 ; f2 : = g2 ; inc : = 1 ;    17     else f1 : = -g2 ; f2 : = -g1 ; inc : = 0 ;   18     end if ; ....    next we compute gb = @xmath47 , using it to decide whether @xmath32 are increasing or decreasing ; this information is stored in the flag inc . then f1 and f2",
    "are assigned the appropriate expression , to be used later to compute @xmath9 .    ....",
    "19     if nops(a ) = 2 then             ...   44     else            ...   58     end if ;   59     end proc : ....    the rest of the code is divided into two separate cases : lines 2042 when the user asks for @xmath9 , and lines 4456 when the user wants to verify if the supplied @xmath9 work .",
    "line 59 is the last line of the procedure and also of the file .    ....   20        if digits > 0 then    21           acc : = digits    22        else acc : = 2-floor(log10(bb - aa ) )   23        end if ; ....    these lines assign to acc the number of digits .    ....   24        tau :",
    "= [ aa ] ;   25        tt : = aa ; ga : = ev(aa , f1 ) ; gb : = ev(bb , f2 ) ; cc : = 0 ;     26        for cc from 1 to steps while ( ga < gb ) do   27          t1 : = min(ffloor((relax*fsolve(f2=ga , var = tt .. bb)+tt)/                    ( relax+1),acc),bb ) ;   28          if t1 \\leq   tt then acc : = acc+1 ; next ; end if ;   29          tt : = t1 ; tau : = [ op(tau),tt ] ;   30          ga : = ev(tt , f1 ) ;   31        end do ; ....    the above is the loop to compute @xmath9 .",
    "ideally , if numerical computation were exact ( and all inequalities were replaced by equality ) , then @xmath9 would have been determined recursively by : @xmath48 geometrically , @xmath9 is the successive values of the iterative algorithm depicted in figure 1 .",
    ".,title=\"fig:\",width=453 ]    @xmath49    @xmath50    @xmath51    @xmath52    in practice , we have to make @xmath9 smaller ; this is done in line 27 using relax . by default relax=99 , and that can be altered by the user .",
    "choosing a smaller relax makes @xmath9 smaller .",
    "the variable cc counts the number of iterations .",
    "the loop exits either if cc exceeds the assigned number of steps or if @xmath9 has reached the right endpoint @xmath23 of the interval .",
    "32        if ga < gb then    33           cc : = min(steps,5 ) ;   34           printf ( \"     * * * * fails after % d steps .",
    "last % d steps are : \" ,                  steps , cc ) ;    35           print(tau[-cc .. -1 ] ) ; ....    in the former case , a failure message is displayed .    ....   36        else   37           tau : = [ op(tau),bb ] ;    38           if long = 1 then    39              dif(g1,g2,tau ) ;    40              plot([g1,g2],var = aa .. bb , gridlines = true , size=[550,400 ] ) ;   41           else tau ;    43           end if ;   44        end if ; ....    otherwise , line 36 adds @xmath23 as the last @xmath9 .",
    "if the long=1 option is set , dif is invoked with the second format to print the verbose output , and the graphs of @xmath32 are plotted . without the verbose option , only the sequence tau is displayed .",
    "this final part of the code handles the long display when dif is invoked in the second format , with supplied @xmath9 . in this format , @xmath9 is given in the input variable a. the variable tau , on the other hand , is free to be used for another purpose , namely , to store the matrix containing the five columns of numbers to be displayed at the end .",
    "lines 4553 is the loop to build the rows ( except the last one which is filled in by line 55 ) of the matrix . line 53 prints the partial tau and returns `` false '' in case condition ( [ g12 ] ) fails . line 56 prints the matrix and the job is done .",
    "99 = 1 h. alzer and m.k .",
    "kwong , on the concavity of dirichlet s eta function and related functional inequalities , _ journal of number theory _ 151 ( 2015 ) , 172 - 196 .",
    "= 1 h. alzer and m.k .",
    "kwong , sturm s theorem and a refinement of vietoris inequality for cosine polynomials , arxiv:1406.0689 ( math.ca ) .",
    "= 1 nonnegative trigonometric polynomials and sturm s theorem , arxiv:1507.00494 [ math.ca ] ( 2015 ) .",
    "= 1 nonnegative trigonometric polynomials , sturm s theorem , and symbolic computation , arxiv:1402.6778 [ math.ca ] ( 2014 ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... # cut and past the following lines into a file called \" dif \"    #   ffloor(x , n )          round float x down to n decimal places ffloor : = ( x , n ) - > subsop(2=-n , convert(floor(x*10^n ) , float ) ) :                     # first format of invocation : determine [ tau_k ]       if digits > 0 then           acc : = digits        else acc : = 2-floor(log10(bb - aa ) )       end if ;       tau : = [ aa ] ;       tt : = aa ; ga : = ev(aa , f1 ) ; gb : = ev(bb , f2 ) ; cc : = 0 ;         # loop to determine tau_k       for cc from 1 to steps while ( ga < gb ) do         t1 : = min(ffloor((relax*fsolve(f2=ga , var = tt .. bb)+tt)/(relax+1),acc),bb ) ;         if t1 <",
    "= tt then acc : = acc+1 ; next ; end if ;         tt : = t1 ; tau : = [ op(tau),tt ] ;         ga : = ev(tt , f1 ) ;       end do ;         if ga < gb then           # fail          cc : = min(steps,5 ) ;          printf ( \"     * * * * fails after % d steps .",
    "last % d steps are : \" , steps , cc ) ;          print(tau[-cc .. -1 ] ) ;       else          # success          tau : = [ op(tau),bb ] ;           if long = 1 then              dif(g1,g2,tau ) ;              plot([g1,g2],var = aa .. bb , gridlines = true , size=[550,400 ] ) ;          else tau ;           end if ;       end if ;             # build matrix tau       for cc from 1 to t1 - 1 do          ga : = ev(a[cc+1-inc],g1 ) ; gb : = ev(a[cc+inc],g2 ) ;",
    "if cc = 1 then             tau : = < 1 | a[1 ] | ga | gb | ga - gb > ;          else             tau : = < tau,<cc | a[cc ] | ga | gb | ga - gb > > ;          end if ;          if ga < gb then print(tau ) ; return false ; end if ;       end do ;"
  ],
  "abstract_text": [
    "<S> a numerical procedure and its maple implementation capable of rigorously , albeit in a brute - force manner , proving specific strict one - variable inequalities in specific finite intervals is described . </S>",
    "<S> the procedure is useful , for instance , to affirm strict lower bounds of specific functions .    </S>",
    "<S> # 1 # 2 plus 2pt # 1    # 1    * # 1 *    1ex    # 1    # 1    2ex    # 1 # 1 # 2    man kam kwong    _ department of applied mathematics + the hong kong polytechnic university , + hunghom , hong kong _ +    26.70 , 26a48 , 26a51    inequalities , monotonicity , numerical procedure , maple procedure .    ' '' '' </S>"
  ]
}