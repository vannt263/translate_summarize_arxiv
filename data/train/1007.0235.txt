{
  "article_text": [
    "to date , a solution of the general problem p @xmath1 np has not be found .",
    "if this problem can be solved then it will be most likely on the basis of some common features of the classes p and np .",
    "looking for a solution of any particular p vs np problem seems to lack perspective . if it were possible to obtain , for a particular np problem , that we can not solve it in polynomial time , it would be necessary to supply the complete set of algorithms used in the solution of this problem , which is most likely impossible .",
    "thinking deeper about the np phenomenon and about the possibility of solving such problems leads to some questions : which algorithms , in principle , could be constructed to solve particular np problems ?",
    "can we avoid combinatorial enumeration in such algorithms ?",
    "can we overcome np - completeness with the help of such algorithms ?",
    "garey and johnson @xcite say that polynomial algorithms can be constructed only when it is possible to penetrate deep into the essence of the problem in question .",
    "the success in solving particular np problems using optimization methods is very high ( e.g. @xcite ) .",
    "most likely , here is the key of the difficulty of finding the precise solution , because one can not substitute the essence of the problem by advances in modern optimization technologies .",
    "it is commonly accepted @xcite that the branch and bound method in all np problems is the most universal and effective .",
    "it is possible that branch and bound methods mostly captures the difficulty of the problem as it is based in investigation and transformation of the network .",
    "the solution of the hcp that we offer here is not based on optimization .",
    "it does not contain a progression to a better solution .",
    "this solution is based on the analysis of structural differences between two objects constructed on the basis of the same non - oriented graph with degree less than equal to 3 .",
    ", @xmath2 , @xmath3 .",
    "free edges are @xmath4 , @xmath5 , @xmath6 , @xmath7 .",
    "segments are @xmath8 , @xmath9 , @xmath10.[fig2 - 1],scaledwidth=30.0% ]    given a graph @xmath11 of size @xmath12 , we define object @xmath13 as a figure representing @xmath11 that , by some property or properties , differs from other figures representing the same graph @xmath11",
    ". we can solve the hcp on a set of objects , and construct a parameter for each object such that the parameters should not coincide unless the graph is hamiltonian . while , individually , these objects do not solve hcp , the solution of the problem is obtained on a finite set of the objects , by considering their special properties .",
    "in fact , for any two such figures , we will find a parameter that will distinguish between them .    for certain special cases ,",
    "it is only possible to construct a single , unique figure . in this case , the solution of the hcp is given trivially by construction of this figure .",
    "however , in general , for the solution of hcp , one has to construct two objects that differ in the constitution of edges in different parts of the objects , and in the method of construction of those parts . as an example , in figure 2.1 , we display the first ( basic ) object constructed from a 25-node graph .    for convenience",
    ", we will distinguish between the exterior part of the figure , that we call the contour , and the interior part .",
    "the contour contains the edges of the graph and so - called _",
    "windows_. a window is an edge that does not belong to the graph . in the example in figure 2.1 , there are three windows : @xmath14 , @xmath2 , and @xmath3 , that are formed by the nodes 2 and 6 , 10 and 15 , and 14 and 25 of the graph @xmath11 .    the edges of the interior part of the object , that are not connected at either end to the nodes that form the windows ( for convenience , we refer to these nodes as _ window nodes _ ) , are called _ free _ edges . in the example given in figure 2.1 ,",
    "the free edges are @xmath4 , @xmath7 , @xmath6 , @xmath5 .    as follows from the example , the basic object has the following properties .    1 .",
    "window nodes are not directly connected by the edges of the interior part .",
    "we refer to such edges as _",
    "links_. 2 .",
    "the basic object contains a _ maximal _ number of windows ( three in this example ) .",
    "that is , no further windows can be inserted without violating the previous property .",
    "the contour is partitioned by windows into several parts , and can be determined and enumerated .",
    "the parts of the object separated by windows will be called _",
    "segments_. in the example in figure 2.1 , there are three segments , between nodes 2 and 25 , 14 and 18 , and 6 and 10 , which we denote by @xmath15 , @xmath9 , @xmath16 .",
    "a segment is called _ degenerate _ if it consists of a single node such that has a window on both sides in the contour .",
    "the basic objects that are constructed for the hcp should satisfy the following properties .    1",
    ".   the number of windows in the object should be maximal . as we show later",
    ", we will use a simple algorithm to increase the number of windows , and we will determine the criterion that signals the end of the algorithm .",
    "window nodes should not be connected to other window nodes by the edges of the interior part .",
    "3 .   the object should not contain degenerate segments if the degree of the graph is @xmath17 .",
    "degenerate segments can only exist for nodes of degree @xmath18 .",
    "4 .   for a given graph",
    ", the set of edges in the interior part should be different for any pair of basic objects .",
    "* lemma 1 . * for a degenerate segment - free graph @xmath11 of size @xmath12 , and degree @xmath0 , the number of segments in all basic objects is less than or equal to @xmath19 $ ] .",
    "first , we observe that , by property 1 , the nodes that form the windows are not interconnected .",
    "therefore , every node that forms a window is connected by the edges of the interior part with another two nodes that do not form windows . from the fragment of the graph shown in figure 2.2",
    ", we see that window @xmath20 , together with nodes @xmath21 and @xmath22 constitutes a set of six nodes in the graph . since in the absence of degenerate segments this is true for every window , then there can not be more than @xmath19 $ ] segments .    ,",
    "@xmath23 , @xmath24 , @xmath22 , @xmath25 and @xmath26 that correspond to a window @xmath20 , and its incident nodes .",
    "none of these nodes can be incident to any other window.[fig2 - 2],scaledwidth=25.0% ]    1",
    ".   the number of windows can be larger if there are degenerate segments .",
    "if there are free edges , then the number of free edges is less than @xmath27 .",
    "3 .   if the degree of the graph was not bounded by 3 then the number of windows in the basic object constructed for the graph would be strictly less than @xmath27 .",
    "this is because the nodes that form the windows for @xmath28 will be connected to a larger number of nodes in the graph that , in view of property 2 , can not form windows themselves .       between windows @xmath29 and @xmath30 ( in figure 2.3a ) .",
    "edge @xmath31 is moved to the contour , and windows @xmath29 and @xmath30 are substituted by a single window , @xmath32 ( in figure 2.3b).[fig3ab],scaledwidth=50.0% ]    consider the problem of constructing a basic object that satisfies properties ( 1)(4 ) above .",
    "this can be performed in two steps . in the first step",
    ", we can use elementary procedures that are from known optimization algorithms @xcite , that are described below .",
    "_ step 1 : construction of a graph whose windows are not connected by the edges of the interior part .",
    "_    it is known that optimization algorithms ensure an optimal solution is found by gradually eliminating links between the windows by means of elementary network transformations .",
    "for this reason , they can be used to construct a basic object such that nodes that form the windows are not interconnected .",
    "it is useful to note that for the first step it is sufficient to use the procedure of checking and substitution of no more than two edges on the contour .     between windows @xmath29 and @xmath30 ( in figure 2.4a ) .",
    "edge @xmath33 is moved to the contour , and windows @xmath29 , @xmath30 , @xmath34 are substituted by two windows , @xmath35 and @xmath36 ( in figure 2.4b).[fig4ab],scaledwidth=50.0% ]    there are four possible cases of elimination of links :    * case 1.1 * : we use the transformation that substitutes two windows @xmath29 , @xmath30 ( see figure 2.3a ) , with a single window @xmath32 and edge @xmath31 ( see figure 2.3b ) . in this case , the interior edge between nodes @xmath23 and @xmath24 is moved to the contour .",
    "* case 1.2 * : we use the transformation that substitutes three windows @xmath29 , @xmath30 , @xmath34 ( see figure 2.4a ) , with two windows @xmath35 , @xmath36 , and the interior edge @xmath33 is moved to the contour ( see figure 2.4b ) .    * case 1.3 * : suppose the contour contains a segment @xmath37 , and its endpoints are connected with an interior edge @xmath38 .",
    "suppose that @xmath37 contains a node @xmath39 that is a neighbour to node @xmath40 on the contour , and that is linked by an interior edge @xmath41 with another node that forms a window ( see figure 2.5a ) . in this case",
    ", we use the transformation that substitutes three windows @xmath29 , @xmath30 , @xmath34 with two windows @xmath35 , @xmath42 , and moves two interior edges @xmath38 and @xmath41 to the contour ( see figure 2.5b ) . the edge @xmath43 is moved to the interior .     between windows @xmath29 and @xmath34 ( in figure 2.5a ) .",
    "edges @xmath38 and @xmath44 are moved to the contour , and windows @xmath29 , @xmath30 and @xmath34 are substituted by two windows , @xmath35 and @xmath45 ( in figure 2 - 5b).[fig2 - 5],scaledwidth=50.0% ]    * case 1.4 * : this case differs from case 3 in that @xmath37 does not contain any nodes that are connected with a node that forms a window . in this case , we select a node @xmath39 on @xmath37 for which an interior arc @xmath46 goes to a different segment that contains a node @xmath47 that is a neighbour to node @xmath48 on the contour ( see figure 2.6a ) .",
    "then , we use the transformation that moves edges @xmath38 , @xmath49 to the contour , and substitutes windows @xmath29 and @xmath34 with two windows @xmath50 , @xmath51 ( see figure 2.6b ) .     between windows @xmath29 and @xmath34 ( in figure 2.6a ) .",
    "edges @xmath38 and @xmath46 are moved to the contour , and windows @xmath29 and @xmath34 are substituted by two windows , @xmath50 and @xmath52 ( in figure 2.6b).[fig2 - 6],scaledwidth=50.0% ]    in all of these cases , an interior edge that joins two window nodes is eliminated from the set of interior edges .",
    "the object that we construct after step 1 can contain an arbitrary number of windows , but can not contain degenerate segments formed by nodes of degree @xmath17 .",
    "we can achieve this by elimination of degenerate segments from the object as described as follows .",
    "* case 1.5 * : suppose that a degenerate segment contains node @xmath53 that form two windows @xmath29 , @xmath54 ( see figure 2.7a ) .",
    "suppose that node @xmath53 has degree @xmath17 , and is connected to nodes @xmath55 , @xmath39 and @xmath56 , none of which form windows . to eliminate @xmath57",
    ", we use the transformation that moves two interior edges @xmath58 and @xmath59 to the contour , and substitutes windows @xmath29 and @xmath54 with two windows @xmath60 , @xmath61 ( see figure 2.7b ) .",
    "( in figure 2.7a ) .",
    "edges @xmath58 and @xmath59 are moved to the contour , and windows @xmath29 and @xmath54 are substituted by two windows , @xmath62 , @xmath63(in figure 2.7b).[fig2 - 7],scaledwidth=50.0% ]    * case 1.6 * : if at least one of nodes @xmath55 , @xmath39 and @xmath40 forms a window , then the degenerate segment @xmath57 is eliminated from the object by either of cases 1.1 and 1.2 above .",
    "we note that the above cases are sufficient to eliminate all interior edges between windows , and all degenerate segments , which completes step 1 .",
    "_ step 2 : introduction of additional windows _",
    "we can introduce additional windows if there are special structures involving the free edges in the object formed in step 1 . recall that the free edges are those that are not incident to any window nodes .",
    "we note that introduction of additional windows should not introduce any links , or else property 1 will be violated .",
    "the windows are added by means of elementary transformations of one free edge to the contour , and two edges of the contour to the interior .",
    "there are two cases when it is possible to introduce an additional window to the object formed in step 1 :     ( in figure 2.8b ) , using free edges @xmath64 , @xmath65 and @xmath66 ( in figure 2.8a).[fig2 - 8],scaledwidth=50.0% ]    * case 2.1 * : suppose that an object formed in step 1 contains free edges @xmath65 , @xmath66 and @xmath64 such that @xmath40 is a neighbour of @xmath47 on the contour , @xmath55 is a neighbour of @xmath48 on the contour , and @xmath55 and @xmath40 are on different sides of edge @xmath64 .",
    "nodes @xmath39 and @xmath56 can be anywhere on the contour ( see figure 2.8a ) .",
    "an additional window @xmath67 is introduced by the transformation that moves interior edge @xmath64 to the contour , and moves edges @xmath68 and @xmath69 to the interior ( see figure 2.8b ) .",
    "this transformation is also valid if one or both of the edges @xmath65 and @xmath66 are not present . in this case , one or both of nodes @xmath55 and @xmath40 will have degree 2 .    * case 2.2 * : suppose than on object formed in step 1 contains free edges @xmath65 , @xmath66 and @xmath64 , such that @xmath40 is a neighbour of @xmath47 on the contour , and @xmath55 is a neighbour of @xmath48 on the contour , and nodes @xmath55 , @xmath40 and",
    "@xmath56 are all on the same side of edge @xmath64 , and a window @xmath29 exists ( see figure 2.9a ) . an additional window can be formed by a transformation of the part of the contour bounded by nodes @xmath40 and @xmath55 . in figure 2.9a , this is the part of the contour to the left of edge @xmath64 ) to become a segment between nodes @xmath53 and @xmath23 ( see figure 2.9b ) . as a result of this transformation ,",
    "we substitute window @xmath29 with windows @xmath70 and @xmath71 .",
    "this transformation is also valid if one or both of the edges @xmath65 and @xmath66 are not present . in this case ,",
    "one or both of nodes @xmath55 and @xmath40 will have degree 2 .     and @xmath55 between @xmath53 and @xmath23 that form window @xmath29 ( in figure 2.9a ) .",
    "this transformation substitutes window @xmath29 by two windows , @xmath70 and @xmath71 ( in figure 2.9b).[fig2 - 9],scaledwidth=50.0% ]    therefore , in both cases , if we have a special configuration of free edges , we can construct additional windows so that the edges @xmath65 , @xmath66 , @xmath64 are no longer free .",
    "if the object contains configurations analogous to those considered above ( see figures 2.8a , 2.9a ) , then additional edges should be moved to its contour .",
    "we note that none of these transformations should be performed if they result in degenerate segments that contain a node whose degree @xmath17 .",
    "a basic object is completed if it is does not contain free edges that could lead to the introduction of additional windows using the transformations described above .",
    "in such a case , we say that the number of windows in the object is maximal .",
    "note that depending on the construction of the graph , it may be possible to construct a different object containing more windows , but it is not necessary to do so .",
    "a basic object may contain one or more free edges , if the configuration of those free edges does not coincide with those described above .",
    "this is the only criteria required to complete the second step of the construction of a basic object .",
    "the second basic object should possess the same properties ( see subsection 2.1.1 ) as the first basic object .",
    "the second basic object is constructed from the first basic object .",
    "the two basic objects will have no common interior edges .",
    "this requires us to introduce additional restrictions in the algorithm for constructing the second basic object , that is otherwise analogous to the algorithm that constructs the first basic object .",
    "these restrictions concern the structure of the contour , and specify the nodes which can not not become window nodes in the second basic object .",
    "we satisfy these new requirements in the first step of the construction of the second object .",
    "suppose that the first basic object is constructed , and satisfies all of the required properties .",
    "then , we identify :    1 .   the window nodes , and the interior edges incident to these nodes .",
    "the number of such edges will be either two ( if the node has degree @xmath17 ) , or one ( if the node has degree @xmath18 ) .",
    "2 .   the free edges . 3 .",
    "degenerate segments that contain a single node of degree @xmath18 .",
    "the set of nodes with degree @xmath18 that do not form windows .",
    "note that the first basic object can not contain any interior edges or nodes of degree @xmath18 that can be different from the cases described above .",
    "this phenomenon is determined by the properties of the construction of the first basic object : the original graph has degree @xmath0 ; the windows of the first basic object are not linked by interior edges ; and the first basic object does not contain degenerate segments of degree @xmath17 .    the first basic object is constructed without restrictions on the contour edges , interior edges , or on the configuration of nodes with degree @xmath18 .",
    "the construction of the second basic object depends on the particular structure of the first basic object .",
    "_ algorithm of the preliminary construction of the second basic object : _    1 .",
    "identify in the first basic object : 1 .",
    "_ chains _ that consist of two interior edges that are both incident to a window node of degree @xmath17 .",
    "interior edges that are incident to the window nodes of degree @xmath18 .",
    "these nodes will form windows in the second basic object as well .",
    "3 .   free edges . 4 .",
    "chains that consist of two interior edges incident to a node of degree @xmath18 that form a degenerate segment .",
    "nodes of degree @xmath18 that do not form windows .",
    "these nodes will form degenerate segments in the second basic object .",
    "the identified chains consisting of two edges , free interior edges , and the degenerate segments of degree @xmath18 all move to the contour , and are all separated by windows .",
    "connect the nodes of the contour in the second basic object by interior edges that belong to the contour of the first basic object .",
    "4 .   now ,",
    "we eliminate some interior edges some interior edges from the second basic object that can not be moved to the contour . these are edges that are : 1 .   incident to window nodes of degree @xmath18 .",
    "2 .   incident to window nodes in the first basic object , and belong to its contour .",
    "mark those nodes that can not form windows . by means of the first two algorithms of eliminating links between windows ( see subsection 2.1.2 , cases 1.1 and 1.2 ) move , to the contour , interior edges incident to these marked nodes . 6 .",
    "mark edges of the contour that can not be moved to the interior .     from the list of candidates for window nodes by elimination of the link between windows @xmath72 , @xmath73 ( see figures 2.10a and 2.10b).[fig2 - 10],scaledwidth=50.0% ]     and @xmath24 from the list of candidates for window nodes by elimination of the link between windows @xmath71 , @xmath74 ( edge @xmath75 ) , and between windows @xmath76 , @xmath77 ( edge @xmath78 ) ( see figures 2.11a and 2.11b).[fig2 - 11],scaledwidth=80.0% ]    1",
    ".   consider , in more detail , the possible situations of the appearance of nodes in the second basic object that can not form windows ( corresponding to step ( 5 ) above ) , and the elimination of those nodes .",
    "suppose that in the first basic object , there are window nodes of degree @xmath18 .",
    "then , if edge @xmath79 that is incident to node @xmath53 belongs to the contour of the first basic object , then the second basic object will contain on the contour an edge @xmath80 incident to the same node @xmath53 , which again forms a window in the second basic object ( see figure 2.10a ) . in the second basic object the node",
    "@xmath24 should not form a window .",
    "if it does , then the second basic object violates the rules outlined in section 2 . in this case , by removing a link between windows @xmath72 and @xmath73 , we can delete node @xmath24 from the candidates to form windows in the second basic object .",
    "we eliminate this link ( interior edge @xmath81 ) in one of two ways described in section 2 . in figure 2.10a",
    ", the positions of windows @xmath72 and @xmath73 imply that the first method should be used . in another configuration of those windows ,",
    "the second method would be used .",
    "the situation when nodes @xmath53 and @xmath24 have degree @xmath18 ( edge @xmath81 is not present ) can not happen , because two adjacent nodes of degree @xmath18 are substituted by a single node of degree @xmath18 .",
    "2 .   suppose that the first basic object contains node @xmath53 of degree @xmath18 that does not form a window , and edges @xmath80 and @xmath79 belong to the contour .",
    "then , node @xmath53 should form a degenerate segment in the second basic object , and nodes @xmath23 and @xmath24 should not form windows ( see figure 2.11a ) . if this condition was violated , then the second basic object would have windows linked by interior edges , which would violate the rules outlined in subsection 2.1.1 . as in item ( a ) above , nodes @xmath23 and",
    "@xmath24 are eliminated from the set of nodes that can form windows in the second basic object by temporarily deleting edges @xmath75 , @xmath82 , between pairs of windows @xmath71 and @xmath74 , and @xmath76 and @xmath83 respectively ( see figure 2.11b ) .",
    "the situation when nodes @xmath53 and @xmath24 , and @xmath53 and @xmath23 have degree @xmath84 ( edges @xmath75 and @xmath82 are absent ) is not possible , as two or more adjacent nodes of degree @xmath18 can be substituted by a single node of degree @xmath18 .",
    "we note that elimination of links between windows by means of the algorithms described in subsection 2.1.2 , cases 1.1 and 1.2 , are performed so as to substitute one of the two windows of the contour by a single interior edge . by doing this , neither edge of the contour is moved to the interior .    1 .",
    "one of the properties of the basic objects is that they have a disjoint set of interior edges . in the preliminary construction of the second basic object ,",
    "the interior edges of the first basic object are all moved to the contour of the second basic object . during the subsequent steps",
    ", their movement to the interior will be prohibited .",
    "this restriction on moving these particular contour edges to the interior is achieved by temporarily deleting interior edges that can not belong to the contour ( item ( 4 ) above ) .",
    "then , the subproblems of the construction of the second basic object whose windows are not linked by interior edges , and of the introduction of additional windows into the second basic object , are performed as outlined in subsection 2.1.2 .",
    "this completes the preliminary construction of the second basic object .      ,",
    "scaledwidth=40.0% ]    , scaledwidth=40.0% ]    , scaledwidth=40.0% ]    construction of the second basic object is performed using the same algorithm as the construction of the first basic object , that is , the construction of an object whose windows are not linked by interior edges , and the subsequent introduction of additional windows .",
    "consider the following example .    in figure 2.1 , the first basic object for a certain 25-node graph is displayed .",
    "the construction of the second basic object proceeds as follows :    1 .   in the first basic object ,",
    "we select : 1",
    ".   chains of the interior that consist of two edges incident to the window nodes : @xmath85 , @xmath86 ; @xmath87 , @xmath88 ; @xmath89 , @xmath90 ; @xmath91 , @xmath92 ; @xmath93 , @xmath94 .",
    "interior edges that are incident to window nodes of degree @xmath18 : @xmath95 .",
    "free edges : @xmath6 , @xmath4 , @xmath7 , @xmath5 .",
    "2 .   the above selected edges separated by windows ,",
    "form the preliminary contour ( see figure 2.12 ) : ( 16 - 14 - 13 w 4 - 10 - 11 w 1 - 6 - 5 w 7 - 2 - 3 w 21 - 18 - 19 w 20 - 25 w 8 - 15 w 22 - 24 w 17 - 23 w 9 - 12 ) .",
    "3 .   connect nodes ( see figure 2.13 ) by interior edges that were not selected in ( 1 ) , and correspond to contour edges in the first basic object : @xmath96 , @xmath97 , @xmath98 , @xmath99 , @xmath100 , @xmath101 , @xmath102 , @xmath103 , @xmath104 , @xmath105 , @xmath106 , @xmath107 , @xmath108 , @xmath109 , @xmath110 , @xmath111 , @xmath112 , @xmath113 , @xmath114 , @xmath115 , @xmath116 , @xmath117 .",
    "4 .   from the set of interior edges ,",
    "we temporarily remove those edges that can not be moved to the contour of the second basic object : @xmath113 , @xmath110 , @xmath117 , @xmath96 , @xmath114 , @xmath109 ( see figure 2.14 ) .",
    "once these edges are temporarily removed , node 25 becomes an end node ( that is , node 25 acquires degree @xmath118 ) , and nodes 24 , 9 , 15 , 1 , 7 , 17 acquire degree @xmath18 .",
    "mark the nodes that can not form windows . in this example",
    ", node @xmath119 can not form a window .",
    "this node is circled ( see figure 2.14 ) . by the algorithm of eliminating links between window nodes",
    "( see subsection 2.1.2 , case 1.2 ) , we move the edge @xmath108 , incident to node 24 , to the contour .",
    "this completes the preliminary construction of the second basic object ( see figure 2.15 ) .",
    ", @xmath120.[fig2 - 15],scaledwidth=40.0% ]    , @xmath100 , @xmath98 , @xmath102 are identified that determine a possibility of forming additional windows.[fig2 - 16],scaledwidth=40.0% ]    we note that the second object at this stage does not contain window nodes of degree @xmath18 .",
    "for this reason , this second object does not contain degenerate segments .",
    "the edges of the contour of the first basic object that should also belong to the contour of the second basic object , and therefore can not be moved to its interior , are displayed in bold ( see figure 2.15 ) .",
    "an object whose windows are not linked by interior edges ( see figure 2.16 ) is constructed using the algorithm described in @xcite ( which uses the steps outlined in subsection 2.1.2 , cases 2.12.4 ) . at this stage ,",
    "construction of the object whose windows are not linked by interior edges is complete .",
    "the next step is to introduce additional windows .",
    "we use the same algorithm ( in subsection 2.1.2 ) that was used in the construction of the first basic object .",
    "if we encounter an instance where an additional window can be introduced by means of free edges , then we introduce this window and continue to search until all instances are exhausted . in our example ( see figure 2.16 ) , there are at most four possibilities of introduction of an additional windows .",
    "the object contains four free edges : @xmath102 , @xmath98 , @xmath121 , @xmath104 , that determine the number of possibilities .",
    "consider all possible ways to introduce an additional window by using any of the listed four free edges .",
    ".[fig2 - 17],scaledwidth=40.0% ]     is formed by moving edge @xmath102 to the contour , and edges @xmath101 , @xmath122 to the interior.[fig2 - 18],scaledwidth=40.0% ]     is formed by moving edge @xmath100 to the contour , and edges @xmath99 , @xmath101 to the interior.[fig2 - 19],scaledwidth=40.0% ]    , scaledwidth=40.0% ]    1 .",
    "there exists a free edge @xmath100 and node 1 of degree @xmath18 that are adjacent to the free edge @xmath98 on one side ( see figure 2.16 ) .",
    "an additional window is introduced by moving part of the contour bounded by nodes @xmath123 and @xmath124 between any two nodes that form a window . in this example , window @xmath125 or @xmath126 .",
    "we move this part of the contour between nodes 22 and 25 ( see figure 2.17 ) .",
    "2 .   free edges @xmath100 and @xmath104 are adjacent to free edge @xmath102 on two different sides ( see figure 2.16 ) .",
    "an additional window @xmath127 is introduced by moving edge @xmath102 to the contour , and edges @xmath101 and @xmath122 to the interior ( see figure 2.18 ) .",
    "3 .   free edges @xmath98 and @xmath102 are adjacent to free edge @xmath100 on two different sides ( see figure 2.16 ) .",
    "an additional window @xmath128 is introduced by moving edge @xmath100 to the contour , and edges @xmath99 and @xmath101 to the interior ( see figure 2.19 ) .",
    "4 .   free edge @xmath104 ( see figure 2.16 ) can not be used to introduce an additional window because node 20 does not have adjacent nodes that satisfy the possibility of introduction of additional windows ( edge @xmath106 is not a free edge , and node 25 forms a window ) .    from all of these possibilities ,",
    "only one can be implemented .",
    "two or more possibilities can not be implemented in this example because , otherwise , the condition of absence of links between windows will be violated .",
    "the second object with the temporarily deleted edges being reintroduced is displayed ( see figure 2.20 ) . comparing the first ( see figure 2.1 ) and the second basic objects ( see figure 2.20 ) we observe the following :    1 .",
    "the sets of interior edges for each basic object are disjoint .",
    "the contours for each basic object contain a number of common edges : @xmath98 , @xmath101 , @xmath116 , @xmath111 , @xmath103 , @xmath129 , @xmath108 , that appeared during the construction of the second basic object .",
    "these edges are marked by dotted lines ( see figure 2.20 ) .",
    "3 .   no links exist in either basic objects .",
    "suppose that we have constructed both basic objects for a graph of degree @xmath0 .",
    "suppose that such a graph contains one or more hamiltonian cycles .",
    "edges of the graph can be naturally separated in three disjoint groups :    1 .",
    "edges that belong to all hamiltonian cycles .",
    "2 .   edges that belong to no hamiltonian cycles .",
    "3 .   edges that belong to some but not all hamiltonian cycles .",
    "some edges from both basic objects can be separated into two disjoint groups :    1 .",
    "interior edges of both basic objects ( these sets of disjoint ) .",
    "common edges of the contours of both basic objects .",
    "the procedure of selection of edges includes not only separation into group , but also the assigning of weights to some edges that determines the weights of all other edges , and of windows in both basic objects .",
    "the assigning of weights can be performed for an additional edge or window of the contour , or to a group of edges and windows .        to any edge of the contour , a weight can be assigned .",
    "we assign a particular weight ( -1 , 0 , or + 1 ) to an edge or window of the contour of a basic object , that determines the weights of all other edges and windows of the basic object .",
    "initially , the weights of all edges and windows are 0 .",
    "suppose that we select a contour edge @xmath66 .",
    "if @xmath12 is odd , we assign weight -1 to this edge , and then we perform the following operations :    1 .",
    "assign weight -0.5 to nodes @xmath40 and @xmath56 .",
    "2 .   moving along the nodes of the contour , starting with node @xmath48 adjacent to node @xmath40 we assign to each node alternating weights + 0.5 , -0.5 .",
    "the weight of every edge and every window is assigned by adding the weights of their adjacent nodes . with this approach",
    "we obtain : 1 .",
    "the weight of one particular edge ( edge @xmath66 ) becomes -1 .",
    "the weight of all contour edges and windows other than @xmath66 remain 0 .",
    "any interior edge attains the weight attains a value that can be -1 , 0 or 1 .",
    "we could also assign the initial weight of -1 to a window @xmath130 , and perform the same operations as above .",
    "if @xmath12 is even , we assign weight 0 to edge @xmath66 , and then we perform the following operations :    1 .",
    "assign weights + 0.5 to node @xmath40 , and -0.5 to node @xmath56 .",
    "moving along the nodes on the contour , starting with node @xmath47 adjacent to node @xmath40 we assign to each node alternative weights -0.5 , + 0.5 .",
    "the weight of every edge and every window is assigned by adding the weights of their adjacent nodes . with this approach",
    "we obtain : 1 .",
    "the weight of all contour edges and windows ( including @xmath66 ) remain 0",
    "any interior edge attains the weight attains a value that can be -1 , 0 or 1 .",
    "consider the result of the selection of edges of a basic object , assuming that the contour of this basic object is a fictitious hamiltonian cycle .",
    "a fictitious hamiltonian cycle is a contour of a basic object whose windows , initially , have the same 0 weight as its edge .",
    "suppose that a graph contains one or more hamiltonian cycles .",
    "suppose that one of the contour edges is selected and assigned a weight of -1 . independently of whether or not this edge belongs to a hamiltonian cycle , the combined length of any hamiltonian cycle will be equal to -1 .",
    "if the selected edge is given a weight of + 1 , then the length of every hamiltonian cycle will also be + 1 .",
    "this is because , on the contour , by our assumption , a fictitious hamiltonian cycle , where the windows become fictitious edges with 0 weight , and the selection of any edge or window implies the same change in the length of any real hamiltonian cycles as the same of any fictitious hamiltonian cycle . consider the following cases :    1 .",
    "suppose that a selected edge belongs to all hamiltonian cycles .",
    "then , by the construction of one such hamiltonian cycle , part of the contour edges should be substituted by interior edges .",
    "since the combined weight of the substituted contour edges equals 0 , and the total length of the hamiltonian cycle is determined by the weight of the selected edge , then the combined weight of the interior edges that substitute the contour edges should also be 0 . 2 .",
    "suppose that the selected edge of weight -1 belongs to a some but not all hamiltonian cycles .",
    "regardless of which hamiltonian cycle is constructed ( with or without this edge ) , the combined weight of the interior edges that substitute contour edges in the hamiltonian cycle will be equal to the combined weights of those contour edges .",
    "if the selected edge belongs to the constructed hamiltonian cycle , then this combined weight will be 0 .",
    "if the selected edge does not belong to the constructed hamiltonian cycle , then the combined weight will be -1 .",
    "3 .   suppose that the selected edge of weight -1 does not belong to any hamiltonian cycle .",
    "then , in the construction of a hamiltonian cycle , this edge should be substituted , and the combined weight of the interior edges that are used in the hamiltonian cycle , and the combined weights of the contour edges that are not used in the hamiltonian cycle , will be -1 .",
    "4 .   suppose that we select a window of weight -1 .",
    "it can be considered as a fictitious edge that does not belong to any hamiltonian cycle , and so should be substituted by an interior edge . in this case , the previous argument is valid : in the construction of a hamiltonian cycle that does not contain the selected window , the combined weights of the interior edges that are used in the hamiltonian cycle , and the combined weights of the contour edges that are not used in the hamiltonian cycle , will be -1 . 5 .",
    "the claims ( 1)(4 ) are valid in the case of selection of any contour edge or window in either basic object .",
    "however , one can select a set of contour edges and/or windows . since in the construction of a hamiltonian cycle ,",
    "relative to any selected contour edge or window , the combined weight of the substituting interior edges is equal to the combined weight of the contour edges that are being substituted , this property will be valid for any number of simultaneously selected contour edges and windows .",
    "hence , the common argument is the following :    1 .   in the construction of a hamiltonian cycle ,",
    "the combined weight of substituted contour edges and windows is equal to the combined weight of the substituting interior edges , and this effect does not depend on whether selected edges belong to the hamiltonian cycle .",
    "2 .   if we simultaneously select a set of contour edges and windows then the combined weights of the substituting interior edges , and this effect does not depend on whether selected edges belong to the hamiltonian cycle .",
    "we note that the assigning of weights in turn assigns weights to the edges of the basic objects .",
    "however , it is also convenient to assign weights to the nodes of the basic objects .",
    "if a node is assigned -0.5 or + 0.5 , then it is means that edges incident to this node gain the weight -0.5 or + 0.5 .",
    "we can select not just a single edge , but a group of edges .",
    "suppose that two basic objects of the same graph are constructed .",
    "the contours of both basic objects contain common contour edges .",
    "each edge of this group could or could not belong to a particular hamiltonian cycle , if any exist .",
    "now we solve the problem of selection of common contour edges . by means of this subproblem",
    ", we will define some characteristics of the basic objects that will determine the hamiltonicity of the graph .",
    "the procedure of selection of common contour edges is as follows .",
    "the task is to select common contour edges of basic objects under the following conditions :    1 .",
    "the weights of the nodes incident to common contour edges in each basic object should be identical .",
    "2 .   the weights of the common contour edges could be -1 , 0 or 1 . 3 .",
    "the interior edges of both basic objects should have 0 weights .",
    "if this is impossible , the correction procedure is performed ( see subsection 3.2.3 ) and then the combined weight of interior edges should be 0 for each object .",
    "we can formulate a dual to the subproblem of selecting common contour edges of the basic objects .",
    "it differs from the above problem by the condition that the contour edges that are not common should all have zero weight .",
    "we can request , in both primal and dual subproblems , that weights of the nodes incident to common contour edges should be identical , not only in both basic objects , but in both subproblems as well . in this case",
    ", the difference in the solution of this subproblem will be in assigning weights to other nodes that are not incident to common contour edges .",
    "in the primal subproblem , weights of those nodes should be assigned in such a way that all interior edges have zero weights . in the dual subproblem , the contour edges that are not common for both basic objects should have 0 weight . these two can be simultaneously achieved .",
    "furthermore , we show that the solution of each of these subproblems can be used to solve hcp .        , scaledwidth=85.0% ]    , scaledwidth=40.0% ]    assigning of weights to edges of the objects is a part of the solution to hcp .",
    "first , we will consider examples of assigning weights to contour edges and interior edges that satisfy the required conditions .",
    "also , we will determine the sequence of such assignment algorithm .",
    "determine the set of contour edges for each object .",
    "the set of common contour edges is determined by comparing the two sets of contour edges together .",
    "one of the conditions of assigning weights to the edges implies that the nodes of the common contour edges should have identical weights in both objects .",
    "for this reason , these nodes , and the contour edges between them , should be selected as a separate subgraph common to both objects .    on the basis of two objects ,",
    "select a subgraph that contains :    1 .",
    "common contour edges . 2 .",
    "edges of each object that link two common contour edges . in both objects , they are the same .",
    "interior edges that are incident to window nodes .",
    "these sets will be disjoint for each object .",
    "consider the following example of the selection of a subgraph for the two objects displayed in figure 3.1 .",
    "the subgraph ( see figure 3.2 ) consists of the following edges :    1 .   edges",
    "@xmath98 , @xmath101 , @xmath103 , @xmath105 , @xmath108 , @xmath111 , @xmath116 are common contour edges . 2 .   interior edges @xmath102 and @xmath131 that link common contour edges .",
    "3 .   pairs of edges that in each object incident are incident to the window nodes . in the first object",
    "they are @xmath94 , @xmath132 ; @xmath88 , @xmath133 ; @xmath92 , @xmath134 ; @xmath86 , @xmath135 . in the second object",
    "they are @xmath105 , @xmath136 ; @xmath100 , @xmath137 .",
    "for the node @xmath138 having @xmath139 edges @xmath140 , @xmath141 .    1 .   for the nodes of the selected subgraph , we need to assign the weights .",
    "this algorithm has to satisfy a number of conditions , as follows . 1 .",
    "the nodes that are incident to common contour edges should have equal weight in both objects .",
    "because the subgraph is common in both objects , then the weights assigned to its edges will be the same in both objects .",
    "the weight of the common edges can be -1 , 0 or + 1 .",
    "the edges of the subgraph that link nodes incident to common contour edges should have 0 weight .",
    "the pairs of edges that are adjacent to a window node of degree 3 , that in one object are interior edges , should have 0 weights .",
    "in the other object , this pair of edges will be contour edges and the weight of these edges is not yet determined , and could be -1 , 0 or + 1 depending on other weight assignments .",
    ", scaledwidth=20.0% ]    , scaledwidth=25.0% ]    consider an example of weight assignment for the subgraph shown in figure 3.2 .    1 .   to all window nodes",
    ", we assign the weight + 0.5 . in figure 3.2",
    "( and other figures ) we represent this assignment only by displaying the sign of the weight .",
    "these nodes are nodes 2 , 10 , 18 , 14 , 22 , 5 and 25 . in general",
    ", we can assign to these nodes the weight + 0.5 or -0.5 .",
    "if there is a node in the subgraph linked to two window nodes , then the two window nodes should be assigned the same weight , either + 0.5 or -0.5 simultaneously . in this example , the weights for nodes 2 , 14 and 25 can be assigned independently .",
    "the weights of nodes 18 and 22 , however , must be the same as each other .",
    "this is because edges @xmath132 and @xmath142 are incident to node 21 , that is incident to the common contour edge @xmath105 .",
    "this is determined by the fact that two edges @xmath132 and @xmath142 are interior edges ( one edge is interior in one object , and the other edge is interior in the other object ) , and should therefore have 0 weight .",
    "an analogous argument is valid for nodes 10 and 5 , for which the weight should therefore be equal .",
    "because the weight of the edges incident to window nodes 2 , 10 , 18 , 14 , 22 , 5 and 25 should be equal to 0 , then nodes 23 , 21 , 19 , 13 , 11 , 4 , 3 , 7 , 16 , 20 , 24 have weight -0.5 .",
    "since edge @xmath143 is interior in one of the basic objects , and has weight -1 , then we need to reassign the weight of one of the windows nodes from + 0.5 to -0.5 .",
    "nodes 19 and 20 that are incident to this node in both object have interior edges that link them to window nodes ( 18 and 25 ) . the weight of one of these nodes should be changed from + 0.5 to -0.5 .",
    "we assign the weight -0.5 to node 25 having @xmath139 .",
    "then , nodes 20 and 24 should be assigned the weight + 0.5 .    1 .   in the subgraph , we select islands that are parts of the subgraph such that their extreme ( endpoint ) nodes have weights -0.5 , or the weight is unassigned .",
    "an island can not contain pairs of edges that are incident to window nodes .",
    "for this example , the islands are displayed in figure 3.3 . in assigning weights to nodes of an island",
    ", one can use patterns displayed in the example of assigning weights to the nodes of chains , including different number of common edges .",
    "if the subgraph contains chains with common contour edges ( see figure 3.4 ) , then the extreme nodes @xmath53 and @xmath23 of the chains can have any weights associated with the choice of the weight of common edges , in particular , -0.5 . in figure 3.4 , we display examples of assigning weights to the nodes of chains containing one , two or three common edges . by variation of the choice of weight for a particular edge , with any number of common edges in the chain ,",
    "the extreme nodes can be assigned equal or opposite weights .",
    "we note that the situation when the extreme nodes are assigned opposite weights remains unchanged for any number of common edges in the chain .",
    "furthermore , we need to assign weights to nodes of the islands that can have only one value . such is node 12 whose weight can only be + 0.5 .",
    "we assign weights to chain @xmath144 ( see figure 3.3 ) .",
    "they are assigned according to the rule displayed in figure 3.4 . if , to node 8 , we assign the weight + 0.5 , then to node 15 we should assign the weight -0.5 , and vice versa .",
    "this completes the algorithm of selection of common contour edges , and assigning weights to the corresponding nodes . as a result of this algorithm , the nodes that are incident to common contour edges",
    "are assigned identical weights in both objects .",
    "also , the edges of the subgraph that belong to three selected sets are assigned admissible weights . in figures 3.1 , 3.2 and 3.3",
    ", the signs of the weights are displayed next to the nodes .      as a result of the selection of common contour edges , some but not all nodes of the objects are assigned weights .",
    "the above algorithm allows us to assign weights to the nodes incident to common contour edges , and also to the window nodes .",
    "the next problem is to assign weights to the nodes that have not yet been assigned a weight .",
    "the missing weights are assigned according to the condition that interior edges must have 0 weights , and are therefore determined by the weights assigned already to other nodes in the above algorithm . in figure 3.1 ,",
    "the nodes whose weights are assigned at this step are circled .",
    "we note that objects may contain nodes whose weights can not be assigned using the above conditions .",
    "for example , in figure 3.1 , nodes 1 , 6 and 5 are not assigned weights .",
    "this is because nodes 1 and 5 are not incident to common contour edges .",
    "the choice of weight of a window node ( in this example , node 6 ) is made on the basis of comparison of the sums of the weights of both objects , and is considered later . the weight of any edge is defined as the sum of the weights of the nodes incident to this edge . in figure 3.1 , the zero weights are not displayed .      1 .",
    "determine the contour edges for each object .",
    "2 .   on the basis of two objects ,",
    "select a subgraph that contains : 1 .",
    "common contour edges . 2 .",
    "edges of each object that link two common contour edges . in both objects , they are the same .",
    "3 .   the sets of interior edges that are incident to window nodes . these sets of disjoint for each object .",
    "3 .   assign weights to the nodes of this subgraph using the algorithm outlined in subsection 3.2.1 .",
    "identify the islands in the above subgraph and assign weights to the nodes contained in the islands using the algorithm also outlined in subsection 3.2.1 .",
    "assign weights to remaining nodes using the algorithm outlined in subsection 3.2.2 .",
    "if in one or both objects there remains nodes without weights assigned , then we assign to those nodes weights according to the rules will be described later .",
    "determine the weight of the edges as the sum of the weights of the nodes incident to this edge .",
    "if , among the interior edges of one or both objects , there appears a nonzero weight , then we apply the following correction algorithm for this object .",
    "_ correction algorithm _    , scaledwidth=85.0% ]    1 .",
    "determine the sum of the weights of interior edges for both objects .",
    "suppose that the sum is @xmath145 ( @xmath146 ) .",
    "the number @xmath147 can only be integer ( -1 , 0 or + 1 ) because the weight of each edge is determined by the sum of the weights of its adjacent nodes .",
    "2 .   change the weight of the edges incident to @xmath147 nodes by + 1 ( -1 ) in such a way that the sum of interior edges becomes 0 .",
    "these edges can not be 1 .",
    "window nodes .",
    "nodes incident to a common contour edges .",
    "nodes with degree @xmath84 .    ,",
    "scaledwidth=40.0% ]    , scaledwidth=20.0% ]    at this stage , the general algorithm of assigning weights to the edges of the objects is complete .",
    "next , we consider examples of assigning weights to edges of objects .    in figure 3.5",
    ", we display two basic objects that satisfy all required conditions .",
    "now we explain how we assign weights to the edges of these objects .    1 .",
    "determine the common contour edges .",
    "in figure 3.5 , the common contour edges are displayed in bold , and they are @xmath92 , @xmath148 , @xmath149 , @xmath150 , @xmath151 .",
    "2 .   on the basis of these two objects ,",
    "select a subgraph that contains : 1 .",
    "common contour edges . 2 .",
    "edges @xmath152 , @xmath153 , @xmath154 , @xmath155 that link nodes incident to common contour edges . 3 .",
    "interior edges incident to the window nodes .",
    "these are @xmath88 and @xmath156 from the first object , and @xmath97 , @xmath157 ; @xmath158 , @xmath159 from the second object .",
    "3 .   assign weights to the nodes of the selected subgraph . 1 .   to window nodes 10 , 1 , 13 , assign weight + 0.5 .",
    "if there is a node in the subgraph linked to two window nodes , then these window nodes must be assigned the same weight + 0.5 ( nodes 10 and 13 ) .",
    "2 .   to nodes 11 , 3 , 4 , 8 , 15 , that are linked with window nodes by a single edge ,",
    "assign the weight -0.5 .",
    "4 .   in the subgraph ,",
    "select the islands .",
    "the pairs of edges incident to a window node can not be part of any island .",
    "assign weights to the nodes in these islands .",
    "first , determine the nodes whose weights are predetermined by previous weight assignments . in this example , nodes 7 and 6 can only have weight + 0.5 .",
    "this choice is determined by the condition that edges @xmath155 and @xmath152 must have 0 weight .",
    "then , the weight of node 12 can only be -0.5 .",
    "the choice of weights for nodes 9 and 2 can be taken arbitrarily . in our example , both edges are assigned the weight -0.5 . in figures 3.5 , 3.6 and 3.7 ,",
    "the weights are displayed next to the nodes .",
    "assign weights to the nodes that have not been assigned a weight in the previous steps .",
    "they are assigned in accordance with the condition that the weights of interior edges should be 0 .",
    "the final assignment of weights is displayed in figure 3.5 , where the weights of edges are also displayed .",
    "the nodes for which the weights are determined during this stage are circled .    ,",
    "scaledwidth=85.0% ]    , scaledwidth=40.0% ]    in figure 3.8 , two basic objects satisfying the required conditions are displayed .",
    "we assign weights to the edges of these objects .    1 .",
    "determine the common contour edges .",
    "in figure 3.8 , the common contour edges are displayed in bold , and they are @xmath98 , @xmath117 , @xmath114 , @xmath102 , @xmath110 , @xmath160 , @xmath132 .",
    "2 .   on the basis of these two objects , select a subgraph ( see figure 3.9 ) that contains : 1 .",
    "common contour edges . 2 .",
    "edges @xmath5 , @xmath105 , @xmath87 that link nodes incident to common contour edges . 3 .",
    "interior edges incident to the window nodes .",
    "these are @xmath115 and @xmath6 ; @xmath97 , @xmath89 ; @xmath122 , @xmath104 ; @xmath142 , @xmath4 from the first object , and @xmath161 , @xmath162 ; @xmath137 , @xmath163 from the second object .",
    "3 .   assign weights to the nodes of the selected subgraph . 1 .   to window nodes 8 , 1 , 19 , 5 , 22 , 25 , assign weight + 0.5",
    ". 2 .   to nodes 13 , 9 , 4 , 6 , 3 , 21 , 20 , 24 , 14 , 15 , that are linked with window nodes by a single edge ,",
    "assign the weight -0.5 . since edge @xmath105 is interior in one of the basic objects , and has weight -1",
    ", then we need to reassign the weight of one of the windows nodes from + 0.5 to -0.5 .",
    "nodes 20 and 21 that are incident to this node in both object have interior edges that link them to window nodes ( 19 and 22 ) . the weight of one of these nodes should be changed from + 0.5 to -0.5 .",
    "we assign the weight -0.5 to node 22 .",
    "then , nodes 21 and 24 should be assigned the weight + 0.5 .",
    "4 .   in the subgraph ,",
    "select the islands .",
    "the pairs of edges incident to a window node can not be part of any island .",
    "assign weights to the nodes in these islands .",
    "first , determine the nodes whose weights are predetermined by previous weight assignments . in this example",
    ", nodes 10 and 12 can only have weight + 0.5 .",
    "this choice is determined by the condition that edges @xmath5 and @xmath87 must have 0 weight .",
    "then , the weight of nodes 7 and 18 can be taken arbitrarily . in our example , both edges are assigned the weight -0.5 . in figures 3.8 , 3.9 and 3.10 , the weights are displayed next to the nodes .",
    "assign weights to the nodes that have not been assigned a weight in the previous steps .",
    "they are assigned in accordance with the condition that the weights of interior edges should be 0 .",
    "the final assignment of weights is displayed in figure 3.8 , where the weights of edges are also displayed .",
    "the nodes for which the weights are determined during this stage are circled .    ,",
    "scaledwidth=20.0% ]    , scaledwidth=85.0% ]    in figure 3.11 , two basic objects satisfying the required conditions are displayed .",
    "we assign weights to the edges of these objects .    1 .",
    "determine the common contour edges .",
    "in figure 3.11 , the common contour edges are displayed in bold , and they are @xmath96 , @xmath163 , @xmath151 , @xmath101 .",
    "2 .   on the basis of these two objects , select a subgraph ( see figure 3.12 ) that contains : 1 .",
    "common contour edges . 2 .",
    "edges @xmath164 , @xmath121 , @xmath5 that link nodes incident to common contour edges . 3 .",
    "interior edges incident to the window nodes .",
    "these are @xmath165 and @xmath166 ; @xmath167 , @xmath168 ; from the first object , and @xmath169 , @xmath170 from the second object .",
    "3 .   assign weights to the nodes of the selected subgraph . 1 .   in the subgraph",
    "there are nodes 2 and 6 , that are linked to two window nodes .",
    "node 6 is linked to window nodes 4 and 8 , and node 2 is linked to window nodes 3 and 4 . in this case , all window nodes 3 , 4 , 8 are assigned a weight + 0.5 . 2 .   nodes 2 , 6 , 5 , 7 that are linked to the window nodes , are assigned a weight -0.5 .",
    "4 .   in the subgraph ,",
    "select the islands ( see figure 3.13 ) .",
    "the pairs of edges incident to a window node can not be part of any island .",
    "assign weights to the nodes in these islands .",
    "first , determine the nodes whose weights are predetermined by previous weight assignments .",
    "because one of the islands contains a link between nodes 9 and 12 , then these nodes should be assigned opposite weights .",
    "assign weight + 0.5 to node 9 , and weight -0.5 to node 12 .",
    "then , the weight of node 11 must be -0.5 . in figures 3.11 , 3.12 and 3.13 ,",
    "the weights are displayed next to the nodes .",
    "assign weights to the nodes that have not been assigned a weight in the previous steps .",
    "they are assigned in accordance with the condition that the weights of interior edges should be 0 .",
    "the final assignment of weights is displayed in figure 3.11 , where the weights of edges are also displayed .",
    "the nodes for which the weights are determined during this stage are circled .",
    ", scaledwidth=40.0% ]    , scaledwidth=25.0% ]    as follows from figure 3.11 , edge @xmath164 that links nodes incident to common contour edges @xmath90 and @xmath151 is assigned a weight -1 . in the second object ,",
    "edge @xmath164 is an interior edge .",
    "this weight assignment contradicts the condition that interior edges must have zero weight . after performing the correction algorithm , which we now outline",
    ", we will still be able to perform the test for hamiltonicity of the graph .",
    "the underlying principal of the correction algorithm will be that in the basic objects , the sum of weights of interior edges must be 0 .",
    "we need to increase or decrease the weight of the edges incident to a node of an object that contains an interior edge of nonzero weight .",
    "this node can not be a window node ( in this case , node 4 or 10 ) , nor nodes that are incident to common contour edges ( in this case , nodes 1 , 2 , 5 , 6 , 7 , 9 , 11 , 12 ) , as the weights of these node should be the same in each object .",
    "therefore , in this example , we can only use nodes 3 and 8 .",
    "we select node 3 , and increase change its weight from -0.5 to + 0.5 .",
    "this increases the weight of all edges incident to node 3 by + 1 .",
    "this will ensure that the sum of weights of the interior edges in the second object is zero .",
    "the second object , with the corrected edge weights , is displayed in figure 3.14 .",
    ", scaledwidth=40.0% ]    therefore , we can now determine the sum of weights of the contour edges , and the sum of weights of the windows .",
    "these parameters are necessary to determine the hamiltonicity of the original graph .",
    "if both basic objects , after undergoing the algorithms outlined in section 3 , have equal sums of weights of contour edges ( @xmath171 ) , and equal sums of weights of their windows ( @xmath172 ) , then the original graph is hamiltonian .",
    "if either of these equalities are violated , the graph is not hamiltonian .    1 .   on transformed objects :",
    "+ consider basic objects that we subject to testing .",
    "suppose that we construct two basic objects .",
    "they do not intersect on interior edges , or on uncommon contour edges .",
    "suppose that the weight assignment algorithm is completed .",
    "+ we next take the union of both basic objects .",
    "the interpretation of the union of one basic object with a second basic object is that we receive the first basic object , where the weight for each edge is the sum of weights of that edge in each basic object .",
    "thus , by finding the union of the first basic object with the second , and also finding the union of the second basic object with the first , we form two new basic objects that have the structure of the two original basic objects , and equal weights .",
    "the interior edges of the first union object will consist of the uncommon contour edges of the second basic object , and vice versa . if , in the first and second basic objects , the sum of contour weights was the same ( @xmath171 ) and the sum of window weights was the same ( @xmath173 ) , then in the union objects , the weight of the contour will increase by the sum of weights of the common contour edges , which is equal in both objects .",
    "the weight of the interior edges for each union object will be equal to the sum of weights of uncommon contour edges in the alternate basic object . if @xmath174 , this implies that the sum of weights of interior edges in both union objects will be the same .",
    "thus , if in the first two basic objects , @xmath171 , and @xmath173 , then likewise the sum of weights of contour edges , and windows , will be the same in the union objects as well .",
    "using analogous arguments , it can be seen that if @xmath175 , or @xmath176 , these inequalities are preserved in the union objects as well .",
    "+ we note that if we were required to perform the correction algorithm , that led to @xmath171 and @xmath173 , then these equalities will be preserved for the union objects as well .",
    "this is because the sum of the weights of interior edges is equal to 0 , and therefore will not change the sum of weights of the contour edges in the union objects .",
    "if we now perform _ equivalent transformations _ , which are described below , then the weight of interior edges in the union objects will become 0 by means of the transformations of the first kind listed below , that do not lead to the violation of the equalities .",
    "if @xmath175 , or @xmath177 , then this inequalities will also be preserved in the union objects after the correction algorithm is performed .",
    "+ suppose that in the first object the length of the hamiltonian cycle was @xmath178 , and in the second it was @xmath179 .",
    "then in the union objects , it will be equal to @xmath180 .",
    "the interior edges of the union objects will have weights -1 , 0 or + 1 .",
    "2 .   on equivalent transformations .",
    "+ equivalent transformations are performed with the aim to confirm the equality of the length of hamiltonian cycles in the constructed basic objects .",
    "these lengths should be such that if interior edges have zero weights , then the length of a hamiltonian cycle in each basic object should be equal to the length of its contour .",
    "since the interior edges in the constructed basic objects have weights -1 , 0 and + 1 , an equivalent transformation would consist of consecutive annihilation of weights of -1 and + 1 of interior edges .",
    "these equivalent transformations can be divided into two groups : 1 .",
    "the first group consists of the transformations that , while annihilating the weight of an edge , does not change the length of the contour , and therefore does not change the length of a hamiltonian cycle .",
    "the second group consists of the transformations that do change the length of the contour while annihilating the weight of an edge , and consequently change the length of a hamiltonian cycle by the same value simultaneously in two basic objects .",
    "+ consider an equivalent transformation of the first type .",
    "suppose we can select @xmath55 interior edges of weight + 1 and @xmath55 interior edges of weight -1 .",
    "we change the weight of @xmath55 interior edges of weight + 1 by using weight -1 that is assigned to nodes that are incident to these interior edges , excluding window nodes .",
    "analogously , we annihilate the weight of @xmath55 interior edges of weight -1 using weight + 1 that is assigned to nodes that are incident to these interior edges , excluding window nodes .",
    "this allows us to annihilate the weight of @xmath181 interior edges .",
    "+ consider a transformation of the second type .",
    "this transformation is equivalent if , in both basic objects , there appears a weight of the same sign .",
    "suppose that @xmath182 ( @xmath171 , @xmath172 ) .",
    "then , the entire annihilation of the weights of interior edges requires adding the same number of weights of the same sign in each basic object that leads to equal , simultaneous , change in the length of a hamiltonian cycle , by assigning zero weights to interior edges of both basic objects . as in the previous case ,",
    "the weights are added to nodes that do not form windows .",
    "the number of added weights depends on the number of interior edges of one basic object with positive weight ( @xmath183 ) , and the number of interior edges in the same basic object with negative weight ( @xmath184 ) .",
    "+ it is possible to identify other equivalent transformations of the second type , using window nodes , however all of them change the length of contour , and therefore a hamiltonian cycle by the same value .",
    "3 .   on hamiltonian graphs .",
    "+ suppose that in two union objects , the sum of contour weights are equal ( @xmath171 ) and the sum of window weights are equal ( @xmath185 ) , that was also true in the original basic objects .",
    "it is known that if the weights of the interior edges are all zero , then : 1 .   in the construction of cycles",
    ", we will omit some of the contour edges , and all of the window edges",
    "we substitute these edges with some interior edges .",
    "the sum of the weights of contour edges and windows that are omitted is equal to the sum of the weights of the interior edges they are substituted with .",
    "+ since the sum of the weights of interior edges that we use for the substitution equals zero ( because all interior edges have zero weight ) , then the length of any possible hamiltonian cycle is equal to the length of the contour ( @xmath186 , @xmath187 ) .",
    "+ the remainder of the proof will show , by means of equivalent transformations , that two union objects will take a form that will allow us to determine the length of any hamiltonian cycle in these forms .",
    "this will be done by ensuring that the interior edges in both union objects have zero weight .",
    "+ we perform equivalent transformations in two union objects . because the sum of weights of the interior edges in both union objects are equal to each other ,",
    "then the composition of the set of interior edges in these objects is the following : 1 .   without loss of generality ,",
    "assume that the weight of the interior is nonnegative .",
    "in the first union object , there are @xmath188 edges with negative weight , and at least @xmath188 edges with positive weight . after equivalent transformations of type 1",
    ", we denote the number of remaining interior edges of positive weight as @xmath189 .",
    "2 .   using analogous arguments to in ( 1 ) , and the fact that the interior edges in both union objects have equal weight , then after equivalent transformations of type 1 , the number of remaining interior edges of positive weight is @xmath40 in the second union object as well .",
    "+ we can alter the weight of these @xmath40 edges in both union objects using equivalent transformations of the second type , to reduce their weight to zero .",
    "these equivalent transformations will change the weight of the contour in both union objects by @xmath190 , and therefore the weights of the contours will remain equal to each other . thus , is in the basic objects @xmath171 and @xmath173 , then the equivalent transformations to the form where @xmath191 and @xmath192 , and therefore @xmath182 , which confirms the existence of a hamiltonian cycle .",
    "4 .   on non - hamiltonian graphs .",
    "+ suppose that in two union objects , @xmath175 and @xmath193 .",
    "without loss of generality , assume that the sum of weights of the interior edges in the first union object is nonnegative .",
    "then , after we perform equivalent transformations of type 1 , there will remain @xmath194 interior edges of positive weight in the first union object .",
    "then , in the second union object , there will remain @xmath55 interior edges with nonzero weight , and the sum of weights of the interior edges in each union object after these equivalent transformations of type 1 is different .",
    "+ at this stage , it is not possible to reduce the weights of all interior edges in both union objects to zero by means of equivalent transformations of type 2 .",
    "since the existence of a hamiltonian cycle implies that the length of any hamiltonian cycle should be equal in both union objects , this proves that graph is non - hamiltonian .",
    "this concludes the proof .",
    "finally , we check the hamiltonicity for the graphs displayed in figures 3.1 , 3.5 , 3.8 and 3.11 .    in figure 3.1 ,",
    "the two basic objects with the completed algorithm of assignment of weights are displayed ( see example 4 ) .",
    "it was suggested that node @xmath195 in the first basic object ( see figure 3.1 ) could be assigned weight -0.5 ( or + 0.5 ) .",
    "the nodes 1 and 5 are assigned weights + 0.5 ( or -0.5 ) .",
    "since we are trying to solve hcp , which is determined by equating @xmath178 and @xmath179 , the choice of weights + 0.5 or -0.5 is entirely determined by the condition @xmath196 .",
    "if node @xmath195 is assigned the weight + 0.5 in the first basic object , it implies that @xmath197 ( @xmath198 , @xmath199 ) , and for the second basic object @xmath200 ( @xmath201 , @xmath202 ) . since @xmath182 , the graph , according to the main theorem , is hamiltonian .    in figure 3.5 ,",
    "the two basic objects with the completed algorithm of assignment of weights are displayed ( see example 5 ) . as a result of this algorithm ,",
    "all edges and windows of the objects are assigned weights -1 , 0 or + 1 .",
    "we determine the sum of weights of the contours of each object , which is supposed to be the length of a hamiltonian cycle .",
    "we obtain @xmath203 ( @xmath204 , @xmath205 ) , and @xmath206 ( @xmath207 , @xmath202 ) . because @xmath208 , @xmath209 , @xmath176 ) , then the graph , according to the main theorem , is non - hamiltonian .    in figure 3.8 ,",
    "the two basic objects with the completed procedure of assignment of weights are displayed ( see example 6 ) . as a result of this procedure ,",
    "all edges and windows of the objects are assigned weights -1 , 0 or + 1 .",
    "we determine the sum of weights of the contours of each object , which is supposed to be the length of a hamiltonian cycle .",
    "we obtain @xmath210 ( @xmath211 , @xmath205 ) , and @xmath212 ( @xmath213 , @xmath202 ) . because @xmath208 ( @xmath175 , @xmath176 ) , then the graph , according to the main theorem , is non - hamiltonian .    in figure 3.11 ,",
    "the two basic objects with the completed procedure of assignment of weights , after the correction procedure is also applied , are displayed ( see example 7 ) . as a result of these algoritms , all edges and windows of the objects",
    "are assigned weights -1 , 0 or + 1 .",
    "we determine the sum of weights of the contours of each object , which is supposed to be the length of a hamiltonian cycle .",
    "we obtain @xmath203 ( @xmath204 , @xmath205 ) , and @xmath214 ( @xmath215 , @xmath216 ) . because @xmath182 ( @xmath217 , @xmath173 ) , then the graph , according to the main theorem , is hamiltonian .",
    "the solution of the hcp consists of several consecutive subproblems :    1 .",
    "construction of a basic object : 1 .",
    "construction of an object whose windows are not linked by interior edges",
    "introduction of additional windows . 2 .",
    "construction of the second object : 1 .",
    "preliminary formation of the second object .",
    "2 .   construction of an object whose windows are not linked by interior edges .",
    "introduction of additional windows .",
    "selection of common edges of the contours of both objects , including assignment of weights to the nodes of both objects ( and therefore to the edges of both object ) .",
    "4 .   determination of parameters of both objects , and comparison of these parameters to determine the existence of a hamiltonian cycle in the graph .    we will now estimate the complexity of each of the above subproblems that are equivalent to the hcp .    1 .",
    "construction of a basic object : 1 .",
    "construction of an object whose windows are not linked by interior edges - this subproblem consists of separate individual algorithms that eliminate links between windows .",
    "the order in which these individual algorithms are performed is determined by the configuration of the windows and the presence of degenerate segments containing nodes whose degree @xmath17 .",
    "each of these procedures moves an interior edge linking window nodes to the contour , and moves one of the contour edges to the interior .",
    "the initial number of windows ( some of which may violate the required properties ) is less than or equal to @xmath12 .",
    "each procedure can be performed by a single search of all nodes , and no corrections ( or doubling back ) are required .",
    "this proves that the complexity of this subproblem is polynomial , because the number of algorithms can not be more than @xmath12 .",
    "2 .   introduction of additional windows  this subproblem consists of separate individual algorithms that introduce additional windows .",
    "the order in which these individual algorithms are performed is determined by the configuration of windows , and by the presence of free edges .",
    "each of these algorithms moves two of the contour edges to the interior , and one free edge to the contour , creating an additional window .",
    "the initial number of windows after the previous step is less than or equal to @xmath218 $ ] . during this algorithm ,",
    "two contour edges are substituted with one free edge , and with an additional window .",
    "this substitution can be performed by a single search of all free edges of the object , and no corrections ( or doubling back ) is required .",
    "this proves that the complexity of this subproblem is polynomial , because the number of algorithms can not be more @xmath218 $ ] .",
    "2 .   construction of the second object : 1 .",
    "preliminary formation of the second object  this subproblem consists of separate individual algorithms that construct the initial formation of the second object .",
    "these algorithms are the construction of the initial contour , the determination of nodes that should not form windows , and temporary elimination of these nodes .",
    "the order in which these individual algorithms are performed is determined by the configuration of the first basic object , i.e. , the number its windows , the position of the windows on the contour , the presence of nodes of the degree @xmath219 , presence of degenerate segments , and the presence of free edges . once these algorithms have been completed , the final algorithm is the temporary elimination of interior edges that can not belong to the contour of the second object , and for which no further algorithms apply .",
    "1 .   construction of the initial contour  this algorithm consists of a sequence of rearrangements of the first basic object by moving the interior edges to the contour , and rearranging some nodes of degree @xmath18 .",
    "the number of such nodes is less than @xmath12 .",
    "2 .   determination and elimination of nodes that should not form windows  this algorithm identifies nodes that are incident to edges that are linked to window nodes of degree @xmath18 .",
    "the algorithm of eliminating these nodes also involves the elimination of links between windows .",
    "the number of nodes that can not form windows of the second object is determined by the number of nodes of degree @xmath18 , which is less than @xmath12 .",
    "3 .   elimination of interior edges that can not belong to the contour  this algorithm identifies interior edges and temporarily deletes them from the object .",
    "the number of interior edges that are deleted is dependent on the number of windows in the first basic object , and the number of nodes with degree @xmath18 in the second object .",
    "+ hence , since each of the individual algorithms that construct the preliminary form of the second object is performed less than @xmath12 times , each performed by a single search on the nodes of the contour , and no corrections ( or doubling back ) are required , the complexity of this subproblem is polynomial .",
    "+ elimination of interior edges that can not belong to the contour prohibits the movement of certain contour edges to the interior .",
    "the subproblems 2(b ) and 2(c ) can be performed as described as in 1(a ) and 1(b ) .",
    "3 .   selection of common edges and assignment of weights to the edges of the object .",
    "this subproblem consists of individual algorithms that : 1 .",
    "identify contour edges that are common for both basic objects .",
    "2 .   assigns equal weights , in both basic objects , to nodes incident to common edges .",
    "3 .   assigns zero weights to all interior edges in either basic object .",
    "if this is impossible , apply the correction algorithm to ensure that the sum of weights of the interior edges is zero .",
    "+ the algorithm of identifying common contour edges consists of comparing contour edges of both objects , and is performed by a single search of the contour edges of both objects .",
    "+ the weights of the nodes that are incident to the common edges should be the same .",
    "this is achieved through the assigning of weights to the subgraph that is common to both objects .",
    "this will ensure that the weight of every common contour edge will be the same in both objects .",
    "the assignment of weights to the edges that link nodes incident to common contour edges is achieved by means of islands that are identified in the subgraph . in those cases when the weight of an interior edge is nonzero",
    ", then we apply the correction algorithm that makes the sum of the weight of interior edges equal to zero . as a result of the weight assignment ,",
    "the sum of weights of the interior edges is zero .",
    "this is achieved by assigning the weights + 0.5 ( or -0.5 ) to a node @xmath53 , and if there is an interior edge @xmath80 , then the weight -0.5 ( or + 0.5 ) should be assigned to node @xmath23 .",
    "+ therefore , since all algorithms of this subproblem are performed no more than @xmath12 times , the complexity of this subproblem is polynomial .",
    "4 .   determination of parameters of both objects  the parameters that determine the hamiltonicity of the graph are sums of weights of edges , and the sums of weights of windows of both basic objects . if for both basic objects , these parameters are equal , the graph is hamiltonian .",
    "these parameters are determined by adding the weights of less than @xmath12 contour edges , and the weights of no more than @xmath218 $ ] windows , in each basic object .",
    "therefore , the complexity of computing these parameters is polynomial",
    ".    therefore , the complexity of performing all of the above subproblems is polynomial .",
    "the described solution of the hcp based on the construction of two basic objects for a given graph can be considered as surprising .",
    "the hcp for graphs of degree @xmath0 is np - complete , but it is just a particular case of hcp for general non - oriented graphs .",
    "however , its solution provides a hope for the solution of the general @xmath220 .",
    "the question of construction of basic objects for other np - complete problems remains open , and further hard work is required to prove the existence of such objects .",
    "it is worth mentioning that these results on the existence of hamiltonian cycles identify an algorithm to construct the cycle , if it exists .",
    "a separate article will be devoted to the construction of this algorithm .",
    "the author is grateful to v. ejov ( school of mathematics and statistics , unisa ) , and m. haythorpe ( school of mathematics and statistics , unisa ) for useful discussions and questions .",
    "9 m.  r.  garey and d.  s. johnson . _ computers and intractability : a guide to the theory of np - completeness _ ( w.  h. freeman & co. , new york , 1979 ) .",
    "i.  i.  goray and l.  i.  goray , _ computer system configured in supporter of solving np - complete problems at high speed _ ( united states patent no . 5 , 535,840 b1 , international intellectual group , inc . , 2003 ) . g.  gutin and a.  p.  punnen ( eds ) , _ the traveling salesman problem and its variations _ ( kluwer academic publishers , boston , 2002 ) .",
    "d.  s.  hochbaum ( ed ) , _ approximation algorithms for np - hard problems _ ( pws publ .",
    "co. , boston , 1997 ) .",
    "s.  arora and m.  sudan , `` improved low - degree testing and its applications '' , _ acm stoc _ ( 1997 ) http://www.cs.princeton.edu/@xmath221arora/pubs/ldtest.ps .",
    "e.  balas and n.  christofides , `` a restricted lagrangean approach to the traveling salesman problem '' , _ math",
    ". progr . _ * .",
    "21 *  ( 1 ) ( 1981 ) 1946 .",
    "m.  held and r.  m. karp , `` traveling salesman problem and minimum spanning trees : part ii '' , _ math .",
    "_ , * 1 * ( 1971 ) 625 . e. l. lawler , d. e. wood , `` branch - and - bound methods : a survey '' , _ or _",
    "* 14 * ( 1966 ) 699719 .",
    "website at : http://www.pcgrate.com/download ."
  ],
  "abstract_text": [
    "<S> any graph can be represented pictorially as a figure . </S>",
    "<S> moreover , it can be represented as two or more figures that can be have different properties to each other . for the purpose of hcp </S>",
    "<S> , we represent a graph by two such figures . in each of them </S>",
    "<S> , there is an exterior part called the _ contour _ , and an interior part . </S>",
    "<S> these two figures differ from each other by the constitution of the edges in the interior part . </S>",
    "<S> that is , any edges in the interior part for one figure are not in the interior for the other figure . </S>",
    "<S> we call these two figures _ </S>",
    "<S> basic objects_.    we develop rules and algorithms that allow us to represent any graph of degree @xmath0 by two basic objects . </S>",
    "<S> individually , neither of these representations possess the features to easily determine the hamiltonicity of the graph </S>",
    "<S> . however , the combination of these two figures , once certain weights are assigned to their edges , allows us to determine the hamiltonicity with a polynomial - time check .    </S>",
    "<S> the rules for the assignment of weights are :    1 .   </S>",
    "<S> the weight of any edge of the interior part is 0 , for both objects . 2 .   </S>",
    "<S> in both figures any common edge of the contour has the same weight .    </S>",
    "<S> the weights of the edges allow us to extend the number of parameters of the objects , that is sufficient to determine the hamiltonicity of the graph . </S>",
    "<S> then , if the graph is hamiltonian , then both figures possess the same set of parameters . </S>",
    "<S> if the sets of parameters for two figures are different , then the graph is not hamiltonian . </S>",
    "<S> the parameters that determine the hamiltonicity of the graph are the sums of weights of edges and _ windows _ of contours in the figure . </S>",
    "<S> the algorithms of their construction do not contain a combinatorial number of elements and have polynomial complexity . </S>",
    "<S> we also supply an estimate of the complexity of each algorithm .    </S>",
    "<S> p vs np , hcp , hamiltonicity of graphs , graphs of degree less than or equal to 3 , equivalent graphs , graph representation by basic objects , contour and interior parts of graphs , assignment weights to edges and nodes , hamiltonian cycle length    68q25 , 68r10 , 03d15 </S>"
  ]
}