{
  "article_text": [
    "using a team of vehicles to accomplish an objective can be effective for problems involving a set of tasks distributed in space and time .",
    "examples of such problems include multi - target intercept  @xcite , terrain mapping  @xcite , reconnaissance  @xcite , and surveillance  @xcite . to achieve effective solutions , in general , a vehicle team needs to follow a cooperative policy .",
    "the generation of such a policy has been the subject of a rich literature in cooperative control .",
    "a sample of the noteworthy work in this field includes a language for modeling and programming cooperative control systems  @xcite , receding horizon control for multi - vehicle systems  @xcite , non - communicative multi - robot coordination  @xcite , hierarchical methods for target assignment and intercept  @xcite , cooperative estimation for reconnaissance problems  @xcite , mixed integer linear programming methods for cooperative control  @xcite , the compilation on multi - robots in dynamics environments  @xcite , and the compilation on cooperative control and optimization  @xcite .",
    "when multi - vehicle teams operate in dynamically changing and uncertain environments , which is often the case , a model predictive approach  @xcite can be used to provide feedback .",
    "this approach involves frequently recomputing the team control policy in real - time .",
    "however , because these systems are often hybrid dynamical systems , computing a cooperative policy is often computationally hard .",
    "the challenge addressed in this paper is to ( 1 ) develop a method to generate near - optimal cooperative policies quickly and ( 2 ) to effectively implement the method .    in our previous work on cooperative control",
    "@xcite we developed mixed integer linear programming methods because of their expressiveness and ease of modeling many types of problems .",
    "the drawback is that real - time planning is infeasible because of the computational complexity of the approach .",
    "this motivated us to develop a trajectory primitive decomposition approach to the problem .",
    "this approach finds near - optimal solutions quickly , allowing real - time implementation , and can be tuned to balance the tradeoff between optimality and computational effort for the particular problem at hand .",
    "the drawback , compared to our previous work , is that it is limited to cooperative control problems in which vehicle tasks can be clearly defined and efficient primitives exist .    in this paper , we present our trajectory primitive decomposition approach . we analyze the average case behavior of the approach by solving instances of a cooperative control problem derived from cornell s roboflag environment . and",
    "finally , we implement the approach in a hierarchical architecture with variable replanning rates at each level and test the implementation in a dynamically changing and uncertain roboflag environment .",
    "the trajectory primitive decomposition involves the introduction of a set of tasks to be executed by the vehicles , allowing the problem to be separated into a low - level component , called task execution , and a high - level component , called task assignment .",
    "the task execution component is formulated as an optimal control problem , which explicitly involves the vehicle dynamics .",
    "given a vehicle and a task , the goal is to find the control inputs necessary to execute the given task in an optimal way .",
    "the task assignment component is an np - hard  @xcite combinatorial optimization problem .",
    "the goal is to assign a sequence of tasks to each vehicle so that the team objective is optimized .",
    "task assignment does not explicitly involve the vehicle dynamics because the task execution component is utilized as a trajectory primitive .",
    "we have developed a branch and bound algorithm to solve the task assignment problem .",
    "one of the benefits of this algorithm is that it can be stopped at any time in the solution process and the output is the best feasible assignment found in that time .",
    "this is advantageous for real - time applications where control strategies must be generated within a time window . in this case ,",
    "the best solution found in the time window is used .",
    "another advantage is that the algorithm is complete ; given enough time , it will find the optimal solution .    to analyze the average case performance of the branch and bound solver",
    ", we generate and solve many instances of the problem .",
    "we look at computational complexity , convergence to the optimal assignment , and performance variations with parameter changes .",
    "we found that the solver converges to the optimal assignment quickly .",
    "however , the solver takes much more time to prove the assignment is optimal . therefore ,",
    "if the solver is terminated early , the best feasible assignment found in that time is likely to be a good one .",
    "we also found several phase transitions in the task assignment problem , similar to those found in the pioneering work  @xcite . at the phase transition point ,",
    "the task assignment problem is much harder to solve . for cooperative control problems involving adversaries ,",
    "the transition point occurs when the capabilities of the two teams are comparable .",
    "this behavior is similar to the complexity of balanced games like chess  @xcite .",
    "finally , we implement the methods in a multi - level architecture with replanning occurring at each level , at different rates ( multi - level model predictive control ) .",
    "the motivation is to provide feedback to help handle dynamically changing environments .",
    "the paper is organized as follows : in section  [ sec : mvta ] , we state the multi - vehicle cooperative control problem and introduce the decomposition . in section",
    "[ sec : roboflag ] , we introduce the example problem used to motivate our approach . in section  [",
    "sec : bb ] , we describe our solver for the task assignment problem , and in section  [ sec : analysis ] , we analyze its average case behavior .",
    "finally , in section  [ sec : mpc ] , we apply our solver in a dynamically changing and uncertain environment using a multi - level model predictive control architecture for feedback .",
    "a web page that accompanies this paper can be found at  @xcite .",
    "the general multi - vehicle cooperative control problem consists of a heterogeneous set of vehicles ( the team ) , an operating environment , operating constraints , and an objective function .",
    "the goal is to generate a team strategy that minimizes the objective function .",
    "the strategy in its lowest level form is the control inputs to each vehicle of the team .    in  @xcite",
    ", we show how to solve this problem using hybrid systems tools .",
    "this approach is successful in determining optimal strategies for complex multi - vehicle problems , but becomes computationally intensive for large problems .",
    "motivated to find faster techniques , we have developed a decomposition approach described in this paper .",
    "the key to the decomposition is to introduce a relevant set of tasks for the problem being considered . using these tasks",
    ", the problem can be decomposed into a task completion component and a task assignment component .",
    "the task completion component is a low level problem , which involves a vehicle and a task to be completed .",
    "the task assignment component is a high level problem , which involves the assignment of a sequence of tasks to be completed by each vehicle in the team .",
    "_ task completion _ : given a vehicle , an operating environment with constraints , a task to be completed , and an objective function , find the control inputs to the vehicle such that the constraints are satisfied , the task is completed , and the objective is minimized .",
    "_ task assignment _ : given a set of vehicles , a task completion algorithm for each vehicle , a set of tasks to be completed , and an objective function , assign a sequence of tasks to each vehicle such that the objective function is minimized .    in the task assignment problem , instead of varying the control inputs to the vehicles to find an optimal strategy",
    ", we vary the sequence of tasks assigned to each vehicle . this problem is a combinatorial optimization problem and does not explicitly involve the dynamics of the vehicles .",
    "however , in order to calculate the objective function for any particular assignment , we must use the task completion algorithm .",
    "task completion acts as a primitive in solving the task assignment problem , as shown by the framework in figure  [ fig : taframe ] . using the low level component ( task completion ) , the high level component ( task assignment ) need not explicitly consider the detailed dynamics of the vehicles required to perform a task .",
    "to motivate and make concrete our decomposition approach , we illustrate the approach on an example problem derived from cornell s multi - vehicle system called roboflag . for an introduction to roboflag ,",
    "see the papers from the invited session on roboflag in the proceedings of the 2003 american control conference  @xcite . in  @xcite",
    ", protocols for the roboflag drill are analyzed using a computation and control language .",
    "the roboflag drill involves two teams of vehicles , the defenders and the attackers , on a playing field with a circular region of radius @xmath0 at its center called the defense zone ( figure  [ fig : drill ] ) .",
    "the attackers objective is to fill the defense zone with as many attackers as possible .",
    "they have a fixed strategy in which each moves toward the defense zone at constant velocity .",
    "an attacker stops if it is intercepted by a defender or if it enters the defense zone .",
    "the defenders objective is to deny as many attackers as possible from entering the defense zone without entering the zone themselves .",
    "a defender denies an attacker from the defense zone by intercepting the attacker before it reaches the defense zone .",
    "the wheeled vehicles of cornell s robocup team  @xcite are the defenders in the roboflag drill problem we consider in this paper .",
    "each vehicle is equipped with a three - motor omni - directional drive that allows it to move along any direction irrespective of its orientation .",
    "this allows for superior maneuverability compared to traditional nonholonomic ( car - like ) vehicles . a local control system on the vehicle , presented in  @xcite and appendix  [ sec : vehicledynamics ] , alters the dynamics so that at a higher level of the hierarchy , the vehicle dynamics are governed by @xmath1 the state vector is @xmath2 , and the control input vector is @xmath3 .",
    "these equations are less complex than the nonlinear governing equations of the vehicles .",
    "they allow for the generation of feasible near - optimal trajectories with little computational effort and have been used successfully in the robocup competition .",
    "each attacker has two discrete modes : active and inactive .",
    "when active , the attacker moves toward the defense zone at constant velocity along a straight line path .",
    "the attacker , which is initially active , transitions to inactive mode if the defender intercepts it or if it enters the defense zone .",
    "once inactive , the attacker does not move and remains inactive for the remainder of play .",
    "these dynamics are captured by the discrete time equations @xmath4 = p[k ] + v_p t a[k]\\nonumber\\\\    & & q[k+1 ] = q[k ] + v_q t a[k ]    \\label{attdyn1}\\end{aligned}\\ ] ] and the state machine ( see figure  [ sm1 ] ) @xmath5 = \\left\\ {    \\begin{array}{ll }      1 & \\mbox{if ( $ a[k]=1 $ ) } \\\\        & \\mbox{and ( not in defense zone ) } \\\\        & \\mbox{and ( not intercepted ) } \\\\      0 & \\mbox{if ( $ a[k]=0$)}\\\\        & \\mbox{or ( in defense zone ) } \\\\        & \\mbox{or ( intercepted ) }    \\end{array } \\right . \\end{aligned}\\ ] ]        for all @xmath6 in the set @xmath7 .",
    "the initial conditions are @xmath8 = p_s$ , $ q[0 ] = q_s$ , and $ a[0 ] = 1$}.    \\label{attdyn3}\\end{aligned}\\ ] ] in these equations , @xmath9 is the number of samples , @xmath10 is the sample time , @xmath11,q[k])$ ] is the attacker s position at time @xmath12 = k t$ ] , @xmath13 is its constant velocity vector , and @xmath14 \\in \\{0,1 \\}$ ] is a discrete state indicating the attacker s mode .",
    "the attacker is active when @xmath14 = 1 $ ] and inactive when @xmath14 = 0 $ ] . given @xmath11,q[k])$ ] and @xmath14 $ ] , we can calculate the attacker s position at any time @xmath15 , denoted @xmath16 , using the equations @xmath17",
    "+ v_p a[k ] ( t - t_a[k])\\nonumber\\\\ q(t ) & { } = { } & q[k ] + v_q a[k ] ( t - t_a[k ] ) , \\label{eqn : inbetween}\\end{aligned}\\ ] ] where @xmath18 .    because the goal of the roboflag drill is to keep attackers out of the defense zone ,",
    "attacker intercept is an obvious task for this problem .",
    "therefore , the task completion problem for the roboflag drill is an intercept problem .",
    "_ roboflag drill attacker intercept ( rdai ) _ : given a defender with state @xmath19 governed by equation  ( [ eom1 ] ) with initial condition @xmath20 , an attacker governed by equations  ( [ attdyn1 ] ) and  ( [ attdyn2 ] ) with initial conditions given by  ( [ attdyn3 ] ) and coordinates @xmath21 given by equation  ( [ eqn : inbetween ] ) , obstacles and restricted regions to be avoided , time dependent final condition @xmath22 , and objective function @xmath23 , find the control inputs to the defender that minimize the objective such that the constraints are satisfied .",
    "the operating environment includes the playing field and the group of attacking vehicles .",
    "the operating constraints include collision avoidance between vehicles and avoidance of the defense zone ( for the defending robots ) .",
    "next , we define notation for a primitive that generates a trajectory solving the rdai problem .",
    "the inputs to the primitive are the current state of defender @xmath24 , denoted @xmath25 , and the current position of attacker @xmath26 , denoted @xmath27 .",
    "the output is the amount of time it takes defender @xmath24 to intercept attacker @xmath26 , denoted @xmath28 , given by @xmath29 .",
    "\\label{eqn : primitive}\\end{aligned}\\ ] ] if defender @xmath24 can not intercept attacker @xmath26 before the attacker enters the defense zone , we set @xmath30 .",
    "near - optimal solutions to the rdai problem can be generated using the technique presented in  @xcite with straightforward modification .",
    "the advantage of this technique is that it finds very good solutions quickly , which allows for the exploration of many trajectories in the planning process .",
    "another way to generate near - optimal solutions for rdai is to use the iterative mixed integer linear programming techniques presented in  @xcite .",
    "the advantage of this approach is that it can handle complex hybrid dynamical systems .",
    "either of these approaches could be used as a primitive for the rdai problem . using the primitive ,",
    "the roboflag drill problem can be expressed as the following task assignment problem :    _ roboflag drill task assignment ( rdta ) _ : given a team of defending vehicles @xmath31 , a set of attackers to intercept @xmath32 , initial conditions for each defender @xmath24 and for each attacker @xmath26 , an rdai primitive , and an objective function @xmath33 , assign each defender @xmath24 in @xmath34 a sequence of attackers to intercept , denoted @xmath35 , such that the objective function is minimized .",
    ".variables for roboflag drill problems [ cols=\"<,<\",options=\"header \" , ]     [ tbl : variables ]    we introduce notation ( listed in table  [ tbl : variables ] ) to describe the cost function @xmath33 and the algorithm that solves the rdta problem .",
    "let @xmath36 be the number of attackers assigned to defender @xmath24 , and let @xmath37 be the sequence of attackers defender @xmath24 is assigned to intercept .",
    "let @xmath38 be the time at which defender @xmath24 completes the @xmath39th task in its task sequence @xmath35 .",
    "let @xmath40 be the set of unassigned attackers , then @xmath41 is the set of assigned attackers .",
    "an assignment for the rdta problem is an intercept sequence @xmath35 for each defender @xmath24 in @xmath34 .",
    "a partial assignment is an assignment such that @xmath40 is not empty , and a complete assignment is an assignment such that @xmath40 is empty .",
    "the set of times @xmath42 , for each defender @xmath24 , are computed using the primitive in equation  ( [ eqn : primitive ] ) .",
    "the time at which defender @xmath24 intercepts the @xmath39th attacker in its intercept sequence , if not empty , is given by @xmath43 where we take @xmath44 . if defender @xmath24 can not intercept attacker @xmath45 before the attacker enters the defense zone , the time @xmath38 is not incremented because , in this case , the defender does not attempt to intercept the attacker .",
    "the time at which defender @xmath24 completes its intercept sequence @xmath35 is given by @xmath46 .    to indicate",
    "if attacker @xmath26 enters the defense zone during the drill , we introduce binary variable @xmath47 given by @xmath48 if @xmath49 , attacker @xmath26 enters the defense zone at some time during play , otherwise , @xmath50 and attacker @xmath26 is intercepted .",
    "we compute @xmath47 for each attacker @xmath26 in the set of assigned attackers ( @xmath51 as follows : for each @xmath24 in @xmath34 and for each @xmath39 in @xmath52 , if @xmath53 then set @xmath54 , otherwise set @xmath55 .    for the rdta problem , the cost function has two components .",
    "the primary component is the number of assigned attackers that enter the defense zone during the drill , @xmath56 the secondary component is the time at which all assigned attackers that do not enter the defense zone ( all @xmath26 such that @xmath57 ) are intercepted , @xmath58 the weighted combination is @xmath59 where we take @xmath60 because we want the primary component to dominate . in particular",
    ", keeping attackers out of the defense zone is most important .",
    "therefore , our goal in the rdta problem is to generate a complete assignment ( @xmath40 empty ) that minimizes equation  ( [ eqn : objective ] ) .",
    "one way to find the optimal assignment for rdta is by exhaustive search ; try every possible assignment of tasks to vehicles and pick the one that minimizes @xmath33 .",
    "this approach quickly becomes computationally infeasible for large problems .",
    "as the number of tasks or the number of vehicles increase , the total number of possible assignments grows significantly .",
    "a more efficient solution method is needed for real - time planning . with this motivation",
    ", we developed a branch and bound solver for the problem . in this section",
    ", we describe the solver and its four major components : node expansion , branching , upper bound , and lower bound .",
    "we use a search tree to enumerate all possible assignments for the problem .",
    "the root node represents the empty assignment , all interior nodes represent partial assignments , and the leaves represent the set of all possible complete assignments .",
    "given a node representing a partial assignment , the node expansion algorithm ( section  [ sec : nodeexpand ] ) generates the node s children . using the node expansion algorithm",
    ", we grow the search tree starting from the root node .",
    "the branching algorithm ( section  [ sec : branch ] ) is used to determine the order in which nodes are expanded . in this algorithm , we use a * search  @xcite to guide the growth of the tree toward good solutions .",
    "given a node in the tree representing a partial assignment , the upper bound algorithm ( section  [ sec : ubalgo ] ) assigns the unassigned attackers in a greedy way .",
    "the result is a feasible assignment .",
    "the cost of this assignment is an upper bound on the optimal cost that can be achieved from the given node s partial assignment .",
    "the upper bound is computed at each node explored in the tree ( not all nodes are explored , many are pruned ) .",
    "as the tree is explored , the best upper bound found to date is stored in memory .    given a node in the search tree representing a partial assignment , the lower bound algorithm ( section  [ sec : lbalgo ] ) assigns the unassigned attackers in @xmath61 using the principle of simultaneity .",
    "each defender is allowed to pursue multiple attackers simultaneously . because this is physically impossible ,",
    "the resulting assignment is potentially infeasible . because no feasible assignment can do better , the cost of this assignment is a lower bound on the cost that can be achieved from the given node s partial assignment .",
    "similar to the upper bound , the lower bound is computed at each node explored in the tree .",
    "if the lower bound for the current node being explored is greater or equal to the best upper bound found , we prune the node from the tree , eliminating all nodes that emanate from the current node .",
    "this can be done because of the way we have constructed the tree .",
    "the task sequences that make up a parent s assignment are subsequences of the sequences that make up each child s assignment .",
    "therefore , exploring the descendants will not result in a better assignment than that already obtained .",
    "before we describe the details of the components , we describe the branch and bound algorithm listed in table  [ tbl : bandb ] .",
    "start with the root node , which represents the empty assignment , and apply the upper bound algorithm .",
    "this generates a feasible assignment with cost denoted @xmath62 because it is the best , and only , feasible solution generated so far .",
    "next , apply the node expansion algorithm to root , generating its children .    at this point , enter a loop . for",
    "each iteration of the loop , apply the branching algorithm to select the node to explore next .",
    "the node selected by the branching algorithm , which we call the current node , contains a partial assignment .",
    "apply the upper bound algorithm to the current node , generating a feasible complete assignment with cost denoted @xmath63 .",
    "if @xmath63 is less than @xmath62 , we have found a better feasible assignment so we set @xmath64 .",
    "next , apply the lower bound algorithm to generate an optimistic cost , denoted @xmath65 , from the current node s partial assignment . if @xmath65 is greater than or equal to the best feasible cost found so far @xmath62 , prune the node from the tree , removing all of its descendants from the search .",
    "we do not need to consider the descendants of this node because doing so will not result in a better feasible assignment than the one found already , with cost @xmath62 .",
    "the loop continues until all nodes have been explored or pruned away .",
    "the result is the optimal assignment for the rdta problem .    in figure",
    "[ fig:4now ] , we plot the solution to two instances of the rdta problem solved using the branch and bound solver .",
    "notice that the defenders work together and do not greedily pursue the attackers that are closest .",
    "for example , in the figure on the left , defenders 2 and 3 ignore the closest attackers and pursue attackers further away for the benefit of the team .    , @xmath66 , and @xmath67 .",
    "]    in the remainder of this section we describe the components of the branch and bound solver in detail .      here",
    "we describe the node expansion algorithm used to grow a search tree that enumerates all possible assignments for the rdta problem .",
    "each node of the tree represents an assignment . starting from the root node ,",
    "attackers are assigned , forming new nodes , until all complete assignments are generated .",
    "each node represents a partial assignment except for the leaves , which represent the set of complete assignments .",
    "consider the case with one defender @xmath68 and three attackers @xmath69 .",
    "the tree for this case is shown in figure  [ simpletree ] . to generate this tree ,",
    "we start from the root node representing the empty assignment , denoted @xmath70 .",
    "we expand the root node generating three children , each representing an assignment containing a single attacker to intercept .",
    "the children are then expanded , and so on , until all possible assignments are generated .",
    "[ .@xmath71 [ .@xmath72 [ .@xmath73 @xmath74 ] ! [ .@xmath75 @xmath76 ] ] ! [ .@xmath77 [ .@xmath78 @xmath79 ] ! [ .@xmath80 @xmath81 ] ] ! [ .@xmath82 [ .@xmath83 @xmath84 ] ! [ .@xmath85 @xmath86 ] ] ]    for multiple defenders , unlike the single defender case , the tree is unbalanced to avoid redundancies .",
    "for example , consider the case with two defenders @xmath87 and two attackers @xmath88 .",
    "the tree for this case is shown in figure  [ simpletree2 ] .",
    "again , each node represents an assignment , but now the assignment is a sequence of attackers to intercept for each defender in @xmath34 .    in general , for defender set @xmath34 with @xmath89 defenders and attacker set @xmath61 with @xmath90 attackers there are @xmath91 complete assignments ( or leaves in the search tree ) .    to generate a search tree for the general case , we use a node expansion algorithm .",
    "this algorithm takes any node and generates the node s children . the assignment for each child",
    "is constructed by appending an unassigned attacker to one of the sequences in the parent node s assignment .",
    "the task sequences in the parent s assignment are always subsequences of the sequences in its child s assignment .",
    "therefore , when we prune a node from the search tree , we can also prune all of its descendants .",
    "the node expansion algorithm uses a different representation for an assignment than we have used thus far .",
    "we introduce this new representation with an example involving the defender set @xmath92 and the attacker set @xmath93 .",
    "consider a partial assignment given by @xmath94 in this case , attackers @xmath95 and @xmath96 have yet to be assigned .",
    "our node expansion algorithm represents this partial assignment with the vectors @xmath97 both of length @xmath98 .",
    "vector @xmath99 holds defender indices and vector @xmath100 holds attacker indices . for a unique representation ,",
    "the elements in @xmath99 are ordered so that @xmath101 . for the example case ,",
    "attackers @xmath102 and @xmath103 ( i.e. ,  @xmath104 and @xmath105 ) are assigned to defender @xmath106 in sequence , and attackers @xmath107 , @xmath108 , @xmath109 ( i.e. ,  @xmath110 , @xmath111 , @xmath112 ) are assigned to defender @xmath113 in sequence .    in general",
    ", the input to the node expansion algorithm is a parent node with assignment give by @xmath114 where both vectors are of size @xmath90 , and @xmath115 is the number of tasks already assigned ( or the number of nonzero entries in each vector ) .",
    "the output is a set of @xmath116 children , where @xmath117",
    "each child has assignment vectors @xmath99 and @xmath100 identical to its parent except for entries @xmath118 and @xmath119 . in the child s assignment",
    ", attacker @xmath120 is appended to defender @xmath121 s sequence of attackers to intercept @xmath122 .",
    "the details of the node expansion algorithm are given in table  [ tbl : nodeexpand ] .",
    "to demonstrate the node expansion algorithm , we expand the node given by equation  ( [ expandexample ] ) as shown in figure  [ fig : nodeexpand ] .",
    "figure  [ fig : nodeexpand2 ] shows the normal notation for this expansion .    using this algorithm",
    ", we can grow the assignment tree for any rdta problem .",
    "in figure  [ fig : nodeexpand3 ] we show the tree for the two vehicle two attacker example written in our node expansion algorithm s notation .      to determine the order in which we expand nodes , we have tried several tree search algorithms including the systematic search algorithms breadth first search ( bfs ) , depth first search ( dfs )  @xcite , and a * search  @xcite .     [",
    ".@xmath123 [ .@xmath124 @xmath125 @xmath126 ] [ .@xmath127 @xmath128 @xmath129 ] [ .@xmath130 @xmath131 @xmath132 ] ]    the a * search algorithm orders nodes according to a heuristic branching function to help guide the search toward the optimal assignment .",
    "we use the upper bound algorithm presented in section  [ sec : ubalgo ] as the branching function . the lower bound algorithm presented in section  [ sec : lbalgo ]",
    "could also be used as the branching function .",
    "for example , consider a tree with three levels , where node @xmath39 is labeled @xmath133 as shown in figure  [ fig : exampletree ] .",
    "for this tree , bfs gives the ordering @xmath134 , and dfs gives the ordering @xmath135 .",
    "suppose the upper bound algorithm run at each node @xmath39 gives the following results : @xmath136 , @xmath137 , @xmath138 , @xmath139 , @xmath140 , @xmath141 , @xmath142 , @xmath143 , @xmath144 .",
    "a * bfs gives the ordering @xmath145 , and a * dfs gives the ordering @xmath146 .    in a * search ,",
    "the children of a node must be sorted with respect to the branching function .",
    "the maximum number of children that emanate from any given node is the @xmath147 children emanating from the root node .",
    "therefore , the maximum number of items that need to be sorted is @xmath147 . to sort the children , we use shell s method  @xcite , which runs in @xmath148 time .      in this section ,",
    "we describe a fast algorithm that generates a feasible complete assignment given any partial assignment .",
    "the cost of the resulting complete assignment is an upper bound on the optimal cost that can be achieved from the given partial assignment .",
    "the idea behind the upper bound algorithm is to assign unassigned attackers in a greedy way . at each step",
    ", we assign the attacker defender pair that results in the minimum intercept time .",
    "we proceed until all attackers are assigned or until none of the remaining attackers can be intercepted before entering the defense zone .",
    "the details of this algorithm , which runs in @xmath149 time , are listed in table  [ tbl : greedy ] .",
    "the input to the algorithm is a partial assignment given by an intercept sequence @xmath35 for each defender @xmath24 in @xmath34 such that the set of unassigned attackers @xmath40 is not empty .",
    "in addition , we take as inputs the variables associated with this partial assignment including the time for defender @xmath24 to complete its intercept sequence @xmath35 , given by @xmath46 , and binary variable @xmath47 for each @xmath26 in the set of assigned attackers @xmath150 .",
    "given a partial assignment , the greedy step of the algorithm determines the attacker in the set @xmath40 that can be intercepted in the minimum amount of time , denoted @xmath151 .",
    "the corresponding defender that intercepts @xmath151 is denoted @xmath152 . to determine this defender , attacker pair @xmath153 we form a matrix @xmath154 of intercept times .",
    "the matrix has size @xmath155 for each @xmath24 in @xmath34 and @xmath26 in @xmath40 .",
    "the element @xmath156 is the time it would take defender @xmath24 to complete its intercept sequence @xmath35 and then intercept attacker @xmath26 .",
    "the minimum of these times gives the desired defender , attacker pair @xmath157    if @xmath158 , no attacker can be intercepted before it enters the defense zone .",
    "thus , we set @xmath159 for each @xmath26 in @xmath40 .",
    "then , we set @xmath40 to the empty set because all attackers are effectively assigned , and we use equation  ( [ eqn : objective ] ) to calculate the upper bound @xmath63 . otherwise , @xmath160 is finite , and we add attacker @xmath151 to defender @xmath152 s intercept sequence by incrementing @xmath161 by one and setting @xmath162 .",
    "then , because @xmath151 has now been assigned , we remove it from the set of unassigned attackers by setting @xmath163 .",
    "if @xmath40 is not empty , we have a new partial assignment , and we repeat the procedure . otherwise , the assignment is complete and we use equation  ( [ eqn : objective ] ) to compute the upper bound @xmath63 .",
    "here we describe a fast algorithm that generates a lower bound on the cost that can be achieved from any given partial assignment .",
    "the idea behind the algorithm is to use the principle of simultaneity . in assigning attackers from @xmath40",
    ", we assume each defender can pursue multiple attackers simultaneously .",
    "the result is a potentially infeasible complete assignment because simultaneity is physically impossible . because no feasible assignment can do better ,",
    "the cost of this assignment is a lower bound on the optimal cost that can be achieved from the given partial assignment .",
    "the algorithm , which runs in @xmath164 time , is listed in table  [ tbl : lb ] .",
    "similar to the upper bound algorithm , the input to the lower bound algorithm is a partial assignment .",
    "this includes an intercept sequence @xmath35 for each defender @xmath24 in @xmath34 with @xmath40 nonempty , @xmath46 for each defender @xmath24 in @xmath34 , and @xmath47 for each attacker @xmath26 in @xmath150 .    each attacker @xmath26 in @xmath40",
    "is assigned a defender as follows : form a matrix @xmath154 with elements @xmath165 for all @xmath24 in @xmath34 and @xmath26 in @xmath40 .",
    "element @xmath156 is equal to the time it takes @xmath24 to intercept the attackers in its intercept sequence @xmath35 plus the time it would take to subsequently intercept attacker @xmath26 . for each @xmath26 in @xmath40 , find the defender , denoted @xmath152 , that can intercept @xmath26 in minimal time @xmath166    if @xmath167 , we set @xmath159 because no defender can intercept attacker @xmath26 before it enters the defense zone .",
    "otherwise , we set @xmath168 because defender @xmath152 can intercept attacker @xmath26 before it enters the defense zone .",
    "the lower bound is therefore give by @xmath169",
    "in this section , we explore the average case computational complexity of the branch and bound algorithm by solving randomly generated instances . each instance is generated by randomly selecting parameters from a uniform distribution over the intervals defined below .",
    "the computations were performed on a pc with intel piii 550mhz processor , 1024 kb cache , 3.8 gb ram , and linux .",
    "for all instances solved , processor speed was the limiting factor , not memory .",
    "the initial position of each attacker is taken to be in an annulus centered on the playing field .",
    "the radius of the initial position , denoted @xmath170 , is chosen at random from a uniform distribution over the interval @xmath171 $ ] .",
    "the angle of the initial position , denoted @xmath172 , is chosen from a uniform distribution over the interval @xmath173 $ ] ( all other angles used in this section @xmath174 , @xmath175 , and @xmath176 are also chosen from a uniform distribution over the interval @xmath173 $ ] ) .",
    "the magnitude of attacker @xmath26 s velocity , denoted @xmath177 , is chosen at random from a uniform distribution over the interval @xmath178 $ ] .",
    "the initial state of the attacker is given by @xmath179    the initial position of each defender is taken to be in a smaller annulus , also centered on the playing field .",
    "the radius of the initial position , denoted @xmath180 , is chosen at random from a uniform distribution over the interval @xmath181 $ ] .",
    "the magnitude of defender @xmath24 s velocity , denoted @xmath182 , is chosen at random from a uniform distribution over the interval @xmath183 $ ] .",
    "the initial state of the defender is given by @xmath184    for the instances generated in this paper , we set @xmath185 and take the parameters from the following intervals : @xmath186 $ ] , @xmath187 , @xmath188 $ ] , and @xmath189 $ ] . in section  [ sec : phasetransitions ] , we study the rdta problem with variations in the velocity parameters @xmath177 and @xmath190 .      in this section , we present the results of an average case computational complexity study on the branch and bound solver .",
    "a particular problem instance is considered solved when the strategy that minimizes the cost is found . in figure",
    "[ fig : ctime1 ] , we plot the fraction of instances solved versus computation time . in the figure on top ,",
    "the cost function is the number of attackers that enter the defense zone ( @xmath191 in equation  ( [ eqn : objective ] ) ) .",
    "solving these instances becomes computationally intensive for modest size problems .",
    "for example , when @xmath66 and @xmath192 , 80% of the instances are solved in 60 seconds or less . in the figure on bottom ,",
    "in addition to the primary component of the cost function , the cost function includes a secondary component ( @xmath193 in equation  ( [ eqn : objective ] ) ) .",
    "the secondary component is the time it takes to intercept all attackers that can be intercepted .",
    "solving these instances of the problem is more computationally intensive than the @xmath194 case .",
    "for example , when @xmath66 and @xmath192 , only 40% of the problems are solved in 60 seconds or less .     in equation  ( [ eqn : objective ] ) ) , and on bottom , the cost includes a secondary component ( @xmath193 in equation  ( [ eqn : objective ] ) ) . for each curve ,",
    "400 random instances of the rdta problem were solved .",
    "the values of the parameters are @xmath66 and @xmath195 .",
    ", title=\"fig : \" ]   in equation  ( [ eqn : objective ] ) ) , and on bottom , the cost includes a secondary component ( @xmath193 in equation  ( [ eqn : objective ] ) ) . for each curve ,",
    "400 random instances of the rdta problem were solved .",
    "the values of the parameters are @xmath66 and @xmath195 .",
    ", title=\"fig : \" ]    the increase in average case computational complexity for the @xmath196 case is expected because the cost function has an additional component to be minimized , which is independent of the primary component . in a case where the primary component is at a minimum , the algorithm will proceed until it proves that the combination of primary and secondary components is minimized .",
    "if it is given enough time , the branch and bound solver finds the optimal assignment , but the average case computational complexity is high .",
    "therefore , using the algorithm to solve for the optimal assignment in real - time is infeasible for most applications .",
    "however , the best assignment found in the allotted time window for planning could be used in place of the optimal assignment . in this case , it is desirable that the algorithm converge to a near - optimal solution quickly .    to learn more about the convergence rate of the branch and bound solver",
    ", we look at the rate at which the best upper bound @xmath62 decreases with branches taken in the search tree . because the branch and bound algorithm is an exact method , @xmath62 eventually converges to @xmath197 .",
    "we define the percent difference from optimal as follows : let @xmath198 be the optimal cost for instance @xmath39 .",
    "let @xmath199 be the best upper bound found after @xmath6 branches for instance @xmath39 .",
    "let @xmath200 be the mean of the set @xmath201 , and let @xmath202 be the mean of the set @xmath203 , where @xmath204 is the number of instances .",
    "the percent difference from optimal is given by @xmath205     versus the number of branches @xmath6 explored .",
    "for each curve 400 random instances of rdta were solved .",
    "the parameters values are @xmath193 , @xmath66 , and @xmath192 . ]    in figure  [ fig : converg1 ] , we plot pd@xmath206 versus the number of branches @xmath206 for instances involving three defenders ( @xmath66 ) and five attackers ( @xmath192 ) . at the root node ( @xmath207 ) ,",
    "the greedy algorithm is applied .",
    "exploration of the tree does not occur at this point .",
    "therefore , the three branching routines produce the same result , @xmath208 .",
    "this means that @xmath209 , or @xmath210 .",
    "in other words , the average cost of the assignment generated by the greedy algorithm is 1.33 times the average optimal cost . at one branch into the tree ( @xmath211 ) ,",
    "both dfs and bfs generate assignments with @xmath212 , and the a * search generates assignments with @xmath213 . therefore , after only two steps , the branch and bound algorithm using a * search generates an assignment that , on average , has cost only 1.05 times the cost of the optimal assignment .    for the instances solved here , the branch and bound solver with a * search converges to the optimal assignment in an average of 8 branches , and it takes an average of 740 branches to prove that the assignment is optimal .",
    "therefore , the solver converges to the optimal solution quickly , and the computational complexity that we observed ( figure  [ fig : ctime1 ] ) is due to the time needed to prove optimality .",
    "these results are encouraging for real - time implementation of the algorithm .",
    "the results show that a very good assignment is generated after a short number of branches .",
    "there is a trade - off between optimality and computation time that can be tuned by deciding how deep into the tree to explore .",
    "going deeper into the tree will generate assignments that are closer to optimal , but at the same time , results in an increased computational burden .",
    "the parameter to be tuned is the maximum number of branches to allow the search procedure to explore , denoted @xmath214 .    to study the computational complexity as @xmath214",
    "is tuned , we look at versions of the algorithm ( using a * ) with @xmath215 ( greedy algorithm ) , @xmath216 , and @xmath217 ( exact algorithm ) .",
    "these three cases generate assignments with average percent difference from optimal given by pd(1)=33% , pd(2)=5% , and pd(@xmath218)=0% respectively .",
    "the results are shown in figure  [ fig : ctimecomp ] .",
    "the algorithm with @xmath216 gives a good balance between optimality and computation time .    .",
    "the @xmath214 variable controls the maximum number of branches explored .",
    "we vary it from @xmath219 , which is a greedy search , to @xmath220 , which is exhaustive search . for each curve ,",
    "400 random instances of the rdta problem was solved . for these problems the parameter values are @xmath193 , @xmath66 , and @xmath221 . ]",
    "the rdta problem is np - hard  @xcite , which can be shown by reduction using the traveling salesman problem .",
    "this is a worst case result that says nothing about the average case complexity of the algorithm or the complexity with parameter variations . in this section",
    ", we study the complexity of the rdta problem as parameters are varied .",
    "we perform this study on the decision version of the problem .    _ roboflag drill decision problem ( rdd ) _ : given a set of defenders @xmath34 and a set of attackers @xmath61 , is there a complete assignment such that no attacker enters the defense zone ?",
    "first , we consider variations in the ratio of attacker velocity to maximum defender velocity , denoted @xmath222 in this section . when the ratio is small , the defenders are much faster than the attackers",
    ". it should be easy to quickly find an assignment such that all attackers are intercepted .",
    "when the ratio is large , the attackers are much faster than the defenders . in this case , it is difficult for the defenders to intercept all of the attackers , which should be easy to determine .",
    "the interesting question is whether there is a transition from being able to intercept all the attackers ( all _ yes _",
    "answers to the rdd problem ) to not being able to intercept all attackers ( all _ no _ answers to the rdd problem ) .",
    "is this transition sharp ?",
    "are there values of the ratio for which solving the rdd is difficult ?    for each value of the velocity ratio , we generated random instances of the rdd problem and solved them with the branch and bound solver .",
    "the results are shown in figure  [ fig : pt1 ] .",
    "the figure on top shows the fraction of instances that evaluate to _ yes _ versus the velocity ratio .",
    "the figure on bottom shows the mean number of branches required to solve an instance versus the velocity ratio . there is a sharp transition from all instances _ yes _ to all instances _",
    "no_. this transition occurs approximately at @xmath223 for the @xmath66 , @xmath192 case . at this value of the ratio ,",
    "there is a spike in computational complexity .",
    "this easy - hard - easy behavior is indicative of a phase transition  @xcite .    ) .",
    "the figure on top shows the fraction of instances that evaluate to _ yes _ versus the velocity ratio .",
    "the figure on bottom shows the mean number of branches needed to solve the problem versus the velocity ratio .",
    "the phase transition occurs at a velocity ration of approximately 1 . for each curve ,",
    "100 random instances of the rdd problem were solved . in these figures , @xmath66 .",
    ", title=\"fig : \" ] ) .",
    "the figure on top shows the fraction of instances that evaluate to _ yes _ versus the velocity ratio .",
    "the figure on bottom shows the mean number of branches needed to solve the problem versus the velocity ratio .",
    "the phase transition occurs at a velocity ration of approximately 1 . for each curve ,",
    "100 random instances of the rdd problem were solved . in these figures , @xmath66 .",
    ", title=\"fig : \" ]    we also study the rdd problem with variations in the ratio of defenders to attackers , denoted @xmath224 , with @xmath225 . for small values of @xmath224 ,",
    "the number of attackers is much larger than the number of defenders , and it should be easy to determine that the team of defenders can not intercept all of the attackers . in this case , most instances should evaluate to _ no_. for large values of @xmath224 ,",
    "the number of defenders is much larger than the number of attackers , and it should be easy to find an assignment in which all attackers are denied from the defense zone .",
    "in this case , most instances should evaluate to _",
    "the results are shown in figure  [ fig : pt2 ] , where it is clear that our expectations proved correct . in between the extremes of the @xmath224 ratio ,",
    "there is a phase transition at a ratio of approximately @xmath226 .    ) .",
    "the solid line shows the fraction of instances that evaluate to _ yes _ versus the ratio .",
    "the dashed line shows the mean number of branches needed to solve the problem versus the ratio . for each curve ,",
    "100 random instances of the rdd problem were solved .",
    "the velocities are @xmath227 . ]    in general , these experiments show that when one side dominates the other ( in terms of the number of vehicles or in terms of the capabilities of the vehicles ) the rdd problem is easy to solve . when the capabilities are comparable ( similar numbers of vehicles , similar performance of the vehicles ) , the rdd is much harder to solve .",
    "this behavior is similar to the complexity of balanced games like chess  @xcite . in section  [ discussion ] , we discuss how knowledge of the phase transition can be exploited to reduce computational complexity .",
    "now that we have a fast solver that generates near - optimal assignments , we test it in a dynamically changing environment .",
    "we consider the roboflag drill problem with attackers that have a simple noncooperative strategy built in , which is unknown to the defenders .",
    "the hope is that frequent replanning , at all levels of the hierarchical decomposition , will mitigate our assumption that the attackers move with constant velocity .",
    "we use a multi - level receding horizon architecture , shown in figure  [ fig : vhierarchy ] , to generate the defenders strategy .",
    "the task assignment module at the top level implements the branch and bound algorithm presented in this paper .",
    "it generates the assignment @xmath35 for each defender @xmath24 , sending new assignments to the middle level of the hierarchy at the rate @xmath228 .",
    "therefore , the algorithm returns the best assignment computed in the time window @xmath229 .",
    "( 10,102)@xmath228 ( 10,55)@xmath230    there is a task completion module for each defender at the middle level of the hierarchy , which receives an updated assignment @xmath35 from the task assignment module at the rate @xmath228 . at a rate @xmath230 , the task completion module generates a trajectory from defender @xmath24 s current state to a point that will intercept attacker @xmath231 assuming the attacker moves at constant velocity . if attacker @xmath231 is intercepted , a trajectory to intercept attacker @xmath232 is generated , and so on .",
    "the vehicle module at the bottom of the hierarchy receives an updated trajectory from the task completion module at the rate @xmath230 .",
    "the module propels the vehicle along this trajectory until it receives an update .",
    "the attackers are taken to be the same vehicles as the defenders ( described in appendix  [ sec : vehicledynamics ] ) . for the attacker intelligence ,",
    "we use the architecture shown in figure  [ fig : ahierarchy ] .",
    "the levels of the hierarchy are decoupled , so each attacker acts independently .",
    "the simple intelligence for each attacker is contained in the top level of the hierarchy .",
    "the primary objective is to arrive at the origin of the field in minimum time .",
    "however , the attacker tries to avoid the defenders if they get too close .",
    "the radius of each defender is artificially enlarged by a factor @xmath233 .",
    "if the artificially enlarged defenders obstruct an attacker s path toward the origin , the attacker treats them as obstacles , finding a destination that results in an obstacle free path .",
    "the destination is found using a simple reactive obstacle avoidance routine used in robocup  @xcite .",
    "the attacker intelligence module runs at the rate @xmath234 .",
    "( 12,94)@xmath234 ( 12,55)@xmath235    the trajectory generation module at the middle of the hierarchy receives an updated destination at the rate @xmath236 .",
    "the module generates a trajectory from the current state of the attacker to the destination with zero final velocity at the rate @xmath235 , using techniques from  @xcite .",
    "the vehicle module at the bottom level of the hierarchy is the same as that for the defenders .",
    "because the algorithms are more computationally intensive for the higher levels of the hierarchy than the lower levels , the rates are constrained as follows : @xmath237 and @xmath238 . in the simulations that follow ,",
    "we take @xmath239 because the middle levels of the two hierarchies are comparative computationally .",
    "we also set @xmath240 .",
    "therefore , if the trajectory generation module replans every time unit , the attacker intelligence module replans every ten time units .    first , note that when both @xmath228 and @xmath230 are zero , there is no replanning . in this case , all attackers usually enter the defense zone .",
    "they easily avoid the defenders because the defenders execute a fixed plan , which becomes obsolete once the attackers start using their intelligence .",
    "next , we present simulation results of the roboflag drill with intelligent attackers and defenders .",
    "we consider problems with eight defenders ( @xmath241 ) , four attackers ( @xmath242 ) , @xmath243 , @xmath244 , and @xmath240 .",
    "we consider several different values of the rate at which the task assignment module replans ( @xmath228 ) .",
    "for each value , we solve 200 randomly generated instances of the problem .",
    "as an evaluation metric , we use the average number of attackers that enter the defense zone during play .    for the case",
    "@xmath245 , there is no replanning at the task assignment level .",
    "replanning only occurs at the task completion level .",
    "the defenders are given a plan from the task assignment module at the beginning of play .",
    "each defender executes its assignment throughout , periodically recalculating the trajectory it must follow to intercept the next attacker in its sequence . for this case , on average , 58% of the attackers enter the defense zone during play .    for the case",
    "@xmath246 , replanning occurs at both the task assignment level and the task completion level of the hierarchy .",
    "in addition to recomputing trajectories to intercept the next attacker in each defender s assignment , the defender assignments are recomputed .",
    "this redistributes tasks based on the current state of the dynamically changing environment , providing feedback . for @xmath247 , @xmath248 , and @xmath249 ,",
    "an average of 38% , 34% , and 32.5% of the attackers enter the defense zone during play , respectively .",
    "therefore , replanning at the task assignment level has helped increase the utility of the strategies generated for the team of defenders .    in figure",
    "[ rd_instance_noreplan ] , we show snapshots of an instance of the roboflag drill simulation for the case where the defenders do not replan at the task assignment level . in this case , all attackers enter the defense zone . in figure",
    "[ rd_instance_replan ] , we show snapshots of the same instance of the roboflag drill simulation , but in this case , the defenders replan at the task assignment level ( @xmath250 ) . the defenders cooperate to deny all attackers from the defense zone .",
    "for example , the two defenders at the lower left of the field cooperate to intercept an attacker .    ) . in this case , all attackers enter the defense zone .",
    "the large circles are the defenders , and the small circles are the attackers .",
    "the solid lines are trajectories .",
    "each cross connected to a dashed line is an attacker s desired destination . ]    ) . because there is replanning at both levels , the defenders cooperate to intercept all attackers .",
    "the large circles are the defenders , and the small circles are the attackers .",
    "the solid lines are trajectories .",
    "each cross connected to a dashed line is an attacker s desired destination . ]",
    "we developed a decomposition approach that generates cooperative strategies for multi - vehicle control problems , and we motivated the approach using an adversarial game called roboflag . in the game , we fixed the strategy for one team and used our approach to generate strategies for the other team . by introducing a set of tasks to be completed by the team and a task completion method for each vehicle , we decomposed the problem into a high level task assignment problem and a low level task completion problem .",
    "we presented a branch and bound solver for task assignment , which uses upper and lower bounds on the optimal assignment to prune the search space .",
    "the upper bound algorithm is a greedy algorithm that generates feasible assignments .",
    "the best greedy assignment is stored in memory during the search , so the algorithm can be stopped at any point in the search and a feasible assignment is available .    in our computational complexity",
    "study , we found that solving the task assignment problem is computationally intensive , which was expected because the problem is np - hard .",
    "however , we showed that the solver converges to the optimal assignment quickly , and takes much more time to prove the assignment is optimal .",
    "therefore , the solver can be run in a time window to generate near - optimal assignments for real - time multi - vehicle strategy generation . to increase the speed of the algorithm",
    ", it may be advantageous to distribute the computation over the set of vehicles  @xcite , taking advantage of the distributed structure of the problem .",
    "we also studied the computational complexity of the solver as parameters were varied .",
    "we varied the ratio of the maximum velocities of the opposing vehicles , and we varied the ratio of the number of vehicles per team .",
    "we found that when one team has a capability advantage over the other , such as a higher maximum velocity or more vehicles , the solution to the task assignment problem is easy to generate .",
    "however , when the teams are comparable in capability , finding the optimal assignment to the problem is much more computationally intensive .",
    "this type of analysis can help in deciding how many vehicles to deploy in an adversarial game and what capabilities the vehicles should have .",
    "in addition , knowledge of the phase transition may be exploited to reduce computational complexity . in  @xcite ,",
    "phase transition ` backbones ' are exploited to decompose combinatorial problems into many separate subproblems , which are much less computationally intensive .",
    "this decomposition is amenable to parallel computation . in  @xcite",
    ", it is shown that the hardness of a problem depends on the parameters of the problem ( as we showed above ) and the details of the algorithm used to solve the problem .",
    "therefore , it is possible that the hard instances of our problem , which lie along the phase transition , may be solved faster if we use a different solution algorithm .",
    "the authors in  @xcite suggest adding randomization to the algorithm and using a rapid restart policy .",
    "the restart policy selects a new random seed for the algorithm and restarts it if the algorithm is not making sufficient progress with the current seed .",
    "finally , we demonstrated the effectiveness of our approach in an environment where the adversaries had a noncooperative intelligence that was unknown .",
    "we found that the simple model used for the adversaries in the solver could be mitigated by a multi - level replanning architecture . in this architecture , there are two levels : low level task completion and high level task assignment .",
    "when replanning does not occur at either level , the solver fails because it generates a plan that becomes obsolete as the adversaries use their intelligence .",
    "when replanning occurs at the task completion level , an assignment is generated once by the solver .",
    "as the adversaries use their intelligence , the task completion component is run periodically for each vehicle , generating a new trajectory to complete the tasks in the vehicle s assignment .",
    "this was somewhat effective at handling the unknown intelligence .",
    "when replanning occurs at both levels , the task assignment component is run periodically in addition to the task completion component .",
    "we found this replanning architecture effective at retasking in the dynamically changing environment .",
    "it is advantageous to replan frequently , on average , but there are instances where replanning frequently is not advantageous . in these cases ,",
    "the vehicles are retasked so frequently that their productivity is reduced .",
    "therefore , it may be desirable to place a penalty on changing each vehicle s current task .    in general , we feel the multi - level replanning approach is a natural way to handle multi - vehicle cooperative control problems .",
    "there are many different directions for further research , including the addition of a high level learning module to generate better models of the adversaries through experience  @xcite .",
    "the wheeled robots of cornell s robocup team  @xcite are the defenders in the roboflag problems we consider in this paper .",
    "we state their governing equations and simplify them by restricting the allowable control inputs  @xcite .",
    "the result is a linear set of governing equations coupled by a nonlinear constraint on the control input .",
    "this procedure allows real - time calculation of many near - optimal trajectories and has been successfully used by cornell s robocup team  @xcite .",
    "each vehicle has a three - motor omni - directional drive which allows it to move along any direction irrespective of its orientation .",
    "this allows for superior maneuverability compared to traditional nonholonomic ( car - like ) vehicles .",
    "the nondimensional governing equations for each vehicle are given by @xmath251 +    \\left [ \\begin{array}{c }      \\dot{x}(t ) \\\\",
    "\\dot{y}(t ) \\\\",
    "\\frac{2ml^2}{j}\\dot{\\theta}(t )    \\end{array } \\right ] =    \\mathbf{u}(\\theta(t),t),\\ ] ] where @xmath252 are the coordinates of the robot on the playing field , @xmath253 is the orientation of the robot , and @xmath254 can be thought of as a @xmath253-dependent control input , where @xmath255,\\ ] ] and @xmath256.\\ ] ] in the equations above , @xmath90 is the mass of the vehicle , @xmath33 is the vehicle s moment of inertia , @xmath257 is the distance from the drive to the center of mass , and @xmath258 is the voltage applied to motor @xmath39 .    by restricting the admissible control inputs we simplify the governing equations in a way that allows near - optimal performance .",
    "the set of admissible voltages @xmath259 is given by the unit cube and the set of admissible control inputs is given by @xmath260 .",
    "the restriction involves replacing the set @xmath261 with the maximal @xmath262-independent set found by taking the intersection of all possible sets of admissible controls .",
    "this set is characterized by the inequalities @xmath263 and @xmath264 where the @xmath262-independent control is given by @xmath265 .",
    "the equations of motion become @xmath251 +    \\left [ \\begin{array}{c }      \\dot{x}(t ) \\\\",
    "\\dot{y}(t ) \\\\",
    "\\frac{2ml^2}{j}\\dot{\\theta}(t )    \\end{array } \\right ] =    \\left [ \\begin{array}{c }      u_x(t ) \\\\",
    "u_y(t ) \\\\",
    "u_\\theta(t )    \\end{array } \\right],\\ ] ] subject to constraints  ( [ constraint1 ] ) and  ( [ constraint2 ] ) , which couple the degrees of freedom . to decouple the @xmath262 dynamics we set @xmath266 .",
    "then constraint  ( [ constraint1 ] ) becomes @xmath267 now the equations of motion for the translational dynamics of the vehicle are given by @xmath268 subject to constraint  ( [ nl_u_constraint ] ) . in state space form",
    "we have @xmath269 where @xmath2 is the state and @xmath3 is the control input .    00",
    "r. w. beard , t. w. mclain , m. a. goodrich , and e.p .",
    "anderson , `` coordinated target assignment and intercept for unmanned air vehicles , '' _ ieee trans . robot .",
    "991922 , dec . 2002 .",
    "r. bejar , i. vetsikas , c. gomes , henry kautz , and b. selman , `` structure and phase transition phenomena in the vtc problem , '' in _ task _ pi meeting workshop , 2001 .",
    "m.  campbell , r.  dandrea , d.  schneider , a.  chaudhry , s.  waydo , j.  sullivan , j.  veverka , and a.  klochko , `` roboflag games using systems based , hierarchical control , '' _ proceedings of the american control conference _ , june 46 , 2003 , pp .  661666 .",
    "c. g. cassandras and w. li , `` a receding horizon approach for solving some cooperative control problems , '' _ proc .",
    "ieee conf .",
    "decision and control _ , las vegas , neveda , dec .",
    "2002 , pp . 37603765 .",
    "t. h. cormen , c. e. leiserson , r. l. rivest , and c. stein . _",
    "introduction to algorithms_. second edition . the mit press , cambridge , massachusetts , 2001 .",
    "r.   dandrea , t.  kalmr - nagy , p.  ganguly , and m.  babish , `` the cornell robocup team , '' in g. kraetzschmar , p. stone , t. balch eds . ,",
    "_ robot soccer worldcup iv , lecture notes in artificial intelligence _ , springer , 2001 .",
    "r.  dandrea and r.  m.  murray , `` the roboflag competition , '' _ proceedings of the american control conference _ ,",
    "june 46 , 2003 , pp .",
    "r.  dandrea and m.  babish , `` the roboflag testbed , '' _ proceedings of the american control conference _ ,",
    "june 46 , 2003 , pp .",
    ". w.  b.  dunbar and r.  m.  murray , `` distributed receding horizon control with application to multi - vehicle formation stabilization , '' accepted to _",
    "automatica _ ,",
    "june , 2004 .",
    "a web page that accompanies this paper can be found at ` http://control.mae.cornell.edu/earl/decomp ` m.  g.  earl and r.  dandrea , `` multi - vehicle cooperative control using mixed integer linear programming , '' preprint available at ` http://control.mae.cornell.edu/earl/milp1 ` m.  g.  earl and r.  dandrea , `` iterative milp methods for vehicle control problems , '' _ proc .",
    "ieee conf .",
    "decision and control _ , atlantis , paradise island , bahamas , dec .",
    "m. g. earl and r. dandrea , `` modeling and control of a multi - agent system using mixed integer linear programming , '' _ proc .",
    "ieee conf .",
    "decision and control _ , las vegas , neveda , dec .",
    "2002 , pp .",
    ". m. r. garey and d. s. johnson . _ computers and intractability : a guide to the theory of np - completeness_. w. h. freeman and company , 1979 . c. p. gomes , b. selman , n. crato , and h. kautz , `` heavy - tailed phenomena in satisfiability and constraint satisfaction problems , '' _ journal of automated reasoning _ , 24 ( 1 - 2 ) : 67100 feb 2000 .",
    "h.  j.  van den herik , j.  w.  h.  m.  uiterwijk , j.  van rjiswijck , `` games solved : now and in the future , '' _ artificial intelligence _ vol .  134 ( 1 - 2 ) : pp .  277 - 311 , jan .  2002 .",
    "y. ho and k. chu , `` team decision theory and information structures in optimal control problems ",
    "part 1 , '' _ ieee trans .",
    "automatic control _",
    "ac-17 , pp . 1522 , 1972 .",
    "e.  klavins , `` a language for modeling and programming cooperative control systems , '' _ proceedings of the international conference on robotics and automation _ , 2004 .",
    "e.  klavins , _",
    "42nd ieee conference on decision and control _ , `` a formal model of a multi - robot control and communication task , '' maui , hi , december 2003 .",
    "s. kirkpatrick and b. selman , `` critical - behavior in the satisfiability of random boolean expressions , '' _ science _ , 264 ( 5163 ) , 12971301 , may 27 , 1994 .",
    "j. r. kok , m. t. j. spaan , and n. vlassis , `` non - communicative multi - robot coordination in dynamic environments , '' _ robotics and autonomous systems _",
    ", 50 ( 23 ) : 99114 , feb .",
    "28 , 2005 .",
    "p. u. lima , f. c. a. groen , `` special issue on multi - robots in dynamic environments , '' _ robotics and autonomous systems _ , 50 ( 23 ) : 8183 , feb .",
    "28 , 2005 .",
    "d.  q.  mayne , j.  b.  rawlings , c.  v.  rao , and p.  o.  m.  scokaert , `` constrained model predictive control : stability and optimality , '' _ automatica _ , vol .",
    "36 , pp .  789814 , 2000 . m.  di marco , a.  garulli , a.  giannitrapani , a.  vicino , `` simultaneous localization and map building for a team of cooperating robots : a set membership approach , '' _ ieee transactions on robotics and automation _ ,",
    "vol .  19 ( 2 ) , pp",
    ".  238249 , apr .",
    "r. monasson , r. zecchina , s. kirkpatrick , b. selman , and l. troyansky , `` determining computational complexity from characteristic phase transitions , '' _ nature _ , 400(8 ) , 1999 .",
    "r. murphey and p. m. pardalos , eds . , _ cooperative control and optimization _ , boston : kluwer academic , 2002",
    ". t. kalmr - nagy , r. dandrea , and p. ganguly .",
    "`` near - optimal dynamic trajectory generation and control of an omnidirectional vehicle , '' _ robotics and autonomous systems _",
    "46 , pp . 4764 , 2004 . j.  ousingsawat and m.  e.  campbell , `` establishing optimal trajectories for multi - vehicle reconnaissance , '' _ aiaa guidance , navigation and control conference _",
    ", 2004 . w. h. press , b. p. flannery , s. a. teukolsky , and w. t. vetterling , _ numerical recipes in c : the art of scientific computing _ , cambridge university press , new york , 1992 .",
    "t. l. ralphs , `` parallel branch and cut for capacitated vehicle routing , '' _ parallel computing _",
    "29(5 ) , pp .",
    "607629 , may 2003 . j. schneider , c. froschhammer , i. morgenstern , t. husslein , and j. m. singer ,  searching for backbones  an efficient parallel algorithm for the traveling salesman problem ,  _ computer physics communications _ , 96 ( 2 - 3 ) : 173188 aug 1996 .",
    "j. schneider ,  searching for backbones  a high - performance parallel algorithm for solving combinatorial optimization problems , ",
    "_ future generation computer systems _ , 19 ( 1 ) : 121131 jan 2003 .",
    "t. schouwenaars , e. feron , b. de moor , and j. p. how , `` mixed integer programming for multi - vehicle path planning , '' _",
    "european control conference _ , september 2001 .",
    "b. selman and s. kirkpatrick , `` critical behavior in the computational cost of satisfiability testing , '' _ artificial intelligence _ , 81(1 - 2):273295 , 1996 . m. stefik . _ introduction to knowledge systems_. morgan kaufmann publishers , inc . , san francisco , california , 1995 . s. a. stoeter , p. e. rybski , k. n. stubbs , c. p.",
    "mcmillen , m. gini , d. f. hougen , and n. papanikolopoulos , `` a robot team for surveillance tasks : design and architecture , '' _ robotics and autonomous systems _",
    ", 40 ( 23 ) : 173183 aug .",
    "31 , 2002 .",
    "p. stone , m. asada , t. balch , r. dandrea , m. fujita , b. hengst , g. kraetzschmar , p. lima , n. lau , h. lund , d .",
    "polani , p .",
    "scerri , s. tadokoro , t .",
    "weigel , and g. wyeth , `` robocup-2000 : the fourth robotic soccer world championships , '' _ ai magazine _ , vol .",
    "22(1 ) , pp .  1138 ,",
    "spring 2001 .",
    "p. stone and m. veloso , `` multiagent systems : a survey from a machine learning perspective , '' _ autonomous robots _ , vol .",
    "345383 , 2000 ."
  ],
  "abstract_text": [
    "<S> we present methods that generate cooperative strategies for multi - vehicle control problems using a decomposition approach . by introducing a set of tasks to be completed by the team of vehicles and a task execution method for each vehicle , we decomposed the problem into a combinatorial component and a continuous component . </S>",
    "<S> the continuous component of the problem is captured by task execution , and the combinatorial component is captured by task assignment . in this paper , we present a solver for task assignment that generates near - optimal assignments quickly and can be used in real - time applications . to motivate our methods , </S>",
    "<S> we apply them to an adversarial game between two teams of vehicles . </S>",
    "<S> one team is governed by simple rules and the other by our algorithms . in our study of this game </S>",
    "<S> we found phase transitions , showing that the task assignment problem is most difficult to solve when the capabilities of the adversaries are comparable . </S>",
    "<S> finally , we implement our algorithms in a multi - level architecture with a variable replanning rate at each level to provide feedback on a dynamically changing and uncertain environment . </S>"
  ]
}