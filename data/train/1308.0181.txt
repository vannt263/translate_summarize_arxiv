{
  "article_text": [
    "* context . *    the strong connection between finite state devices and descriptive formalisms , such as first - order or monadic second - order logic , has been a guideline in computer science since the seminal work of bchi  @xcite , elgot  @xcite and trakhtenbrot  @xcite .",
    "this bridge has continuously been fruitful , disseminating tools and bringing a number of applications outside of its original research area .",
    "for instance , compiling logical specifications into various forms of automata has become one of the most successful methods in automatic program verification  @xcite .",
    "one of the challenging issues when dealing with a logical formalism is to precisely understand its expressiveness and its limitations .",
    "while solutions to _ decide _ such logics often use a compilation procedure from formulas to automata , capturing the expressive power amounts to the opposite translation : given a language , one wants to know whether one can reconstruct a formula that describes it . in other words , we want to solve an instance of the _ membership problem _ , which asks whether an input language belongs to some given class .    for regular languages of finite words , the main tool developed to capture this expressive power is the syntactic monoid  @xcite : this is a finite , computable , algebraic abstraction of the language , whose properties make it possible to decide membership .",
    "an emblematic example is the membership problem for the class of first - order definable languages , solved by schtzenberger  @xcite and mcnaughton and papert  , which has led to the development of algebraic methods for obtaining decidable characterizations of logical or combinatorial  properties .    *",
    "the separation problem and its motivations . *",
    "we consider here the _ separation problem _ as a generalization of the membership problem .",
    "assume we are given two classes of languages @xmath0 and @xmath1 .",
    "the question is , given _ two _ input languages from @xmath0 , whether we can separate them by a language from  @xmath1 .",
    "here , we say that a language _ separates _",
    "@xmath2 from @xmath3 if it contains @xmath2 and is disjoint from @xmath3 .",
    "an obvious necessary condition for separability is that the input languages @xmath4 be disjoint .",
    "a separator language _ witnesses _ this condition .",
    "one strong motivation for this problem is to understand the limits of logics over finite words .",
    "notice that membership reduces to separation when @xmath5is closed under complement , because checking that a language belongs to @xmath1amounts to testing that it is @xmath1-separable from its complement .",
    "deciding @xmath1-separation is also more difficult than deciding membership in  @xmath1 , as one can not rely on algebraic tools tailored to the membership problem .",
    "it may also be computationally harder , as we shall see in this paper .",
    "thus , solving the separation problem requires a deeper understanding of @xmath1than what is sufficient to check membership : one not only wants to decide whether @xmath1is powerful enough to _ describe _ a language , but also to decide whether it can _ discriminate _ between two input  languages .",
    "this discriminating power provides more accurate information than the expressive power .",
    "* contributions . *    in general",
    ", elements of @xmath0 can not always be separated by an element of  @xmath6 and there is no minimal separator wrt .",
    "we are interested in the following  questions :    1",
    ".   can we _ decide _ whether one can separate two given languages of @xmath0 by a language of  @xmath6 ?",
    "2 .   what is the _ complexity _ of this decision problem ?",
    "3 .   if separation is possible , can we _ compute _ a separator , and at which cost ?",
    "we investigate the separation problem by locally and locally threshold testable languages .",
    "a language is called _ locally testable ( lt ) _ if membership of a word can be tested by inspecting its prefixes , suffixes and infixes up to some length ( which depends on the language ) . the membership problem for this class",
    "was raised by mcnaughton and papert  , and solved independently by mcnaughton and zalcstein  @xcite and by brzozowski and simon  . if the input language is given by a deterministic automaton , the membership problem to lt is ptime  .",
    "this class has several generalizations .",
    "the most studied one is that of _ locally threshold testable languages ( ltt ) _ , where counting infixes is allowed up to some threshold .",
    "these are the languages definable in @xmath7 , _",
    "i.e. _ , first - order logic with the successor relation ( but without the order ) .",
    "again , membership is decidable  , and can actually be again tested in ptime  @xcite if the input language is given by a deterministic automaton .    actually , the decision problem @xmath8 has been rephrased in purely algebraic terms  @xcite : solving the separation problem for a class @xmath1amounts to computing the so - called _",
    "2-pointlike sets _ for the algebraic variety corresponding to @xmath1 .",
    "it has been shown that both the varieties corresponding to and to of commutative and aperiodic semigroups with right zero semigroups . ]",
    "have computable pointlike sets .",
    "this is a consequence of   for and of   for .",
    "however , this approach suffers some drawbacks .",
    "* first , the proofs are purely algebraic , and they provide no insight on the underlying class @xmath1of regular languages itself .",
    "instead , the proofs are based on algebraic properties of a profinite semigroup that depends on  @xmath1 , and which is in general uncountable . *",
    "the proofs involve difficult results from profinite semigroup theory , and therefore require a significant background in algebra and topology : this is the second drawback .",
    "the separation problem is indeed equivalent to showing that the topological closure of the input languages wrt .",
    "the profinite topology do intersect .",
    "deciding nonemptiness of such an intersection in turn requires a deep understanding of the algebraic properties of this profinite semigroup . *",
    "finally , this approach only provides a yes / no answer , but no description of what an actual separator might be .",
    "the present paper alleviates these drawbacks , by only using elementary pumping arguments , and providing bounds on the parameters defining the separators .",
    "our results are as follows : we show that separability of regular languages by and languages is decidable by _ reduction to fixed parameters _ : for a fixed threshold , we provide a bound on the length of infixes that define a possible separator . for -separators ,",
    "we also provide a bound for a sufficient threshold .",
    "this reduces the problem to a finite number of candidate separators , and hence entails decidability .",
    "we further get an equivalent formulation on nfas in terms of forbidden patterns for the languages to be separable , which yields an nexptime algorithm .",
    "we also obtain lower complexity bounds : even starting from dfas , the problem is np - hard for and ( while membership is in ptime ) .",
    "finally , we discuss the separation problem starting from context - free input languages rather than regular ones .",
    "the main arguments rely on pumping in monoids or automata .",
    "the core of our proof is generic : we show that if one can find two words , one in each input language , that are close enough wrt .",
    "the class of separators , then the languages are not separable . here ,",
    "`` close enough '' is defined in terms of parameters of the input languages , such as the size of input  nfas .    *",
    "the separation problem in other contexts . *",
    "while our main concern is theoretical , let us mention some motivating applications where separation occurs as a main ingredient .    in model checking , reachable configurations of a system",
    "can be represented by a language .",
    "separating it from the language representing bad configurations proves to be effective for verifying safety of a system .",
    "craig interpolation is a form of separation used in this  context , as well as in type inference , theorem proving , hardware specification  . in the same line of thought ,",
    "separation is the core idea of the reachability algorithm for vector addition systems designed by leroux  @xcite , who greatly simplified the original decidability proof  @xcite thanks to a difficult separation theorem : he proved that a recursively enumerable set of separators ( namely presburger definable sets of configurations ) witnesses non - reachability .",
    "a related problem addressed also in automatic verification is to find separators in terms of small or minimal dfas  @xcite using learning algorithms  @xcite .",
    "finally , questions in database theory also motivated separation questions  @xcite .",
    "these applications justify a systematic study of the separation problem .",
    "it is therefore surprising that it deserved only little attention and isolated work  @xcite , even in the restricted , yet still challenging case of regular  languages .    *",
    "related work for other classes .",
    "*    the separation problem has recently been shown to be ptime - decidable for the class of piecewise - testable languages , independently and with different techniques in  @xcite and  @xcite . in the latter paper , it has also been solved using elementary pumping arguments for the class of unambiguous languages , a widely studied class that corresponds to languages definable in first - order logic with only 2 variables .",
    "the case of full first - order logic , already shown decidable in @xcite , has been reproved in  @xcite with the proof canvas of the present paper , which extends to separating languages of infinite words .",
    "recently , the problem has also been shown decidable for separation by @xmath9-definable languages ( that is , languages definable by first - order formulas having only 2 alternations and beginning with an existential block ) .",
    "this information has been in turn used to get decidable characterizations for higher levels in the first - order quantifier alternation hierarchy  @xcite",
    ".    * paper outline . *",
    "we present the necessary background and notation in section  [ sec : prelims ] .",
    "the classes and are defined in section  [ sec : classdef ] . in section  [ sec : boundk ] , we present our results for solving separation when the counting threshold is assumed to be fixed .",
    "this solves separation in particular for the class . in section  [ sec : ltt ] , we show that separation by languages can be decided by bounding the counting threshold .",
    "we also provide an optimality result for the bound we obtain . in section  [ sec : comp ] , we show upper and lower bounds for the separation problem by and languages . in section  [ sec : cf ] , we consider separation by and languages when the input languages to be separated are context - free , rather than regular .",
    "we finally present some open problems and further work in section  [ sec : conc ] .",
    "* words and languages . *",
    "we fix a finite alphabet @xmath10 .",
    "we denote by @xmath11 the free monoid over  @xmath10 .",
    "the empty word is denoted by  @xmath12 .",
    "if @xmath13 is a word , we set @xmath14 as the _ length _ , or _ size _ of @xmath13 .",
    "when @xmath13 is nonempty , we view @xmath13 as a sequence of @xmath14 positions labeled over @xmath10 .",
    "we number positions from @xmath15 ( for the leftmost one ) to @xmath16 ( for the rightmost one ) .    * infixes , prefixes , suffixes . *",
    "an _ infix _ of a word @xmath13 is a word @xmath17 such that @xmath18 for some @xmath19 .",
    "moreover , if @xmath20 ( resp .",
    "@xmath21 ) we say that @xmath17 is a _ prefix _ ( resp .",
    "_ suffix _ ) of @xmath13 .",
    "let @xmath22 .",
    "we write @xmath23 $ ] for the infix of @xmath13 starting at position @xmath24 and ending at position @xmath25 . by convention",
    ", we also set @xmath26 = \\varepsilon$ ] .",
    "observe that by definition , when @xmath27 , we have @xmath28 = w[x , y ] \\cdot w[y , z]$ ] .    * profiles . * for @xmath29 ,",
    "let @xmath30 and @xmath31 .",
    "@xmath32-profile _ is a pair of words @xmath33 of lengths at most @xmath34 and @xmath35 , respectively .",
    "given @xmath36 and @xmath24 a position of @xmath13 , the _",
    "@xmath32-profileof @xmath24 _ is the pair @xmath33 defined as follows : @xmath37 $ ] and @xmath38 $ ] ( see figure  [ fig : profiled ] ) .",
    "a @xmath32-profile@xmath33 _ occurs in a word @xmath13 _ if there exists some position @xmath24 within @xmath13 whose @xmath32-profileis @xmath33 .",
    "similarly , if @xmath39 is a natural number , we say that @xmath33 _ occurs @xmath39 times in @xmath13 _ if there are @xmath39 distinct positions in @xmath13 where @xmath33 occurs .",
    "we denote by @xmath40 the set of @xmath32-profilesover @xmath10 .",
    "note that its size is @xmath41 .",
    "= [ line width=0.7pt,- > ] = [ line width=1.5pt,- > ] = [ line width=1.0pt , snake = brace ]    ( b1 ) at ( 0.0,0.0 ) @xmath42 ; ( b2 ) at ( 0.2,0.0 ) @xmath43 ; ( b3 ) at ( 0.4,0.0 ) @xmath44 ; ( b4 ) at ( 0.6,0.0 ) @xmath44 ; ( b5 ) at ( 0.8,0.0 ) @xmath44 ; ( b6 ) at ( 1.0,0.0 ) @xmath43 ; ( b7 ) at ( 1.2,0.0 ) @xmath43 ; ( b8 ) at ( 1.4,0.0 ) @xmath42 ; ( b9 ) at ( 1.6,0.0 ) @xmath44 ; ( ba ) at ( 1.8,0.0 ) @xmath42 ; ( bb ) at ( 2.0,0.0 ) @xmath43 ; ( bc ) at ( 2.2,0.0 ) @xmath43 ; ( bd ) at ( 2.4,0.0 ) @xmath42 ; ( be ) at ( 2.6,0.0 ) @xmath42 ; ( bf ) at ( 2.8,0.0 ) @xmath43 ;    ( x1 ) at ( 0.0,0.8 ) @xmath24 ; ( x2 ) at ( 1.6,0.8 ) @xmath45 ; ( x3 ) at ( 2.6,0.8 ) @xmath46 ;    ( x1 ) to ( b1 ) ; ( x2 ) to ( b9 ) ; ( x3 ) to ( be ) ;    ( p1 ) at ( 0.0,-1.0 ) @xmath47 ; ( p2 ) at ( 1.6,-1.0 ) @xmath48 ; ( p3 ) at ( 3.4,-1.0 ) @xmath49 ;    ( b1 ) to ( p1 ) ; ( b9 ) to ( p2 ) ; ( be ) to [ out=-90,in=90 ] ( p3 ) ;    ( p0 ) at ( @xmath50 ) @xmath51-profiles of @xmath52 and @xmath46 : ;    intuitively , the @xmath32-profileis the description of the infix of @xmath13 that is centered at position  @xmath24 .",
    "observe in particular that the @xmath32-profilesthat occur in a word determine the prefixes and suffixes of length @xmath53 of this word .",
    "this is convenient , since we only have to consider one object instead of three as in the usual presentations of the classes and .",
    "* separability*. given languages @xmath54 over @xmath11 , we say that @xmath3 _ separates _",
    "@xmath55 from @xmath56 if @xmath57 given a class @xmath1of languages , we say that the pair @xmath58 is _",
    "@xmath1-separable _ if some language @xmath59 separates @xmath55 from @xmath56 .",
    "when @xmath1is closed under complement , @xmath58 is @xmath1-separable if and only if @xmath60 is , in which case we simply say that @xmath55 and @xmath56 are  @xmath1-separable . *",
    "automata . *",
    "[ paragraph : automata ] a _ nondeterministic finite automaton _ ( nfa ) over @xmath10 is denoted by a tuple @xmath61 , where @xmath62 is the finite set of states and @xmath63 is the transition relation .",
    "observe that this definition is not the standard one : we do not include the initial and final state sets ( we shall explain below why this is more convenient in our setting ) . abusing notation , we also denote by @xmath64 the relation induced by the transition relation .",
    "given sets @xmath65 and @xmath66 , we then set @xmath67 a language @xmath68 is _ accepted _ , or _",
    "recognized _ by @xmath69 if _ there exist _ sets @xmath65 and @xmath70 such that @xmath71 . in this case , we call @xmath72 the set of _ initial states _ and @xmath73 the set of _ final states for @xmath3_. the reason why we do not include initial and final states in our definition of an nfa is the following : when dealing with separation , we start from two input languages . however , it is convenient to work with a single automaton recognizing them both , rather than having to deal with two .",
    "our definition permits this : an nfa recognizing both languages can be obtained by building the cartesian product of nfas recognizing the input languages , and by then suitably choosing initial and final states for each of the input languages .",
    "the _ size _ @xmath74 of an automaton @xmath69 is its number of states plus its number of transitions .",
    "if @xmath75 is a function , then @xmath69 is called a _ deterministic _ finite automaton ( dfa ) .",
    "* monoids .",
    "* let @xmath3 be a language and let @xmath76 be a monoid .",
    "we say that _",
    "@xmath3 is recognized by @xmath76 _ if there exists a monoid morphism @xmath77 together with a subset @xmath78 such that @xmath79 .",
    "we also say in this case that @xmath3 is recognized by @xmath80 .",
    "it is well known that a language is accepted by an nfa if and only if it can be recognized by a _",
    "finite monoid_. we denote by @xmath81 the size of a finite monoid .    in the same way as for nfas",
    ", we want to work with a single monoid recognizing both input languages .",
    "this is easy to obtain , since if @xmath82 ( resp .",
    "@xmath83 ) recognizes @xmath84 ( resp .",
    "@xmath85 ) , then @xmath86 defined by @xmath87 recognizes both @xmath88 and @xmath89 .",
    "finally , it is well known that one can compute from any nfa a finite monoid recognizing any language that this nfa can accept .",
    "the easiest way to do so is to consider the _ transition monoid _ of the nfa , which is generated by boolean matrices @xmath90 for @xmath91 , where @xmath92 if @xmath93 and @xmath94 otherwise .",
    "it is straightforward to check that this finite monoid recognizes any language accepted by @xmath69 .",
    "in this paper , we investigate two classes of languages . intuitively , a language is locally testable if membership of a word in the language only depends on the _ set _ of infixes , prefixes and suffixes up to some fixed length that occur in the word . for a locally threshold testable language ,",
    "membership may also depend on the _ number _ of occurrences of such infixes , which may thus be counted up to some fixed threshold .",
    "in this section we provide specific definitions for both classes .",
    "we start with the larger class of locally threshold testable languages . in the following ,",
    "we say that two numbers are _ equal up to threshold @xmath95 _ if either both numbers are equal , or both are greater than or  equal  to  @xmath95 .    *",
    "locally threshold testable languages .",
    "* we say that a language is _ locally threshold testable _",
    "( ) if it is a boolean combination of languages of the form :    1 .",
    "[ p1 ] @xmath96 , for some @xmath97 .",
    "[ p2 ] @xmath98 , for some @xmath97 .",
    "[ p3 ] @xmath99 , for some @xmath97 and @xmath100 .",
    "actually , languages can be defined in terms of first - order logic : a language is if and only if it can be defined by an @xmath7formula , _ i.e. _ , a first - order logic formula using predicates for the equality and next position relations , but not for the linear order .",
    "we also define an index on languages .",
    "usually , this index is defined as the smallest size of infixes , prefixes and suffixes needed to define the language . however , since we only work with @xmath32-profiles , we directly define an index based on the size of @xmath32-profiles .",
    "given a @xmath32-profile@xmath33 , let @xmath101 be the number of positions @xmath24 in @xmath13 such that @xmath33 is the @xmath32-profileof @xmath24 . for @xmath102 and @xmath103 , we write @xmath104 if for every @xmath32-profile@xmath33 , the numbers @xmath101 and @xmath105 are equal up to threshold @xmath95",
    ".    one can verify that @xmath106 is an equivalence relation ( and actually a congruence ) of finite index .",
    "for @xmath107 , let us denote by @xmath108 $ ] the set of the finitely many languages that are unions of @xmath109-classes . by definition , we have @xmath110 $ ] . given @xmath111 , the smallest @xmath108$]-language containing  @xmath3  is @xmath112_{k}^{d}}}=\\{w\\in a^*\\mid \\exists u\\in l\\text { such that } u{{\\ensuremath{\\equiv_{k}^{d}}\\xspace}}w\\}.\\ ] ]",
    "as it is often the case , there is no smallest language containing a given regular language .",
    "for instance , over @xmath113 , any language containing @xmath114 is of the form @xmath115 with @xmath73  finite . removing @xmath116 from such a language yields a smaller one , still containing  @xmath114 .    * locally testable languages .",
    "* the class of locally testable languages is the restriction of languages in which infixes can not be counted .",
    "a language is _ locally testable _ ( ) if it is a boolean combination of languages of the form  , and the following restriction of  :    1 .   [ p4 ] @xmath117 , for some @xmath97 .",
    "no simple description of in terms of first - order logic is known . in terms of linear temporal logic ,",
    "languages are exactly those defined by formulas involving only the operators ( eventually ) and ( next ) , with no nesting of operators .    given two words @xmath118 and a number @xmath32 , we write @xmath119 for @xmath120 . for all @xmath121 , we denote by @xmath122 $ ] the set of languages that are unions of @xmath123-classes , and @xmath124 $ ] .",
    "given @xmath111 and @xmath125 , the smallest @xmath122$]-language containing  @xmath3 is @xmath112_{k}}}=\\{w\\in a^*\\mid \\exists u\\in l\\text { such that } u{{\\ensuremath{\\equiv_{k}}\\xspace}}w\\}.\\ ] ] however , as for , there is no smallest language containing a given regular language .",
    "in this section , we prove that if @xmath95 is a fixed natural number , it is decidable whether two languages can be separated by an language of counting threshold @xmath95 ( _ i.e. _ , by an @xmath108 $ ] language for some @xmath32 ) . in particular , this covers the case of , which corresponds to @xmath126 .",
    "all results in this section are for an arbitrary fixed  @xmath95 .",
    "our result is twofold .    *",
    "first , we establish a bound @xmath32 on the size of profiles that it suffices to consider in order to separate the input languages .",
    "this bound only depends on the size of monoids recognizing these languages , and it can be computed .",
    "one can then use a brute - force algorithm that tests separability by all the finitely many @xmath108 $ ] languages . *",
    "the second contribution is a criterion on the input languages to check separability by an @xmath108 $ ] language for some @xmath32 .",
    "this criterion can be defined equivalently on automata or monoids recognizing the input languages , in terms of the absence of common patterns .",
    "the section is divided in four subsections .",
    "our criterion is stated in the first one .",
    "the remaining subsections are then devoted to the statement and proof of the theorem .      in this section",
    ", we define our criterion that two languages must satisfy in order to be separable .",
    "the criterion can be defined equivalently on automata or monoids recognizing the languages .    * block patterns . *",
    "a _ block _ is a triple of words @xmath127 where @xmath128 are nonempty .",
    "similarly , a _ prefix block _ is a pair of words @xmath129 with @xmath130 nonempty , and a _ suffix block _ is a pair of words @xmath131 with @xmath132 nonempty .",
    "let @xmath133 .",
    "a _ @xmath95-pattern _ @xmath134is    * either a word @xmath13 , * or a triple @xmath135 where @xmath136 and @xmath137 are respectively a prefix and a suffix block , and @xmath138 is a function mapping blocks to the set @xmath139 , such that all but finitely many blocks are mapped to @xmath15 .    * decompositions .",
    "* let @xmath13 be a word and let @xmath140 be a @xmath95-pattern .",
    "we say that _ @xmath13 admits a @xmath140-decomposition _ if @xmath13 admits a decomposition @xmath141 with @xmath142 and such that either @xmath143 and @xmath144 , or @xmath145 and the following conditions are verified :    1 .",
    "@xmath146 and @xmath147 .",
    "2 .   for every block @xmath148 , if @xmath149 , then @xmath150 .",
    "3 .   for every block @xmath148 , if @xmath151 , then @xmath152 .    we may say @xmath140-decompositionto mean @xmath140-decomposition__of some word__. let @xmath153 be a morphism into a monoid  @xmath76 , and let @xmath154 .",
    "a @xmath140-decompositionof @xmath13 is said to be _",
    "@xmath155-compatible _ if @xmath156 and @xmath157 , for all @xmath158 .",
    "similarly , if @xmath159 are two states of an automaton @xmath69 , a @xmath140-decompositionis _ @xmath160-compatible _ if there is a run from @xmath161 to @xmath162 on @xmath13 , such that for all @xmath158 , each infix @xmath163 labels a loop in the  run , as pictured in  [ fig : compat ] .",
    "= [ minimum size=0.35cm , draw , circle , inner sep=2pt ] = [ minimum size=0.35cm , draw , circle , double , double distance=1pt ] = [ line width=0.5pt,- > ]    ( a1 ) at ( 0.0,0.0 ) @xmath161 ; ( a2 ) at ( 1.5,0.0 ) ; ( a3 ) at ( 3.0,0.0 )  ; ( a4 ) at ( 4.5,0.0 ) ; ( a5 ) at ( 6.0,0.0 ) ; ( a6 ) at ( 7.5,0.0 )  ; ( a7 ) at ( 9.0,0.0 ) ; ( a8 ) at ( 10.5,0.0 ) @xmath162 ;    ( a1 ) to node[below ] @xmath164 ( a2 ) ; ( a2 ) to node[below ] @xmath165 ( @xmath166 ) ; ( a3 ) to node[below ] @xmath167 ( a4 ) ; ( a5 ) to node[below ] @xmath168 ( @xmath169 ) ; ( @xmath170 ) to node[below ] @xmath171 ( a7 ) ;    ( a4 ) to node[below ] @xmath172 ( a5 ) ;    ( a7 ) to node[below ] @xmath173 ( a8 ) ;    ( a2 ) to [ out=125,in=55,loop ] node[above ] @xmath174 ( a2 ) ; ( a4 ) to [ out=125,in=55,loop ] node[above ] @xmath163 ( a4 ) ; ( a5 ) to [ out=125,in=55,loop ] node[above ] @xmath175 ( a5 ) ; ( a7 ) to [ out=125,in=55,loop ] node[above ] @xmath176 ( a7 ) ;    * common patterns . *",
    "let @xmath100 and @xmath177 be a morphism into a finite monoid .",
    "we say that a pair @xmath178 has a _",
    "common @xmath95-pattern _ if there exist a @xmath95-pattern @xmath134and two @xmath140-decompositionsof ( possibly different ) words that are respectively @xmath179-compatible and @xmath180-compatible . in this terminology ,",
    "@xmath80 is understood and not mentioned explicitly .",
    "similarly , if @xmath181 is an automaton , and @xmath182 are states of @xmath181 , we say that the pair @xmath183 has a _",
    "common @xmath95-pattern _ if there exist a @xmath95-pattern @xmath134and two @xmath140-decompositionsof words that are respectively @xmath184-compatible and @xmath185-compatible .",
    "in particular , @xmath183 has a common 1-pattern if there are paths in @xmath181 of the form shown in  [ fig : compat ] with the same _ set _ of triples @xmath186 , going respectively from @xmath187 to @xmath188 and from @xmath189 to @xmath190 .",
    "the reason for introducing common patterns is the following .",
    "first , having a common @xmath95-pattern for a pair @xmath191 is a decidable property .",
    "second , it is a necessary and sufficient condition for the languages @xmath192 and @xmath193 _ not _ being separable by any @xmath108 $ ] language , for any  @xmath32 .",
    "a similar statement holds for common @xmath95-patterns in nfas .",
    "this is what we state now in our main theorem for this section .",
    "[ thm : seplttd ] fix @xmath100 .",
    "let @xmath194 be regular languages .",
    "let @xmath195 be a morphism into a finite monoid @xmath76 recognizing both @xmath55 and @xmath56 .",
    "let @xmath181 be an nfa recognizing both @xmath55 and @xmath56 , with @xmath196 .",
    "set @xmath197 .",
    "then , the following conditions are equivalent :    1 .",
    "[ item : a ] @xmath55 and @xmath56 are @xmath198$]-separable for some @xmath199 .",
    "[ item : b ] @xmath55 and @xmath56 are @xmath108$]-separable .",
    "[ item : c ] the language @xmath200_{k}^{d}}}$ ] separates @xmath55 from @xmath56 .",
    "[ item : d ] no pair in @xmath201 has a common @xmath95-pattern . 5 .",
    "[ item : e ] no pair in @xmath202 has a common @xmath95-pattern .    observe that item   is essentially a _ delay theorem _",
    "@xcite for separation restricted to the case of : we prove that the size of profiles ( _ i.e. _ , infixes ) that a potential separator needs to consider can be bounded by a function of the size of the monoids recognizing the  languages . by restricting theorem  [ thm : seplttd ] to the case @xmath126",
    ", we get the following separation theorem for , that we explicitly state in view of the relevance of this class .",
    "[ thm : seplt ] let @xmath194 be regular languages .",
    "let @xmath195 be a morphism into a finite monoid @xmath76 recognizing both @xmath55 and @xmath56 .",
    "let @xmath181 be an nfa recognizing both @xmath55 and @xmath56 , with @xmath196 . set @xmath197 .",
    "the following conditions are equivalent :    1 .",
    "[ item : a2 ] @xmath55 and @xmath56 are @xmath203-separable .",
    "[ item : b2 ] @xmath55 and @xmath56 are @xmath122$]-separable .",
    "[ item : c2 ] the language @xmath200_{k}}}$ ] separates @xmath55 from @xmath56 .",
    "[ item : d2 ] no pair in @xmath201 has a common @xmath204-pattern . 5 .   [ item : e2 ] no pair in @xmath202 has a common @xmath204-pattern .",
    "theorem  [ thm : seplttd ] and theorem  [ thm : seplt ] yield algorithms for deciding - and -separability for a fixed threshold .",
    "indeed , the algorithm just tests all the finitely many @xmath108 $ ] languages as potential separators .",
    "this brute - force approach yields a very costly procedure .",
    "it turns out that a more practical algorithm can be obtained from items   and  .",
    "we postpone the presentation of this algorithm to section  [ sec : comp ] .",
    "[ cor : decidltd ] let @xmath100 .",
    "it is decidable whether two given regular languages are @xmath198$]-separable for some @xmath205 .",
    "in particular , it is decidable whether they are @xmath203-separable .",
    "it remains to prove theorem  [ thm : seplttd ] .",
    "the implications @xmath206 are immediate by definition .",
    "we now prove the implications @xmath207 , devoting a separate subsection to the proof of each implication .",
    "we prove the contrapositive of @xmath208 : if @xmath209 has a common @xmath95-pattern , then there exists no @xmath205 such that @xmath55 and @xmath56 are @xmath198$]-separable .",
    "this is an immediate consequence of the next proposition .",
    "[ prop : decomptokp ] fix @xmath100 and let @xmath181 be an nfa .",
    "let @xmath182 be states of @xmath181 . if @xmath183 has a common @xmath95-pattern , then , for all @xmath205 , there exist @xmath210 accepted respectively by @xmath211 and @xmath212 such that @xmath213 .",
    "set @xmath214 and @xmath215 .",
    "let @xmath134be a common @xmath95-pattern of @xmath183 . if @xmath216 , then by definition , @xmath217 , and it suffices to choose @xmath218 .",
    "otherwise , @xmath145 and there exist @xmath219 , @xmath220 having a @xmath184- respectively @xmath185-compatible @xmath140-decomposition .",
    "let @xmath221 and @xmath222 be these decompositions . for @xmath205 ,  set @xmath223 by definition of compatibility , we deduce that @xmath224 and @xmath225 .",
    "we claim that @xmath226 . indeed , from the @xmath140-decompositionsof @xmath227 and @xmath228",
    ", we deduce that @xmath229 and @xmath230 , which implies that @xmath231 and @xmath232 have the same prefix of length @xmath233 ( and actually , even of length @xmath234 ) .",
    "similarly , they have the same suffix of length @xmath233 .",
    "to show the claim , it remains to verify that each word of length at most @xmath199 occurs the same number of times , up to threshold  @xmath95 , as an infix in @xmath231 and in @xmath232 .",
    "let @xmath235 be an infix of length at most @xmath199 of , say , @xmath231 .",
    "assume first that @xmath235 occurs in some @xmath236 .",
    "then it occurs at least @xmath95 times .",
    "since the decompositions of @xmath210 are @xmath140-decompositions , there exists some @xmath237 such that @xmath238 .",
    "therefore , @xmath235 occurs at least @xmath95 times as an infix in  @xmath239 , hence also in @xmath232 .",
    "assume finally that @xmath235 does not occur in any @xmath236 .",
    "therefore , it overlaps with some of the @xmath172 s , and for these indices @xmath240 , it is an infix of @xmath241 .",
    "since both decompositions of @xmath231 and @xmath232 are @xmath134-compatible , the number of triples @xmath186 in the decomposition of @xmath231 and the number of triples @xmath242 in that of @xmath232 which are equal to a given triple is the same , up to threshold  @xmath95 .",
    "therefore , @xmath235 occurs the same number of times up to threshold @xmath95 in both @xmath231 and @xmath232 .",
    "we have thus shown that @xmath226 .",
    "we prove the contrapositive : if there is a pair @xmath243 having a common @xmath95-pattern , then there is a pair @xmath244 also having a common @xmath95-pattern .",
    "this follows from the following claim , which states that the presence of a `` recognizing pair '' @xmath245 that has a common @xmath95-pattern does not depend on the choice of the recognizing monoid morphisms .",
    "let @xmath133 , and let @xmath195 and @xmath246 be monoid morphisms recognizing both @xmath55 and @xmath56 .",
    "if there exists @xmath247 having a common @xmath95-pattern , then there exists @xmath248 also having a common @xmath95-pattern .",
    "let us admit the claim for a moment .",
    "assume that @xmath243 has a common @xmath95-pattern .",
    "let @xmath249 be the transition monoid of @xmath181 , and let @xmath246 be the associated morphism .",
    "since @xmath250 recognizes @xmath251 ( see  @xcite ) , one can apply the claim : it follows that there exists @xmath252 having a common @xmath95-pattern . by definition of a transition monoid",
    ", it is then immediate to build from @xmath253 a pair @xmath244 having a common @xmath95-pattern .",
    "it remains to prove the claim .",
    "let @xmath195 and @xmath246 be morphisms recognizing both @xmath251 for @xmath254 , and let @xmath255 and @xmath256 .",
    "let @xmath140 be a common @xmath95-pattern of @xmath257 .",
    "if @xmath258 , then by definition @xmath259 , so @xmath134is a common @xmath95-pattern of @xmath260 .",
    "otherwise , @xmath140 is of the form @xmath135 . we define a new @xmath95-pattern @xmath261 that is common to some @xmath262 .",
    "let @xmath263 be such that @xmath264 is idempotent for all @xmath265 and @xmath266 .",
    "for any block @xmath267 , set @xmath268 .",
    "the mapping @xmath269 is clearly injective .",
    "set @xmath261 as the @xmath95-pattern @xmath270 defined as follows :    * @xmath271 with @xmath272 . * for any block @xmath273 , if @xmath274 for some block @xmath148 , then @xmath275 .",
    "otherwise @xmath276 .",
    "* @xmath277 with @xmath278 .",
    "we now prove that @xmath261 is a common @xmath95-pattern of some @xmath279 . by definition of @xmath134 , there exist @xmath280 , @xmath281 having an @xmath282- , respectively @xmath180-compatible @xmath140-decomposition .",
    "let @xmath221 and @xmath283 be these decompositions .",
    "set @xmath284 for @xmath285 , @xmath286 for @xmath287 , @xmath288 , @xmath289 , @xmath290 for @xmath291 , and @xmath292 for @xmath293 .",
    "let then @xmath294 it is immediate by definition of @xmath261 and @xmath295 that @xmath210 are @xmath261-decompositions .",
    "then , it follows from the definition of @xmath296 for elements of @xmath76 that @xmath297 for @xmath298 .",
    "hence , we have @xmath299 .",
    "we choose @xmath300 , so that @xmath279 .",
    "finally , it follows from the definition of @xmath296 for @xmath249 that for @xmath298 , the decomposition of @xmath301 given by   is @xmath302-compatible .",
    "we have thus shown that @xmath303 has a common @xmath95-pattern .",
    "again , we prove the contrapositive of the statement : if @xmath200_{k}^{d}}}$ ] does not separate @xmath55 from @xmath56 when @xmath197 , then there exists @xmath304 having a common @xmath95-pattern .",
    "observe that by definition of @xmath200_{k}^{d}}}$ ] , if @xmath200_{k}^{d}}}$ ] does not separate @xmath55 from @xmath56 , then there exist @xmath305 , @xmath306 with @xmath307 .",
    "we take @xmath308 and @xmath309 .",
    "the next proposition shows that the pair @xmath245 indeed has a common @xmath95-pattern .",
    "[ prop : ktodecomp ] let @xmath195 be a morphism and let @xmath197 .",
    "let @xmath310 and let @xmath210 be words such that @xmath307 .",
    "then , there exists a @xmath95-pattern @xmath134 , an @xmath311-compatible @xmath140-decomposition , and an @xmath312-compatible @xmath140-decomposition .    the remainder of the section is now devoted to the proof of proposition  [ prop : ktodecomp ] .",
    "we set @xmath313 and @xmath95 as in the statement of the proposition .",
    "observe first that if @xmath314 , then it suffices to take @xmath315 .",
    "therefore , we suppose for the remainder of the proof that @xmath316 .",
    "we proceed as follows : we construct two new words @xmath317 from @xmath210 such that @xmath318 admits an @xmath311-compatible @xmath140-decompositionand @xmath319 admits an @xmath312-compatible @xmath140-decomposition , for some @xmath95-pattern @xmath145 .",
    "we first describe the construction of @xmath317 , and then prove that it is correct .",
    "it amounts to duplicating infixes verifying special properties in @xmath210 .",
    "we first define these special infixes , called _",
    ". _    * @xmath32-loops .",
    "* let @xmath36 , @xmath24 be a position in @xmath13 , and @xmath33 be the @xmath320-profile of @xmath24 .",
    "we say that _ @xmath24 admits a @xmath32-loop _ if there exists a nonempty prefix @xmath235 of @xmath321 such that @xmath322 . in this case , we call the smallest such @xmath235 _ the @xmath32-loopof @xmath24_. see  figure  [ fig : kloop ]",
    ".    = [ line width=0.7pt,- > ] = [ line width=1.5pt,- > ] = [ line width=1.0pt , snake = brace ]    ( b1 ) at ( -3.9,0.0 ) @xmath42 ; ( b2 ) at ( -2.1,0.0 ) @xmath43 ; ( b3 ) at ( -1.9,0.0 ) @xmath43 ; ( b4 ) at ( -0.1,0.0 ) @xmath44 ; ( b1.mid east ) to ( b2.mid west ) ; ( b3.mid east ) to ( b4.mid west ) ; ( @xmath323 ) to ( b1.mid west ) ; ( a1 ) at ( 0.1,0.0 ) @xmath42 ; ( c1 ) at ( 0.8,0.0 ) @xmath44 ; ( a2 ) at ( 1.9,0.0 ) @xmath42 ; ( a3 ) at ( 2.1,0.0 ) @xmath43 ; ( a4 ) at ( 3.9,0.0 ) @xmath43 ;    ( a1.mid east ) to ( c1.mid west ) ; ( c1.mid east ) to ( a2.mid west ) ; ( a3.mid east ) to ( a4.mid west ) ;    ( a4.mid east ) to ( @xmath324 ) ;    ( z1 ) at ( 0.1,-0.6 ) @xmath24 ;    ( z1 ) to ( a1 ) ;    ( -2.0,-0.75 ) to node[below ] @xmath325-profile of @xmath24 ( 2.0,-0.75 ) ; ( -4.0,-1.5 ) to node[below ] @xmath32-profile of @xmath24 ( 4.0,-1.5 ) ;    ( -2.0,0.7 ) to node[above ] @xmath326 ( 0.0,0.7 ) ; ( 0.0,0.7 ) to node[above ] @xmath321 ( 2.0,0.7 ) ;    ( 0.0,0.25 ) to node[above ] @xmath235 ( 0.9,0.25 ) ;    at ( 0.0,1.4 ) @xmath327 ;    for our construction to work , we need @xmath32-loopsto have three specific properties .",
    "the first two are simple facts that are immediate from the definition : @xmath32-loopsare determined by profiles and can be duplicated without modifying the image of the word under  @xmath80 .",
    "[ fct : profloop ]",
    "let @xmath24 be a position . whether @xmath24 admits a @xmath32-loop , and if so , which @xmath32-loop@xmath24 admits , only depends on the @xmath325-profile of @xmath24 .",
    "[ fct : tloop ] let @xmath13 be a word and let @xmath24 be a position within @xmath13 such that @xmath24 admits a @xmath32-loop@xmath235",
    ". then we have @xmath328 ) = \\alpha(w[0,x ] )    \\cdot \\alpha(u)$ ] .",
    "the last property we need is that @xmath32-loopsoccur frequently in words , _",
    "i.e. _ , at least one of @xmath329 consecutive positions must admit a @xmath32-loop .",
    "this follows from pumping arguments .",
    "[ lem : cloop ] let @xmath13 be a word and let @xmath330 be @xmath329 consecutive positions in  @xmath13 . then , there exists at least one position @xmath331 with @xmath332 that admits a @xmath32-loop .    by choice of @xmath32 , @xmath333 . by the pigeonhole principle ,",
    "we obtain two natural numbers @xmath334 such that @xmath335)=\\alpha(w[x_1,x_j])$ ] .",
    "we prove that @xmath331 admits a @xmath32-loop .",
    "consider the @xmath336-profile @xmath33 of @xmath331 and @xmath337 $ ] .",
    "since @xmath338|<\\lfloor k/4\\rfloor$ ] , @xmath339 $ ] is a suffix of @xmath326 , so @xmath340 . since @xmath341 , @xmath235 is a prefix of @xmath321 .",
    "therefore @xmath331 admits a @xmath32-loop .",
    "observe that @xmath235 is not necessarily _ the _",
    "@xmath32-loopof @xmath331 , as there might be a smaller word that also satisfies the definition .    * construction of @xmath317 . * we can now construct @xmath318 and @xmath319 . if @xmath342 are words and @xmath24 is a position of @xmath13 , the _ word constructed by inserting @xmath235 at position @xmath24",
    "_ is the word @xmath343 \\cdot u \\cdot w[x,|w|]$ ] . from @xmath231 ( resp .",
    "@xmath232 ) , we construct @xmath318 ( resp .",
    "@xmath319 ) by inserting simultaneously all infixes @xmath344 in @xmath231 ( resp .",
    "@xmath232 ) at any position @xmath24 that admits a @xmath32-loop , and where @xmath344 is the @xmath32-loopof @xmath24 .",
    "it remains to prove that the construction is correct , _",
    "i.e. _ , that for @xmath254 , @xmath345 admits an @xmath346-compatible @xmath140-decompositionfor some @xmath95-pattern @xmath145 .",
    "* the construction is correct . *",
    "if we had @xmath347 , then from @xmath348 one would obtain @xmath349 , a case already excluded .",
    "hence , both @xmath210 have length at least @xmath350 , so by lemma  [ lem : cloop ] , at least one insertion has occurred in both @xmath231 and @xmath232 .",
    "we now prove that there exists a @xmath95-pattern @xmath145 such that for @xmath254 , @xmath345 admits an @xmath346-compatible @xmath140-decomposition .",
    "we first define the @xmath95-pattern @xmath135 . by definition",
    ", @xmath318 can be decomposed as @xmath351 with @xmath352 and the words @xmath353 are the @xmath32-loopsinserted in the construction . since at least one insertion was made , we have @xmath354 and we can set @xmath355 , @xmath147 .",
    "we define @xmath138 as the function that maps a block @xmath356 to the number of times it occurs in the decomposition , up to threshold  @xmath95 .",
    "set @xmath145 . by definition , @xmath357 is a @xmath140-decompositionfor @xmath318 .",
    "moreover , it is @xmath311-compatible by fact  [ fct : tloop ] .",
    "it remains to prove that @xmath319 admits an @xmath312-compatible @xmath140-decomposition .    by definition",
    ", @xmath319 can be decomposed in a similar way as @xmath318 , @xmath358 with @xmath359 and the words @xmath360 are the @xmath32-loopsinserted in the construction of  @xmath319 .",
    "we prove that this is a @xmath140-decomposition .",
    "it will then be @xmath312-compatible by fact  [ fct : tloop ] .    to every position @xmath24 in @xmath232",
    "we associate a block , prefix block or suffix block in the following way . by definition",
    ", @xmath24 must fall into a word @xmath361 for some @xmath240 .",
    "if @xmath362 , we denote by @xmath363 the triple @xmath364 . similarly if @xmath365 ( resp .",
    "@xmath366 ) , then @xmath363 is the pair @xmath367 ( resp .",
    "@xmath368 ) .",
    "the result now follows from the next lemma .",
    "[ lem : blockscst ] let @xmath52 be distinct positions of words @xmath231 or @xmath232 with the same @xmath32-profile",
    ". then @xmath369 .",
    "moreover , the number of copies of a block @xmath370 in the decomposition of @xmath231 ( resp .",
    "@xmath232 ) is exactly the number of positions @xmath24 in @xmath231 ( resp .",
    "@xmath232 ) such that @xmath371 .",
    "there are several cases to treat depending on whether @xmath52 are in @xmath231 or @xmath232 and whether there are at least @xmath329 positions to the right and left of @xmath52 or not .",
    "all cases are treated similarly .",
    "therefore , we only treat the case when there are at least @xmath329 positions to the right and left of @xmath52 , and positions @xmath52 are both in @xmath231 .",
    "let @xmath46 be a position such that there are at least @xmath372 positions to the right and left of @xmath46 .",
    "let @xmath33 be the @xmath32-profileof @xmath46 and @xmath373 and @xmath374 be the positions admitting @xmath32-loopsthat are closest to @xmath46 .",
    "observe that by lemma  [ lem : cloop ] , @xmath375 and @xmath376 , hence @xmath377 belong to the copy of @xmath378 at @xmath46 .",
    "we claim that the relative positions of @xmath377 in this copy and the actual @xmath32-loopsonly depend on @xmath33 .",
    "this claims immediately implies , by construction of @xmath317 , that @xmath379 only depends on its @xmath32-profile .",
    "this entails the first part of the lemma .",
    "moreover , this also proves that if @xmath380 , then the relative position of @xmath46 within the corresponding copy of @xmath235 only depends on the @xmath32-profileof @xmath46 .",
    "this means that two positions with the same @xmath32-profilecan only generate the same copy of a block if they are equal : this is the second part of the  lemma .",
    "it remains to prove the claim . by definition of profiles ,",
    "the @xmath325-profiles of @xmath377 are determined by the @xmath32-profileof @xmath46 ( see figure  [ fig : profile ] ) .",
    "( b1 ) at ( -4.9,0.0 ) @xmath44 ; ( b2 ) at ( -2.6,0.0 ) @xmath42 ; ( b3 ) at ( -2.4,0.0 ) @xmath44 ; ( b4 ) at ( -0.1,0.0 ) @xmath44 ;    ( b1.mid east ) to ( b2.mid west ) ; ( b3.mid east ) to ( b4.mid west ) ; ( @xmath323 ) to ( b1.mid west ) ;    ( a1 ) at ( 0.1,0.0 ) @xmath43 ; ( a2 ) at ( 2.4,0.0 ) @xmath43 ; ( a3 ) at ( 2.6,0.0 ) @xmath44 ; ( a4 ) at ( 4.9,0.0 ) @xmath42 ;    ( a1.mid east ) to ( a2.mid west ) ; ( a3.mid east ) to ( a4.mid west ) ; ( a4.mid east ) to ( @xmath324 ) ;    ( z1 ) at ( 0.1,0.6 ) @xmath46 ;    ( z1 ) to ( a1 ) ; ( -2.5,-0.3 ) to node[below ] @xmath381 positions ( 0.0,-0.3 ) ; ( 0.3,-0.3 ) to node[below ] @xmath382 positions ( 2.5,-0.3 ) ; ( -2.5,0.15 ) to ( 0.0,0.15 ) ; ( 0.3,0.15 ) to ( 2.5,0.15 ) ; ( -5.0,-1.0 ) to node[below ] @xmath326 ( 0.0,-1.0 ) ; ( 0.0,-1.0 ) to node[below ] @xmath321 ( 5.0,-1.0 ) ; ( -5.0,-1.5 ) to node[below ] @xmath32-profile of @xmath24 ( 5.0,-1.5 ) ;    ( info ) at ( 3.0,2.0 ) contains a @xmath32-loop + @xmath325-profiles included in @xmath378 ;    ( info.west ) to [ out=180,in=90 ] ( -1.25,0.3 ) ; ( info.south ) to [ out=-90,in=90 ] ( + 1.4,0.3 ) ;    by fact  [ fct : profloop ] , this means that @xmath377 as well as their actual @xmath32-loopare determined by the @xmath32-profileof @xmath46 , which terminates the proof .",
    "taking @xmath52 as the first positions ( resp .",
    "last positions ) of @xmath210 , lemma  [ lem : blockscst ] implies that @xmath383 ( resp .",
    "@xmath384 ) .",
    "we finish by proving that for every block @xmath356 the number of indices @xmath240 such that @xmath385 is the same in the decompositions of @xmath317 up to threshold @xmath95 . by definition of @xmath135",
    "this will prove that the decomposition of @xmath319 is indeed a @xmath140-decomposition .",
    "let @xmath386 be a block .",
    "by lemma  [ lem : blockscst ] , there exists a set @xmath387 of @xmath32-profilessuch that the number of indices @xmath240 in @xmath388 ( resp .",
    "@xmath319 ) such that @xmath389 is exactly the number of positions in @xmath231 ( resp .  in @xmath232 ) with a @xmath32-profilein @xmath387 . because @xmath307 these numbers are then equal in @xmath390 up to threshold @xmath95 and this finishes the proof of proposition  [ prop : ktodecomp ]",
    "this section is devoted to . again",
    ", our theorem actually contains several results . in the case of",
    ", two parameters are involved : the size @xmath32 of profiles and the counting threshold  @xmath95 .",
    "the first result in our theorem states that the bound on @xmath32 of theorem  [ thm : seplttd ] still holds for full .",
    "this means that two languages are -separable if and only if there exists some counting threshold @xmath95 such that they are @xmath108$]-separable with the same bound @xmath32 as in theorem  [ thm : seplttd ] .",
    "it turns out that this already yields an algorithm for testing -separability .",
    "the algorithm relies on the decidability of presburger arithmetic and is actually adapted in a straightforward manner from an algorithm of  @xcite for deciding membership in .",
    "while this first result gives an algorithm for testing separability , it gives no insight about an actual separator .",
    "indeed , the procedure does not produce the actual counting threshold  @xmath95 .",
    "this is obtained in the second part of our theorem : we prove that two languages are -separable if and only if they are @xmath108$]-separable , where  @xmath32 is as defined in theorem  [ thm : seplttd ] , and @xmath95 is bounded by a function of the size of the monoid ( or automaton ) recognizing the input languages .",
    "note that this result also gives another ( brute - force ) algorithm for testing -separability .",
    "we now state our theorem .",
    "recall that @xmath40 denotes the set of @xmath32-profiles .",
    "[ thm : sepltt ] let @xmath194 be regular languages .",
    "let @xmath391 be a morphism into a finite monoid @xmath76 recognizing both @xmath55 and @xmath56 .",
    "let @xmath181 be an nfa recognizing both @xmath55 and @xmath56 , such that @xmath196 .",
    "set @xmath39 to be either @xmath392 or @xmath393 .",
    "let @xmath197 and let @xmath394 .",
    "then , the following conditions are equivalent :    1 .   [ item : a3 ] @xmath55 and @xmath56 are -separable .",
    "[ item : b3 ] there exists @xmath395 such that @xmath55 and @xmath56 are @xmath396$]-separable .",
    "[ item : e3 ] there exists @xmath395 such that no pair in @xmath201 has a common @xmath397-pattern .",
    "[ item : f3 ] there exists @xmath395 such that no pair in @xmath202 has a common @xmath397-pattern .",
    "[ item : c3 ] @xmath55 and @xmath56 are @xmath108$]-separable .",
    "[ item : d3 ] the language @xmath200_{k}^{d}}}$ ] separates @xmath55 from @xmath56 .",
    "observe that decidability of -separability is immediate from item   by using the usual brute - force algorithm . as it was the case for a fixed counting threshold ,",
    "this algorithm is slow and we will present a faster algorithm by using items   and   in section  [ sec : comp ] .    [",
    "cor : decidltt ] it is decidable whether two given regular languages are -separable .    by definition ,",
    "a language is if it is @xmath108 $ ] for some natural numbers @xmath398 .",
    "hence , the equivalence between items  , , and   is an immediate consequence of theorem  [ thm : seplttd ] .",
    "it is also clear that @xmath399 .",
    "therefore , we only need to prove items   or from one of the other properties , _",
    "i.e. _ , the bound on the threshold @xmath95 .",
    "unfortunately , these are exactly the items we need for corollary  [ cor : decidltt ] .",
    "however , we will prove that by reusing an algorithm of  @xcite , corollary  [ cor : decidltt ] can also be derived directly from item  .",
    "the remainder of this section is organized in three subsections .",
    "we first explain how corollary  [ cor : decidltt ] can be derived from item   without actually having to compute a bound on the counting threshold .",
    "next , we prove our bound on the counting threshold in theorem  [ thm : sepltt ] . finally , we discuss the optimality of this bound in the last subsection .",
    "as we explained , the equivalence of item   to -separability is immediate from theorem  [ thm : seplttd ] .",
    "we explain how to combine item   with an algorithm of  @xcite to obtain decidability directly .    in  @xcite",
    ", it is proved that once @xmath32 is fixed , parikh s theorem  @xcite can be used to prove that whether a language is @xmath108 $ ] for some @xmath95 can be rephrased as a computable presburger formula .",
    "decidability of membership in can then be reduced to decidability of presburger arithmetic . for achieving this ,",
    "two ingredients were needed : @xmath400 a bound on @xmath32 , and @xmath401 the translation to presburger arithmetic .",
    "it turns out that in  @xcite , only the proof of @xmath400 was specific to membership .",
    "on the other hand , separation was already taken care of in @xmath401 , because the intuition behind the presburger formula was testing _ separability _ between the input language and its complement . in our setting , we have already replaced  @xmath400 , _ i.e. _ ,  bounding  @xmath32 , by item  .",
    "therefore , the argument can be generalized .",
    "we explain in the remainder of this subsection how to construct the presburger formula .",
    "the argument makes use of the notion of commutative image , which we first recall .",
    "* commutative images .",
    "* let @xmath402 .",
    "the _ commutative image _ of @xmath13 , denoted by @xmath403 , is the @xmath10-indexed vector of natural numbers counting , for every @xmath404 , how many occurrences of @xmath43 there are  in  @xmath13 .",
    "this notion can be easily generalized in order to count profiles rather than just letters .",
    "let @xmath125 .",
    "the _ @xmath32-image _ of @xmath13 , @xmath405 , is the @xmath40-indexed vector of numbers counting for every @xmath32-profile@xmath33 the number of positions in @xmath13 with @xmath32-profile@xmath33 .",
    "if @xmath3 is a language , the _ @xmath32-image _ of @xmath3 , @xmath406 is the set @xmath407 .",
    "the definition of @xmath109yields the following  fact .    [ lem : eqredef ] let @xmath408 and let @xmath107 .",
    "then @xmath104 if and only if @xmath405 and @xmath409 are equal componentwise up to threshold @xmath95 .",
    "a well - known result about commutative images is parikh s theorem  @xcite , which states that if @xmath3 is context - free ( and so in particular if @xmath3 is regular ) , then @xmath410 is semilinear , _",
    "i.e. _ , presburger definable  .",
    "as explained in  @xcite , parikh s theorem extends without difficulty to @xmath32-images .",
    "[ prop : parikh ] let @xmath3 be a context - free language and let @xmath411 .",
    "then @xmath406 is semilinear .",
    "moreover , a presburger formula for this semilinear set can be computed from @xmath3 .    when @xmath412 , the proposition is parikh s theorem .",
    "when @xmath413 , consider the language @xmath414 over the alphabet @xmath40 of @xmath32-profiles such that @xmath415 if and only if there exists @xmath416 of the same length and such that a position in @xmath17 is labeled by the @xmath32-profileof the same position in @xmath13 .",
    "it is straightforward to see that @xmath414 is context - free and that the @xmath32-image@xmath406 of @xmath3 is its commutative image @xmath417 , which is semilinear by parikh s theorem .",
    "we can now explain how to decide -separability .",
    "by item   in theorem  [ thm : sepltt ] , @xmath194 are -separable if and only if they are @xmath108$]-separable for @xmath197 ( where @xmath76 is a monoid recognizing both @xmath418 ) and some natural number @xmath95",
    ". therefore , whether @xmath194 are -separable can be rephrased as follows : does there exist some threshold @xmath95 such that there exist no words @xmath419 such that @xmath307 ?",
    "by fact  [ lem : eqredef ] , this can be expressed in terms of @xmath32-images : does there exist a threshold @xmath95 such that there exist no vectors of natural numbers @xmath420 that are equal up to threshold @xmath95 ?",
    "it follows from theorem  [ prop : parikh ] that the above question can be expressed as a computable presburger formula .",
    "decidability of -separability then follows from decidability of presburger arithmetic .",
    "we now prove the bound on the counting threshold  @xmath95 .",
    "this amounts to proving that items   and   in theorem  [ thm : sepltt ] are equivalent to item  . by definition , it is immediate that @xmath421 . it remains to prove @xmath422 .",
    "we actually prove the contrapositive : if @xmath200_{k}^{d}}}$ ] does not separate @xmath55 from @xmath56 for the values of @xmath398 defined in the theorem , then there is no @xmath396$]-separator for any @xmath397 .",
    "assume that @xmath200_{k}^{d}}}$ ] is not a separator . by definition",
    ", this means that there exist @xmath305 and @xmath423 such that @xmath307 .",
    "set @xmath397 some arbitrary natural number .",
    "we prove that @xmath95 is large enough to construct words @xmath424 such that @xmath425 . by definition of @xmath426",
    ", this means that there exists no @xmath396$]-separator , which is what we want to prove .",
    "recall that @xmath427 or @xmath428 . to simplify the writing",
    ", we only treat the case when @xmath428 .",
    "the other case can be proved similarly . set @xmath429 ,",
    "so that @xmath430 . for @xmath431 , we prove the following property by induction : @xmath432      & \\text{{{$k$-profiles\\xspace}}that do not        occur more than $ d'$ times in both $ u_1 $ and $ u_2 $ is smaller}\\\\[-1ex ]      & \\text{than $ \\ell$ , then there exist words $ u'_1 \\in l_1 $ and $ u'_2 \\in        l_2 $ such that $ u'_1 { \\ensuremath{\\equiv_{k}^{d'}}\\xspace } u'_2$. }    \\end{aligned}\\ ] ]    before proving @xmath433 , note that by definition of @xmath430 and since @xmath40 is the set of _ all _ @xmath32-profiles , @xmath210 verify the premise of @xmath434 .",
    "therefore , @xmath435 entails that there exist words @xmath317 such that the desired property @xmath425 holds for all @xmath397 .",
    "it remains to prove @xmath433 for @xmath431 , which we do by induction on @xmath199 .",
    "the main idea for the inductive step is that by choice of @xmath95 , @xmath32-profilesthat occur many times in @xmath210 can be pumped in more than @xmath397 occurrences .",
    "this is summarized in the following lemma , that we prove below .",
    "[ lem : thresholdpump ] let @xmath436 .",
    "let @xmath437 be a natural number , @xmath438 and @xmath439 ( resp .",
    "@xmath440 ) .",
    "one can construct a word @xmath441 ( resp .",
    "@xmath442 ) such that @xmath443 and every @xmath32-profilethat occurs @xmath444 or more times in @xmath13 occurs @xmath397 or more times in @xmath17 .",
    "assume for a moment that lemma  [ lem : thresholdpump ] holds and let us deduce that @xmath433 holds , by induction on @xmath199 . if @xmath445 , the result is obvious since by definition all @xmath32-profilesin @xmath446 occur more than @xmath397 times in both words and therefore @xmath447 .",
    "assume now that @xmath448 .",
    "if @xmath447 , then it suffices to take @xmath449 and @xmath450 . otherwise , since @xmath451 , this means that there exists at least one @xmath32-profile@xmath33 that occurs more than @xmath452 times in both @xmath165 and @xmath453 but less than @xmath397 times in at least one of the two words . by applying lemma  [ lem : thresholdpump ] to both @xmath165 and @xmath453 with @xmath454 and @xmath455 , we get two words @xmath456 and @xmath457 such that @xmath458",
    ". moreover , @xmath33 now occurs more than @xmath397 times in both @xmath459 and @xmath460 .",
    "therefore , the number of @xmath32-profilesthat do not occur more than @xmath397 times in both @xmath459 and @xmath460 is smaller than @xmath233 .",
    "hence , we can apply the induction hypothesis to @xmath459 and @xmath460 which yields the desired @xmath461 .    to conclude the proof , it remains to show lemma  [ lem : thresholdpump ] .    by symmetry",
    ", we may assume that @xmath462 .",
    "the intuition is that as soon as a @xmath32-profileoccurs more than @xmath393 times ( which is the case if it occurs more than @xmath39 times ) , there exist two occurrences of this @xmath32-profilethat are labeled with the same state in the run of @xmath181 on @xmath13 .",
    "therefore , pumping can be used on @xmath13 to generate @xmath397 copies of the @xmath32-profile without affecting membership in @xmath55 .",
    "the issue with this argument is that in order to enforce @xmath443 , we need to be careful and avoid duplicating @xmath32-profilesthat occur less than @xmath463 times in @xmath13 .",
    "this is why we actually need a much higher constant than @xmath39 in order to achieve the  pumping .",
    "let @xmath33 be some @xmath32-profilethat occurs more than @xmath444 times in @xmath13 ( if there is none , it suffices to take @xmath464 ) .",
    "we explain how @xmath13 can be pumped in @xmath17 that contains more than @xmath397 copies of @xmath33 while enforcing @xmath443 .",
    "the construction can then be repeated to treat all @xmath32-profilesoccurring more than @xmath444 times in @xmath13 , in order to get the desired @xmath17 .",
    "let @xmath465 be @xmath444 positions where @xmath33 occurs .",
    "observe that there are at most @xmath466 positions in @xmath13 such that the @xmath32-profileat this position occurs strictly less than @xmath463 times in @xmath13 . by choice of @xmath467 , a simple application of the pigeonhole principle yields that there exist at least @xmath39 consecutive positions in the list ,",
    "say @xmath468 , such that no intermediate position between @xmath331 and @xmath469 has a @xmath32-profileoccurring less than @xmath463 times in @xmath13 .",
    "by choice of @xmath39 , there are two positions among @xmath470 that are labeled with the same state in the run of @xmath181 on @xmath13 .",
    "therefore , the corresponding infix can be pumped to generate @xmath397 copies of @xmath33 without affecting membership in @xmath55 . moreover , by choice of the positions @xmath468 , the pumping did not duplicate @xmath32-profilesoccurring less than @xmath463 times in @xmath13 .",
    "therefore , the resulting word @xmath17 verifies @xmath471 and @xmath441 .",
    "observe that the bound of theorem  [ thm : sepltt ] for the counting threshold is exponential in the size of @xmath472 ( which is itself exponential in the size of the monoid ) .",
    "a relevant question is to know whether this bound can be improved .",
    "our proof completely separates the bounding of @xmath32 and @xmath95 .",
    "we first provide a bound on @xmath32 in theorem  [ thm : seplttd ] .",
    "then , we bound the threshold by essentially viewing our words as words over the alphabet @xmath40 of @xmath32-profiles .",
    "this technique ignores properties of @xmath32-profiles .",
    "in particular , the @xmath32-profilesof adjacent positions are strongly related , a fact that our proof does not exploit .    in this subsection",
    ", we prove that getting a better bound on the counting threshold would require taking these additional properties into account .",
    "more precisely , we prove that if @xmath412 ( which means that the @xmath32-profileof a position is just its label ) , we can construct separable languages for which the separator requires a counting threshold that is exponential in @xmath473 .    for convenience , we assume the alphabet @xmath10 to be of even size and write @xmath474 .",
    "consider the following languages @xmath475    [ lem : counterexample ] @xmath194 are @xmath476$]-separable for some @xmath95 , but not @xmath477$]-separable .",
    "we prove that @xmath194 are @xmath476$]-separable for @xmath478 .",
    "consider the following language @xmath3 .",
    "a word @xmath13 belongs to @xmath3 if and only if for all odd @xmath240 either @xmath13 contains at least @xmath479 copies of @xmath480 , or the number of copies of @xmath481 in @xmath13 is exactly twice the number of copies of @xmath480 in @xmath13 .",
    "the maximal threshold up to which we have to count occurrences of letters for checking membership in @xmath3 of a word @xmath13 is the case where @xmath13 has exactly @xmath482 occurrences of @xmath483 , and therefore exactly @xmath484 occurrences of @xmath485 .",
    "this shows that @xmath486 $ ] .",
    "we prove that @xmath3 is a separator . by definition",
    ", we have @xmath487 .",
    "we prove that @xmath488 . by contradiction , assume that @xmath489 .",
    "since @xmath462 , it contains only one copy of @xmath490 .",
    "then , since @xmath416 , it must contain two copies of @xmath491 . by iterating the argument",
    "we get that @xmath13 must contain @xmath484 copies of @xmath485 , which is impossible since this number must be multiple of @xmath492 , by definition of @xmath55 .",
    "it follows that @xmath486 $ ] is a separator .",
    "it remains to prove that @xmath194 are not @xmath477$]-separable .",
    "consider the words @xmath493 it is clear that @xmath494",
    ". therefore @xmath194 are not @xmath477$]-separable .",
    "in this section , we present lower and upper complexity bounds for deciding - and -separability .    both the lower and upper bounds rely on the pattern criteria of theorems  [ thm : seplt ] and  [ thm : sepltt ] .",
    "we are able to prove that starting from nfas or dfas recognizing the input languages , deciding separability can be achieved in co - nexptime for and in 2-expspace for .",
    "moreover , we prove a co - np lower bound for both problems .      in this subsection , we prove the complexity upper bounds for the separation problem for both and .",
    "the corresponding algorithms rely on the patterns criteria of theorems  [ thm : seplt ] and  [ thm : sepltt ] .",
    "we prove the two following results .",
    "[ prop : ult ] deciding whether two languages accepted by some nfa are -separable can be achieved in co - nexptime .",
    "[ prop : ultt ] deciding whether two languages accepted by some nfa are -separable can be achieved in 2-expspace .    both algorithms work by reducing the problems to the special case of @xmath412 , _",
    "i.e. _ , whether there exists an ( resp .  )",
    "separator that considers only @xmath204-profiles .",
    "the reduction is identical in both cases and the difference resides in proving that it is correct .",
    "these proofs rely on item   in theorem  [ thm : seplt ] and item   in theorem  [ thm : sepltt ] respectively .",
    "the computations involved in the reduction can be done in exptime and the new nfa it outputs is of size exponential in the input nfa .",
    "therefore , it then suffices to give algorithms for the special case @xmath412 , which run in co - np for and expspace for .",
    "note that a reduction to @xmath412 could also be done by considering the bound @xmath32 on the size of profiles in theorems  [ thm : seplt ] and  [ thm : sepltt ] . indeed , once @xmath32",
    "is fixed it suffices to modify the input nfa to work on the alphabet of @xmath32-profilesto be reduced to the case @xmath412 . however",
    ", this technique might yield an nfa that is doubly exponential in the size of the input nfa .",
    "we first present and prove the reduction to the case @xmath412 .",
    "then we explain how to decide both problems in this special case .",
    "let @xmath495 be an nfa .",
    "it follows from theorem  [ thm : seplt ] ( resp .  theorem  [ thm : sepltt ] ) that to determine whether @xmath496 and @xmath497 are not -separable ( resp .",
    "not -separable ) , it suffices to verify whether there exists a pair in @xmath498 having a common @xmath204-pattern ( resp .  whether there exists @xmath95 such that some pair in @xmath202 has a common @xmath95-pattern ) .",
    "this requires verifying whether there exist a pattern @xmath134and @xmath140-decompositionscompatible with such a pair .",
    "observe that a @xmath140-decompositioncan be viewed as a word over the alphabet of blocks .",
    "the main idea behind the reduction is to construct a new nfa @xmath499 recognizing words over the alphabet of blocks that represent @xmath140-decompositionsthat , for some @xmath134 , are compatible with pairs of states of @xmath500 and of @xmath501 in @xmath181 .",
    "there are two main issues with this outline .",
    "first , the alphabet of blocks is infinite .",
    "second , a notion of compatibility has to be enforced between consecutive blocks in a word , _",
    "i.e. _ , @xmath502 needs to be followed by @xmath503 for some @xmath504 .",
    "again , this compatibility can not be simply encoded in the states since there are infinitely many words .",
    "both issues are solved using a similar argument . recall that we are only interested in @xmath140-decompositionsthat are compatible with pairs of states of @xmath500 and of @xmath501 in  @xmath181 .",
    "observe that for a block @xmath502 to appear in such a decomposition , there need to exist states @xmath505 with loops at @xmath505 labeled by @xmath506 respectively and a path from @xmath162 to @xmath507 labeled by @xmath235 .",
    "we abstract a block by the set of pairs of states verifying this property .",
    "since there are finitely many such sets , this yields a finite alphabet .",
    "the same argument can be used for compatibility : all words @xmath508 that need to be considered for compatibility need to label a loop at some state @xmath162 .",
    "we abstract @xmath508 by the set of states having such a loop labeled  @xmath508 .",
    "the information can then be encoded in the states of @xmath499 .",
    "we now describe the formal construction .",
    "let @xmath509 .",
    "we say that @xmath510 is _ synchronizable _ if there exists a nonempty word @xmath511 such that for all @xmath512 there exists a loop at @xmath162 labeled by @xmath508 .",
    "we will encode compatibility in synchronizable sets of states .",
    "if @xmath513 , we denote by @xmath514 ( resp .  by  @xmath515 ) the set of states that are left ( resp .",
    "right ) members of pairs in @xmath516 .",
    "we say that @xmath516 is _ synchronizable _ if * a ) * there exists @xmath517 such that for all @xmath518 there exists a run from @xmath162 to @xmath507 labeled by @xmath235 , * b ) * @xmath514 is synchronizable and * c ) * @xmath515 is synchronizable . in order to deal with prefixes and suffixes ,",
    "we generalize the notion to these limit cases .",
    "we say that @xmath516 is _ prefix synchronizable _",
    "_ suffix synchronizable _ ) if * a ) * and * c ) * ( resp .  *",
    "a ) * and * b ) * ) hold . finally , we say that @xmath516 is _ weakly synchronizable _ if * a ) * holds .",
    "we set @xmath519 and @xmath520 as the sets of weakly synchronizable , prefix synchronizable , synchronizable and suffix synchronizable sets of pairs of states , respectively .",
    "we can now define @xmath499 .",
    "set the alphabet @xmath521 as the disjoint union of @xmath519 and @xmath520 .",
    "the state set @xmath522 is defined as follows .",
    "@xmath523 we now define the transitions . for all @xmath524 ,",
    "we add a @xmath42-transition from @xmath525 to @xmath526 if @xmath527 . for all @xmath528",
    ", we add a @xmath42-transition from @xmath525 to @xmath529 if @xmath527 and @xmath530 .",
    "similarly , for all @xmath531 , we add a @xmath42-transition from @xmath529 to @xmath532 if @xmath533 and @xmath534 . finally , for all @xmath535",
    ", we add a @xmath42-transition from @xmath529 to @xmath536 if @xmath537 , @xmath538 and  @xmath539 .",
    "this ends the construction of @xmath499 from @xmath540 .",
    "observe that it is of size exponential in the size of @xmath181 .",
    "we now prove that the computation can be done in exptime .",
    "[ lem : construc ] given an nfa @xmath540 as input , @xmath499 can be constructed in exptime .",
    "testing synchronizability of a set of states ( resp .",
    "a set of pairs of states ) can easily be reduced to checking nonempty intersection between a set of nfas .",
    "this is known to be a pspace - complete problem .",
    "it follows that computing the synchronizable sets can be done in exptime .",
    "it is then clear that the remaining computations can be done in exptime .",
    "we now prove that the construction is correct , _",
    "i.e. _ , that it reduces - and -separability to the special case @xmath412 .",
    "[ lem : reducor ] let @xmath541 be an nfa , and let @xmath542 .",
    "then :    1 .",
    "@xmath543 are -separable if and only if @xmath544 are @xmath545$]-separable .",
    "2 .   @xmath543 are -separable if and only if there exists @xmath100 such that @xmath544 are @xmath476$]-separable .",
    "we only give the proof for using condition   from theorem  [ thm : sepltt ] .",
    "the proof for is obtained similarly using condition   from theorem  [ thm : seplt ] .",
    "suppose that @xmath496 and @xmath497 are not -separable .",
    "we prove that for all @xmath100 , @xmath546 and @xmath547 are not @xmath476$]-separable . set @xmath100 . by condition   of theorem  [ thm : sepltt ]",
    ", there exists a common @xmath95-pattern @xmath134 : there are two words @xmath548 and @xmath549 such that @xmath550 and @xmath551 are @xmath140-decompositions , respectively compatible with some @xmath552 in @xmath181 and @xmath553 in @xmath181 .",
    "there are two cases .    in the first case , @xmath554 and @xmath349",
    ". therefore , @xmath555 . by definition",
    ", it follows that there exists some @xmath524 such that @xmath556 , which ends the proof .    in the second case , @xmath557 .",
    "set @xmath558 such that @xmath146 , @xmath559 and for all @xmath240 , @xmath560 .",
    "similarly , we define @xmath561 .",
    "observe that since we started from @xmath140-decompositionsfor a @xmath95-pattern @xmath134 , we have @xmath562 .",
    "we use these words to construct @xmath563 belonging to @xmath546 and @xmath547 , respectively .",
    "let @xmath148 be a block appearing in @xmath564 .",
    "we set @xmath565 as the set of pairs of states that correspond to @xmath148 in the runs on @xmath231 and @xmath232 .",
    "since the @xmath140-decompositionsare compatible with their respective nfas , by definition , @xmath566 is synchronizable .",
    "similarly , if @xmath136 ( resp .",
    "@xmath137 ) is a prefix ( resp .",
    "suffix ) block occurring in @xmath564 , we get a prefix ( resp .",
    "suffix ) synchronizable set @xmath567 ( resp .",
    "@xmath568 ) .",
    "we now set @xmath569 and @xmath570 . by definition of @xmath499 and the fact that the @xmath140-decompositionsare @xmath571- , @xmath572-compatible , @xmath573 belong to @xmath546 and @xmath547 , respectively .",
    "moreover , since @xmath574 , we have @xmath575 .",
    "we conclude that @xmath546 and @xmath547 are not @xmath476$]-separable .",
    "conversely , assume that for all @xmath100 , @xmath546 and @xmath547 are not @xmath476$]-separable .",
    "we prove that for all @xmath100 , there exists a pair in @xmath576 having a common @xmath95-pattern @xmath134 .",
    "set @xmath100 , by hypothesis , there exist @xmath577 in @xmath578 , respectively , such that @xmath579 .",
    "again , we have two cases . by definition of @xmath499 , either @xmath580 or @xmath581 . in the first case",
    ", this means that @xmath582 , and therefore it suffices to set @xmath134as a word in this intersection to conclude .    otherwise , @xmath583 and @xmath584 . by definition of @xmath585 , to each label appearing in @xmath586 we can associate a unique block , prefix block or suffix block .",
    "we set @xmath145 as the @xmath95-pattern defined in the following way : @xmath587,@xmath588are the prefix and suffix blocks associated to @xmath589 and @xmath590 respectively .",
    "since @xmath575 , for all blocks @xmath148 , the number of occurrences of labels @xmath42 such that @xmath370is associated to @xmath42 is the same in @xmath591 up to threshold @xmath95 , we set @xmath592 as this number .",
    "finally , let @xmath593 and @xmath594 such that @xmath595 labels a path from @xmath596 to @xmath597 in @xmath499 .",
    "it is now straightforward to verify that the pair @xmath183 admits compatible @xmath140-decompositionsin @xmath181 , which terminates the proof .",
    "we explain how - and -separability can be decided when the size of profiles if fixed to @xmath204 . observe that in this case , the @xmath204-profile of a position is its label .",
    "we prove the two following lemmas .",
    "[ lem : lt1 ] deciding whether two regular languages given by an accepting nfa are @xmath545$]-separable is in co - np .",
    "[ lem : ltt1 ] given an nfa accepting two languages @xmath55 and @xmath56 , deciding whether there exists @xmath100 such that @xmath55 and @xmath56 are @xmath476$]-separable is in expspace .    as we explained in section",
    "[ sec : ltt ] , decidability follows from parikh s theorem and decidability of presburger arithmetic . however , applying these results naively yields high complexity .",
    "we explain here how to refine the argument in order to get co - np and expspace complexities .",
    "set @xmath598 as the parikh s images of @xmath55 and @xmath56 , respectively . as we explained in section",
    "[ sec : ltt ] , non -- separability is equivalent to the following presburger property : `` for all @xmath100 there exist @xmath599 , @xmath600 that are equal componentwise up to threshold  @xmath95 . '' by  @xcite , existential presburger formulas for @xmath601 can be computed in linear time ( see also  @xcite for the same technique applied to context - free grammars ) .",
    "therefore , a presburger formula for the property can also be computed in linear time . moreover , by definition , this property has exactly one quantifier alternation , it then follows from  @xcite that it can be decided in expspace .",
    "the same construction can be done for @xmath203 .",
    "however , the counting threshold @xmath95 is fixed to  @xmath204 .",
    "therefore , the constructed formula is existential .",
    "it is known that existential presburger formuals can be decided in np ( see  @xcite ) .",
    "we conclude that @xmath545$]-separability is in  co - np .    in the case of",
    "the problem is actually co - np - complete .",
    "this means that lemma  [ lem : lt1 ] can not be improved and that improving proposition  [ prop : ult ] would require improving the reduction .",
    "for , the situation is different , it is likely that a sharper analysis of the presburger formula would yield a better upper bound . indeed , while deciding presburger formulas with only one quantifier alternation is already very costly in general , the formula we consider is very specific .",
    "= [ minimum size=0.35cm , draw , circle , inner sep=0pt ] = [ minimum size=0.35cm , draw , circle , inner sep=2pt ] = [ minimum size=0.35cm , draw , circle , double ] = [ draw , rectangle , thick ]    = [ line width=0.7pt,- > ]    = [ line width=2.0pt , double,- > ] = [ line width=0.25cm , gray!50,- ] = [ line width=1.0pt,- ] = [ line width=1.0pt , snake = zigzag ] = [ line width=1.0pt , snake = snake ] = [ line width=1.0pt , snake = brace ] = [ midway , draw , thick , rounded rectangle , align = center , fill = white ]    = [ inner sep=0pt ] = [ rectangle ]    = [ line width=1.0pt , snake = brace ]    in this subsection , we prove co - np lower bounds for both and -separability .",
    "the bounds hold when the input languages are given as nfas or dfas .",
    "[ prop : hard ] let @xmath194 be languages accepted by two input dfas @xmath602 , respectively .",
    "the two following problems are co - np - hard :    1 .",
    "[ itm : lt ] are @xmath55 and @xmath56 -separable ?",
    "[ itm : ltt ] are @xmath55 and @xmath56 -separable ?",
    "we only do the proof for .",
    "the reduction is identical for the case .",
    "we prove that testing whether @xmath55 and @xmath56 are not -separable is np - hard .",
    "the proof is by reduction of * 3-sat*. from an instance of * 3-sat * , we construct two dfas and prove that the corresponding languages are not -separable if and only if the * 3-sat * instance is satisfiable .    let @xmath603 be a set of @xmath492-clauses over the set of variables @xmath604 .",
    "we construct dfas @xmath605 and @xmath606 over the alphabet @xmath607 . given @xmath608 , we say that @xmath13 _ encodes an assignment of truth values _ if for all @xmath291 , @xmath13 contains either the label @xmath331 or the label @xmath609 , but not both .",
    "it is straightforward to see that an assignment of truth values for the variables can be uniquely defined from such a word .",
    "moreover , by definition of , we have the following fact .",
    "[ fct : assign ] the language of correct assignments is .    intuitively , we want our dfas @xmath610 to verify the following three properties :    1 .",
    "[ item : code1 ] all words accepted by @xmath605 encode assignments , and for each assignment of variables , a word coding that assignment is accepted by @xmath605 .",
    "[ item : code2 ] all assignments accepted by @xmath606 satisfy @xmath5 , and for each assignment of variables satisfying @xmath5 , a word coding that assignment is accepted by @xmath606 .",
    "[ item : code3 ] if there exist @xmath611 accepted by @xmath610 that encode the same assignment of variables , then for all @xmath107 , @xmath210 can be chosen such that @xmath307 .",
    "conditions   and   are simple to enforce . indeed , for condition",
    ", it suffices to construct a dfa recognizing the words @xmath612 such that for all @xmath291 , @xmath613 or @xmath614 . for condition",
    "it suffices to construct a dfa recognizing the words @xmath615 where for all @xmath616 , @xmath617 is a literal of @xmath618 and @xmath235 is an arbitrary word ( @xmath235 is necessary since some variables might not appear in the prefix , preventing the word from coding an assignment ) .",
    "the problem with these two template dfas is that they do not verify condition  . to solve this issue , we add loops on their states in order to generate as many copies of infixes as necessary to make two words coding the same assignment indistinguishable wrt .  the class  .",
    "we begin by giving @xmath605 , of which a graphical representation is shown in figure  [ fig : a1 ] .",
    "it recognizes @xmath55 , with the marked initial and final states .",
    "( a10 ) at ( 0.0,+0.0 ) ; ( a11 ) at ( 1.5,+0.7 ) ; ( a12 ) at ( 1.5,-0.7 ) ;    ( a20 ) at ( 3.0,+0.0 ) ; ( a21 ) at ( 4.5,+0.7 ) ; ( a22 ) at ( 4.5,-0.7 ) ;    ( a30 ) at ( 6.0,+0.0 ) ;    ( a40 ) at ( 8.0,+0.0 ) ; ( a41 ) at ( 9.5,+0.7 ) ; ( a42 ) at ( 9.5,-0.7 ) ;    ( a50 ) at ( 11.0,+0.0 ) ;    ( @xmath619 ) to ( a10 ) ; ( a10 ) to node[sloped , above ] @xmath620 ( a11 ) ; ( a10 ) to node[sloped , below ] @xmath621 ( a12 ) ;    ( a11 ) to node[sloped , above ] @xmath622 ( a20 ) ; ( a12 ) to node[sloped , below ] @xmath622 ( a20 ) ;    ( a20 ) to node[sloped , above ] @xmath623 ( a21 ) ; ( a20 ) to node[sloped , below ] @xmath624 ( a22 ) ;    ( a21 ) to node[sloped , above ] @xmath622 ( a30 ) ; ( a22 ) to node[sloped , below ] @xmath622 ( a30 ) ;    ( a40 ) to node[sloped , above ] @xmath625 ( a41 ) ; ( a40 ) to node[sloped , below ] @xmath626 ( a42 ) ;    ( a41 ) to node[sloped , above ] @xmath622 ( a50 ) ; ( a42 ) to node[sloped , below ] @xmath622 ( a50 ) ;    at ( @xmath627 ) @xmath628 ;    ( a10 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( a10 ) ; ( a20 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( a20 ) ; ( a30 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( a30 ) ; ( a40 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( a40 ) ; ( a50 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( a50 ) ;    ( a11 ) to [ out=+105,in=+75,loop ] node[above ] @xmath629 ( a11 ) ; ( a21 ) to [ out=+105,in=+75,loop ] node[above ] @xmath630 ( a21 ) ;    ( a41 ) to [ out=+105,in=+75,loop ] node[above ] @xmath631 ( a41 ) ;    ( a12 ) to [ out=-105,in=-75,loop ] node[below ] @xmath632 ( a12 ) ; ( a22 ) to [ out=-105,in=-75,loop ] node[below ] @xmath633 ( a22 ) ; ( a42 ) to [ out=-105,in=-75,loop ] node[below ] @xmath634 ( a42 ) ;    by definition , @xmath605 verifies condition  .",
    "we now define @xmath606 as a sequence of @xmath635 subautomata , each one corresponding to a clause @xmath636 in @xmath0 . intuitively , if @xmath637 , the subautomata selects a label within @xmath638 .",
    "this means that if this word encodes an assignment , it must satisfy all clauses in @xmath5 .",
    "we give a graphical representation of @xmath606 in figure  [ fig : a2 ] ( it recognizes @xmath56 , with the marked initial and final states ) .    ( b1 ) at ( 0.0,0.0 ) ; ( b2 ) at ( 3.5,0.0 ) ; ( b3 ) at ( 7.0,0.0 ) ; ( b4 ) at ( 9.0,0.0 ) ; ( b5 ) at ( 12.5,0.0 ) ; ( @xmath639 ) to ( b1 ) ;    at ( @xmath640 ) @xmath628 ;    ( b1 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( b1 ) ; ( b2 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( b2 ) ; ( b3 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( b3 ) ; ( b4 ) to [ out=105,in=75,loop ] node[above ] @xmath622 ( b4 ) ; ( b5 ) to [ out=105,in=75,loop ] node[above ] @xmath10 ( b5 ) ;    ( c2 ) at ( @xmath641 ) ; ( c1 ) at ( @xmath642 ) ; ( c3 ) at ( @xmath643 ) ;    ( b1 ) to node[sloped , above ] @xmath644 ( c1 ) ; ( b1 ) to node[sloped , above ] @xmath645 ( c2 ) ; ( b1 ) to node[sloped , below ] @xmath621 ( c3 ) ;    ( c1 ) to node[sloped , above ] @xmath622 ( b2 ) ; ( c2 ) to node[sloped , above ] @xmath622 ( b2 ) ; ( c3 ) to node[sloped , below ] @xmath622 ( b2 ) ;    ( c1 ) to [ out=+105,in=+75,loop ] node[above ] ( r1 ) @xmath646 ( c1 ) ; ( c2 ) to [ out=+105,in=+75,loop ] node[above ] @xmath647 ( c2 ) ; ( c3 ) to [ out=+105,in=+75,loop ] node[above ] @xmath632 ( c3 ) ;    ( d2 ) at ( @xmath648 ) ; ( d1 ) at ( @xmath649 ) ; ( d3 ) at ( @xmath650 ) ;    ( b2 ) to node[sloped , above ] @xmath624 ( d1 ) ; ( b2 ) to node[sloped , above ] @xmath651 ( d2 ) ; ( b2 ) to node[sloped , below ] @xmath652 ( d3 ) ;    ( d1 ) to node[sloped , above ] @xmath622 ( b3 ) ; ( d2 ) to node[sloped , above ] @xmath622 ( b3 ) ; ( d3 ) to node[sloped , below ] @xmath622 ( b3 ) ;    ( d1 ) to [ out=+105,in=+75,loop ] node[above ] ( r1 ) @xmath633 ( d1 ) ; ( d2 ) to [ out=+105,in=+75,loop ] node[above ] @xmath653 ( d2 ) ; ( d3 ) to [ out=+105,in=+75,loop ] node[above ] @xmath654 ( d3 ) ;    ( f2 ) at ( @xmath655 ) ; ( f1 ) at ( @xmath656 ) ; ( f3 ) at ( @xmath657 ) ;    ( b4 ) to node[sloped , above ] @xmath658 ( f1 ) ; ( b4 ) to node[sloped , above ] @xmath620 ( f2 ) ; ( b4 ) to node[sloped , below ] @xmath651 ( f3 ) ;    ( f1 ) to node[sloped , above ] @xmath622 ( b5 ) ; ( f2 ) to node[sloped , above ] @xmath622 ( b5 ) ; ( f3 ) to node[sloped , below ] @xmath622 ( b5 ) ;    ( f1 ) to [ out=+105,in=+75,loop ] node[above ] ( r1 ) @xmath659 ( f1 ) ; ( f2 ) to [ out=+105,in=+75,loop ] node[above ] @xmath629 ( f2 ) ; ( f3 ) to [ out=+105,in=+75,loop ] node[above ] @xmath653 ( f3 ) ;    ( @xmath660 ) to node[below , sloped ] clause @xmath661 ( @xmath662 ) ;    ( @xmath663 ) to node[below , sloped ] clause @xmath664 ( @xmath665 ) ;    ( @xmath666 ) to node[below , sloped ] clause @xmath667 ( @xmath668 ) ;    by definition , @xmath606 verifies condition  .",
    "it remains to verify that condition   holds .",
    "[ lem : reduc - sat ] if there are words @xmath210 accepted by @xmath610 that encode the same assignment , then for all @xmath107 , they can be chosen such that @xmath307 .",
    "this is done by using the loops in @xmath610 to generate as many copies of the @xmath32-profilesin @xmath210 as needed in order to get words that are @xmath106-equivalent .",
    "we finish by proving that @xmath5is satisfiable if and only if @xmath194 are not -separable .",
    "assume first that @xmath55 and @xmath56 are not -separable .",
    "by fact  [ fct : assign ] , this means that there exist @xmath305 and @xmath669 sharing the same alphabet . by condition",
    ", @xmath231 encodes an assignment .",
    "therefore , @xmath232 ( which has the same alphabet ) encodes the same assignment which satisfies @xmath5by condition  .",
    "hence @xmath0 is satisfiable .",
    "conversely , assume that @xmath5is satisfiable . we prove that for all @xmath670 , @xmath671 are not @xmath108$]-separable . set @xmath670 and consider an assignment of truth values satisfying @xmath5 . by conditions   and",
    ", there must exist @xmath210 accepted by @xmath672 that both encode this assignment .",
    "it follows from lemma  [ lem : reduc - sat ] that @xmath210 can be chosen such that @xmath673 .",
    "therefore , @xmath194 are not @xmath108$]-separable , which terminates the proof .",
    "in order to prove decidability of -separability for regular languages , we needed three ingredients : parikh s theorem , decidability of presburger arithmetic and item   in theorem  [ thm : sepltt ] . since parikh s theorem holds not only for regular languages but also for context - free languages , we retain at least two of the ingredients in the context - free setting .",
    "in particular , we can reuse the argument of section  [ sec : ltt ] to prove that once the size @xmath32 of the infixes is fixed , separability by is decidable for context - free languages . for any fixed @xmath674 ,",
    "we write @xmath675 = \\bigcup_{d \\in { \\ensuremath{\\mathbb{n}}\\xspace } } { \\textup{ltt}\\xspace}[k , d]$ ] .",
    "[ thm : lttkdecidcf ] let @xmath194 be context - free languages and @xmath411 .",
    "it is decidable whether @xmath194 are @xmath675$]-separable .",
    "an interesting consequence of theorem  [ thm : lttkdecidcf ] is that @xmath676$]-separability of context - free languages is decidable .",
    "a language is @xmath676 $ ] if and only if it can be defined by a first - order logic formula that can only test equality between positions , but not ordering .",
    "this result is surprising since membership of a context - free language in this class is undecidable .",
    "we give a proof of this fact below , which is a simple adaptation of the proof of greibach s theorem ( which is in particular used to prove that regularity of a context - free language is  undecidable ) .",
    "[ thm : lttkdecidcf2 ] let @xmath3 be a context - free language .",
    "it is undecidable whether @xmath677 $ ] .",
    "we reduce universality of context - free languages to this membership problem .",
    "let @xmath3 be a context - free language over @xmath10 and let @xmath678 .",
    "let @xmath679 $ ] be some context - free language and set @xmath680 .",
    "clearly , a context - free grammar for @xmath55 can be computed from a context - free grammar for @xmath3 .",
    "we show that @xmath681 if and only if  @xmath682 $ ] .",
    "if @xmath681 , then @xmath683 $ ] .",
    "conversely , assume that @xmath682 $ ] , and suppose by contradiction that @xmath684 .",
    "pick @xmath36 such that @xmath685 . by definition ,",
    "one can verify that @xmath676 $ ] is closed under right residuals .",
    "therefore , @xmath687 $ ] which is a contradiction by definition of @xmath2 .",
    "these two results may seem contradictory .",
    "indeed in the setting of regular languages , membership can be reduced to separability ( a language belongs to a class if the class can separate it from its complement ) .",
    "however , context - free languages are not closed under complement , which makes the reduction false in this larger setting .",
    "an interesting question is whether decidability extends to full - and -separability of context - free languages .",
    "this would also be surprising since membership of a context - free language in or are undecidable problems .",
    "such a result would require to generalize our third ingredient , item   in theorem  [ thm : sepltt ] , to context - free languages .",
    "this means that we would need a method for computing a bound on the size of the infixes that a potential separator has to consider .",
    "it turns out that this is not possible .",
    "[ thm : lttkdecidcf3 ] let @xmath194 be context - free languages . it is undecidable whether @xmath194 are -separable",
    ". it is undecidable whether @xmath194 are -separable .",
    "it was already known  @xcite that separability by a regular language is undecidable for context - free languages .",
    "the proof of theorem  [ thm : lttkdecidcf3 ] is essentially the same since the reduction provided in  @xcite actually works for any class of regular separators that contains all languages of the form @xmath688 where @xmath689 are finite languages .",
    "since this is clearly the case for both and , theorem  [ thm : lttkdecidcf3 ] follows . for the sake of completeness",
    ", we provide a version of this proof tailored to and below .    the proof is done by reduction of the halting problem on turing machines to -separability and -separability .",
    "the reduction is the same for both and and is essentially a rewriting of a proof of  @xcite .",
    "consider a deterministic turing machine @xmath690 .",
    "we prove that it is possible to compute context - free languages @xmath194 from @xmath690 such that @xmath690 halts on the empty input if and only if @xmath194 are -separable , if and only if @xmath194 are -separable .",
    "let @xmath10 be the alphabet of @xmath690 , let @xmath62 be its set of states , and let @xmath691 where @xmath692 . as usual , we encode configurations of @xmath690 as words in @xmath693 : the word @xmath694 means that @xmath690 is in state @xmath162 , the tape holds @xmath695 , and the head currently scans the distinguished @xmath43 position . finally , if @xmath696 , we denote by @xmath697 the mirror image of @xmath13 .",
    "we can now define the context - free languages @xmath194 over @xmath521 .",
    "the language @xmath55 contains all words of the form : @xmath698 such that @xmath699 are encodings of configurations of @xmath690 , and for all @xmath700 , @xmath701 ( _ i.e. _ , @xmath702 is the configuration of @xmath690 reached after one computation step from configuration @xmath703 ) .",
    "similarly , @xmath56 contains all words of the form : @xmath704 such that @xmath699 are encodings of configurations of @xmath690 , @xmath705 is the initial configuration of @xmath690 starting with an empty input and for all @xmath706 , @xmath707 .",
    "it is classical that @xmath194 are indeed context - free and that grammars for @xmath194 can be computed from @xmath690 .",
    "we now make a simple observation about prefixes that are common to both languages .",
    "let @xmath708 be a sequence of configurations and let @xmath709 be the word @xmath710      w & = & c^{}_1\\#c_2^{r}\\#c^{}_3\\#c_4^r \\cdots      \\#c^{}_{2k-1}\\#c_{2k}^{r}\\#c^{}_{2k+1}\\ # & \\text{(if $ i=2k+1 $ ) . }",
    "\\end{array}\\ ] ] by definition of @xmath194 , we have the following fact :    [ fct : reduc ] if @xmath13 is both a prefix of some word in @xmath55 and some word in @xmath56 , then @xmath711 are the first @xmath240 configurations of the run of @xmath690 starting from the empty input . moreover ,",
    "if @xmath712 and @xmath713 is a prefix of a word in @xmath56 , then @xmath44 is configuration @xmath714 in the run .",
    "symmetrically , if @xmath715 and @xmath716 is a prefix of a word in @xmath55 , then @xmath44 is configuration @xmath714 in the run .",
    "it remains to prove that this is indeed a reduction , _",
    "i.e. _ , that @xmath690 halts on the empty input if and only if @xmath194 are -separable , if and only if @xmath194 are -separable .",
    "assume first that @xmath690 does not halt on empty input .",
    "this means that the run of @xmath690 is an infinite sequence of configurations @xmath717 . by definition of @xmath194 , for all @xmath411 : @xmath718    c^{}_1\\#c_2^{r}\\#c^{}_3\\#c_4^r \\cdots \\#c^{}_{2k-1}\\#c_{2k}^r \\ # \\gamma^{2k } & \\in l_2 . \\end{array}\\ ] ] it is then easy to deduce that @xmath194 can not be separated by a or language ( actually not even by a regular language ) .",
    "conversely , assume that @xmath690 halts on the empty input within @xmath199 steps , _",
    "i.e. _ , @xmath719 and @xmath720 is the halting configuration . before defining an separator",
    ", we observe that sufficiently long prefixes of sufficiently long words of @xmath194 are  distinct .",
    "[ lem : reduc ] let @xmath305 and @xmath306 of length greater than @xmath721 and let @xmath446 be the prefixes of length @xmath722 of @xmath210 , respectively",
    ". then @xmath723 .",
    "we proceed by contradiction .",
    "assume @xmath724 and let @xmath235 be the largest prefix of @xmath725 of the form @xmath726",
    "u=&c^{}_1 \\ # c_2^{r } \\ # c^{}_3 \\ # c_4^r \\cdots \\ # c_{i-1}^{r } \\ #      c_{i } \\#&\\text{depending on whether $ i$ is even or not . }",
    "\\end{array}\\ ] ] by definition @xmath727 , where @xmath508 can be of the form @xmath728 with @xmath729 or is the prefix of @xmath44 or @xmath730 for some configuration @xmath44 of @xmath690 .",
    "assume first that @xmath731 with @xmath732 .",
    "by fact  [ fct : reduc ] , @xmath708 are the first @xmath240 configurations of the run of @xmath690 starting from the empty input . since @xmath690 halts in @xmath199 steps , this means that @xmath733 and that each configuration @xmath734 is of length at most @xmath735 .",
    "it follows that @xmath235 is of length at most @xmath736 .",
    "therefore , @xmath725 is of length at most @xmath737 , in contradiction with the definition of @xmath446 .",
    "assume finally that @xmath508 is the prefix of @xmath44 or @xmath730 for some configuration @xmath44 of @xmath690 .",
    "by fact  [ fct : reduc ] , @xmath44 is so that @xmath738 are the first @xmath739 configurations of the run of @xmath690 starting from the empty input . since @xmath690 halts in @xmath199 steps",
    ", this means that @xmath740 and that each configuration is of length at most @xmath741 .",
    "it follows that @xmath725 is of length at most @xmath742 which is again a contradiction .",
    "let @xmath743 be the language of words of @xmath55 of length less than @xmath722 .",
    "similarly , let @xmath744 be the set of prefixes of length @xmath722 of words in @xmath55",
    ". finally , set @xmath745 . by definition , @xmath689",
    "are finite languages , hence @xmath3 is clearly ( and therefore ) .",
    "it remains to prove that @xmath3 is a separator .    by definition , we have @xmath746 .",
    "let us prove that @xmath747 .",
    "we proceed by contradiction : assume that there exists @xmath748 .",
    "if @xmath749 , then the contradiction is immediate because , by definition of @xmath55 , @xmath13 must be in of the form @xmath698 now , belonging to @xmath56 would require twice as many letters @xmath750 at the end of the word . on the other hand ,",
    "if @xmath751 , then , by definition of @xmath744 there exists some word of length @xmath722 that is both a prefix of a word in @xmath55 and a prefix of a word in @xmath56 .",
    "this contradicts lemma  [ lem : reduc ] .",
    "we deduce that @xmath194 are -separable , and therefore also -separable , which concludes the proof of theorem  [ thm : lttkdecidcf3 ] .",
    "we have shown separation theorems for both and . in both cases ,",
    "we provide a decision procedure to test separability , running in co - nexptime and 2-expspace respectively .",
    "another contribution is a description of possible separators , given by bounds defining them .",
    "several questions remain open in this line of research .",
    "a first one is to obtain tight complexity bounds for both classes . while we have co - nexptime and 2-expspace upper bounds for and respectively , we have only co - np lower bounds .",
    "the upper bounds rely on a reduction to the case @xmath412 , _",
    "i.e. _ , a translation to the special case when the size of infixes is fixed to @xmath204 .",
    "this translation is exponential wrt.the size of the input automata . improving the upper bounds",
    "would likely require improving this reduction .",
    "another question is to generalize our techniques to other settings , and to obtain transfer results .",
    "first , one can consider other fragments for separability .",
    "for instance , if separation is decidable for some fragment of first - order logic , is it still decidable when adding some predicate to the logic , such as the successor ? in the present paper , this is what we do for the specific case of , whose corresponding logic , @xmath7 , is obtained by adding the successor to first - order logic with only equality on positions and alphabetic predicates .",
    "another natural example is adding modulo predicates , which would allow to treat for instance , the generalization of in which infixes can now also be counted modulo constants .",
    "generalizing our results to more complex structures such as trees would also be interesting .",
    "however , in the setting of trees , while decidable characterizations are known for both and  @xcite , no delay theorem is known .",
    "this makes separation a challenging problem as our techniques rely on a generalization of this theorem .",
    "chen , a.  farzan , e.  m. clarke , y .- k .",
    "tsay , and b .- y .",
    "learning minimal separating dfa s for compositional verification . in _ tacas09 _ , volume 5505 of _ lect .",
    "notes comp .",
    "_ , pages 3145 .",
    "springer , 2009 .",
    "w.  czerwinski , w.  martens , and t.  masopust .",
    "efficient separability of regular languages by subsequences and suffixes . in _ proc . of icalp13",
    "_ , volume 7966 of _ lect .",
    "notes comp .",
    "_ , pages 150161 .",
    "springer , 2013 .",
    "s.  kim , r.  mcnaughton , and r.  mccloskey . a polynomial time algorithm for the local testability problem of deterministic finite automata . in _ algorithms and data structures _ , number 382 in lect .",
    "notes comp .",
    ", pages 420436 .",
    "springer , 1989 .",
    "t.  place , l.  van rooijen , and m.  zeitoun . separating regular languages by piecewise testable and unambiguous languages . in _ proc . of mfcs13",
    "_ , number 8087 in lect .",
    "notes comp .",
    ", pages 729740 .",
    "springer , 2013 ."
  ],
  "abstract_text": [
    "<S> a separator for two languages is a third language containing the first one and disjoint from the second one . </S>",
    "<S> we investigate the following decision problem : given two regular input languages , decide whether there exists a locally testable ( resp .  </S>",
    "<S> a locally threshold testable ) separator . in both cases , </S>",
    "<S> we design a decision procedure based on the occurrence of special patterns in automata accepting the input languages . </S>",
    "<S> we prove that the problem is computationally harder than deciding membership . </S>",
    "<S> the correctness proof of the algorithm yields a stronger result , namely a description of a possible separator . </S>",
    "<S> finally , we discuss the same problem for context - free input  languages . </S>"
  ]
}