{
  "article_text": [
    "we assume that we are given a set g consisting of @xmath0 points , along with their coordinates , in n - dimensional x - space .",
    "our task is to partition all the @xmath0 points by using planes such that no two points are left un - separated by some plane .",
    "our method is such that each point in g , is looked at mostly once and once only , then it is put in a another set s which consists of other points and planes , s will contain all the coordinate information of the points in it as well as the equations of the planes which are in it .",
    "we start with a set s which has a few number of points @xmath4 which were drawn from g , but positioned in s such that they have the same coordinates in s as they had in g , and also , s , has initially an adequate number of planes @xmath5 , so chosen that they separate all the points @xmath4 presently in s. after which points are chosen randomly from g ; a point thus chosen can be immediately put in s ( but at a position which has the same coordinate as the point had in g ) if it will be separated from all other points in s by the planes presently in s , if this is not so then the point will be put temporarily in a set t. points from g are thus picked and put in ( s or t ) , one by one , at some time it may be necessary to add a new plane such that , after the inclusion of this new plane ( making @xmath6 ) some @xmath1 points currently in t are separated from one another by one or other of the @xmath7 planes currently present , and thus can be transfered to s. all this is only possible because we have discovered a quick method which reveals whether a particular point p in s is separated from other points such as r in s or not .",
    "we are able to do this because we associate an orientation vector @xmath8 , with every point p in s , this orientation vector is a hamming vector of dimension @xmath9 the current number of planes in s. the orientation vector has the property that two points will not have a plane between them if and only if @xmath10 .",
    "that is @xmath11 automatically implies that p and r are separated by at least one of the @xmath9 planes in s. since orientation vectors are hamming vectors of dimension @xmath9 , the condition @xmath11 can be quickly verified , to ensure that points p and r are separable in s. the above process of including points , one by one , chosen randomly from g is done in such a way that all the points in s always remain separated from one another by the current number of planes @xmath9 , in s. this condition is ensured by following a procedure which we will now describe .",
    "however , as related earlier , we require the services of another set t , and we will use this set t to temporarily hold certain `` candidate '' points and line segments till the `` candidate '' points are qualified to be transfered to s. we now describe the procedure : let us say that s contains n points and q planes , because of the process followed so far all the points @xmath3 are separable by the @xmath9 planes in s. we now choose randomly a new point , say p , from set g , this point p is then considered as a candidate  for being the @xmath12 point for inclusion in s , however for p to be actually included in s we must calculate the orientation vector @xmath8 and ensure that @xmath13 points @xmath14 .",
    "since there are @xmath3 points such as r , the preceding conditions on @xmath8 involve @xmath3 hamming vector comparisions . if p satisfies all these conditions then this implies that p is separable from all points currently existing in s and can thus be safely be added to s so p is transferd to s and then @xmath15 and a new candidate point ",
    "point p is chosen from g.",
    "however if the test for @xmath8 fails this means there is some point @xmath16 s.t .",
    "@xmath17 , this indicates that p and a are not separated by @xmath9 and thus p can not be put in s. at this point we rename the point p as b for convenience and put b in t and we also store the `` pair '' ( a , b ) in t. we will treat ( a , b ) as a line segment connecting two points a and b where @xmath16 and @xmath18 , we then keep a counter which keeps a count of the number of pairs in t. after this we randomly choose another point p from g as the next possible `` candidate '' for s and repeat the procedure .",
    "it is important that at each stage of the algorithmic process , the orientation vector of points in s are calculated and stored in s along with the candidate points and their orientation vectors in another set t. the algorithm keeps adding points and calculating planes to be put in s step by step all the time ensuring that s contains only points that are separated from one another by the @xmath9 planes presently contained in s. each point when thus chosen either is separate from other points or if not , as we have seen matters are so arranged , that it is identified `` as a special point '' which is not yet separated , such points such as b , are placed in t along with its `` pair '' and with the segment ( a , b ) .",
    "matters can always be so arranged that each point in t has one and only one point in s which is its neighbor .",
    "( two points are neighbors if they are un - separated ) .",
    "it is obvious that a point such as b can not have two points say a and c as neighbors , with both a and c belonging to s , because this means @xmath19 and @xmath20 which implies @xmath21 which is impossible because a and c , if they both belong to s , can not have their orientation vectors equal to each other since s contains points which are separated from one another by @xmath9 planes .",
    "the collection proceeds ( at random ) as new points are added to s or t depending on whether the new point is either separate or labelled as `` special '' .",
    "as soon as n `` special '' points are collected in t , the process of collecting points is temporarily halted .",
    "now the set t is examined , since the counter has stopped at @xmath22 , there will be in t , precisely @xmath1 pairs of points @xmath23 and @xmath24 .",
    "+ _ we now have arrived at a very crucial stage in the algorithm _",
    ", till now we have been merely adding points , now it is time to add a new plane to s. we do so now , and we do it in such a manner that the new plane will pass through all the midpoints @xmath25 of all the @xmath1 segments @xmath26 that we have collected in t. if we do this , we would have in a single stroke , not only separated all the @xmath1 points @xmath27 from their respective pairs the @xmath28 , by this new plane , but also from one another .",
    "it can be easily proved that all the @xmath29 will be separated from one another if we do not permit two @xmath30 to be the neighbor of the same a. ( this situation is rare in large n dimension space but is discussed later and shown that it can be handled ) .",
    "note this requirement automatically means the two @xmath30 are separated because if @xmath31 is a neighbor of @xmath32 and if @xmath27 is not a neighbor of @xmath32 this means @xmath33 and @xmath34 implying @xmath35 .",
    "thus if we do not permit two @xmath30 to be neighbors of the same @xmath36 , then after the @xmath7 plane bisects all the @xmath1 segments then we can include the @xmath7 plane in s , thus enabling all the @xmath1 points @xmath37 to be included in s too .",
    "the separation of @xmath1 line segments by a single extra plane , can be done only because we are in n - dimension space .",
    "the calculation of the coefficients of this @xmath38 plane can be done by ( say ) gaussian elimination and involves @xmath39 multiplications .",
    "then the new plane with its coefficients are added to s. all the @xmath1 recently separated points @xmath27 are added to s so @xmath40 after this all the @xmath30 are removed from t along with the pairs ( because they are all separate - a reconfirmation is done ) . and importantly , after adding this @xmath7 new plane to s the orientation vectors of all points in s have to be modified wrt this new plane all the orientation vectors are now of dimension @xmath7",
    "-it only means adding a bit to each vector .",
    "+ this noniterative algorithm is possible because we use the concept of an orientation vector [ 3 ] which is a hamming vector and has the following properties : ( i ) every point is associated with its own orientation vector , ( ii ) the orientation vector for a point p in s keeps track of how p is positioned with respect to all the planes in s and ( iii ) the orientation vector is unique for each point in s and ( iv ) the orientation vectors of two points say p and q are unequal if and only if they are separated by at least one plane in s ; equality implies that p and q are not separated .",
    "the method is a kind of pigeon hole principle , except that each point is a pigeon and the pigeon holes ( region between half spaces ) are added in installments ( much more than one at a time ) only when they are needed , to accommodate new pigeons . at each stage of the algorithm",
    "there is only one pigeon in its hole , and as the algorithm proceeds the size of some pigeon holes may reduce as they are partitioned , and many pigeon holes are created and new pigeons are added to occupy some of the empty holes and at the end of the algorithm all the pigeons are accommodated .",
    "we give the necessary definitions and briefly prove the fundamental algorithm by which planes which separate a given set of points could be found .",
    "our task is to determine the equations of the planes that can separate the points in such a way that every point is separated from another by at least one plane .",
    "assumption : it is assumed that we have specified a ( defined ) normal direction , a point which lies on the positive side of the normal is said to lie on the positive side of the plane , on the other hand if the point lies on the other side it is said to lie on the negative side.this direction is easily found if the equation of the plane is known for example if @xmath41    is the equation to some @xmath1- dimensional plane then a point p whose coordinates are @xmath42 will be said to be on the positive side if @xmath43 and in the negative side if    @xmath44    each component of the orientation vector of a point p in x space , is on the positive side or negative side of each plane.(the`orientation vector ' , is defined in the next section , below . )      * orientation vector * : suppose we have a point p in n - dimension space * ( also called x - space ) * and suppose we are given 3-planes .",
    "we define a orientation vector as a hamming vector whose components precisely specify on which side the point p lies with respect to the 3 planes .",
    "example : if the point p lies on the positive side of plane 1 , negative side of plane 2 and positive side of plane 3 , then we define the orientation vector associated with p as @xmath8 and define @xmath45 . similarly a point q which lies on the negative side of plane 1 , negative side of plane 2 and positive side of plane 3 will have an orientation vector @xmath46 .",
    "points , whose orientation vector differ from another by at least one component can be said to be separated by at least one plane .",
    "* q space or hamming space : * we will also call the space spanned by the orientation vector as hamming space or q space .",
    "since each point p in x - space has an orientation ( hamming ) vector associated with it , we can imagine that all the points in x space are mapped to a point in hamming space .",
    "of course this mapping is many to one , but the fact to notice is the following : let p be some point in x - space , then all points , r , in x space which are not separated from p by planes will all have the same orientation vector as p ie .",
    "@xmath10 and we describe this by saying : `` points p and r belong to the same ` quadrant ' '' this statement is certainly true for the `` images '' of p and r in q - space , but we will loosely use this terminology for the points in x - space and say p and r are in the same `` quadrant '' , what we really mean is that p and r are points in x - space and that they are not separated by planes ; sometimes we will use the term * neighbors * and say p and r are neighbors .",
    "the point to remember is that p and r will be neighbors if and only if @xmath10 . therefore if one wishes to find out if two points a and b are separated in x - space which contains planes , all one needs to do is to compare their orientation vectors : @xmath47 with @xmath48 .    * a saturated plane : * we consider a plane in @xmath1 dimension space to be `` saturated '' if it has already been constrained to pass through @xmath1 points and hence can not be adjusted to pass through a new point , the coefficients of such a plane are completely determinable .",
    "a plane in 3 dimension gets saturated if it is made to pass through three points .",
    "we will suppose we are given all the data containing @xmath0 points , and that all all their coordinates in @xmath1 dimension space are known to us .",
    "our task is then to find the planes numbering @xmath49 , that can separate all these points from one another and also to find all the coefficients of the equations which define each one of these planes .      *",
    "input to the algorithm * we are given a set g containing a total of @xmath0 points in @xmath1 dimensional space .",
    "that is we know the coordinates of all these points .",
    "these points may also belong to different classes , so they may be given a label or ` color ' .",
    "however , since we are isolating all points from one another regardless of their class , the labels do not matter here , but will be useful in certain applications .",
    "* without , too much of a loss of generality we will assume that the coordinates of all the n points in g are rational numbers , i.e they are either integers or fractions .",
    "* we will see that this assumptions makes the coefficients of all the @xmath9 planes that separate the @xmath3 in g , also rational numbers .    * output items of the algorithm : * the equations of the planes which divide each point in such a way that every point is separated from another . and an integer @xmath50 which is equal to the total number of planes required .",
    "the equations of the @xmath51 plane will be of the form : @xmath52 where all the @xmath53 are coefficients of the plane all these coefficients are determined by the algorithm and @xmath54 is a known number nearly equal to unity .    * storage requirements for running the algorithm : * a set set s which will contain a list of @xmath3 points and @xmath9 planes .",
    "s will contain the orientation vectors of all the points in s and the identification numbers ( labels ) for the planes , along with the coefficients which define each plane .",
    "s contains an array v for storing orientation vectors ; and ` counter ' : an integer number .    in all stages of the algorithm s",
    ", will contain only those points , ( n in number ) which are completely separated from one another by the q planes contained in s. this condition of separability of the n points in s is never violated even though n and and q change as the algorithm progresses . when the algorithm ends s will contain the necessary output .",
    "another set t which contains points and their orientation vectors and an array m : `` list of midpoints '' which are the coordinates of the mid points of certain line segments . at each stage of the algorithm this set t , will contain pairs of points one not in s and the other in s. we are sure that each such point has only one such neighbor ( in s ) , because the points in s are always separate from one another and hence two points in the same quadrant can not both belong to s. each such point stored in t will also store the coordinate of the point which is the midpoint of the line joining it to its neighbor and the line segment with its neighbor .",
    "the points in t are the candidates waiting to be put in s but they first have to be separated from all the points in s. we shall see that as soon as t has a collection of n pairs of such points , then a new plane is drawn which separates all these points so that they become eligible to be incorporated in s. ( later on , we will permit a given point in s to have two or even three neighbors in t , these too will be candidates to be put in s , but for a first reading of this algorithm , it is simpler to assume that a point in s can have at most one neighbor in t. )    we also need another set d , this is the ` dust - bin ' set , it removes all ` accumulation ' points when detected from set g , ( as explained later this is done so that the algorithm does not go into an infinite loop ; which may happen if g contains a sequence of points converging to an ` accumulation ' point or ` limit ' point - we assume that such points do not exist in g ) .",
    "step 1 : initially collect a small number of initial points numbering @xmath55 and choose a set of @xmath56 planes that separate each one of these @xmath55 points and put these planes in s. the coefficients defining the equations of these @xmath56 planes should be determined ( or randomly chosen but ensuring that they separate the @xmath55 ) , call @xmath4 and @xmath5 . store",
    "all orientation vectors of points in s in array v. in addition we need a set t which will contain points which can not become immediate members of s but are prospective members and will become members of s eventually . set",
    "t will contain points which are neighbours of a point which already is a member of s. to make things simple we will assume that at the start , all the @xmath56 planes are saturated .",
    "( we do not want to adjust any of these planes ) and @xmath55 s.t . @xmath57 and @xmath58",
    ". put counter = 0 .",
    "step 2 : if no more points in g go to step 7 , else : randomly choose a new point from g , which could be a candidate point to be put in s , from the remaining points not in s , go to step 3 .",
    "step 3 : check if this new point is in a new ` quadrant ' , this involves finding its orientation vector and comparing with those in s. if the point is in a new quadrant , put this point in s and store its orientation vector in v , put @xmath59 go to step 2 , if not , it means it has a neighbor in its quadrant .",
    "go to step 4 .",
    "step 4 : ( you will come here only if the current point has a neighbor in s. notation and procedure for this step : we keep count of the number of members of s which have first neighbors .",
    "such points are called @xmath60 , its first neighbor will be called @xmath61 , if @xmath60 has a second neighbour this will be called @xmath62 and the third will be called @xmath63 . ) first : find the ` distance ' of this new point from its neighbor , call this@xmath64 * if * @xmath65 then remove the new point from g itself and put it in set d , and go to step 2 ; * else * put this new point in set t. check if this new point is in a quadrant which has already a pair in t , if not , put @xmath66 define @xmath67 , call the point with which this new point is a neighbor as @xmath60 .",
    "however , if this new point already is a neighbor of some point @xmath68 already in s and if @xmath69 exist call this new point @xmath70 , if only @xmath71 exists call the new point @xmath72 go to step 2 . however , if @xmath73 , @xmath74 as well as @xmath75 exists this means the new point will become a 4th neighbor of @xmath68 , a situation which we do not permit , so put back the new point in g and go to step 2 . if @xmath62 and if @xmath63 do not exist , it means this point @xmath60 has only the present point as neighbor .",
    "calculate the mid point of the segment@xmath76 , if not already calculated , and call it @xmath77 , add the coordinates @xmath77 , in a `` list of midpoints '' .",
    "( note @xmath78 only keeps track of the first neighbors of the the @xmath79 . )    if @xmath22 go to step 5 , if less than n , go to step 2 .",
    "step 5 : since @xmath22 , this means you have collected n points in t , each of which have to be separated from their neighbors .",
    "however we , first re - check if all the @xmath1 points collected in t are in different quadrants ( this step is only cautionary , and not necessary if step 4 has been done properly),if say @xmath61 and @xmath80 in t are in the same quadrant , then mark one of them say @xmath80 as @xmath62 , if the latter does nt exist , else as @xmath63 ( if both @xmath62and @xmath63both exist there is no place for @xmath80 put it back in g , restore the count of points in g as well as restore in either case@xmath81 , check similarly for other @xmath82 and then go to step 2 . ) , if there are @xmath9 planes there are @xmath83 quadrants , hence the chances of two points randomly chosen to be in the same quadrant is @xmath84 .",
    "we permit max .",
    "no of neighbors,3 , just to ensure that even in the freakiest conditions the algorithm comes to a halt successfully .",
    "of course the the other possibility is the presence of points of ` accumulation ' , however this does not happen when points represent integers . ]    now in this step we will separate the n pairs collected in t by introducing a new plane which passes through all the @xmath1 mid points , whose coordinates are available in `` list of midpoints '' in the array m : `` list of midpoints '' and determine the coefficients of the new plane , by solving the@xmath1 constraint eqs . to pass it through the @xmath1 midpoints ; call this plane as plane number @xmath7 and put @xmath6 , and include this new plane in s along with all the @xmath1 points labeled @xmath85 and their coordinates , put @xmath86 ,    step 6 : now check the neighbors of all the @xmath60 , @xmath87 , in t , if only @xmath62 exists then it gets promoted to first neighbour .",
    "but there is a slight complication after @xmath60 and @xmath88 separated @xmath62 can be a neighbor either of @xmath60 or @xmath61 so if it is the former call @xmath89 as @xmath90 else call @xmath90 as @xmath91 and @xmath92 as @xmath90 the same kind of investigation needs to be done for @xmath93 because it can now belong to the old @xmath94 quadrant or belong to the new @xmath95 quadrant , in either case the @xmath96 gets promoted as second neighbour and it will be called @xmath62",
    ". calculate the new mid point @xmath77 for the just created segment @xmath76 and store .    after finishing this task , the number , @xmath97 of second neighbours that were promoted as first neighbours will be known , after drawing the plane @xmath7 , then call @xmath98 .",
    "update v , the orientation vectors of points now stored in s wrt to this new plane ( their dimensions become @xmath7 ) ; clear the data in m : `` list of midpoints '' of all points t you have transfered to s and remove data , of these @xmath99 points that have been transfered to s , from set t ( most of the time @xmath100 ) and go to step 2 .",
    "step 7 : ( you will come here only if no more points are left in g @xmath101 and counter is not yet @xmath102 ) if counter = 0 , stop else introduce a new plane passing through the midpoints of segments collected so far , ( t will contain as many points as the value of counter ) , since counter @xmath103 , some of the coefficients of this plane can be randomly chosen ; ( take action like step 6 to check all these new points are in their own quadrants ) , update v , the orientation vectors of points now stored in s wrt to this new plane ( their dimensions become @xmath7 ) ; call this plane @xmath6 , counter = 0 , clear the data in m : `` list of midpoints '' then if now @xmath101 i.e. g is empty , stop ; else go back to step 2 .",
    "* at the end of section 6.2 , we mention that the case when @xmath104 and g is empty which is one of the possibilities in step 7 ; the situation can be dealt with in an easier manner . *",
    "end of algorithm    the algorithm works swiftly most of the time , since in our case all the point are discrete and there are no limit points or ther is no `` accumulation points '' in g the algorithm will always come to a halt successfully .",
    "the general case when the input data is say prepared by another program , then certain conditions need to be met to ensure the correct halting of the algorithm .",
    "these are idscussed in the cted reference .",
    "the following crucial concepts will immediately clarify the steps of the whole algorithm : : in n dimension space , if we are given n line segements ;    @xmath105 ,    then a single plane passing through the mid points of each segment will separate the n points @xmath106 from the n points @xmath107 that is the @xmath79 and the @xmath82 will lie on opposite sides of the plane . * but this does not ensure that the @xmath79 are separate from each other and the @xmath82 are separate from each other . * in order to ensure this we have imposed the condition that each of the @xmath79 belong to set s and are * already separate from each other * and have all have different orientation vectors ( in the space of q planes which are in s ) , * similarly by imposing the condition that each @xmath108 , ( each of which belong to t ) , has only one neighbor in s * , ( for the moment ignore the second and third neighbours@xmath109 and @xmath110 ) we are making sure that each @xmath73 is separate from other @xmath82 though , each @xmath73 is not separate from its neighbor in s namely @xmath111 .",
    "thus each pair of points @xmath112 have the same orientation vector . now",
    "if the @xmath113)st plane is drawn then it will ensure that all the @xmath114 points i.e. the set of all the @xmath79 and the set of all the @xmath82 are not only separate but are separated from each other .",
    "we can then include plane @xmath7 and the @xmath1 points viz .",
    "the @xmath82 in s. this intuitive result is mathematically easily demonstrable : * *    * proof : * since we have included the @xmath113)st plane , all the orientation vectors have gained one more dimension and have @xmath7 dimensions , the last , @xmath113)st component of the orientation vector of point @xmath111 will differ from the last component of the orientation vector of its ex - neighbor @xmath115 because they are now on either sides of plane @xmath113 ) . thus proving that all the @xmath114 points are now separate**. qed * *    the rare cases of three points belonging to the same quadrant ( viz @xmath116 ) is permitted but not four , we do this only to avoid unecessary return of points to g , once randomly chosen from g. however , one can simplify the algorithm if one just returns the second point to g and then choose a new point at random .      at the start",
    "s only contains points which are separable from each other , because that is the way they have been selected . since @xmath5",
    "have been selected initially each of the orientation vectors of the points in s , are @xmath9 dimension vectors .",
    "they are all different .",
    "now till the time we come to step 5 we are just collecting points which are separable and putting them s or in case thay have a neighbor in s then we are putting the points in t. this can go on till there are n points in t and we arrive at step 5 .",
    "at this point there are n points in t and n points in s. firstly , there can never be two points in s which are neighbors to a single point in t. this is because every point in s has a different orientation ( hamming ) vectors so they belong to different quadrants in hamming space and one point in t can not belong to two quadrants .",
    "there are now only two possibilities ( i ) each point in t has one distinct neighbor in s or ( ii ) there are two or three points in t which have the _ same _ neighbor in s. we will consider the first possibility ( i ) : since by choice , every point in t must have one neighbor in s , they all belong to different quadrants , since there are n points which can be separated by the @xmath7 st plane after implementing step 5",
    ". then in the new @xmath7 space all the points ( the old points in s and the n new points in t ) are all separable form one another and hence all the n points in t which awere first neighbours the @xmath61 s can now be included in s , we must add the @xmath7 st component to each orientation vector in s to make them into orientation vector wrt to the @xmath7 st plane .    now coming to the second possibility ,",
    "if there are two or three points in t which have the same neighbor in s then after introducing the new @xmath117 plane only one of the points in t namely the one which is the first neighbor of @xmath60 say @xmath61can be transfered to s and the other points @xmath118 @xmath63 need to be kept in t with one of the points @xmath60 or @xmath61 as its neighbor and the newly calculated midpoint.(because the @xmath7 plane has separated the @xmath60and @xmath61 they are on opposite sides of plane @xmath7 , so we have to now determine on which sides @xmath118 @xmath63 are ; the seemingly complicated arguments are only to ensure that we make the right decision about @xmath118 @xmath63 ) .",
    "however , the situation ( ii ) is rare in high dimension n space , since we are choosing points in random , and can best be avoided by not choosing two points in t which are neighbors to the same point in s ( this means ejecting the second point from t and putting it back among @xmath0 in g , or by keeping it in t and use it , later , only after you have introduced a new plane or even after a few new planes . ) in brief , the situation ( ii ) can be avoided though it just causes difficulties in programming .",
    "so we see after step 5 and step 6 we will have an enhanced set s with more points and one more plane and all of which are separated by these @xmath7 planes .",
    "so we can call @xmath117 as @xmath9 and then re - do steps 2 to 6 till all points @xmath0 in g are exhausted .",
    "then s will contain all the points and all the planes which separate them .",
    "step 7 will happen in the end when all the points are exhausted but there are less than _ n _ points in t and these must be separated .",
    "* * the logic of step 7 is similar to step 6**. * *    * it may be mentioned here that step 7 can be completely avoided . *",
    "if we find that there are say less than n points in t. let us say r is a number such @xmath119 .",
    "all we have to do is choose r random points ( these should not have been in g ) each of which has as a neighbor in its quadrant , one of the points which was drawn from g but now in s. then put each of these r points along with its neighbor as a pair in t. since you have already @xmath78 number of pairs in t , with the addition of these r pairs , we have @xmath1 pairs . now since @xmath22 , we can choose the last plane separating all the @xmath1 pairs .",
    "so we see at the end of the algorithm s will contain all the points along with the equations of the @xmath9 planes that separate them , * * which are the needed outputs . * * qed * *    in the above algorithm it is assumed that every new plane does not ` split ' some other point ( pass through ) . however if this happens ( it is a very rare event ) , to some point , we will have to shift the ` mid points ' of the segments slightly to one side ( because to cut a segment into two parts it is not necessary that the plane passes exactly though its mid point ) so that the plane passes to one side of the offending point,[multiblock footnote omitted ] and then proceed with the algorithm .      before completing the proof of the algorithm , it better to briefly discuss the conditions when the algorithm will stop and when it will not and to make sure that it will always stop .    in order to better understand what is happening :",
    "we will pretend that the first part of the * if ... then * statement in step 4 is removed .",
    "ie the ` distance ' is not calculated and all new points which arrive at this step are never removed and put in d even if it is close to its neighbor .",
    "( this analysis will then reveal the need of set d ) .",
    "it is then clear from the algorithm that as we randomly pick points from g each point picked finds a new quadrant or finds itself in t. if it finds itself in a new quadrant there is no problem : it is put in s and the algorithm goes to step 2 , and a new point is picked from g. but if it lands itself in t , then it is paired with another point which is already in s. let us say that such a point is q and it has been paired with p which is in s and we pair(p , q ) . now the algorithm will not attempt to transfer q to s from t until it has collected @xmath1 such pairs",
    ". then the algorithm draws a plane through the mid points of @xmath1 pairs .",
    "every thing is fine if all the pairs are in different quadrants the new plane separates all the @xmath114 points and the @xmath1 points which were collected in t ( and now separated)are transfered to s. the algorithm ensures that in the set of @xmath1 pairs if there are at most 3 ( @xmath120 ) points which are neighbors of a point in s ( in the same quadrant ) , for example @xmath121 can be neighbor of @xmath122 which is in s , then things would be fine .",
    "things will not be fine if every new point that is subsequently picked will all belong to the same quadrant as q !",
    "this strange phenomena will happen when :    1 .",
    "all the q s which are chosen all belong to a sequence which has an `` accumulation '' point .",
    "that is the remaining points in g which are left after all the others are separated are only those points which tend to be close to some unknown accumulation point ( or limit point ) close to p. this will happen since we are treating x - space as real space and all the coordinates @xmath123 are either rational numbers ( or even real numbers which are uncountable as opposed to integers which are countable ) .",
    "and then we are trying to separate an infinity of points or uncountable points in a sequence by a countable ( or finite ) set of planes an impossibility !",
    "2 .   when all the points in g are not distinct and there are repetitions in data .",
    "they way to get rid of both the situations is to take a bit of care in preparing the input data . in real life situations the input set g may be points generated by another computer program .",
    "the following are obvious suggestions :    1 .",
    "we have characterized all the components of the @xmath1 space as real numbers , that is all the @xmath124 in the coordinate array of point p : @xmath123 , are considered real . it is better that one of the components is an unique integer number .",
    "for example , in the case of the medical data which we describe in section 3.2 ( below ) it is better to label each point with an unique integer number ie every patient p is given a unique integer label @xmath125 , and we put this value as ( say ) the @xmath126 component of the coordinate of p. that is we put @xmath127 .",
    "if this happens no two points will ever have the same coordinate , ( because they differ in their @xmath126 component ) and the number of points will always be an integer number , and be kept finite hence countable .",
    "they will always be separable because the minimum euclidean ( or manhattan)distance would be 1 .",
    "2 .   for every prospective candidate for t",
    ", we check its ` distance ' @xmath64 from it neighbor and if @xmath128 , we remove the point from g and put it into the ` dust - bin ' set d. we use a small threshold value for @xmath129 , we need only calculate the ` manhattan distance ' for @xmath64 .",
    "this process removes all ` accumulation ' points from the data and thus explains the need of the first part of * if ... then * statement in step 4 .",
    "ensure that there are no repetitions in input data i.e. the points in g are all distinct .",
    "once it is ensured that the input data , set g , is prepared as above , the algorithm will run smoothly .",
    "as we have seen , as the algorithm progresses and points are being transferred from g to s and new pairs are being created , one will have to draw a new plane as soon as @xmath1 pairs are collected .",
    "let these @xmath1 segments be called :    @xmath130 ,    and let the mid points of each segment such as @xmath131 be denoted as @xmath132 thus we have the list of midpoints for all the @xmath1 segments :    @xmath133 , where the coordinate of the @xmath134 mid point is denoted as @xmath135    now we require that the @xmath136 plane :    @xmath137    should pass through all the above @xmath1 mid points , we thus have the @xmath1 constraint equations , from @xmath138 : @xmath139    the above eqs.(4)represent @xmath1 linear equations which can be solved by suitable numerical techniques , eg .",
    "gaussian elimination , to obtain the @xmath1 unknown coefficients @xmath140 , for @xmath141 .",
    "it may be noted that since all the @xmath132 are midpoints of the segments @xmath131 and the coordinates of @xmath142 and @xmath143 are rational numbers the coordinates of @xmath132 are also rational numbers , this makes all the coefficients @xmath140 rational numbers .",
    "this observation has profound implications as we have described in the footnote 9 at end of page 12 .    * in appendix a we have worked out a simple example on the working of the algorithm in great detail .",
    "it may be consulted by anyone who needs to quickly get an hands on experience of the algorithm and program it . *      the computational complexity of the algorithm is easily determined .    *",
    "given : * @xmath0 : total number of points ; @xmath50 : total number of planes used ; @xmath1 ; dimension of x - space .",
    "\\1 . to determine the coefficients of each plane by gaussian elimination we require @xmath144 multiplications , and @xmath144 additions therefore for @xmath50 planes we have @xmath145 multiplications and @xmath145 additions . 2 .",
    "to compute the orientation vector of each point with respect to @xmath50 planes require per point per plane : @xmath1 linear evaluations , each consisting of @xmath1 multiplications and @xmath1 additions .",
    "therefore total : @xmath146 multiplications and @xmath146 additions .",
    "when every time a new point is put into s , it s orientation vector is compared with the orientation vector of the points in s. therefore there are @xmath147 hamming vector comparisons .",
    "but just to see if two hamming vectors of dimension @xmath50 are not equal it does not require us to check all the @xmath50 components , the moment the rth component differs the hamming vectors are declared unequal .",
    "so we may assume that 99 percent of the time only about 8 components are checked on the average .",
    "so the number of bit comparisons made are : @xmath148 bit comparisons .",
    "we must calculate the manhattan distance of every candidate member which arrives at t from its neighbor ( step 4 ) .",
    "for every plane there will be @xmath1 such points arriving at t. each manhattan distance calculation requires @xmath1 subtractions and @xmath1 additions , therefore for @xmath9 planes we have @xmath149 additions .",
    "we ignore the additions required to detect accumulation points which we had put in the dust - bin set d , assuming they are small in number .",
    "now we need to guess as to how many planes are require to separate @xmath0 points , we use the estimate of boland and urrutia ( 1995 ) , ref [ 2 ] , also see [ 1],and assume that @xmath150 , hence we come to the conclusion that the order of computations involved by the algorithm are :    @xmath151 multiplications ;    @xmath152 additions and    @xmath153 bit comparisons .",
    "we will now briefly describe how this algorithm can be applied to data retrieval .",
    "suppose one has @xmath3 points in a @xmath1 dimension x - space and the algorithm was used to separate all n points and it was found after running the algorithm that @xmath9 planes were finally necessary .",
    "we will now show that this information can be used as a data retrieval device .",
    "that is all the data can now be stored in such a manner that retrieval can be done with great efficiency .",
    "now for purposes of this illustration we will assume that each point n represents @xmath1 dimension image ( say we had used a passport size photograph which represents a face using precisely @xmath1 pixels ) now we wish to store these images in such a manner that retrieval becomes easy .",
    "the idea is simple : after we have solved the problem , we will have the exact information of how each of the data points @xmath3 reside in x - space with respect to each other and the separation planes , because we have the orientation vector for each point stored in s. we can use this information to ( i ) store the images in such a manner that ( ii ) it is possible to retrieve it easily .",
    "what we mean is that after the storage is done and if we are given a fresh ( approximate ) image of a person whose face is stored in the storage receptacle in the repository , it possible to use this new ( approximate ) image to retrieve the stored image .    we show that if the new photo which is a point p in x - space , is close to the original photo , say a point l stored in the receptacle then all we need to do is calculate @xmath8 and compare with @xmath154",
    ", we will show presently by using the neural engine in the picture below the task requires only @xmath155 multiplication @xmath155 additions to retrieve l. fig ref : fig - fig - a        in the figure @xmath156 represent the equation to the first plane stored in s ; we assume that the equation to this plane is gven by @xmath41 we then define @xmath157 if we use the unit step function defined as : @xmath158 defined s.t .",
    "@xmath159 , if @xmath160 and @xmath161 if @xmath162 and define @xmath163 , then @xmath164 is 1 if the point p is on the + ve side of plane 1 and is zero if it is on the -ve side of plane 1 .",
    "the same goes for the other planes @xmath165 .",
    "so the output array @xmath166 is a binarized version of the orientation vector @xmath8 .",
    "therefore our `` storage plan '' for each point l in is to use a binary representation of the orientation vector @xmath154 of a point @xmath167 as its label as shown in the receptacle in the figure and then store information about l in the space next to this code .",
    "`` retrieval plan '' : present an approximate image of l say p to the network .",
    "it is then possible to immediately retieve the information about l when a nearby point p has the same ov as l ie it is in the same quadrant as l in x - space .",
    "thus the coordinates @xmath168 of p when presented to the neural engine retrieves l. the retrieval just takes @xmath155 multiplication @xmath155 additions .",
    "a similar application can be thought of in medicine . in this case",
    "a person p may be represented as a point in n - dimensional feature space and the @xmath1 numbers in the array @xmath168 may represent , values of platelet count , wbc count , rbc count , mcv , mch , etc .",
    "a total of @xmath1 variables .",
    "so a doctor may be looking at patient p , and wondering if there is any other person in the data base whose medical condition is similar to that of the present patient p. all the doctor has to do is to input @xmath168 to the retrieval system shown in fig 1 , and a l will be extracted s.t @xmath169 , hence it is very likely that p and l share similar ailments since they share the same quadrant .",
    "the doctor can then examine the entire case sheet of person l which is retrieved by the the repository shown to the extreme right .",
    "thanks to the advancement of computer technology , algorithms such as this one could be very attractive . in order to be aware that such possibilities could soon become realities ,",
    "let us obtain an approximate estimate of the numbers involved : taking the case of medical records ; assuming @xmath170 for such a problem since @xmath1 is large it is reasonable to expect that approx .",
    "@xmath171 , we see that the number of calculations for finding these planes and separating all the n points is approx @xmath172 multiplications , since computers have achieved around 1 tflops this translates to around 20 seconds . to retrieve the data :",
    "for example the history of patient l , which is similar to patient p , from a data base of 10 billion , would take @xmath155 multiplications i.e. 2000 multiplications , which is practically instantaneous .",
    "in these two subsections we speak about one of the properties that the algorithm has and some interesting aspects of the algorithm .",
    "claude shannon , held the view that a bit is an information and one must use just the right amount of bits necessary to solve a problem .",
    "( a mathematical theory of communication bell sys . tech .",
    "379 - 423 , and 623 - 656 , 1948 ) .",
    "we show below that the algorithm gathers and uses the information optimally : we will define a completed ` stage ' of the algorithmic process as that state when a new plane say the @xmath51 has been inducted into s along with the other points which it has just separated and which are now in s along with all the orientation vectors of the points now in s. to get to the next ` stage ' the algorithm transfers enough number of points and garners just sufficient information for it to draw the @xmath38 plane",
    ". we will now prove that the new information collected in bits is exactly equal to that which will be stored after the next stage is completed that is after the @xmath38 plane is drawn .",
    "no extra bits are collected , so the algorithm always makes optimum use of information it collects ` stage ' by ` stage ' right up to the end when the problem is completely solved .",
    "let us imagine : we are at a ` stage ' when we had just added the @xmath51 plane which then separated all @xmath3 points in s , since we have calculated all the @xmath3 , orientation vectors w.rt .",
    "each of the planes we have used @xmath173 bits of information to arrive at this ` stage ' .",
    "now let us say as we proceed with the algorithmic process : we added @xmath99 new points which happened to fall in empty quadrants and @xmath1 new points which are paired with the old .",
    "when the @xmath38 plane is drawn all these @xmath174 new points are added to @xmath3 , to make the number of points in s equal to @xmath175 .",
    "but since we need to determine the orientation vectors of these new points wrt the @xmath117 planes now in s , we would be acquiring @xmath176 bits of information , in addition , since we have to update the orientation vectors of the old @xmath3 points wrt this new @xmath117plane , we have to add one bit for each such old vector ( because the old orientation vectors were of dimension @xmath9 and now it has to be increased by one to accommodate the new plane ) so we have acquired @xmath3 bits .",
    "so the new bits of information acquired is : @xmath177 .",
    "so if we add this to the old @xmath173 bits already acquired we have a total of @xmath178 bits which is exactly equal to @xmath179 bits now stored as orientation vectors by the @xmath180 points now in s. so we see , that in the process of acquisition and usage and then storage of bits of information there has been no loss nor any redundancy . and even though the points in g are picked at random , shanon s principle has been followed , strictly , in an optimal manner in going from @xmath9 planes to @xmath7 planes and then onwards till the final @xmath50 plane is determined and drawn .",
    "the algorithm uses the geometrical properties of @xmath181dimension space , to judiciously choose a plane passing through @xmath1 mid - points simultaneously , at an appropriate time , to make all this possible",
    ".      we will now speak about a few interesting aspects of the algorithm :    \\1 . once you have solved the problem ,",
    "there is no need to start from the very beginning , if at some later date you need to separate a new set of @xmath182 points .",
    "all you have to do is include this new set into set g ( which is presently empty ) and start running the algorithm from step 2",
    ". then these new points will be inducted into s one by one and new planes added when ever necessary , till all the points are separated and g is once again empty.also since for large dimension @xmath1 we have the relationship @xmath183 , when you have solved the problem of @xmath3 points with @xmath9 planes then if at some later date the number of points become @xmath184 then @xmath185 only and when @xmath186 then @xmath187 .",
    "this is a huge advantage .",
    "suppose at some future time you need to increase the dimension of data say from @xmath1 to @xmath188 ?",
    "once again there is no need to worry , assume that all the existing points have the same coordinates for the first @xmath1 components but for the @xmath189 st coordinate we define its value as zero .",
    "do the same thing for the planes , the @xmath189 coefficient of each plane is defined to be zero .",
    "that is for any existing planes we just define the coefficient @xmath190 eg .",
    "see eq(1 ) .",
    "now all the data has become @xmath189 dimensional and there is no need to change anything else and as and when new data points which are now dimension @xmath188 comes in , we put them into g and the algorithm can proceed from step 2 , just as before .",
    "both the points 1 .",
    "and 2 , above raises interesting possibilities .",
    "suppose each data point of @xmath1 dimension , represented an image of dimension @xmath1 , you can incorporate new images at any point of time .",
    "in fact you can incorporate images of larger size .",
    "let us extend 3 .",
    "a bit further : now if you want to incorporate a different kind of data which are @xmath97 dimensional , let us say they are different because they are data pertaining to spoken words , again there is no problem ! just increase the dimension of data to dimension @xmath191 , so each point is an entity in @xmath191 dimension space .",
    "the old data will live in the first @xmath1 dimensions with their components from @xmath188 to @xmath191 defined as zero ; whereas the new data pertaining to words will again be defined in this @xmath191 dimension space but will have their first @xmath1 components as zero and have their components from @xmath188 to @xmath191 as mostly non zero .",
    "so we see new data can always be added not only of the same type but of different types and the old data is never discarded only the dimension of space increases and this can go on from generation to generation .",
    "the set s will be the repository of all knowledge in perpetuity ! as they say knowledge never dies !",
    "in this paper we have reported the discovery of a new algorithm for separating a given set of @xmath0 points by planes in n - dimensional space .",
    "the algorithm is noniterative and will always halt successfully .",
    "it has the property of restart , if new points are needed to be separated the algorithm can continue from where it left off . and at some later stage if the dimension of the data is increased ( @xmath1 to @xmath191 ) is increased the algorithm can still continue from where it left off , ( after some adjustments ) and tackle the new data points which are of a higher dimension .",
    "the algorithm is insensitive to the type of data ; the points may represent , images , words or any other type .",
    "it can handle even the types are mixed as discussed in section 4 .",
    "a rigorous proof has been provided in the body of the paper and a worked example is given in appendix a.    the computational complexity is of @xmath192 , where @xmath3 is the given number of points and @xmath1 is the dimension of space .    *",
    "an informal essay on the new algorithm and its future applications is contained in appendix b *",
    "the author thanks the management of sreenidhi institute of science and technology for their sustained support .",
    "he proclaims his grateful thanks to his wife suhasini , for her willingness to be a sounding board on innumerable occasions and listen to his monologues without which he does not think this work would have ever been done .",
    "\\1 . william b. johnson and joram lindenstrauss :",
    "extensions of lipschitz mappings on to a hilbert space , contemporary mathematics , 26 , pp 189 - 206 ( 1984 )    \\2 .",
    "ralph p. boland and jorge urrutia : separating collection of points in euclidean spaces , information processing letters , vol 53 , no.4 , pp , 177 - 183 ( 1995 )    \\3 .",
    "k.eswaran:a system and method of classification etc .",
    "patents filed ipo no.(a ) 1256/che july 2006 and ( b ) 2669/che june 2015    \\4 .",
    "fischer : `` the statistical utilization of multiple measurements '' , annals of eugenics , 8 , 376 - 386 ( 1938 ) ; also annals eugenics , 7 , 179 - 188 ( 1936 )    \\5 .",
    "mahalanobis : `` on the generalized distance in statistics '' , proc .",
    "inst . of sc .",
    "india , 12 , 49 - 55 ( 1936 )    \\6 .",
    "mcculloch , w. and pitts , w. a : `` logical calculus of the ideas immanent in nervous activity '' , bulletin of mathematical biophysics , 5:115133 .",
    "( 1943 )    \\7 .",
    "a. n. kolmogorov : on the representation of continuous functions of many variables by superpositions of continuous functions of one variable and addition .",
    "doklay akademii nauk ussr , 14(5):953 - 956 , ( 1957 ) .",
    "translated in : amer .",
    "28 , 55 - 59 ( 1963 ) .",
    "paul werbos : `` beyond regression : new tools for prediction and analysis in the behavioral sciences '' , phd thesis , harvard university , 1974    \\9 .",
    "rumelhart , d. e. , hinton , g. e. , and r. j. williams : learning representations by back - propagating errors .",
    "nature , 323 , 533536 ( 1986 ) .",
    "j. schmidhuber : deep learning in neural networks : an overview .",
    "75 pages , www.arxiv.org/abs/1404.7828 ( 2014 ) .",
    "yoshua bengio : learning deep architectures for ai .",
    "foundations and trends in machine learning : vol .",
    "1 , pp 1 - 127 ( 2009 ) .",
    "k. eswaran : `` on the storage and retrieval of primes using n - dimensional geometry '' , sent for publication .",
    "hawkins with s. blakeslee : `` on intelligence '' , publ . henry holt and co. ny .",
    "( 2004 )    \\14 .",
    "d. george and j.c .",
    "hawkins : trainable hierarchical memory system and method , january 24 2012 .",
    "url https:/ www.google.com patents us8103603 .",
    "us patent 8,103,603",
    "* we will now show the working of our algorithm in complete detail .",
    "the algorithm was used to separate the points shown in fig * [ fig : fig - b ]    it was discovered that the above points which are 29 in number in 2d space , can be separated by 8 planes , by using the algorithm .",
    "we will now show how this was done .",
    "however , instead of using unlabeled points we will use fig [ fig : fig - c ] which has a label for each point but in the same position .",
    "( fig [ fig : fig - b ] and fig [ fig : fig - c ] are identical except for labels ) .",
    "the 29 points belong to three classes , ( class a , b , c ) .",
    "we have numbered each point by a number , these numbers is the sequence with which each point was chosen to be in set s ( or t ) when we solved the problem .",
    "we now retain the labels while we describe the process that was followed so that the method can be better understood .",
    "we describe the process in stages .",
    "* stage1 : *    the first stage is when we started with an initial set of points which are separated by planes .    in our commentary below we use the present tense in describing what was actually already done , this change of tense from past to present has been adopted so that the commentary reads better .",
    "this initial set of planes are two in number and numbered 1 and 2 as shown in fig [ fig : fig - i ] below . and the initial set of points , three in number are @xmath193 . we store the coefficients of the two equations for the planes 1 and 2 in s. the equations for the two planes 1 and 2 will be of the form :    @xmath194    @xmath195    we compute the orientation vectors of these three points which are shown in fig [ fig : fig - i ] . and store in s and put @xmath196 and @xmath197 .",
    "the first component of the orientation vector of @xmath198 is @xmath199 because it lies on the positive side of the normal of plane 1 , indicated by black arrow , similarly the second component is also @xmath199 because @xmath198 is also on the positive side of plane 2 , therefore we write @xmath200 , the other orientation vectors of @xmath201 and @xmath202 are depicted in fig [ fig : fig - i ] .",
    "the first component of @xmath203 is @xmath204 , because it lies on the negative side of plane 2 but its second component is @xmath199 because it lies on the positive side of plane 2 , hence @xmath205 , the ov of point @xmath201 is also shown in the fig [ fig : fig - i ] . notice all the three point have different orientation vectors and therefore they all are in separate quadrants , of course this is as it should be , otherwise they would not have qualified to be members of s.    now applying step 2 of our algorithm we choose point @xmath206 , and then go to step 3 , and check whether this point is in the same quadrant as the other three points , in order to do this we have to find the orientation vector of this point : this is done by substituting the @xmath207 of the point @xmath206 in eq .",
    "( 2 ) , for plane 1 , the lhs will evaluate to some -ve value which will signify that @xmath206 is on the -ve side of plane 1 , then we substitute @xmath207 of the point @xmath206 in eq . ( 3 ) which is the equation for plane 2 , the lhs will again evaluate to some -ve value which will signify that @xmath206 is on the -ve side of plane 2 . in this manner",
    "we obtain the orientation vector of point @xmath206 as @xmath208 .    in n dimension space",
    "this is the only way we can determine orientation vectors . and",
    "determining an orientation vector of a point in n - space where q planes are present would involve evaluating q linear equations of type eq.(1 ) , and therefore would need a total of @xmath155 multiplications and @xmath155 additions .",
    "however when n = 2 ( or 3 ) and we have a diagram such as the one below present , we can write down the orientation vectors by sight , we can see that @xmath206 is on the -ve side of the plane 2 because it is on the opposite side of the normal direction of plane 1 , which is indicated by the black arrow on the top of the figure , similarly @xmath206 is on the -ve side of the plane 2 because it is on the opposite side of the normal direction of plane 2 , which is indicated by the black arrow in the middle right corner of the figure , hence we can conclude , correctly , that @xmath208 . * from now on we will write down the orientation vectors by sight .",
    "*    we now complete the process given in step 3 with regard to this new point @xmath206 , we see that by comparing the orientation vectors of this point @xmath206 with the orientation vectors of the points which are currently in s , namely @xmath193 , and finding that it is different we are sure that @xmath206 is in its own quadrant space and thus point @xmath206 is added to s , and its orientation vector is stored in v and we put @xmath209 and go to step 2 .",
    "we now see that there are no more free regions where a point randomly chosen from g that is points from fig [ fig : fig - c ] can be put in s. and hence when we go to step 2 and choose a new point , we will be directed to go to step 3 , as we shall soon see in stage 2 .",
    "* stage 2 *    we are now in step 2 , we randomly select a point say @xmath210 notice it has a neighbor @xmath211 .",
    "this is discovered by sight , but in actuality if we are in @xmath1 dimension space , we calculate the orientation vector of this new point , @xmath212 and compare with all other orientation vectors of points already in s , namely @xmath213 and then discover that @xmath214 , this implies that in q - space @xmath211and @xmath210 are mapped to the same point , hence in x - space they are not separated by any planes thus we discover that point @xmath211 is a neighbor of the randomly chosen point @xmath210 .",
    "the above is the standard procedure of discovering whether a new randomly chosen point has a neighbor in s , this procedure is done in step 3 for all randomly chosen points .",
    "_ this standard procedure of discovering neighbors in s , is assumed to be always adopted , _ * though for the purpose of this example we will from hence forth , do the `` neigbour detection '' in s , by sight . *",
    "now that @xmath210 has a neighbor we go to step 4 , calculate the mid point coordinate @xmath215 and store it in the list of midpoints and put @xmath210 in t. put @xmath216 and then go to step 2 .",
    "we now choose a new point at random say , @xmath217 it has a neighbor point @xmath218 which is already in s , we find the midpoint @xmath219 put @xmath217 in t and increase @xmath220 , but this time we can not go back to step 2 .",
    "since we are in two dimension space ( n=2 ) , we need to immediately separate the points in t from their respective neighbors in s. as can be seen that the algorithm initiates procedures to start including a new plane , in s , as soon as @xmath22 ( where @xmath1 is the dimension of space ) .     which are stored in the `` list of midpoints '' .",
    "the calculation of the coefficients of this new plane is done in step 5 and the order of computations to find the newplane ( say ) by using gaussian elimination is @xmath39 , so if we have to intoduce @xmath50 planes in the problem the multiplications are in the order of @xmath221 . ] to proceed with our algorithm we need to go to step 5 .",
    "step 5 says that we must now find the equation to a new plane which passes through the mid points @xmath215 and @xmath219 , this is easliy done by assuming that the equation to this new plane is : @xmath222 ; with unknown coefficients @xmath223 then these two unknown coefficients can be found by using the condition that the line must pass through @xmath215and @xmath219 , whose coordinates are @xmath224 and @xmath225 to obtain the eqs :    @xmath226    @xmath227    solving the above we determine @xmath223 which completely defines the equation for plane 3 , which is now include s and we drawn this line as shown in fig [ fig : fig - d ] . since the coefficients @xmath223 are known the direction of the normal is also known , the normal is also drawn ( black arrow ) in the figure .",
    "now @xmath228 .",
    "going to step 6 , we check to see if all the points are in their own quadrants ( ie are separated ) by actually updating the finding the orientation vectors of the old points wrt to the 3 planes .",
    "the orientation vectors are now of dimension 3 and given by :    @xmath229 @xmath230 @xmath231 .",
    "we see that all the orientation vectors    of @xmath232 are all different so that they are all in their own quadrants in q - space and hence separated from one another in x - space .",
    "this ofcourse , is plainly visible by sight in fig [ fig : fig - d ] .",
    "now we complete the tasks indicated in step 6 .",
    "we clear the `` list of mid points '' , include the new points @xmath233 in s , include plane 3 in s put q=3 , clear the set t because its contents @xmath233 have been transferd to s. then we go to step 2 .",
    "the situation arising is shown in fig [ fig : fig - d ] below :        * stage 3 : *    we are now in step 2 .",
    "since no more points can be added , the situation is exactly the same as that in the beginning of stage 2 , so we repeat what was done in stage 2 except that we randomly choose two new points @xmath234 and @xmath235 which have neighbors @xmath236 and @xmath217 which are already in s. so we follow the steps similar to that described in stage 2 and end up with a new plane , viz .",
    "plane number 4 , put q = q+1=4 ; and s now contains 8 points all their orientation vectors in the new 4 dimensional q space are all different and therefore all the 8 points are separated by these 4 planes .",
    "see fig [ fig : fig - e ] .",
    "* stage 4 ; *    from now on we will hurry through the steps .",
    "we are in step 2 .",
    "two new points : @xmath237 which is neighbor of @xmath206 and @xmath238 which is a neighbor of @xmath211 are introduced and a new plane plane no .",
    "5 is introduced and transfered to s.    after this we see that the next point @xmath239 occurs in an empty quadrant hence it is immediately added to s , the next two points @xmath240 have neighbors @xmath238 and @xmath241 resp . and therefore need a new plane , viz plane 6 , and are all transfered to s along with plane 6 .",
    "the next point @xmath242 happens to be in its own quadrant so is included in s. the next two points @xmath243 have neighbors @xmath244 and @xmath245 in s and determine a new plane 7 and are transferred to s along with 7 .",
    "see fig [ fig : fig - f ]        * stage 5 : *    we are in step 2 : 7 planes have been just added and s contains 16 points .",
    "all the orientation vectors are now dimension 7 .",
    "they are all different for the 16 points , as may be checked tediously or by sight .",
    "the new randomly chosen points @xmath246 all are in their own quadrants and can be directly included in s with out troubling ourselves to add a new plane see fig [ fig : fig - g ] .",
    "( this sort of situation when we can include a whole sequence of points before we introduce a new plane occurs when the number of planes q increase , because the number of quadrants in q space increase . for q planes we have @xmath83 quadrants in q space , therefore there is space for more points in q space . )",
    "dimension space is much easier , this is because whenever you introduce a plane say from @xmath9 to @xmath7 the number of quadrants in x - space double from @xmath247 to @xmath248 , this doubling in x - space stops after @xmath249 after which you will get some confined regions . now an interesting question arises : if have just added a plane ( say ) the @xmath51 and you already have n points in s , how many points can you add to s before you need the next plane ?",
    "the answer for large @xmath1 is that you can on the average add @xmath250 points . ] after this we arrive at @xmath251 and @xmath252 which have neighbors already in s namely @xmath218 and @xmath217 .",
    "these determine the last plane plane 8 .",
    "see fig [ fig : fig - g ]        * stage 6 : *    we are in step 2 and have just introduced plane 8 .",
    "there are 24 points in s and 8 planes .",
    "we see that we now randomly choose the sequence of points @xmath253 and @xmath254 all of them are in their own quadrants and are already separated from other points in s and from each other and hence can be included in s without adding any more planes .",
    "and now there are no more points in g and so we have @xmath255and @xmath256 .",
    "the final solution is given in fig [ fig : fig - h ]          in this subsection we will , for the sake of completeness , tackle some of the situations that we had discussed before , in section 4,but with reference to this * worked example .",
    "*    how shall we tackle new points ?",
    "suppose we have once solved a problem that is , we have separated @xmath3 points given in an original set g , in n dimension space and have found that @xmath9 planes have done the job .",
    "after this we make a retrieval and storage engine as depicted in fig [ fig : fig - a ] and discussed in section 3 .",
    "we begin to use the retrieval engine for some time , and afterwards we encounter new data .",
    "* case 1 : new data has the same dimension as the old data *    we have already spoken about this situation : we had said that there is no need to start from the very beginning , the algorithm can start from where it left off.we just add these new points to set g , which until now was empty , and start the algorithm from step 2 keeping the set s containing the latest number of points and planes which we had ( i.e. @xmath257 and @xmath258 , with all the @xmath259 ) , just before we encounter this new data .",
    "we already depicted the situation , in our example , figure [ fig : fig - h ] , we have separated 29 points with 8 planes .",
    "now we encounter 2 more points ( say ) @xmath260 and @xmath261 .",
    "we just continue as before ( assuming just for convenience that both these have neighbors ) : treat these two as temporary candidates in t with neighbors as shown in [ fig : fig - j ] and draw a new plane number 9 .",
    "this separates all the 31 points and we have an additional plane , and these two new points all of which now can be included in s. notice new quadrants are created , these new quadrants could capture some new points , which are are still in g. the algorithm continues from step 2 till g is empty and then stops . if g becomes empty at @xmath262 then the situation in s is as shown in fig [ fig : fig - j ] .        *",
    "case 2 : new data does not have the same dimension as the old data , but has one more dimension @xmath263 *    suppose we are as before in a situation depicted by fig .",
    "[ fig : fig - h ] i.e. s contains 29 points and 8 planes .",
    "now we encounter three new points of dimension @xmath263 , since all our original data is 2d we can assume that all the points are in the x - y plane .",
    "we assume that these three new points belong to the new data set and are of dimension @xmath188 .",
    "we tackle the problem by first converting all the 2-d data in s to 3 d data , this is simply done by embedding the 2d data in 3d space . with reference to fig",
    "[ fig : fig - c ]    step c1 : convert all the 2-d coordinates by defining for each point whose original coordinates are @xmath264 a new coordinate @xmath265 such that @xmath266    step c2 : convert all the 2d equations of the @xmath9 planes to corresponding equations valid as 3d equations eg if the equation of the @xmath267nd plane is ( say ) :    @xmath195    we should convert it to : @xmath268 and define @xmath269 this process should be done for all the @xmath9 planes .    by this process",
    "a 2d plane will become a 3d plane , however its normal will be in the x - y plane .",
    "if we assume that x - y plane to be ` horizontal ' then all the planes will become vertical walls containing the original 2d lines .",
    "these planes are now shown as blue lines .",
    "all the original quadrants at this stage will become 3-d regions defined by vertical walls shown as blue lines .",
    "we start the algorithmic process : we go to step 2 of the algorithm after putting @xmath270 and @xmath271 and putting a , b , c in g. and s will contain @xmath9 3d planes and n points along with their ` orientation vectors ' . for simplicity we will assume that none of the three points a , b , c fall in a new ` quadrant ' so they will all end up in t and each with their respective neighbors for example the neighbor of a and b are shown to be : @xmath244 and @xmath272 resp .",
    "we will have three mid points which we call @xmath273 .",
    "now since @xmath274 , we go to step 5 and find the equation to the plane which passes through these three midpoints .",
    "the new ` genuine ' 3d planest plane is the first plane among all the planes in s , whose normal is not lying in the x - y plane .",
    "of course as we proceed with the algorithm and be adding points in 3d space there will be many such planes in s. ] along with the old 8 planes will now separate all the n=29 points from a , b , c and from each other .",
    "so we can now add a , b , c to s and include this new plane so @xmath275 and @xmath276 and calculate all the orientation vectors of the 32 points ( i.e. update v ) and then go to step 2 of the algorithm after clearing t and the ` list of midpoints ' .",
    "so we see now s has 32 points all separated by 9 , 3d planes if there are more points in g , the algorithm proceeds or else stops .",
    "fig [ fig : fig - k ]    we have thus seen how the algorithm can restart from the last step made earlier , even when the dimension of the new points are increased by one .    * end of worked example *",
    "* what the algorithm does * : imagine we are given a set @xmath277 of n points in n - dimensional space .",
    "basically the algorithm finds planes , in n - dimension space such that they can separate all the n points , in such a manner that every point is separated from every other point by at least one plane .",
    "the output of the algorithm is a set s containing the points and also the equations of the planes that separate them .",
    "( in general for large dimension space the number of planes @xmath278required is approx.@xmath279 ) .    *",
    "how its done : * let us imagine the set @xmath277 as an n - dimensional @xmath280space , containing @xmath3 points .",
    "we create another n - dimensional @xmath281-space called @xmath282 .",
    "we then transfer points randomly from @xmath277 to @xmath282 one by one , so that they occupy the same coordinate position in @xmath282 as they had occupied in @xmath277 ( their coordinates do not change ) and also planes are drawn in s. the algorithm makes sure that after a new plane is drawn , all the points in s at this stage are separated .",
    "the algorithm proceeds stage by stage transferring , new points from @xmath277 and drawing new planes in s till eventually s contains all the n points as well as the q planes needed to separate all the n from one another .    *",
    "beauty : * there is a certain beauty in the algorithm , there are no redundancies and duplications .",
    "if it required say 97 bits of information to draw a plane , then it will acquire exactly all these 97 bits of information and draw the plane , then store the 97 bits , before it seeks more information to draw another plane ) , sec 4.1 , p. 15",
    ", contains the proof .",
    "it adopts shannons principle that each bit is an information , so use it as far as possible , before you seek another bit of information , ( but these are technicalities that i will pass on for some other time ) .",
    "just to put the paper in its proper perspective , we list its contents :    1 .",
    "it has a very strict mathematical proof , of how @xmath3 points in n - dimensional space can be separated by q planes . 2 .",
    "the complexity is of @xmath283 .",
    "this itself is somewhat unique because very few algorithms have this efficiency to name a few:(i ) the fft , complexity : @xmath284 , ( ii ) euclidean algorithm of gcd complexity : @xmath285 , @xmath3 being the larger of the two numbers , ( iii ) quick sort algorithm complexity on the average @xmath284 worst case @xmath286 , ( iv ) gauss elimination for solving @xmath3 linear equations @xmath287 , ( vi ) primality testing algorithm of agarwal et al , complexity @xmath288 , ( vi ) rsa algorithm @xmath287 , here @xmath3 is the number of bits .",
    "it contains the conditions under which the algorithm can be made to work along with a proof .",
    "we have simple worked example in the appendix a and outlined applications in sec 3 and its interesting properties in sec 4 .",
    "many researchers , from statisticians and neural network scientists have long been trying to separate clusters by planes or discriminant functions .",
    "this has been ever since the time of fisher [ 4 ] and mahalanobis [ 5 ] and mcculloch and pitts[6 ] , kolmogorov [ 7 ] , werbos[8 ] , and rumelhart , hinton and williams [ 9 ] and others [ 10 ] , also the deep learning people[11 ] , famous names in the fields .",
    "but all have had great difficulties in large n - dimensional space and they found that it is not easy .",
    "so the phrase like the curse of dimensionality and np hard complexity , has become a part of folk lore . however , from the very beginning it was never very easy to separate clusters by planes .",
    "this is mostly because , a cluster is not well defined , every cluster has its own shape and in @xmath1-dimensions you could have long thin filaments and all kinds of snake like dragon like shapes which constitute a cluster .",
    "though statisticians try to approximate the shape of each cluster as ellipsoids or even simple spheres , clusters in general would require more parameters to define their shapes than that required to define the planes which are supposed to separate them !",
    "so all along it was , perhaps , very naive of all of us to have tried to separate clusters when such entities are not mathematically well defined .",
    "i felt that it is far better to separate the individual points and to use the enormous space and degrees of freedom that is available in @xmath1-dimension space to separate each point , rather than try to separate clusters which will never be well defined .",
    "this was the genesis of the idea that gave an impetus to do the kind of research work reported in this paper .",
    "as an illustration , in the last section we have considered a cluster of 29 points in 2-d , see fig 3 , and used the algorithm to separate all the 29 points using 8 planes see fig 9 , ( it can be proved that the theoretical minimum for 29 points in 2-d , is 7 planes ) .",
    "another fact , that only adds to the prospect of success in this new direction is that : for large n dimension space where @xmath289 ( @xmath3 being the number of points ) , you will find the number of planes @xmath9 , needed for separating @xmath3 points is far less than the number of points itself , in fact @xmath290    imagine : even a highly reduced small passport size image of @xmath291 pixels is a point in a @xmath292 dimension space . and",
    "in such a space there are @xmath293 quadrants i.e. approximately @xmath294 quadrants . and",
    "even if you put one image in one quadrant ( thus automatically separating them from others ) you will never be able to fill up this space : there are only about @xmath295 atoms in the universe so how will you make so many photographs ?        the answer is : we wanted all the readers to concentrate on the algorithm and its proof and not rile them with matters not germane to the task on hand ; for after all a mathematical paper makes its greatest impact by cold logic and rigid proofs rather than tall talk and philosophy .  ..    in sec 3.2 where we describe a possible application to medical records of 10 billion people- the number of planes , @xmath9 , you require would be @xmath296 or @xmath297 planes .",
    "most of the time you will require very few planes to separate all@xmath3 points .",
    "this is counter intuitive but will always happen , for large @xmath1 the number of planes @xmath9 will be @xmath298 . the following  explains the phenomena : consider an empty @xmath1-dimensional space , void of planes , then if you put one plane , it divides the space to 2  quadrants , the 2nd plane will divide the space to 4  quadrants , the 3rd to 8 and the qth plane to@xmath83  quadrants .",
    "( the doubling stops only when @xmath249 , afterwards some closed regions are formed ) , so you see you have sufficient number of planes @xmath9 to handle @xmath3 points even if you put one point in a single quadrant all you need is @xmath279planes .      in all these applications one must some how employ mappings to reduce multi - dimensional data , temporal data or any other kind of data to image points in n - dimensional space ,",
    "it is only then that the methods of the algorithm described in this paper can be usefully employed for classification or decision making .",
    "an example illustrating this method is given in ref.[12 ] , by which any @xmath181digit prime number can be depicted as a point in @xmath181 dimension space ; and therefore a prime number repository for storage and easy retrieval of primes can be created .",
    "the figure 12 , below shows how all 2-digit prime numbers can be considered as points in 2-d space and separated by just 10 planes .",
    "chess games:**we can treat each chess game as a point in @xmath114-dimension .",
    "its coordinates being @xmath299 the @xmath1 moves made by white and black ( it is not hard to convert the moves @xmath300 etc . into numbers",
    "so the above array which represents a single chess game , is represented as a single point in 2n - dimension space ) .",
    "it is possible to store numerous chess games , say @xmath3 , for easy retrieval using the same technique as described for medical data .",
    "the number of planes involved would be only @xmath301 .      in the above cases the data is static and not dynamic .",
    "in many life situations it is necessary to tackle dynamic data viz .",
    "sequences , like a sequence of events , tracking of time signal , or even such matters as health monitoring of machines , ( eg . see jeff hawking [ 13]-[14 ] , who has underlined the importance of storing and recalling a sequence of events in order to further research in artificial intelligence ) .",
    "we then need a method using which we can compare two sequences , say , one a shorter sequence , @xmath302 , of length , @xmath303 , with a longer sequence @xmath304 of length @xmath97 , which is stored in the memory .",
    "the @xmath72 may be the  condition of a machine in the year , @xmath305 , of its working life . so that the possible  future  values of the shorter sequence@xmath72",
    "can be predicted by comparing it with a longer sequence@xmath306 , which is the record of some machine which has already lived its life and whose records are now stored in a memory along with the historical records of many such machines .",
    "we must imagine that the longer second sequence has been extracted from the data base , by the retrieval engine ( see sec 3.2 ) , because it happens to have its first @xmath303 values somewhat close to the @xmath303 values of the shorter sequence .",
    "we describe a method of mapping a sequence to points in a @xmath1-dimensional space .",
    "this mapping is necessary to tackle dynamic situations and tracking / memorizing a sequence of events .",
    "the data contained in the sequence are then  mere points in @xmath1-dimensional space which are then separated by using the algorithm using @xmath9 planes , the orientation vectors are used to store the data in a repository sec 3.2 ) . but in order to perform all these tasks we need a scheme to convert a sequence to points in @xmath1-dimensional space ; we now demonstrate how this can be done .",
    "we will suppose@xmath1 is the max number of years that each record has .",
    "it is possible to store the sequence as points in an @xmath1 dimensional space using the following scheme .",
    "we define the coordinates in @xmath1-dimension space for each member of the sequence as follows :              note : each of the above is a point in @xmath1-dimension space .",
    "hence the sequence of points given above is like a world - line in @xmath1-space . ( even though , we considered the @xmath72 as a single number ; there is no difficulty if this is ( say ) @xmath316 dimensional then the actual value of the bigger space will @xmath317 dimensional i.e. be @xmath318 . and a similar scheme for the sequence@xmath319 :              similarly , we can think of the sequence of points above as a world - line in n - space .",
    "the problem of comparing two sequences @xmath326 and @xmath319 has been reduced to the comparison of two world - lines .",
    "since we have separated every point such as the @xmath327 by using planes , we can easily retrieve any sequence such as @xmath319 by using the retrieval engine . now , suppose we are presented a point @xmath328 ( as described in sec 3.2 ) , whose coordinates are @xmath329 ; the retrieval engine will retrieve a point @xmath167 whose coordinates @xmath330 are closest to point @xmath328 .",
    "this implies you have detected another world - line @xmath319 , which had had similar experiences in its first@xmath303 episodes of its ` life ' as that of world - line @xmath326 ; and hence it is quite possible that the fate of @xmath326 would be similar to what befell @xmath331 thus making it possible to retrieve the entire record @xmath332 , thus enabling us to predict the possible values of @xmath333 when @xmath334 by looking at the other values @xmath335 which are now been made available .    in the above example , you could also think of world line @xmath326 as the medical record of some person who is presently living and is @xmath303 years old . and the world line @xmath319 as the medical record of some person who had probably lived and died , but whose first @xmath303 years of life she / he had a similar medical history as that of @xmath326 .",
    "this is how we can predict the ` future life ' of a presently occurring sequence of events by using the repository containing historical data of sequences that have occurred in the past .",
    "* 3 . other possibilities :",
    "* we could similarly convert decision trees and/or logical trees to sequences which can then be mapped as points in a large @xmath1 dimension space , so we see the algorithm can help in decision making and imitative learning etc .",
    "of large complex data ."
  ],
  "abstract_text": [
    "<S> we demonstrate an algorithm that can separate any number of points in n - dimensional space from one another by planes . given a set g of @xmath0 points , along with their coordinates , in n - dimensional x - space , the algorithm partitions all the @xmath0 points by using planes such that no two points are left un - separated by some plane . </S>",
    "<S> the algorithm proceeds by transferring points from g to another set s in n - dimensional x - space , to the same coordinate position in s as it was in g. however initially s has very few points and very few planes , but the few planes are so chosen that all the points in s are already separated from each other by the few planes contained in it . </S>",
    "<S> each point is then chosen at random from g and then transferred to s one by one , matters are so arranged that if necessary new planes are drawn in s so that the points in s will always be separated . in order to do this each point from g </S>",
    "<S> is labeled as a member of s if it is separated from others in s , otherwise it is labeled as a `` special '' point which is not yet separated . the collection proceeds ( at random ) as new points are added to s from g and each new point is either separate and becomes a member of s or labeled as `` special '' . </S>",
    "<S> as soon as @xmath1 `` special '' points are collected they are all separated by a single extra plane , which is then added to the collection . </S>",
    "<S> the algorithm is made possible because a new concept called orientation vector is used . </S>",
    "<S> this vector is a hamming vector and is associated with each point and has all the information necessary to ascertain if two points are separate or not . </S>",
    "<S> the algorithm proceeds till s contains all the planes which separate all the points . </S>",
    "<S> the method is non iterative , it will always halt successfully and the algorithm strictly follows shannon s principle of making optimal use of information as it advances stage by stage . </S>",
    "<S> it has the property of restart , if new points are needed to be separated the algorithm can continue from where it left off . at some later stage </S>",
    "<S> if the dimension of the data ( n to n+r ) is increased the algorithm can still continue from where it left off , and tackle the new data points which are of a higher dimension , after some minor modifications .    a proof is provided with a worked example . the computational complexity is of @xmath2 , where @xmath3 is the given number of points and $ n$ is the dimension of space . in summary </S>",
    "<S> this paper describes a non - iterative algorithm of separating a given set of points in n - dimension by planes . </S>",
    "<S> its application to data retrieval problems in very large medical data bases is also given . </S>",
    "<S> possible future applications are also identified .    </S>",
    "<S> dept . of computer science , </S>",
    "<S> sreenidhi institute of science and technology , yamnampet , ghatkesar , hyderabad , 500010 india </S>"
  ]
}