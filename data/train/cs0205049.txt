{
  "article_text": [
    "the well - known huffman coding problem @xcite is the following : given a sequence of access probabilities @xmath5 , construct a binary prefix code @xmath6 minimizing the expected length @xmath7 .",
    "binary prefix code _ is a set of binary strings , none of which is a prefix of another .",
    "a natural generalization of the problem is to allow the words of the code to be strings over an arbitrary alphabet of @xmath8 letters and to allow each letter to have an arbitrary non - negative length .",
    "the length of a codeword is then the sum of the lengths of its letters .",
    "for instance , the `` dots and dashes '' of morse code are a variable - length alphabet with length corresponding to transmission time .",
    "( see figure [ comparisons ] . )",
    "this generalization of huffman coding to a variable - length alphabet has been considered by many authors , including altenkamp and mehlhorn @xcite , and karp @xcite .",
    "apparently no polynomial - time algorithm for it is known , nor is it known to be np - hard .",
    "a prefix code in which the codewords @xmath9 are in alphabetical order is called _ alphabetic _ @xcite . in this case",
    "the underlying tree represents an @xmath0-ary _ search tree_. the length of the @xmath2th letter corresponds to the time required to descend from a node into its @xmath2th subtree .",
    "this time is often a function of @xmath2 in search - tree algorithms , for instance , when the subtree to descend into is chosen by sequential search .",
    "an optimal alphabetic code thus corresponds to a minimum expected - cost search tree .    in this paper",
    "we consider the special case in which the codewords occur with equal probability , i.e. , each @xmath10 equals @xmath11 . with this restriction ,",
    "the alphabetic and non - alphabetic problems are equivalent",
    ". the problem may be viewed as a variant of huffman coding in which the lengths of the letters , rather than the codeword probabilities , are non - uniform .",
    "alternatively , it may viewed as the problem of finding an optimal @xmath0-ary search tree , where the search queries are uniformly distributed but the time to descend from a parent to its @xmath2th child depends on @xmath2 . for the complexity results stated in this paper , the algorithms return a tree representing an optimal code .    in 1989 ,",
    "kapoor and reingold @xcite described a simple @xmath12-time algorithm for the binary case @xmath13 . in 1975 ,",
    "perl , garey , and even @xcite gave an @xmath14-time algorithm .",
    "( although due a typographical error their abstract incorrectly claims an @xmath15-time algorithm . )",
    "in the same year cot @xcite described an @xmath16-time algorithm . in 1971",
    ", varn @xcite gave an algorithm without analyzing its complexity .",
    "it appears varn s algorithm requires @xmath17 time .    in this paper",
    "we describe an @xmath3-time algorithm based on new insights into the structure of optimal trees . in section 2",
    "we define _ shallow _ and _ proper _ trees and prove that some proper shallow tree is optimal . in section 3",
    "we develop the algorithm , which efficiently constructs all proper shallow trees and returns one representing an optimal prefix code .",
    "fix an instance of the problem , given by the respective lengths @xmath18 of the @xmath0 letters in the alphabet and the number @xmath1 of ( equiprobable and prefix - free ) codewords required .",
    "we assume the standard tree representation of prefix codes , as described in the following definition .",
    "the _ infinite @xmath0-ary tree _ is the infinite , rooted , @xmath0-ary tree .",
    "each tree edge has a length and a label  an edge going from a node to its @xmath2th child has length @xmath19 and is labeled with the @xmath2th letter in the alphabet .",
    "a _ node _ is a node of the infinite @xmath0-ary tree .",
    "the finite words over the alphabet of @xmath0 letters correspond to the nodes .",
    "the labels along the path from the root to any node spell the corresponding word and the length of the path is the length of this word .",
    "a prefix code corresponds to a set of nodes none of which is a descendant of another .",
    "( see figure [ comparisons ] . )    ' '' ''",
    "a _ tree _ is any subtree @xmath20 of the infinite @xmath0-ary tree containing the root . in any tree , @xmath1 of the leaves",
    "will be identified as _ terminals _ ; their corresponding words form a prefix code .",
    "the remaining nodes in the tree are referred to as _ non - terminals_.    give a node @xmath21 , the notation @xmath22 denotes @xmath21 s @xmath2th child ; @xmath23 denotes the depth ( the length of the corresponding codeword ) ; @xmath24 denotes the parent .",
    "the _ cost @xmath25 _ of such a tree is the sum of the depths of the terminals  also called the _ external weighted path length _ of the tree .",
    "a _ proper _ tree is a tree in which every non - terminal has at least two children .    the goal is to find an optimal tree with @xmath1 terminals .",
    "it is easy to see that some optimal tree is proper ; thus , we restrict our attention to proper trees .",
    "our basic tool for understanding the structure of optimal trees is a swapping argument .",
    "for example , in any proper optimal tree , no non - terminal is deeper than any terminal .",
    "otherwise , the terminal and the subtree rooted at the non - terminal could be swapped , decreasing the average depth of the terminals .",
    "we use a swapping argument to prove that an optimal proper tree has the following form for some @xmath26 .",
    "the non - terminals are the @xmath26 shallowest ( i.e. , least - depth ) nodes of the infinite tree , while the terminals are the @xmath1 shallowest available children of these nodes in the infinite tree .",
    "we call such a tree _ shallow _ ; here is the precise definition :    a tree @xmath20 is _ shallow _ provided that    * for any non - terminal @xmath27 and any node @xmath28 ( not necessarily in @xmath20 ) that is not a non - terminal , @xmath29 and * for any terminal @xmath27 and any node @xmath28 that is not in @xmath20 but is a child of a non - terminal , @xmath29 .",
    "note that a non - terminal of an ( improper ) shallow tree might have no children in the tree .",
    "this is why we refer to `` terminal '' and `` non - terminal '' nodes in place of the more common `` internal nodes '' and `` leaves '' .    as a simple example consider the basic binary tree ; @xmath30 @xmath31 a proper binary tree @xmath20 will be shallow if and only if there is some depth @xmath32 such that ( a ) every node @xmath21 in the infinite tree with @xmath33 is a non - terminal in @xmath20 and ( b ) all terminals of @xmath20 are on levels @xmath32 and @xmath34 conditions ( a ) and ( b ) are necessary and sufficient conditions for @xmath20 to have minimum external path length among all binary trees with the same number of leaves , see e.g. ,  @xcite .",
    "so , a binary tree has minimum external path length for its number of leaves if and only if it is shallow .",
    "for example , the binary tree on the left of figure [ comparisons ] has minimum external path length among all trees with @xmath35 leaves because it fulfills conditions ( a ) and ( b ) with @xmath36 as we will see later , though , for most values of @xmath0 and @xmath37 shallowness alone does not imply optimality .",
    "however , if a shallow tree has the right number of non - terminals , then it is optimal :    [ shallow lemma ] let @xmath38 be the minimum number of non - terminals in any optimal tree .",
    "then any shallow tree with @xmath38 non - terminals is optimal and proper .",
    "fix a shallow tree @xmath20 with @xmath38 non - terminals",
    ". we will show the existence of an optimal tree with the same non - terminals as @xmath20 . since @xmath20 is shallow , by property ( ii ) , this will imply @xmath20 is optimal . by the choice of @xmath38 , @xmath20 is also proper ( otherwise there would be an optimal proper tree with fewer non - terminals ) .",
    "it remains to show the existence of an optimal tree with the same non - terminals as @xmath20 .",
    "let @xmath39 be an optimal ( and therefore proper ) tree with @xmath38 non - terminals .",
    "let @xmath40 and @xmath41 be the sets of non - terminals of @xmath20 and @xmath39 , respectively . if @xmath42 we are done .",
    "otherwise , let @xmath21 be a minimum - depth node in @xmath43 , so that @xmath21 s parent is in @xmath41 .",
    "let @xmath44 be a node in @xmath45 .",
    "note that , since @xmath20 is shallow , @xmath46 , but that , in @xmath39 , @xmath44 is a non - terminal ( with at least two terminal descendants ) while @xmath21 is either a terminal or not present .    in @xmath39 ,",
    "swap the subtrees rooted at @xmath21 and @xmath44 . specifically , make @xmath21 a non - terminal and , for each descendant @xmath47 of @xmath44 , delete it and add the corresponding descendant @xmath48 of @xmath21 .",
    "if @xmath47 was a terminal , make @xmath48 a terminal , otherwise make @xmath48 a non - terminal .",
    "if @xmath21 was a terminal , make @xmath44 a terminal , otherwise delete @xmath44 .",
    "call the resulting tree @xmath49 .    from",
    "@xmath46 it follows that @xmath50 .",
    "thus , @xmath49 is also optimal .",
    "note that @xmath49 shares one more non - terminal with @xmath20 than does @xmath39 .",
    "thus , repeated swapping produces an optimal tree with the same non - terminals as @xmath20 .",
    "[ shallow lemma ] any shallow tree @xmath20 satisfies @xmath51 for every proper tree @xmath49 with the same number of non - terminals .",
    "fix a shallow tree @xmath20 .",
    "if there are no proper trees @xmath49 with the same number of non - terminals , the lemma is trivially true .",
    "otherwise , among such trees , consider those that minimize @xmath52 .",
    "let @xmath39 be one that maximizes the number of non - terminals shared with @xmath20 .",
    "suppose for contradiction that the set of non - terminals of @xmath20 differs from that of @xmath39 . among all non - terminals of @xmath20 that are not non - terminals of @xmath39",
    "let @xmath21 be one whose parent is a non - terminal of @xmath39 .",
    "let @xmath28 be any non - terminal of @xmath39 that is not a non - terminal of @xmath20 .",
    "since @xmath20 is shallow , by property ( i ) , @xmath29",
    ".    in @xmath39 , node @xmath21 , if present , is a terminal .",
    "node @xmath28 , on the other hand , has at least two terminal descendants , because @xmath39 is proper . in @xmath39 , consider swapping @xmath21 and @xmath28 s subtrees .",
    "( specifically , make @xmath21 a non - terminal . if @xmath21 was a terminal in @xmath53",
    "make @xmath28 a terminal , otherwise delete @xmath28 . for each descendant @xmath54 of @xmath28 , delete @xmath54 and add the corresponding descendant @xmath55 of @xmath21 ( as a terminal if @xmath54 was a terminal ) . )",
    "the swap does nt increase @xmath56 yet increases the number of non - terminals shared with @xmath20 . by the choice of @xmath39 , this is a contradiction .",
    "thus , @xmath20 and @xmath39 have the same set of non - terminals .",
    "since @xmath20 is shallow , by property ( ii ) , @xmath57 .    as an aside , a similar argument proves something like the converse : if a proper tree is optimal among all trees with the same number of non - terminals , then it is shallow .",
    "if a proper tree @xmath20 satisfies @xmath51 for every tree @xmath49 with the same number of non - terminals , then @xmath20 is shallow .    among the shallowest nodes in the infinite tree that are not non - terminals of @xmath20 ,",
    "let @xmath21 be one whose parent is a non - terminal of @xmath20 .",
    "let @xmath28 be any non - terminal of @xmath20 .",
    "it must be that @xmath58 , for otherwise swapping , in @xmath20 , the ( zero- or one - node ) subtree at @xmath21 with the subtree at @xmath28 would decrease @xmath49 .",
    "similarly , if @xmath21 is any terminal of @xmath20 and @xmath28 is not in @xmath20 but is a child of a non - terminal of @xmath20 , @xmath58 .",
    "thus @xmath20 is shallow .",
    "lemma [ shallow lemma ] implies that it suffices to consider shallow , proper trees :    [ sequence lemma ] let @xmath59 .",
    "let @xmath60 be any sequence of shallow trees such that for each @xmath26 , @xmath61 has @xmath26 non - terminals .",
    "then one of the @xmath61 is proper and optimal .",
    "let @xmath26 be the minimum number of non - terminals of any optimal tree .",
    "since each node in the optimal tree has at most @xmath0 children , @xmath62 . by lemma [ shallow lemma ] , @xmath61 is optimal .",
    "further , @xmath61 must be proper ; otherwise , it would be easy to construct an optimal tree with fewer non - terminals .",
    "note that @xmath63 , since each node has degree at most @xmath0 .",
    "[ sequence corollary ] let @xmath59 .",
    "let @xmath60 be any sequence of shallow trees such that for each @xmath26 , @xmath61 has @xmath26 non - terminals .",
    "then one of the @xmath61 is proper and optimal .",
    "the algorithm generates a sequence of shallow trees as above and returns the one which has minimum cost .",
    "the lemma guarantees that this tree will be optimal .",
    "the rest of the paper is devoted to examining the properties of shallow trees which enable the enumeration of the proper shallow trees in @xmath64 time .    ' '' ''      [ [ ordering - the - nodes . ] ] ordering the nodes .",
    "+ + + + + + + + + + + + + + + + + + + +    label the nodes of the infinite tree as @xmath65 in order of increasing depth .",
    "break ties arbitrarily , except that if two nodes @xmath21 and @xmath28 are of equal depth , and both are @xmath2th children of their respective parents , and @xmath66 , then let @xmath67 ( this is needed for lemma [ child lemma ] ) . for the sake of notation , identify each node with its label , so that @xmath68 is the root , @xmath69 is a minimum - depth child of the root , etc .",
    "figure [ infinite tree ] illustrates the top section of such a labeling for @xmath70 @xmath71 @xmath72 and @xmath73 these values of @xmath0 and @xmath74 are the ones we use in all later examples .    for each @xmath75 define @xmath61 to be the tree whose non - terminals are @xmath76 and whose terminals are the minimum @xmath1 nodes among the children of @xmath76 in @xmath77 .",
    "thus , @xmath61 is the `` shallowest '' tree with @xmath26 non - terminals with respect to the ordering of the nodes .",
    "since the ordering of the nodes respects depth , each @xmath61 is shallow .",
    "figure [ tmex ] presents @xmath78 @xmath79 @xmath80 and @xmath81 for @xmath82 using the labeling of figure [ infinite tree ] .",
    "@xmath83 } }      &    3 &   3 & 1\\\\        { { \\mbox{\\bf w}[{i } ] } }     &    5 &   5 & 4      \\end{array }      & &      \\begin{array}{c|ccc }                   i               & 1   &   2 & 3\\\\ \\hline        { { \\mbox{\\bf u}[{i } ] } }      &    4 &   3 & 1\\\\        { { \\mbox{\\bf w}[{i } ] } }     &    6 &   6 & 3      \\end{array }    \\end{array}\\ ] ]    @xmath84 } }      &    4 &   4 & 1\\\\        { { \\mbox{\\bf w}[{i } ] } }     &    7 &   7 & 2      \\end{array }      & &      \\begin{array}{c|ccc }                   i               & 1   &   2 & 3\\\\ \\hline        { { \\mbox{\\bf u}[{i } ] } }      &    4 &   4 & 2\\\\        { { \\mbox{\\bf w}[{i } ] } }     &    8 &   7 & 2      \\end{array }    \\end{array}\\ ] ]      next we turn our attention to the relation of @xmath85 to @xmath61 .",
    "[ sprout lemma ] for @xmath75 , the new non - terminal ( node @xmath86 ) in @xmath85 is the minimum terminal of @xmath61 .",
    "the parent of @xmath86 is in @xmath76 , so @xmath86 is the minimum child of @xmath76 in @xmath77 .",
    "the result follows from the definition of @xmath61 .",
    "[ level lemma ] for @xmath75 , provided the new non - terminal ( node @xmath86 ) in @xmath85 has at least one child , each terminal of @xmath85 is either a child of @xmath86 or a terminal of @xmath61 .",
    "let node @xmath86 have @xmath87 children in @xmath85 .",
    "let @xmath88 denote the set of children of nodes @xmath76 in @xmath77 .",
    "the terminals of tree @xmath85 consist of the minimum @xmath87 children of node @xmath86 together with the minimum @xmath89 nodes in @xmath90 .",
    "these @xmath89 nodes , together with node @xmath86 ( the minimum node in @xmath88 ) , are the @xmath91 minimum nodes in @xmath88 . if @xmath92 , then by the definition of @xmath61 , each such node is a terminal in @xmath61 .",
    "the main significance of lemmas [ sprout lemma ] and [ level lemma ] is that they will allow an efficient construction of @xmath85 .",
    "moreover , they imply that , if @xmath61 is not proper , neither is any subsequent tree .",
    "one of the trees @xmath93 is optimal and proper , where @xmath94 .",
    "[ algorithm proof lemma ]    by lemma [ level lemma ] , if @xmath61 is improper , then so is @xmath85  either node @xmath86 has no children in @xmath85 or the non - terminal in @xmath61 that had less than two children also has less than two children in @xmath85 .",
    "hence , for each @xmath95 , tree @xmath61 is improper .",
    "thus corollary [ sequence corollary ] implies that one of the trees @xmath93 is proper and optimal .    for @xmath96 @xmath97 and ( as shown in figure [ tmex ] )",
    "@xmath81 is improper .",
    "the lemma then implies that one of @xmath78 @xmath79 or @xmath98 must have minimum external path length .",
    "calculation shows that @xmath99 with @xmath100 is the optimal one .",
    "the algorithm uses the following two operations to compute the trees .      to  a tree is to add @xmath101 children of the maximum non - terminal to the tree as terminals and to remove the @xmath101 largest terminals in the tree .",
    "the @xmath101 children are the minimum @xmath101 children not yet in the tree , where @xmath101 is maximum such that all children added are less than all terminals deleted .    the algorithm computes the initial tree @xmath102 then repeatedly s and s to obtain successive trees until the tree so obtained is not proper .",
    "lemmas [ sprout lemma ] and [ level lemma ] imply that , as long as node @xmath86 has at least one child in @xmath85 ( it will if @xmath85 is proper ) , ing and ing @xmath61 yields @xmath103 figure [ level and sprout picture ] illustrates this operation .",
    "[ observation]let @xmath106 if node @xmath86 has at least one child in @xmath85 then ing and ing @xmath61 yields tree @xmath103 if node @xmath86 has no children in @xmath85 , then the maximum terminal in @xmath61 is less than the minimum child of node @xmath86 and ing and ing @xmath61 yields a tree in which non - terminal @xmath86 has one child .",
    "hence , the algorithm always correctly identifies @xmath107 and terminates correctly , having considered all relevant trees .",
    "to  requires identification and conversion of the minimum terminal of the current tree , whereas to  requires identification and replacement of ( no more than @xmath0 ) maximum terminals by children of the new non - terminal .",
    "one could identify the maximum and minimum terminals in @xmath108 time by storing all terminals in two standard priority queues ( one to detect the minimum , the other to detect the maximum ) . at most @xmath0 terminals",
    "would be replaced in computing each tree and , because @xmath109 only @xmath12 trees would be computed .",
    "this approach yields an @xmath110-time algorithm .    by a more careful use of the structure of the trees , we improve this in two ways .",
    "first , we give an amortized analysis showing that in total , only @xmath111 , rather than @xmath15 , terminals are replaced .",
    "second , we show how to reduce the number of non - terminals in each priority queue to at most @xmath0 .",
    "this yields an @xmath3-time algorithm .",
    "[ child lemma ] in any @xmath61 , if @xmath21 and @xmath28 are non - terminals with @xmath112 , and the @xmath2th child of @xmath28 is in the tree , then so is the @xmath2th child of @xmath21 .",
    "if the @xmath2th child of @xmath28 is a non - terminal , then so is the @xmath2th child of @xmath21 .",
    "the number of terminals replaced while obtaining @xmath61 from @xmath114 is at most the number of children of non - terminal @xmath26 in @xmath61 .",
    "although this might be @xmath0 for many @xmath26 , the sum of the numbers of children is @xmath111 :      by corollary [ child corollary ] , within @xmath117 node @xmath26 has the fewest children .",
    "the total number of children of the @xmath26 non - terminals is @xmath118 .",
    "thus , @xmath115 is at most the average @xmath119 .",
    "@xmath120 the result follows from @xmath121 and @xmath122      to reduce the number of terminals that must be considered in finding the minimum and maximum terminals , we partition the terminals into @xmath0 groups .",
    "the @xmath2th group consists of the terminals that are @xmath2th children @xmath123 .",
    "[ interval lemma ] in any @xmath61 , for any @xmath2 , the set of non - terminals whose @xmath2th children are terminals is of the form @xmath124 for some @xmath125 and @xmath126 .",
    "the minimum among terminals that are @xmath2th children is @xmath127 ( the @xmath2th child of @xmath125 ) .",
    "the maximum among these terminals is @xmath128 .",
    "this lemma implies that the minimum terminal in @xmath61 is the minimum among @xmath130 .",
    "our algorithm finds the minimum terminal in @xmath20 by maintaining these @xmath0 particular children ( rather than all @xmath1 terminals ) in a priority queue .",
    "this reduces the cost of finding the minimum from @xmath108 to @xmath131 similarly the algorithm finds the maximum terminal in @xmath132 time by maintaining @xmath133 in an additional priority queue .",
    "[ unimodality ] as an aside , one can prove using lemma [ interval lemma ] that , for any @xmath26 such that @xmath134 , @xmath135 .",
    "that is , the sequence of tree costs is unimodal . to prove this ,",
    "consider building @xmath85 from @xmath61 .",
    "@xmath136ing increases the cost by @xmath137 ; @xmath138ing decreases the cost with each swap . for each swap in building @xmath85 from @xmath61",
    ", one can show there was a corresponding swap in building @xmath61 from @xmath114 and that the decrease in cost ( from @xmath139 to @xmath85 ) due to the former is bounded by the decrease in cost ( from @xmath114 to @xmath61 ) due to the latter .",
    "thus , in practice the algorithm could be modified to stop and return @xmath114 when @xmath140 .",
    "the full algorithm has two distinct phases .",
    "the first phase constructs the base tree @xmath141 the second phase starts with @xmath142 and , by ing and ing , iteratively constructs the sequence of shallow trees @xmath143 and returns one which has smallest external path length .",
    "@xmath107 is the last proper tree in the sequence , i.e. , @xmath144 is improper .",
    "lemma [ algorithm proof lemma ] guarantees that the algorithm returns an optimal tree .",
    "we now describe how to implement the first part of the algorithm in @xmath145 time and the second in @xmath64 time ; the full algorithm therefore runs in @xmath64 time .",
    "the skeleton of the final algorithm is shown in fig .",
    "[ alg fig ] .",
    "procedure @xmath146 creates tree @xmath147 the variable @xmath148 contains the external path length of current tree @xmath61 and @xmath149 contains the number of children of node @xmath26 in tree @xmath113 as presented , the algorithm computes only the cost of an optimal tree .",
    "it can easily be modified to compute the actual tree .",
    "note that to check that the current tree @xmath61 is proper , by observation [ observation ] and corollary [ degree corollary ] , it suffices to check that non - terminal @xmath26 has at least two children .",
    "@xmath154   + _make the minimum terminal a non - terminal _    + .",
    "@xmath158   + . let @xmath159}})}$ ] be the minimum terminal in .",
    "+ . @xmath160 } } \\leftarrow { { \\mbox{\\bf d}[{{{\\mbox{\\bf u}[{i}]}}}]}}+{c_{i}}$ ] ; @xmath161 } } \\leftarrow { { \\mbox{\\bf u}[{i } ] } } + 1 $ ] ; @xmath162   + .",
    "@xmath163}}$ ] ; @xmath164 ;   + _add smallest child as a terminal _",
    "   + . @xmath165    @xmath155   + . while = ( = @xmath166 and @xmath167 is less than   +   the max .",
    "terminal @xmath168}})}$ ] in ) do   + . @xmath165",
    "+   _delete the maximum terminal _    + .",
    "@xmath169}}}]}}+{c_{i}})$ ]   + . @xmath170 } } \\leftarrow { { \\mbox{\\bf w}[{i } ] } } - 1 $ ] ; @xmath162        recall that the nodes of the infinite tree are labeled in order of increasing depth with ties broken arbitrarily except for the requirement that if @xmath21 and @xmath48 are both of equal depth and both are @xmath2th children of their respective parents , then @xmath175 iff @xmath176 depending upon @xmath177 there may be many such labelings .",
    "the algorithm we present breaks ties lexicographically  suppose @xmath21 and @xmath48 have the same depth and let @xmath178 and @xmath179 ; then @xmath175 iff @xmath180 ( or @xmath181 and @xmath182 ) . figure [ infinite tree ] illustrates this labeling for @xmath70 @xmath183 @xmath184 and @xmath185 the sequence of shallow trees is fully determined by this labelling .",
    "figure [ tmex ] illustrates the shallow trees with @xmath186 non - terminals for these @xmath0 and @xmath101 values .",
    "@xmath187 : :     the number of terminals .",
    "@xmath188 : :     the number of non - terminals .",
    "also the rank of the maximum    non - terminal . @xmath148",
    ": :     the sum of the depths of the terminals . @xmath149 : :     the number of children of non - terminal @xmath188 .",
    "@xmath189}}$ ] : :     the depth of each non - terminal @xmath21 .",
    "@xmath161}}$ ] : :     the rank of the minimum non - terminal ( if any ) whose    @xmath2th child is a terminal ( @xmath190 ) .",
    "@xmath170}}$ ] : :     the rank of the maximum non - terminal ( if any ) whose    @xmath2th child is a terminal ( @xmath190 )",
    ".    if no non - terminal has a terminal @xmath2th child , then    @xmath161 } } > { { \\mbox{\\bf w}[{i}]}}$ ] .",
    ": :     a priority queue for finding the minimum terminal . +    contains    @xmath191 } } ) } : { { \\mbox{\\bf u}[{i } ] } } \\le { { \\mbox{\\bf w}[{i}]}}\\}$ ] . : :     a priority queue for finding the maximum terminal .",
    "+    contains    @xmath192 } } ) } : { { \\mbox{\\bf u}[{i } ] } } \\le { { \\mbox{\\bf w}[{i}]}}\\}$ ] .    for an example",
    "refer back to figure [ tmex ] .",
    "tree @xmath99 has @xmath193 = 0 , \\qquad       d[2 ] = 2 , \\qquad      d[3 ] = 3 , \\qquad      d[4 ] = 4 , \\qquad      d[5 ] = 4 , \\qquad      d[6 ] = 4 ,      \\\\ \\\\",
    "{ { \\mbox{\\bf u}[{1}]}}=4 , \\qquad      { { \\mbox{\\bf u}[{2}]}}=3 , \\qquad      { { \\mbox{\\bf u}[{3}]}}=1 , \\qquad      { { \\mbox{\\bf w}[{1}]}}= 6 , \\qquad      { { \\mbox{\\bf w}[{2}]}}=6 , \\qquad      { { \\mbox{\\bf w}[{3}]}}=3      \\\\ \\\\      { \\mbox{{\\bf low}-queue}}= \\{{\\mbox{child}_{1}(4 ) } , { \\mbox{child}_{2}(3 ) } , { \\mbox{child}_{3}(1)}\\ } ,      \\\\ \\\\      { \\mbox{{\\bf high}-queue}}= \\{{\\mbox{child}_{1}(6 ) } , { \\mbox{child}_{2}(6 ) } , { \\mbox{child}_{3}(3)}\\}.    \\end{array}\\ ] ]    the priority queues are maintained as follows . in general",
    ", a terminal in @xmath61 can have rank ( label ) arbitrarily larger than @xmath26 .",
    "the algorithm explicitly maintains the ranks and depths of the @xmath26 non - terminals in the current tree ; the algorithm compares the ranks of terminals in the priority queues via the ranks and depths of their ( non - terminal ) parents .",
    "when @xmath161}}$ ] or @xmath170}}$ ] changes to reflect a new current tree , the queues are updated by the following routine :    @xmath162   + . if = ( @xmath161 } } \\le { { \\mbox{\\bf w}[{i}]}}$ ] ) then   + . update @xmath159}})}$ ] in   and @xmath168}})}$ ] in   +   to maintain the queues invariants .",
    "else delete both nodes from their respective queues .",
    "line 2 replaces the old @xmath159}})}$ ] in @xmath194 ( @xmath168}})}$ ] in @xmath195 ) by the new one when @xmath161}}$ ] ( @xmath170}}$ ] ) changes .",
    "line 3 will only be executed if @xmath159 } } ) } > { \\mbox{child}_{i}({{\\mbox{\\bf w}[{i}]}})}$ ] , which will only happen if the tree no longer contains any @xmath2th child as a terminal .",
    "note that lemmas [ level lemma ] and [ child lemma ] imply that if , for some @xmath2 and @xmath61 , no non - terminal has an @xmath2th child in @xmath61 , then no non - terminal has an @xmath2th child in @xmath85 .        to construct @xmath142",
    "we assume that @xmath197 otherwise @xmath142 is simply the root and its first @xmath1 children . for @xmath198 ,",
    "define @xmath61 to be the tree with non - terminals @xmath76 and _ all _ of the @xmath199 children of @xmath76 as terminals .",
    "the proof of lemma [ sprout lemma ] generalizes easily to these trees ; node @xmath86 is the minimum terminal of @xmath113     @xmath200   + _create @xmath201 _    + .",
    "@xmath202 @xmath203 } } \\leftarrow 0;$ ] @xmath204   + .",
    "create @xmath205 create @xmath206   + . for",
    "= @xmath207 do   + .",
    "@xmath161 } } \\leftarrow { { \\mbox{\\bf w}[{i } ] } } \\leftarrow 1 $ ] ; @xmath208   +     + _create @xmath209 _",
    "   + . for",
    "= @xmath210 do   + .",
    "let @xmath159}})}$ ] be the minimum terminal in .",
    "+ . @xmath160 } } \\leftarrow { { \\mbox{\\bf d}[{{{\\mbox{\\bf u}[{i}]}}}]}}+{c_{i}}$ ] ; @xmath161 } } \\leftarrow { { \\mbox{\\bf u}[{i } ] } } + 1 $ ] ; @xmath208   + .",
    "for = @xmath211 do   + .",
    "@xmath212 } } \\leftarrow { \\mbox{\\bf m}}$ ] ; @xmath213   + . @xmath214 } }                           + \\sum_{j=1}^r ( { { \\mbox{\\bf d}[{{\\mbox{\\bf m } } } ] } } + { c_{j}});$ ]   +    + _create @xmath142 _",
    "@xmath215 @xmath216   + . let @xmath159}})}$ ] be the minimum terminal in .",
    "+ . @xmath160 } } \\leftarrow { { \\mbox{\\bf d}[{{{\\mbox{\\bf u}[{i}]}}}]}}+{c_{i}}$ ] ; @xmath161 } } \\leftarrow { { \\mbox{\\bf u}[{i } ] } } + 1 $ ] ; @xmath162   + . for = @xmath217",
    "@xmath212 } } \\leftarrow { \\mbox{\\bf m}}$ ] ; @xmath213   + . @xmath214 } }                    + \\sum_{j=1}^\\delta ( { { \\mbox{\\bf d}[{{\\mbox{\\bf m } } } ] } } + { c_{j}});$ ]   + . @xmath218   + .",
    "@xmath219    the tree @xmath201 is easy to construct .",
    "it is the tree with @xmath68 root and @xmath0 children .",
    "inductively construct the tree @xmath139 from the tree @xmath220 @xmath221 as follows : find the minimum terminal in @xmath61 by taking the minimum terminal out of @xmath222 label this node @xmath223 make it a non - terminal , and add all of its children to @xmath139 as terminals .",
    "the details are shown in fig .",
    "[ create first ] .",
    "finally , construct @xmath142 from @xmath224 by making the lowest terminal of @xmath224 into node @xmath225 add the @xmath226 minimum children of node @xmath227 as terminals bringing the total number of terminals in the current tree to @xmath228 level the resulting tree .",
    "since only @xmath229 trees are constructed while computing @xmath142 and each tree can be constructed from the previous tree in @xmath230 time , the time required to compute @xmath142 is @xmath111 .",
    "( if desired , the time for each tree @xmath61 with @xmath231 can be reduced to @xmath132 , because maximum terminals are not replaced in constructing such a tree . )",
    "the algorithm constructs the sequence of trees @xmath143 as described previously .",
    "tree @xmath139 is found by ing and then ing its predecessor @xmath232 the cost is @xmath233 time , where @xmath115 is the number of children of the new non - terminal @xmath26 in @xmath113 by lemma [ dm bound lemma ] this part of the algorithm runs in @xmath234 time .",
    "_ acknowledgements : _ the authors would like to thank dr .",
    "jacob ecco for introducing us to the morse code puzzle which sparked this investigation .",
    "they would also like to thank siu ngan choi and rudolf fleischer ( who made observation [ unimodality ]  the unimodality of the tree costs ) for their careful reading of an earlier manuscript and subsequent comments ."
  ],
  "abstract_text": [
    "<S> we consider the following variant of huffman coding in which the costs of the letters , rather than the probabilities of the words , are non - uniform : `` given an alphabet of @xmath0 letters _ of non - uniform length _ , find a minimum - average - length prefix - free set of @xmath1 codewords over the alphabet ; '' equivalently , `` find an optimal @xmath0-ary search tree with @xmath1 leaves , where each leaf is accessed with equal probability but the cost to descend from a parent to its @xmath2th child depends on @xmath2 . '' </S>",
    "<S> we show new structural properties of such codes , leading to an @xmath3-time algorithm for finding them . </S>",
    "<S> this new algorithm is simpler and faster than the best previously known @xmath4-time algorithm due to perl , garey , and even .    </S>",
    "<S> algorithms , huffman codes , prefix codes , trees .    </S>",
    "<S> analysis of algorithms . </S>"
  ]
}