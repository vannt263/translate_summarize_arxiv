{
  "article_text": [
    "we present a ga which is distributed in two novel ways : along genotype and temporal axes .",
    "in contrast to a conventional ga spatially distributed on the population axis , our doubly distributed algorithm first distributes , _ for every member of the population _ , a _ subset of the genotype _ to each network node rather than a subset of the population to each .",
    "the motivation for this genotype axis of distribution is to distribute the fitness evaluation steps of the network coding ga ( ncga ) @xcite which relies on network codes generated randomly and in a decentralized manner .",
    "self - referentially , the ga solving the network coding problem must be embedded in the same network for which it is searching for the optimal coding . with just this axis of distribution ,",
    "the distributed ncga equals the performance of the ( centralized ) ncga in terms of solution quality .",
    "however , as experiments herein suggest , it can lead to a significant gain in running time .",
    "the motivation for the second axis of distribution is to maximize the efficient use of the computational nodes in the network by minimizing their idle duration during the ga search . along this second , temporal axis of distribution , successive sets of candidate solutions",
    "are pipelined through the network , from source to sinks and back .",
    "a time lag is incurred as the selected candidate travels through the network to undergo variation and fitness evaluation before it is inserted back into the population .",
    "this creates an age gap between the population from which a candidate solution is selected and the population into which it is inserted and leads to the question of how _ selection _ and _ replacement _ in the doubly distributed ga should proceed .",
    "the approach that is least efficient in terms of time , treats multiple pipelined sets of candidates as components of a single population that proceeds in an age - synchronized , generational style for selection and replacement .",
    "it sends pipelined sets of selected candidates through the network but waits until every set has emerged back out before replacing any of them .",
    "we show that this approach , which we term `` generational / single population , '' incurs a cost of priming and flushing the pipeline but is faster than not pipelining at all .    to avoid intermittently flushing the pipeline and then needing to prime it again",
    ", our first approach is to divide the population into a number of subpopulations and insert selected then genetically varied individuals back into the same subpopulation they were selected from . migration between sub - populations occurs at some specified frequency regardless of a slight age difference which maintains close temporal consistency .",
    "we call this approach `` generational / multi - population . ''",
    "alternatively , we can be intentionally `` sloppy '' and forgo any temporal consistency .",
    "much like a steady state ga , a single population is steadily updated .",
    "however , unlike a steady state ga , regardless of the time gap ( between when a candidate is selected , genetically varied , then evaluated for fitness and when an attempt is made to insert it into the population ) , insertion simply proceeds with the current population as new candidates emerge processed from the network .",
    "in addition to yielding a simple algorithm , the `` temporally sloppy '' approach crudely approximates the asynchronously timed selection , reproduction and replacement events of a naturally evolving population .",
    "we dub this `` non - generational / single population . ''",
    "pipelining increases the number of evaluations per time unit .",
    "the generational / multi - population and generational/ single population approaches are constrained to respect age synchrony between selection and replacement .",
    "but the non - generational / single population approach does not and , therefore , will have different and as yet unexplored dynamics .",
    "will it converge with more or less fitness evaluations ?",
    "does the efficiency of pipelining produce a faster time to convergence ?",
    "will it find quality solutions ?",
    "we explore these questions in the experiments .",
    "though the proposed algorithm is discussed in the context of network coding , the contributions of this paper are not limited within that scope .",
    "1 ) a genetic algorithm with the proposed two novel methods of distribution can be readily applied to a variety of other optimization scenarios arising in communication networks ( e.g. , routing , resource allocation , etc . ) or other connected systems where local decision variables are to be specified for the optimal performance of the whole system .",
    "2 ) furthermore , the proposed framework of temporal axis distribution can be combined with , not only the pipelining methods considered in this paper , a fairly general class of state - of - the - art strategies for parallel management of populations and communication between populations ( e.g. , @xcite ) , because it imposes essentially no constraint on the implementation of any such strategies except that there is slight temporal inconsistency between populations , which as shown in this paper may also have little effect to other strategies .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : nwcoding ] describes and formulates the network coding problem .",
    "section  [ sec : ncga ] describes the ncga which serves as a baseline .",
    "section  [ sec : disthorizontal ] motivates and describes distributing the ncga along the genotype axis .",
    "section  [ sec : distvertical ] motivates the distribution along the temporal axis and describes three pipelined approaches .",
    "section  [ sec : exp ] experimentally quantifies the advantage of distribution on the genotype axis and compares the pipelined approaches .",
    "section [ sec : con ] concludes .",
    "network coding is a novel technique that generalizes routing . in traditional routing , each interior network node , which is not a source or sink node , simply forwards the received data or sends out multiple copies of it .",
    "in contrast , network coding allows interior network nodes to perform arbitrary mathematical operations , e.g. , summation or subtraction , to combine the data received from different links .",
    "it is well known that network throughput can be significantly increased by network coding @xcite . while network coding is assumed to be done at all possible nodes in most of the network coding literature",
    ", it is often the case that network coding is required only at a subset of nodes to achieve the desired throughput .",
    "consider example 1 :    in the canonical example of network @xmath0 ( figure [ fig : bf ] ) @xcite , where each link has unit capacity , source @xmath1 can send 2 units of data simultaneously to sinks @xmath2 and @xmath3 , which is not possible with routing alone . but",
    "only node @xmath4 needs to combine its two inputs while all other nodes perform routing only . if we suppose that link @xmath5 in network @xmath0 has capacity 2 , which we represent by two parallel unit - capacity links in network @xmath6 ( figure [ fig : bf2 ] ) , a multicast of rate 2 is possible without network coding . in network",
    "@xmath7 ( figure [ fig : corr ] ) , where node @xmath1 is to transmit data at rate 2 to the 3 leaf nodes , network coding is required either at node @xmath8 or at node @xmath9 , but not at both . @xmath10",
    "[ ex : intro ]    [ fig : sample ]    example [ ex : intro ] leads us to the following question : to achieve the desired throughput , at which nodes does network coding need to occur ?",
    "the problem of determining a minimal set of nodes where coding is required is np - hard ; its decision problem , which decides whether the given multicast rate is achievable without coding , reduces to a multiple steiner subgraph problem , which is np - hard  @xcite . for a ga",
    ", the problem can be posed as the minimization of coding cost ( in links or nodes ) subject to the constraint of feasibility ( achieving the desired throughput ) .",
    "we assume that a network is given by a directed multigraph @xmath11 as in @xcite where each link has a unit capacity whose unit can be arbitrarily chosen , e.g. , @xmath12 bits per second for a constant @xmath12 , or a fixed size packet per unit time , etc .",
    "links with larger capacities are represented by multiple links .",
    "only integer flows are allowed , hence there is either no flow or a unit rate of flow on each link .",
    "we consider the single multicast scenario in which a single source @xmath13 wishes to transmit data at rate @xmath14 to a set @xmath15 of sink nodes .",
    "rate @xmath14 is said to be achievable if there exists a transmission scheme that enables all @xmath16 sinks to receive all of the information sent .",
    "we only consider linear coding , where a node s output on an outgoing link is a linear combination of the inputs from its incoming links .",
    "linear coding is sufficient for multicast @xcite .    given an achievable rate @xmath14 , we wish to determine a minimal set of nodes where coding is required in order to achieve this rate .",
    "however , whether coding is necessary at a node is determined by whether coding is necessary at at least one of the node s outgoing links and thus , as pointed out also in @xcite , the number of coding links is in fact a more accurate estimator of the amount of computation incurred by coding .",
    "we assume hereafter that our objective is to minimize the number of coding _",
    "links _ rather than _",
    "nodes_.    it is clear that no coding is required at a node with only a single input since these nodes have nothing to combine with @xcite . for a node with multiple incoming links , which we refer to as a _ merging node _",
    ", if the linearly coded output to a particular outgoing link weights all but one incoming message by zero , effectively no coding occurs on that link ; even if the only nonzero coefficient is not identity , there is another coding scheme that replaces the coefficient by identity @xcite .",
    "thus , to determine whether coding is necessary at an outgoing link of a merging node , we need to verify whether we can constrain the output of the link to depend on a single input without destroying the achievability of the given rate . as in network @xmath7 of example",
    "[ ex : intro ] , the necessity of coding at a link depends on which other links code and thus the problem of deciding where to perform network coding in general involves a selection out of exponentially many possible choices . employing a ga - based search method",
    "efficiently addresses the large and exponentially scaling size of the space .",
    "in the network research community , @xcite and @xcite have documented results that demonstrate the benefit of the ncga over other existing approaches in terms of reducing the number of coding links or nodes and its applicability to a variety of generalized scenarios . in the ga community , @xcite has investigated two different genotype encodings and associated operators .",
    "reference @xcite s main finding is that the encoding and the genetic operators that respect the block structure of the problem , which will be detailed later , substantially outperforms those do not .",
    "it is also claimed that such superior performance is mainly due to the modularity enforced by the block - wise genetic operators .",
    "we first describe the elements of the ncga that uses a standard generation - based ga control loop with centralized operations .",
    "this centralized ncga , which we refer to as  * algorithm a * , \" serves as a baseline approach in comparison with the distributed versions of the algorithm , which share the ga elements introduced in this section .",
    "suppose a merging node with @xmath17 incoming links . to consider the transmission to _ each _ of its outgoing links , we assign a binary variable to each of its @xmath18 incoming links ,",
    "whose being 1 indicates that the link state is _ active _ ( the input from the associated incoming link is transmitted to the outgoing link ) and 0 indicates it is _ inactive_. given that network coding is required for the transmission only if two or more link states are active , we may need to consider those @xmath18 variables together .",
    "we refer to the set of the @xmath18 variables as a _ block _ of length @xmath18 ( see figure [ fig : block ] for an example ) .",
    "[ fig : block ]    we notice that once a block has at least two 1 s , coding is already required on the outgoing link associated with that block , and thus replacing all the remaining 0 s with 1 s has no effect on whether coding is done .",
    "moreover , it can be shown that substituting 0 with 1 , as opposed to substituting 1 with 0 , does not hurt the feasibility .",
    "therefore , for a feasible genotype ( which is defined below ) , any block with two or more 1 s can be treated the same as the block with all 1 s .",
    "thus we could group all the states with two or more active links into a single state , _ coded _ transmission .",
    "this state is rounded out by @xmath18 states for the _ uncoded _ transmissions of the input received from one of the @xmath18 single incoming links and one state indicating _ no _ transmission .",
    "thus , each block of length @xmath18 can only take one of the following @xmath19 strings : @xmath20 , @xmath21 , @xmath22 , @xmath23 , @xmath24 , @xmath25 , @xmath26 .",
    "if we denote by @xmath27 and @xmath28 the in - degree and the out - degree of node @xmath29 , node @xmath29 has @xmath28 blocks of length @xmath27 , and thus we have the search space of size @xmath30 , where @xmath31 is the set of all merging nodes .",
    "a genotype is called _ feasible _ if there exists a network coding scheme that achieves the given rate @xmath14 with the link states determined by the genotype . for the feasibility test of a genotype , we rely on the algebraic method described in @xcite , which later enables a distributed feasibility test .",
    "given the feasibility of genotype @xmath32 , its fitness value @xmath33 is assigned as @xmath34 where the number of coding links can be easily calculated by counting the number of blocks in the genotype with at least two @xmath35 s .      to preserve the above encoding structure , we need to define a new set of genetic operators , which we refer to as _ block - wise _ genetic operators .",
    "for block - wise uniform crossover , we let two genotypes subject to crossover exchange each block , rather than bit , independently with the given crossover probability . for block - wise mutation , we let each block under mutation take another string chosen uniformly at random out of @xmath36 other strings for a length-@xmath18 block .",
    "the ncga evaluates fitness in a multi - step way : 1 ) each merging node consults the corresponding genotype blocks to compute _ random _ linear combinations of the inputs , 2 ) alternately routed messages reach the sinks , 3 ) the feasibility of the genotype is assessed at the sinks , 4 ) if feasible , the coding links are counted .",
    "the ncga uses tournament selection and terminates at some maximum number of generations .",
    "afterward , the best solution of the run is optimized with _ greedy sweep _ :",
    "each of the remaining 1 s is switched to 0 if it can be done without violating feasibility .",
    "this procedure can only improve the solution , and sometimes the improvement can be substantial @xcite .",
    "decentralizing the ncga enables a network coding protocol where the resources used for coding are optimized on the fly in a setup phase . plus , distribution reduces the computational efficiency of the algebraic feasibility test ( see section [ sec : complexity ] for details ) .",
    "we refer to this genotype(only)-distributed ncga as  * algorithm b*. \"      because of the way network coding depends on each merging node contributing to the coding , and because each merging node references its corresponding block on a genotype , the appropriate way to distribute the ncga is to have each node handle only the blocks it needs from every member of the population .",
    "so , instead of dividing up the population and giving each island a subset of genotypes , we divide up the genotype of every population member and give each merging node a population wide set of that genotype subset .",
    "thus , in contrast to a conventional distributed ga , the axis of distribution is genotype rather than population as illustrated in figure [ fig : popstructure ] .",
    "the previously centralized fitness evaluation steps are transformed into : 1 ) forward evaluation stage from merging nodes to each sink 2 ) backward evaluation stage from sinks to source and 3 ) fitness calculation at the source . with some amount of additional message information and coordination ,",
    "all genetic operations can be done locally at each merging node .",
    "see figure  [ fig : distributed ] for the overall structure .",
    "while we assume that each link can transmit one packet with the fixed size , say @xmath12 bits , per time unit in the given direction , each link is also assumed to be able to send some amount of feedback data , typically much smaller than the packet size , in the _ reverse _ direction .",
    "also , we assume that each interior node operates in a burst - oriented mode ; i.e. , for the forward ( backward ) evaluation phase , each node starts updating its output only after an updated input has been received from all incoming ( outgoing ) links .",
    "the source initiates the algorithm by transmitting the  optimize \" signal containing the following predetermined parameters : target multicast rate @xmath14 , population size @xmath37 , the size @xmath38 of the finite field to be used , crossover probability , and mutation rate .",
    "each participating node that has received the signal passes the signal to its downstream nodes .",
    "each merging node with @xmath39 incoming links will manage a _ coding vector _ indicating the link states per population member . to initialize its subset of the population ,",
    "each merging node generates @xmath40 binary numbers randomly .",
    "then , for the coding vectors corresponding to the first of the @xmath37 chromosomes , all the components are set to 1 @xcite .      for the feasibility test of a chromosome ,",
    "each node transmits a vector consisting of @xmath14 components , which we refer to as a _ pilot vector_. each of its the components is from the finite field @xmath41 and the @xmath42-th component represents the coefficient used to encode the @xmath42-th source data .",
    "we assume that a set of @xmath37 pilot vectors is transmitted together by a single packet .",
    "the source initiates the forward evaluation phase by sending out on each of its outgoing links a set of @xmath37 random pilot vectors .",
    "each non - merging node simply forwards all the pilot vectors received from its incoming link to all its outgoing links .",
    "each merging node transmits on each of its outgoing links a random linear combination of the received pilot vectors , computed based on the node s coding vectors as follows .",
    "let us consider a particular outgoing link and denote the associated @xmath43 coding vectors by @xmath44 , @xmath45 , ... , @xmath46 . for the @xmath42-th ( @xmath47 ) output pilot vector @xmath48 , we denote the @xmath42-th input pilot vectors received form the incoming links by @xmath49 , @xmath50 , ... , @xmath51 .",
    "define the set @xmath52 of indices as @xmath53 then , @xmath54 where rand@xmath55 denotes a random element from @xmath41 .",
    "if the set @xmath52 is empty , @xmath48 is assumed to be zero .      to calculate a chromosome s fitness value ,",
    "two kinds of information need to be gathered : 1 ) whether each sink can decode data of rate @xmath14 and 2 ) how many links are used for coding at each merging node . each sink can determine whether data of rate @xmath14 is decodable for each of the @xmath37 chromosomes by computing the rank of the collection of received pilot vectors .",
    "it is worth to point out that this is the same algebraic evaluation method described in @xcite , but",
    "the difference is that , rather than computing the system matrix with randomized elements centrally , now we actually construct random linear codes over the network in a decentralized fashion .",
    "hence , this feasibility test also bears the same , but uncritical , possibility of errors as in the centralized case .",
    "regarding the number of coding links , each merging node can simply count the number links where coding is required by inspecting its coding vectors used in the forward evaluation phase .    for the feedback of this information , each node transmits a vector consisting of @xmath37 components , which is referred to as a _ fitness",
    "vector_. the backward evaluation phase proceeds as follows :    1 .   after the feasibility tests of the @xmath37 chromosomes are done , each sink generates a fitness vector whose @xmath42-th ( @xmath47 ) component is zero if the @xmath42-th chromosome is feasible at the sink , and infinity otherwise .",
    "each sink then initiates the backward evaluation phase by transmitting its fitness vector to all of its parents .",
    "2 .   each interior node calculates its own fitness vector whose @xmath42-th ( @xmath47 ) component is the number of coding links at the node for the @xmath42-th chromosome plus the sum of all the @xmath42-th components of the received fitness vectors .",
    "each node then transmits the calculated fitness vector to _ only one _ of its parents , and an all - zero fitness vector ( for just signaling ) to the other parent nodes .",
    "note that , since the network is assumed to be acyclic , each coding link of a chromosome contributes exactly once to the corresponding component of the source node s fitness vector , and thus the above update procedure provides the source with the correct total number of coding links .",
    "the source calculates the fitness values of @xmath37 chromosomes simply by component - wise summation of the received fitness vectors .",
    "note that if an infinity were generated by _ any _ of the sinks , it should dominate the summations all the way up to the source , and thus the source can calculate the correct fitness value for the infeasible chromosome .",
    "the source can determine when to terminate the optimization by counting the number of generations iterated thus far .",
    "since the population is divided into subsets that are managed at the merging nodes , genetic operations also need to be done locally at the merging nodes .",
    "however , some amount of coordination is required for consistent genetic operations throughout all the merging nodes , more specifically , for 1 ) selection of chromosomes , 2 ) paring of chromosomes for crossover , and 3 ) whether each pair is subject to crossover .",
    "this information is carried by a _ coordination vector _ , calculated at the source , consisting of the indices of selected chromosomes that are randomly paired and 1-bit data for each pair indicating whether the pair needs to be crossed over .",
    "the coordination vector is _ transmitted together with _",
    "the pilot vectors in the next forward evaluation phase .      based on the received coordination vector ,",
    "each merging node can locally perform genetic operations and renew its portion of the population as follows :    1 .   for selection",
    ", each node only retains the coding vectors that correspond to the indices of selected chromosomes . 2 .",
    "for block - wise crossover , each node independently determines whether each block is crossed over .",
    "since no block is shared by multiple merging nodes , this can be done independently at each merging node .",
    "3 .   for block",
    "- wise mutation , each node independently determines whether each block is mutated without any coordination with other nodes either .",
    "greedy sweep requires an additional protocol where , after the iteration terminates , the source is notified of the merging nodes with at least one coding link , for each of which the source sends out a packet to test if uncoded transmission is possible on the link(s ) where currently coding is required .",
    "since this additional protocol requires more extensive coordination between nodes , we may leave this procedure optional , whose detailed description is omitted owing to space limitations .      the computational complexity required for evaluation of a single chromosome",
    "is @xmath56 , which can be substantially less than that for the centralized version of the algorithm , i.e. , @xmath57 or @xmath58 @xcite .",
    "a unique characteristic of the genotype - distributed ncga is that once each generation is initiated at the source ( procedure [ p7 ] in figure [ fig : distributed ] ) , the fitness values of @xmath37 genotypes become only available after the forward and backward evaluation phases are done , i.e. , when the last fitness vector arrives at the source .",
    "let us assume that the time required for each node to calculate its outgoing pilot vectors based on the received ones is negligible compared with the time required for packet transmissions . then , if we denote by @xmath59 the length of the longest path from the source to any of the sinks , the time lag between the initiation of the generation and the termination of the backward evaluation phase is @xmath60 time units ( see figure [ fig : baseline ] ) .",
    "let us now define the _ evaluation efficiency _ , which we denote by @xmath61 , as the number of fitness evaluations performed per unit time throughout the iteration of the ga .",
    "then , for algorithm b(genotype(only)-distributed ncga ) , @xmath61 is only @xmath62 .    for better efficiency , we may still utilize the network resources , while waiting for the fitness vectors to return to the source , to evaluate more genotypes .",
    "suppose that , after initiating the forward evaluation phase of the @xmath63-th generation at time @xmath64 , we initiate additional @xmath65 forward evaluation phases at times @xmath66 , ... , @xmath67 .",
    "when @xmath68 , the network resources become fully utilized by the time when the fitness values of the first set of @xmath37 genotypes are available .",
    "note that in fact @xmath18 may even exceed @xmath60 , but then the evaluation of the @xmath69-th generation starts delayed at time @xmath70 , rather than @xmath71 . for simplicity ,",
    "we assume @xmath72 in the following .",
    "if we consider the @xmath18 sets of @xmath37 genotypes as a single population , we have to wait additional @xmath65 time units , after the first backward evaluation phase ends ( at time @xmath71 ) , to proceed to the next generation .",
    "in other words , we must flush the pipeline ( and prime it again ) .",
    "hence , the evaluation efficiency is given by @xmath73 whose maximum is obtained when @xmath68 such that @xmath74 . for later comparison , we refer to this algorithm with @xmath68 as  * algorithm c*. \"    avoiding the inefficiency of flushing the pipeline would generate a better @xmath61 and consequently faster convergence , provided that the algorithm requires a similar number of evaluations for the solutions of the same quality .",
    "depending on how to manage those @xmath18 sets of @xmath37 genotypes , we may consider two different approaches as follows .",
    "in this approach , referred to as  * algorithm d * , \" we regard each of those @xmath18 sets of @xmath37 genotypes as a _ subpopulation _ which occasionally exchanges individuals with other subpopulations .",
    "it is worth to point out that , unlike typical island parallel gas @xcite where subpopulations are _ spatially _ distributed over different locations of computation , we have subpopulations that are _ temporally _ distributed over different times of evaluation .",
    "we assume that migration is done at every @xmath75 generations such that , before selection , each subpopulation replaces its worst @xmath65 individuals with the collection of @xmath65 individuals , one from each of the other @xmath65 subpopulations . since we have no constraint on the ( spatial ) connections between the subpopulations , we can freely choose to assume and exploit the complete connectivity between subpopulations .",
    "on the other hand , our algorithm imposes a different kind of constraint on migration , which is regarding the time synchronization between subpopulations .",
    "let us assume that there is no delay in the network , so the backward evaluation phase of a particular subpopulation ends exactly after @xmath60 time units its forward evaluation phase started .",
    "suppose now that migration is about to happen at time @xmath66 while constructing the first subpopulation for the @xmath69-th generation .",
    "at that time , only the first subpopulation has the fitness values for the @xmath63-th generation , while all other @xmath65 subpopulations still wait for their fitness values for the @xmath63-th generation to become available .",
    "similarly , at time @xmath76 @xmath77 , only the first @xmath78 subpopulations have their fitness values for the @xmath63-th generation , while the remaining @xmath79 subpopulations do not . if we choose to perform migration in a _ age - synchronized _",
    ", i.e. , _ temporally consistent _ manner such that all the subpopulations exchange the best individuals of the _ same _ generation , we have to wait until time @xmath70 without being able to renew any subpopulation .",
    "hence , we alternatively perform the _ age - mixed _ , i.e. , _ temporally closely consistent _ , migration , where we collect the best individuals from the other @xmath65 subpopulations of the _ most recent _ generation for which the fitness values are available .",
    "for instance , when we renew the @xmath78-th @xmath80 subpopulation at time @xmath76 , we take the best individual from each of the @xmath81-th subpopulations at generation @xmath63 , and from each of the @xmath82-th subpopulations at generation @xmath83 .",
    "algorithm d proceeds in a completely pipelined manner ( see figure [ fig : parallel ] ) , yielding the evaluation efficiency @xmath84 where @xmath85 is the number of generations at the termination of the iteration . note that , when @xmath68 and @xmath86 , @xmath87 .",
    "note that most changes in algorithm d , compared with the genotype - distributed ncga in section [ sec : disthorizontal ] , are regarding the computational aspects at the source .",
    "hence , algorithm d can be implemented within the same framework the genotype - distributed ncga , with slight changes in the structure of the coordination vector and the increased number of coding vectors that each merging node keeps .",
    "owing to space limits , further implementational details are omitted .          rather than managing @xmath18 separate subpopulations , this approach , referred to as  * algorithm e * , \" operates on a single population of size @xmath88 .",
    "the population is updated when the fitness values of each of the @xmath18 sets of @xmath37 genotypes , referred to as _ offspring _",
    ", become available ( i.e. , `` just - in - time '' ) .",
    "this is a temporally  sloppy  approach . from time 1 to @xmath18 ,",
    "the forward evaluation phases for the initial ( random ) @xmath18 offspring are initiated . at time",
    "@xmath89 @xmath77 , the fitness values for the @xmath78-th offspring can be calculated at the source and _ all _ those @xmath37 genotypes are just added to the population .",
    "we then calculate the coordination vector for the @xmath78-th offspring , by performing tournament selection out of the current population , which is partially filled until time @xmath90 , and initiate the forward evaluation phase for the second generation . at time",
    "@xmath91 @xmath77 and on , we update the population as follows : first combine the @xmath78-th offspring , whose fitness values are just calculated , with the existing population , and then pick the best @xmath92 individuals , out of those @xmath93 individuals , to form the updated population .    considering each window of @xmath60 time units from the beginning , we notice that except for the first and the last windows , @xmath92 genotypes are evaluated in each window ( see figure [ fig : ss ] ) . hence , if we assume that the total number of elapsed time units is large ( @xmath94 ) , we have @xmath95 , and when @xmath68 , we obtain the maximum @xmath87 .",
    "algorithm e can also be implemented similarly to the genotype - distributed ncga with some changes in the coordination and coding vectors , whose details are omitted .",
    "since the genotype - distributed ncga ( algorithm b ) shares the same computational part of ga with the centralized one ( algorithm a ) , the two algorithms show the same performance in terms of solution quality .",
    "however , as described in section [ sec : complexity ] , the computational complexity required by algorithm b depends only on local topological parameters , which can often lead to a significant gain in terms of the running time . to compare the elapsed running time of the two algorithms , we run a test on a created set of topologies with high connectivity such that there exists a link between each pair of numbered nodes @xmath42 and @xmath78 ( @xmath96 ) , where the source is node 1 and the sinks are the last 10 nodes .",
    "the test is done by a simulation on a single machine while each node s function is performed by a separate thread , thus it is pessimistic since it can not benefit from the multi - processing gain whereas it only suffers from additional computational burdens for managing a number of threads .",
    "table [ tab : eval3 ] shows that , nevertheless , algorithm b exhibits an advantage in running time as the size of the network grows .      to compare the doubly distributed approaches , we construct network @xmath97 by cascading 15 copies of network @xmath6 in example [ ex : intro](figure [ fig : bf2 ] ) in the form of a depth-4 binary tree such that the source of each subsequent copy of @xmath6 is replaced by an earlier copy s sink .",
    "the source is the tree s root node and the sinks are the 16 leaf nodes . setting @xmath12 , the unit packet size , to 1500 bytes as a typical ethernet packet",
    ", we can calculate that @xmath37 , the number of genotypes handled by a single packet , is around 200 . since @xmath98 in network @xmath97 , @xmath99 .",
    "table [ tab : popparams ] summarizes the parameters for five algorithms we experiment with .",
    "migration frequency ( @xmath75 ) is changed from 10 to 1 from algorithm d@xmath100 to d@xmath101 .",
    "we set the tournament size to the half of the ( sub)population size in each algorithm , i.e. , 100 , 3200 , 100 , 3200 for algorithms b , c , d , e , respectively .",
    "the mixing ratio and the crossover probability are both 0.8 and the mutation rate is 0.015 for all algorithms .",
    "we perform 30 runs for each algorithm until the algorithm converges to the optimal solution , which for network @xmath97 is known to be zero .",
    "table [ tab : result ] shows the elapsed time units with the _ time efficiency _ @xmath102 , which we define as the algorithm s speedup with respect to algorithm b , and the total number of evaluations with the evaluation efficiency @xmath61 obtained from the experiments , which indeed matches the theoretical values almost exactly . for elapsed time and number of evaluations , p - value resulting from paired t - test with the next best ( i , e . , smallest )",
    "one is reported .",
    "pipelining is intended to be efficient by reducing the idle time of network nodes , hence algorithm b , which does not pipeline , has the lowest @xmath61 .",
    "though algorithm c , which pipelines but stop to flush and re - prime , has much increased @xmath61 , algorithms d@xmath100 , d@xmath103 , and e , which operate fully pipelined , offer the highest @xmath61 . note , however , that the different dynamics of these algorithms may impact the number of fitness evaluations required to reach the optimal solution , hence as can be observed in table [ tab : result ] , the number of evaluations ( and consequently , the realized @xmath102 ) do not reveal @xmath61 in proportion .",
    "figure [ fig : tradeoff ] shows that evaluation efficiency comes at the cost of additional fitness evaluations .",
    "algorithms d@xmath100 and b dominate all others yet not each other ; algorithm b is less efficient ( it does not pipeline ) but requires less fitness evaluations , while d@xmath100 is more efficient but requires more evaluations .",
    "algorithm d@xmath100 gives a speedup ( @xmath102 ) of more than 5 times over algorithm b. algorithms c , d@xmath101 and e , though dominated by d@xmath100 , still offer higher @xmath102 than b. these algorithms thus merit additional investigation because they may give better performance for different network topologies or other problems .",
    "algorithms d@xmath101 and d@xmath100 , though distributed temporally , resemble a spatially distributed ga ( referred to as multiple - deme ga in @xcite ) in that they incur no communication overhead and can assume a fully - connected processor topology .",
    "the only difference in algorithm dynamics is that migration takes place between sub - populations that differ in age by one generation ( see section 5.2 ) .",
    "thus the performances of d@xmath101 and d@xmath100 as compared to b are in fact foreseeable from the observation that , in general , multiple - deme gas require a greater number of evaluations than a standard ga while offering speedups due to parallelism , which is equivalent to higher @xmath61 .",
    "however , in our experiments , the size and the number of subpopulations are determined to maximize @xmath61 rather than the performance of ga .",
    "determining the migration strategy for multiple - gas is an open question and probably problem dependent @xcite .",
    "algorithm e is a completely new algorithm , where the selection from the population and the replacement of offsprings are temporally inconsistent . a ( slightly ) similar property can be found in the second prototype for parallel ga in @xcite , where the algorithm sends out individuals to processors to be evaluated , and inserts and re - selects them opportunistically , i.e. , when their fitness becomes available .",
    "such , rather radical , changes in algorithm dynamics may raise a question whether algorithm e would even work , which is verified by our experiments .",
    "the performance of @xmath104 is similar to that of d@xmath101 , hence surpassed by d@xmath100 , which can be explained by the observation that the temporal mixing of e is similar to d@xmath101 s frequent mixing .",
    "together , these two results suggest that the doubly distributed ga is robust to age mixing ( i.e. , temporal sloppiness ) , which deserves further in - depth analysis in the future .",
    "we have presented a ga which is distributed in two novel ways : along genotype and temporal axes . in order to distribute the fitness evaluation for the network coding problem ,",
    "our doubly distributed algorithm first distributes , for every member of the population , a subset of the genotype to each network node rather than a subset of the population to each . to maximize the efficient use of the computational nodes in the network ,",
    "the second axis divides the candidate solutions into pipelined sets and thus the distribution is in the temporal domain , rather that in the spatial domain .",
    "we have found that this temporal distribution may lead to temporal inconsistency in selection and replacement , however our experiments have yielded better efficiency in terms of the time to convergence without incurring significant penalties ."
  ],
  "abstract_text": [
    "<S> we present a genetic algorithm which is distributed in two novel ways : along genotype and temporal axes . </S>",
    "<S> our algorithm first distributes , for every member of the population , a subset of the genotype to each network node , rather than a subset of the population to each . </S>",
    "<S> this genotype distribution is shown to offer a significant gain in running time . </S>",
    "<S> then , for efficient use of the computational resources in the network , our algorithm divides the candidate solutions into pipelined sets and thus the distribution is in the temporal domain , rather that in the spatial domain . </S>",
    "<S> this temporal distribution may lead to temporal inconsistency in selection and replacement , however our experiments yield better efficiency in terms of the time to convergence without incurring significant penalties .    </S>",
    "<S> * categories and subject descriptors : * c.2.1 [ computer - communication networks ] : network architecture and design    * general terms : * algorithms    * keywords : * distributed genetic algorithm , network coding , optimization </S>"
  ]
}