{
  "article_text": [
    "ptimal prefix - free coding , or _",
    "huffman coding _ , is a standard compression technique .",
    "encoding alphabet _ @xmath3 , a _ code _ is just a set of words in @xmath4 given @xmath5 probabilities or nonnegative frequencies @xmath6 , and associated code @xmath7 the _ cost _ of the code is @xmath8 where @xmath9 denotes the length of @xmath10 .",
    "a code is _ prefix - free _ if no codeword @xmath10 is a prefix of any other codeword @xmath11 .",
    "optimal _ prefix - free code for @xmath6 is a prefix - free code that minimizes its cost among all prefix - free codes .    in @xcite ,",
    "huffman gave the now classical @xmath12 time algorithm for solving this problem .",
    "if the @xmath13 s are given in sorted order , huffman s algorithm can be improved to @xmath14 time @xcite . in this note",
    "we will always assume that the @xmath13 s are presorted and that @xmath15 .    in some applications , it is desirable that the length of all code words are bounded by a constant , i.e. , @xmath16 where @xmath17 is given .",
    "the problem of finding the minimal cost prefix - free code among all codes satisfying this length constraint is the _ length - limited huffman coding _ ( llhc ) problem , which we will consider here . fig .",
    "[ fig : seq_ex ] gives an example of inputs for which the huffman code is _ not _ the same as the length - limited huffman code .",
    "the first algorithm for llhc was due to karp @xcite in 1961 ; his algorithm is based on integer linear programming ( ilp ) , which , using standard ilp solving techniques , leads to an exponential time algorithm .",
    "gilbert @xcite in 1971 was interested in this problem because of the issue of inaccurately known sources ; since the probabilities @xmath13 s are not known precisely , a set of codes with limited length will , in some sense , be `` safe '' .",
    "the algorithm presented in @xcite was an enumeration one and therefore also runs in exponential time . in 1972",
    "hu and tan @xcite developed an @xmath18 time dynamic programming ( dp ) algorithm .",
    "the first polynomial time algorithm , running in @xmath19 time and using @xmath19 space , was presented by garey in 1974 @xcite .",
    "garey s algorithm was based on a dp formulation similar to that developed by knuth for deriving optimal binary search trees in @xcite and hence only works for binary encoding alphabets .",
    "a decade later , larmore @xcite gave an algorithm running in @xmath20 time and using @xmath21 space .",
    "this algorithm is a hybrid of @xcite and @xcite , and therefore also only works for the binary case .",
    "this was finally improved by larmore and hirschberg @xcite who gave a totally different algorithm running in @xmath22 time and using @xmath14 space . in that paper ,",
    "the authors first transform the length - limited huffman coding problem to the _ coin collector s _ problem , a special type of knapsack problem , and then , solve the coin collector s problem by what they name the _ package - merge _ algorithm .",
    "their result is a very clever special case algorithm developed for this specific problem .",
    "theoretically , larmore and hirschberg s result was later superseded for the case if @xmath23 such that @xmath24 , @xmath25 @xmath26 by two algorithms based on the _ parametric search _ paradigm @xcite .",
    "the algorithm by aggarwal , schieber and tokuyama @xcite runs in @xmath27 time and @xmath14 space .",
    "a later improvement by schieber @xcite runs in @xmath28 time and uses @xmath14 space .",
    "these algorithms are very complicated , though , and even for @xmath26 , the larmore - hirschberg one is the one used in practice @xcite . for completeness , we point out that the algorithms of @xcite are all only claimed for the binary ( @xmath29 ) case but they can be extended to work for the non - binary ( @xmath30 case using observations similar to those we provide in appendix [ app : llhcdp ] for the derivation of a dp for the generic @xmath31-ary llhc problem .",
    "shortly after @xcite appeared , larmore and przytycka @xcite , in the context of parallel programming , gave a simple dynamic programming formulation for the binary huffman coding problem .",
    "although their dp was for regular huffman coding and not the llhc problem , we will see that it is quite easy to modify their dp to model the llhc problem .",
    "it is then straightforward to show that their formulation also permits constructing the optimal tree in @xmath32 time by constructing a size @xmath32 dp table .",
    "this is done is section [ sec : dp ] .",
    "this straight dp approach would not be as good as the larmore - hirschberg one , though , because , like many dp algorithms , it requires maintaining the entire dp table to permit backtracking to construct the solution , which would require @xmath32 space .",
    "the main result of this note is the development of a simple technique ( section [ sec : space ] ) that permits reducing the dp space consumption down to @xmath14 , thus matching the larmore - hirschberg performance with a straightforward dp model .",
    "our technique is not restricted to length - limited coding .",
    "it can be used to reduce space from @xmath22 to @xmath33 in a variety of @xmath22 time dps in the literature . in section [ sec : further ] we illustrate with examples from the d - median on a line problem ( placing web proxies on a linear topology network ) @xcite and wireless paging @xcite .",
    "set @xmath34 and @xmath35 for @xmath36 .",
    "larmore and przytycka @xcite formulated the binary huffman coding problem as a dp ( [ eq : lm ] ) where @xmath37 and for @xmath38 : @xmath39 in this dp , @xmath40 is the cost of the optimal huffman code .",
    "another version of this dp , generalized for unequal - cost binary coding alphabets , also appeared in @xcite .",
    "it is straightforward to modify ( [ eq : lm ] ) to model the binary llhc problem .",
    "the resulting dp is @xmath41 where @xmath42 will denote the cost of the optimal length - limited huffman code and @xmath43 in the next subsection we will see an interpretation of this dp ( which also provides an interpretation of ( [ eq : lm ] ) ) . in order to make this note self - contained , a complete derivation of the dp for the @xmath31-ary alphabet case is provided in appendix [ app : llhcdp ] .    as far",
    "as running time is concerned , ( [ eq : lm ] ) appears to a - priori require @xmath44 time to fill in its corresponding dp table .",
    "@xcite used the inherent concavity of @xmath45 to reduce this time down to @xmath14 by transforming the problem to an instance of the concave least weight subsequence ( clws ) problem and using one of the known @xmath14 time algorithms , e.g. , @xcite , for solving that problem .    similarly , ( [ eq : dp_def ] ) appears to a - priori require @xmath46 time to fill in its dp table .",
    "we will see that we may again use the concavity of @xmath45 to reduce this down by an order of magnitude , to @xmath22 by using the smawk algorithm @xcite for finding row - minima of matrices as a subroutine .",
    "unlike the clws algorithms , the smawk one is very simple to code and very efficient implementations are available in different packages , e.g. , @xcite . in the conclusion to this note , after the application of the technique becomes understandable , we will explain why @xcite needed to use the more complicated clws routine to solve the basic dp while we can use the simpler smawk one .",
    "the @xmath22 dp algorithm for solving the llch problem , while seemingly never explicitly stated in the literature , was known as folklore .",
    "even though it is much simpler to implement than the @xmath22 larmore and hirschberg @xcite package - merge algorithm it suffers from the drawback of requiring @xmath32 space .",
    "the main contribution of this note is the observation that its space can be reduced down to @xmath33 making it comparable with package - merge .",
    "note that since , for the llhc problem we may trivially assume @xmath47 , this implies a space requirement of @xmath14 .",
    "furthermore , our space improvement will work not only for the llhc problem but for all dps in form ( [ eq : dp_def ] ) where the @xmath48 satisfy a particular property .",
    "we quickly sketch the meaning of the dp ( [ eq : dp_def ] ) for the binary case .",
    "figures [ fig : seq_ex ] and [ fig : dp_table ] illustrate this sketch . we note that in order to stress the parts important to our analysis , our formalism is a bit different than @xcite . a complete derivation of the dp for the @xmath31-ary case with the appropriate general versions of the lemmas and observations stated below along with their proofs , is provided in appendix [ app : llhcdp ] .",
    "it is standard that there is a @xmath49 correspondence between binary prefix - free code with @xmath5 words and binary tree with @xmath5 leaves .",
    "the set of edges from an internal node to its children are labeled by a * 0 * or * 1*. each leaf corresponds to a code word , which is the concatenation of the characters on the root - to - leaf path .",
    "the cost of the code equals the _ weighted external path length _ of the tree .",
    "so we are really interested in finding a binary tree with minimum weighted external path length .",
    "denote the height of the tree by @xmath50 the bottommost leaves are on level @xmath51 ; the root on level @xmath52 . optimal assignments of the @xmath13 s to the leaves always assign smaller valued @xmath13 s to leaves at lower levels .",
    "a node in a binary tree is _ complete _ if it has two children and a tree is _ complete _ if all of its internal nodes are complete .",
    "a min - cost tree must be complete , so we restrict ourselves to complete trees .",
    "a complete tree @xmath53 of height @xmath52 can be completely represented by a sequence @xmath54 , where @xmath55 denotes the number of internal nodes at levels @xmath56 .",
    "note that , by definition , @xmath57 , @xmath58 . also note that every level must contain at least one internal node so @xmath59 .",
    "finally , it is straightforward ( see appendix [ app : llhcdp ] ) to show that the total number of leaves on level @xmath60 is @xmath61 , so @xmath62 for all @xmath63 . for technical reasons ,",
    "because we will be dealing with trees having height _ at most _ @xmath52 ( but not necessarily _ equal to _ @xmath52 ) , we allow initial padding of the sequence by * 0*s so a sequence representing a tree will be of the form @xmath54 that has the following properties    [ def : valid.list ] sequence @xmath54 is _ valid _ if    * @xmath64 such that @xmath65 , * @xmath66 * @xmath62 for all @xmath67 .",
    "a sequence is _ complete _ if it is valid and @xmath58 .",
    "we can rewrite the cost function for a tree in terms of its complete sequence .",
    "[ lem : eqn : cost.tree ] if complete sequence @xmath54 represents a tree , then the cost of the tree is @xmath68 .",
    "( note that padding complete sequences with initial * 0*s does not change the cost of the sequence . )",
    "we may mechanically extend this cost function to _ all _ valid sequences as follows .",
    "[ def : cost ] for valid @xmath69 , set @xmath70 @xmath71 is _ optimal _ if @xmath72 where the minimum is taken over all length @xmath52 sequences @xmath73 with @xmath74 i.e. , all sequences of the same length that end with the same value .",
    "our goal is to find optimal trees by using the dp to optimize over valid sequences .",
    "an immediate issue is that not all complete sequences represent trees , e.g. , @xmath75 is complete for @xmath76 but , by observation , does not represent a tree .",
    "the saving fact is that even though not all complete sequences represent trees , all _ optimal _ complete sequences represent trees .",
    "[ lem : sequence.2.tree ] an optimal valid sequence ending in @xmath58 always represents a tree .",
    "thus , to solve the llhc problem of finding an optimal tree of height @xmath77 , we only need to find an optimal valid sequence of length @xmath78 ending with @xmath79 ( reconstructing the tree from the sequence can be done in @xmath14 time ) . in the dp defined by equations ( [ eq : dp_def ] ) and ( [ eqn : c ] ) ,",
    "@xmath80 clearly models the recurrence for finding an optimal valid sequence @xmath81 of length @xmath82 with @xmath83 so this dp solves the problem .",
    "note that , a - priori , filling in the dp table @xmath84 one entry at a time seems to require @xmath85 time .",
    "we will now sketch the standard way of reducing this time down to @xmath86 before doing so we must distinguish between the _ value _ problem and the _ construction problem_. the value problem would be to calculate the value of @xmath87 the construction problem would be to construct an optimal valid _ sequence _",
    "@xmath88 with @xmath89 and @xmath90 this would require backtracking through the dp table by setting @xmath91 , @xmath92 and finding @xmath93 such that @xmath94          an @xmath95 matrix @xmath96 is _ monge _ and @xmath97 @xmath98 but it is well known , see , e.g. , @xcite , that this is equivalent to ( [ eq : monge def ] ) . ] if for @xmath99 and @xmath100 @xmath101    the monge property can be thought of as a discrete version of concavity .",
    "it appears implicitly in many optimization problems for which it permits speeding up their solutions ( @xcite ) provides a nice survey ) .",
    "one of the classic techniques used is the smawk algorithm for finding row - minima .    given an @xmath95 matrix @xmath96 , the _ minimum _ of row @xmath102 , @xmath103 is the entry of row @xmath102 that has the smallest value ; in case of ties , we take the rightmost entry . thus , a solution of the row - minima problem is a collection of indices @xmath104 , @xmath103 such that @xmath105 figure [ fig : row_ex ] gives four examples of monge matrices and their row minima .    at first glance",
    "it seems that we would have to examine all of the @xmath106 entries in @xmath96 to find the row minima but , @xcite proved    ( the smawk algorithm @xcite ) + [ lem : smawk ] let @xmath96 be a @xmath95 monge matrix such that entry @xmath107 can be calculated in @xmath108 time .",
    "then the row minima problem on @xmath96 can be solved in @xmath109 time .",
    "the constant hidden by the @xmath110 is very small , around 2 , and the algorithm is easy to code , so it is quite practical to use .    note that the smawk algorithm does nt have the time available to build the entire @xmath95 matrix .",
    "instead , it searches through the matrix in a clever way , constructing entries as needed .",
    "one standard use of the smawk algorithm is in the speedup of dynamic programs that have monge properties .",
    "a dp in the form ( [ eq : dp_def ] ) is _ monge _ if , for all @xmath111 and @xmath112 , @xmath113    _ note : in many dp applications , it is possible that for some @xmath114 , @xmath115 . the inequality in ( [ eq : def_quad ] ) treats @xmath116 in the natural way , e.g. , for any constant @xmath117 ; @xmath118 and @xmath119 .",
    "also , @xmath120 .",
    "the smawk algorithm permits the use of @xmath116 in this way .",
    "_    now suppose that a dp defined by ( [ eq : dp_def ] ) is monge .",
    "for @xmath121 define matrix @xmath122 by @xmath123 then , from ( [ eq : def_quad ] ) , we have @xmath124 and @xmath122 is monge .",
    "note that @xmath125 so , @xmath126 are just the row - minima of @xmath122 .",
    "see figure [ fig : row_ex ] .",
    "since @xmath122 is monge , we can use the smawk algorithm to , in @xmath14 time , find _ all _ of its row minima at one time .",
    "more specifically , let @xmath127 and @xmath128 be the corresponding values ( [ eq : res ] ) returned when running smawk@xmath129 then the algorithm for filling in the table is just to iteratively run down the rows of the table , using smawk to fill in each row by using knowledge of the previous row :     + for @xmath130 to @xmath131 + smawk @xmath132 + @xmath133 set @xmath134    note that this algorithm uses @xmath32 time , since , for each fixed @xmath82 , the smawk algorithm only uses @xmath14 time .",
    "also note that if we re only interested in the final row , then the algorithm uses only @xmath14 space , since once row @xmath82 has been calculated , the values from row @xmath135 can be thrown away .",
    "we now return to the llhc problem and show that it can be plugged into the above machinery .",
    "[ lem : c.qi ] the @xmath136 defined in ( [ eqn : c ] ) satisfy monge property ( [ eq : def_quad ] ) .    if @xmath137 the righthand side of ( [ eq : def_quad ] ) is @xmath116 , so ( [ eq : def_quad ] ) is satisfied .",
    "if @xmath138 or @xmath139 , the righthand side of ( [ eq : def_quad ] ) is @xmath116 , so ( [ eq : def_quad ] ) is satisfied .",
    "if @xmath140 and @xmath141 , ( [ eq : def_quad ] ) can be rewritten as @xmath142 it is easy to verify @xmath143    hence , ( [ eqn : c.qi.rewrite ] ) holds .",
    "thus , from the discussion above , we can find all of the @xmath126 in @xmath32 time .",
    "in particular , @xmath42 will be the cost of the optimal tree with height _ at most _",
    "@xmath17 which is the required cost of the optimum @xmath17-limited code .",
    "we have thus seen how to solve the value problem in @xmath22 time .",
    "the difficulty is that _ constructing _ the optimal tree associated with @xmath42 would require finding the associated optimal valid sequence with @xmath144 this would require solving the construction problem by finding all indices @xmath145 in ( [ eq : const ] ) .",
    "the standard way of solving this problem is to maintain an array storing the @xmath127 values returned by the algorithm .",
    "starting from @xmath42 and backtrack through the @xmath146 array , constructing the corresponding sequence by setting @xmath92 and @xmath147 unfortunately , this requires maintaining a size @xmath32 auxiliary array , which requires too much space .",
    "and [ fig : row_ex ] .",
    "the bold edges are the minimum cost path from @xmath148 to @xmath149 note that the @xmath102 coordinates of the path are @xmath150 which is _ exactly _ the sequence of @xmath127 s corresponding to optimal solution of the problem , which is also the sequence corresponding to the optimal tree . ]    let @xmath151 be the grid nodes @xmath152 with @xmath153 and @xmath154 . consider the directed graph @xmath155 in which @xmath152 points to all nodes immediately below it and to its right , i.e. , @xmath156 see figure [ fig : drop_ex ] .",
    "such graphs are sometimes called _ dropping level - graphs _ @xcite .",
    "now assign edge @xmath157 the weight @xmath48",
    ". the length of a path in @xmath158 will just be the sum of the weights of the edges in the path .",
    "the important observation is that @xmath126 in dp ( [ eq : dp_def ] ) is simply the length of the min - cost path from @xmath148 to @xmath152 in this weighted @xmath158 .",
    "more specifically , the value problem is to find the _ length of a shortest path _ and the construction problem is to find an _ actual shortest path . _    a - priori ,",
    "finding such a path seems to require @xmath22 space .",
    "there are two different algorithms in the literature for reducing the space down to @xmath33 in related problems .",
    "the first was for finding a maximum common subsequence of two sequences .",
    "this reduced down to the problem of finding a _ max - length _ path in something very similar to a dropping level - graph in which each vertex has bounded indegree and bounded outdegree .",
    "hirschberg @xcite developed an @xmath32 time , @xmath159 space algorithm for this problem .",
    "his algorithm was very influential in the bioinformatics community and its technique is incorporated into many later algorithms e.,g @xcite .",
    "the techniques s performance is very dependent upon the bounded degree of the vertices , which is not true in our case .",
    "the second , due to munro and ramirez @xcite , was exactly for the problem of constructing min - cost paths in full dropping level - graphs .",
    "their algorithm ran in @xmath46 time and @xmath159 space .",
    "their @xmath46 time is too expensive for us .",
    "we will now see how to reduce this down to @xmath32 using the monge speedup while still maintaining the @xmath159 space .",
    "the general problem will be to construct an optimal @xmath160-@xmath161 path in @xmath158 where @xmath162 is above and not to the left of @xmath163 i.e. , @xmath164 and @xmath165 let @xmath166 be the subgrid with upper - left corner @xmath160 and lower - right corner @xmath161 ( with associated induced edges from @xmath158 ) .",
    "first note that , because @xmath158 is a dropping level - graph , any optimal ( min or max cost ) @xmath160-@xmath161 path in @xmath158 must lie completely in @xmath166 .",
    "both algorithms @xcite start from the same observation , which is to build the path _ recursively _ i.e. , by first ( a ) finding a point @xmath167 halfway ( by link distance ) on the optimal @xmath160-@xmath161 path in @xmath166 and then ( b ) output the recursively constructed optimal @xmath160-@xmath168 path in @xmath169 and optimal @xmath168-@xmath161 path in @xmath170 .    for dropping level - graphs , if @xmath171 and @xmath172 then the midlevel must be @xmath173 .",
    "suppose that we had an algorithm @xmath174 that returned a point @xmath167 on a shortest @xmath160-@xmath161 path in @xmath175 then , translated into our notation and with appropriate termination conditions the construction algorithm can be written as :     + 1 .",
    "if @xmath176 and @xmath177 then + 2 .",
    "output edge @xmath178 + 3 .",
    "else if @xmath179 and @xmath180 then + 4 .",
    "output vertical path from @xmath160 to @xmath161 + 5 .",
    "else + 6 . set @xmath181 + 7 .",
    "@xmath182 ;  path@xmath183 + [ fig : alg_path ]        ( figure [ fig : path_illus ] illustrates this idea . ) to solve the original problem we just call path@xmath184 where @xmath185 and @xmath186 correctness follows from the fact that at each recursive call , the vertical distance @xmath187 decreases so the recursion must terminate .",
    "furthermore , when the recursion terminates , either ( i ) @xmath176 and @xmath188 so the _ only _ @xmath160-@xmath161 path in @xmath166 is the edge @xmath178 or ( ii ) @xmath179 and @xmath180 so the _ only _ @xmath160-@xmath161 path in @xmath166 is the vertical path going down from @xmath160 to @xmath161 .",
    "the efficiency of the resulting algorithm , both in time and space , will depend upon how efficiently @xmath181 can be found .",
    "note that with the exception of the calls of type @xmath174 , the rest of the execution of path@xmath184 ( including all recursive calls ) only requires a total of @xmath189 space , since each recursive call uses only @xmath108 space and there are at most @xmath189 such calls .",
    "thus , if @xmath174 can be found using @xmath33 space , then the entire procedure requires only @xmath33 space .",
    "this is actually how both @xcite achieve their space bounds .",
    "the two algorithms differ in how they calculate @xmath168 .",
    "although both their approaches can be used for our problem , we will work with a modified version of that of @xcite , since it will be simpler to explain .",
    "we now describe how to use the smawk algorithm to find @xmath190 in @xmath22 time and @xmath14 space .",
    "the extension to general @xmath174 will follow later . recall that the procedure fill_table from figure [ fig : alg_ft ] used the fact that @xmath84 was monge and the smawk algorithm to iteratively fill in the rows @xmath191 , for @xmath192 given row @xmath193 , the procedure calculated @xmath191 in @xmath14 time using smawk , and then threw away @xmath193 .    consider an arbitrary node @xmath152 on level @xmath194 the shortest path from @xmath195 to @xmath152 must pass through _ some _ node on level @xmath196 .",
    "we now modify fill_table to `` remember '' this node .",
    "more specifically , our algorithm will calculate auxiliary data @xmath197 .    * for @xmath198",
    ", @xmath197 will be undefined .",
    "* for @xmath199 , @xmath197 will be an index @xmath200 such that node @xmath201 appears on some shortest path from @xmath195 to @xmath152 .",
    "so , when the procedure terminates , @xmath202 will be @xmath203    by definition , on level @xmath196 , we have @xmath204    for @xmath205 suppose @xmath206 is the immediate predecessor of @xmath152 on the shortest path from @xmath195 to @xmath152 . then ( i ) a shortest path from @xmath195 to @xmath206 followed by ( ii ) the edge from @xmath206 to @xmath152 is ( iii ) a shortest path from @xmath195 to @xmath152 ; we may therefore set @xmath207    we can use this observation to modify fill_table to calculate the @xmath208 information .",
    "+ for @xmath130 to @xmath196 + smawk @xmath132 + @xmath133 set @xmath134 + @xmath133 set @xmath209 + for @xmath210 to @xmath17 + smawk @xmath132 + @xmath133 ,  set @xmath134 + @xmath133 ,   set @xmath211    note that @xmath190 can throw away all of the values @xmath212 and @xmath193 after the values @xmath208 and @xmath191 have been calculated , so it only uses @xmath14 space . similarly to the analysis of fill_table , it uses only @xmath22 time since each call to the smawk algorithm uses only @xmath14 time .",
    "so far , we have only shown how to find @xmath213 .",
    "note that the _ only assumptions _ we used were that @xmath84 satisfies dp ( [ eq : dp_def ] ) and is monge , i.e. , the @xmath48 satisfy ( [ eq : def_quad ] ) .",
    "now suppose that we are given @xmath214 @xmath166 is a dropping level - graph on its own nodes so the cost of the shortest path from @xmath160 to any node @xmath215 is @xmath216 defined by @xmath217 where @xmath218 and @xmath219 note that this new dp is exactly in the same form as ( [ eq : dp_def ] ) , just with a different @xmath5 and shifted @xmath220 since the original @xmath48 satisfy ( [ eq : def_quad ] ) , so do the @xmath221 .",
    "thus ( [ eq : dp_def_2 ] ) with the @xmath221 is monge as well .    therefore , we can run exactly the same algorithm written in figure [ fig : midalg ] to find the midpoint @xmath222 of the min - cost @xmath160-@xmath161 path in @xmath223 time and @xmath224 space .    as discussed previously ,",
    "if @xmath174 only requires @xmath33 space , then path@xmath178 only requires @xmath33 space , so we have completed the space analysis .",
    "it remains to analyze running time .",
    "set @xmath225 to be the `` area '' of @xmath166 .",
    "recall that line 3 of path@xmath178implies that @xmath226 when @xmath174 is called .",
    "therefore @xmath227 and the running time of @xmath174 is @xmath228    we now analyze the running time of path@xmath184 . first consider the recursive calls when lines 1 - 4 occur , i.e. , the recursion terminates .",
    "the _ total _ work performed by such calls is the total number of edges outputted .",
    "since an edge is outputted only once and the total path contains @xmath17 edges , the total work performed is @xmath229    next consider the calls when line 5 - 7 occur . since each such call returns a vertex @xmath168 on the path ,",
    "there are only @xmath131 such calls so lines 6 and 7 are only called @xmath189 times and their total work , with the exception of the call to @xmath230 , is @xmath229    finally consider the work performed by the @xmath174 calls .",
    "partition the calls into levels .",
    "* level 1 is the original call @xmath190 . *",
    "level 2 contains the recursive calls directly made by the level-1 call . * in general , level",
    "@xmath102 contains the recursive calls directly made by the level-@xmath231 calls .",
    "note that if @xmath174 is a level @xmath102 call with @xmath162 and @xmath232 ) then @xmath233 furthermore , by induction , if @xmath174 and @xmath234 are two different level @xmath102 calls , then horizontal ranges @xmath235 $ ] and @xmath236 $ ] are _ disjoint _ except for possibly @xmath237 or @xmath238 .",
    "fix @xmath239 let @xmath240 @xmath241 be the calls at level @xmath102 .",
    "the facts that each grid @xmath242 has height @xmath243 and that the horizontal ranges of the grids are disjoint implies @xmath244    thus the total of all level-@xmath102 calls is @xmath245 .",
    "summing over the @xmath246 levels we get that the total work performed by all of the @xmath174 calls on line 6 is @xmath247 thus , the total work performed by path@xmath184 is @xmath22 and we are finished .",
    "we just saw how , in @xmath32 time and @xmath159 space , to solve the construction problem for any dp in form ( [ eq : dp_def ] ) that satisfies the monge property ( [ eq : def_quad ] ) .",
    "@xmath32 time was known previously ; the @xmath159 space bound , is the new improvement .",
    "there are many other dp problems besides the binary llhc that satisfy ( [ eq : def_quad ] ) and whose space can thus be improved .",
    "we illustrate with three examples .     + we have discussed the binary llhc problem in which @xmath248 the general @xmath31-ary alphabet case with @xmath249 probabilities is still modeled by a dp in form ( [ eq : dp_def ] ) but with @xmath250 .",
    "the only difference is that ( [ eqn : c ] ) is replaced by @xmath251 a full derivation of this dp is given in appendix [ app : llhcdp ] .",
    "the proof that the @xmath136 satisfy the monge property ( [ eq : def_quad ] ) is similar to the proof of lemma [ lem : c.qi ] .",
    "thus , we can construct a solution to the @xmath31-ary llhc problem in @xmath0 time and @xmath1 space as well .",
    "+ we are given @xmath252 customers located on the positive real line ; customer @xmath102 is at location @xmath253 without loss of generality , assume @xmath254 there are @xmath47 service centers located on the line and a customer is serviced by the closest service center to its left ( thus we always assume a service center at @xmath255 ) .",
    "each customer has a service request @xmath256 the cost of servicing customer @xmath102 is @xmath10 times the distance to its service center . in @xcite ,",
    "motivated by the application of optimally placing web proxies on a linear topology network , woeginger showed that this problem could be modeled by a dp in form in form ( [ eq : dp_def ] ) where @xmath257 and proved that these @xmath48 satisfy monge property ( [ eq : def_quad ] ) .",
    "he then used the smawk algorithm to construct a solution in @xmath22 time and @xmath22 space . using the technique we just described ,",
    "this can be reduced to @xmath22 time and @xmath14 space .",
    "we also mention that there is an undirected variant of this problem in which a node is serviced by its _",
    "closest _ service center looking both left and right .",
    "there are many algorithms in the literature that ( explicitly or implicitly ) use concavity to construct solutions for this problem in @xmath22 time using @xmath14 space , e.g. , @xcite .",
    "@xcite does this by using a dp formulation that is in the dp form ( [ eq : dp_def ] ) and satisfies the monge property ( [ eq : def_quad ] ) so the technique in this paper can reduce the space for this problem down to @xmath14 as well .",
    "+ the third application comes from wireless mobile paging",
    ". a user can be in one of @xmath249 different cells .",
    "we are given a probability distribution in which @xmath13 denotes the probability that a user will be in cell @xmath102 and want to minimize the bandwidth needed to send paging requests to identify the cell in which the user resides .",
    "this problem was originally conjectured to be np - complete , but @xcite developed a dp algorithm for it .",
    "the input of the problem is the @xmath5 probabilities @xmath258 and an integer @xmath259 ( corresponding to the number of paging rounds used ) .",
    "the dp developed by @xcite is exactly in our dp form ( [ eq : dp_def ] ) with @xmath260 the goal is to compute @xmath261 , which will be the minimum expected bandwidth needed . solving the construction version of this dp permits constructing the actual paging protocol that yields this minimum bandwidth .",
    "@xcite used the naive algorithm to solve the dp in @xmath46 time and @xmath32 space .",
    "@xcite proved that the @xmath48 defined by ( [ eq : wmp.cd ] ) satisfy the the monge property ( [ eq : def_quad ] ) and thus reduced the time to @xmath32 , but still required @xmath32 space .",
    "the algorithm in this paper permits improving the space complexity of constructing the protocol down to @xmath262 .",
    "the standard approach to solving the length - limited huffman coding ( llhc ) problem is via the special purpose package - merge algorithm of hirschberg and larmore @xcite which runs in @xmath22 time and @xmath14 space , where @xmath5 is the number of codewords and @xmath17 is the length - limit on the code .    in this note",
    "we point out that this problem can be solved in the same time and space using a straightforward dynamic programming formulation .",
    "we started by noting that it was known that the llhc problem could be modeled using a dp in the form @xmath263    where @xmath264 will denote the minimum cost of a code with longest word at most @xmath82 and the @xmath48 are easily calculable constants .",
    "this implies an @xmath85 time @xmath22 space algorithm .",
    "we then note that , using standard dp speedup techniques , e.g. , the smawk algorithm , the time could be reduced down to @xmath22 .",
    "the main contribution of this paper is to note that , once the problem is expressed in this formulation , the space can be reduced down to @xmath14 while maintaining the time at @xmath22 .",
    "the space reduction developed for this problem was also shown to apply to other problems in the literature that previously had been thought to require @xmath32 space .",
    "we conclude by noting that if we re only interested in solving the standard huffman coding problem and not the llhc one then dp ( [ eq : h_final ] ) with @xmath48 defined by ( [ eqn : c_r ] ) collapses down to @xmath265 where @xmath266 denotes the minimum cost of a `` valid sequence '' ending in @xmath102 .",
    "@xmath267 will be the cost of an optimal complete sequence and solving the construction problem for this dp will give this optimal sequence .",
    "we can construct the code from this optimal sequence in @xmath268 time .",
    "there is a subtle point here which should be mentioned .",
    "the matrix @xmath96 defined by @xmath269 is monge ( the proof is similar to that of lemma [ lem : c.qi ] ) .",
    "we can _ not _ use the smawk algorithm to find its row minima and solve the problem , though .",
    "the reason is that , as stated in lemma [ lem : smawk ] , the smawk algorithm requires being able to calculate any arbitrary requested entry @xmath107 in @xmath108 time . in our current dp ,",
    "though , the @xmath107 are dependent upon the values @xmath270 which are the row - minima of other rows in the same matrix !",
    "thus , we have no way of calculating @xmath107 in @xmath108 time when required and the smawk algorithm can not be applied .",
    "this is the reason why larmore and przytycka @xcite needed to use the more sophisticated clws algorithm of @xcite to solve the binary ( @xmath271 ) version of this problem .",
    "other algorithms for more generalized versions of the clws have since appeared , e.g. , @xcite , that could also be used to solve this problem in @xmath14 time , but they are also quite complicated . to summarize , by transforming @xmath31-ary huffman coding into a dp and using sophisticated tools such as @xcite or @xcite we can solve the problem in @xmath14 time .",
    "this is not of practical interest , though , since the simple , greedy , huffman encoding algorithm is just as fast . where the dp formulation helps is in the llhc problem , exactly where the greedy procedure fails .",
    "in that case we have the added practical benefit of being able to use the simple smawk algorithm rather than the more complicated @xcite or @xcite .",
    "10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    d.  a. huffman , `` a method for the construction of minimum - redundancy codes , '' in _ proceedings of the institution of radio engineers _ , vol .  40 , 1952 , pp . 10981101",
    ".    j.  van leeuwen , `` on the construction of huffman trees , '' in _ proceedings of the 3rd international colloquium on automata , languages and programming _ , 1976 , pp .",
    ".    r.  m. karp , `` minimum - redundancy coding for the discrete noiseless channel , '' _ ieee transactions on information theory _",
    ", vol .  7 , no .  1 ,",
    "pp . 2738 , 1961 .",
    "e.  n. gilbert , `` codes based on inaccurate source probabilities , '' _ ieee transactions on information theory _ , vol .",
    "17 , no .  3 , pp .",
    "304314 , 1971 .",
    "t.  c. hu and k.  c. tan , `` path length of binary search trees , '' _ siam journal on applied mathematics _ ,",
    "22 , no .  2 ,",
    "pp . 225234 , 1972 .",
    "m.  r. garey , `` optimal binary search trees with restricted maximal depth , '' _ siam journal on computing _ , vol .  3 , no .  2 , pp . 101110 , 1974 .",
    "d.  e. knuth , `` optimum binary search trees , '' _ acta informatica _",
    ", vol .  1 ,",
    "pp . 1425 , 1971 .",
    "l.  l. larmore , `` height restricted optimal binary trees , '' _ siam journal on computing _ , vol .  16 , no .  6 , pp .",
    "11151123 , 1987 .",
    "l.  l. larmore and d.  s. hirschberg , `` a fast algorithm for optimal length - limited huffman codes , '' _ journal of the acm _ , vol .",
    "37 , no .  3 , pp .",
    "464473 , 1990 .",
    "n.  megiddo , `` applying parallel computation algorithms in the design of serial algorithms , '' _ journal of the acm _ , vol .",
    "30 , no .  4 , pp . 852865 , 1983 .",
    "a.  aggarwal , b.  schieber , and t.  tokuyama , `` finding a minimum - weight @xmath63-link path in graphs with the concave monge property and applications , '' _ discrete and computational geometry _",
    "12 , pp . 263280 , 1994 .",
    "b.  schieber , `` computing a minimum weight @xmath63-link path in graphs with the concave monge property , '' _ journal of algorithms _ , vol .",
    "29 , no .  2 ,",
    "pp . 204222 , 1998 .",
    "a.  turpin and a.  moffat , `` efficient implementation of the package - merge paradigm for generating length - limited codes , '' in _ proceedings of computing : the australasian theory symposium _",
    ", 1996 , pp . 187195 .",
    " , `` practical length - limited coding for large alphabets , '' _ the computer journal _ , vol .",
    "38 , no .  5 , pp . 339347 , 1995 .",
    "l.  l. larmore and t.  m. przytycka , `` parallel construction of trees with optimal weighted path length , '' in _ proceedings of the 3rd annual acm symposium on parallel algorithms and architectures _ , 1991 , pp .",
    " , `` constructing huffman trees in parallel , '' _ siam journal on computing _ , vol .  24 , no .  6 , pp .",
    "11631169 , 1995 .",
    "g.  j. woeginger , `` monge strikes again : optimal placement of web proxies in the internet , '' _ operations research letters _ , vol .  27 , no .  3 , pp .",
    "9396 , 2000 .",
    "b.  krishnamachari , r .- h .",
    "gau , s.  b. wicker , and z.  j. haas , `` optimal sequential paging in cellular wireless networks , '' _ wireless networks _ , vol .",
    "10 , no .  2 ,",
    "pp . 121131 , 2004 .",
    "p.  bradford , m.  j. golin , l.  l. larmore , and w.  rytter , `` optimal prefix - free codes for unequal letter costs : dynamic programming with the monge property , '' _ journal of algorithms _ , vol .",
    "42 , no .  2 ,",
    "pp . 277303 , 2002 .",
    "r.  wilber , `` the concave least - weight subsequence problem revisited , '' _ journal of algorithms _ , vol .",
    "9 , no .  3 , pp .",
    "418425 , 1988 .",
    "a.  aggarwal , m.  m. klawe , s.  moran , p.  w. shor , and r.  e. wilber , `` geometric applications of a matrix - searching algorithm , '' _ algorithmica _ , vol .  2 ,",
    "pp . 195208 , 1987 .",
    "d.  eppstein , `` smawk totally monotone matrix searching algorithm , '' python package available at : http://aspn.activestate.com/aspn/cookbook/python/recipe/117244 , 2002 , release march 17 , 2002 .",
    "`` neobio  bioinformatics algorithms in java : class smawk , '' java package available at : http://neobio.sourceforge.net/javadoc/neobio/alignment/smawk.html .",
    "r.  e. burkard , b.  klinz , and r.  rudolf , `` perspectives of monge properties in optimization , '' _ discrete applied mathematics _ , vol .  70 , no .  2 , pp .",
    "95161 , 1996 .",
    "j.  i. munro and r.  j. ramirez , `` reducing space requirements for shortest path problems , '' _ operations research _ , vol .",
    "30 , no .  5 , pp . 10091013 , 1982 .",
    "d.  s. hirschberg , `` a linear space algorithm for computing maximal common subsequences , '' _ communications of the acm _ , vol .",
    "18 , no .  6 , pp .",
    "341343 , 1975 .",
    "chao , r.  c. hardison , and w.  miller , `` recent developments in linear - space alignment methods : a survey , '' _ journal of computational biology _ , vol .  1 , no .  4 , pp . 271292 , 1994 .",
    "e.  w. myers and w.  miller , `` optimal alignments in linear space , '' _ bioinformatics ( formerly computer applications in the biosciences ) _ , vol .  4 , no .  1 ,",
    "pp . 1117 , 1988 .",
    "r.  hassin and a.  tamir , `` improved complexity bounds for location problems on the real line , '' _ operations research letters _ , vol .  10 , no .  7 , pp . 395402 , 1991 .",
    "v.  auletta , d.  parente , and g.  persiano , `` placing resources on a growing line , '' _ journal of algorithms _ , vol .  26 , no .  1 , pp .",
    "87100 , 1998 .",
    "r.  fleischer , m.  j. golin , and y.  zhang , `` online maintenance of k - medians and k - covers on a line . '' _ algorithmica _ , vol .",
    "45 , no .  4 , pp . 549567 , 2006 .",
    "b.  krishnamachari , r .- h .",
    "gau , s.  b. wicker , and z.  j. haas , `` optimal sequential paging in cellular wireless networks , '' _ wireless networks _ ,",
    "10 , no .  2 , 2004 .",
    "a.  bar - noy , m.  j. golin , and y.  zhang , `` online dynamic programming speedups , '' in _ proceedings of the 4th workshop on approximation and online algorithms _ ,",
    "l.  l. larmore and b.  schieber , `` on - line dynamic programming with applications to the prediction of rna secondary structure , '' _ journal of algorithms _ , vol .",
    "12 , no .  3 , pp .",
    "490515 , 1991 .",
    "in order to make this note self - contained we provide a brief derivation of the dp that models the llhc .",
    "to the best of our knowledge , the derivation for the general @xmath31-ary case has never been written down before ( although it is known as `` folklore '' ) .",
    "a set of @xmath5 prefix - free codes in an @xmath31-ary alphabet can be represented by an @xmath31-ary tree with @xmath5 leaves . the @xmath272 edge from an internal node to its children",
    "is labeled by @xmath273 .",
    "each leaf corresponds to a code word , which is the concatenation of the characters on the root - to - leaf path .",
    "then , the expected code length equals the weighted external path length of the tree .",
    "denote the height of the tree by @xmath52 .",
    "the lowest leaves are on level @xmath51 ; the root is at level @xmath52 .",
    "optimal ( min weighted external path - length ) assignments of the probability @xmath13 s to the leaves always assign smaller probabilities to leaves at lower levels .",
    "since the probabilities are given in sorted order , this assignment can be done in @xmath14 time for a given tree .",
    "the _ cost _ of a tree is its weighted external path length w.r.t .",
    "an optimal assignment .",
    "define the _ degree _ of a node to be the number of its children .",
    "a node is _ complete _ if it is of degree @xmath31 , and a tree is _ complete _ if all its internal nodes are complete .",
    "the following properties are easy to prove        these properties imply that the optimal tree is almost complete and has @xmath276 internal nodes .",
    "if @xmath252 is divisible by @xmath277 , the tree is complete .",
    "otherwise , we can add @xmath278 dummy leaves to make it complete .",
    "we assign dummy @xmath13 s with zero values to these dummy leaves .",
    "it is easy to see that the new tree with these dummy leaves is precisely an optimal tree for the probabilities with the added zero - valued dummy @xmath13 s .",
    "so , finding an optimal tree for probabilities with these dummy @xmath13 s is equivalent to the original problem .",
    "therefore , w.l.o.g . , we assume in the original problem , the optimal tree is a complete tree , i.e. , we assume @xmath252 is always a multiple of @xmath277 . in this way we transform the @xmath31-ary huffman coding problem to the problem of finding an optimal complete @xmath31-ary tree with @xmath5 leaves",
    ".    a complete tree of height @xmath52 can be fully represented by a sequence @xmath54 , where @xmath55 denotes the number of internal nodes at levels @xmath56 .",
    "note that from this sequence we can calculate @xmath279 , the number of internal nodes _ on _ level @xmath63 and with that information we can reconstruct the tree in @xmath14 time as follows :     + 1 . for @xmath280 to @xmath52 + 2 .",
    "create @xmath281 nodes @xmath282 on level @xmath63 ; + 3 . create @xmath283 leaves on level @xmath284 ; + 4 . make @xmath285 the parents of the @xmath286 nodes on + level @xmath284 .                    for a complete @xmath31-ary tree with @xmath5 leaves , we have @xmath297 and , from lemma [ lem : leaf_no ] , @xmath298 for all @xmath67 . for technical reasons , because we will be dealing with trees having height _ at most _ ( but not necessarily equal to ) @xmath52 , we allow initial padding of the sequence by * 0*s so that a sequence representing a tree will be of the form @xmath54 that has the following properties          it is straightforward to see that padding the sequence representing a tree with initial * 0*s , does not change the tree built by the create procedure or the validity of lemmas [ lem : leaf_no ] and [ lem : eqn : cost.tree.2 ] .",
    "@xmath71 is _ optimal _ if @xmath72 where the minimum is taken over all valid length @xmath52 @xmath299-sequences @xmath73 with @xmath74 i.e. , all sequences of the same length that end with the same value .",
    "_ note : padding a sequence with initial * 0*s does nt change its completeness or cost .",
    "furthermore , if @xmath71 is created by padding the sequence corresponding to tree @xmath53 with initial * 0*s , then procedure create will still recreate @xmath53 from @xmath305 _      the subtle issue is that not all complete sequences correspond to trees , e.g , @xmath308 is a complete @xmath309 sequence that does not represent any binary tree .",
    "thus , a - priori , finding an optimal complete sequence might not help us find an optimal tree .",
    "we are saved by the next lemma .",
    "thus , we can find an optimal tree by first solving the construction problem for dp ( [ eq : dp_def ] ) with conditions ( [ eq : defc_2 ] ) to get an optimal complete @xmath299-sequence @xmath71 and then building the tree that corresponds to @xmath71 .",
    "given @xmath310 we can assign the @xmath13 to the leaves of forest @xmath311 from bottom to top of tree and define the cost of @xmath311 ( with respect to the @xmath13 ) to be the sum of the costs of its component trees . note that a tree with @xmath5 leaves is a forest and its cost as a forest will be the same as its cost as a tree .",
    "now , for forest @xmath311 let @xmath55 be the number of internal nodes it has at level @xmath56 .",
    "then , we can talk about the sequence @xmath312 associated with the forest .",
    "reviewing the proofs of lemmas [ lem : leaf_no ] and [ lem : eqn : cost.tree.2 ] we see that they were actually statements about forests and not trees so @xmath311 has @xmath287 leaves on levels @xmath313 and @xmath314            note that this will immediately imply lemma [ lem : sequence.2.tree.2 ] because if @xmath71 is complete then @xmath316 and , by validity , @xmath317 , implying @xmath318 .",
    "thus the forest corresponding to @xmath71 is composed of exactly @xmath319 trees at level @xmath52 and is therefore a tree itself .",
    "define @xmath328 since @xmath329 is optimal , by induction , @xmath329 represents a forest @xmath330 with @xmath331 roots at level @xmath332 and a total of @xmath333 leaves .",
    "there are now two cases : see figure [ fig : forest ] .",
    "now consider @xmath311 as being labeled with the @xmath341 smallest @xmath13 and construct a new forest @xmath342 as follows .",
    "choose @xmath343 trees from @xmath342 containing the @xmath343 largest weights in the forest , i.e. , @xmath344 @xmath345 move those @xmath343 forests up one level so their roots are now at height @xmath52 and not @xmath346 now add @xmath334 new nodes to level @xmath52 .",
    "make them the parents of the remaining @xmath335 nodes on level @xmath346 this forest is a legal forest .",
    "call its representative sequence @xmath347    we now observe + ( a ) @xmath348 so @xmath349 ( b ) thus @xmath350 and @xmath351 ( c ) let @xmath352 be levels @xmath51-@xmath353 of @xmath342 . since every complete tree contains at least @xmath31 nodes , the @xmath343 trees raised contain at least the @xmath343 nodes @xmath354 where @xmath355 and one other node .",
    "since every such node was raised one level , @xmath356 combining ( b ) and ( c ) shows that @xmath357 .",
    "this is a contradiction since both @xmath71 and @xmath358 are valid sequences of length @xmath52 that end with the same value @xmath359 and @xmath71 is optimal .",
    "thus the case @xmath337 can not happen and we are finished ."
  ],
  "abstract_text": [
    "<S> the `` state - of - the - art '' in length limited huffman coding algorithms is the @xmath0-time , @xmath1-space one of hirschberg and larmore , where @xmath2 is the length restriction on the code . </S>",
    "<S> this is a very clever , very problem specific , technique . in this note </S>",
    "<S> we show that there is a simple dynamic - programming ( dp ) method that solves the problem with the same time and space bounds . </S>",
    "<S> the fact that there was an @xmath0 time dp algorithm was previously known ; it is a straightforward dp with the _ monge _ property ( which permits an order of magnitude speedup ) . </S>",
    "<S> it was not interesting , though , because it also required @xmath0 space .    </S>",
    "<S> the main result of this paper is the _ technique _ developed for reducing the space . </S>",
    "<S> it is quite simple and applicable to many other problems modeled by dps with the monge property . </S>",
    "<S> we illustrate this with examples from web - proxy design and wireless mobile paging .    </S>",
    "<S> prefix - free codes , huffman coding , dynamic programming , web - proxies , wireless paging , the monge property . </S>"
  ]
}