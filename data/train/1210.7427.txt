{
  "article_text": [
    "this manuscript was submitted to parallel computing ( elsevier ) for the special issue devoted to the pmaa 2012 conference .",
    "parallel computing can be difficult . in order to have a functioning parallel program ,",
    "one first needs to find algorithms that can be executed in parallel .",
    "then , the algorithms must be expressed in such a way that the parallelism is exposed so that separate , independent parts can be identified .",
    "furthermore , the work must be distributed among the available processors / nodes and data required by each processor must be communicated as needed .",
    "we present in this article a parallel programming model intended to facilitate the above process of developing parallel programs .",
    "our aim is to achieve scalability up to any number of processors , on distributed memory machines and possibly on heterogeneous computers , to handle not only algorithms with static distribution of work and data but also hierarchic , recursive algorithms where communication patterns are not known beforehand , and may change dynamically .",
    "fault tolerance is also important , especially considering the trends in modern supercomputers , where hardware errors are unavoidable in any large parallel calculation .",
    "much research has been devoted to parallel programming models . to give some background to the design choices made while developing our new interface , we below mention some of the more well - known previous models .",
    "a programming model usually exists in the form of a tool , e.g. a library or language , that supports program development within the model .",
    "a crucial point here is the interface separating the concerns of the application programmer from the inner workings of the library or language .    in message passing programming models ( e.g. mpi and pvm ) the application programmer has to decide how the data should be distributed and use explicit communication to make sure that the needed data is available whenever a task is to be performed .",
    "this gives the programmer control , but a drawback is that implementation of complex algorithms , for example requiring dynamical load balancing , is difficult .",
    "an alternative that makes it easier to implement complex algorithms is to use some programming model where data is shared via a distributed shared memory .",
    "the linda programming model is built on an associative logically shared memory called a tuple space . in implementations of linda for distributed memory",
    "each processor manages a portion of the tuple space .",
    "there is in principle no way for the linda implementation to know in advance which processes that will access a particular tuple .",
    "however , efficient implementations attempt to optimize the distribution of data based on observation of the tuple traffic between processes @xcite . in case of static traffic patterns the run - time system",
    "can then quickly set up efficient communication channels",
    ". however , in cases of dynamic algorithms with a varying communication pattern , it is not of much help .",
    "languages based on a partitioned global address space ( pgas ) such as unified parallel c ( upc ) @xcite and coarray fortran give the programmer more control of the distribution of data . using pgas approaches , a skilled programmer can avoid extensive communication by distributing and accessing data in a good manner . on the downside",
    ", moving more responsibilities to the application programmer reduces the possibilities for the library / language to help .    in recent years",
    "there has been a growing interest in task - based programming models .",
    "a multitude of tools have been developed including cilk @xcite , smpss @xcite and ompss @xcite , starpu @xcite , and superglue @xcite .",
    "most of them have initially been developed for multicore architectures , in some cases with support for accelerators .",
    "however , there has also been some efforts to apply task - based approaches to clusters of computers .",
    "cilk - now is a variant of cilk for networks of workstations @xcite , starpu - mpi is an extension of starpu for clusters of accelerator - enhanced machines @xcite , and ompss has been implemented for clusters of gpus as well @xcite .",
    "the dague framework  @xcite is an example of a task - based approach that achieves high performance in dense linear algebra operations .    in task - based programming models ,",
    "the programmer writes the program in terms of tasks , usually specifying dependencies in one way or another , and a runtime engine schedules the tasks on the available resources .",
    "the programmer is responsible for exposing parallelism , and the task scheduler is responsible for mapping the work to physical resources .",
    "however , typically , either all data is managed by one `` master '' node or the application programmer has to supply the distribution of data .      as stated above ,",
    "a key issue is the division of labor between the application programmer and the inner workings of the parallel library / language . in the present work we adopt a task - based approach for the distribution of work .",
    "however , we also provide abstractions to handle data .",
    "the idea is that the application programmer should be responsible for dividing data into smaller pieces to allow for data distribution , but not for the mapping of this data to physical resources .",
    "the application programmer ( the user ) defines task types and registers tasks for execution .",
    "similarly , the user defines chunk types and registers chunks for storage .",
    "thus , a key feature of the present work is that the application programmer is relieved from the burden of providing the data distribution .",
    "this makes parallel programming a lot easier , especially for applications where dynamic data structures play an important role .",
    "examples of such applications include sparse matrix operations where the nonzero pattern is unknown beforehand and adaptive mesh refinement . for this type of applications ,",
    "it is often beneficial to use hierarchic data structures coupled to recursive algorithms .",
    "one notable example is large scale electronic structure calculations where dynamic hierarchic data structures and algorithms are used with success @xcite .",
    "although our abstractions do not impose a particular layout of work or data , we have had and have a view to make them work well for dynamic hierarchic algorithms and data structures .",
    "we refer to our parallel programming model as the `` chunks and tasks '' programming model @xcite and it is presented here in the form of a c++ application programming interface .",
    "a chunks and tasks library implementation is essentially composed of two parts , a chunk management system and a task scheduler , that are responsible for mapping data and work , respectively , to physical resources .",
    "the main focus of the work presented here has been on establishing the application programming interface . in our view , defining the interface is most important since it in some sense is an answer to the question of how to draw the line between the concerns of the application programmer and the concerns of the parallel library .",
    "furthermore , once the interface is fixed , application programmers can work on implementing parallel algorithms independently of any improvements in internal chunks and tasks library implementations .",
    "also , there may be several different chunks and tasks library implementations that an application programmer can switch between without need for any changes in the application program source code . to further enforce a clean interface with the possibility to switch between different libraries we currently have two different library implementations of chunks and tasks , a serial and a parallel implementation .",
    "the chunks and tasks interface is described in section  [ sec : cht ] . in section",
    "[ sec : pilot - impl ] , we describe a pilot library implementation based on mpi and posix threads and present a few benchmark calculations .",
    "section  [ sec : discussion ] contains some discussion including performance and fault resilience considerations .",
    "finally , a brief summary and outlook is given in section  [ sec : conclusion ] .",
    "chunks and tasks is a parallel programming model , presented in this article in the form of a c++ application programming interface .",
    "the interface is intended to make it easier to parallelize any method that can be formulated as a dynamic hierarchic algorithm .",
    "being evident from the name , the interface is built around two central concepts : chunks and tasks .",
    "the user defines chunk classes describing objects encapsulating pieces of data .",
    "a chunk is registered by passing the control of the chunk object to the chunks and tasks library . in return",
    "the user receives a chunk identifier that later can be used to specify data dependencies .",
    "the user also defines task classes describing work to be performed .",
    "a task type is defined by a number of input chunk types , the work to be performed and a single output chunk type .",
    "the relationships between the chunk and task base classes and user defined classes are shown in figure  [ fig - cht - classes ] .    in this section ,",
    "we describe the abstractions that are the basis of the chunks and tasks interface . in [ example - code ] we provide a concrete example program that uses chunks and tasks to compute a fibonacci number .    ]      to define a chunk type you need to inherit from the chunk base class and define a few member functions . functions to pack / unpack the chunk to / from a given buffer are mandatory .",
    "those functions may for example be used by a chunks and tasks library when chunks need to be sent to other processes over a network or to write chunks to secondary storage .",
    "after the point where the chunk has been registered and the user has gotten hold of the chunk identifier ( ` cht::chunkid ` ) for that particular chunk , modification of the chunk is not allowed .",
    "although any data or information may be stored in a chunk object , one anticipated use is to store identifiers to other chunks which in turn store chunk identifiers and so on giving rise to a hierarchic data structure .    to make it possible for the library to take responsibility for managing such chunk hierarchies ,",
    "the user should in such cases implement a function ` getchildchunks ` that returns a list of all chunk identifiers stored in that chunk .",
    "the list of child chunks can be used by a library implementation in different ways , for example to destruct chunk hierarchies , to prefetch child chunks , or to send child chunks together with a chunk .",
    "task types are derived from the task base class .",
    "the programmer has to specify the input chunk types and an output chunk type .",
    "the work to be performed is specified by supplying an ` execute ` function which takes read - only chunks as input and returns a chunk or task identifier .",
    "the work to be performed often includes registration of new tasks . in a task registration the task type and input identifiers",
    "are specified and a task identifier ( ` cht::taskid ` ) is returned .",
    "this task identifier may be used as input to subsequent task registrations , thereby specifying dependencies between tasks . since",
    "each task produces a single output chunk , input for new tasks can be specified using either chunk or task identifiers .",
    "in our design , we have been careful to ensure that the task execution can be performed without interruption , that is without waiting for other tasks to finish or for communication .",
    "access to chunks is only allowed as input to tasks .",
    "this means that it is not possible for the chunks and tasks library to perform a task prior to having the data needed for execution available . besides the ` registertask ` function , user defined task types inherit the ` registerchunk ` , ` copychunk ` , and ` getinputchunkid ` functions from the task base class , see figure  [ fig - cht - classes ] .",
    "all these functions should be non - blocking . note that chunk registration and copy may trigger communication with remote processes .",
    "however , the calling thread does not need to wait for this communication , as will be explained in section  [ sec : task_scheduler_service ] .",
    "task identifiers of any previously registered tasks may be specified as input to a task . similarly to @xcite , it is thus possible to structure an algorithm both in a recursive divide and conquer style and with dependencies on any ancestor . however , contrary to @xcite , since chunks are read - only , neither the library developer nor the application programmer need to worry about races for shared data access .",
    "it is also impossible to end up in a dead - lock due to mistakes in application code since all tasks directly or indirectly only depend on read - only data .",
    "a calculation performed using chunks and tasks is started from a standard serial c++ main program written by the application programmer . in a similar way as in a task execution , the user constructs chunks to be used as input to tasks and registers tasks to be executed by the chunks and tasks library .",
    "often , there is a working serial implementation for a particular application .",
    "it is then desirable to be able to parallelize the most time consuming part(s ) without rewriting the whole code .",
    "we allow the main program to remain a serial code with the chunks and tasks parallelization employed only for selected parts .",
    "unlike most mpi and pgas programs our pilot chunks and tasks library implementation does not use a single program multiple data ( spmd ) style .",
    "instead , the program starts as a serial program and at the chunks and tasks start - up the worker processes are spawned .",
    "these processes execute a worker program provided by the chunks and tasks library .",
    "each worker starts a set of services , including a chunk service and a task scheduler service .",
    "each service uses its own mpi communicators .",
    "our present library implementation uses the ` mpi_comm_spawn ` function in the mpi 2 standard .",
    "if a fully compliant mpi 2 library is not available , all processes can be started simultaneously and then assume the roles of parent and workers .",
    "however , we believe that the spawn functionality is valuable since it provides the possibility of dynamically adapting the amount of resources used by a calculation .      when the chunk service starts , on each worker a thread is created that is responsible for listening for mpi messages from other workers issued by the chunk service on those workers",
    ". other workers may request to get , delete , or copy a chunk .",
    "when a chunk is registered , the size of the chunk is known , and it is therefore possible to store the size of the chunk in the chunk identifier . besides obvious practical benefits for chunk communication , this information may for example be used in parametric models to estimate task execution times .",
    "the chunk identifier also contains the mpi rank of the worker where the chunk is stored , so when a chunk needs to be fetched we directly know to which worker the request should be sent .",
    "new chunks are by default assigned to the local worker , so that no communication is needed to register new chunks .    in the chunk identifier",
    "is also stored a chunk _ type _ identifier . given a chunk type identifier and the serialized chunk data , a chunk object can be reconstructed on another worker .",
    "a chunk factory constructs a chunk object of correct type given the chunk type identifier , and a call to the ` assignfrombuffer ` function completes the reconstruction .",
    "the chunk service also implements chunk cache functionality : when a remote chunk has been fetched over the network , it is kept in memory so that we do not need to fetch it again if the chunk is requested multiple times .",
    "cached chunks are purged from memory in a least recently used fashion .",
    "our task scheduler is based on work stealing .",
    "the calculation is initiated by the parent process sending the mother task to one of the workers .",
    "this worker begins to execute tasks in a depth first fashion , working its way down in the task hierarchy .",
    "whenever a worker is out of work , it attempts to steal work from another worker chosen at random . in order to achieve as much parallelism as possible ,",
    "tasks are always stolen as high up in the task hierarchy as possible .    when a task is stolen , the stealing worker has to reconstruct the task . as in the chunk reconstruction ,",
    "the task identifier includes a task type identifier that is used in a call to a task factory which constructs a task object of the correct type .",
    "when the task scheduler service starts , several threads are created on each worker process . as for the chunk service ,",
    "one thread is responsible for listening for mpi messages from the task scheduler service running on other processes .",
    "these messages can include task steal attempts or task information .",
    "another thread is fetching data for tasks pending for execution , to achieve overlap of communication and computation .",
    "a number of threads execute tasks .",
    "the outcome of a task execution consists of the output chunk or task identifier and the effect of calls to ` registerchunk ` , ` copychunk ` , and ` registertask ` .",
    "it is possible to implement the effect of these operations immediately .",
    "however , in our pilot implementation , the aggregate effect of a task execution is performed in a single transaction at some point after the execution of the task has finished , in a way similar to the return transaction technique proposed by blumofe and lisiecki  @xcite .",
    "this is accomplished by accumulating all the information needed for the transaction during the task execution .    in this way",
    ", the task execution can be performed without interruption , even if a call to for example ` copychunk ` would result in communication with a remote process .",
    "other benefits include the possibility to do speculative execution of tasks .      on each worker , several threads execute tasks .",
    "in order to have efficient task stealing between workers , we need to avoid unrolling additional branches of a task hierarchy when there is a lot of work in a branch that is already about to be unrolled .",
    "this could be achieved by only allowing one thread at a time to execute non - leaf tasks , i.e.  tasks that register child tasks .",
    "the problem is that , in principle , the only way to know if a task is a leaf task or not is to run ` execute ` for that task . to circumvent this problem we use what we refer to as _ speculative task",
    "execution_. tasks are executed speculatively in the sense that it is not known , at the time of execution , if the task transaction will be performed . for tasks that turn out to be leaf tasks ,",
    "the task transaction is performed immediately . for non - leaf tasks ,",
    "task transactions are only allowed one at a time . in this way",
    "we avoid undesired unrolling of several branches of a task hierarchy at the same time .",
    "an executed task for which the transaction has not been performed , can still be stolen , ensuring that stealing still occurs as high as possible in the task hierarchy .",
    "all effects of a task are collected in the transaction for that task .",
    "if the transaction is considered as the outcome of a task , then the task is completely free from side effects .",
    "however , if the output chunk or task identifier is considered as the outcome of the task , then the effect of calls to ` registerchunk ` , ` copychunk ` , and ` registertask ` during task execution should strictly speaking be considered as side effects .",
    "however , the ultimate effect of such calls is the creation of chunks whose identifiers from user code can only be reached through the output identifier .",
    "this means that dropping the output identifier without further notice would only result in a chunk leak .",
    "this has important implications for fault resilience as will be discussed in section  [ sec : fault - resilience ] .      to test our pilot implementation",
    "we have written a test program that implements matrix - matrix multiplication for hierarchic block - sparse matrices using the chunks and tasks programming model .",
    "the matrices are represented by quad - trees of chunk identifiers . at the lowest level , each nonzero submatrix",
    "is represented by a regular full matrix . at higher levels ,",
    "four chunk identifiers are stored referring to submatrices at the next lower level .",
    "if a submatrix is zero it is represented by the special chunk identifier ` cht::chunk_id_null ` .",
    "this implementation corresponds to the hierarchic block - sparse matrix data structure in  @xcite now expressed using the chunks and tasks interface .",
    "the matrix - matrix multiplication is implemented using three task types ; one for matrix - matrix multiplication , one for matrix - matrix addition , and one to construct a matrix from the chunk identifiers of the four submatrices .",
    "sparsity is handled by checking for ` cht::chunk_id_null ` .",
    "the same matrix - matrix multiplication implementation was used for all test calculations discussed below , for both dense and block - sparse cases .",
    "we performed test calculations on the tintin cluster at the uppmax computer center .",
    "each compute node is a dual amd bulldozer compute server with two 8-core opteron 6220 processors running at 3.0 ghz , with 64 gb of memory per node .",
    "the nodes are interconnected with a 2:1 oversubscribed qdr infiniband fabric .",
    "since the 16 cores on each node share 8 256-bit fused multiply - add ( fma ) units , each node can at best perform 8 * 4 double precision multiply - add operations per cycle . given the clock speed of 3.0 ghz",
    ", this gives a theoretical peak performance of 96 gflop / s per node .",
    "however , one can not expect to reach the theoretical peak performance in practice .",
    "since we used the amd core math library ( acml ) for matrix - matrix products at the lowest level , the acml performance for large dense matrices can be seen as a practical peak performance limit .",
    "we refer to this as `` acml peak '' , which we computed from dense matrix - matrix multiplication with acml for matrix size 12000 @xmath0 12000 using all cores on the node .",
    "this gave an `` acml peak '' value of 80.171 gflop / s per node .",
    "in our test calculations the chunks and tasks library used one mpi process per node , with 15 worker threads per process .",
    "figure [ fig - strong - scaling ] shows strong scaling behavior for dense matrix - matrix multiplication for matrix size 60000 @xmath0 60000 when increasing the number of nodes from 15 to 60 .",
    "figure [ fig - problem - size - scaling ] shows the performance when increasing the problem size for dense matrix - matrix multiplication when running on 60 nodes .",
    "the submatrix size at the lowest level was 1000 @xmath0 1000 .",
    "60000 [ fig - strong - scaling],scaledwidth=50.0% ]    , scaledwidth=50.0% ]    , scaledwidth=50.0% ]    figure  [ fig - varying - fill - factor ] shows results of matrix - matrix multiplication for block - sparse matrices with random sparsity patterns of varying fill factor .",
    "given the specified fill factor the nonzero submatrices were uniformly randomly distributed over the matrix .",
    "the figure shows how the wall time for the matrix square operation decreases with increasing sparsity .    as an initial test of the usefulness of the chunks and tasks programming model for a specific application , linear scaling electronic structure calculations , we have parallelized the overlap matrix computation in the ergo quantum chemistry program@xcite using chunks and tasks .",
    "the ergo program performs electronic structure calculations using gaussian basis sets , where typically a number of basis functions are centered on each atom .",
    "a necessary first step in such a computation is to compute the overlap matrix @xmath1 .",
    "to parallelize this procedure we have used a hierarchic representation of the basis set , where each part of the hierarchy contains basis functions located in a particular part of space . in the same way as for the sparse matrix representation ,",
    "higher levels in the hierarchy contain chunk identifiers referring to basis set descriptions at lower levels .",
    "using such a hierarchic basis set description , it is straightforward to implement tasks to compute the overlap matrix .",
    "one of the most performance - critical parts in linear scaling electronic structure calculations is matrix - matrix multiplication ; in particular , methods for computation of the density matrix usually rely on repeated sparse matrix - matrix multiplication .",
    "we have tested the performance of our matrix - matrix multiplication implementation based on chunks and tasks by computing the square of the overlap matrix for water clusters of varying size .",
    "figure  [ fig - water - clusters - scaling ] shows timings for the computation of @xmath2 when running on 60 nodes .",
    "as expected , the computational time scales roughly linearly with the water cluster size .",
    "the calculations shown in figure  [ fig - water - clusters - scaling ] were done for water clusters of up to 123457 water molecules , corresponding to 864199 gaussian basis functions using the sto-3 g basis set .",
    "a submatrix size of 500 @xmath0 500 was used at the lowest level .",
    "the overlap matrix was truncated so that the frobenius norm of the error matrix was smaller than @xmath3 . for the largest water cluster ,",
    "the overlap matrix then contained 1.20 % nonzero elements , and the product @xmath2 contained 5.34 % nonzero elements .",
    "this corresponds to a total memory requirement of about 391 gb to store @xmath1 and @xmath2 .",
    "the chunks and tasks interface allows the application programmer to define distributed data objects by creating chunks that refer to other chunks through their chunk identifiers .",
    "the programmer does not need to specify where the chunks should be stored .",
    "this gives great flexibility , especially when implementing dynamic hierarchic algorithms where the structure of data to be created is not known beforehand .",
    "thus , compared to other parallelization approaches where the data distribution is explicitly specified by the programmer , the chunks and tasks approach moves more responsibility to the library , letting the programmer focus on algorithm development and to exposing parallelism by making sure distributed objects are represented by trees of chunks .    relieving the programmer of the responsibility for",
    "data distribution means additional challenges when implementing a chunks and tasks library .",
    "however , as demonstrated in section  [ sec : pilot - impl ] , high performance can still be achieved .",
    "chunks and tasks library implementations have great freedom in how data is managed and where tasks are run depending on the required input data .",
    "our pilot implementation demonstrates one possible way to manage data , but many others are certainly possible .",
    "importantly , application programs implemented using the chunks and tasks interface can remain unchanged and still benefit from any future improved library implementations .",
    "the chunks and tasks programming model implicitly imposes certain restrictions on how work and data is handled in an application program .",
    "chunks are read - only .",
    "chunks and tasks are identified by their identifiers provided by the chunks and tasks library upon registration .",
    "it is therefore not possible to register tasks with dependencies on tasks that have not yet been registered .",
    "it is also not possible to create task hierarchies with dependencies across branches .",
    "this stands in contrast to the linda programming model  @xcite where tuples are accessed associatively , with none of the above restrictions .",
    "however , the restrictions imposed by chunks and tasks make implementation of efficient parallel chunks and tasks libraries feasible .",
    "chunk cache coherence is not an issue .",
    "there is no need to resolve dependencies on remote tasks .",
    "furthermore , an efficient library can make use of the chunk identifiers to make data available efficiently , or choose to run tasks where the data is located .",
    "another feature made possible due to the restrictions imposed by the interface is efficient implementation of the ` copychunk ` function . from a user perspective , ` copychunk ` takes a chunk identifier , copies the chunk , and returns an identifier for the new chunk ( the copy ) .    however , a library implementation of ` copychunk ` can take advantage of that chunks are read - only . a copy",
    "is then performed by creating a new chunk identifier that refers to the same chunk .",
    "the library counts all chunk identifiers that refer to the same chunk and delete the whole chunk hierarchy represented by that chunk only when the last copy of the chunk is being deleted .",
    "thus , although the copy is actually a _ shallow copy _ , from a user perspective it should be considered as a _",
    "deep copy_.",
    "so what are the practical implications of this ?",
    "consider , for example , an adaptive mesh refinement algorithm where the mesh is represented by a chunk hierarchy and say that we want to refine a local portion of the mesh .",
    "since chunks are read - only one might think that such a local refinement would incur a replication of the entire mesh .",
    "however , thanks to the copy chunk functionality , only the refined region needs to be reconstructed .",
    "a fault - resilient program is able to continue executing in case of a failure , e.g.  a worker crash .",
    "communication systems such as mpi are not able to single - handedly , without intervention by the application program , handle faults @xcite .",
    "the reason is that , in this programming model , the distribution of data and the program to be executed by each process is the concern of the application programmer and not the mpi library .",
    "the best thing the communication system can do is to gracefully report failures to the application program which then may take appropriate measures @xcite .",
    "one approach to achieve fault - tolerance at the application level is to maintain a shadow copy of all data that is needed to recover in case of a process failure @xcite .",
    "global arrays includes functionality to control the mapping of a global array onto the processes .",
    "this makes it it possible for the user to make sure that primary and shadow copies do not overlap @xcite .",
    "similarly to @xcite , it should with chunks and tasks be possible to achieve resilience to faults at the chunks and tasks library level .",
    "provided that a fault - resilient chunks and tasks library is used , a conforming chunks and tasks application will automatically be fault - resilient .",
    "this can be seen as a consequence of the chunks and tasks not being a spmd programming model ; worker processes are run by the library rather than by the application .",
    "in order for the chunks and tasks library to be resilient , it has to include mechanisms for chunk backup and re - execution of failed tasks . since tasks in chunks and tasks",
    "do not have critical side effects , a fail - safe library does not need to deal with failed tasks that have produced partial output , as in for example  @xcite .",
    "if a task fails , one can simply re - execute it .",
    "recovery of chunks lost due to a process failure can be achieved by storing a shadow copy on another process as described above .",
    "we have presented the chunks and tasks programming model , our answer to the question of how to draw the line between the concerns of an application programmer and the concerns of a parallel library or language .",
    "our philosophy is that application programmers should focus on parallel algorithm development and on _ exposing _ parallelism in both data and work .",
    "this makes the development of parallel programs easier , in particular for applications that require dynamic distribution of both work and data . at the same time ,",
    "chunks and tasks imposes restrictions on data access and task dependencies that make it possible to implement chunks and tasks libraries with high performance .",
    "furthermore , it is possible to achieve fault resilience at the chunks and tasks library level , which derives from the fact that the library is responsible for mapping of both work and data to physical resources .",
    "we see before us that parallelization tools building on the chunks and tasks programming model will expand the applicability of high performance parallel computing to an important class of applications that require dynamic handling of work and data .",
    "stimulating discussions at the pscp colloquium at uppsala university as well as support from the swedish research council under grant no .",
    "623 - 2009 - 803 and from the swedish national strategic e - science research program essence are gratefully acknowledged .",
    "the calculations were performed on resources provided by the swedish national infrastructure for computing ( snic ) at uppsala multidisciplinary center for advanced computational science ( uppmax ) .",
    ".... # include < iostream > # include \" chunks_and_tasks.h \" # include \" fibonacci.h \" int main ( ) {    int n = 13 ;    cht::start ( ) ;    cht::chunkid cid_n = cht::registerchunk(new cint(n ) ) ;    cht::chunkid cid_result =       cht::executemothertask < fibonacci>(cid_n ) ;    //",
    "get result .",
    "cht::shared_ptr < cint const > result ;    cht::getchunk(cid_result , result ) ;    //",
    "delete chunks .",
    "cht::deletechunk(cid_n ) ;    cht::deletechunk(cid_result ) ;    // stop cht services    cht::stop ( ) ;",
    "std::cout < < \" the thirteenth fibonacci number is \"               < < * result < < std::endl ;    return 0 ; } ....    .... # include \" chunks_and_tasks.h \" struct cint : public cht::chunk {    // functions required for a chunk    void writetobuffer(char * databuffer ,                size_t const buffersize ) const ;    size_t getsize ( ) const ;    void assignfrombuffer(char const * databuffer ,               size_t const buffersize ) ;    size_t memoryusage ( ) const ;    // cint specific functionality    cint(int x _ ) : x(x _ ) { }    cint ( ) { }    operator int ( ) const { return x ; }   private :    int x ; // the number itself    cht_chunk_type_declaration ; } ; ....      cht_chunk_type_implementation((cint ) ) ; void cint::writetobuffer(char * databuffer ,                size_t const buffersize ) const {    if ( buffersize ! = getsize ( ) )      throw std::runtime_error(\"wrong buffer size to \"                   \" cint::writetobuffer . \" ) ;    memcpy(databuffer , & x , sizeof(int ) ) ; } size_t cint::getsize ( ) const {    return sizeof(int ) ; } void cint::assignfrombuffer(char const * databuffer ,                   size_t const buffersize ) {    if ( buffersize ! = getsize ( ) )      throw std::runtime_error(\"wrong buffer size to \"                   \" cint::assign_from_buffer . \" ) ;    memcpy(&x , databuffer , sizeof(int ) ) ; } size_t cint::memoryusage ( ) const {    return getsize ( ) ; } ....",
    "cht_task_type_implementation((add ) ) ; cht::id add::execute(cint const & n1 , cint const & n2 ) {    cint result_chunk = n1+n2 ;    cht::chunkid cid_result =       registerchunk(new cint(result_chunk ) , cht::persistent ) ;    return cid_result ; }    cht_task_type_implementation((fibonacci ) ) ; cht::id fibonacci::execute(cint const & n ) {    if(n < 2 )       return copychunk ( getinputchunkid(n ) ) ;    cht::chunkid c1 = registerchunk ( new cint(n-1 ) ) ;    cht::id t1 = registertask < fibonacci > ( c1 ) ;    cht::chunkid c2 = registerchunk ( new cint(n-2 ) ) ;    cht::id t2 = registertask < fibonacci > ( c2 ) ;    return registertask < add>(t1 , t2 , cht::persistent ) ; } //",
    "end execute ....",
    "j.  bueno , j.  planas , a.  duran , r.  m. badia , x.  martorell , e.  ayguad , j.  labarta , productive programming of gpu clusters with ompss , in : 26th international parallel and distributed processing symposium , ieee computer society , 2012 , pp . 557568 .    c.  augonnet ,",
    "s.  thibault , r.  namyst , p .- a .",
    "wacrenier , starpu : a unified platform for task scheduling on heterogeneous multicore architectures , concurrency computat .",
    "23  ( 2 ) ( 2011 ) 187198 .",
    "r.  d. blumofe , p.  a. lisiecki , adaptive and reliable parallel computing on networks of workstations , in : proceedings of the annual conference on usenix annual technical conference , atec 97 , usenix association , berkeley , ca , usa , 1997 , pp . 1010 .    c.  augonnet , o.  aumage , n.  furmento , r.  namyst , s.  thibault , starpu - mpi : task programming over clusters of machines enhanced with accelerators , in : j.  l. trff , s.  benkner , j.  j. dongarra ( eds . ) , recent advances in the message passing interface , vol .",
    "7490 of lecture notes in computer science , springer berlin heidelberg , 2012 , pp . 298299 .",
    "g.  e. fagg , j.  j. dongarra , ft - mpi : fault tolerant mpi , supporting dynamic applications in a dynamic world , in : j.  dongarra , p.  kacsuk , n.  podhorszki ( eds . ) , recent advances in parallel virtual machine and message passing interface , vol .",
    "1908 of lecture notes in computer science , springer berlin heidelberg , 2000 , pp .",
    "346353 .",
    "n.  ali , s.  krishnamoorthy , n.  govind , b.  palmer , a redundant communication approach to scalable fault tolerance in pgas programming models , in : parallel , distributed and network - based processing ( pdp ) , 2011 19th euromicro international conference on , 2011 , pp .",
    "j.  dinan , a.  singri , p.  sadayappan , s.  krishnamoorthy , selective recovery from failures in a task parallel programming model , in : proceedings of the 2010 10th ieee / acm international conference on cluster , cloud and grid computing , ccgrid 10 , ieee computer society , washington , dc , usa , 2010 , pp ."
  ],
  "abstract_text": [
    "<S> we propose chunks and tasks , a parallel programming model built on abstractions for both data and work . </S>",
    "<S> the application programmer specifies how data and work can be split into smaller pieces , chunks and tasks , respectively . </S>",
    "<S> the chunks and tasks library maps the chunks and tasks to physical resources . in this way we seek to combine user friendliness with high performance . </S>",
    "<S> an application programmer can express a parallel algorithm using a few simple building blocks , defining data and work objects and their relationships . </S>",
    "<S> no explicit communication calls are needed ; the distribution of both work and data is handled by the chunks and tasks library . </S>",
    "<S> this makes efficient implementation of complex applications that require dynamic distribution of work and data easier . at the same time , </S>",
    "<S> chunks and tasks imposes restrictions on data access and task dependencies that facilitates the development of high performance parallel back ends . </S>",
    "<S> we discuss the fundamental abstractions underlying the programming model , as well as performance and fault resilience considerations . </S>",
    "<S> we also present a pilot c++ library implementation for clusters of multicore machines and demonstrate its performance for sparse blocked matrix - matrix multiplication .    distributed memory parallelization , dynamic distribution , dynamic load balancing , fault tolerance , parallel programming model , work stealing </S>"
  ]
}