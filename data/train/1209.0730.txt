{
  "article_text": [
    "question of generating random bits from a source of biased coins dates back to von neumann @xcite who observed that when one focuses on a pair of coin tosses , the events ht and th have the same probability ( h is for ` head ' and t is for ` tail ' ) of being generated ; hence , ht produces the output symbol @xmath1 and th produces the output symbol @xmath2 .",
    "the other two possible events , namely , hh and tt , are ignored , namely , they do not produce any output symbols .",
    "however , von neumann s algorithm is not optimal in terms of the number of random bits that are generated .",
    "this problem was solved , specifically , given a fixed number of biased coin tosses with unknown probability , it is well known how to generate random bits with asymptotically optimal efficiency , namely , the expected number of unbiased random bits generated per coin toss is asymptotically equal to the entropy of the biased coin @xcite .",
    "however , these solutions , including elias s algorithm and peres s algorithm , can generate random bits only after receiving the complete input sequence ( or a fixed number of input bits ) , and the number of random bits generated is a random variable .",
    "we consider the setup of generating a  stream \" of random bits ; that is , whenever random bits are required , the algorithm reads new coin tosses and generates random bits dynamically .",
    "our new streaming algorithm is more efficient ( in the number of input bits , memory and time ) for producing the required number of random bits and is a better choice for implementation in practical systems .",
    "we notice that von neumann scheme is the one which is able to generate a stream of random bits , but its efficiency is far from optimal . our goal is to modify this scheme such that it can achieve the information - theoretic upper bound on efficiency .",
    "specifically , we would like to construct a function @xmath3 which satisfies the following conditions :    * @xmath4 generates a stream .",
    "for any two sequences of coin tosses @xmath5 , @xmath6 is a prefix of @xmath7 .",
    "* @xmath4 generates random bits .",
    "let @xmath8 be the sequence of coin tosses inducing @xmath9 bits ; that is , @xmath10 but for any strict prefix @xmath11 of @xmath12 , @xmath13 .",
    "then the first @xmath9 bits of @xmath14 are independent and unbiased .",
    "* @xmath4 has asymptotically optimal efficiency .",
    "that is , for any @xmath15 , @xmath16}{k}\\rightarrow\\frac{1}{h(p)}\\ ] ] as @xmath17 , where @xmath18 is the entropy of the biased coin @xcite .",
    "we note that the von neumann scheme uses only @xmath19 states , i.e. , a symbol in @xmath20 , for storing state information .",
    "for example , the output bit is @xmath1 if and only if the current state is h and the input symbol is t. in this case , the new state is @xmath21 .",
    "similarly , the output bit is @xmath2 if and only if the current state is t and the input symbol is h. in this case , the new state is @xmath21 .",
    "our approach for generalizing von neumann s scheme is by increasing the memory ( or state ) of our algorithm such that we do not lose information that might be useful for generating future random bits .",
    "we represent the state information as a binary tree , called status tree , in which each node is labeled by a symbol in @xmath22 .",
    "when a source symbol ( a coin toss ) is received , we modify the status tree based on certain simple rules and generate random bits in a dynamic way .",
    "this is the key idea in our algorithm ; we call this approach the random - stream algorithm . in some sense , the random - stream algorithm is the streaming version of peres s algorithm .",
    "we show that this algorithm satisfies all three conditions above , namely , it can generate a stream of random bits with asymptotically optimal efficiency . in practice , we can reduce the space size by limiting the depth of the status tree .",
    "we will demonstrate that as the depth of the status tree increases , the efficiency of the algorithm quickly converges to the information - theoretic upper bound .",
    "an extension of the question is to generate random bits or random - bit streams from an arbitrary markov chain with unknown transition probabilities .",
    "this problem was first studied by samuelson @xcite , and his algorithm was later improved by blum @xcite .",
    "recently , we proposed the first known algorithm that runs in expected linear time and achieves the information - theoretic upper bound on efficiency @xcite . in this paper",
    ", we briefly introduce the techniques of generating random - bit streams from markov chains .",
    "the rest of the paper is organized as follows .",
    "section [ stream_section_stream ] presents our key result , the random - stream algorithm that generates random bit streams from arbitrary biased coins and achieves the information - theoretic upper bound on efficiency . in section [ stream_section_generalization ] , we generalize the random - stream algorithm to generate random bit streams from a source of a larger alphabet .",
    "an extension for markov chains is provided in section [ stream_section_markov ] , followed by the concluding remarks .",
    "many algorithms have been proposed for efficiently generating random bits from a fixed number of coins tosses , including elias s algorithm and peres s algorithm . however , in these algorithms , the input bits can be processed only after all of them have been received , and the number of random bits generated can not be controlled . in this section ,",
    "we focus on deriving a new algorithm , the _ random - stream algorithm _ , that generates a stream of random bits from an arbitrary biased - coin source and achieves the information - theoretic upper bound on efficiency .",
    "given an application that requires random bits , the random - stream algorithm can generate random bits dynamically based on requests from the application .    while von neumann s scheme can generate a stream of random bits from an arbitrary biased coin , its efficiency is far from being optimal .",
    "the main reason is that it uses minimal state information , recorded by a symbol of alphabet size three in @xmath23 .",
    "the key idea in our algorithm is to create a binary tree for storing the state information , called a status tree .",
    "a node in the status tree stores a symbol in @xmath24 .",
    "the following procedure shows how the status tree is created and is dynamically updated in response to arriving input bits . at the beginning",
    ", the tree has only a single root node labeled as @xmath21 .",
    "when reading a coin toss from the source , we modify the status tree based on certain rules . for each node in the status tree ,",
    "if it receives a message ( h or t ) , we do operations on the node .",
    "meanwhile , this node may pass some new messages to its children .",
    "iteratively , we can process the status tree until no more messages are generated .",
    "specifically , let @xmath25 be a node in the tree .",
    "assume the label of @xmath25 is @xmath26 and it receives a symbol @xmath27 from its parent node ( or from the source if @xmath25 is the root node ) .",
    "depending on the values of x and y , we do the following operations on node @xmath25 .    1 .",
    "when @xmath28 , set @xmath29 .",
    "2 .   when @xmath30 or @xmath2 , output @xmath31 and set @xmath29 .",
    "3 .   when @xmath32 or @xmath33 , we first check whether @xmath25 has children . if it does not have , we create two children with label @xmath21 for it .",
    "let @xmath34 and @xmath35 denote the two children of @xmath25 . *",
    "if @xmath36 , we set @xmath28 , then pass a symbol @xmath33 to @xmath34 and a symbol @xmath37 to @xmath35 .",
    "* if @xmath38 , we set @xmath28 , then pass a symbol @xmath33 to @xmath34 and a symbol @xmath33 to @xmath35 . *",
    "if @xmath39 , we set @xmath30 , then pass a symbol @xmath37 to @xmath34 .",
    "* if @xmath40 , we set @xmath41 , then pass a symbol @xmath37 to @xmath34 .",
    "+ we see that the node @xmath25 passes a symbol @xmath42 to its left child and if @xmath29 it passes a symbol @xmath31 to its right child .",
    "note that the timing is crucial that we output a node s label ( when it is @xmath1 or @xmath2 ) only after it receives the next symbol from its parent or from the source .",
    "this is different from von neumann s scheme where a @xmath1 or a @xmath2 is generated immediately without waiting for the next symbol .",
    "if we only consider the output of the root node in the status tree , then it is similar to von neumann s scheme .",
    "and the other nodes correspond to the information discarded by von neumann s scheme . in some sense ,",
    "the random - stream algorithm can be treated as a  stream \" version of peres s algorithm .",
    "the following example is constructed for the purpose of demonstration .",
    "[ example1_1 ] assume we have a biased coin and our randomized application requires @xmath43 random bits .",
    "[ fig_peresscheme ] illustrates how the random - stream algorithm works when the incoming stream is htttht ... in this figure , we can see the changes of the status tree and the messages ( symbols ) passed throughout the tree for each step .",
    "we see that the output stream is @xmath44    [ stream_lemma1_1 ] let @xmath11 be the current input sequence and let @xmath45 be the current status tree . given @xmath45 and the bits generated by each node in @xmath45",
    ", we can reconstruct @xmath11 uniquely .    let us prove this lemma by induction .",
    "if the maximum depth of the status tree is @xmath2 , it has only a single node . in this case",
    ", @xmath11 is exactly the label on the single node .",
    "hence the conclusion is trivial .",
    "now we show that if the conclusion holds for all status trees with maximum depth at most @xmath9 , then it also holds for all status trees with maximum depth @xmath46 .    given a status tree @xmath45 with maximum depth @xmath46 ,",
    "we let @xmath47 denote the binary sequence generated by the root node , and @xmath48 are the sequences of symbols received by its left child and right child .",
    "if the label of the root node is in @xmath49 , we add it to @xmath50 . according to the random - stream algorithm , it is easy to get that @xmath51    based on our assumption",
    ", @xmath52 can be constructed from the left and right subtrees and the bits generated by each node in the subtree since their depths are at most @xmath9 .",
    "we show that once @xmath53 satisfy the equality above , the input sequence @xmath11 can be uniquely constructed from @xmath53 and @xmath54 , where @xmath54 is the label of the root node .",
    "the procedure is as follows : let us start from an empty string for @xmath11 and read symbols from @xmath55 sequentially",
    ". if a symbol read from @xmath55 is @xmath37 , we read a bit from @xmath50 . if this bit is @xmath1 we add @xmath56 to @xmath11 , otherwise we add @xmath57 to @xmath11 . if a symbol read from @xmath55 is @xmath33 , we read a symbol ( @xmath37 or @xmath33 ) from @xmath58 . if this symbol is @xmath37 we add @xmath59 to @xmath11 , otherwise we add @xmath60 to @xmath11 .",
    "after reading all the elements in @xmath52 and @xmath50 , the length of the resulting input sequence is @xmath61 .",
    "now , we add @xmath54 to the resulting input sequence if @xmath62 .",
    "this leads to the final sequence @xmath11 , which is unique .",
    "let us consider the status tree in fig .",
    "[ fig_peresscheme](f ) .",
    "and we know that the root node generates @xmath1 and the first node in the second level generates @xmath1",
    ". we can have the following conclusions iteratively .",
    "* in the third level , the symbols received by the node with label h are h , and the node with label @xmath21 does not receive any symbols . * in the second level , the symbols received by the node with label @xmath1 are hth , and the symbols received by the node with label t are t. * for the root node , the symbols received are htttht , which accords with example [ example1_1 ] .",
    "let @xmath63 be the function of the random - stream algorithm .",
    "we show that this function satisfies all the three conditions described in the introduction .",
    "it is easy to see that the first condition holds , i.e. , for any two sequences @xmath5 , @xmath6 is a prefix of @xmath7 , hence it generates streams .",
    "the following two theorems indicate that @xmath4 also satisfies the other two conditions .",
    "[ stream_theorem1]given a source of biased coin with unknown probability , the random - stream algorithm generates a stream of random bits , i.e. , for any @xmath15 , if we stop running the algorithm after generating @xmath9 bits then these @xmath9 bits are independent and unbiased .",
    "let @xmath64 with @xmath65 denote the set consisting of all the binary sequences yielding @xmath50 . here",
    ", we say that a binary sequence @xmath11 _ yields _ @xmath50 if and only if @xmath66 $ ] ( the prefix of @xmath11 with length @xmath67 ) generates a sequence shorter than @xmath50 and @xmath11 generates a sequence with @xmath50 as a prefix ( including @xmath50 itself ) . to prove that the algorithm can generate random - bit streams ,",
    "we show that for any distinct binary sequences @xmath68 , the elements in @xmath69 and those in @xmath70 are one - to - one mapping . the detailed proof is given in subsection [ section_proof1 ] .",
    "[ stream_theorem2 ] given a biased coin with probability @xmath71 being h , let @xmath72 be the number of coin tosses required for generating @xmath9 random bits in the random - stream algorithm , then @xmath73}{k}= \\frac{1}{h(p)}.\\ ] ]    the proof of theorem [ stream_theorem2 ] is based on the fact that the random - stream algorithm is as efficient as peres s algorithm .",
    "the difference is that in peres s algorithm the input length is fixed and the output length is variable .",
    "but in the random - stream algorithm the output length is fixed and the input length is variable .",
    "so the key of the proof is to connect these two cases . the detailed proof is given in subsection [ section_proof2 ] .",
    "so far , we can conclude that the random - stream algorithm can generate a stream of random bits from an arbitrary biased coin with asymptotically optimal efficiency .",
    "however , the size of the binary tree increases as the number of input coin tosses increases .",
    "the longest path of the tree is the left - most path , in which each node passes one message to the next node when it receives two messages from its previous node .",
    "hence , the maximum depth of the tree is @xmath74 for @xmath72 input bits .",
    "this linear increase in space is a practical challenge .",
    "our observation is that we can control the size of the space by limiting the maximum depth of the tree ",
    "if a node s depth reaches a certain threshold , it will stop creating new leaves .",
    "we can prove that this method correctly generates a stream of random bits from an arbitrary biased coin .",
    "we call this method the random - stream algorithm with maximum depth @xmath75 .",
    "[ stream_theorem7 ] given a source of a biased coin with unknown probability , the random - stream algorithm with maximum depth @xmath75 generates a stream of random bits , i.e. , for any @xmath15 , if we stop running the algorithm after generating @xmath9 bits then these @xmath9 bits are independent and unbiased .",
    "the proof of theorem [ stream_theorem7 ] is a simple modification of the proof of theorem [ stream_theorem1 ] , given in subsection [ section_proof3 ] . in order to save memory space ,",
    "we need to reduce the efficiency .",
    "fortunately , as the maximum depth increases , the efficiency of this method can quickly converge to the theoretical limit .    when the maximum depth of the tree is @xmath2 ( it has only the root node ) , then the algorithm is approximately von neumann s scheme .",
    "the expected number of coin tosses required per random bit is @xmath76 asymptotically , where @xmath77 and @xmath71 is the probability for the biased coin being h.    [ stream_theorem3 ] when the maximum depth of the tree is @xmath1 , the expected number of coin tosses required per random bit is @xmath78 asymptotically , where @xmath77 and @xmath71 is the probability for the biased coin being h.    generally , if the maximum depth of the tree is @xmath75 , then we can calculate the efficiency of the random - stream algorithm by iteration in the following way :    [ stream_theorem4 ] when the maximum depth of the tree is @xmath75 and the probability of the biased coin is @xmath71 of being h , the expected number of coin tosses required per random bit is @xmath79 asymptotically , where @xmath80 can be obtained by iterating @xmath81 with @xmath77 and @xmath82 .    theorem [ stream_theorem4 ]",
    "shows that the efficiency of a random - stream algorithm with maximum depth @xmath75 can be easily calculated by iteration .",
    "one thing that we can claim is , @xmath83 however , it is difficult to get an explicit expression for @xmath80 when @xmath75 is finite .",
    "as @xmath75 increases , the convergence rate of @xmath80 depends on the value of @xmath71 .",
    "the following extreme case implies that @xmath80 can converge to @xmath18 very quickly .",
    ".the expected number of coin tosses required per random bit for different probability @xmath71 and different maximum depths [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     [ table2 ]    another property that we consider is the expected time for processing a single coin toss .",
    "assume that it takes a single unit of time to process a message received at a node , then the expected time is exactly the expected number of messages that have been generated in the status tree ( including the input coin toss itself ) .",
    "table [ table2 ] shows the expected time for processing a single input bit when the input is infinitely long , implying the computational efficiency of the random - stream algorithm with limited depth .",
    "it can be proved that for an input generated by an arbitrary biased coin the expected time for processing a single coin toss is upper bounded by the maximum depth plus one ( it is not a tight bound ) .      in this subsection",
    ", we prove theorem [ stream_theorem1 ] .",
    "[ stream_lemma1_2 ] let @xmath45 be the status tree induced by @xmath84 , and let @xmath85 be the number of bits generated by the nodes in @xmath45 , where @xmath86 is the number of nodes in @xmath45 .",
    "then for any @xmath87 with @xmath88 , there exists an unique sequence @xmath89 such that it induces the same status tree @xmath45 , and the bits generated by the @xmath90th node in @xmath45 is @xmath91 .",
    "for such a sequence @xmath92 , it is a permutation of @xmath93 with the same last element .    to prove this conclusion",
    ", we can apply the idea of lemma [ stream_lemma1_1 ] .",
    "it is obviously that if the maximum depth of @xmath45 is zero , then the conclusion is trivial .",
    "assume that the conclusion holds for any status tree with maximum depth at most @xmath9 , then we show that it also holds for any status tree with maximum depth @xmath46 .    given a status tree @xmath45 with maximum depth @xmath46",
    ", we use @xmath94 to denote the binary sequence generated by the root node based on @xmath93 , and @xmath95 to denote the sequences of symbols received by its left child and right child . according to our assumption , by flipping the bits generated by the left subtree",
    ", we can construct an unique sequence @xmath96 uniquely such that @xmath97 is a permutation of @xmath98 with the same last element .",
    "similarly , for the right subtree , we have @xmath99 uniquely such that @xmath100 is a permutation of @xmath101 with the same last element .",
    "assume that by flipping the bits generated by the root node , we get a binary sequence @xmath102 such that @xmath103 ( if the label @xmath104 , we add it to @xmath105 and @xmath102 ) , then @xmath106 which implies that we can construct @xmath92 from @xmath107 and the label @xmath54 on the root node uniquely ( according to the proof of the above lemma ) .",
    "since the length of @xmath92 is uniquely determined by @xmath108 and @xmath54 , we can also conclude that @xmath93 and @xmath92 have the same length .    to see that @xmath92 is a permutation of @xmath93",
    ", we show that @xmath92 has the same number of @xmath37 s as @xmath93 . given a sequence @xmath109 ,",
    "let @xmath110 denote the number of @xmath37 s in @xmath11 .",
    "it is not hard to see that @xmath111 @xmath112 where @xmath113 and @xmath114 due to our assumption .",
    "hence @xmath115 and @xmath92 is a permutation of @xmath93 .",
    "finally , we would like to see that @xmath93 and @xmath92 have the same last element .",
    "that is because if @xmath62 , then both @xmath93 and @xmath92 end with @xmath54 . if @xmath116 , the last element of @xmath92 depends on the last element of @xmath97 , the last element of @xmath100 , and @xmath54 .",
    "our assumption gives that @xmath97 has the same element as @xmath98 and @xmath100 has the same element as @xmath101 .",
    "so we can conclude that @xmath93 and @xmath92 have the same last element .",
    "this completes the proof .    , where the input sequence for ( a ) is htttht , and the input sequence for ( b ) is tththt.,width=326 ]    the status tree of a sequence htttht is given by fig .",
    "[ fig_perestree](a ) .",
    "if we flip the second bit @xmath1 into @xmath2 , see fig .",
    "[ fig_perestree](b ) , we can construct a sequence of coin tosses , which is tththt .",
    "now , we define an equivalence relation on @xmath117 .",
    "[ definition_1 ] let @xmath118 be the status tree of @xmath93 and @xmath119 be the status tree of @xmath92 .",
    "two sequences @xmath120 are equivalent denoted by @xmath121 if and only if @xmath122 , and for each pair of nodes @xmath123 with @xmath124 and @xmath125 at the same position they generate the same number of bits .",
    "let @xmath64 with @xmath65 denote the set consisting of all the binary sequences yielding @xmath50 . here",
    ", we say that a binary sequence @xmath11 _ yields _ @xmath50 if and only if @xmath66 $ ] generates a sequence shorter than @xmath50 and @xmath11 generates a sequence with @xmath50 as a prefix ( including @xmath50 itself ) .",
    "namely , let @xmath4 be the function of the random - stream algorithm , them @xmath126)|<|y|,\\ ] ] @xmath127 to prove that the algorithm can generate random - bit streams , we show that for any distinct binary sequences @xmath68 , the elements in @xmath69 and those in @xmath70 are one - to - one mapping .    [ stream_lemma1_3 ]",
    "let @xmath4 be the function of the random - stream algorithm .",
    "for any distinct binary sequences @xmath68 , if @xmath128 , there are exactly one sequence @xmath129 such that    * @xmath130 .",
    "* @xmath131 and @xmath132 for some binary sequence @xmath133 .",
    "let us prove this conclusion by induction . here",
    ", we use @xmath134 to denote the prefix of @xmath93 of length @xmath135 and use @xmath136 to denote the last symbol of @xmath93 .",
    "so @xmath137 .",
    "when @xmath138 , if @xmath139 , we can write @xmath140 as @xmath141 for some @xmath142 . in this case , we assume that the status tree of @xmath134 is @xmath143 , and in which node @xmath25 generates the first bit @xmath2 when reading the symbol @xmath136 . if we flip the label of @xmath25 from @xmath2 to @xmath1 , we get another status tree , denoted by @xmath144 . using the same argument as lemma [ stream_lemma1_1 ] , we are able to construct a sequence @xmath145 such that its status tree is @xmath144 and it does not generate any bits . concatenating @xmath145 with @xmath136 results in a new sequence @xmath92 , i.e. , @xmath146 , such that @xmath130 and @xmath147 .",
    "similarly , for any sequence @xmath92 that yields @xmath1 , i.e. , @xmath148 , if @xmath147 , we can find a sequence @xmath139 such that @xmath121 and @xmath149 .",
    "so we can say that the elements in @xmath150 and @xmath151 are one - to - one mapping .",
    "now we assume that all the elements in @xmath69 and @xmath70 are one - to - one mapping for all @xmath68 , then we show that this conclusion also holds for any @xmath152 .",
    "two cases need to be considered .",
    "\\1 ) @xmath153 end with the same bit .",
    "without loss of generality , we assume this bit is @xmath2 , then we can write @xmath154 and @xmath155 . if @xmath156 , then we can write @xmath157 in which the first bit of @xmath158 is @xmath2 .",
    "according to our assumption , there exists a sequence @xmath159 such that @xmath130 and @xmath160 . in this case , if we write @xmath161 , then @xmath162 .",
    "so such a sequence @xmath92 satisfies our requirements .    if @xmath163 , that means @xmath164 has been generated before reading the symbol @xmath136 .",
    "let us consider a prefix of @xmath93 , denote by @xmath165 , such that it yields @xmath164 .",
    "in this case , @xmath166 and we can write @xmath167 . according to our assumption",
    ", there exists exactly one sequence @xmath168 such that @xmath169 and @xmath170 .",
    "since @xmath165 and @xmath168 induce the same status tree , if we construct a sequence @xmath171 , then @xmath130 and @xmath92 generates the same bits as @xmath93 when reading symbols from @xmath172 .",
    "it is easy to see that such a sequence @xmath92 satisfies our requirements .    since this result is also true for the inverse case , if @xmath153 end with same bit the elements in @xmath69 and @xmath70 are one - to - one mapping .",
    "\\2 ) let us consider the case that @xmath153 end with different bits .",
    "without loss of generality , we assume that @xmath154 and @xmath173 .",
    "according to the argument above , the elements in @xmath174 and @xmath175 are one - to - one mapping ; and the elements in @xmath176 and @xmath177 are one - to - one mapping .",
    "so our task is to prove that the elements in @xmath178 and @xmath179 are one - to - one mapping . for any sequence @xmath180 ,",
    "let @xmath134 be its prefix of length @xmath135 . here",
    ", @xmath134 generates only zeros whose length is at most @xmath9 .",
    "let @xmath143 denote the status tree of @xmath134 and let @xmath25 be the node in @xmath143 that generates the @xmath181 bit ( zero ) when reading the symbol @xmath136 .",
    "then we can construct a new sequence @xmath145 with status tree @xmath144 such that    * @xmath144 and @xmath143 are the same except the label of @xmath25 is @xmath2 and the label of the node at the same position in @xmath144 is @xmath1 .",
    "* for each node @xmath25 in @xmath143 , let @xmath182 be its corresponding node at the same position in @xmath144 , then @xmath25 and @xmath182 generate the same bits .",
    "the construction of @xmath145 follows the proof of lemma [ stream_lemma1_2 ] .",
    "if we construct a sequence @xmath146 , it is not hard to show that @xmath92 satisfies our requirements , i.e. ,    * @xmath130 ; * @xmath145 generates less than @xmath46 bits , i.e. , @xmath183 ; * if @xmath184 , then @xmath185 , where @xmath186 is for @xmath9 zeros .",
    "also based on the inverse argument , we see that the elements in @xmath178 and @xmath179 are one - to - one mapping .",
    "so if @xmath153 end with different bits , the elements in @xmath69 and @xmath70 are one - to - one mapping .",
    "finally , we can conclude that the elements in @xmath69 and @xmath70 are one - to - one mapping for any @xmath68 with @xmath15 .",
    "this completes the proof .",
    "* theorem [ stream_theorem1 ] . *",
    "_ given a source of biased coin with unknown probability , the random - stream algorithm generates a stream of random bits , i.e. , for any @xmath15 , if we stop running the algorithm after generating @xmath9 bits then these @xmath9 bits are independent and unbiased . _",
    "according to lemma [ stream_lemma1_3 ] , for any @xmath68 , the elements in @xmath69 and @xmath70 are one - to - one mapping .",
    "if two sequences are one - to - one mapping , they have to be equivalent , which implies that their probabilities of being generated are the same .",
    "hence , the probability of generating a sequence in @xmath69 is equal to that of generating a sequence in @xmath70 .",
    "it implies that @xmath187 and @xmath188 have the same probability of being generated for a fixed number @xmath9 .",
    "since this is true for any @xmath68 , the probability of generating an arbitrary binary sequence @xmath65 is @xmath189 .",
    "finally , we have the statement in the theorem .",
    "this completes the proof .",
    "[ stream_lemma2_1 ] given a stream of biased coin tosses , where the probability of generating h is @xmath71 , we run the random - stream algorithm until the number of coin tosses reaches @xmath190 . in this case , let @xmath0 be the number of random bits generated , then for any @xmath191 , if @xmath190 is large enough , we have that @xmath192<\\delta,\\ ] ] where @xmath193 is the entropy of the biased coin .",
    "if we consider the case of fixed input length , then the random - stream algorithm is as efficient as peres s algorithm asymptotically .",
    "using the same proof given in @xcite for peres s algorithm , we can get @xmath194}{l}=h(p).\\ ] ]    given a sequence of coin tosses of length @xmath190 , we want to prove that for any @xmath195 , @xmath196}{e[m]}<-\\epsilon]=0.\\ ] ]    to prove this result , we assume that this limitation holds for @xmath197 , i.e. , for any @xmath198 , if @xmath190 is large enough , then @xmath199}{e[m]}<-\\epsilon_1]<\\delta.\\ ] ] under this assumption , we show that there always exists @xmath200 such that the limitation also holds for @xmath201 . hence , the value of @xmath202 can be arbitrarily small .    in the random - stream algorithm , @xmath190 is the number of symbols ( coin tosses ) received by the root .",
    "let @xmath203 be the number of random bits generated by the root , @xmath204 be the number of random bits generated by its left subtree and @xmath205 be the number of random bits generated by its right subtree .",
    "then it is easy to get @xmath206    since the @xmath203 random bits generated by the root node are independent , we can always make @xmath190 large enough such that @xmath207}{e[m_1]}<-\\epsilon_1/2]<\\delta/3.\\ ] ] at the same time , by making @xmath190 large enough , we can make both @xmath204 and @xmath205 large enough such that ( based on our assumption ) @xmath208}{e[m_{(l)}]}<-\\epsilon_1]<\\delta/3\\ ] ] and @xmath209}{e[m_{(r)}]}<-\\epsilon_1]<\\delta/3.\\ ] ]    based on the three inequalities above , we can get @xmath210\\leq -\\epsilon_1 ( \\frac{e[m_1]}{2 } + e[m_{(l)}]+e[m_{(r)}])]<\\delta.\\ ] ]    if we set @xmath211}{2 } + e[m_{(l)}]+e[m_{(r)}]}{e[m_1+m_{(l)}+m_{(r)}]},\\ ] ] then @xmath199}{e[m]}<-\\epsilon_2]<\\delta.\\ ] ]    given the probability @xmath71 of the coin , when @xmath190 is large , @xmath212=\\theta(e[m ] ) , e[m_{(l)}]=\\theta(e[m ] ) , e[m_{(r)}]=\\theta(e[m]),\\ ] ] which implies that @xmath200 .",
    "so we can conclude that for any @xmath213 , if @xmath190 is large enough then @xmath199}{e[m]}<-\\epsilon]<\\delta.\\ ] ] and based on the fact that @xmath214\\rightarrow lh(p)$ ] , we get the result in the lemma .",
    "* theorem [ stream_theorem2 ] . *",
    "_ given a biased coin with probability @xmath71 being h , let @xmath72 be the number of coin tosses required for generating @xmath9 random bits in the random - stream algorithm , then @xmath73}{k}= \\frac{1}{h(p)}.\\ ] ] _",
    "for any @xmath191 , we set @xmath215 , according to the conclusion of the previous lemma , with probability at least @xmath216 , the output length is at least @xmath9 if the input length @xmath190 is fixed and large enough . in another word , if the output length is @xmath9 , which is fixed , then with probability at least @xmath216 , the input length @xmath217 .    so with probability less than @xmath218 , we require more than @xmath190 coin tosses .",
    "the worst case is that we did not generate any bits for the first @xmath190 coin tosses . in this case , we need to generate @xmath9 more random bits . as a result ,",
    "the expected number of coin tosses required is at most @xmath219 $ ] .",
    "based on the analysis above , we derive @xmath220\\leq ( 1-\\delta)l + ( \\delta ) ( l+e[n]),\\ ] ] then @xmath220\\leq \\frac{l}{1-\\delta}=\\frac{k}{h(p)}\\frac{(1+\\epsilon)}{(1-\\delta)}.\\ ] ]    since @xmath221 can be arbitrarily small when @xmath190 ( or @xmath9 ) is large enough @xmath73}{k}\\leq \\frac{1}{h(p)}.\\ ] ]    based on shannon s theory @xcite , it is impossible to generate @xmath9 random bits from a source with expected entropy less than @xmath9 . hence @xmath222 \\geq k,\\ ] ] i.e. , @xmath73}{k}\\geq \\frac{1}{h(p)}.\\ ] ]    finally , we get the conclusion in the theorem .",
    "this completes the proof .",
    "the proof of theorem [ stream_theorem7 ] is very similar as the proof of theorem [ stream_theorem1 ] .",
    "let @xmath64 with @xmath65 denote the set consisting of all the binary sequences yielding @xmath50 in the random - stream algorithm with limited maximum depth .",
    "then for any distinct binary sequences @xmath68 , the elements in @xmath69 and those in @xmath70 are one - to - one mapping . specifically , we can get the following lemma .",
    "let @xmath4 be the function of the random - stream algorithm with maximum depth @xmath75 .",
    "for any distinct binary sequences @xmath68 , if @xmath128 , there exists one sequence @xmath129 such that    * @xmath121 .",
    "* let @xmath118 be the status tree of @xmath93 and @xmath119 be the status tree of @xmath92 .",
    "for any node @xmath25 with depth larger than @xmath75 in @xmath118 , let @xmath182 be its corresponding node in @xmath119 at the same position , then @xmath25 and @xmath182 generate the same bits .",
    "* @xmath131 and @xmath132 for some binary sequence @xmath133 .",
    "the proof of this lemma is a simple modification of that for lemma [ stream_lemma1_3 ] , which is by induction .",
    "a simple sketch is given as follows .",
    "first , similar as the proof for lemma [ stream_lemma1_3 ] , it can be proved that : when @xmath138 , for any sequence @xmath223 , there exists one sequence @xmath148 such that @xmath224 satisfy the conditions in the lemma , and vice versa .",
    "so we can say that the elements in @xmath150 and @xmath151 are one - to - one mapping .",
    "then we assume that all the elements in @xmath69 and @xmath70 are one - to - one mapping for all @xmath225 , then we show that this conclusion also holds for any @xmath226 .",
    "two cases need to be considered .",
    "\\1 ) @xmath153 end with the same bit .",
    "without loss of generality , we assume this bit is @xmath2 , then we can write @xmath154 and @xmath155 .",
    "if @xmath227 , then according to our assumption , it is easy to prove the conclusion , i.e. , there exists a sequence @xmath92 satisfies the conditions .",
    "if @xmath228 , then we can write @xmath167 and @xmath229 . according to our assumption , for the sequence @xmath165 , we can find its mapping @xmath168 such that ( 1 ) @xmath230 ; ( 2 ) @xmath231 induce the same status tree and their corresponding nodes with depth larger than @xmath75 generate the same bits ; and ( 3 ) @xmath232 and @xmath233 . if we construct a sequence @xmath234 , it will satisfy all the conditions in the lemma .    since this result is also true for the inverse case , if @xmath153 end with same bit , the elements in @xmath69 and @xmath70 are one - to - one mapping .",
    "\\2 ) @xmath235 end with different bits .",
    "without loss of generality , we assume that @xmath236 and @xmath173 .",
    "according to the argument above , the elements in @xmath237 and @xmath69 are one - to - one mapping ; and the elements in @xmath238 and @xmath70 are one - to - one mapping .",
    "so we only need to prove that the elements in @xmath237 and @xmath238 are one - to - one mapping . in this case , for any @xmath239 , let @xmath137 with a single symbol @xmath136",
    ". then @xmath134 generates only zeros whose length is at most @xmath9 .",
    "let @xmath143 denote the status tree of @xmath134 and let @xmath25 be the node in @xmath143 that generates the @xmath240th bit ( zero ) when reading the symbol @xmath136 .",
    "note that the depth of @xmath25 is at most @xmath75 . in this case",
    ", we can construct a new sequence @xmath145 with status tree @xmath144 such that    * @xmath144 and @xmath143 are the same except the label of @xmath25 is @xmath2 and the label of the node at the same position in @xmath144 is @xmath1 .",
    "* for each node @xmath25 in @xmath143 , let @xmath182 be its corresponding node at the same position in @xmath144 , then @xmath25 and @xmath182 generate the same bits .",
    "then we can prove that the sequence @xmath146 satisfies our all our conditions in the lemma .",
    "also based on the inverse argument , we can claim that the elements in @xmath241 and @xmath242 are one - to - one mapping .",
    "finally , we can conclude that the elements in @xmath69 and @xmath70 are one - to - one mapping for any @xmath243 with @xmath244 .",
    "this completes the proof .    from the above lemma , it is easy to get theorem [ stream_theorem7 ] .    * theorem [ stream_theorem7 ] . *",
    "_ given a source of biased coin with unknown probability , the random - stream algorithm with maximum depth @xmath75 generates a stream of random bits , i.e. , for any @xmath15 , if we stop running the algorithm after generating @xmath9 bits then these @xmath9 bits are independent and unbiased .",
    "_    we can apply the same procedure of proving theorem [ stream_theorem2 ] .",
    "similar to the proof of theorem [ stream_theorem2 ] , we first consider the case that the input length is fixed .",
    "[ stream_lemma2_2 ] given a stream of biased coin tosses , where the probability of generating h is @xmath71 , we run the random - stream algorithm with maximum depth @xmath75 until the number of coin tosses reaches @xmath190 . in this case , let @xmath0 be the number of random bits generated , then for any @xmath191 , if @xmath190 is large enough , we have that @xmath245<\\delta,\\ ] ] where @xmath80 is given in ( [ stream_equ_efficiencydepthd ] ) .",
    "let @xmath80 be the asymptotic expected number of random bits generated per coin toss when the random - stream algorithm has maximum depth @xmath75 and the probability of the biased coin is @xmath71",
    ". then @xmath246}{l}=\\rho_d(p).\\ ] ] when the fixed input length @xmath190 is large enough , the random - stream algorithm generates approximately @xmath247 random bits , which are generated by the root node , the left subtree ( subtree rooted at root s left child ) and the right subtree ( subtree rooted at the root s right child ) .",
    "considering the root node , it generates approximately @xmath248 random bits with @xmath77 .",
    "meanwhile , the root node passes approximately @xmath249 messages ( h or t ) to its left child , where the messages are independent and the probability of h is @xmath250 ; and the root node passes approximately @xmath251 messages ( h or t ) to its right child , where the messages are independent and the probability of h is @xmath252 . as a result , according to the definition of @xmath253 , the left subtree generates approximately @xmath254 random bits , and the right subtree generates approximately @xmath255 random bits . as @xmath256 , we have @xmath257 it yields @xmath258 so we can calculate @xmath80 by iteration . when @xmath259 , the status tree has the single root node , and it is easy to get @xmath82 .",
    "then , following the proof of lemma [ stream_lemma2_1 ] , for any @xmath191 , if @xmath190 is large enough , we have that @xmath199}{e[m]}<-\\epsilon]<\\delta.\\ ] ]    so we can get the conclusion in the lemma .",
    "this completes the proof .    from the above lemma",
    ", we can get theorem [ stream_theorem4 ] , that is ,    * theorem [ stream_theorem4 ] . * _ when the maximum depth of the tree is @xmath75 and the probability of the biased coin is @xmath71 of being h , the expected number of coin tosses required per random bit is @xmath79 asymptotically , where @xmath80 can be obtained by iterating @xmath260 with @xmath77 and @xmath82 .",
    "_    we can apply the same procedure of proving theorem [ stream_theorem1 ] except we apply lemma [ stream_lemma2_2 ] instead of lemma [ stream_lemma2_1 ] .",
    "in @xcite , we introduced a universal scheme for transforming an arbitrary algorithm for generating random bits from a sequence of biased coin tosses to manage the general source of an @xmath0-sided die .",
    "this scheme works when the input is a sequence of fixed length ; in this section , we study how to modify this scheme to generate random - bit streams from @xmath0-sided dice .",
    "for sake of completeness we describe the original scheme here .",
    "the main idea of the scheme is to convert a sequence with alphabet larger than two , written as @xmath261 into multiple binary sequences . to do this ,",
    "we create a binary tree , called a binarization tree , in which each node is labeled with a binary sequence of h and t. given the binary representations of @xmath262 for all @xmath263 , the path of each node in the tree indicates a prefix , and the binary sequence labeled at this node consists of all the bits ( h or t ) following the prefix in the binary representations of @xmath264 ( if it exists ) .",
    "[ fig_prefixtree ] is an instance of binarization tree when the input sequence is @xmath265 , produced by a @xmath19-sided die . to see this",
    ", we write each symbol ( die roll ) into a binary representation of length two , hence @xmath11 can be represented as @xmath266 only collecting the first bits of all the symbols yields an independent binary sequence @xmath267 which is labeled on the root node ; collecting the second bits following t , we get another independent binary sequence @xmath268 which is labeled on the left child of the root node .",
    "the universal scheme says that we can ` treat ' each binary sequence labeled on the binarization tree as a sequence of biased coin tosses : let @xmath269 be any algorithm that can generate random bits from an arbitrary biased coin , then applying @xmath269 to each of the sequences labeled on the binarization tree and concatenating their outputs together results in an independent and unbiased sequence , namely , a sequence of random bits .    specifically , given the number of sides @xmath0 of a loaded die , the depth of the binarization tree is @xmath270 .",
    "let @xmath271 denote the set consisting of all the binary sequences of length at most @xmath272 , i.e. , @xmath273 given @xmath274 , let @xmath275 denote the binary sequence labeled on a node corresponding to a prefix @xmath276 in the binarization tree , then we get a group of binary sequences @xmath277 for any function @xmath269 that generates random bits from a fixed number of coin tosses , we can generate random bits from @xmath11 by calculating @xmath278 where @xmath279 is the concatenation of @xmath280 and @xmath281 .",
    "so in the above example , the output of @xmath265 is @xmath282 , i.e. , @xmath283 this conclusion is simple , but not obvious , since the binary sequences labeled on the same binarization tree are correlated with each other .",
    "we want to generalize the random - stream algorithm to generate random - bit streams from an @xmath0-sided die . using the similar idea as above ,",
    "we convert the input stream into multiple binary streams , where each binary stream corresponds to a node in the binalization tree .",
    "we apply the random - stream algorithm to all these binary streams individually , and for each stream we create a status tree for storing state information . when we read a dice roll of @xmath0 sides from the source , we pass all the @xmath284 bits of its binary representation to @xmath285 different streams that corresponds to a path in the binalization tree",
    ". then we process all these @xmath286 streams from top to bottom along that path . in this way",
    ", a single binary stream is produced .",
    "while each node in the binalization tree generates a random - bit stream , the resulting single stream is a mixture of these random - bit streams .",
    "but it is not obvious whether the resulting stream is a random - bit stream or not , since the values of the bits generated affect their orders .",
    "the following example is constructed for demonstrating this algorithm .",
    ".,width=345 ]    let us consider a stream of symbols generated from a @xmath19-sided die , @xmath287 instead of storing a binary sequence at each node in the binalization tree , we associate each node with a status tree corresponding to a random - stream algorithm . here , we get two nontrivial binary streams @xmath288 corresponding to prefix @xmath21 and @xmath33 respectively , fig . [ fig_generalized ] demonstrates how the status trees change when we read symbols one by one .",
    "for instance , when the @xmath289th symbol @xmath1(th ) is read , it passes t to the root node ( corresponding to the prefix @xmath21 ) and passes h to the left child of the root node ( corresponding to the prefix t ) of the binalization tree .",
    "based on the rules of the random - stream algorithm , we modify the status trees associated with these two nodes . during this process",
    ", a bit @xmath2 is generated .    finally , this scheme generates a stream of bits @xmath290 , where the first bit is generated after reading the @xmath289th symbol , the second bit is generated after reading the @xmath291th symbol , ... we call this scheme as the generalized random - stream algorithm .",
    "as we expected , this algorithm can generate a stream of random bits from an arbitrary loaded die with @xmath292 sides .",
    "[ stream_theorem5 ] given a loaded die with @xmath292 sides , if we stop running the generalized random - stream algorithm after generating @xmath9 bits , then these @xmath9 bits are independent and unbiased .",
    "the proof of the above theorem is given in subsection [ stream_section_provetheorem5 ] .",
    "since the random - stream algorithm is as efficient as peres s algorithm asymptotically , we can prove that the generalized random - stream algorithm is also asymptotically optimal .",
    "[ stream_theorem6 ] given an @xmath0-sided die with probability distribution @xmath293 , let @xmath72 be the number of symbols ( dice rolls ) used in the generalized random - stream algorithm and let @xmath9 be the number of random bits generated , then @xmath73}{k}=\\frac{1}{h(p_0,p_1, ... ,p_{m-1})},\\ ] ] where @xmath294 is the entropy of the @xmath0-sided die .",
    "first , according to shannon s theory , it is easy to get that @xmath73}{k}\\geq \\frac{1}{h(p_0,p_1, ... ,p_{m-1})}.\\ ] ]    now , we let @xmath295 with an arbitrary @xmath195 .",
    "following the proof of theorem 7 in @xcite , it can be shown that when @xmath9 is large enough , the algorithm generates more than @xmath9 random bits with probability at least @xmath216 with any @xmath198 . then using the same argument in theorem [ stream_theorem2 ]",
    ", we can get @xmath73}{k}\\leq \\frac{1}{h(p_0,p_1, ... ,p_{m-1})}\\frac{1+\\epsilon}{1-\\delta},\\ ] ] for any @xmath296 .",
    "hence , we can get the conclusion in the theorem .    of source , we can limit the depths of all the status trees for saving space , with proof emitted .",
    "it can be seen that given a loaded die of @xmath0 sides , the space usage is proportional to @xmath0 and the expected computational time is proportional to @xmath297 .      here , we want to prove that the generalized random - stream algorithm generates a stream of random bits from an arbitrary @xmath0-sided die . similar as above ,",
    "we let @xmath64 with @xmath65 denote the set consisting of all the sequences yielding @xmath50 . here",
    ", we say that a sequence @xmath11 yields @xmath50 if and only if @xmath66 $ ] generates a sequence shorter than @xmath50 and @xmath11 generates a sequence with @xmath50 as a prefix ( including @xmath50 itself ) .",
    "we would like to show that the elements in @xmath69 and those in @xmath70 are one - to - one mapping if @xmath187 and @xmath188 have the same length .",
    "[ definition_2 ] two sequences @xmath298 with @xmath299 are equivalent , denoted by @xmath121 , if and only @xmath300 for all @xmath301 , where @xmath302 is the binary sequence labeled on a node corresponding to a prefix @xmath276 in the binalization tree induced by @xmath93 , and the equivalence of @xmath302 and @xmath303 was given in definition [ definition_1 ] .    _",
    "@xcite _ [ stream_lemma_biasedcoin ] let @xmath304 with @xmath301 be the binary sequences labeled on the binarization tree of @xmath305 as defined above .",
    "assume @xmath306 is a permutation of @xmath307 for all @xmath301 , then there exists exactly one sequence @xmath308 such that it yields a binarization tree that labels @xmath309 with @xmath301 .    the proof is provided in @xcite .",
    "let @xmath4 be the function of the generalized random - stream algorithm , and let @xmath93 be a sequence produced by an @xmath0-sided die . for any distinct sequences @xmath68 , if @xmath310 , there are exactly one sequence @xmath129 such that    * @xmath130 .",
    "* @xmath131 and @xmath132 for some binary sequence @xmath311 .",
    "the idea of the proof is to combine the proof of lemma [ stream_lemma1_3 ] with the result in lemma [ stream_lemma_biasedcoin ] .",
    "let us prove this conclusion by induction . here , we use @xmath134 to denote the prefix of @xmath93 of length @xmath135 and use @xmath136 to denote the last symbol of @xmath93 .",
    "so @xmath137 .",
    "@xmath312 is the binary sequence labeled on a node corresponding to a prefix @xmath276 in the binalization tree induced by @xmath134 , and the status tree of @xmath313 with @xmath314 is denoted as @xmath315 .",
    "when @xmath138 , if @xmath139 , we can write @xmath140 as @xmath141 . in this case , let @xmath25 in @xmath316 with @xmath317 be the node that generates the first bit @xmath2 . if we flip the label of @xmath25 from @xmath2 to @xmath1 , we get another status tree @xmath318 . using the same argument in lemma [ stream_lemma1_2 ] , we are able to construct a sequence @xmath319 such that its status tree is @xmath318 and it does not generate any bits .",
    "here , @xmath319 is a permutation of @xmath320 . from @xmath321",
    ", we can construct a sequence @xmath145 uniquely following the proof of lemma [ stream_lemma_biasedcoin ] ( see @xcite ) .",
    "concatenating @xmath145 with @xmath136 results in a new sequence @xmath92 , i.e. , @xmath146 such that @xmath130 and @xmath147 .",
    "inversely , we can get the same result .",
    "it shows that the elements in @xmath150 and @xmath151 are one - to - one mapping .",
    "now we assume that the conclusion holds for all @xmath68 , then we show that it also holds for any @xmath152 .",
    "two cases need to be considered .",
    "\\1 ) @xmath153 end with the same bit . without loss of generality , we assume that this bit is @xmath2",
    ", then we can write @xmath154 and @xmath155 .",
    "if @xmath93 yields @xmath187 , based on our assumption , it is easy to see that there exists a sequence @xmath92 satisfies our requirements . if @xmath93 does not yield @xmath187 , that means @xmath164 has been generated before reading the symbol @xmath136 .",
    "let us consider a prefix of @xmath93 , denote by @xmath165 , such that it yields @xmath164 .",
    "in this case , @xmath166 and we can write @xmath322 . according to our assumption",
    ", there exists exactly one sequence @xmath168 such that @xmath169 and @xmath170 .",
    "since @xmath165 and @xmath168 lead to the same binalization tree ( all the status trees at the same positions are the same ) , if we construct a sequence @xmath171 , then @xmath130 and @xmath92 generates the same bits as @xmath93 when reading symbols from @xmath172 .",
    "it is easy to see that such a sequence @xmath92 satisfies our requirements .    since this result is also true for the inverse case , if @xmath152 end with the same bit , the elements in @xmath69 and @xmath70 are one - to - one mapping .",
    "\\2 ) let us consider the case that @xmath153 end with different bits .",
    "without loss of generality , we assume that @xmath154 and @xmath173 .",
    "according to the argument above , the elements in @xmath174 and @xmath175 are one - to - one mapping ; the elements in @xmath176 and @xmath177 are one - to - one mapping .",
    "so our task is to prove that the elements in @xmath178 and @xmath179 are one - to - one mapping . for any sequence @xmath180 ,",
    "let @xmath134 be its prefix of length @xmath135 . here",
    ", @xmath134 generates only zeros whose length is at most @xmath9 .",
    "let @xmath323 denote one of the status trees such that @xmath324 is the node that generates that @xmath181 bit ( zero ) when reading the symbol @xmath136 .",
    "then we can construct a new sequence @xmath145 such that    * let @xmath325 with @xmath314 be the binary sequences induced by @xmath145 , and let @xmath326 be the status tree of @xmath306 .",
    "the binalization trees of @xmath134 and @xmath145 are the same ( all the status trees at the same positions are the same ) , except the label of @xmath25 is @xmath2 and the label of its corresponding node @xmath182 in @xmath318 is @xmath1 . *",
    "each node @xmath25 in @xmath326 generates the same bits as its corresponding node @xmath182 in @xmath327 for all @xmath314 .",
    "the construction of @xmath145 follows the proof of lemma [ stream_lemma1_1 ] and then lemma [ stream_lemma_biasedcoin ] .",
    "if we construct a sequence @xmath146 , it is not hard to show that @xmath92 satisfies our requirements , i.e. ,    * @xmath130 ; * @xmath145 generates less than @xmath46 bits , i.e. , @xmath183 ; * if @xmath161 , then @xmath328 .",
    "also based on the inverse argument , we see that the elements in @xmath178 and @xmath179 are one - to - one mapping .",
    "finally , we can conclude that the elements in @xmath69 and @xmath70 are one - to - one mapping for any @xmath68 with @xmath15 .",
    "this completes the proof .",
    "based on the above result and the argument for theorem [ stream_theorem1 ] , we can easily prove theorem [ stream_theorem5 ] .    * theorem [ stream_theorem5 ] .",
    "* _ given a loaded die with @xmath292 sides , if we stop running the generalized random - stream algorithm after generating @xmath9 bits , then these @xmath9 bits are independent and unbiased . _",
    "in this section , we study how to efficiently generate random - bit streams from markov chains .",
    "the nonstream case was studied by samuelson @xcite , blum @xcite and later generalized by zhou and bruck @xcite . here , using the techniques developed in @xcite , and applying the techniques introduced in this paper , we are able to generate random - bit streams from markov chains .",
    "we present the algorithm briefly .    for a given markov chain , it generates a stream of states , denoted by @xmath329 .",
    "we can treat each state , say @xmath330 , as a die and consider the ` next states ' ( the states the chain has transitioned to after being at state @xmath330 ) as the results of a die roll , called the exit of @xmath330 .",
    "for all @xmath331 , if we only consider the exits of @xmath330 , they form a stream .",
    "so we have total @xmath0 streams corresponding to the exits of @xmath332 respectively .",
    "for example , assume the input is @xmath333    if we consider the states following @xmath334 , we get a stream as the set of states in boldface : @xmath335    hence the four streams are @xmath336    the generalized random - stream algorithm is applied to each stream separately for generating random - bit streams . here , when we get an exit of a state @xmath330 , we should not directly pass it to the generalized random - stream algorithm that corresponds to the state @xmath330 .",
    "instead , it waits until we get the next exit of the state @xmath330 . in another word",
    ", we keep the current exit in pending . in the above example ,",
    "after we read @xmath337 , @xmath338 has been passed to the generalized random - stream algorithm corresponding to @xmath334 , @xmath339 has been passed to the generalized random - stream algorithm corresponding to @xmath340, ... the most recent exit of each state , namely @xmath341 are in pending .",
    "finally , we mix all the bits generated from different streams based on their natural generating order . as a result",
    ", we get a stream of random bits from an arbitrary markov chain , and it achieves the information - theoretic upper bound on efficiency .",
    "now , we call this algorithm the random - stream algorithm for markov chains , and we describe it as follows .",
    "= 0.5em    * input : * a stream @xmath342 produced by a markov chain , where @xmath343 .",
    "* output : * a stream of @xmath344s and @xmath345s .",
    "* main function : *    let @xmath346 be the generalized random - stream algorithm for the exits of @xmath347 for @xmath348 , and @xmath349 be the pending exit of @xmath347 for @xmath348 . set @xmath350 for @xmath348 .",
    "input @xmath349 to @xmath346 for processing .",
    "set @xmath351 .    given a source of a markov chain with unknown transition probabilities , the random - stream algorithm for markov chains generates a stream of random bits , i.e. , for any @xmath15 , if we stop running the algorithm after generating @xmath9 bits then these @xmath9 bits are independent and unbiased .",
    "the proof of the above theorem is a simple extension of the proof for theorem [ stream_theorem5 ] .",
    "let @xmath64 denote the set of input sequences that yield a binary sequence @xmath50 .",
    "our main idea is still to prove that all the elements in @xmath69 and @xmath70 are one - to - one mapping for all @xmath68 with @xmath15 .",
    "the detailed proof is a little complex , but it is not difficult ; we only need to follow the proof of theorem [ stream_theorem5 ] and combine it with the following result from @xcite . here",
    ", we omit the detailed proof .",
    "given an input sequence @xmath352 that produced from a markov chain , let @xmath353 be the exit sequence of @xmath347 ( the symbols following @xmath347 ) for @xmath348 .",
    "assume that @xmath354 $ ] is an arbitrary collection of exit sequences such that @xmath355 and @xmath353 are permutations and they have the same last element for all @xmath348 .",
    "then there exists a sequence @xmath356 such that @xmath357 and @xmath358 for all @xmath348 . for this @xmath359",
    ", we have @xmath360 .",
    "in this paper , we addressed the problem of generating random - bit streams from i.i.d .",
    "sources with unknown distributions .",
    "first , we considered the case of biased coins and derived a simple algorithm to generate random - bit streams .",
    "this algorithm achieves the information - theoretic upper bound on efficiency .",
    "we showed that this algorithm can be generalized to generate random - bit streams from an arbitrary @xmath0-sided die with @xmath299 , and its information efficiency is also asymptotically optimal .",
    "furthermore , we demonstrated that by applying the ( generalized ) random - stream algorithm , we can generate random - bit streams from an arbitrary markov chain very efficiently .",
    "h. zhou and j. bruck ,  a universal scheme for transforming binary algorithms to generate random bits from loaded dice , \" , technical report , department of electrical engineering , california institute of technology , 2012 ."
  ],
  "abstract_text": [
    "<S> generating random bits from a source of biased coins ( the biased is unknown ) is a classical question that was originally studied by von neumann . </S>",
    "<S> there are a number of known algorithms that have asymptotically optimal information efficiency , namely , the expected number of generated random bits per input bit is asymptotically close to the entropy of the source . </S>",
    "<S> however , only the original von neumann algorithm has a ` streaming property ' - it operates on a single input bit at a time and it generates random bits when possible , alas , it does not have an optimal information efficiency .    </S>",
    "<S> the main contribution of this paper is an algorithm that generates random bit streams from biased coins , uses bounded space and runs in expected linear time . as the size of the allotted space increases , the algorithm approaches the information - theoretic upper bound on efficiency . </S>",
    "<S> in addition , we discuss how to extend this algorithm to generate random bit streams from @xmath0-sided dice or correlated sources such as markov chains .    random number generation , biased coins , markov chains , streams . </S>"
  ]
}