{
  "article_text": [
    "the offline software framework of the pierre auger observatory  @xcite provides an infrastructure to support a variety of distinct computational tasks necessary to analyze data gathered by the observatory .",
    "the observatory itself is designed to measure the extensive air showers produced by the highest energy cosmic rays ( @xmath0  ev ) with the goal of discovering their origins and composition .",
    "two different techniques are used to detect air showers .",
    "firstly , a collection of telescopes is used to sense the fluorescence light produced by excited atmospheric nitrogen as the cascade of particles develops and deposits energy in the atmosphere .",
    "this method can be used only when the sky is moonless and dark , and thus has roughly a 15% duty cycle .",
    "secondly , an array of detectors on the ground is used to sample particle densities and arrival times as the air shower impinges upon the earth s surface .",
    "each surface detector consists of a tank containing 12 tons of purified water instrumented with photomultiplier tubes to detect the cherenkov light produced by passing particles .",
    "the surface detector has a 100% duty cycle .",
    "a subsample of air showers detected by both instruments , dubbed hybrid events , are very precisely measured and provide an invaluable energy calibration tool . in order to provide full sky coverage ,",
    "the baseline design of the observatory calls for two sites , one in the southern hemisphere and one in the north .",
    "the southern site is located in mendoza , argentina , and construction there is nearing completion , at which time the observatory will comprise 24 fluorescence telescopes overlooking 1600 surface detectors spaced 1.5  km apart on a hexagonal grid .",
    "the state of colorado in the usa has been selected as the location for the northern site .",
    "the requirements of this project place rather strong demands on the software framework underlying data analysis .",
    "most importantly , the framework must be flexible and robust enough to support the collaborative effort of a large number of physicists developing a variety of applications over the projected 20 year lifetime of the experiment .",
    "specifically , the software must support simulation and reconstruction of events using surface , fluorescence and hybrid methods , as well as simulation of calibration techniques and other ancillary tasks such as data preprocessing .",
    "further , as the experimental run will be long , it is essential that the software be extensible to accommodate future upgrades to the observatory instrumentation .",
    "the offline framework must also handle a number of data formats in order to deal with event and monitoring information from a variety of instruments , as well as the output of air shower simulation codes .",
    "additionally , it is desirable that all physics code be `` exposed '' in the sense that any collaboration member must be able to replace existing algorithms with his or her own in a straightforward manner .",
    "finally , while the underlying framework itself may exploit the full power of c++ and object - oriented design , the portions of the code directly used by physicists should not assume a particularly detailed knowledge of these topics .",
    "the offline framework was designed with these principles in mind .",
    "implementation began in 2002 , and the first physics results based upon this code were presented at the @xmath1 international cosmic ray conference  @xcite .",
    "the offline framework comprises three principal parts : a collection of processing _ modules _ which can be assembled and sequenced through instructions provided in an xml file , an _ event _ data model through which modules can relay data to one another and which accumulates all simulation and reconstruction information , and a _ detector description _ which provides a gateway to data describing the configuration and performance of the observatory as well as atmospheric conditions as a function of time .",
    "these ingredients are depicted in fig .",
    "[ f : general ] .",
    "this approach of pipelining processing modules which communicate through an event serves to separate data from the algorithms which operate on these data . though this approach is not particularly characteristic of object oriented design , it was used nonetheless , as it better satisfies the requirements of physicists whose primary objective is collaborative development and refinement of algorithms .",
    "these components are complemented by a set of foundation classes and utilities for error logging , physics and mathematical manipulation , as well as a unique package supporting abstract manipulation of geometrical objects .",
    "each of these aspects of the framework is described in more detail below .",
    "experience has shown that most tasks of interest of the pierre auger collaboration can be factorized into sequences of self contained processing steps .",
    "physicists prepare such processing algorithms in so - called _ modules _ , which they register with the framework via a macro .",
    "this modular design allows collaborators to exchange code easily , compare algorithms and build up a wide variety of applications by combining modules in various sequences .",
    "modules inherit a common interface which declares the methods that carry out processing .",
    "specifically , module authors must implement a ` run ` method which is called once per event , as well as ` init ` and ` finish ` methods to be called at the beginning and end of a processing job .",
    "authors invoke a macro in the module class declaration which registers a factory function used by the framework to instantiate the module when requested .",
    "the registry mechanism provides a fall - back hook that handles requests for modules not known to the registry .",
    "dynamical loading using this fall - back mechanism is currently under development .",
    "modules themselves are not instrumented with a means to place requirements on versions of other modules or on module execution order ; instead , the configuration machinery described in section  [ sec : configuration ] is used to set such requirements .    for most applications , run - time control over module sequences",
    "is afforded through a _",
    "run controller _ which invokes the various processing steps within the modules according to a set of externally provided instructions .",
    "we have constructed a simple xml - based  @xcite language for specifying these sequencing instructions .",
    "the decision to employ xml for this task was based on several considerations .",
    "firstly , sequencing via interpreted xml files allows one to set up or modify the behavior of a run without compiling , and so offers the convenience of an interpreted language .",
    "in addition , xml syntax is simple and relatively familiar to the community , and hence imposes a minimal learning curve compared to most scripting languages .",
    "furthermore , xml sequencing instructions can be straightforwardly logged using the same mechanisms employed for other types of configuration logging , as described in some detail in section  [ sec : configuration ] .",
    "finally , xml proves sufficient to support our commonest applications , which do not require especially intricate sequencing control .",
    "in fact the majority of applications require only two fundamental instructions .",
    "first , a ` module ` element instructs the run controller to invoke the processing method of the module whose name appears between the begin and end tags .",
    "second , a ` loop ` tag is used to command looping over modules , including arbitrarily deep loop nests .",
    "this tag may be decorated with attributes indicating the number of times to loop , and whether or not the contents of the event should be pushed onto a stack before the modules contained in the loop begin acting upon it .",
    "it is appropriate to push the event to a stack if , for example , one wishes to repeat a random process starting from the same input . on the other hand",
    ", one would disable the push to stack in order to implement an iterative procedure distributed over several modules .",
    "[ f : xml ] shows a simple example of the structure of a sequencing file .    ....",
    "< sequencefile >        < loop numtimes=\"unbounded \" >          < module > simulatedshowerreader < /module >          < loop numtimes=\"10 \" pushtostack=\"yes \" >             < module > eventgenerator      < /module",
    ">             < module > tanksimulator       < /module >             < module > triggersimulator    < /module >             < module > eventexporter",
    "< /module >          < /loop",
    ">        < /loop",
    ">     < /sequencefile > ....    modules can signal the run controller via return codes of the ` init ` , ` run ` and ` finish ` methods , and command it to break a loop or to skip all subsequent modules up to the next loop tag .",
    "parameters , cuts and configuration instructions used by modules or by the framework itself are stored in xml files .",
    "a globally accessible _ central configurator _ points modules and framework components to the location of their configuration data , and creates parsers to assist in reading information from these locations .",
    "the locations of configuration data are specified in a so - called _ bootstrap _ file , and may comprise local filenames , uris  @xcite or xpath  @xcite addresses .",
    "the name of the bootstrap file is passed to the application at run time via the command line .",
    "the configuration mechanism can also concatenate all configuration data accessed during a run and write it in a log file .",
    "this log file includes a preamble with a format identical to that of a bootstrap file , with xpath addresses specifying the locations of all the configuration data in the file . in this way",
    ", a log file can subsequently be read , as though it were a bootstrap file , in order to reproduce a run with an identical configuration .",
    "this configuration logging mechanism may also be used to record the versions of modules and external libraries which are used during a run .",
    "external package versions are determined at build time by our gnu autotools - based build machinery  @xcite , which searches the local system for required packages and verifies that versions of different packages are compatible with one another .",
    "the build system generates a script which can later be interrogated by the logging mechanism to record package versions employed for a particular run .",
    "module versions are declared in the code by module authors , and are accessible to the configuration logging mechanism through the module interface .    to check configuration files for errors ,",
    "the w3c xml schema  @xcite standard validation is employed throughout .",
    "this approach is used not only to validate internal framework configuration , but also to check configuration files of modules prepared by framework users .",
    "this has proved to be successful in saving coding time for developers and users alike , and facilitates much more detailed error checking than most users are likely to implement on their own .",
    "further details on how configuration files are parsed and validated are given in section  [ sec : parsing ] .",
    "the configuration machinery is also able to verify configuration file contents against a set of default files by employing md5 digests  @xcite .",
    "the default configuration files are prepared by the framework developers and the analysis teams , and reference digests are computed from these files at build time . at run time , the digest for each configuration file is recomputed and compared to the reference value .",
    "depending on run - time options , discrepant digests can either force program termination , or can simply log a warning .",
    "this machinery provides a means for those managing data analyses to quickly verify that configurations in use are the ones which have been recommended for the task at hand .",
    "the offline framework provides two parallel hierarchies for accessing data : the _ event _ for reading and writing information that changes per event , and the read - only _ detector description _ for retrieving static or relatively slowly varying information such as detector geometry , calibration constants , and atmospheric conditions .",
    "the _ event _ data model contains all raw , calibrated , reconstructed and monte carlo data and acts as the principal backbone for communication between modules .",
    "the overall structure comprises a collection of classes organized following the hierarchy normally associated with the observatory instruments , with further subdivisions for accessing such information as monte carlo truth , reconstructed quantities , calibration information and raw data . a non - exhaustive illustration of this hierarchy is given in fig .",
    "[ f : event ] .",
    "user modules access the event through a reference to the top of the hierarchy which is passed to the module interface by the run controller .",
    "since the event constitutes the inter - module communication backbone , reference semantics are used throughout to access data structures in the event , and constructors are kept private to prevent accidental copying of event components . for example , to retrieve the object representing the first photomultiplier tube ( pmt ) object of station number 157 belonging to the surface detector ( s ) portion of the event , one could write simply ,    .... pmt & pmt1 = theevent.getsevent().getstation(157).getpmt(1 ) ; ....    where ` theevent ` is a reference to the top of the event hierarchy .    the event is built up dynamically as needed , and is instrumented with a simple protocol allowing modules to interrogate the event at any point to discover its current constituents .",
    "this protocol provides the means for a given module to determine whether the input data required to carry out the desired processing is available . as an example , consider the case of the monte carlo truth belonging to a pmt object called ` thepmt ` . attempting to access a non - existent subcomponent ` thepmt ` raises an exception :    .... pmt & idontexistyet = thepmt.getsimdata();// exception ....    checking for the existence of the desired data , creating an event subcomponent , and retrieveing a handle to the data therein would be carried out as follows :    .... if ( ! thepmt.hassimdata ( ) )                 //",
    "check for simdata    thepmt.makesimdata ( ) ;                   //",
    "create simdata pmt & thepmtsim = thepmt.getsimdata ( ) ;     // success ....    the structure of the event interface can not be modified by modules .",
    "while this restriction limits the flexibility available to module authors , it does facilitate straightforward module interchangeability , which , as discussed in section  [ sec : examples ] , is of primary importance in our case . in practice ,",
    "when users find the event structure does not accommodate their needs , they may implement ad hoc inter - module communication as temporary solution , and propose the required event interface changes to the framework developers .",
    "though this approach does require periodic developer intervention , it has not proved to be overly problematic for our project .",
    "it is worth noting that the use of an event data model as an algorithm communication backbone is not an uncommon approach , and is employed by other high energy physics and astrophysics experiments  @xcite . in our case",
    ", however , the data access methods are somewhat less generalized than the techniques employed by larger experiments ( see for example @xcite ) .",
    "our feeling is that the cost incurred in terms of flexibility is reasonably offset by user - side simplicity .    the event representation in memory , or transient event ,",
    "is decoupled from the representation on file , or persistent event .",
    "when a request is made to write event contents to file , the data are transferred from the transient event through a so - called file interface to the persistent event , which is instrumented with machinery for serialization .",
    "conversely , when data are requested from file , a file interface transfers the data from the persistent event to the appropriate part of the event interface .",
    "users can transfer all or part of the event from memory to a file at any stage in the processing , and reload the event and continue processing from that point onward .",
    "various file formats are handled using the file interface mechanism , including raw event and monitoring formats as well as the different formats employed by the aires  @xcite , corsika  @xcite , conex  @xcite and seneca  @xcite air shower simulation packages .",
    "[ f : eventbackend ] contains a diagram of this event input / output mechanism .",
    "event serialization is implemented using the root  @xcite toolkit , though the decoupling of the transient and persistent events is intended to allow for relatively straightforward changes of serialization machinery if this should ever prove to be advantageous .",
    "when it becomes necessary to modify the event structure , backward compatibility is provided via the root schema evolution mechanism .",
    "we note that similar strategies for event persistency and schema evolution have been adopted by other large experiments  @xcite .    .",
    "data are transferred between this transient event and persistent objects through a common file interface .",
    "different file implementations are able to read and/or write in different formats , including those used by the data acquisition systems ( ` das ` formats ) , formats used by other simulation packages , as well as a `` native '' format ( ` rooteventfile ` ) which accommodates all raw data , reconstructed quantities , and monte carlo truth .",
    ", width=345 ]      the _ detector description _ provides a unified interface from which module authors can retrieve non - event data including the detector configuration and performance at a particular time as well as atmospheric conditions . like the event interface",
    ", the detector interface is organized following the hierarchy normally associated with the observatory instruments , and provides a set of simple - to - use access functions to extract data .",
    "data requests are passed by this interface to a registry of so - called _ managers _ , each of which is capable of extracting a particular sort of information from a particular data source .",
    "data retrieved from a manager are cached in the interface for future use . in this approach ,",
    "the user deals with a single interface even though the data sought may reside in any number of different sources .",
    "generally we choose to store static detector information in xml files , and time - varying monitoring and calibration data in mysql  @xcite databases .",
    "however , as the project evolves it sometimes happens that access to detector data in some other format is required , perhaps as a stop - gap measure .",
    "the manager mechanism allows one to quickly provide simple interfaces in such cases , keeping the complexity of accessing multiple formats hidden from the user .",
    "the structure of the detector description machinery is illustrated in fig .",
    "[ f : detector ] .",
    "note that it is possible to implement more than one manager for a particular sort of data . in this way",
    ", a special manager can override data from a general manager .",
    "for example , a user can decide to use a database for the majority of the description of the detector , but override some data by writing them in an xml file which is interpreted by the special manager .",
    "the specification of which data sources are accessed by the manager registry and in what order they are queried is detailed in a configuration file .",
    "the configuration of the manager registry is transparent to the user code .",
    "the detector description is also equipped to support a set of plug - in functions , called _ models _ which can be used for additional processing of data retrieved through the detector interface .",
    "these are used primarily to interpret atmospheric monitoring data . as an example",
    ", users can invoke a model designed to evaluate attenuation of light due to aerosols between two points in the atmosphere .",
    "this model interrogates the detector interface to find the atmospheric conditions at the specified time , and computes the attenuation .",
    "models can also be placed under command of a _ super - model _ which can attempt various methods of computing the desired result , depending on what data are available for the specified time .",
    "the manager mechanism has also proved convenient for generating detector data for use by specialized monte carlo simulations .",
    "for instance , when studying reconstruction techniques , it is sometimes useful to include hypothetical surface detector stations in a simulation run , where the positions of the hypothetical stations are defined in the reference frame of the shower being simulated .",
    "a manager has been prepared which uses the simulated shower geometry to project a user - defined collection of hypothetical stations onto the ground , overlaying them on the actual station positions .",
    "both sorts of station information are accessible transparently via the same interface .",
    "the offline framework is built on a collection of utilities , including an xml parser , an error logger , various mathematics and physics services including a novel geometry package , testing utilities and a set of foundation classes to represent objects such as signal traces , tabulated functions and particles . in this section ,",
    "we describe the parsing and geometry packages in more detail .",
    "as noted previously , xml is employed to store configuration data for framework components and user contributed modules .",
    "our xml reading utility , named simply _ reader _ , is built upon the xerces  @xcite validating parser , and is designed to provide ease - of - use at the expense of somewhat reduced flexibility compared to the xerces apis .",
    "the reader utility also provides additional features such as units handling for dimensional quantities , expression evaluation , and casting of data in xml files to atomic types , standard template library  @xcite containers , and data types specific to the auger observatory software .",
    "navigation through hierarchical data is supported by a handful of methods for locating children and siblings of a given xml element .",
    "data casting is provided through overloaded access functions .",
    "for instance , a configuration file can contain a dimensional quantity with units specified by an expression in the tag attribute :    .... < g unit=\"meter / second^2 \" > 9.8 <",
    "/g > ....    upon request , the reader casts the data between the ` < g > ` tags to the data type used in the access function , evaluates the ` meter / second^2 ` expression in the attribute , and then uses the result to convert the ` 9.8 ` into pre - defined internal units .",
    "validation rules are specified using the xml schema standard  @xcite , which is well supported by xerces and which has proved to be more palatable to our user base than the older dtd  @xcite standard .",
    "the built - in schema types have been extended with a collection of data types commonly used by the collaboration , including lists , three - vectors , and tabulated functions as well quantities which require an associated unit .",
    "for example , the line of xml shown above can be validated using the schema fragment ,    .... < xs : element name=\"g \" type=\"auger : doublewithunit\"/ > ....    where the prefix ` xs ` denotes the standard schema namespace , and the ` auger ` prefix indicates the namespace containing our extensions of the standard types . here",
    "the ` doublewithunit ` type specification guarantees that exactly one double precision number appears in the element , and that a ` unit ` attribute is present in the corresponding tag .",
    "one can build up rather involved types in a straightforward manner .",
    "for instance , it is useful to have the ability to define functions using either tabulated values :    .... < energydistribution >     < x unit=\"mev \" > 100 330 1000 < /x",
    "y > 1 0.95 0.5 < /y",
    "/energydistribution > ....    or using a parametrization with limits :    .... < energydistribution >     < pdf > 1/x < /pdf",
    ">    < min unit=\"mev \" > 100 < /min >    < max unit=\"gev \"",
    "> < /energydistribution > ....    the corresponding schema rules require the ` < energydistribution > ` to be specified by a group of xml elements :    .... < xs : element name=\"energydistribution \" >    < xs : complextype >      < xs : group ref=\"distributionfunction\"/ >    < /xs : complextype > < /xs : element > ....    where this group in turn is defined as a choice between two sequences of xml elements dictating the two ways to specify the distribution function mentioned above :    .... < xs : group name=\"distributionfunction \" >",
    "< xs : choice >      < xs : sequence >        < xs : element name=\"x \" type=\"auger : listofdoubleswithunits\"/ >        < xs : element name=\"y \"   type=\"auger : listofdoubles\"/ >",
    "< /xs : sequence >      < xs : sequence >        < xs : element name=\"pdf \" type=\"xs : string\"/ >        < xs : element name=\"min \" type=\"auger : doublewithunit\"/ >",
    "< xs : element name=\"max \" type=\"auger : doublewithunit\"/ >      < /xs : sequence >    < /xs : choice > < /xs : group > ....    the combination of xml and xml schema validation enables us to support quite detailed configurations and robust checking , both in the internal framework configuration and in user - provided physics modules . to give a specific example",
    ", we consider the case of a so - called `` particle injector '' module which is used to randomly draw particles from various distributions and pass them to downstream detector response simulation modules . in configuring this module",
    "we wish to support a number of options in different combinations , including : placing particles at specific locations relative to a detector , or distributing them over cylindrical or spherical surfaces around the detector ; selecting different particle types with differing probabilities ; setting discrete energies or drawing energies from a distribution ; setting discrete zenith and azimuthal angles or drawing them from distributions ; and describing distributions either analytically through an expression , or using a tabulated function .",
    "the hierarchical model employed by xml allows one to notate all these options in a human - readable form .",
    "further , xml schema validation facilitates detailed policing of the corresponding configuration file , so that for instance one can require a distribution to be described _ either _ analytically _ or _ in tabular form , as outlined in the example above .",
    "note that the general effectiveness of xml and xml schema in software for large experiments has been noted by other authors  @xcite .      as discussed previously ,",
    "the pierre auger observatory comprises many instruments spread over a large area and , in the case of the fluorescence telescopes , oriented in different directions .",
    "consequently there is no naturally preferred coordinate system for the observatory ; indeed each detector component has its own natural system , as do components of the event such as the air shower itself .",
    "furthermore , since the detector spans more than 50  km from side to side , the curvature of the earth can not generally be neglected .",
    "in such a circumstance , keeping track of all the required transformations when performing geometrical computations is tedious and error prone .",
    "this problem is alleviated in the offline geometry package by providing abstract geometrical objects such as points and vectors .",
    "operations on these objects can then be written in an abstract way , independent of any particular coordinate system .",
    "internally , the objects store components and track the coordinate system used . there is no need for pre - defined coordinate system conventions , or coordinate system conversions at module boundaries .",
    "the transformation of the internal representation occurs automatically .    despite the lack of a single natural coordinate system for the observatory ,",
    "there are several important coordinate systems available .",
    "a registry mechanism provides access to a selection of global coordinate systems .",
    "coordinate systems related to a particular component of the detector , like a telescope , or systems which depend on the event being processed , such as a shower coordinate system , are available through access functions belonging to the relevant classes of the detector or event structures .",
    "coordinate systems are defined relative to other coordinate systems .",
    "ultimately , a single root coordinate system is required .",
    "it must be fixed by convention , and in our case we choose an origin at the center of the earth .",
    "other base coordinate systems and a caching mechanism help to avoid the construction of potentially long chains of transformations when going from one coordinate system to another .",
    "the following is a simple example of how the geometry and units packages are used together :    .... point pos(x*km , y*km , z*km , poscoordsys ) ; vector dist(deltax , deltay , deltaz , othercoordsys ) ;    point newpos = pos + dist ; cout < < \" x = \" < < newpos.getx(outcoordsys)/m < < \" meters \" ; ....    the variables ` x ` , ` y ` , and ` z ` are provided by some external source , in the units indicated ( km ) , whereas ` deltax ` , ` deltay ` , and ` deltaz ` are results from a previous calculation , already in the internal units .",
    "coordinate systems are required whenever components are used explicitly .",
    "units are used on input and output of data and when exchanging information with external packages .",
    "the surveying of the detector utilizes universal transverse mercator ( utm ) coordinates with the wgs84 ellipsoid .",
    "these coordinates are convenient for navigation .",
    "they involve , however , a non - linear , conformal transformation .",
    "the geometry package provides a ` utmpoint ` class for dealing with positions given in utm , in particular for the conversion to and from cartesian coordinates .",
    "this class also handles the geodetic conventions , which define the latitude based on the local vertical ( see fig .",
    "[ fig : geodesy ] ) , as opposed to the angle @xmath2 , where @xmath3 is the usual zenith angle in spherical coordinates .",
    "is defined as the angle between the local vertical and a plane parallel to the equatorial plane .",
    "for an elliptical shape , it is not just the complement of the zenith angle @xmath3 in the definition of spherical coordinates .",
    "]    the high degree of abstraction makes use of the geometry package quite easy .",
    "uncontrolled , repeated coordinate transformations , though , can be a problem both for execution speed and for numerical precision . to control this behavior , it is possible to force the internal representation of an object to use a particular coordinate system .",
    "the geometry package guarantees that no transformations take place in operation where all objects are represented in the same coordinate system .",
    "this provides a handle for experts to control when transformations take place .",
    "to help ensure code maintainability and stability in the face of a large number of contributors and a decades - long experimental run , unit and acceptance testing are integrated into the offline framework build and distribution system .",
    "this sort of quality assurance mechanism is crucial for any software which must continue to develop over a timescale of many years .",
    "our build system is based on the gnu autotools  @xcite , which provide hooks for integrating tests with the build and distribution system .",
    "a substantial collection of unit tests has been developed , each of which is designed to comprehensively exercise a single framework component .",
    "we have employed the cppunit  @xcite testing framework as an aid in implementing these unit tests .",
    "in addition to such low - level tests , a collection of higher - level acceptance tests has been developed which is used to verify that complete applications continue to function properly during ongoing development .",
    "such acceptance tests typically run full physics applications before and after each code change and notify developers in case of any unexpected differences in results .    as a distributed cross - platform project , the auger offline software must be regularly compiled and checked on numerous platforms . to automate this process ,",
    "we have employed the tools provided by the buildbot project  @xcite .",
    "the buildbot is a python - based system in which a master daemon is informed each time the code repository has been significantly altered .",
    "the master then triggers a collection of build slaves running on various platforms to download the latest code , build it , run the unit and acceptance tests , and inform the appropriate developers in case problems are detected .",
    "this has proved to be a very effective system , and provides rapid feedback to developers in case of problems .",
    "the choice of external packages upon which to build the offline framework was dictated not only by package features and the requirement of being open - source , but also by our best assessment of prospects for longevity . at the same time",
    ", we attempted to avoid locking the design to any single - provider solution . to help achieve this , the functionality of external libraries is often provided to the client code through wrappers or faades , as in the case of xml parsing described in sections  [ sec : config ] and  [ sec : parsing ] , or through a bridge , as in the case of the detector description described in section  [ sec : detector ] .",
    "the collection of external libraries currently employed includes root  @xcite for serialization , xerces  @xcite for xml parsing and validation , clhep  @xcite for expression evaluation and geometry foundations , boost  @xcite for its many valuable c++ extensions , and optionally geant4  @xcite for detailed detector simulations .",
    "in this section we demonstrate the application of the offline software to typical simulation and reconstruction user tasks .",
    "we consider specifically the case of _ hybrid _ simulation and reconstruction , which involves combining the sequences for surface and fluorescence detector simulation and reconstruction . the discussion is meant to illustrate some of the advantages of modularization at the level of algorithms , as well as the simple xml - based sequencing control .",
    "simulation of events observed by the hybrid detector typically involves creation of a shower using a monte carlo generator  @xcite , the simulation of the response and triggering of the surface array to the particles arriving at the ground , and the simulation of the telescope response and triggering to the profile of fluorescence light emitted along the shower track .",
    "finally , event building and export to various data formats can be performed .",
    "detector simulations can be broken down into a sequence of steps , each of which is generally encapsulated within a separate module .",
    "for example , simulation of the surface detector typically begins with a module which places the simulated shower impact point somewhere within the surface array configuration .",
    "this is followed by a module which uses this information to determine which particles enter into which water tanks .",
    "subsequent modules then simulate the particle energy loss and cherenkov light emission in each tank , the response of the phototubes and tank electronics , and the local tank trigger .",
    "a final module simulates the response of the central trigger , which considers information from multiple detector components when determining whether to record the event .",
    "simulation of a fluorescence event involves modules for placing the simulated shower at some distance from one of the eyes , simulating the fluorescence and cherenkov light emitted by the shower as it develops , and finally simulating the response of the fluorescence telescopes , electronics and triggering . in fig .",
    "[ f : hsim ] we show a typical module sequence for hybrid detector simulation .",
    "each element designates an individual simulation step .    ....",
    "< sequencefile >       < ! -- loop over all monte carlo showers on file -- >     < loop numtimes=\"unbounded \" >       < ! -- read in a monte carlo shower -- >     < module > eventfilereader < /module",
    ">          < ! -- use each shower 10 times -- >        < loop numtimes=\"10 \" pushtostack=\"yes \" >             < ! -- position the shower in random spot on simulated array -- >          < module > eventgenerator            < /module >            < ! -- simulate the surface detector response -- >          < module > showerregenerator          < /module >          < module > g4tanksimulator            < /module >          < module > phototubesimulator         <",
    "/module >          < module > sdelectronicssimulator     <",
    "/module >",
    "< module > tanktriggersimulator       < /module >            < ! -- simulate the fluorescence detector response -- >          < module > showerlightsimulator       < /module >",
    "< module > lightatdiaphragmsimulator < /module",
    ">          < module > telescopesimulator         <",
    "/module >          < module > fdbackgroundsimulator      < /module >          < module > fdelectronicssimulator     < /module >",
    "< module > fdtriggersimulator         < /module >            < ! -- simulate the trigger , build and export event -- >          < module > centraltriggersimulator    < /module",
    ">          < module > eventfileexporter          < /module",
    ">               < /loop",
    ">     < /loop",
    "< /sequencefile > ....    the essential elements for the surface and fluorescence detector simulation are contained within the innermost loop of the module sequence , while the outer loop allows for processing of all monte carlo events in a file or collection of files .",
    "the surface detector simulation up to the tank triggering step is done first , then the fluorescence simulation up to the local eye triggering is performed .",
    "the central triggering , event building and exporting are performed last .",
    "it does not matter whether surface detector or fluorescence detector simulation is performed first , though both must be completed before the central triggering and event building steps occur .",
    "modularization allows one to easily substitute alternative algorithms to perform a particular step of the simulation sequence .",
    "for instance , the detailed tank response simulation can be replaced with a simplified , fast simulation by simply replacing the relevant element .",
    "such modularization of algorithms also allows collaborators to propose different approaches to a particular aspect of the simulation process , and to compare results running under identical conditions .",
    "the hybrid event reconstruction module sequence is indicated in fig .  [",
    "f : hrec ] .",
    "this sequence begins with calibration of the fluorescence and surface detectors , a procedure which transforms real or simulated raw data into physical quantities .",
    "afterwards a so - called pulse finding algorithm is used to further process the traces recorded by the fluorescence telescopes .",
    "next , a series of geometrical reconstruction modules are employed . first the plane containing the shower axis and the eye which detected it is determined . a complete geometrical fit within this plane",
    "is performed , taking into account both the timing of the shower image as it traverses the telescope pixels as well as the timing and impact point on the surface detectors .",
    "a calculation of the light flux reaching the telescope aperture is then carried out .",
    "the last step is the profile reconstruction , which converts the fluorescence light profile recorded by the telescopes to a determination of the energy deposit at a given atmospheric depth along the shower axis .",
    "the outcome of these steps is depicted in fig .",
    "[ f : reconstruction ] .",
    "< module > fdcalibrator            < /module",
    ">         < module > sdcalibrator            < /module >             < module > fdpulsefinder           < /module >           < module > fdsdpfinder             < /module >         < module > hybridgeometryfinder    < /module >          < module > fdaperturelight         <",
    "/module >                 < module > fdprofilereconstructor < /module",
    ">                 ... ....",
    "while the framework described in this note is actively used for analysis , there are a few substantial enhancements in preparation .",
    "first , we are developing an interactive visualization package which is fully integrated into the framework and which will provide not only graphical display of reconstructed event properties and monte carlo truth , but also interactive control over configuration and reconstruction procedures .",
    "this package will complement existing visualization tools which we use to browse processed events .",
    "second , python  @xcite bindings for the framework are in preparation .",
    "once complete , all of the framework public interfaces will be exposed via python , allowing users to prepare rapid prototypes of analysis and visualization tasks .",
    "python - based module sequencing will also be supported , allowing more intricate run control than is currently afforded through our xml - base sequencing system for cases when this may be desired .",
    "although these bindings will provide convenience for testing ideas and developing algorithms , the existing module sequencing system and xml - based run control will continue to be used for production runs , particularly as the logging features of this machinery is desirable for batch processing .",
    "third , the user module system described in section  [ sec : config ] is being upgraded to support dynamical loading of modules .",
    "this will allow for easier use of modules with the interactive visualization system mentioned above , and support easier module distribution and shorter development cycles .",
    "finally , the event persistency machinery discussed in section  [ sec : event ] is undergoing revision .",
    "though the approach we have implemented has been successful in decoupling the in - memory event from the representation on disk , the design does impose a maintenance burden since any modification of the structure must be implemented both in the transient and persistent events . for the future",
    "we envisage a system employing a meta - description of the event which will be used to automatically generate the transient and persistent events as well as the python bindings mentioned above .",
    "we have implemented a software framework for analysis of data gathered by the pierre auger observatory .",
    "this software provides machinery to facilitate collaborative development of algorithms to address various analysis tasks as well as tools to assist in the configuration and bookkeeping needed for production runs of simulated and real data .",
    "the framework is sufficiently configurable to adapt to a diverse set of applications , while the user side remains simple enough for c++ non - experts to learn in a reasonable time .",
    "the modular design allows straightforward swapping of algorithms for quick comparisons of different approaches to a problem .",
    "the interfaces to detector and event information free the users from having to deal individually with multiple data formats and data sources .",
    "this software , while still undergoing vigorous development and improvement , has been used in production of the first physics results from the observatory .",
    "the authors would like to thank the various funding agencies which made this work possible , as well as the fearless early adopters of the offline framework .",
    "j. abraham _",
    "[ pierre auger collaboration ] , `` properties and performance of the prototype instrument for the pierre auger observatory , '' nucl .",
    "instrum . meth .",
    "a * 523 * , 50 ( 2004 ) .",
    "s. argir _",
    "[ pierre auger collaboration ] , `` the offline software framework of the pierre auger observatory , '' fermilab - conf-05 - 311-e - td _ presented at 29th international cosmic ray conference ( icrc 2005 ) , pune , india , 3 - 11 aug 2005 . _ ; elliotte rusty harold , w. scott means , `` xml in a nutshell '' , oreilly , 2004 , isbn : 0 - 596 - 00764 - 7 .      ; + http://www.gnu.org/software/automake ; + http://www.gnu.org/software/libtool ; gary v. vaughn , ben ellison , tom tromey , ian lance taylorm `` gnu autoconf , automake , and libtool '' sams , 2000 , isbn 1 - 57870 - 190 - 2 .",
    "j. kowalkowski , h. greenlee , q. li , s. protopopescu , g. watts , v. white , j. yu , `` d0 offline reconstruction and analysis control framework '' , international conference on computing in high - energy physics and nuclear physics ( chep 2000 ) , padova , italy , 7 - 11 feb 2000 .",
    "+ http://chep2000.pd.infn.it/.    c.d .",
    "jones , m. paterno , j. kowalkowski , l. sexton - kennedy , w. tanenbaum , `` the new cms event data model and framework '' , international conference on computing in high - energy physics and nuclear physics ( chep2006 ) , mumbai , india , 13 - 17 feb 2006 . ; + c.d .",
    "jones , `` access to non - event data for cms '' , _ ibid _ ; + see also ` http://cmsdoc.cern.ch/cms/cpt/software/html/general/ ` .",
    "t. deyoung , `` icetray : a software framework for icecube '' , international conference on computing in high - energy physics and nuclear physics ( chep2004 ) , interlaken , switzerland , 27 september - 1 october 2004 .",
    "+ http://www.chep2004.org .",
    "e. moyse , f. akesson , `` event data model in atlas '' , international conference on computing in high - energy physics and nuclear physics ( chep2006 ) , mumbai , india , 13 - 17 feb 2006 .",
    "+ http://www.tifr.res.in/  chep06/."
  ],
  "abstract_text": [
    "<S> the pierre auger observatory is designed to unveil the nature and the origins of the highest energy cosmic rays . </S>",
    "<S> the large and geographically dispersed collaboration of physicists and the wide - ranging collection of simulation and reconstruction tasks pose some special challenges for the offline analysis software . </S>",
    "<S> we have designed and implemented a general purpose framework which allows collaborators to contribute algorithms and sequencing instructions to build up the variety of applications they require . </S>",
    "<S> the framework includes machinery to manage these user codes , to organize the abundance of user - contributed configuration files , to facilitate multi - format file handling , and to provide access to event and time - dependent detector information which can reside in various data sources . </S>",
    "<S> a number of utilities are also provided , including a novel geometry package which allows manipulation of abstract geometrical objects independent of coordinate system choice . </S>",
    "<S> the framework is implemented in c++ , and takes advantage of object oriented design and common open source tools , while keeping the user side simple enough for c++ novices to learn in a reasonable time . </S>",
    "<S> the distribution system incorporates unit and acceptance testing in order to support rapid development of both the core framework and contributed user code .    ,    ,    ,    ,    ,    ,    ,    ,    , and    offline software , framework , object oriented , simulation , cosmic rays    07.05.bx , 07.05.kf , 07.05.tp , 29.85.+c </S>"
  ]
}